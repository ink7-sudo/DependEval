[
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ViewAnimator;\n\nimport com.philliphsu.bottomsheetpickers.R;\n\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.DAY_PICKER_INDEX;\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.MONTH_PICKER_INDEX;\n\n\npublic final class DayPickerViewAnimator extends ViewAnimator {\n\n    private final Animation mDayPickerInAnimation;\n    private final Animation mDayPickerOutAnimation;\n    private final Animation mMonthPickerInAnimation;\n    private final Animation mMonthPickerOutAnimation;\n\n    public DayPickerViewAnimator(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mDayPickerInAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_day_picker_slide_up);\n        mDayPickerOutAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_day_picker_slide_down);\n        mMonthPickerInAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_month_picker_slide_down);\n        mMonthPickerOutAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_month_picker_slide_up);\n    }\n\n    @Override\n    public void setDisplayedChild(int whichChild) {\n        switch (whichChild) {\n            case DAY_PICKER_INDEX:\n                setInAnimation(mDayPickerInAnimation);\n                setOutAnimation(mMonthPickerOutAnimation);\n                break;\n            case MONTH_PICKER_INDEX:\n                setInAnimation(mMonthPickerInAnimation);\n                setOutAnimation(mDayPickerOutAnimation);\n                break;\n        }\n        super.setDisplayedChild(whichChild);\n    }\n\n    final void setDisplayedChild(int whichChild, boolean animate) {\n        if (animate) {\n            setDisplayedChild(whichChild);\n        } else {\n            setInAnimation(null);\n            setOutAnimation(null);\n            super.setDisplayedChild(whichChild);\n        }\n    }\n}\n\n'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.text.format.DateUtils;\n\nimport java.util.Calendar;\nimport java.util.Formatter;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\n\nfinal class DateFormatHelper {\n\n    private static final StringBuilder STRINGBUILDER = new StringBuilder(50);\n    private static final Formatter FORMATTER = new Formatter(STRINGBUILDER, Locale.getDefault());\n\n    static String formatDate(final Calendar calendar, final int flags) {\n        return formatDate(calendar.getTimeInMillis(), flags);\n    }\n\n    static String formatDate(final long millis, final int flags) {\n        STRINGBUILDER.setLength(0);\n\n        return DateUtils.formatDateRange(null, FORMATTER, millis, millis, flags,\n                TimeZone.getDefault().getID()).toString();\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'"
        ]
    },
    {
        "files": [
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/multiple/MultipleContractContentTest.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/multiple/MultipleContractContentProvider.java'",
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'"
        ],
        "content": "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/multiple/MultipleContractContentTest.java'\n:package com.tjeannin.provigen.test.multiple;\n\nimport android.test.mock.MockContentResolver;\nimport com.tjeannin.provigen.test.ExtendedProviderTestCase;\nimport com.tjeannin.provigen.test.multiple.MultipleContractContentProvider.ContractOne;\nimport com.tjeannin.provigen.test.multiple.MultipleContractContentProvider.ContractTwo;\n\npublic class MultipleContractContentTest extends ExtendedProviderTestCase<MultipleContractContentProvider> {\n\n    private MockContentResolver contentResolver;\n\n    public MultipleContractContentTest() {\n        super(MultipleContractContentProvider.class, \"com.test.simple\");\n    }\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        contentResolver = getMockContentResolver();\n    }\n\n    public void testMultipleContractInsertDontOverlap() {\n\n\n        assertEquals(0, getRowCount(ContractOne.CONTENT_URI));\n        assertEquals(0, getRowCount(ContractTwo.CONTENT_URI));\n\n        contentResolver.insert(ContractTwo.CONTENT_URI, getContentValues(ContractTwo.class));\n\n        assertEquals(0, getRowCount(ContractOne.CONTENT_URI));\n        assertEquals(1, getRowCount(ContractTwo.CONTENT_URI));\n\n        contentResolver.insert(ContractOne.CONTENT_URI, getContentValues(ContractOne.class));\n\n        assertEquals(1, getRowCount(ContractOne.CONTENT_URI));\n        assertEquals(1, getRowCount(ContractTwo.CONTENT_URI));\n    }\n\n    public void testAddingAnotherContractLater() {\n\n        contentResolver.insert(ContractOne.CONTENT_URI, getContentValues(ContractOne.class));\n        assertEquals(1, getRowCount(ContractOne.CONTENT_URI));\n\n        resetContractClasses(new Class[]{ContractTwo.class, ContractOne.class});\n        assertEquals(0, getRowCount(ContractTwo.CONTENT_URI));\n        assertEquals(1, getRowCount(ContractOne.CONTENT_URI));\n\n        contentResolver.insert(ContractTwo.CONTENT_URI, getContentValues(ContractTwo.class));\n        assertEquals(1, getRowCount(ContractTwo.CONTENT_URI));\n        assertEquals(1, getRowCount(ContractOne.CONTENT_URI));\n\n        contentResolver.insert(ContractOne.CONTENT_URI, getContentValues(ContractOne.class));\n        assertEquals(1, getRowCount(ContractTwo.CONTENT_URI));\n        assertEquals(2, getRowCount(ContractOne.CONTENT_URI));\n    }\n}\n",
        "gt": [
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/multiple/MultipleContractContentProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/multiple/MultipleContractContentTest.java'"
        ]
    },
    {
        "files": [
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'",
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictTest.java'"
        ],
        "content": "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'\n:package com.tjeannin.provigen.test.constraint;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport com.tjeannin.provigen.ProviGenBaseContract;\nimport com.tjeannin.provigen.ProviGenProvider;\nimport com.tjeannin.provigen.annotation.Column;\nimport com.tjeannin.provigen.annotation.Column.Type;\nimport com.tjeannin.provigen.annotation.ContentUri;\nimport com.tjeannin.provigen.helper.TableBuilder;\nimport com.tjeannin.provigen.model.Constraint;\nimport com.tjeannin.provigen.model.Constraint.OnConflict;\n\npublic class OnConflictProvider extends ProviGenProvider {\n\n    @Override\n    public SQLiteOpenHelper openHelper(Context context) {\n        return new SQLiteOpenHelper(context, \"ProviGenDatabase\", null, 1) {\n            @Override\n            public void onCreate(SQLiteDatabase database) {\n                new TableBuilder(ContractAbort.class)\n                        .addConstraint(ContractAbort.AN_INT, Constraint.UNIQUE, OnConflict.ABORT)\n                        .createTable(database);\n\n                new TableBuilder(ContractReplace.class)\n                        .addConstraint(ContractReplace.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n\n                new TableBuilder(ContractFail.class)\n                        .addConstraint(ContractFail.AN_INT, Constraint.UNIQUE, OnConflict.FAIL)\n                        .createTable(database);\n\n                new TableBuilder(ContractMultipleResolution.class)\n                        .addConstraint(ContractMultipleResolution.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .addConstraint(ContractMultipleResolution.ANOTHER_INT, Constraint.UNIQUE, OnConflict.ABORT)\n                        .createTable(database);\n\n            }\n\n            @Override\n            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n            }\n        };\n    }\n\n    @Override\n    public Class[] contractClasses() {\n        return new Class[]{ContractAbort.class, ContractReplace.class, ContractFail.class, ContractMultipleResolution.class};\n    }\n\n    public static interface ContractAbort extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractReplace extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractFail extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractMultipleResolution extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @Column(Type.INTEGER)\n        public static final String ANOTHER_INT = \"another_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n}\n",
        "gt": [
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictTest.java'"
        ]
    },
    {
        "files": [
            "'btrace/btrace-dist/src/main/resources/samples/SysProp.java'",
            "'btrace/btrace-services-api/src/main/java/org/openjdk/btrace/services/api/RuntimeContext.java'",
            "'btrace/btrace-core/src/main/java/org/openjdk/btrace/core/BTraceUtils.java'"
        ],
        "content": "'btrace/btrace-dist/src/main/resources/samples/SysProp.java'\n:\n\n\nimport org.openjdk.btrace.core.annotations.BTrace;\nimport org.openjdk.btrace.core.annotations.OnMethod;\n\nimport static org.openjdk.btrace.core.BTraceUtils.Sys;\nimport static org.openjdk.btrace.core.BTraceUtils.println;\n\n\n@BTrace\npublic class SysProp {\n    @OnMethod(\n            clazz = \"java.lang.System\",\n            method = \"getProperty\"\n    )\n    public static void onGetProperty(String name) {\n        println(name);\n\n        println(Sys.Env.property(name));\n    }\n}\n",
        "gt": [
            "'btrace/btrace-services-api/src/main/java/org/openjdk/btrace/services/api/RuntimeContext.java'",
            "'btrace/btrace-core/src/main/java/org/openjdk/btrace/core/BTraceUtils.java'",
            "'btrace/btrace-dist/src/main/resources/samples/SysProp.java'"
        ]
    },
    {
        "files": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'"
        ],
        "content": "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'\n:package io.advantageous.qbit.service.discovery;\n\nimport io.advantageous.qbit.reactive.Callback;\nimport io.advantageous.qbit.service.Startable;\nimport io.advantageous.qbit.service.Stoppable;\nimport io.advantageous.qbit.service.health.HealthStatus;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.*;\n\n\npublic interface ServiceDiscovery extends Startable, Stoppable {\n\n\n    static String uniqueString(int port) {\n        try {\n            return port + \"-\" + InetAddress.getLocalHost().getHostName().replace('.', '-');\n        } catch (UnknownHostException e) {\n            return port + \"-\" + UUID.randomUUID().toString();\n        }\n    }\n\n\n    default EndpointDefinition register(\n            final String serviceName,\n            final String host,\n            final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceName + \".\" + uniqueString(port),\n                serviceName, host, port);\n    }\n\n\n    default EndpointDefinition registerWithTTL(\n            final String serviceName,\n            final String host,\n            final int port,\n            final int timeToLiveSeconds) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceName + \".\" + uniqueString(port),\n                serviceName, host, port, timeToLiveSeconds);\n    }\n\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default EndpointDefinition registerWithIdAndTimeToLive(\n            final String serviceName, final String serviceId, String host, final int port, final int timeToLiveSeconds) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceId,\n                serviceName, host, port, timeToLiveSeconds);\n    }\n\n\n    default EndpointDefinition registerWithId(final String serviceName, final String serviceId, String host, final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceId,\n                serviceName, host, port);\n    }\n\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default EndpointDefinition registerWithIdAndTTLAndTags(String serviceName, String serviceId, String host, int port, int timeToLiveSeconds,\n                                                           List<String> endpointTags) {\n        return new EndpointDefinition(HealthStatus.PASS, serviceId, serviceName, host, port, timeToLiveSeconds, endpointTags);\n    }\n\n\n    default void watch(String serviceName) {\n    }\n\n\n    default void checkIn(String serviceId, HealthStatus healthStatus) {\n\n    }\n\n\n    default void checkInOk(String serviceId) {\n\n    }\n\n\n    default List<EndpointDefinition> loadServices(final String serviceName) {\n\n        return Collections.emptyList();\n    }\n\n\n    default void loadServicesAsync(Callback<List<EndpointDefinition>> callback, final String serviceName) {\n\n    }\n\n\n    default List<EndpointDefinition> loadServicesNow(final String serviceName) {\n\n        return Collections.emptyList();\n    }\n\n\n    default void start() {\n    }\n\n\n    default void stop() {\n    }\n\n\n    default Set<EndpointDefinition> localDefinitions() {\n        return Collections.emptySet();\n    }\n\n}\n",
        "gt": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'"
        ]
    },
    {
        "files": [
            "'material-calendar-view/materialcalendarview/src/main/java/io/blackbox_vision/materialcalendarview/internal/utils/ScreenUtils.java'",
            "'material-calendar-view/app/src/main/java/io/blackbox_vision/materialcalendarview/sample/view/MainActivity.java'",
            "'material-calendar-view/app/src/main/java/io/blackbox_vision/materialcalendarview/sample/utils/AnimationUtils.java'"
        ],
        "content": "'material-calendar-view/materialcalendarview/src/main/java/io/blackbox_vision/materialcalendarview/internal/utils/ScreenUtils.java'\n:package io.blackbox_vision.materialcalendarview.internal.utils;\n\nimport android.content.Context;\nimport android.support.annotation.NonNull;\nimport android.util.DisplayMetrics;\nimport android.view.WindowManager;\n\npublic final class ScreenUtils {\n\n    private ScreenUtils() { }\n\n    public static int getScreenHeight(@NonNull Context context) {\n        final DisplayMetrics metrics = new DisplayMetrics();\n        final WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);\n\n        wm.getDefaultDisplay().getMetrics(metrics);\n\n        return metrics.heightPixels;\n    }\n}\n\n'material-calendar-view/app/src/main/java/io/blackbox_vision/materialcalendarview/sample/view/MainActivity.java'\n:package io.blackbox_vision.materialcalendarview.sample.view;\n\nimport android.os.Bundle;\nimport android.support.annotation.NonNull;\nimport android.support.design.widget.FloatingActionButton;\nimport android.support.design.widget.NavigationView;\nimport android.support.v4.view.GravityCompat;\nimport android.support.v4.widget.DrawerLayout;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.ActionBarDrawerToggle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.view.MenuItem;\nimport android.widget.TextView;\n\nimport butterknife.BindView;\n\nimport butterknife.ButterKnife;\nimport io.blackbox_vision.materialcalendarview.sample.R;\nimport io.blackbox_vision.materialcalendarview.sample.logic.presenter.MainPresenter;\nimport io.blackbox_vision.materialcalendarview.sample.logic.presenter_view.MainView;\nimport io.blackbox_vision.materialcalendarview.view.CalendarView;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Locale;\n\n\nimport static io.blackbox_vision.materialcalendarview.sample.utils.AnimationUtils.animate;\n\n\npublic final class MainActivity extends AppCompatActivity implements MainView {\n    private static final String DATE_TEMPLATE = \"dd/MM/yyyy\";\n    private static final String MONTH_TEMPLATE = \"MMMM yyyy\";\n\n    private final MainPresenter presenter = new MainPresenter(this);\n\n    @BindView(R.id.textview)\n    TextView textView;\n\n    @BindView(R.id.drawer_layout)\n    DrawerLayout drawer;\n\n    @BindView(R.id.toolbar)\n    Toolbar toolbar;\n\n    @BindView(R.id.nav_view)\n    NavigationView navigationView;\n\n    @BindView(R.id.fab)\n    FloatingActionButton fab;\n\n    @BindView(R.id.calendar_view)\n    CalendarView calendarView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        ButterKnife.bind(this);\n\n        setSupportActionBar(toolbar);\n\n        presenter.addNavigationDrawer();\n        presenter.addCalendarView();\n        presenter.addTextView();\n        presenter.animate();\n    }\n\n    @Override\n    public void onBackPressed() {\n        if (drawer.isDrawerOpen(GravityCompat.START)) {\n            drawer.closeDrawer(GravityCompat.START);\n        } else {\n            super.onBackPressed();\n        }\n    }\n\n    public boolean onNavigationItemSelected(MenuItem item) {\n        drawer.closeDrawer(GravityCompat.START);\n        return true;\n    }\n\n    @Override\n    public void prepareTextView() {\n        textView.setText(String.format(\"Today is %s\", formatDate(DATE_TEMPLATE, new Date(System.currentTimeMillis()))));\n    }\n    @Override\n    public void prepareCalendarView() {\n        Calendar disabledCal = Calendar.getInstance();\n        disabledCal.set(Calendar.DATE, disabledCal.get(Calendar.DATE) - 1);\n\n        calendarView.setFirstDayOfWeek(Calendar.SUNDAY)\n                .setOnDateClickListener(this::onDateClick)\n                .setOnMonthChangeListener(this::onMonthChange)\n                .setOnDateLongClickListener(this::onDateLongClick)\n                .setOnMonthTitleClickListener(this::onMonthTitleClick);\n\n        if (calendarView.isMultiSelectDayEnabled()) {\n            calendarView.setOnMultipleDaySelectedListener((month, dates) -> {\n\n            });\n        }\n\n        calendarView.update(Calendar.getInstance(Locale.getDefault()));\n    }\n\n    @Override\n    public void prepareNavigationDrawer() {\n        final ActionBarDrawerToggle toggle = new ActionBarDrawerToggle(\n                this,\n                drawer,\n                toolbar,\n                R.string.navigation_drawer_open,\n                R.string.navigation_drawer_close\n        );\n\n        drawer.addDrawerListener(toggle);\n        toggle.syncState();\n\n        navigationView.setNavigationItemSelectedListener(this::onNavigationItemSelected);\n    }\n\n    @Override\n    public void animateViews() {\n        calendarView.shouldAnimateOnEnter(true);\n        animate(fab, getApplicationContext());\n        animate(textView, getApplicationContext());\n    }\n\n    private void onDateLongClick(@NonNull final Date date) {\n        textView.setText(formatDate(DATE_TEMPLATE, date));\n    }\n\n    private void onDateClick(@NonNull final Date date) {\n        textView.setText(formatDate(DATE_TEMPLATE, date));\n    }\n\n    private void onMonthTitleClick(@NonNull final Date date) {\n\n    }\n\n    private void onMonthChange(@NonNull final Date date) {\n        final ActionBar actionBar = getSupportActionBar();\n\n        if (null != actionBar) {\n            String dateStr = formatDate(MONTH_TEMPLATE, date);\n            dateStr = dateStr.substring(0, 1).toUpperCase() + dateStr.substring(1, dateStr.length());\n\n            actionBar.setTitle(dateStr);\n        }\n    }\n\n    private String formatDate(@NonNull String dateTemplate, @NonNull Date date) {\n        return new SimpleDateFormat(dateTemplate, Locale.getDefault()).format(date);\n    }\n}\n\n'material-calendar-view/app/src/main/java/io/blackbox_vision/materialcalendarview/sample/utils/AnimationUtils.java'\n:package io.blackbox_vision.materialcalendarview.sample.utils;\n\n\nimport android.content.Context;\nimport android.support.annotation.NonNull;\nimport android.support.v4.view.ViewCompat;\nimport android.view.View;\nimport android.view.animation.DecelerateInterpolator;\n\nimport static io.blackbox_vision.materialcalendarview.internal.utils.ScreenUtils.getScreenHeight;\n\npublic final class AnimationUtils {\n\n    private AnimationUtils() { }\n\n    public static void animate(@NonNull View v, @NonNull Context ctx) {\n        ViewCompat.setTranslationY(v, getScreenHeight(ctx));\n        ViewCompat.setAlpha(v, 0f);\n        ViewCompat.animate(v)\n                .translationY(0f)\n                .setDuration(1500)\n                .alpha(1f)\n                .setInterpolator(new DecelerateInterpolator(3.0f))\n                .start();\n    }\n}\n",
        "gt": [
            "'material-calendar-view/materialcalendarview/src/main/java/io/blackbox_vision/materialcalendarview/internal/utils/ScreenUtils.java'",
            "'material-calendar-view/app/src/main/java/io/blackbox_vision/materialcalendarview/sample/utils/AnimationUtils.java'",
            "'material-calendar-view/app/src/main/java/io/blackbox_vision/materialcalendarview/sample/view/MainActivity.java'"
        ]
    },
    {
        "files": [
            "'Vineyard/app/src/androidTest/java/com/hitherejoe/vineyard/util/CustomMatchers.java'",
            "'Vineyard/app/src/main/java/com/hitherejoe/vineyard/injection/ApplicationContext.java'",
            "'Vineyard/app/src/androidTest/java/com/hitherejoe/vineyard/MainActivityTest.java'"
        ],
        "content": "'Vineyard/app/src/androidTest/java/com/hitherejoe/vineyard/util/CustomMatchers.java'\n:package com.hitherejoe.vineyard.util;\n\nimport android.os.IBinder;\nimport android.support.test.espresso.Root;\nimport android.text.TextUtils;\nimport android.view.View;\nimport android.view.WindowManager;\n\nimport com.hitherejoe.vineyard.R;\n\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.TypeSafeMatcher;\n\nimport static android.support.test.espresso.core.deps.guava.base.Preconditions.checkArgument;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDescendantOfA;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.hamcrest.Matchers.allOf;\n\npublic class CustomMatchers {\n\n    public static Matcher<View> withItemText(final String itemText, final int parentId) {\n        checkArgument(!TextUtils.isEmpty(itemText), \"itemText cannot be null or empty\");\n        return new TypeSafeMatcher<View>() {\n            @Override\n            public boolean matchesSafely(View item) {\n                return allOf(isDescendantOfA(withId(parentId)),\n                        withText(itemText)).matches(item);\n            }\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"is isDescendantOfA RecyclerView with text \" + itemText);\n            }\n        };\n    }\n\n\n    public static Matcher<Root> isToast() {\n        return new TypeSafeMatcher<Root>() {\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"is toast\");\n            }\n\n            @Override\n            public boolean matchesSafely(Root root) {\n                int type = root.getWindowLayoutParams().get().type;\n                if ((type == WindowManager.LayoutParams.TYPE_TOAST)) {\n                    IBinder windowToken = root.getDecorView().getWindowToken();\n                    IBinder appToken = root.getDecorView().getApplicationWindowToken();\n                    if (windowToken == appToken) {\n\n\n                        return true;\n                    }\n                }\n                return false;\n            }\n        };\n    }\n\n}\n",
        "gt": [
            "'Vineyard/app/src/main/java/com/hitherejoe/vineyard/injection/ApplicationContext.java'",
            "'Vineyard/app/src/androidTest/java/com/hitherejoe/vineyard/util/CustomMatchers.java'",
            "'Vineyard/app/src/androidTest/java/com/hitherejoe/vineyard/MainActivityTest.java'"
        ]
    },
    {
        "files": [
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'"
        ],
        "content": "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'\n:package com.hitherejoe.bourboncorecommon.ui.shot;\n\nimport com.hitherejoe.bourboncorecommon.data.DataManager;\nimport com.hitherejoe.bourboncorecommon.data.model.Comment;\nimport com.hitherejoe.bourboncorecommon.util.RxSchedulersOverrideRule;\nimport com.hitherejoe.bourboncorecommon.util.TestDataFactory;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport rx.Single;\n\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ShotPresenterTest {\n\n    @Mock\n    ShotMvpView mMockShotMvpView;\n    @Mock\n    DataManager mMockDataManager;\n    private ShotPresenter mShotPresenter;\n\n    @Rule\n    public final RxSchedulersOverrideRule mOverrideSchedulersRule = new RxSchedulersOverrideRule();\n\n    @Before\n    public void setUp() {\n        mShotPresenter = new ShotPresenter(mMockDataManager);\n        mShotPresenter.attachView(mMockShotMvpView);\n    }\n\n    @After\n    public void detachView() {\n        mShotPresenter.detachView();\n    }\n\n    @Test\n    public void getCommentsSuccessful() {\n        List<Comment> comments = TestDataFactory.makeComments(5);\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showComments(comments);\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsEmpty() {\n        List<Comment> comments = new ArrayList<>();\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showEmptyComments();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsFailure() {\n        stubDataManagerGetComments(Single.<List<Comment>>error(new RuntimeException()));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showError();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    private void stubDataManagerGetComments(Single<List<Comment>> single) {\n        when(mMockDataManager.getComments(anyInt(), anyInt(), anyInt())).thenReturn(single);\n    }\n\n}\n'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'\n:package com.hitherejoe.androidtestcommon.util;\n\nimport android.text.TextUtils;\nimport android.view.View;\n\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.TypeSafeMatcher;\n\nimport static android.support.test.espresso.intent.Checks.checkArgument;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDescendantOfA;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.hamcrest.core.AllOf.allOf;\n\npublic class CustomMatchers {\n\n    public static Matcher<View> withItemText(final String itemText, final int parentId) {\n        checkArgument(!TextUtils.isEmpty(itemText), \"itemText cannot be null or empty\");\n        return new TypeSafeMatcher<View>() {\n            @Override\n            public boolean matchesSafely(View item) {\n                return allOf(isDescendantOfA(withId(parentId)),\n                        withText(itemText)).matches(item);\n            }\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"is isDescendantOfA RecyclerView with text \" + itemText);\n            }\n        };\n    }\n\n}\n\n'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'\n:package com.hitherejoe.bourboncorecommon.injection;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport javax.inject.Qualifier;\n\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ApplicationContext {\n\n}",
        "gt": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'"
        ]
    },
    {
        "files": [
            "'Auditor/app/src/main/java/app/attestation/auditor/attestation/AttestationApplicationId.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/AttestationProtocol.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/attestation/Constants.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/RemoteVerifyJob.java'"
        ],
        "content": "'Auditor/app/src/main/java/app/attestation/auditor/attestation/AttestationApplicationId.java'\n:\n\npackage app.attestation.auditor.attestation;\n\nimport static app.attestation.auditor.attestation.Constants.ATTESTATION_APPLICATION_ID_PACKAGE_INFOS_INDEX;\nimport static app.attestation.auditor.attestation.Constants.ATTESTATION_APPLICATION_ID_SIGNATURE_DIGESTS_INDEX;\nimport static app.attestation.auditor.attestation.Constants.ATTESTATION_PACKAGE_INFO_PACKAGE_NAME_INDEX;\nimport static app.attestation.auditor.attestation.Constants.ATTESTATION_PACKAGE_INFO_VERSION_INDEX;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport org.bouncycastle.asn1.ASN1Encodable;\nimport org.bouncycastle.asn1.ASN1EncodableVector;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1OctetString;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.ASN1Set;\nimport org.bouncycastle.asn1.DEROctetString;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.DERSet;\n\n\npublic class AttestationApplicationId {\n  public final List<AttestationPackageInfo> packageInfos;\n  public final List<byte[]> signatureDigests;\n\n  private AttestationApplicationId(byte[] attestationApplicationId) {\n    ASN1Sequence attestationApplicationIdSequence =\n        ASN1Sequence.getInstance(attestationApplicationId);\n    ASN1Set attestationPackageInfos =\n        (ASN1Set)\n            attestationApplicationIdSequence.getObjectAt(\n                ATTESTATION_APPLICATION_ID_PACKAGE_INFOS_INDEX);\n    packageInfos = new ArrayList<>();\n    for (ASN1Encodable packageInfo : attestationPackageInfos) {\n      packageInfos.add(new AttestationPackageInfo((ASN1Sequence) packageInfo));\n    }\n\n    ASN1Set digests =\n        (ASN1Set)\n            attestationApplicationIdSequence.getObjectAt(\n                ATTESTATION_APPLICATION_ID_SIGNATURE_DIGESTS_INDEX);\n    signatureDigests = new ArrayList<>();\n    for (ASN1Encodable digest : digests) {\n      signatureDigests.add(((ASN1OctetString) digest).getOctets());\n    }\n  }\n\n  public AttestationApplicationId(\n      List<AttestationPackageInfo> packageInfos, List<byte[]> signatureDigests) {\n    this.packageInfos = packageInfos;\n    this.signatureDigests = signatureDigests;\n  }\n\n  static AttestationApplicationId createAttestationApplicationId(byte[] attestationApplicationId) {\n    return new AttestationApplicationId(attestationApplicationId);\n  }\n\n  ASN1Sequence toAsn1Sequence() {\n    ASN1Encodable[] applicationIdAsn1Array = new ASN1Encodable[2];\n    ASN1EncodableVector tmpPackageInfos = new ASN1EncodableVector();\n    packageInfos.forEach(packageInfo -> tmpPackageInfos.add(packageInfo.toAsn1Sequence()));\n    applicationIdAsn1Array[ATTESTATION_APPLICATION_ID_PACKAGE_INFOS_INDEX] =\n        new DERSet(tmpPackageInfos);\n\n    ASN1EncodableVector tmpSignatureDigests = new ASN1EncodableVector();\n    signatureDigests.forEach(digest -> tmpSignatureDigests.add(new DEROctetString(digest)));\n    applicationIdAsn1Array[ATTESTATION_APPLICATION_ID_SIGNATURE_DIGESTS_INDEX] =\n        new DERSet(tmpSignatureDigests);\n\n    return new DERSequence(applicationIdAsn1Array);\n  }\n\n  @Override\n  public boolean equals(Object object) {\n    if (object instanceof AttestationApplicationId) {\n      AttestationApplicationId that = (AttestationApplicationId) object;\n      return this.packageInfos.equals(that.packageInfos)\n          && Arrays.deepEquals(this.signatureDigests.toArray(), that.signatureDigests.toArray());\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(packageInfos, Arrays.deepHashCode(signatureDigests.toArray()));\n  }\n\n\n  public static class AttestationPackageInfo {\n    public final String packageName;\n    public final long version;\n\n    private AttestationPackageInfo(ASN1Sequence packageInfo) {\n      packageName =\n          new String(\n              ((ASN1OctetString)\n                      packageInfo.getObjectAt(ATTESTATION_PACKAGE_INFO_PACKAGE_NAME_INDEX))\n                  .getOctets(),\n              UTF_8);\n      version =\n          ((ASN1Integer) packageInfo.getObjectAt(ATTESTATION_PACKAGE_INFO_VERSION_INDEX))\n              .getValue()\n              .longValue();\n    }\n\n    public AttestationPackageInfo(String packageName, long version) {\n      this.packageName = packageName;\n      this.version = version;\n    }\n\n    ASN1Sequence toAsn1Sequence() {\n      ASN1Encodable[] packageInfoAsn1Array = new ASN1Encodable[2];\n      packageInfoAsn1Array[ATTESTATION_PACKAGE_INFO_PACKAGE_NAME_INDEX] =\n          new DEROctetString(packageName.getBytes(UTF_8));\n      packageInfoAsn1Array[ATTESTATION_PACKAGE_INFO_VERSION_INDEX] = new ASN1Integer(version);\n      return new DERSequence(packageInfoAsn1Array);\n    }\n\n    @Override\n    public boolean equals(Object object) {\n      if (object instanceof AttestationPackageInfo) {\n        AttestationPackageInfo that = (AttestationPackageInfo) object;\n        return this.packageName.equals(that.packageName) && this.version == that.version;\n      }\n      return false;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(packageName, version);\n    }\n  }\n}\n",
        "gt": [
            "'Auditor/app/src/main/java/app/attestation/auditor/attestation/Constants.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/attestation/AttestationApplicationId.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/AttestationProtocol.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/RemoteVerifyJob.java'"
        ]
    },
    {
        "files": [
            "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/server/EndpointServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/ServiceContext.java'",
            "'qbit/qbit/vertx/src/test/java/io/advantageous/qbit/vertx/VertxRESTIntegrationTest.java'"
        ],
        "content": "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'\n:package io.advantageous.qbit.vertx.http;\n\nimport io.advantageous.qbit.http.server.HttpServer;\nimport io.advantageous.qbit.http.server.HttpServerBuilder;\nimport io.advantageous.qbit.vertx.http.server.HttpServerVertx;\nimport io.advantageous.qbit.vertx.http.server.SimpleVertxHttpServerWrapper;\nimport io.vertx.core.Vertx;\nimport io.vertx.ext.web.Route;\nimport io.vertx.ext.web.Router;\n\n\n\npublic class VertxHttpServerBuilder extends HttpServerBuilder {\n\n\n\n    private Vertx vertx;\n\n\n    private Router router;\n\n\n    private io.vertx.core.http.HttpServer vertxHttpServer;\n\n\n    private boolean startedVertx;\n\n\n    private Route route;\n\n    public static VertxHttpServerBuilder vertxHttpServerBuilder() {\n        return new VertxHttpServerBuilder();\n    }\n\n    public Router getRouter() {\n        return router;\n    }\n\n    public VertxHttpServerBuilder setRouter(final Router router) {\n        this.router = router;\n        return this;\n    }\n\n\n    public Route getRoute() {\n        return route;\n    }\n\n    public VertxHttpServerBuilder setRoute(final Route route) {\n        this.route = route;\n        return this;\n    }\n\n    public Vertx getVertx() {\n        if (vertx == null) {\n            startedVertx = true;\n            vertx = Vertx.vertx();\n        }\n        return vertx;\n    }\n\n    public VertxHttpServerBuilder setVertx(final Vertx vertx) {\n        this.vertx = vertx;\n        return this;\n    }\n\n\n    public io.vertx.core.http.HttpServer getHttpServer() {\n        return vertxHttpServer;\n    }\n\n    public VertxHttpServerBuilder setHttpServer(final io.vertx.core.http.HttpServer httpServer) {\n        this.vertxHttpServer = httpServer;\n        return this;\n    }\n\n    public HttpServer build() {\n\n\n        HttpServer httpServer;\n\n\n\n        if (vertxHttpServer == null) {\n\n            if (this.getRoute() != null) {\n                throw new IllegalArgumentException(\"You can't pass a route if you don't pass an httpServer\");\n            }\n\n            if (this.getRouter() != null) {\n                throw new IllegalArgumentException(\"You can't pass a router if you don't pass an httpServer\");\n            }\n\n            httpServer = new HttpServerVertx(startedVertx, this.getVertx(), getEndpointName(), getConfig(),\n                    getSystemManager(), getServiceDiscovery(), getHealthServiceAsync(),\n                    getServiceDiscoveryTtl(), getServiceDiscoveryTtlTimeUnit(), getResponseDecorators(),\n                    getHttpResponseCreator(), getRequestBodyContinuePredicate());\n        } else {\n\n\n            if (vertx == null) {\n                throw new IllegalArgumentException(\"You can't pass a httpServer and not pass a vertx object\");\n            }\n            httpServer = new SimpleVertxHttpServerWrapper(getHttpServer(), getRouter(), getRoute(),\n                    super.getConfig().getFlushInterval(), this.getEndpointName(),\n                    this.getVertx(), this.getSystemManager(),\n                    this.getServiceDiscovery(), this.getHealthServiceAsync(), getServiceDiscoveryTtl(),\n                    getServiceDiscoveryTtlTimeUnit(), getResponseDecorators(), getHttpResponseCreator(),\n                    getRequestBodyContinuePredicate());\n        }\n\n        if (this.getRequestContinuePredicate() != null) {\n            httpServer.setShouldContinueHttpRequest(this.getRequestContinuePredicate());\n        }\n\n        if (getSystemManager() != null) {\n            getSystemManager().registerServer(httpServer);\n        }\n        return httpServer;\n    }\n}\n",
        "gt": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/ServiceContext.java'",
            "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/server/EndpointServerBuilder.java'",
            "'qbit/qbit/vertx/src/test/java/io/advantageous/qbit/vertx/VertxRESTIntegrationTest.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ViewAnimator;\n\nimport com.philliphsu.bottomsheetpickers.R;\n\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.DAY_PICKER_INDEX;\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.MONTH_PICKER_INDEX;\n\n\npublic final class DayPickerViewAnimator extends ViewAnimator {\n\n    private final Animation mDayPickerInAnimation;\n    private final Animation mDayPickerOutAnimation;\n    private final Animation mMonthPickerInAnimation;\n    private final Animation mMonthPickerOutAnimation;\n\n    public DayPickerViewAnimator(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mDayPickerInAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_day_picker_slide_up);\n        mDayPickerOutAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_day_picker_slide_down);\n        mMonthPickerInAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_month_picker_slide_down);\n        mMonthPickerOutAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_month_picker_slide_up);\n    }\n\n    @Override\n    public void setDisplayedChild(int whichChild) {\n        switch (whichChild) {\n            case DAY_PICKER_INDEX:\n                setInAnimation(mDayPickerInAnimation);\n                setOutAnimation(mMonthPickerOutAnimation);\n                break;\n            case MONTH_PICKER_INDEX:\n                setInAnimation(mMonthPickerInAnimation);\n                setOutAnimation(mDayPickerOutAnimation);\n                break;\n        }\n        super.setDisplayedChild(whichChild);\n    }\n\n    final void setDisplayedChild(int whichChild, boolean animate) {\n        if (animate) {\n            setDisplayedChild(whichChild);\n        } else {\n            setInAnimation(null);\n            setOutAnimation(null);\n            super.setDisplayedChild(whichChild);\n        }\n    }\n}\n\n'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.text.format.DateUtils;\n\nimport java.util.Calendar;\nimport java.util.Formatter;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\n\nfinal class DateFormatHelper {\n\n    private static final StringBuilder STRINGBUILDER = new StringBuilder(50);\n    private static final Formatter FORMATTER = new Formatter(STRINGBUILDER, Locale.getDefault());\n\n    static String formatDate(final Calendar calendar, final int flags) {\n        return formatDate(calendar.getTimeInMillis(), flags);\n    }\n\n    static String formatDate(final long millis, final int flags) {\n        STRINGBUILDER.setLength(0);\n\n        return DateUtils.formatDateRange(null, FORMATTER, millis, millis, flags,\n                TimeZone.getDefault().getID()).toString();\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'"
        ]
    },
    {
        "files": [
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'"
        ],
        "content": "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'\n:package com.hitherejoe.bourboncorecommon.ui.shot;\n\nimport com.hitherejoe.bourboncorecommon.data.DataManager;\nimport com.hitherejoe.bourboncorecommon.data.model.Comment;\nimport com.hitherejoe.bourboncorecommon.util.RxSchedulersOverrideRule;\nimport com.hitherejoe.bourboncorecommon.util.TestDataFactory;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport rx.Single;\n\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ShotPresenterTest {\n\n    @Mock\n    ShotMvpView mMockShotMvpView;\n    @Mock\n    DataManager mMockDataManager;\n    private ShotPresenter mShotPresenter;\n\n    @Rule\n    public final RxSchedulersOverrideRule mOverrideSchedulersRule = new RxSchedulersOverrideRule();\n\n    @Before\n    public void setUp() {\n        mShotPresenter = new ShotPresenter(mMockDataManager);\n        mShotPresenter.attachView(mMockShotMvpView);\n    }\n\n    @After\n    public void detachView() {\n        mShotPresenter.detachView();\n    }\n\n    @Test\n    public void getCommentsSuccessful() {\n        List<Comment> comments = TestDataFactory.makeComments(5);\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showComments(comments);\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsEmpty() {\n        List<Comment> comments = new ArrayList<>();\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showEmptyComments();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsFailure() {\n        stubDataManagerGetComments(Single.<List<Comment>>error(new RuntimeException()));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showError();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    private void stubDataManagerGetComments(Single<List<Comment>> single) {\n        when(mMockDataManager.getComments(anyInt(), anyInt(), anyInt())).thenReturn(single);\n    }\n\n}\n'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'\n:package com.hitherejoe.androidtestcommon.util;\n\nimport android.text.TextUtils;\nimport android.view.View;\n\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.TypeSafeMatcher;\n\nimport static android.support.test.espresso.intent.Checks.checkArgument;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDescendantOfA;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.hamcrest.core.AllOf.allOf;\n\npublic class CustomMatchers {\n\n    public static Matcher<View> withItemText(final String itemText, final int parentId) {\n        checkArgument(!TextUtils.isEmpty(itemText), \"itemText cannot be null or empty\");\n        return new TypeSafeMatcher<View>() {\n            @Override\n            public boolean matchesSafely(View item) {\n                return allOf(isDescendantOfA(withId(parentId)),\n                        withText(itemText)).matches(item);\n            }\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"is isDescendantOfA RecyclerView with text \" + itemText);\n            }\n        };\n    }\n\n}\n\n'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'\n:package com.hitherejoe.bourboncorecommon.injection;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport javax.inject.Qualifier;\n\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ApplicationContext {\n\n}",
        "gt": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'"
        ],
        "content": "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'\n:package io.advantageous.qbit.service.discovery;\n\nimport io.advantageous.qbit.reactive.Callback;\nimport io.advantageous.qbit.service.Startable;\nimport io.advantageous.qbit.service.Stoppable;\nimport io.advantageous.qbit.service.health.HealthStatus;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.*;\n\n\npublic interface ServiceDiscovery extends Startable, Stoppable {\n\n\n    static String uniqueString(int port) {\n        try {\n            return port + \"-\" + InetAddress.getLocalHost().getHostName().replace('.', '-');\n        } catch (UnknownHostException e) {\n            return port + \"-\" + UUID.randomUUID().toString();\n        }\n    }\n\n\n    default EndpointDefinition register(\n            final String serviceName,\n            final String host,\n            final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceName + \".\" + uniqueString(port),\n                serviceName, host, port);\n    }\n\n\n    default EndpointDefinition registerWithTTL(\n            final String serviceName,\n            final String host,\n            final int port,\n            final int timeToLiveSeconds) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceName + \".\" + uniqueString(port),\n                serviceName, host, port, timeToLiveSeconds);\n    }\n\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default EndpointDefinition registerWithIdAndTimeToLive(\n            final String serviceName, final String serviceId, String host, final int port, final int timeToLiveSeconds) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceId,\n                serviceName, host, port, timeToLiveSeconds);\n    }\n\n\n    default EndpointDefinition registerWithId(final String serviceName, final String serviceId, String host, final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceId,\n                serviceName, host, port);\n    }\n\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default EndpointDefinition registerWithIdAndTTLAndTags(String serviceName, String serviceId, String host, int port, int timeToLiveSeconds,\n                                                           List<String> endpointTags) {\n        return new EndpointDefinition(HealthStatus.PASS, serviceId, serviceName, host, port, timeToLiveSeconds, endpointTags);\n    }\n\n\n    default void watch(String serviceName) {\n    }\n\n\n    default void checkIn(String serviceId, HealthStatus healthStatus) {\n\n    }\n\n\n    default void checkInOk(String serviceId) {\n\n    }\n\n\n    default List<EndpointDefinition> loadServices(final String serviceName) {\n\n        return Collections.emptyList();\n    }\n\n\n    default void loadServicesAsync(Callback<List<EndpointDefinition>> callback, final String serviceName) {\n\n    }\n\n\n    default List<EndpointDefinition> loadServicesNow(final String serviceName) {\n\n        return Collections.emptyList();\n    }\n\n\n    default void start() {\n    }\n\n\n    default void stop() {\n    }\n\n\n    default Set<EndpointDefinition> localDefinitions() {\n        return Collections.emptySet();\n    }\n\n}\n",
        "gt": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'"
        ]
    },
    {
        "files": [
            "'jetcd/jetcd-core/src/main/java/io/etcd/jetcd/options/OptionsUtil.java'",
            "'jetcd/jetcd-core/src/main/java/io/etcd/jetcd/support/Requests.java'",
            "'jetcd/jetcd-core/src/main/java/io/etcd/jetcd/options/GetOption.java'"
        ],
        "content": "'jetcd/jetcd-core/src/main/java/io/etcd/jetcd/options/OptionsUtil.java'\n:\n\npackage io.etcd.jetcd.options;\n\nimport java.util.Arrays;\n\nimport io.etcd.jetcd.ByteSequence;\nimport io.etcd.jetcd.api.RangeRequest;\nimport io.etcd.jetcd.options.GetOption.SortOrder;\nimport io.etcd.jetcd.options.GetOption.SortTarget;\n\npublic final class OptionsUtil {\n    private static final byte[] NO_PREFIX_END = { 0 };\n\n    private OptionsUtil() {\n    }\n\n\n    public static ByteSequence prefixEndOf(ByteSequence prefix) {\n        byte[] endKey = prefix.getBytes().clone();\n        for (int i = endKey.length - 1; i >= 0; i--) {\n            if (endKey[i] != (byte) 0xff) {\n                endKey[i] = (byte) (endKey[i] + 1);\n                return ByteSequence.from(Arrays.copyOf(endKey, i + 1));\n            }\n        }\n\n        return ByteSequence.from(NO_PREFIX_END);\n    }\n\n\n    public static RangeRequest.SortOrder toRangeRequestSortOrder(SortOrder order) {\n        switch (order) {\n            case NONE:\n                return RangeRequest.SortOrder.NONE;\n            case ASCEND:\n                return RangeRequest.SortOrder.ASCEND;\n            case DESCEND:\n                return RangeRequest.SortOrder.DESCEND;\n            default:\n                return RangeRequest.SortOrder.UNRECOGNIZED;\n        }\n    }\n\n\n    public static RangeRequest.SortTarget toRangeRequestSortTarget(SortTarget target) {\n        switch (target) {\n            case KEY:\n                return RangeRequest.SortTarget.KEY;\n            case CREATE:\n                return RangeRequest.SortTarget.CREATE;\n            case MOD:\n                return RangeRequest.SortTarget.MOD;\n            case VALUE:\n                return RangeRequest.SortTarget.VALUE;\n            case VERSION:\n                return RangeRequest.SortTarget.VERSION;\n            default:\n                return RangeRequest.SortTarget.UNRECOGNIZED;\n        }\n    }\n}\n\n'jetcd/jetcd-core/src/main/java/io/etcd/jetcd/support/Requests.java'\n:package io.etcd.jetcd.support;\n\nimport java.util.Optional;\nimport java.util.function.Consumer;\n\nimport io.etcd.jetcd.ByteSequence;\nimport io.etcd.jetcd.api.DeleteRangeRequest;\nimport io.etcd.jetcd.api.PutRequest;\nimport io.etcd.jetcd.api.RangeRequest;\nimport io.etcd.jetcd.options.DeleteOption;\nimport io.etcd.jetcd.options.GetOption;\nimport io.etcd.jetcd.options.OptionsUtil;\nimport io.etcd.jetcd.options.PutOption;\n\nimport com.google.protobuf.ByteString;\n\nimport static io.etcd.jetcd.options.OptionsUtil.toRangeRequestSortOrder;\nimport static io.etcd.jetcd.options.OptionsUtil.toRangeRequestSortTarget;\n\npublic final class Requests {\n\n    private Requests() {\n    }\n\n    public static RangeRequest mapRangeRequest(ByteSequence key, GetOption option, ByteSequence namespace) {\n        RangeRequest.Builder builder = RangeRequest.newBuilder()\n            .setKey(Util.prefixNamespace(key, namespace))\n            .setCountOnly(option.isCountOnly())\n            .setLimit(option.getLimit())\n            .setRevision(option.getRevision())\n            .setKeysOnly(option.isKeysOnly())\n            .setSerializable(option.isSerializable())\n            .setSortOrder(toRangeRequestSortOrder(option.getSortOrder()))\n            .setSortTarget(toRangeRequestSortTarget(option.getSortField()))\n            .setMinCreateRevision(option.getMinCreateRevision())\n            .setMaxCreateRevision(option.getMaxCreateRevision())\n            .setMinModRevision(option.getMinModRevision())\n            .setMaxModRevision(option.getMaxModRevision());\n\n        defineRangeRequestEnd(key, option.getEndKey(), option.isPrefix(), namespace, builder::setRangeEnd);\n        return builder.build();\n    }\n\n    public static PutRequest mapPutRequest(ByteSequence key, ByteSequence value, PutOption option, ByteSequence namespace) {\n        return PutRequest.newBuilder()\n            .setKey(Util.prefixNamespace(key, namespace))\n            .setValue(ByteString.copyFrom(value.getBytes()))\n            .setLease(option.getLeaseId())\n            .setPrevKv(option.getPrevKV())\n            .build();\n    }\n\n    public static DeleteRangeRequest mapDeleteRequest(ByteSequence key, DeleteOption option, ByteSequence namespace) {\n        DeleteRangeRequest.Builder builder = DeleteRangeRequest.newBuilder()\n            .setKey(Util.prefixNamespace(key, namespace))\n            .setPrevKv(option.isPrevKV());\n\n        defineRangeRequestEnd(key, option.getEndKey(), option.isPrefix(), namespace, builder::setRangeEnd);\n\n        return builder.build();\n    }\n\n    private static void defineRangeRequestEnd(\n        ByteSequence key,\n        Optional<ByteSequence> endKeyOptional,\n        boolean hasPrefix,\n        ByteSequence namespace,\n        Consumer<ByteString> setRangeEndConsumer) {\n\n        if (endKeyOptional.isPresent()) {\n            setRangeEndConsumer\n                .accept(Util.prefixNamespaceToRangeEnd(ByteString.copyFrom(endKeyOptional.get().getBytes()), namespace));\n        } else {\n            if (hasPrefix) {\n                ByteSequence endKey = OptionsUtil.prefixEndOf(key);\n                setRangeEndConsumer.accept(Util.prefixNamespaceToRangeEnd(ByteString.copyFrom(endKey.getBytes()), namespace));\n            }\n        }\n    }\n}\n",
        "gt": [
            "'jetcd/jetcd-core/src/main/java/io/etcd/jetcd/options/GetOption.java'",
            "'jetcd/jetcd-core/src/main/java/io/etcd/jetcd/options/OptionsUtil.java'",
            "'jetcd/jetcd-core/src/main/java/io/etcd/jetcd/support/Requests.java'"
        ]
    },
    {
        "files": [
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Client/Test.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Director/Director.java'"
        ],
        "content": "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'\n:package ConcreteBuilder;\n\nimport Builder.Builder;\nimport Components.*;\nimport Product.Manual;\n\npublic class CarManualBuilder implements Builder {\n    private CarType type;\n    private int seats;\n    private Engine engine;\n    private Transmission transmiossion;\n    private TripComputer tripComputer;\n    private GPSNavigator gpsNavigator;\n\n    @Override\n    public void setCarType(CarType type) {\n        this.type = type;\n    }\n\n    @Override\n    public void setSeats(int seat) {\n        this.seats = seat;\n    }\n\n    @Override\n    public void setEngine(Engine engine) {\n        this.engine = engine;\n    }\n\n    @Override\n    public void setTransmission(Transmission transmission) {\n        this.transmiossion = transmiossion;\n    }\n\n    @Override\n    public void setTripComputer(TripComputer tripComputer) {\n        this.tripComputer = tripComputer;\n    }\n\n    @Override\n    public void setGPSNavigator(GPSNavigator gpsNavigator) {\n        this.gpsNavigator = gpsNavigator;\n    }\n\n    public Manual getResult() {\n        return new Manual(type, seats, engine, transmiossion, tripComputer, gpsNavigator);\n    }\n}\n",
        "gt": [
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Director/Director.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Client/Test.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-codec/src/test/java/io/airlift/drift/codec/metadata/TestThriftCatalog.java'",
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/metadata/ThriftServiceMetadata.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Streams;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.drift.DriftScribeService;\nimport io.airlift.drift.server.DriftServer;\nimport io.airlift.drift.server.DriftService;\nimport io.airlift.drift.server.stats.NullMethodInvocationStatsFactory;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerConfig;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransportFactory;\nimport org.testng.annotations.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Lists.newArrayList;\nimport static io.airlift.drift.integration.ApacheThriftTesterUtil.apacheThriftTestClients;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_MESSAGES;\nimport static io.airlift.drift.integration.ClientTestUtils.HEADER_VALUE;\nimport static io.airlift.drift.integration.DriftNettyTesterUtil.driftNettyTestClients;\nimport static io.airlift.drift.integration.LegacyApacheThriftTesterUtil.legacyApacheThriftTestClients;\nimport static io.airlift.drift.transport.netty.codec.Transport.HEADER;\nimport static java.util.Collections.nCopies;\nimport static org.testng.Assert.assertEquals;\n\npublic class TestClientsWithDriftNettyServer\n{\n    private static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n\n    @Test\n    public void testDriftServer()\n    {\n        testDriftServer(ImmutableList.of());\n    }\n\n    @Test\n    public void testHandlersWithDriftServer()\n    {\n        TestingFilter firstFilter = new TestingFilter();\n        TestingFilter secondFilter = new TestingFilter();\n        List<MethodInvocationFilter> filters = ImmutableList.of(firstFilter, secondFilter);\n\n        int invocationCount = testDriftServer(filters);\n\n        firstFilter.assertCounts(invocationCount);\n        secondFilter.assertCounts(invocationCount);\n    }\n\n    private static int testDriftServer(List<MethodInvocationFilter> filters)\n    {\n        DriftScribeService scribeService = new DriftScribeService();\n        AtomicInteger invocationCount = new AtomicInteger();\n        AtomicInteger headerInvocationCount = new AtomicInteger();\n        testDriftServer(new DriftService(scribeService), address -> {\n            for (boolean secure : ImmutableList.of(true, false)) {\n                for (Transport transport : ImmutableList.of(HEADER)) {\n                    for (Protocol protocol : Protocol.values()) {\n                        int count = Streams.concat(\n                                legacyApacheThriftTestClients(filters, transport, protocol, secure).stream(),\n                                driftNettyTestClients(filters, transport, protocol, secure).stream(),\n                                apacheThriftTestClients(filters, transport, protocol, secure).stream())\n                                .mapToInt(client -> client.applyAsInt(address))\n                                .sum();\n                        invocationCount.addAndGet(count);\n                        if (transport == HEADER) {\n                            headerInvocationCount.addAndGet(count);\n                        }\n                    }\n                }\n            }\n        });\n\n        assertEquals(scribeService.getMessages(), newArrayList(concat(nCopies(invocationCount.get(), DRIFT_MESSAGES))));\n        assertEquals(scribeService.getHeaders(), newArrayList(nCopies(headerInvocationCount.get(), HEADER_VALUE)));\n\n        return invocationCount.get();\n    }\n\n    private static void testDriftServer(DriftService service, Consumer<HostAndPort> task)\n    {\n        DriftNettyServerConfig config = new DriftNettyServerConfig()\n                .setSslEnabled(true)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setKey(ClientTestUtils.getPrivateKeyFile());\n        TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n        DriftServer driftServer = new DriftServer(\n                new DriftNettyServerTransportFactory(config, testingAllocator),\n                CODEC_MANAGER,\n                new NullMethodInvocationStatsFactory(),\n                ImmutableSet.of(service),\n                ImmutableSet.of());\n        try {\n            driftServer.start();\n\n            HostAndPort address = HostAndPort.fromParts(\"localhost\", ((DriftNettyServerTransport) driftServer.getServerTransport()).getPort());\n\n            task.accept(address);\n        }\n        finally {\n            driftServer.shutdown();\n            testingAllocator.close();\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-codec/src/test/java/io/airlift/drift/codec/metadata/TestThriftCatalog.java'",
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/metadata/ThriftServiceMetadata.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'"
        ]
    },
    {
        "files": [
            "'jitescript/src/main/java/me/qmx/jitescript/util/CodegenUtils.java'",
            "'jitescript/src/main/java/me/qmx/jitescript/CodeBlock.java'",
            "'jitescript/src/test/java/me/qmx/jitescript/AnnotationsTest.java'",
            "'jitescript/src/test/java/me/qmx/jitescript/JiteClassTest.java'"
        ],
        "content": "'jitescript/src/main/java/me/qmx/jitescript/util/CodegenUtils.java'\n:\npackage me.qmx.jitescript.util;\n\nimport org.objectweb.asm.AnnotationVisitor;\nimport org.objectweb.asm.Type;\n\nimport java.util.Arrays;\nimport java.util.Map;\n\n\npublic final class CodegenUtils {\n\n    private CodegenUtils() {\n    }\n\n\n    public static String c(String p) {\n        return p.replace('/', '.');\n    }\n\n\n    public static String p(Class<?> n) {\n        return n.getName().replace('.', '/');\n    }\n\n\n    public static String ci(Class<?> n) {\n        if (n.isArray()) {\n            n = n.getComponentType();\n            if (n.isPrimitive()) {\n                if (n == Byte.TYPE) {\n                    return \"[B\";\n                } else if (n == Boolean.TYPE) {\n                    return \"[Z\";\n                } else if (n == Short.TYPE) {\n                    return \"[S\";\n                } else if (n == Character.TYPE) {\n                    return \"[C\";\n                } else if (n == Integer.TYPE) {\n                    return \"[I\";\n                } else if (n == Float.TYPE) {\n                    return \"[F\";\n                } else if (n == Double.TYPE) {\n                    return \"[D\";\n                } else if (n == Long.TYPE) {\n                    return \"[J\";\n                } else {\n                    throw new RuntimeException(\"Unrecognized type in compiler: \" + n.getName());\n                }\n            } else {\n                return \"[\" + ci(n);\n            }\n        } else {\n            if (n.isPrimitive()) {\n                if (n == Byte.TYPE) {\n                    return \"B\";\n                } else if (n == Boolean.TYPE) {\n                    return \"Z\";\n                } else if (n == Short.TYPE) {\n                    return \"S\";\n                } else if (n == Character.TYPE) {\n                    return \"C\";\n                } else if (n == Integer.TYPE) {\n                    return \"I\";\n                } else if (n == Float.TYPE) {\n                    return \"F\";\n                } else if (n == Double.TYPE) {\n                    return \"D\";\n                } else if (n == Long.TYPE) {\n                    return \"J\";\n                } else if (n == Void.TYPE) {\n                    return \"V\";\n                } else {\n                    throw new RuntimeException(\"Unrecognized type in compiler: \" + n.getName());\n                }\n            } else {\n                return \"L\" + p(n) + \";\";\n            }\n        }\n    }\n\n\n    public static String human(Class<?> n) {\n        return n.getCanonicalName();\n    }\n\n\n    public static String sig(Class<?> retval, Class<?>... params) {\n        return sigParams(params) + ci(retval);\n    }\n\n    public static String sig(Class<?>[] retvalParams) {\n        Class<?>[] justParams = new Class<?>[retvalParams.length - 1];\n        System.arraycopy(retvalParams, 1, justParams, 0, justParams.length);\n        return sigParams(justParams) + ci(retvalParams[0]);\n    }\n\n    public static String sig(Class<?> retval, String descriptor, Class<?>... params) {\n        return sigParams(descriptor, params) + ci(retval);\n    }\n\n    public static String sigParams(Class<?>... params) {\n        StringBuilder signature = new StringBuilder(\"(\");\n\n        for (int i = 0; i < params.length; i++) {\n            signature.append(ci(params[i]));\n        }\n\n        signature.append(\")\");\n\n        return signature.toString();\n    }\n\n    public static String sigParams(String descriptor, Class<?>... params) {\n        StringBuilder signature = new StringBuilder(\"(\");\n\n        signature.append(descriptor);\n\n        for (int i = 0; i < params.length; i++) {\n            signature.append(ci(params[i]));\n        }\n\n        signature.append(\")\");\n\n        return signature.toString();\n    }\n\n    public static String pretty(Class<?> retval, Class<?>... params) {\n        return prettyParams(params) + human(retval);\n    }\n\n    public static String prettyParams(Class<?>... params) {\n        StringBuilder signature = new StringBuilder(\"(\");\n\n        for (int i = 0; i < params.length; i++) {\n            signature.append(human(params[i]));\n            if (i < params.length - 1) {\n                signature.append(',');\n            }\n        }\n\n        signature.append(\")\");\n\n        return signature.toString();\n    }\n\n    public static Class<?>[] params(Class<?>... classes) {\n        return classes;\n    }\n\n    public static Class<?>[] params(Class<?> cls, int times) {\n        Class<?>[] classes = new Class<?>[times];\n        Arrays.fill(classes, cls);\n        return classes;\n    }\n\n    public static Class<?>[] params(Class<?> cls1, Class<?> clsFill, int times) {\n        Class<?>[] classes = new Class<?>[times + 1];\n        Arrays.fill(classes, clsFill);\n        classes[0] = cls1;\n        return classes;\n    }\n\n    public static Class<?>[] params(Class<?> cls1, Class<?> cls2, Class<?> clsFill, int times) {\n        Class<?>[] classes = new Class<?>[times + 2];\n        Arrays.fill(classes, clsFill);\n        classes[0] = cls1;\n        classes[1] = cls2;\n        return classes;\n    }\n\n    public static String getAnnotatedBindingClassName(String javaMethodName, String typeName, boolean isStatic, int required,\n            int optional, boolean multi, boolean framed) {\n        String commonClassSuffix;\n        if (multi) {\n            commonClassSuffix = (isStatic ? \"$s$\" : \"$i$\") + javaMethodName;\n        } else {\n            commonClassSuffix = (isStatic ? \"$s$\" : \"$i$\") + required + \"$\" + optional + \"$\" + javaMethodName;\n        }\n        return typeName + commonClassSuffix;\n    }\n\n    public static void visitAnnotationFields(AnnotationVisitor visitor, Map<String, Object> fields) {\n        for (Map.Entry<String, Object> fieldEntry : fields.entrySet()) {\n            Object value = fieldEntry.getValue();\n            if (value.getClass().isArray()) {\n                Object[] values = (Object[]) value;\n                AnnotationVisitor arrayV = visitor.visitArray(fieldEntry.getKey());\n                for (int i = 0; i < values.length; i++) {\n                    arrayV.visit(null, values[i]);\n                }\n                arrayV.visitEnd();\n            } else if (value.getClass().isEnum()) {\n                visitor.visitEnum(fieldEntry.getKey(), ci(value.getClass()), value.toString());\n            } else if (value instanceof Class) {\n                visitor.visit(fieldEntry.getKey(), Type.getType((Class) value));\n            } else {\n                visitor.visit(fieldEntry.getKey(), value);\n            }\n        }\n    }\n\n    public static Class<?> getBoxType(Class<?> type) {\n        if (type == int.class) {\n            return Integer.class;\n        } else if (type == byte.class) {\n            return Byte.class;\n        } else if (type == short.class) {\n            return Short.class;\n        } else if (type == char.class) {\n            return Character.class;\n        } else if (type == long.class) {\n            return Long.class;\n        } else if (type == float.class) {\n            return Float.class;\n        } else if (type == double.class) {\n            return Double.class;\n        } else if (type == boolean.class) {\n            return Boolean.class;\n        } else {\n            throw new RuntimeException(\"Not a native type: \" + type);\n        }\n    }\n}\n",
        "gt": [
            "'jitescript/src/main/java/me/qmx/jitescript/util/CodegenUtils.java'",
            "'jitescript/src/main/java/me/qmx/jitescript/CodeBlock.java'",
            "'jitescript/src/test/java/me/qmx/jitescript/JiteClassTest.java'",
            "'jitescript/src/test/java/me/qmx/jitescript/AnnotationsTest.java'"
        ]
    },
    {
        "files": [
            "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/server/EndpointServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/ServiceContext.java'",
            "'qbit/qbit/vertx/src/test/java/io/advantageous/qbit/vertx/VertxRESTIntegrationTest.java'"
        ],
        "content": "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'\n:package io.advantageous.qbit.vertx.http;\n\nimport io.advantageous.qbit.http.server.HttpServer;\nimport io.advantageous.qbit.http.server.HttpServerBuilder;\nimport io.advantageous.qbit.vertx.http.server.HttpServerVertx;\nimport io.advantageous.qbit.vertx.http.server.SimpleVertxHttpServerWrapper;\nimport io.vertx.core.Vertx;\nimport io.vertx.ext.web.Route;\nimport io.vertx.ext.web.Router;\n\n\n\npublic class VertxHttpServerBuilder extends HttpServerBuilder {\n\n\n\n    private Vertx vertx;\n\n\n    private Router router;\n\n\n    private io.vertx.core.http.HttpServer vertxHttpServer;\n\n\n    private boolean startedVertx;\n\n\n    private Route route;\n\n    public static VertxHttpServerBuilder vertxHttpServerBuilder() {\n        return new VertxHttpServerBuilder();\n    }\n\n    public Router getRouter() {\n        return router;\n    }\n\n    public VertxHttpServerBuilder setRouter(final Router router) {\n        this.router = router;\n        return this;\n    }\n\n\n    public Route getRoute() {\n        return route;\n    }\n\n    public VertxHttpServerBuilder setRoute(final Route route) {\n        this.route = route;\n        return this;\n    }\n\n    public Vertx getVertx() {\n        if (vertx == null) {\n            startedVertx = true;\n            vertx = Vertx.vertx();\n        }\n        return vertx;\n    }\n\n    public VertxHttpServerBuilder setVertx(final Vertx vertx) {\n        this.vertx = vertx;\n        return this;\n    }\n\n\n    public io.vertx.core.http.HttpServer getHttpServer() {\n        return vertxHttpServer;\n    }\n\n    public VertxHttpServerBuilder setHttpServer(final io.vertx.core.http.HttpServer httpServer) {\n        this.vertxHttpServer = httpServer;\n        return this;\n    }\n\n    public HttpServer build() {\n\n\n        HttpServer httpServer;\n\n\n\n        if (vertxHttpServer == null) {\n\n            if (this.getRoute() != null) {\n                throw new IllegalArgumentException(\"You can't pass a route if you don't pass an httpServer\");\n            }\n\n            if (this.getRouter() != null) {\n                throw new IllegalArgumentException(\"You can't pass a router if you don't pass an httpServer\");\n            }\n\n            httpServer = new HttpServerVertx(startedVertx, this.getVertx(), getEndpointName(), getConfig(),\n                    getSystemManager(), getServiceDiscovery(), getHealthServiceAsync(),\n                    getServiceDiscoveryTtl(), getServiceDiscoveryTtlTimeUnit(), getResponseDecorators(),\n                    getHttpResponseCreator(), getRequestBodyContinuePredicate());\n        } else {\n\n\n            if (vertx == null) {\n                throw new IllegalArgumentException(\"You can't pass a httpServer and not pass a vertx object\");\n            }\n            httpServer = new SimpleVertxHttpServerWrapper(getHttpServer(), getRouter(), getRoute(),\n                    super.getConfig().getFlushInterval(), this.getEndpointName(),\n                    this.getVertx(), this.getSystemManager(),\n                    this.getServiceDiscovery(), this.getHealthServiceAsync(), getServiceDiscoveryTtl(),\n                    getServiceDiscoveryTtlTimeUnit(), getResponseDecorators(), getHttpResponseCreator(),\n                    getRequestBodyContinuePredicate());\n        }\n\n        if (this.getRequestContinuePredicate() != null) {\n            httpServer.setShouldContinueHttpRequest(this.getRequestContinuePredicate());\n        }\n\n        if (getSystemManager() != null) {\n            getSystemManager().registerServer(httpServer);\n        }\n        return httpServer;\n    }\n}\n",
        "gt": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/ServiceContext.java'",
            "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/server/EndpointServerBuilder.java'",
            "'qbit/qbit/vertx/src/test/java/io/advantageous/qbit/vertx/VertxRESTIntegrationTest.java'"
        ]
    },
    {
        "files": [
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsTest.java'",
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/model/Constraint.java'"
        ],
        "content": "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'\n:package com.tjeannin.provigen.test.constraint;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport com.tjeannin.provigen.ProviGenBaseContract;\nimport com.tjeannin.provigen.ProviGenProvider;\nimport com.tjeannin.provigen.annotation.Column;\nimport com.tjeannin.provigen.annotation.Column.Type;\nimport com.tjeannin.provigen.annotation.ContentUri;\nimport com.tjeannin.provigen.helper.TableBuilder;\nimport com.tjeannin.provigen.model.Constraint;\nimport com.tjeannin.provigen.model.Constraint.OnConflict;\n\npublic class ConstraintsProvider extends ProviGenProvider {\n\n    @Override\n    public SQLiteOpenHelper openHelper(final Context context) {\n        return new SQLiteOpenHelper(context, \"ProviGenDatabase\", null, 1) {\n            @Override\n            public void onCreate(SQLiteDatabase database) {\n                new TableBuilder(NotNullContract.class)\n                        .addConstraint(NotNullContract.AN_INT, Constraint.NOT_NULL, OnConflict.ABORT)\n                        .createTable(database);\n\n                new TableBuilder(UniqueContract.class)\n                        .addConstraint(UniqueContract.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n\n                new TableBuilder(UniqueAndNotNullContract.class)\n                        .addConstraint(UniqueAndNotNullContract.AN_INT, Constraint.NOT_NULL, OnConflict.ABORT)\n                        .addConstraint(UniqueAndNotNullContract.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n            }\n\n            @Override\n            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n            }\n        };\n    }\n\n    @Override\n    public Class[] contractClasses() {\n        return new Class[]{NotNullContract.class, UniqueContract.class, UniqueAndNotNullContract.class};\n    }\n\n\n    public static interface NotNullContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n\n    public static interface UniqueContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n\n    public static interface UniqueAndNotNullContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n}\n\n'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsTest.java'\n:package com.tjeannin.provigen.test.constraint;\n\nimport android.content.ContentValues;\nimport com.tjeannin.provigen.test.ExtendedProviderTestCase;\nimport com.tjeannin.provigen.test.constraint.ConstraintsProvider.NotNullContract;\nimport com.tjeannin.provigen.test.constraint.ConstraintsProvider.UniqueAndNotNullContract;\nimport com.tjeannin.provigen.test.constraint.ConstraintsProvider.UniqueContract;\n\npublic class ConstraintsTest extends ExtendedProviderTestCase<ConstraintsProvider> {\n\n    public ConstraintsTest() {\n        super(ConstraintsProvider.class, \"com.test.simple\");\n    }\n\n    public void testNotNullAnnotation() {\n\n        ContentValues contentValuesWithNull = getContentValues(NotNullContract.class);\n        contentValuesWithNull.putNull(NotNullContract.AN_INT);\n\n        ContentValues normalContentValues = getContentValues(NotNullContract.class);\n\n        assertEquals(0, getRowCount(NotNullContract.CONTENT_URI));\n        getMockContentResolver().insert(NotNullContract.CONTENT_URI, contentValuesWithNull);\n        assertEquals(0, getRowCount(NotNullContract.CONTENT_URI));\n        getMockContentResolver().insert(NotNullContract.CONTENT_URI, normalContentValues);\n        assertEquals(1, getRowCount(NotNullContract.CONTENT_URI));\n        getMockContentResolver().insert(NotNullContract.CONTENT_URI, contentValuesWithNull);\n        assertEquals(1, getRowCount(NotNullContract.CONTENT_URI));\n    }\n\n    public void testUniqueAnnotation() {\n\n        getMockContentResolver().insert(UniqueContract.CONTENT_URI, getContentValues(UniqueContract.class));\n        getMockContentResolver().insert(UniqueContract.CONTENT_URI, getContentValues(UniqueContract.class));\n        getMockContentResolver().insert(UniqueContract.CONTENT_URI, getContentValues(UniqueContract.class));\n\n        assertEquals(1, getRowCount(UniqueContract.CONTENT_URI));\n    }\n\n    public void testBothUniqueAndNotNullAnnotation() {\n\n        getMockContentResolver().insert(UniqueAndNotNullContract.CONTENT_URI, new ContentValues());\n\n        assertEquals(0, getRowCount(UniqueAndNotNullContract.CONTENT_URI));\n\n        getMockContentResolver().insert(UniqueAndNotNullContract.CONTENT_URI, getContentValues(UniqueAndNotNullContract.class));\n        getMockContentResolver().insert(UniqueAndNotNullContract.CONTENT_URI, getContentValues(UniqueAndNotNullContract.class));\n        getMockContentResolver().insert(UniqueAndNotNullContract.CONTENT_URI, getContentValues(UniqueAndNotNullContract.class));\n\n        assertEquals(1, getRowCount(UniqueAndNotNullContract.CONTENT_URI));\n    }\n}\n",
        "gt": [
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/model/Constraint.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsTest.java'"
        ]
    },
    {
        "files": [
            "'Auditor/app/src/main/java/app/attestation/auditor/attestation/AttestationApplicationId.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/AttestationProtocol.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/attestation/Constants.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/RemoteVerifyJob.java'"
        ],
        "content": "'Auditor/app/src/main/java/app/attestation/auditor/attestation/AttestationApplicationId.java'\n:\n\npackage app.attestation.auditor.attestation;\n\nimport static app.attestation.auditor.attestation.Constants.ATTESTATION_APPLICATION_ID_PACKAGE_INFOS_INDEX;\nimport static app.attestation.auditor.attestation.Constants.ATTESTATION_APPLICATION_ID_SIGNATURE_DIGESTS_INDEX;\nimport static app.attestation.auditor.attestation.Constants.ATTESTATION_PACKAGE_INFO_PACKAGE_NAME_INDEX;\nimport static app.attestation.auditor.attestation.Constants.ATTESTATION_PACKAGE_INFO_VERSION_INDEX;\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\nimport org.bouncycastle.asn1.ASN1Encodable;\nimport org.bouncycastle.asn1.ASN1EncodableVector;\nimport org.bouncycastle.asn1.ASN1Integer;\nimport org.bouncycastle.asn1.ASN1OctetString;\nimport org.bouncycastle.asn1.ASN1Sequence;\nimport org.bouncycastle.asn1.ASN1Set;\nimport org.bouncycastle.asn1.DEROctetString;\nimport org.bouncycastle.asn1.DERSequence;\nimport org.bouncycastle.asn1.DERSet;\n\n\npublic class AttestationApplicationId {\n  public final List<AttestationPackageInfo> packageInfos;\n  public final List<byte[]> signatureDigests;\n\n  private AttestationApplicationId(byte[] attestationApplicationId) {\n    ASN1Sequence attestationApplicationIdSequence =\n        ASN1Sequence.getInstance(attestationApplicationId);\n    ASN1Set attestationPackageInfos =\n        (ASN1Set)\n            attestationApplicationIdSequence.getObjectAt(\n                ATTESTATION_APPLICATION_ID_PACKAGE_INFOS_INDEX);\n    packageInfos = new ArrayList<>();\n    for (ASN1Encodable packageInfo : attestationPackageInfos) {\n      packageInfos.add(new AttestationPackageInfo((ASN1Sequence) packageInfo));\n    }\n\n    ASN1Set digests =\n        (ASN1Set)\n            attestationApplicationIdSequence.getObjectAt(\n                ATTESTATION_APPLICATION_ID_SIGNATURE_DIGESTS_INDEX);\n    signatureDigests = new ArrayList<>();\n    for (ASN1Encodable digest : digests) {\n      signatureDigests.add(((ASN1OctetString) digest).getOctets());\n    }\n  }\n\n  public AttestationApplicationId(\n      List<AttestationPackageInfo> packageInfos, List<byte[]> signatureDigests) {\n    this.packageInfos = packageInfos;\n    this.signatureDigests = signatureDigests;\n  }\n\n  static AttestationApplicationId createAttestationApplicationId(byte[] attestationApplicationId) {\n    return new AttestationApplicationId(attestationApplicationId);\n  }\n\n  ASN1Sequence toAsn1Sequence() {\n    ASN1Encodable[] applicationIdAsn1Array = new ASN1Encodable[2];\n    ASN1EncodableVector tmpPackageInfos = new ASN1EncodableVector();\n    packageInfos.forEach(packageInfo -> tmpPackageInfos.add(packageInfo.toAsn1Sequence()));\n    applicationIdAsn1Array[ATTESTATION_APPLICATION_ID_PACKAGE_INFOS_INDEX] =\n        new DERSet(tmpPackageInfos);\n\n    ASN1EncodableVector tmpSignatureDigests = new ASN1EncodableVector();\n    signatureDigests.forEach(digest -> tmpSignatureDigests.add(new DEROctetString(digest)));\n    applicationIdAsn1Array[ATTESTATION_APPLICATION_ID_SIGNATURE_DIGESTS_INDEX] =\n        new DERSet(tmpSignatureDigests);\n\n    return new DERSequence(applicationIdAsn1Array);\n  }\n\n  @Override\n  public boolean equals(Object object) {\n    if (object instanceof AttestationApplicationId) {\n      AttestationApplicationId that = (AttestationApplicationId) object;\n      return this.packageInfos.equals(that.packageInfos)\n          && Arrays.deepEquals(this.signatureDigests.toArray(), that.signatureDigests.toArray());\n    }\n    return false;\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(packageInfos, Arrays.deepHashCode(signatureDigests.toArray()));\n  }\n\n\n  public static class AttestationPackageInfo {\n    public final String packageName;\n    public final long version;\n\n    private AttestationPackageInfo(ASN1Sequence packageInfo) {\n      packageName =\n          new String(\n              ((ASN1OctetString)\n                      packageInfo.getObjectAt(ATTESTATION_PACKAGE_INFO_PACKAGE_NAME_INDEX))\n                  .getOctets(),\n              UTF_8);\n      version =\n          ((ASN1Integer) packageInfo.getObjectAt(ATTESTATION_PACKAGE_INFO_VERSION_INDEX))\n              .getValue()\n              .longValue();\n    }\n\n    public AttestationPackageInfo(String packageName, long version) {\n      this.packageName = packageName;\n      this.version = version;\n    }\n\n    ASN1Sequence toAsn1Sequence() {\n      ASN1Encodable[] packageInfoAsn1Array = new ASN1Encodable[2];\n      packageInfoAsn1Array[ATTESTATION_PACKAGE_INFO_PACKAGE_NAME_INDEX] =\n          new DEROctetString(packageName.getBytes(UTF_8));\n      packageInfoAsn1Array[ATTESTATION_PACKAGE_INFO_VERSION_INDEX] = new ASN1Integer(version);\n      return new DERSequence(packageInfoAsn1Array);\n    }\n\n    @Override\n    public boolean equals(Object object) {\n      if (object instanceof AttestationPackageInfo) {\n        AttestationPackageInfo that = (AttestationPackageInfo) object;\n        return this.packageName.equals(that.packageName) && this.version == that.version;\n      }\n      return false;\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(packageName, version);\n    }\n  }\n}\n",
        "gt": [
            "'Auditor/app/src/main/java/app/attestation/auditor/attestation/Constants.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/attestation/AttestationApplicationId.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/AttestationProtocol.java'",
            "'Auditor/app/src/main/java/app/attestation/auditor/RemoteVerifyJob.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.apache.ResultCode;\nimport io.airlift.drift.integration.scribe.apache.scribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TCompactProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransport;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportFactory;\nimport org.apache.thrift.transport.layered.TFramedTransport;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\nimport java.util.List;\nimport java.util.function.ToIntFunction;\n\nimport static io.airlift.drift.integration.ClientTestUtils.MESSAGES;\nimport static org.testng.Assert.assertEquals;\n\nfinal class LegacyApacheThriftTesterUtil\n{\n    private LegacyApacheThriftTesterUtil() {}\n\n    public static List<ToIntFunction<HostAndPort>> legacyApacheThriftTestClients(List<MethodInvocationFilter> filters, Transport transport, Protocol protocol, boolean secure)\n    {\n        return ImmutableList.of(\n                address -> logThrift(address, MESSAGES, filters, transport, protocol, secure));\n    }\n\n    private static int logThrift(HostAndPort address, List<LogEntry> messages, List<MethodInvocationFilter> filters, Transport transportType, Protocol protocolType, boolean secure)\n    {\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        TTransportFactory transportFactory;\n        switch (transportType) {\n            case UNFRAMED:\n                transportFactory = new TTransportFactory();\n                break;\n            case FRAMED:\n                transportFactory = new TFramedTransport.Factory();\n                break;\n            case HEADER:\n                return 0;\n            default:\n                throw new IllegalArgumentException(\"Unsupported transport \" + transportType);\n        }\n\n        try (TSocket socket = createClientSocket(secure, address)) {\n            if (!socket.isOpen()) {\n                socket.open();\n            }\n            TTransport transport = transportFactory.getTransport(socket);\n            TProtocol protocol;\n            switch (protocolType) {\n                case BINARY:\n                    protocol = new TBinaryProtocol(transport);\n                    break;\n                case COMPACT:\n                    protocol = new TCompactProtocol(transport);\n                    break;\n                case FB_COMPACT:\n                    return 0;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported protocol \" + protocolType);\n            }\n\n            assertEquals(new scribe.Client(protocol).Log(messages), ResultCode.OK);\n        }\n        catch (TException e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static TSocket createClientSocket(boolean secure, HostAndPort address)\n            throws TTransportException\n    {\n        if (!secure) {\n            return new TSocket(address.getHost(), address.getPort());\n        }\n\n        try {\n            SSLContext serverSslContext = ClientTestUtils.getClientSslContext();\n            SSLSocket clientSocket = (SSLSocket) serverSslContext.getSocketFactory().createSocket(address.getHost(), address.getPort());\n\n            return new TSocket(clientSocket);\n        }\n        catch (Exception e) {\n            throw new TTransportException(\"Error initializing secure socket\", e);\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ]
    },
    {
        "files": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleR2dbcExceptions.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ],
        "content": "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleR2dbcExceptions.java'\n:\n\npackage oracle.r2dbc.impl;\n\nimport io.r2dbc.spi.R2dbcBadGrammarException;\nimport io.r2dbc.spi.R2dbcDataIntegrityViolationException;\nimport io.r2dbc.spi.R2dbcException;\nimport io.r2dbc.spi.R2dbcNonTransientException;\nimport io.r2dbc.spi.R2dbcNonTransientResourceException;\nimport io.r2dbc.spi.R2dbcRollbackException;\nimport io.r2dbc.spi.R2dbcTimeoutException;\nimport io.r2dbc.spi.R2dbcTransientException;\nimport io.r2dbc.spi.R2dbcTransientResourceException;\nimport oracle.jdbc.OracleDatabaseException;\n\nimport java.sql.SQLException;\nimport java.sql.SQLIntegrityConstraintViolationException;\nimport java.sql.SQLNonTransientConnectionException;\nimport java.sql.SQLNonTransientException;\nimport java.sql.SQLRecoverableException;\nimport java.sql.SQLSyntaxErrorException;\nimport java.sql.SQLTimeoutException;\nimport java.sql.SQLTransactionRollbackException;\nimport java.sql.SQLTransientConnectionException;\nimport java.sql.SQLTransientException;\nimport java.util.function.Supplier;\n\n\nfinal class OracleR2dbcExceptions {\n\n\n  private OracleR2dbcExceptions() { }\n\n\n  static <T> T requireNonNull(T obj, String message) {\n    if (obj == null)\n      throw new IllegalArgumentException(message);\n    else\n      return obj;\n  }\n\n\n\n  static void requireOpenConnection(java.sql.Connection jdbcConnection) {\n    if (fromJdbc(jdbcConnection::isClosed))\n      throw new IllegalStateException(\"Connection is closed\");\n  }\n\n\n  static R2dbcException toR2dbcException(SQLException sqlException) {\n    return toR2dbcException(sqlException, getSql(sqlException));\n  }\n\n\n  static R2dbcException toR2dbcException(\n    SQLException sqlException, String sql) {\n    assert sqlException != null : \"sqlException is null\";\n\n    final String message = sqlException.getMessage();\n    final String sqlState = sqlException.getSQLState();\n    final int errorCode = sqlException.getErrorCode();\n\n    if (sqlException instanceof SQLNonTransientException) {\n      if (sqlException instanceof SQLSyntaxErrorException) {\n        return new R2dbcBadGrammarException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else if (sqlException instanceof SQLIntegrityConstraintViolationException) {\n        return new R2dbcDataIntegrityViolationException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else if (sqlException instanceof SQLNonTransientConnectionException) {\n        return new R2dbcNonTransientResourceException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else {\n        return new OracleR2dbcNonTransientException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n    }\n    else if (sqlException instanceof SQLTransientException) {\n      if (sqlException instanceof SQLTimeoutException) {\n        return new R2dbcTimeoutException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else if (sqlException instanceof SQLTransactionRollbackException) {\n        return new R2dbcRollbackException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else if (sqlException instanceof SQLTransientConnectionException) {\n        return new R2dbcTransientResourceException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else {\n        return new OracleR2dbcTransientException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n    }\n    else if (sqlException instanceof SQLRecoverableException) {\n\n\n\n\n      return new R2dbcTransientResourceException(\n        message, sqlState, errorCode, sql, sqlException);\n    }\n    else {\n      return new OracleR2dbcException(\n        message, sqlState, errorCode, sql, sqlException);\n    }\n  }\n\n\n  static void runJdbc(JdbcRunnable runnable)\n    throws R2dbcException {\n    try {\n      runnable.runOrThrow();\n    }\n    catch (SQLException sqlException) {\n      throw toR2dbcException(sqlException);\n    }\n  }\n\n\n  static <T> T fromJdbc(JdbcSupplier<T> supplier)\n    throws R2dbcException {\n    try {\n      return supplier.getOrThrow();\n    }\n    catch (SQLException sqlException) {\n      throw toR2dbcException(sqlException);\n    }\n  }\n\n\n  static R2dbcNonTransientException newNonTransientException(\n    String message, String sql, Throwable cause) {\n    return new OracleR2dbcNonTransientException(message, null, 0, sql, cause);\n  }\n\n\n  private static String getSql(SQLException sqlException) {\n    Throwable cause = sqlException.getCause();\n\n    while (cause != null) {\n\n      if (cause instanceof OracleDatabaseException)\n        return ((OracleDatabaseException)cause).getSql();\n\n      cause = cause.getCause();\n    }\n\n    return null;\n  }\n\n\n  @FunctionalInterface\n  interface JdbcRunnable extends Runnable {\n\n    void runOrThrow() throws SQLException;\n\n\n    @Override\n    default void run() throws R2dbcException {\n      runJdbc(this);\n    }\n  }\n\n\n  @FunctionalInterface\n  interface JdbcSupplier<T> extends Supplier<T> {\n\n    T getOrThrow() throws SQLException;\n\n\n    @Override\n    default T get() throws R2dbcException {\n      return fromJdbc(this);\n    }\n  }\n\n\n  private static final class OracleR2dbcException\n    extends R2dbcException {\n    private OracleR2dbcException(\n      String message, String sqlState, int errorCode, String sql,\n      SQLException sqlException) {\n      super(message, sqlState, errorCode, sql, sqlException);\n    }\n  }\n\n\n  private static final class OracleR2dbcTransientException\n    extends R2dbcTransientException {\n    private OracleR2dbcTransientException(\n      String message, String sqlState, int errorCode, String sql,\n      SQLException sqlException) {\n      super(message, sqlState, errorCode, sql, sqlException);\n    }\n  }\n\n\n  private static final class OracleR2dbcNonTransientException\n    extends R2dbcNonTransientException {\n    private OracleR2dbcNonTransientException(\n      String message, String sqlState, int errorCode, String sql,\n      Throwable cause) {\n      super(message, sqlState, errorCode, sql, cause);\n    }\n  }\n\n}\n",
        "gt": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleR2dbcExceptions.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/FaceDetectionActivity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/FaceDetectionActivity.java'"
        ]
    },
    {
        "files": [
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Client/Test.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Director/Director.java'"
        ],
        "content": "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'\n:package ConcreteBuilder;\n\nimport Builder.Builder;\nimport Components.*;\nimport Product.Manual;\n\npublic class CarManualBuilder implements Builder {\n    private CarType type;\n    private int seats;\n    private Engine engine;\n    private Transmission transmiossion;\n    private TripComputer tripComputer;\n    private GPSNavigator gpsNavigator;\n\n    @Override\n    public void setCarType(CarType type) {\n        this.type = type;\n    }\n\n    @Override\n    public void setSeats(int seat) {\n        this.seats = seat;\n    }\n\n    @Override\n    public void setEngine(Engine engine) {\n        this.engine = engine;\n    }\n\n    @Override\n    public void setTransmission(Transmission transmission) {\n        this.transmiossion = transmiossion;\n    }\n\n    @Override\n    public void setTripComputer(TripComputer tripComputer) {\n        this.tripComputer = tripComputer;\n    }\n\n    @Override\n    public void setGPSNavigator(GPSNavigator gpsNavigator) {\n        this.gpsNavigator = gpsNavigator;\n    }\n\n    public Manual getResult() {\n        return new Manual(type, seats, engine, transmiossion, tripComputer, gpsNavigator);\n    }\n}\n\n'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Client/Test.java'\n:package Client;\n\nimport ConcreteBuilder.CarBuilder;\nimport Director.Director;\nimport Product.Car;\n\npublic class Test {\n    public static void main(String[] args) {\n        Director director = new Director();\n        CarBuilder carBuilder = new CarBuilder();\n        director.constructSportsCar(carBuilder);\n        Car car = carBuilder.getResult();\n        System.out.println(\"Car Built: \" + car.getCarType());\n    }\n}\n\n'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Director/Director.java'\n:package Director;\n\nimport Builder.Builder;\nimport Components.*;\n\npublic class Director {\n    public void constructSportsCar(Builder builder) {\n        builder.setCarType(CarType.SPORTS_CAR);\n        builder.setSeats(2);\n        builder.setEngine(new Engine(3.0, 0));\n        builder.setTransmission(Transmission.SEMI_AUTOMATIC);\n        builder.setTripComputer(new TripComputer());\n        builder.setGPSNavigator(new GPSNavigator());\n    }\n\n    public void constructCityCar(Builder builder) {\n        builder.setCarType(CarType.CITY_CAR);\n        builder.setSeats(2);\n        builder.setEngine(new Engine(1.2, 0));\n        builder.setTransmission(Transmission.AUTOMATIC);\n        builder.setTripComputer(new TripComputer());\n        builder.setGPSNavigator(new GPSNavigator());\n    }\n\n    public void constructSUV(Builder builder) {\n        builder.setCarType(CarType.SUV);\n        builder.setSeats(4);\n        builder.setEngine(new Engine(2.5, 0));\n        builder.setTransmission(Transmission.MANUAL);\n        builder.setGPSNavigator(new GPSNavigator());\n    }\n}\n",
        "gt": [
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Director/Director.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Client/Test.java'"
        ]
    },
    {
        "files": [
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Client/Test.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Director/Director.java'"
        ],
        "content": "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'\n:package ConcreteBuilder;\n\nimport Builder.Builder;\nimport Components.*;\nimport Product.Manual;\n\npublic class CarManualBuilder implements Builder {\n    private CarType type;\n    private int seats;\n    private Engine engine;\n    private Transmission transmiossion;\n    private TripComputer tripComputer;\n    private GPSNavigator gpsNavigator;\n\n    @Override\n    public void setCarType(CarType type) {\n        this.type = type;\n    }\n\n    @Override\n    public void setSeats(int seat) {\n        this.seats = seat;\n    }\n\n    @Override\n    public void setEngine(Engine engine) {\n        this.engine = engine;\n    }\n\n    @Override\n    public void setTransmission(Transmission transmission) {\n        this.transmiossion = transmiossion;\n    }\n\n    @Override\n    public void setTripComputer(TripComputer tripComputer) {\n        this.tripComputer = tripComputer;\n    }\n\n    @Override\n    public void setGPSNavigator(GPSNavigator gpsNavigator) {\n        this.gpsNavigator = gpsNavigator;\n    }\n\n    public Manual getResult() {\n        return new Manual(type, seats, engine, transmiossion, tripComputer, gpsNavigator);\n    }\n}\n\n'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Client/Test.java'\n:package Client;\n\nimport ConcreteBuilder.CarBuilder;\nimport Director.Director;\nimport Product.Car;\n\npublic class Test {\n    public static void main(String[] args) {\n        Director director = new Director();\n        CarBuilder carBuilder = new CarBuilder();\n        director.constructSportsCar(carBuilder);\n        Car car = carBuilder.getResult();\n        System.out.println(\"Car Built: \" + car.getCarType());\n    }\n}\n\n'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Director/Director.java'\n:package Director;\n\nimport Builder.Builder;\nimport Components.*;\n\npublic class Director {\n    public void constructSportsCar(Builder builder) {\n        builder.setCarType(CarType.SPORTS_CAR);\n        builder.setSeats(2);\n        builder.setEngine(new Engine(3.0, 0));\n        builder.setTransmission(Transmission.SEMI_AUTOMATIC);\n        builder.setTripComputer(new TripComputer());\n        builder.setGPSNavigator(new GPSNavigator());\n    }\n\n    public void constructCityCar(Builder builder) {\n        builder.setCarType(CarType.CITY_CAR);\n        builder.setSeats(2);\n        builder.setEngine(new Engine(1.2, 0));\n        builder.setTransmission(Transmission.AUTOMATIC);\n        builder.setTripComputer(new TripComputer());\n        builder.setGPSNavigator(new GPSNavigator());\n    }\n\n    public void constructSUV(Builder builder) {\n        builder.setCarType(CarType.SUV);\n        builder.setSeats(4);\n        builder.setEngine(new Engine(2.5, 0));\n        builder.setTransmission(Transmission.MANUAL);\n        builder.setGPSNavigator(new GPSNavigator());\n    }\n}\n",
        "gt": [
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/ConcreteBuilder/CarManualBuilder.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Director/Director.java'",
            "'Design-Patterns/Creational/Builder/Java Implementation/BuilderDesignPattern/src/main/java/Client/Test.java'"
        ]
    },
    {
        "files": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/ReadablesMetadata.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleResultImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleR2dbcExceptions.java'"
        ],
        "content": "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/ReadablesMetadata.java'\n:\n\npackage oracle.r2dbc.impl;\n\nimport io.r2dbc.spi.ColumnMetadata;\nimport io.r2dbc.spi.OutParameterMetadata;\nimport io.r2dbc.spi.OutParametersMetadata;\nimport io.r2dbc.spi.ReadableMetadata;\nimport io.r2dbc.spi.RowMetadata;\nimport oracle.jdbc.OracleStruct;\nimport oracle.jdbc.OracleTypeMetaData;\nimport oracle.r2dbc.OracleR2dbcObjectMetadata;\nimport oracle.r2dbc.OracleR2dbcTypes;\n\nimport java.sql.ResultSetMetaData;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\n\nimport static oracle.r2dbc.impl.OracleR2dbcExceptions.fromJdbc;\n\n\nclass ReadablesMetadata<T extends ReadableMetadata> {\n\n\n  private final List<T> metadataList;\n\n\n  private final Map<String, Integer> nameIndexes;\n\n\n  private ReadablesMetadata(T[] metadatas) {\n\n\n\n\n    nameIndexes = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n    for (int i = 0; i < metadatas.length; i++)\n      nameIndexes.putIfAbsent(metadatas[i].getName(), i);\n\n    metadataList = List.of(metadatas);\n  }\n\n\n  static RowMetadataImpl createRowMetadata(\n    ResultSetMetaData resultSetMetaData) {\n    return new RowMetadataImpl(\n      ReadablesMetadata.toColumnMetadata(resultSetMetaData));\n  }\n\n\n  static OracleR2dbcObjectMetadataImpl createAttributeMetadata(\n    OracleStruct oracleStruct) {\n    return fromJdbc(() ->\n      new OracleR2dbcObjectMetadataImpl(\n        OracleR2dbcTypes.objectType(oracleStruct.getSQLTypeName()),\n        ReadablesMetadata.toColumnMetadata(\n          ((OracleTypeMetaData.Struct)oracleStruct.getOracleMetaData())\n            .getMetaData())));\n  }\n\n\n  static OutParametersMetadataImpl createOutParametersMetadata(\n    OutParameterMetadata[] metadata) {\n    return new OutParametersMetadataImpl(metadata);\n  }\n\n\n  private static ColumnMetadata[] toColumnMetadata(\n    ResultSetMetaData resultSetMetaData) {\n\n    int columnCount = fromJdbc(resultSetMetaData::getColumnCount);\n    ColumnMetadata[] columnMetadataArray = new ColumnMetadata[columnCount];\n\n    for (int i = 0; i < columnCount; i++) {\n      columnMetadataArray[i] =\n        OracleReadableMetadataImpl.createColumnMetadata(resultSetMetaData, i);\n    }\n\n    return columnMetadataArray;\n  }\n\n\n  protected final T get(int index) {\n    if (index < 0) {\n      throw new IndexOutOfBoundsException(\"Negative index: \" + index);\n    }\n    else if (index >= metadataList.size()) {\n      throw new IndexOutOfBoundsException(\n        \"Index \" + index + \" exceeds the maximum index: \"\n          + metadataList.size());\n    }\n    else {\n      return metadataList.get(index);\n    }\n  }\n\n\n  protected final T get(String name) {\n    OracleR2dbcExceptions.requireNonNull(name, \"name is null\");\n\n\n    int index = getColumnIndex(name);\n    if (index == -1)\n      throw new NoSuchElementException(\"No column found with name: \" + name);\n\n    return metadataList.get(index);\n  }\n\n\n  protected final List<T> getList() {\n    return metadataList;\n  }\n\n\n  final int getColumnIndex(String name) {\n    Integer index =  nameIndexes.get(name);\n    return index == null ? -1 : index;\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if (!(other instanceof ReadablesMetadata))\n      return super.equals(other);\n\n    ReadablesMetadata<?> otherMetadata = (ReadablesMetadata<?>)other;\n    return metadataList.equals(otherMetadata.metadataList);\n  }\n\n  @Override\n  public int hashCode() {\n    return metadataList.hashCode();\n  }\n\n  static final class RowMetadataImpl\n    extends ReadablesMetadata<ColumnMetadata> implements RowMetadata {\n\n\n    private RowMetadataImpl(ColumnMetadata[] columnMetadata) {\n      super(columnMetadata);\n    }\n\n    @Override\n    public ColumnMetadata getColumnMetadata(int index) {\n      return get(index);\n    }\n\n    @Override\n    public ColumnMetadata getColumnMetadata(String name) {\n      return get(name);\n    }\n\n    @Override\n    public List<? extends ColumnMetadata> getColumnMetadatas() {\n      return getList();\n    }\n\n\n    @Override\n    public boolean contains(String columnName) {\n      return getColumnIndex(columnName) != -1;\n    }\n  }\n\n  static final class OutParametersMetadataImpl\n    extends ReadablesMetadata<OutParameterMetadata>\n    implements OutParametersMetadata {\n\n\n    private OutParametersMetadataImpl(\n      OutParameterMetadata[] columnMetadata) {\n      super(columnMetadata);\n    }\n\n    @Override\n    public OutParameterMetadata getParameterMetadata(int index) {\n      return get(index);\n    }\n\n    @Override\n    public OutParameterMetadata getParameterMetadata(String name) {\n      return get(name);\n    }\n\n    @Override\n    public List<? extends OutParameterMetadata> getParameterMetadatas() {\n      return getList();\n    }\n  }\n\n  static final class OracleR2dbcObjectMetadataImpl\n    extends ReadablesMetadata<ReadableMetadata>\n    implements OracleR2dbcObjectMetadata {\n\n\n    private final OracleR2dbcTypes.ObjectType objectType;\n\n\n    private OracleR2dbcObjectMetadataImpl(\n      OracleR2dbcTypes.ObjectType objectType,\n      ReadableMetadata[] attributeMetadata) {\n      super(attributeMetadata);\n      this.objectType = objectType;\n    }\n\n    @Override\n    public OracleR2dbcTypes.ObjectType getObjectType() {\n      return objectType;\n    }\n\n    @Override\n    public ReadableMetadata getAttributeMetadata(int index) {\n      return get(index);\n    }\n\n    @Override\n    public ReadableMetadata getAttributeMetadata(String name) {\n      return get(name);\n    }\n\n    @Override\n    public List<ReadableMetadata> getAttributeMetadatas() {\n      return getList();\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (!(other instanceof OracleR2dbcObjectMetadata))\n        return false;\n\n      OracleR2dbcObjectMetadata otherMetadata =\n        (OracleR2dbcObjectMetadata) other;\n\n      if (!objectType.equals(otherMetadata.getObjectType()))\n        return false;\n\n      return super.equals(other);\n    }\n  }\n\n}\n",
        "gt": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleR2dbcExceptions.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/ReadablesMetadata.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleResultImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ]
    },
    {
        "files": [
            "'jox/structured/src/test/java/com/softwaremill/jox/structured/ParTest.java'",
            "'jox/structured/src/main/java/com/softwaremill/jox/structured/Scopes.java'",
            "'jox/structured/src/main/java/com/softwaremill/jox/structured/Par.java'"
        ],
        "content": "'jox/structured/src/test/java/com/softwaremill/jox/structured/ParTest.java'\n:package com.softwaremill.jox.structured;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\nimport static com.softwaremill.jox.structured.Par.par;\nimport static com.softwaremill.jox.structured.Par.parLimit;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertIterableEquals;\n\npublic class ParTest {\n    @Test\n    void testParRunsComputationsInParallel() throws Exception {\n        Trail trail = new Trail();\n        var result = par(List.of(() -> {\n            Thread.sleep(200);\n            trail.add(\"a\");\n            return 1;\n        }, () -> {\n            Thread.sleep(100);\n            trail.add(\"b\");\n            return 2;\n        }));\n\n        trail.add(\"done\");\n\n        assertIterableEquals(List.of(1, 2), result);\n        assertIterableEquals(Arrays.asList(\"b\", \"a\", \"done\"), trail.get());\n    }\n\n    @Test\n    void testParInterruptsOtherComputationsIfOneFails() throws InterruptedException {\n        Trail trail = new Trail();\n        try {\n            par(List.of(() -> {\n                Thread.sleep(200);\n                trail.add(\"par 1 done\");\n                return null;\n            }, () -> {\n                Thread.sleep(100);\n                trail.add(\"exception\");\n                throw new Exception(\"boom\");\n            }));\n        } catch (ExecutionException e) {\n            if (e.getCause().getMessage().equals(\"boom\")) {\n                trail.add(\"catch\");\n            }\n        }\n\n\n        Thread.sleep(300);\n        trail.add(\"all done\");\n\n        assertIterableEquals(Arrays.asList(\"exception\", \"catch\", \"all done\"), trail.get());\n    }\n\n    @Test\n    void testParLimitRunsUpToGivenNumberOfComputationsInParallel() throws Exception {\n        AtomicInteger running = new AtomicInteger(0);\n        AtomicInteger max = new AtomicInteger(0);\n        var result = parLimit(2, IntStream.rangeClosed(1, 9).<Callable<Integer>>mapToObj(i -> () -> {\n            int current = running.incrementAndGet();\n            max.updateAndGet(m -> Math.max(current, m));\n            Thread.sleep(100);\n            running.decrementAndGet();\n            return i * 2;\n        }).toList());\n\n        assertIterableEquals(List.of(2, 4, 6, 8, 10, 12, 14, 16, 18), result);\n        assertEquals(2, max.get());\n    }\n\n    @Test\n    void testParLimitInterruptsOtherComputationsIfOneFails() throws InterruptedException {\n        AtomicInteger counter = new AtomicInteger(0);\n        Trail trail = new Trail();\n        try {\n            parLimit(2, IntStream.rangeClosed(1, 5).<Callable<Void>>mapToObj(i -> () -> {\n                if (counter.incrementAndGet() == 4) {\n                    Thread.sleep(10);\n                    trail.add(\"exception\");\n                    throw new Exception(\"boom\");\n                } else {\n                    Thread.sleep(200);\n                    trail.add(\"x\");\n                    return null;\n                }\n            }).toList());\n        } catch (ExecutionException e) {\n            if (e.getCause().getMessage().equals(\"boom\")) {\n                trail.add(\"catch\");\n            }\n        }\n\n        Thread.sleep(300);\n        trail.add(\"all done\");\n\n        assertIterableEquals(Arrays.asList(\"x\", \"x\", \"exception\", \"catch\", \"all done\"), trail.get());\n    }\n}\n\n'jox/structured/src/main/java/com/softwaremill/jox/structured/Scopes.java'\n:package com.softwaremill.jox.structured;\n\nimport java.util.concurrent.ExecutionException;\n\npublic class Scopes {\n\n    public static <T> T unsupervised(ScopedUnsupervised<T> f) throws ExecutionException, InterruptedException {\n        return scopedWithCapability(new Scope(new NoOpSupervisor()), f::run);\n    }\n\n\n    public static <T> T supervised(Scoped<T> f) throws ExecutionException, InterruptedException {\n        var s = new DefaultSupervisor();\n        var capability = new Scope(s);\n        try {\n            var rawScope = capability.getScope();\n            try {\n                try {\n                    var mainBodyFork = capability.forkUser(() -> f.run(capability));\n\n                    s.join();\n\n                    return mainBodyFork.join();\n                } finally {\n                    rawScope.shutdown();\n                    rawScope.join();\n                }\n\n            } finally {\n                rawScope.close();\n            }\n        } catch (Throwable e) {\n\n\n            s.addSuppressedErrors(e);\n            throw e;\n        }\n    }\n\n    static <T> T scopedWithCapability(Scope capability, Scoped<T> f) throws ExecutionException, InterruptedException {\n        var scope = capability.getScope();\n\n        try {\n            try {\n                return f.run(capability);\n            } catch (Exception e) {\n                throw new ExecutionException(e);\n            } finally {\n                scope.shutdown();\n                scope.join();\n            }\n\n        } finally {\n            scope.close();\n        }\n    }\n}\n\n'jox/structured/src/main/java/com/softwaremill/jox/structured/Par.java'\n:package com.softwaremill.jox.structured;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Semaphore;\n\nimport static com.softwaremill.jox.structured.Scopes.supervised;\n\npublic class Par {\n\n    public static <T> List<T> par(List<Callable<T>> fs) throws ExecutionException, InterruptedException {\n        return supervised(scope -> {\n            var forks = fs.stream().map(f -> scope.fork(f)).toList();\n            var results = new ArrayList<T>();\n            for (Fork<T> fork : forks) {\n                results.add(fork.join());\n            }\n            return results;\n        });\n    }\n\n\n    public static <T> List<T> parLimit(int parallelism, List<Callable<T>> fs) throws ExecutionException, InterruptedException {\n        return supervised(scope -> {\n            var s = new Semaphore(parallelism);\n            var forks = fs.stream().map(f -> scope.fork(() -> {\n                s.acquire();\n                var r = f.call();\n\n                s.release();\n                return r;\n            })).toList();\n            var results = new ArrayList<T>();\n            for (Fork<T> fork : forks) {\n                results.add(fork.join());\n            }\n            return results;\n        });\n    }\n}\n",
        "gt": [
            "'jox/structured/src/main/java/com/softwaremill/jox/structured/Scopes.java'",
            "'jox/structured/src/main/java/com/softwaremill/jox/structured/Par.java'",
            "'jox/structured/src/test/java/com/softwaremill/jox/structured/ParTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ]
    },
    {
        "files": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/SqlTypeMap.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableMetadataImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ],
        "content": "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/SqlTypeMap.java'\n:\npackage oracle.r2dbc.impl;\n\nimport io.r2dbc.spi.R2dbcType;\nimport io.r2dbc.spi.Type;\nimport oracle.jdbc.OracleType;\nimport oracle.r2dbc.OracleR2dbcObject;\nimport oracle.r2dbc.OracleR2dbcTypes;\nimport oracle.sql.VECTOR;\nimport oracle.sql.json.OracleJsonObject;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.sql.JDBCType;\nimport java.sql.RowId;\nimport java.sql.SQLException;\nimport java.sql.SQLType;\nimport java.sql.Types;\nimport java.time.Duration;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.OffsetDateTime;\nimport java.time.OffsetTime;\nimport java.time.Period;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport static java.util.Map.entry;\n\n\nfinal class SqlTypeMap {\n\n\n  private static final Map<SQLType, Type> JDBC_TO_R2DBC_TYPE_MAP =\n    Map.ofEntries(\n      entry(JDBCType.ARRAY, R2dbcType.COLLECTION),\n      entry(JDBCType.BIGINT, R2dbcType.BIGINT),\n      entry(JDBCType.BINARY, R2dbcType.BINARY),\n      entry(OracleType.BINARY_DOUBLE, OracleR2dbcTypes.BINARY_DOUBLE),\n      entry(OracleType.BINARY_FLOAT, OracleR2dbcTypes.BINARY_FLOAT),\n      entry(JDBCType.BLOB, R2dbcType.BLOB),\n      entry(JDBCType.BOOLEAN, R2dbcType.BOOLEAN),\n      entry(JDBCType.CHAR, R2dbcType.CHAR),\n      entry(JDBCType.CLOB, R2dbcType.CLOB),\n      entry(JDBCType.DATE, R2dbcType.DATE),\n      entry(JDBCType.DECIMAL, R2dbcType.DECIMAL),\n      entry(JDBCType.DOUBLE, R2dbcType.DOUBLE),\n      entry(JDBCType.FLOAT, R2dbcType.FLOAT),\n      entry(JDBCType.INTEGER, R2dbcType.INTEGER),\n      entry(\n        OracleType.INTERVAL_DAY_TO_SECOND,\n        OracleR2dbcTypes.INTERVAL_DAY_TO_SECOND),\n      entry(\n        OracleType.INTERVAL_YEAR_TO_MONTH,\n        OracleR2dbcTypes.INTERVAL_YEAR_TO_MONTH),\n      entry(OracleType.JSON, OracleR2dbcTypes.JSON),\n      entry(JDBCType.LONGVARBINARY, OracleR2dbcTypes.LONG_RAW),\n      entry(JDBCType.LONGVARCHAR, OracleR2dbcTypes.LONG),\n      entry(JDBCType.NCHAR, R2dbcType.NCHAR),\n      entry(JDBCType.NCLOB, R2dbcType.NCLOB),\n      entry(JDBCType.NUMERIC, R2dbcType.NUMERIC),\n      entry(JDBCType.NVARCHAR, R2dbcType.NVARCHAR),\n      entry(JDBCType.REAL, R2dbcType.REAL),\n      entry(JDBCType.REF_CURSOR, OracleR2dbcTypes.REF_CURSOR),\n      entry(JDBCType.ROWID, OracleR2dbcTypes.ROWID),\n      entry(JDBCType.SMALLINT, R2dbcType.SMALLINT),\n      entry(JDBCType.TIME, R2dbcType.TIME),\n      entry(JDBCType.TIME_WITH_TIMEZONE, R2dbcType.TIME_WITH_TIME_ZONE),\n      entry(JDBCType.TIMESTAMP, R2dbcType.TIMESTAMP),\n      entry(\n        OracleType.TIMESTAMP_WITH_LOCAL_TIME_ZONE,\n        OracleR2dbcTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE),\n      entry(\n\n\n        OracleType.TIMESTAMP_WITH_TIME_ZONE,\n        R2dbcType.TIMESTAMP_WITH_TIME_ZONE),\n      entry(JDBCType.TINYINT, R2dbcType.TINYINT),\n      entry(JDBCType.VARBINARY, R2dbcType.VARBINARY),\n      entry(JDBCType.VARCHAR, R2dbcType.VARCHAR),\n      entry(OracleType.VECTOR, OracleR2dbcTypes.VECTOR)\n    );\n\n\n  private static final Map<Type, SQLType> R2DBC_TO_JDBC_TYPE_MAP =\n\n    JDBC_TO_R2DBC_TYPE_MAP.entrySet().stream()\n      .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n\n\n  private static final Map<Class<?>, SQLType> JAVA_TO_SQL_TYPE_MAP =\n    Map.ofEntries(\n\n      entry(String.class, JDBCType.VARCHAR),\n      entry(Boolean.class, JDBCType.BOOLEAN),\n      entry(ByteBuffer.class, JDBCType.VARBINARY),\n      entry(Integer.class, JDBCType.INTEGER),\n      entry(Byte.class, JDBCType.TINYINT),\n      entry(Short.class, JDBCType.SMALLINT),\n      entry(Long.class, JDBCType.BIGINT),\n      entry(BigDecimal.class, JDBCType.NUMERIC),\n      entry(Float.class, JDBCType.REAL),\n      entry(Double.class, JDBCType.DOUBLE),\n      entry(LocalDate.class, JDBCType.DATE),\n      entry(LocalTime.class, JDBCType.TIME),\n      entry(OffsetTime.class, JDBCType.TIME_WITH_TIMEZONE),\n      entry(LocalDateTime.class, JDBCType.TIMESTAMP),\n      entry(OffsetDateTime.class, JDBCType.TIMESTAMP_WITH_TIMEZONE),\n      entry(io.r2dbc.spi.Blob.class, JDBCType.BLOB),\n      entry(io.r2dbc.spi.Clob.class, JDBCType.CLOB),\n      entry(Object[].class, JDBCType.ARRAY),\n\n\n\n\n\n\n\n      entry(byte[].class, JDBCType.VARBINARY),\n      entry(BigInteger.class, JDBCType.BIGINT),\n      entry(java.sql.Date.class, JDBCType.DATE),\n      entry(java.sql.Time.class, JDBCType.TIME),\n      entry(java.sql.Timestamp.class, JDBCType.TIMESTAMP),\n      entry(java.sql.Array.class, JDBCType.ARRAY),\n      entry(java.sql.Blob.class, JDBCType.BLOB),\n      entry(java.sql.Clob.class, JDBCType.CLOB),\n      entry(java.sql.Struct.class, JDBCType.STRUCT),\n      entry(java.sql.Ref.class, JDBCType.REF),\n      entry(java.net.URL.class, JDBCType.DATALINK),\n      entry(java.sql.RowId.class, JDBCType.ROWID),\n      entry(java.sql.NClob.class, JDBCType.NCLOB),\n      entry(java.sql.SQLXML.class, JDBCType.SQLXML),\n      entry(java.util.Calendar.class, JDBCType.TIMESTAMP),\n      entry(java.util.Date.class, JDBCType.TIMESTAMP),\n\n\n      entry(Duration.class, OracleType.INTERVAL_DAY_TO_SECOND),\n      entry(Period.class, OracleType.INTERVAL_YEAR_TO_MONTH),\n      entry(OracleJsonObject.class, OracleType.JSON),\n\n\n\n\n      entry(boolean[].class, JDBCType.ARRAY),\n\n\n      entry(short[].class, JDBCType.ARRAY),\n      entry(int[].class, JDBCType.ARRAY),\n      entry(long[].class, JDBCType.ARRAY),\n      entry(float[].class, JDBCType.ARRAY),\n      entry(double[].class, JDBCType.ARRAY),\n\n\n\n      entry(Map.class, JDBCType.STRUCT),\n      entry(OracleR2dbcObject.class, JDBCType.STRUCT),\n\n\n      entry(VECTOR.class, OracleType.VECTOR)\n    );\n\n\n  static Type toR2dbcType(SQLType jdbcType) {\n    return JDBC_TO_R2DBC_TYPE_MAP.get(jdbcType);\n  }\n\n\n  static Type toR2dbcType(int jdbcTypeNumber) {\n\n\n    for (JDBCType jdbcType : JDBCType.values()) {\n      Integer vendorTypeNumber = jdbcType.getVendorTypeNumber();\n\n      if (vendorTypeNumber != null && vendorTypeNumber == jdbcTypeNumber)\n        return toR2dbcType(jdbcType);\n    }\n\n\n    try {\n      OracleType oracleType =\n        oracle.jdbc.OracleType.toOracleType(jdbcTypeNumber);\n\n      if (oracleType != null)\n        return toR2dbcType(oracleType);\n      else\n        return null;\n    }\n    catch (SQLException typeNotFound) {\n\n      return null;\n    }\n  }\n\n\n  static SQLType toJdbcType(Type r2dbcType) {\n    if (r2dbcType instanceof Type.InferredType)\n      return toJdbcType(r2dbcType.getJavaType());\n    else if (r2dbcType instanceof OracleR2dbcTypes.ArrayType)\n      return JDBCType.ARRAY;\n    else if (r2dbcType instanceof OracleR2dbcTypes.ObjectType)\n      return JDBCType.STRUCT;\n    else\n      return R2DBC_TO_JDBC_TYPE_MAP.get(r2dbcType);\n  }\n\n\n  static SQLType toJdbcType(Class<?> javaType) {\n    SQLType sqlType = JAVA_TO_SQL_TYPE_MAP.get(javaType);\n\n    if (sqlType != null) {\n      return sqlType;\n    }\n    else {\n\n      return JAVA_TO_SQL_TYPE_MAP.entrySet()\n        .stream()\n        .filter(entry -> entry.getKey().isAssignableFrom(javaType))\n        .map(Map.Entry::getValue)\n        .findFirst()\n        .orElse(null);\n    }\n  }\n}\n",
        "gt": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/SqlTypeMap.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableMetadataImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ]
    },
    {
        "files": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleR2dbcExceptions.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ],
        "content": "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleR2dbcExceptions.java'\n:\n\npackage oracle.r2dbc.impl;\n\nimport io.r2dbc.spi.R2dbcBadGrammarException;\nimport io.r2dbc.spi.R2dbcDataIntegrityViolationException;\nimport io.r2dbc.spi.R2dbcException;\nimport io.r2dbc.spi.R2dbcNonTransientException;\nimport io.r2dbc.spi.R2dbcNonTransientResourceException;\nimport io.r2dbc.spi.R2dbcRollbackException;\nimport io.r2dbc.spi.R2dbcTimeoutException;\nimport io.r2dbc.spi.R2dbcTransientException;\nimport io.r2dbc.spi.R2dbcTransientResourceException;\nimport oracle.jdbc.OracleDatabaseException;\n\nimport java.sql.SQLException;\nimport java.sql.SQLIntegrityConstraintViolationException;\nimport java.sql.SQLNonTransientConnectionException;\nimport java.sql.SQLNonTransientException;\nimport java.sql.SQLRecoverableException;\nimport java.sql.SQLSyntaxErrorException;\nimport java.sql.SQLTimeoutException;\nimport java.sql.SQLTransactionRollbackException;\nimport java.sql.SQLTransientConnectionException;\nimport java.sql.SQLTransientException;\nimport java.util.function.Supplier;\n\n\nfinal class OracleR2dbcExceptions {\n\n\n  private OracleR2dbcExceptions() { }\n\n\n  static <T> T requireNonNull(T obj, String message) {\n    if (obj == null)\n      throw new IllegalArgumentException(message);\n    else\n      return obj;\n  }\n\n\n\n  static void requireOpenConnection(java.sql.Connection jdbcConnection) {\n    if (fromJdbc(jdbcConnection::isClosed))\n      throw new IllegalStateException(\"Connection is closed\");\n  }\n\n\n  static R2dbcException toR2dbcException(SQLException sqlException) {\n    return toR2dbcException(sqlException, getSql(sqlException));\n  }\n\n\n  static R2dbcException toR2dbcException(\n    SQLException sqlException, String sql) {\n    assert sqlException != null : \"sqlException is null\";\n\n    final String message = sqlException.getMessage();\n    final String sqlState = sqlException.getSQLState();\n    final int errorCode = sqlException.getErrorCode();\n\n    if (sqlException instanceof SQLNonTransientException) {\n      if (sqlException instanceof SQLSyntaxErrorException) {\n        return new R2dbcBadGrammarException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else if (sqlException instanceof SQLIntegrityConstraintViolationException) {\n        return new R2dbcDataIntegrityViolationException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else if (sqlException instanceof SQLNonTransientConnectionException) {\n        return new R2dbcNonTransientResourceException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else {\n        return new OracleR2dbcNonTransientException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n    }\n    else if (sqlException instanceof SQLTransientException) {\n      if (sqlException instanceof SQLTimeoutException) {\n        return new R2dbcTimeoutException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else if (sqlException instanceof SQLTransactionRollbackException) {\n        return new R2dbcRollbackException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else if (sqlException instanceof SQLTransientConnectionException) {\n        return new R2dbcTransientResourceException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n      else {\n        return new OracleR2dbcTransientException(\n          message, sqlState, errorCode, sql, sqlException);\n      }\n    }\n    else if (sqlException instanceof SQLRecoverableException) {\n\n\n\n\n      return new R2dbcTransientResourceException(\n        message, sqlState, errorCode, sql, sqlException);\n    }\n    else {\n      return new OracleR2dbcException(\n        message, sqlState, errorCode, sql, sqlException);\n    }\n  }\n\n\n  static void runJdbc(JdbcRunnable runnable)\n    throws R2dbcException {\n    try {\n      runnable.runOrThrow();\n    }\n    catch (SQLException sqlException) {\n      throw toR2dbcException(sqlException);\n    }\n  }\n\n\n  static <T> T fromJdbc(JdbcSupplier<T> supplier)\n    throws R2dbcException {\n    try {\n      return supplier.getOrThrow();\n    }\n    catch (SQLException sqlException) {\n      throw toR2dbcException(sqlException);\n    }\n  }\n\n\n  static R2dbcNonTransientException newNonTransientException(\n    String message, String sql, Throwable cause) {\n    return new OracleR2dbcNonTransientException(message, null, 0, sql, cause);\n  }\n\n\n  private static String getSql(SQLException sqlException) {\n    Throwable cause = sqlException.getCause();\n\n    while (cause != null) {\n\n      if (cause instanceof OracleDatabaseException)\n        return ((OracleDatabaseException)cause).getSql();\n\n      cause = cause.getCause();\n    }\n\n    return null;\n  }\n\n\n  @FunctionalInterface\n  interface JdbcRunnable extends Runnable {\n\n    void runOrThrow() throws SQLException;\n\n\n    @Override\n    default void run() throws R2dbcException {\n      runJdbc(this);\n    }\n  }\n\n\n  @FunctionalInterface\n  interface JdbcSupplier<T> extends Supplier<T> {\n\n    T getOrThrow() throws SQLException;\n\n\n    @Override\n    default T get() throws R2dbcException {\n      return fromJdbc(this);\n    }\n  }\n\n\n  private static final class OracleR2dbcException\n    extends R2dbcException {\n    private OracleR2dbcException(\n      String message, String sqlState, int errorCode, String sql,\n      SQLException sqlException) {\n      super(message, sqlState, errorCode, sql, sqlException);\n    }\n  }\n\n\n  private static final class OracleR2dbcTransientException\n    extends R2dbcTransientException {\n    private OracleR2dbcTransientException(\n      String message, String sqlState, int errorCode, String sql,\n      SQLException sqlException) {\n      super(message, sqlState, errorCode, sql, sqlException);\n    }\n  }\n\n\n  private static final class OracleR2dbcNonTransientException\n    extends R2dbcNonTransientException {\n    private OracleR2dbcNonTransientException(\n      String message, String sqlState, int errorCode, String sql,\n      Throwable cause) {\n      super(message, sqlState, errorCode, sql, cause);\n    }\n  }\n\n}\n",
        "gt": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleR2dbcExceptions.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ]
    },
    {
        "files": [
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsTest.java'",
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'"
        ],
        "content": "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'\n:package com.tjeannin.provigen.test.constraint;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport com.tjeannin.provigen.ProviGenBaseContract;\nimport com.tjeannin.provigen.ProviGenProvider;\nimport com.tjeannin.provigen.annotation.Column;\nimport com.tjeannin.provigen.annotation.Column.Type;\nimport com.tjeannin.provigen.annotation.ContentUri;\nimport com.tjeannin.provigen.helper.TableBuilder;\nimport com.tjeannin.provigen.model.Constraint;\nimport com.tjeannin.provigen.model.Constraint.OnConflict;\n\npublic class ConstraintsProvider extends ProviGenProvider {\n\n    @Override\n    public SQLiteOpenHelper openHelper(final Context context) {\n        return new SQLiteOpenHelper(context, \"ProviGenDatabase\", null, 1) {\n            @Override\n            public void onCreate(SQLiteDatabase database) {\n                new TableBuilder(NotNullContract.class)\n                        .addConstraint(NotNullContract.AN_INT, Constraint.NOT_NULL, OnConflict.ABORT)\n                        .createTable(database);\n\n                new TableBuilder(UniqueContract.class)\n                        .addConstraint(UniqueContract.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n\n                new TableBuilder(UniqueAndNotNullContract.class)\n                        .addConstraint(UniqueAndNotNullContract.AN_INT, Constraint.NOT_NULL, OnConflict.ABORT)\n                        .addConstraint(UniqueAndNotNullContract.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n            }\n\n            @Override\n            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n            }\n        };\n    }\n\n    @Override\n    public Class[] contractClasses() {\n        return new Class[]{NotNullContract.class, UniqueContract.class, UniqueAndNotNullContract.class};\n    }\n\n\n    public static interface NotNullContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n\n    public static interface UniqueContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n\n    public static interface UniqueAndNotNullContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n}\n",
        "gt": [
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsTest.java'"
        ]
    },
    {
        "files": [
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/statements/StatementWrapper.java'",
            "'Achilles/achilles-core/src/test/java/info/archinnov/achilles/internals/sample_classes/functions/TestFunctionRegistryWithOpsCenterKeyspaceName.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/cql/TypeMapper.java'"
        ],
        "content": "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/statements/StatementWrapper.java'\n:\n\npackage info.archinnov.achilles.internals.statements;\n\nimport static info.archinnov.achilles.internals.cql.TypeMapper.toJavaType;\nimport static info.archinnov.achilles.internals.utils.LoggerHelper.replaceByteBuffersByHexString;\nimport static java.lang.String.format;\n\nimport java.util.*;\nimport java.util.stream.IntStream;\n\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.datastax.driver.core.*;\nimport com.datastax.driver.core.exceptions.TraceRetrievalException;\n\nimport info.archinnov.achilles.internals.options.CassandraOptions;\nimport info.archinnov.achilles.internals.types.ResultSetWrapper;\nimport info.archinnov.achilles.logger.AchillesLoggers;\n\npublic interface StatementWrapper {\n    Logger LOGGER = LoggerFactory.getLogger(StatementWrapper.class);\n\n    EventComparator EVENT_TRACE_COMPARATOR = new EventComparator();\n    Logger DML_LOGGER = LoggerFactory.getLogger(AchillesLoggers.ACHILLES_DML_STATEMENT);\n\n    Object[] getBoundValues();\n\n    BoundStatement getBoundStatement();\n\n    void applyOptions(CassandraOptions cassandraOptions);\n\n    void logDML();\n\n    ResultSet logReturnResults(ResultSet resultSet, int maxDisplayedRows);\n\n    Row logReturnedRow(Row row);\n\n    ResultSet logTrace(ResultSet resultSet);\n\n    default void writeDMLStatementLog(Logger actualLogger, UUID queryId, String queryString, ConsistencyLevel consistencyLevel, Object[] boundValues, Object[] encodedValues) {\n        if (actualLogger.isDebugEnabled()) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(format(\"Writing DML log for query %s with id %s\", queryString, queryId));\n            }\n            StringBuilder logBuilder = new StringBuilder(\"\\n\");\n            logBuilder.append(String.format(\"Query ID %s : [%s] with CONSISTENCY LEVEL [%s]\",\n                    queryId.toString(), queryString, consistencyLevel));\n            if (ArrayUtils.isNotEmpty(boundValues)) {\n                logBuilder.append(String.format(\"\\n\\t Java bound values : %s\", replaceByteBuffersByHexString(boundValues)));\n                logBuilder.append(String.format(\"\\n\\t Encoded bound values : %s\", replaceByteBuffersByHexString(encodedValues)));\n            }\n            actualLogger.debug(logBuilder.toString());\n        }\n    }\n\n    default void logReturnedResultsInternal(Logger actualLogger, UUID queryId, ResultSetWrapper resultSet, int maxDisplayedRows) {\n        if (maxDisplayedRows > 0) {\n            final int availableWithoutFetching = resultSet.getAvailableWithoutFetching();\n            StringBuilder results = new StringBuilder(format(\"Query ID %s results : \\n\", queryId));\n            actualLogger.debug(resultSet.toString());\n            for (int i = 0; i < Integer.min(availableWithoutFetching, maxDisplayedRows); i++) {\n                final Row row = resultSet.peek();\n                appendRowDataToBuilder(row, row.getColumnDefinitions().asList(), results);\n            }\n            actualLogger.debug(results.toString());\n        }\n    }\n\n    default void logReturnedRowInternal(Logger actualLogger, UUID queryId, Row row) {\n        StringBuilder results = new StringBuilder(format(\"Query ID %s row : \\n\", queryId));\n        appendRowDataToBuilder(row, row.getColumnDefinitions().asList(), results);\n        actualLogger.debug(results.toString());\n    }\n\n    default void appendRowDataToBuilder(Row row, List<ColumnDefinitions.Definition> columnsDef, StringBuilder builder) {\n        StringJoiner joiner = new StringJoiner(\", \", \"\\t\", \"\\n\");\n        IntStream.range(0, columnsDef.size())\n                .forEach(index -> {\n                    final ColumnDefinitions.Definition def = columnsDef.get(index);\n                    final Object value = extractValueFromRow(row, index, def.getType());\n                    joiner.add(format(\"%s: %s\", def.getName(), value));\n                });\n        builder.append(joiner.toString());\n    }\n\n    default Object extractValueFromRow(Row row, int index, DataType dataType) {\n        final DataType.Name typeName = dataType.getName();\n        switch (typeName) {\n            case LIST:\n            case SET:\n            case MAP:\n            case TUPLE:\n            case CUSTOM:\n                return row.getObject(index);\n            default:\n                return row.get(index, toJavaType(typeName));\n        }\n    }\n\n    default void tracingInternal(Logger actualLogger, UUID queryId, ResultSet resultSet) {\n        StringBuilder trace = new StringBuilder();\n        if (actualLogger.isTraceEnabled()) {\n            for (ExecutionInfo executionInfo : resultSet.getAllExecutionInfo()) {\n\n                trace.append(format(\"\\n\\nTracing for Query ID %s at host %s with achieved consistency level %s \\n\", queryId.toString(), executionInfo.getQueriedHost(), executionInfo.getAchievedConsistencyLevel()));\n                trace.append(\"****************************\\n\");\n                trace.append(format(\"%1$-80s | %2$-16s | %3$-24s | %4$-20s\\n\", \"Description\", \"Source\", \"Source elapsed in micros\", \"Thread name\"));\n                try {\n                    final QueryTrace queryTrace = executionInfo.getQueryTrace();\n                    if (queryTrace != null) {\n                        final List<QueryTrace.Event> events = new ArrayList<>(queryTrace.getEvents());\n                        Collections.sort(events, EVENT_TRACE_COMPARATOR);\n                        for (QueryTrace.Event event : events) {\n                            trace.append(format(\"%1$-80s | %2$-16s | %3$-24s | %4$-20s\\n\", event.getDescription(), event.getSource(), event.getSourceElapsedMicros(), event.getThreadName()));\n                        }\n                    }\n                } catch (TraceRetrievalException e) {\n                    final String queryString = getBoundStatement().preparedStatement().getQueryString();\n                    trace.append(format(\" ERROR: cannot retrieve trace for query %s because it may not be yet available\", queryString));\n                }\n                trace.append(\"****************************\\n\\n\");\n            }\n\n            actualLogger.trace(trace.toString());\n        }\n    }\n\n    class EventComparator implements Comparator<QueryTrace.Event> {\n        @Override\n        public int compare(QueryTrace.Event event1, QueryTrace.Event event2) {\n            return event1.getSource().toString().compareTo(event2.getSource().toString());\n        }\n    }\n}\n\n'Achilles/achilles-core/src/test/java/info/archinnov/achilles/internals/sample_classes/functions/TestFunctionRegistryWithOpsCenterKeyspaceName.java'\n:\n\npackage info.archinnov.achilles.internals.sample_classes.functions;\n\nimport info.archinnov.achilles.annotations.FunctionRegistry;\n\n@FunctionRegistry(keyspace = \"\\\"OpsCenter\\\"\")\npublic interface TestFunctionRegistryWithOpsCenterKeyspaceName {\n\n    String opsCenterKeyspaceName(int val);\n}\n",
        "gt": [
            "'Achilles/achilles-core/src/test/java/info/archinnov/achilles/internals/sample_classes/functions/TestFunctionRegistryWithOpsCenterKeyspaceName.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/cql/TypeMapper.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/statements/StatementWrapper.java'"
        ]
    },
    {
        "files": [
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'"
        ],
        "content": "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'\n:package com.hitherejoe.bourboncorecommon.ui.shot;\n\nimport com.hitherejoe.bourboncorecommon.data.DataManager;\nimport com.hitherejoe.bourboncorecommon.data.model.Comment;\nimport com.hitherejoe.bourboncorecommon.util.RxSchedulersOverrideRule;\nimport com.hitherejoe.bourboncorecommon.util.TestDataFactory;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport rx.Single;\n\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ShotPresenterTest {\n\n    @Mock\n    ShotMvpView mMockShotMvpView;\n    @Mock\n    DataManager mMockDataManager;\n    private ShotPresenter mShotPresenter;\n\n    @Rule\n    public final RxSchedulersOverrideRule mOverrideSchedulersRule = new RxSchedulersOverrideRule();\n\n    @Before\n    public void setUp() {\n        mShotPresenter = new ShotPresenter(mMockDataManager);\n        mShotPresenter.attachView(mMockShotMvpView);\n    }\n\n    @After\n    public void detachView() {\n        mShotPresenter.detachView();\n    }\n\n    @Test\n    public void getCommentsSuccessful() {\n        List<Comment> comments = TestDataFactory.makeComments(5);\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showComments(comments);\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsEmpty() {\n        List<Comment> comments = new ArrayList<>();\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showEmptyComments();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsFailure() {\n        stubDataManagerGetComments(Single.<List<Comment>>error(new RuntimeException()));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showError();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    private void stubDataManagerGetComments(Single<List<Comment>> single) {\n        when(mMockDataManager.getComments(anyInt(), anyInt(), anyInt())).thenReturn(single);\n    }\n\n}\n'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'\n:package com.hitherejoe.androidtestcommon.util;\n\nimport android.text.TextUtils;\nimport android.view.View;\n\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.TypeSafeMatcher;\n\nimport static android.support.test.espresso.intent.Checks.checkArgument;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDescendantOfA;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.hamcrest.core.AllOf.allOf;\n\npublic class CustomMatchers {\n\n    public static Matcher<View> withItemText(final String itemText, final int parentId) {\n        checkArgument(!TextUtils.isEmpty(itemText), \"itemText cannot be null or empty\");\n        return new TypeSafeMatcher<View>() {\n            @Override\n            public boolean matchesSafely(View item) {\n                return allOf(isDescendantOfA(withId(parentId)),\n                        withText(itemText)).matches(item);\n            }\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"is isDescendantOfA RecyclerView with text \" + itemText);\n            }\n        };\n    }\n\n}\n\n'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'\n:package com.hitherejoe.bourboncorecommon.injection;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport javax.inject.Qualifier;\n\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ApplicationContext {\n\n}",
        "gt": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.avro.AvroSchemaVisitor;\nimport com.netflix.iceberg.avro.ValueWriter;\nimport com.netflix.iceberg.avro.ValueWriters;\nimport com.netflix.iceberg.types.Type;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.types.DataType;\nimport java.io.IOException;\nimport java.util.List;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getFieldId;\nimport static com.netflix.iceberg.avro.AvroSchemaVisitor.visit;\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\npublic class SparkAvroWriter implements DatumWriter<InternalRow> {\n  private final com.netflix.iceberg.Schema schema;\n  private ValueWriter<InternalRow> writer = null;\n\n  public SparkAvroWriter(com.netflix.iceberg.Schema schema) {\n    this.schema = schema;\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void setSchema(Schema schema) {\n    this.writer = (ValueWriter<InternalRow>) visit(schema, new WriteBuilder(this.schema));\n  }\n\n  @Override\n  public void write(InternalRow datum, Encoder out) throws IOException {\n    writer.write(datum, out);\n  }\n\n  private static class WriteBuilder extends AvroSchemaVisitor<ValueWriter<?>> {\n    private final com.netflix.iceberg.Schema schema;\n\n    private WriteBuilder(com.netflix.iceberg.Schema schema) {\n      this.schema = schema;\n    }\n\n    @Override\n    public ValueWriter<?> record(Schema record, List<String> names, List<ValueWriter<?>> fields) {\n      List<DataType> types = Lists.newArrayList();\n      for (Schema.Field field : record.getFields()) {\n        types.add(convert(schema.findType(getFieldId(field))));\n      }\n      return SparkValueWriters.struct(fields, types);\n    }\n\n    @Override\n    public ValueWriter<?> union(Schema union, List<ValueWriter<?>> options) {\n      Preconditions.checkArgument(options.contains(ValueWriters.nulls()),\n          \"Cannot create writer for non-option union: \" + union);\n      Preconditions.checkArgument(options.size() == 2,\n          \"Cannot create writer for non-option union: \" + union);\n      if (union.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return ValueWriters.option(0, options.get(1));\n      } else {\n        return ValueWriters.option(1, options.get(0));\n      }\n    }\n\n    @Override\n    public ValueWriter<?> array(Schema array, ValueWriter<?> elementWriter) {\n      LogicalType logical = array.getLogicalType();\n      if (logical != null && \"map\".equals(logical.getName())) {\n        Type keyType = schema.findType(getFieldId(array.getElementType().getField(\"key\")));\n        Type valueType = schema.findType(getFieldId(array.getElementType().getField(\"value\")));\n        ValueWriter<?>[] writers = ((SparkValueWriters.StructWriter) elementWriter).writers;\n        return SparkValueWriters.arrayMap(\n            writers[0], convert(keyType), writers[1], convert(valueType));\n      }\n\n      Type elementType = schema.findType(AvroSchemaUtil.getElementId(array));\n      return SparkValueWriters.array(elementWriter, convert(elementType));\n    }\n\n    @Override\n    public ValueWriter<?> map(Schema map, ValueWriter<?> valueReader) {\n      Type keyType = schema.findType(AvroSchemaUtil.getKeyId(map));\n      Type valueType = schema.findType(AvroSchemaUtil.getValueId(map));\n      return SparkValueWriters.map(\n          SparkValueWriters.strings(), convert(keyType), valueReader, convert(valueType));\n    }\n\n    @Override\n    public ValueWriter<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n\n            return ValueWriters.ints();\n\n          case \"timestamp-micros\":\n\n            return ValueWriters.longs();\n\n          case \"decimal\":\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueWriters.decimal(decimal.getPrecision(), decimal.getScale());\n\n          case \"uuid\":\n            return ValueWriters.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unsupported logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueWriters.nulls();\n        case BOOLEAN:\n          return ValueWriters.booleans();\n        case INT:\n          return ValueWriters.ints();\n        case LONG:\n          return ValueWriters.longs();\n        case FLOAT:\n          return ValueWriters.floats();\n        case DOUBLE:\n          return ValueWriters.doubles();\n        case STRING:\n          return SparkValueWriters.strings();\n        case FIXED:\n          return ValueWriters.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueWriters.bytes();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'"
        ]
    },
    {
        "files": [
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'"
        ],
        "content": "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'\n:package com.hitherejoe.bourboncorecommon.ui.shot;\n\nimport com.hitherejoe.bourboncorecommon.data.DataManager;\nimport com.hitherejoe.bourboncorecommon.data.model.Comment;\nimport com.hitherejoe.bourboncorecommon.util.RxSchedulersOverrideRule;\nimport com.hitherejoe.bourboncorecommon.util.TestDataFactory;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport rx.Single;\n\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ShotPresenterTest {\n\n    @Mock\n    ShotMvpView mMockShotMvpView;\n    @Mock\n    DataManager mMockDataManager;\n    private ShotPresenter mShotPresenter;\n\n    @Rule\n    public final RxSchedulersOverrideRule mOverrideSchedulersRule = new RxSchedulersOverrideRule();\n\n    @Before\n    public void setUp() {\n        mShotPresenter = new ShotPresenter(mMockDataManager);\n        mShotPresenter.attachView(mMockShotMvpView);\n    }\n\n    @After\n    public void detachView() {\n        mShotPresenter.detachView();\n    }\n\n    @Test\n    public void getCommentsSuccessful() {\n        List<Comment> comments = TestDataFactory.makeComments(5);\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showComments(comments);\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsEmpty() {\n        List<Comment> comments = new ArrayList<>();\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showEmptyComments();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsFailure() {\n        stubDataManagerGetComments(Single.<List<Comment>>error(new RuntimeException()));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showError();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    private void stubDataManagerGetComments(Single<List<Comment>> single) {\n        when(mMockDataManager.getComments(anyInt(), anyInt(), anyInt())).thenReturn(single);\n    }\n\n}\n'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'\n:package com.hitherejoe.androidtestcommon.util;\n\nimport android.text.TextUtils;\nimport android.view.View;\n\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.TypeSafeMatcher;\n\nimport static android.support.test.espresso.intent.Checks.checkArgument;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDescendantOfA;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.hamcrest.core.AllOf.allOf;\n\npublic class CustomMatchers {\n\n    public static Matcher<View> withItemText(final String itemText, final int parentId) {\n        checkArgument(!TextUtils.isEmpty(itemText), \"itemText cannot be null or empty\");\n        return new TypeSafeMatcher<View>() {\n            @Override\n            public boolean matchesSafely(View item) {\n                return allOf(isDescendantOfA(withId(parentId)),\n                        withText(itemText)).matches(item);\n            }\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"is isDescendantOfA RecyclerView with text \" + itemText);\n            }\n        };\n    }\n\n}\n\n'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'\n:package com.hitherejoe.bourboncorecommon.injection;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport javax.inject.Qualifier;\n\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ApplicationContext {\n\n}",
        "gt": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'WorldGuard/worldguard-bukkit/src/main/java/com/sk89q/worldguard/bukkit/util/Events.java'",
            "'WorldGuard/worldguard-bukkit/src/main/java/com/sk89q/worldguard/bukkit/ProtectionQuery.java'",
            "'WorldGuard/worldguard-core/src/main/java/com/sk89q/worldguard/blacklist/TrackedEvent.java'"
        ],
        "content": "'WorldGuard/worldguard-bukkit/src/main/java/com/sk89q/worldguard/bukkit/util/Events.java'\n:\n\npackage com.sk89q.worldguard.bukkit.util;\n\nimport com.sk89q.worldguard.bukkit.event.BulkEvent;\nimport org.bukkit.Bukkit;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.LivingEntity;\nimport org.bukkit.event.Cancellable;\nimport org.bukkit.event.Event;\nimport org.bukkit.event.Event.Result;\nimport org.bukkit.event.entity.EntityDamageEvent.DamageCause;\nimport org.bukkit.event.player.PlayerInteractEvent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\n\npublic final class Events {\n\n    private Events() {\n    }\n\n\n    public static void fire(Event event) {\n        checkNotNull(event);\n        Bukkit.getServer().getPluginManager().callEvent(event);\n    }\n\n\n    public static <T extends Event & Cancellable> boolean fireAndTestCancel(T eventToFire) {\n        Bukkit.getServer().getPluginManager().callEvent(eventToFire);\n        return eventToFire.isCancelled();\n    }\n\n\n    public static <T extends Event & Cancellable> boolean fireToCancel(Cancellable original, T eventToFire) {\n        Bukkit.getServer().getPluginManager().callEvent(eventToFire);\n        if (eventToFire.isCancelled()) {\n            original.setCancelled(true);\n            return true;\n        }\n\n        return false;\n    }\n\n\n    public static <T extends Event & Cancellable> boolean fireItemEventToCancel(PlayerInteractEvent original, T eventToFire) {\n        Bukkit.getServer().getPluginManager().callEvent(eventToFire);\n        if (eventToFire.isCancelled()) {\n            original.setUseItemInHand(Result.DENY);\n            return true;\n        }\n\n        return false;\n    }\n\n\n    public static <T extends Event & Cancellable & BulkEvent> boolean fireBulkEventToCancel(Cancellable original, T eventToFire) {\n        Bukkit.getServer().getPluginManager().callEvent(eventToFire);\n        if (eventToFire.getExplicitResult() == Result.DENY) {\n            original.setCancelled(true);\n            return true;\n        }\n\n        return false;\n    }\n\n\n    public static boolean isFireCause(DamageCause cause) {\n        return cause == DamageCause.FIRE || cause == DamageCause.FIRE_TICK;\n    }\n\n\n    public static boolean isExplosionCause(DamageCause cause) {\n        return cause == DamageCause.BLOCK_EXPLOSION || cause == DamageCause.ENTITY_EXPLOSION;\n    }\n\n\n    public static void restoreStatistic(Entity entity, DamageCause cause) {\n        if (cause == DamageCause.DROWNING && entity instanceof LivingEntity) {\n            LivingEntity living = (LivingEntity) entity;\n            living.setRemainingAir(living.getMaximumAir());\n        }\n\n        if (isFireCause(cause)) {\n            entity.setFireTicks(0);\n        }\n\n        if (cause == DamageCause.LAVA) {\n            entity.setFireTicks(0);\n        }\n    }\n}\n",
        "gt": [
            "'WorldGuard/worldguard-core/src/main/java/com/sk89q/worldguard/blacklist/TrackedEvent.java'",
            "'WorldGuard/worldguard-bukkit/src/main/java/com/sk89q/worldguard/bukkit/util/Events.java'",
            "'WorldGuard/worldguard-bukkit/src/main/java/com/sk89q/worldguard/bukkit/ProtectionQuery.java'"
        ]
    },
    {
        "files": [
            "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/server/EndpointServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/ServiceContext.java'",
            "'qbit/qbit/vertx/src/test/java/io/advantageous/qbit/vertx/VertxRESTIntegrationTest.java'"
        ],
        "content": "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'\n:package io.advantageous.qbit.vertx.http;\n\nimport io.advantageous.qbit.http.server.HttpServer;\nimport io.advantageous.qbit.http.server.HttpServerBuilder;\nimport io.advantageous.qbit.vertx.http.server.HttpServerVertx;\nimport io.advantageous.qbit.vertx.http.server.SimpleVertxHttpServerWrapper;\nimport io.vertx.core.Vertx;\nimport io.vertx.ext.web.Route;\nimport io.vertx.ext.web.Router;\n\n\n\npublic class VertxHttpServerBuilder extends HttpServerBuilder {\n\n\n\n    private Vertx vertx;\n\n\n    private Router router;\n\n\n    private io.vertx.core.http.HttpServer vertxHttpServer;\n\n\n    private boolean startedVertx;\n\n\n    private Route route;\n\n    public static VertxHttpServerBuilder vertxHttpServerBuilder() {\n        return new VertxHttpServerBuilder();\n    }\n\n    public Router getRouter() {\n        return router;\n    }\n\n    public VertxHttpServerBuilder setRouter(final Router router) {\n        this.router = router;\n        return this;\n    }\n\n\n    public Route getRoute() {\n        return route;\n    }\n\n    public VertxHttpServerBuilder setRoute(final Route route) {\n        this.route = route;\n        return this;\n    }\n\n    public Vertx getVertx() {\n        if (vertx == null) {\n            startedVertx = true;\n            vertx = Vertx.vertx();\n        }\n        return vertx;\n    }\n\n    public VertxHttpServerBuilder setVertx(final Vertx vertx) {\n        this.vertx = vertx;\n        return this;\n    }\n\n\n    public io.vertx.core.http.HttpServer getHttpServer() {\n        return vertxHttpServer;\n    }\n\n    public VertxHttpServerBuilder setHttpServer(final io.vertx.core.http.HttpServer httpServer) {\n        this.vertxHttpServer = httpServer;\n        return this;\n    }\n\n    public HttpServer build() {\n\n\n        HttpServer httpServer;\n\n\n\n        if (vertxHttpServer == null) {\n\n            if (this.getRoute() != null) {\n                throw new IllegalArgumentException(\"You can't pass a route if you don't pass an httpServer\");\n            }\n\n            if (this.getRouter() != null) {\n                throw new IllegalArgumentException(\"You can't pass a router if you don't pass an httpServer\");\n            }\n\n            httpServer = new HttpServerVertx(startedVertx, this.getVertx(), getEndpointName(), getConfig(),\n                    getSystemManager(), getServiceDiscovery(), getHealthServiceAsync(),\n                    getServiceDiscoveryTtl(), getServiceDiscoveryTtlTimeUnit(), getResponseDecorators(),\n                    getHttpResponseCreator(), getRequestBodyContinuePredicate());\n        } else {\n\n\n            if (vertx == null) {\n                throw new IllegalArgumentException(\"You can't pass a httpServer and not pass a vertx object\");\n            }\n            httpServer = new SimpleVertxHttpServerWrapper(getHttpServer(), getRouter(), getRoute(),\n                    super.getConfig().getFlushInterval(), this.getEndpointName(),\n                    this.getVertx(), this.getSystemManager(),\n                    this.getServiceDiscovery(), this.getHealthServiceAsync(), getServiceDiscoveryTtl(),\n                    getServiceDiscoveryTtlTimeUnit(), getResponseDecorators(), getHttpResponseCreator(),\n                    getRequestBodyContinuePredicate());\n        }\n\n        if (this.getRequestContinuePredicate() != null) {\n            httpServer.setShouldContinueHttpRequest(this.getRequestContinuePredicate());\n        }\n\n        if (getSystemManager() != null) {\n            getSystemManager().registerServer(httpServer);\n        }\n        return httpServer;\n    }\n}\n",
        "gt": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/ServiceContext.java'",
            "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpServerBuilder.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/server/EndpointServerBuilder.java'",
            "'qbit/qbit/vertx/src/test/java/io/advantageous/qbit/vertx/VertxRESTIntegrationTest.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'"
        ],
        "content": "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Lists;\nimport com.google.common.io.Files;\nimport com.netflix.iceberg.types.Types;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.Files.localInput;\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\npublic class TableTestBase {\n\n  static final Schema SCHEMA = new Schema(\n      required(3, \"id\", Types.IntegerType.get()),\n      required(4, \"data\", Types.StringType.get())\n  );\n\n\n  static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA)\n      .bucket(\"data\", 16)\n      .build();\n\n  static final DataFile FILE_A = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-a.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=0\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_B = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-b.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=1\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_C = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-c.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=2\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_D = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-d.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=3\")\n      .withRecordCount(0)\n      .build();\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();\n\n  File tableDir = null;\n  File metadataDir = null;\n  TestTables.TestTable table = null;\n\n  @Before\n  public void setupTable() throws Exception {\n    this.tableDir = temp.newFolder();\n    tableDir.delete();\n\n    this.metadataDir = new File(tableDir, \"metadata\");\n    this.table = create(SCHEMA, SPEC);\n  }\n\n  @After\n  public void cleanupTables() {\n    TestTables.clearTables();\n  }\n\n  List<File> listManifestFiles() {\n    return listManifestFiles(tableDir);\n  }\n\n  List<File> listManifestFiles(File tableDir) {\n    return Lists.newArrayList(new File(tableDir, \"metadata\").listFiles((dir, name) ->\n        !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n  }\n\n  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n    return TestTables.create(tableDir, \"test\", schema, spec);\n  }\n\n  TestTables.TestTable load() {\n    return TestTables.load(tableDir, \"test\");\n  }\n\n  Integer version() {\n    return TestTables.metadataVersion(\"test\");\n  }\n\n  TableMetadata readMetadata() {\n    return TestTables.readMetadata(\"test\");\n  }\n\n  void validateSnapshot(Snapshot old, Snapshot snap, DataFile... newFiles) {\n    List<ManifestFile> oldManifests = old != null ? old.manifests() : ImmutableList.of();\n\n\n    List<ManifestFile> newManifests = Lists.newArrayList(snap.manifests());\n    for (ManifestFile oldManifest : oldManifests) {\n      Assert.assertTrue(\"New snapshot should contain old manifests\",\n          newManifests.remove(oldManifest));\n    }\n\n    Assert.assertEquals(\"Should create 1 new manifest and reuse old manifests\",\n        1, newManifests.size());\n    ManifestFile manifest = newManifests.get(0);\n\n    long id = snap.snapshotId();\n    Iterator<String> newPaths = paths(newFiles).iterator();\n\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest.path())).entries()) {\n      DataFile file = entry.file();\n      Assert.assertEquals(\"Path should match expected\", newPaths.next(), file.path().toString());\n      Assert.assertEquals(\"File's snapshot ID should match\", id, entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", newPaths.hasNext());\n  }\n\n  List<String> paths(DataFile... dataFiles) {\n    List<String> paths = Lists.newArrayListWithExpectedSize(dataFiles.length);\n    for (DataFile file : dataFiles) {\n      paths.add(file.path().toString());\n    }\n    return paths;\n  }\n\n  static void validateManifest(ManifestFile manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    validateManifest(manifest.path(), ids, expectedFiles);\n  }\n\n  static void validateManifest(String manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static void validateManifestEntries(ManifestFile manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    validateManifestEntries(manifest.path(), ids, expectedFiles, expectedStatuses);\n  }\n\n  static void validateManifestEntries(String manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      final ManifestEntry.Status expectedStatus = expectedStatuses.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n      Assert.assertEquals(\"Entry status should match expected ID\",\n          expectedStatus, entry.status());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static Iterator<ManifestEntry.Status> statuses(ManifestEntry.Status... statuses) {\n    return Iterators.forArray(statuses);\n  }\n\n  static Iterator<Long> ids(Long... ids) {\n    return Iterators.forArray(ids);\n  }\n\n  static Iterator<DataFile> files(DataFile... files) {\n    return Iterators.forArray(files);\n  }\n\n  static Iterator<DataFile> files(ManifestFile manifest) {\n    return ManifestReader.read(localInput(manifest.path())).iterator();\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.apache.ResultCode;\nimport io.airlift.drift.integration.scribe.apache.scribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TCompactProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransport;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportFactory;\nimport org.apache.thrift.transport.layered.TFramedTransport;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\nimport java.util.List;\nimport java.util.function.ToIntFunction;\n\nimport static io.airlift.drift.integration.ClientTestUtils.MESSAGES;\nimport static org.testng.Assert.assertEquals;\n\nfinal class LegacyApacheThriftTesterUtil\n{\n    private LegacyApacheThriftTesterUtil() {}\n\n    public static List<ToIntFunction<HostAndPort>> legacyApacheThriftTestClients(List<MethodInvocationFilter> filters, Transport transport, Protocol protocol, boolean secure)\n    {\n        return ImmutableList.of(\n                address -> logThrift(address, MESSAGES, filters, transport, protocol, secure));\n    }\n\n    private static int logThrift(HostAndPort address, List<LogEntry> messages, List<MethodInvocationFilter> filters, Transport transportType, Protocol protocolType, boolean secure)\n    {\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        TTransportFactory transportFactory;\n        switch (transportType) {\n            case UNFRAMED:\n                transportFactory = new TTransportFactory();\n                break;\n            case FRAMED:\n                transportFactory = new TFramedTransport.Factory();\n                break;\n            case HEADER:\n                return 0;\n            default:\n                throw new IllegalArgumentException(\"Unsupported transport \" + transportType);\n        }\n\n        try (TSocket socket = createClientSocket(secure, address)) {\n            if (!socket.isOpen()) {\n                socket.open();\n            }\n            TTransport transport = transportFactory.getTransport(socket);\n            TProtocol protocol;\n            switch (protocolType) {\n                case BINARY:\n                    protocol = new TBinaryProtocol(transport);\n                    break;\n                case COMPACT:\n                    protocol = new TCompactProtocol(transport);\n                    break;\n                case FB_COMPACT:\n                    return 0;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported protocol \" + protocolType);\n            }\n\n            assertEquals(new scribe.Client(protocol).Log(messages), ResultCode.OK);\n        }\n        catch (TException e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static TSocket createClientSocket(boolean secure, HostAndPort address)\n            throws TTransportException\n    {\n        if (!secure) {\n            return new TSocket(address.getHost(), address.getPort());\n        }\n\n        try {\n            SSLContext serverSslContext = ClientTestUtils.getClientSslContext();\n            SSLSocket clientSocket = (SSLSocket) serverSslContext.getSocketFactory().createSocket(address.getHost(), address.getPort());\n\n            return new TSocket(clientSocket);\n        }\n        catch (Exception e) {\n            throw new TTransportException(\"Error initializing secure socket\", e);\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'"
        ]
    },
    {
        "files": [
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'",
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictTest.java'"
        ],
        "content": "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'\n:package com.tjeannin.provigen.test.constraint;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport com.tjeannin.provigen.ProviGenBaseContract;\nimport com.tjeannin.provigen.ProviGenProvider;\nimport com.tjeannin.provigen.annotation.Column;\nimport com.tjeannin.provigen.annotation.Column.Type;\nimport com.tjeannin.provigen.annotation.ContentUri;\nimport com.tjeannin.provigen.helper.TableBuilder;\nimport com.tjeannin.provigen.model.Constraint;\nimport com.tjeannin.provigen.model.Constraint.OnConflict;\n\npublic class OnConflictProvider extends ProviGenProvider {\n\n    @Override\n    public SQLiteOpenHelper openHelper(Context context) {\n        return new SQLiteOpenHelper(context, \"ProviGenDatabase\", null, 1) {\n            @Override\n            public void onCreate(SQLiteDatabase database) {\n                new TableBuilder(ContractAbort.class)\n                        .addConstraint(ContractAbort.AN_INT, Constraint.UNIQUE, OnConflict.ABORT)\n                        .createTable(database);\n\n                new TableBuilder(ContractReplace.class)\n                        .addConstraint(ContractReplace.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n\n                new TableBuilder(ContractFail.class)\n                        .addConstraint(ContractFail.AN_INT, Constraint.UNIQUE, OnConflict.FAIL)\n                        .createTable(database);\n\n                new TableBuilder(ContractMultipleResolution.class)\n                        .addConstraint(ContractMultipleResolution.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .addConstraint(ContractMultipleResolution.ANOTHER_INT, Constraint.UNIQUE, OnConflict.ABORT)\n                        .createTable(database);\n\n            }\n\n            @Override\n            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n            }\n        };\n    }\n\n    @Override\n    public Class[] contractClasses() {\n        return new Class[]{ContractAbort.class, ContractReplace.class, ContractFail.class, ContractMultipleResolution.class};\n    }\n\n    public static interface ContractAbort extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractReplace extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractFail extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractMultipleResolution extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @Column(Type.INTEGER)\n        public static final String ANOTHER_INT = \"another_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n}\n\n'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'\n:package com.tjeannin.provigen.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface Column {\n    String value();\n\n    public class Type {\n        public static final String INTEGER = \"INTEGER\";\n        public static final String REAL = \"REAL\";\n        public static final String TEXT = \"TEXT\";\n        public static final String BLOB = \"BLOB\";\n    }\n}\n",
        "gt": [
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'"
        ],
        "content": "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Lists;\nimport com.google.common.io.Files;\nimport com.netflix.iceberg.types.Types;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.Files.localInput;\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\npublic class TableTestBase {\n\n  static final Schema SCHEMA = new Schema(\n      required(3, \"id\", Types.IntegerType.get()),\n      required(4, \"data\", Types.StringType.get())\n  );\n\n\n  static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA)\n      .bucket(\"data\", 16)\n      .build();\n\n  static final DataFile FILE_A = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-a.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=0\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_B = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-b.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=1\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_C = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-c.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=2\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_D = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-d.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=3\")\n      .withRecordCount(0)\n      .build();\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();\n\n  File tableDir = null;\n  File metadataDir = null;\n  TestTables.TestTable table = null;\n\n  @Before\n  public void setupTable() throws Exception {\n    this.tableDir = temp.newFolder();\n    tableDir.delete();\n\n    this.metadataDir = new File(tableDir, \"metadata\");\n    this.table = create(SCHEMA, SPEC);\n  }\n\n  @After\n  public void cleanupTables() {\n    TestTables.clearTables();\n  }\n\n  List<File> listManifestFiles() {\n    return listManifestFiles(tableDir);\n  }\n\n  List<File> listManifestFiles(File tableDir) {\n    return Lists.newArrayList(new File(tableDir, \"metadata\").listFiles((dir, name) ->\n        !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n  }\n\n  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n    return TestTables.create(tableDir, \"test\", schema, spec);\n  }\n\n  TestTables.TestTable load() {\n    return TestTables.load(tableDir, \"test\");\n  }\n\n  Integer version() {\n    return TestTables.metadataVersion(\"test\");\n  }\n\n  TableMetadata readMetadata() {\n    return TestTables.readMetadata(\"test\");\n  }\n\n  void validateSnapshot(Snapshot old, Snapshot snap, DataFile... newFiles) {\n    List<ManifestFile> oldManifests = old != null ? old.manifests() : ImmutableList.of();\n\n\n    List<ManifestFile> newManifests = Lists.newArrayList(snap.manifests());\n    for (ManifestFile oldManifest : oldManifests) {\n      Assert.assertTrue(\"New snapshot should contain old manifests\",\n          newManifests.remove(oldManifest));\n    }\n\n    Assert.assertEquals(\"Should create 1 new manifest and reuse old manifests\",\n        1, newManifests.size());\n    ManifestFile manifest = newManifests.get(0);\n\n    long id = snap.snapshotId();\n    Iterator<String> newPaths = paths(newFiles).iterator();\n\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest.path())).entries()) {\n      DataFile file = entry.file();\n      Assert.assertEquals(\"Path should match expected\", newPaths.next(), file.path().toString());\n      Assert.assertEquals(\"File's snapshot ID should match\", id, entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", newPaths.hasNext());\n  }\n\n  List<String> paths(DataFile... dataFiles) {\n    List<String> paths = Lists.newArrayListWithExpectedSize(dataFiles.length);\n    for (DataFile file : dataFiles) {\n      paths.add(file.path().toString());\n    }\n    return paths;\n  }\n\n  static void validateManifest(ManifestFile manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    validateManifest(manifest.path(), ids, expectedFiles);\n  }\n\n  static void validateManifest(String manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static void validateManifestEntries(ManifestFile manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    validateManifestEntries(manifest.path(), ids, expectedFiles, expectedStatuses);\n  }\n\n  static void validateManifestEntries(String manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      final ManifestEntry.Status expectedStatus = expectedStatuses.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n      Assert.assertEquals(\"Entry status should match expected ID\",\n          expectedStatus, entry.status());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static Iterator<ManifestEntry.Status> statuses(ManifestEntry.Status... statuses) {\n    return Iterators.forArray(statuses);\n  }\n\n  static Iterator<Long> ids(Long... ids) {\n    return Iterators.forArray(ids);\n  }\n\n  static Iterator<DataFile> files(DataFile... files) {\n    return Iterators.forArray(files);\n  }\n\n  static Iterator<DataFile> files(ManifestFile manifest) {\n    return ManifestReader.read(localInput(manifest.path())).iterator();\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ViewAnimator;\n\nimport com.philliphsu.bottomsheetpickers.R;\n\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.DAY_PICKER_INDEX;\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.MONTH_PICKER_INDEX;\n\n\npublic final class DayPickerViewAnimator extends ViewAnimator {\n\n    private final Animation mDayPickerInAnimation;\n    private final Animation mDayPickerOutAnimation;\n    private final Animation mMonthPickerInAnimation;\n    private final Animation mMonthPickerOutAnimation;\n\n    public DayPickerViewAnimator(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mDayPickerInAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_day_picker_slide_up);\n        mDayPickerOutAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_day_picker_slide_down);\n        mMonthPickerInAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_month_picker_slide_down);\n        mMonthPickerOutAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_month_picker_slide_up);\n    }\n\n    @Override\n    public void setDisplayedChild(int whichChild) {\n        switch (whichChild) {\n            case DAY_PICKER_INDEX:\n                setInAnimation(mDayPickerInAnimation);\n                setOutAnimation(mMonthPickerOutAnimation);\n                break;\n            case MONTH_PICKER_INDEX:\n                setInAnimation(mMonthPickerInAnimation);\n                setOutAnimation(mDayPickerOutAnimation);\n                break;\n        }\n        super.setDisplayedChild(whichChild);\n    }\n\n    final void setDisplayedChild(int whichChild, boolean animate) {\n        if (animate) {\n            setDisplayedChild(whichChild);\n        } else {\n            setInAnimation(null);\n            setOutAnimation(null);\n            super.setDisplayedChild(whichChild);\n        }\n    }\n}\n\n'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.text.format.DateUtils;\n\nimport java.util.Calendar;\nimport java.util.Formatter;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\n\nfinal class DateFormatHelper {\n\n    private static final StringBuilder STRINGBUILDER = new StringBuilder(50);\n    private static final Formatter FORMATTER = new Formatter(STRINGBUILDER, Locale.getDefault());\n\n    static String formatDate(final Calendar calendar, final int flags) {\n        return formatDate(calendar.getTimeInMillis(), flags);\n    }\n\n    static String formatDate(final long millis, final int flags) {\n        STRINGBUILDER.setLength(0);\n\n        return DateUtils.formatDateRange(null, FORMATTER, millis, millis, flags,\n                TimeZone.getDefault().getID()).toString();\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'"
        ]
    },
    {
        "files": [
            "'lsp4intellij/src/main/java/org/wso2/lsp4intellij/utils/DocumentUtils.java'",
            "'lsp4intellij/src/main/java/org/wso2/lsp4intellij/client/ServerWrapperBaseClientContext.java'",
            "'lsp4intellij/src/main/java/org/wso2/lsp4intellij/editor/EditorEventManager.java'"
        ],
        "content": "'lsp4intellij/src/main/java/org/wso2/lsp4intellij/utils/DocumentUtils.java'\n:\npackage org.wso2.lsp4intellij.utils;\n\nimport com.intellij.openapi.diagnostic.Logger;\nimport com.intellij.openapi.editor.Document;\nimport com.intellij.openapi.editor.Editor;\nimport com.intellij.openapi.editor.LogicalPosition;\nimport com.intellij.openapi.util.TextRange;\nimport com.intellij.openapi.util.text.StringUtil;\nimport com.intellij.util.DocumentUtil;\nimport org.eclipse.lsp4j.InsertReplaceEdit;\nimport org.eclipse.lsp4j.Position;\nimport org.eclipse.lsp4j.TextEdit;\nimport org.eclipse.lsp4j.jsonrpc.messages.Either;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport javax.annotation.Nullable;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static org.wso2.lsp4intellij.utils.ApplicationUtils.computableReadAction;\n\n\npublic class DocumentUtils {\n\n    private static final Logger LOG = Logger.getInstance(DocumentUtils.class);\n    public static final String WIN_SEPARATOR = \"\\r\\n\";\n    public static final String LINUX_SEPARATOR = \"\\n\";\n\n\n    @Nullable\n    public static Position logicalToLSPPos(LogicalPosition position, Editor editor) {\n        return offsetToLSPPos(editor, editor.logicalPositionToOffset(position));\n    }\n\n\n    @Nullable\n    public static Position offsetToLSPPos(LogicalPosition position, Editor editor) {\n        return offsetToLSPPos(editor, editor.logicalPositionToOffset(position));\n    }\n\n\n    @Nullable\n    public static Position offsetToLSPPos(Editor editor, int offset) {\n        return computableReadAction(() -> {\n            if (editor.isDisposed()) {\n                return null;\n            }\n            Document doc = editor.getDocument();\n            int line = doc.getLineNumber(offset);\n            int lineStart = doc.getLineStartOffset(line);\n            String lineTextBeforeOffset = doc.getText(TextRange.create(lineStart, offset));\n            int column = lineTextBeforeOffset.length();\n            return new Position(line, column);\n        });\n    }\n\n\n    public static int LSPPosToOffset(Editor editor, Position pos) {\n        return computableReadAction(() -> {\n            if (editor == null) {\n                return -1;\n            }\n            if (editor.isDisposed()) {\n                return -2;\n            }\n\n            Document doc = editor.getDocument();\n            int line = max(0, Math.min(pos.getLine(), doc.getLineCount()));\n            if (line >= doc.getLineCount()) {\n                return doc.getTextLength();\n            }\n            String lineText = doc.getText(DocumentUtil.getLineTextRange(doc, line));\n\n            final int positionInLine = max(0, min(lineText.length(), pos.getCharacter()));\n            int tabs = StringUtil.countChars(lineText, '\\t', 0, positionInLine, false);\n            int tabSize = getTabSize(editor);\n            int column = positionInLine + tabs * (tabSize - 1);\n            int offset = editor.logicalPositionToOffset(new LogicalPosition(line, column));\n            if (pos.getCharacter() >= lineText.length()) {\n                LOG.debug(String.format(\"LSPPOS outofbounds: %s, line : %s, column : %d, offset : %d\", pos,\n                        lineText, column, offset));\n            }\n            int docLength = doc.getTextLength();\n            if (offset > docLength) {\n                LOG.debug(String.format(\"Offset greater than text length : %d > %d\", offset, docLength));\n            }\n            return Math.min(max(offset, 0), docLength);\n\n        });\n    }\n\n    @Nullable\n    public static LogicalPosition getTabsAwarePosition(Editor editor, Position pos) {\n        return computableReadAction(() -> {\n            if (editor.isDisposed()) {\n                return null;\n            }\n            Document doc = editor.getDocument();\n            int line = max(0, Math.min(pos.getLine(), doc.getLineCount() - 1));\n            String lineText = doc.getText(DocumentUtil.getLineTextRange(doc, line));\n            final int positionInLine = max(0, min(lineText.length(), pos.getCharacter()));\n            int tabs = StringUtil.countChars(lineText, '\\t', 0, positionInLine, false);\n            int tabSize = getTabSize(editor);\n            int column = positionInLine + tabs * (tabSize - 1);\n            return new LogicalPosition(line, column);\n        });\n    }\n\n\n    public static int getTabSize(Editor editor) {\n        return computableReadAction(() -> editor.getSettings().getTabSize(editor.getProject()));\n    }\n\n    public static boolean shouldUseSpaces(Editor editor) {\n        return computableReadAction(() -> !editor.getSettings().isUseTabCharacter(editor.getProject()));\n    }\n\n    public static List<Either<TextEdit, InsertReplaceEdit>> toEither(List<TextEdit> edits) {\n        return edits.stream().map(Either::<TextEdit, InsertReplaceEdit>forLeft).collect(Collectors.toList());\n    }\n}\n\n'lsp4intellij/src/main/java/org/wso2/lsp4intellij/client/ServerWrapperBaseClientContext.java'\n:\npackage org.wso2.lsp4intellij.client;\n\nimport com.intellij.openapi.project.Project;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.wso2.lsp4intellij.client.languageserver.requestmanager.RequestManager;\nimport org.wso2.lsp4intellij.client.languageserver.wrapper.LanguageServerWrapper;\nimport org.wso2.lsp4intellij.editor.EditorEventManager;\n\npublic class ServerWrapperBaseClientContext implements ClientContext {\n\n    private final LanguageServerWrapper wrapper;\n\n    public ServerWrapperBaseClientContext(@NotNull LanguageServerWrapper wrapper) {\n        this.wrapper = wrapper;\n    }\n\n    @Override\n    public EditorEventManager getEditorEventManagerFor(@NotNull String documentUri) {\n        return wrapper.getEditorManagerFor(documentUri);\n    }\n\n    @Nullable\n    @Override\n    public Project getProject() {\n        return wrapper.getProject();\n    }\n\n    @Nullable\n    @Override\n    public RequestManager getRequestManager() {\n        return wrapper.getRequestManager();\n    }\n\n    public LanguageServerWrapper getWrapper() {\n        return wrapper;\n    }\n}\n",
        "gt": [
            "'lsp4intellij/src/main/java/org/wso2/lsp4intellij/client/ServerWrapperBaseClientContext.java'",
            "'lsp4intellij/src/main/java/org/wso2/lsp4intellij/utils/DocumentUtils.java'",
            "'lsp4intellij/src/main/java/org/wso2/lsp4intellij/editor/EditorEventManager.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.content.Context;\nimport android.util.AttributeSet;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.widget.ViewAnimator;\n\nimport com.philliphsu.bottomsheetpickers.R;\n\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.DAY_PICKER_INDEX;\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.MONTH_PICKER_INDEX;\n\n\npublic final class DayPickerViewAnimator extends ViewAnimator {\n\n    private final Animation mDayPickerInAnimation;\n    private final Animation mDayPickerOutAnimation;\n    private final Animation mMonthPickerInAnimation;\n    private final Animation mMonthPickerOutAnimation;\n\n    public DayPickerViewAnimator(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        mDayPickerInAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_day_picker_slide_up);\n        mDayPickerOutAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_day_picker_slide_down);\n        mMonthPickerInAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_month_picker_slide_down);\n        mMonthPickerOutAnimation = AnimationUtils.loadAnimation(context, R.anim.bsp_month_picker_slide_up);\n    }\n\n    @Override\n    public void setDisplayedChild(int whichChild) {\n        switch (whichChild) {\n            case DAY_PICKER_INDEX:\n                setInAnimation(mDayPickerInAnimation);\n                setOutAnimation(mMonthPickerOutAnimation);\n                break;\n            case MONTH_PICKER_INDEX:\n                setInAnimation(mMonthPickerInAnimation);\n                setOutAnimation(mDayPickerOutAnimation);\n                break;\n        }\n        super.setDisplayedChild(whichChild);\n    }\n\n    final void setDisplayedChild(int whichChild, boolean animate) {\n        if (animate) {\n            setDisplayedChild(whichChild);\n        } else {\n            setInAnimation(null);\n            setOutAnimation(null);\n            super.setDisplayedChild(whichChild);\n        }\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewAnimator.java'"
        ]
    },
    {
        "files": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/data/DataManagerTest.java'"
        ],
        "content": "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'\n:package com.hitherejoe.bourboncorecommon.injection;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport javax.inject.Qualifier;\n\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ApplicationContext {\n\n}",
        "gt": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/data/DataManagerTest.java'"
        ]
    },
    {
        "files": [
            "'camunda-bpm-spring-boot-starter/starter/src/main/java/org/camunda/bpm/spring/boot/starter/configuration/impl/DefaultJobConfiguration.java'",
            "'camunda-bpm-spring-boot-starter/starter/src/main/java/org/camunda/bpm/spring/boot/starter/CamundaBpmConfiguration.java'",
            "'camunda-bpm-spring-boot-starter/starter/src/main/java/org/camunda/bpm/spring/boot/starter/util/CamundaSpringBootUtil.java'"
        ],
        "content": "'camunda-bpm-spring-boot-starter/starter/src/main/java/org/camunda/bpm/spring/boot/starter/configuration/impl/DefaultJobConfiguration.java'\n:\npackage org.camunda.bpm.spring.boot.starter.configuration.impl;\n\nimport static org.camunda.bpm.spring.boot.starter.util.CamundaSpringBootUtil.join;\n\nimport java.util.List;\nimport java.util.Optional;\n\nimport org.camunda.bpm.engine.impl.jobexecutor.CallerRunsRejectedJobsHandler;\nimport org.camunda.bpm.engine.impl.jobexecutor.JobExecutor;\nimport org.camunda.bpm.engine.impl.jobexecutor.JobHandler;\nimport org.camunda.bpm.engine.spring.SpringProcessEngineConfiguration;\nimport org.camunda.bpm.engine.spring.components.jobexecutor.SpringJobExecutor;\nimport org.camunda.bpm.spring.boot.starter.configuration.CamundaJobConfiguration;\nimport org.camunda.bpm.spring.boot.starter.event.JobExecutorStartingEventListener;\nimport org.camunda.bpm.spring.boot.starter.property.CamundaBpmProperties;\nimport org.camunda.bpm.spring.boot.starter.property.JobExecutionProperty;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.core.task.TaskExecutor;\nimport org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;\n\n\npublic class DefaultJobConfiguration extends AbstractCamundaConfiguration implements CamundaJobConfiguration {\n\n  @Autowired\n  protected JobExecutor jobExecutor;\n\n  @Autowired(required = false)\n  protected List<JobHandler<?>> customJobHandlers;\n\n  @Override\n  public void preInit(final SpringProcessEngineConfiguration configuration) {\n    configureJobExecutor(configuration);\n    registerCustomJobHandlers(configuration);\n  }\n\n  protected void registerCustomJobHandlers(SpringProcessEngineConfiguration configuration) {\n    configuration.setCustomJobHandlers(join(configuration.getCustomJobHandlers(), customJobHandlers));\n    for (JobHandler<?> jobHandler : configuration.getCustomJobHandlers()) {\n      logger.info(\"Register Custom JobHandler: '{}'\", jobHandler.getType());\n    }\n  }\n\n  protected void configureJobExecutor(SpringProcessEngineConfiguration configuration) {\n\n\n    configuration.setJobExecutorActivate(false);\n    configuration.setJobExecutorDeploymentAware(camundaBpmProperties.getJobExecution().isDeploymentAware());\n    configuration.setJobExecutor(jobExecutor);\n\n  }\n\n  public static class JobConfiguration {\n\n    public static final String CAMUNDA_TASK_EXECUTOR_QUALIFIER = \"camundaTaskExecutor\";\n\n    @Bean(name = CAMUNDA_TASK_EXECUTOR_QUALIFIER)\n    @ConditionalOnMissingBean(name = CAMUNDA_TASK_EXECUTOR_QUALIFIER)\n    @ConditionalOnProperty(prefix = \"camunda.bpm.job-execution\", name = \"enabled\", havingValue = \"true\", matchIfMissing = true)\n    public static TaskExecutor camundaTaskExecutor(CamundaBpmProperties properties) {\n      int corePoolSize = properties.getJobExecution().getCorePoolSize();\n      int maxPoolSize = properties.getJobExecution().getMaxPoolSize();\n      int queueCapacity = properties.getJobExecution().getQueueCapacity();\n\n      final ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();\n\n      threadPoolTaskExecutor.setCorePoolSize(corePoolSize);\n      threadPoolTaskExecutor.setMaxPoolSize(maxPoolSize);\n      threadPoolTaskExecutor.setQueueCapacity(queueCapacity);\n\n      Optional.ofNullable(properties.getJobExecution().getKeepAliveSeconds())\n        .ifPresent(threadPoolTaskExecutor::setKeepAliveSeconds);\n\n      LOG.configureJobExecutorPool(corePoolSize, maxPoolSize);\n      return threadPoolTaskExecutor;\n    }\n\n    @Bean\n    @ConditionalOnMissingBean(JobExecutor.class)\n    @ConditionalOnProperty(prefix = \"camunda.bpm.job-execution\", name = \"enabled\", havingValue = \"true\", matchIfMissing = true)\n    public static JobExecutor jobExecutor(@Qualifier(CAMUNDA_TASK_EXECUTOR_QUALIFIER) final TaskExecutor taskExecutor, CamundaBpmProperties properties) {\n      final SpringJobExecutor springJobExecutor = new SpringJobExecutor();\n      springJobExecutor.setTaskExecutor(taskExecutor);\n      springJobExecutor.setRejectedJobsHandler(new CallerRunsRejectedJobsHandler());\n\n      JobExecutionProperty jobExecution = properties.getJobExecution();\n      Optional.ofNullable(jobExecution.getLockTimeInMillis()).ifPresent(springJobExecutor::setLockTimeInMillis);\n      Optional.ofNullable(jobExecution.getMaxJobsPerAcquisition()).ifPresent(springJobExecutor::setMaxJobsPerAcquisition);\n      Optional.ofNullable(jobExecution.getWaitTimeInMillis()).ifPresent(springJobExecutor::setWaitTimeInMillis);\n      Optional.ofNullable(jobExecution.getMaxWait()).ifPresent(springJobExecutor::setMaxWait);\n      Optional.ofNullable(jobExecution.getBackoffTimeInMillis()).ifPresent(springJobExecutor::setBackoffTimeInMillis);\n      Optional.ofNullable(jobExecution.getMaxBackoff()).ifPresent(springJobExecutor::setMaxBackoff);\n      Optional.ofNullable(jobExecution.getBackoffDecreaseThreshold()).ifPresent(springJobExecutor::setBackoffDecreaseThreshold);\n      Optional.ofNullable(jobExecution.getWaitIncreaseFactor()).ifPresent(springJobExecutor::setWaitIncreaseFactor);\n\n      return springJobExecutor;\n    }\n\n    @Bean\n    @ConditionalOnProperty(prefix = \"camunda.bpm.job-execution\", name = \"enabled\", havingValue = \"true\", matchIfMissing = true)\n    @ConditionalOnBean(JobExecutor.class)\n    public static JobExecutorStartingEventListener jobExecutorStartingEventListener() {\n      return new JobExecutorStartingEventListener();\n    }\n  }\n}\n",
        "gt": [
            "'camunda-bpm-spring-boot-starter/starter/src/main/java/org/camunda/bpm/spring/boot/starter/util/CamundaSpringBootUtil.java'",
            "'camunda-bpm-spring-boot-starter/starter/src/main/java/org/camunda/bpm/spring/boot/starter/configuration/impl/DefaultJobConfiguration.java'",
            "'camunda-bpm-spring-boot-starter/starter/src/main/java/org/camunda/bpm/spring/boot/starter/CamundaBpmConfiguration.java'"
        ]
    },
    {
        "files": [
            "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/validation/references/annotations/SubstitutionType.java'",
            "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/components/JsonSdlParser.java'",
            "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/descriptors/SslServerDescriptor.java'",
            "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/components/JsonSdlObjectMapper.java'"
        ],
        "content": "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/validation/references/annotations/SubstitutionType.java'\n:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npackage com.cloudera.csd.validation.references.annotations;\n\n\npublic enum SubstitutionType {\n  PARAMETERS,\n  HOST,\n  USER,\n  GROUP,\n  PRINCIPAL,\n}\n",
        "gt": [
            "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/validation/references/annotations/SubstitutionType.java'",
            "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/descriptors/SslServerDescriptor.java'",
            "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/components/JsonSdlParser.java'",
            "'cm_ext/cm-schema/src/main/java/com/cloudera/csd/components/JsonSdlObjectMapper.java'"
        ]
    },
    {
        "files": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/helper/StubHelper.java'"
        ],
        "content": "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'\n:package com.hitherejoe.bourboncorecommon.injection;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport javax.inject.Qualifier;\n\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ApplicationContext {\n\n}\n'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'\n:package com.hitherejoe.androidtestcommon.util;\n\nimport android.text.TextUtils;\nimport android.view.View;\n\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.TypeSafeMatcher;\n\nimport static android.support.test.espresso.intent.Checks.checkArgument;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDescendantOfA;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.hamcrest.core.AllOf.allOf;\n\npublic class CustomMatchers {\n\n    public static Matcher<View> withItemText(final String itemText, final int parentId) {\n        checkArgument(!TextUtils.isEmpty(itemText), \"itemText cannot be null or empty\");\n        return new TypeSafeMatcher<View>() {\n            @Override\n            public boolean matchesSafely(View item) {\n                return allOf(isDescendantOfA(withId(parentId)),\n                        withText(itemText)).matches(item);\n            }\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"is isDescendantOfA RecyclerView with text \" + itemText);\n            }\n        };\n    }\n\n}\n",
        "gt": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/helper/StubHelper.java'"
        ]
    },
    {
        "files": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/SqlTypeMap.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableMetadataImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ],
        "content": "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/SqlTypeMap.java'\n:\npackage oracle.r2dbc.impl;\n\nimport io.r2dbc.spi.R2dbcType;\nimport io.r2dbc.spi.Type;\nimport oracle.jdbc.OracleType;\nimport oracle.r2dbc.OracleR2dbcObject;\nimport oracle.r2dbc.OracleR2dbcTypes;\nimport oracle.sql.VECTOR;\nimport oracle.sql.json.OracleJsonObject;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.sql.JDBCType;\nimport java.sql.RowId;\nimport java.sql.SQLException;\nimport java.sql.SQLType;\nimport java.sql.Types;\nimport java.time.Duration;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.LocalTime;\nimport java.time.OffsetDateTime;\nimport java.time.OffsetTime;\nimport java.time.Period;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport static java.util.Map.entry;\n\n\nfinal class SqlTypeMap {\n\n\n  private static final Map<SQLType, Type> JDBC_TO_R2DBC_TYPE_MAP =\n    Map.ofEntries(\n      entry(JDBCType.ARRAY, R2dbcType.COLLECTION),\n      entry(JDBCType.BIGINT, R2dbcType.BIGINT),\n      entry(JDBCType.BINARY, R2dbcType.BINARY),\n      entry(OracleType.BINARY_DOUBLE, OracleR2dbcTypes.BINARY_DOUBLE),\n      entry(OracleType.BINARY_FLOAT, OracleR2dbcTypes.BINARY_FLOAT),\n      entry(JDBCType.BLOB, R2dbcType.BLOB),\n      entry(JDBCType.BOOLEAN, R2dbcType.BOOLEAN),\n      entry(JDBCType.CHAR, R2dbcType.CHAR),\n      entry(JDBCType.CLOB, R2dbcType.CLOB),\n      entry(JDBCType.DATE, R2dbcType.DATE),\n      entry(JDBCType.DECIMAL, R2dbcType.DECIMAL),\n      entry(JDBCType.DOUBLE, R2dbcType.DOUBLE),\n      entry(JDBCType.FLOAT, R2dbcType.FLOAT),\n      entry(JDBCType.INTEGER, R2dbcType.INTEGER),\n      entry(\n        OracleType.INTERVAL_DAY_TO_SECOND,\n        OracleR2dbcTypes.INTERVAL_DAY_TO_SECOND),\n      entry(\n        OracleType.INTERVAL_YEAR_TO_MONTH,\n        OracleR2dbcTypes.INTERVAL_YEAR_TO_MONTH),\n      entry(OracleType.JSON, OracleR2dbcTypes.JSON),\n      entry(JDBCType.LONGVARBINARY, OracleR2dbcTypes.LONG_RAW),\n      entry(JDBCType.LONGVARCHAR, OracleR2dbcTypes.LONG),\n      entry(JDBCType.NCHAR, R2dbcType.NCHAR),\n      entry(JDBCType.NCLOB, R2dbcType.NCLOB),\n      entry(JDBCType.NUMERIC, R2dbcType.NUMERIC),\n      entry(JDBCType.NVARCHAR, R2dbcType.NVARCHAR),\n      entry(JDBCType.REAL, R2dbcType.REAL),\n      entry(JDBCType.REF_CURSOR, OracleR2dbcTypes.REF_CURSOR),\n      entry(JDBCType.ROWID, OracleR2dbcTypes.ROWID),\n      entry(JDBCType.SMALLINT, R2dbcType.SMALLINT),\n      entry(JDBCType.TIME, R2dbcType.TIME),\n      entry(JDBCType.TIME_WITH_TIMEZONE, R2dbcType.TIME_WITH_TIME_ZONE),\n      entry(JDBCType.TIMESTAMP, R2dbcType.TIMESTAMP),\n      entry(\n        OracleType.TIMESTAMP_WITH_LOCAL_TIME_ZONE,\n        OracleR2dbcTypes.TIMESTAMP_WITH_LOCAL_TIME_ZONE),\n      entry(\n\n\n        OracleType.TIMESTAMP_WITH_TIME_ZONE,\n        R2dbcType.TIMESTAMP_WITH_TIME_ZONE),\n      entry(JDBCType.TINYINT, R2dbcType.TINYINT),\n      entry(JDBCType.VARBINARY, R2dbcType.VARBINARY),\n      entry(JDBCType.VARCHAR, R2dbcType.VARCHAR),\n      entry(OracleType.VECTOR, OracleR2dbcTypes.VECTOR)\n    );\n\n\n  private static final Map<Type, SQLType> R2DBC_TO_JDBC_TYPE_MAP =\n\n    JDBC_TO_R2DBC_TYPE_MAP.entrySet().stream()\n      .collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey));\n\n\n  private static final Map<Class<?>, SQLType> JAVA_TO_SQL_TYPE_MAP =\n    Map.ofEntries(\n\n      entry(String.class, JDBCType.VARCHAR),\n      entry(Boolean.class, JDBCType.BOOLEAN),\n      entry(ByteBuffer.class, JDBCType.VARBINARY),\n      entry(Integer.class, JDBCType.INTEGER),\n      entry(Byte.class, JDBCType.TINYINT),\n      entry(Short.class, JDBCType.SMALLINT),\n      entry(Long.class, JDBCType.BIGINT),\n      entry(BigDecimal.class, JDBCType.NUMERIC),\n      entry(Float.class, JDBCType.REAL),\n      entry(Double.class, JDBCType.DOUBLE),\n      entry(LocalDate.class, JDBCType.DATE),\n      entry(LocalTime.class, JDBCType.TIME),\n      entry(OffsetTime.class, JDBCType.TIME_WITH_TIMEZONE),\n      entry(LocalDateTime.class, JDBCType.TIMESTAMP),\n      entry(OffsetDateTime.class, JDBCType.TIMESTAMP_WITH_TIMEZONE),\n      entry(io.r2dbc.spi.Blob.class, JDBCType.BLOB),\n      entry(io.r2dbc.spi.Clob.class, JDBCType.CLOB),\n      entry(Object[].class, JDBCType.ARRAY),\n\n\n\n\n\n\n\n      entry(byte[].class, JDBCType.VARBINARY),\n      entry(BigInteger.class, JDBCType.BIGINT),\n      entry(java.sql.Date.class, JDBCType.DATE),\n      entry(java.sql.Time.class, JDBCType.TIME),\n      entry(java.sql.Timestamp.class, JDBCType.TIMESTAMP),\n      entry(java.sql.Array.class, JDBCType.ARRAY),\n      entry(java.sql.Blob.class, JDBCType.BLOB),\n      entry(java.sql.Clob.class, JDBCType.CLOB),\n      entry(java.sql.Struct.class, JDBCType.STRUCT),\n      entry(java.sql.Ref.class, JDBCType.REF),\n      entry(java.net.URL.class, JDBCType.DATALINK),\n      entry(java.sql.RowId.class, JDBCType.ROWID),\n      entry(java.sql.NClob.class, JDBCType.NCLOB),\n      entry(java.sql.SQLXML.class, JDBCType.SQLXML),\n      entry(java.util.Calendar.class, JDBCType.TIMESTAMP),\n      entry(java.util.Date.class, JDBCType.TIMESTAMP),\n\n\n      entry(Duration.class, OracleType.INTERVAL_DAY_TO_SECOND),\n      entry(Period.class, OracleType.INTERVAL_YEAR_TO_MONTH),\n      entry(OracleJsonObject.class, OracleType.JSON),\n\n\n\n\n      entry(boolean[].class, JDBCType.ARRAY),\n\n\n      entry(short[].class, JDBCType.ARRAY),\n      entry(int[].class, JDBCType.ARRAY),\n      entry(long[].class, JDBCType.ARRAY),\n      entry(float[].class, JDBCType.ARRAY),\n      entry(double[].class, JDBCType.ARRAY),\n\n\n\n      entry(Map.class, JDBCType.STRUCT),\n      entry(OracleR2dbcObject.class, JDBCType.STRUCT),\n\n\n      entry(VECTOR.class, OracleType.VECTOR)\n    );\n\n\n  static Type toR2dbcType(SQLType jdbcType) {\n    return JDBC_TO_R2DBC_TYPE_MAP.get(jdbcType);\n  }\n\n\n  static Type toR2dbcType(int jdbcTypeNumber) {\n\n\n    for (JDBCType jdbcType : JDBCType.values()) {\n      Integer vendorTypeNumber = jdbcType.getVendorTypeNumber();\n\n      if (vendorTypeNumber != null && vendorTypeNumber == jdbcTypeNumber)\n        return toR2dbcType(jdbcType);\n    }\n\n\n    try {\n      OracleType oracleType =\n        oracle.jdbc.OracleType.toOracleType(jdbcTypeNumber);\n\n      if (oracleType != null)\n        return toR2dbcType(oracleType);\n      else\n        return null;\n    }\n    catch (SQLException typeNotFound) {\n\n      return null;\n    }\n  }\n\n\n  static SQLType toJdbcType(Type r2dbcType) {\n    if (r2dbcType instanceof Type.InferredType)\n      return toJdbcType(r2dbcType.getJavaType());\n    else if (r2dbcType instanceof OracleR2dbcTypes.ArrayType)\n      return JDBCType.ARRAY;\n    else if (r2dbcType instanceof OracleR2dbcTypes.ObjectType)\n      return JDBCType.STRUCT;\n    else\n      return R2DBC_TO_JDBC_TYPE_MAP.get(r2dbcType);\n  }\n\n\n  static SQLType toJdbcType(Class<?> javaType) {\n    SQLType sqlType = JAVA_TO_SQL_TYPE_MAP.get(javaType);\n\n    if (sqlType != null) {\n      return sqlType;\n    }\n    else {\n\n      return JAVA_TO_SQL_TYPE_MAP.entrySet()\n        .stream()\n        .filter(entry -> entry.getKey().isAssignableFrom(javaType))\n        .map(Map.Entry::getValue)\n        .findFirst()\n        .orElse(null);\n    }\n  }\n}\n",
        "gt": [
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/SqlTypeMap.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleReadableMetadataImpl.java'",
            "'oracle-r2dbc/src/main/java/oracle/r2dbc/impl/OracleStatementImpl.java'"
        ]
    },
    {
        "files": [
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsTest.java'",
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/model/Constraint.java'"
        ],
        "content": "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'\n:package com.tjeannin.provigen.test.constraint;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport com.tjeannin.provigen.ProviGenBaseContract;\nimport com.tjeannin.provigen.ProviGenProvider;\nimport com.tjeannin.provigen.annotation.Column;\nimport com.tjeannin.provigen.annotation.Column.Type;\nimport com.tjeannin.provigen.annotation.ContentUri;\nimport com.tjeannin.provigen.helper.TableBuilder;\nimport com.tjeannin.provigen.model.Constraint;\nimport com.tjeannin.provigen.model.Constraint.OnConflict;\n\npublic class ConstraintsProvider extends ProviGenProvider {\n\n    @Override\n    public SQLiteOpenHelper openHelper(final Context context) {\n        return new SQLiteOpenHelper(context, \"ProviGenDatabase\", null, 1) {\n            @Override\n            public void onCreate(SQLiteDatabase database) {\n                new TableBuilder(NotNullContract.class)\n                        .addConstraint(NotNullContract.AN_INT, Constraint.NOT_NULL, OnConflict.ABORT)\n                        .createTable(database);\n\n                new TableBuilder(UniqueContract.class)\n                        .addConstraint(UniqueContract.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n\n                new TableBuilder(UniqueAndNotNullContract.class)\n                        .addConstraint(UniqueAndNotNullContract.AN_INT, Constraint.NOT_NULL, OnConflict.ABORT)\n                        .addConstraint(UniqueAndNotNullContract.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n            }\n\n            @Override\n            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n            }\n        };\n    }\n\n    @Override\n    public Class[] contractClasses() {\n        return new Class[]{NotNullContract.class, UniqueContract.class, UniqueAndNotNullContract.class};\n    }\n\n\n    public static interface NotNullContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n\n    public static interface UniqueContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n\n    public static interface UniqueAndNotNullContract extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n\n    }\n}\n\n'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsTest.java'\n:package com.tjeannin.provigen.test.constraint;\n\nimport android.content.ContentValues;\nimport com.tjeannin.provigen.test.ExtendedProviderTestCase;\nimport com.tjeannin.provigen.test.constraint.ConstraintsProvider.NotNullContract;\nimport com.tjeannin.provigen.test.constraint.ConstraintsProvider.UniqueAndNotNullContract;\nimport com.tjeannin.provigen.test.constraint.ConstraintsProvider.UniqueContract;\n\npublic class ConstraintsTest extends ExtendedProviderTestCase<ConstraintsProvider> {\n\n    public ConstraintsTest() {\n        super(ConstraintsProvider.class, \"com.test.simple\");\n    }\n\n    public void testNotNullAnnotation() {\n\n        ContentValues contentValuesWithNull = getContentValues(NotNullContract.class);\n        contentValuesWithNull.putNull(NotNullContract.AN_INT);\n\n        ContentValues normalContentValues = getContentValues(NotNullContract.class);\n\n        assertEquals(0, getRowCount(NotNullContract.CONTENT_URI));\n        getMockContentResolver().insert(NotNullContract.CONTENT_URI, contentValuesWithNull);\n        assertEquals(0, getRowCount(NotNullContract.CONTENT_URI));\n        getMockContentResolver().insert(NotNullContract.CONTENT_URI, normalContentValues);\n        assertEquals(1, getRowCount(NotNullContract.CONTENT_URI));\n        getMockContentResolver().insert(NotNullContract.CONTENT_URI, contentValuesWithNull);\n        assertEquals(1, getRowCount(NotNullContract.CONTENT_URI));\n    }\n\n    public void testUniqueAnnotation() {\n\n        getMockContentResolver().insert(UniqueContract.CONTENT_URI, getContentValues(UniqueContract.class));\n        getMockContentResolver().insert(UniqueContract.CONTENT_URI, getContentValues(UniqueContract.class));\n        getMockContentResolver().insert(UniqueContract.CONTENT_URI, getContentValues(UniqueContract.class));\n\n        assertEquals(1, getRowCount(UniqueContract.CONTENT_URI));\n    }\n\n    public void testBothUniqueAndNotNullAnnotation() {\n\n        getMockContentResolver().insert(UniqueAndNotNullContract.CONTENT_URI, new ContentValues());\n\n        assertEquals(0, getRowCount(UniqueAndNotNullContract.CONTENT_URI));\n\n        getMockContentResolver().insert(UniqueAndNotNullContract.CONTENT_URI, getContentValues(UniqueAndNotNullContract.class));\n        getMockContentResolver().insert(UniqueAndNotNullContract.CONTENT_URI, getContentValues(UniqueAndNotNullContract.class));\n        getMockContentResolver().insert(UniqueAndNotNullContract.CONTENT_URI, getContentValues(UniqueAndNotNullContract.class));\n\n        assertEquals(1, getRowCount(UniqueAndNotNullContract.CONTENT_URI));\n    }\n}\n",
        "gt": [
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/model/Constraint.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/ConstraintsTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'"
        ],
        "content": "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Lists;\nimport com.google.common.io.Files;\nimport com.netflix.iceberg.types.Types;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.Files.localInput;\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\npublic class TableTestBase {\n\n  static final Schema SCHEMA = new Schema(\n      required(3, \"id\", Types.IntegerType.get()),\n      required(4, \"data\", Types.StringType.get())\n  );\n\n\n  static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA)\n      .bucket(\"data\", 16)\n      .build();\n\n  static final DataFile FILE_A = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-a.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=0\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_B = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-b.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=1\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_C = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-c.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=2\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_D = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-d.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=3\")\n      .withRecordCount(0)\n      .build();\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();\n\n  File tableDir = null;\n  File metadataDir = null;\n  TestTables.TestTable table = null;\n\n  @Before\n  public void setupTable() throws Exception {\n    this.tableDir = temp.newFolder();\n    tableDir.delete();\n\n    this.metadataDir = new File(tableDir, \"metadata\");\n    this.table = create(SCHEMA, SPEC);\n  }\n\n  @After\n  public void cleanupTables() {\n    TestTables.clearTables();\n  }\n\n  List<File> listManifestFiles() {\n    return listManifestFiles(tableDir);\n  }\n\n  List<File> listManifestFiles(File tableDir) {\n    return Lists.newArrayList(new File(tableDir, \"metadata\").listFiles((dir, name) ->\n        !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n  }\n\n  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n    return TestTables.create(tableDir, \"test\", schema, spec);\n  }\n\n  TestTables.TestTable load() {\n    return TestTables.load(tableDir, \"test\");\n  }\n\n  Integer version() {\n    return TestTables.metadataVersion(\"test\");\n  }\n\n  TableMetadata readMetadata() {\n    return TestTables.readMetadata(\"test\");\n  }\n\n  void validateSnapshot(Snapshot old, Snapshot snap, DataFile... newFiles) {\n    List<ManifestFile> oldManifests = old != null ? old.manifests() : ImmutableList.of();\n\n\n    List<ManifestFile> newManifests = Lists.newArrayList(snap.manifests());\n    for (ManifestFile oldManifest : oldManifests) {\n      Assert.assertTrue(\"New snapshot should contain old manifests\",\n          newManifests.remove(oldManifest));\n    }\n\n    Assert.assertEquals(\"Should create 1 new manifest and reuse old manifests\",\n        1, newManifests.size());\n    ManifestFile manifest = newManifests.get(0);\n\n    long id = snap.snapshotId();\n    Iterator<String> newPaths = paths(newFiles).iterator();\n\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest.path())).entries()) {\n      DataFile file = entry.file();\n      Assert.assertEquals(\"Path should match expected\", newPaths.next(), file.path().toString());\n      Assert.assertEquals(\"File's snapshot ID should match\", id, entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", newPaths.hasNext());\n  }\n\n  List<String> paths(DataFile... dataFiles) {\n    List<String> paths = Lists.newArrayListWithExpectedSize(dataFiles.length);\n    for (DataFile file : dataFiles) {\n      paths.add(file.path().toString());\n    }\n    return paths;\n  }\n\n  static void validateManifest(ManifestFile manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    validateManifest(manifest.path(), ids, expectedFiles);\n  }\n\n  static void validateManifest(String manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static void validateManifestEntries(ManifestFile manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    validateManifestEntries(manifest.path(), ids, expectedFiles, expectedStatuses);\n  }\n\n  static void validateManifestEntries(String manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      final ManifestEntry.Status expectedStatus = expectedStatuses.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n      Assert.assertEquals(\"Entry status should match expected ID\",\n          expectedStatus, entry.status());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static Iterator<ManifestEntry.Status> statuses(ManifestEntry.Status... statuses) {\n    return Iterators.forArray(statuses);\n  }\n\n  static Iterator<Long> ids(Long... ids) {\n    return Iterators.forArray(ids);\n  }\n\n  static Iterator<DataFile> files(DataFile... files) {\n    return Iterators.forArray(files);\n  }\n\n  static Iterator<DataFile> files(ManifestFile manifest) {\n    return ManifestReader.read(localInput(manifest.path())).iterator();\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'"
        ],
        "content": "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'\n:package io.advantageous.qbit.service.discovery;\n\nimport io.advantageous.qbit.reactive.Callback;\nimport io.advantageous.qbit.service.Startable;\nimport io.advantageous.qbit.service.Stoppable;\nimport io.advantageous.qbit.service.health.HealthStatus;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.*;\n\n\npublic interface ServiceDiscovery extends Startable, Stoppable {\n\n\n    static String uniqueString(int port) {\n        try {\n            return port + \"-\" + InetAddress.getLocalHost().getHostName().replace('.', '-');\n        } catch (UnknownHostException e) {\n            return port + \"-\" + UUID.randomUUID().toString();\n        }\n    }\n\n\n    default EndpointDefinition register(\n            final String serviceName,\n            final String host,\n            final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceName + \".\" + uniqueString(port),\n                serviceName, host, port);\n    }\n\n\n    default EndpointDefinition registerWithTTL(\n            final String serviceName,\n            final String host,\n            final int port,\n            final int timeToLiveSeconds) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceName + \".\" + uniqueString(port),\n                serviceName, host, port, timeToLiveSeconds);\n    }\n\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default EndpointDefinition registerWithIdAndTimeToLive(\n            final String serviceName, final String serviceId, String host, final int port, final int timeToLiveSeconds) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceId,\n                serviceName, host, port, timeToLiveSeconds);\n    }\n\n\n    default EndpointDefinition registerWithId(final String serviceName, final String serviceId, String host, final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceId,\n                serviceName, host, port);\n    }\n\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default EndpointDefinition registerWithIdAndTTLAndTags(String serviceName, String serviceId, String host, int port, int timeToLiveSeconds,\n                                                           List<String> endpointTags) {\n        return new EndpointDefinition(HealthStatus.PASS, serviceId, serviceName, host, port, timeToLiveSeconds, endpointTags);\n    }\n\n\n    default void watch(String serviceName) {\n    }\n\n\n    default void checkIn(String serviceId, HealthStatus healthStatus) {\n\n    }\n\n\n    default void checkInOk(String serviceId) {\n\n    }\n\n\n    default List<EndpointDefinition> loadServices(final String serviceName) {\n\n        return Collections.emptyList();\n    }\n\n\n    default void loadServicesAsync(Callback<List<EndpointDefinition>> callback, final String serviceName) {\n\n    }\n\n\n    default List<EndpointDefinition> loadServicesNow(final String serviceName) {\n\n        return Collections.emptyList();\n    }\n\n\n    default void start() {\n    }\n\n\n    default void stop() {\n    }\n\n\n    default Set<EndpointDefinition> localDefinitions() {\n        return Collections.emptySet();\n    }\n\n}\n",
        "gt": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'"
        ]
    },
    {
        "files": [
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'",
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictTest.java'"
        ],
        "content": "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'\n:package com.tjeannin.provigen.test.constraint;\n\nimport android.content.Context;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport com.tjeannin.provigen.ProviGenBaseContract;\nimport com.tjeannin.provigen.ProviGenProvider;\nimport com.tjeannin.provigen.annotation.Column;\nimport com.tjeannin.provigen.annotation.Column.Type;\nimport com.tjeannin.provigen.annotation.ContentUri;\nimport com.tjeannin.provigen.helper.TableBuilder;\nimport com.tjeannin.provigen.model.Constraint;\nimport com.tjeannin.provigen.model.Constraint.OnConflict;\n\npublic class OnConflictProvider extends ProviGenProvider {\n\n    @Override\n    public SQLiteOpenHelper openHelper(Context context) {\n        return new SQLiteOpenHelper(context, \"ProviGenDatabase\", null, 1) {\n            @Override\n            public void onCreate(SQLiteDatabase database) {\n                new TableBuilder(ContractAbort.class)\n                        .addConstraint(ContractAbort.AN_INT, Constraint.UNIQUE, OnConflict.ABORT)\n                        .createTable(database);\n\n                new TableBuilder(ContractReplace.class)\n                        .addConstraint(ContractReplace.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .createTable(database);\n\n                new TableBuilder(ContractFail.class)\n                        .addConstraint(ContractFail.AN_INT, Constraint.UNIQUE, OnConflict.FAIL)\n                        .createTable(database);\n\n                new TableBuilder(ContractMultipleResolution.class)\n                        .addConstraint(ContractMultipleResolution.AN_INT, Constraint.UNIQUE, OnConflict.REPLACE)\n                        .addConstraint(ContractMultipleResolution.ANOTHER_INT, Constraint.UNIQUE, OnConflict.ABORT)\n                        .createTable(database);\n\n            }\n\n            @Override\n            public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\n            }\n        };\n    }\n\n    @Override\n    public Class[] contractClasses() {\n        return new Class[]{ContractAbort.class, ContractReplace.class, ContractFail.class, ContractMultipleResolution.class};\n    }\n\n    public static interface ContractAbort extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractReplace extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractFail extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n\n    public static interface ContractMultipleResolution extends ProviGenBaseContract {\n\n        @Column(Type.INTEGER)\n        public static final String AN_INT = \"an_int\";\n\n        @Column(Type.INTEGER)\n        public static final String ANOTHER_INT = \"another_int\";\n\n        @ContentUri\n        public static final Uri CONTENT_URI = Uri.parse(\"content:\n    }\n}\n\n'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'\n:package com.tjeannin.provigen.annotation;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface Column {\n    String value();\n\n    public class Type {\n        public static final String INTEGER = \"INTEGER\";\n        public static final String REAL = \"REAL\";\n        public static final String TEXT = \"TEXT\";\n        public static final String BLOB = \"BLOB\";\n    }\n}\n",
        "gt": [
            "'ProviGen/ProviGenLib/src/com/tjeannin/provigen/annotation/Column.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictProvider.java'",
            "'ProviGen/ProviGenTests/src/com/tjeannin/provigen/test/constraint/OnConflictTest.java'"
        ]
    },
    {
        "files": [
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'"
        ],
        "content": "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'\n:package com.hitherejoe.bourboncorecommon.ui.shot;\n\nimport com.hitherejoe.bourboncorecommon.data.DataManager;\nimport com.hitherejoe.bourboncorecommon.data.model.Comment;\nimport com.hitherejoe.bourboncorecommon.util.RxSchedulersOverrideRule;\nimport com.hitherejoe.bourboncorecommon.util.TestDataFactory;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport rx.Single;\n\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class ShotPresenterTest {\n\n    @Mock\n    ShotMvpView mMockShotMvpView;\n    @Mock\n    DataManager mMockDataManager;\n    private ShotPresenter mShotPresenter;\n\n    @Rule\n    public final RxSchedulersOverrideRule mOverrideSchedulersRule = new RxSchedulersOverrideRule();\n\n    @Before\n    public void setUp() {\n        mShotPresenter = new ShotPresenter(mMockDataManager);\n        mShotPresenter.attachView(mMockShotMvpView);\n    }\n\n    @After\n    public void detachView() {\n        mShotPresenter.detachView();\n    }\n\n    @Test\n    public void getCommentsSuccessful() {\n        List<Comment> comments = TestDataFactory.makeComments(5);\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showComments(comments);\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsEmpty() {\n        List<Comment> comments = new ArrayList<>();\n        stubDataManagerGetComments(Single.just(comments));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showEmptyComments();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    @Test\n    public void getCommentsFailure() {\n        stubDataManagerGetComments(Single.<List<Comment>>error(new RuntimeException()));\n        mShotPresenter.getComments(TestDataFactory.randomInt(), 0, 0);\n        verify(mMockShotMvpView).showProgress();\n        verify(mMockShotMvpView).showError();\n        verify(mMockShotMvpView).hideProgress();\n    }\n\n    private void stubDataManagerGetComments(Single<List<Comment>> single) {\n        when(mMockDataManager.getComments(anyInt(), anyInt(), anyInt())).thenReturn(single);\n    }\n\n}\n'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'\n:package com.hitherejoe.androidtestcommon.util;\n\nimport android.text.TextUtils;\nimport android.view.View;\n\nimport org.hamcrest.Description;\nimport org.hamcrest.Matcher;\nimport org.hamcrest.TypeSafeMatcher;\n\nimport static android.support.test.espresso.intent.Checks.checkArgument;\nimport static android.support.test.espresso.matcher.ViewMatchers.isDescendantOfA;\nimport static android.support.test.espresso.matcher.ViewMatchers.withId;\nimport static android.support.test.espresso.matcher.ViewMatchers.withText;\nimport static org.hamcrest.core.AllOf.allOf;\n\npublic class CustomMatchers {\n\n    public static Matcher<View> withItemText(final String itemText, final int parentId) {\n        checkArgument(!TextUtils.isEmpty(itemText), \"itemText cannot be null or empty\");\n        return new TypeSafeMatcher<View>() {\n            @Override\n            public boolean matchesSafely(View item) {\n                return allOf(isDescendantOfA(withId(parentId)),\n                        withText(itemText)).matches(item);\n            }\n\n            @Override\n            public void describeTo(Description description) {\n                description.appendText(\"is isDescendantOfA RecyclerView with text \" + itemText);\n            }\n        };\n    }\n\n}\n\n'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'\n:package com.hitherejoe.bourboncorecommon.injection;\n\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\nimport javax.inject.Qualifier;\n\n@Qualifier\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface ApplicationContext {\n\n}",
        "gt": [
            "'Bourbon/CoreCommon/src/main/java/com/hitherejoe/bourboncorecommon/injection/ApplicationContext.java'",
            "'Bourbon/AndroidTestCommon/src/main/java/com/hitherejoe/androidtestcommon/util/CustomMatchers.java'",
            "'Bourbon/CoreCommon/src/test/java/com/hitherejoe/bourboncorecommon/ui/shot/ShotPresenterTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/BaseMetastoreTableOperations.java'",
            "'iceberg/hive/src/test/java/com/netflix/iceberg/hive/HiveTablesTest.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/hadoop/HadoopInputFile.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/BaseMetastoreTableOperations.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.base.Objects;\nimport com.netflix.iceberg.exceptions.RuntimeIOException;\nimport com.netflix.iceberg.hadoop.HadoopFileIO;\nimport com.netflix.iceberg.io.OutputFile;\nimport com.netflix.iceberg.util.Tasks;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.UUID;\n\nimport static com.netflix.iceberg.TableMetadataParser.getFileExtension;\nimport static com.netflix.iceberg.TableMetadataParser.read;\nimport static com.netflix.iceberg.hadoop.HadoopInputFile.fromLocation;\n\n\npublic abstract class BaseMetastoreTableOperations implements TableOperations {\n  private static final Logger LOG = LoggerFactory.getLogger(BaseMetastoreTableOperations.class);\n\n  public static final String TABLE_TYPE_PROP = \"table_type\";\n  public static final String ICEBERG_TABLE_TYPE_VALUE = \"iceberg\";\n  public static final String METADATA_LOCATION_PROP = \"metadata_location\";\n  public static final String PREVIOUS_METADATA_LOCATION_PROP = \"previous_metadata_location\";\n\n  private static final String METADATA_FOLDER_NAME = \"metadata\";\n  private static final String DATA_FOLDER_NAME = \"data\";\n  private static final String HIVE_LOCATION_FOLDER_NAME = \"empty\";\n\n  private final Configuration conf;\n  private final FileIO fileIo;\n\n  private TableMetadata currentMetadata = null;\n  private String currentMetadataLocation = null;\n  private boolean shouldRefresh = true;\n  private String baseLocation = null;\n  private int version = -1;\n\n  protected BaseMetastoreTableOperations(Configuration conf) {\n    this.conf = conf;\n    this.fileIo = new HadoopFileIO(conf);\n  }\n\n  @Override\n  public TableMetadata current() {\n    if (shouldRefresh) {\n      return refresh();\n    }\n    return currentMetadata;\n  }\n\n  public String currentMetadataLocation() {\n    return currentMetadataLocation;\n  }\n\n  public int currentVersion() {\n    return version;\n  }\n\n  protected void requestRefresh() {\n    this.shouldRefresh = true;\n  }\n\n  public String hiveTableLocation() {\n    return String.format(\"%s/%s\", baseLocation, HIVE_LOCATION_FOLDER_NAME);\n  }\n\n  protected String writeNewMetadata(TableMetadata metadata, int version) {\n    if (baseLocation == null) {\n      baseLocation = metadata.location();\n    }\n\n    String newTableMetadataFilePath = newTableMetadataFilePath(baseLocation, version);\n    OutputFile newMetadataLocation = fileIo.newOutputFile(newTableMetadataFilePath);\n\n\n    TableMetadataParser.write(metadata, newMetadataLocation);\n\n    return newTableMetadataFilePath;\n  }\n\n  protected void refreshFromMetadataLocation(String newLocation) {\n    refreshFromMetadataLocation(newLocation, 20);\n  }\n\n  protected void refreshFromMetadataLocation(String newLocation, int numRetries) {\n\n    if (!Objects.equal(currentMetadataLocation, newLocation)) {\n      LOG.info(\"Refreshing table metadata from new version: \" + newLocation);\n\n      Tasks.foreach(newLocation)\n          .retry(numRetries).exponentialBackoff(100, 5000, 600000, 4.0  )\n          .suppressFailureWhenFinished()\n          .run(location -> {\n            this.currentMetadata = read(this, fromLocation(location, conf));\n            this.currentMetadataLocation = location;\n            this.baseLocation = currentMetadata.location();\n            this.version = parseVersion(location);\n          });\n    }\n    this.shouldRefresh = false;\n  }\n\n  @Override\n  public String metadataFileLocation(String fileName) {\n    return String.format(\"%s/%s/%s\", baseLocation, METADATA_FOLDER_NAME, fileName);\n  }\n\n  @Override\n  public FileIO io() {\n    return fileIo;\n  }\n\n  @Override\n  public long newSnapshotId() {\n    return System.currentTimeMillis();\n  }\n\n  private String newTableMetadataFilePath(String baseLocation, int newVersion) {\n    return String.format(\"%s/%s/%05d-%s%s\",\n            baseLocation,\n            METADATA_FOLDER_NAME,\n            newVersion,\n            UUID.randomUUID(),\n            getFileExtension(this.conf));\n  }\n\n  private static int parseVersion(String metadataLocation) {\n    int versionStart = metadataLocation.lastIndexOf('/') + 1;\n    int versionEnd = metadataLocation.indexOf('-', versionStart);\n    try {\n      return Integer.valueOf(metadataLocation.substring(versionStart, versionEnd));\n    } catch (NumberFormatException e) {\n      LOG.warn(\"Unable to parse version from metadata location: \" + metadataLocation);\n      return -1;\n    }\n  }\n\n  private static FileSystem getFS(Path path, Configuration conf) {\n    try {\n      return path.getFileSystem(conf);\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n  }\n}\n\n'iceberg/hive/src/test/java/com/netflix/iceberg/hive/HiveTablesTest.java'\n:\npackage com.netflix.iceberg.hive;\n\nimport com.netflix.iceberg.exceptions.CommitFailedException;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.hadoop.hive.metastore.api.Table;\nimport org.apache.thrift.TException;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\nimport static com.netflix.iceberg.BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE;\nimport static com.netflix.iceberg.BaseMetastoreTableOperations.METADATA_LOCATION_PROP;\nimport static com.netflix.iceberg.BaseMetastoreTableOperations.TABLE_TYPE_PROP;\n\npublic class HiveTablesTest extends HiveTableBaseTest {\n  @Test\n  public void testCreate() throws TException {\n\n    final Table table = metastoreClient.getTable(DB_NAME, TABLE_NAME);\n\n\n    final Map<String, String> parameters = table.getParameters();\n    Assert.assertNotNull(parameters);\n    Assert.assertTrue(ICEBERG_TABLE_TYPE_VALUE.equalsIgnoreCase(parameters.get(TABLE_TYPE_PROP)));\n    Assert.assertTrue(ICEBERG_TABLE_TYPE_VALUE.equalsIgnoreCase(table.getTableType()));\n\n\n    Assert.assertEquals(getTableLocation(TABLE_NAME) , table.getSd().getLocation());\n\n\n    Assert.assertEquals(0 , table.getPartitionKeysSize());\n\n\n    Assert.assertEquals(1, metadataVersionFiles(TABLE_NAME).size());\n    Assert.assertEquals(0, manifestFiles(TABLE_NAME).size());\n\n    final com.netflix.iceberg.Table icebergTable = new HiveTables(hiveConf).load(DB_NAME, TABLE_NAME);\n\n    Assert.assertEquals(schema.asStruct(), icebergTable.schema().asStruct());\n  }\n\n  @Test\n  public void testExistingTableUpdate() throws TException {\n    com.netflix.iceberg.Table icebergTable = new HiveTables(hiveConf).load(DB_NAME, TABLE_NAME);\n\n    icebergTable.updateSchema().addColumn(\"data\", Types.LongType.get()).commit();\n\n    icebergTable = new HiveTables(hiveConf).load(DB_NAME, TABLE_NAME);\n\n\n    Assert.assertEquals(2, metadataVersionFiles(TABLE_NAME).size());\n    Assert.assertEquals(0, manifestFiles(TABLE_NAME).size());\n    Assert.assertEquals(altered.asStruct(), icebergTable.schema().asStruct());\n\n    final Table table = metastoreClient.getTable(DB_NAME, TABLE_NAME);\n    final List<String> hiveColumns = table.getSd().getCols().stream().map(f -> f.getName()).collect(Collectors.toList());\n    final List<String> icebergColumns = altered.columns().stream().map(f -> f.name()).collect(Collectors.toList());\n    Assert.assertEquals(icebergColumns, hiveColumns);\n  }\n\n  @Test(expected = CommitFailedException.class)\n  public void testFailure() throws TException {\n    com.netflix.iceberg.Table icebergTable = new HiveTables(hiveConf).load(DB_NAME, TABLE_NAME);\n    final Table table = metastoreClient.getTable(DB_NAME, TABLE_NAME);\n    final String dummyLocation = \"dummylocation\";\n    table.getParameters().put(METADATA_LOCATION_PROP, dummyLocation);\n    metastoreClient.alter_table(DB_NAME, TABLE_NAME, table);\n    icebergTable.updateSchema()\n            .addColumn(\"data\", Types.LongType.get())\n            .commit();\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/hadoop/HadoopInputFile.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/BaseMetastoreTableOperations.java'",
            "'iceberg/hive/src/test/java/com/netflix/iceberg/hive/HiveTablesTest.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'"
        ],
        "content": "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Lists;\nimport com.google.common.io.Files;\nimport com.netflix.iceberg.types.Types;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.Files.localInput;\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\npublic class TableTestBase {\n\n  static final Schema SCHEMA = new Schema(\n      required(3, \"id\", Types.IntegerType.get()),\n      required(4, \"data\", Types.StringType.get())\n  );\n\n\n  static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA)\n      .bucket(\"data\", 16)\n      .build();\n\n  static final DataFile FILE_A = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-a.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=0\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_B = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-b.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=1\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_C = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-c.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=2\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_D = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-d.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=3\")\n      .withRecordCount(0)\n      .build();\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();\n\n  File tableDir = null;\n  File metadataDir = null;\n  TestTables.TestTable table = null;\n\n  @Before\n  public void setupTable() throws Exception {\n    this.tableDir = temp.newFolder();\n    tableDir.delete();\n\n    this.metadataDir = new File(tableDir, \"metadata\");\n    this.table = create(SCHEMA, SPEC);\n  }\n\n  @After\n  public void cleanupTables() {\n    TestTables.clearTables();\n  }\n\n  List<File> listManifestFiles() {\n    return listManifestFiles(tableDir);\n  }\n\n  List<File> listManifestFiles(File tableDir) {\n    return Lists.newArrayList(new File(tableDir, \"metadata\").listFiles((dir, name) ->\n        !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n  }\n\n  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n    return TestTables.create(tableDir, \"test\", schema, spec);\n  }\n\n  TestTables.TestTable load() {\n    return TestTables.load(tableDir, \"test\");\n  }\n\n  Integer version() {\n    return TestTables.metadataVersion(\"test\");\n  }\n\n  TableMetadata readMetadata() {\n    return TestTables.readMetadata(\"test\");\n  }\n\n  void validateSnapshot(Snapshot old, Snapshot snap, DataFile... newFiles) {\n    List<ManifestFile> oldManifests = old != null ? old.manifests() : ImmutableList.of();\n\n\n    List<ManifestFile> newManifests = Lists.newArrayList(snap.manifests());\n    for (ManifestFile oldManifest : oldManifests) {\n      Assert.assertTrue(\"New snapshot should contain old manifests\",\n          newManifests.remove(oldManifest));\n    }\n\n    Assert.assertEquals(\"Should create 1 new manifest and reuse old manifests\",\n        1, newManifests.size());\n    ManifestFile manifest = newManifests.get(0);\n\n    long id = snap.snapshotId();\n    Iterator<String> newPaths = paths(newFiles).iterator();\n\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest.path())).entries()) {\n      DataFile file = entry.file();\n      Assert.assertEquals(\"Path should match expected\", newPaths.next(), file.path().toString());\n      Assert.assertEquals(\"File's snapshot ID should match\", id, entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", newPaths.hasNext());\n  }\n\n  List<String> paths(DataFile... dataFiles) {\n    List<String> paths = Lists.newArrayListWithExpectedSize(dataFiles.length);\n    for (DataFile file : dataFiles) {\n      paths.add(file.path().toString());\n    }\n    return paths;\n  }\n\n  static void validateManifest(ManifestFile manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    validateManifest(manifest.path(), ids, expectedFiles);\n  }\n\n  static void validateManifest(String manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static void validateManifestEntries(ManifestFile manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    validateManifestEntries(manifest.path(), ids, expectedFiles, expectedStatuses);\n  }\n\n  static void validateManifestEntries(String manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      final ManifestEntry.Status expectedStatus = expectedStatuses.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n      Assert.assertEquals(\"Entry status should match expected ID\",\n          expectedStatus, entry.status());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static Iterator<ManifestEntry.Status> statuses(ManifestEntry.Status... statuses) {\n    return Iterators.forArray(statuses);\n  }\n\n  static Iterator<Long> ids(Long... ids) {\n    return Iterators.forArray(ids);\n  }\n\n  static Iterator<DataFile> files(DataFile... files) {\n    return Iterators.forArray(files);\n  }\n\n  static Iterator<DataFile> files(ManifestFile manifest) {\n    return ManifestReader.read(localInput(manifest.path())).iterator();\n  }\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.base.Objects;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.types.Types.IntegerType;\nimport com.netflix.iceberg.types.Types.LongType;\nimport com.netflix.iceberg.types.Types.StructType;\nimport org.apache.avro.generic.IndexedRecord;\nimport org.apache.avro.specific.SpecificData;\n\nimport java.util.Collection;\n\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\nclass ManifestEntry implements IndexedRecord, SpecificData.SchemaConstructable{\n  enum Status {\n    EXISTING(0),\n    ADDED(1),\n    DELETED(2);\n\n    public static Status[] values = new Status[3];\n    static {\n      for (Status status : Status.values()) {\n        values[status.id] = status;\n      }\n    }\n\n    private final int id;\n\n    Status(int id) {\n      this.id = id;\n    }\n\n    public int id() {\n      return id;\n    }\n\n    public static Status fromId(int id) {\n      return values[id];\n    }\n  }\n\n  private final org.apache.avro.Schema schema;\n  private Status status = Status.EXISTING;\n  private long snapshotId = 0L;\n  private DataFile file = null;\n\n  public ManifestEntry(org.apache.avro.Schema schema) {\n    this.schema = schema;\n  }\n\n  ManifestEntry(StructType partitionType) {\n    this.schema = AvroSchemaUtil.convert(getSchema(partitionType), \"manifest_entry\");\n  }\n\n  private ManifestEntry(ManifestEntry toCopy) {\n    this.schema = toCopy.schema;\n    this.status = toCopy.status;\n    this.snapshotId = toCopy.snapshotId;\n    this.file = toCopy.file().copy();\n  }\n\n  ManifestEntry wrapExisting(long snapshotId, DataFile file) {\n    this.status = Status.EXISTING;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapAppend(long snapshotId, DataFile file) {\n    this.status = Status.ADDED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapDelete(long snapshotId, DataFile file) {\n    this.status = Status.DELETED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n\n  public Status status() {\n    return status;\n  }\n\n\n  public long snapshotId() {\n    return snapshotId;\n  }\n\n\n  public DataFile file() {\n    return file;\n  }\n\n  public ManifestEntry copy() {\n    return new ManifestEntry(this);\n  }\n\n  @Override\n  public void put(int i, Object v) {\n    switch (i) {\n      case 0:\n        this.status = Status.fromId((Integer) v);\n        return;\n      case 1:\n        this.snapshotId = (Long) v;\n        return;\n      case 2:\n        this.file = (DataFile) v;\n        return;\n      default:\n\n    }\n  }\n\n  @Override\n  public Object get(int i) {\n    switch (i) {\n      case 0:\n        return status.id();\n      case 1:\n        return snapshotId;\n      case 2:\n        return file;\n      default:\n        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n    }\n  }\n\n  @Override\n  public org.apache.avro.Schema getSchema() {\n    return schema;\n  }\n\n  static Schema projectSchema(StructType partitionType, Collection<String> columns) {\n    return wrapFileSchema(\n        new Schema(DataFile.getType(partitionType).fields()).select(columns).asStruct());\n  }\n\n  static Schema getSchema(StructType partitionType) {\n    return wrapFileSchema(DataFile.getType(partitionType));\n  }\n\n  private static Schema wrapFileSchema(StructType fileStruct) {\n\n    return new Schema(\n        required(0, \"status\", IntegerType.get()),\n        required(1, \"snapshot_id\", LongType.get()),\n        required(2, \"data_file\", fileStruct));\n  }\n\n  @Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n        .add(\"status\", status)\n        .add(\"snapshot_id\", snapshotId)\n        .add(\"file\", file)\n        .toString();\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/ssl/SslContextFactory.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Streams;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.drift.DriftScribeService;\nimport io.airlift.drift.server.DriftServer;\nimport io.airlift.drift.server.DriftService;\nimport io.airlift.drift.server.stats.NullMethodInvocationStatsFactory;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerConfig;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransportFactory;\nimport org.testng.annotations.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Lists.newArrayList;\nimport static io.airlift.drift.integration.ApacheThriftTesterUtil.apacheThriftTestClients;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_MESSAGES;\nimport static io.airlift.drift.integration.ClientTestUtils.HEADER_VALUE;\nimport static io.airlift.drift.integration.DriftNettyTesterUtil.driftNettyTestClients;\nimport static io.airlift.drift.integration.LegacyApacheThriftTesterUtil.legacyApacheThriftTestClients;\nimport static io.airlift.drift.transport.netty.codec.Transport.HEADER;\nimport static java.util.Collections.nCopies;\nimport static org.testng.Assert.assertEquals;\n\npublic class TestClientsWithDriftNettyServer\n{\n    private static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n\n    @Test\n    public void testDriftServer()\n    {\n        testDriftServer(ImmutableList.of());\n    }\n\n    @Test\n    public void testHandlersWithDriftServer()\n    {\n        TestingFilter firstFilter = new TestingFilter();\n        TestingFilter secondFilter = new TestingFilter();\n        List<MethodInvocationFilter> filters = ImmutableList.of(firstFilter, secondFilter);\n\n        int invocationCount = testDriftServer(filters);\n\n        firstFilter.assertCounts(invocationCount);\n        secondFilter.assertCounts(invocationCount);\n    }\n\n    private static int testDriftServer(List<MethodInvocationFilter> filters)\n    {\n        DriftScribeService scribeService = new DriftScribeService();\n        AtomicInteger invocationCount = new AtomicInteger();\n        AtomicInteger headerInvocationCount = new AtomicInteger();\n        testDriftServer(new DriftService(scribeService), address -> {\n            for (boolean secure : ImmutableList.of(true, false)) {\n                for (Transport transport : ImmutableList.of(HEADER)) {\n                    for (Protocol protocol : Protocol.values()) {\n                        int count = Streams.concat(\n                                legacyApacheThriftTestClients(filters, transport, protocol, secure).stream(),\n                                driftNettyTestClients(filters, transport, protocol, secure).stream(),\n                                apacheThriftTestClients(filters, transport, protocol, secure).stream())\n                                .mapToInt(client -> client.applyAsInt(address))\n                                .sum();\n                        invocationCount.addAndGet(count);\n                        if (transport == HEADER) {\n                            headerInvocationCount.addAndGet(count);\n                        }\n                    }\n                }\n            }\n        });\n\n        assertEquals(scribeService.getMessages(), newArrayList(concat(nCopies(invocationCount.get(), DRIFT_MESSAGES))));\n        assertEquals(scribeService.getHeaders(), newArrayList(nCopies(headerInvocationCount.get(), HEADER_VALUE)));\n\n        return invocationCount.get();\n    }\n\n    private static void testDriftServer(DriftService service, Consumer<HostAndPort> task)\n    {\n        DriftNettyServerConfig config = new DriftNettyServerConfig()\n                .setSslEnabled(true)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setKey(ClientTestUtils.getPrivateKeyFile());\n        TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n        DriftServer driftServer = new DriftServer(\n                new DriftNettyServerTransportFactory(config, testingAllocator),\n                CODEC_MANAGER,\n                new NullMethodInvocationStatsFactory(),\n                ImmutableSet.of(service),\n                ImmutableSet.of());\n        try {\n            driftServer.start();\n\n            HostAndPort address = HostAndPort.fromParts(\"localhost\", ((DriftNettyServerTransport) driftServer.getServerTransport()).getPort());\n\n            task.accept(address);\n        }\n        finally {\n            driftServer.shutdown();\n            testingAllocator.close();\n        }\n    }\n}\n\n'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.DriftClientFactory;\nimport io.airlift.drift.client.DriftClientFactoryManager;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.integration.scribe.drift.DriftAsyncScribe;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftScribe;\nimport io.airlift.drift.transport.client.DriftClientConfig;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.client.DriftNettyClientConfig;\nimport io.airlift.drift.transport.netty.client.DriftNettyClientModule;\nimport io.airlift.drift.transport.netty.client.DriftNettyConnectionFactoryConfig;\nimport io.airlift.drift.transport.netty.client.DriftNettyMethodInvokerFactory;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.ToIntFunction;\n\nimport static io.airlift.drift.client.ExceptionClassifier.NORMAL_RESULT;\nimport static io.airlift.drift.integration.ClientTestUtils.CODEC_MANAGER;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_MESSAGES;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_OK;\nimport static io.airlift.drift.integration.ClientTestUtils.HEADER_VALUE;\nimport static io.airlift.drift.integration.ClientTestUtils.logDriftClientBinder;\nimport static io.airlift.drift.transport.netty.client.DriftNettyMethodInvokerFactory.createStaticDriftNettyMethodInvokerFactory;\nimport static io.airlift.drift.transport.netty.codec.Protocol.COMPACT;\nimport static io.airlift.drift.transport.netty.codec.Transport.HEADER;\nimport static org.testng.Assert.assertEquals;\n\nfinal class DriftNettyTesterUtil\n{\n    private DriftNettyTesterUtil() {}\n\n    public static List<ToIntFunction<HostAndPort>> driftNettyTestClients(List<MethodInvocationFilter> filters, Transport transport, Protocol protocol, boolean secure)\n    {\n        return ImmutableList.of(\n                address -> logNettyDriftClient(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyStaticDriftClient(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyDriftClientAsync(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyClientBinder(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure));\n    }\n\n    private static int logNettyDriftClient(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<String> methodInvokerFactory = new DriftNettyMethodInvokerFactory<>(\n                        new DriftNettyConnectionFactoryConfig(),\n                        clientIdentity -> config,\n                        testingAllocator)) {\n            DriftClientFactoryManager<String> clientFactoryManager = new DriftClientFactoryManager<>(CODEC_MANAGER, methodInvokerFactory);\n            DriftClientFactory proxyFactory = clientFactoryManager.createDriftClientFactory(\"clientIdentity\", addressSelector, NORMAL_RESULT);\n\n            DriftScribe scribe = proxyFactory.createDriftClient(DriftScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyStaticDriftClient(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<?> methodInvokerFactory = createStaticDriftNettyMethodInvokerFactory(config, testingAllocator)) {\n            DriftClientFactory proxyFactory = new DriftClientFactory(CODEC_MANAGER, methodInvokerFactory, addressSelector);\n\n            DriftScribe scribe = proxyFactory.createDriftClient(DriftScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyDriftClientAsync(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<String> methodInvokerFactory = new DriftNettyMethodInvokerFactory<>(\n                        new DriftNettyConnectionFactoryConfig(),\n                        clientIdentity -> config,\n                        testingAllocator)) {\n            DriftClientFactoryManager<String> proxyFactoryManager = new DriftClientFactoryManager<>(CODEC_MANAGER, methodInvokerFactory);\n            DriftClientFactory proxyFactory = proxyFactoryManager.createDriftClientFactory(\"myFactory\", addressSelector, NORMAL_RESULT);\n\n            DriftAsyncScribe scribe = proxyFactory.createDriftClient(DriftAsyncScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries).get(), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyClientBinder(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator()) {\n            return logDriftClientBinder(address, headerValue, entries, new DriftNettyClientModule(testingAllocator), filters, transport, protocol, secure);\n        }\n    }\n\n    private static boolean isValidConfiguration(Transport transport, Protocol protocol)\n    {\n\n        return transport != HEADER || protocol != COMPACT;\n    }\n}\n",
        "gt": [
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/ssl/SslContextFactory.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n\n'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport com.jnardari.opencv_androidsamples.R;\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Mat;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport android.util.Log;\nimport android.view.SurfaceView;\nimport android.view.WindowManager;\n\npublic class Tutorial1Activity extends AppCompatActivity implements CvCameraViewListener2 {\n    private static final String TAG = \"Tutorial1Activity\";\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n    private boolean              mIsJavaCamera = true;\n    private MenuItem             mItemSwitchCamera = null;\n\n    private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public Tutorial1Activity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_tutorial1);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.tutorial1_activity_java_surface_view);\n\n        mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);\n\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n    }\n\n    public void onCameraViewStopped() {\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        return inputFrame.rgba();\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'"
        ]
    },
    {
        "files": [
            "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'",
            "'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'",
            "'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'"
        ],
        "content": "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'\n:\npackage org.jeasy.flows.work;\n\n\npublic enum WorkStatus {\n\n\n    FAILED,\n\n\n    COMPLETED\n}\n\n'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'\n:\npackage org.jeasy.flows.engine;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.jeasy.flows.work.DefaultWorkReport;\nimport org.jeasy.flows.work.Work;\nimport org.jeasy.flows.work.WorkContext;\nimport org.jeasy.flows.work.WorkReport;\nimport org.jeasy.flows.work.WorkStatus;\nimport org.jeasy.flows.workflow.*;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.jeasy.flows.engine.WorkFlowEngineBuilder.aNewWorkFlowEngine;\nimport static org.jeasy.flows.work.WorkReportPredicate.COMPLETED;\nimport static org.jeasy.flows.workflow.ConditionalFlow.Builder.aNewConditionalFlow;\nimport static org.jeasy.flows.workflow.ParallelFlow.Builder.aNewParallelFlow;\nimport static org.jeasy.flows.workflow.RepeatFlow.Builder.aNewRepeatFlow;\nimport static org.jeasy.flows.workflow.SequentialFlow.Builder.aNewSequentialFlow;\n\npublic class WorkFlowEngineImplTest {\n\n    private final WorkFlowEngine workFlowEngine = new WorkFlowEngineImpl();\n\n    @Test\n    public void run() {\n\n        WorkFlow workFlow = Mockito.mock(WorkFlow.class);\n        WorkContext workContext = Mockito.mock(WorkContext.class);\n\n\n        workFlowEngine.run(workFlow,workContext);\n\n\n        Mockito.verify(workFlow).execute(workContext);\n    }\n\n\n\n    @Test\n    public void composeWorkFlowFromSeparateFlowsAndExecuteIt() {\n\n        PrintMessageWork work1 = new PrintMessageWork(\"foo\");\n        PrintMessageWork work2 = new PrintMessageWork(\"hello\");\n        PrintMessageWork work3 = new PrintMessageWork(\"world\");\n        PrintMessageWork work4 = new PrintMessageWork(\"done\");\n\n        RepeatFlow repeatFlow = aNewRepeatFlow()\n                .named(\"print foo 3 times\")\n                .repeat(work1)\n                .times(3)\n                .build();\n\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        ParallelFlow parallelFlow = aNewParallelFlow()\n                .named(\"print 'hello' and 'world' in parallel\")\n                .execute(work2, work3)\n                .with(executorService)\n                .build();\n\n        ConditionalFlow conditionalFlow = aNewConditionalFlow()\n                .execute(parallelFlow)\n                .when(COMPLETED)\n                .then(work4)\n                .build();\n\n        SequentialFlow sequentialFlow = aNewSequentialFlow()\n                .execute(repeatFlow)\n                .then(conditionalFlow)\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        WorkReport workReport = workFlowEngine.run(sequentialFlow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n        System.out.println(\"workflow report = \" + workReport);\n    }\n\n    @Test\n    public void defineWorkFlowInlineAndExecuteIt() {\n\n        PrintMessageWork work1 = new PrintMessageWork(\"foo\");\n        PrintMessageWork work2 = new PrintMessageWork(\"hello\");\n        PrintMessageWork work3 = new PrintMessageWork(\"world\");\n        PrintMessageWork work4 = new PrintMessageWork(\"done\");\n\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        WorkFlow workflow = aNewSequentialFlow()\n                .execute(aNewRepeatFlow()\n                            .named(\"print foo 3 times\")\n                            .repeat(work1)\n                            .times(3)\n                            .build())\n                .then(aNewConditionalFlow()\n                        .execute(aNewParallelFlow()\n                                    .named(\"print 'hello' and 'world' in parallel\")\n                                    .execute(work2, work3)\n                                    .with(executorService)\n                                    .build())\n                        .when(COMPLETED)\n                        .then(work4)\n                        .build())\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        WorkReport workReport = workFlowEngine.run(workflow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n        System.out.println(\"workflow report = \" + workReport);\n    }\n\n    @Test\n    public void useWorkContextToPassInitialParametersAndShareDataBetweenWorkUnits() {\n        WordCountWork work1 = new WordCountWork(1);\n        WordCountWork work2 = new WordCountWork(2);\n        AggregateWordCountsWork work3 = new AggregateWordCountsWork();\n        PrintWordCount work4 = new PrintWordCount();\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        WorkFlow workflow = aNewSequentialFlow()\n                .execute(aNewParallelFlow()\n                            .execute(work1, work2)\n                            .with(executorService)\n                            .build())\n                .then(work3)\n                .then(work4)\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        workContext.put(\"partition1\", \"hello foo\");\n        workContext.put(\"partition2\", \"hello bar\");\n        WorkReport workReport = workFlowEngine.run(workflow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n    }\n\n    static class PrintMessageWork implements Work {\n\n        private final String message;\n\n        public PrintMessageWork(String message) {\n            this.message = message;\n        }\n\n        public String getName() {\n            return \"print message work\";\n        }\n\n        public WorkReport execute(WorkContext workContext) {\n            System.out.println(message);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n\n    }\n\n    static class WordCountWork implements Work {\n\n        private final int partition;\n\n        public WordCountWork(int partition) {\n            this.partition = partition;\n        }\n\n        @Override\n        public String getName() {\n            return \"count words in a given string\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            String input = (String) workContext.get(\"partition\" + partition);\n            workContext.put(\"wordCountInPartition\" + partition, input.split(\" \").length);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n\n    static class AggregateWordCountsWork implements Work {\n\n        @Override\n        public String getName() {\n            return \"aggregate word counts from partitions\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            Set<Map.Entry<String, Object>> entrySet = workContext.getEntrySet();\n            int sum = 0;\n            for (Map.Entry<String, Object> entry : entrySet) {\n                if (entry.getKey().contains(\"InPartition\")) {\n                    sum += (int) entry.getValue();\n                }\n            }\n            workContext.put(\"totalCount\", sum);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n\n    static class PrintWordCount implements Work {\n\n        @Override\n        public String getName() {\n            return \"print total word count\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            int totalCount = (int) workContext.get(\"totalCount\");\n            System.out.println(totalCount);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n}\n\n'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'\n:\npackage org.jeasy.flows.workflow;\n\nimport org.jeasy.flows.work.Work;\nimport org.jeasy.flows.work.WorkContext;\nimport org.jeasy.flows.work.WorkReport;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.jeasy.flows.work.WorkStatus.FAILED;\n\n\npublic class SequentialFlow extends AbstractWorkFlow {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SequentialFlow.class.getName());\n\n    private final List<Work> workUnits = new ArrayList<>();\n\n    SequentialFlow(String name, List<Work> workUnits) {\n        super(name);\n        this.workUnits.addAll(workUnits);\n    }\n\n\n    public WorkReport execute(WorkContext workContext) {\n        WorkReport workReport = null;\n        for (Work work : workUnits) {\n            workReport = work.execute(workContext);\n            if (workReport != null && FAILED.equals(workReport.getStatus())) {\n                LOGGER.info(\"Work unit ''{}'' has failed, skipping subsequent work units\", work.getName());\n                break;\n            }\n        }\n        return workReport;\n    }\n\n    public static class Builder {\n\n        private Builder() {\n\n        }\n\n        public static NameStep aNewSequentialFlow() {\n            return new BuildSteps();\n        }\n\n        public interface NameStep extends ExecuteStep {\n            ExecuteStep named(String name);\n        }\n\n        public interface ExecuteStep {\n            ThenStep execute(Work initialWork);\n            ThenStep execute(List<Work> initialWorkUnits);\n        }\n\n        public interface ThenStep {\n            ThenStep then(Work nextWork);\n            ThenStep then(List<Work> nextWorkUnits);\n            SequentialFlow build();\n        }\n\n        private static class BuildSteps implements NameStep, ExecuteStep, ThenStep {\n\n            private String name;\n            private final List<Work> works;\n\n            BuildSteps() {\n                this.name = UUID.randomUUID().toString();\n                this.works = new ArrayList<>();\n            }\n\n            public ExecuteStep named(String name) {\n                this.name = name;\n                return this;\n            }\n\n            @Override\n            public ThenStep execute(Work initialWork) {\n                this.works.add(initialWork);\n                return this;\n            }\n\n            @Override\n            public ThenStep execute(List<Work> initialWorkUnits) {\n                this.works.addAll(initialWorkUnits);\n                return this;\n            }\n\n            @Override\n            public ThenStep then(Work nextWork) {\n                this.works.add(nextWork);\n                return this;\n            }\n\n            @Override\n            public ThenStep then(List<Work> nextWorkUnits) {\n                this.works.addAll(nextWorkUnits);\n                return this;\n            }\n\n            @Override\n            public SequentialFlow build() {\n                return new SequentialFlow(this.name, this.works);\n            }\n        }\n    }\n}\n",
        "gt": [
            "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'",
            "'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'",
            "'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'"
        ]
    },
    {
        "files": [
            "'fraud-detection-demo/flink-job/src/main/java/com/ververica/field/config/Parameters.java'",
            "'fraud-detection-demo/flink-job/src/main/java/com/ververica/field/dynamicrules/RulesEvaluator.java'",
            "'fraud-detection-demo/flink-job/src/test/java/com/ververica/field/dynamicrules/RulesEvaluatorTest.java'"
        ],
        "content": "'fraud-detection-demo/flink-job/src/main/java/com/ververica/field/config/Parameters.java'\n:\n\npackage com.ververica.field.config;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport org.apache.flink.api.java.utils.ParameterTool;\n\npublic class Parameters {\n\n  private final ParameterTool tool;\n\n  public Parameters(ParameterTool tool) {\n    this.tool = tool;\n  }\n\n  <T> T getOrDefault(Param<T> param) {\n    if (!tool.has(param.getName())) {\n      return param.getDefaultValue();\n    }\n    Object value;\n    if (param.getType() == Integer.class) {\n      value = tool.getInt(param.getName());\n    } else if (param.getType() == Long.class) {\n      value = tool.getLong(param.getName());\n    } else if (param.getType() == Double.class) {\n      value = tool.getDouble(param.getName());\n    } else if (param.getType() == Boolean.class) {\n      value = tool.getBoolean(param.getName());\n    } else {\n      value = tool.get(param.getName());\n    }\n    return param.getType().cast(value);\n  }\n\n  public static Parameters fromArgs(String[] args) {\n    ParameterTool tool = ParameterTool.fromArgs(args);\n    return new Parameters(tool);\n  }\n\n\n  public static final Param<String> KAFKA_HOST = Param.string(\"kafka-host\", \"localhost\");\n  public static final Param<Integer> KAFKA_PORT = Param.integer(\"kafka-port\", 9092);\n\n  public static final Param<String> DATA_TOPIC = Param.string(\"data-topic\", \"livetransactions\");\n  public static final Param<String> ALERTS_TOPIC = Param.string(\"alerts-topic\", \"alerts\");\n  public static final Param<String> RULES_TOPIC = Param.string(\"rules-topic\", \"rules\");\n  public static final Param<String> LATENCY_TOPIC = Param.string(\"latency-topic\", \"latency\");\n  public static final Param<String> RULES_EXPORT_TOPIC =\n      Param.string(\"current-rules-topic\", \"current-rules\");\n\n  public static final Param<String> OFFSET = Param.string(\"offset\", \"latest\");\n\n\n  public static final Param<String> GCP_PROJECT_NAME = Param.string(\"gcp-project\", \"da-fe-212612\");\n  public static final Param<String> GCP_PUBSUB_RULES_SUBSCRIPTION =\n      Param.string(\"pubsub-rules\", \"rules-demo\");\n  public static final Param<String> GCP_PUBSUB_ALERTS_SUBSCRIPTION =\n      Param.string(\"pubsub-alerts\", \"alerts-demo\");\n  public static final Param<String> GCP_PUBSUB_LATENCY_SUBSCRIPTION =\n      Param.string(\"pubsub-latency\", \"latency-demo\");\n  public static final Param<String> GCP_PUBSUB_RULES_EXPORT_SUBSCRIPTION =\n      Param.string(\"pubsub-rules-export\", \"current-rules-demo\");\n\n\n  public static final Param<Integer> SOCKET_PORT = Param.integer(\"pubsub-rules-export\", 9999);\n\n\n\n  public static final Param<String> RULES_SOURCE = Param.string(\"rules-source\", \"SOCKET\");\n  public static final Param<String> TRANSACTIONS_SOURCE = Param.string(\"data-source\", \"GENERATOR\");\n  public static final Param<String> ALERTS_SINK = Param.string(\"alerts-sink\", \"STDOUT\");\n  public static final Param<String> LATENCY_SINK = Param.string(\"latency-sink\", \"STDOUT\");\n  public static final Param<String> RULES_EXPORT_SINK = Param.string(\"rules-export-sink\", \"STDOUT\");\n\n  public static final Param<Integer> RECORDS_PER_SECOND = Param.integer(\"records-per-second\", 2);\n\n  public static final Param<Boolean> LOCAL_EXECUTION = Param.bool(\"local\", false);\n\n  public static final Param<Integer> SOURCE_PARALLELISM = Param.integer(\"source-parallelism\", 2);\n\n  public static final Param<Boolean> ENABLE_CHECKPOINTS = Param.bool(\"checkpoints\", false);\n\n  public static final Param<Integer> CHECKPOINT_INTERVAL =\n      Param.integer(\"checkpoint-interval\", 60_000_0);\n  public static final Param<Integer> MIN_PAUSE_BETWEEN_CHECKPOINTS =\n      Param.integer(\"min-pause-btwn-checkpoints\", 10000);\n  public static final Param<Integer> OUT_OF_ORDERNESS = Param.integer(\"out-of-orderdness\", 500);\n\n\n\n  public static final List<Param<String>> STRING_PARAMS =\n      Arrays.asList(\n          KAFKA_HOST,\n          DATA_TOPIC,\n          ALERTS_TOPIC,\n          RULES_TOPIC,\n          LATENCY_TOPIC,\n          RULES_EXPORT_TOPIC,\n          OFFSET,\n          GCP_PROJECT_NAME,\n          GCP_PUBSUB_RULES_SUBSCRIPTION,\n          GCP_PUBSUB_ALERTS_SUBSCRIPTION,\n          GCP_PUBSUB_LATENCY_SUBSCRIPTION,\n          GCP_PUBSUB_RULES_EXPORT_SUBSCRIPTION,\n          RULES_SOURCE,\n          TRANSACTIONS_SOURCE,\n          ALERTS_SINK,\n          LATENCY_SINK,\n          RULES_EXPORT_SINK);\n\n  public static final List<Param<Integer>> INT_PARAMS =\n      Arrays.asList(\n          KAFKA_PORT,\n          SOCKET_PORT,\n          RECORDS_PER_SECOND,\n          SOURCE_PARALLELISM,\n          CHECKPOINT_INTERVAL,\n          MIN_PAUSE_BETWEEN_CHECKPOINTS,\n          OUT_OF_ORDERNESS);\n\n  public static final List<Param<Boolean>> BOOL_PARAMS =\n      Arrays.asList(LOCAL_EXECUTION, ENABLE_CHECKPOINTS);\n}\n\n'fraud-detection-demo/flink-job/src/main/java/com/ververica/field/dynamicrules/RulesEvaluator.java'\n:\n\npackage com.ververica.field.dynamicrules;\n\nimport static com.ververica.field.config.Parameters.CHECKPOINT_INTERVAL;\nimport static com.ververica.field.config.Parameters.ENABLE_CHECKPOINTS;\nimport static com.ververica.field.config.Parameters.LOCAL_EXECUTION;\nimport static com.ververica.field.config.Parameters.MIN_PAUSE_BETWEEN_CHECKPOINTS;\nimport static com.ververica.field.config.Parameters.OUT_OF_ORDERNESS;\nimport static com.ververica.field.config.Parameters.RULES_SOURCE;\nimport static com.ververica.field.config.Parameters.SOURCE_PARALLELISM;\n\nimport com.ververica.field.config.Config;\nimport com.ververica.field.dynamicrules.functions.AverageAggregate;\nimport com.ververica.field.dynamicrules.functions.DynamicAlertFunction;\nimport com.ververica.field.dynamicrules.functions.DynamicKeyFunction;\nimport com.ververica.field.dynamicrules.sinks.AlertsSink;\nimport com.ververica.field.dynamicrules.sinks.CurrentRulesSink;\nimport com.ververica.field.dynamicrules.sinks.LatencySink;\nimport com.ververica.field.dynamicrules.sources.RulesSource;\nimport com.ververica.field.dynamicrules.sources.TransactionsSource;\nimport java.io.IOException;\nimport java.util.concurrent.TimeUnit;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.flink.api.common.restartstrategy.RestartStrategies;\nimport org.apache.flink.api.common.state.MapStateDescriptor;\nimport org.apache.flink.api.common.typeinfo.BasicTypeInfo;\nimport org.apache.flink.api.common.typeinfo.TypeInformation;\nimport org.apache.flink.configuration.ConfigConstants;\nimport org.apache.flink.configuration.Configuration;\nimport org.apache.flink.streaming.api.TimeCharacteristic;\nimport org.apache.flink.streaming.api.datastream.BroadcastStream;\nimport org.apache.flink.streaming.api.datastream.DataStream;\nimport org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;\nimport org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;\nimport org.apache.flink.streaming.api.functions.source.SourceFunction;\nimport org.apache.flink.streaming.api.functions.timestamps.BoundedOutOfOrdernessTimestampExtractor;\nimport org.apache.flink.streaming.api.windowing.time.Time;\nimport org.apache.flink.util.OutputTag;\n\n@Slf4j\npublic class RulesEvaluator {\n\n  private Config config;\n\n  RulesEvaluator(Config config) {\n    this.config = config;\n  }\n\n  public void run() throws Exception {\n\n    RulesSource.Type rulesSourceType = getRulesSourceType();\n\n    boolean isLocal = config.get(LOCAL_EXECUTION);\n    boolean enableCheckpoints = config.get(ENABLE_CHECKPOINTS);\n    int checkpointsInterval = config.get(CHECKPOINT_INTERVAL);\n    int minPauseBtwnCheckpoints = config.get(CHECKPOINT_INTERVAL);\n\n\n    StreamExecutionEnvironment env = configureStreamExecutionEnvironment(rulesSourceType, isLocal);\n\n    if (enableCheckpoints) {\n      env.enableCheckpointing(checkpointsInterval);\n      env.getCheckpointConfig().setMinPauseBetweenCheckpoints(minPauseBtwnCheckpoints);\n    }\n\n\n    DataStream<Rule> rulesUpdateStream = getRulesUpdateStream(env);\n    DataStream<Transaction> transactions = getTransactionsStream(env);\n\n    BroadcastStream<Rule> rulesStream = rulesUpdateStream.broadcast(Descriptors.rulesDescriptor);\n\n\n    DataStream<Alert> alerts =\n        transactions\n            .connect(rulesStream)\n            .process(new DynamicKeyFunction())\n            .uid(\"DynamicKeyFunction\")\n            .name(\"Dynamic Partitioning Function\")\n            .keyBy((keyed) -> keyed.getKey())\n            .connect(rulesStream)\n            .process(new DynamicAlertFunction())\n            .uid(\"DynamicAlertFunction\")\n            .name(\"Dynamic Rule Evaluation Function\");\n\n    DataStream<String> allRuleEvaluations =\n        ((SingleOutputStreamOperator<Alert>) alerts).getSideOutput(Descriptors.demoSinkTag);\n\n    DataStream<Long> latency =\n        ((SingleOutputStreamOperator<Alert>) alerts).getSideOutput(Descriptors.latencySinkTag);\n\n    DataStream<Rule> currentRules =\n        ((SingleOutputStreamOperator<Alert>) alerts).getSideOutput(Descriptors.currentRulesSinkTag);\n\n    alerts.print().name(\"Alert STDOUT Sink\");\n    allRuleEvaluations.print().setParallelism(1).name(\"Rule Evaluation Sink\");\n\n    DataStream<String> alertsJson = AlertsSink.alertsStreamToJson(alerts);\n    DataStream<String> currentRulesJson = CurrentRulesSink.rulesStreamToJson(currentRules);\n\n    currentRulesJson.print();\n\n    alertsJson\n        .addSink(AlertsSink.createAlertsSink(config))\n        .setParallelism(1)\n        .name(\"Alerts JSON Sink\");\n    currentRulesJson.addSink(CurrentRulesSink.createRulesSink(config)).setParallelism(1);\n\n    DataStream<String> latencies =\n        latency\n            .timeWindowAll(Time.seconds(10))\n            .aggregate(new AverageAggregate())\n            .map(String::valueOf);\n    latencies.addSink(LatencySink.createLatencySink(config));\n\n    env.execute(\"Fraud Detection Engine\");\n  }\n\n  private DataStream<Transaction> getTransactionsStream(StreamExecutionEnvironment env) {\n\n    SourceFunction<String> transactionSource = TransactionsSource.createTransactionsSource(config);\n    int sourceParallelism = config.get(SOURCE_PARALLELISM);\n    DataStream<String> transactionsStringsStream =\n        env.addSource(transactionSource)\n            .name(\"Transactions Source\")\n            .setParallelism(sourceParallelism);\n    DataStream<Transaction> transactionsStream =\n        TransactionsSource.stringsStreamToTransactions(transactionsStringsStream);\n    return transactionsStream.assignTimestampsAndWatermarks(\n        new SimpleBoundedOutOfOrdernessTimestampExtractor<>(config.get(OUT_OF_ORDERNESS)));\n  }\n\n  private DataStream<Rule> getRulesUpdateStream(StreamExecutionEnvironment env) throws IOException {\n\n    RulesSource.Type rulesSourceEnumType = getRulesSourceType();\n\n    SourceFunction<String> rulesSource = RulesSource.createRulesSource(config);\n    DataStream<String> rulesStrings =\n        env.addSource(rulesSource).name(rulesSourceEnumType.getName()).setParallelism(1);\n    return RulesSource.stringsStreamToRules(rulesStrings);\n  }\n\n  private RulesSource.Type getRulesSourceType() {\n    String rulesSource = config.get(RULES_SOURCE);\n    return RulesSource.Type.valueOf(rulesSource.toUpperCase());\n  }\n\n  private StreamExecutionEnvironment configureStreamExecutionEnvironment(\n      RulesSource.Type rulesSourceEnumType, boolean isLocal) {\n    Configuration flinkConfig = new Configuration();\n    flinkConfig.setBoolean(ConfigConstants.LOCAL_START_WEBSERVER, true);\n\n    StreamExecutionEnvironment env =\n        isLocal\n            ? StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(flinkConfig)\n            : StreamExecutionEnvironment.getExecutionEnvironment();\n\n    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);\n    env.getCheckpointConfig().setCheckpointInterval(config.get(CHECKPOINT_INTERVAL));\n    env.getCheckpointConfig()\n        .setMinPauseBetweenCheckpoints(config.get(MIN_PAUSE_BETWEEN_CHECKPOINTS));\n\n    configureRestartStrategy(env, rulesSourceEnumType);\n    return env;\n  }\n\n  private static class SimpleBoundedOutOfOrdernessTimestampExtractor<T extends Transaction>\n      extends BoundedOutOfOrdernessTimestampExtractor<T> {\n\n    public SimpleBoundedOutOfOrdernessTimestampExtractor(int outOfOrderdnessMillis) {\n      super(Time.of(outOfOrderdnessMillis, TimeUnit.MILLISECONDS));\n    }\n\n    @Override\n    public long extractTimestamp(T element) {\n      return element.getEventTime();\n    }\n  }\n\n  private void configureRestartStrategy(\n      StreamExecutionEnvironment env, RulesSource.Type rulesSourceEnumType) {\n    switch (rulesSourceEnumType) {\n      case SOCKET:\n        env.setRestartStrategy(\n            RestartStrategies.fixedDelayRestart(\n                10, org.apache.flink.api.common.time.Time.of(10, TimeUnit.SECONDS)));\n        break;\n      case KAFKA:\n\n\n    }\n  }\n\n  public static class Descriptors {\n    public static final MapStateDescriptor<Integer, Rule> rulesDescriptor =\n        new MapStateDescriptor<>(\n            \"rules\", BasicTypeInfo.INT_TYPE_INFO, TypeInformation.of(Rule.class));\n\n    public static final OutputTag<String> demoSinkTag = new OutputTag<String>(\"demo-sink\") {};\n    public static final OutputTag<Long> latencySinkTag = new OutputTag<Long>(\"latency-sink\") {};\n    public static final OutputTag<Rule> currentRulesSinkTag =\n        new OutputTag<Rule>(\"current-rules-sink\") {};\n  }\n}\n",
        "gt": [
            "'fraud-detection-demo/flink-job/src/main/java/com/ververica/field/config/Parameters.java'",
            "'fraud-detection-demo/flink-job/src/main/java/com/ververica/field/dynamicrules/RulesEvaluator.java'",
            "'fraud-detection-demo/flink-job/src/test/java/com/ververica/field/dynamicrules/RulesEvaluatorTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.PartitionField;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.StructLike;\nimport com.netflix.iceberg.transforms.Transform;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.Decimal;\nimport org.apache.spark.unsafe.types.UTF8String;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\nclass PartitionKey implements StructLike {\n\n  private final PartitionSpec spec;\n  private final int size;\n  private final Object[] partitionTuple;\n  private final Transform[] transforms;\n  private final Accessor<InternalRow>[] accessors;\n\n  @SuppressWarnings(\"unchecked\")\n  PartitionKey(PartitionSpec spec) {\n    this.spec = spec;\n\n    List<PartitionField> fields = spec.fields();\n    this.size = fields.size();\n    this.partitionTuple = new Object[size];\n    this.transforms = new Transform[size];\n    this.accessors = (Accessor<InternalRow>[]) Array.newInstance(Accessor.class, size);\n\n    Schema schema = spec.schema();\n    Map<Integer, Accessor<InternalRow>> accessors = buildAccessors(schema);\n    for (int i = 0; i < size; i += 1) {\n      PartitionField field = fields.get(i);\n      Accessor<InternalRow> accessor = accessors.get(field.sourceId());\n      if (accessor == null) {\n        throw new RuntimeException(\n            \"Cannot build accessor for field: \" + schema.findField(field.sourceId()));\n      }\n      this.accessors[i] = accessor;\n      this.transforms[i] = field.transform();\n    }\n  }\n\n  private PartitionKey(PartitionKey toCopy) {\n    this.spec = toCopy.spec;\n    this.size = toCopy.size;\n    this.partitionTuple = new Object[toCopy.partitionTuple.length];\n    this.transforms = toCopy.transforms;\n    this.accessors = toCopy.accessors;\n\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      this.partitionTuple[i] = defensiveCopyIfNeeded(toCopy.partitionTuple[i]);\n    }\n  }\n\n  private Object defensiveCopyIfNeeded(Object obj) {\n    if (obj instanceof UTF8String) {\n\n      byte[] bytes = ((UTF8String) obj).getBytes();\n      return UTF8String.fromBytes(Arrays.copyOf(bytes, bytes.length));\n    }\n    return obj;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[\");\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      if (i > 0) {\n        sb.append(\", \");\n      }\n      sb.append(partitionTuple[i]);\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  PartitionKey copy() {\n    return new PartitionKey(this);\n  }\n\n  String toPath() {\n    return spec.partitionToPath(this);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  void partition(InternalRow row) {\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      Transform<Object, Object> transform = transforms[i];\n      partitionTuple[i] = transform.apply(accessors[i].get(row));\n    }\n  }\n\n  @Override\n  public int size() {\n    return size;\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public <T> T get(int pos, Class<T> javaClass) {\n    return javaClass.cast(partitionTuple[pos]);\n  }\n\n  @Override\n  public <T> void set(int pos, T value) {\n    partitionTuple[pos] = value;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    PartitionKey that = (PartitionKey) o;\n    return Arrays.equals(partitionTuple, that.partitionTuple);\n  }\n\n  @Override\n  public int hashCode() {\n    return Arrays.hashCode(partitionTuple);\n  }\n\n  private interface Accessor<T> {\n    Object get(T container);\n  }\n\n  private static Map<Integer, Accessor<InternalRow>> buildAccessors(Schema schema) {\n    return TypeUtil.visit(schema, new BuildPositionAccessors());\n  }\n\n  private static Accessor<InternalRow> newAccessor(int p, Type type) {\n    switch (type.typeId()) {\n      case STRING:\n        return new StringAccessor(p, convert(type));\n      case DECIMAL:\n        return new DecimalAccessor(p, convert(type));\n      default:\n        return new PositionAccessor(p, convert(type));\n    }\n  }\n\n  private static Accessor<InternalRow> newAccessor(int p, boolean isOptional, Types.StructType type,\n                                                   Accessor<InternalRow> accessor) {\n    int size = type.fields().size();\n    if (isOptional) {\n\n      return new WrappedPositionAccessor(p, size, accessor);\n    } else if (accessor instanceof PositionAccessor) {\n      return new Position2Accessor(p, size, (PositionAccessor) accessor);\n    } else if (accessor instanceof Position2Accessor) {\n      return new Position3Accessor(p, size, (Position2Accessor) accessor);\n    } else {\n      return new WrappedPositionAccessor(p, size, accessor);\n    }\n  }\n\n  private static class BuildPositionAccessors\n      extends TypeUtil.SchemaVisitor<Map<Integer, Accessor<InternalRow>>> {\n    @Override\n    public Map<Integer, Accessor<InternalRow>> schema(\n        Schema schema, Map<Integer, Accessor<InternalRow>> structResult) {\n      return structResult;\n    }\n\n    @Override\n    public Map<Integer, Accessor<InternalRow>> struct(\n        Types.StructType struct, List<Map<Integer, Accessor<InternalRow>>> fieldResults) {\n      Map<Integer, Accessor<InternalRow>> accessors = Maps.newHashMap();\n      List<Types.NestedField> fields = struct.fields();\n      for (int i = 0; i < fieldResults.size(); i += 1) {\n        Types.NestedField field = fields.get(i);\n        Map<Integer, Accessor<InternalRow>> result = fieldResults.get(i);\n        if (result != null) {\n          for (Map.Entry<Integer, Accessor<InternalRow>> entry : result.entrySet()) {\n            accessors.put(entry.getKey(), newAccessor(i, field.isOptional(),\n                field.type().asNestedType().asStructType(), entry.getValue()));\n          }\n        } else {\n          accessors.put(field.fieldId(), newAccessor(i, field.type()));\n        }\n      }\n\n      if (accessors.isEmpty()) {\n        return null;\n      }\n\n      return accessors;\n    }\n\n    @Override\n    public Map<Integer, Accessor<InternalRow>> field(\n        Types.NestedField field, Map<Integer, Accessor<InternalRow>> fieldResult) {\n      return fieldResult;\n    }\n  }\n\n  private static class PositionAccessor implements Accessor<InternalRow> {\n    protected final DataType type;\n    protected int p;\n\n    private PositionAccessor(int p, DataType type) {\n      this.p = p;\n      this.type = type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return row.get(p, type);\n    }\n  }\n\n  private static class StringAccessor extends PositionAccessor {\n    private StringAccessor(int p, DataType type) {\n      super(p, type);\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return row.get(p, type).toString();\n    }\n  }\n\n  private static class DecimalAccessor extends PositionAccessor {\n    private DecimalAccessor(int p, DataType type) {\n      super(p, type);\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return ((Decimal) row.get(p, type)).toJavaBigDecimal();\n    }\n  }\n\n  private static class Position2Accessor implements Accessor<InternalRow> {\n    private final int p0;\n    private final int size0;\n    private final int p1;\n    private final DataType type;\n\n    private Position2Accessor(int p, int size, PositionAccessor wrapped) {\n      this.p0 = p;\n      this.size0 = size;\n      this.p1 = wrapped.p;\n      this.type = wrapped.type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      return row.getStruct(p0, size0).get(p1, type);\n    }\n  }\n\n  private static class Position3Accessor implements Accessor<InternalRow> {\n    private final int p0;\n    private final int size0;\n    private final int p1;\n    private final int size1;\n    private final int p2;\n    private final DataType type;\n\n    private Position3Accessor(int p, int size, Position2Accessor wrapped) {\n      this.p0 = p;\n      this.size0 = size;\n      this.p1 = wrapped.p0;\n      this.size1 = wrapped.size0;\n      this.p2 = wrapped.p1;\n      this.type = wrapped.type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      return row.getStruct(p0, size0).getStruct(p1, size1).get(p2, type);\n    }\n  }\n\n  private static class WrappedPositionAccessor implements Accessor<InternalRow> {\n    private final int p;\n    private final int size;\n    private final Accessor<InternalRow> accessor;\n\n    private WrappedPositionAccessor(int p, int size, Accessor<InternalRow> accessor) {\n      this.p = p;\n      this.size = size;\n      this.accessor = accessor;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      InternalRow inner = row.getStruct(p, size);\n      if (inner != null) {\n        return accessor.get(inner);\n      }\n      return null;\n    }\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'"
        ]
    },
    {
        "files": [
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'",
            "'graalvm-demos/espresso-jshell/src/main/java/com/oracle/truffle/espresso/jshell/EspressoLocalExecutionControl.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/ExecutionControlForwarder.java'"
        ],
        "content": "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'\n:\npackage jdk.jshell.execution;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport jdk.jshell.JShellException;\nimport jdk.jshell.spi.ExecutionControl;\nimport static jdk.jshell.execution.ExecutionControlForwarder.NULL_MARKER;\nimport static jdk.jshell.execution.RemoteCodes.*;\n\n\npublic class StreamingExecutionControl implements ExecutionControl {\n\n    private final ObjectOutput out;\n    private final ObjectInput in;\n\n\n    public StreamingExecutionControl(ObjectOutput out, ObjectInput in) {\n        this.out = out;\n        this.in = in;\n    }\n\n    @Override\n    public void load(ClassBytecodes[] cbcs)\n            throws ClassInstallException, NotImplementedException, EngineTerminationException {\n        try {\n\n            writeCommand(CMD_LOAD);\n            out.writeObject(cbcs);\n            out.flush();\n\n            readAndReportClassInstallResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote load: \" + ex);\n        }\n    }\n\n    @Override\n    public void redefine(ClassBytecodes[] cbcs)\n            throws ClassInstallException, NotImplementedException, EngineTerminationException {\n        try {\n\n            writeCommand(CMD_REDEFINE);\n            out.writeObject(cbcs);\n            out.flush();\n\n            readAndReportClassInstallResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote redefine: \" + ex);\n        }\n    }\n\n    @Override\n    public String invoke(String classname, String methodname)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_INVOKE);\n            out.writeUTF(classname);\n            out.writeUTF(methodname);\n            out.flush();\n\n            readAndReportExecutionResult();\n            String result = in.readUTF();\n            return result;\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote invoke: \" + ex);\n        }\n    }\n\n    @Override\n    public String varValue(String classname, String varname)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_VAR_VALUE);\n            out.writeUTF(classname);\n            out.writeUTF(varname);\n            out.flush();\n\n            readAndReportExecutionResult();\n            String result = in.readUTF();\n            return result;\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote varValue: \" + ex);\n        }\n    }\n\n\n    @Override\n    public void addToClasspath(String path)\n            throws EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_ADD_CLASSPATH);\n            out.writeUTF(path);\n            out.flush();\n\n            readAndReportClassSimpleResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote add to classpath: \" + ex);\n        }\n    }\n\n    @Override\n    public void stop()\n            throws EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_STOP);\n            out.flush();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote stop: \" + ex);\n        }\n    }\n\n    @Override\n    public Object extensionCommand(String command, Object arg)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n            writeCommand(command);\n            out.writeObject(arg);\n            out.flush();\n\n            readAndReportExecutionResult();\n            Object result = in.readObject();\n            return result;\n        } catch (IOException | ClassNotFoundException ex) {\n            throw new EngineTerminationException(\"Exception transmitting remote extensionCommand: \"\n                    + command + \" -- \" + ex);\n        }\n    }\n\n\n    @Override\n    public void close() {\n        try {\n            writeCommand(CMD_CLOSE);\n            out.flush();\n        } catch (IOException ex) {\n\n        }\n    }\n\n    private void writeCommand(String cmd) throws IOException {\n        out.writeInt(COMMAND_PREFIX);\n        out.writeUTF(cmd);\n    }\n\n\n    private String readNullOrUTF() throws IOException {\n        String s = in.readUTF();\n        return s.equals(NULL_MARKER) ? null : s;\n    }\n\n\n    private void readAndReportClassSimpleResult() throws EngineTerminationException, InternalException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_INTERNAL_PROBLEM: {\n                    String message = in.readUTF();\n                    throw new InternalException(message);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException ex) {\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n\n    private void readAndReportClassInstallResult() throws ClassInstallException,\n            NotImplementedException, EngineTerminationException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_CLASS_INSTALL_EXCEPTION: {\n                    String message = in.readUTF();\n                    boolean[] loaded = (boolean[]) in.readObject();\n                    throw new ClassInstallException(message, loaded);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException | ClassNotFoundException ex) {\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n\n    private void readAndReportExecutionResult() throws RunException,\n            EngineTerminationException, InternalException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_USER_EXCEPTION: {\n\n                    throw readUserException();\n                }\n                case RESULT_CORRALLED: {\n\n                    throw readResolutionException();\n                }\n                case RESULT_USER_EXCEPTION_CHAINED: {\n\n                    in.readInt();\n                    UserException result = readUserException();\n                    RunException caused = result;\n\n                    loop: while (true) {\n                        RunException ex;\n                        int cstatus = in.readInt();\n                        switch (cstatus) {\n                            case RESULT_USER_EXCEPTION: {\n\n                                ex = readUserException();\n                                break;\n                            }\n                            case RESULT_CORRALLED: {\n\n                                ex = readResolutionException();\n                                break;\n                            }\n                            case RESULT_SUCCESS: {\n\n                                break loop;\n                            }\n                            default: {\n                                throw new EngineTerminationException(\"Bad chained remote result code: \" + cstatus);\n                            }\n                        }\n                        caused.initCause(ex);\n                        caused = ex;\n                    }\n                    caused.initCause(null);\n                    throw result;\n                }\n                case RESULT_STOPPED: {\n\n                    throw new StoppedException();\n                }\n                case RESULT_INTERNAL_PROBLEM: {\n\n                    String message = in.readUTF();\n                    throw new InternalException(message);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException | ClassNotFoundException ex) {\n            ex.printStackTrace();\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n    private UserException readUserException() throws IOException, ClassNotFoundException {\n        String message = readNullOrUTF();\n        String exceptionClassName = in.readUTF();\n        StackTraceElement[] elems = (StackTraceElement[]) in.readObject();\n        return new UserException(message, exceptionClassName, elems);\n    }\n\n    private ResolutionException readResolutionException() throws IOException, ClassNotFoundException {\n        int id = in.readInt();\n        StackTraceElement[] elems = (StackTraceElement[]) in.readObject();\n        return new ResolutionException(id, elems);\n    }\n}\n",
        "gt": [
            "'graalvm-demos/espresso-jshell/src/main/java/com/oracle/truffle/espresso/jshell/EspressoLocalExecutionControl.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/ExecutionControlForwarder.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.avro.AvroSchemaVisitor;\nimport com.netflix.iceberg.avro.ValueWriter;\nimport com.netflix.iceberg.avro.ValueWriters;\nimport com.netflix.iceberg.types.Type;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.types.DataType;\nimport java.io.IOException;\nimport java.util.List;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getFieldId;\nimport static com.netflix.iceberg.avro.AvroSchemaVisitor.visit;\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\npublic class SparkAvroWriter implements DatumWriter<InternalRow> {\n  private final com.netflix.iceberg.Schema schema;\n  private ValueWriter<InternalRow> writer = null;\n\n  public SparkAvroWriter(com.netflix.iceberg.Schema schema) {\n    this.schema = schema;\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void setSchema(Schema schema) {\n    this.writer = (ValueWriter<InternalRow>) visit(schema, new WriteBuilder(this.schema));\n  }\n\n  @Override\n  public void write(InternalRow datum, Encoder out) throws IOException {\n    writer.write(datum, out);\n  }\n\n  private static class WriteBuilder extends AvroSchemaVisitor<ValueWriter<?>> {\n    private final com.netflix.iceberg.Schema schema;\n\n    private WriteBuilder(com.netflix.iceberg.Schema schema) {\n      this.schema = schema;\n    }\n\n    @Override\n    public ValueWriter<?> record(Schema record, List<String> names, List<ValueWriter<?>> fields) {\n      List<DataType> types = Lists.newArrayList();\n      for (Schema.Field field : record.getFields()) {\n        types.add(convert(schema.findType(getFieldId(field))));\n      }\n      return SparkValueWriters.struct(fields, types);\n    }\n\n    @Override\n    public ValueWriter<?> union(Schema union, List<ValueWriter<?>> options) {\n      Preconditions.checkArgument(options.contains(ValueWriters.nulls()),\n          \"Cannot create writer for non-option union: \" + union);\n      Preconditions.checkArgument(options.size() == 2,\n          \"Cannot create writer for non-option union: \" + union);\n      if (union.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return ValueWriters.option(0, options.get(1));\n      } else {\n        return ValueWriters.option(1, options.get(0));\n      }\n    }\n\n    @Override\n    public ValueWriter<?> array(Schema array, ValueWriter<?> elementWriter) {\n      LogicalType logical = array.getLogicalType();\n      if (logical != null && \"map\".equals(logical.getName())) {\n        Type keyType = schema.findType(getFieldId(array.getElementType().getField(\"key\")));\n        Type valueType = schema.findType(getFieldId(array.getElementType().getField(\"value\")));\n        ValueWriter<?>[] writers = ((SparkValueWriters.StructWriter) elementWriter).writers;\n        return SparkValueWriters.arrayMap(\n            writers[0], convert(keyType), writers[1], convert(valueType));\n      }\n\n      Type elementType = schema.findType(AvroSchemaUtil.getElementId(array));\n      return SparkValueWriters.array(elementWriter, convert(elementType));\n    }\n\n    @Override\n    public ValueWriter<?> map(Schema map, ValueWriter<?> valueReader) {\n      Type keyType = schema.findType(AvroSchemaUtil.getKeyId(map));\n      Type valueType = schema.findType(AvroSchemaUtil.getValueId(map));\n      return SparkValueWriters.map(\n          SparkValueWriters.strings(), convert(keyType), valueReader, convert(valueType));\n    }\n\n    @Override\n    public ValueWriter<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n\n            return ValueWriters.ints();\n\n          case \"timestamp-micros\":\n\n            return ValueWriters.longs();\n\n          case \"decimal\":\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueWriters.decimal(decimal.getPrecision(), decimal.getScale());\n\n          case \"uuid\":\n            return ValueWriters.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unsupported logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueWriters.nulls();\n        case BOOLEAN:\n          return ValueWriters.booleans();\n        case INT:\n          return ValueWriters.ints();\n        case LONG:\n          return ValueWriters.longs();\n        case FLOAT:\n          return ValueWriters.floats();\n        case DOUBLE:\n          return ValueWriters.doubles();\n        case STRING:\n          return SparkValueWriters.strings();\n        case FIXED:\n          return ValueWriters.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueWriters.bytes();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n\n'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'\n:package net.programmierecke.radiodroid2.tests.utils;\n\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\nimport androidx.recyclerview.widget.RecyclerView;\nimport androidx.test.espresso.PerformException;\nimport androidx.test.espresso.UiController;\nimport androidx.test.espresso.ViewAction;\nimport androidx.test.espresso.action.GeneralLocation;\nimport androidx.test.espresso.action.MotionEvents;\nimport androidx.test.espresso.action.PrecisionDescriber;\nimport androidx.test.espresso.action.Press;\nimport androidx.test.espresso.action.Swipe;\nimport androidx.test.espresso.action.Swiper;\nimport androidx.test.espresso.util.HumanReadables;\n\nimport org.hamcrest.Matcher;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static androidx.test.espresso.core.internal.deps.guava.base.Preconditions.checkElementIndex;\nimport static androidx.test.espresso.matcher.ViewMatchers.isDisplayingAtLeast;\n\npublic class RecyclerDragAndDropAction implements ViewAction {\n\n\n    private static final int VIEW_DISPLAY_PERCENTAGE = 50;\n\n\n    private static final int DRAG_EVENT_COUNT = 10;\n\n    private static final int DRAG_DURATION = 600;\n\n    private final Swiper swiper;\n    private final int idxFrom;\n    private final int idxTo;\n    private final PrecisionDescriber precisionDescriber;\n\n    public static ViewAction recyclerDragAndDrop(int idxFrom, int idxTo) {\n        return new RecyclerDragAndDropAction(Swipe.FAST, idxFrom, idxTo, Press.FINGER);\n    }\n\n    public RecyclerDragAndDropAction(Swiper swiper, int idxFrom, int idxTo, PrecisionDescriber precisionDescriber) {\n        this.swiper = swiper;\n        this.idxFrom = idxFrom;\n        this.idxTo = idxTo;\n        this.precisionDescriber = precisionDescriber;\n    }\n\n    @Override\n    public Matcher<View> getConstraints() {\n        return isDisplayingAtLeast(VIEW_DISPLAY_PERCENTAGE);\n    }\n\n    private static float[][] interpolate(float[] start, float[] end, int steps) {\n        checkElementIndex(1, start.length);\n        checkElementIndex(1, end.length);\n\n        float[][] res = new float[steps][2];\n\n        for (int i = 1; i < steps + 1; i++) {\n            res[i - 1][0] = start[0] + (end[0] - start[0]) * i / (steps);\n            res[i - 1][1] = start[1] + (end[1] - start[1]) * i / (steps);\n        }\n\n        return res;\n    }\n\n    @Override\n    public void perform(UiController uiController, View view) {\n        final RecyclerView recyclerView = (RecyclerView) view;\n\n        TestUtils.centerItemInRecycler(uiController, recyclerView, idxFrom);\n        uiController.loopMainThreadUntilIdle();\n\n        final View fromView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxFrom)).itemView;\n        final float[] fromViewPosition = GeneralLocation.VISIBLE_CENTER.calculateCoordinates(fromView);\n\n        final float[] precision = precisionDescriber.describePrecision();\n\n        final List<MotionEvent> events = new ArrayList<>();\n        MotionEvents.DownResultHolder downEvent = null;\n\n        boolean success = false;\n        for (int i = 0; i < 3 && !success; i++) {\n            try {\n                downEvent = MotionEvents.sendDown(uiController, fromViewPosition, precision);\n\n                final int longPressTimeout = (int) (ViewConfiguration.getLongPressTimeout() * 1.5f);\n                uiController.loopMainThreadForAtLeast(longPressTimeout);\n\n                TestUtils.centerItemInRecycler(uiController, recyclerView, idxTo);\n                uiController.loopMainThreadUntilIdle();\n\n                final View toView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxTo)).itemView;\n                float[] toViewPosition = GeneralLocation.TOP_CENTER.calculateCoordinates(toView);\n\n                float[][] steps = interpolate(fromViewPosition, toViewPosition, DRAG_EVENT_COUNT);\n\n                final long intervalMS = DRAG_DURATION / steps.length;\n                long eventTime = downEvent.down.getDownTime();\n                for (float[] step : steps) {\n                    eventTime += intervalMS;\n                    events.add(MotionEvents.obtainMovement(downEvent.down.getDownTime(), eventTime, step));\n                }\n\n                eventTime += intervalMS;\n                events.add(\n                        MotionEvent.obtain(\n                                downEvent.down.getDownTime(),\n                                eventTime,\n                                MotionEvent.ACTION_UP,\n                                toViewPosition[0],\n                                toViewPosition[1],\n                                0));\n                uiController.injectMotionEventSequence(events);\n                success = true;\n            } catch (Exception e) {\n                throw new PerformException.Builder()\n                        .withActionDescription(this.getDescription())\n                        .withViewDescription(HumanReadables.describe(view))\n                        .withCause(e)\n                        .build();\n            } finally {\n                for (MotionEvent event : events) {\n                    event.recycle();\n                }\n\n                if (downEvent != null) {\n                    downEvent.down.recycle();\n                }\n            }\n        }\n\n        int duration = ViewConfiguration.getPressedStateDuration();\n\n        if (duration > 0) {\n            uiController.loopMainThreadForAtLeast(duration);\n        }\n    }\n\n    @Override\n    public String getDescription() {\n        return swiper.toString().toLowerCase() + \" recycler-drag-and-drop\";\n    }\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/internal/reflection/ReflectionThriftStructCodec.java'",
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/internal/reflection/ReflectionThriftUnionCodec.java'",
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/metadata/FieldKind.java'"
        ],
        "content": "'drift/drift-codec/src/main/java/io/airlift/drift/codec/internal/reflection/ReflectionThriftStructCodec.java'\n:\npackage io.airlift.drift.codec.internal.reflection;\n\nimport com.google.errorprone.annotations.Immutable;\nimport io.airlift.drift.annotations.ThriftField;\nimport io.airlift.drift.codec.ThriftCodec;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.codec.internal.ProtocolReader;\nimport io.airlift.drift.codec.internal.ProtocolWriter;\nimport io.airlift.drift.codec.metadata.ThriftConstructorInjection;\nimport io.airlift.drift.codec.metadata.ThriftFieldInjection;\nimport io.airlift.drift.codec.metadata.ThriftFieldMetadata;\nimport io.airlift.drift.codec.metadata.ThriftInjection;\nimport io.airlift.drift.codec.metadata.ThriftMethodInjection;\nimport io.airlift.drift.codec.metadata.ThriftParameterInjection;\nimport io.airlift.drift.codec.metadata.ThriftStructMetadata;\nimport io.airlift.drift.protocol.TProtocolException;\nimport io.airlift.drift.protocol.TProtocolReader;\nimport io.airlift.drift.protocol.TProtocolWriter;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.google.common.base.Throwables.throwIfInstanceOf;\nimport static com.google.common.base.Throwables.throwIfUnchecked;\nimport static com.google.common.base.Verify.verify;\nimport static io.airlift.drift.codec.metadata.FieldKind.THRIFT_FIELD;\n\n@Immutable\npublic class ReflectionThriftStructCodec<T>\n        extends AbstractReflectionThriftCodec<T>\n{\n    public ReflectionThriftStructCodec(ThriftCodecManager manager, ThriftStructMetadata metadata)\n    {\n        super(manager, metadata);\n    }\n\n    @Override\n    public T read(TProtocolReader protocol)\n            throws Exception\n    {\n        ProtocolReader reader = new ProtocolReader(protocol);\n        reader.readStructBegin();\n\n        Map<Short, Object> data = new HashMap<>(metadata.getFields().size());\n        while (reader.nextField()) {\n            short fieldId = reader.getFieldId();\n\n\n            ThriftCodec<?> codec = fields.get(fieldId);\n            if (codec == null) {\n                reader.skipFieldData();\n                continue;\n            }\n\n\n            ThriftFieldMetadata field = metadata.getField(fieldId);\n            if (field.isReadOnly() || field.getType() != THRIFT_FIELD) {\n                reader.skipFieldData();\n                continue;\n            }\n\n\n            Object value = reader.readField(codec);\n            if (value == null) {\n                if (field.getRequiredness() == ThriftField.Requiredness.REQUIRED) {\n                    throw new TProtocolException(\"required field was not set\");\n                }\n                else {\n                    continue;\n                }\n            }\n\n            data.put(fieldId, value);\n        }\n        reader.readStructEnd();\n\n\n        return constructStruct(data);\n    }\n\n    @Override\n    public void write(T instance, TProtocolWriter protocol)\n            throws Exception\n    {\n        ProtocolWriter writer = new ProtocolWriter(protocol);\n        writer.writeStructBegin(metadata.getStructName());\n\n        for (ThriftFieldMetadata fieldMetadata : metadata.getFields(THRIFT_FIELD)) {\n\n            if (fieldMetadata.isWriteOnly()) {\n                continue;\n            }\n\n\n            Object fieldValue = getFieldValue(instance, fieldMetadata);\n\n\n            if (fieldValue != null) {\n                @SuppressWarnings(\"unchecked\")\n                ThriftCodec<Object> codec = (ThriftCodec<Object>) fields.get(fieldMetadata.getId());\n                writer.writeField(fieldMetadata.getName(), fieldMetadata.getId(), codec, fieldValue);\n            }\n        }\n        writer.writeStructEnd();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private T constructStruct(Map<Short, Object> data)\n            throws Exception\n    {\n\n        Object instance;\n        {\n            ThriftConstructorInjection constructor = metadata.getConstructorInjection().get();\n            Object[] parametersValues = new Object[constructor.getParameters().size()];\n            for (ThriftParameterInjection parameter : constructor.getParameters()) {\n                Object value = data.get(parameter.getId());\n                if (value == null) {\n                    value = metadata.getField(parameter.getId()).getThriftType().getNullValue();\n                }\n                parametersValues[parameter.getParameterIndex()] = value;\n            }\n\n            instance = invokeConstructor(constructor.getConstructor(), parametersValues);\n        }\n\n\n        for (ThriftFieldMetadata fieldMetadata : metadata.getFields(THRIFT_FIELD)) {\n            for (ThriftInjection injection : fieldMetadata.getInjections()) {\n                if (injection instanceof ThriftFieldInjection) {\n                    ThriftFieldInjection fieldInjection = (ThriftFieldInjection) injection;\n                    Object value = data.get(fieldInjection.getId());\n                    if (value != null) {\n                        fieldInjection.getField().set(instance, value);\n                    }\n                }\n            }\n        }\n\n\n        for (ThriftMethodInjection methodInjection : metadata.getMethodInjections()) {\n            boolean shouldInvoke = false;\n            Object[] parametersValues = new Object[methodInjection.getParameters().size()];\n            for (ThriftParameterInjection parameter : methodInjection.getParameters()) {\n                Object value = data.get(parameter.getId());\n                if (value != null) {\n                    parametersValues[parameter.getParameterIndex()] = value;\n                    shouldInvoke = true;\n                }\n            }\n\n            if (shouldInvoke) {\n                invokeMethod(methodInjection.getMethod(), instance, parametersValues);\n            }\n        }\n\n\n        if (metadata.getBuilderMethod().isPresent()) {\n            ThriftMethodInjection builderMethod = metadata.getBuilderMethod().get();\n            Object[] parametersValues = new Object[builderMethod.getParameters().size()];\n            for (ThriftParameterInjection parameter : builderMethod.getParameters()) {\n                Object value = data.get(parameter.getId());\n                parametersValues[parameter.getParameterIndex()] = value;\n            }\n\n            instance = invokeMethod(builderMethod.getMethod(), instance, parametersValues);\n            validateCreatedInstance(metadata.getStructClass(), instance);\n        }\n\n        return (T) instance;\n    }\n\n    static void validateCreatedInstance(Class<?> clazz, Object instance)\n    {\n        verify(instance != null, \"Builder method returned a null instance\");\n\n        verify(\n                clazz.isInstance(instance),\n                \"Builder method returned instance of type %s, but an instance of %s is required\",\n                instance.getClass().getName(),\n                clazz.getName());\n    }\n\n    static <T> T invokeConstructor(Constructor<T> constructor, Object[] args)\n            throws Exception\n    {\n        try {\n            return constructor.newInstance(args);\n        }\n        catch (InvocationTargetException e) {\n            throwIfUnchecked(e.getCause());\n            throwIfInstanceOf(e.getCause(), Exception.class);\n            throw e;\n        }\n    }\n\n    static Object invokeMethod(Method method, Object instance, Object[] args)\n            throws Exception\n    {\n        try {\n            return method.invoke(instance, args);\n        }\n        catch (InvocationTargetException e) {\n            throwIfUnchecked(e.getCause());\n            throwIfInstanceOf(e.getCause(), Exception.class);\n            throw e;\n        }\n    }\n}\n\n'drift/drift-codec/src/main/java/io/airlift/drift/codec/internal/reflection/ReflectionThriftUnionCodec.java'\n:\npackage io.airlift.drift.codec.internal.reflection;\n\nimport com.google.common.collect.Maps;\nimport com.google.errorprone.annotations.Immutable;\nimport io.airlift.drift.codec.ThriftCodec;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.codec.internal.ProtocolReader;\nimport io.airlift.drift.codec.internal.ProtocolWriter;\nimport io.airlift.drift.codec.metadata.FieldKind;\nimport io.airlift.drift.codec.metadata.ThriftConstructorInjection;\nimport io.airlift.drift.codec.metadata.ThriftFieldInjection;\nimport io.airlift.drift.codec.metadata.ThriftFieldMetadata;\nimport io.airlift.drift.codec.metadata.ThriftInjection;\nimport io.airlift.drift.codec.metadata.ThriftMethodInjection;\nimport io.airlift.drift.codec.metadata.ThriftStructMetadata;\nimport io.airlift.drift.protocol.TProtocolReader;\nimport io.airlift.drift.protocol.TProtocolWriter;\n\nimport java.util.Map;\n\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static com.google.common.collect.Maps.uniqueIndex;\nimport static io.airlift.drift.codec.internal.reflection.ReflectionThriftStructCodec.invokeConstructor;\nimport static io.airlift.drift.codec.internal.reflection.ReflectionThriftStructCodec.invokeMethod;\nimport static io.airlift.drift.codec.internal.reflection.ReflectionThriftStructCodec.validateCreatedInstance;\nimport static io.airlift.drift.codec.metadata.FieldKind.THRIFT_FIELD;\nimport static java.lang.String.format;\nimport static java.util.Objects.requireNonNull;\n\n@Immutable\npublic class ReflectionThriftUnionCodec<T>\n        extends AbstractReflectionThriftCodec<T>\n{\n    private final Map<Short, ThriftFieldMetadata> metadataMap;\n    private final Map.Entry<ThriftFieldMetadata, ThriftCodec<?>> idField;\n\n    public ReflectionThriftUnionCodec(ThriftCodecManager manager, ThriftStructMetadata metadata)\n    {\n        super(manager, metadata);\n\n        ThriftFieldMetadata idField = getOnlyElement(metadata.getFields(FieldKind.THRIFT_UNION_ID));\n\n        this.idField = Maps.immutableEntry(idField, manager.getCodec(idField.getThriftType()));\n        requireNonNull(this.idField.getValue(), () -> \"No codec for ID field found: \" + idField);\n\n        this.metadataMap = uniqueIndex(metadata.getFields(), ThriftFieldMetadata::getId);\n    }\n\n    @Override\n    public T read(TProtocolReader protocol)\n            throws Exception\n    {\n        ProtocolReader reader = new ProtocolReader(protocol);\n        reader.readStructBegin();\n\n        Map.Entry<Short, Object> data = null;\n        Short fieldId = null;\n        while (reader.nextField()) {\n            checkState(fieldId == null, \"Received Union with more than one value (seen id %s, now id %s)\", fieldId, reader.getFieldId());\n\n            fieldId = reader.getFieldId();\n\n\n            ThriftCodec<?> codec = fields.get(fieldId);\n            if (codec == null) {\n                reader.skipFieldData();\n            }\n            else {\n\n                ThriftFieldMetadata field = metadata.getField(fieldId);\n                if (field.isWriteOnly() || field.getType() != THRIFT_FIELD) {\n                    reader.skipFieldData();\n                    continue;\n                }\n\n\n                Object value = reader.readField(codec);\n                if (value == null) {\n                    continue;\n                }\n\n                data = Maps.immutableEntry(fieldId, value);\n            }\n        }\n        reader.readStructEnd();\n\n\n        return constructStruct(data);\n    }\n\n    @Override\n    public void write(T instance, TProtocolWriter protocol)\n            throws Exception\n    {\n        ProtocolWriter writer = new ProtocolWriter(protocol);\n\n        Short idValue = (Short) getFieldValue(instance, idField.getKey());\n\n        writer.writeStructBegin(metadata.getStructName());\n\n        if (metadataMap.containsKey(idValue)) {\n            ThriftFieldMetadata fieldMetadata = metadataMap.get(idValue);\n\n            if (fieldMetadata.isReadOnly() || fieldMetadata.getType() != THRIFT_FIELD) {\n                throw new IllegalStateException(format(\"Field %s is not readable\", fieldMetadata.getName()));\n            }\n\n            Object fieldValue = getFieldValue(instance, fieldMetadata);\n\n\n            if (fieldValue != null) {\n                @SuppressWarnings(\"unchecked\")\n                ThriftCodec<Object> codec = (ThriftCodec<Object>) fields.get(fieldMetadata.getId());\n                writer.writeField(fieldMetadata.getName(), fieldMetadata.getId(), codec, fieldValue);\n            }\n        }\n        writer.writeStructEnd();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private T constructStruct(Map.Entry<Short, Object> data)\n            throws Exception\n    {\n\n        Object instance = null;\n\n        ThriftFieldMetadata fieldMetadata = null;\n\n        if (data != null) {\n            fieldMetadata = metadataMap.get(data.getKey());\n            if (fieldMetadata != null && fieldMetadata.getConstructorInjection().isPresent()) {\n                instance = invokeConstructor(fieldMetadata.getConstructorInjection().get().getConstructor(), new Object[] {data.getValue()});\n            }\n        }\n\n        if (instance == null && metadata.getConstructorInjection().isPresent()) {\n            ThriftConstructorInjection constructor = metadata.getConstructorInjection().get();\n\n            instance = invokeConstructor(constructor.getConstructor(), new Object[0]);\n        }\n\n        if (fieldMetadata != null) {\n\n            for (ThriftInjection injection : fieldMetadata.getInjections()) {\n                if (injection instanceof ThriftFieldInjection) {\n                    ThriftFieldInjection fieldInjection = (ThriftFieldInjection) injection;\n                    if (data.getValue() != null) {\n                        fieldInjection.getField().set(instance, data.getValue());\n                    }\n                }\n            }\n\n            if (fieldMetadata.getMethodInjection().isPresent() && data.getValue() != null) {\n                invokeMethod(fieldMetadata.getMethodInjection().get().getMethod(), instance, new Object[] {data.getValue()});\n            }\n        }\n\n        if (data != null) {\n\n            for (ThriftInjection injection : idField.getKey().getInjections()) {\n                if (injection instanceof ThriftFieldInjection) {\n                    ThriftFieldInjection fieldInjection = (ThriftFieldInjection) injection;\n                    fieldInjection.getField().set(instance, data.getKey());\n                }\n            }\n\n\n            if (metadata.getBuilderMethod().isPresent()) {\n                ThriftMethodInjection builderMethod = metadata.getBuilderMethod().get();\n                instance = invokeMethod(builderMethod.getMethod(), instance, new Object[] {data.getValue()});\n                validateCreatedInstance(metadata.getStructClass(), instance);\n            }\n        }\n\n        return (T) instance;\n    }\n}\n",
        "gt": [
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/metadata/FieldKind.java'",
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/internal/reflection/ReflectionThriftStructCodec.java'",
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/internal/reflection/ReflectionThriftUnionCodec.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/BuildAvroProjection.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\nimport static org.apache.avro.Schema.Type.MAP;\nimport static org.apache.avro.Schema.Type.RECORD;\nimport static org.apache.avro.Schema.Type.UNION;\n\npublic class AvroSchemaUtil {\n  public static final String FIELD_ID_PROP = \"field-id\";\n  public static final String KEY_ID_PROP = \"key-id\";\n  public static final String VALUE_ID_PROP = \"value-id\";\n  public static final String ELEMENT_ID_PROP = \"element-id\";\n  public static final String ADJUST_TO_UTC_PROP = \"adjust-to-utc\";\n\n  private static final Schema NULL = Schema.create(Schema.Type.NULL);\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               String tableName) {\n    return convert(schema, ImmutableMap.of(schema.asStruct(), tableName));\n  }\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               Map<Types.StructType, String> names) {\n    return TypeUtil.visit(schema, new TypeToSchema(names));\n  }\n\n  public static Schema convert(Type type) {\n    return convert(type, ImmutableMap.of());\n  }\n\n  public static Schema convert(Types.StructType type, String name) {\n    return convert(type, ImmutableMap.of(type, name));\n  }\n\n  public static Schema convert(Type type, Map<Types.StructType, String> names) {\n    return TypeUtil.visit(type, new TypeToSchema(names));\n  }\n\n  public static Type convert(Schema schema) {\n    return AvroSchemaVisitor.visit(schema, new SchemaToType(schema));\n  }\n\n  public static Map<Type, Schema> convertTypes(Types.StructType type, String name) {\n    TypeToSchema converter = new TypeToSchema(ImmutableMap.of(type, name));\n    TypeUtil.visit(type, converter);\n    return ImmutableMap.copyOf(converter.getConversionMap());\n  }\n\n  public static Schema pruneColumns(Schema schema, Set<Integer> selectedIds) {\n    return new PruneColumns(selectedIds).rootSchema(schema);\n  }\n\n  public static Schema buildAvroProjection(Schema schema, com.netflix.iceberg.Schema expected,\n                                           Map<String, String> renames) {\n    return AvroCustomOrderSchemaVisitor.visit(schema, new BuildAvroProjection(expected, renames));\n  }\n\n  public static boolean isTimestamptz(Schema schema) {\n    LogicalType logicalType = schema.getLogicalType();\n    if (logicalType != null && logicalType instanceof LogicalTypes.TimestampMicros) {\n\n      Object value = schema.getObjectProp(ADJUST_TO_UTC_PROP);\n      if (value instanceof Boolean) {\n        return (Boolean) value;\n      } else if (value instanceof String) {\n        return Boolean.parseBoolean((String) value);\n      }\n    }\n\n    return false;\n  }\n\n  static boolean isOptionSchema(Schema schema) {\n    if (schema.getType() == UNION && schema.getTypes().size() == 2) {\n      if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return true;\n      } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Schema toOption(Schema schema) {\n    if (schema.getType() == UNION) {\n      Preconditions.checkArgument(isOptionSchema(schema),\n          \"Union schemas are not supported: \" + schema);\n      return schema;\n    } else {\n      return Schema.createUnion(NULL, schema);\n    }\n  }\n\n  static Schema fromOption(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == UNION,\n        \"Expected union schema but was passed: {}\", schema);\n    Preconditions.checkArgument(schema.getTypes().size() == 2,\n        \"Expected optional schema, but was passed: {}\", schema);\n    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n      return schema.getTypes().get(1);\n    } else {\n      return schema.getTypes().get(0);\n    }\n  }\n\n  static Schema fromOptions(List<Schema> options) {\n    Preconditions.checkArgument(options.size() == 2,\n        \"Expected two schemas, but was passed: {} options\", options.size());\n    if (options.get(0).getType() == Schema.Type.NULL) {\n      return options.get(1);\n    } else {\n      return options.get(0);\n    }\n  }\n\n  static boolean isKeyValueSchema(Schema schema) {\n    return (schema.getType() == RECORD && schema.getFields().size() == 2);\n  }\n\n  static Schema createMap(int keyId, Schema keySchema,\n                          int valueId, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n\n    return LogicalMap.get().addToSchema(Schema.createArray(Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField))));\n  }\n\n  static Schema createProjectionMap(String recordName,\n                          int keyId, String keyName, Schema keySchema,\n                          int valueId, String valueName, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    if (!\"key\".equals(keyName)) {\n      keyField.addAlias(keyName);\n    }\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n    if (!\"value\".equals(valueName)) {\n      valueField.addAlias(valueName);\n    }\n\n    Schema keyValueRecord = Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField));\n    if (!keyValueName.equals(recordName)) {\n      keyValueRecord.addAlias(recordName);\n    }\n\n    return LogicalMap.get().addToSchema(Schema.createArray(keyValueRecord));\n  }\n\n  private static int getId(Schema schema, String propertyName) {\n    if (schema.getType() == UNION) {\n      return getId(fromOption(schema), propertyName);\n    }\n\n    Object id = schema.getObjectProp(propertyName);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", propertyName);\n\n    return toInt(id);\n  }\n\n  public static int getKeyId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map key id for non-map schema: \" + schema);\n    return getId(schema, KEY_ID_PROP);\n  }\n\n  public static int getValueId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map value id for non-map schema: \" + schema);\n    return getId(schema, VALUE_ID_PROP);\n  }\n\n  public static int getElementId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Cannot get array element id for non-array schema: \" + schema);\n    return getId(schema, ELEMENT_ID_PROP);\n  }\n\n  public static int getFieldId(Schema.Field field) {\n    Object id = field.getObjectProp(FIELD_ID_PROP);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", FIELD_ID_PROP);\n\n    return toInt(id);\n  }\n\n  private static int toInt(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).intValue();\n    } else if (value instanceof String) {\n      return Integer.parseInt((String) value);\n    }\n\n    throw new UnsupportedOperationException(\"Cannot coerce value to int: \" + value);\n  }\n\n  static Schema copyRecord(Schema record, List<Schema.Field> newFields, String newName) {\n    Schema copy;\n    if (newName != null) {\n      copy = Schema.createRecord(newName, record.getDoc(), null, record.isError(), newFields);\n\n\n\n      copy.addAlias(record.getName(), record.getNamespace() == null ? \"\" : record.getNamespace());\n    } else {\n      copy = Schema.createRecord(record.getName(),\n          record.getDoc(), record.getNamespace(), record.isError(), newFields);\n    }\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  static Schema.Field copyField(Schema.Field field, Schema newSchema, String newName) {\n    Schema.Field copy = new Schema.Field(newName,\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    if (!newName.equals(field.name())) {\n      copy.addAlias(field.name());\n    }\n\n    return copy;\n  }\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.toOption;\nimport static org.apache.avro.JsonProperties.NULL_VALUE;\n\nclass TypeToSchema extends TypeUtil.SchemaVisitor<Schema> {\n  private static final Schema BOOLEAN_SCHEMA = Schema.create(Schema.Type.BOOLEAN);\n  private static final Schema INTEGER_SCHEMA = Schema.create(Schema.Type.INT);\n  private static final Schema LONG_SCHEMA = Schema.create(Schema.Type.LONG);\n  private static final Schema FLOAT_SCHEMA = Schema.create(Schema.Type.FLOAT);\n  private static final Schema DOUBLE_SCHEMA = Schema.create(Schema.Type.DOUBLE);\n  private static final Schema DATE_SCHEMA = LogicalTypes.date()\n      .addToSchema(Schema.create(Schema.Type.INT));\n  private static final Schema TIME_SCHEMA = LogicalTypes.timeMicros()\n      .addToSchema(Schema.create(Schema.Type.LONG));\n  private static final Schema TIMESTAMP_SCHEMA = LogicalTypes.timestampMicros()\n      .addToSchema(Schema.create(Schema.Type.LONG));\n  private static final Schema TIMESTAMPTZ_SCHEMA = LogicalTypes.timestampMicros()\n      .addToSchema(Schema.create(Schema.Type.LONG));\n  private static final Schema STRING_SCHEMA = Schema.create(Schema.Type.STRING);\n  private static final Schema UUID_SCHEMA = LogicalTypes.uuid()\n      .addToSchema(Schema.createFixed(\"uuid_fixed\", null, null, 16));\n  private static final Schema BINARY_SCHEMA = Schema.create(Schema.Type.BYTES);\n\n  static {\n    TIMESTAMP_SCHEMA.addProp(AvroSchemaUtil.ADJUST_TO_UTC_PROP, false);\n    TIMESTAMPTZ_SCHEMA.addProp(AvroSchemaUtil.ADJUST_TO_UTC_PROP, true);\n  }\n\n  private final Map<Type, Schema> results = Maps.newHashMap();\n  private final Map<Types.StructType, String> names;\n\n  TypeToSchema(Map<Types.StructType, String> names) {\n    this.names = names;\n  }\n\n  Map<Type, Schema> getConversionMap() {\n    return results;\n  }\n\n  @Override\n  public Schema schema(com.netflix.iceberg.Schema schema, Schema structSchema) {\n    return structSchema;\n  }\n\n  @Override\n  public Schema struct(Types.StructType struct, List<Schema> fieldSchemas) {\n    Schema recordSchema = results.get(struct);\n    if (recordSchema != null) {\n      return recordSchema;\n    }\n\n    String recordName = names.get(struct);\n    if (recordName == null) {\n      recordName = \"r\" + fieldIds.peek();\n    }\n\n    List<Types.NestedField> structFields = struct.fields();\n    List<Schema.Field> fields = Lists.newArrayListWithExpectedSize(fieldSchemas.size());\n    for (int i = 0; i < structFields.size(); i += 1) {\n      Types.NestedField structField = structFields.get(i);\n      Schema.Field field = new Schema.Field(\n          structField.name(), fieldSchemas.get(i), null,\n          structField.isOptional() ? NULL_VALUE : null);\n      field.addProp(AvroSchemaUtil.FIELD_ID_PROP, structField.fieldId());\n      fields.add(field);\n    }\n\n    recordSchema = Schema.createRecord(recordName, null, null, false, fields);\n\n    results.put(struct, recordSchema);\n\n    return recordSchema;\n  }\n\n  @Override\n  public Schema field(Types.NestedField field, Schema fieldSchema) {\n    if (field.isOptional()) {\n      return toOption(fieldSchema);\n    } else {\n      return fieldSchema;\n    }\n  }\n\n  @Override\n  public Schema list(Types.ListType list, Schema elementSchema) {\n    Schema listSchema = results.get(list);\n    if (listSchema != null) {\n      return listSchema;\n    }\n\n    if (list.isElementOptional()) {\n      listSchema = Schema.createArray(toOption(elementSchema));\n    } else {\n      listSchema = Schema.createArray(elementSchema);\n    }\n\n    listSchema.addProp(AvroSchemaUtil.ELEMENT_ID_PROP, list.elementId());\n\n    results.put(list, listSchema);\n\n    return listSchema;\n  }\n\n  @Override\n  public Schema map(Types.MapType map, Schema keySchema, Schema valueSchema) {\n    Schema mapSchema = results.get(map);\n    if (mapSchema != null) {\n      return mapSchema;\n    }\n\n    if (keySchema.getType() == Schema.Type.STRING) {\n\n      mapSchema = Schema.createMap(\n          map.isValueOptional() ? toOption(valueSchema) : valueSchema);\n      mapSchema.addProp(AvroSchemaUtil.KEY_ID_PROP, map.keyId());\n      mapSchema.addProp(AvroSchemaUtil.VALUE_ID_PROP, map.valueId());\n\n    } else {\n      mapSchema = AvroSchemaUtil.createMap(map.keyId(), keySchema,\n          map.valueId(), map.isValueOptional() ? toOption(valueSchema) : valueSchema);\n    }\n\n    results.put(map, mapSchema);\n\n    return mapSchema;\n  }\n\n  @Override\n  public Schema primitive(Type.PrimitiveType primitive) {\n    Schema primitiveSchema;\n    switch (primitive.typeId()) {\n      case BOOLEAN:\n        primitiveSchema = BOOLEAN_SCHEMA;\n        break;\n      case INTEGER:\n        primitiveSchema = INTEGER_SCHEMA;\n        break;\n      case LONG:\n        primitiveSchema = LONG_SCHEMA;\n        break;\n      case FLOAT:\n        primitiveSchema = FLOAT_SCHEMA;\n        break;\n      case DOUBLE:\n        primitiveSchema = DOUBLE_SCHEMA;\n        break;\n      case DATE:\n        primitiveSchema = DATE_SCHEMA;\n        break;\n      case TIME:\n        primitiveSchema = TIME_SCHEMA;\n        break;\n      case TIMESTAMP:\n        if (((Types.TimestampType) primitive).shouldAdjustToUTC()) {\n          primitiveSchema = TIMESTAMPTZ_SCHEMA;\n        } else {\n          primitiveSchema = TIMESTAMP_SCHEMA;\n        }\n        break;\n      case STRING:\n        primitiveSchema = STRING_SCHEMA;\n        break;\n      case UUID:\n        primitiveSchema = UUID_SCHEMA;\n        break;\n      case FIXED:\n        Types.FixedType fixed = (Types.FixedType) primitive;\n        primitiveSchema = Schema.createFixed(\"fixed_\" + fixed.length(), null, null, fixed.length());\n        break;\n      case BINARY:\n        primitiveSchema = BINARY_SCHEMA;\n        break;\n      case DECIMAL:\n        Types.DecimalType decimal = (Types.DecimalType) primitive;\n        primitiveSchema = LogicalTypes.decimal(decimal.precision(), decimal.scale())\n            .addToSchema(Schema.createFixed(\n                \"decimal_\" + decimal.precision() + \"_\" + decimal.scale(),\n                null, null, TypeUtil.decimalRequriedBytes(decimal.precision())));\n        break;\n      default:\n        throw new UnsupportedOperationException(\n            \"Unsupported type ID: \" + primitive.typeId());\n    }\n\n    results.put(primitive, primitiveSchema);\n\n    return primitiveSchema;\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/BuildAvroProjection.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'"
        ],
        "content": "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Files;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.Table;\nimport com.netflix.iceberg.TableProperties;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.avro.AvroIterable;\nimport com.netflix.iceberg.hadoop.HadoopTables;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.spark.data.AvroDataTest;\nimport com.netflix.iceberg.spark.data.RandomData;\nimport com.netflix.iceberg.spark.data.SparkAvroReader;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.generic.GenericData.Record;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.spark.api.java.JavaRDD;\nimport org.apache.spark.api.java.JavaSparkContext;\nimport org.apache.spark.sql.DataFrameWriter;\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.junit.AfterClass;\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.List;\n\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\nimport static com.netflix.iceberg.spark.data.TestHelpers.assertEqualsSafe;\nimport static com.netflix.iceberg.spark.data.TestHelpers.assertEqualsUnsafe;\n\n@RunWith(Parameterized.class)\npublic class TestDataFrameWrites extends AvroDataTest {\n  private static final Configuration CONF = new Configuration();\n\n  private final String format;\n\n  @Parameterized.Parameters\n  public static Object[][] parameters() {\n    return new Object[][] {\n        new Object[] { \"parquet\" },\n        new Object[] { \"orc\" },\n        new Object[] { \"avro\" }\n    };\n  }\n\n  public TestDataFrameWrites(String format) {\n    this.format = format;\n  }\n\n  private static SparkSession spark = null;\n  private static JavaSparkContext sc = null;\n\n  @BeforeClass\n  public static void startSpark() {\n    TestDataFrameWrites.spark = SparkSession.builder().master(\"local[2]\").getOrCreate();\n    TestDataFrameWrites.sc = new JavaSparkContext(spark.sparkContext());\n  }\n\n  @AfterClass\n  public static void stopSpark() {\n    SparkSession spark = TestDataFrameWrites.spark;\n    TestDataFrameWrites.spark = null;\n    TestDataFrameWrites.sc = null;\n    spark.stop();\n  }\n\n  @Override\n  protected void writeAndValidate(Schema schema) throws IOException {\n    File location = createTableFolder();\n    Table table = createTable(schema, location);\n    writeAndValidateWithLocations(table, location, new File(location, \"data\"));\n  }\n\n  @Test\n  public void testWriteWithCustomDataLocation() throws IOException {\n    File location = createTableFolder();\n    File tablePropertyDataLocation = temp.newFolder(\"test-table-property-data-dir\");\n    Table table = createTable(new Schema(SUPPORTED_PRIMITIVES.fields()), location);\n    table.updateProperties().set(\n        TableProperties.WRITE_NEW_DATA_LOCATION, tablePropertyDataLocation.getAbsolutePath()).commit();\n    writeAndValidateWithLocations(table, location, tablePropertyDataLocation);\n  }\n\n  private File createTableFolder() throws IOException {\n    File parent = temp.newFolder(\"parquet\");\n    File location = new File(parent, \"test\");\n    Assert.assertTrue(\"Mkdir should succeed\", location.mkdirs());\n    return location;\n  }\n\n  private Table createTable(Schema schema, File location) {\n    HadoopTables tables = new HadoopTables(CONF);\n    return tables.create(schema, PartitionSpec.unpartitioned(), location.toString());\n  }\n\n  private void writeAndValidateWithLocations(Table table, File location, File expectedDataDir) throws IOException {\n    Schema tableSchema = table.schema();\n\n    table.updateProperties().set(TableProperties.DEFAULT_FILE_FORMAT, format).commit();\n\n    List<Record> expected = RandomData.generateList(tableSchema, 100, 0L);\n    Dataset<Row> df = createDataset(expected, tableSchema);\n    DataFrameWriter<?> writer = df.write().format(\"iceberg\").mode(\"append\");\n\n    writer.save(location.toString());\n\n    table.refresh();\n\n    Dataset<Row> result = spark.read()\n        .format(\"iceberg\")\n        .load(location.toString());\n\n    List<Row> actual = result.collectAsList();\n\n    Assert.assertEquals(\"Result size should match expected\", expected.size(), actual.size());\n    for (int i = 0; i < expected.size(); i += 1) {\n      assertEqualsSafe(tableSchema.asStruct(), expected.get(i), actual.get(i));\n    }\n\n    table.currentSnapshot().addedFiles().forEach(dataFile ->\n        Assert.assertTrue(\n            String.format(\n                \"File should have the parent directory %s, but has: %s.\",\n                expectedDataDir.getAbsolutePath(),\n                dataFile.path()),\n            URI.create(dataFile.path().toString()).getPath().startsWith(expectedDataDir.getAbsolutePath())));\n  }\n\n  private Dataset<Row> createDataset(List<Record> records, Schema schema) throws IOException {\n\n\n    File testFile = temp.newFile();\n    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n\n    try (FileAppender<Record> writer = Avro.write(Files.localOutput(testFile))\n        .schema(schema)\n        .named(\"test\")\n        .build()) {\n      for (Record rec : records) {\n        writer.add(rec);\n      }\n    }\n\n    List<InternalRow> rows;\n    try (AvroIterable<InternalRow> reader = Avro.read(Files.localInput(testFile))\n        .createReaderFunc(SparkAvroReader::new)\n        .project(schema)\n        .build()) {\n      rows = Lists.newArrayList(reader);\n    }\n\n\n    for (int i = 0; i < records.size(); i += 1) {\n      assertEqualsUnsafe(schema.asStruct(), records.get(i), rows.get(i));\n    }\n\n    JavaRDD<InternalRow> rdd = sc.parallelize(rows);\n    return spark.internalCreateDataFrame(JavaRDD.toRDD(rdd), convert(schema), false);\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ]
    },
    {
        "files": [
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/ExternalPreview.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/MarkdownPreviewPane.java'"
        ],
        "content": "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'\n:\n\npackage org.markdownwriterfx.options;\n\nimport java.io.File;\nimport java.util.List;\nimport java.util.prefs.Preferences;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javafx.beans.property.BooleanProperty;\nimport javafx.beans.property.IntegerProperty;\nimport javafx.beans.property.ObjectProperty;\nimport javafx.beans.property.StringProperty;\nimport javafx.scene.text.Font;\nimport org.markdownwriterfx.projects.ProjectManager;\nimport org.markdownwriterfx.projects.ProjectSettings;\nimport org.markdownwriterfx.util.PrefsBooleanProperty;\nimport org.markdownwriterfx.util.PrefsEnumProperty;\nimport org.markdownwriterfx.util.PrefsIntegerProperty;\nimport org.markdownwriterfx.util.PrefsStringProperty;\nimport org.markdownwriterfx.util.PrefsStringsProperty;\nimport org.markdownwriterfx.util.Utils;\n\n\npublic class Options\n{\n\tpublic static final String[] DEF_FONT_FAMILIES = {\n\t\t\"Consolas\",\n\t\t\"DejaVu Sans Mono\",\n\t\t\"Lucida Sans Typewriter\",\n\t\t\"Lucida Console\",\n\t};\n\n\tpublic static final int DEF_FONT_SIZE = 12;\n\tpublic static final int MIN_FONT_SIZE = 8;\n\tpublic static final int MAX_FONT_SIZE = 36;\n\tpublic static final String DEF_MARKDOWN_FILE_EXTENSIONS = \"*.md,*.markdown,*.txt\";\n\tpublic enum RendererType { CommonMark, FlexMark }\n\tpublic static final int DEF_WRAP_LINE_LENGTH = 80;\n\tpublic static final int MIN_WRAP_LINE_LENGTH = 10;\n\n\tprivate static Preferences globalOptions;\n\tprivate static Preferences options;\n\n\tpublic static void load(Preferences globalOptions) {\n\t\tOptions.globalOptions = globalOptions;\n\n\t\toptions = getProjectOptions(ProjectManager.getActiveProject());\n\n\t\tfontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\n\t\tfontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\n\t\tlineSeparator.init(options, \"lineSeparator\", null);\n\t\tencoding.init(options, \"encoding\", null);\n\t\tmarkdownFileExtensions.init(options, \"markdownFileExtensions\", DEF_MARKDOWN_FILE_EXTENSIONS);\n\t\tmarkdownExtensions.init(options, \"markdownExtensions\");\n\t\tmarkdownRenderer.init(options, \"markdownRenderer\", RendererType.CommonMark);\n\t\tshowLineNo.init(options, \"showLineNo\", false);\n\t\tshowWhitespace.init(options, \"showWhitespace\", false);\n\t\tshowImagesEmbedded.init(options, \"showImagesEmbedded\", false);\n\n\t\temphasisMarker.init(options, \"emphasisMarker\", \"_\");\n\t\tstrongEmphasisMarker.init(options, \"strongEmphasisMarker\", \"**\");\n\t\tbulletListMarker.init(options, \"bulletListMarker\", \"-\");\n\n\t\twrapLineLength.init(options, \"wrapLineLength\", DEF_WRAP_LINE_LENGTH);\n\t\tformatOnSave.init(options, \"formatOnSave\", false);\n\t\tformatOnlyModifiedParagraphs.init(options, \"formatOnlyModifiedParagraphs\", false);\n\n\t\tspellChecker.init(options, \"spellChecker\", true);\n\t\tgrammarChecker.init(options, \"grammarChecker\", true);\n\t\tlanguage.init(options, \"language\", null);\n\t\tuserDictionary.init(options, \"userDictionary\", getDefaultUserDictionary());\n\t\tdisabledRules.init(options, \"disabledRules\");\n\n\t\tadditionalCSS.init(options, \"additionalCSS\", null);\n\n\n\t\taddonsPath.init(globalOptions, \"addonsPath\", null);\n\n\n\t\tProjectManager.activeProjectProperty().addListener((observer, oldProject, newProject) -> {\n\t\t\tset(getProjectOptions(newProject));\n\t\t});\n\t}\n\n\tprivate static void set(Preferences options) {\n\t\tif (Options.options == options)\n\t\t\treturn;\n\n\t\tOptions.options = options;\n\n\t\tfontFamily.setPreferences(options);\n\t\tfontSize.setPreferences(options);\n\t\tlineSeparator.setPreferences(options);\n\t\tencoding.setPreferences(options);\n\t\tmarkdownFileExtensions.setPreferences(options);\n\t\tmarkdownExtensions.setPreferences(options);\n\t\tmarkdownRenderer.setPreferences(options);\n\t\tshowLineNo.setPreferences(options);\n\t\tshowWhitespace.setPreferences(options);\n\t\tshowImagesEmbedded.setPreferences(options);\n\n\t\temphasisMarker.setPreferences(options);\n\t\tstrongEmphasisMarker.setPreferences(options);\n\t\tbulletListMarker.setPreferences(options);\n\n\t\twrapLineLength.setPreferences(options);\n\t\tformatOnSave.setPreferences(options);\n\t\tformatOnlyModifiedParagraphs.setPreferences(options);\n\n\t\tspellChecker.setPreferences(options);\n\t\tgrammarChecker.setPreferences(options);\n\t\tlanguage.setPreferences(options);\n\t\tuserDictionary.setPreferences(options);\n\t\tdisabledRules.setPreferences(options);\n\n\t\tadditionalCSS.setPreferences(options);\n\n\t\taddonsPath.setPreferences(globalOptions);\n\t}\n\n\tprivate static Preferences getProjectOptions(File project) {\n\t\tif (project != null) {\n\t\t\tPreferences projectOptions = ProjectSettings.get(project).getOptions();\n\t\t\tif (projectOptions != null)\n\t\t\t\treturn projectOptions;\n\t\t}\n\n\t\treturn globalOptions;\n\t}\n\n\tstatic boolean isStoreInProject() {\n\t\treturn options != globalOptions;\n\t}\n\n\tstatic void storeInProject(boolean enable) {\n\t\tProjectSettings projectSettings = ProjectSettings.get(ProjectManager.getActiveProject());\n\t\tprojectSettings.enableOptions(enable);\n\t\tset(enable ? projectSettings.getOptions() : globalOptions);\n\t}\n\n\n\tprivate static String safeFontFamily(String fontFamily) {\n\t\tList<String> fontFamilies = Font.getFamilies();\n\t\tif (fontFamily != null && fontFamilies.contains(fontFamily))\n\t\t\treturn fontFamily;\n\n\t\tfor (String family : DEF_FONT_FAMILIES) {\n\t\t\tif (fontFamilies.contains(family))\n\t\t\t\treturn family;\n\t\t}\n\t\treturn \"Monospaced\";\n\t}\n\n\n\tprivate static final PrefsStringProperty fontFamily = new PrefsStringProperty();\n\tpublic static String getFontFamily() { return fontFamily.get(); }\n\tpublic static void setFontFamily(String fontFamily) { Options.fontFamily.set(fontFamily); }\n\tpublic static StringProperty fontFamilyProperty() { return fontFamily; }\n\n\n\tprivate static final PrefsIntegerProperty fontSize = new PrefsIntegerProperty();\n\tpublic static int getFontSize() { return fontSize.get(); }\n\tpublic static void setFontSize(int fontSize) { Options.fontSize.set(Math.min(Math.max(fontSize,  MIN_FONT_SIZE), MAX_FONT_SIZE)); }\n\tpublic static IntegerProperty fontSizeProperty() { return fontSize; }\n\n\n\tprivate static final PrefsStringProperty lineSeparator = new PrefsStringProperty();\n\tpublic static String getLineSeparator() { return lineSeparator.get(); }\n\tpublic static void setLineSeparator(String lineSeparator) { Options.lineSeparator.set(lineSeparator); }\n\tpublic static StringProperty lineSeparatorProperty() { return lineSeparator; }\n\n\n\tprivate static final PrefsStringProperty encoding = new PrefsStringProperty();\n\tpublic static String getEncoding() { return encoding.get(); }\n\tpublic static void setEncoding(String encoding) { Options.encoding.set(encoding); }\n\tpublic static StringProperty encodingProperty() { return encoding; }\n\n\n\tprivate static final PrefsStringProperty markdownFileExtensions = new PrefsStringProperty();\n\tpublic static String getMarkdownFileExtensions() { return markdownFileExtensions.get(); }\n\tpublic static void setMarkdownFileExtensions(String markdownFileExtensions) { Options.markdownFileExtensions.set(markdownFileExtensions); }\n\tpublic static StringProperty markdownFileExtensionsProperty() { return markdownFileExtensions; }\n\n\n\tprivate static final PrefsStringsProperty markdownExtensions = new PrefsStringsProperty();\n\tpublic static String[] getMarkdownExtensions() { return markdownExtensions.get(); }\n\tpublic static void setMarkdownExtensions(String[] markdownExtensions) { Options.markdownExtensions.set(markdownExtensions); }\n\tpublic static ObjectProperty<String[]> markdownExtensionsProperty() { return markdownExtensions; }\n\n\n\tprivate static final PrefsEnumProperty<RendererType> markdownRenderer = new PrefsEnumProperty<>( RendererType.CommonMark );\n\tpublic static RendererType getMarkdownRenderer() { return markdownRenderer.get(); }\n\tpublic static void setMarkdownRenderer(RendererType markdownRenderer) { Options.markdownRenderer.set(markdownRenderer); }\n\tpublic static ObjectProperty<RendererType> markdownRendererProperty() { return markdownRenderer; }\n\n\n\tprivate static final PrefsBooleanProperty showLineNo = new PrefsBooleanProperty();\n\tpublic static boolean isShowLineNo() { return showLineNo.get(); }\n\tpublic static void setShowLineNo(boolean showLineNo) { Options.showLineNo.set(showLineNo); }\n\tpublic static BooleanProperty showLineNoProperty() { return showLineNo; }\n\n\n\tprivate static final PrefsBooleanProperty showWhitespace = new PrefsBooleanProperty();\n\tpublic static boolean isShowWhitespace() { return showWhitespace.get(); }\n\tpublic static void setShowWhitespace(boolean showWhitespace) { Options.showWhitespace.set(showWhitespace); }\n\tpublic static BooleanProperty showWhitespaceProperty() { return showWhitespace; }\n\n\n\tprivate static final PrefsBooleanProperty showImagesEmbedded = new PrefsBooleanProperty();\n\tpublic static boolean isShowImagesEmbedded() { return showImagesEmbedded.get(); }\n\tpublic static void setShowImagesEmbedded(boolean showImagesEmbedded) { Options.showImagesEmbedded.set(showImagesEmbedded); }\n\tpublic static BooleanProperty showImagesEmbeddedProperty() { return showImagesEmbedded; }\n\n\n\tprivate static final PrefsStringProperty emphasisMarker = new PrefsStringProperty();\n\tpublic static String getEmphasisMarker() { return emphasisMarker.get(); }\n\tpublic static void setEmphasisMarker(String emphasisMarker) { Options.emphasisMarker.set(emphasisMarker); }\n\tpublic static StringProperty emphasisMarkerProperty() { return emphasisMarker; }\n\n\n\tprivate static final PrefsStringProperty strongEmphasisMarker = new PrefsStringProperty();\n\tpublic static String getStrongEmphasisMarker() { return strongEmphasisMarker.get(); }\n\tpublic static void setStrongEmphasisMarker(String strongEmphasisMarker) { Options.strongEmphasisMarker.set(strongEmphasisMarker); }\n\tpublic static StringProperty strongEmphasisMarkerProperty() { return strongEmphasisMarker; }\n\n\n\tprivate static final PrefsStringProperty bulletListMarker = new PrefsStringProperty();\n\tpublic static String getBulletListMarker() { return bulletListMarker.get(); }\n\tpublic static void setBulletListMarker(String bulletListMarker) { Options.bulletListMarker.set(bulletListMarker); }\n\tpublic static StringProperty bulletListMarkerProperty() { return bulletListMarker; }\n\n\n\tprivate static final PrefsIntegerProperty wrapLineLength = new PrefsIntegerProperty();\n\tpublic static int getWrapLineLength() { return wrapLineLength.get(); }\n\tpublic static void setWrapLineLength(int wrapLineLength) { Options.wrapLineLength.set(Math.max(wrapLineLength, MIN_WRAP_LINE_LENGTH)); }\n\tpublic static IntegerProperty wrapLineLengthProperty() { return wrapLineLength; }\n\n\n\tprivate static final PrefsBooleanProperty formatOnSave = new PrefsBooleanProperty();\n\tpublic static boolean isFormatOnSave() { return formatOnSave.get(); }\n\tpublic static void setFormatOnSave(boolean formatOnSave) { Options.formatOnSave.set(formatOnSave); }\n\tpublic static BooleanProperty formatOnSaveProperty() { return formatOnSave; }\n\n\n\tprivate static final PrefsBooleanProperty formatOnlyModifiedParagraphs = new PrefsBooleanProperty();\n\tpublic static boolean isFormatOnlyModifiedParagraphs() { return formatOnlyModifiedParagraphs.get(); }\n\tpublic static void setFormatOnlyModifiedParagraphs(boolean formatOnlyModifiedParagraphs) { Options.formatOnlyModifiedParagraphs.set(formatOnlyModifiedParagraphs); }\n\tpublic static BooleanProperty formatOnlyModifiedParagraphsProperty() { return formatOnlyModifiedParagraphs; }\n\n\n\tprivate static final PrefsBooleanProperty spellChecker = new PrefsBooleanProperty();\n\tpublic static boolean isSpellChecker() { return spellChecker.get(); }\n\tpublic static void setSpellChecker(boolean spellChecker) { Options.spellChecker.set(spellChecker); }\n\tpublic static BooleanProperty spellCheckerProperty() { return spellChecker; }\n\n\n\tprivate static final PrefsBooleanProperty grammarChecker = new PrefsBooleanProperty();\n\tpublic static boolean isGrammarChecker() { return grammarChecker.get(); }\n\tpublic static void setGrammarChecker(boolean grammarChecker) { Options.grammarChecker.set(grammarChecker); }\n\tpublic static BooleanProperty grammarCheckerProperty() { return grammarChecker; }\n\n\n\tprivate static final PrefsStringProperty language = new PrefsStringProperty();\n\tpublic static String getLanguage() { return language.get(); }\n\tpublic static void setLanguage(String language) { Options.language.set(language); }\n\tpublic static StringProperty languageProperty() { return language; }\n\n\n\tprivate static final PrefsStringProperty userDictionary = new PrefsStringProperty();\n\tpublic static String getUserDictionary() { return userDictionaryOrDefault(userDictionary.get()); }\n\tpublic static void setUserDictionary(String userDictionary) { Options.userDictionary.set(userDictionaryOrDefault(userDictionary)); }\n\tpublic static StringProperty userDictionaryProperty() { return userDictionary; }\n\tprivate static String getDefaultUserDictionary() {\n\t\treturn System.getProperty(\"user.home\") + System.getProperty(\"file.separator\") + \"dictionary-mwfx.txt\";\n\t}\n\tprivate static String userDictionaryOrDefault(String userDictionary) {\n\t\treturn !Utils.isNullOrEmpty(userDictionary) ? userDictionary : getDefaultUserDictionary();\n\t}\n\n\n\n\tprivate static final PrefsStringsProperty disabledRules = new PrefsStringsProperty();\n\tpublic static String[] getDisabledRules() { return disabledRules.get(); }\n\tpublic static void setDisabledRules(String[] disabledRules) { Options.disabledRules.set(disabledRules); }\n\tpublic static ObjectProperty<String[]> disabledRulesProperty() { return disabledRules; }\n\n\tpublic static String ruleIdDesc2id(String str) {\n\t\treturn str.contains(\"=\") ? str.substring(0, str.indexOf('=')) : str;\n\t}\n\n\tpublic static String ruleIdDesc2desc(String str) {\n\t\treturn str.contains(\"=\") ? str.substring(str.indexOf('=') + 1) : str;\n\t}\n\n\tpublic static List<String> ruleIdDescs2ids(String[] strs) {\n\t\treturn Stream.of(strs)\n\t\t\t.map(Options::ruleIdDesc2id)\n\t\t\t.collect(Collectors.toList());\n\t}\n\n\n\tprivate static final PrefsStringProperty additionalCSS = new PrefsStringProperty();\n\tpublic static String getAdditionalCSS() { return additionalCSS.get(); }\n\tpublic static void setAdditionalCSS(String additionalCSS) { Options.additionalCSS.set(additionalCSS); }\n\tpublic static StringProperty additionalCSSProperty() { return additionalCSS; }\n\n\n\tprivate static final PrefsStringProperty addonsPath = new PrefsStringProperty();\n\tpublic static String getAddonsPath() { return addonsPath.get(); }\n\tpublic static void setAddonsPath(String addonsPath) { Options.addonsPath.set(addonsPath); }\n\tpublic static StringProperty addonsPathProperty() { return addonsPath; }\n}\n",
        "gt": [
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/MarkdownPreviewPane.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/ExternalPreview.java'"
        ]
    },
    {
        "files": [
            "'jox/channels/src/test/java/com/softwaremill/jox/SegmentTest.java'",
            "'jox/channels/src/test/java/com/softwaremill/jox/SegmentRendezvousTest.java'",
            "'jox/channels/src/main/java/com/softwaremill/jox/Segment.java'"
        ],
        "content": "'jox/channels/src/test/java/com/softwaremill/jox/SegmentTest.java'\n:package com.softwaremill.jox;\n\nimport org.junit.jupiter.api.Test;\n\nimport static com.softwaremill.jox.Segment.SEGMENT_SIZE;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SegmentTest {\n    @Test\n    void segmentShouldBecomeRemovedOnceAllCellsInterruptedAndProcessed() {\n\n        var ss = createSegmentChain(3, 0, false);\n\n\n\n        for (int i = 0; i < SEGMENT_SIZE; i++) {\n            ss[1].cellInterruptedReceiver();\n\n            assertFalse(ss[1].isRemoved());\n            assertEquals(ss[1].getPrev(), ss[0]);\n            assertEquals(ss[1].getNext(), ss[2]);\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[1]);\n            assertEquals(ss[2].getPrev(), ss[1]);\n            assertNull(ss[2].getNext());\n        }\n\n\n        for (int i = 0; i < SEGMENT_SIZE - 1; i++) {\n            ss[1].cellProcessed_notInterruptedSender();\n\n            assertFalse(ss[1].isRemoved());\n            assertEquals(ss[1].getPrev(), ss[0]);\n            assertEquals(ss[1].getNext(), ss[2]);\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[1]);\n            assertEquals(ss[2].getPrev(), ss[1]);\n            assertNull(ss[2].getNext());\n        }\n\n        ss[1].cellProcessed_notInterruptedSender();\n        assertTrue(ss[1].isRemoved());\n\n\n        assertNull(ss[0].getPrev());\n        assertEquals(ss[0].getNext(), ss[2]);\n        assertEquals(ss[2].getPrev(), ss[0]);\n        assertNull(ss[2].getNext());\n    }\n\n    @Test\n    void segmentShouldBecomeRemovedOnceAllCellsSenderInterrupted() {\n\n        var ss = createSegmentChain(3, 0, false);\n\n\n        for (int i = 0; i < SEGMENT_SIZE - 1; i++) {\n            ss[1].cellInterruptedSender();\n\n            assertFalse(ss[1].isRemoved());\n            assertEquals(ss[1].getPrev(), ss[0]);\n            assertEquals(ss[1].getNext(), ss[2]);\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[1]);\n            assertEquals(ss[2].getPrev(), ss[1]);\n            assertNull(ss[2].getNext());\n        }\n\n        ss[1].cellInterruptedSender();\n        assertTrue(ss[1].isRemoved());\n\n\n        assertNull(ss[0].getPrev());\n        assertEquals(ss[0].getNext(), ss[2]);\n        assertEquals(ss[2].getPrev(), ss[0]);\n        assertNull(ss[2].getNext());\n    }\n\n    @Test\n    void shouldReturnTheLastSegmentWhenClosing() {\n\n        var ss = createSegmentChain(3, 0, false);\n\n\n        var s = ss[0].close();\n\n\n        assertEquals(ss[2].getId(), s.getId());\n    }\n\n    static Segment[] createSegmentChain(int count, long id, boolean isRendezvous) {\n        var segments = new Segment[count];\n        var thisSegment = new Segment(id, null, 0, isRendezvous);\n        segments[0] = thisSegment;\n        for (int i = 1; i < count; i++) {\n            var nextSegment = new Segment(id + i, thisSegment, 0, isRendezvous);\n            thisSegment.setNext(nextSegment);\n            segments[i] = nextSegment;\n            thisSegment = nextSegment;\n        }\n        return segments;\n    }\n\n    static void sendInterruptAllCells(Segment s) {\n        for (int i = 0; i < SEGMENT_SIZE; i++) {\n            s.cellInterruptedSender();\n        }\n    }\n}\n\n'jox/channels/src/test/java/com/softwaremill/jox/SegmentRendezvousTest.java'\n:package com.softwaremill.jox;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutionException;\n\nimport static com.softwaremill.jox.Segment.SEGMENT_SIZE;\nimport static com.softwaremill.jox.SegmentTest.createSegmentChain;\nimport static com.softwaremill.jox.SegmentTest.sendInterruptAllCells;\nimport static com.softwaremill.jox.TestUtil.forkVoid;\nimport static com.softwaremill.jox.TestUtil.scoped;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SegmentRendezvousTest {\n\n    private Segment someSegment;\n    private static final VarHandle SOME_SEGMENT;\n\n    static {\n        try {\n            MethodHandles.Lookup l = MethodHandles.privateLookupIn(SegmentRendezvousTest.class, MethodHandles.lookup());\n            SOME_SEGMENT = l.findVarHandle(SegmentRendezvousTest.class, \"someSegment\", Segment.class);\n        } catch (ReflectiveOperationException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    @Test\n    void segmentShouldBecomeRemovedOnceAllCellsInterrupted() {\n\n        var ss = createSegmentChain(3, 0, true);\n\n\n        for (int i = 0; i < SEGMENT_SIZE - 1; i++) {\n            ss[1].cellInterruptedReceiver();\n\n            assertFalse(ss[1].isRemoved());\n            assertEquals(ss[1].getPrev(), ss[0]);\n            assertEquals(ss[1].getNext(), ss[2]);\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[1]);\n            assertEquals(ss[2].getPrev(), ss[1]);\n            assertNull(ss[2].getNext());\n        }\n\n        ss[1].cellInterruptedReceiver();\n        assertTrue(ss[1].isRemoved());\n\n\n        assertNull(ss[0].getPrev());\n        assertEquals(ss[0].getNext(), ss[2]);\n        assertEquals(ss[2].getPrev(), ss[0]);\n        assertNull(ss[2].getNext());\n    }\n\n    @Test\n    void shouldRemoveMultipleSegments() {\n\n        var ss = createSegmentChain(5, 0, true);\n\n\n\n        assertTrue(ss[1].tryIncPointers());\n        assertTrue(ss[2].tryIncPointers());\n        assertTrue(ss[3].tryIncPointers());\n\n        for (int i = 0; i < SEGMENT_SIZE; i++) {\n            ss[1].cellInterruptedReceiver();\n            assertFalse(ss[1].isRemoved());\n            ss[2].cellInterruptedReceiver();\n            assertFalse(ss[2].isRemoved());\n            ss[3].cellInterruptedReceiver();\n            assertFalse(ss[3].isRemoved());\n        }\n\n        assertTrue(ss[1].decPointers());\n        assertTrue(ss[2].decPointers());\n        assertTrue(ss[3].decPointers());\n\n        assertEquals(ss[0].getNext(), ss[1]);\n        assertEquals(ss[1].getNext(), ss[2]);\n        assertEquals(ss[2].getNext(), ss[3]);\n        assertEquals(ss[3].getNext(), ss[4]);\n\n        ss[2].remove();\n\n\n        assertEquals(ss[0].getNext(), ss[4]);\n        assertEquals(ss[4].getPrev(), ss[0]);\n    }\n\n    @Test\n    void shouldNotIncrementIncomingPointersIfSegmentRemoved() {\n\n        var ss = createSegmentChain(1, 0, true);\n\n\n        sendInterruptAllCells(ss[0]);\n\n\n        assertFalse(ss[0].tryIncPointers());\n    }\n\n    @Test\n    void shouldIncrementAndDecrementPointersInSegment() {\n\n        var ss = createSegmentChain(1, 0, true);\n\n\n        assertTrue(ss[0].tryIncPointers());\n        assertFalse(ss[0].decPointers());\n    }\n\n    @Test\n    void shouldNotRemoveSegmentIfThereAreIncomingPointers() {\n\n        var ss = createSegmentChain(2, 0, true);\n\n\n        assertTrue(ss[0].tryIncPointers());\n\n        for (int i = 0; i < SEGMENT_SIZE; i++) {\n            ss[0].cellInterruptedReceiver();\n            assertFalse(ss[0].isRemoved());\n        }\n\n\n        assertTrue(ss[0].decPointers());\n        assertTrue(ss[0].isRemoved());\n\n        ss[0].remove();\n        assertNull(ss[1].getPrev());\n        assertNull(ss[1].getNext());\n    }\n\n    @Test\n    void shouldRemoveSegmentsWhenRunConcurrently() throws ExecutionException, InterruptedException {\n\n        int segmentCount = 30;\n\n        for (int k = 0; k < 1000; k++) {\n            var ss = createSegmentChain(segmentCount, 0, true);\n\n\n            scoped(scope -> {\n\n                for (int i = 1; i < ss.length - 1; i++) {\n                    for (int j = 0; j < SEGMENT_SIZE - 1; j++) {\n                        ss[i].cellInterruptedReceiver();\n                    }\n                }\n\n\n                for (int i = 1; i < ss.length - 1; i++) {\n                    int ii = i;\n                    forkVoid(scope, () -> {\n                        ss[ii].cellInterruptedReceiver();\n                    });\n                }\n            });\n\n\n            for (int i = 1; i < ss.length - 1; i++) {\n                assertTrue(ss[i].isRemoved());\n            }\n\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[segmentCount - 1]);\n            assertEquals(ss[segmentCount - 1].getPrev(), ss[0]);\n            assertNull(ss[segmentCount - 1].getNext());\n        }\n    }\n\n    @Test\n    void shouldNotResurrectAnUnlikedSegment() {\n\n        var ss = createSegmentChain(3, 0, true);\n\n\n\n        ss[2].cleanPrev();\n\n\n        sendInterruptAllCells(ss[1]);\n\n\n        assertTrue(ss[1].isRemoved());\n        assertEquals(ss[0].getNext(), ss[2]);\n        assertEquals(ss[2].getPrev(), null);\n    }\n\n    @Test\n    void shouldFindAndMoveSegmentReferenceForward() {\n\n        var s = createSegmentChain(4, 0, true);\n        someSegment = s[0];\n\n\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, s[0], 2);\n\n\n        assertEquals(s[2], result);\n\n\n        result = Segment.findAndMoveForward(SOME_SEGMENT, this, s[0], 5);\n        assertEquals(5, result.getId());\n        assertEquals(result, s[3].getNext().getNext());\n    }\n\n    @Test\n    void shouldMoveReferenceForwardIfClosedAndFoundSegmentExists() {\n\n        var s = createSegmentChain(4, 0, true);\n        someSegment = s[0];\n\n\n        s[0].close();\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, s[0], 3);\n\n\n        assertEquals(s[3], result);\n        assertEquals(s[3], someSegment);\n    }\n\n    @Test\n    void shouldNotMoveReferenceForwardIfClosedAndFoundSegmentDoesNotExist() {\n\n        var s = createSegmentChain(4, 0, true);\n        someSegment = s[0];\n\n\n        s[0].close();\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, s[0], 5);\n\n\n        assertNull(result);\n        assertEquals(s[0], someSegment);\n    }\n\n    @Test\n    void shouldRemoveOldTailSegment() {\n\n        var ss = createSegmentChain(2, 0, true);\n\n\n        sendInterruptAllCells(ss[1]);\n\n\n        assertTrue(ss[1].isRemoved());\n        assertEquals(ss[0].getNext(), ss[1]);\n\n\n        someSegment = ss[0];\n        var s2 = Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 2);\n\n\n        assertEquals(s2, ss[0].getNext());\n        assertEquals(s2.getPrev(), ss[0]);\n    }\n\n    @Test\n    void shouldReturnNextSegmentIfRemoved() {\n\n        var ss = createSegmentChain(3, 0, true);\n        sendInterruptAllCells(ss[1]);\n\n\n        someSegment = ss[0];\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 1);\n\n\n        assertEquals(ss[2], result);\n    }\n\n    @Test\n    void shouldNotUpdateSegmentReferenceIfAlreadyUpdated() {\n\n        var ss = createSegmentChain(3, 0, true);\n        someSegment = ss[2];\n\n\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 1);\n\n\n        assertEquals(ss[1], result);\n        assertEquals(ss[2], someSegment);\n    }\n\n    @Test\n    void shouldUpdateSegmentPointersWhenReferenceChanges() {\n\n        var ss = createSegmentChain(3, 0, true);\n        someSegment = ss[0];\n\n\n        Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 1);\n\n\n        sendInterruptAllCells(ss[1]);\n        assertFalse(ss[1].isRemoved());\n\n\n        Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 2);\n\n\n        assertTrue(ss[1].isRemoved());\n        sendInterruptAllCells(ss[2]);\n        assertFalse(ss[2].isRemoved());\n    }\n\n    @Test\n    void shouldConcurrentlyMoveSegmentsForward() throws ExecutionException, InterruptedException {\n\n        for (int k = 0; k < 1000; k++) {\n            var ss = createSegmentChain(1, 0, true);\n            someSegment = ss[0];\n            var observedSegments = new ConcurrentHashMap<Integer, Segment>();\n\n\n            scoped(scope -> {\n\n                for (int f = 0; f < 10; f++) {\n                    forkVoid(scope, () -> {\n                        var s = ss[0];\n                        for (int i = 0; i < 300; i++) {\n                            s = Segment.findAndMoveForward(SOME_SEGMENT, this, s, i);\n                            var previous = observedSegments.put(i, s);\n                            if (previous != s && previous != null) {\n                                fail(\"Already observed segment: \" + previous + \" for id: \" + i + \", but found: \" + s);\n                            }\n                        }\n                    });\n                }\n            });\n        }\n    }\n}\n",
        "gt": [
            "'jox/channels/src/main/java/com/softwaremill/jox/Segment.java'",
            "'jox/channels/src/test/java/com/softwaremill/jox/SegmentTest.java'",
            "'jox/channels/src/test/java/com/softwaremill/jox/SegmentRendezvousTest.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n\n'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport com.jnardari.opencv_androidsamples.R;\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Mat;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport android.util.Log;\nimport android.view.SurfaceView;\nimport android.view.WindowManager;\n\npublic class Tutorial1Activity extends AppCompatActivity implements CvCameraViewListener2 {\n    private static final String TAG = \"Tutorial1Activity\";\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n    private boolean              mIsJavaCamera = true;\n    private MenuItem             mItemSwitchCamera = null;\n\n    private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public Tutorial1Activity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_tutorial1);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.tutorial1_activity_java_surface_view);\n\n        mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);\n\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n    }\n\n    public void onCameraViewStopped() {\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        return inputFrame.rgba();\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.PartitionField;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.StructLike;\nimport com.netflix.iceberg.transforms.Transform;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.Decimal;\nimport org.apache.spark.unsafe.types.UTF8String;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\nclass PartitionKey implements StructLike {\n\n  private final PartitionSpec spec;\n  private final int size;\n  private final Object[] partitionTuple;\n  private final Transform[] transforms;\n  private final Accessor<InternalRow>[] accessors;\n\n  @SuppressWarnings(\"unchecked\")\n  PartitionKey(PartitionSpec spec) {\n    this.spec = spec;\n\n    List<PartitionField> fields = spec.fields();\n    this.size = fields.size();\n    this.partitionTuple = new Object[size];\n    this.transforms = new Transform[size];\n    this.accessors = (Accessor<InternalRow>[]) Array.newInstance(Accessor.class, size);\n\n    Schema schema = spec.schema();\n    Map<Integer, Accessor<InternalRow>> accessors = buildAccessors(schema);\n    for (int i = 0; i < size; i += 1) {\n      PartitionField field = fields.get(i);\n      Accessor<InternalRow> accessor = accessors.get(field.sourceId());\n      if (accessor == null) {\n        throw new RuntimeException(\n            \"Cannot build accessor for field: \" + schema.findField(field.sourceId()));\n      }\n      this.accessors[i] = accessor;\n      this.transforms[i] = field.transform();\n    }\n  }\n\n  private PartitionKey(PartitionKey toCopy) {\n    this.spec = toCopy.spec;\n    this.size = toCopy.size;\n    this.partitionTuple = new Object[toCopy.partitionTuple.length];\n    this.transforms = toCopy.transforms;\n    this.accessors = toCopy.accessors;\n\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      this.partitionTuple[i] = defensiveCopyIfNeeded(toCopy.partitionTuple[i]);\n    }\n  }\n\n  private Object defensiveCopyIfNeeded(Object obj) {\n    if (obj instanceof UTF8String) {\n\n      byte[] bytes = ((UTF8String) obj).getBytes();\n      return UTF8String.fromBytes(Arrays.copyOf(bytes, bytes.length));\n    }\n    return obj;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[\");\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      if (i > 0) {\n        sb.append(\", \");\n      }\n      sb.append(partitionTuple[i]);\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  PartitionKey copy() {\n    return new PartitionKey(this);\n  }\n\n  String toPath() {\n    return spec.partitionToPath(this);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  void partition(InternalRow row) {\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      Transform<Object, Object> transform = transforms[i];\n      partitionTuple[i] = transform.apply(accessors[i].get(row));\n    }\n  }\n\n  @Override\n  public int size() {\n    return size;\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public <T> T get(int pos, Class<T> javaClass) {\n    return javaClass.cast(partitionTuple[pos]);\n  }\n\n  @Override\n  public <T> void set(int pos, T value) {\n    partitionTuple[pos] = value;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    PartitionKey that = (PartitionKey) o;\n    return Arrays.equals(partitionTuple, that.partitionTuple);\n  }\n\n  @Override\n  public int hashCode() {\n    return Arrays.hashCode(partitionTuple);\n  }\n\n  private interface Accessor<T> {\n    Object get(T container);\n  }\n\n  private static Map<Integer, Accessor<InternalRow>> buildAccessors(Schema schema) {\n    return TypeUtil.visit(schema, new BuildPositionAccessors());\n  }\n\n  private static Accessor<InternalRow> newAccessor(int p, Type type) {\n    switch (type.typeId()) {\n      case STRING:\n        return new StringAccessor(p, convert(type));\n      case DECIMAL:\n        return new DecimalAccessor(p, convert(type));\n      default:\n        return new PositionAccessor(p, convert(type));\n    }\n  }\n\n  private static Accessor<InternalRow> newAccessor(int p, boolean isOptional, Types.StructType type,\n                                                   Accessor<InternalRow> accessor) {\n    int size = type.fields().size();\n    if (isOptional) {\n\n      return new WrappedPositionAccessor(p, size, accessor);\n    } else if (accessor instanceof PositionAccessor) {\n      return new Position2Accessor(p, size, (PositionAccessor) accessor);\n    } else if (accessor instanceof Position2Accessor) {\n      return new Position3Accessor(p, size, (Position2Accessor) accessor);\n    } else {\n      return new WrappedPositionAccessor(p, size, accessor);\n    }\n  }\n\n  private static class BuildPositionAccessors\n      extends TypeUtil.SchemaVisitor<Map<Integer, Accessor<InternalRow>>> {\n    @Override\n    public Map<Integer, Accessor<InternalRow>> schema(\n        Schema schema, Map<Integer, Accessor<InternalRow>> structResult) {\n      return structResult;\n    }\n\n    @Override\n    public Map<Integer, Accessor<InternalRow>> struct(\n        Types.StructType struct, List<Map<Integer, Accessor<InternalRow>>> fieldResults) {\n      Map<Integer, Accessor<InternalRow>> accessors = Maps.newHashMap();\n      List<Types.NestedField> fields = struct.fields();\n      for (int i = 0; i < fieldResults.size(); i += 1) {\n        Types.NestedField field = fields.get(i);\n        Map<Integer, Accessor<InternalRow>> result = fieldResults.get(i);\n        if (result != null) {\n          for (Map.Entry<Integer, Accessor<InternalRow>> entry : result.entrySet()) {\n            accessors.put(entry.getKey(), newAccessor(i, field.isOptional(),\n                field.type().asNestedType().asStructType(), entry.getValue()));\n          }\n        } else {\n          accessors.put(field.fieldId(), newAccessor(i, field.type()));\n        }\n      }\n\n      if (accessors.isEmpty()) {\n        return null;\n      }\n\n      return accessors;\n    }\n\n    @Override\n    public Map<Integer, Accessor<InternalRow>> field(\n        Types.NestedField field, Map<Integer, Accessor<InternalRow>> fieldResult) {\n      return fieldResult;\n    }\n  }\n\n  private static class PositionAccessor implements Accessor<InternalRow> {\n    protected final DataType type;\n    protected int p;\n\n    private PositionAccessor(int p, DataType type) {\n      this.p = p;\n      this.type = type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return row.get(p, type);\n    }\n  }\n\n  private static class StringAccessor extends PositionAccessor {\n    private StringAccessor(int p, DataType type) {\n      super(p, type);\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return row.get(p, type).toString();\n    }\n  }\n\n  private static class DecimalAccessor extends PositionAccessor {\n    private DecimalAccessor(int p, DataType type) {\n      super(p, type);\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return ((Decimal) row.get(p, type)).toJavaBigDecimal();\n    }\n  }\n\n  private static class Position2Accessor implements Accessor<InternalRow> {\n    private final int p0;\n    private final int size0;\n    private final int p1;\n    private final DataType type;\n\n    private Position2Accessor(int p, int size, PositionAccessor wrapped) {\n      this.p0 = p;\n      this.size0 = size;\n      this.p1 = wrapped.p;\n      this.type = wrapped.type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      return row.getStruct(p0, size0).get(p1, type);\n    }\n  }\n\n  private static class Position3Accessor implements Accessor<InternalRow> {\n    private final int p0;\n    private final int size0;\n    private final int p1;\n    private final int size1;\n    private final int p2;\n    private final DataType type;\n\n    private Position3Accessor(int p, int size, Position2Accessor wrapped) {\n      this.p0 = p;\n      this.size0 = size;\n      this.p1 = wrapped.p0;\n      this.size1 = wrapped.size0;\n      this.p2 = wrapped.p1;\n      this.type = wrapped.type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      return row.getStruct(p0, size0).getStruct(p1, size1).get(p2, type);\n    }\n  }\n\n  private static class WrappedPositionAccessor implements Accessor<InternalRow> {\n    private final int p;\n    private final int size;\n    private final Accessor<InternalRow> accessor;\n\n    private WrappedPositionAccessor(int p, int size, Accessor<InternalRow> accessor) {\n      this.p = p;\n      this.size = size;\n      this.accessor = accessor;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      InternalRow inner = row.getStruct(p, size);\n      if (inner != null) {\n        return accessor.get(inner);\n      }\n      return null;\n    }\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Paint.Align;\nimport android.graphics.Paint.Style;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.Nullable;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.MONTH_NAVIGATION_BAR_SIZE;\n\n\npublic final class MonthPickerView extends View {\n    private static final String TAG = \"MonthPickerView\";\n\n    private static final int NUM_COLUMNS = 3;\n    private static final int NUM_ROWS = 4;\n    private static final int MONTH_SEPARATOR_WIDTH = 1;\n\n    private static int MONTH_LABEL_TEXT_SIZE;\n    private static int MONTH_SELECTED_CIRCLE_SIZE;\n\n\n    private int mEdgePadding = 0;\n\n    private Paint mMonthLabelPaint;\n    private Paint mSelectedCirclePaint;\n\n\n    private int mWidth;\n    private int mRowHeight;\n    private CalendarDay mSelectedDay;\n\n    private int mYear;\n\n    private final int mCurrentMonth;\n\n    private final int mCurrentYear;\n\n    private final String[] mShortMonthLabels;\n\n    @Nullable\n    private DateRangeHelper mDateRangeHelper;\n    @Nullable\n    private OnMonthClickListener mOnMonthClickListener;\n\n    private int mNormalTextColor;\n    private int mCurrentMonthTextColor;\n    private int mDisabledMonthTextColor;\n    private int mSelectedMonthTextColor;\n\n    public MonthPickerView(Context context) {\n        this(context, null);\n    }\n\n    public MonthPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        Resources res = context.getResources();\n\n        mShortMonthLabels = new DateFormatSymbols().getShortMonths();\n\n        mNormalTextColor = getColor(context, R.color.bsp_text_color_primary_light);\n\n        mSelectedMonthTextColor = getColor(context, R.color.bsp_date_picker_view_animator);\n        mCurrentMonthTextColor = Utils.getThemeAccentColor(context);\n        mDisabledMonthTextColor = getColor(context, R.color.bsp_text_color_disabled_light);\n\n        Calendar now = Calendar.getInstance();\n        mCurrentMonth = now.get(Calendar.MONTH);\n        mCurrentYear = now.get(Calendar.YEAR);\n\n        MONTH_LABEL_TEXT_SIZE = res.getDimensionPixelSize(R.dimen.bsp_month_picker_month_label_size);\n        MONTH_SELECTED_CIRCLE_SIZE = res.getDimensionPixelSize(R.dimen.bsp_month_select_circle_radius);\n\n        mRowHeight = (res.getDimensionPixelOffset(R.dimen.bsp_date_picker_view_animator_height)\n                - MONTH_NAVIGATION_BAR_SIZE) / NUM_ROWS;\n        mEdgePadding = res.getDimensionPixelSize(R.dimen.bsp_month_view_edge_padding);\n\n\n\n        initView();\n    }\n\n\n    void setDisplayParams(CalendarDay selectedDay, int year) {\n        mSelectedDay = selectedDay;\n        mYear = year;\n\n\n\n    }\n\n\n    private void adjustDayInMonthIfNeeded(int month) {\n        int daysInMonth = Utils.getDaysInMonth(month, mYear);\n        if (mSelectedDay.day > daysInMonth) {\n            mSelectedDay.day = daysInMonth;\n        }\n    }\n\n    private int constrainDayInMonth(int month, int defaultDay) {\n        int daysInMonth = Utils.getDaysInMonth(month, mYear);\n        return Math.min(defaultDay, daysInMonth);\n    }\n\n    public void setDatePickerController(DatePickerController controller) {\n        mDateRangeHelper = new DateRangeHelper(controller);\n    }\n\n    public void setOnMonthClickListener(@Nullable OnMonthClickListener onMonthClickListener) {\n        mOnMonthClickListener = onMonthClickListener;\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        if (themeDark) {\n            mNormalTextColor = getColor(context, R.color.bsp_text_color_primary_dark);\n            mSelectedMonthTextColor = getColor(context, R.color.bsp_dark_gray);\n            mDisabledMonthTextColor = getColor(context, R.color.bsp_text_color_disabled_dark);\n            initView();\n        }\n    }\n\n\n    void setCurrentMonthTextColor(@ColorInt int color) {\n        mCurrentMonthTextColor = color;\n    }\n\n\n    void setSelectedCirclePaintColor(@ColorInt int color) {\n        mSelectedCirclePaint.setColor(color);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_UP:\n                final int month = getMonthFromLocation(event.getX(), event.getY());\n                if (month >= 0) {\n                    onMonthClick(month);\n                }\n                break;\n        }\n        return true;\n    }\n\n\n    protected void initView() {\n        mMonthLabelPaint = new Paint();\n        mMonthLabelPaint.setAntiAlias(true);\n        mMonthLabelPaint.setTextSize(MONTH_LABEL_TEXT_SIZE);\n        mMonthLabelPaint.setStyle(Style.FILL);\n        mMonthLabelPaint.setTextAlign(Align.CENTER);\n        mMonthLabelPaint.setFakeBoldText(false);\n\n        mSelectedCirclePaint = new Paint();\n        mSelectedCirclePaint.setFakeBoldText(true);\n        mSelectedCirclePaint.setAntiAlias(true);\n        mSelectedCirclePaint.setColor(mCurrentMonthTextColor);\n        mSelectedCirclePaint.setTextAlign(Align.CENTER);\n        mSelectedCirclePaint.setStyle(Style.FILL);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), mRowHeight * NUM_ROWS\n                + MONTH_NAVIGATION_BAR_SIZE);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        mWidth = w;\n\n\n\n    }\n\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        drawMonthLabels(canvas);\n    }\n\n    private void drawMonthLabels(Canvas canvas) {\n        int y = (((mRowHeight + MONTH_LABEL_TEXT_SIZE) / 2) - MONTH_SEPARATOR_WIDTH);\n        final float monthWidthHalf = (mWidth - mEdgePadding * 2) / (NUM_COLUMNS * 2.0f);\n        int col = 0;\n        for (int month = Calendar.JANUARY; month <= Calendar.DECEMBER; month++) {\n            final int x = (int)((2 * col + 1) * monthWidthHalf + mEdgePadding);\n\n\n\n\n            int constrainedDay = constrainDayInMonth(month, mSelectedDay.day);\n            drawMonthLabel(canvas, mYear, month, constrainedDay, x, y);\n            col++;\n            if (col == NUM_COLUMNS) {\n                col = 0;\n                y += mRowHeight;\n            }\n        }\n    }\n\n    private void drawMonthLabel(Canvas canvas, int year, int month, int day, int x, int y) {\n        final int selectedYear = mSelectedDay.year;\n        final int selectedMonth = mSelectedDay.month;\n\n        boolean drawCircle = selectedYear == year && selectedMonth == month;\n        if (drawCircle) {\n            canvas.drawCircle(x , y - (MONTH_LABEL_TEXT_SIZE / 3), MONTH_SELECTED_CIRCLE_SIZE,\n                    mSelectedCirclePaint);\n        }\n\n\n\n        if (mDateRangeHelper != null && mDateRangeHelper.isOutOfRange(year, month, day)) {\n            mMonthLabelPaint.setFakeBoldText(false);\n            mMonthLabelPaint.setColor(mDisabledMonthTextColor);\n        } else {\n            boolean currentMonthYear = mCurrentYear == year && mCurrentMonth == month;\n            mMonthLabelPaint.setFakeBoldText(currentMonthYear || drawCircle);\n            mMonthLabelPaint.setColor(drawCircle ? mSelectedMonthTextColor :\n                    (currentMonthYear ? mCurrentMonthTextColor : mNormalTextColor));\n        }\n        canvas.drawText(mShortMonthLabels[month], x, y, mMonthLabelPaint);\n    }\n\n\n    public int getMonthFromLocation(float x, float y) {\n        final int month = getInternalMonthFromLocation(x, y);\n        if (month < Calendar.JANUARY || month > Calendar.DECEMBER) {\n            return -1;\n        }\n        return month;\n    }\n\n\n    protected int getInternalMonthFromLocation(float x, float y) {\n        int monthStart = mEdgePadding;\n        if (x < monthStart || x > mWidth - mEdgePadding) {\n\n            return -1;\n        }\n        int row = (int) (y / mRowHeight);\n\n        int column = (int) ((x - monthStart) * NUM_COLUMNS / (mWidth - mEdgePadding * 2));\n\n        int month = column;\n        month += row * NUM_COLUMNS;\n        return month;\n    }\n\n\n    private void onMonthClick(int month) {\n        adjustDayInMonthIfNeeded(month);\n\n        if (mDateRangeHelper != null && mDateRangeHelper.isOutOfRange(mYear, month, mSelectedDay.day)) {\n            return;\n        }\n\n        if (mOnMonthClickListener != null) {\n            mOnMonthClickListener.onMonthClick(this, month, mYear);\n        }\n\n\n\n    }\n\n    interface OnMonthClickListener {\n        void onMonthClick(MonthPickerView view, int month, int year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientAnnotationFactory.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.apache.ResultCode;\nimport io.airlift.drift.integration.scribe.apache.scribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TCompactProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransport;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportFactory;\nimport org.apache.thrift.transport.layered.TFramedTransport;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\nimport java.util.List;\nimport java.util.function.ToIntFunction;\n\nimport static io.airlift.drift.integration.ClientTestUtils.MESSAGES;\nimport static org.testng.Assert.assertEquals;\n\nfinal class LegacyApacheThriftTesterUtil\n{\n    private LegacyApacheThriftTesterUtil() {}\n\n    public static List<ToIntFunction<HostAndPort>> legacyApacheThriftTestClients(List<MethodInvocationFilter> filters, Transport transport, Protocol protocol, boolean secure)\n    {\n        return ImmutableList.of(\n                address -> logThrift(address, MESSAGES, filters, transport, protocol, secure));\n    }\n\n    private static int logThrift(HostAndPort address, List<LogEntry> messages, List<MethodInvocationFilter> filters, Transport transportType, Protocol protocolType, boolean secure)\n    {\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        TTransportFactory transportFactory;\n        switch (transportType) {\n            case UNFRAMED:\n                transportFactory = new TTransportFactory();\n                break;\n            case FRAMED:\n                transportFactory = new TFramedTransport.Factory();\n                break;\n            case HEADER:\n                return 0;\n            default:\n                throw new IllegalArgumentException(\"Unsupported transport \" + transportType);\n        }\n\n        try (TSocket socket = createClientSocket(secure, address)) {\n            if (!socket.isOpen()) {\n                socket.open();\n            }\n            TTransport transport = transportFactory.getTransport(socket);\n            TProtocol protocol;\n            switch (protocolType) {\n                case BINARY:\n                    protocol = new TBinaryProtocol(transport);\n                    break;\n                case COMPACT:\n                    protocol = new TCompactProtocol(transport);\n                    break;\n                case FB_COMPACT:\n                    return 0;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported protocol \" + protocolType);\n            }\n\n            assertEquals(new scribe.Client(protocol).Log(messages), ResultCode.OK);\n        }\n        catch (TException e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static TSocket createClientSocket(boolean secure, HostAndPort address)\n            throws TTransportException\n    {\n        if (!secure) {\n            return new TSocket(address.getHost(), address.getPort());\n        }\n\n        try {\n            SSLContext serverSslContext = ClientTestUtils.getClientSslContext();\n            SSLSocket clientSocket = (SSLSocket) serverSslContext.getSocketFactory().createSocket(address.getHost(), address.getPort());\n\n            return new TSocket(clientSocket);\n        }\n        catch (Exception e) {\n            throw new TTransportException(\"Error initializing secure socket\", e);\n        }\n    }\n}\n\n'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'\n:\npackage io.airlift.drift.client.guice;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.reflect.TypeParameter;\nimport com.google.common.reflect.TypeToken;\nimport com.google.inject.Binder;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Module;\nimport com.google.inject.Provider;\nimport com.google.inject.Provides;\nimport com.google.inject.Scopes;\nimport com.google.inject.Singleton;\nimport com.google.inject.TypeLiteral;\nimport io.airlift.configuration.ConfigDefaults;\nimport io.airlift.drift.client.DriftClient;\nimport io.airlift.drift.client.DriftClientFactory;\nimport io.airlift.drift.client.DriftClientFactoryManager;\nimport io.airlift.drift.client.ExceptionClassifier;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.client.stats.JmxMethodInvocationStatsFactory;\nimport io.airlift.drift.client.stats.MethodInvocationStatsFactory;\nimport io.airlift.drift.client.stats.NullMethodInvocationStatsFactory;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.codec.guice.ThriftCodecModule;\nimport io.airlift.drift.transport.client.DriftClientConfig;\nimport io.airlift.drift.transport.client.MethodInvokerFactory;\nimport org.weakref.jmx.MBeanExporter;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport static com.google.inject.multibindings.Multibinder.newSetBinder;\nimport static com.google.inject.multibindings.OptionalBinder.newOptionalBinder;\nimport static io.airlift.configuration.ConfigBinder.configBinder;\nimport static io.airlift.drift.client.ExceptionClassifier.mergeExceptionClassifiers;\nimport static io.airlift.drift.client.guice.DriftClientAnnotationFactory.extractDriftClientBindingAnnotation;\nimport static io.airlift.drift.client.guice.DriftClientAnnotationFactory.getDriftClientAnnotation;\nimport static io.airlift.drift.codec.metadata.ThriftServiceMetadata.getThriftServiceAnnotation;\nimport static java.util.Objects.requireNonNull;\n\npublic class DriftClientBinder\n{\n    public static DriftClientBinder driftClientBinder(Binder binder)\n    {\n        return new DriftClientBinder(binder);\n    }\n\n    private final Binder binder;\n\n    private DriftClientBinder(Binder binder)\n    {\n        this.binder = requireNonNull(binder, \"binder is null\").skipSources(this.getClass());\n        binder.install(new ThriftCodecModule());\n        binder.install(new DriftClientBinderModule());\n    }\n\n    public <T> DriftClientBindingBuilder bindDriftClient(Class<T> clientInterface)\n    {\n        String configPrefix = getServiceName(clientInterface);\n        return bindDriftClient(clientInterface, configPrefix, DefaultClient.class);\n    }\n\n    public <T> DriftClientBindingBuilder bindDriftClient(Class<T> clientInterface, Class<? extends Annotation> annotationType)\n    {\n        String configPrefix = getServiceName(clientInterface);\n        if (annotationType != DefaultClient.class) {\n            configPrefix += \".\" + annotationType.getSimpleName();\n        }\n        return bindDriftClient(clientInterface, configPrefix, annotationType);\n    }\n\n    private <T> DriftClientBindingBuilder bindDriftClient(Class<T> clientInterface, String configPrefix, Class<? extends Annotation> annotation)\n    {\n        Annotation clientAnnotation = getDriftClientAnnotation(clientInterface, annotation);\n\n        configBinder(binder).bindConfig(DriftClientConfig.class, clientAnnotation, configPrefix);\n\n        TypeLiteral<DriftClient<T>> typeLiteral = driftClientTypeLiteral(clientInterface);\n\n        Provider<T> instanceProvider = new DriftClientInstanceProvider<>(clientAnnotation, Key.get(typeLiteral, annotation));\n        Provider<DriftClient<T>> factoryProvider = new DriftClientProvider<>(clientInterface, clientAnnotation);\n\n        binder.bind(Key.get(clientInterface, annotation)).toProvider(instanceProvider).in(Scopes.SINGLETON);\n        binder.bind(Key.get(typeLiteral, annotation)).toProvider(factoryProvider).in(Scopes.SINGLETON);\n\n        if (annotation == DefaultClient.class) {\n            binder.bind(Key.get(clientInterface)).toProvider(instanceProvider).in(Scopes.SINGLETON);\n            binder.bind(Key.get(typeLiteral)).toProvider(factoryProvider).in(Scopes.SINGLETON);\n        }\n\n        return new DriftClientBindingBuilder(binder, clientAnnotation, configPrefix);\n    }\n\n    public <T> void bindClientConfigDefaults(Class<T> clientInterface, ConfigDefaults<DriftClientConfig> configDefaults)\n    {\n        bindClientConfigDefaults(clientInterface, DefaultClient.class, configDefaults);\n    }\n\n    public <T> void bindClientConfigDefaults(Class<T> clientInterface, Class<? extends Annotation> annotationType, ConfigDefaults<DriftClientConfig> configDefaults)\n    {\n        bindConfigDefaults(clientInterface, annotationType, DriftClientConfig.class, configDefaults);\n    }\n\n    public <T, C> void bindConfigDefaults(Class<T> clientInterface, Class<C> configClass, ConfigDefaults<C> configDefaults)\n    {\n        bindConfigDefaults(configClass, DefaultClient.class, configClass, configDefaults);\n    }\n\n    public <T, C> void bindConfigDefaults(Class<T> clientInterface, Class<? extends Annotation> annotationType, Class<C> configClass, ConfigDefaults<C> configDefaults)\n    {\n        configBinder(binder).bindConfigDefaults(configClass, getDriftClientAnnotation(clientInterface, annotationType), configDefaults);\n    }\n\n    private static String getServiceName(Class<?> clientInterface)\n    {\n        requireNonNull(clientInterface, \"clientInterface is null\");\n        String serviceName = getThriftServiceAnnotation(clientInterface).value();\n        if (!serviceName.isEmpty()) {\n            return serviceName;\n        }\n        return clientInterface.getSimpleName();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T> TypeLiteral<DriftClient<T>> driftClientTypeLiteral(Class<T> clientInterface)\n    {\n        Type javaType = new TypeToken<DriftClient<T>>() {}\n                .where(new TypeParameter<T>() {}, TypeToken.of(clientInterface))\n                .getType();\n        return (TypeLiteral<DriftClient<T>>) TypeLiteral.get(javaType);\n    }\n\n    private static class DriftClientInstanceProvider<T>\n            extends AbstractAnnotatedProvider<T>\n    {\n        private final Key<DriftClient<T>> key;\n\n        public DriftClientInstanceProvider(Annotation annotation, Key<DriftClient<T>> key)\n        {\n            super(annotation);\n            this.key = requireNonNull(key, \"key is null\");\n        }\n\n        @Override\n        protected T get(Injector injector, Annotation annotation)\n        {\n            return injector.getInstance(key).get();\n        }\n    }\n\n    private static class DriftClientProvider<T>\n            extends AbstractAnnotatedProvider<DriftClient<T>>\n    {\n        private static final TypeLiteral<DriftClientFactoryManager<Annotation>> DRIFT_CLIENT_FACTORY_MANAGER_TYPE = new TypeLiteral<DriftClientFactoryManager<Annotation>>() {};\n        private static final TypeLiteral<Set<MethodInvocationFilter>> SET_METHOD_INVOCATION_FILTERS_TYPE = new TypeLiteral<Set<MethodInvocationFilter>>() {};\n        private static final TypeLiteral<Set<ExceptionClassifier>> SET_EXCEPTION_CLASSIFIER_TYPE = new TypeLiteral<Set<ExceptionClassifier>>() {};\n\n        private final Class<T> clientInterface;\n\n        public DriftClientProvider(Class<T> clientInterface, Annotation annotation)\n        {\n            super(annotation);\n            this.clientInterface = requireNonNull(clientInterface, \"clientInterface is null\");\n        }\n\n        @Override\n        protected DriftClient<T> get(Injector injector, Annotation clientAnnotation)\n        {\n            DriftClientConfig config = injector.getInstance(Key.get(DriftClientConfig.class, clientAnnotation));\n            DriftClientFactoryManager<Annotation> driftClientFactoryManager = injector.getInstance(Key.get(DRIFT_CLIENT_FACTORY_MANAGER_TYPE));\n\n            AddressSelector<?> addressSelector = injector.getInstance(Key.get(AddressSelector.class, clientAnnotation));\n\n            ExceptionClassifier exceptionClassifier = mergeExceptionClassifiers(ImmutableList.<ExceptionClassifier>builder()\n                    .addAll(injector.getInstance(Key.get(SET_EXCEPTION_CLASSIFIER_TYPE, clientAnnotation)))\n                    .addAll(injector.getInstance(Key.get(SET_EXCEPTION_CLASSIFIER_TYPE)))\n                    .build());\n\n            List<MethodInvocationFilter> filters = ImmutableList.copyOf(injector.getInstance(Key.get(SET_METHOD_INVOCATION_FILTERS_TYPE, clientAnnotation)));\n\n            DriftClientFactory driftClientFactory = driftClientFactoryManager.createDriftClientFactory(clientAnnotation, addressSelector, exceptionClassifier);\n            return driftClientFactory.createDriftClient(clientInterface, extractDriftClientBindingAnnotation(clientAnnotation), filters, config);\n        }\n    }\n\n    private static class DefaultMethodInvocationStatsFactoryProvider\n            implements Provider<MethodInvocationStatsFactory>\n    {\n        private final Optional<MBeanExporter> mbeanExporter;\n\n        @Inject\n        public DefaultMethodInvocationStatsFactoryProvider(Optional<MBeanExporter> mbeanExporter)\n        {\n            this.mbeanExporter = mbeanExporter;\n        }\n\n        @Override\n        public MethodInvocationStatsFactory get()\n        {\n            return mbeanExporter\n                    .map(JmxMethodInvocationStatsFactory::new)\n                    .map(MethodInvocationStatsFactory.class::cast)\n                    .orElseGet(NullMethodInvocationStatsFactory::new);\n        }\n    }\n\n    private static class DriftClientBinderModule\n            implements Module\n    {\n        @Override\n        public void configure(Binder binder)\n        {\n            newSetBinder(binder, ExceptionClassifier.class);\n            newOptionalBinder(binder, MBeanExporter.class);\n            newOptionalBinder(binder, MethodInvocationStatsFactory.class)\n                    .setDefault()\n                    .toProvider(DefaultMethodInvocationStatsFactoryProvider.class)\n                    .in(Scopes.SINGLETON);\n        }\n\n        @Provides\n        @Singleton\n        private static DriftClientFactoryManager<Annotation> getDriftClientFactory(\n                ThriftCodecManager codecManager,\n                MethodInvokerFactory<Annotation> methodInvokerFactory,\n                MethodInvocationStatsFactory methodInvocationStatsFactory)\n        {\n            return new DriftClientFactoryManager<>(codecManager, methodInvokerFactory, methodInvocationStatsFactory);\n        }\n\n        @Override\n        public boolean equals(Object o)\n        {\n            if (this == o) {\n                return true;\n            }\n            return o != null && getClass() == o.getClass();\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return getClass().hashCode();\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientAnnotationFactory.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.inject.BindingAnnotation;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.Scopes;\nimport io.airlift.bootstrap.Bootstrap;\nimport io.airlift.bootstrap.LifeCycleManager;\nimport io.airlift.drift.client.DriftClient;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftResultCode;\nimport io.airlift.drift.integration.scribe.drift.DriftScribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.jmx.testing.TestingJmxModule;\nimport org.weakref.jmx.guice.MBeanModule;\n\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManagerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport static io.airlift.drift.client.guice.DriftClientBinder.driftClientBinder;\nimport static io.airlift.drift.client.guice.MethodInvocationFilterBinder.staticFilterBinder;\nimport static io.airlift.security.pem.PemReader.loadKeyStore;\nimport static io.airlift.security.pem.PemReader.loadTrustStore;\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertSame;\n\nfinal class ClientTestUtils\n{\n    public static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n    public static final List<LogEntry> MESSAGES = ImmutableList.of(\n            new LogEntry(\"hello\", \"world\"),\n            new LogEntry(\"bye\", \"world\"));\n    public static final String HEADER_VALUE = \"header-value\";\n    public static final List<DriftLogEntry> DRIFT_MESSAGES = ImmutableList.copyOf(\n            MESSAGES.stream()\n                    .map(input -> new DriftLogEntry(input.category, input.message))\n                    .collect(Collectors.toList()));\n    public static final DriftResultCode DRIFT_OK = DriftResultCode.OK;\n\n    private ClientTestUtils() {}\n\n    public static int logDriftClientBinder(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            Module transportModule,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n\n        Bootstrap app = new Bootstrap(\n                new MBeanModule(),\n                new TestingJmxModule(),\n                transportModule,\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class, CustomClient.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> binder.bind(ScribeUser.class).in(Scopes.SINGLETON));\n\n        LifeCycleManager lifeCycleManager = null;\n\n        try {\n            app.setRequiredConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"scribe.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.CustomClient.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.thrift.client.protocol\", protocol.toString())\n                    .put(\"scribe.CustomClient.thrift.client.protocol\", protocol.toString())\n                    .build());\n\n\n            app.setOptionalConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.CustomClient.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.CustomClient.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .build());\n\n            Injector injector = app\n                    .doNotInitializeLogging()\n                    .initialize();\n\n            lifeCycleManager = injector.getInstance(LifeCycleManager.class);\n            DriftScribe scribe = injector.getInstance(DriftScribe.class);\n\n            ScribeUser user = injector.getInstance(ScribeUser.class);\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n\n            assertEquals(user.getClient().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getClientCustom().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactory().get().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactoryCustom().get().log(headerValue, entries), DRIFT_OK);\n\n            assertSame(scribe, user.getClient());\n            assertNotSame(user.getClient(), user.getClientCustom());\n            assertNotSame(user.getFactory(), user.getFactoryCustom());\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        finally {\n            if (lifeCycleManager != null) {\n                try {\n                    lifeCycleManager.stop();\n                }\n                catch (Exception ignored) {\n                }\n            }\n        }\n        return 5;\n    }\n\n    public static SSLContext getServerSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        keyManagerFactory.init(loadKeyStore(getPrivateKeyFile(), getPrivateKeyFile(), Optional.empty()), new char[0]);\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static SSLContext getClientSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static File getPrivateKeyFile()\n    {\n        return getResourceFile(\"rsa.key\");\n    }\n\n    public static File getCertificateChainFile()\n    {\n        return getResourceFile(\"rsa.crt\");\n    }\n\n    private static File getResourceFile(String name)\n    {\n        URL resource = TestClientsWithApacheServer.class.getClassLoader().getResource(name);\n        if (resource == null) {\n            throw new IllegalArgumentException(\"Resource not found \" + name);\n        }\n        return new File(resource.getFile());\n    }\n\n    @Target({FIELD, PARAMETER, METHOD})\n    @Retention(RUNTIME)\n    @BindingAnnotation\n    private @interface CustomClient {}\n\n    private static class ScribeUser\n    {\n        @Inject\n        private DriftScribe client;\n\n        @Inject\n        @CustomClient\n        private DriftScribe clientCustom;\n\n        @Inject\n        private DriftClient<DriftScribe> factory;\n\n        @Inject\n        @CustomClient\n        private DriftClient<DriftScribe> factoryCustom;\n\n        public DriftScribe getClient()\n        {\n            return client;\n        }\n\n        public DriftScribe getClientCustom()\n        {\n            return clientCustom;\n        }\n\n        public DriftClient<DriftScribe> getFactory()\n        {\n            return factory;\n        }\n\n        public DriftClient<DriftScribe> getFactoryCustom()\n        {\n            return factoryCustom;\n        }\n    }\n}\n\n'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'\n:\npackage io.airlift.drift.client;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.List;\n\nimport static io.airlift.drift.client.ExceptionClassification.NORMAL_EXCEPTION;\nimport static io.airlift.drift.client.ExceptionClassification.mergeExceptionClassifications;\nimport static java.util.Objects.requireNonNull;\n\npublic interface ExceptionClassifier\n{\n    ExceptionClassifier NORMAL_RESULT = throwable -> NORMAL_EXCEPTION;\n\n    static ExceptionClassifier mergeExceptionClassifiers(Iterable<? extends ExceptionClassifier> classifiers)\n    {\n        List<ExceptionClassifier> exceptionClassifiers = ImmutableList.copyOf(requireNonNull(classifiers, \"classifiers is null\"));\n        return throwable -> exceptionClassifiers.stream()\n                .map(classifier -> classifier.classifyException(throwable))\n                .collect(mergeExceptionClassifications());\n    }\n\n    ExceptionClassification classifyException(Throwable throwable);\n}\n",
        "gt": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.View;\nimport android.view.ViewConfiguration;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.AbsListView;\nimport android.widget.AbsListView.OnScrollListener;\nimport android.widget.ListView;\n\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\n\npublic abstract class DayPickerView extends ListView implements OnScrollListener,\n    OnDateChangedListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n\n    protected static final int SCROLL_HYST_WEEKS = 2;\n\n    protected static final int GOTO_SCROLL_DURATION = 250;\n\n\n    protected static final int SCROLL_CHANGE_DELAY = 40;\n\n    public static final int DAYS_PER_WEEK = 7;\n    public static int LIST_TOP_OFFSET = -1;\n\n\n    protected int mNumWeeks = 6;\n    protected boolean mShowWeekNumber = false;\n    protected int mDaysPerWeek = 7;\n    private static SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n\n    protected float mFriction = 1.0f;\n\n    protected Context mContext;\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected MonthAdapter mAdapter;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mFirstDayOfWeek;\n\n    protected CharSequence mPrevMonthName;\n\n    protected int mCurrentMonthDisplayed;\n\n    protected long mPreviousScrollPosition;\n\n    protected int mPreviousScrollState = OnScrollListener.SCROLL_STATE_IDLE;\n\n    protected int mCurrentScrollState = OnScrollListener.SCROLL_STATE_IDLE;\n\n    private DatePickerController mController;\n    private boolean mPerformingScroll;\n\n    private boolean mThemeDark;\n\n    public DayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public DayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public DayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        super(context);\n        init(context);\n        mThemeDark = themeDark;\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n    }\n\n    public void init(Context context) {\n        mHandler = new Handler();\n        setLayoutParams(new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));\n        setDrawSelectorOnTop(false);\n\n        mContext = context;\n        setUpListView();\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    public void onChange() {\n        refreshAdapter();\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        setAdapter(mAdapter);\n    }\n\n    public abstract MonthAdapter createMonthAdapter(Context context,\n            DatePickerController controller);\n\n    public abstract MonthAdapter createMonthAdapter(Context context,\n            DatePickerController controller, boolean themeDark);\n\n\n    protected void setUpListView() {\n\n        setCacheColorHint(0);\n\n        setDivider(null);\n\n        setItemsCanFocus(true);\n\n        setFastScrollEnabled(false);\n        setVerticalScrollBarEnabled(false);\n        setOnScrollListener(this);\n        setFadingEdgeLength(0);\n\n        setFriction(ViewConfiguration.getScrollFriction() * mFriction);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = (day.year - mController.getMinYear())\n                * MonthAdapter.MONTHS_IN_YEAR + day.month;\n\n        View child;\n        int i = 0;\n        int top = 0;\n\n        do {\n            child = getChildAt(i++);\n            if (child == null) {\n                break;\n            }\n            top = child.getTop();\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.d(TAG, \"child at \" + (i - 1) + \" has top \" + top);\n            }\n        } while (top < 0);\n\n\n        int selectedPosition;\n        if (child != null) {\n            selectedPosition = getPositionForView(child);\n        } else {\n            selectedPosition = 0;\n        }\n\n        if (setSelected) {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthDisplayed(mTempDay);\n            mPreviousScrollState = OnScrollListener.SCROLL_STATE_FLING;\n            if (animate) {\n                smoothScrollToPositionFromTop(\n                        position, LIST_TOP_OFFSET, GOTO_SCROLL_DURATION);\n                return true;\n            } else {\n                postSetSelection(position);\n            }\n        } else if (setSelected) {\n            setMonthDisplayed(mSelectedDay);\n        }\n        return false;\n    }\n\n    public void postSetSelection(final int position) {\n        clearFocus();\n        post(new Runnable() {\n\n            @Override\n            public void run() {\n                setSelection(position);\n            }\n        });\n        onScrollStateChanged(this, OnScrollListener.SCROLL_STATE_IDLE);\n    }\n\n\n    @Override\n    public void onScroll(\n            AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) {\n        MonthView child = (MonthView) view.getChildAt(0);\n        if (child == null) {\n            return;\n        }\n\n\n        long currScroll = view.getFirstVisiblePosition() * child.getHeight() - child.getBottom();\n        mPreviousScrollPosition = currScroll;\n        mPreviousScrollState = mCurrentScrollState;\n    }\n\n\n    protected void setMonthDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        invalidateViews();\n    }\n\n    @Override\n    public void onScrollStateChanged(AbsListView view, int scrollState) {\n\n\n        mScrollStateChangedRunnable.doScrollStateChange(view, scrollState);\n    }\n\n    protected ScrollStateRunnable mScrollStateChangedRunnable = new ScrollStateRunnable();\n\n    protected class ScrollStateRunnable implements Runnable {\n        private int mNewState;\n\n\n        public void doScrollStateChange(AbsListView view, int scrollState) {\n            mHandler.removeCallbacks(this);\n            mNewState = scrollState;\n            mHandler.postDelayed(this, SCROLL_CHANGE_DELAY);\n        }\n\n        @Override\n        public void run() {\n            mCurrentScrollState = mNewState;\n            if (Log.isLoggable(TAG, Log.DEBUG)) {\n                Log.d(TAG,\n                        \"new scroll state: \" + mNewState + \" old state: \" + mPreviousScrollState);\n            }\n\n            if (mNewState == OnScrollListener.SCROLL_STATE_IDLE\n                    && mPreviousScrollState != OnScrollListener.SCROLL_STATE_IDLE\n                    && mPreviousScrollState != OnScrollListener.SCROLL_STATE_TOUCH_SCROLL) {\n                mPreviousScrollState = mNewState;\n                int i = 0;\n                View child = getChildAt(i);\n                while (child != null && child.getBottom() <= 0) {\n                    child = getChildAt(++i);\n                }\n                if (child == null) {\n\n                    return;\n                }\n                int firstPosition = getFirstVisiblePosition();\n                int lastPosition = getLastVisiblePosition();\n                boolean scroll = firstPosition != 0 && lastPosition != getCount() - 1;\n                final int top = child.getTop();\n                final int bottom = child.getBottom();\n                final int midpoint = getHeight() / 2;\n                if (scroll && top < LIST_TOP_OFFSET) {\n                    if (bottom > midpoint) {\n                        smoothScrollBy(top, GOTO_SCROLL_DURATION);\n                    } else {\n                        smoothScrollBy(bottom, GOTO_SCROLL_DURATION);\n                    }\n                }\n            } else {\n                mPreviousScrollState = mNewState;\n            }\n        }\n    }\n\n\n    public int getMostVisiblePosition() {\n        final int firstPosition = getFirstVisiblePosition();\n        final int height = getHeight();\n\n        int maxDisplayedHeight = 0;\n        int mostVisibleIndex = 0;\n        int i=0;\n        int bottom = 0;\n        while (bottom < height) {\n            View child = getChildAt(i);\n            if (child == null) {\n                break;\n            }\n            bottom = child.getBottom();\n            int displayedHeight = Math.min(bottom, height) - Math.max(0, child.getTop());\n            if (displayedHeight > maxDisplayedHeight) {\n                mostVisibleIndex = i;\n                maxDisplayedHeight = displayedHeight;\n            }\n            i++;\n        }\n        return firstPosition + mostVisibleIndex;\n    }\n\n    @Override\n    public void onDateChanged() {\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    protected void layoutChildren() {\n        final CalendarDay focusedDay = findAccessibilityFocus();\n        super.layoutChildren();\n        if (mPerformingScroll) {\n            mPerformingScroll = false;\n        } else {\n            restoreAccessibilityFocus(focusedDay);\n        }\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getFirstVisiblePosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        mPerformingScroll = true;\n        return true;\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.avro.AvroSchemaVisitor;\nimport com.netflix.iceberg.avro.ValueWriter;\nimport com.netflix.iceberg.avro.ValueWriters;\nimport com.netflix.iceberg.types.Type;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.types.DataType;\nimport java.io.IOException;\nimport java.util.List;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getFieldId;\nimport static com.netflix.iceberg.avro.AvroSchemaVisitor.visit;\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\npublic class SparkAvroWriter implements DatumWriter<InternalRow> {\n  private final com.netflix.iceberg.Schema schema;\n  private ValueWriter<InternalRow> writer = null;\n\n  public SparkAvroWriter(com.netflix.iceberg.Schema schema) {\n    this.schema = schema;\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void setSchema(Schema schema) {\n    this.writer = (ValueWriter<InternalRow>) visit(schema, new WriteBuilder(this.schema));\n  }\n\n  @Override\n  public void write(InternalRow datum, Encoder out) throws IOException {\n    writer.write(datum, out);\n  }\n\n  private static class WriteBuilder extends AvroSchemaVisitor<ValueWriter<?>> {\n    private final com.netflix.iceberg.Schema schema;\n\n    private WriteBuilder(com.netflix.iceberg.Schema schema) {\n      this.schema = schema;\n    }\n\n    @Override\n    public ValueWriter<?> record(Schema record, List<String> names, List<ValueWriter<?>> fields) {\n      List<DataType> types = Lists.newArrayList();\n      for (Schema.Field field : record.getFields()) {\n        types.add(convert(schema.findType(getFieldId(field))));\n      }\n      return SparkValueWriters.struct(fields, types);\n    }\n\n    @Override\n    public ValueWriter<?> union(Schema union, List<ValueWriter<?>> options) {\n      Preconditions.checkArgument(options.contains(ValueWriters.nulls()),\n          \"Cannot create writer for non-option union: \" + union);\n      Preconditions.checkArgument(options.size() == 2,\n          \"Cannot create writer for non-option union: \" + union);\n      if (union.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return ValueWriters.option(0, options.get(1));\n      } else {\n        return ValueWriters.option(1, options.get(0));\n      }\n    }\n\n    @Override\n    public ValueWriter<?> array(Schema array, ValueWriter<?> elementWriter) {\n      LogicalType logical = array.getLogicalType();\n      if (logical != null && \"map\".equals(logical.getName())) {\n        Type keyType = schema.findType(getFieldId(array.getElementType().getField(\"key\")));\n        Type valueType = schema.findType(getFieldId(array.getElementType().getField(\"value\")));\n        ValueWriter<?>[] writers = ((SparkValueWriters.StructWriter) elementWriter).writers;\n        return SparkValueWriters.arrayMap(\n            writers[0], convert(keyType), writers[1], convert(valueType));\n      }\n\n      Type elementType = schema.findType(AvroSchemaUtil.getElementId(array));\n      return SparkValueWriters.array(elementWriter, convert(elementType));\n    }\n\n    @Override\n    public ValueWriter<?> map(Schema map, ValueWriter<?> valueReader) {\n      Type keyType = schema.findType(AvroSchemaUtil.getKeyId(map));\n      Type valueType = schema.findType(AvroSchemaUtil.getValueId(map));\n      return SparkValueWriters.map(\n          SparkValueWriters.strings(), convert(keyType), valueReader, convert(valueType));\n    }\n\n    @Override\n    public ValueWriter<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n\n            return ValueWriters.ints();\n\n          case \"timestamp-micros\":\n\n            return ValueWriters.longs();\n\n          case \"decimal\":\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueWriters.decimal(decimal.getPrecision(), decimal.getScale());\n\n          case \"uuid\":\n            return ValueWriters.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unsupported logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueWriters.nulls();\n        case BOOLEAN:\n          return ValueWriters.booleans();\n        case INT:\n          return ValueWriters.ints();\n        case LONG:\n          return ValueWriters.longs();\n        case FLOAT:\n          return ValueWriters.floats();\n        case DOUBLE:\n          return ValueWriters.doubles();\n        case STRING:\n          return SparkValueWriters.strings();\n        case FIXED:\n          return ValueWriters.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueWriters.bytes();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ApacheThriftTesterUtil.java'",
            "'drift/drift-codec/src/test/java/io/airlift/drift/codec/metadata/TestThriftCatalog.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/metadata/ThriftServiceMetadata.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.inject.BindingAnnotation;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.Scopes;\nimport io.airlift.bootstrap.Bootstrap;\nimport io.airlift.bootstrap.LifeCycleManager;\nimport io.airlift.drift.client.DriftClient;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftResultCode;\nimport io.airlift.drift.integration.scribe.drift.DriftScribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.jmx.testing.TestingJmxModule;\nimport org.weakref.jmx.guice.MBeanModule;\n\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManagerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport static io.airlift.drift.client.guice.DriftClientBinder.driftClientBinder;\nimport static io.airlift.drift.client.guice.MethodInvocationFilterBinder.staticFilterBinder;\nimport static io.airlift.security.pem.PemReader.loadKeyStore;\nimport static io.airlift.security.pem.PemReader.loadTrustStore;\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertSame;\n\nfinal class ClientTestUtils\n{\n    public static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n    public static final List<LogEntry> MESSAGES = ImmutableList.of(\n            new LogEntry(\"hello\", \"world\"),\n            new LogEntry(\"bye\", \"world\"));\n    public static final String HEADER_VALUE = \"header-value\";\n    public static final List<DriftLogEntry> DRIFT_MESSAGES = ImmutableList.copyOf(\n            MESSAGES.stream()\n                    .map(input -> new DriftLogEntry(input.category, input.message))\n                    .collect(Collectors.toList()));\n    public static final DriftResultCode DRIFT_OK = DriftResultCode.OK;\n\n    private ClientTestUtils() {}\n\n    public static int logDriftClientBinder(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            Module transportModule,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n\n        Bootstrap app = new Bootstrap(\n                new MBeanModule(),\n                new TestingJmxModule(),\n                transportModule,\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class, CustomClient.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> binder.bind(ScribeUser.class).in(Scopes.SINGLETON));\n\n        LifeCycleManager lifeCycleManager = null;\n\n        try {\n            app.setRequiredConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"scribe.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.CustomClient.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.thrift.client.protocol\", protocol.toString())\n                    .put(\"scribe.CustomClient.thrift.client.protocol\", protocol.toString())\n                    .build());\n\n\n            app.setOptionalConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.CustomClient.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.CustomClient.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .build());\n\n            Injector injector = app\n                    .doNotInitializeLogging()\n                    .initialize();\n\n            lifeCycleManager = injector.getInstance(LifeCycleManager.class);\n            DriftScribe scribe = injector.getInstance(DriftScribe.class);\n\n            ScribeUser user = injector.getInstance(ScribeUser.class);\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n\n            assertEquals(user.getClient().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getClientCustom().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactory().get().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactoryCustom().get().log(headerValue, entries), DRIFT_OK);\n\n            assertSame(scribe, user.getClient());\n            assertNotSame(user.getClient(), user.getClientCustom());\n            assertNotSame(user.getFactory(), user.getFactoryCustom());\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        finally {\n            if (lifeCycleManager != null) {\n                try {\n                    lifeCycleManager.stop();\n                }\n                catch (Exception ignored) {\n                }\n            }\n        }\n        return 5;\n    }\n\n    public static SSLContext getServerSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        keyManagerFactory.init(loadKeyStore(getPrivateKeyFile(), getPrivateKeyFile(), Optional.empty()), new char[0]);\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static SSLContext getClientSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static File getPrivateKeyFile()\n    {\n        return getResourceFile(\"rsa.key\");\n    }\n\n    public static File getCertificateChainFile()\n    {\n        return getResourceFile(\"rsa.crt\");\n    }\n\n    private static File getResourceFile(String name)\n    {\n        URL resource = TestClientsWithApacheServer.class.getClassLoader().getResource(name);\n        if (resource == null) {\n            throw new IllegalArgumentException(\"Resource not found \" + name);\n        }\n        return new File(resource.getFile());\n    }\n\n    @Target({FIELD, PARAMETER, METHOD})\n    @Retention(RUNTIME)\n    @BindingAnnotation\n    private @interface CustomClient {}\n\n    private static class ScribeUser\n    {\n        @Inject\n        private DriftScribe client;\n\n        @Inject\n        @CustomClient\n        private DriftScribe clientCustom;\n\n        @Inject\n        private DriftClient<DriftScribe> factory;\n\n        @Inject\n        @CustomClient\n        private DriftClient<DriftScribe> factoryCustom;\n\n        public DriftScribe getClient()\n        {\n            return client;\n        }\n\n        public DriftScribe getClientCustom()\n        {\n            return clientCustom;\n        }\n\n        public DriftClient<DriftScribe> getFactory()\n        {\n            return factory;\n        }\n\n        public DriftClient<DriftScribe> getFactoryCustom()\n        {\n            return factoryCustom;\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-codec/src/test/java/io/airlift/drift/codec/metadata/TestThriftCatalog.java'",
            "'drift/drift-codec/src/main/java/io/airlift/drift/codec/metadata/ThriftServiceMetadata.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ApacheThriftTesterUtil.java'"
        ]
    },
    {
        "files": [
            "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'",
            "'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'",
            "'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'"
        ],
        "content": "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'\n:\npackage org.jeasy.flows.work;\n\n\npublic enum WorkStatus {\n\n\n    FAILED,\n\n\n    COMPLETED\n}\n\n'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'\n:\npackage org.jeasy.flows.engine;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.jeasy.flows.work.DefaultWorkReport;\nimport org.jeasy.flows.work.Work;\nimport org.jeasy.flows.work.WorkContext;\nimport org.jeasy.flows.work.WorkReport;\nimport org.jeasy.flows.work.WorkStatus;\nimport org.jeasy.flows.workflow.*;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.jeasy.flows.engine.WorkFlowEngineBuilder.aNewWorkFlowEngine;\nimport static org.jeasy.flows.work.WorkReportPredicate.COMPLETED;\nimport static org.jeasy.flows.workflow.ConditionalFlow.Builder.aNewConditionalFlow;\nimport static org.jeasy.flows.workflow.ParallelFlow.Builder.aNewParallelFlow;\nimport static org.jeasy.flows.workflow.RepeatFlow.Builder.aNewRepeatFlow;\nimport static org.jeasy.flows.workflow.SequentialFlow.Builder.aNewSequentialFlow;\n\npublic class WorkFlowEngineImplTest {\n\n    private final WorkFlowEngine workFlowEngine = new WorkFlowEngineImpl();\n\n    @Test\n    public void run() {\n\n        WorkFlow workFlow = Mockito.mock(WorkFlow.class);\n        WorkContext workContext = Mockito.mock(WorkContext.class);\n\n\n        workFlowEngine.run(workFlow,workContext);\n\n\n        Mockito.verify(workFlow).execute(workContext);\n    }\n\n\n\n    @Test\n    public void composeWorkFlowFromSeparateFlowsAndExecuteIt() {\n\n        PrintMessageWork work1 = new PrintMessageWork(\"foo\");\n        PrintMessageWork work2 = new PrintMessageWork(\"hello\");\n        PrintMessageWork work3 = new PrintMessageWork(\"world\");\n        PrintMessageWork work4 = new PrintMessageWork(\"done\");\n\n        RepeatFlow repeatFlow = aNewRepeatFlow()\n                .named(\"print foo 3 times\")\n                .repeat(work1)\n                .times(3)\n                .build();\n\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        ParallelFlow parallelFlow = aNewParallelFlow()\n                .named(\"print 'hello' and 'world' in parallel\")\n                .execute(work2, work3)\n                .with(executorService)\n                .build();\n\n        ConditionalFlow conditionalFlow = aNewConditionalFlow()\n                .execute(parallelFlow)\n                .when(COMPLETED)\n                .then(work4)\n                .build();\n\n        SequentialFlow sequentialFlow = aNewSequentialFlow()\n                .execute(repeatFlow)\n                .then(conditionalFlow)\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        WorkReport workReport = workFlowEngine.run(sequentialFlow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n        System.out.println(\"workflow report = \" + workReport);\n    }\n\n    @Test\n    public void defineWorkFlowInlineAndExecuteIt() {\n\n        PrintMessageWork work1 = new PrintMessageWork(\"foo\");\n        PrintMessageWork work2 = new PrintMessageWork(\"hello\");\n        PrintMessageWork work3 = new PrintMessageWork(\"world\");\n        PrintMessageWork work4 = new PrintMessageWork(\"done\");\n\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        WorkFlow workflow = aNewSequentialFlow()\n                .execute(aNewRepeatFlow()\n                            .named(\"print foo 3 times\")\n                            .repeat(work1)\n                            .times(3)\n                            .build())\n                .then(aNewConditionalFlow()\n                        .execute(aNewParallelFlow()\n                                    .named(\"print 'hello' and 'world' in parallel\")\n                                    .execute(work2, work3)\n                                    .with(executorService)\n                                    .build())\n                        .when(COMPLETED)\n                        .then(work4)\n                        .build())\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        WorkReport workReport = workFlowEngine.run(workflow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n        System.out.println(\"workflow report = \" + workReport);\n    }\n\n    @Test\n    public void useWorkContextToPassInitialParametersAndShareDataBetweenWorkUnits() {\n        WordCountWork work1 = new WordCountWork(1);\n        WordCountWork work2 = new WordCountWork(2);\n        AggregateWordCountsWork work3 = new AggregateWordCountsWork();\n        PrintWordCount work4 = new PrintWordCount();\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        WorkFlow workflow = aNewSequentialFlow()\n                .execute(aNewParallelFlow()\n                            .execute(work1, work2)\n                            .with(executorService)\n                            .build())\n                .then(work3)\n                .then(work4)\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        workContext.put(\"partition1\", \"hello foo\");\n        workContext.put(\"partition2\", \"hello bar\");\n        WorkReport workReport = workFlowEngine.run(workflow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n    }\n\n    static class PrintMessageWork implements Work {\n\n        private final String message;\n\n        public PrintMessageWork(String message) {\n            this.message = message;\n        }\n\n        public String getName() {\n            return \"print message work\";\n        }\n\n        public WorkReport execute(WorkContext workContext) {\n            System.out.println(message);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n\n    }\n\n    static class WordCountWork implements Work {\n\n        private final int partition;\n\n        public WordCountWork(int partition) {\n            this.partition = partition;\n        }\n\n        @Override\n        public String getName() {\n            return \"count words in a given string\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            String input = (String) workContext.get(\"partition\" + partition);\n            workContext.put(\"wordCountInPartition\" + partition, input.split(\" \").length);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n\n    static class AggregateWordCountsWork implements Work {\n\n        @Override\n        public String getName() {\n            return \"aggregate word counts from partitions\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            Set<Map.Entry<String, Object>> entrySet = workContext.getEntrySet();\n            int sum = 0;\n            for (Map.Entry<String, Object> entry : entrySet) {\n                if (entry.getKey().contains(\"InPartition\")) {\n                    sum += (int) entry.getValue();\n                }\n            }\n            workContext.put(\"totalCount\", sum);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n\n    static class PrintWordCount implements Work {\n\n        @Override\n        public String getName() {\n            return \"print total word count\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            int totalCount = (int) workContext.get(\"totalCount\");\n            System.out.println(totalCount);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n}\n\n'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'\n:\npackage org.jeasy.flows.workflow;\n\nimport org.jeasy.flows.work.Work;\nimport org.jeasy.flows.work.WorkContext;\nimport org.jeasy.flows.work.WorkReport;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.jeasy.flows.work.WorkStatus.FAILED;\n\n\npublic class SequentialFlow extends AbstractWorkFlow {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SequentialFlow.class.getName());\n\n    private final List<Work> workUnits = new ArrayList<>();\n\n    SequentialFlow(String name, List<Work> workUnits) {\n        super(name);\n        this.workUnits.addAll(workUnits);\n    }\n\n\n    public WorkReport execute(WorkContext workContext) {\n        WorkReport workReport = null;\n        for (Work work : workUnits) {\n            workReport = work.execute(workContext);\n            if (workReport != null && FAILED.equals(workReport.getStatus())) {\n                LOGGER.info(\"Work unit ''{}'' has failed, skipping subsequent work units\", work.getName());\n                break;\n            }\n        }\n        return workReport;\n    }\n\n    public static class Builder {\n\n        private Builder() {\n\n        }\n\n        public static NameStep aNewSequentialFlow() {\n            return new BuildSteps();\n        }\n\n        public interface NameStep extends ExecuteStep {\n            ExecuteStep named(String name);\n        }\n\n        public interface ExecuteStep {\n            ThenStep execute(Work initialWork);\n            ThenStep execute(List<Work> initialWorkUnits);\n        }\n\n        public interface ThenStep {\n            ThenStep then(Work nextWork);\n            ThenStep then(List<Work> nextWorkUnits);\n            SequentialFlow build();\n        }\n\n        private static class BuildSteps implements NameStep, ExecuteStep, ThenStep {\n\n            private String name;\n            private final List<Work> works;\n\n            BuildSteps() {\n                this.name = UUID.randomUUID().toString();\n                this.works = new ArrayList<>();\n            }\n\n            public ExecuteStep named(String name) {\n                this.name = name;\n                return this;\n            }\n\n            @Override\n            public ThenStep execute(Work initialWork) {\n                this.works.add(initialWork);\n                return this;\n            }\n\n            @Override\n            public ThenStep execute(List<Work> initialWorkUnits) {\n                this.works.addAll(initialWorkUnits);\n                return this;\n            }\n\n            @Override\n            public ThenStep then(Work nextWork) {\n                this.works.add(nextWork);\n                return this;\n            }\n\n            @Override\n            public ThenStep then(List<Work> nextWorkUnits) {\n                this.works.addAll(nextWorkUnits);\n                return this;\n            }\n\n            @Override\n            public SequentialFlow build() {\n                return new SequentialFlow(this.name, this.works);\n            }\n        }\n    }\n}\n",
        "gt": [
            "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'",
            "'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'",
            "'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'"
        ]
    },
    {
        "files": [
            "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'",
            "'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'",
            "'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'"
        ],
        "content": "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'\n:\npackage org.jeasy.flows.work;\n\n\npublic enum WorkStatus {\n\n\n    FAILED,\n\n\n    COMPLETED\n}\n\n'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'\n:\npackage org.jeasy.flows.engine;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\nimport org.jeasy.flows.work.DefaultWorkReport;\nimport org.jeasy.flows.work.Work;\nimport org.jeasy.flows.work.WorkContext;\nimport org.jeasy.flows.work.WorkReport;\nimport org.jeasy.flows.work.WorkStatus;\nimport org.jeasy.flows.workflow.*;\nimport org.junit.Test;\nimport org.mockito.Mockito;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.jeasy.flows.engine.WorkFlowEngineBuilder.aNewWorkFlowEngine;\nimport static org.jeasy.flows.work.WorkReportPredicate.COMPLETED;\nimport static org.jeasy.flows.workflow.ConditionalFlow.Builder.aNewConditionalFlow;\nimport static org.jeasy.flows.workflow.ParallelFlow.Builder.aNewParallelFlow;\nimport static org.jeasy.flows.workflow.RepeatFlow.Builder.aNewRepeatFlow;\nimport static org.jeasy.flows.workflow.SequentialFlow.Builder.aNewSequentialFlow;\n\npublic class WorkFlowEngineImplTest {\n\n    private final WorkFlowEngine workFlowEngine = new WorkFlowEngineImpl();\n\n    @Test\n    public void run() {\n\n        WorkFlow workFlow = Mockito.mock(WorkFlow.class);\n        WorkContext workContext = Mockito.mock(WorkContext.class);\n\n\n        workFlowEngine.run(workFlow,workContext);\n\n\n        Mockito.verify(workFlow).execute(workContext);\n    }\n\n\n\n    @Test\n    public void composeWorkFlowFromSeparateFlowsAndExecuteIt() {\n\n        PrintMessageWork work1 = new PrintMessageWork(\"foo\");\n        PrintMessageWork work2 = new PrintMessageWork(\"hello\");\n        PrintMessageWork work3 = new PrintMessageWork(\"world\");\n        PrintMessageWork work4 = new PrintMessageWork(\"done\");\n\n        RepeatFlow repeatFlow = aNewRepeatFlow()\n                .named(\"print foo 3 times\")\n                .repeat(work1)\n                .times(3)\n                .build();\n\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        ParallelFlow parallelFlow = aNewParallelFlow()\n                .named(\"print 'hello' and 'world' in parallel\")\n                .execute(work2, work3)\n                .with(executorService)\n                .build();\n\n        ConditionalFlow conditionalFlow = aNewConditionalFlow()\n                .execute(parallelFlow)\n                .when(COMPLETED)\n                .then(work4)\n                .build();\n\n        SequentialFlow sequentialFlow = aNewSequentialFlow()\n                .execute(repeatFlow)\n                .then(conditionalFlow)\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        WorkReport workReport = workFlowEngine.run(sequentialFlow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n        System.out.println(\"workflow report = \" + workReport);\n    }\n\n    @Test\n    public void defineWorkFlowInlineAndExecuteIt() {\n\n        PrintMessageWork work1 = new PrintMessageWork(\"foo\");\n        PrintMessageWork work2 = new PrintMessageWork(\"hello\");\n        PrintMessageWork work3 = new PrintMessageWork(\"world\");\n        PrintMessageWork work4 = new PrintMessageWork(\"done\");\n\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        WorkFlow workflow = aNewSequentialFlow()\n                .execute(aNewRepeatFlow()\n                            .named(\"print foo 3 times\")\n                            .repeat(work1)\n                            .times(3)\n                            .build())\n                .then(aNewConditionalFlow()\n                        .execute(aNewParallelFlow()\n                                    .named(\"print 'hello' and 'world' in parallel\")\n                                    .execute(work2, work3)\n                                    .with(executorService)\n                                    .build())\n                        .when(COMPLETED)\n                        .then(work4)\n                        .build())\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        WorkReport workReport = workFlowEngine.run(workflow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n        System.out.println(\"workflow report = \" + workReport);\n    }\n\n    @Test\n    public void useWorkContextToPassInitialParametersAndShareDataBetweenWorkUnits() {\n        WordCountWork work1 = new WordCountWork(1);\n        WordCountWork work2 = new WordCountWork(2);\n        AggregateWordCountsWork work3 = new AggregateWordCountsWork();\n        PrintWordCount work4 = new PrintWordCount();\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        WorkFlow workflow = aNewSequentialFlow()\n                .execute(aNewParallelFlow()\n                            .execute(work1, work2)\n                            .with(executorService)\n                            .build())\n                .then(work3)\n                .then(work4)\n                .build();\n\n        WorkFlowEngine workFlowEngine = aNewWorkFlowEngine().build();\n        WorkContext workContext = new WorkContext();\n        workContext.put(\"partition1\", \"hello foo\");\n        workContext.put(\"partition2\", \"hello bar\");\n        WorkReport workReport = workFlowEngine.run(workflow, workContext);\n        executorService.shutdown();\n        assertThat(workReport.getStatus()).isEqualTo(WorkStatus.COMPLETED);\n    }\n\n    static class PrintMessageWork implements Work {\n\n        private final String message;\n\n        public PrintMessageWork(String message) {\n            this.message = message;\n        }\n\n        public String getName() {\n            return \"print message work\";\n        }\n\n        public WorkReport execute(WorkContext workContext) {\n            System.out.println(message);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n\n    }\n\n    static class WordCountWork implements Work {\n\n        private final int partition;\n\n        public WordCountWork(int partition) {\n            this.partition = partition;\n        }\n\n        @Override\n        public String getName() {\n            return \"count words in a given string\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            String input = (String) workContext.get(\"partition\" + partition);\n            workContext.put(\"wordCountInPartition\" + partition, input.split(\" \").length);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n\n    static class AggregateWordCountsWork implements Work {\n\n        @Override\n        public String getName() {\n            return \"aggregate word counts from partitions\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            Set<Map.Entry<String, Object>> entrySet = workContext.getEntrySet();\n            int sum = 0;\n            for (Map.Entry<String, Object> entry : entrySet) {\n                if (entry.getKey().contains(\"InPartition\")) {\n                    sum += (int) entry.getValue();\n                }\n            }\n            workContext.put(\"totalCount\", sum);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n\n    static class PrintWordCount implements Work {\n\n        @Override\n        public String getName() {\n            return \"print total word count\";\n        }\n\n        @Override\n        public WorkReport execute(WorkContext workContext) {\n            int totalCount = (int) workContext.get(\"totalCount\");\n            System.out.println(totalCount);\n            return new DefaultWorkReport(WorkStatus.COMPLETED, workContext);\n        }\n    }\n}\n\n'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'\n:\npackage org.jeasy.flows.workflow;\n\nimport org.jeasy.flows.work.Work;\nimport org.jeasy.flows.work.WorkContext;\nimport org.jeasy.flows.work.WorkReport;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.jeasy.flows.work.WorkStatus.FAILED;\n\n\npublic class SequentialFlow extends AbstractWorkFlow {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(SequentialFlow.class.getName());\n\n    private final List<Work> workUnits = new ArrayList<>();\n\n    SequentialFlow(String name, List<Work> workUnits) {\n        super(name);\n        this.workUnits.addAll(workUnits);\n    }\n\n\n    public WorkReport execute(WorkContext workContext) {\n        WorkReport workReport = null;\n        for (Work work : workUnits) {\n            workReport = work.execute(workContext);\n            if (workReport != null && FAILED.equals(workReport.getStatus())) {\n                LOGGER.info(\"Work unit ''{}'' has failed, skipping subsequent work units\", work.getName());\n                break;\n            }\n        }\n        return workReport;\n    }\n\n    public static class Builder {\n\n        private Builder() {\n\n        }\n\n        public static NameStep aNewSequentialFlow() {\n            return new BuildSteps();\n        }\n\n        public interface NameStep extends ExecuteStep {\n            ExecuteStep named(String name);\n        }\n\n        public interface ExecuteStep {\n            ThenStep execute(Work initialWork);\n            ThenStep execute(List<Work> initialWorkUnits);\n        }\n\n        public interface ThenStep {\n            ThenStep then(Work nextWork);\n            ThenStep then(List<Work> nextWorkUnits);\n            SequentialFlow build();\n        }\n\n        private static class BuildSteps implements NameStep, ExecuteStep, ThenStep {\n\n            private String name;\n            private final List<Work> works;\n\n            BuildSteps() {\n                this.name = UUID.randomUUID().toString();\n                this.works = new ArrayList<>();\n            }\n\n            public ExecuteStep named(String name) {\n                this.name = name;\n                return this;\n            }\n\n            @Override\n            public ThenStep execute(Work initialWork) {\n                this.works.add(initialWork);\n                return this;\n            }\n\n            @Override\n            public ThenStep execute(List<Work> initialWorkUnits) {\n                this.works.addAll(initialWorkUnits);\n                return this;\n            }\n\n            @Override\n            public ThenStep then(Work nextWork) {\n                this.works.add(nextWork);\n                return this;\n            }\n\n            @Override\n            public ThenStep then(List<Work> nextWorkUnits) {\n                this.works.addAll(nextWorkUnits);\n                return this;\n            }\n\n            @Override\n            public SequentialFlow build() {\n                return new SequentialFlow(this.name, this.works);\n            }\n        }\n    }\n}\n",
        "gt": [
            "'easy-flows/src/main/java/org/jeasy/flows/work/WorkStatus.java'",
            "'easy-flows/src/main/java/org/jeasy/flows/workflow/SequentialFlow.java'",
            "'easy-flows/src/test/java/org/jeasy/flows/engine/WorkFlowEngineImplTest.java'"
        ]
    },
    {
        "files": [
            "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'",
            "'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'"
        ],
        "content": "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'\n:\npackage org.intellij.jflex.psi;\n\nimport com.intellij.psi.tree.IElementType;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.lang.ASTNode;\nimport org.intellij.jflex.psi.impl.*;\nimport com.intellij.psi.impl.source.tree.CompositePsiElement;\n\npublic interface JFlexTypes {\n\n  IElementType FLEX_CHAR_RANGE = new JFlexCompositeElementType(\"FLEX_CHAR_RANGE\");\n  IElementType FLEX_CHOICE_EXPRESSION = new JFlexCompositeElementType(\"FLEX_CHOICE_EXPRESSION\");\n  IElementType FLEX_CLASS_EXPRESSION = new JFlexCompositeElementType(\"FLEX_CLASS_EXPRESSION\");\n  IElementType FLEX_DECLARATIONS_SECTION = new JFlexCompositeElementType(\"FLEX_DECLARATIONS_SECTION\");\n  IElementType FLEX_EXPRESSION = new JFlexCompositeElementType(\"FLEX_EXPRESSION\");\n  IElementType FLEX_JAVA_CODE = new JFlexCompositeElementType(\"FLEX_JAVA_CODE\");\n  IElementType FLEX_JAVA_NAME = new JFlexCompositeElementType(\"FLEX_JAVA_NAME\");\n  IElementType FLEX_JAVA_TYPE = new JFlexCompositeElementType(\"FLEX_JAVA_TYPE\");\n  IElementType FLEX_JAVA_TYPE_PARAMETERS = new JFlexCompositeElementType(\"FLEX_JAVA_TYPE_PARAMETERS\");\n  IElementType FLEX_LEXICAL_RULES_SECTION = new JFlexCompositeElementType(\"FLEX_LEXICAL_RULES_SECTION\");\n  IElementType FLEX_LITERAL_EXPRESSION = new JFlexCompositeElementType(\"FLEX_LITERAL_EXPRESSION\");\n  IElementType FLEX_LOOK_AHEAD = new JFlexCompositeElementType(\"FLEX_LOOK_AHEAD\");\n  IElementType FLEX_MACRO_DEFINITION = new JFlexCompositeElementType(\"FLEX_MACRO_DEFINITION\");\n  IElementType FLEX_MACRO_REFERENCE = new JFlexCompositeElementType(\"FLEX_MACRO_REFERENCE\");\n  IElementType FLEX_MACRO_REF_EXPRESSION = new JFlexCompositeElementType(\"FLEX_MACRO_REF_EXPRESSION\");\n  IElementType FLEX_NOT_EXPRESSION = new JFlexCompositeElementType(\"FLEX_NOT_EXPRESSION\");\n  IElementType FLEX_OPTION = new JFlexCompositeElementType(\"FLEX_OPTION\");\n  IElementType FLEX_PAREN_EXPRESSION = new JFlexCompositeElementType(\"FLEX_PAREN_EXPRESSION\");\n  IElementType FLEX_PREDEFINED_CLASS_EXPRESSION = new JFlexCompositeElementType(\"FLEX_PREDEFINED_CLASS_EXPRESSION\");\n  IElementType FLEX_QUANTIFIER_EXPRESSION = new JFlexCompositeElementType(\"FLEX_QUANTIFIER_EXPRESSION\");\n  IElementType FLEX_RULE = new JFlexCompositeElementType(\"FLEX_RULE\");\n  IElementType FLEX_SEQUENCE_EXPRESSION = new JFlexCompositeElementType(\"FLEX_SEQUENCE_EXPRESSION\");\n  IElementType FLEX_STATE_DECLARATION = new JFlexCompositeElementType(\"FLEX_STATE_DECLARATION\");\n  IElementType FLEX_STATE_DEFINITION = new JFlexCompositeElementType(\"FLEX_STATE_DEFINITION\");\n  IElementType FLEX_STATE_LIST = new JFlexCompositeElementType(\"FLEX_STATE_LIST\");\n  IElementType FLEX_STATE_REFERENCE = new JFlexCompositeElementType(\"FLEX_STATE_REFERENCE\");\n  IElementType FLEX_USER_CODE_SECTION = new JFlexCompositeElementType(\"FLEX_USER_CODE_SECTION\");\n  IElementType FLEX_USER_VALUE = new JFlexCompositeElementType(\"FLEX_USER_VALUE\");\n\n  IElementType FLEX_AMPAMP = new JFlexTokenType(\"&&\");\n  IElementType FLEX_ANGLE1 = new JFlexTokenType(\"<\");\n  IElementType FLEX_ANGLE2 = new JFlexTokenType(\">\");\n  IElementType FLEX_BANG = new JFlexTokenType(\"!\");\n  IElementType FLEX_BAR = new JFlexTokenType(\"|\");\n  IElementType FLEX_BARBAR = new JFlexTokenType(\"||\");\n  IElementType FLEX_BLOCK_COMMENT = new JFlexTokenType(\"block_comment\");\n  IElementType FLEX_BRACE1 = new JFlexTokenType(\"{\");\n  IElementType FLEX_BRACE2 = new JFlexTokenType(\"}\");\n  IElementType FLEX_BRACK1 = new JFlexTokenType(\"[\");\n  IElementType FLEX_BRACK2 = new JFlexTokenType(\"]\");\n  IElementType FLEX_CHAR = new JFlexTokenType(\"char\");\n  IElementType FLEX_CHAR_CLASS = new JFlexTokenType(\"char_class\");\n  IElementType FLEX_CHAR_ESC = new JFlexTokenType(\"char_esc\");\n  IElementType FLEX_COMMA = new JFlexTokenType(\",\");\n  IElementType FLEX_DASH = new JFlexTokenType(\"-\");\n  IElementType FLEX_DASHDASH = new JFlexTokenType(\"--\");\n  IElementType FLEX_DOLLAR = new JFlexTokenType(\"$\");\n  IElementType FLEX_DOT = new JFlexTokenType(\".\");\n  IElementType FLEX_EOF = new JFlexTokenType(\"<<EOF>>\");\n  IElementType FLEX_EQ = new JFlexTokenType(\"=\");\n  IElementType FLEX_FSLASH = new JFlexTokenType(\"/\");\n  IElementType FLEX_HAT = new JFlexTokenType(\"^\");\n  IElementType FLEX_ID = new JFlexTokenType(\"id\");\n  IElementType FLEX_LINE_COMMENT = new JFlexTokenType(\"line_comment\");\n  IElementType FLEX_NUMBER = new JFlexTokenType(\"number\");\n  IElementType FLEX_OPT16BIT = new JFlexTokenType(\"%16bit\");\n  IElementType FLEX_OPT_7BIT = new JFlexTokenType(\"%7bit\");\n  IElementType FLEX_OPT_8BIT = new JFlexTokenType(\"%8bit\");\n  IElementType FLEX_OPT_ABSTRACT = new JFlexTokenType(\"%abstract\");\n  IElementType FLEX_OPT_APIPRIVATE = new JFlexTokenType(\"%apiprivate\");\n  IElementType FLEX_OPT_BUFFER = new JFlexTokenType(\"%buffer\");\n  IElementType FLEX_OPT_CASELESS = new JFlexTokenType(\"%caseless\");\n  IElementType FLEX_OPT_CHAR = new JFlexTokenType(\"%char\");\n  IElementType FLEX_OPT_CLASS = new JFlexTokenType(\"%class\");\n  IElementType FLEX_OPT_CODE1 = new JFlexTokenType(\"%{\");\n  IElementType FLEX_OPT_CODE2 = new JFlexTokenType(\"%}\");\n  IElementType FLEX_OPT_COLUMN = new JFlexTokenType(\"%column\");\n  IElementType FLEX_OPT_CTORARG = new JFlexTokenType(\"%ctorarg\");\n  IElementType FLEX_OPT_CUP = new JFlexTokenType(\"%cup\");\n  IElementType FLEX_OPT_CUPDEBUG = new JFlexTokenType(\"%cupdebug\");\n  IElementType FLEX_OPT_CUPSYM = new JFlexTokenType(\"%cupsym\");\n  IElementType FLEX_OPT_DEBUG = new JFlexTokenType(\"%debug\");\n  IElementType FLEX_OPT_EOF1 = new JFlexTokenType(\"%eof{\");\n  IElementType FLEX_OPT_EOF2 = new JFlexTokenType(\"%eof}\");\n  IElementType FLEX_OPT_EOFCLOSE = new JFlexTokenType(\"%eofclose\");\n  IElementType FLEX_OPT_EOFTHROW = new JFlexTokenType(\"%eofthrow\");\n  IElementType FLEX_OPT_EOFTHROW1 = new JFlexTokenType(\"%eofthrow{\");\n  IElementType FLEX_OPT_EOFTHROW2 = new JFlexTokenType(\"%eofthrow}\");\n  IElementType FLEX_OPT_EOFVAL1 = new JFlexTokenType(\"%eofval{\");\n  IElementType FLEX_OPT_EOFVAL2 = new JFlexTokenType(\"%eofval}\");\n  IElementType FLEX_OPT_EXTENDS = new JFlexTokenType(\"%extends\");\n  IElementType FLEX_OPT_FINAL = new JFlexTokenType(\"%final\");\n  IElementType FLEX_OPT_FULL = new JFlexTokenType(\"%full\");\n  IElementType FLEX_OPT_FUNCTION = new JFlexTokenType(\"%function\");\n  IElementType FLEX_OPT_IGNORECASE = new JFlexTokenType(\"%ignorecase\");\n  IElementType FLEX_OPT_IMPLEMENTS = new JFlexTokenType(\"%implements\");\n  IElementType FLEX_OPT_INCLUDE = new JFlexTokenType(\"%include\");\n  IElementType FLEX_OPT_INIT1 = new JFlexTokenType(\"%init{\");\n  IElementType FLEX_OPT_INIT2 = new JFlexTokenType(\"%init}\");\n  IElementType FLEX_OPT_INITTHROW = new JFlexTokenType(\"%initthrow\");\n  IElementType FLEX_OPT_INITTHROW1 = new JFlexTokenType(\"%initthrow{\");\n  IElementType FLEX_OPT_INITTHROW2 = new JFlexTokenType(\"%initthrow}\");\n  IElementType FLEX_OPT_INT = new JFlexTokenType(\"%int\");\n  IElementType FLEX_OPT_INTEGER = new JFlexTokenType(\"%integer\");\n  IElementType FLEX_OPT_INTWRAP = new JFlexTokenType(\"%intwrap\");\n  IElementType FLEX_OPT_LINE = new JFlexTokenType(\"%line\");\n  IElementType FLEX_OPT_NOTUNIX = new JFlexTokenType(\"%notunix\");\n  IElementType FLEX_OPT_PUBLIC = new JFlexTokenType(\"%public\");\n  IElementType FLEX_OPT_SCANERROR = new JFlexTokenType(\"%scanerror\");\n  IElementType FLEX_OPT_STANDALONE = new JFlexTokenType(\"%standalone\");\n  IElementType FLEX_OPT_STATE = new JFlexTokenType(\"%state\");\n  IElementType FLEX_OPT_TYPE = new JFlexTokenType(\"%type\");\n  IElementType FLEX_OPT_UNICODE = new JFlexTokenType(\"%unicode\");\n  IElementType FLEX_OPT_XSTATE = new JFlexTokenType(\"%xstate\");\n  IElementType FLEX_OPT_YYEOF = new JFlexTokenType(\"%yyeof\");\n  IElementType FLEX_OPT_YYLEXTHROW = new JFlexTokenType(\"%yylexthrow\");\n  IElementType FLEX_OPT_YYLEXTHROW1 = new JFlexTokenType(\"%yylexthrow{\");\n  IElementType FLEX_OPT_YYLEXTHROW2 = new JFlexTokenType(\"%yylexthrow}\");\n  IElementType FLEX_PAREN1 = new JFlexTokenType(\"(\");\n  IElementType FLEX_PAREN2 = new JFlexTokenType(\")\");\n  IElementType FLEX_PLUS = new JFlexTokenType(\"+\");\n  IElementType FLEX_QUESTION = new JFlexTokenType(\"?\");\n  IElementType FLEX_RAW = new JFlexTokenType(\"code block\");\n  IElementType FLEX_STAR = new JFlexTokenType(\"*\");\n  IElementType FLEX_STRING = new JFlexTokenType(\"string\");\n  IElementType FLEX_TILDE = new JFlexTokenType(\"~\");\n  IElementType FLEX_TILDETILDE = new JFlexTokenType(\"~~\");\n  IElementType FLEX_TWO_PERCS = new JFlexTokenType(\"%%\");\n  IElementType FLEX_UNCLOSED = new JFlexTokenType(\"unclosed\");\n  IElementType FLEX_VERSION = new JFlexTokenType(\"version\");\n\n  class Factory {\n    public static CompositePsiElement createElement(IElementType type) {\n       if (type == FLEX_CHAR_RANGE) {\n        return new JFlexCharRangeImpl(type);\n      }\n      else if (type == FLEX_CHOICE_EXPRESSION) {\n        return new JFlexChoiceExpressionImpl(type);\n      }\n      else if (type == FLEX_CLASS_EXPRESSION) {\n        return new JFlexClassExpressionImpl(type);\n      }\n      else if (type == FLEX_DECLARATIONS_SECTION) {\n        return new JFlexDeclarationsSectionImpl(type);\n      }\n      else if (type == FLEX_JAVA_CODE) {\n        return new JFlexJavaCodeImpl(type);\n      }\n      else if (type == FLEX_JAVA_NAME) {\n        return new JFlexJavaNameImpl(type);\n      }\n      else if (type == FLEX_JAVA_TYPE) {\n        return new JFlexJavaTypeImpl(type);\n      }\n      else if (type == FLEX_JAVA_TYPE_PARAMETERS) {\n        return new JFlexJavaTypeParametersImpl(type);\n      }\n      else if (type == FLEX_LEXICAL_RULES_SECTION) {\n        return new JFlexLexicalRulesSectionImpl(type);\n      }\n      else if (type == FLEX_LITERAL_EXPRESSION) {\n        return new JFlexLiteralExpressionImpl(type);\n      }\n      else if (type == FLEX_LOOK_AHEAD) {\n        return new JFlexLookAheadImpl(type);\n      }\n      else if (type == FLEX_MACRO_DEFINITION) {\n        return new JFlexMacroDefinitionImpl(type);\n      }\n      else if (type == FLEX_MACRO_REFERENCE) {\n        return new JFlexMacroReferenceImpl(type);\n      }\n      else if (type == FLEX_MACRO_REF_EXPRESSION) {\n        return new JFlexMacroRefExpressionImpl(type);\n      }\n      else if (type == FLEX_NOT_EXPRESSION) {\n        return new JFlexNotExpressionImpl(type);\n      }\n      else if (type == FLEX_OPTION) {\n        return new JFlexOptionImpl(type);\n      }\n      else if (type == FLEX_PAREN_EXPRESSION) {\n        return new JFlexParenExpressionImpl(type);\n      }\n      else if (type == FLEX_PREDEFINED_CLASS_EXPRESSION) {\n        return new JFlexPredefinedClassExpressionImpl(type);\n      }\n      else if (type == FLEX_QUANTIFIER_EXPRESSION) {\n        return new JFlexQuantifierExpressionImpl(type);\n      }\n      else if (type == FLEX_RULE) {\n        return new JFlexRuleImpl(type);\n      }\n      else if (type == FLEX_SEQUENCE_EXPRESSION) {\n        return new JFlexSequenceExpressionImpl(type);\n      }\n      else if (type == FLEX_STATE_DECLARATION) {\n        return new JFlexStateDeclarationImpl(type);\n      }\n      else if (type == FLEX_STATE_DEFINITION) {\n        return new JFlexStateDefinitionImpl(type);\n      }\n      else if (type == FLEX_STATE_LIST) {\n        return new JFlexStateListImpl(type);\n      }\n      else if (type == FLEX_STATE_REFERENCE) {\n        return new JFlexStateReferenceImpl(type);\n      }\n      else if (type == FLEX_USER_CODE_SECTION) {\n        return new JFlexUserCodeSectionImpl(type);\n      }\n      else if (type == FLEX_USER_VALUE) {\n        return new JFlexUserValueImpl(type);\n      }\n      throw new AssertionError(\"Unknown element type: \" + type);\n    }\n  }\n}\n",
        "gt": [
            "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'",
            "'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/ssl/SslContextFactory.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/ConnectionManager.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'"
        ],
        "content": "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/ssl/SslContextFactory.java'\n:\npackage io.airlift.drift.transport.netty.ssl;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.util.concurrent.ExecutionError;\nimport com.google.common.util.concurrent.UncheckedExecutionException;\nimport io.airlift.units.Duration;\n\nimport java.io.File;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\npublic class SslContextFactory\n{\n    private final LoadingCache<SslContextParameters, ReloadableSslContext> cache;\n\n    public static SslContextFactory createSslContextFactory(boolean forClient, Duration refreshTime, ScheduledExecutorService scheduledExecutor)\n    {\n        SslContextFactory sslContextFactory = new SslContextFactory(forClient);\n        scheduledExecutor.scheduleWithFixedDelay(sslContextFactory::refresh, refreshTime.toMillis(), refreshTime.toMillis(), MILLISECONDS);\n        return sslContextFactory;\n    }\n\n    private SslContextFactory(boolean forClient)\n    {\n        this.cache = CacheBuilder.newBuilder()\n                .expireAfterAccess(1, TimeUnit.HOURS)\n                .build(CacheLoader.from(key ->\n                        new ReloadableSslContext(\n                                forClient,\n                                key.getTrustCertificatesFile(),\n                                key.getClientCertificatesFile(),\n                                key.getPrivateKeyFile(),\n                                key.getPrivateKeyPassword(),\n                                key.getSessionCacheSize(),\n                                key.getSessionTimeout(),\n                                key.getCiphers())));\n    }\n\n    public ReloadableSslContext get(\n            File trustCertificatesFile,\n            Optional<File> clientCertificatesFile,\n            Optional<File> privateKeyFile,\n            Optional<String> privateKeyPassword,\n            long sessionCacheSize,\n            Duration sessionTimeout,\n            List<String> ciphers)\n    {\n        return get(new SslContextParameters(\n                trustCertificatesFile,\n                clientCertificatesFile,\n                privateKeyFile,\n                privateKeyPassword,\n                sessionCacheSize,\n                sessionTimeout,\n                ciphers));\n    }\n\n    public ReloadableSslContext get(SslContextParameters sslContextParameters)\n    {\n        try {\n            return cache.getUnchecked(sslContextParameters);\n        }\n        catch (UncheckedExecutionException | ExecutionError e) {\n            throw new RuntimeException(\"Error initializing SSL context\", e.getCause());\n        }\n    }\n\n    private void refresh()\n    {\n        cache.asMap().values().forEach(ReloadableSslContext::reload);\n    }\n\n    public static class SslContextParameters\n    {\n        private final File trustCertificatesFile;\n        private final Optional<File> clientCertificatesFile;\n        private final Optional<File> privateKeyFile;\n        private final Optional<String> privateKeyPassword;\n\n        private final long sessionCacheSize;\n        private final Duration sessionTimeout;\n        private final List<String> ciphers;\n\n        public SslContextParameters(\n                File trustCertificatesFile,\n                Optional<File> clientCertificatesFile,\n                Optional<File> privateKeyFile,\n                Optional<String> privateKeyPassword,\n                long sessionCacheSize,\n                Duration sessionTimeout, List<String> ciphers)\n        {\n            this.trustCertificatesFile = requireNonNull(trustCertificatesFile, \"trustCertificatesFile is null\");\n            this.clientCertificatesFile = requireNonNull(clientCertificatesFile, \"clientCertificatesFile is null\");\n            this.privateKeyFile = requireNonNull(privateKeyFile, \"privateKeyFile is null\");\n            this.privateKeyPassword = requireNonNull(privateKeyPassword, \"privateKeyPassword is null\");\n            this.sessionCacheSize = sessionCacheSize;\n            this.sessionTimeout = requireNonNull(sessionTimeout, \"sessionTimeout is null\");\n            this.ciphers = ImmutableList.copyOf(requireNonNull(ciphers, \"ciphers is null\"));\n        }\n\n        public File getTrustCertificatesFile()\n        {\n            return trustCertificatesFile;\n        }\n\n        public Optional<File> getClientCertificatesFile()\n        {\n            return clientCertificatesFile;\n        }\n\n        public Optional<File> getPrivateKeyFile()\n        {\n            return privateKeyFile;\n        }\n\n        public Optional<String> getPrivateKeyPassword()\n        {\n            return privateKeyPassword;\n        }\n\n        public long getSessionCacheSize()\n        {\n            return sessionCacheSize;\n        }\n\n        public Duration getSessionTimeout()\n        {\n            return sessionTimeout;\n        }\n\n        public List<String> getCiphers()\n        {\n            return ciphers;\n        }\n\n        @Override\n        public boolean equals(Object o)\n        {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n            SslContextParameters that = (SslContextParameters) o;\n            return sessionCacheSize == that.sessionCacheSize &&\n                    Objects.equals(trustCertificatesFile, that.trustCertificatesFile) &&\n                    Objects.equals(clientCertificatesFile, that.clientCertificatesFile) &&\n                    Objects.equals(privateKeyFile, that.privateKeyFile) &&\n                    Objects.equals(privateKeyPassword, that.privateKeyPassword) &&\n                    Objects.equals(sessionTimeout, that.sessionTimeout) &&\n                    Objects.equals(ciphers, that.ciphers);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return Objects.hash(trustCertificatesFile, clientCertificatesFile, privateKeyFile, privateKeyPassword, sessionCacheSize, sessionTimeout, ciphers);\n        }\n    }\n}\n\n'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.DriftClientFactory;\nimport io.airlift.drift.client.DriftClientFactoryManager;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.integration.scribe.drift.DriftAsyncScribe;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftScribe;\nimport io.airlift.drift.transport.client.DriftClientConfig;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.client.DriftNettyClientConfig;\nimport io.airlift.drift.transport.netty.client.DriftNettyClientModule;\nimport io.airlift.drift.transport.netty.client.DriftNettyConnectionFactoryConfig;\nimport io.airlift.drift.transport.netty.client.DriftNettyMethodInvokerFactory;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.ToIntFunction;\n\nimport static io.airlift.drift.client.ExceptionClassifier.NORMAL_RESULT;\nimport static io.airlift.drift.integration.ClientTestUtils.CODEC_MANAGER;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_MESSAGES;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_OK;\nimport static io.airlift.drift.integration.ClientTestUtils.HEADER_VALUE;\nimport static io.airlift.drift.integration.ClientTestUtils.logDriftClientBinder;\nimport static io.airlift.drift.transport.netty.client.DriftNettyMethodInvokerFactory.createStaticDriftNettyMethodInvokerFactory;\nimport static io.airlift.drift.transport.netty.codec.Protocol.COMPACT;\nimport static io.airlift.drift.transport.netty.codec.Transport.HEADER;\nimport static org.testng.Assert.assertEquals;\n\nfinal class DriftNettyTesterUtil\n{\n    private DriftNettyTesterUtil() {}\n\n    public static List<ToIntFunction<HostAndPort>> driftNettyTestClients(List<MethodInvocationFilter> filters, Transport transport, Protocol protocol, boolean secure)\n    {\n        return ImmutableList.of(\n                address -> logNettyDriftClient(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyStaticDriftClient(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyDriftClientAsync(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyClientBinder(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure));\n    }\n\n    private static int logNettyDriftClient(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<String> methodInvokerFactory = new DriftNettyMethodInvokerFactory<>(\n                        new DriftNettyConnectionFactoryConfig(),\n                        clientIdentity -> config,\n                        testingAllocator)) {\n            DriftClientFactoryManager<String> clientFactoryManager = new DriftClientFactoryManager<>(CODEC_MANAGER, methodInvokerFactory);\n            DriftClientFactory proxyFactory = clientFactoryManager.createDriftClientFactory(\"clientIdentity\", addressSelector, NORMAL_RESULT);\n\n            DriftScribe scribe = proxyFactory.createDriftClient(DriftScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyStaticDriftClient(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<?> methodInvokerFactory = createStaticDriftNettyMethodInvokerFactory(config, testingAllocator)) {\n            DriftClientFactory proxyFactory = new DriftClientFactory(CODEC_MANAGER, methodInvokerFactory, addressSelector);\n\n            DriftScribe scribe = proxyFactory.createDriftClient(DriftScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyDriftClientAsync(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<String> methodInvokerFactory = new DriftNettyMethodInvokerFactory<>(\n                        new DriftNettyConnectionFactoryConfig(),\n                        clientIdentity -> config,\n                        testingAllocator)) {\n            DriftClientFactoryManager<String> proxyFactoryManager = new DriftClientFactoryManager<>(CODEC_MANAGER, methodInvokerFactory);\n            DriftClientFactory proxyFactory = proxyFactoryManager.createDriftClientFactory(\"myFactory\", addressSelector, NORMAL_RESULT);\n\n            DriftAsyncScribe scribe = proxyFactory.createDriftClient(DriftAsyncScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries).get(), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyClientBinder(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator()) {\n            return logDriftClientBinder(address, headerValue, entries, new DriftNettyClientModule(testingAllocator), filters, transport, protocol, secure);\n        }\n    }\n\n    private static boolean isValidConfiguration(Transport transport, Protocol protocol)\n    {\n\n        return transport != HEADER || protocol != COMPACT;\n    }\n}\n",
        "gt": [
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/ssl/SslContextFactory.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/ConnectionManager.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'"
        ]
    },
    {
        "files": [
            "'PowerTutor/src/edu/umich/PowerTutor/phone/PhoneSelector.java'",
            "'PowerTutor/src/edu/umich/PowerTutor/components/Audio.java'",
            "'PowerTutor/src/edu/umich/PowerTutor/components/Sensors.java'"
        ],
        "content": "'PowerTutor/src/edu/umich/PowerTutor/phone/PhoneSelector.java'\n:\n\npackage edu.umich.PowerTutor.phone;\n\nimport java.util.List;\n\nimport android.content.Context;\nimport android.os.Build;\nimport android.util.Log;\nimport edu.umich.PowerTutor.components.Audio;\nimport edu.umich.PowerTutor.components.CPU;\nimport edu.umich.PowerTutor.components.GPS;\nimport edu.umich.PowerTutor.components.LCD;\nimport edu.umich.PowerTutor.components.OLED;\nimport edu.umich.PowerTutor.components.PowerComponent;\nimport edu.umich.PowerTutor.components.Sensors;\nimport edu.umich.PowerTutor.components.Threeg;\nimport edu.umich.PowerTutor.components.Wifi;\nimport edu.umich.PowerTutor.components.Audio.AudioData;\nimport edu.umich.PowerTutor.components.CPU.CpuData;\nimport edu.umich.PowerTutor.components.GPS.GpsData;\nimport edu.umich.PowerTutor.components.LCD.LcdData;\nimport edu.umich.PowerTutor.components.OLED.OledData;\nimport edu.umich.PowerTutor.components.Sensors.SensorData;\nimport edu.umich.PowerTutor.components.Threeg.ThreegData;\nimport edu.umich.PowerTutor.components.Wifi.WifiData;\nimport edu.umich.PowerTutor.service.PowerData;\nimport edu.umich.PowerTutor.util.NotificationService;\nimport edu.umich.PowerTutor.util.SystemInfo;\n\npublic class PhoneSelector {\n  private static final String TAG = \"PhoneSelector\";\n\n  public static final int PHONE_UNKNOWN = 0;\n  public static final int PHONE_DREAM = 1;\n  public static final int PHONE_SAPPHIRE = 2;\n  public static final int PHONE_PASSION = 3;\n\n\n  public static final String[] OLED_PHONES = {\n    \"bravo\",\n    \"passion\",\n    \"GT-I9000\",\n    \"inc\",\n    \"legend\",\n    \"GT-I7500\",\n    \"SPH-M900\",\n    \"SGH-I897\",\n    \"SGH-T959\",\n    \"desirec\",\n  };\n\n\n\n  private PhoneSelector() {}\n\n  public static boolean phoneSupported() {\n    return getPhoneType() != PHONE_UNKNOWN;\n  }\n\n  public static boolean hasOled() {\n    for(int i = 0; i < OLED_PHONES.length; i++) {\n      if(Build.DEVICE.equals(OLED_PHONES[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public static int getPhoneType() {\n    if(Build.DEVICE.startsWith(\"dream\")) return PHONE_DREAM;\n    if(Build.DEVICE.startsWith(\"sapphire\")) return PHONE_SAPPHIRE;\n    if(Build.DEVICE.startsWith(\"passion\")) return PHONE_PASSION;\n    return PHONE_UNKNOWN;\n  }\n\n  public static PhoneConstants getConstants(Context context) {\n    switch(getPhoneType()) {\n      case PHONE_DREAM:\n        return new DreamConstants(context);\n      case PHONE_SAPPHIRE:\n        return new SapphireConstants(context);\n      case PHONE_PASSION:\n        return new PassionConstants(context);\n      default:\n        boolean oled = hasOled();\n        Log.w(TAG, \"Phone type not recognized (\" + Build.DEVICE + \"), using \" +\n              (oled ? \"Passion\" : \"Dream\") + \" constants\");\n        return oled ? new PassionConstants(context) :\n                      new DreamConstants(context);\n    }\n  }\n\n  public static PhonePowerCalculator getCalculator(Context context) {\n    switch(getPhoneType()) {\n      case PHONE_DREAM:\n        return new DreamPowerCalculator(context);\n      case PHONE_SAPPHIRE:\n        return new SapphirePowerCalculator(context);\n      case PHONE_PASSION:\n        return new PassionPowerCalculator(context);\n      default:\n        boolean oled = hasOled();\n        Log.w(TAG, \"Phone type not recognized (\" + Build.DEVICE + \"), using \" +\n              (oled ? \"Passion\" : \"Dream\") + \" calculator\");\n        return oled ? new PassionPowerCalculator(context) :\n                      new DreamPowerCalculator(context);\n    }\n  }\n\n  public static void generateComponents(Context context,\n                                        List<PowerComponent> components,\n                                        List<PowerFunction> functions) {\n    final PhoneConstants constants = getConstants(context);\n    final PhonePowerCalculator calculator = getCalculator(context);\n\n\n\n\n\n    if(hasOled()) {\n      components.add(new OLED(context, constants));\n      functions.add(new PowerFunction() {\n        public double calculate(PowerData data) {\n          return calculator.getOledPower((OledData)data);\n        }});\n    } else {\n      components.add(new LCD(context));\n      functions.add(new PowerFunction() {\n        public double calculate(PowerData data) {\n          return calculator.getLcdPower((LcdData)data);\n        }});\n    }\n\n\n    components.add(new CPU(constants));\n    functions.add(new PowerFunction() {\n      public double calculate(PowerData data) {\n        return calculator.getCpuPower((CpuData)data);\n      }});\n\n\n    String wifiInterface =\n        SystemInfo.getInstance().getProperty(\"wifi.interface\");\n    if(wifiInterface != null && wifiInterface.length() != 0) {\n      components.add(new Wifi(context, constants));\n      functions.add(new PowerFunction() {\n        public double calculate(PowerData data) {\n          return calculator.getWifiPower((WifiData)data);\n        }});\n    }\n\n\n    if(constants.threegInterface().length() != 0) {\n      components.add(new Threeg(context, constants));\n      functions.add(new PowerFunction() {\n        public double calculate(PowerData data) {\n          return calculator.getThreeGPower((ThreegData)data);\n        }});\n    }\n\n\n    components.add(new GPS(context, constants));\n    functions.add(new PowerFunction() {\n      public double calculate(PowerData data) {\n        return calculator.getGpsPower((GpsData)data);\n      }});\n\n\n    components.add(new Audio(context));\n    functions.add(new PowerFunction() {\n      public double calculate(PowerData data) {\n        return calculator.getAudioPower((AudioData)data);\n      }});\n\n\n    if(NotificationService.available()) {\n      components.add(new Sensors(context));\n      functions.add(new PowerFunction() {\n        public double calculate(PowerData data) {\n          return calculator.getSensorPower((SensorData)data);\n        }});\n    }\n  }\n}\n\n'PowerTutor/src/edu/umich/PowerTutor/components/Audio.java'\n:\n\n\n\npackage edu.umich.PowerTutor.components;\n\n\n\nimport edu.umich.PowerTutor.PowerNotifications;\n\nimport edu.umich.PowerTutor.service.IterationData;\n\nimport edu.umich.PowerTutor.service.PowerData;\n\nimport edu.umich.PowerTutor.util.NotificationService;\n\nimport edu.umich.PowerTutor.util.Recycler;\n\n\n\nimport android.content.Context;\n\nimport android.media.AudioManager;\n\n\n\nimport java.io.IOException;\n\nimport java.io.OutputStreamWriter;\n\nimport java.util.TreeSet;\n\n\n\n\n\npublic class Audio extends PowerComponent {\n\n\n\n  public static class AudioData extends PowerData {\n\n    private static Recycler<AudioData> recycler = new Recycler<AudioData>();\n\n\n\n    public static AudioData obtain() {\n\n      AudioData result = recycler.obtain();\n\n      if(result != null) return result;\n\n      return new AudioData();\n\n    }\n\n\n\n    @Override\n\n    public void recycle() {\n\n      recycler.recycle(this);\n\n    }\n\n\n\n    public boolean musicOn;\n\n\n\n    private AudioData() {\n\n    }\n\n\n\n    public void init(boolean musicOn) {\n\n      this.musicOn = musicOn;\n\n    }\n\n\n\n    public void writeLogDataInfo(OutputStreamWriter out) throws IOException {\n\n      out.write(\"Audio-on \" + musicOn + \"\\n\");\n\n    }\n\n  }\n\n\n\n  private static class MediaData implements Comparable {\n\n    private static Recycler<MediaData> recycler = new Recycler<MediaData>();\n\n\n\n    public static MediaData obtain() {\n\n      MediaData result = recycler.obtain();\n\n      if(result != null) return result;\n\n      return new MediaData();\n\n    }\n\n\n\n    public void recycle() {\n\n      recycler.recycle(this);\n\n    }\n\n\n\n    public int uid;\n\n    public int id;\n\n    public int assignUid;\n\n\n\n    public int compareTo(Object obj) {\n\n      MediaData x = (MediaData)obj;\n\n      if(uid < x.uid) return -1;\n\n      if(uid > x.uid) return 1;\n\n      if(id < x.id) return -1;\n\n      if(id > x.id) return 1;\n\n      return 0;\n\n    }\n\n\n\n    public boolean equals(Object obj) {\n\n      MediaData x = (MediaData)obj;\n\n      return uid == x.uid && id == x.id;\n\n    }\n\n  }\n\n\n\n  private AudioManager audioManager;\n\n  private PowerNotifications audioNotif;\n\n  private TreeSet<MediaData> uidData;\n\n\n\n  public Audio(Context context) {\n\n    if(NotificationService.available()) {\n\n      uidData = new TreeSet<MediaData>();\n\n      audioNotif = new NotificationService.DefaultReceiver() {\n\n        private int sysUid = -1;\n\n\n\n        @Override\n\n        public void noteSystemMediaCall(int uid) {\n\n          sysUid = uid;\n\n        }\n\n\n\n        @Override\n\n        public void noteStartMedia(int uid, int id) {\n\n          MediaData data = MediaData.obtain();\n\n          data.uid = uid;\n\n          data.id = id;\n\n          if(uid == 1000 && sysUid != -1) {\n\n            data.assignUid = sysUid;\n\n            sysUid = -1;\n\n          } else {\n\n            data.assignUid = uid;\n\n          }\n\n          synchronized(uidData) {\n\n            if(!uidData.add(data)) {\n\n              data.recycle();\n\n            }\n\n          }\n\n        }\n\n\n\n        @Override\n\n        public void noteStopMedia(int uid, int id) {\n\n          MediaData data = MediaData.obtain();\n\n          data.uid = uid;\n\n          data.id = id;\n\n          synchronized(uidData) {\n\n            uidData.remove(data);\n\n          }\n\n          data.recycle();\n\n        }\n\n      };\n\n      NotificationService.addHook(audioNotif);\n\n    }\n\n\n\n    audioManager = (AudioManager)context.getSystemService(\n\n                                             Context.AUDIO_SERVICE);\n\n  }\n\n\n\n  @Override\n\n  protected void onExit() {\n\n    if(audioNotif != null) {\n\n      NotificationService.removeHook(audioNotif);\n\n    }\n\n  }\n\n\n\n  @Override\n\n  public IterationData calculateIteration(long iteration) {\n\n    IterationData result = IterationData.obtain();\n\n    AudioData data = AudioData.obtain();\n\n    data.init(uidData != null && !uidData.isEmpty() ||\n\n              audioManager.isMusicActive());\n\n    result.setPowerData(data);\n\n\n\n    if(uidData != null) synchronized(uidData) {\n\n      int last_uid = -1;\n\n      for(MediaData dat : uidData) {\n\n        if(dat.uid != last_uid) {\n\n          AudioData audioPower = AudioData.obtain();\n\n          audioPower.init(true);\n\n          result.addUidPowerData(dat.assignUid, audioPower);\n\n        }\n\n        last_uid = dat.uid;\n\n      }\n\n    }\n\n\n\n    return result;\n\n  }\n\n\n\n  @Override\n\n  public boolean hasUidInformation() {\n\n    return audioNotif != null;\n\n  }\n\n\n\n  @Override\n\n  public String getComponentName() {\n\n    return \"Audio\";\n\n  }\n\n}\n\n",
        "gt": [
            "'PowerTutor/src/edu/umich/PowerTutor/components/Audio.java'",
            "'PowerTutor/src/edu/umich/PowerTutor/components/Sensors.java'",
            "'PowerTutor/src/edu/umich/PowerTutor/phone/PhoneSelector.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'",
            "'drift/drift-transport-netty/src/test/java/io/airlift/drift/transport/netty/scribe/apache/scribe.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.inject.BindingAnnotation;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.Scopes;\nimport io.airlift.bootstrap.Bootstrap;\nimport io.airlift.bootstrap.LifeCycleManager;\nimport io.airlift.drift.client.DriftClient;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftResultCode;\nimport io.airlift.drift.integration.scribe.drift.DriftScribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.jmx.testing.TestingJmxModule;\nimport org.weakref.jmx.guice.MBeanModule;\n\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManagerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport static io.airlift.drift.client.guice.DriftClientBinder.driftClientBinder;\nimport static io.airlift.drift.client.guice.MethodInvocationFilterBinder.staticFilterBinder;\nimport static io.airlift.security.pem.PemReader.loadKeyStore;\nimport static io.airlift.security.pem.PemReader.loadTrustStore;\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertSame;\n\nfinal class ClientTestUtils\n{\n    public static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n    public static final List<LogEntry> MESSAGES = ImmutableList.of(\n            new LogEntry(\"hello\", \"world\"),\n            new LogEntry(\"bye\", \"world\"));\n    public static final String HEADER_VALUE = \"header-value\";\n    public static final List<DriftLogEntry> DRIFT_MESSAGES = ImmutableList.copyOf(\n            MESSAGES.stream()\n                    .map(input -> new DriftLogEntry(input.category, input.message))\n                    .collect(Collectors.toList()));\n    public static final DriftResultCode DRIFT_OK = DriftResultCode.OK;\n\n    private ClientTestUtils() {}\n\n    public static int logDriftClientBinder(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            Module transportModule,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n\n        Bootstrap app = new Bootstrap(\n                new MBeanModule(),\n                new TestingJmxModule(),\n                transportModule,\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class, CustomClient.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> binder.bind(ScribeUser.class).in(Scopes.SINGLETON));\n\n        LifeCycleManager lifeCycleManager = null;\n\n        try {\n            app.setRequiredConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"scribe.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.CustomClient.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.thrift.client.protocol\", protocol.toString())\n                    .put(\"scribe.CustomClient.thrift.client.protocol\", protocol.toString())\n                    .build());\n\n\n            app.setOptionalConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.CustomClient.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.CustomClient.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .build());\n\n            Injector injector = app\n                    .doNotInitializeLogging()\n                    .initialize();\n\n            lifeCycleManager = injector.getInstance(LifeCycleManager.class);\n            DriftScribe scribe = injector.getInstance(DriftScribe.class);\n\n            ScribeUser user = injector.getInstance(ScribeUser.class);\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n\n            assertEquals(user.getClient().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getClientCustom().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactory().get().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactoryCustom().get().log(headerValue, entries), DRIFT_OK);\n\n            assertSame(scribe, user.getClient());\n            assertNotSame(user.getClient(), user.getClientCustom());\n            assertNotSame(user.getFactory(), user.getFactoryCustom());\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        finally {\n            if (lifeCycleManager != null) {\n                try {\n                    lifeCycleManager.stop();\n                }\n                catch (Exception ignored) {\n                }\n            }\n        }\n        return 5;\n    }\n\n    public static SSLContext getServerSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        keyManagerFactory.init(loadKeyStore(getPrivateKeyFile(), getPrivateKeyFile(), Optional.empty()), new char[0]);\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static SSLContext getClientSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static File getPrivateKeyFile()\n    {\n        return getResourceFile(\"rsa.key\");\n    }\n\n    public static File getCertificateChainFile()\n    {\n        return getResourceFile(\"rsa.crt\");\n    }\n\n    private static File getResourceFile(String name)\n    {\n        URL resource = TestClientsWithApacheServer.class.getClassLoader().getResource(name);\n        if (resource == null) {\n            throw new IllegalArgumentException(\"Resource not found \" + name);\n        }\n        return new File(resource.getFile());\n    }\n\n    @Target({FIELD, PARAMETER, METHOD})\n    @Retention(RUNTIME)\n    @BindingAnnotation\n    private @interface CustomClient {}\n\n    private static class ScribeUser\n    {\n        @Inject\n        private DriftScribe client;\n\n        @Inject\n        @CustomClient\n        private DriftScribe clientCustom;\n\n        @Inject\n        private DriftClient<DriftScribe> factory;\n\n        @Inject\n        @CustomClient\n        private DriftClient<DriftScribe> factoryCustom;\n\n        public DriftScribe getClient()\n        {\n            return client;\n        }\n\n        public DriftScribe getClientCustom()\n        {\n            return clientCustom;\n        }\n\n        public DriftClient<DriftScribe> getFactory()\n        {\n            return factory;\n        }\n\n        public DriftClient<DriftScribe> getFactoryCustom()\n        {\n            return factoryCustom;\n        }\n    }\n}\n\n'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.apache.ResultCode;\nimport io.airlift.drift.integration.scribe.apache.scribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TCompactProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransport;\nimport org.apache.thrift.transport.TTransportException;\nimport org.apache.thrift.transport.TTransportFactory;\nimport org.apache.thrift.transport.layered.TFramedTransport;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLSocket;\n\nimport java.util.List;\nimport java.util.function.ToIntFunction;\n\nimport static io.airlift.drift.integration.ClientTestUtils.MESSAGES;\nimport static org.testng.Assert.assertEquals;\n\nfinal class LegacyApacheThriftTesterUtil\n{\n    private LegacyApacheThriftTesterUtil() {}\n\n    public static List<ToIntFunction<HostAndPort>> legacyApacheThriftTestClients(List<MethodInvocationFilter> filters, Transport transport, Protocol protocol, boolean secure)\n    {\n        return ImmutableList.of(\n                address -> logThrift(address, MESSAGES, filters, transport, protocol, secure));\n    }\n\n    private static int logThrift(HostAndPort address, List<LogEntry> messages, List<MethodInvocationFilter> filters, Transport transportType, Protocol protocolType, boolean secure)\n    {\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        TTransportFactory transportFactory;\n        switch (transportType) {\n            case UNFRAMED:\n                transportFactory = new TTransportFactory();\n                break;\n            case FRAMED:\n                transportFactory = new TFramedTransport.Factory();\n                break;\n            case HEADER:\n                return 0;\n            default:\n                throw new IllegalArgumentException(\"Unsupported transport \" + transportType);\n        }\n\n        try (TSocket socket = createClientSocket(secure, address)) {\n            if (!socket.isOpen()) {\n                socket.open();\n            }\n            TTransport transport = transportFactory.getTransport(socket);\n            TProtocol protocol;\n            switch (protocolType) {\n                case BINARY:\n                    protocol = new TBinaryProtocol(transport);\n                    break;\n                case COMPACT:\n                    protocol = new TCompactProtocol(transport);\n                    break;\n                case FB_COMPACT:\n                    return 0;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported protocol \" + protocolType);\n            }\n\n            assertEquals(new scribe.Client(protocol).Log(messages), ResultCode.OK);\n        }\n        catch (TException e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static TSocket createClientSocket(boolean secure, HostAndPort address)\n            throws TTransportException\n    {\n        if (!secure) {\n            return new TSocket(address.getHost(), address.getPort());\n        }\n\n        try {\n            SSLContext serverSslContext = ClientTestUtils.getClientSslContext();\n            SSLSocket clientSocket = (SSLSocket) serverSslContext.getSocketFactory().createSocket(address.getHost(), address.getPort());\n\n            return new TSocket(clientSocket);\n        }\n        catch (Exception e) {\n            throw new TTransportException(\"Error initializing secure socket\", e);\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-transport-netty/src/test/java/io/airlift/drift/transport/netty/scribe/apache/scribe.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/LegacyApacheThriftTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Paint.Align;\nimport android.graphics.Paint.Style;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.Nullable;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.MONTH_NAVIGATION_BAR_SIZE;\n\n\npublic final class MonthPickerView extends View {\n    private static final String TAG = \"MonthPickerView\";\n\n    private static final int NUM_COLUMNS = 3;\n    private static final int NUM_ROWS = 4;\n    private static final int MONTH_SEPARATOR_WIDTH = 1;\n\n    private static int MONTH_LABEL_TEXT_SIZE;\n    private static int MONTH_SELECTED_CIRCLE_SIZE;\n\n\n    private int mEdgePadding = 0;\n\n    private Paint mMonthLabelPaint;\n    private Paint mSelectedCirclePaint;\n\n\n    private int mWidth;\n    private int mRowHeight;\n    private CalendarDay mSelectedDay;\n\n    private int mYear;\n\n    private final int mCurrentMonth;\n\n    private final int mCurrentYear;\n\n    private final String[] mShortMonthLabels;\n\n    @Nullable\n    private DateRangeHelper mDateRangeHelper;\n    @Nullable\n    private OnMonthClickListener mOnMonthClickListener;\n\n    private int mNormalTextColor;\n    private int mCurrentMonthTextColor;\n    private int mDisabledMonthTextColor;\n    private int mSelectedMonthTextColor;\n\n    public MonthPickerView(Context context) {\n        this(context, null);\n    }\n\n    public MonthPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        Resources res = context.getResources();\n\n        mShortMonthLabels = new DateFormatSymbols().getShortMonths();\n\n        mNormalTextColor = getColor(context, R.color.bsp_text_color_primary_light);\n\n        mSelectedMonthTextColor = getColor(context, R.color.bsp_date_picker_view_animator);\n        mCurrentMonthTextColor = Utils.getThemeAccentColor(context);\n        mDisabledMonthTextColor = getColor(context, R.color.bsp_text_color_disabled_light);\n\n        Calendar now = Calendar.getInstance();\n        mCurrentMonth = now.get(Calendar.MONTH);\n        mCurrentYear = now.get(Calendar.YEAR);\n\n        MONTH_LABEL_TEXT_SIZE = res.getDimensionPixelSize(R.dimen.bsp_month_picker_month_label_size);\n        MONTH_SELECTED_CIRCLE_SIZE = res.getDimensionPixelSize(R.dimen.bsp_month_select_circle_radius);\n\n        mRowHeight = (res.getDimensionPixelOffset(R.dimen.bsp_date_picker_view_animator_height)\n                - MONTH_NAVIGATION_BAR_SIZE) / NUM_ROWS;\n        mEdgePadding = res.getDimensionPixelSize(R.dimen.bsp_month_view_edge_padding);\n\n\n\n        initView();\n    }\n\n\n    void setDisplayParams(CalendarDay selectedDay, int year) {\n        mSelectedDay = selectedDay;\n        mYear = year;\n\n\n\n    }\n\n\n    private void adjustDayInMonthIfNeeded(int month) {\n        int daysInMonth = Utils.getDaysInMonth(month, mYear);\n        if (mSelectedDay.day > daysInMonth) {\n            mSelectedDay.day = daysInMonth;\n        }\n    }\n\n    private int constrainDayInMonth(int month, int defaultDay) {\n        int daysInMonth = Utils.getDaysInMonth(month, mYear);\n        return Math.min(defaultDay, daysInMonth);\n    }\n\n    public void setDatePickerController(DatePickerController controller) {\n        mDateRangeHelper = new DateRangeHelper(controller);\n    }\n\n    public void setOnMonthClickListener(@Nullable OnMonthClickListener onMonthClickListener) {\n        mOnMonthClickListener = onMonthClickListener;\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        if (themeDark) {\n            mNormalTextColor = getColor(context, R.color.bsp_text_color_primary_dark);\n            mSelectedMonthTextColor = getColor(context, R.color.bsp_dark_gray);\n            mDisabledMonthTextColor = getColor(context, R.color.bsp_text_color_disabled_dark);\n            initView();\n        }\n    }\n\n\n    void setCurrentMonthTextColor(@ColorInt int color) {\n        mCurrentMonthTextColor = color;\n    }\n\n\n    void setSelectedCirclePaintColor(@ColorInt int color) {\n        mSelectedCirclePaint.setColor(color);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_UP:\n                final int month = getMonthFromLocation(event.getX(), event.getY());\n                if (month >= 0) {\n                    onMonthClick(month);\n                }\n                break;\n        }\n        return true;\n    }\n\n\n    protected void initView() {\n        mMonthLabelPaint = new Paint();\n        mMonthLabelPaint.setAntiAlias(true);\n        mMonthLabelPaint.setTextSize(MONTH_LABEL_TEXT_SIZE);\n        mMonthLabelPaint.setStyle(Style.FILL);\n        mMonthLabelPaint.setTextAlign(Align.CENTER);\n        mMonthLabelPaint.setFakeBoldText(false);\n\n        mSelectedCirclePaint = new Paint();\n        mSelectedCirclePaint.setFakeBoldText(true);\n        mSelectedCirclePaint.setAntiAlias(true);\n        mSelectedCirclePaint.setColor(mCurrentMonthTextColor);\n        mSelectedCirclePaint.setTextAlign(Align.CENTER);\n        mSelectedCirclePaint.setStyle(Style.FILL);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), mRowHeight * NUM_ROWS\n                + MONTH_NAVIGATION_BAR_SIZE);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        mWidth = w;\n\n\n\n    }\n\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        drawMonthLabels(canvas);\n    }\n\n    private void drawMonthLabels(Canvas canvas) {\n        int y = (((mRowHeight + MONTH_LABEL_TEXT_SIZE) / 2) - MONTH_SEPARATOR_WIDTH);\n        final float monthWidthHalf = (mWidth - mEdgePadding * 2) / (NUM_COLUMNS * 2.0f);\n        int col = 0;\n        for (int month = Calendar.JANUARY; month <= Calendar.DECEMBER; month++) {\n            final int x = (int)((2 * col + 1) * monthWidthHalf + mEdgePadding);\n\n\n\n\n            int constrainedDay = constrainDayInMonth(month, mSelectedDay.day);\n            drawMonthLabel(canvas, mYear, month, constrainedDay, x, y);\n            col++;\n            if (col == NUM_COLUMNS) {\n                col = 0;\n                y += mRowHeight;\n            }\n        }\n    }\n\n    private void drawMonthLabel(Canvas canvas, int year, int month, int day, int x, int y) {\n        final int selectedYear = mSelectedDay.year;\n        final int selectedMonth = mSelectedDay.month;\n\n        boolean drawCircle = selectedYear == year && selectedMonth == month;\n        if (drawCircle) {\n            canvas.drawCircle(x , y - (MONTH_LABEL_TEXT_SIZE / 3), MONTH_SELECTED_CIRCLE_SIZE,\n                    mSelectedCirclePaint);\n        }\n\n\n\n        if (mDateRangeHelper != null && mDateRangeHelper.isOutOfRange(year, month, day)) {\n            mMonthLabelPaint.setFakeBoldText(false);\n            mMonthLabelPaint.setColor(mDisabledMonthTextColor);\n        } else {\n            boolean currentMonthYear = mCurrentYear == year && mCurrentMonth == month;\n            mMonthLabelPaint.setFakeBoldText(currentMonthYear || drawCircle);\n            mMonthLabelPaint.setColor(drawCircle ? mSelectedMonthTextColor :\n                    (currentMonthYear ? mCurrentMonthTextColor : mNormalTextColor));\n        }\n        canvas.drawText(mShortMonthLabels[month], x, y, mMonthLabelPaint);\n    }\n\n\n    public int getMonthFromLocation(float x, float y) {\n        final int month = getInternalMonthFromLocation(x, y);\n        if (month < Calendar.JANUARY || month > Calendar.DECEMBER) {\n            return -1;\n        }\n        return month;\n    }\n\n\n    protected int getInternalMonthFromLocation(float x, float y) {\n        int monthStart = mEdgePadding;\n        if (x < monthStart || x > mWidth - mEdgePadding) {\n\n            return -1;\n        }\n        int row = (int) (y / mRowHeight);\n\n        int column = (int) ((x - monthStart) * NUM_COLUMNS / (mWidth - mEdgePadding * 2));\n\n        int month = column;\n        month += row * NUM_COLUMNS;\n        return month;\n    }\n\n\n    private void onMonthClick(int month) {\n        adjustDayInMonthIfNeeded(month);\n\n        if (mDateRangeHelper != null && mDateRangeHelper.isOutOfRange(mYear, month, mSelectedDay.day)) {\n            return;\n        }\n\n        if (mOnMonthClickListener != null) {\n            mOnMonthClickListener.onMonthClick(this, month, mYear);\n        }\n\n\n\n    }\n\n    interface OnMonthClickListener {\n        void onMonthClick(MonthPickerView view, int month, int year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ]
    },
    {
        "files": [
            "'jox/channels/src/test/java/com/softwaremill/jox/SegmentTest.java'",
            "'jox/channels/src/test/java/com/softwaremill/jox/SegmentRendezvousTest.java'",
            "'jox/channels/src/main/java/com/softwaremill/jox/Segment.java'"
        ],
        "content": "'jox/channels/src/test/java/com/softwaremill/jox/SegmentTest.java'\n:package com.softwaremill.jox;\n\nimport org.junit.jupiter.api.Test;\n\nimport static com.softwaremill.jox.Segment.SEGMENT_SIZE;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SegmentTest {\n    @Test\n    void segmentShouldBecomeRemovedOnceAllCellsInterruptedAndProcessed() {\n\n        var ss = createSegmentChain(3, 0, false);\n\n\n\n        for (int i = 0; i < SEGMENT_SIZE; i++) {\n            ss[1].cellInterruptedReceiver();\n\n            assertFalse(ss[1].isRemoved());\n            assertEquals(ss[1].getPrev(), ss[0]);\n            assertEquals(ss[1].getNext(), ss[2]);\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[1]);\n            assertEquals(ss[2].getPrev(), ss[1]);\n            assertNull(ss[2].getNext());\n        }\n\n\n        for (int i = 0; i < SEGMENT_SIZE - 1; i++) {\n            ss[1].cellProcessed_notInterruptedSender();\n\n            assertFalse(ss[1].isRemoved());\n            assertEquals(ss[1].getPrev(), ss[0]);\n            assertEquals(ss[1].getNext(), ss[2]);\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[1]);\n            assertEquals(ss[2].getPrev(), ss[1]);\n            assertNull(ss[2].getNext());\n        }\n\n        ss[1].cellProcessed_notInterruptedSender();\n        assertTrue(ss[1].isRemoved());\n\n\n        assertNull(ss[0].getPrev());\n        assertEquals(ss[0].getNext(), ss[2]);\n        assertEquals(ss[2].getPrev(), ss[0]);\n        assertNull(ss[2].getNext());\n    }\n\n    @Test\n    void segmentShouldBecomeRemovedOnceAllCellsSenderInterrupted() {\n\n        var ss = createSegmentChain(3, 0, false);\n\n\n        for (int i = 0; i < SEGMENT_SIZE - 1; i++) {\n            ss[1].cellInterruptedSender();\n\n            assertFalse(ss[1].isRemoved());\n            assertEquals(ss[1].getPrev(), ss[0]);\n            assertEquals(ss[1].getNext(), ss[2]);\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[1]);\n            assertEquals(ss[2].getPrev(), ss[1]);\n            assertNull(ss[2].getNext());\n        }\n\n        ss[1].cellInterruptedSender();\n        assertTrue(ss[1].isRemoved());\n\n\n        assertNull(ss[0].getPrev());\n        assertEquals(ss[0].getNext(), ss[2]);\n        assertEquals(ss[2].getPrev(), ss[0]);\n        assertNull(ss[2].getNext());\n    }\n\n    @Test\n    void shouldReturnTheLastSegmentWhenClosing() {\n\n        var ss = createSegmentChain(3, 0, false);\n\n\n        var s = ss[0].close();\n\n\n        assertEquals(ss[2].getId(), s.getId());\n    }\n\n    static Segment[] createSegmentChain(int count, long id, boolean isRendezvous) {\n        var segments = new Segment[count];\n        var thisSegment = new Segment(id, null, 0, isRendezvous);\n        segments[0] = thisSegment;\n        for (int i = 1; i < count; i++) {\n            var nextSegment = new Segment(id + i, thisSegment, 0, isRendezvous);\n            thisSegment.setNext(nextSegment);\n            segments[i] = nextSegment;\n            thisSegment = nextSegment;\n        }\n        return segments;\n    }\n\n    static void sendInterruptAllCells(Segment s) {\n        for (int i = 0; i < SEGMENT_SIZE; i++) {\n            s.cellInterruptedSender();\n        }\n    }\n}\n\n'jox/channels/src/test/java/com/softwaremill/jox/SegmentRendezvousTest.java'\n:package com.softwaremill.jox;\n\nimport org.junit.jupiter.api.Test;\n\nimport java.lang.invoke.MethodHandles;\nimport java.lang.invoke.VarHandle;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutionException;\n\nimport static com.softwaremill.jox.Segment.SEGMENT_SIZE;\nimport static com.softwaremill.jox.SegmentTest.createSegmentChain;\nimport static com.softwaremill.jox.SegmentTest.sendInterruptAllCells;\nimport static com.softwaremill.jox.TestUtil.forkVoid;\nimport static com.softwaremill.jox.TestUtil.scoped;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SegmentRendezvousTest {\n\n    private Segment someSegment;\n    private static final VarHandle SOME_SEGMENT;\n\n    static {\n        try {\n            MethodHandles.Lookup l = MethodHandles.privateLookupIn(SegmentRendezvousTest.class, MethodHandles.lookup());\n            SOME_SEGMENT = l.findVarHandle(SegmentRendezvousTest.class, \"someSegment\", Segment.class);\n        } catch (ReflectiveOperationException e) {\n            throw new ExceptionInInitializerError(e);\n        }\n    }\n\n    @Test\n    void segmentShouldBecomeRemovedOnceAllCellsInterrupted() {\n\n        var ss = createSegmentChain(3, 0, true);\n\n\n        for (int i = 0; i < SEGMENT_SIZE - 1; i++) {\n            ss[1].cellInterruptedReceiver();\n\n            assertFalse(ss[1].isRemoved());\n            assertEquals(ss[1].getPrev(), ss[0]);\n            assertEquals(ss[1].getNext(), ss[2]);\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[1]);\n            assertEquals(ss[2].getPrev(), ss[1]);\n            assertNull(ss[2].getNext());\n        }\n\n        ss[1].cellInterruptedReceiver();\n        assertTrue(ss[1].isRemoved());\n\n\n        assertNull(ss[0].getPrev());\n        assertEquals(ss[0].getNext(), ss[2]);\n        assertEquals(ss[2].getPrev(), ss[0]);\n        assertNull(ss[2].getNext());\n    }\n\n    @Test\n    void shouldRemoveMultipleSegments() {\n\n        var ss = createSegmentChain(5, 0, true);\n\n\n\n        assertTrue(ss[1].tryIncPointers());\n        assertTrue(ss[2].tryIncPointers());\n        assertTrue(ss[3].tryIncPointers());\n\n        for (int i = 0; i < SEGMENT_SIZE; i++) {\n            ss[1].cellInterruptedReceiver();\n            assertFalse(ss[1].isRemoved());\n            ss[2].cellInterruptedReceiver();\n            assertFalse(ss[2].isRemoved());\n            ss[3].cellInterruptedReceiver();\n            assertFalse(ss[3].isRemoved());\n        }\n\n        assertTrue(ss[1].decPointers());\n        assertTrue(ss[2].decPointers());\n        assertTrue(ss[3].decPointers());\n\n        assertEquals(ss[0].getNext(), ss[1]);\n        assertEquals(ss[1].getNext(), ss[2]);\n        assertEquals(ss[2].getNext(), ss[3]);\n        assertEquals(ss[3].getNext(), ss[4]);\n\n        ss[2].remove();\n\n\n        assertEquals(ss[0].getNext(), ss[4]);\n        assertEquals(ss[4].getPrev(), ss[0]);\n    }\n\n    @Test\n    void shouldNotIncrementIncomingPointersIfSegmentRemoved() {\n\n        var ss = createSegmentChain(1, 0, true);\n\n\n        sendInterruptAllCells(ss[0]);\n\n\n        assertFalse(ss[0].tryIncPointers());\n    }\n\n    @Test\n    void shouldIncrementAndDecrementPointersInSegment() {\n\n        var ss = createSegmentChain(1, 0, true);\n\n\n        assertTrue(ss[0].tryIncPointers());\n        assertFalse(ss[0].decPointers());\n    }\n\n    @Test\n    void shouldNotRemoveSegmentIfThereAreIncomingPointers() {\n\n        var ss = createSegmentChain(2, 0, true);\n\n\n        assertTrue(ss[0].tryIncPointers());\n\n        for (int i = 0; i < SEGMENT_SIZE; i++) {\n            ss[0].cellInterruptedReceiver();\n            assertFalse(ss[0].isRemoved());\n        }\n\n\n        assertTrue(ss[0].decPointers());\n        assertTrue(ss[0].isRemoved());\n\n        ss[0].remove();\n        assertNull(ss[1].getPrev());\n        assertNull(ss[1].getNext());\n    }\n\n    @Test\n    void shouldRemoveSegmentsWhenRunConcurrently() throws ExecutionException, InterruptedException {\n\n        int segmentCount = 30;\n\n        for (int k = 0; k < 1000; k++) {\n            var ss = createSegmentChain(segmentCount, 0, true);\n\n\n            scoped(scope -> {\n\n                for (int i = 1; i < ss.length - 1; i++) {\n                    for (int j = 0; j < SEGMENT_SIZE - 1; j++) {\n                        ss[i].cellInterruptedReceiver();\n                    }\n                }\n\n\n                for (int i = 1; i < ss.length - 1; i++) {\n                    int ii = i;\n                    forkVoid(scope, () -> {\n                        ss[ii].cellInterruptedReceiver();\n                    });\n                }\n            });\n\n\n            for (int i = 1; i < ss.length - 1; i++) {\n                assertTrue(ss[i].isRemoved());\n            }\n\n            assertNull(ss[0].getPrev());\n            assertEquals(ss[0].getNext(), ss[segmentCount - 1]);\n            assertEquals(ss[segmentCount - 1].getPrev(), ss[0]);\n            assertNull(ss[segmentCount - 1].getNext());\n        }\n    }\n\n    @Test\n    void shouldNotResurrectAnUnlikedSegment() {\n\n        var ss = createSegmentChain(3, 0, true);\n\n\n\n        ss[2].cleanPrev();\n\n\n        sendInterruptAllCells(ss[1]);\n\n\n        assertTrue(ss[1].isRemoved());\n        assertEquals(ss[0].getNext(), ss[2]);\n        assertEquals(ss[2].getPrev(), null);\n    }\n\n    @Test\n    void shouldFindAndMoveSegmentReferenceForward() {\n\n        var s = createSegmentChain(4, 0, true);\n        someSegment = s[0];\n\n\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, s[0], 2);\n\n\n        assertEquals(s[2], result);\n\n\n        result = Segment.findAndMoveForward(SOME_SEGMENT, this, s[0], 5);\n        assertEquals(5, result.getId());\n        assertEquals(result, s[3].getNext().getNext());\n    }\n\n    @Test\n    void shouldMoveReferenceForwardIfClosedAndFoundSegmentExists() {\n\n        var s = createSegmentChain(4, 0, true);\n        someSegment = s[0];\n\n\n        s[0].close();\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, s[0], 3);\n\n\n        assertEquals(s[3], result);\n        assertEquals(s[3], someSegment);\n    }\n\n    @Test\n    void shouldNotMoveReferenceForwardIfClosedAndFoundSegmentDoesNotExist() {\n\n        var s = createSegmentChain(4, 0, true);\n        someSegment = s[0];\n\n\n        s[0].close();\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, s[0], 5);\n\n\n        assertNull(result);\n        assertEquals(s[0], someSegment);\n    }\n\n    @Test\n    void shouldRemoveOldTailSegment() {\n\n        var ss = createSegmentChain(2, 0, true);\n\n\n        sendInterruptAllCells(ss[1]);\n\n\n        assertTrue(ss[1].isRemoved());\n        assertEquals(ss[0].getNext(), ss[1]);\n\n\n        someSegment = ss[0];\n        var s2 = Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 2);\n\n\n        assertEquals(s2, ss[0].getNext());\n        assertEquals(s2.getPrev(), ss[0]);\n    }\n\n    @Test\n    void shouldReturnNextSegmentIfRemoved() {\n\n        var ss = createSegmentChain(3, 0, true);\n        sendInterruptAllCells(ss[1]);\n\n\n        someSegment = ss[0];\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 1);\n\n\n        assertEquals(ss[2], result);\n    }\n\n    @Test\n    void shouldNotUpdateSegmentReferenceIfAlreadyUpdated() {\n\n        var ss = createSegmentChain(3, 0, true);\n        someSegment = ss[2];\n\n\n        var result = Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 1);\n\n\n        assertEquals(ss[1], result);\n        assertEquals(ss[2], someSegment);\n    }\n\n    @Test\n    void shouldUpdateSegmentPointersWhenReferenceChanges() {\n\n        var ss = createSegmentChain(3, 0, true);\n        someSegment = ss[0];\n\n\n        Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 1);\n\n\n        sendInterruptAllCells(ss[1]);\n        assertFalse(ss[1].isRemoved());\n\n\n        Segment.findAndMoveForward(SOME_SEGMENT, this, ss[0], 2);\n\n\n        assertTrue(ss[1].isRemoved());\n        sendInterruptAllCells(ss[2]);\n        assertFalse(ss[2].isRemoved());\n    }\n\n    @Test\n    void shouldConcurrentlyMoveSegmentsForward() throws ExecutionException, InterruptedException {\n\n        for (int k = 0; k < 1000; k++) {\n            var ss = createSegmentChain(1, 0, true);\n            someSegment = ss[0];\n            var observedSegments = new ConcurrentHashMap<Integer, Segment>();\n\n\n            scoped(scope -> {\n\n                for (int f = 0; f < 10; f++) {\n                    forkVoid(scope, () -> {\n                        var s = ss[0];\n                        for (int i = 0; i < 300; i++) {\n                            s = Segment.findAndMoveForward(SOME_SEGMENT, this, s, i);\n                            var previous = observedSegments.put(i, s);\n                            if (previous != s && previous != null) {\n                                fail(\"Already observed segment: \" + previous + \" for id: \" + i + \", but found: \" + s);\n                            }\n                        }\n                    });\n                }\n            });\n        }\n    }\n}\n",
        "gt": [
            "'jox/channels/src/main/java/com/softwaremill/jox/Segment.java'",
            "'jox/channels/src/test/java/com/softwaremill/jox/SegmentTest.java'",
            "'jox/channels/src/test/java/com/softwaremill/jox/SegmentRendezvousTest.java'"
        ]
    },
    {
        "files": [
            "'Achilles/achilles-model/src/main/java/info/archinnov/achilles/type/lightweighttransaction/LWTResultListener.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/crud/DeleteWithOptions.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/LWTHelper.java'"
        ],
        "content": "'Achilles/achilles-model/src/main/java/info/archinnov/achilles/type/lightweighttransaction/LWTResultListener.java'\n:\n\npackage info.archinnov.achilles.type.lightweighttransaction;\n\nimport static java.lang.String.format;\n\nimport info.archinnov.achilles.type.TypedMap;\n\n\npublic interface LWTResultListener {\n\n    default void onSuccess() {\n\n    }\n\n    void onError(LWTResult lwtResult);\n\n\n\n    class LWTResult {\n        private final LWTOperation lwtOperation;\n        private final TypedMap currentValues;\n\n        public LWTResult(LWTOperation lwtOperation, TypedMap currentValues) {\n            this.lwtOperation = lwtOperation;\n            this.currentValues = currentValues;\n        }\n\n        public LWTOperation operation() {\n            return lwtOperation;\n        }\n\n        public TypedMap currentValues() {\n            return currentValues;\n        }\n\n        @Override\n        public String toString() {\n            return format(\"LightWeight Transaction operation %s cannot be applied. Current values are: %s\", lwtOperation, currentValues);\n        }\n\n        public enum LWTOperation {INSERT, UPDATE}\n    }\n}\n\n'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/crud/DeleteWithOptions.java'\n:\n\npackage info.archinnov.achilles.internals.dsl.crud;\n\nimport static info.archinnov.achilles.internals.cache.CacheKey.Operation.DELETE;\nimport static info.archinnov.achilles.internals.cache.CacheKey.Operation.DELETE_IF_EXISTS;\nimport static info.archinnov.achilles.internals.dsl.LWTHelper.triggerLWTListeners;\nimport static info.archinnov.achilles.type.interceptor.Event.POST_DELETE;\nimport static info.archinnov.achilles.type.interceptor.Event.PRE_DELETE;\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.datastax.driver.core.BoundStatement;\nimport com.datastax.driver.core.ExecutionInfo;\nimport com.datastax.driver.core.PreparedStatement;\nimport com.datastax.driver.core.ResultSet;\n\nimport info.archinnov.achilles.internals.cache.CacheKey;\nimport info.archinnov.achilles.internals.dsl.StatementProvider;\nimport info.archinnov.achilles.internals.dsl.action.MutationAction;\nimport info.archinnov.achilles.internals.dsl.options.AbstractOptionsForUpdateOrDelete;\nimport info.archinnov.achilles.internals.metamodel.AbstractEntityProperty;\nimport info.archinnov.achilles.internals.options.CassandraOptions;\nimport info.archinnov.achilles.internals.runtime.RuntimeEngine;\nimport info.archinnov.achilles.internals.statements.BoundStatementWrapper;\nimport info.archinnov.achilles.internals.statements.OperationType;\nimport info.archinnov.achilles.internals.statements.StatementWrapper;\n\npublic class DeleteWithOptions<ENTITY> extends AbstractOptionsForUpdateOrDelete<DeleteWithOptions<ENTITY>>\n        implements MutationAction, StatementProvider {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DeleteWithOptions.class);\n\n    private final Class<ENTITY> entityClass;\n    private final AbstractEntityProperty<ENTITY> meta;\n    private final RuntimeEngine rte;\n    private Object[] primaryKeyValues;\n    private Object[] encodedPrimaryKeyValues;\n    private final Optional<ENTITY> instance;\n    private final CassandraOptions options;\n    private Optional<Boolean> ifExists = Optional.empty();\n\n    public DeleteWithOptions(Class<ENTITY> entityClass,\n                             AbstractEntityProperty<ENTITY> meta,\n                             RuntimeEngine rte,\n                             Object[] primaryKeyValues,\n                             Object[] encodedPrimaryKeyValues,\n                             Optional<ENTITY> instance,\n                             Optional<CassandraOptions> cassandraOptions) {\n        this.entityClass = entityClass;\n        this.meta = meta;\n        this.rte = rte;\n        this.primaryKeyValues = primaryKeyValues;\n        this.encodedPrimaryKeyValues = encodedPrimaryKeyValues;\n        this.instance = instance;\n        this.options = cassandraOptions.orElse(new CassandraOptions());\n    }\n\n    public CompletableFuture<ExecutionInfo> executeAsyncWithStats() {\n\n        if (this.instance.isPresent()) {\n            final ENTITY entity = this.instance.get();\n            meta.triggerInterceptorsForEvent(PRE_DELETE, entity);\n        }\n\n        final StatementWrapper statementWrapper = getInternalBoundStatementWrapper();\n        final String queryString = statementWrapper.getBoundStatement().preparedStatement().getQueryString();\n\n        if (LOGGER.isTraceEnabled()) {\n            LOGGER.trace(format(\"Execute delete async with execution info : %s\", queryString));\n        }\n\n        CompletableFuture<ResultSet> cfutureRS = rte.execute(statementWrapper);\n\n        return cfutureRS\n                .thenApply(options::resultSetAsyncListener)\n                .thenApply(statementWrapper::logTrace)\n                .thenApply(x -> triggerLWTListeners(lwtResultListeners, x, queryString))\n                .thenApply(x -> x.getExecutionInfo())\n                .thenApply(x -> {\n                    if (this.instance.isPresent()) meta.triggerInterceptorsForEvent(POST_DELETE, instance.get());\n                    return x;\n                });\n    }\n\n    @Override\n    protected CassandraOptions getOptions() {\n        return options;\n    }\n\n    @Override\n    public BoundStatement generateAndGetBoundStatement() {\n        return getInternalBoundStatementWrapper().getBoundStatement();\n    }\n\n    @Override\n    public String getStatementAsString() {\n        return rte.getStaticCache(new CacheKey(entityClass, DELETE)).getQueryString();\n    }\n\n    @Override\n    public List<Object> getBoundValues() {\n        return Arrays.asList(primaryKeyValues);\n    }\n\n    @Override\n    public List<Object> getEncodedBoundValues() {\n        return Arrays.asList(encodedPrimaryKeyValues);\n    }\n\n    @Override\n    protected DeleteWithOptions<ENTITY> getThis() {\n        return this;\n    }\n\n    private StatementWrapper getInternalBoundStatementWrapper() {\n        if (LOGGER.isTraceEnabled()) {\n            LOGGER.trace(format(\"Generate bound statement wrapper\"));\n        }\n\n        final PreparedStatement ps = getInternalPreparedStatement();\n        final BoundStatementWrapper statementWrapper = new BoundStatementWrapper(OperationType.DELETE, meta, ps, primaryKeyValues, encodedPrimaryKeyValues);\n        statementWrapper.applyOptions(options);\n        return statementWrapper;\n    }\n\n    private PreparedStatement getInternalPreparedStatement() {\n        if (ifExists.isPresent() && ifExists.get() == true) {\n            return DELETE_IF_EXISTS.getPreparedStatement(rte, meta, options);\n        } else {\n            return DELETE.getPreparedStatement(rte, meta, options);\n        }\n    }\n\n    public DeleteWithOptions<ENTITY> ifExists(boolean ifExists) {\n        this.ifExists = Optional.of(ifExists);\n        return this;\n    }\n\n    public DeleteWithOptions<ENTITY> ifExists() {\n        this.ifExists = Optional.of(true);\n        return this;\n    }\n}\n\n'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/LWTHelper.java'\n:\n\npackage info.archinnov.achilles.internals.dsl;\n\nimport static info.archinnov.achilles.type.lightweighttransaction.LWTResultListener.LWTResult.LWTOperation.INSERT;\nimport static info.archinnov.achilles.type.lightweighttransaction.LWTResultListener.LWTResult.LWTOperation.UPDATE;\nimport static java.lang.String.format;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.TreeMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.datastax.driver.core.ColumnDefinitions;\nimport com.datastax.driver.core.ResultSet;\nimport com.datastax.driver.core.Row;\n\nimport info.archinnov.achilles.exception.AchillesLightWeightTransactionException;\nimport info.archinnov.achilles.type.TypedMap;\nimport info.archinnov.achilles.type.lightweighttransaction.LWTResultListener;\nimport info.archinnov.achilles.type.lightweighttransaction.LWTResultListener.LWTResult;\nimport info.archinnov.achilles.type.lightweighttransaction.LWTResultListener.LWTResult.LWTOperation;\n\npublic class LWTHelper {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LWTHelper.class);\n\n    private static final String IF_NOT_EXIST_CLAUSE = \" IF NOT EXISTS\";\n    private static final String IF_CLAUSE = \" IF \";\n\n    private static void notifyLWTError(Optional<List<LWTResultListener>> lwtResultListeners, LWTResult lwtResult) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(format(\"Maybe notify listener of LWT error : %s\",\n                    lwtResult));\n        }\n\n        if (lwtResultListeners.isPresent()) {\n            for (LWTResultListener listener : lwtResultListeners.get()) {\n                listener.onError(lwtResult);\n            }\n        } else {\n            throw new AchillesLightWeightTransactionException(lwtResult);\n        }\n    }\n\n    private static void notifyCASSuccess(Optional<List<LWTResultListener>> lwtResultListeners) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(format(\"Maybe notify listener of LWT success\"));\n        }\n        lwtResultListeners.ifPresent(list -> list.forEach(listener -> listener.onSuccess()));\n    }\n\n    private static boolean isLWTOperation(String queryString) {\n        return queryString.contains(IF_CLAUSE);\n    }\n\n    private static boolean isLWTInsert(String queryString) {\n        return queryString.contains(IF_NOT_EXIST_CLAUSE);\n    }\n\n    public static ResultSet triggerLWTListeners(Optional<List<LWTResultListener>> lwtResultListeners, ResultSet resultSet, String queryString) {\n        if (isLWTOperation(queryString)) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(format(\"Trigger LWT listeners for query : %s\", queryString));\n            }\n\n            final Row lwtResult = resultSet.one();\n            if (!resultSet.wasApplied()) {\n                TreeMap<String, Object> currentValues = new TreeMap<>();\n                for (ColumnDefinitions.Definition columnDef : lwtResult.getColumnDefinitions()) {\n                    final String columnDefName = columnDef.getName();\n                    Object columnValue = lwtResult.getObject(columnDefName);\n                    currentValues.put(columnDefName, columnValue);\n                }\n\n                LWTOperation lwtOperation = UPDATE;\n                if (isLWTInsert(queryString)) {\n                    lwtOperation = INSERT;\n                }\n                notifyLWTError(lwtResultListeners, new LWTResult(lwtOperation, TypedMap.fromMap(currentValues)));\n            } else {\n                notifyCASSuccess(lwtResultListeners);\n            }\n        }\n        return resultSet;\n    }\n}\n",
        "gt": [
            "'Achilles/achilles-model/src/main/java/info/archinnov/achilles/type/lightweighttransaction/LWTResultListener.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/LWTHelper.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/crud/DeleteWithOptions.java'"
        ]
    },
    {
        "files": [
            "'Achilles/achilles-model/src/main/java/info/archinnov/achilles/type/lightweighttransaction/LWTResultListener.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/crud/DeleteWithOptions.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/LWTHelper.java'"
        ],
        "content": "'Achilles/achilles-model/src/main/java/info/archinnov/achilles/type/lightweighttransaction/LWTResultListener.java'\n:\n\npackage info.archinnov.achilles.type.lightweighttransaction;\n\nimport static java.lang.String.format;\n\nimport info.archinnov.achilles.type.TypedMap;\n\n\npublic interface LWTResultListener {\n\n    default void onSuccess() {\n\n    }\n\n    void onError(LWTResult lwtResult);\n\n\n\n    class LWTResult {\n        private final LWTOperation lwtOperation;\n        private final TypedMap currentValues;\n\n        public LWTResult(LWTOperation lwtOperation, TypedMap currentValues) {\n            this.lwtOperation = lwtOperation;\n            this.currentValues = currentValues;\n        }\n\n        public LWTOperation operation() {\n            return lwtOperation;\n        }\n\n        public TypedMap currentValues() {\n            return currentValues;\n        }\n\n        @Override\n        public String toString() {\n            return format(\"LightWeight Transaction operation %s cannot be applied. Current values are: %s\", lwtOperation, currentValues);\n        }\n\n        public enum LWTOperation {INSERT, UPDATE}\n    }\n}\n\n'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/crud/DeleteWithOptions.java'\n:\n\npackage info.archinnov.achilles.internals.dsl.crud;\n\nimport static info.archinnov.achilles.internals.cache.CacheKey.Operation.DELETE;\nimport static info.archinnov.achilles.internals.cache.CacheKey.Operation.DELETE_IF_EXISTS;\nimport static info.archinnov.achilles.internals.dsl.LWTHelper.triggerLWTListeners;\nimport static info.archinnov.achilles.type.interceptor.Event.POST_DELETE;\nimport static info.archinnov.achilles.type.interceptor.Event.PRE_DELETE;\nimport static java.lang.String.format;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.datastax.driver.core.BoundStatement;\nimport com.datastax.driver.core.ExecutionInfo;\nimport com.datastax.driver.core.PreparedStatement;\nimport com.datastax.driver.core.ResultSet;\n\nimport info.archinnov.achilles.internals.cache.CacheKey;\nimport info.archinnov.achilles.internals.dsl.StatementProvider;\nimport info.archinnov.achilles.internals.dsl.action.MutationAction;\nimport info.archinnov.achilles.internals.dsl.options.AbstractOptionsForUpdateOrDelete;\nimport info.archinnov.achilles.internals.metamodel.AbstractEntityProperty;\nimport info.archinnov.achilles.internals.options.CassandraOptions;\nimport info.archinnov.achilles.internals.runtime.RuntimeEngine;\nimport info.archinnov.achilles.internals.statements.BoundStatementWrapper;\nimport info.archinnov.achilles.internals.statements.OperationType;\nimport info.archinnov.achilles.internals.statements.StatementWrapper;\n\npublic class DeleteWithOptions<ENTITY> extends AbstractOptionsForUpdateOrDelete<DeleteWithOptions<ENTITY>>\n        implements MutationAction, StatementProvider {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(DeleteWithOptions.class);\n\n    private final Class<ENTITY> entityClass;\n    private final AbstractEntityProperty<ENTITY> meta;\n    private final RuntimeEngine rte;\n    private Object[] primaryKeyValues;\n    private Object[] encodedPrimaryKeyValues;\n    private final Optional<ENTITY> instance;\n    private final CassandraOptions options;\n    private Optional<Boolean> ifExists = Optional.empty();\n\n    public DeleteWithOptions(Class<ENTITY> entityClass,\n                             AbstractEntityProperty<ENTITY> meta,\n                             RuntimeEngine rte,\n                             Object[] primaryKeyValues,\n                             Object[] encodedPrimaryKeyValues,\n                             Optional<ENTITY> instance,\n                             Optional<CassandraOptions> cassandraOptions) {\n        this.entityClass = entityClass;\n        this.meta = meta;\n        this.rte = rte;\n        this.primaryKeyValues = primaryKeyValues;\n        this.encodedPrimaryKeyValues = encodedPrimaryKeyValues;\n        this.instance = instance;\n        this.options = cassandraOptions.orElse(new CassandraOptions());\n    }\n\n    public CompletableFuture<ExecutionInfo> executeAsyncWithStats() {\n\n        if (this.instance.isPresent()) {\n            final ENTITY entity = this.instance.get();\n            meta.triggerInterceptorsForEvent(PRE_DELETE, entity);\n        }\n\n        final StatementWrapper statementWrapper = getInternalBoundStatementWrapper();\n        final String queryString = statementWrapper.getBoundStatement().preparedStatement().getQueryString();\n\n        if (LOGGER.isTraceEnabled()) {\n            LOGGER.trace(format(\"Execute delete async with execution info : %s\", queryString));\n        }\n\n        CompletableFuture<ResultSet> cfutureRS = rte.execute(statementWrapper);\n\n        return cfutureRS\n                .thenApply(options::resultSetAsyncListener)\n                .thenApply(statementWrapper::logTrace)\n                .thenApply(x -> triggerLWTListeners(lwtResultListeners, x, queryString))\n                .thenApply(x -> x.getExecutionInfo())\n                .thenApply(x -> {\n                    if (this.instance.isPresent()) meta.triggerInterceptorsForEvent(POST_DELETE, instance.get());\n                    return x;\n                });\n    }\n\n    @Override\n    protected CassandraOptions getOptions() {\n        return options;\n    }\n\n    @Override\n    public BoundStatement generateAndGetBoundStatement() {\n        return getInternalBoundStatementWrapper().getBoundStatement();\n    }\n\n    @Override\n    public String getStatementAsString() {\n        return rte.getStaticCache(new CacheKey(entityClass, DELETE)).getQueryString();\n    }\n\n    @Override\n    public List<Object> getBoundValues() {\n        return Arrays.asList(primaryKeyValues);\n    }\n\n    @Override\n    public List<Object> getEncodedBoundValues() {\n        return Arrays.asList(encodedPrimaryKeyValues);\n    }\n\n    @Override\n    protected DeleteWithOptions<ENTITY> getThis() {\n        return this;\n    }\n\n    private StatementWrapper getInternalBoundStatementWrapper() {\n        if (LOGGER.isTraceEnabled()) {\n            LOGGER.trace(format(\"Generate bound statement wrapper\"));\n        }\n\n        final PreparedStatement ps = getInternalPreparedStatement();\n        final BoundStatementWrapper statementWrapper = new BoundStatementWrapper(OperationType.DELETE, meta, ps, primaryKeyValues, encodedPrimaryKeyValues);\n        statementWrapper.applyOptions(options);\n        return statementWrapper;\n    }\n\n    private PreparedStatement getInternalPreparedStatement() {\n        if (ifExists.isPresent() && ifExists.get() == true) {\n            return DELETE_IF_EXISTS.getPreparedStatement(rte, meta, options);\n        } else {\n            return DELETE.getPreparedStatement(rte, meta, options);\n        }\n    }\n\n    public DeleteWithOptions<ENTITY> ifExists(boolean ifExists) {\n        this.ifExists = Optional.of(ifExists);\n        return this;\n    }\n\n    public DeleteWithOptions<ENTITY> ifExists() {\n        this.ifExists = Optional.of(true);\n        return this;\n    }\n}\n\n'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/LWTHelper.java'\n:\n\npackage info.archinnov.achilles.internals.dsl;\n\nimport static info.archinnov.achilles.type.lightweighttransaction.LWTResultListener.LWTResult.LWTOperation.INSERT;\nimport static info.archinnov.achilles.type.lightweighttransaction.LWTResultListener.LWTResult.LWTOperation.UPDATE;\nimport static java.lang.String.format;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.TreeMap;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.datastax.driver.core.ColumnDefinitions;\nimport com.datastax.driver.core.ResultSet;\nimport com.datastax.driver.core.Row;\n\nimport info.archinnov.achilles.exception.AchillesLightWeightTransactionException;\nimport info.archinnov.achilles.type.TypedMap;\nimport info.archinnov.achilles.type.lightweighttransaction.LWTResultListener;\nimport info.archinnov.achilles.type.lightweighttransaction.LWTResultListener.LWTResult;\nimport info.archinnov.achilles.type.lightweighttransaction.LWTResultListener.LWTResult.LWTOperation;\n\npublic class LWTHelper {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LWTHelper.class);\n\n    private static final String IF_NOT_EXIST_CLAUSE = \" IF NOT EXISTS\";\n    private static final String IF_CLAUSE = \" IF \";\n\n    private static void notifyLWTError(Optional<List<LWTResultListener>> lwtResultListeners, LWTResult lwtResult) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(format(\"Maybe notify listener of LWT error : %s\",\n                    lwtResult));\n        }\n\n        if (lwtResultListeners.isPresent()) {\n            for (LWTResultListener listener : lwtResultListeners.get()) {\n                listener.onError(lwtResult);\n            }\n        } else {\n            throw new AchillesLightWeightTransactionException(lwtResult);\n        }\n    }\n\n    private static void notifyCASSuccess(Optional<List<LWTResultListener>> lwtResultListeners) {\n        if (LOGGER.isDebugEnabled()) {\n            LOGGER.debug(format(\"Maybe notify listener of LWT success\"));\n        }\n        lwtResultListeners.ifPresent(list -> list.forEach(listener -> listener.onSuccess()));\n    }\n\n    private static boolean isLWTOperation(String queryString) {\n        return queryString.contains(IF_CLAUSE);\n    }\n\n    private static boolean isLWTInsert(String queryString) {\n        return queryString.contains(IF_NOT_EXIST_CLAUSE);\n    }\n\n    public static ResultSet triggerLWTListeners(Optional<List<LWTResultListener>> lwtResultListeners, ResultSet resultSet, String queryString) {\n        if (isLWTOperation(queryString)) {\n            if (LOGGER.isDebugEnabled()) {\n                LOGGER.debug(format(\"Trigger LWT listeners for query : %s\", queryString));\n            }\n\n            final Row lwtResult = resultSet.one();\n            if (!resultSet.wasApplied()) {\n                TreeMap<String, Object> currentValues = new TreeMap<>();\n                for (ColumnDefinitions.Definition columnDef : lwtResult.getColumnDefinitions()) {\n                    final String columnDefName = columnDef.getName();\n                    Object columnValue = lwtResult.getObject(columnDefName);\n                    currentValues.put(columnDefName, columnValue);\n                }\n\n                LWTOperation lwtOperation = UPDATE;\n                if (isLWTInsert(queryString)) {\n                    lwtOperation = INSERT;\n                }\n                notifyLWTError(lwtResultListeners, new LWTResult(lwtOperation, TypedMap.fromMap(currentValues)));\n            } else {\n                notifyCASSuccess(lwtResultListeners);\n            }\n        }\n        return resultSet;\n    }\n}\n",
        "gt": [
            "'Achilles/achilles-model/src/main/java/info/archinnov/achilles/type/lightweighttransaction/LWTResultListener.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/LWTHelper.java'",
            "'Achilles/achilles-core/src/main/java/info/archinnov/achilles/internals/dsl/crud/DeleteWithOptions.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n\n'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport com.jnardari.opencv_androidsamples.R;\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Mat;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport android.util.Log;\nimport android.view.SurfaceView;\nimport android.view.WindowManager;\n\npublic class Tutorial1Activity extends AppCompatActivity implements CvCameraViewListener2 {\n    private static final String TAG = \"Tutorial1Activity\";\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n    private boolean              mIsJavaCamera = true;\n    private MenuItem             mItemSwitchCamera = null;\n\n    private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public Tutorial1Activity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_tutorial1);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.tutorial1_activity_java_surface_view);\n\n        mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);\n\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n    }\n\n    public void onCameraViewStopped() {\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        return inputFrame.rgba();\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'"
        ]
    },
    {
        "files": [
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'",
            "'graalvm-demos/espresso-jshell/src/main/java/com/oracle/truffle/espresso/jshell/EspressoLocalExecutionControl.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/ExecutionControlForwarder.java'"
        ],
        "content": "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'\n:\npackage jdk.jshell.execution;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport jdk.jshell.JShellException;\nimport jdk.jshell.spi.ExecutionControl;\nimport static jdk.jshell.execution.ExecutionControlForwarder.NULL_MARKER;\nimport static jdk.jshell.execution.RemoteCodes.*;\n\n\npublic class StreamingExecutionControl implements ExecutionControl {\n\n    private final ObjectOutput out;\n    private final ObjectInput in;\n\n\n    public StreamingExecutionControl(ObjectOutput out, ObjectInput in) {\n        this.out = out;\n        this.in = in;\n    }\n\n    @Override\n    public void load(ClassBytecodes[] cbcs)\n            throws ClassInstallException, NotImplementedException, EngineTerminationException {\n        try {\n\n            writeCommand(CMD_LOAD);\n            out.writeObject(cbcs);\n            out.flush();\n\n            readAndReportClassInstallResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote load: \" + ex);\n        }\n    }\n\n    @Override\n    public void redefine(ClassBytecodes[] cbcs)\n            throws ClassInstallException, NotImplementedException, EngineTerminationException {\n        try {\n\n            writeCommand(CMD_REDEFINE);\n            out.writeObject(cbcs);\n            out.flush();\n\n            readAndReportClassInstallResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote redefine: \" + ex);\n        }\n    }\n\n    @Override\n    public String invoke(String classname, String methodname)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_INVOKE);\n            out.writeUTF(classname);\n            out.writeUTF(methodname);\n            out.flush();\n\n            readAndReportExecutionResult();\n            String result = in.readUTF();\n            return result;\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote invoke: \" + ex);\n        }\n    }\n\n    @Override\n    public String varValue(String classname, String varname)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_VAR_VALUE);\n            out.writeUTF(classname);\n            out.writeUTF(varname);\n            out.flush();\n\n            readAndReportExecutionResult();\n            String result = in.readUTF();\n            return result;\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote varValue: \" + ex);\n        }\n    }\n\n\n    @Override\n    public void addToClasspath(String path)\n            throws EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_ADD_CLASSPATH);\n            out.writeUTF(path);\n            out.flush();\n\n            readAndReportClassSimpleResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote add to classpath: \" + ex);\n        }\n    }\n\n    @Override\n    public void stop()\n            throws EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_STOP);\n            out.flush();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote stop: \" + ex);\n        }\n    }\n\n    @Override\n    public Object extensionCommand(String command, Object arg)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n            writeCommand(command);\n            out.writeObject(arg);\n            out.flush();\n\n            readAndReportExecutionResult();\n            Object result = in.readObject();\n            return result;\n        } catch (IOException | ClassNotFoundException ex) {\n            throw new EngineTerminationException(\"Exception transmitting remote extensionCommand: \"\n                    + command + \" -- \" + ex);\n        }\n    }\n\n\n    @Override\n    public void close() {\n        try {\n            writeCommand(CMD_CLOSE);\n            out.flush();\n        } catch (IOException ex) {\n\n        }\n    }\n\n    private void writeCommand(String cmd) throws IOException {\n        out.writeInt(COMMAND_PREFIX);\n        out.writeUTF(cmd);\n    }\n\n\n    private String readNullOrUTF() throws IOException {\n        String s = in.readUTF();\n        return s.equals(NULL_MARKER) ? null : s;\n    }\n\n\n    private void readAndReportClassSimpleResult() throws EngineTerminationException, InternalException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_INTERNAL_PROBLEM: {\n                    String message = in.readUTF();\n                    throw new InternalException(message);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException ex) {\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n\n    private void readAndReportClassInstallResult() throws ClassInstallException,\n            NotImplementedException, EngineTerminationException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_CLASS_INSTALL_EXCEPTION: {\n                    String message = in.readUTF();\n                    boolean[] loaded = (boolean[]) in.readObject();\n                    throw new ClassInstallException(message, loaded);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException | ClassNotFoundException ex) {\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n\n    private void readAndReportExecutionResult() throws RunException,\n            EngineTerminationException, InternalException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_USER_EXCEPTION: {\n\n                    throw readUserException();\n                }\n                case RESULT_CORRALLED: {\n\n                    throw readResolutionException();\n                }\n                case RESULT_USER_EXCEPTION_CHAINED: {\n\n                    in.readInt();\n                    UserException result = readUserException();\n                    RunException caused = result;\n\n                    loop: while (true) {\n                        RunException ex;\n                        int cstatus = in.readInt();\n                        switch (cstatus) {\n                            case RESULT_USER_EXCEPTION: {\n\n                                ex = readUserException();\n                                break;\n                            }\n                            case RESULT_CORRALLED: {\n\n                                ex = readResolutionException();\n                                break;\n                            }\n                            case RESULT_SUCCESS: {\n\n                                break loop;\n                            }\n                            default: {\n                                throw new EngineTerminationException(\"Bad chained remote result code: \" + cstatus);\n                            }\n                        }\n                        caused.initCause(ex);\n                        caused = ex;\n                    }\n                    caused.initCause(null);\n                    throw result;\n                }\n                case RESULT_STOPPED: {\n\n                    throw new StoppedException();\n                }\n                case RESULT_INTERNAL_PROBLEM: {\n\n                    String message = in.readUTF();\n                    throw new InternalException(message);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException | ClassNotFoundException ex) {\n            ex.printStackTrace();\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n    private UserException readUserException() throws IOException, ClassNotFoundException {\n        String message = readNullOrUTF();\n        String exceptionClassName = in.readUTF();\n        StackTraceElement[] elems = (StackTraceElement[]) in.readObject();\n        return new UserException(message, exceptionClassName, elems);\n    }\n\n    private ResolutionException readResolutionException() throws IOException, ClassNotFoundException {\n        int id = in.readInt();\n        StackTraceElement[] elems = (StackTraceElement[]) in.readObject();\n        return new ResolutionException(id, elems);\n    }\n}\n\n'graalvm-demos/espresso-jshell/src/main/java/com/oracle/truffle/espresso/jshell/EspressoLocalExecutionControl.java'\n:\npackage com.oracle.truffle.espresso.jshell;\n\nimport org.graalvm.polyglot.Context;\nimport org.graalvm.polyglot.Engine;\nimport org.graalvm.polyglot.Value;\n\nimport java.nio.file.Path;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic final class EspressoLocalExecutionControl extends EspressoExecutionControl {\n\n    private static Map<String, String> contextOptions;\n\n    public static void initializeInParallel(Map<String, String> options) {\n\n        contextOptions = (options != null) ? options : Collections.emptyMap();\n        new Thread(LocalExecutionControl::get).start();\n    }\n\n    protected static final Lazy<Context> context = Lazy.of(() -> {\n        return Context.newBuilder(\"java\")\n                .options(contextOptions)\n                .allowAllAccess(true)\n                .build();\n    });\n\n    protected static final Lazy<Value> LocalExecutionControl = Lazy.of(() -> loadClass(context.get(), \"jdk.jshell.execution.LocalExecutionControl\"));\n    protected static final Lazy<Value> java_lang_System = Lazy.of(() -> loadClass(context.get(), \"java.lang.System\"));\n\n    private static Value loadClass(Context context, String className) {\n        return context.getBindings(\"java\").getMember(className);\n    }\n\n    @Override\n    public Value loadClass(String className) {\n        return loadClass(context.get(), className);\n    }\n\n    public EspressoLocalExecutionControl(List<String> extraRemoteOptions) {\n        super(Lazy.of(() -> {\n            Value ec = LocalExecutionControl.get().newInstance();\n            for (int i = 0; i < extraRemoteOptions.size(); ++i) {\n                String option = extraRemoteOptions.get(i);\n                if (\"--class-path\".equals(option) || \"-class-path\".equals(option)) {\n                    if (i + 1 < extraRemoteOptions.size()) {\n                        ec.invokeMember(\"addToClasspath\", extraRemoteOptions.get(i + 1));\n                        ++i;\n                    }\n                }\n            }\n            return ec;\n        }));\n    }\n}\n",
        "gt": [
            "'graalvm-demos/espresso-jshell/src/main/java/com/oracle/truffle/espresso/jshell/EspressoLocalExecutionControl.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/ExecutionControlForwarder.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'"
        ],
        "content": "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.netflix.iceberg.Files;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.io.CloseableIterable;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.junit.Assert;\nimport org.junit.Assume;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.spark.data.TestHelpers.assertEqualsUnsafe;\n\npublic class TestSparkParquetReader extends AvroDataTest {\n  protected void writeAndValidate(Schema schema) throws IOException {\n    Assume.assumeTrue(\"Parquet Avro cannot write non-string map keys\", null == TypeUtil.find(schema,\n        type -> type.isMapType() && type.asMapType().keyType() != Types.StringType.get()));\n\n    List<GenericData.Record> expected = RandomData.generateList(schema, 100, 0L);\n\n    File testFile = temp.newFile();\n    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n\n    try (FileAppender<GenericData.Record> writer = Parquet.write(Files.localOutput(testFile))\n        .schema(schema)\n        .named(\"test\")\n        .build()) {\n      writer.addAll(expected);\n    }\n\n    try (CloseableIterable<InternalRow> reader = Parquet.read(Files.localInput(testFile))\n        .project(schema)\n        .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n        .build()) {\n      Iterator<InternalRow> rows = reader.iterator();\n      for (int i = 0; i < expected.size(); i += 1) {\n        Assert.assertTrue(\"Should have expected number of rows\", rows.hasNext());\n        assertEqualsUnsafe(schema.asStruct(), expected.get(i), rows.next());\n      }\n      Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n    }\n  }\n}\n\n'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'\n:\n\npackage com.netflix.iceberg.types;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic class TypeUtil {\n  public static Schema select(Schema schema, Set<Integer> fieldIds) {\n    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n    Preconditions.checkNotNull(fieldIds, \"Field ids cannot be null\");\n\n    Type result = visit(schema, new PruneColumns(fieldIds));\n    if (schema.asStruct() == result) {\n      return schema;\n    } else if (result != null) {\n      if (schema.getAliases() != null) {\n        return new Schema(result.asNestedType().fields(), schema.getAliases());\n      } else {\n        return new Schema(result.asNestedType().fields());\n      }\n    }\n\n    return new Schema(ImmutableList.of(), schema.getAliases());\n  }\n\n  public static Set<Integer> getProjectedIds(Schema schema) {\n    return visit(schema, new GetProjectedIds());\n  }\n\n  public static Set<Integer> getProjectedIds(Type schema) {\n    if (schema.isPrimitiveType()) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(visit(schema, new GetProjectedIds()));\n  }\n\n  public static Schema selectNot(Schema schema, Set<Integer> fieldIds) {\n    Set<Integer> projectedIds = getProjectedIds(schema);\n    projectedIds.removeAll(fieldIds);\n    return select(schema, projectedIds);\n  }\n\n  public static Schema join(Schema left, Schema right) {\n    List<Types.NestedField> joinedColumns = Lists.newArrayList();\n    joinedColumns.addAll(left.columns());\n    joinedColumns.addAll(right.columns());\n    return new Schema(joinedColumns);\n  }\n\n  public static Map<String, Integer> indexByName(Types.StructType struct) {\n    return visit(struct, new IndexByName());\n  }\n\n  public static Map<Integer, Types.NestedField> indexById(Types.StructType struct) {\n    return visit(struct, new IndexById());\n  }\n\n\n  public static Type assignFreshIds(Type type, NextID nextId) {\n    return TypeUtil.visit(type, new AssignFreshIds(nextId));\n  }\n\n\n  public static Schema assignFreshIds(Schema schema, NextID nextId) {\n    return new Schema(TypeUtil\n        .visit(schema.asStruct(), new AssignFreshIds(nextId))\n        .asNestedType()\n        .fields());\n  }\n\n\n  public static Schema reassignIds(Schema schema, Schema idSourceSchema) {\n    Types.StructType struct = visit(schema, new ReassignIds(idSourceSchema)).asStructType();\n    return new Schema(struct.fields());\n  }\n\n  public static Type find(Schema schema, Predicate<Type> predicate) {\n    return visit(schema, new FindTypeVisitor(predicate));\n  }\n\n  public static boolean isPromotionAllowed(Type from, Type.PrimitiveType to) {\n\n\n    if (from.equals(to)) {\n      return true;\n    }\n\n    switch (from.typeId()) {\n      case INTEGER:\n        return to == Types.LongType.get();\n\n      case FLOAT:\n        return to == Types.DoubleType.get();\n\n      case DECIMAL:\n        Types.DecimalType fromDecimal = (Types.DecimalType) from;\n        if (to.typeId() != Type.TypeID.DECIMAL) {\n          return false;\n        }\n\n        Types.DecimalType toDecimal = (Types.DecimalType) to;\n        return (fromDecimal.scale() == toDecimal.scale() &&\n            fromDecimal.precision() <= toDecimal.precision());\n    }\n\n    return false;\n  }\n\n\n  public interface NextID {\n    int get();\n  }\n\n  public static class SchemaVisitor<T> {\n    protected LinkedList<String> fieldNames = Lists.newLinkedList();\n    protected LinkedList<Integer> fieldIds = Lists.newLinkedList();\n\n    public T schema(Schema schema, T structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, List<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, T fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, T elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, T keyResult, T valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  public static <T> T visit(Schema schema, SchemaVisitor<T> visitor) {\n    return visitor.schema(schema, visit(schema.asStruct(), visitor));\n  }\n\n  public static <T> T visit(Type type, SchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<T> results = Lists.newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          visitor.fieldIds.push(field.fieldId());\n          visitor.fieldNames.push(field.name());\n          T result;\n          try {\n            result = visit(field.type(), visitor);\n          } finally {\n            visitor.fieldIds.pop();\n            visitor.fieldNames.pop();\n          }\n          results.add(visitor.field(field, result));\n        }\n        return visitor.struct(struct, results);\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        T elementResult;\n\n        visitor.fieldIds.push(list.elementId());\n        try {\n          elementResult = visit(list.elementType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.list(list, elementResult);\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        T keyResult;\n        T valueResult;\n\n        visitor.fieldIds.push(map.keyId());\n        try {\n          keyResult = visit(map.keyType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        visitor.fieldIds.push(map.valueId());\n        try {\n          valueResult = visit(map.valueType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.map(map, keyResult, valueResult);\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  public static class CustomOrderSchemaVisitor<T> {\n    public T schema(Schema schema, Supplier<T> structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, Iterable<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, Supplier<T> fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, Supplier<T> elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, Supplier<T> keyResult, Supplier<T> valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  private static class VisitFuture<T> implements Supplier<T> {\n    private final Type type;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFuture(Type type, CustomOrderSchemaVisitor<T> visitor) {\n      this.type = type;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visit(type, visitor);\n    }\n  }\n\n  private static class VisitFieldFuture<T> implements Supplier<T> {\n    private final Types.NestedField field;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFieldFuture(Types.NestedField field, CustomOrderSchemaVisitor<T> visitor) {\n      this.field = field;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visitor.field(field, new VisitFuture<>(field.type(), visitor));\n    }\n  }\n\n  public static <T> T visit(Schema schema, CustomOrderSchemaVisitor<T> visitor) {\n    return visitor.schema(schema, new VisitFuture<>(schema.asStruct(), visitor));\n  }\n\n\n  public static <T> T visit(Type type, CustomOrderSchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<VisitFieldFuture<T>> results = Lists\n            .newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          results.add(\n              new VisitFieldFuture<>(field, visitor));\n        }\n\n        return visitor.struct(struct, Iterables.transform(results, VisitFieldFuture::get));\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        return visitor.list(list, new VisitFuture<>(list.elementType(), visitor));\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        return visitor.map(map,\n            new VisitFuture<>(map.keyType(), visitor),\n            new VisitFuture<>(map.valueType(), visitor));\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  static int decimalMaxPrecision(int numBytes) {\n    Preconditions.checkArgument(numBytes >= 0 && numBytes < 24,\n        \"Unsupported decimal length: \" + numBytes);\n    return MAX_PRECISION[numBytes];\n  }\n\n  public static int decimalRequriedBytes(int precision) {\n    Preconditions.checkArgument(precision >= 0 && precision < 40,\n        \"Unsupported decimal precision: \" + precision);\n    return REQUIRED_LENGTH[precision];\n  }\n\n  private static int[] MAX_PRECISION = new int[24];\n  private static int[] REQUIRED_LENGTH = new int[40];\n\n  static {\n\n    for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n      MAX_PRECISION[len] = (int) Math.floor(Math.log10(Math.pow(2, 8*len - 1) - 1));\n    }\n\n\n    for (int precision = 0; precision < REQUIRED_LENGTH.length; precision += 1) {\n      REQUIRED_LENGTH[precision] = -1;\n      for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n\n        if (precision <= MAX_PRECISION[len]) {\n          REQUIRED_LENGTH[precision] = len;\n          break;\n        }\n      }\n      if (REQUIRED_LENGTH[precision] < 0) {\n        throw new IllegalStateException(\n            \"Could not find required length for precision \" + precision);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'"
        ],
        "content": "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.netflix.iceberg.Files;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.io.CloseableIterable;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.junit.Assert;\nimport org.junit.Assume;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.spark.data.TestHelpers.assertEqualsUnsafe;\n\npublic class TestSparkParquetReader extends AvroDataTest {\n  protected void writeAndValidate(Schema schema) throws IOException {\n    Assume.assumeTrue(\"Parquet Avro cannot write non-string map keys\", null == TypeUtil.find(schema,\n        type -> type.isMapType() && type.asMapType().keyType() != Types.StringType.get()));\n\n    List<GenericData.Record> expected = RandomData.generateList(schema, 100, 0L);\n\n    File testFile = temp.newFile();\n    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n\n    try (FileAppender<GenericData.Record> writer = Parquet.write(Files.localOutput(testFile))\n        .schema(schema)\n        .named(\"test\")\n        .build()) {\n      writer.addAll(expected);\n    }\n\n    try (CloseableIterable<InternalRow> reader = Parquet.read(Files.localInput(testFile))\n        .project(schema)\n        .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n        .build()) {\n      Iterator<InternalRow> rows = reader.iterator();\n      for (int i = 0; i < expected.size(); i += 1) {\n        Assert.assertTrue(\"Should have expected number of rows\", rows.hasNext());\n        assertEqualsUnsafe(schema.asStruct(), expected.get(i), rows.next());\n      }\n      Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n    }\n  }\n}\n\n'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'\n:\n\npackage com.netflix.iceberg.types;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic class TypeUtil {\n  public static Schema select(Schema schema, Set<Integer> fieldIds) {\n    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n    Preconditions.checkNotNull(fieldIds, \"Field ids cannot be null\");\n\n    Type result = visit(schema, new PruneColumns(fieldIds));\n    if (schema.asStruct() == result) {\n      return schema;\n    } else if (result != null) {\n      if (schema.getAliases() != null) {\n        return new Schema(result.asNestedType().fields(), schema.getAliases());\n      } else {\n        return new Schema(result.asNestedType().fields());\n      }\n    }\n\n    return new Schema(ImmutableList.of(), schema.getAliases());\n  }\n\n  public static Set<Integer> getProjectedIds(Schema schema) {\n    return visit(schema, new GetProjectedIds());\n  }\n\n  public static Set<Integer> getProjectedIds(Type schema) {\n    if (schema.isPrimitiveType()) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(visit(schema, new GetProjectedIds()));\n  }\n\n  public static Schema selectNot(Schema schema, Set<Integer> fieldIds) {\n    Set<Integer> projectedIds = getProjectedIds(schema);\n    projectedIds.removeAll(fieldIds);\n    return select(schema, projectedIds);\n  }\n\n  public static Schema join(Schema left, Schema right) {\n    List<Types.NestedField> joinedColumns = Lists.newArrayList();\n    joinedColumns.addAll(left.columns());\n    joinedColumns.addAll(right.columns());\n    return new Schema(joinedColumns);\n  }\n\n  public static Map<String, Integer> indexByName(Types.StructType struct) {\n    return visit(struct, new IndexByName());\n  }\n\n  public static Map<Integer, Types.NestedField> indexById(Types.StructType struct) {\n    return visit(struct, new IndexById());\n  }\n\n\n  public static Type assignFreshIds(Type type, NextID nextId) {\n    return TypeUtil.visit(type, new AssignFreshIds(nextId));\n  }\n\n\n  public static Schema assignFreshIds(Schema schema, NextID nextId) {\n    return new Schema(TypeUtil\n        .visit(schema.asStruct(), new AssignFreshIds(nextId))\n        .asNestedType()\n        .fields());\n  }\n\n\n  public static Schema reassignIds(Schema schema, Schema idSourceSchema) {\n    Types.StructType struct = visit(schema, new ReassignIds(idSourceSchema)).asStructType();\n    return new Schema(struct.fields());\n  }\n\n  public static Type find(Schema schema, Predicate<Type> predicate) {\n    return visit(schema, new FindTypeVisitor(predicate));\n  }\n\n  public static boolean isPromotionAllowed(Type from, Type.PrimitiveType to) {\n\n\n    if (from.equals(to)) {\n      return true;\n    }\n\n    switch (from.typeId()) {\n      case INTEGER:\n        return to == Types.LongType.get();\n\n      case FLOAT:\n        return to == Types.DoubleType.get();\n\n      case DECIMAL:\n        Types.DecimalType fromDecimal = (Types.DecimalType) from;\n        if (to.typeId() != Type.TypeID.DECIMAL) {\n          return false;\n        }\n\n        Types.DecimalType toDecimal = (Types.DecimalType) to;\n        return (fromDecimal.scale() == toDecimal.scale() &&\n            fromDecimal.precision() <= toDecimal.precision());\n    }\n\n    return false;\n  }\n\n\n  public interface NextID {\n    int get();\n  }\n\n  public static class SchemaVisitor<T> {\n    protected LinkedList<String> fieldNames = Lists.newLinkedList();\n    protected LinkedList<Integer> fieldIds = Lists.newLinkedList();\n\n    public T schema(Schema schema, T structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, List<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, T fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, T elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, T keyResult, T valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  public static <T> T visit(Schema schema, SchemaVisitor<T> visitor) {\n    return visitor.schema(schema, visit(schema.asStruct(), visitor));\n  }\n\n  public static <T> T visit(Type type, SchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<T> results = Lists.newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          visitor.fieldIds.push(field.fieldId());\n          visitor.fieldNames.push(field.name());\n          T result;\n          try {\n            result = visit(field.type(), visitor);\n          } finally {\n            visitor.fieldIds.pop();\n            visitor.fieldNames.pop();\n          }\n          results.add(visitor.field(field, result));\n        }\n        return visitor.struct(struct, results);\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        T elementResult;\n\n        visitor.fieldIds.push(list.elementId());\n        try {\n          elementResult = visit(list.elementType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.list(list, elementResult);\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        T keyResult;\n        T valueResult;\n\n        visitor.fieldIds.push(map.keyId());\n        try {\n          keyResult = visit(map.keyType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        visitor.fieldIds.push(map.valueId());\n        try {\n          valueResult = visit(map.valueType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.map(map, keyResult, valueResult);\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  public static class CustomOrderSchemaVisitor<T> {\n    public T schema(Schema schema, Supplier<T> structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, Iterable<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, Supplier<T> fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, Supplier<T> elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, Supplier<T> keyResult, Supplier<T> valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  private static class VisitFuture<T> implements Supplier<T> {\n    private final Type type;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFuture(Type type, CustomOrderSchemaVisitor<T> visitor) {\n      this.type = type;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visit(type, visitor);\n    }\n  }\n\n  private static class VisitFieldFuture<T> implements Supplier<T> {\n    private final Types.NestedField field;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFieldFuture(Types.NestedField field, CustomOrderSchemaVisitor<T> visitor) {\n      this.field = field;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visitor.field(field, new VisitFuture<>(field.type(), visitor));\n    }\n  }\n\n  public static <T> T visit(Schema schema, CustomOrderSchemaVisitor<T> visitor) {\n    return visitor.schema(schema, new VisitFuture<>(schema.asStruct(), visitor));\n  }\n\n\n  public static <T> T visit(Type type, CustomOrderSchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<VisitFieldFuture<T>> results = Lists\n            .newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          results.add(\n              new VisitFieldFuture<>(field, visitor));\n        }\n\n        return visitor.struct(struct, Iterables.transform(results, VisitFieldFuture::get));\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        return visitor.list(list, new VisitFuture<>(list.elementType(), visitor));\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        return visitor.map(map,\n            new VisitFuture<>(map.keyType(), visitor),\n            new VisitFuture<>(map.valueType(), visitor));\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  static int decimalMaxPrecision(int numBytes) {\n    Preconditions.checkArgument(numBytes >= 0 && numBytes < 24,\n        \"Unsupported decimal length: \" + numBytes);\n    return MAX_PRECISION[numBytes];\n  }\n\n  public static int decimalRequriedBytes(int precision) {\n    Preconditions.checkArgument(precision >= 0 && precision < 40,\n        \"Unsupported decimal precision: \" + precision);\n    return REQUIRED_LENGTH[precision];\n  }\n\n  private static int[] MAX_PRECISION = new int[24];\n  private static int[] REQUIRED_LENGTH = new int[40];\n\n  static {\n\n    for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n      MAX_PRECISION[len] = (int) Math.floor(Math.log10(Math.pow(2, 8*len - 1) - 1));\n    }\n\n\n    for (int precision = 0; precision < REQUIRED_LENGTH.length; precision += 1) {\n      REQUIRED_LENGTH[precision] = -1;\n      for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n\n        if (precision <= MAX_PRECISION[len]) {\n          REQUIRED_LENGTH[precision] = len;\n          break;\n        }\n      }\n      if (REQUIRED_LENGTH[precision] < 0) {\n        throw new IllegalStateException(\n            \"Could not find required length for precision \" + precision);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/utils/calibration/OnCameraFrameRender.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/utils/calibration/OnCameraFrameRender.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Paint.Align;\nimport android.graphics.Paint.Style;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.Nullable;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.MONTH_NAVIGATION_BAR_SIZE;\n\n\npublic final class MonthPickerView extends View {\n    private static final String TAG = \"MonthPickerView\";\n\n    private static final int NUM_COLUMNS = 3;\n    private static final int NUM_ROWS = 4;\n    private static final int MONTH_SEPARATOR_WIDTH = 1;\n\n    private static int MONTH_LABEL_TEXT_SIZE;\n    private static int MONTH_SELECTED_CIRCLE_SIZE;\n\n\n    private int mEdgePadding = 0;\n\n    private Paint mMonthLabelPaint;\n    private Paint mSelectedCirclePaint;\n\n\n    private int mWidth;\n    private int mRowHeight;\n    private CalendarDay mSelectedDay;\n\n    private int mYear;\n\n    private final int mCurrentMonth;\n\n    private final int mCurrentYear;\n\n    private final String[] mShortMonthLabels;\n\n    @Nullable\n    private DateRangeHelper mDateRangeHelper;\n    @Nullable\n    private OnMonthClickListener mOnMonthClickListener;\n\n    private int mNormalTextColor;\n    private int mCurrentMonthTextColor;\n    private int mDisabledMonthTextColor;\n    private int mSelectedMonthTextColor;\n\n    public MonthPickerView(Context context) {\n        this(context, null);\n    }\n\n    public MonthPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        Resources res = context.getResources();\n\n        mShortMonthLabels = new DateFormatSymbols().getShortMonths();\n\n        mNormalTextColor = getColor(context, R.color.bsp_text_color_primary_light);\n\n        mSelectedMonthTextColor = getColor(context, R.color.bsp_date_picker_view_animator);\n        mCurrentMonthTextColor = Utils.getThemeAccentColor(context);\n        mDisabledMonthTextColor = getColor(context, R.color.bsp_text_color_disabled_light);\n\n        Calendar now = Calendar.getInstance();\n        mCurrentMonth = now.get(Calendar.MONTH);\n        mCurrentYear = now.get(Calendar.YEAR);\n\n        MONTH_LABEL_TEXT_SIZE = res.getDimensionPixelSize(R.dimen.bsp_month_picker_month_label_size);\n        MONTH_SELECTED_CIRCLE_SIZE = res.getDimensionPixelSize(R.dimen.bsp_month_select_circle_radius);\n\n        mRowHeight = (res.getDimensionPixelOffset(R.dimen.bsp_date_picker_view_animator_height)\n                - MONTH_NAVIGATION_BAR_SIZE) / NUM_ROWS;\n        mEdgePadding = res.getDimensionPixelSize(R.dimen.bsp_month_view_edge_padding);\n\n\n\n        initView();\n    }\n\n\n    void setDisplayParams(CalendarDay selectedDay, int year) {\n        mSelectedDay = selectedDay;\n        mYear = year;\n\n\n\n    }\n\n\n    private void adjustDayInMonthIfNeeded(int month) {\n        int daysInMonth = Utils.getDaysInMonth(month, mYear);\n        if (mSelectedDay.day > daysInMonth) {\n            mSelectedDay.day = daysInMonth;\n        }\n    }\n\n    private int constrainDayInMonth(int month, int defaultDay) {\n        int daysInMonth = Utils.getDaysInMonth(month, mYear);\n        return Math.min(defaultDay, daysInMonth);\n    }\n\n    public void setDatePickerController(DatePickerController controller) {\n        mDateRangeHelper = new DateRangeHelper(controller);\n    }\n\n    public void setOnMonthClickListener(@Nullable OnMonthClickListener onMonthClickListener) {\n        mOnMonthClickListener = onMonthClickListener;\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        if (themeDark) {\n            mNormalTextColor = getColor(context, R.color.bsp_text_color_primary_dark);\n            mSelectedMonthTextColor = getColor(context, R.color.bsp_dark_gray);\n            mDisabledMonthTextColor = getColor(context, R.color.bsp_text_color_disabled_dark);\n            initView();\n        }\n    }\n\n\n    void setCurrentMonthTextColor(@ColorInt int color) {\n        mCurrentMonthTextColor = color;\n    }\n\n\n    void setSelectedCirclePaintColor(@ColorInt int color) {\n        mSelectedCirclePaint.setColor(color);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_UP:\n                final int month = getMonthFromLocation(event.getX(), event.getY());\n                if (month >= 0) {\n                    onMonthClick(month);\n                }\n                break;\n        }\n        return true;\n    }\n\n\n    protected void initView() {\n        mMonthLabelPaint = new Paint();\n        mMonthLabelPaint.setAntiAlias(true);\n        mMonthLabelPaint.setTextSize(MONTH_LABEL_TEXT_SIZE);\n        mMonthLabelPaint.setStyle(Style.FILL);\n        mMonthLabelPaint.setTextAlign(Align.CENTER);\n        mMonthLabelPaint.setFakeBoldText(false);\n\n        mSelectedCirclePaint = new Paint();\n        mSelectedCirclePaint.setFakeBoldText(true);\n        mSelectedCirclePaint.setAntiAlias(true);\n        mSelectedCirclePaint.setColor(mCurrentMonthTextColor);\n        mSelectedCirclePaint.setTextAlign(Align.CENTER);\n        mSelectedCirclePaint.setStyle(Style.FILL);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), mRowHeight * NUM_ROWS\n                + MONTH_NAVIGATION_BAR_SIZE);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        mWidth = w;\n\n\n\n    }\n\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        drawMonthLabels(canvas);\n    }\n\n    private void drawMonthLabels(Canvas canvas) {\n        int y = (((mRowHeight + MONTH_LABEL_TEXT_SIZE) / 2) - MONTH_SEPARATOR_WIDTH);\n        final float monthWidthHalf = (mWidth - mEdgePadding * 2) / (NUM_COLUMNS * 2.0f);\n        int col = 0;\n        for (int month = Calendar.JANUARY; month <= Calendar.DECEMBER; month++) {\n            final int x = (int)((2 * col + 1) * monthWidthHalf + mEdgePadding);\n\n\n\n\n            int constrainedDay = constrainDayInMonth(month, mSelectedDay.day);\n            drawMonthLabel(canvas, mYear, month, constrainedDay, x, y);\n            col++;\n            if (col == NUM_COLUMNS) {\n                col = 0;\n                y += mRowHeight;\n            }\n        }\n    }\n\n    private void drawMonthLabel(Canvas canvas, int year, int month, int day, int x, int y) {\n        final int selectedYear = mSelectedDay.year;\n        final int selectedMonth = mSelectedDay.month;\n\n        boolean drawCircle = selectedYear == year && selectedMonth == month;\n        if (drawCircle) {\n            canvas.drawCircle(x , y - (MONTH_LABEL_TEXT_SIZE / 3), MONTH_SELECTED_CIRCLE_SIZE,\n                    mSelectedCirclePaint);\n        }\n\n\n\n        if (mDateRangeHelper != null && mDateRangeHelper.isOutOfRange(year, month, day)) {\n            mMonthLabelPaint.setFakeBoldText(false);\n            mMonthLabelPaint.setColor(mDisabledMonthTextColor);\n        } else {\n            boolean currentMonthYear = mCurrentYear == year && mCurrentMonth == month;\n            mMonthLabelPaint.setFakeBoldText(currentMonthYear || drawCircle);\n            mMonthLabelPaint.setColor(drawCircle ? mSelectedMonthTextColor :\n                    (currentMonthYear ? mCurrentMonthTextColor : mNormalTextColor));\n        }\n        canvas.drawText(mShortMonthLabels[month], x, y, mMonthLabelPaint);\n    }\n\n\n    public int getMonthFromLocation(float x, float y) {\n        final int month = getInternalMonthFromLocation(x, y);\n        if (month < Calendar.JANUARY || month > Calendar.DECEMBER) {\n            return -1;\n        }\n        return month;\n    }\n\n\n    protected int getInternalMonthFromLocation(float x, float y) {\n        int monthStart = mEdgePadding;\n        if (x < monthStart || x > mWidth - mEdgePadding) {\n\n            return -1;\n        }\n        int row = (int) (y / mRowHeight);\n\n        int column = (int) ((x - monthStart) * NUM_COLUMNS / (mWidth - mEdgePadding * 2));\n\n        int month = column;\n        month += row * NUM_COLUMNS;\n        return month;\n    }\n\n\n    private void onMonthClick(int month) {\n        adjustDayInMonthIfNeeded(month);\n\n        if (mDateRangeHelper != null && mDateRangeHelper.isOutOfRange(mYear, month, mSelectedDay.day)) {\n            return;\n        }\n\n        if (mOnMonthClickListener != null) {\n            mOnMonthClickListener.onMonthClick(this, month, mYear);\n        }\n\n\n\n    }\n\n    interface OnMonthClickListener {\n        void onMonthClick(MonthPickerView view, int month, int year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'\n:package com.philliphsu.bottomsheetpickers.date;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.Paint.Align;\nimport android.graphics.Paint.Style;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.Nullable;\nimport android.util.AttributeSet;\nimport android.view.MotionEvent;\nimport android.view.View;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\n\nimport java.text.DateFormatSymbols;\nimport java.util.Calendar;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static com.philliphsu.bottomsheetpickers.date.PagingDayPickerView.MONTH_NAVIGATION_BAR_SIZE;\n\n\npublic final class MonthPickerView extends View {\n    private static final String TAG = \"MonthPickerView\";\n\n    private static final int NUM_COLUMNS = 3;\n    private static final int NUM_ROWS = 4;\n    private static final int MONTH_SEPARATOR_WIDTH = 1;\n\n    private static int MONTH_LABEL_TEXT_SIZE;\n    private static int MONTH_SELECTED_CIRCLE_SIZE;\n\n\n    private int mEdgePadding = 0;\n\n    private Paint mMonthLabelPaint;\n    private Paint mSelectedCirclePaint;\n\n\n    private int mWidth;\n    private int mRowHeight;\n    private CalendarDay mSelectedDay;\n\n    private int mYear;\n\n    private final int mCurrentMonth;\n\n    private final int mCurrentYear;\n\n    private final String[] mShortMonthLabels;\n\n    @Nullable\n    private DateRangeHelper mDateRangeHelper;\n    @Nullable\n    private OnMonthClickListener mOnMonthClickListener;\n\n    private int mNormalTextColor;\n    private int mCurrentMonthTextColor;\n    private int mDisabledMonthTextColor;\n    private int mSelectedMonthTextColor;\n\n    public MonthPickerView(Context context) {\n        this(context, null);\n    }\n\n    public MonthPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        Resources res = context.getResources();\n\n        mShortMonthLabels = new DateFormatSymbols().getShortMonths();\n\n        mNormalTextColor = getColor(context, R.color.bsp_text_color_primary_light);\n\n        mSelectedMonthTextColor = getColor(context, R.color.bsp_date_picker_view_animator);\n        mCurrentMonthTextColor = Utils.getThemeAccentColor(context);\n        mDisabledMonthTextColor = getColor(context, R.color.bsp_text_color_disabled_light);\n\n        Calendar now = Calendar.getInstance();\n        mCurrentMonth = now.get(Calendar.MONTH);\n        mCurrentYear = now.get(Calendar.YEAR);\n\n        MONTH_LABEL_TEXT_SIZE = res.getDimensionPixelSize(R.dimen.bsp_month_picker_month_label_size);\n        MONTH_SELECTED_CIRCLE_SIZE = res.getDimensionPixelSize(R.dimen.bsp_month_select_circle_radius);\n\n        mRowHeight = (res.getDimensionPixelOffset(R.dimen.bsp_date_picker_view_animator_height)\n                - MONTH_NAVIGATION_BAR_SIZE) / NUM_ROWS;\n        mEdgePadding = res.getDimensionPixelSize(R.dimen.bsp_month_view_edge_padding);\n\n\n\n        initView();\n    }\n\n\n    void setDisplayParams(CalendarDay selectedDay, int year) {\n        mSelectedDay = selectedDay;\n        mYear = year;\n\n\n\n    }\n\n\n    private void adjustDayInMonthIfNeeded(int month) {\n        int daysInMonth = Utils.getDaysInMonth(month, mYear);\n        if (mSelectedDay.day > daysInMonth) {\n            mSelectedDay.day = daysInMonth;\n        }\n    }\n\n    private int constrainDayInMonth(int month, int defaultDay) {\n        int daysInMonth = Utils.getDaysInMonth(month, mYear);\n        return Math.min(defaultDay, daysInMonth);\n    }\n\n    public void setDatePickerController(DatePickerController controller) {\n        mDateRangeHelper = new DateRangeHelper(controller);\n    }\n\n    public void setOnMonthClickListener(@Nullable OnMonthClickListener onMonthClickListener) {\n        mOnMonthClickListener = onMonthClickListener;\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        if (themeDark) {\n            mNormalTextColor = getColor(context, R.color.bsp_text_color_primary_dark);\n            mSelectedMonthTextColor = getColor(context, R.color.bsp_dark_gray);\n            mDisabledMonthTextColor = getColor(context, R.color.bsp_text_color_disabled_dark);\n            initView();\n        }\n    }\n\n\n    void setCurrentMonthTextColor(@ColorInt int color) {\n        mCurrentMonthTextColor = color;\n    }\n\n\n    void setSelectedCirclePaintColor(@ColorInt int color) {\n        mSelectedCirclePaint.setColor(color);\n    }\n\n    @Override\n    public boolean onTouchEvent(MotionEvent event) {\n        switch (event.getAction()) {\n            case MotionEvent.ACTION_UP:\n                final int month = getMonthFromLocation(event.getX(), event.getY());\n                if (month >= 0) {\n                    onMonthClick(month);\n                }\n                break;\n        }\n        return true;\n    }\n\n\n    protected void initView() {\n        mMonthLabelPaint = new Paint();\n        mMonthLabelPaint.setAntiAlias(true);\n        mMonthLabelPaint.setTextSize(MONTH_LABEL_TEXT_SIZE);\n        mMonthLabelPaint.setStyle(Style.FILL);\n        mMonthLabelPaint.setTextAlign(Align.CENTER);\n        mMonthLabelPaint.setFakeBoldText(false);\n\n        mSelectedCirclePaint = new Paint();\n        mSelectedCirclePaint.setFakeBoldText(true);\n        mSelectedCirclePaint.setAntiAlias(true);\n        mSelectedCirclePaint.setColor(mCurrentMonthTextColor);\n        mSelectedCirclePaint.setTextAlign(Align.CENTER);\n        mSelectedCirclePaint.setStyle(Style.FILL);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(MeasureSpec.getSize(widthMeasureSpec), mRowHeight * NUM_ROWS\n                + MONTH_NAVIGATION_BAR_SIZE);\n    }\n\n    @Override\n    protected void onSizeChanged(int w, int h, int oldw, int oldh) {\n        mWidth = w;\n\n\n\n    }\n\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        drawMonthLabels(canvas);\n    }\n\n    private void drawMonthLabels(Canvas canvas) {\n        int y = (((mRowHeight + MONTH_LABEL_TEXT_SIZE) / 2) - MONTH_SEPARATOR_WIDTH);\n        final float monthWidthHalf = (mWidth - mEdgePadding * 2) / (NUM_COLUMNS * 2.0f);\n        int col = 0;\n        for (int month = Calendar.JANUARY; month <= Calendar.DECEMBER; month++) {\n            final int x = (int)((2 * col + 1) * monthWidthHalf + mEdgePadding);\n\n\n\n\n            int constrainedDay = constrainDayInMonth(month, mSelectedDay.day);\n            drawMonthLabel(canvas, mYear, month, constrainedDay, x, y);\n            col++;\n            if (col == NUM_COLUMNS) {\n                col = 0;\n                y += mRowHeight;\n            }\n        }\n    }\n\n    private void drawMonthLabel(Canvas canvas, int year, int month, int day, int x, int y) {\n        final int selectedYear = mSelectedDay.year;\n        final int selectedMonth = mSelectedDay.month;\n\n        boolean drawCircle = selectedYear == year && selectedMonth == month;\n        if (drawCircle) {\n            canvas.drawCircle(x , y - (MONTH_LABEL_TEXT_SIZE / 3), MONTH_SELECTED_CIRCLE_SIZE,\n                    mSelectedCirclePaint);\n        }\n\n\n\n        if (mDateRangeHelper != null && mDateRangeHelper.isOutOfRange(year, month, day)) {\n            mMonthLabelPaint.setFakeBoldText(false);\n            mMonthLabelPaint.setColor(mDisabledMonthTextColor);\n        } else {\n            boolean currentMonthYear = mCurrentYear == year && mCurrentMonth == month;\n            mMonthLabelPaint.setFakeBoldText(currentMonthYear || drawCircle);\n            mMonthLabelPaint.setColor(drawCircle ? mSelectedMonthTextColor :\n                    (currentMonthYear ? mCurrentMonthTextColor : mNormalTextColor));\n        }\n        canvas.drawText(mShortMonthLabels[month], x, y, mMonthLabelPaint);\n    }\n\n\n    public int getMonthFromLocation(float x, float y) {\n        final int month = getInternalMonthFromLocation(x, y);\n        if (month < Calendar.JANUARY || month > Calendar.DECEMBER) {\n            return -1;\n        }\n        return month;\n    }\n\n\n    protected int getInternalMonthFromLocation(float x, float y) {\n        int monthStart = mEdgePadding;\n        if (x < monthStart || x > mWidth - mEdgePadding) {\n\n            return -1;\n        }\n        int row = (int) (y / mRowHeight);\n\n        int column = (int) ((x - monthStart) * NUM_COLUMNS / (mWidth - mEdgePadding * 2));\n\n        int month = column;\n        month += row * NUM_COLUMNS;\n        return month;\n    }\n\n\n    private void onMonthClick(int month) {\n        adjustDayInMonthIfNeeded(month);\n\n        if (mDateRangeHelper != null && mDateRangeHelper.isOutOfRange(mYear, month, mSelectedDay.day)) {\n            return;\n        }\n\n        if (mOnMonthClickListener != null) {\n            mOnMonthClickListener.onMonthClick(this, month, mYear);\n        }\n\n\n\n    }\n\n    interface OnMonthClickListener {\n        void onMonthClick(MonthPickerView view, int month, int year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerView.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n\n'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport com.jnardari.opencv_androidsamples.R;\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Mat;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport android.util.Log;\nimport android.view.SurfaceView;\nimport android.view.WindowManager;\n\npublic class Tutorial1Activity extends AppCompatActivity implements CvCameraViewListener2 {\n    private static final String TAG = \"Tutorial1Activity\";\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n    private boolean              mIsJavaCamera = true;\n    private MenuItem             mItemSwitchCamera = null;\n\n    private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public Tutorial1Activity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_tutorial1);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.tutorial1_activity_java_surface_view);\n\n        mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);\n\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n    }\n\n    public void onCameraViewStopped() {\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        return inputFrame.rgba();\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n\n'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'\n:package net.programmierecke.radiodroid2.tests.utils;\n\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\nimport androidx.recyclerview.widget.RecyclerView;\nimport androidx.test.espresso.PerformException;\nimport androidx.test.espresso.UiController;\nimport androidx.test.espresso.ViewAction;\nimport androidx.test.espresso.action.GeneralLocation;\nimport androidx.test.espresso.action.MotionEvents;\nimport androidx.test.espresso.action.PrecisionDescriber;\nimport androidx.test.espresso.action.Press;\nimport androidx.test.espresso.action.Swipe;\nimport androidx.test.espresso.action.Swiper;\nimport androidx.test.espresso.util.HumanReadables;\n\nimport org.hamcrest.Matcher;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static androidx.test.espresso.core.internal.deps.guava.base.Preconditions.checkElementIndex;\nimport static androidx.test.espresso.matcher.ViewMatchers.isDisplayingAtLeast;\n\npublic class RecyclerDragAndDropAction implements ViewAction {\n\n\n    private static final int VIEW_DISPLAY_PERCENTAGE = 50;\n\n\n    private static final int DRAG_EVENT_COUNT = 10;\n\n    private static final int DRAG_DURATION = 600;\n\n    private final Swiper swiper;\n    private final int idxFrom;\n    private final int idxTo;\n    private final PrecisionDescriber precisionDescriber;\n\n    public static ViewAction recyclerDragAndDrop(int idxFrom, int idxTo) {\n        return new RecyclerDragAndDropAction(Swipe.FAST, idxFrom, idxTo, Press.FINGER);\n    }\n\n    public RecyclerDragAndDropAction(Swiper swiper, int idxFrom, int idxTo, PrecisionDescriber precisionDescriber) {\n        this.swiper = swiper;\n        this.idxFrom = idxFrom;\n        this.idxTo = idxTo;\n        this.precisionDescriber = precisionDescriber;\n    }\n\n    @Override\n    public Matcher<View> getConstraints() {\n        return isDisplayingAtLeast(VIEW_DISPLAY_PERCENTAGE);\n    }\n\n    private static float[][] interpolate(float[] start, float[] end, int steps) {\n        checkElementIndex(1, start.length);\n        checkElementIndex(1, end.length);\n\n        float[][] res = new float[steps][2];\n\n        for (int i = 1; i < steps + 1; i++) {\n            res[i - 1][0] = start[0] + (end[0] - start[0]) * i / (steps);\n            res[i - 1][1] = start[1] + (end[1] - start[1]) * i / (steps);\n        }\n\n        return res;\n    }\n\n    @Override\n    public void perform(UiController uiController, View view) {\n        final RecyclerView recyclerView = (RecyclerView) view;\n\n        TestUtils.centerItemInRecycler(uiController, recyclerView, idxFrom);\n        uiController.loopMainThreadUntilIdle();\n\n        final View fromView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxFrom)).itemView;\n        final float[] fromViewPosition = GeneralLocation.VISIBLE_CENTER.calculateCoordinates(fromView);\n\n        final float[] precision = precisionDescriber.describePrecision();\n\n        final List<MotionEvent> events = new ArrayList<>();\n        MotionEvents.DownResultHolder downEvent = null;\n\n        boolean success = false;\n        for (int i = 0; i < 3 && !success; i++) {\n            try {\n                downEvent = MotionEvents.sendDown(uiController, fromViewPosition, precision);\n\n                final int longPressTimeout = (int) (ViewConfiguration.getLongPressTimeout() * 1.5f);\n                uiController.loopMainThreadForAtLeast(longPressTimeout);\n\n                TestUtils.centerItemInRecycler(uiController, recyclerView, idxTo);\n                uiController.loopMainThreadUntilIdle();\n\n                final View toView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxTo)).itemView;\n                float[] toViewPosition = GeneralLocation.TOP_CENTER.calculateCoordinates(toView);\n\n                float[][] steps = interpolate(fromViewPosition, toViewPosition, DRAG_EVENT_COUNT);\n\n                final long intervalMS = DRAG_DURATION / steps.length;\n                long eventTime = downEvent.down.getDownTime();\n                for (float[] step : steps) {\n                    eventTime += intervalMS;\n                    events.add(MotionEvents.obtainMovement(downEvent.down.getDownTime(), eventTime, step));\n                }\n\n                eventTime += intervalMS;\n                events.add(\n                        MotionEvent.obtain(\n                                downEvent.down.getDownTime(),\n                                eventTime,\n                                MotionEvent.ACTION_UP,\n                                toViewPosition[0],\n                                toViewPosition[1],\n                                0));\n                uiController.injectMotionEventSequence(events);\n                success = true;\n            } catch (Exception e) {\n                throw new PerformException.Builder()\n                        .withActionDescription(this.getDescription())\n                        .withViewDescription(HumanReadables.describe(view))\n                        .withCause(e)\n                        .build();\n            } finally {\n                for (MotionEvent event : events) {\n                    event.recycle();\n                }\n\n                if (downEvent != null) {\n                    downEvent.down.recycle();\n                }\n            }\n        }\n\n        int duration = ViewConfiguration.getPressedStateDuration();\n\n        if (duration > 0) {\n            uiController.loopMainThreadForAtLeast(duration);\n        }\n    }\n\n    @Override\n    public String getDescription() {\n        return swiper.toString().toLowerCase() + \" recycler-drag-and-drop\";\n    }\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n\n'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'\n:package net.programmierecke.radiodroid2.tests.utils;\n\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\nimport androidx.recyclerview.widget.RecyclerView;\nimport androidx.test.espresso.PerformException;\nimport androidx.test.espresso.UiController;\nimport androidx.test.espresso.ViewAction;\nimport androidx.test.espresso.action.GeneralLocation;\nimport androidx.test.espresso.action.MotionEvents;\nimport androidx.test.espresso.action.PrecisionDescriber;\nimport androidx.test.espresso.action.Press;\nimport androidx.test.espresso.action.Swipe;\nimport androidx.test.espresso.action.Swiper;\nimport androidx.test.espresso.util.HumanReadables;\n\nimport org.hamcrest.Matcher;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static androidx.test.espresso.core.internal.deps.guava.base.Preconditions.checkElementIndex;\nimport static androidx.test.espresso.matcher.ViewMatchers.isDisplayingAtLeast;\n\npublic class RecyclerDragAndDropAction implements ViewAction {\n\n\n    private static final int VIEW_DISPLAY_PERCENTAGE = 50;\n\n\n    private static final int DRAG_EVENT_COUNT = 10;\n\n    private static final int DRAG_DURATION = 600;\n\n    private final Swiper swiper;\n    private final int idxFrom;\n    private final int idxTo;\n    private final PrecisionDescriber precisionDescriber;\n\n    public static ViewAction recyclerDragAndDrop(int idxFrom, int idxTo) {\n        return new RecyclerDragAndDropAction(Swipe.FAST, idxFrom, idxTo, Press.FINGER);\n    }\n\n    public RecyclerDragAndDropAction(Swiper swiper, int idxFrom, int idxTo, PrecisionDescriber precisionDescriber) {\n        this.swiper = swiper;\n        this.idxFrom = idxFrom;\n        this.idxTo = idxTo;\n        this.precisionDescriber = precisionDescriber;\n    }\n\n    @Override\n    public Matcher<View> getConstraints() {\n        return isDisplayingAtLeast(VIEW_DISPLAY_PERCENTAGE);\n    }\n\n    private static float[][] interpolate(float[] start, float[] end, int steps) {\n        checkElementIndex(1, start.length);\n        checkElementIndex(1, end.length);\n\n        float[][] res = new float[steps][2];\n\n        for (int i = 1; i < steps + 1; i++) {\n            res[i - 1][0] = start[0] + (end[0] - start[0]) * i / (steps);\n            res[i - 1][1] = start[1] + (end[1] - start[1]) * i / (steps);\n        }\n\n        return res;\n    }\n\n    @Override\n    public void perform(UiController uiController, View view) {\n        final RecyclerView recyclerView = (RecyclerView) view;\n\n        TestUtils.centerItemInRecycler(uiController, recyclerView, idxFrom);\n        uiController.loopMainThreadUntilIdle();\n\n        final View fromView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxFrom)).itemView;\n        final float[] fromViewPosition = GeneralLocation.VISIBLE_CENTER.calculateCoordinates(fromView);\n\n        final float[] precision = precisionDescriber.describePrecision();\n\n        final List<MotionEvent> events = new ArrayList<>();\n        MotionEvents.DownResultHolder downEvent = null;\n\n        boolean success = false;\n        for (int i = 0; i < 3 && !success; i++) {\n            try {\n                downEvent = MotionEvents.sendDown(uiController, fromViewPosition, precision);\n\n                final int longPressTimeout = (int) (ViewConfiguration.getLongPressTimeout() * 1.5f);\n                uiController.loopMainThreadForAtLeast(longPressTimeout);\n\n                TestUtils.centerItemInRecycler(uiController, recyclerView, idxTo);\n                uiController.loopMainThreadUntilIdle();\n\n                final View toView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxTo)).itemView;\n                float[] toViewPosition = GeneralLocation.TOP_CENTER.calculateCoordinates(toView);\n\n                float[][] steps = interpolate(fromViewPosition, toViewPosition, DRAG_EVENT_COUNT);\n\n                final long intervalMS = DRAG_DURATION / steps.length;\n                long eventTime = downEvent.down.getDownTime();\n                for (float[] step : steps) {\n                    eventTime += intervalMS;\n                    events.add(MotionEvents.obtainMovement(downEvent.down.getDownTime(), eventTime, step));\n                }\n\n                eventTime += intervalMS;\n                events.add(\n                        MotionEvent.obtain(\n                                downEvent.down.getDownTime(),\n                                eventTime,\n                                MotionEvent.ACTION_UP,\n                                toViewPosition[0],\n                                toViewPosition[1],\n                                0));\n                uiController.injectMotionEventSequence(events);\n                success = true;\n            } catch (Exception e) {\n                throw new PerformException.Builder()\n                        .withActionDescription(this.getDescription())\n                        .withViewDescription(HumanReadables.describe(view))\n                        .withCause(e)\n                        .build();\n            } finally {\n                for (MotionEvent event : events) {\n                    event.recycle();\n                }\n\n                if (downEvent != null) {\n                    downEvent.down.recycle();\n                }\n            }\n        }\n\n        int duration = ViewConfiguration.getPressedStateDuration();\n\n        if (duration > 0) {\n            uiController.loopMainThreadForAtLeast(duration);\n        }\n    }\n\n    @Override\n    public String getDescription() {\n        return swiper.toString().toLowerCase() + \" recycler-drag-and-drop\";\n    }\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/utils/calibration/OnCameraFrameRender.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/utils/calibration/OnCameraFrameRender.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'"
        ],
        "content": "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Files;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.Table;\nimport com.netflix.iceberg.TableProperties;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.avro.AvroIterable;\nimport com.netflix.iceberg.hadoop.HadoopTables;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.spark.data.AvroDataTest;\nimport com.netflix.iceberg.spark.data.RandomData;\nimport com.netflix.iceberg.spark.data.SparkAvroReader;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.generic.GenericData.Record;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.spark.api.java.JavaRDD;\nimport org.apache.spark.api.java.JavaSparkContext;\nimport org.apache.spark.sql.DataFrameWriter;\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.junit.AfterClass;\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.List;\n\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\nimport static com.netflix.iceberg.spark.data.TestHelpers.assertEqualsSafe;\nimport static com.netflix.iceberg.spark.data.TestHelpers.assertEqualsUnsafe;\n\n@RunWith(Parameterized.class)\npublic class TestDataFrameWrites extends AvroDataTest {\n  private static final Configuration CONF = new Configuration();\n\n  private final String format;\n\n  @Parameterized.Parameters\n  public static Object[][] parameters() {\n    return new Object[][] {\n        new Object[] { \"parquet\" },\n        new Object[] { \"orc\" },\n        new Object[] { \"avro\" }\n    };\n  }\n\n  public TestDataFrameWrites(String format) {\n    this.format = format;\n  }\n\n  private static SparkSession spark = null;\n  private static JavaSparkContext sc = null;\n\n  @BeforeClass\n  public static void startSpark() {\n    TestDataFrameWrites.spark = SparkSession.builder().master(\"local[2]\").getOrCreate();\n    TestDataFrameWrites.sc = new JavaSparkContext(spark.sparkContext());\n  }\n\n  @AfterClass\n  public static void stopSpark() {\n    SparkSession spark = TestDataFrameWrites.spark;\n    TestDataFrameWrites.spark = null;\n    TestDataFrameWrites.sc = null;\n    spark.stop();\n  }\n\n  @Override\n  protected void writeAndValidate(Schema schema) throws IOException {\n    File location = createTableFolder();\n    Table table = createTable(schema, location);\n    writeAndValidateWithLocations(table, location, new File(location, \"data\"));\n  }\n\n  @Test\n  public void testWriteWithCustomDataLocation() throws IOException {\n    File location = createTableFolder();\n    File tablePropertyDataLocation = temp.newFolder(\"test-table-property-data-dir\");\n    Table table = createTable(new Schema(SUPPORTED_PRIMITIVES.fields()), location);\n    table.updateProperties().set(\n        TableProperties.WRITE_NEW_DATA_LOCATION, tablePropertyDataLocation.getAbsolutePath()).commit();\n    writeAndValidateWithLocations(table, location, tablePropertyDataLocation);\n  }\n\n  private File createTableFolder() throws IOException {\n    File parent = temp.newFolder(\"parquet\");\n    File location = new File(parent, \"test\");\n    Assert.assertTrue(\"Mkdir should succeed\", location.mkdirs());\n    return location;\n  }\n\n  private Table createTable(Schema schema, File location) {\n    HadoopTables tables = new HadoopTables(CONF);\n    return tables.create(schema, PartitionSpec.unpartitioned(), location.toString());\n  }\n\n  private void writeAndValidateWithLocations(Table table, File location, File expectedDataDir) throws IOException {\n    Schema tableSchema = table.schema();\n\n    table.updateProperties().set(TableProperties.DEFAULT_FILE_FORMAT, format).commit();\n\n    List<Record> expected = RandomData.generateList(tableSchema, 100, 0L);\n    Dataset<Row> df = createDataset(expected, tableSchema);\n    DataFrameWriter<?> writer = df.write().format(\"iceberg\").mode(\"append\");\n\n    writer.save(location.toString());\n\n    table.refresh();\n\n    Dataset<Row> result = spark.read()\n        .format(\"iceberg\")\n        .load(location.toString());\n\n    List<Row> actual = result.collectAsList();\n\n    Assert.assertEquals(\"Result size should match expected\", expected.size(), actual.size());\n    for (int i = 0; i < expected.size(); i += 1) {\n      assertEqualsSafe(tableSchema.asStruct(), expected.get(i), actual.get(i));\n    }\n\n    table.currentSnapshot().addedFiles().forEach(dataFile ->\n        Assert.assertTrue(\n            String.format(\n                \"File should have the parent directory %s, but has: %s.\",\n                expectedDataDir.getAbsolutePath(),\n                dataFile.path()),\n            URI.create(dataFile.path().toString()).getPath().startsWith(expectedDataDir.getAbsolutePath())));\n  }\n\n  private Dataset<Row> createDataset(List<Record> records, Schema schema) throws IOException {\n\n\n    File testFile = temp.newFile();\n    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n\n    try (FileAppender<Record> writer = Avro.write(Files.localOutput(testFile))\n        .schema(schema)\n        .named(\"test\")\n        .build()) {\n      for (Record rec : records) {\n        writer.add(rec);\n      }\n    }\n\n    List<InternalRow> rows;\n    try (AvroIterable<InternalRow> reader = Avro.read(Files.localInput(testFile))\n        .createReaderFunc(SparkAvroReader::new)\n        .project(schema)\n        .build()) {\n      rows = Lists.newArrayList(reader);\n    }\n\n\n    for (int i = 0; i < records.size(); i += 1) {\n      assertEqualsUnsafe(schema.asStruct(), records.get(i), rows.get(i));\n    }\n\n    JavaRDD<InternalRow> rdd = sc.parallelize(rows);\n    return spark.internalCreateDataFrame(JavaRDD.toRDD(rdd), convert(schema), false);\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestDataFrameWrites.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/LogicalMap.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/avro/LogicalMap.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Maps;\nimport org.apache.avro.Conversion;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.Schema;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\n\npublic class LogicalMap extends LogicalType {\n  static final String NAME = \"map\";\n  private static final LogicalMap INSTANCE = new LogicalMap();\n\n  static LogicalMap get() {\n    return INSTANCE;\n  }\n\n  private LogicalMap() {\n    super(NAME);\n  }\n\n  @Override\n  public void validate(Schema schema) {\n    super.validate(schema);\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Invalid type for map, must be an array: %s\", schema);\n    Preconditions.checkArgument(AvroSchemaUtil.isKeyValueSchema(schema.getElementType()),\n        \"Invalid key-value record: %s\", schema.getElementType());\n  }\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\nimport static org.apache.avro.Schema.Type.MAP;\nimport static org.apache.avro.Schema.Type.RECORD;\nimport static org.apache.avro.Schema.Type.UNION;\n\npublic class AvroSchemaUtil {\n  public static final String FIELD_ID_PROP = \"field-id\";\n  public static final String KEY_ID_PROP = \"key-id\";\n  public static final String VALUE_ID_PROP = \"value-id\";\n  public static final String ELEMENT_ID_PROP = \"element-id\";\n  public static final String ADJUST_TO_UTC_PROP = \"adjust-to-utc\";\n\n  private static final Schema NULL = Schema.create(Schema.Type.NULL);\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               String tableName) {\n    return convert(schema, ImmutableMap.of(schema.asStruct(), tableName));\n  }\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               Map<Types.StructType, String> names) {\n    return TypeUtil.visit(schema, new TypeToSchema(names));\n  }\n\n  public static Schema convert(Type type) {\n    return convert(type, ImmutableMap.of());\n  }\n\n  public static Schema convert(Types.StructType type, String name) {\n    return convert(type, ImmutableMap.of(type, name));\n  }\n\n  public static Schema convert(Type type, Map<Types.StructType, String> names) {\n    return TypeUtil.visit(type, new TypeToSchema(names));\n  }\n\n  public static Type convert(Schema schema) {\n    return AvroSchemaVisitor.visit(schema, new SchemaToType(schema));\n  }\n\n  public static Map<Type, Schema> convertTypes(Types.StructType type, String name) {\n    TypeToSchema converter = new TypeToSchema(ImmutableMap.of(type, name));\n    TypeUtil.visit(type, converter);\n    return ImmutableMap.copyOf(converter.getConversionMap());\n  }\n\n  public static Schema pruneColumns(Schema schema, Set<Integer> selectedIds) {\n    return new PruneColumns(selectedIds).rootSchema(schema);\n  }\n\n  public static Schema buildAvroProjection(Schema schema, com.netflix.iceberg.Schema expected,\n                                           Map<String, String> renames) {\n    return AvroCustomOrderSchemaVisitor.visit(schema, new BuildAvroProjection(expected, renames));\n  }\n\n  public static boolean isTimestamptz(Schema schema) {\n    LogicalType logicalType = schema.getLogicalType();\n    if (logicalType != null && logicalType instanceof LogicalTypes.TimestampMicros) {\n\n      Object value = schema.getObjectProp(ADJUST_TO_UTC_PROP);\n      if (value instanceof Boolean) {\n        return (Boolean) value;\n      } else if (value instanceof String) {\n        return Boolean.parseBoolean((String) value);\n      }\n    }\n\n    return false;\n  }\n\n  static boolean isOptionSchema(Schema schema) {\n    if (schema.getType() == UNION && schema.getTypes().size() == 2) {\n      if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return true;\n      } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Schema toOption(Schema schema) {\n    if (schema.getType() == UNION) {\n      Preconditions.checkArgument(isOptionSchema(schema),\n          \"Union schemas are not supported: \" + schema);\n      return schema;\n    } else {\n      return Schema.createUnion(NULL, schema);\n    }\n  }\n\n  static Schema fromOption(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == UNION,\n        \"Expected union schema but was passed: {}\", schema);\n    Preconditions.checkArgument(schema.getTypes().size() == 2,\n        \"Expected optional schema, but was passed: {}\", schema);\n    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n      return schema.getTypes().get(1);\n    } else {\n      return schema.getTypes().get(0);\n    }\n  }\n\n  static Schema fromOptions(List<Schema> options) {\n    Preconditions.checkArgument(options.size() == 2,\n        \"Expected two schemas, but was passed: {} options\", options.size());\n    if (options.get(0).getType() == Schema.Type.NULL) {\n      return options.get(1);\n    } else {\n      return options.get(0);\n    }\n  }\n\n  static boolean isKeyValueSchema(Schema schema) {\n    return (schema.getType() == RECORD && schema.getFields().size() == 2);\n  }\n\n  static Schema createMap(int keyId, Schema keySchema,\n                          int valueId, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n\n    return LogicalMap.get().addToSchema(Schema.createArray(Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField))));\n  }\n\n  static Schema createProjectionMap(String recordName,\n                          int keyId, String keyName, Schema keySchema,\n                          int valueId, String valueName, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    if (!\"key\".equals(keyName)) {\n      keyField.addAlias(keyName);\n    }\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n    if (!\"value\".equals(valueName)) {\n      valueField.addAlias(valueName);\n    }\n\n    Schema keyValueRecord = Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField));\n    if (!keyValueName.equals(recordName)) {\n      keyValueRecord.addAlias(recordName);\n    }\n\n    return LogicalMap.get().addToSchema(Schema.createArray(keyValueRecord));\n  }\n\n  private static int getId(Schema schema, String propertyName) {\n    if (schema.getType() == UNION) {\n      return getId(fromOption(schema), propertyName);\n    }\n\n    Object id = schema.getObjectProp(propertyName);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", propertyName);\n\n    return toInt(id);\n  }\n\n  public static int getKeyId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map key id for non-map schema: \" + schema);\n    return getId(schema, KEY_ID_PROP);\n  }\n\n  public static int getValueId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map value id for non-map schema: \" + schema);\n    return getId(schema, VALUE_ID_PROP);\n  }\n\n  public static int getElementId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Cannot get array element id for non-array schema: \" + schema);\n    return getId(schema, ELEMENT_ID_PROP);\n  }\n\n  public static int getFieldId(Schema.Field field) {\n    Object id = field.getObjectProp(FIELD_ID_PROP);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", FIELD_ID_PROP);\n\n    return toInt(id);\n  }\n\n  private static int toInt(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).intValue();\n    } else if (value instanceof String) {\n      return Integer.parseInt((String) value);\n    }\n\n    throw new UnsupportedOperationException(\"Cannot coerce value to int: \" + value);\n  }\n\n  static Schema copyRecord(Schema record, List<Schema.Field> newFields, String newName) {\n    Schema copy;\n    if (newName != null) {\n      copy = Schema.createRecord(newName, record.getDoc(), null, record.isError(), newFields);\n\n\n\n      copy.addAlias(record.getName(), record.getNamespace() == null ? \"\" : record.getNamespace());\n    } else {\n      copy = Schema.createRecord(record.getName(),\n          record.getDoc(), record.getNamespace(), record.isError(), newFields);\n    }\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  static Schema.Field copyField(Schema.Field field, Schema newSchema, String newName) {\n    Schema.Field copy = new Schema.Field(newName,\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    if (!newName.equals(field.name())) {\n      copy.addAlias(field.name());\n    }\n\n    return copy;\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/LogicalMap.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'",
            "'iceberg/parquet/src/test/java/com/netflix/iceberg/parquet/TestDictionaryRowGroupFilter.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\nimport static org.apache.avro.Schema.Type.MAP;\nimport static org.apache.avro.Schema.Type.RECORD;\nimport static org.apache.avro.Schema.Type.UNION;\n\npublic class AvroSchemaUtil {\n  public static final String FIELD_ID_PROP = \"field-id\";\n  public static final String KEY_ID_PROP = \"key-id\";\n  public static final String VALUE_ID_PROP = \"value-id\";\n  public static final String ELEMENT_ID_PROP = \"element-id\";\n  public static final String ADJUST_TO_UTC_PROP = \"adjust-to-utc\";\n\n  private static final Schema NULL = Schema.create(Schema.Type.NULL);\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               String tableName) {\n    return convert(schema, ImmutableMap.of(schema.asStruct(), tableName));\n  }\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               Map<Types.StructType, String> names) {\n    return TypeUtil.visit(schema, new TypeToSchema(names));\n  }\n\n  public static Schema convert(Type type) {\n    return convert(type, ImmutableMap.of());\n  }\n\n  public static Schema convert(Types.StructType type, String name) {\n    return convert(type, ImmutableMap.of(type, name));\n  }\n\n  public static Schema convert(Type type, Map<Types.StructType, String> names) {\n    return TypeUtil.visit(type, new TypeToSchema(names));\n  }\n\n  public static Type convert(Schema schema) {\n    return AvroSchemaVisitor.visit(schema, new SchemaToType(schema));\n  }\n\n  public static Map<Type, Schema> convertTypes(Types.StructType type, String name) {\n    TypeToSchema converter = new TypeToSchema(ImmutableMap.of(type, name));\n    TypeUtil.visit(type, converter);\n    return ImmutableMap.copyOf(converter.getConversionMap());\n  }\n\n  public static Schema pruneColumns(Schema schema, Set<Integer> selectedIds) {\n    return new PruneColumns(selectedIds).rootSchema(schema);\n  }\n\n  public static Schema buildAvroProjection(Schema schema, com.netflix.iceberg.Schema expected,\n                                           Map<String, String> renames) {\n    return AvroCustomOrderSchemaVisitor.visit(schema, new BuildAvroProjection(expected, renames));\n  }\n\n  public static boolean isTimestamptz(Schema schema) {\n    LogicalType logicalType = schema.getLogicalType();\n    if (logicalType != null && logicalType instanceof LogicalTypes.TimestampMicros) {\n\n      Object value = schema.getObjectProp(ADJUST_TO_UTC_PROP);\n      if (value instanceof Boolean) {\n        return (Boolean) value;\n      } else if (value instanceof String) {\n        return Boolean.parseBoolean((String) value);\n      }\n    }\n\n    return false;\n  }\n\n  static boolean isOptionSchema(Schema schema) {\n    if (schema.getType() == UNION && schema.getTypes().size() == 2) {\n      if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return true;\n      } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Schema toOption(Schema schema) {\n    if (schema.getType() == UNION) {\n      Preconditions.checkArgument(isOptionSchema(schema),\n          \"Union schemas are not supported: \" + schema);\n      return schema;\n    } else {\n      return Schema.createUnion(NULL, schema);\n    }\n  }\n\n  static Schema fromOption(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == UNION,\n        \"Expected union schema but was passed: {}\", schema);\n    Preconditions.checkArgument(schema.getTypes().size() == 2,\n        \"Expected optional schema, but was passed: {}\", schema);\n    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n      return schema.getTypes().get(1);\n    } else {\n      return schema.getTypes().get(0);\n    }\n  }\n\n  static Schema fromOptions(List<Schema> options) {\n    Preconditions.checkArgument(options.size() == 2,\n        \"Expected two schemas, but was passed: {} options\", options.size());\n    if (options.get(0).getType() == Schema.Type.NULL) {\n      return options.get(1);\n    } else {\n      return options.get(0);\n    }\n  }\n\n  static boolean isKeyValueSchema(Schema schema) {\n    return (schema.getType() == RECORD && schema.getFields().size() == 2);\n  }\n\n  static Schema createMap(int keyId, Schema keySchema,\n                          int valueId, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n\n    return LogicalMap.get().addToSchema(Schema.createArray(Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField))));\n  }\n\n  static Schema createProjectionMap(String recordName,\n                          int keyId, String keyName, Schema keySchema,\n                          int valueId, String valueName, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    if (!\"key\".equals(keyName)) {\n      keyField.addAlias(keyName);\n    }\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n    if (!\"value\".equals(valueName)) {\n      valueField.addAlias(valueName);\n    }\n\n    Schema keyValueRecord = Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField));\n    if (!keyValueName.equals(recordName)) {\n      keyValueRecord.addAlias(recordName);\n    }\n\n    return LogicalMap.get().addToSchema(Schema.createArray(keyValueRecord));\n  }\n\n  private static int getId(Schema schema, String propertyName) {\n    if (schema.getType() == UNION) {\n      return getId(fromOption(schema), propertyName);\n    }\n\n    Object id = schema.getObjectProp(propertyName);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", propertyName);\n\n    return toInt(id);\n  }\n\n  public static int getKeyId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map key id for non-map schema: \" + schema);\n    return getId(schema, KEY_ID_PROP);\n  }\n\n  public static int getValueId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map value id for non-map schema: \" + schema);\n    return getId(schema, VALUE_ID_PROP);\n  }\n\n  public static int getElementId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Cannot get array element id for non-array schema: \" + schema);\n    return getId(schema, ELEMENT_ID_PROP);\n  }\n\n  public static int getFieldId(Schema.Field field) {\n    Object id = field.getObjectProp(FIELD_ID_PROP);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", FIELD_ID_PROP);\n\n    return toInt(id);\n  }\n\n  private static int toInt(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).intValue();\n    } else if (value instanceof String) {\n      return Integer.parseInt((String) value);\n    }\n\n    throw new UnsupportedOperationException(\"Cannot coerce value to int: \" + value);\n  }\n\n  static Schema copyRecord(Schema record, List<Schema.Field> newFields, String newName) {\n    Schema copy;\n    if (newName != null) {\n      copy = Schema.createRecord(newName, record.getDoc(), null, record.isError(), newFields);\n\n\n\n      copy.addAlias(record.getName(), record.getNamespace() == null ? \"\" : record.getNamespace());\n    } else {\n      copy = Schema.createRecord(record.getName(),\n          record.getDoc(), record.getNamespace(), record.isError(), newFields);\n    }\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  static Schema.Field copyField(Schema.Field field, Schema newSchema, String newName) {\n    Schema.Field copy = new Schema.Field(newName,\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    if (!newName.equals(field.name())) {\n      copy.addAlias(field.name());\n    }\n\n    return copy;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.types.ArrayType$;\nimport org.apache.spark.sql.types.BinaryType$;\nimport org.apache.spark.sql.types.BooleanType$;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.DateType$;\nimport org.apache.spark.sql.types.DecimalType$;\nimport org.apache.spark.sql.types.DoubleType$;\nimport org.apache.spark.sql.types.FloatType$;\nimport org.apache.spark.sql.types.IntegerType$;\nimport org.apache.spark.sql.types.LongType$;\nimport org.apache.spark.sql.types.MapType$;\nimport org.apache.spark.sql.types.Metadata;\nimport org.apache.spark.sql.types.StringType$;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType$;\nimport org.apache.spark.sql.types.TimestampType$;\nimport java.util.List;\n\nclass TypeToSparkType extends TypeUtil.SchemaVisitor<DataType> {\n  TypeToSparkType() {\n  }\n\n  @Override\n  public DataType schema(Schema schema, DataType structType) {\n    return structType;\n  }\n\n  @Override\n  public DataType struct(Types.StructType struct, List<DataType> fieldResults) {\n    List<Types.NestedField> fields = struct.fields();\n\n    List<StructField> sparkFields = Lists.newArrayListWithExpectedSize(fieldResults.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      DataType type = fieldResults.get(i);\n      sparkFields.add(StructField.apply(field.name(), type, field.isOptional(), Metadata.empty()));\n    }\n\n    return StructType$.MODULE$.apply(sparkFields);\n  }\n\n  @Override\n  public DataType field(Types.NestedField field, DataType fieldResult) {\n    return fieldResult;\n  }\n\n  @Override\n  public DataType list(Types.ListType list, DataType elementResult) {\n    return ArrayType$.MODULE$.apply(elementResult, list.isElementOptional());\n  }\n\n  @Override\n  public DataType map(Types.MapType map, DataType keyResult, DataType valueResult) {\n    return MapType$.MODULE$.apply(keyResult, valueResult, map.isValueOptional());\n  }\n\n  @Override\n  public DataType primitive(Type.PrimitiveType primitive) {\n    switch (primitive.typeId()) {\n      case BOOLEAN:\n        return BooleanType$.MODULE$;\n      case INTEGER:\n        return IntegerType$.MODULE$;\n      case LONG:\n        return LongType$.MODULE$;\n      case FLOAT:\n        return FloatType$.MODULE$;\n      case DOUBLE:\n        return DoubleType$.MODULE$;\n      case DATE:\n        return DateType$.MODULE$;\n      case TIME:\n        throw new UnsupportedOperationException(\n            \"Spark does not support time fields\");\n      case TIMESTAMP:\n        Types.TimestampType timestamp = (Types.TimestampType) primitive;\n        if (timestamp.shouldAdjustToUTC()) {\n          return TimestampType$.MODULE$;\n        }\n        throw new UnsupportedOperationException(\n            \"Spark does not support timestamp without time zone fields\");\n      case STRING:\n        return StringType$.MODULE$;\n      case UUID:\n\n        return StringType$.MODULE$;\n      case FIXED:\n        return BinaryType$.MODULE$;\n      case BINARY:\n        return BinaryType$.MODULE$;\n      case DECIMAL:\n        Types.DecimalType decimal = (Types.DecimalType) primitive;\n        return DecimalType$.MODULE$.apply(decimal.precision(), decimal.scale());\n      default:\n        throw new UnsupportedOperationException(\n            \"Cannot convert unknown type to Spark: \" + primitive);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/parquet/src/test/java/com/netflix/iceberg/parquet/TestDictionaryRowGroupFilter.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.inject.BindingAnnotation;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.Scopes;\nimport io.airlift.bootstrap.Bootstrap;\nimport io.airlift.bootstrap.LifeCycleManager;\nimport io.airlift.drift.client.DriftClient;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftResultCode;\nimport io.airlift.drift.integration.scribe.drift.DriftScribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.jmx.testing.TestingJmxModule;\nimport org.weakref.jmx.guice.MBeanModule;\n\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManagerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport static io.airlift.drift.client.guice.DriftClientBinder.driftClientBinder;\nimport static io.airlift.drift.client.guice.MethodInvocationFilterBinder.staticFilterBinder;\nimport static io.airlift.security.pem.PemReader.loadKeyStore;\nimport static io.airlift.security.pem.PemReader.loadTrustStore;\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertSame;\n\nfinal class ClientTestUtils\n{\n    public static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n    public static final List<LogEntry> MESSAGES = ImmutableList.of(\n            new LogEntry(\"hello\", \"world\"),\n            new LogEntry(\"bye\", \"world\"));\n    public static final String HEADER_VALUE = \"header-value\";\n    public static final List<DriftLogEntry> DRIFT_MESSAGES = ImmutableList.copyOf(\n            MESSAGES.stream()\n                    .map(input -> new DriftLogEntry(input.category, input.message))\n                    .collect(Collectors.toList()));\n    public static final DriftResultCode DRIFT_OK = DriftResultCode.OK;\n\n    private ClientTestUtils() {}\n\n    public static int logDriftClientBinder(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            Module transportModule,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n\n        Bootstrap app = new Bootstrap(\n                new MBeanModule(),\n                new TestingJmxModule(),\n                transportModule,\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class, CustomClient.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> binder.bind(ScribeUser.class).in(Scopes.SINGLETON));\n\n        LifeCycleManager lifeCycleManager = null;\n\n        try {\n            app.setRequiredConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"scribe.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.CustomClient.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.thrift.client.protocol\", protocol.toString())\n                    .put(\"scribe.CustomClient.thrift.client.protocol\", protocol.toString())\n                    .build());\n\n\n            app.setOptionalConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.CustomClient.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.CustomClient.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .build());\n\n            Injector injector = app\n                    .doNotInitializeLogging()\n                    .initialize();\n\n            lifeCycleManager = injector.getInstance(LifeCycleManager.class);\n            DriftScribe scribe = injector.getInstance(DriftScribe.class);\n\n            ScribeUser user = injector.getInstance(ScribeUser.class);\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n\n            assertEquals(user.getClient().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getClientCustom().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactory().get().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactoryCustom().get().log(headerValue, entries), DRIFT_OK);\n\n            assertSame(scribe, user.getClient());\n            assertNotSame(user.getClient(), user.getClientCustom());\n            assertNotSame(user.getFactory(), user.getFactoryCustom());\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        finally {\n            if (lifeCycleManager != null) {\n                try {\n                    lifeCycleManager.stop();\n                }\n                catch (Exception ignored) {\n                }\n            }\n        }\n        return 5;\n    }\n\n    public static SSLContext getServerSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        keyManagerFactory.init(loadKeyStore(getPrivateKeyFile(), getPrivateKeyFile(), Optional.empty()), new char[0]);\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static SSLContext getClientSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static File getPrivateKeyFile()\n    {\n        return getResourceFile(\"rsa.key\");\n    }\n\n    public static File getCertificateChainFile()\n    {\n        return getResourceFile(\"rsa.crt\");\n    }\n\n    private static File getResourceFile(String name)\n    {\n        URL resource = TestClientsWithApacheServer.class.getClassLoader().getResource(name);\n        if (resource == null) {\n            throw new IllegalArgumentException(\"Resource not found \" + name);\n        }\n        return new File(resource.getFile());\n    }\n\n    @Target({FIELD, PARAMETER, METHOD})\n    @Retention(RUNTIME)\n    @BindingAnnotation\n    private @interface CustomClient {}\n\n    private static class ScribeUser\n    {\n        @Inject\n        private DriftScribe client;\n\n        @Inject\n        @CustomClient\n        private DriftScribe clientCustom;\n\n        @Inject\n        private DriftClient<DriftScribe> factory;\n\n        @Inject\n        @CustomClient\n        private DriftClient<DriftScribe> factoryCustom;\n\n        public DriftScribe getClient()\n        {\n            return client;\n        }\n\n        public DriftScribe getClientCustom()\n        {\n            return clientCustom;\n        }\n\n        public DriftClient<DriftScribe> getFactory()\n        {\n            return factory;\n        }\n\n        public DriftClient<DriftScribe> getFactoryCustom()\n        {\n            return factoryCustom;\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithApacheServer.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/hadoop/HadoopTableTestBase.java'"
        ],
        "content": "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.netflix.iceberg.exceptions.CommitFailedException;\nimport com.netflix.iceberg.exceptions.ValidationException;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.mockito.internal.util.collections.Sets;\n\nimport java.io.File;\nimport java.util.Collections;\n\nimport static com.netflix.iceberg.ManifestEntry.Status.ADDED;\nimport static com.netflix.iceberg.ManifestEntry.Status.DELETED;\nimport static com.netflix.iceberg.ManifestEntry.Status.EXISTING;\n\npublic class TestReplaceFiles extends TableTestBase {\n\n  @Test\n  public void testEmptyTable() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    TableMetadata base = readMetadata();\n    Assert.assertNull(\"Should not have a current snapshot\", base.currentSnapshot());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-a.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B))\n            .commit());\n  }\n\n  @Test\n  public void testAddOnly() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        IllegalArgumentException.class,\n        \"Files to add can not be null or empty\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Collections.emptySet())\n            .apply());\n  }\n\n  @Test\n  public void testDeleteOnly() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        IllegalArgumentException.class,\n        \"Files to delete cannot be null or empty\",\n        () -> table.newRewrite()\n            .rewriteFiles(Collections.emptySet(), Sets.newSet(FILE_A))\n            .apply());\n  }\n\n  @Test\n  public void testDeleteWithDuplicateEntriesInManifest() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    long baseSnapshotId = base.currentSnapshot().snapshotId();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    Snapshot pending = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_C))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n    Assert.assertFalse(\"Should not contain manifest from initial write\",\n        pending.manifests().contains(initialManifest));\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_C),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId,pendingId, baseSnapshotId),\n        files(FILE_A, FILE_A, FILE_B),\n        statuses(DELETED, DELETED, EXISTING));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testAddAndDelete() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    long baseSnapshotId = base.currentSnapshot().snapshotId();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    Snapshot pending = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_C))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n    Assert.assertFalse(\"Should not contain manifest from initial write\",\n        pending.manifests().contains(initialManifest));\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_C),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId, baseSnapshotId),\n        files(FILE_A, FILE_B),\n        statuses(DELETED, EXISTING));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testFailure() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.ops().failCommits(5);\n\n    RewriteFiles rewrite = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B));\n    Snapshot pending = rewrite.apply();\n\n    Assert.assertEquals(\"Should produce 2 manifests\", 2, pending.manifests().size());\n    ManifestFile manifest1 = pending.manifests().get(0);\n    ManifestFile manifest2 = pending.manifests().get(1);\n\n    validateManifestEntries(manifest1,\n        ids(pending.snapshotId()), files(FILE_B), statuses(ADDED));\n    validateManifestEntries(manifest2,\n        ids(pending.snapshotId()), files(FILE_A), statuses(DELETED));\n\n    AssertHelpers.assertThrows(\"Should retry 4 times and throw last failure\",\n        CommitFailedException.class, \"Injected failure\", rewrite::commit);\n\n    Assert.assertFalse(\"Should clean up new manifest\", new File(manifest1.path()).exists());\n    Assert.assertFalse(\"Should clean up new manifest\", new File(manifest2.path()).exists());\n\n\n    Assert.assertEquals(\"Only 1 manifest should exist\", 1, listManifestFiles().size());\n  }\n\n  @Test\n  public void testRecovery() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.ops().failCommits(3);\n\n    RewriteFiles rewrite = table.newRewrite().rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B));\n    Snapshot pending = rewrite.apply();\n\n    Assert.assertEquals(\"Should produce 2 manifests\", 2, pending.manifests().size());\n    ManifestFile manifest1 = pending.manifests().get(0);\n    ManifestFile manifest2 = pending.manifests().get(1);\n\n    validateManifestEntries(manifest1,\n        ids(pending.snapshotId()), files(FILE_B), statuses(ADDED));\n    validateManifestEntries(manifest2,\n        ids(pending.snapshotId()), files(FILE_A), statuses(DELETED));\n\n    rewrite.commit();\n\n    Assert.assertTrue(\"Should reuse the manifest for appends\", new File(manifest1.path()).exists());\n    Assert.assertTrue(\"Should reuse the manifest with deletes\", new File(manifest2.path()).exists());\n\n    TableMetadata metadata = readMetadata();\n    Assert.assertTrue(\"Should commit the manifest for append\",\n        metadata.currentSnapshot().manifests().contains(manifest2));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testDeleteNonExistentFile() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-c.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_C), Sets.newSet(FILE_D))\n            .commit());\n\n    Assert.assertEquals(\"Only 1 manifests should exist\", 1, listManifestFiles().size());\n  }\n\n  @Test\n  public void testAlreadyDeletedFile() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n\n    RewriteFiles rewrite = table.newRewrite();\n    Snapshot pending = rewrite\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_B),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId, base.currentSnapshot().snapshotId()),\n        files(FILE_A),\n        statuses(DELETED));\n\n    rewrite.commit();\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-a.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_D))\n            .commit());\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.base.Objects;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.types.Types.IntegerType;\nimport com.netflix.iceberg.types.Types.LongType;\nimport com.netflix.iceberg.types.Types.StructType;\nimport org.apache.avro.generic.IndexedRecord;\nimport org.apache.avro.specific.SpecificData;\n\nimport java.util.Collection;\n\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\nclass ManifestEntry implements IndexedRecord, SpecificData.SchemaConstructable{\n  enum Status {\n    EXISTING(0),\n    ADDED(1),\n    DELETED(2);\n\n    public static Status[] values = new Status[3];\n    static {\n      for (Status status : Status.values()) {\n        values[status.id] = status;\n      }\n    }\n\n    private final int id;\n\n    Status(int id) {\n      this.id = id;\n    }\n\n    public int id() {\n      return id;\n    }\n\n    public static Status fromId(int id) {\n      return values[id];\n    }\n  }\n\n  private final org.apache.avro.Schema schema;\n  private Status status = Status.EXISTING;\n  private long snapshotId = 0L;\n  private DataFile file = null;\n\n  public ManifestEntry(org.apache.avro.Schema schema) {\n    this.schema = schema;\n  }\n\n  ManifestEntry(StructType partitionType) {\n    this.schema = AvroSchemaUtil.convert(getSchema(partitionType), \"manifest_entry\");\n  }\n\n  private ManifestEntry(ManifestEntry toCopy) {\n    this.schema = toCopy.schema;\n    this.status = toCopy.status;\n    this.snapshotId = toCopy.snapshotId;\n    this.file = toCopy.file().copy();\n  }\n\n  ManifestEntry wrapExisting(long snapshotId, DataFile file) {\n    this.status = Status.EXISTING;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapAppend(long snapshotId, DataFile file) {\n    this.status = Status.ADDED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapDelete(long snapshotId, DataFile file) {\n    this.status = Status.DELETED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n\n  public Status status() {\n    return status;\n  }\n\n\n  public long snapshotId() {\n    return snapshotId;\n  }\n\n\n  public DataFile file() {\n    return file;\n  }\n\n  public ManifestEntry copy() {\n    return new ManifestEntry(this);\n  }\n\n  @Override\n  public void put(int i, Object v) {\n    switch (i) {\n      case 0:\n        this.status = Status.fromId((Integer) v);\n        return;\n      case 1:\n        this.snapshotId = (Long) v;\n        return;\n      case 2:\n        this.file = (DataFile) v;\n        return;\n      default:\n\n    }\n  }\n\n  @Override\n  public Object get(int i) {\n    switch (i) {\n      case 0:\n        return status.id();\n      case 1:\n        return snapshotId;\n      case 2:\n        return file;\n      default:\n        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n    }\n  }\n\n  @Override\n  public org.apache.avro.Schema getSchema() {\n    return schema;\n  }\n\n  static Schema projectSchema(StructType partitionType, Collection<String> columns) {\n    return wrapFileSchema(\n        new Schema(DataFile.getType(partitionType).fields()).select(columns).asStruct());\n  }\n\n  static Schema getSchema(StructType partitionType) {\n    return wrapFileSchema(DataFile.getType(partitionType));\n  }\n\n  private static Schema wrapFileSchema(StructType fileStruct) {\n\n    return new Schema(\n        required(0, \"status\", IntegerType.get()),\n        required(1, \"snapshot_id\", LongType.get()),\n        required(2, \"data_file\", fileStruct));\n  }\n\n  @Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n        .add(\"status\", status)\n        .add(\"snapshot_id\", snapshotId)\n        .add(\"file\", file)\n        .toString();\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/hadoop/HadoopTableTestBase.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/LogicalMap.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/avro/LogicalMap.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Maps;\nimport org.apache.avro.Conversion;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.Schema;\n\nimport java.util.Collection;\nimport java.util.Map;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\n\npublic class LogicalMap extends LogicalType {\n  static final String NAME = \"map\";\n  private static final LogicalMap INSTANCE = new LogicalMap();\n\n  static LogicalMap get() {\n    return INSTANCE;\n  }\n\n  private LogicalMap() {\n    super(NAME);\n  }\n\n  @Override\n  public void validate(Schema schema) {\n    super.validate(schema);\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Invalid type for map, must be an array: %s\", schema);\n    Preconditions.checkArgument(AvroSchemaUtil.isKeyValueSchema(schema.getElementType()),\n        \"Invalid key-value record: %s\", schema.getElementType());\n  }\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\nimport static org.apache.avro.Schema.Type.MAP;\nimport static org.apache.avro.Schema.Type.RECORD;\nimport static org.apache.avro.Schema.Type.UNION;\n\npublic class AvroSchemaUtil {\n  public static final String FIELD_ID_PROP = \"field-id\";\n  public static final String KEY_ID_PROP = \"key-id\";\n  public static final String VALUE_ID_PROP = \"value-id\";\n  public static final String ELEMENT_ID_PROP = \"element-id\";\n  public static final String ADJUST_TO_UTC_PROP = \"adjust-to-utc\";\n\n  private static final Schema NULL = Schema.create(Schema.Type.NULL);\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               String tableName) {\n    return convert(schema, ImmutableMap.of(schema.asStruct(), tableName));\n  }\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               Map<Types.StructType, String> names) {\n    return TypeUtil.visit(schema, new TypeToSchema(names));\n  }\n\n  public static Schema convert(Type type) {\n    return convert(type, ImmutableMap.of());\n  }\n\n  public static Schema convert(Types.StructType type, String name) {\n    return convert(type, ImmutableMap.of(type, name));\n  }\n\n  public static Schema convert(Type type, Map<Types.StructType, String> names) {\n    return TypeUtil.visit(type, new TypeToSchema(names));\n  }\n\n  public static Type convert(Schema schema) {\n    return AvroSchemaVisitor.visit(schema, new SchemaToType(schema));\n  }\n\n  public static Map<Type, Schema> convertTypes(Types.StructType type, String name) {\n    TypeToSchema converter = new TypeToSchema(ImmutableMap.of(type, name));\n    TypeUtil.visit(type, converter);\n    return ImmutableMap.copyOf(converter.getConversionMap());\n  }\n\n  public static Schema pruneColumns(Schema schema, Set<Integer> selectedIds) {\n    return new PruneColumns(selectedIds).rootSchema(schema);\n  }\n\n  public static Schema buildAvroProjection(Schema schema, com.netflix.iceberg.Schema expected,\n                                           Map<String, String> renames) {\n    return AvroCustomOrderSchemaVisitor.visit(schema, new BuildAvroProjection(expected, renames));\n  }\n\n  public static boolean isTimestamptz(Schema schema) {\n    LogicalType logicalType = schema.getLogicalType();\n    if (logicalType != null && logicalType instanceof LogicalTypes.TimestampMicros) {\n\n      Object value = schema.getObjectProp(ADJUST_TO_UTC_PROP);\n      if (value instanceof Boolean) {\n        return (Boolean) value;\n      } else if (value instanceof String) {\n        return Boolean.parseBoolean((String) value);\n      }\n    }\n\n    return false;\n  }\n\n  static boolean isOptionSchema(Schema schema) {\n    if (schema.getType() == UNION && schema.getTypes().size() == 2) {\n      if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return true;\n      } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Schema toOption(Schema schema) {\n    if (schema.getType() == UNION) {\n      Preconditions.checkArgument(isOptionSchema(schema),\n          \"Union schemas are not supported: \" + schema);\n      return schema;\n    } else {\n      return Schema.createUnion(NULL, schema);\n    }\n  }\n\n  static Schema fromOption(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == UNION,\n        \"Expected union schema but was passed: {}\", schema);\n    Preconditions.checkArgument(schema.getTypes().size() == 2,\n        \"Expected optional schema, but was passed: {}\", schema);\n    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n      return schema.getTypes().get(1);\n    } else {\n      return schema.getTypes().get(0);\n    }\n  }\n\n  static Schema fromOptions(List<Schema> options) {\n    Preconditions.checkArgument(options.size() == 2,\n        \"Expected two schemas, but was passed: {} options\", options.size());\n    if (options.get(0).getType() == Schema.Type.NULL) {\n      return options.get(1);\n    } else {\n      return options.get(0);\n    }\n  }\n\n  static boolean isKeyValueSchema(Schema schema) {\n    return (schema.getType() == RECORD && schema.getFields().size() == 2);\n  }\n\n  static Schema createMap(int keyId, Schema keySchema,\n                          int valueId, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n\n    return LogicalMap.get().addToSchema(Schema.createArray(Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField))));\n  }\n\n  static Schema createProjectionMap(String recordName,\n                          int keyId, String keyName, Schema keySchema,\n                          int valueId, String valueName, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    if (!\"key\".equals(keyName)) {\n      keyField.addAlias(keyName);\n    }\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n    if (!\"value\".equals(valueName)) {\n      valueField.addAlias(valueName);\n    }\n\n    Schema keyValueRecord = Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField));\n    if (!keyValueName.equals(recordName)) {\n      keyValueRecord.addAlias(recordName);\n    }\n\n    return LogicalMap.get().addToSchema(Schema.createArray(keyValueRecord));\n  }\n\n  private static int getId(Schema schema, String propertyName) {\n    if (schema.getType() == UNION) {\n      return getId(fromOption(schema), propertyName);\n    }\n\n    Object id = schema.getObjectProp(propertyName);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", propertyName);\n\n    return toInt(id);\n  }\n\n  public static int getKeyId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map key id for non-map schema: \" + schema);\n    return getId(schema, KEY_ID_PROP);\n  }\n\n  public static int getValueId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map value id for non-map schema: \" + schema);\n    return getId(schema, VALUE_ID_PROP);\n  }\n\n  public static int getElementId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Cannot get array element id for non-array schema: \" + schema);\n    return getId(schema, ELEMENT_ID_PROP);\n  }\n\n  public static int getFieldId(Schema.Field field) {\n    Object id = field.getObjectProp(FIELD_ID_PROP);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", FIELD_ID_PROP);\n\n    return toInt(id);\n  }\n\n  private static int toInt(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).intValue();\n    } else if (value instanceof String) {\n      return Integer.parseInt((String) value);\n    }\n\n    throw new UnsupportedOperationException(\"Cannot coerce value to int: \" + value);\n  }\n\n  static Schema copyRecord(Schema record, List<Schema.Field> newFields, String newName) {\n    Schema copy;\n    if (newName != null) {\n      copy = Schema.createRecord(newName, record.getDoc(), null, record.isError(), newFields);\n\n\n\n      copy.addAlias(record.getName(), record.getNamespace() == null ? \"\" : record.getNamespace());\n    } else {\n      copy = Schema.createRecord(record.getName(),\n          record.getDoc(), record.getNamespace(), record.isError(), newFields);\n    }\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  static Schema.Field copyField(Schema.Field field, Schema newSchema, String newName) {\n    Schema.Field copy = new Schema.Field(newName,\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    if (!newName.equals(field.name())) {\n      copy.addAlias(field.name());\n    }\n\n    return copy;\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/LogicalMap.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'"
        ],
        "content": "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'\n:\npackage io.airlift.drift.transport.netty.client;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.transport.client.MethodInvoker;\nimport io.airlift.drift.transport.client.MethodInvokerFactory;\nimport io.airlift.drift.transport.netty.client.ConnectionManager.ConnectionParameters;\nimport io.airlift.drift.transport.netty.ssl.SslContextFactory;\nimport io.airlift.drift.transport.netty.ssl.SslContextFactory.SslContextParameters;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport jakarta.annotation.PreDestroy;\n\nimport java.io.Closeable;\nimport java.util.Optional;\nimport java.util.function.Function;\n\nimport static io.airlift.concurrent.Threads.daemonThreadsNamed;\nimport static io.airlift.drift.transport.netty.codec.Protocol.COMPACT;\nimport static io.airlift.drift.transport.netty.codec.Transport.HEADER;\nimport static io.airlift.drift.transport.netty.ssl.SslContextFactory.createSslContextFactory;\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\npublic class DriftNettyMethodInvokerFactory<I>\n        implements MethodInvokerFactory<I>, Closeable\n{\n    private final Function<I, DriftNettyClientConfig> clientConfigurationProvider;\n\n    private final EventLoopGroup group;\n    private final SslContextFactory sslContextFactory;\n    private final Optional<HostAndPort> defaultSocksProxy;\n    private final ConnectionManager connectionManager;\n\n    public static DriftNettyMethodInvokerFactory<?> createStaticDriftNettyMethodInvokerFactory(DriftNettyClientConfig clientConfig)\n    {\n        return createStaticDriftNettyMethodInvokerFactory(clientConfig, ByteBufAllocator.DEFAULT);\n    }\n\n    @VisibleForTesting\n    public static DriftNettyMethodInvokerFactory<?> createStaticDriftNettyMethodInvokerFactory(DriftNettyClientConfig clientConfig, ByteBufAllocator allocator)\n    {\n        return new DriftNettyMethodInvokerFactory<>(new DriftNettyConnectionFactoryConfig(), clientIdentity -> clientConfig, allocator);\n    }\n\n    public DriftNettyMethodInvokerFactory(\n            DriftNettyConnectionFactoryConfig factoryConfig,\n            Function<I, DriftNettyClientConfig> clientConfigurationProvider)\n    {\n        this(factoryConfig, clientConfigurationProvider, ByteBufAllocator.DEFAULT);\n    }\n\n    @VisibleForTesting\n    public DriftNettyMethodInvokerFactory(\n            DriftNettyConnectionFactoryConfig factoryConfig,\n            Function<I, DriftNettyClientConfig> clientConfigurationProvider,\n            ByteBufAllocator allocator)\n    {\n        requireNonNull(factoryConfig, \"factoryConfig is null\");\n\n        group = new NioEventLoopGroup(factoryConfig.getThreadCount(), daemonThreadsNamed(\"drift-client-%s\"));\n\n        this.clientConfigurationProvider = requireNonNull(clientConfigurationProvider, \"clientConfigurationProvider is null\");\n        this.sslContextFactory = createSslContextFactory(true, factoryConfig.getSslContextRefreshTime(), group);\n        this.defaultSocksProxy = Optional.ofNullable(factoryConfig.getSocksProxy());\n\n        ConnectionManager connectionManager = new ConnectionFactory(group, sslContextFactory, allocator);\n        if (factoryConfig.isConnectionPoolEnabled()) {\n            connectionManager = new ConnectionPool(connectionManager, group, factoryConfig.getConnectionPoolMaxSize(), factoryConfig.getConnectionPoolIdleTimeout());\n        }\n        this.connectionManager = connectionManager;\n    }\n\n    @Override\n    public MethodInvoker createMethodInvoker(I clientIdentity)\n    {\n        ConnectionParameters clientConfig = toConnectionConfig(clientConfigurationProvider.apply(clientIdentity));\n\n\n        clientConfig.getSslContextParameters()\n                .ifPresent(sslContextParameters -> sslContextFactory.get(sslContextParameters).get());\n\n        return new DriftNettyMethodInvoker(clientConfig, connectionManager, group);\n    }\n\n    @PreDestroy\n    @Override\n    public void close()\n    {\n        try {\n            connectionManager.close();\n        }\n        finally {\n            try {\n                group.shutdownGracefully(0, 0, MILLISECONDS).await();\n            }\n            catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    private ConnectionParameters toConnectionConfig(DriftNettyClientConfig clientConfig)\n    {\n        if (clientConfig.getTransport() == HEADER && clientConfig.getProtocol() == COMPACT) {\n            throw new IllegalArgumentException(\"HEADER transport cannot be used with COMPACT protocol, use FB_COMPACT instead\");\n        }\n\n        Optional<SslContextParameters> sslContextConfig = Optional.empty();\n        if (clientConfig.isSslEnabled()) {\n            sslContextConfig = Optional.of(new SslContextParameters(\n                    clientConfig.getTrustCertificate(),\n                    Optional.ofNullable(clientConfig.getKey()),\n                    Optional.ofNullable(clientConfig.getKey()),\n                    Optional.ofNullable(clientConfig.getKeyPassword()),\n                    clientConfig.getSessionCacheSize(),\n                    clientConfig.getSessionTimeout(),\n                    clientConfig.getCiphers()));\n        }\n\n        Optional<HostAndPort> socksProxy = Optional.ofNullable(clientConfig.getSocksProxy());\n        if (!socksProxy.isPresent()) {\n            socksProxy = defaultSocksProxy;\n        }\n\n        return new ConnectionParameters(\n                clientConfig.getTransport(),\n                clientConfig.getProtocol(),\n                clientConfig.getMaxFrameSize(),\n                clientConfig.getConnectTimeout(),\n                clientConfig.getRequestTimeout(),\n                socksProxy,\n                sslContextConfig);\n    }\n}\n\n'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Streams;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.drift.DriftScribeService;\nimport io.airlift.drift.server.DriftServer;\nimport io.airlift.drift.server.DriftService;\nimport io.airlift.drift.server.stats.NullMethodInvocationStatsFactory;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerConfig;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransportFactory;\nimport org.testng.annotations.Test;\n\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Consumer;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Lists.newArrayList;\nimport static io.airlift.drift.integration.ApacheThriftTesterUtil.apacheThriftTestClients;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_MESSAGES;\nimport static io.airlift.drift.integration.ClientTestUtils.HEADER_VALUE;\nimport static io.airlift.drift.integration.DriftNettyTesterUtil.driftNettyTestClients;\nimport static io.airlift.drift.integration.LegacyApacheThriftTesterUtil.legacyApacheThriftTestClients;\nimport static io.airlift.drift.transport.netty.codec.Transport.HEADER;\nimport static java.util.Collections.nCopies;\nimport static org.testng.Assert.assertEquals;\n\npublic class TestClientsWithDriftNettyServer\n{\n    private static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n\n    @Test\n    public void testDriftServer()\n    {\n        testDriftServer(ImmutableList.of());\n    }\n\n    @Test\n    public void testHandlersWithDriftServer()\n    {\n        TestingFilter firstFilter = new TestingFilter();\n        TestingFilter secondFilter = new TestingFilter();\n        List<MethodInvocationFilter> filters = ImmutableList.of(firstFilter, secondFilter);\n\n        int invocationCount = testDriftServer(filters);\n\n        firstFilter.assertCounts(invocationCount);\n        secondFilter.assertCounts(invocationCount);\n    }\n\n    private static int testDriftServer(List<MethodInvocationFilter> filters)\n    {\n        DriftScribeService scribeService = new DriftScribeService();\n        AtomicInteger invocationCount = new AtomicInteger();\n        AtomicInteger headerInvocationCount = new AtomicInteger();\n        testDriftServer(new DriftService(scribeService), address -> {\n            for (boolean secure : ImmutableList.of(true, false)) {\n                for (Transport transport : ImmutableList.of(HEADER)) {\n                    for (Protocol protocol : Protocol.values()) {\n                        int count = Streams.concat(\n                                legacyApacheThriftTestClients(filters, transport, protocol, secure).stream(),\n                                driftNettyTestClients(filters, transport, protocol, secure).stream(),\n                                apacheThriftTestClients(filters, transport, protocol, secure).stream())\n                                .mapToInt(client -> client.applyAsInt(address))\n                                .sum();\n                        invocationCount.addAndGet(count);\n                        if (transport == HEADER) {\n                            headerInvocationCount.addAndGet(count);\n                        }\n                    }\n                }\n            }\n        });\n\n        assertEquals(scribeService.getMessages(), newArrayList(concat(nCopies(invocationCount.get(), DRIFT_MESSAGES))));\n        assertEquals(scribeService.getHeaders(), newArrayList(nCopies(headerInvocationCount.get(), HEADER_VALUE)));\n\n        return invocationCount.get();\n    }\n\n    private static void testDriftServer(DriftService service, Consumer<HostAndPort> task)\n    {\n        DriftNettyServerConfig config = new DriftNettyServerConfig()\n                .setSslEnabled(true)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setKey(ClientTestUtils.getPrivateKeyFile());\n        TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n        DriftServer driftServer = new DriftServer(\n                new DriftNettyServerTransportFactory(config, testingAllocator),\n                CODEC_MANAGER,\n                new NullMethodInvocationStatsFactory(),\n                ImmutableSet.of(service),\n                ImmutableSet.of());\n        try {\n            driftServer.start();\n\n            HostAndPort address = HostAndPort.fromParts(\"localhost\", ((DriftNettyServerTransport) driftServer.getServerTransport()).getPort());\n\n            task.accept(address);\n        }\n        finally {\n            driftServer.shutdown();\n            testingAllocator.close();\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServer.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/codec/Protocol.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.codec.ThriftCodec;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftResultCode;\nimport io.airlift.drift.transport.MethodMetadata;\nimport io.airlift.drift.transport.ParameterMetadata;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerConfig;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransportFactory;\nimport io.airlift.drift.transport.server.ServerInvokeRequest;\nimport io.airlift.drift.transport.server.ServerMethodInvoker;\nimport io.airlift.drift.transport.server.ServerTransport;\nimport org.testng.annotations.Test;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.ToIntFunction;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static com.google.common.collect.Lists.newArrayList;\nimport static io.airlift.drift.codec.metadata.ThriftType.list;\nimport static io.airlift.drift.integration.ApacheThriftTesterUtil.apacheThriftTestClients;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_OK;\nimport static io.airlift.drift.integration.ClientTestUtils.MESSAGES;\nimport static io.airlift.drift.integration.DriftNettyTesterUtil.driftNettyTestClients;\nimport static io.airlift.drift.integration.LegacyApacheThriftTesterUtil.legacyApacheThriftTestClients;\nimport static java.util.Collections.nCopies;\nimport static org.testng.Assert.assertEquals;\n\npublic class TestClientsWithDriftNettyServerTransport\n{\n    @Test\n    public void testDriftServer()\n    {\n        testDriftServer(ImmutableList.of());\n    }\n\n    @Test\n    public void testHandlersWithDriftServer()\n    {\n        TestingFilter firstFilter = new TestingFilter();\n        TestingFilter secondFilter = new TestingFilter();\n        List<MethodInvocationFilter> filters = ImmutableList.of(firstFilter, secondFilter);\n\n        int invocationCount = testDriftServer(filters);\n\n        firstFilter.assertCounts(invocationCount);\n        secondFilter.assertCounts(invocationCount);\n    }\n\n    private static int testDriftServer(List<MethodInvocationFilter> filters)\n    {\n        TestServerMethodInvoker methodInvoker = new TestServerMethodInvoker();\n\n        ImmutableList.Builder<ToIntFunction<HostAndPort>> clients = ImmutableList.builder();\n        for (boolean secure : ImmutableList.of(true, false)) {\n            for (Transport transport : Transport.values()) {\n                for (Protocol protocol : Protocol.values()) {\n                    clients.addAll(legacyApacheThriftTestClients(filters, transport, protocol, secure))\n                            .addAll(driftNettyTestClients(filters, transport, protocol, secure))\n                            .addAll(apacheThriftTestClients(filters, transport, protocol, secure));\n                }\n            }\n        }\n        int invocationCount = testDriftServer(methodInvoker, clients.build());\n\n        assertEquals(methodInvoker.getMessages(), newArrayList(concat(nCopies(invocationCount, MESSAGES))));\n\n        return invocationCount;\n    }\n\n    private static int testDriftServer(ServerMethodInvoker methodInvoker, List<ToIntFunction<HostAndPort>> clients)\n    {\n        DriftNettyServerConfig config = new DriftNettyServerConfig()\n                .setSslEnabled(true)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setKey(ClientTestUtils.getPrivateKeyFile());\n        TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n        ServerTransport serverTransport = new DriftNettyServerTransportFactory(config, testingAllocator).createServerTransport(methodInvoker);\n        try {\n            serverTransport.start();\n\n            HostAndPort address = HostAndPort.fromParts(\"localhost\", ((DriftNettyServerTransport) serverTransport).getPort());\n\n            int sum = 0;\n            for (ToIntFunction<HostAndPort> client : clients) {\n                sum += client.applyAsInt(address);\n            }\n            return sum;\n        }\n        finally {\n            serverTransport.shutdown();\n            testingAllocator.close();\n        }\n    }\n\n    private static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n    private static final MethodMetadata LOG_METHOD_METADATA = new MethodMetadata(\n            \"Log\",\n            ImmutableList.of(new ParameterMetadata(\n                    (short) 1,\n                    \"messages\",\n                    (ThriftCodec<Object>) CODEC_MANAGER.getCodec(list(CODEC_MANAGER.getCodec(DriftLogEntry.class).getType())))),\n            (ThriftCodec<Object>) (Object) CODEC_MANAGER.getCodec(DriftResultCode.class),\n            ImmutableMap.of(),\n            ImmutableMap.of(),\n            false,\n            true);\n\n    private static class TestServerMethodInvoker\n            implements ServerMethodInvoker\n    {\n        private final List<LogEntry> messages = new CopyOnWriteArrayList<>();\n\n        private List<LogEntry> getMessages()\n        {\n            return messages;\n        }\n\n        @Override\n        public Optional<MethodMetadata> getMethodMetadata(String name)\n        {\n            if (LOG_METHOD_METADATA.getName().equals(name)) {\n                return Optional.of(LOG_METHOD_METADATA);\n            }\n            return Optional.empty();\n        }\n\n        @Override\n        public ListenableFuture<Object> invoke(ServerInvokeRequest request)\n        {\n            MethodMetadata method = request.getMethod();\n            if (!LOG_METHOD_METADATA.getName().equals(method.getName())) {\n                return Futures.immediateFailedFuture(new IllegalArgumentException(\"unknown method \" + method));\n            }\n\n            Map<Short, Object> parameters = request.getParameters();\n            if (parameters.size() != 1 || !parameters.containsKey((short) 1) || !(getOnlyElement(parameters.values()) instanceof List)) {\n                return Futures.immediateFailedFuture(new IllegalArgumentException(\"invalid parameters\"));\n            }\n            for (DriftLogEntry driftLogEntry : (List<DriftLogEntry>) getOnlyElement(parameters.values())) {\n                messages.add(new LogEntry(driftLogEntry.getCategory(), driftLogEntry.getMessage()));\n            }\n\n            return Futures.immediateFuture(DRIFT_OK);\n        }\n\n        @Override\n        public void recordResult(String methodName, long startTime, ListenableFuture<Object> result)\n        {\n\n        }\n    }\n}\n\n'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/codec/Protocol.java'\n:\npackage io.airlift.drift.transport.netty.codec;\n\nimport io.airlift.drift.protocol.TBinaryProtocol;\nimport io.airlift.drift.protocol.TCompactProtocol;\nimport io.airlift.drift.protocol.TFacebookCompactProtocol;\nimport io.airlift.drift.protocol.TProtocol;\nimport io.airlift.drift.protocol.TTransport;\n\npublic enum Protocol\n{\n    BINARY {\n        @Override\n        public TProtocol createProtocol(TTransport transport)\n        {\n            return new TBinaryProtocol(transport);\n        }\n\n        @Override\n        public int getHeaderTransportId()\n        {\n            return 0;\n        }\n    },\n    COMPACT {\n        @Override\n        public TProtocol createProtocol(TTransport transport)\n        {\n            return new TCompactProtocol(transport);\n        }\n\n        @Override\n        public int getHeaderTransportId()\n        {\n            throw new IllegalStateException(\"COMPACT can not be used with HEADER transport; use FB_COMPACT instead\");\n        }\n    },\n    FB_COMPACT {\n        @Override\n        public TProtocol createProtocol(TTransport transport)\n        {\n            return new TFacebookCompactProtocol(transport);\n        }\n\n        @Override\n        public int getHeaderTransportId()\n        {\n            return 2;\n        }\n    };\n\n    public abstract TProtocol createProtocol(TTransport transport);\n\n    public abstract int getHeaderTransportId();\n\n    public static Protocol getProtocolByHeaderTransportId(int headerTransportId)\n    {\n        if (headerTransportId == BINARY.getHeaderTransportId()) {\n            return BINARY;\n        }\n        if (headerTransportId == FB_COMPACT.getHeaderTransportId()) {\n            return FB_COMPACT;\n        }\n        throw new IllegalArgumentException(\"Unsupported header transport protocol ID: \" + headerTransportId);\n    }\n}\n",
        "gt": [
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/codec/Protocol.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/DriftNettyMethodInvokerFactory.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'"
        ],
        "content": "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.netflix.iceberg.Files;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.io.CloseableIterable;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.junit.Assert;\nimport org.junit.Assume;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.spark.data.TestHelpers.assertEqualsUnsafe;\n\npublic class TestSparkParquetReader extends AvroDataTest {\n  protected void writeAndValidate(Schema schema) throws IOException {\n    Assume.assumeTrue(\"Parquet Avro cannot write non-string map keys\", null == TypeUtil.find(schema,\n        type -> type.isMapType() && type.asMapType().keyType() != Types.StringType.get()));\n\n    List<GenericData.Record> expected = RandomData.generateList(schema, 100, 0L);\n\n    File testFile = temp.newFile();\n    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n\n    try (FileAppender<GenericData.Record> writer = Parquet.write(Files.localOutput(testFile))\n        .schema(schema)\n        .named(\"test\")\n        .build()) {\n      writer.addAll(expected);\n    }\n\n    try (CloseableIterable<InternalRow> reader = Parquet.read(Files.localInput(testFile))\n        .project(schema)\n        .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n        .build()) {\n      Iterator<InternalRow> rows = reader.iterator();\n      for (int i = 0; i < expected.size(); i += 1) {\n        Assert.assertTrue(\"Should have expected number of rows\", rows.hasNext());\n        assertEqualsUnsafe(schema.asStruct(), expected.get(i), rows.next());\n      }\n      Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n    }\n  }\n}\n\n'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'\n:\n\npackage com.netflix.iceberg.types;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic class TypeUtil {\n  public static Schema select(Schema schema, Set<Integer> fieldIds) {\n    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n    Preconditions.checkNotNull(fieldIds, \"Field ids cannot be null\");\n\n    Type result = visit(schema, new PruneColumns(fieldIds));\n    if (schema.asStruct() == result) {\n      return schema;\n    } else if (result != null) {\n      if (schema.getAliases() != null) {\n        return new Schema(result.asNestedType().fields(), schema.getAliases());\n      } else {\n        return new Schema(result.asNestedType().fields());\n      }\n    }\n\n    return new Schema(ImmutableList.of(), schema.getAliases());\n  }\n\n  public static Set<Integer> getProjectedIds(Schema schema) {\n    return visit(schema, new GetProjectedIds());\n  }\n\n  public static Set<Integer> getProjectedIds(Type schema) {\n    if (schema.isPrimitiveType()) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(visit(schema, new GetProjectedIds()));\n  }\n\n  public static Schema selectNot(Schema schema, Set<Integer> fieldIds) {\n    Set<Integer> projectedIds = getProjectedIds(schema);\n    projectedIds.removeAll(fieldIds);\n    return select(schema, projectedIds);\n  }\n\n  public static Schema join(Schema left, Schema right) {\n    List<Types.NestedField> joinedColumns = Lists.newArrayList();\n    joinedColumns.addAll(left.columns());\n    joinedColumns.addAll(right.columns());\n    return new Schema(joinedColumns);\n  }\n\n  public static Map<String, Integer> indexByName(Types.StructType struct) {\n    return visit(struct, new IndexByName());\n  }\n\n  public static Map<Integer, Types.NestedField> indexById(Types.StructType struct) {\n    return visit(struct, new IndexById());\n  }\n\n\n  public static Type assignFreshIds(Type type, NextID nextId) {\n    return TypeUtil.visit(type, new AssignFreshIds(nextId));\n  }\n\n\n  public static Schema assignFreshIds(Schema schema, NextID nextId) {\n    return new Schema(TypeUtil\n        .visit(schema.asStruct(), new AssignFreshIds(nextId))\n        .asNestedType()\n        .fields());\n  }\n\n\n  public static Schema reassignIds(Schema schema, Schema idSourceSchema) {\n    Types.StructType struct = visit(schema, new ReassignIds(idSourceSchema)).asStructType();\n    return new Schema(struct.fields());\n  }\n\n  public static Type find(Schema schema, Predicate<Type> predicate) {\n    return visit(schema, new FindTypeVisitor(predicate));\n  }\n\n  public static boolean isPromotionAllowed(Type from, Type.PrimitiveType to) {\n\n\n    if (from.equals(to)) {\n      return true;\n    }\n\n    switch (from.typeId()) {\n      case INTEGER:\n        return to == Types.LongType.get();\n\n      case FLOAT:\n        return to == Types.DoubleType.get();\n\n      case DECIMAL:\n        Types.DecimalType fromDecimal = (Types.DecimalType) from;\n        if (to.typeId() != Type.TypeID.DECIMAL) {\n          return false;\n        }\n\n        Types.DecimalType toDecimal = (Types.DecimalType) to;\n        return (fromDecimal.scale() == toDecimal.scale() &&\n            fromDecimal.precision() <= toDecimal.precision());\n    }\n\n    return false;\n  }\n\n\n  public interface NextID {\n    int get();\n  }\n\n  public static class SchemaVisitor<T> {\n    protected LinkedList<String> fieldNames = Lists.newLinkedList();\n    protected LinkedList<Integer> fieldIds = Lists.newLinkedList();\n\n    public T schema(Schema schema, T structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, List<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, T fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, T elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, T keyResult, T valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  public static <T> T visit(Schema schema, SchemaVisitor<T> visitor) {\n    return visitor.schema(schema, visit(schema.asStruct(), visitor));\n  }\n\n  public static <T> T visit(Type type, SchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<T> results = Lists.newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          visitor.fieldIds.push(field.fieldId());\n          visitor.fieldNames.push(field.name());\n          T result;\n          try {\n            result = visit(field.type(), visitor);\n          } finally {\n            visitor.fieldIds.pop();\n            visitor.fieldNames.pop();\n          }\n          results.add(visitor.field(field, result));\n        }\n        return visitor.struct(struct, results);\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        T elementResult;\n\n        visitor.fieldIds.push(list.elementId());\n        try {\n          elementResult = visit(list.elementType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.list(list, elementResult);\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        T keyResult;\n        T valueResult;\n\n        visitor.fieldIds.push(map.keyId());\n        try {\n          keyResult = visit(map.keyType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        visitor.fieldIds.push(map.valueId());\n        try {\n          valueResult = visit(map.valueType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.map(map, keyResult, valueResult);\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  public static class CustomOrderSchemaVisitor<T> {\n    public T schema(Schema schema, Supplier<T> structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, Iterable<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, Supplier<T> fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, Supplier<T> elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, Supplier<T> keyResult, Supplier<T> valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  private static class VisitFuture<T> implements Supplier<T> {\n    private final Type type;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFuture(Type type, CustomOrderSchemaVisitor<T> visitor) {\n      this.type = type;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visit(type, visitor);\n    }\n  }\n\n  private static class VisitFieldFuture<T> implements Supplier<T> {\n    private final Types.NestedField field;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFieldFuture(Types.NestedField field, CustomOrderSchemaVisitor<T> visitor) {\n      this.field = field;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visitor.field(field, new VisitFuture<>(field.type(), visitor));\n    }\n  }\n\n  public static <T> T visit(Schema schema, CustomOrderSchemaVisitor<T> visitor) {\n    return visitor.schema(schema, new VisitFuture<>(schema.asStruct(), visitor));\n  }\n\n\n  public static <T> T visit(Type type, CustomOrderSchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<VisitFieldFuture<T>> results = Lists\n            .newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          results.add(\n              new VisitFieldFuture<>(field, visitor));\n        }\n\n        return visitor.struct(struct, Iterables.transform(results, VisitFieldFuture::get));\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        return visitor.list(list, new VisitFuture<>(list.elementType(), visitor));\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        return visitor.map(map,\n            new VisitFuture<>(map.keyType(), visitor),\n            new VisitFuture<>(map.valueType(), visitor));\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  static int decimalMaxPrecision(int numBytes) {\n    Preconditions.checkArgument(numBytes >= 0 && numBytes < 24,\n        \"Unsupported decimal length: \" + numBytes);\n    return MAX_PRECISION[numBytes];\n  }\n\n  public static int decimalRequriedBytes(int precision) {\n    Preconditions.checkArgument(precision >= 0 && precision < 40,\n        \"Unsupported decimal precision: \" + precision);\n    return REQUIRED_LENGTH[precision];\n  }\n\n  private static int[] MAX_PRECISION = new int[24];\n  private static int[] REQUIRED_LENGTH = new int[40];\n\n  static {\n\n    for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n      MAX_PRECISION[len] = (int) Math.floor(Math.log10(Math.pow(2, 8*len - 1) - 1));\n    }\n\n\n    for (int precision = 0; precision < REQUIRED_LENGTH.length; precision += 1) {\n      REQUIRED_LENGTH[precision] = -1;\n      for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n\n        if (precision <= MAX_PRECISION[len]) {\n          REQUIRED_LENGTH[precision] = len;\n          break;\n        }\n      }\n      if (REQUIRED_LENGTH[precision] < 0) {\n        throw new IllegalStateException(\n            \"Could not find required length for precision \" + precision);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'"
        ]
    },
    {
        "files": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'"
        ],
        "content": "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'\n:\n\npackage com.netflix.iceberg.types;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic class TypeUtil {\n  public static Schema select(Schema schema, Set<Integer> fieldIds) {\n    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n    Preconditions.checkNotNull(fieldIds, \"Field ids cannot be null\");\n\n    Type result = visit(schema, new PruneColumns(fieldIds));\n    if (schema.asStruct() == result) {\n      return schema;\n    } else if (result != null) {\n      if (schema.getAliases() != null) {\n        return new Schema(result.asNestedType().fields(), schema.getAliases());\n      } else {\n        return new Schema(result.asNestedType().fields());\n      }\n    }\n\n    return new Schema(ImmutableList.of(), schema.getAliases());\n  }\n\n  public static Set<Integer> getProjectedIds(Schema schema) {\n    return visit(schema, new GetProjectedIds());\n  }\n\n  public static Set<Integer> getProjectedIds(Type schema) {\n    if (schema.isPrimitiveType()) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(visit(schema, new GetProjectedIds()));\n  }\n\n  public static Schema selectNot(Schema schema, Set<Integer> fieldIds) {\n    Set<Integer> projectedIds = getProjectedIds(schema);\n    projectedIds.removeAll(fieldIds);\n    return select(schema, projectedIds);\n  }\n\n  public static Schema join(Schema left, Schema right) {\n    List<Types.NestedField> joinedColumns = Lists.newArrayList();\n    joinedColumns.addAll(left.columns());\n    joinedColumns.addAll(right.columns());\n    return new Schema(joinedColumns);\n  }\n\n  public static Map<String, Integer> indexByName(Types.StructType struct) {\n    return visit(struct, new IndexByName());\n  }\n\n  public static Map<Integer, Types.NestedField> indexById(Types.StructType struct) {\n    return visit(struct, new IndexById());\n  }\n\n\n  public static Type assignFreshIds(Type type, NextID nextId) {\n    return TypeUtil.visit(type, new AssignFreshIds(nextId));\n  }\n\n\n  public static Schema assignFreshIds(Schema schema, NextID nextId) {\n    return new Schema(TypeUtil\n        .visit(schema.asStruct(), new AssignFreshIds(nextId))\n        .asNestedType()\n        .fields());\n  }\n\n\n  public static Schema reassignIds(Schema schema, Schema idSourceSchema) {\n    Types.StructType struct = visit(schema, new ReassignIds(idSourceSchema)).asStructType();\n    return new Schema(struct.fields());\n  }\n\n  public static Type find(Schema schema, Predicate<Type> predicate) {\n    return visit(schema, new FindTypeVisitor(predicate));\n  }\n\n  public static boolean isPromotionAllowed(Type from, Type.PrimitiveType to) {\n\n\n    if (from.equals(to)) {\n      return true;\n    }\n\n    switch (from.typeId()) {\n      case INTEGER:\n        return to == Types.LongType.get();\n\n      case FLOAT:\n        return to == Types.DoubleType.get();\n\n      case DECIMAL:\n        Types.DecimalType fromDecimal = (Types.DecimalType) from;\n        if (to.typeId() != Type.TypeID.DECIMAL) {\n          return false;\n        }\n\n        Types.DecimalType toDecimal = (Types.DecimalType) to;\n        return (fromDecimal.scale() == toDecimal.scale() &&\n            fromDecimal.precision() <= toDecimal.precision());\n    }\n\n    return false;\n  }\n\n\n  public interface NextID {\n    int get();\n  }\n\n  public static class SchemaVisitor<T> {\n    protected LinkedList<String> fieldNames = Lists.newLinkedList();\n    protected LinkedList<Integer> fieldIds = Lists.newLinkedList();\n\n    public T schema(Schema schema, T structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, List<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, T fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, T elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, T keyResult, T valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  public static <T> T visit(Schema schema, SchemaVisitor<T> visitor) {\n    return visitor.schema(schema, visit(schema.asStruct(), visitor));\n  }\n\n  public static <T> T visit(Type type, SchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<T> results = Lists.newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          visitor.fieldIds.push(field.fieldId());\n          visitor.fieldNames.push(field.name());\n          T result;\n          try {\n            result = visit(field.type(), visitor);\n          } finally {\n            visitor.fieldIds.pop();\n            visitor.fieldNames.pop();\n          }\n          results.add(visitor.field(field, result));\n        }\n        return visitor.struct(struct, results);\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        T elementResult;\n\n        visitor.fieldIds.push(list.elementId());\n        try {\n          elementResult = visit(list.elementType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.list(list, elementResult);\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        T keyResult;\n        T valueResult;\n\n        visitor.fieldIds.push(map.keyId());\n        try {\n          keyResult = visit(map.keyType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        visitor.fieldIds.push(map.valueId());\n        try {\n          valueResult = visit(map.valueType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.map(map, keyResult, valueResult);\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  public static class CustomOrderSchemaVisitor<T> {\n    public T schema(Schema schema, Supplier<T> structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, Iterable<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, Supplier<T> fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, Supplier<T> elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, Supplier<T> keyResult, Supplier<T> valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  private static class VisitFuture<T> implements Supplier<T> {\n    private final Type type;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFuture(Type type, CustomOrderSchemaVisitor<T> visitor) {\n      this.type = type;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visit(type, visitor);\n    }\n  }\n\n  private static class VisitFieldFuture<T> implements Supplier<T> {\n    private final Types.NestedField field;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFieldFuture(Types.NestedField field, CustomOrderSchemaVisitor<T> visitor) {\n      this.field = field;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visitor.field(field, new VisitFuture<>(field.type(), visitor));\n    }\n  }\n\n  public static <T> T visit(Schema schema, CustomOrderSchemaVisitor<T> visitor) {\n    return visitor.schema(schema, new VisitFuture<>(schema.asStruct(), visitor));\n  }\n\n\n  public static <T> T visit(Type type, CustomOrderSchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<VisitFieldFuture<T>> results = Lists\n            .newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          results.add(\n              new VisitFieldFuture<>(field, visitor));\n        }\n\n        return visitor.struct(struct, Iterables.transform(results, VisitFieldFuture::get));\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        return visitor.list(list, new VisitFuture<>(list.elementType(), visitor));\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        return visitor.map(map,\n            new VisitFuture<>(map.keyType(), visitor),\n            new VisitFuture<>(map.valueType(), visitor));\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  static int decimalMaxPrecision(int numBytes) {\n    Preconditions.checkArgument(numBytes >= 0 && numBytes < 24,\n        \"Unsupported decimal length: \" + numBytes);\n    return MAX_PRECISION[numBytes];\n  }\n\n  public static int decimalRequriedBytes(int precision) {\n    Preconditions.checkArgument(precision >= 0 && precision < 40,\n        \"Unsupported decimal precision: \" + precision);\n    return REQUIRED_LENGTH[precision];\n  }\n\n  private static int[] MAX_PRECISION = new int[24];\n  private static int[] REQUIRED_LENGTH = new int[40];\n\n  static {\n\n    for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n      MAX_PRECISION[len] = (int) Math.floor(Math.log10(Math.pow(2, 8*len - 1) - 1));\n    }\n\n\n    for (int precision = 0; precision < REQUIRED_LENGTH.length; precision += 1) {\n      REQUIRED_LENGTH[precision] = -1;\n      for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n\n        if (precision <= MAX_PRECISION[len]) {\n          REQUIRED_LENGTH[precision] = len;\n          break;\n        }\n      }\n      if (REQUIRED_LENGTH[precision] < 0) {\n        throw new IllegalStateException(\n            \"Could not find required length for precision \" + precision);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/test/java/com/netflix/iceberg/avro/TestSchemaConversions.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/avro/AvroTestHelpers.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'"
        ],
        "content": "'iceberg/core/src/test/java/com/netflix/iceberg/avro/TestSchemaConversions.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport org.apache.avro.SchemaBuilder;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport java.util.List;\n\nimport static com.netflix.iceberg.avro.AvroTestHelpers.addElementId;\nimport static com.netflix.iceberg.avro.AvroTestHelpers.addKeyId;\nimport static com.netflix.iceberg.avro.AvroTestHelpers.addValueId;\nimport static com.netflix.iceberg.avro.AvroTestHelpers.optionalField;\nimport static com.netflix.iceberg.avro.AvroTestHelpers.record;\nimport static com.netflix.iceberg.avro.AvroTestHelpers.requiredField;\nimport static com.netflix.iceberg.types.Types.NestedField.optional;\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\npublic class TestSchemaConversions {\n  @Test\n  public void testPrimitiveTypes() {\n    List<Type> primitives = Lists.newArrayList(\n        Types.BooleanType.get(),\n        Types.IntegerType.get(),\n        Types.LongType.get(),\n        Types.FloatType.get(),\n        Types.DoubleType.get(),\n        Types.DateType.get(),\n        Types.TimeType.get(),\n        Types.TimestampType.withZone(),\n        Types.TimestampType.withoutZone(),\n        Types.StringType.get(),\n        Types.UUIDType.get(),\n        Types.FixedType.ofLength(12),\n        Types.BinaryType.get(),\n        Types.DecimalType.of(9, 4)\n    );\n\n    List<Schema> avroPrimitives = Lists.newArrayList(\n        Schema.create(Schema.Type.BOOLEAN),\n        Schema.create(Schema.Type.INT),\n        Schema.create(Schema.Type.LONG),\n        Schema.create(Schema.Type.FLOAT),\n        Schema.create(Schema.Type.DOUBLE),\n        LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT)),\n        LogicalTypes.timeMicros().addToSchema(Schema.create(Schema.Type.LONG)),\n        addAdjustToUtc(LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG)), true),\n        addAdjustToUtc(LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG)), false),\n        Schema.create(Schema.Type.STRING),\n        LogicalTypes.uuid().addToSchema(Schema.createFixed(\"uuid_fixed\", null, null, 16)),\n        Schema.createFixed(\"fixed_12\", null, null, 12),\n        Schema.create(Schema.Type.BYTES),\n        LogicalTypes.decimal(9, 4).addToSchema(Schema.createFixed(\"decimal_9_4\", null, null, 4))\n    );\n\n    for (int i = 0; i < primitives.size(); i += 1) {\n      Type type = primitives.get(i);\n      Schema avro = avroPrimitives.get(i);\n      Assert.assertEquals(\"Avro schema to primitive: \" + avro,\n          type, AvroSchemaUtil.convert(avro));\n      Assert.assertEquals(\"Primitive to avro schema: \" + type,\n          avro, AvroSchemaUtil.convert(type));\n    }\n  }\n\n  private Schema addAdjustToUtc(Schema schema, boolean adjustToUTC) {\n    schema.addProp(AvroSchemaUtil.ADJUST_TO_UTC_PROP, adjustToUTC);\n    return schema;\n  }\n\n  @Test\n  public void testStructAndPrimitiveTypes() {\n    Types.StructType struct = Types.StructType.of(\n        optional(20, \"bool\", Types.BooleanType.get()),\n        optional(21, \"int\", Types.IntegerType.get()),\n        optional(22, \"long\", Types.LongType.get()),\n        optional(23, \"float\", Types.FloatType.get()),\n        optional(24, \"double\", Types.DoubleType.get()),\n        optional(25, \"date\", Types.DateType.get()),\n        optional(27, \"time\", Types.TimeType.get()),\n        optional(28, \"timestamptz\", Types.TimestampType.withZone()),\n        optional(29, \"timestamp\", Types.TimestampType.withoutZone()),\n        optional(30, \"string\", Types.StringType.get()),\n        optional(31, \"uuid\", Types.UUIDType.get()),\n        optional(32, \"fixed\", Types.FixedType.ofLength(16)),\n        optional(33, \"binary\", Types.BinaryType.get()),\n        optional(34, \"decimal\", Types.DecimalType.of(14, 2))\n    );\n\n    Schema schema = record(\"primitives\",\n        optionalField(20, \"bool\", Schema.create(Schema.Type.BOOLEAN)),\n        optionalField(21, \"int\", Schema.create(Schema.Type.INT)),\n        optionalField(22, \"long\", Schema.create(Schema.Type.LONG)),\n        optionalField(23, \"float\", Schema.create(Schema.Type.FLOAT)),\n        optionalField(24, \"double\", Schema.create(Schema.Type.DOUBLE)),\n        optionalField(25, \"date\", LogicalTypes.date().addToSchema(Schema.create(Schema.Type.INT))),\n        optionalField(27, \"time\", LogicalTypes.timeMicros().addToSchema(Schema.create(Schema.Type.LONG))),\n        optionalField(28, \"timestamptz\", addAdjustToUtc(LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG)), true)),\n        optionalField(29, \"timestamp\", addAdjustToUtc(LogicalTypes.timestampMicros().addToSchema(Schema.create(Schema.Type.LONG)), false)),\n        optionalField(30, \"string\", Schema.create(Schema.Type.STRING)),\n        optionalField(31, \"uuid\", LogicalTypes.uuid().addToSchema(Schema.createFixed(\"uuid_fixed\", null, null, 16))),\n        optionalField(32, \"fixed\", Schema.createFixed(\"fixed_16\", null, null, 16)),\n        optionalField(33, \"binary\", Schema.create(Schema.Type.BYTES)),\n        optionalField(34, \"decimal\", LogicalTypes.decimal(14, 2).addToSchema(Schema.createFixed(\"decimal_14_2\", null, null, 6)))\n    );\n\n    Assert.assertEquals(\"Test conversion from Avro schema\",\n        struct, AvroSchemaUtil.convert(schema));\n    Assert.assertEquals(\"Test conversion to Avro schema\",\n        schema, AvroSchemaUtil.convert(struct, \"primitives\"));\n  }\n\n  @Test\n  public void testList() {\n    Type list = Types.ListType.ofRequired(34, Types.UUIDType.get());\n    Schema schema = addElementId(34, SchemaBuilder.array().items(\n        LogicalTypes.uuid().addToSchema(Schema.createFixed(\"uuid_fixed\", null, null, 16))));\n\n    Assert.assertEquals(\"Avro schema to list\",\n        list, AvroSchemaUtil.convert(schema));\n    Assert.assertEquals(\"List to Avro schema\",\n        schema, AvroSchemaUtil.convert(list));\n  }\n\n  @Test\n  public void testListOfStructs() {\n    Type list = Types.ListType.ofRequired(34, Types.StructType.of(\n        required(35, \"lat\", Types.FloatType.get()),\n        required(36, \"long\", Types.FloatType.get())\n    ));\n\n    Schema schema = addElementId(34, SchemaBuilder.array().items(\n        record(\"r34\",\n            requiredField(35, \"lat\", Schema.create(Schema.Type.FLOAT)),\n            requiredField(36, \"long\", Schema.create(Schema.Type.FLOAT)))\n    ));\n\n    Assert.assertEquals(\"Avro schema to list\",\n        list, AvroSchemaUtil.convert(schema));\n    Assert.assertEquals(\"List to Avro schema\",\n        schema, AvroSchemaUtil.convert(list));\n  }\n\n  @Test\n  public void testMapOfLongToBytes() {\n    Type map = Types.MapType.ofRequired(33, 34, Types.LongType.get(), Types.BinaryType.get());\n    Schema schema = AvroSchemaUtil.createMap(\n        33, Schema.create(Schema.Type.LONG),\n        34, Schema.create(Schema.Type.BYTES));\n\n    Assert.assertEquals(\"Avro schema to map\",\n        map, AvroSchemaUtil.convert(schema));\n    Assert.assertEquals(\"Map to Avro schema\",\n        schema, AvroSchemaUtil.convert(map));\n  }\n\n  @Test\n  public void testMapOfStringToBytes() {\n    Type map = Types.MapType.ofRequired(33, 34, Types.StringType.get(), Types.BinaryType.get());\n    Schema schema = addKeyId(33, addValueId(34, SchemaBuilder.map().values(\n        Schema.create(Schema.Type.BYTES))));\n\n    Assert.assertEquals(\"Avro schema to map\",\n        map, AvroSchemaUtil.convert(schema));\n    Assert.assertEquals(\"Map to Avro schema\",\n        schema, AvroSchemaUtil.convert(map));\n  }\n\n  @Test\n  public void testMapOfListToStructs() {\n    Type map = Types.MapType.ofRequired(33, 34,\n        Types.ListType.ofRequired(35, Types.IntegerType.get()),\n        Types.StructType.of(\n            required(36, \"a\", Types.IntegerType.get()),\n            optional(37, \"b\", Types.IntegerType.get())\n        ));\n    Schema schema = AvroSchemaUtil.createMap(\n        33, addElementId(35, Schema.createArray(Schema.create(Schema.Type.INT))),\n        34, record(\"r34\",\n            requiredField(36, \"a\", Schema.create(Schema.Type.INT)),\n            optionalField(37, \"b\", Schema.create(Schema.Type.INT))));\n\n    Assert.assertEquals(\"Avro schema to map\",\n        map, AvroSchemaUtil.convert(schema));\n    Assert.assertEquals(\"Map to Avro schema\",\n        schema, AvroSchemaUtil.convert(map));\n  }\n\n  @Test\n  public void testMapOfStringToStructs() {\n    Type map = Types.MapType.ofRequired(33, 34, Types.StringType.get(), Types.StructType.of(\n        required(35, \"a\", Types.IntegerType.get()),\n        optional(36, \"b\", Types.IntegerType.get())\n    ));\n    Schema schema = addKeyId(33, addValueId(34, SchemaBuilder.map().values(\n        record(\"r34\",\n            requiredField(35, \"a\", Schema.create(Schema.Type.INT)),\n            optionalField(36, \"b\", Schema.create(Schema.Type.INT))))));\n\n    Assert.assertEquals(\"Avro schema to map\",\n        map, AvroSchemaUtil.convert(schema));\n    Assert.assertEquals(\"Map to Avro schema\",\n        schema, AvroSchemaUtil.convert(map));\n  }\n\n  @Test\n  public void testComplexSchema() {\n    com.netflix.iceberg.Schema schema = new com.netflix.iceberg.Schema(\n        required(1, \"id\", Types.IntegerType.get()),\n        optional(2, \"data\", Types.StringType.get()),\n        optional(\n            3,\n            \"preferences\",\n            Types.StructType\n                .of(required(8, \"feature1\", Types.BooleanType.get()), optional(9, \"feature2\", Types.BooleanType.get()))),\n        required(\n            4,\n            \"locations\",\n            Types.MapType.ofRequired(\n                10,\n                11,\n                Types.StructType.of(\n                    required(20, \"address\", Types.StringType.get()),\n                    required(21, \"city\", Types.StringType.get()),\n                    required(22, \"state\", Types.StringType.get()),\n                    required(23, \"zip\", Types.IntegerType.get())\n                ),\n                Types.StructType.of(required(12, \"lat\", Types.FloatType.get()), required(13, \"long\", Types.FloatType.get()))\n            )\n        ),\n        optional(\n            5,\n            \"points\",\n            Types.ListType.ofOptional(\n                14,\n                Types.StructType.of(required(15, \"x\", Types.LongType.get()), required(16, \"y\", Types.LongType.get())))),\n        required(6, \"doubles\", Types.ListType.ofRequired(17, Types.DoubleType.get())),\n        optional(7, \"properties\", Types.MapType.ofOptional(18, 19, Types.StringType.get(), Types.StringType.get())));\n\n    AvroSchemaUtil.convert(schema, \"newTableName\").toString(true);\n  }\n\n}\n\n'iceberg/core/src/test/java/com/netflix/iceberg/avro/AvroTestHelpers.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.Types;\nimport com.netflix.iceberg.util.CharSequenceWrapper;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.Schema;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.generic.GenericData.Record;\nimport org.junit.Assert;\n\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.toOption;\n\nclass AvroTestHelpers {\n  static Schema.Field optionalField(int id, String name, Schema schema) {\n    return addId(id, new Schema.Field(name, toOption(schema), null, JsonProperties.NULL_VALUE));\n\n  }\n\n  static Schema.Field requiredField(int id, String name, Schema schema) {\n    return addId(id, new Schema.Field(name, schema, null, null));\n  }\n\n  static Schema record(String name, Schema.Field... fields) {\n    return Schema.createRecord(name, null, null, false, Arrays.asList(fields));\n  }\n\n  static Schema.Field addId(int id, Schema.Field field) {\n    field.addProp(AvroSchemaUtil.FIELD_ID_PROP, id);\n    return field;\n  }\n\n  static Schema addElementId(int id, Schema schema) {\n    schema.addProp(AvroSchemaUtil.ELEMENT_ID_PROP, id);\n    return schema;\n  }\n\n  static Schema addKeyId(int id, Schema schema) {\n    schema.addProp(AvroSchemaUtil.KEY_ID_PROP, id);\n    return schema;\n  }\n\n  static Schema addValueId(int id, Schema schema) {\n    schema.addProp(AvroSchemaUtil.VALUE_ID_PROP, id);\n    return schema;\n  }\n\n  static void assertEquals(Types.StructType struct, Record expected, Record actual) {\n    List<Types.NestedField> fields = struct.fields();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Type fieldType = fields.get(i).type();\n\n      Object expectedValue = expected.get(i);\n      Object actualValue = actual.get(i);\n\n      assertEquals(fieldType, expectedValue, actualValue);\n    }\n  }\n\n  static void assertEquals(Types.ListType list, List<?> expected, List<?> actual) {\n    Type elementType = list.elementType();\n\n    Assert.assertEquals(\"List size should match\", expected.size(), actual.size());\n\n    for (int i = 0; i < expected.size(); i += 1) {\n      Object expectedValue = expected.get(i);\n      Object actualValue = actual.get(i);\n\n      assertEquals(elementType, expectedValue, actualValue);\n    }\n  }\n\n  static void assertEquals(Types.MapType map, Map<?, ?> expected, Map<?, ?> actual) {\n    Type valueType = map.valueType();\n\n    Assert.assertEquals(\"Map size should match\", expected.size(), actual.size());\n\n    for (Object expectedKey : expected.keySet()) {\n      Object expectedValue = expected.get(expectedKey);\n      Object actualValue = actual.get(expectedKey);\n\n      assertEquals(valueType, expectedValue, actualValue);\n    }\n  }\n\n  private static void assertEquals(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n      case STRING:\n      case DATE:\n      case TIME:\n      case TIMESTAMP:\n      case UUID:\n      case FIXED:\n      case BINARY:\n      case DECIMAL:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Expected should be a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Actual should be a Record\", actual instanceof Record);\n        assertEquals(type.asStructType(), (Record) expected, (Record) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Expected should be a List\", expected instanceof List);\n        Assert.assertTrue(\"Actual should be a List\", actual instanceof List);\n        assertEquals(type.asListType(), (List) expected, (List) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Expected should be a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Actual should be a Map\", actual instanceof Map);\n        assertEquals(type.asMapType(), (Map<?, ?>) expected, (Map<?, ?>) actual);\n        break;\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/avro/AvroTestHelpers.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/avro/TestSchemaConversions.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'"
        ],
        "content": "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.netflix.iceberg.Files;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.io.CloseableIterable;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.junit.Assert;\nimport org.junit.Assume;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.spark.data.TestHelpers.assertEqualsUnsafe;\n\npublic class TestSparkParquetReader extends AvroDataTest {\n  protected void writeAndValidate(Schema schema) throws IOException {\n    Assume.assumeTrue(\"Parquet Avro cannot write non-string map keys\", null == TypeUtil.find(schema,\n        type -> type.isMapType() && type.asMapType().keyType() != Types.StringType.get()));\n\n    List<GenericData.Record> expected = RandomData.generateList(schema, 100, 0L);\n\n    File testFile = temp.newFile();\n    Assert.assertTrue(\"Delete should succeed\", testFile.delete());\n\n    try (FileAppender<GenericData.Record> writer = Parquet.write(Files.localOutput(testFile))\n        .schema(schema)\n        .named(\"test\")\n        .build()) {\n      writer.addAll(expected);\n    }\n\n    try (CloseableIterable<InternalRow> reader = Parquet.read(Files.localInput(testFile))\n        .project(schema)\n        .createReaderFunc(type -> SparkParquetReaders.buildReader(schema, type))\n        .build()) {\n      Iterator<InternalRow> rows = reader.iterator();\n      for (int i = 0; i < expected.size(); i += 1) {\n        Assert.assertTrue(\"Should have expected number of rows\", rows.hasNext());\n        assertEqualsUnsafe(schema.asStruct(), expected.get(i), rows.next());\n      }\n      Assert.assertFalse(\"Should not have extra rows\", rows.hasNext());\n    }\n  }\n}\n\n'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'\n:\n\npackage com.netflix.iceberg.types;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic class TypeUtil {\n  public static Schema select(Schema schema, Set<Integer> fieldIds) {\n    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n    Preconditions.checkNotNull(fieldIds, \"Field ids cannot be null\");\n\n    Type result = visit(schema, new PruneColumns(fieldIds));\n    if (schema.asStruct() == result) {\n      return schema;\n    } else if (result != null) {\n      if (schema.getAliases() != null) {\n        return new Schema(result.asNestedType().fields(), schema.getAliases());\n      } else {\n        return new Schema(result.asNestedType().fields());\n      }\n    }\n\n    return new Schema(ImmutableList.of(), schema.getAliases());\n  }\n\n  public static Set<Integer> getProjectedIds(Schema schema) {\n    return visit(schema, new GetProjectedIds());\n  }\n\n  public static Set<Integer> getProjectedIds(Type schema) {\n    if (schema.isPrimitiveType()) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(visit(schema, new GetProjectedIds()));\n  }\n\n  public static Schema selectNot(Schema schema, Set<Integer> fieldIds) {\n    Set<Integer> projectedIds = getProjectedIds(schema);\n    projectedIds.removeAll(fieldIds);\n    return select(schema, projectedIds);\n  }\n\n  public static Schema join(Schema left, Schema right) {\n    List<Types.NestedField> joinedColumns = Lists.newArrayList();\n    joinedColumns.addAll(left.columns());\n    joinedColumns.addAll(right.columns());\n    return new Schema(joinedColumns);\n  }\n\n  public static Map<String, Integer> indexByName(Types.StructType struct) {\n    return visit(struct, new IndexByName());\n  }\n\n  public static Map<Integer, Types.NestedField> indexById(Types.StructType struct) {\n    return visit(struct, new IndexById());\n  }\n\n\n  public static Type assignFreshIds(Type type, NextID nextId) {\n    return TypeUtil.visit(type, new AssignFreshIds(nextId));\n  }\n\n\n  public static Schema assignFreshIds(Schema schema, NextID nextId) {\n    return new Schema(TypeUtil\n        .visit(schema.asStruct(), new AssignFreshIds(nextId))\n        .asNestedType()\n        .fields());\n  }\n\n\n  public static Schema reassignIds(Schema schema, Schema idSourceSchema) {\n    Types.StructType struct = visit(schema, new ReassignIds(idSourceSchema)).asStructType();\n    return new Schema(struct.fields());\n  }\n\n  public static Type find(Schema schema, Predicate<Type> predicate) {\n    return visit(schema, new FindTypeVisitor(predicate));\n  }\n\n  public static boolean isPromotionAllowed(Type from, Type.PrimitiveType to) {\n\n\n    if (from.equals(to)) {\n      return true;\n    }\n\n    switch (from.typeId()) {\n      case INTEGER:\n        return to == Types.LongType.get();\n\n      case FLOAT:\n        return to == Types.DoubleType.get();\n\n      case DECIMAL:\n        Types.DecimalType fromDecimal = (Types.DecimalType) from;\n        if (to.typeId() != Type.TypeID.DECIMAL) {\n          return false;\n        }\n\n        Types.DecimalType toDecimal = (Types.DecimalType) to;\n        return (fromDecimal.scale() == toDecimal.scale() &&\n            fromDecimal.precision() <= toDecimal.precision());\n    }\n\n    return false;\n  }\n\n\n  public interface NextID {\n    int get();\n  }\n\n  public static class SchemaVisitor<T> {\n    protected LinkedList<String> fieldNames = Lists.newLinkedList();\n    protected LinkedList<Integer> fieldIds = Lists.newLinkedList();\n\n    public T schema(Schema schema, T structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, List<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, T fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, T elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, T keyResult, T valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  public static <T> T visit(Schema schema, SchemaVisitor<T> visitor) {\n    return visitor.schema(schema, visit(schema.asStruct(), visitor));\n  }\n\n  public static <T> T visit(Type type, SchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<T> results = Lists.newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          visitor.fieldIds.push(field.fieldId());\n          visitor.fieldNames.push(field.name());\n          T result;\n          try {\n            result = visit(field.type(), visitor);\n          } finally {\n            visitor.fieldIds.pop();\n            visitor.fieldNames.pop();\n          }\n          results.add(visitor.field(field, result));\n        }\n        return visitor.struct(struct, results);\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        T elementResult;\n\n        visitor.fieldIds.push(list.elementId());\n        try {\n          elementResult = visit(list.elementType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.list(list, elementResult);\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        T keyResult;\n        T valueResult;\n\n        visitor.fieldIds.push(map.keyId());\n        try {\n          keyResult = visit(map.keyType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        visitor.fieldIds.push(map.valueId());\n        try {\n          valueResult = visit(map.valueType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.map(map, keyResult, valueResult);\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  public static class CustomOrderSchemaVisitor<T> {\n    public T schema(Schema schema, Supplier<T> structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, Iterable<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, Supplier<T> fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, Supplier<T> elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, Supplier<T> keyResult, Supplier<T> valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  private static class VisitFuture<T> implements Supplier<T> {\n    private final Type type;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFuture(Type type, CustomOrderSchemaVisitor<T> visitor) {\n      this.type = type;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visit(type, visitor);\n    }\n  }\n\n  private static class VisitFieldFuture<T> implements Supplier<T> {\n    private final Types.NestedField field;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFieldFuture(Types.NestedField field, CustomOrderSchemaVisitor<T> visitor) {\n      this.field = field;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visitor.field(field, new VisitFuture<>(field.type(), visitor));\n    }\n  }\n\n  public static <T> T visit(Schema schema, CustomOrderSchemaVisitor<T> visitor) {\n    return visitor.schema(schema, new VisitFuture<>(schema.asStruct(), visitor));\n  }\n\n\n  public static <T> T visit(Type type, CustomOrderSchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<VisitFieldFuture<T>> results = Lists\n            .newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          results.add(\n              new VisitFieldFuture<>(field, visitor));\n        }\n\n        return visitor.struct(struct, Iterables.transform(results, VisitFieldFuture::get));\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        return visitor.list(list, new VisitFuture<>(list.elementType(), visitor));\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        return visitor.map(map,\n            new VisitFuture<>(map.keyType(), visitor),\n            new VisitFuture<>(map.valueType(), visitor));\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  static int decimalMaxPrecision(int numBytes) {\n    Preconditions.checkArgument(numBytes >= 0 && numBytes < 24,\n        \"Unsupported decimal length: \" + numBytes);\n    return MAX_PRECISION[numBytes];\n  }\n\n  public static int decimalRequriedBytes(int precision) {\n    Preconditions.checkArgument(precision >= 0 && precision < 40,\n        \"Unsupported decimal precision: \" + precision);\n    return REQUIRED_LENGTH[precision];\n  }\n\n  private static int[] MAX_PRECISION = new int[24];\n  private static int[] REQUIRED_LENGTH = new int[40];\n\n  static {\n\n    for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n      MAX_PRECISION[len] = (int) Math.floor(Math.log10(Math.pow(2, 8*len - 1) - 1));\n    }\n\n\n    for (int precision = 0; precision < REQUIRED_LENGTH.length; precision += 1) {\n      REQUIRED_LENGTH[precision] = -1;\n      for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n\n        if (precision <= MAX_PRECISION[len]) {\n          REQUIRED_LENGTH[precision] = len;\n          break;\n        }\n      }\n      if (REQUIRED_LENGTH[precision] < 0) {\n        throw new IllegalStateException(\n            \"Could not find required length for precision \" + precision);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestSparkParquetReader.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'",
            "'iceberg/parquet/src/test/java/com/netflix/iceberg/parquet/TestDictionaryRowGroupFilter.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\nimport static org.apache.avro.Schema.Type.MAP;\nimport static org.apache.avro.Schema.Type.RECORD;\nimport static org.apache.avro.Schema.Type.UNION;\n\npublic class AvroSchemaUtil {\n  public static final String FIELD_ID_PROP = \"field-id\";\n  public static final String KEY_ID_PROP = \"key-id\";\n  public static final String VALUE_ID_PROP = \"value-id\";\n  public static final String ELEMENT_ID_PROP = \"element-id\";\n  public static final String ADJUST_TO_UTC_PROP = \"adjust-to-utc\";\n\n  private static final Schema NULL = Schema.create(Schema.Type.NULL);\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               String tableName) {\n    return convert(schema, ImmutableMap.of(schema.asStruct(), tableName));\n  }\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               Map<Types.StructType, String> names) {\n    return TypeUtil.visit(schema, new TypeToSchema(names));\n  }\n\n  public static Schema convert(Type type) {\n    return convert(type, ImmutableMap.of());\n  }\n\n  public static Schema convert(Types.StructType type, String name) {\n    return convert(type, ImmutableMap.of(type, name));\n  }\n\n  public static Schema convert(Type type, Map<Types.StructType, String> names) {\n    return TypeUtil.visit(type, new TypeToSchema(names));\n  }\n\n  public static Type convert(Schema schema) {\n    return AvroSchemaVisitor.visit(schema, new SchemaToType(schema));\n  }\n\n  public static Map<Type, Schema> convertTypes(Types.StructType type, String name) {\n    TypeToSchema converter = new TypeToSchema(ImmutableMap.of(type, name));\n    TypeUtil.visit(type, converter);\n    return ImmutableMap.copyOf(converter.getConversionMap());\n  }\n\n  public static Schema pruneColumns(Schema schema, Set<Integer> selectedIds) {\n    return new PruneColumns(selectedIds).rootSchema(schema);\n  }\n\n  public static Schema buildAvroProjection(Schema schema, com.netflix.iceberg.Schema expected,\n                                           Map<String, String> renames) {\n    return AvroCustomOrderSchemaVisitor.visit(schema, new BuildAvroProjection(expected, renames));\n  }\n\n  public static boolean isTimestamptz(Schema schema) {\n    LogicalType logicalType = schema.getLogicalType();\n    if (logicalType != null && logicalType instanceof LogicalTypes.TimestampMicros) {\n\n      Object value = schema.getObjectProp(ADJUST_TO_UTC_PROP);\n      if (value instanceof Boolean) {\n        return (Boolean) value;\n      } else if (value instanceof String) {\n        return Boolean.parseBoolean((String) value);\n      }\n    }\n\n    return false;\n  }\n\n  static boolean isOptionSchema(Schema schema) {\n    if (schema.getType() == UNION && schema.getTypes().size() == 2) {\n      if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return true;\n      } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Schema toOption(Schema schema) {\n    if (schema.getType() == UNION) {\n      Preconditions.checkArgument(isOptionSchema(schema),\n          \"Union schemas are not supported: \" + schema);\n      return schema;\n    } else {\n      return Schema.createUnion(NULL, schema);\n    }\n  }\n\n  static Schema fromOption(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == UNION,\n        \"Expected union schema but was passed: {}\", schema);\n    Preconditions.checkArgument(schema.getTypes().size() == 2,\n        \"Expected optional schema, but was passed: {}\", schema);\n    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n      return schema.getTypes().get(1);\n    } else {\n      return schema.getTypes().get(0);\n    }\n  }\n\n  static Schema fromOptions(List<Schema> options) {\n    Preconditions.checkArgument(options.size() == 2,\n        \"Expected two schemas, but was passed: {} options\", options.size());\n    if (options.get(0).getType() == Schema.Type.NULL) {\n      return options.get(1);\n    } else {\n      return options.get(0);\n    }\n  }\n\n  static boolean isKeyValueSchema(Schema schema) {\n    return (schema.getType() == RECORD && schema.getFields().size() == 2);\n  }\n\n  static Schema createMap(int keyId, Schema keySchema,\n                          int valueId, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n\n    return LogicalMap.get().addToSchema(Schema.createArray(Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField))));\n  }\n\n  static Schema createProjectionMap(String recordName,\n                          int keyId, String keyName, Schema keySchema,\n                          int valueId, String valueName, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    if (!\"key\".equals(keyName)) {\n      keyField.addAlias(keyName);\n    }\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n    if (!\"value\".equals(valueName)) {\n      valueField.addAlias(valueName);\n    }\n\n    Schema keyValueRecord = Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField));\n    if (!keyValueName.equals(recordName)) {\n      keyValueRecord.addAlias(recordName);\n    }\n\n    return LogicalMap.get().addToSchema(Schema.createArray(keyValueRecord));\n  }\n\n  private static int getId(Schema schema, String propertyName) {\n    if (schema.getType() == UNION) {\n      return getId(fromOption(schema), propertyName);\n    }\n\n    Object id = schema.getObjectProp(propertyName);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", propertyName);\n\n    return toInt(id);\n  }\n\n  public static int getKeyId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map key id for non-map schema: \" + schema);\n    return getId(schema, KEY_ID_PROP);\n  }\n\n  public static int getValueId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map value id for non-map schema: \" + schema);\n    return getId(schema, VALUE_ID_PROP);\n  }\n\n  public static int getElementId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Cannot get array element id for non-array schema: \" + schema);\n    return getId(schema, ELEMENT_ID_PROP);\n  }\n\n  public static int getFieldId(Schema.Field field) {\n    Object id = field.getObjectProp(FIELD_ID_PROP);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", FIELD_ID_PROP);\n\n    return toInt(id);\n  }\n\n  private static int toInt(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).intValue();\n    } else if (value instanceof String) {\n      return Integer.parseInt((String) value);\n    }\n\n    throw new UnsupportedOperationException(\"Cannot coerce value to int: \" + value);\n  }\n\n  static Schema copyRecord(Schema record, List<Schema.Field> newFields, String newName) {\n    Schema copy;\n    if (newName != null) {\n      copy = Schema.createRecord(newName, record.getDoc(), null, record.isError(), newFields);\n\n\n\n      copy.addAlias(record.getName(), record.getNamespace() == null ? \"\" : record.getNamespace());\n    } else {\n      copy = Schema.createRecord(record.getName(),\n          record.getDoc(), record.getNamespace(), record.isError(), newFields);\n    }\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  static Schema.Field copyField(Schema.Field field, Schema newSchema, String newName) {\n    Schema.Field copy = new Schema.Field(newName,\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    if (!newName.equals(field.name())) {\n      copy.addAlias(field.name());\n    }\n\n    return copy;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.types.ArrayType$;\nimport org.apache.spark.sql.types.BinaryType$;\nimport org.apache.spark.sql.types.BooleanType$;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.DateType$;\nimport org.apache.spark.sql.types.DecimalType$;\nimport org.apache.spark.sql.types.DoubleType$;\nimport org.apache.spark.sql.types.FloatType$;\nimport org.apache.spark.sql.types.IntegerType$;\nimport org.apache.spark.sql.types.LongType$;\nimport org.apache.spark.sql.types.MapType$;\nimport org.apache.spark.sql.types.Metadata;\nimport org.apache.spark.sql.types.StringType$;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType$;\nimport org.apache.spark.sql.types.TimestampType$;\nimport java.util.List;\n\nclass TypeToSparkType extends TypeUtil.SchemaVisitor<DataType> {\n  TypeToSparkType() {\n  }\n\n  @Override\n  public DataType schema(Schema schema, DataType structType) {\n    return structType;\n  }\n\n  @Override\n  public DataType struct(Types.StructType struct, List<DataType> fieldResults) {\n    List<Types.NestedField> fields = struct.fields();\n\n    List<StructField> sparkFields = Lists.newArrayListWithExpectedSize(fieldResults.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      DataType type = fieldResults.get(i);\n      sparkFields.add(StructField.apply(field.name(), type, field.isOptional(), Metadata.empty()));\n    }\n\n    return StructType$.MODULE$.apply(sparkFields);\n  }\n\n  @Override\n  public DataType field(Types.NestedField field, DataType fieldResult) {\n    return fieldResult;\n  }\n\n  @Override\n  public DataType list(Types.ListType list, DataType elementResult) {\n    return ArrayType$.MODULE$.apply(elementResult, list.isElementOptional());\n  }\n\n  @Override\n  public DataType map(Types.MapType map, DataType keyResult, DataType valueResult) {\n    return MapType$.MODULE$.apply(keyResult, valueResult, map.isValueOptional());\n  }\n\n  @Override\n  public DataType primitive(Type.PrimitiveType primitive) {\n    switch (primitive.typeId()) {\n      case BOOLEAN:\n        return BooleanType$.MODULE$;\n      case INTEGER:\n        return IntegerType$.MODULE$;\n      case LONG:\n        return LongType$.MODULE$;\n      case FLOAT:\n        return FloatType$.MODULE$;\n      case DOUBLE:\n        return DoubleType$.MODULE$;\n      case DATE:\n        return DateType$.MODULE$;\n      case TIME:\n        throw new UnsupportedOperationException(\n            \"Spark does not support time fields\");\n      case TIMESTAMP:\n        Types.TimestampType timestamp = (Types.TimestampType) primitive;\n        if (timestamp.shouldAdjustToUTC()) {\n          return TimestampType$.MODULE$;\n        }\n        throw new UnsupportedOperationException(\n            \"Spark does not support timestamp without time zone fields\");\n      case STRING:\n        return StringType$.MODULE$;\n      case UUID:\n\n        return StringType$.MODULE$;\n      case FIXED:\n        return BinaryType$.MODULE$;\n      case BINARY:\n        return BinaryType$.MODULE$;\n      case DECIMAL:\n        Types.DecimalType decimal = (Types.DecimalType) primitive;\n        return DecimalType$.MODULE$.apply(decimal.precision(), decimal.scale());\n      default:\n        throw new UnsupportedOperationException(\n            \"Cannot convert unknown type to Spark: \" + primitive);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/parquet/src/test/java/com/netflix/iceberg/parquet/TestDictionaryRowGroupFilter.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n\n'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'\n:package net.programmierecke.radiodroid2.tests.utils;\n\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\nimport androidx.recyclerview.widget.RecyclerView;\nimport androidx.test.espresso.PerformException;\nimport androidx.test.espresso.UiController;\nimport androidx.test.espresso.ViewAction;\nimport androidx.test.espresso.action.GeneralLocation;\nimport androidx.test.espresso.action.MotionEvents;\nimport androidx.test.espresso.action.PrecisionDescriber;\nimport androidx.test.espresso.action.Press;\nimport androidx.test.espresso.action.Swipe;\nimport androidx.test.espresso.action.Swiper;\nimport androidx.test.espresso.util.HumanReadables;\n\nimport org.hamcrest.Matcher;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static androidx.test.espresso.core.internal.deps.guava.base.Preconditions.checkElementIndex;\nimport static androidx.test.espresso.matcher.ViewMatchers.isDisplayingAtLeast;\n\npublic class RecyclerDragAndDropAction implements ViewAction {\n\n\n    private static final int VIEW_DISPLAY_PERCENTAGE = 50;\n\n\n    private static final int DRAG_EVENT_COUNT = 10;\n\n    private static final int DRAG_DURATION = 600;\n\n    private final Swiper swiper;\n    private final int idxFrom;\n    private final int idxTo;\n    private final PrecisionDescriber precisionDescriber;\n\n    public static ViewAction recyclerDragAndDrop(int idxFrom, int idxTo) {\n        return new RecyclerDragAndDropAction(Swipe.FAST, idxFrom, idxTo, Press.FINGER);\n    }\n\n    public RecyclerDragAndDropAction(Swiper swiper, int idxFrom, int idxTo, PrecisionDescriber precisionDescriber) {\n        this.swiper = swiper;\n        this.idxFrom = idxFrom;\n        this.idxTo = idxTo;\n        this.precisionDescriber = precisionDescriber;\n    }\n\n    @Override\n    public Matcher<View> getConstraints() {\n        return isDisplayingAtLeast(VIEW_DISPLAY_PERCENTAGE);\n    }\n\n    private static float[][] interpolate(float[] start, float[] end, int steps) {\n        checkElementIndex(1, start.length);\n        checkElementIndex(1, end.length);\n\n        float[][] res = new float[steps][2];\n\n        for (int i = 1; i < steps + 1; i++) {\n            res[i - 1][0] = start[0] + (end[0] - start[0]) * i / (steps);\n            res[i - 1][1] = start[1] + (end[1] - start[1]) * i / (steps);\n        }\n\n        return res;\n    }\n\n    @Override\n    public void perform(UiController uiController, View view) {\n        final RecyclerView recyclerView = (RecyclerView) view;\n\n        TestUtils.centerItemInRecycler(uiController, recyclerView, idxFrom);\n        uiController.loopMainThreadUntilIdle();\n\n        final View fromView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxFrom)).itemView;\n        final float[] fromViewPosition = GeneralLocation.VISIBLE_CENTER.calculateCoordinates(fromView);\n\n        final float[] precision = precisionDescriber.describePrecision();\n\n        final List<MotionEvent> events = new ArrayList<>();\n        MotionEvents.DownResultHolder downEvent = null;\n\n        boolean success = false;\n        for (int i = 0; i < 3 && !success; i++) {\n            try {\n                downEvent = MotionEvents.sendDown(uiController, fromViewPosition, precision);\n\n                final int longPressTimeout = (int) (ViewConfiguration.getLongPressTimeout() * 1.5f);\n                uiController.loopMainThreadForAtLeast(longPressTimeout);\n\n                TestUtils.centerItemInRecycler(uiController, recyclerView, idxTo);\n                uiController.loopMainThreadUntilIdle();\n\n                final View toView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxTo)).itemView;\n                float[] toViewPosition = GeneralLocation.TOP_CENTER.calculateCoordinates(toView);\n\n                float[][] steps = interpolate(fromViewPosition, toViewPosition, DRAG_EVENT_COUNT);\n\n                final long intervalMS = DRAG_DURATION / steps.length;\n                long eventTime = downEvent.down.getDownTime();\n                for (float[] step : steps) {\n                    eventTime += intervalMS;\n                    events.add(MotionEvents.obtainMovement(downEvent.down.getDownTime(), eventTime, step));\n                }\n\n                eventTime += intervalMS;\n                events.add(\n                        MotionEvent.obtain(\n                                downEvent.down.getDownTime(),\n                                eventTime,\n                                MotionEvent.ACTION_UP,\n                                toViewPosition[0],\n                                toViewPosition[1],\n                                0));\n                uiController.injectMotionEventSequence(events);\n                success = true;\n            } catch (Exception e) {\n                throw new PerformException.Builder()\n                        .withActionDescription(this.getDescription())\n                        .withViewDescription(HumanReadables.describe(view))\n                        .withCause(e)\n                        .build();\n            } finally {\n                for (MotionEvent event : events) {\n                    event.recycle();\n                }\n\n                if (downEvent != null) {\n                    downEvent.down.recycle();\n                }\n            }\n        }\n\n        int duration = ViewConfiguration.getPressedStateDuration();\n\n        if (duration > 0) {\n            uiController.loopMainThreadForAtLeast(duration);\n        }\n    }\n\n    @Override\n    public String getDescription() {\n        return swiper.toString().toLowerCase() + \" recycler-drag-and-drop\";\n    }\n}\n\n'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'\n:package net.programmierecke.radiodroid2.tests;\n\nimport static androidx.test.espresso.Espresso.onView;\nimport static androidx.test.espresso.assertion.ViewAssertions.matches;\nimport static androidx.test.espresso.matcher.ViewMatchers.hasDescendant;\nimport static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;\nimport static androidx.test.espresso.matcher.ViewMatchers.withId;\nimport static androidx.test.espresso.matcher.ViewMatchers.withText;\nimport static net.programmierecke.radiodroid2.tests.utils.RecyclerDragAndDropAction.recyclerDragAndDrop;\nimport static net.programmierecke.radiodroid2.tests.utils.RecyclerRecyclingMatcher.recyclerRecycles;\nimport static net.programmierecke.radiodroid2.tests.utils.RecyclerViewMatcher.withRecyclerView;\nimport static net.programmierecke.radiodroid2.tests.utils.ScrollToRecyclerItemAction.scrollToRecyclerItem;\nimport static net.programmierecke.radiodroid2.tests.utils.TestUtils.getFakeRadioStationName;\nimport static net.programmierecke.radiodroid2.tests.utils.conditionwatcher.ViewMatchWaiter.waitForView;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.junit.Assert.assertEquals;\n\nimport android.content.pm.ActivityInfo;\nimport android.os.Build;\nimport android.os.SystemClock;\n\nimport androidx.test.core.app.ApplicationProvider;\nimport androidx.test.espresso.action.ViewActions;\nimport androidx.test.espresso.matcher.ViewMatchers;\nimport androidx.test.filters.LargeTest;\nimport androidx.test.filters.SdkSuppress;\nimport androidx.test.rule.ActivityTestRule;\n\nimport net.programmierecke.radiodroid2.ActivityMain;\nimport net.programmierecke.radiodroid2.FavouriteManager;\nimport net.programmierecke.radiodroid2.R;\nimport net.programmierecke.radiodroid2.RadioDroidApp;\nimport net.programmierecke.radiodroid2.tests.utils.FirstViewMatcher;\nimport net.programmierecke.radiodroid2.tests.utils.TestUtils;\n\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\n\nimport java.util.Arrays;\n\n@LargeTest\n@RunWith(Parameterized.class)\npublic class UIFavouritesFragmentTest {\n\n    @Parameterized.Parameter(value = 0)\n    public int orientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;\n\n    @Parameterized.Parameters(name = \"orientation={0}\")\n    public static Iterable<Object[]> initParameters() {\n        return Arrays.asList(new Object[][]{\n                {ActivityInfo.SCREEN_ORIENTATION_PORTRAIT},\n                {ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE}\n        });\n    }\n\n    @Rule\n    public ActivityTestRule<ActivityMain> activityRule\n            = new ActivityTestRule<ActivityMain>(ActivityMain.class) {\n        @Override\n        protected void afterActivityLaunched() {\n            getActivity().setRequestedOrientation(orientation);\n            super.afterActivityLaunched();\n        }\n    };\n\n    private static final int STATIONS_COUNT = 20;\n\n    private FavouriteManager favouriteManager;\n\n    @Before\n    public void setUp() {\n        TestUtils.populateFavourites(ApplicationProvider.getApplicationContext(), STATIONS_COUNT);\n\n        RadioDroidApp app = ApplicationProvider.getApplicationContext();\n        favouriteManager = app.getFavouriteManager();\n    }\n\n    @Test\n    public void stationsRecyclerFavourites_ShouldRecycleItems() {\n        onView(ViewMatchers.withId(R.id.nav_item_starred)).perform(ViewActions.click());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).check(matches(recyclerRecycles()));\n    }\n\n    @Ignore(\"Disabled until drag and drop is fixed, see \" +\n            \"https:\n    @Test\n    public void stationInFavourites_ShouldBeReordered_WithDragAndDrop() {\n        onView(ViewMatchers.withId(R.id.nav_item_starred)).perform(ViewActions.click());\n\n\n        onView(withId(R.id.recyclerViewStations)).perform(recyclerDragAndDrop(4, 0));\n\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(0))\n                .check(matches(hasDescendant(withText(getFakeRadioStationName(4)))));\n        assertEquals(getFakeRadioStationName(4), favouriteManager.getList().get(0).Name);\n\n        onView(withId(R.id.recyclerViewStations)).perform(recyclerDragAndDrop(4, 3));\n\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(3))\n                .check(matches(hasDescendant(withText(getFakeRadioStationName(3)))));\n        assertEquals(getFakeRadioStationName(3), favouriteManager.getList().get(3).Name);\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(4))\n                .check(matches(hasDescendant(withText(getFakeRadioStationName(2)))));\n        assertEquals(getFakeRadioStationName(2), favouriteManager.getList().get(4).Name);\n\n        onView(withId(R.id.recyclerViewStations)).perform(recyclerDragAndDrop(3, 1));\n\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(1))\n                .check(matches(hasDescendant(withText(getFakeRadioStationName(3)))));\n        assertEquals(getFakeRadioStationName(3), favouriteManager.getList().get(1).Name);\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(2))\n                .check(matches(hasDescendant(withText(getFakeRadioStationName(0)))));\n        assertEquals(getFakeRadioStationName(0), favouriteManager.getList().get(2).Name);\n    }\n\n    @Ignore(\"Disabled until drag and drop is fixed, see \" +\n            \"https:\n    @Test\n    public void stationInFavourites_ShouldBeReordered_WithSimpleDragAndDrop() {\n        onView(ViewMatchers.withId(R.id.nav_item_starred)).perform(ViewActions.click());\n\n\n        onView(withId(R.id.recyclerViewStations)).perform(scrollToRecyclerItem(0));\n        onView(withId(R.id.recyclerViewStations)).perform(recyclerDragAndDrop(1, 0));\n\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(0))\n                .check(matches(hasDescendant(withText(getFakeRadioStationName(1)))));\n        assertEquals(getFakeRadioStationName(1), favouriteManager.getList().get(0).Name);\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(1))\n                .check(matches(hasDescendant(withText(getFakeRadioStationName(0)))));\n        assertEquals(getFakeRadioStationName(0), favouriteManager.getList().get(1).Name);\n    }\n\n    @SdkSuppress(maxSdkVersion = 32)\n    @Test\n    public void stationInFavourites_ShouldBeDeleted_WithSwipeRight() {\n        onView(withId(R.id.nav_item_starred)).perform(ViewActions.click());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).perform(scrollToRecyclerItem(0));\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(0)).perform(ViewActions.swipeRight());\n        waitForView(withId(com.google.android.material.R.id.snackbar_action));\n        SystemClock.sleep(1000);\n        assertEquals(STATIONS_COUNT - 1, favouriteManager.getList().size());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).perform(scrollToRecyclerItem(1));\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(1)).perform(ViewActions.swipeRight());\n        waitForView(withId(com.google.android.material.R.id.snackbar_action));\n        SystemClock.sleep(1000);\n        assertEquals(STATIONS_COUNT - 2, favouriteManager.getList().size());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).perform(scrollToRecyclerItem(2));\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(2)).perform(ViewActions.swipeRight());\n        waitForView(withId(com.google.android.material.R.id.snackbar_action));\n        SystemClock.sleep(1000);\n        assertEquals(STATIONS_COUNT - 3, favouriteManager.getList().size());\n\n\n        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {\n\n            onView(withId(com.google.android.material.R.id.snackbar_action)).perform(ViewActions.click());\n\n            assertEquals(STATIONS_COUNT - 2, favouriteManager.getList().size());\n            onView(withId(R.id.recyclerViewStations)).perform(scrollToRecyclerItem(2));\n            onView(withRecyclerView(R.id.recyclerViewStations).atPosition(2))\n                    .check(matches(hasDescendant(withText(getFakeRadioStationName(4)))));\n        }\n    }\n}\n\n'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'\n:package net.programmierecke.radiodroid2.database;\n\nimport android.content.Context;\n\nimport androidx.annotation.NonNull;\nimport androidx.room.Database;\nimport androidx.room.Room;\nimport androidx.room.RoomDatabase;\nimport androidx.room.TypeConverters;\nimport androidx.sqlite.db.SupportSQLiteDatabase;\n\nimport net.programmierecke.radiodroid2.history.TrackHistoryDao;\nimport net.programmierecke.radiodroid2.history.TrackHistoryEntry;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\n\nimport static net.programmierecke.radiodroid2.history.TrackHistoryEntry.MAX_UNKNOWN_TRACK_DURATION;\n\n@Database(entities = {TrackHistoryEntry.class}, version = 1)\n@TypeConverters({Converters.class})\npublic abstract class RadioDroidDatabase extends RoomDatabase {\n    public abstract TrackHistoryDao songHistoryDao();\n\n    private static volatile RadioDroidDatabase INSTANCE;\n\n    private Executor queryExecutor = Executors.newSingleThreadExecutor(runnable -> new Thread(runnable, \"RadioDroidDatabase Executor\"));\n\n    public static RadioDroidDatabase getDatabase(final Context context) {\n        if (INSTANCE == null) {\n            synchronized (RadioDroidDatabase.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                            RadioDroidDatabase.class, \"radio_droid_database\")\n                            .addCallback(CALLBACK)\n                            .fallbackToDestructiveMigration()\n                            .build();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n\n    public Executor getQueryExecutor() {\n        return queryExecutor;\n    }\n\n    private static RoomDatabase.Callback CALLBACK = new RoomDatabase.Callback() {\n        @Override\n        public void onCreate(@NonNull SupportSQLiteDatabase db) {\n            super.onCreate(db);\n        }\n\n        @Override\n        public void onOpen(@NonNull SupportSQLiteDatabase db) {\n            super.onOpen(db);\n\n            INSTANCE.queryExecutor.execute(() -> {\n\n\n                INSTANCE.songHistoryDao().setLastHistoryItemEndTimeRelative(MAX_UNKNOWN_TRACK_DURATION);\n            });\n        }\n    };\n\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIFavouritesFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/guice/TestGuiceIntegration.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientAnnotationFactory.java'",
            "'drift/drift-client/src/test/java/io/airlift/drift/client/address/TestSimpleAddressSelectorBinder.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/guice/TestGuiceIntegration.java'\n:\npackage io.airlift.drift.integration.guice;\n\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.inject.Injector;\nimport com.google.inject.Scopes;\nimport io.airlift.bootstrap.Bootstrap;\nimport io.airlift.bootstrap.LifeCycleManager;\nimport io.airlift.drift.TApplicationException;\nimport io.airlift.drift.TException;\nimport io.airlift.drift.client.ExceptionClassification;\nimport io.airlift.drift.client.RetriesFailedException;\nimport io.airlift.drift.integration.guice.EchoService.EmptyOptionalException;\nimport io.airlift.drift.integration.guice.EchoService.NullValueException;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.transport.client.MessageTooLargeException;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.client.DriftNettyClientModule;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerModule;\nimport org.testng.annotations.Test;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.util.Optional;\nimport java.util.OptionalDouble;\nimport java.util.OptionalInt;\nimport java.util.OptionalLong;\n\nimport static com.google.common.util.concurrent.Futures.getUnchecked;\nimport static io.airlift.drift.client.ExceptionClassification.HostStatus.NORMAL;\nimport static io.airlift.drift.client.ExceptionClassification.NORMAL_EXCEPTION;\nimport static io.airlift.drift.client.address.SimpleAddressSelectorBinder.simpleAddressSelector;\nimport static io.airlift.drift.client.guice.DriftClientBinder.driftClientBinder;\nimport static io.airlift.drift.integration.guice.ThrowingService.MAX_FRAME_SIZE;\nimport static io.airlift.drift.server.guice.DriftServerBinder.driftServerBinder;\nimport static java.lang.Math.toIntExact;\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport static java.util.Arrays.asList;\nimport static java.util.Arrays.fill;\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertFalse;\nimport static org.testng.Assert.assertThrows;\nimport static org.testng.Assert.assertTrue;\nimport static org.testng.Assert.fail;\n\npublic class TestGuiceIntegration\n{\n    @Test\n    public void testWithoutPooling()\n            throws Exception\n    {\n        test(false);\n    }\n\n    @Test\n    public void testWithPooling()\n            throws Exception\n    {\n        test(true);\n    }\n\n    private static void test(boolean pooling)\n            throws Exception\n    {\n        int port = findUnusedPort();\n\n        TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n        Bootstrap bootstrap = new Bootstrap(\n                new DriftNettyServerModule(testingAllocator),\n                new DriftNettyClientModule(testingAllocator),\n                binder -> {\n                    binder.bind(ThrowingServiceHandler.class).in(Scopes.SINGLETON);\n                    driftServerBinder(binder).bindService(EchoServiceHandler.class);\n                    driftServerBinder(binder).bindService(MismatchServiceHandler.class);\n                    driftServerBinder(binder).bindService(ThrowingServiceHandler.class);\n                    driftClientBinder(binder).bindDriftClient(EchoService.class).withAddressSelector(simpleAddressSelector());\n                    driftClientBinder(binder).bindDriftClient(MismatchService.class).withAddressSelector(simpleAddressSelector());\n                    driftClientBinder(binder).bindDriftClient(ThrowingService.class).withAddressSelector(simpleAddressSelector())\n                            .withExceptionClassifier(t -> {\n                                if (t instanceof ExampleException) {\n                                    boolean retryable = ((ExampleException) t).isRetryable();\n                                    return new ExceptionClassification(Optional.of(retryable), NORMAL);\n                                }\n                                return NORMAL_EXCEPTION;\n                            });\n                });\n\n        Injector injector = bootstrap\n                .setRequiredConfigurationProperty(\"thrift.server.port\", String.valueOf(port))\n                .setRequiredConfigurationProperty(\"thrift.server.max-frame-size\", MAX_FRAME_SIZE.toString())\n                .setRequiredConfigurationProperty(\"thrift.client.connection-pool.enabled\", String.valueOf(pooling))\n                .setRequiredConfigurationProperty(\"echo.thrift.client.addresses\", \"localhost:\" + port)\n                .setRequiredConfigurationProperty(\"mismatch.thrift.client.addresses\", \"localhost:\" + port)\n                .setRequiredConfigurationProperty(\"throwing.thrift.client.addresses\", \"localhost:\" + port)\n                .setRequiredConfigurationProperty(\"throwing.thrift.client.min-backoff-delay\", \"1ms\")\n                .setRequiredConfigurationProperty(\"throwing.thrift.client.backoff-scale-factor\", \"1.0\")\n                .setRequiredConfigurationProperty(\"throwing.thrift.client.max-frame-size\", MAX_FRAME_SIZE.toString())\n                .doNotInitializeLogging()\n                .initialize();\n\n        LifeCycleManager lifeCycleManager = injector.getInstance(LifeCycleManager.class);\n        EchoService echoService = injector.getInstance(EchoService.class);\n        MismatchService mismatchService = injector.getInstance(MismatchService.class);\n        ThrowingService throwingService = injector.getInstance(ThrowingService.class);\n        ThrowingServiceHandler throwingServiceHandler = injector.getInstance(ThrowingServiceHandler.class);\n\n        try {\n            assertEchoService(echoService);\n\n            assertEquals(mismatchService.extraClientArgs(123, 456), 123);\n            assertEquals(mismatchService.extraServerArgs(), 42);\n\n            assertExceptionClassifier(throwingService);\n\n            assertAnnotatedException(throwingService);\n\n            assertLargeMessage(throwingService, throwingServiceHandler);\n        }\n        finally {\n            lifeCycleManager.stop();\n            testingAllocator.close();\n        }\n    }\n\n    @SuppressWarnings(\"OptionalAssignedToNull\")\n    private static void assertEchoService(EchoService service)\n            throws NullValueException, EmptyOptionalException\n    {\n        service.echoVoid();\n\n        assertFalse(service.echoBoolean(false));\n        assertTrue(service.echoBoolean(true));\n\n        assertEquals(service.echoByte((byte) 42), 42);\n        assertEquals(service.echoByte((byte) 0xAB), (byte) 0xAB);\n        assertEquals(service.echoByte(Byte.MIN_VALUE), Byte.MIN_VALUE);\n        assertEquals(service.echoByte(Byte.MAX_VALUE), Byte.MAX_VALUE);\n\n        assertEquals(service.echoShort((short) 1234), 1234);\n        assertEquals(service.echoShort((short) 0xDEAD), (short) 0xDEAD);\n        assertEquals(service.echoShort(Short.MIN_VALUE), Short.MIN_VALUE);\n        assertEquals(service.echoShort(Short.MAX_VALUE), Short.MAX_VALUE);\n\n        assertEquals(service.echoInt(123_456), 123_456);\n        assertEquals(service.echoInt(0xDEADBEEF), 0xDEADBEEF);\n        assertEquals(service.echoInt(Integer.MIN_VALUE), Integer.MIN_VALUE);\n        assertEquals(service.echoInt(Integer.MAX_VALUE), Integer.MAX_VALUE);\n\n        assertEquals(service.echoLong(9_876_543_210L), 9_876_543_210L);\n        assertEquals(service.echoLong(0xDEADBEEF_CAFEBABEL), 0xDEADBEEF_CAFEBABEL);\n        assertEquals(service.echoLong(Long.MIN_VALUE), Long.MIN_VALUE);\n        assertEquals(service.echoLong(Long.MAX_VALUE), Long.MAX_VALUE);\n\n        assertEquals(service.echoDouble(123.456), 123.456);\n        assertEquals(service.echoDouble(-456.123), -456.123);\n        assertEquals(service.echoDouble(0.0), 0.0);\n        assertEquals(service.echoDouble(-0.0), -0.0);\n        assertEquals(service.echoDouble(Double.NEGATIVE_INFINITY), Double.NEGATIVE_INFINITY);\n        assertEquals(service.echoDouble(Double.POSITIVE_INFINITY), Double.POSITIVE_INFINITY);\n        assertEquals(service.echoDouble(Double.NaN), Double.NaN);\n\n        assertEquals(service.echoString(\"hello\"), \"hello\");\n        assertThrows(NullValueException.class, () -> service.echoString(null));\n\n        assertEquals(service.echoBinary(\"hello\".getBytes(UTF_8)), \"hello\".getBytes(UTF_8));\n        assertThrows(NullValueException.class, () -> service.echoBinary(null));\n\n        DriftLogEntry logEntry = new DriftLogEntry(\"abc\", \"xyz\");\n        assertEquals(service.echoStruct(logEntry), logEntry);\n        assertThrows(NullValueException.class, () -> service.echoStruct(null));\n\n        assertEquals(service.echoInteger(123_456), (Integer) 123_456);\n        assertThrows(NullValueException.class, () -> service.echoInteger(null));\n\n        assertEquals(service.echoListInteger(asList(123_456, 42)), asList(123_456, 42));\n        assertThrows(NullValueException.class, () -> service.echoListInteger(null));\n\n        assertEquals(service.echoListString(asList(\"hello\", \"world\")), asList(\"hello\", \"world\"));\n        assertThrows(NullValueException.class, () -> service.echoListInteger(null));\n\n        assertEquals(service.echoOptionalInt(OptionalInt.of(123_456)), 123_456);\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalInt(OptionalInt.empty()));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalInt(null));\n\n        assertEquals(service.echoOptionalLong(OptionalLong.of(9_876_543_210L)), 9_876_543_210L);\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalLong(OptionalLong.empty()));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalLong(null));\n\n        assertEquals(service.echoOptionalDouble(OptionalDouble.of(123.456)), 123.456);\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalDouble(OptionalDouble.empty()));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalDouble(null));\n\n        assertEquals(service.echoOptionalString(Optional.of(\"hello\")), \"hello\");\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalString(Optional.empty()));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalString(null));\n\n        assertEquals(service.echoOptionalStruct(Optional.of(logEntry)), logEntry);\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalStruct(Optional.empty()));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalStruct(null));\n\n        assertEquals(service.echoOptionalListInteger(Optional.of(asList(123_456, 42))), asList(123_456, 42));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalListInteger(Optional.empty()));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalListInteger(null));\n\n        assertEquals(service.echoOptionalListString(Optional.of(asList(\"hello\", \"world\"))), asList(\"hello\", \"world\"));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalListString(Optional.empty()));\n        assertThrows(EmptyOptionalException.class, () -> service.echoOptionalListString(null));\n    }\n\n    private static void assertExceptionClassifier(ThrowingService service)\n    {\n        assertThatThrownBy(() -> service.fail(\"no-retry\", false))\n                .hasMessage(\"no-retry\")\n                .isInstanceOfSatisfying(ExampleException.class, e -> {\n                    assertThat(e.isRetryable()).isFalse();\n                    assertThat(e.getSuppressed()).hasOnlyOneElementSatisfying(s ->\n                            assertThat(s).isInstanceOf(RetriesFailedException.class)\n                                    .hasMessageContaining(\"Non-retryable exception\")\n                                    .hasMessageContaining(\"invocationAttempts: 1,\"));\n                });\n\n        assertThatThrownBy(() -> service.fail(\"can-retry\", true))\n                .hasMessage(\"can-retry\")\n                .isInstanceOfSatisfying(ExampleException.class, e -> {\n                    assertThat(e.isRetryable()).isTrue();\n                    assertThat(e.getSuppressed()).hasOnlyOneElementSatisfying(s ->\n                            assertThat(s).isInstanceOf(RetriesFailedException.class)\n                                    .hasMessageContaining(\"Max retry attempts (5) exceeded\")\n                                    .hasMessageContaining(\"invocationAttempts: 6,\"));\n                });\n    }\n\n    private static void assertAnnotatedException(ThrowingService service)\n    {\n        assertThatThrownBy(() -> service.failWithException(true))\n                .hasMessage(\"RETRY\")\n                .isInstanceOfSatisfying(RetryableException.class, e ->\n                        assertThat(e.getSuppressed()).hasOnlyOneElementSatisfying(s ->\n                                assertThat(s).isInstanceOf(RetriesFailedException.class)\n                                        .hasMessageContaining(\"Max retry attempts (5) exceeded\")\n                                        .hasMessageContaining(\"invocationAttempts: 6,\")));\n\n        assertThatThrownBy(() -> service.failWithException(false))\n                .hasMessage(\"NO RETRY\")\n                .isInstanceOfSatisfying(NonRetryableException.class, e ->\n                        assertThat(e.getSuppressed()).hasOnlyOneElementSatisfying(s ->\n                                assertThat(s).isInstanceOf(RetriesFailedException.class)\n                                        .hasMessageContaining(\"Non-retryable exception\")\n                                        .hasMessageContaining(\"invocationAttempts: 1,\")));\n    }\n\n    private static void assertLargeMessage(ThrowingService service, ThrowingServiceHandler handler)\n    {\n\n        receiveTooLargeMessage(service);\n        sendTooLargeMessage(service);\n\n\n        ListenableFuture<String> awaitFuture = service.await();\n        getUnchecked(handler.waitForAwait());\n        assertFalse(awaitFuture.isDone());\n        receiveTooLargeMessage(service);\n        assertFalse(awaitFuture.isDone());\n        assertEquals(service.release(), \"OK\");\n        assertEquals(getUnchecked(awaitFuture), \"OK\");\n\n        awaitFuture = service.await();\n        getUnchecked(handler.waitForAwait());\n        assertFalse(awaitFuture.isDone());\n        sendTooLargeMessage(service);\n        assertFalse(awaitFuture.isDone());\n        assertEquals(service.release(), \"OK\");\n        assertEquals(getUnchecked(awaitFuture), \"OK\");\n    }\n\n    private static void receiveTooLargeMessage(ThrowingService service)\n    {\n        try {\n            service.generateTooLargeFrame();\n            fail(\"expected exception\");\n        }\n        catch (TException e) {\n            assertThat(e).isInstanceOf(MessageTooLargeException.class)\n                    .hasMessageMatching(\"Frame size .+ exceeded max size .+\");\n            assertEquals(e.getSuppressed().length, 1);\n            Throwable t = e.getSuppressed()[0];\n            assertThat(t).isInstanceOf(RetriesFailedException.class)\n                    .hasMessageContaining(\"Non-retryable exception\")\n                    .hasMessageContaining(\"invocationAttempts: 1,\");\n        }\n    }\n\n    private static void sendTooLargeMessage(ThrowingService service)\n    {\n        byte[] data = new byte[toIntExact(MAX_FRAME_SIZE.toBytes()) + 1];\n        fill(data, (byte) 0xAB);\n        try {\n            service.acceptBytes(data);\n            fail(\"expected exception\");\n        }\n        catch (TException e) {\n            assertThat(e).isInstanceOf(TApplicationException.class)\n                    .hasMessageMatching(\"Frame size .+ exceeded max size .+\");\n        }\n    }\n\n    private static int findUnusedPort()\n            throws IOException\n    {\n        try (ServerSocket socket = new ServerSocket(0)) {\n            return socket.getLocalPort();\n        }\n    }\n}\n\n'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientAnnotationFactory.java'\n:\npackage io.airlift.drift.client.guice;\n\nimport com.google.inject.BindingAnnotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport static java.lang.String.format;\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static java.util.Objects.requireNonNull;\n\npublic final class DriftClientAnnotationFactory\n{\n    private DriftClientAnnotationFactory() {}\n\n    public static Annotation getDriftClientAnnotation(Class<?> value, Class<? extends Annotation> qualifier)\n    {\n        return new DriftClientAnnotationImpl(value, qualifier);\n    }\n\n    public static Optional<Class<? extends Annotation>> extractDriftClientBindingAnnotation(Annotation driftClientAnnotation)\n    {\n        if (driftClientAnnotation instanceof DriftClientAnnotation) {\n            DriftClientAnnotation annotation = (DriftClientAnnotation) driftClientAnnotation;\n            Class<? extends Annotation> qualifier = annotation.qualifier();\n            if (qualifier != DefaultClient.class) {\n                return Optional.of(qualifier);\n            }\n        }\n        return Optional.empty();\n    }\n\n    @Target({FIELD, PARAMETER, METHOD})\n    @Retention(RUNTIME)\n    @BindingAnnotation\n    @interface DriftClientAnnotation\n    {\n        Class<?> value();\n\n        Class<? extends Annotation> qualifier();\n    }\n\n    @SuppressWarnings(\"ClassExplicitlyAnnotation\")\n    private static final class DriftClientAnnotationImpl\n            implements DriftClientAnnotation\n    {\n        private final Class<?> value;\n        private final Class<? extends Annotation> qualifier;\n\n        private DriftClientAnnotationImpl(Class<?> value, Class<? extends Annotation> qualifier)\n        {\n            this.value = requireNonNull(value, \"value is null\");\n            this.qualifier = requireNonNull(qualifier, \"qualifier is null\");\n        }\n\n        @Override\n        public Class<?> value()\n        {\n            return value;\n        }\n\n        @Override\n        public Class<? extends Annotation> qualifier()\n        {\n            return qualifier;\n        }\n\n        @Override\n        public Class<? extends Annotation> annotationType()\n        {\n            return DriftClientAnnotation.class;\n        }\n\n        @Override\n        public int hashCode()\n        {\n\n            return (127 * \"value\".hashCode()) ^ value.hashCode() +\n                    (127 * \"qualifier\".hashCode()) ^ qualifier.hashCode();\n        }\n\n        @Override\n        public boolean equals(Object o)\n        {\n            if (!(o instanceof DriftClientAnnotation)) {\n                return false;\n            }\n            DriftClientAnnotation other = (DriftClientAnnotation) o;\n            return Objects.equals(value, other.value()) && Objects.equals(qualifier, other.qualifier());\n        }\n\n        @Override\n        public String toString()\n        {\n            return format(\"@%s(value=%s, qualifier=%s)\", DriftClientAnnotation.class.getName(), value, qualifier);\n        }\n    }\n}\n\n'drift/drift-client/src/test/java/io/airlift/drift/client/address/TestSimpleAddressSelectorBinder.java'\n:\npackage io.airlift.drift.client.address;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport io.airlift.bootstrap.Bootstrap;\nimport io.airlift.bootstrap.LifeCycleManager;\nimport io.airlift.drift.annotations.ThriftMethod;\nimport io.airlift.drift.annotations.ThriftService;\nimport io.airlift.drift.client.guice.AddressSelectorBinder;\nimport io.airlift.drift.client.guice.DefaultClient;\nimport org.testng.annotations.Test;\n\nimport java.lang.annotation.Annotation;\nimport java.util.List;\nimport java.util.Map;\n\nimport static io.airlift.drift.client.address.SimpleAddressSelectorBinder.simpleAddressSelector;\nimport static io.airlift.drift.client.guice.DriftClientAnnotationFactory.getDriftClientAnnotation;\nimport static io.airlift.testing.Assertions.assertInstanceOf;\nimport static org.testng.Assert.assertEquals;\n\npublic class TestSimpleAddressSelectorBinder\n{\n    private static final Annotation THRIFT_SERVICE_ANNOTATION = getDriftClientAnnotation(Client.class, DefaultClient.class);\n\n    @Test\n    public void testNoDefaults()\n            throws Exception\n    {\n        List<HostAndPort> addresses = ImmutableList.of(HostAndPort.fromParts(\"example.com\", 1), HostAndPort.fromParts(\"example.com\", 2));\n        Map<String, String> properties = ImmutableMap.of(\"testService\" + \".thrift.client.addresses\", \"example.com:1,example.com:2\");\n        testAddressSelector(simpleAddressSelector(), properties, addresses);\n    }\n\n    @Test\n    public void testSingleDefault()\n            throws Exception\n    {\n        HostAndPort address = HostAndPort.fromParts(\"example.com\", 1);\n        testAddressSelector(simpleAddressSelector(address), ImmutableMap.of(), ImmutableList.of(address));\n\n        testAddressSelector(\n                simpleAddressSelector(address),\n                ImmutableMap.of(\"testService\" + \".thrift.client.addresses\", \"example.com:11,example.com:22\"),\n                ImmutableList.of(HostAndPort.fromParts(\"example.com\", 11), HostAndPort.fromParts(\"example.com\", 22)));\n    }\n\n    @Test\n    public void testMultipleDefaults()\n            throws Exception\n    {\n        List<HostAndPort> addresses = ImmutableList.of(HostAndPort.fromParts(\"example.com\", 1), HostAndPort.fromParts(\"example.com\", 2));\n        testAddressSelector(simpleAddressSelector(addresses), ImmutableMap.of(), addresses);\n\n        testAddressSelector(\n                simpleAddressSelector(addresses),\n                ImmutableMap.of(\"testService\" + \".thrift.client.addresses\", \"example.com:11,example.com:22\"),\n                ImmutableList.of(HostAndPort.fromParts(\"example.com\", 11), HostAndPort.fromParts(\"example.com\", 22)));\n    }\n\n    private static void testAddressSelector(\n            AddressSelectorBinder addressSelectorBinder,\n            Map<String, String> configurationProperties,\n            List<HostAndPort> expected)\n            throws Exception\n    {\n        Bootstrap app = new Bootstrap(\n                binder -> addressSelectorBinder.bind(binder, THRIFT_SERVICE_ANNOTATION, \"testService\"));\n\n        LifeCycleManager lifeCycleManager = null;\n        try {\n            Injector injector = app\n                    .setRequiredConfigurationProperties(configurationProperties)\n                    .doNotInitializeLogging()\n                    .initialize();\n            lifeCycleManager = injector.getInstance(LifeCycleManager.class);\n\n            AddressSelector<?> addressSelector = injector.getInstance(Key.get(AddressSelector.class, THRIFT_SERVICE_ANNOTATION));\n            assertInstanceOf(addressSelector, SimpleAddressSelector.class);\n            SimpleAddressSelector simpleAddressSelector = (SimpleAddressSelector) addressSelector;\n            assertEquals(simpleAddressSelector.getAddresses(), expected);\n        }\n        finally {\n            if (lifeCycleManager != null) {\n                try {\n                    lifeCycleManager.stop();\n                }\n                catch (Exception ignored) {\n                }\n            }\n        }\n    }\n\n    @ThriftService(\"testService\")\n    public interface Client\n    {\n        @ThriftMethod\n        String test();\n    }\n}\n",
        "gt": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientAnnotationFactory.java'",
            "'drift/drift-client/src/test/java/io/airlift/drift/client/address/TestSimpleAddressSelectorBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/guice/TestGuiceIntegration.java'"
        ]
    },
    {
        "files": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ],
        "content": "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'\n:\n\npackage com.netflix.iceberg.parquet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.parquet.column.ColumnDescriptor;\nimport org.apache.parquet.column.page.PageReadStore;\nimport org.apache.parquet.io.api.Binary;\nimport org.apache.parquet.schema.Type;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static java.util.Collections.emptyIterator;\n\npublic class ParquetValueReaders {\n  private ParquetValueReaders() {\n  }\n\n  public static <T> ParquetValueReader<T> option(Type type, int definitionLevel,\n                                                 ParquetValueReader<T> reader) {\n    if (type.isRepetition(Type.Repetition.OPTIONAL)) {\n      return new OptionReader<>(definitionLevel, reader);\n    }\n    return reader;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static <T> ParquetValueReader<T> nulls() {\n    return (ParquetValueReader<T>) NullReader.INSTANCE;\n  }\n\n  private static class NullReader<T> implements ParquetValueReader<T> {\n    private static final NullReader<Void> INSTANCE = new NullReader<>();\n    private static final List<TripleIterator<?>> COLUMNS = ImmutableList.of();\n    private static final TripleIterator<?> NULL_COLUMN = new TripleIterator<Object> () {\n      @Override\n      public int currentDefinitionLevel() {\n        return 0;\n      }\n\n      @Override\n      public int currentRepetitionLevel() {\n        return 0;\n      }\n\n      @Override\n      public <N> N nextNull() {\n        return null;\n      }\n\n      @Override\n      public boolean hasNext() {\n        return false;\n      }\n\n      @Override\n      public Object next() {\n        return null;\n      }\n    };\n\n    private NullReader() {\n    }\n\n    @Override\n    public T read(T reuse) {\n      return null;\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return NULL_COLUMN;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return COLUMNS;\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n    }\n  }\n\n  public abstract static class PrimitiveReader<T> implements ParquetValueReader<T> {\n    private final ColumnDescriptor desc;\n    protected final ColumnIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected PrimitiveReader(ColumnDescriptor desc) {\n      this.desc = desc;\n      this.column = ColumnIterator.newIterator(desc, \"\");\n      this.children = ImmutableList.of(column);\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      column.setPageSource(pageStore.getPageReader(desc));\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n  }\n\n  public static class UnboxedReader<T> extends PrimitiveReader<T> {\n    public UnboxedReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T read(T ignored) {\n      return (T) column.next();\n    }\n\n    public boolean readBoolean() {\n      return column.nextBoolean();\n    }\n\n    public int readInteger() {\n      return column.nextInteger();\n    }\n\n    public long readLong() {\n      return column.nextLong();\n    }\n\n    public float readFloat() {\n      return column.nextFloat();\n    }\n\n    public double readDouble() {\n      return column.nextDouble();\n    }\n\n    public Binary readBinary() {\n      return column.nextBinary();\n    }\n  }\n\n  public static class StringReader extends PrimitiveReader<String> {\n    public StringReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public String read(String reuse) {\n      return column.nextBinary().toStringUsingUTF8();\n    }\n  }\n\n  public static class IntAsLongReader extends UnboxedReader<Long> {\n    public IntAsLongReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public Long read(Long ignored) {\n      return readLong();\n    }\n\n    @Override\n    public long readLong() {\n      return super.readInteger();\n    }\n  }\n\n  public static class FloatAsDoubleReader extends UnboxedReader<Double> {\n    public FloatAsDoubleReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public Double read(Double ignored) {\n      return readDouble();\n    }\n\n    @Override\n    public double readDouble() {\n      return super.readFloat();\n    }\n  }\n\n  public static class IntegerAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private final int scale;\n\n    public IntegerAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal ignored) {\n      return new BigDecimal(BigInteger.valueOf(column.nextInteger()), scale);\n    }\n  }\n\n  public static class LongAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private final int scale;\n\n    public LongAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal ignored) {\n      return new BigDecimal(BigInteger.valueOf(column.nextLong()), scale);\n    }\n  }\n\n  public static class BinaryAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private int scale;\n\n    public BinaryAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal reuse) {\n      byte[] bytes = column.nextBinary().getBytesUnsafe();\n      return new BigDecimal(new BigInteger(bytes), scale);\n    }\n  }\n\n  public static class BytesReader extends PrimitiveReader<ByteBuffer> {\n    public BytesReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public ByteBuffer read(ByteBuffer reuse) {\n      Binary binary = column.nextBinary();\n      ByteBuffer data = binary.toByteBuffer();\n      if (reuse != null && reuse.hasArray() && reuse.capacity() >= data.remaining()) {\n        data.get(reuse.array(), reuse.arrayOffset(), data.remaining());\n        reuse.position(0);\n        reuse.limit(data.remaining());\n        return reuse;\n      } else {\n        byte[] array = new byte[data.remaining()];\n        data.get(array, 0, data.remaining());\n        return ByteBuffer.wrap(array);\n      }\n    }\n  }\n\n  private static class OptionReader<T> implements ParquetValueReader<T> {\n    private final int definitionLevel;\n    private final ParquetValueReader<T> reader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    OptionReader(int definitionLevel, ParquetValueReader<T> reader) {\n      this.definitionLevel = definitionLevel;\n      this.reader = reader;\n      this.column = reader.column();\n      this.children = reader.columns();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      reader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public T read(T reuse) {\n      if (column.currentDefinitionLevel() > definitionLevel) {\n        return reader.read(reuse);\n      }\n\n      for (TripleIterator<?> column : children) {\n        column.nextNull();\n      }\n\n      return null;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n  }\n\n  public abstract static class RepeatedReader<T, I, E> implements ParquetValueReader<T> {\n    private final int definitionLevel;\n    private final int repetitionLevel;\n    private final ParquetValueReader<E> reader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected RepeatedReader(int definitionLevel, int repetitionLevel, ParquetValueReader<E> reader) {\n      this.definitionLevel = definitionLevel;\n      this.repetitionLevel = repetitionLevel;\n      this.reader = reader;\n      this.column = reader.column();\n      this.children = reader.columns();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      reader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public T read(T reuse) {\n      I intermediate = newListData(reuse);\n\n      do {\n        if (column.currentDefinitionLevel() > definitionLevel) {\n          addElement(intermediate, reader.read(getElement(intermediate)));\n        } else {\n\n          for (TripleIterator<?> column : children) {\n            column.nextNull();\n          }\n\n\n          break;\n        }\n      } while (column.currentRepetitionLevel() > repetitionLevel);\n\n      return buildList(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    protected abstract I newListData(T reuse);\n\n    protected abstract E getElement(I list);\n\n    protected abstract void addElement(I list, E element);\n\n    protected abstract T buildList(I list);\n  }\n\n  public static class ListReader<E> extends RepeatedReader<List<E>, List<E>, E> {\n    private List<E> lastList = null;\n    private Iterator<E> elements = null;\n\n    public ListReader(int definitionLevel, int repetitionLevel,\n                      ParquetValueReader<E> reader) {\n      super(definitionLevel, repetitionLevel, reader);\n    }\n\n    @Override\n    protected List<E> newListData(List<E> reuse) {\n      List<E> list;\n      if (lastList != null) {\n        lastList.clear();\n        list = lastList;\n      } else {\n        list = Lists.newArrayList();\n      }\n\n      if (reuse != null) {\n        this.lastList = reuse;\n        this.elements = reuse.iterator();\n      } else {\n        this.lastList = null;\n        this.elements = emptyIterator();\n      }\n\n      return list;\n    }\n\n    @Override\n    protected E getElement(List<E> reuse) {\n      if (elements.hasNext()) {\n        return elements.next();\n      }\n\n      return null;\n    }\n\n    @Override\n    protected void addElement(List<E> list, E element) {\n      list.add(element);\n    }\n\n    @Override\n    protected List<E> buildList(List<E> list) {\n      return list;\n    }\n  }\n\n  public abstract static class RepeatedKeyValueReader<M, I, K, V> implements ParquetValueReader<M> {\n    private final int definitionLevel;\n    private final int repetitionLevel;\n    private final ParquetValueReader<K> keyReader;\n    private final ParquetValueReader<V> valueReader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected RepeatedKeyValueReader(int definitionLevel, int repetitionLevel,\n                           ParquetValueReader<K> keyReader, ParquetValueReader<V> valueReader) {\n      this.definitionLevel = definitionLevel;\n      this.repetitionLevel = repetitionLevel;\n      this.keyReader = keyReader;\n      this.valueReader = valueReader;\n      this.column = keyReader.column();\n      this.children = ImmutableList.<TripleIterator<?>>builder()\n          .addAll(keyReader.columns())\n          .addAll(valueReader.columns())\n          .build();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      keyReader.setPageSource(pageStore);\n      valueReader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public M read(M reuse) {\n      I intermediate = newMapData(reuse);\n\n      do {\n        if (column.currentDefinitionLevel() > definitionLevel) {\n          Map.Entry<K, V> pair = getPair(intermediate);\n          addPair(intermediate, keyReader.read(pair.getKey()), valueReader.read(pair.getValue()));\n        } else {\n\n          for (TripleIterator<?> column : children) {\n            column.nextNull();\n          }\n\n\n          break;\n        }\n      } while (column.currentRepetitionLevel() > repetitionLevel);\n\n      return buildMap(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    protected abstract I newMapData(M reuse);\n\n    protected abstract Map.Entry<K, V> getPair(I map);\n\n    protected abstract void addPair(I map, K key, V value);\n\n    protected abstract M buildMap(I map);\n  }\n\n  public static class MapReader<K, V> extends RepeatedKeyValueReader<Map<K, V>, Map<K, V>, K, V> {\n    private final ReusableEntry<K, V> nullEntry = new ReusableEntry<>();\n    private Map<K, V> lastMap = null;\n    private Iterator<Map.Entry<K, V>> pairs = null;\n\n    public MapReader(int definitionLevel, int repetitionLevel,\n                     ParquetValueReader<K> keyReader,\n                     ParquetValueReader<V> valueReader) {\n      super(definitionLevel, repetitionLevel, keyReader, valueReader);\n    }\n\n    @Override\n    protected Map<K, V> newMapData(Map<K, V> reuse) {\n      Map<K, V> map;\n      if (lastMap != null) {\n        lastMap.clear();\n        map = lastMap;\n      } else {\n        map = Maps.newLinkedHashMap();\n      }\n\n      if (reuse != null) {\n        this.lastMap = reuse;\n        this.pairs = reuse.entrySet().iterator();\n      } else {\n        this.lastMap = null;\n        this.pairs = emptyIterator();\n      }\n\n      return map;\n    }\n\n    @Override\n    protected Map.Entry<K, V> getPair(Map<K, V> map) {\n      if (pairs.hasNext()) {\n        return pairs.next();\n      } else {\n        return nullEntry;\n      }\n    }\n\n    @Override\n    protected void addPair(Map<K, V> map, K key, V value) {\n      map.put(key, value);\n    }\n\n    @Override\n    protected Map<K, V> buildMap(Map<K, V> map) {\n      return map;\n    }\n  }\n\n  public static class ReusableEntry<K, V> implements Map.Entry<K, V> {\n    private K key = null;\n    private V value = null;\n\n    public void set(K key, V value) {\n      this.key = key;\n      this.value = value;\n    }\n\n    @Override\n    public K getKey() {\n      return key;\n    }\n\n    @Override\n    public V getValue() {\n      return value;\n    }\n\n    @Override\n    public V setValue(V value) {\n      V lastValue = this.value;\n      this.value = value;\n      return lastValue;\n    }\n  }\n\n  public abstract static class StructReader<T, I> implements ParquetValueReader<T> {\n    private interface Setter<R> {\n      void set(R record, int pos, Object reuse);\n    }\n\n    private final ParquetValueReader<?>[] readers;\n    private final TripleIterator<?> column;\n    private final TripleIterator<?>[] columns;\n    private final Setter<I>[] setters;\n    private final List<TripleIterator<?>> children;\n\n    @SuppressWarnings(\"unchecked\")\n    protected StructReader(List<Type> types, List<ParquetValueReader<?>> readers) {\n      this.readers = (ParquetValueReader<?>[]) Array.newInstance(\n          ParquetValueReader.class, readers.size());\n      this.columns = (TripleIterator<?>[]) Array.newInstance(TripleIterator.class, readers.size());\n      this.setters = (Setter<I>[]) Array.newInstance(Setter.class, readers.size());\n\n      ImmutableList.Builder<TripleIterator<?>> columnsBuilder = ImmutableList.builder();\n      for (int i = 0; i < readers.size(); i += 1) {\n        ParquetValueReader<?> reader = readers.get(i);\n        this.readers[i] = readers.get(i);\n        this.columns[i] = reader.column();\n        this.setters[i] = newSetter(reader, types.get(i));\n        columnsBuilder.addAll(reader.columns());\n      }\n\n      this.children = columnsBuilder.build();\n      if (children.size() > 0) {\n        this.column = children.get(0);\n      } else {\n        this.column = NullReader.NULL_COLUMN;\n      }\n    }\n\n    @Override\n    public final void setPageSource(PageReadStore pageStore) {\n      for (int i = 0; i < readers.length; i += 1) {\n        readers[i].setPageSource(pageStore);\n      }\n    }\n\n    @Override\n    public final TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public final T read(T reuse) {\n      I intermediate = newStructData(reuse);\n\n      for (int i = 0; i < readers.length; i += 1) {\n        set(intermediate, i, readers[i].read(get(intermediate, i)));\n\n      }\n\n      return buildStruct(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <E> Setter<I> newSetter(ParquetValueReader<E> reader, Type type) {\n      if (reader instanceof UnboxedReader && type.isPrimitive()) {\n        UnboxedReader<?> unboxed  = (UnboxedReader<?>) reader;\n        switch (type.asPrimitiveType().getPrimitiveTypeName()) {\n          case BOOLEAN:\n            return (record, pos, ignored) -> setBoolean(record, pos, unboxed.readBoolean());\n          case INT32:\n            return (record, pos, ignored) -> setInteger(record, pos, unboxed.readInteger());\n          case INT64:\n            return (record, pos, ignored) -> setLong(record, pos, unboxed.readLong());\n          case FLOAT:\n            return (record, pos, ignored) -> setFloat(record, pos, unboxed.readFloat());\n          case DOUBLE:\n            return (record, pos, ignored) -> setDouble(record, pos, unboxed.readDouble());\n          case FIXED_LEN_BYTE_ARRAY:\n          case BINARY:\n            return (record, pos, ignored) -> set(record, pos, unboxed.readBinary());\n          default:\n            throw new UnsupportedOperationException(\"Unsupported type: \" + type);\n        }\n      }\n\n\n      return (record, pos, reuse) -> {\n        Object obj = reader.read((E) reuse);\n        if (obj != null) {\n          set(record, pos, obj);\n        } else {\n          setNull(record, pos);\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <E> E get(I intermediate, int pos) {\n      return (E) getField(intermediate, pos);\n    }\n\n    protected abstract I newStructData(T reuse);\n\n    protected abstract Object getField(I intermediate, int pos);\n\n    protected abstract T buildStruct(I struct);\n\n\n    protected abstract void set(I struct, int pos, Object value);\n\n    protected void setNull(I struct, int pos) {\n      set(struct, pos, null);\n    }\n\n    protected void setBoolean(I struct, int pos, boolean value) {\n      set(struct, pos, value);\n    }\n\n    protected void setInteger(I struct, int pos, int value) {\n      set(struct, pos, value);\n    }\n\n    protected void setLong(I struct, int pos, long value) {\n      set(struct, pos, value);\n    }\n\n    protected void setFloat(I struct, int pos, float value) {\n      set(struct, pos, value);\n    }\n\n    protected void setDouble(I struct, int pos, double value) {\n      set(struct, pos, value);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ]
    },
    {
        "files": [
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'"
        ],
        "content": "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'\n:\n\npackage github.daneren2005.dsub.adapter;\n\nimport android.content.Context;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport java.util.List;\n\nimport github.daneren2005.dsub.R;\nimport github.daneren2005.dsub.domain.MusicDirectory;\nimport github.daneren2005.dsub.domain.MusicDirectory.Entry;\nimport github.daneren2005.dsub.util.ImageLoader;\nimport github.daneren2005.dsub.util.Util;\nimport github.daneren2005.dsub.view.AlbumView;\nimport github.daneren2005.dsub.view.SongView;\nimport github.daneren2005.dsub.view.UpdateView;\nimport github.daneren2005.dsub.view.UpdateView.UpdateViewHolder;\n\npublic class EntryGridAdapter extends SectionAdapter<Entry> {\n\tprivate static String TAG = EntryGridAdapter.class.getSimpleName();\n\n\tpublic static int VIEW_TYPE_ALBUM_CELL = 1;\n\tpublic static int VIEW_TYPE_ALBUM_LINE = 2;\n\tpublic static int VIEW_TYPE_SONG = 3;\n\n\tprivate ImageLoader imageLoader;\n\tprivate boolean largeAlbums;\n\tprivate boolean showArtist = false;\n\tprivate boolean showAlbum = false;\n\tprivate boolean removeFromPlaylist = false;\n\tprivate View header;\n\n\tpublic EntryGridAdapter(Context context, List<Entry> entries, ImageLoader imageLoader, boolean largeCell) {\n\t\tsuper(context, entries);\n\t\tthis.imageLoader = imageLoader;\n\t\tthis.largeAlbums = largeCell;\n\n\n\t\tString artist = null;\n\t\tfor(MusicDirectory.Entry entry: entries) {\n\t\t\tif(artist == null) {\n\t\t\t\tartist = entry.getArtist();\n\t\t\t}\n\n\t\t\tif(artist != null && !artist.equals(entry.getArtist())) {\n\t\t\t\tshowArtist = true;\n\t\t\t}\n\t\t}\n\t\tcheckable = true;\n\t}\n\n\t@Override\n\tpublic UpdateViewHolder onCreateSectionViewHolder(ViewGroup parent, int viewType) {\n\t\tUpdateView updateView = null;\n\t\tif(viewType == VIEW_TYPE_ALBUM_LINE || viewType == VIEW_TYPE_ALBUM_CELL) {\n\t\t\tupdateView = new AlbumView(context, viewType == VIEW_TYPE_ALBUM_CELL);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tupdateView = new SongView(context);\n\t\t}\n\n\t\treturn new UpdateViewHolder(updateView);\n\t}\n\n\t@Override\n\tpublic void onBindViewHolder(UpdateViewHolder holder, Entry entry, int viewType) {\n\t\tUpdateView view = holder.getUpdateView();\n\t\tif(viewType == VIEW_TYPE_ALBUM_CELL || viewType == VIEW_TYPE_ALBUM_LINE) {\n\t\t\tAlbumView albumView = (AlbumView) view;\n\t\t\talbumView.setShowArtist(showArtist);\n\t\t\talbumView.setObject(entry, imageLoader);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tSongView songView = (SongView) view;\n\t\t\tsongView.setShowAlbum(showAlbum);\n\t\t\tsongView.setObject(entry, checkable && !entry.isVideo());\n\t\t}\n\t}\n\n\tpublic UpdateViewHolder onCreateHeaderHolder(ViewGroup parent) {\n\t\treturn new UpdateViewHolder(header, false);\n\t}\n\tpublic void onBindHeaderHolder(UpdateViewHolder holder, String header, int sectionIndex) {\n\n\t}\n\n\t@Override\n\tpublic int getItemViewType(Entry entry) {\n\t\tif(entry.isDirectory()) {\n\t\t\tif (largeAlbums) {\n\t\t\t\treturn VIEW_TYPE_ALBUM_CELL;\n\t\t\t} else {\n\t\t\t\treturn VIEW_TYPE_ALBUM_LINE;\n\t\t\t}\n\t\t} else {\n\t\t\treturn VIEW_TYPE_SONG;\n\t\t}\n\t}\n\n\tpublic void setHeader(View header) {\n\t\tthis.header = header;\n\t\tthis.singleSectionHeader = true;\n\t}\n\tpublic View getHeader() {\n\t\treturn header;\n\t}\n\n\tpublic void setShowArtist(boolean showArtist) {\n\t\tthis.showArtist = showArtist;\n\t}\n\n\tpublic void setShowAlbum(boolean showAlbum) {\n\t\tthis.showAlbum = showAlbum;\n\t}\n\n\tpublic void removeAt(int index) {\n\t\tsections.get(0).remove(index);\n\t\tif(header != null) {\n\t\t\tindex++;\n\t\t}\n\t\tnotifyItemRemoved(index);\n\t}\n\n\tpublic void setRemoveFromPlaylist(boolean removeFromPlaylist) {\n\t\tthis.removeFromPlaylist = removeFromPlaylist;\n\t}\n\n\t@Override\n\tpublic void onCreateActionModeMenu(Menu menu, MenuInflater menuInflater) {\n\t\tif(Util.isOffline(context)) {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media_offline, menu);\n\t\t} else {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media, menu);\n\t\t}\n\n\t\tif(!removeFromPlaylist) {\n\t\t\tmenu.removeItem(R.id.menu_remove_playlist);\n\t\t}\n\n\t\tif(!selected.isEmpty()) {\n\t\t\tMenuItem starItem = menu.findItem(R.id.menu_star);\n\t\t\tif(starItem != null) {\n\t\t\t\tboolean isStarred = selected.get(0).isStarred();\n\t\t\t\tstarItem.setTitle(isStarred ? R.string.common_unstar : R.string.common_star);\n\t\t\t}\n\t\t}\n\t}\n}\n\n'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'\n:\npackage github.daneren2005.dsub.domain;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.media.MediaMetadataRetriever;\nimport android.os.Build;\nimport android.util.Log;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Locale;\n\nimport github.daneren2005.dsub.service.DownloadService;\nimport github.daneren2005.dsub.util.Constants;\nimport github.daneren2005.dsub.util.UpdateHelper;\nimport github.daneren2005.dsub.util.Util;\n\n\npublic class MusicDirectory implements Serializable {\n\tprivate static final String TAG = MusicDirectory.class.getSimpleName();\n\n    private String name;\n\tprivate String id;\n\tprivate String parent;\n    private List<Entry> children;\n\n\tpublic MusicDirectory() {\n\t\tchildren = new ArrayList<Entry>();\n\t}\n\tpublic MusicDirectory(List<Entry> children) {\n\t\tthis.children = children;\n\t}\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n\t public String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getParent() {\n\t\treturn parent;\n\t}\n\n\tpublic void setParent(String parent) {\n\t\tthis.parent = parent;\n\t}\n\n\tpublic void addChild(Entry child) {\n\t\tif(child != null) {\n\t\t\tchildren.add(child);\n\t\t}\n\t}\n\tpublic void addChildren(List<Entry> children) {\n\t\tthis.children.addAll(children);\n\t}\n\n\tpublic void replaceChildren(List<Entry> children) {\n\t\tthis.children = children;\n\t}\n\n    public synchronized List<Entry> getChildren() {\n        return getChildren(true, true);\n    }\n\n    public synchronized List<Entry> getChildren(boolean includeDirs, boolean includeFiles) {\n        if (includeDirs && includeFiles) {\n            return children;\n        }\n\n        List<Entry> result = new ArrayList<Entry>(children.size());\n        for (Entry child : children) {\n            if (child != null && child.isDirectory() && includeDirs || !child.isDirectory() && includeFiles) {\n                result.add(child);\n            }\n        }\n        return result;\n    }\n\tpublic synchronized List<Entry> getSongs() {\n\t\tList<Entry> result = new ArrayList<Entry>();\n\t\tfor (Entry child : children) {\n\t\t\tif (child != null && !child.isDirectory() && !child.isVideo()) {\n\t\t\t\tresult.add(child);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic synchronized int getChildrenSize() {\n\t\treturn children.size();\n\t}\n\n\tpublic void shuffleChildren() {\n\t\tCollections.shuffle(this.children);\n\t}\n\n\tpublic void sortChildren(Context context, int instance) {\n\n\t\tif(ServerInfo.checkServerVersion(context, \"1.8\", instance)) {\n\t\t\tsortChildren(Util.getPreferences(context).getBoolean(Constants.PREFERENCES_KEY_CUSTOM_SORT_ENABLED, true));\n\t\t}\n\t}\n\tpublic void sortChildren(boolean byYear) {\n\t\tEntryComparator.sort(children, byYear);\n\t}\n\n\tpublic synchronized boolean updateMetadata(MusicDirectory refreshedDirectory) {\n\t\tboolean metadataUpdated = false;\n\t\tIterator<Entry> it = children.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tEntry entry = it.next();\n\t\t\tint index = refreshedDirectory.children.indexOf(entry);\n\t\t\tif(index != -1) {\n\t\t\t\tfinal Entry refreshed = refreshedDirectory.children.get(index);\n\n\t\t\t\tentry.setTitle(refreshed.getTitle());\n\t\t\t\tentry.setAlbum(refreshed.getAlbum());\n\t\t\t\tentry.setArtist(refreshed.getArtist());\n\t\t\t\tentry.setTrack(refreshed.getTrack());\n\t\t\t\tentry.setYear(refreshed.getYear());\n\t\t\t\tentry.setGenre(refreshed.getGenre());\n\t\t\t\tentry.setTranscodedContentType(refreshed.getTranscodedContentType());\n\t\t\t\tentry.setTranscodedSuffix(refreshed.getTranscodedSuffix());\n\t\t\t\tentry.setDiscNumber(refreshed.getDiscNumber());\n\t\t\t\tentry.setStarred(refreshed.isStarred());\n\t\t\t\tentry.setRating(refreshed.getRating());\n\t\t\t\tentry.setType(refreshed.getType());\n\t\t\t\tif(!Util.equals(entry.getCoverArt(), refreshed.getCoverArt())) {\n\t\t\t\t\tmetadataUpdated = true;\n\t\t\t\t\tentry.setCoverArt(refreshed.getCoverArt());\n\t\t\t\t}\n\n\t\t\t\tnew UpdateHelper.EntryInstanceUpdater(entry) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void update(Entry found) {\n\t\t\t\t\t\tfound.setTitle(refreshed.getTitle());\n\t\t\t\t\t\tfound.setAlbum(refreshed.getAlbum());\n\t\t\t\t\t\tfound.setArtist(refreshed.getArtist());\n\t\t\t\t\t\tfound.setTrack(refreshed.getTrack());\n\t\t\t\t\t\tfound.setYear(refreshed.getYear());\n\t\t\t\t\t\tfound.setGenre(refreshed.getGenre());\n\t\t\t\t\t\tfound.setTranscodedContentType(refreshed.getTranscodedContentType());\n\t\t\t\t\t\tfound.setTranscodedSuffix(refreshed.getTranscodedSuffix());\n\t\t\t\t\t\tfound.setDiscNumber(refreshed.getDiscNumber());\n\t\t\t\t\t\tfound.setStarred(refreshed.isStarred());\n\t\t\t\t\t\tfound.setRating(refreshed.getRating());\n\t\t\t\t\t\tfound.setType(refreshed.getType());\n\t\t\t\t\t\tif(!Util.equals(found.getCoverArt(), refreshed.getCoverArt())) {\n\t\t\t\t\t\t\tfound.setCoverArt(refreshed.getCoverArt());\n\t\t\t\t\t\t\tmetadataUpdate = DownloadService.METADATA_UPDATED_COVER_ART;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.execute();\n\t\t\t}\n\t\t}\n\n\t\treturn metadataUpdated;\n\t}\n\tpublic synchronized boolean updateEntriesList(Context context, int instance, MusicDirectory refreshedDirectory) {\n\t\tboolean changed = false;\n\t\tIterator<Entry> it = children.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tEntry entry = it.next();\n\n\t\t\tif(refreshedDirectory.children.indexOf(entry) == -1) {\n\t\t\t\tit.remove();\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\n\t\tboolean resort = false;\n\t\tfor(Entry refreshed: refreshedDirectory.children) {\n\t\t\tif(!this.children.contains(refreshed)) {\n\t\t\t\tthis.children.add(refreshed);\n\t\t\t\tresort = true;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif(resort) {\n\t\t\tthis.sortChildren(context, instance);\n\t\t}\n\n\t\treturn changed;\n\t}\n\n    public static class Entry implements Serializable {\n\t\tpublic static final int TYPE_SONG = 0;\n\t\tpublic static final int TYPE_PODCAST = 1;\n\t\tpublic static final int TYPE_AUDIO_BOOK = 2;\n\n\t\tprivate String id;\n\t\tprivate String parent;\n\t\tprivate String grandParent;\n\t\tprivate String albumId;\n\t\tprivate String artistId;\n\t\tprivate boolean directory;\n\t\tprivate String title;\n\t\tprivate String album;\n\t\tprivate String artist;\n\t\tprivate Integer track;\n\t\tprivate Integer customOrder;\n\t\tprivate Integer year;\n\t\tprivate String genre;\n\t\tprivate String contentType;\n\t\tprivate String suffix;\n\t\tprivate String transcodedContentType;\n\t\tprivate String transcodedSuffix;\n\t\tprivate String coverArt;\n\t\tprivate Long size;\n\t\tprivate Integer duration;\n\t\tprivate Integer bitRate;\n\t\tprivate String path;\n\t\tprivate boolean video;\n\t\tprivate Integer discNumber;\n\t\tprivate boolean starred;\n\t\tprivate Integer rating;\n\t\tprivate Bookmark bookmark;\n\t\tprivate int type = 0;\n\t\tprivate int closeness;\n\t\tprivate transient Artist linkedArtist;\n\n\t\tpublic Entry() {\n\n\t\t}\n\t\tpublic Entry(String id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\tpublic Entry(Artist artist) {\n\t\t\tthis.id = artist.getId();\n\t\t\tthis.title = artist.getName();\n\t\t\tthis.directory = true;\n\t\t\tthis.starred = artist.isStarred();\n\t\t\tthis.rating = artist.getRating();\n\t\t\tthis.linkedArtist = artist;\n\t\t}\n\n\t\t@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)\n\t\tpublic void loadMetadata(File file) {\n\t\t\ttry {\n\t\t\t\tMediaMetadataRetriever metadata = new MediaMetadataRetriever();\n\t\t\t\tmetadata.setDataSource(file.getAbsolutePath());\n\t\t\t\tString discNumber = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DISC_NUMBER);\n\t\t\t\tif(discNumber == null) {\n\t\t\t\t\tdiscNumber = \"1/1\";\n\t\t\t\t}\n\t\t\t\tint slashIndex = discNumber.indexOf(\"/\");\n\t\t\t\tif(slashIndex > 0) {\n\t\t\t\t\tdiscNumber = discNumber.substring(0, slashIndex);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tsetDiscNumber(Integer.parseInt(discNumber));\n\t\t\t\t} catch(Exception e) {\n\t\t\t\t\tLog.w(TAG, \"Non numbers in disc field!\");\n\t\t\t\t}\n\t\t\t\tString bitrate = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE);\n\t\t\t\tsetBitRate(Integer.parseInt((bitrate != null) ? bitrate : \"0\") / 1000);\n\t\t\t\tString length = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);\n\t\t\t\tsetDuration(Integer.parseInt(length) / 1000);\n\t\t\t\tString artist = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);\n\t\t\t\tif(artist != null) {\n\t\t\t\t\tsetArtist(artist);\n\t\t\t\t}\n\t\t\t\tString album = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);\n\t\t\t\tif(album != null) {\n\t\t\t\t\tsetAlbum(album);\n\t\t\t\t}\n\t\t\t\tmetadata.release();\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.i(TAG, \"Device doesn't properly support MediaMetadataRetreiver\", e);\n\t\t\t}\n\t\t}\n\t\tpublic void rebaseTitleOffPath() {\n\t\t\ttry {\n\t\t\t\tString filename = getPath();\n\t\t\t\tif(filename == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tint index = filename.lastIndexOf('/');\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tfilename = filename.substring(index + 1);\n\t\t\t\t\tif (getTrack() != null) {\n\t\t\t\t\t\tfilename = filename.replace(String.format(\"%02d \", getTrack()), \"\");\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = filename.lastIndexOf('.');\n\t\t\t\t\tif(index != -1) {\n\t\t\t\t\t\tfilename = filename.substring(0, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tsetTitle(filename);\n\t\t\t\t}\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to update title based off of path\", e);\n\t\t\t}\n\t\t}\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public String getParent() {\n            return parent;\n        }\n\n        public void setParent(String parent) {\n            this.parent = parent;\n        }\n\n\t\tpublic String getGrandParent() {\n            return grandParent;\n        }\n\n        public void setGrandParent(String grandParent) {\n            this.grandParent = grandParent;\n        }\n\n\t\tpublic String getAlbumId() {\n\t\t\treturn albumId;\n\t\t}\n\n\t\tpublic void setAlbumId(String albumId) {\n\t\t\tthis.albumId = albumId;\n\t\t}\n\n\t\tpublic String getArtistId() {\n\t\t\treturn artistId;\n\t\t}\n\n\t\tpublic void setArtistId(String artistId) {\n\t\t\tthis.artistId = artistId;\n\t\t}\n\n        public boolean isDirectory() {\n            return directory;\n        }\n\n        public void setDirectory(boolean directory) {\n            this.directory = directory;\n        }\n\n        public String getTitle() {\n            return title;\n        }\n\n        public void setTitle(String title) {\n            this.title = title;\n        }\n\n        public String getAlbum() {\n            return album;\n        }\n\n\t\tpublic boolean isAlbum() {\n\t\t\treturn getParent() != null || getArtist() != null;\n\t\t}\n\n\t\tpublic String getAlbumDisplay() {\n\t\t\tif(album != null && title.startsWith(\"Disc \")) {\n\t\t\t\treturn album;\n\t\t\t} else {\n\t\t\t\treturn title;\n\t\t\t}\n\t\t}\n\n        public void setAlbum(String album) {\n            this.album = album;\n        }\n\n        public String getArtist() {\n            return artist;\n        }\n\n        public void setArtist(String artist) {\n            this.artist = artist;\n        }\n\n        public Integer getTrack() {\n            return track;\n        }\n\n        public void setTrack(Integer track) {\n            this.track = track;\n        }\n\n\t\tpublic Integer getCustomOrder() {\n\t\t\treturn customOrder;\n\t\t}\n\t\tpublic void setCustomOrder(Integer customOrder) {\n\t\t\tthis.customOrder = customOrder;\n\t\t}\n\n        public Integer getYear() {\n            return year;\n        }\n\n        public void setYear(Integer year) {\n            this.year = year;\n        }\n\n        public String getGenre() {\n            return genre;\n        }\n\n        public void setGenre(String genre) {\n            this.genre = genre;\n        }\n\n        public String getContentType() {\n            return contentType;\n        }\n\n        public void setContentType(String contentType) {\n            this.contentType = contentType;\n        }\n\n        public String getSuffix() {\n            return suffix;\n        }\n\n        public void setSuffix(String suffix) {\n            this.suffix = suffix;\n        }\n\n        public String getTranscodedContentType() {\n            return transcodedContentType;\n        }\n\n        public void setTranscodedContentType(String transcodedContentType) {\n            this.transcodedContentType = transcodedContentType;\n        }\n\n        public String getTranscodedSuffix() {\n            return transcodedSuffix;\n        }\n\n        public void setTranscodedSuffix(String transcodedSuffix) {\n            this.transcodedSuffix = transcodedSuffix;\n        }\n\n        public Long getSize() {\n            return size;\n        }\n\n        public void setSize(Long size) {\n            this.size = size;\n        }\n\n        public Integer getDuration() {\n            return duration;\n        }\n\n        public void setDuration(Integer duration) {\n            this.duration = duration;\n        }\n\n        public Integer getBitRate() {\n            return bitRate;\n        }\n\n        public void setBitRate(Integer bitRate) {\n            this.bitRate = bitRate;\n        }\n\n        public String getCoverArt() {\n            return coverArt;\n        }\n\n        public void setCoverArt(String coverArt) {\n            this.coverArt = coverArt;\n        }\n\n        public String getPath() {\n            return path;\n        }\n\n        public void setPath(String path) {\n            this.path = path;\n        }\n\n        public boolean isVideo() {\n            return video;\n        }\n\n        public void setVideo(boolean video) {\n            this.video = video;\n        }\n\n\t\tpublic Integer getDiscNumber() {\n\t\t\treturn discNumber;\n\t\t}\n\n\t\tpublic void setDiscNumber(Integer discNumber) {\n\t\t\tthis.discNumber = discNumber;\n\t\t}\n\n        public boolean isStarred() {\n            return starred;\n        }\n\n        public void setStarred(boolean starred) {\n            this.starred = starred;\n\n\t\t\tif(linkedArtist != null) {\n\t\t\t\tlinkedArtist.setStarred(starred);\n\t\t\t}\n        }\n\n\t\tpublic int getRating() {\n\t\t\treturn rating == null ? 0 : rating;\n\t\t}\n\t\tpublic void setRating(Integer rating) {\n\t\t\tif(rating == null || rating == 0) {\n\t\t\t\tthis.rating = null;\n\t\t\t} else {\n\t\t\t\tthis.rating = rating;\n\t\t\t}\n\n\t\t\tif(linkedArtist != null) {\n\t\t\t\tlinkedArtist.setRating(rating);\n\t\t\t}\n\t\t}\n\n\t\tpublic Bookmark getBookmark() {\n\t\t\treturn bookmark;\n\t\t}\n\t\tpublic void setBookmark(Bookmark bookmark) {\n\t\t\tthis.bookmark = bookmark;\n\t\t}\n\n\t\tpublic int getType() {\n\t\t\treturn type;\n\t\t}\n\t\tpublic void setType(int type) {\n\t\t\tthis.type = type;\n\t\t}\n\t\tpublic boolean isSong() {\n\t\t\treturn type == TYPE_SONG;\n\t\t}\n\t\tpublic boolean isPodcast() {\n\t\t\treturn this instanceof PodcastEpisode || type == TYPE_PODCAST;\n\t\t}\n\t\tpublic boolean isAudioBook() {\n\t\t\treturn type == TYPE_AUDIO_BOOK;\n\t\t}\n\n\t\tpublic int getCloseness() {\n\t\t\treturn closeness;\n\t\t}\n\n\t\tpublic void setCloseness(int closeness) {\n\t\t\tthis.closeness = closeness;\n\t\t}\n\n\t\tpublic boolean isOnlineId(Context context) {\n\t\t\ttry {\n\t\t\t\tString cacheLocation = Util.getPreferences(context).getString(Constants.PREFERENCES_KEY_CACHE_LOCATION, null);\n\t\t\t\treturn cacheLocation == null || id == null || id.indexOf(cacheLocation) == -1;\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to check online id validity\");\n\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            Entry entry = (Entry) o;\n            return id.equals(entry.id);\n        }\n\n        @Override\n        public int hashCode() {\n            return id.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return title;\n        }\n\n        public byte[] toByteArray() throws IOException {\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tObjectOutput out = null;\n\t\t\ttry {\n\t\t\t\tout = new ObjectOutputStream(bos);\n\t\t\t\tout.writeObject(this);\n\t\t\t\tout.flush();\n\t\t\t\treturn bos.toByteArray();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tbos.close();\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static Entry fromByteArray(byte[] byteArray) throws IOException, ClassNotFoundException {\n\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(byteArray);\n\t\t\tObjectInput in = null;\n\t\t\ttry {\n\t\t\t\tin = new ObjectInputStream(bis);\n\t\t\t\treturn (Entry) in.readObject();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static class EntryComparator implements Comparator<Entry> {\n\t\tprivate boolean byYear;\n\t\tprivate Collator collator;\n\n\t\tpublic EntryComparator(boolean byYear) {\n\t\t\tthis.byYear = byYear;\n\t\t\tthis.collator = Collator.getInstance(Locale.US);\n\t\t\tthis.collator.setStrength(Collator.PRIMARY);\n\t\t}\n\n\t\tpublic int compare(Entry lhs, Entry rhs) {\n\t\t\tif(lhs.isDirectory() && !rhs.isDirectory()) {\n\t\t\t\treturn -1;\n\t\t\t} else if(!lhs.isDirectory() && rhs.isDirectory()) {\n\t\t\t\treturn 1;\n\t\t\t} else if(lhs.isDirectory() && rhs.isDirectory()) {\n\t\t\t\tif(byYear) {\n\t\t\t\t\tInteger lhsYear = lhs.getYear();\n\t\t\t\t\tInteger rhsYear = rhs.getYear();\n\t\t\t\t\tif(lhsYear != null && rhsYear != null) {\n\t\t\t\t\t\treturn lhsYear.compareTo(rhsYear);\n\t\t\t\t\t} else if(lhsYear != null) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else if(rhsYear != null) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn collator.compare(lhs.getAlbumDisplay(), rhs.getAlbumDisplay());\n\t\t\t}\n\n\t\t\tInteger lhsDisc = lhs.getDiscNumber();\n\t\t\tInteger rhsDisc = rhs.getDiscNumber();\n\n\t\t\tif(lhsDisc != null && rhsDisc != null) {\n\t\t\t\tif(lhsDisc < rhsDisc) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if(lhsDisc > rhsDisc) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInteger lhsTrack = lhs.getTrack();\n\t\t\tInteger rhsTrack = rhs.getTrack();\n\t\t\tif(lhsTrack == rhsTrack) {\n\t\t\t\treturn collator.compare(lhs.getTitle(), rhs.getTitle());\n\t\t\t} else if(lhsTrack != null && rhsTrack != null) {\n\t\t\t\treturn lhsTrack.compareTo(rhsTrack);\n\t\t\t} else if(lhsTrack != null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic static void sort(List<Entry> entries) {\n\t\t\tsort(entries, true);\n\t\t}\n\t\tpublic static void sort(List<Entry> entries, boolean byYear) {\n\t\t\ttry {\n\t\t\t\tCollections.sort(entries, new EntryComparator(byYear));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to sort MusicDirectory\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "gt": [
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.avro.AvroSchemaVisitor;\nimport com.netflix.iceberg.avro.ValueWriter;\nimport com.netflix.iceberg.avro.ValueWriters;\nimport com.netflix.iceberg.types.Type;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.types.DataType;\nimport java.io.IOException;\nimport java.util.List;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getFieldId;\nimport static com.netflix.iceberg.avro.AvroSchemaVisitor.visit;\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\npublic class SparkAvroWriter implements DatumWriter<InternalRow> {\n  private final com.netflix.iceberg.Schema schema;\n  private ValueWriter<InternalRow> writer = null;\n\n  public SparkAvroWriter(com.netflix.iceberg.Schema schema) {\n    this.schema = schema;\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void setSchema(Schema schema) {\n    this.writer = (ValueWriter<InternalRow>) visit(schema, new WriteBuilder(this.schema));\n  }\n\n  @Override\n  public void write(InternalRow datum, Encoder out) throws IOException {\n    writer.write(datum, out);\n  }\n\n  private static class WriteBuilder extends AvroSchemaVisitor<ValueWriter<?>> {\n    private final com.netflix.iceberg.Schema schema;\n\n    private WriteBuilder(com.netflix.iceberg.Schema schema) {\n      this.schema = schema;\n    }\n\n    @Override\n    public ValueWriter<?> record(Schema record, List<String> names, List<ValueWriter<?>> fields) {\n      List<DataType> types = Lists.newArrayList();\n      for (Schema.Field field : record.getFields()) {\n        types.add(convert(schema.findType(getFieldId(field))));\n      }\n      return SparkValueWriters.struct(fields, types);\n    }\n\n    @Override\n    public ValueWriter<?> union(Schema union, List<ValueWriter<?>> options) {\n      Preconditions.checkArgument(options.contains(ValueWriters.nulls()),\n          \"Cannot create writer for non-option union: \" + union);\n      Preconditions.checkArgument(options.size() == 2,\n          \"Cannot create writer for non-option union: \" + union);\n      if (union.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return ValueWriters.option(0, options.get(1));\n      } else {\n        return ValueWriters.option(1, options.get(0));\n      }\n    }\n\n    @Override\n    public ValueWriter<?> array(Schema array, ValueWriter<?> elementWriter) {\n      LogicalType logical = array.getLogicalType();\n      if (logical != null && \"map\".equals(logical.getName())) {\n        Type keyType = schema.findType(getFieldId(array.getElementType().getField(\"key\")));\n        Type valueType = schema.findType(getFieldId(array.getElementType().getField(\"value\")));\n        ValueWriter<?>[] writers = ((SparkValueWriters.StructWriter) elementWriter).writers;\n        return SparkValueWriters.arrayMap(\n            writers[0], convert(keyType), writers[1], convert(valueType));\n      }\n\n      Type elementType = schema.findType(AvroSchemaUtil.getElementId(array));\n      return SparkValueWriters.array(elementWriter, convert(elementType));\n    }\n\n    @Override\n    public ValueWriter<?> map(Schema map, ValueWriter<?> valueReader) {\n      Type keyType = schema.findType(AvroSchemaUtil.getKeyId(map));\n      Type valueType = schema.findType(AvroSchemaUtil.getValueId(map));\n      return SparkValueWriters.map(\n          SparkValueWriters.strings(), convert(keyType), valueReader, convert(valueType));\n    }\n\n    @Override\n    public ValueWriter<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n\n            return ValueWriters.ints();\n\n          case \"timestamp-micros\":\n\n            return ValueWriters.longs();\n\n          case \"decimal\":\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueWriters.decimal(decimal.getPrecision(), decimal.getScale());\n\n          case \"uuid\":\n            return ValueWriters.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unsupported logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueWriters.nulls();\n        case BOOLEAN:\n          return ValueWriters.booleans();\n        case INT:\n          return ValueWriters.ints();\n        case LONG:\n          return ValueWriters.longs();\n        case FLOAT:\n          return ValueWriters.floats();\n        case DOUBLE:\n          return ValueWriters.doubles();\n        case STRING:\n          return SparkValueWriters.strings();\n        case FIXED:\n          return ValueWriters.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueWriters.bytes();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'\n:\n\npackage com.netflix.iceberg.types;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic class TypeUtil {\n  public static Schema select(Schema schema, Set<Integer> fieldIds) {\n    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n    Preconditions.checkNotNull(fieldIds, \"Field ids cannot be null\");\n\n    Type result = visit(schema, new PruneColumns(fieldIds));\n    if (schema.asStruct() == result) {\n      return schema;\n    } else if (result != null) {\n      if (schema.getAliases() != null) {\n        return new Schema(result.asNestedType().fields(), schema.getAliases());\n      } else {\n        return new Schema(result.asNestedType().fields());\n      }\n    }\n\n    return new Schema(ImmutableList.of(), schema.getAliases());\n  }\n\n  public static Set<Integer> getProjectedIds(Schema schema) {\n    return visit(schema, new GetProjectedIds());\n  }\n\n  public static Set<Integer> getProjectedIds(Type schema) {\n    if (schema.isPrimitiveType()) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(visit(schema, new GetProjectedIds()));\n  }\n\n  public static Schema selectNot(Schema schema, Set<Integer> fieldIds) {\n    Set<Integer> projectedIds = getProjectedIds(schema);\n    projectedIds.removeAll(fieldIds);\n    return select(schema, projectedIds);\n  }\n\n  public static Schema join(Schema left, Schema right) {\n    List<Types.NestedField> joinedColumns = Lists.newArrayList();\n    joinedColumns.addAll(left.columns());\n    joinedColumns.addAll(right.columns());\n    return new Schema(joinedColumns);\n  }\n\n  public static Map<String, Integer> indexByName(Types.StructType struct) {\n    return visit(struct, new IndexByName());\n  }\n\n  public static Map<Integer, Types.NestedField> indexById(Types.StructType struct) {\n    return visit(struct, new IndexById());\n  }\n\n\n  public static Type assignFreshIds(Type type, NextID nextId) {\n    return TypeUtil.visit(type, new AssignFreshIds(nextId));\n  }\n\n\n  public static Schema assignFreshIds(Schema schema, NextID nextId) {\n    return new Schema(TypeUtil\n        .visit(schema.asStruct(), new AssignFreshIds(nextId))\n        .asNestedType()\n        .fields());\n  }\n\n\n  public static Schema reassignIds(Schema schema, Schema idSourceSchema) {\n    Types.StructType struct = visit(schema, new ReassignIds(idSourceSchema)).asStructType();\n    return new Schema(struct.fields());\n  }\n\n  public static Type find(Schema schema, Predicate<Type> predicate) {\n    return visit(schema, new FindTypeVisitor(predicate));\n  }\n\n  public static boolean isPromotionAllowed(Type from, Type.PrimitiveType to) {\n\n\n    if (from.equals(to)) {\n      return true;\n    }\n\n    switch (from.typeId()) {\n      case INTEGER:\n        return to == Types.LongType.get();\n\n      case FLOAT:\n        return to == Types.DoubleType.get();\n\n      case DECIMAL:\n        Types.DecimalType fromDecimal = (Types.DecimalType) from;\n        if (to.typeId() != Type.TypeID.DECIMAL) {\n          return false;\n        }\n\n        Types.DecimalType toDecimal = (Types.DecimalType) to;\n        return (fromDecimal.scale() == toDecimal.scale() &&\n            fromDecimal.precision() <= toDecimal.precision());\n    }\n\n    return false;\n  }\n\n\n  public interface NextID {\n    int get();\n  }\n\n  public static class SchemaVisitor<T> {\n    protected LinkedList<String> fieldNames = Lists.newLinkedList();\n    protected LinkedList<Integer> fieldIds = Lists.newLinkedList();\n\n    public T schema(Schema schema, T structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, List<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, T fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, T elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, T keyResult, T valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  public static <T> T visit(Schema schema, SchemaVisitor<T> visitor) {\n    return visitor.schema(schema, visit(schema.asStruct(), visitor));\n  }\n\n  public static <T> T visit(Type type, SchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<T> results = Lists.newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          visitor.fieldIds.push(field.fieldId());\n          visitor.fieldNames.push(field.name());\n          T result;\n          try {\n            result = visit(field.type(), visitor);\n          } finally {\n            visitor.fieldIds.pop();\n            visitor.fieldNames.pop();\n          }\n          results.add(visitor.field(field, result));\n        }\n        return visitor.struct(struct, results);\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        T elementResult;\n\n        visitor.fieldIds.push(list.elementId());\n        try {\n          elementResult = visit(list.elementType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.list(list, elementResult);\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        T keyResult;\n        T valueResult;\n\n        visitor.fieldIds.push(map.keyId());\n        try {\n          keyResult = visit(map.keyType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        visitor.fieldIds.push(map.valueId());\n        try {\n          valueResult = visit(map.valueType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.map(map, keyResult, valueResult);\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  public static class CustomOrderSchemaVisitor<T> {\n    public T schema(Schema schema, Supplier<T> structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, Iterable<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, Supplier<T> fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, Supplier<T> elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, Supplier<T> keyResult, Supplier<T> valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  private static class VisitFuture<T> implements Supplier<T> {\n    private final Type type;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFuture(Type type, CustomOrderSchemaVisitor<T> visitor) {\n      this.type = type;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visit(type, visitor);\n    }\n  }\n\n  private static class VisitFieldFuture<T> implements Supplier<T> {\n    private final Types.NestedField field;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFieldFuture(Types.NestedField field, CustomOrderSchemaVisitor<T> visitor) {\n      this.field = field;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visitor.field(field, new VisitFuture<>(field.type(), visitor));\n    }\n  }\n\n  public static <T> T visit(Schema schema, CustomOrderSchemaVisitor<T> visitor) {\n    return visitor.schema(schema, new VisitFuture<>(schema.asStruct(), visitor));\n  }\n\n\n  public static <T> T visit(Type type, CustomOrderSchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<VisitFieldFuture<T>> results = Lists\n            .newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          results.add(\n              new VisitFieldFuture<>(field, visitor));\n        }\n\n        return visitor.struct(struct, Iterables.transform(results, VisitFieldFuture::get));\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        return visitor.list(list, new VisitFuture<>(list.elementType(), visitor));\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        return visitor.map(map,\n            new VisitFuture<>(map.keyType(), visitor),\n            new VisitFuture<>(map.valueType(), visitor));\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  static int decimalMaxPrecision(int numBytes) {\n    Preconditions.checkArgument(numBytes >= 0 && numBytes < 24,\n        \"Unsupported decimal length: \" + numBytes);\n    return MAX_PRECISION[numBytes];\n  }\n\n  public static int decimalRequriedBytes(int precision) {\n    Preconditions.checkArgument(precision >= 0 && precision < 40,\n        \"Unsupported decimal precision: \" + precision);\n    return REQUIRED_LENGTH[precision];\n  }\n\n  private static int[] MAX_PRECISION = new int[24];\n  private static int[] REQUIRED_LENGTH = new int[40];\n\n  static {\n\n    for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n      MAX_PRECISION[len] = (int) Math.floor(Math.log10(Math.pow(2, 8*len - 1) - 1));\n    }\n\n\n    for (int precision = 0; precision < REQUIRED_LENGTH.length; precision += 1) {\n      REQUIRED_LENGTH[precision] = -1;\n      for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n\n        if (precision <= MAX_PRECISION[len]) {\n          REQUIRED_LENGTH[precision] = len;\n          break;\n        }\n      }\n      if (REQUIRED_LENGTH[precision] < 0) {\n        throw new IllegalStateException(\n            \"Could not find required length for precision \" + precision);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n\n'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.MenuItem;\nimport com.jnardari.opencv_androidsamples.R;\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Mat;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport android.util.Log;\nimport android.view.SurfaceView;\nimport android.view.WindowManager;\n\npublic class Tutorial1Activity extends AppCompatActivity implements CvCameraViewListener2 {\n    private static final String TAG = \"Tutorial1Activity\";\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n    private boolean              mIsJavaCamera = true;\n    private MenuItem             mItemSwitchCamera = null;\n\n    private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public Tutorial1Activity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_tutorial1);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.tutorial1_activity_java_surface_view);\n\n        mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);\n\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n    }\n\n    public void onCameraViewStopped() {\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        return inputFrame.rgba();\n    }\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/Tutorial1Activity.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.NonNull;\nimport android.support.graphics.drawable.AnimatedVectorDrawableCompat;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.ImageButton;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\nimport com.philliphsu.bottomsheetpickers.date.MonthPickerView.OnMonthClickListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\n\n\nclass PagingDayPickerView extends LinearLayout implements OnDateChangedListener, OnPageChangeListener, OnMonthClickListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n    static final int DAY_PICKER_INDEX = 0;\n    static final int MONTH_PICKER_INDEX = 1;\n\n    static int MONTH_NAVIGATION_BAR_SIZE;\n\n    private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected PagingMonthAdapter mAdapter;\n\n    private DayPickerViewAnimator mMonthAnimator;\n    private ViewPager mViewPager;\n    private MonthPickerView mMonthPickerView;\n    private TextView mMonthYearTitleView;\n    private ImageButton mPreviousButton;\n    private ImageButton mNextButton;\n    private View mTitleContainer;\n\n\n    private AnimatedVectorDrawableCompat mArrowDownDrawable;\n\n    private AnimatedVectorDrawableCompat mArrowUpDrawable;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mCurrentMonthDisplayed;\n\n    private int mCurrentView = DAY_PICKER_INDEX;\n\n    private int mCurrentYearDisplayed;\n\n    private DatePickerController mController;\n\n    private boolean mThemeDark;\n    private int mAccentColor;\n\n    public PagingDayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        this(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark,\n                               int accentColor) {\n        super(context);\n\n        mThemeDark = themeDark;\n        mAccentColor = accentColor;\n        init(context);\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n        mMonthPickerView.setDatePickerController(mController);\n    }\n\n    private void init(Context context) {\n        mHandler = new Handler();\n        setOrientation(VERTICAL);\n        setLayoutParams(new LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        Resources res = getResources();\n        MONTH_NAVIGATION_BAR_SIZE = res.getDimensionPixelOffset(R.dimen.bsp_month_navigation_bar_height)\n                + res.getDimensionPixelOffset(R.dimen.bsp_month_view_top_padding);\n\n        final View view = LayoutInflater.from(context).inflate(R.layout.bsp_day_picker_content, this, true);\n        mMonthAnimator = (DayPickerViewAnimator) findViewById(R.id.bsp_month_animator);\n        mMonthPickerView = (MonthPickerView) findViewById(R.id.bsp_month_picker);\n        mMonthPickerView.setOnMonthClickListener(this);\n        mViewPager = (ViewPager) findViewById(R.id.bsp_viewpager);\n        mViewPager.addOnPageChangeListener(this);\n        mMonthYearTitleView = (TextView) view.findViewById(R.id.bsp_month_year_title);\n        mTitleContainer = view.findViewById(R.id.bsp_month_year_title_container);\n        mTitleContainer.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int newIndex = mCurrentView == DAY_PICKER_INDEX ? MONTH_PICKER_INDEX : DAY_PICKER_INDEX;\n                setupCurrentView(newIndex, true);\n            }\n        });\n        mPreviousButton = (ImageButton) view.findViewById(R.id.bsp_prev);\n        mPreviousButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int previousItem = mViewPager.getCurrentItem() - 1;\n                if (previousItem >= 0) {\n                    mViewPager.setCurrentItem(previousItem, true);\n                }\n            }\n        });\n        mNextButton = (ImageButton) view.findViewById(R.id.bsp_next);\n        mNextButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int nextItem = mViewPager.getCurrentItem() + 1;\n                if (nextItem < mAdapter.getCount()) {\n                    mViewPager.setCurrentItem(nextItem, true);\n                }\n            }\n        });\n\n        mArrowDownDrawable = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_down);\n        mArrowUpDrawable   = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_up);\n        setArrowDrawableOnTitle(mArrowDownDrawable);\n\n\n        if (mThemeDark) {\n            int selectableItemBg = getColor(context, R.color.bsp_selectable_item_background_dark);\n            Utils.setColorControlHighlight(mPreviousButton, selectableItemBg);\n            Utils.setColorControlHighlight(mNextButton, selectableItemBg);\n            Utils.setColorControlHighlight(mTitleContainer, selectableItemBg);\n            int cursor = getColor(context, R.color.bsp_text_color_secondary_dark);\n            Utils.applyTint(mPreviousButton, cursor);\n            Utils.applyTint(mNextButton, cursor);\n        }\n\n\n        int monthYearTitleColor = getColor(context, mThemeDark?\n                R.color.bsp_text_color_primary_dark : R.color.bsp_text_color_primary_light);\n        int dropdownArrowColor = getColor(context, mThemeDark?\n                R.color.bsp_icon_color_active_dark : R.color.bsp_icon_color_active_light);\n\n        mMonthYearTitleView.setTextColor(monthYearTitleColor);\n        mArrowDownDrawable.setTint(dropdownArrowColor);\n        mArrowUpDrawable.setTint(dropdownArrowColor);\n\n        mMonthPickerView.setTheme(context, mThemeDark);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mViewPager.removeOnPageChangeListener(this);\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    void setAccentColor(@ColorInt int color) {\n        mAccentColor = color;\n        mMonthPickerView.setCurrentMonthTextColor(color);\n        mMonthPickerView.setSelectedCirclePaintColor(color);\n    }\n\n    public void onChange() {\n        refreshAdapter();\n        refreshMonthPicker();\n    }\n\n\n    void setupCurrentView(int currentView, boolean animate) {\n        if (currentView == DAY_PICKER_INDEX || currentView == MONTH_PICKER_INDEX) {\n            boolean isDayPicker = currentView == DAY_PICKER_INDEX;\n            setCurrentView(currentView, animate);\n            if (isDayPicker) {\n                setTitle(mAdapter.getPageTitle(mViewPager.getCurrentItem()));\n                toggleArrowsVisibility(getPagerPosition());\n            } else {\n\n\n\n                setTitle(String.valueOf(mCurrentYearDisplayed));\n                toggleArrowsVisibility(false, false);\n            }\n        } else {\n            Log.e(TAG, \"Error restoring current view\");\n        }\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            if (mAccentColor != 0) {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark, mAccentColor);\n            } else {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n            }\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        mViewPager.setAdapter(mAdapter);\n    }\n\n\n    private void refreshMonthPicker() {\n        prepareMonthPickerForDisplay(mSelectedDay.year);\n        mMonthPickerView.invalidate();\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller) {\n        return new PagingMonthAdapter(context, controller);\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark) {\n        return createMonthAdapter(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark,\n                                                 int accentColor) {\n        return new PagingMonthAdapter(context, controller, themeDark, accentColor);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n        final int selectedPosition = getPosition(mSelectedDay);\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = getPosition(day);\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthAndYearDisplayed(mTempDay);\n            if (animate) {\n                mViewPager.setCurrentItem(position, true);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n                return true;\n            } else {\n                postSetSelection(position, setSelected);\n            }\n        } else if (setSelected) {\n            setMonthAndYearDisplayed(mSelectedDay);\n            setSelectedDay(mSelectedDay);\n        }\n        return false;\n    }\n\n\n    private int getPosition(CalendarDay day) {\n        return mAdapter.getPosition(day);\n    }\n\n    public void postSetSelection(final int position, final boolean setSelected) {\n        clearFocus();\n        post(new Runnable() {\n            @Override\n            public void run() {\n                mViewPager.setCurrentItem(position, false);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n            }\n        });\n    }\n\n    void postSetupCurrentView(final int currentView, final boolean animate) {\n        post(new Runnable() {\n            @Override\n            public void run() {\n                setupCurrentView(currentView, animate);\n            }\n        });\n    }\n\n\n    protected void setMonthAndYearDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        mCurrentYearDisplayed = date.year;\n    }\n\n    private void setSelectedDay(CalendarDay day) {\n        mAdapter.setSelectedDay(day);\n    }\n\n    @Override\n    public void onDateChanged() {\n        if (mCurrentView != DAY_PICKER_INDEX) {\n            setCurrentView(DAY_PICKER_INDEX, false);\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getPagerPosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        return true;\n    }\n\n    int getPagerPosition() {\n        return mViewPager.getCurrentItem();\n    }\n\n    int getCurrentView() {\n        return mCurrentView;\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mCurrentView == DAY_PICKER_INDEX) {\n            setTitle(mAdapter.getPageTitle(position));\n            toggleArrowsVisibility(position);\n            final int month = mAdapter.getMonth(position);\n            final int year = mAdapter.getYear(position);\n            if (mCurrentYearDisplayed != year) {\n                mCurrentYearDisplayed = year;\n            }\n            if (mCurrentMonthDisplayed != month) {\n                mCurrentMonthDisplayed = month;\n            }\n        }\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n\n    private void setTitle(CharSequence title) {\n        mMonthYearTitleView.setText(title);\n    }\n\n\n    private void toggleArrowsVisibility(int position) {\n        toggleArrowsVisibility(position > 0, position + 1 < mAdapter.getCount());\n    }\n\n    private void toggleArrowsVisibility(boolean leftVisible, boolean rightVisible) {\n        mPreviousButton.setVisibility(leftVisible ? VISIBLE : INVISIBLE);\n        mNextButton.setVisibility(rightVisible ? VISIBLE : INVISIBLE);\n    }\n\n    private void setArrowDrawableOnTitle(@NonNull Drawable arrow) {\n        if (Utils.checkApiLevel(17)) {\n            mMonthYearTitleView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, arrow, null);\n        } else {\n            mMonthYearTitleView.setCompoundDrawablesWithIntrinsicBounds(null, null, arrow, null);\n        }\n    }\n\n    private void animateArrow(AnimatedVectorDrawableCompat arrow) {\n        setArrowDrawableOnTitle(arrow);\n        arrow.start();\n    }\n\n    private void setCurrentView(final int viewIndex, boolean animate) {\n        switch (viewIndex) {\n            case DAY_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    mMonthAnimator.setDisplayedChild(DAY_PICKER_INDEX, animate);\n                    animateArrow(mArrowUpDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n            case MONTH_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    prepareMonthPickerForDisplay(mCurrentYearDisplayed);\n                    mMonthAnimator.setDisplayedChild(MONTH_PICKER_INDEX, animate);\n                    animateArrow(mArrowDownDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n        }\n    }\n\n    private void prepareMonthPickerForDisplay(int currentYear) {\n        mMonthPickerView.setDisplayParams(mSelectedDay, currentYear);\n    }\n\n    @Override\n    public void onMonthClick(MonthPickerView view, int month, int year) {\n\n\n\n\n\n        setCurrentView(DAY_PICKER_INDEX, true);\n\n\n\n\n\n\n\n\n\n\n        if (month == mCurrentMonthDisplayed) {\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        mController.tryVibrate();\n        mController.onMonthYearSelected(month, year);\n    }\n}\n\n'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\n\nimport java.util.Calendar;\n\n\npublic interface DatePickerController {\n\n    void onYearSelected(int year);\n\n    void onDayOfMonthSelected(int year, int month, int day);\n\n    void onMonthYearSelected(int month, int year);\n\n    void registerOnDateChangedListener(OnDateChangedListener listener);\n\n    void unregisterOnDateChangedListener(OnDateChangedListener listener);\n\n    CalendarDay getSelectedDay();\n\n    int getFirstDayOfWeek();\n\n    int getMinYear();\n\n    int getMaxYear();\n\n    Calendar getMinDate();\n\n    Calendar getMaxDate();\n\n    void tryVibrate();\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ]
    },
    {
        "files": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'"
        ],
        "content": "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'\n:package net.programmierecke.radiodroid2.history;\n\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.room.ColumnInfo;\nimport androidx.room.Entity;\nimport androidx.room.PrimaryKey;\n\nimport java.util.Date;\n\n@Entity(tableName = \"track_history\")\npublic class TrackHistoryEntry {\n\n    @PrimaryKey(autoGenerate = true)\n    public int uid;\n\n    @ColumnInfo(name = \"station_uuid\")\n    @NonNull\n    public String stationUuid;\n\n    @ColumnInfo(name = \"station_icon_url\")\n    @NonNull\n    public String stationIconUrl;\n\n    @ColumnInfo(name = \"track\")\n    @NonNull\n    public String track;\n\n    @ColumnInfo(name = \"artist\")\n    @NonNull\n    public String artist;\n\n    @ColumnInfo(name = \"title\")\n    @NonNull\n    public String title;\n\n    @ColumnInfo(name = \"art_url\")\n    @Nullable\n    public String artUrl;\n\n    @ColumnInfo(name = \"start_time\")\n    @NonNull\n    public Date startTime;\n\n    @ColumnInfo(name = \"end_time\")\n    @NonNull\n    public Date endTime;\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        TrackHistoryEntry that = (TrackHistoryEntry) o;\n\n        if (uid != that.uid) return false;\n        if (!stationUuid.equals(that.stationUuid)) return false;\n        if (!track.equals(that.track)) return false;\n        if (!artist.equals(that.artist)) return false;\n        if (!title.equals(that.title)) return false;\n        if (artUrl != null ? !artUrl.equals(that.artUrl) : that.artUrl != null) return false;\n        if (!startTime.equals(that.startTime)) return false;\n        return endTime.equals(that.endTime);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = uid;\n        result = 31 * result + stationUuid.hashCode();\n        result = 31 * result + track.hashCode();\n        result = 31 * result + artist.hashCode();\n        result = 31 * result + title.hashCode();\n        result = 31 * result + (artUrl != null ? artUrl.hashCode() : 0);\n        result = 31 * result + startTime.hashCode();\n        result = 31 * result + endTime.hashCode();\n        return result;\n    }\n\n    public final static int MAX_HISTORY_ITEMS_IN_TABLE = 1000;\n    public final static int MAX_UNKNOWN_TRACK_DURATION = 3 * 60 * 1000;\n}\n\n'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'\n:package net.programmierecke.radiodroid2.tests.utils;\n\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.ViewConfiguration;\n\nimport androidx.recyclerview.widget.RecyclerView;\nimport androidx.test.espresso.PerformException;\nimport androidx.test.espresso.UiController;\nimport androidx.test.espresso.ViewAction;\nimport androidx.test.espresso.action.GeneralLocation;\nimport androidx.test.espresso.action.MotionEvents;\nimport androidx.test.espresso.action.PrecisionDescriber;\nimport androidx.test.espresso.action.Press;\nimport androidx.test.espresso.action.Swipe;\nimport androidx.test.espresso.action.Swiper;\nimport androidx.test.espresso.util.HumanReadables;\n\nimport org.hamcrest.Matcher;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\n\nimport static androidx.test.espresso.core.internal.deps.guava.base.Preconditions.checkElementIndex;\nimport static androidx.test.espresso.matcher.ViewMatchers.isDisplayingAtLeast;\n\npublic class RecyclerDragAndDropAction implements ViewAction {\n\n\n    private static final int VIEW_DISPLAY_PERCENTAGE = 50;\n\n\n    private static final int DRAG_EVENT_COUNT = 10;\n\n    private static final int DRAG_DURATION = 600;\n\n    private final Swiper swiper;\n    private final int idxFrom;\n    private final int idxTo;\n    private final PrecisionDescriber precisionDescriber;\n\n    public static ViewAction recyclerDragAndDrop(int idxFrom, int idxTo) {\n        return new RecyclerDragAndDropAction(Swipe.FAST, idxFrom, idxTo, Press.FINGER);\n    }\n\n    public RecyclerDragAndDropAction(Swiper swiper, int idxFrom, int idxTo, PrecisionDescriber precisionDescriber) {\n        this.swiper = swiper;\n        this.idxFrom = idxFrom;\n        this.idxTo = idxTo;\n        this.precisionDescriber = precisionDescriber;\n    }\n\n    @Override\n    public Matcher<View> getConstraints() {\n        return isDisplayingAtLeast(VIEW_DISPLAY_PERCENTAGE);\n    }\n\n    private static float[][] interpolate(float[] start, float[] end, int steps) {\n        checkElementIndex(1, start.length);\n        checkElementIndex(1, end.length);\n\n        float[][] res = new float[steps][2];\n\n        for (int i = 1; i < steps + 1; i++) {\n            res[i - 1][0] = start[0] + (end[0] - start[0]) * i / (steps);\n            res[i - 1][1] = start[1] + (end[1] - start[1]) * i / (steps);\n        }\n\n        return res;\n    }\n\n    @Override\n    public void perform(UiController uiController, View view) {\n        final RecyclerView recyclerView = (RecyclerView) view;\n\n        TestUtils.centerItemInRecycler(uiController, recyclerView, idxFrom);\n        uiController.loopMainThreadUntilIdle();\n\n        final View fromView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxFrom)).itemView;\n        final float[] fromViewPosition = GeneralLocation.VISIBLE_CENTER.calculateCoordinates(fromView);\n\n        final float[] precision = precisionDescriber.describePrecision();\n\n        final List<MotionEvent> events = new ArrayList<>();\n        MotionEvents.DownResultHolder downEvent = null;\n\n        boolean success = false;\n        for (int i = 0; i < 3 && !success; i++) {\n            try {\n                downEvent = MotionEvents.sendDown(uiController, fromViewPosition, precision);\n\n                final int longPressTimeout = (int) (ViewConfiguration.getLongPressTimeout() * 1.5f);\n                uiController.loopMainThreadForAtLeast(longPressTimeout);\n\n                TestUtils.centerItemInRecycler(uiController, recyclerView, idxTo);\n                uiController.loopMainThreadUntilIdle();\n\n                final View toView = Objects.requireNonNull(recyclerView.findViewHolderForAdapterPosition(idxTo)).itemView;\n                float[] toViewPosition = GeneralLocation.TOP_CENTER.calculateCoordinates(toView);\n\n                float[][] steps = interpolate(fromViewPosition, toViewPosition, DRAG_EVENT_COUNT);\n\n                final long intervalMS = DRAG_DURATION / steps.length;\n                long eventTime = downEvent.down.getDownTime();\n                for (float[] step : steps) {\n                    eventTime += intervalMS;\n                    events.add(MotionEvents.obtainMovement(downEvent.down.getDownTime(), eventTime, step));\n                }\n\n                eventTime += intervalMS;\n                events.add(\n                        MotionEvent.obtain(\n                                downEvent.down.getDownTime(),\n                                eventTime,\n                                MotionEvent.ACTION_UP,\n                                toViewPosition[0],\n                                toViewPosition[1],\n                                0));\n                uiController.injectMotionEventSequence(events);\n                success = true;\n            } catch (Exception e) {\n                throw new PerformException.Builder()\n                        .withActionDescription(this.getDescription())\n                        .withViewDescription(HumanReadables.describe(view))\n                        .withCause(e)\n                        .build();\n            } finally {\n                for (MotionEvent event : events) {\n                    event.recycle();\n                }\n\n                if (downEvent != null) {\n                    downEvent.down.recycle();\n                }\n            }\n        }\n\n        int duration = ViewConfiguration.getPressedStateDuration();\n\n        if (duration > 0) {\n            uiController.loopMainThreadForAtLeast(duration);\n        }\n    }\n\n    @Override\n    public String getDescription() {\n        return swiper.toString().toLowerCase() + \" recycler-drag-and-drop\";\n    }\n}\n\n'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'\n:package net.programmierecke.radiodroid2.database;\n\nimport android.content.Context;\n\nimport androidx.annotation.NonNull;\nimport androidx.room.Database;\nimport androidx.room.Room;\nimport androidx.room.RoomDatabase;\nimport androidx.room.TypeConverters;\nimport androidx.sqlite.db.SupportSQLiteDatabase;\n\nimport net.programmierecke.radiodroid2.history.TrackHistoryDao;\nimport net.programmierecke.radiodroid2.history.TrackHistoryEntry;\n\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\n\nimport static net.programmierecke.radiodroid2.history.TrackHistoryEntry.MAX_UNKNOWN_TRACK_DURATION;\n\n@Database(entities = {TrackHistoryEntry.class}, version = 1)\n@TypeConverters({Converters.class})\npublic abstract class RadioDroidDatabase extends RoomDatabase {\n    public abstract TrackHistoryDao songHistoryDao();\n\n    private static volatile RadioDroidDatabase INSTANCE;\n\n    private Executor queryExecutor = Executors.newSingleThreadExecutor(runnable -> new Thread(runnable, \"RadioDroidDatabase Executor\"));\n\n    public static RadioDroidDatabase getDatabase(final Context context) {\n        if (INSTANCE == null) {\n            synchronized (RadioDroidDatabase.class) {\n                if (INSTANCE == null) {\n                    INSTANCE = Room.databaseBuilder(context.getApplicationContext(),\n                            RadioDroidDatabase.class, \"radio_droid_database\")\n                            .addCallback(CALLBACK)\n                            .fallbackToDestructiveMigration()\n                            .build();\n                }\n            }\n        }\n        return INSTANCE;\n    }\n\n    public Executor getQueryExecutor() {\n        return queryExecutor;\n    }\n\n    private static RoomDatabase.Callback CALLBACK = new RoomDatabase.Callback() {\n        @Override\n        public void onCreate(@NonNull SupportSQLiteDatabase db) {\n            super.onCreate(db);\n        }\n\n        @Override\n        public void onOpen(@NonNull SupportSQLiteDatabase db) {\n            super.onOpen(db);\n\n            INSTANCE.queryExecutor.execute(() -> {\n\n\n                INSTANCE.songHistoryDao().setLastHistoryItemEndTimeRelative(MAX_UNKNOWN_TRACK_DURATION);\n            });\n        }\n    };\n\n}\n\n'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'\n:package net.programmierecke.radiodroid2.tests;\n\nimport static androidx.test.espresso.Espresso.onView;\nimport static androidx.test.espresso.assertion.ViewAssertions.matches;\nimport static androidx.test.espresso.matcher.ViewMatchers.hasDescendant;\nimport static androidx.test.espresso.matcher.ViewMatchers.isDisplayed;\nimport static androidx.test.espresso.matcher.ViewMatchers.withId;\nimport static androidx.test.espresso.matcher.ViewMatchers.withText;\nimport static net.programmierecke.radiodroid2.tests.utils.RecyclerDragAndDropAction.recyclerDragAndDrop;\nimport static net.programmierecke.radiodroid2.tests.utils.RecyclerRecyclingMatcher.recyclerRecycles;\nimport static net.programmierecke.radiodroid2.tests.utils.RecyclerViewMatcher.withRecyclerView;\nimport static net.programmierecke.radiodroid2.tests.utils.ScrollToRecyclerItemAction.scrollToRecyclerItem;\nimport static net.programmierecke.radiodroid2.tests.utils.TestUtils.getFakeRadioStationName;\nimport static net.programmierecke.radiodroid2.tests.utils.conditionwatcher.ViewMatchWaiter.waitForView;\nimport static org.hamcrest.Matchers.allOf;\nimport static org.junit.Assert.assertEquals;\n\nimport android.content.pm.ActivityInfo;\nimport android.os.Build;\nimport android.os.SystemClock;\n\nimport androidx.test.core.app.ApplicationProvider;\nimport androidx.test.espresso.action.ViewActions;\nimport androidx.test.espresso.matcher.ViewMatchers;\nimport androidx.test.filters.LargeTest;\nimport androidx.test.filters.SdkSuppress;\nimport androidx.test.rule.ActivityTestRule;\n\nimport net.programmierecke.radiodroid2.ActivityMain;\nimport net.programmierecke.radiodroid2.HistoryManager;\nimport net.programmierecke.radiodroid2.R;\nimport net.programmierecke.radiodroid2.RadioDroidApp;\nimport net.programmierecke.radiodroid2.tests.utils.FirstViewMatcher;\nimport net.programmierecke.radiodroid2.tests.utils.TestUtils;\n\nimport org.junit.Before;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\n\nimport java.util.Arrays;\n\n@LargeTest\n@RunWith(Parameterized.class)\npublic class UIHistoryFragmentTest {\n\n    @Parameterized.Parameter(value = 0)\n    public int orientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;\n\n    @Parameterized.Parameters(name = \"orientation={0}\")\n    public static Iterable<Object[]> initParameters() {\n        return Arrays.asList(new Object[][]{\n                {ActivityInfo.SCREEN_ORIENTATION_PORTRAIT},\n                {ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE}\n        });\n    }\n\n    @Rule\n    public ActivityTestRule<ActivityMain> activityRule\n            = new ActivityTestRule<ActivityMain>(ActivityMain.class) {\n        @Override\n        protected void afterActivityLaunched() {\n            getActivity().setRequestedOrientation(orientation);\n            super.afterActivityLaunched();\n        }\n    };\n\n    private static final int STATIONS_COUNT = 20;\n\n    private HistoryManager historyManager;\n\n    @Before\n    public void setUp() {\n        TestUtils.populateHistory(ApplicationProvider.getApplicationContext(), STATIONS_COUNT);\n\n        RadioDroidApp app = ApplicationProvider.getApplicationContext();\n        historyManager = app.getHistoryManager();\n    }\n\n    @Test\n    public void stationsRecyclerHistory_ShouldRecycleItems() {\n        onView(ViewMatchers.withId(R.id.nav_item_starred)).perform(ViewActions.click());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).check(matches(recyclerRecycles()));\n    }\n\n    @Ignore\n    @Test\n    public void stationsInHistory_ShouldNotBeReordered_WithDragAndDrop() {\n        onView(ViewMatchers.withId(R.id.nav_item_history)).perform(ViewActions.click());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).perform(scrollToRecyclerItem(0));\n        onView(withId(R.id.recyclerViewStations)).perform(recyclerDragAndDrop(1, 0));\n\n        for (int i = 0; i < 5; i++) {\n            onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).perform(scrollToRecyclerItem(i));\n            onView(withRecyclerView(R.id.recyclerViewStations).atPosition(i))\n                    .check(matches(hasDescendant(withText(getFakeRadioStationName(STATIONS_COUNT - i - 1)))));\n            assertEquals(historyManager.getList().get(i).Name, getFakeRadioStationName(STATIONS_COUNT - i - 1));\n        }\n    }\n\n    @SdkSuppress(maxSdkVersion = 32)\n    @Test\n    public void stationInHistory_ShouldBeDeleted_WithSwipeRight() {\n        onView(withId(R.id.nav_item_history)).perform(ViewActions.click());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).perform(scrollToRecyclerItem(0));\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(0)).perform(ViewActions.swipeRight());\n        waitForView(withId(com.google.android.material.R.id.snackbar_action));\n        SystemClock.sleep(1000);\n        assertEquals(STATIONS_COUNT - 1, historyManager.getList().size());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).perform(scrollToRecyclerItem(1));\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(1)).perform(ViewActions.swipeRight());\n        waitForView(withId(com.google.android.material.R.id.snackbar_action));\n        SystemClock.sleep(1000);\n        assertEquals(STATIONS_COUNT - 2, historyManager.getList().size());\n\n        onView(allOf((withId(R.id.recyclerViewStations)), FirstViewMatcher.firstView())).perform(scrollToRecyclerItem(2));\n        onView(withRecyclerView(R.id.recyclerViewStations).atPosition(2)).perform(ViewActions.swipeRight());\n        waitForView(withId(com.google.android.material.R.id.snackbar_action));\n        SystemClock.sleep(1000);\n        assertEquals(STATIONS_COUNT - 3, historyManager.getList().size());\n\n\n        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {\n\n            onView(withId(com.google.android.material.R.id.snackbar_action)).perform(ViewActions.click());\n\n            assertEquals(STATIONS_COUNT - 2, historyManager.getList().size());\n            onView(withId(R.id.recyclerViewStations)).perform(scrollToRecyclerItem(2));\n            onView(withRecyclerView(R.id.recyclerViewStations).atPosition(2))\n                    .check(matches(hasDescendant(withText(getFakeRadioStationName(STATIONS_COUNT - 5)))));\n        }\n    }\n}\n",
        "gt": [
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/history/TrackHistoryEntry.java'",
            "'RadioDroid/app/src/main/java/net/programmierecke/radiodroid2/database/RadioDroidDatabase.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/utils/RecyclerDragAndDropAction.java'",
            "'RadioDroid/app/src/androidTest/java/net/programmierecke/radiodroid2/tests/UIHistoryFragmentTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestAvroScan.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.base.Objects;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.types.Types.IntegerType;\nimport com.netflix.iceberg.types.Types.LongType;\nimport com.netflix.iceberg.types.Types.StructType;\nimport org.apache.avro.generic.IndexedRecord;\nimport org.apache.avro.specific.SpecificData;\n\nimport java.util.Collection;\n\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\nclass ManifestEntry implements IndexedRecord, SpecificData.SchemaConstructable{\n  enum Status {\n    EXISTING(0),\n    ADDED(1),\n    DELETED(2);\n\n    public static Status[] values = new Status[3];\n    static {\n      for (Status status : Status.values()) {\n        values[status.id] = status;\n      }\n    }\n\n    private final int id;\n\n    Status(int id) {\n      this.id = id;\n    }\n\n    public int id() {\n      return id;\n    }\n\n    public static Status fromId(int id) {\n      return values[id];\n    }\n  }\n\n  private final org.apache.avro.Schema schema;\n  private Status status = Status.EXISTING;\n  private long snapshotId = 0L;\n  private DataFile file = null;\n\n  public ManifestEntry(org.apache.avro.Schema schema) {\n    this.schema = schema;\n  }\n\n  ManifestEntry(StructType partitionType) {\n    this.schema = AvroSchemaUtil.convert(getSchema(partitionType), \"manifest_entry\");\n  }\n\n  private ManifestEntry(ManifestEntry toCopy) {\n    this.schema = toCopy.schema;\n    this.status = toCopy.status;\n    this.snapshotId = toCopy.snapshotId;\n    this.file = toCopy.file().copy();\n  }\n\n  ManifestEntry wrapExisting(long snapshotId, DataFile file) {\n    this.status = Status.EXISTING;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapAppend(long snapshotId, DataFile file) {\n    this.status = Status.ADDED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapDelete(long snapshotId, DataFile file) {\n    this.status = Status.DELETED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n\n  public Status status() {\n    return status;\n  }\n\n\n  public long snapshotId() {\n    return snapshotId;\n  }\n\n\n  public DataFile file() {\n    return file;\n  }\n\n  public ManifestEntry copy() {\n    return new ManifestEntry(this);\n  }\n\n  @Override\n  public void put(int i, Object v) {\n    switch (i) {\n      case 0:\n        this.status = Status.fromId((Integer) v);\n        return;\n      case 1:\n        this.snapshotId = (Long) v;\n        return;\n      case 2:\n        this.file = (DataFile) v;\n        return;\n      default:\n\n    }\n  }\n\n  @Override\n  public Object get(int i) {\n    switch (i) {\n      case 0:\n        return status.id();\n      case 1:\n        return snapshotId;\n      case 2:\n        return file;\n      default:\n        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n    }\n  }\n\n  @Override\n  public org.apache.avro.Schema getSchema() {\n    return schema;\n  }\n\n  static Schema projectSchema(StructType partitionType, Collection<String> columns) {\n    return wrapFileSchema(\n        new Schema(DataFile.getType(partitionType).fields()).select(columns).asStruct());\n  }\n\n  static Schema getSchema(StructType partitionType) {\n    return wrapFileSchema(DataFile.getType(partitionType));\n  }\n\n  private static Schema wrapFileSchema(StructType fileStruct) {\n\n    return new Schema(\n        required(0, \"status\", IntegerType.get()),\n        required(1, \"snapshot_id\", LongType.get()),\n        required(2, \"data_file\", fileStruct));\n  }\n\n  @Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n        .add(\"status\", status)\n        .add(\"snapshot_id\", snapshotId)\n        .add(\"file\", file)\n        .toString();\n  }\n}\n\n'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestAvroScan.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.netflix.iceberg.DataFile;\nimport com.netflix.iceberg.DataFiles;\nimport com.netflix.iceberg.FileFormat;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.Table;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.hadoop.HadoopTables;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.spark.data.AvroDataTest;\nimport com.netflix.iceberg.spark.data.RandomData;\nimport com.netflix.iceberg.spark.data.TestHelpers;\nimport org.apache.avro.generic.GenericData.Record;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.SparkSession;\nimport org.junit.AfterClass;\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.UUID;\n\nimport static com.netflix.iceberg.Files.localOutput;\n\npublic class TestAvroScan extends AvroDataTest {\n  private static final Configuration CONF = new Configuration();\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();\n\n  private static SparkSession spark = null;\n\n  @BeforeClass\n  public static void startSpark() {\n    TestAvroScan.spark = SparkSession.builder().master(\"local[2]\").getOrCreate();\n  }\n\n  @AfterClass\n  public static void stopSpark() {\n    SparkSession spark = TestAvroScan.spark;\n    TestAvroScan.spark = null;\n    spark.stop();\n  }\n\n  protected void writeAndValidate(Schema schema) throws IOException {\n    File parent = temp.newFolder(\"avro\");\n    File location = new File(parent, \"test\");\n    File dataFolder = new File(location, \"data\");\n    dataFolder.mkdirs();\n\n    File avroFile = new File(dataFolder,\n        FileFormat.AVRO.addExtension(UUID.randomUUID().toString()));\n\n    HadoopTables tables = new HadoopTables(CONF);\n    Table table = tables.create(schema, PartitionSpec.unpartitioned(), location.toString());\n\n\n\n    Schema tableSchema = table.schema();\n\n    List<Record> expected = RandomData.generateList(tableSchema, 100, 1L);\n\n    try (FileAppender<Record> writer = Avro.write(localOutput(avroFile))\n        .schema(tableSchema)\n        .build()) {\n      writer.addAll(expected);\n    }\n\n    DataFile file = DataFiles.builder(PartitionSpec.unpartitioned())\n        .withRecordCount(100)\n        .withFileSizeInBytes(avroFile.length())\n        .withPath(avroFile.toString())\n        .build();\n\n    table.newAppend().appendFile(file).commit();\n\n    Dataset<Row> df = spark.read()\n        .format(\"iceberg\")\n        .load(location.toString());\n\n    List<Row> rows = df.collectAsList();\n    Assert.assertEquals(\"Should contain 100 rows\", 100, rows.size());\n\n    for (int i = 0; i < expected.size(); i += 1) {\n      TestHelpers.assertEqualsSafe(tableSchema.asStruct(), expected.get(i), rows.get(i));\n    }\n  }\n}\n\n'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.netflix.iceberg.exceptions.CommitFailedException;\nimport com.netflix.iceberg.exceptions.ValidationException;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.mockito.internal.util.collections.Sets;\n\nimport java.io.File;\nimport java.util.Collections;\n\nimport static com.netflix.iceberg.ManifestEntry.Status.ADDED;\nimport static com.netflix.iceberg.ManifestEntry.Status.DELETED;\nimport static com.netflix.iceberg.ManifestEntry.Status.EXISTING;\n\npublic class TestReplaceFiles extends TableTestBase {\n\n  @Test\n  public void testEmptyTable() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    TableMetadata base = readMetadata();\n    Assert.assertNull(\"Should not have a current snapshot\", base.currentSnapshot());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-a.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B))\n            .commit());\n  }\n\n  @Test\n  public void testAddOnly() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        IllegalArgumentException.class,\n        \"Files to add can not be null or empty\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Collections.emptySet())\n            .apply());\n  }\n\n  @Test\n  public void testDeleteOnly() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        IllegalArgumentException.class,\n        \"Files to delete cannot be null or empty\",\n        () -> table.newRewrite()\n            .rewriteFiles(Collections.emptySet(), Sets.newSet(FILE_A))\n            .apply());\n  }\n\n  @Test\n  public void testDeleteWithDuplicateEntriesInManifest() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    long baseSnapshotId = base.currentSnapshot().snapshotId();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    Snapshot pending = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_C))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n    Assert.assertFalse(\"Should not contain manifest from initial write\",\n        pending.manifests().contains(initialManifest));\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_C),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId,pendingId, baseSnapshotId),\n        files(FILE_A, FILE_A, FILE_B),\n        statuses(DELETED, DELETED, EXISTING));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testAddAndDelete() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    long baseSnapshotId = base.currentSnapshot().snapshotId();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    Snapshot pending = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_C))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n    Assert.assertFalse(\"Should not contain manifest from initial write\",\n        pending.manifests().contains(initialManifest));\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_C),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId, baseSnapshotId),\n        files(FILE_A, FILE_B),\n        statuses(DELETED, EXISTING));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testFailure() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.ops().failCommits(5);\n\n    RewriteFiles rewrite = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B));\n    Snapshot pending = rewrite.apply();\n\n    Assert.assertEquals(\"Should produce 2 manifests\", 2, pending.manifests().size());\n    ManifestFile manifest1 = pending.manifests().get(0);\n    ManifestFile manifest2 = pending.manifests().get(1);\n\n    validateManifestEntries(manifest1,\n        ids(pending.snapshotId()), files(FILE_B), statuses(ADDED));\n    validateManifestEntries(manifest2,\n        ids(pending.snapshotId()), files(FILE_A), statuses(DELETED));\n\n    AssertHelpers.assertThrows(\"Should retry 4 times and throw last failure\",\n        CommitFailedException.class, \"Injected failure\", rewrite::commit);\n\n    Assert.assertFalse(\"Should clean up new manifest\", new File(manifest1.path()).exists());\n    Assert.assertFalse(\"Should clean up new manifest\", new File(manifest2.path()).exists());\n\n\n    Assert.assertEquals(\"Only 1 manifest should exist\", 1, listManifestFiles().size());\n  }\n\n  @Test\n  public void testRecovery() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.ops().failCommits(3);\n\n    RewriteFiles rewrite = table.newRewrite().rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B));\n    Snapshot pending = rewrite.apply();\n\n    Assert.assertEquals(\"Should produce 2 manifests\", 2, pending.manifests().size());\n    ManifestFile manifest1 = pending.manifests().get(0);\n    ManifestFile manifest2 = pending.manifests().get(1);\n\n    validateManifestEntries(manifest1,\n        ids(pending.snapshotId()), files(FILE_B), statuses(ADDED));\n    validateManifestEntries(manifest2,\n        ids(pending.snapshotId()), files(FILE_A), statuses(DELETED));\n\n    rewrite.commit();\n\n    Assert.assertTrue(\"Should reuse the manifest for appends\", new File(manifest1.path()).exists());\n    Assert.assertTrue(\"Should reuse the manifest with deletes\", new File(manifest2.path()).exists());\n\n    TableMetadata metadata = readMetadata();\n    Assert.assertTrue(\"Should commit the manifest for append\",\n        metadata.currentSnapshot().manifests().contains(manifest2));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testDeleteNonExistentFile() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-c.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_C), Sets.newSet(FILE_D))\n            .commit());\n\n    Assert.assertEquals(\"Only 1 manifests should exist\", 1, listManifestFiles().size());\n  }\n\n  @Test\n  public void testAlreadyDeletedFile() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n\n    RewriteFiles rewrite = table.newRewrite();\n    Snapshot pending = rewrite\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_B),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId, base.currentSnapshot().snapshotId()),\n        files(FILE_A),\n        statuses(DELETED));\n\n    rewrite.commit();\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-a.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_D))\n            .commit());\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestAvroScan.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.NonNull;\nimport android.support.graphics.drawable.AnimatedVectorDrawableCompat;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.ImageButton;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\nimport com.philliphsu.bottomsheetpickers.date.MonthPickerView.OnMonthClickListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\n\n\nclass PagingDayPickerView extends LinearLayout implements OnDateChangedListener, OnPageChangeListener, OnMonthClickListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n    static final int DAY_PICKER_INDEX = 0;\n    static final int MONTH_PICKER_INDEX = 1;\n\n    static int MONTH_NAVIGATION_BAR_SIZE;\n\n    private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected PagingMonthAdapter mAdapter;\n\n    private DayPickerViewAnimator mMonthAnimator;\n    private ViewPager mViewPager;\n    private MonthPickerView mMonthPickerView;\n    private TextView mMonthYearTitleView;\n    private ImageButton mPreviousButton;\n    private ImageButton mNextButton;\n    private View mTitleContainer;\n\n\n    private AnimatedVectorDrawableCompat mArrowDownDrawable;\n\n    private AnimatedVectorDrawableCompat mArrowUpDrawable;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mCurrentMonthDisplayed;\n\n    private int mCurrentView = DAY_PICKER_INDEX;\n\n    private int mCurrentYearDisplayed;\n\n    private DatePickerController mController;\n\n    private boolean mThemeDark;\n    private int mAccentColor;\n\n    public PagingDayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        this(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark,\n                               int accentColor) {\n        super(context);\n\n        mThemeDark = themeDark;\n        mAccentColor = accentColor;\n        init(context);\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n        mMonthPickerView.setDatePickerController(mController);\n    }\n\n    private void init(Context context) {\n        mHandler = new Handler();\n        setOrientation(VERTICAL);\n        setLayoutParams(new LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        Resources res = getResources();\n        MONTH_NAVIGATION_BAR_SIZE = res.getDimensionPixelOffset(R.dimen.bsp_month_navigation_bar_height)\n                + res.getDimensionPixelOffset(R.dimen.bsp_month_view_top_padding);\n\n        final View view = LayoutInflater.from(context).inflate(R.layout.bsp_day_picker_content, this, true);\n        mMonthAnimator = (DayPickerViewAnimator) findViewById(R.id.bsp_month_animator);\n        mMonthPickerView = (MonthPickerView) findViewById(R.id.bsp_month_picker);\n        mMonthPickerView.setOnMonthClickListener(this);\n        mViewPager = (ViewPager) findViewById(R.id.bsp_viewpager);\n        mViewPager.addOnPageChangeListener(this);\n        mMonthYearTitleView = (TextView) view.findViewById(R.id.bsp_month_year_title);\n        mTitleContainer = view.findViewById(R.id.bsp_month_year_title_container);\n        mTitleContainer.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int newIndex = mCurrentView == DAY_PICKER_INDEX ? MONTH_PICKER_INDEX : DAY_PICKER_INDEX;\n                setupCurrentView(newIndex, true);\n            }\n        });\n        mPreviousButton = (ImageButton) view.findViewById(R.id.bsp_prev);\n        mPreviousButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int previousItem = mViewPager.getCurrentItem() - 1;\n                if (previousItem >= 0) {\n                    mViewPager.setCurrentItem(previousItem, true);\n                }\n            }\n        });\n        mNextButton = (ImageButton) view.findViewById(R.id.bsp_next);\n        mNextButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int nextItem = mViewPager.getCurrentItem() + 1;\n                if (nextItem < mAdapter.getCount()) {\n                    mViewPager.setCurrentItem(nextItem, true);\n                }\n            }\n        });\n\n        mArrowDownDrawable = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_down);\n        mArrowUpDrawable   = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_up);\n        setArrowDrawableOnTitle(mArrowDownDrawable);\n\n\n        if (mThemeDark) {\n            int selectableItemBg = getColor(context, R.color.bsp_selectable_item_background_dark);\n            Utils.setColorControlHighlight(mPreviousButton, selectableItemBg);\n            Utils.setColorControlHighlight(mNextButton, selectableItemBg);\n            Utils.setColorControlHighlight(mTitleContainer, selectableItemBg);\n            int cursor = getColor(context, R.color.bsp_text_color_secondary_dark);\n            Utils.applyTint(mPreviousButton, cursor);\n            Utils.applyTint(mNextButton, cursor);\n        }\n\n\n        int monthYearTitleColor = getColor(context, mThemeDark?\n                R.color.bsp_text_color_primary_dark : R.color.bsp_text_color_primary_light);\n        int dropdownArrowColor = getColor(context, mThemeDark?\n                R.color.bsp_icon_color_active_dark : R.color.bsp_icon_color_active_light);\n\n        mMonthYearTitleView.setTextColor(monthYearTitleColor);\n        mArrowDownDrawable.setTint(dropdownArrowColor);\n        mArrowUpDrawable.setTint(dropdownArrowColor);\n\n        mMonthPickerView.setTheme(context, mThemeDark);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mViewPager.removeOnPageChangeListener(this);\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    void setAccentColor(@ColorInt int color) {\n        mAccentColor = color;\n        mMonthPickerView.setCurrentMonthTextColor(color);\n        mMonthPickerView.setSelectedCirclePaintColor(color);\n    }\n\n    public void onChange() {\n        refreshAdapter();\n        refreshMonthPicker();\n    }\n\n\n    void setupCurrentView(int currentView, boolean animate) {\n        if (currentView == DAY_PICKER_INDEX || currentView == MONTH_PICKER_INDEX) {\n            boolean isDayPicker = currentView == DAY_PICKER_INDEX;\n            setCurrentView(currentView, animate);\n            if (isDayPicker) {\n                setTitle(mAdapter.getPageTitle(mViewPager.getCurrentItem()));\n                toggleArrowsVisibility(getPagerPosition());\n            } else {\n\n\n\n                setTitle(String.valueOf(mCurrentYearDisplayed));\n                toggleArrowsVisibility(false, false);\n            }\n        } else {\n            Log.e(TAG, \"Error restoring current view\");\n        }\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            if (mAccentColor != 0) {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark, mAccentColor);\n            } else {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n            }\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        mViewPager.setAdapter(mAdapter);\n    }\n\n\n    private void refreshMonthPicker() {\n        prepareMonthPickerForDisplay(mSelectedDay.year);\n        mMonthPickerView.invalidate();\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller) {\n        return new PagingMonthAdapter(context, controller);\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark) {\n        return createMonthAdapter(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark,\n                                                 int accentColor) {\n        return new PagingMonthAdapter(context, controller, themeDark, accentColor);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n        final int selectedPosition = getPosition(mSelectedDay);\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = getPosition(day);\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthAndYearDisplayed(mTempDay);\n            if (animate) {\n                mViewPager.setCurrentItem(position, true);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n                return true;\n            } else {\n                postSetSelection(position, setSelected);\n            }\n        } else if (setSelected) {\n            setMonthAndYearDisplayed(mSelectedDay);\n            setSelectedDay(mSelectedDay);\n        }\n        return false;\n    }\n\n\n    private int getPosition(CalendarDay day) {\n        return mAdapter.getPosition(day);\n    }\n\n    public void postSetSelection(final int position, final boolean setSelected) {\n        clearFocus();\n        post(new Runnable() {\n            @Override\n            public void run() {\n                mViewPager.setCurrentItem(position, false);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n            }\n        });\n    }\n\n    void postSetupCurrentView(final int currentView, final boolean animate) {\n        post(new Runnable() {\n            @Override\n            public void run() {\n                setupCurrentView(currentView, animate);\n            }\n        });\n    }\n\n\n    protected void setMonthAndYearDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        mCurrentYearDisplayed = date.year;\n    }\n\n    private void setSelectedDay(CalendarDay day) {\n        mAdapter.setSelectedDay(day);\n    }\n\n    @Override\n    public void onDateChanged() {\n        if (mCurrentView != DAY_PICKER_INDEX) {\n            setCurrentView(DAY_PICKER_INDEX, false);\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getPagerPosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        return true;\n    }\n\n    int getPagerPosition() {\n        return mViewPager.getCurrentItem();\n    }\n\n    int getCurrentView() {\n        return mCurrentView;\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mCurrentView == DAY_PICKER_INDEX) {\n            setTitle(mAdapter.getPageTitle(position));\n            toggleArrowsVisibility(position);\n            final int month = mAdapter.getMonth(position);\n            final int year = mAdapter.getYear(position);\n            if (mCurrentYearDisplayed != year) {\n                mCurrentYearDisplayed = year;\n            }\n            if (mCurrentMonthDisplayed != month) {\n                mCurrentMonthDisplayed = month;\n            }\n        }\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n\n    private void setTitle(CharSequence title) {\n        mMonthYearTitleView.setText(title);\n    }\n\n\n    private void toggleArrowsVisibility(int position) {\n        toggleArrowsVisibility(position > 0, position + 1 < mAdapter.getCount());\n    }\n\n    private void toggleArrowsVisibility(boolean leftVisible, boolean rightVisible) {\n        mPreviousButton.setVisibility(leftVisible ? VISIBLE : INVISIBLE);\n        mNextButton.setVisibility(rightVisible ? VISIBLE : INVISIBLE);\n    }\n\n    private void setArrowDrawableOnTitle(@NonNull Drawable arrow) {\n        if (Utils.checkApiLevel(17)) {\n            mMonthYearTitleView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, arrow, null);\n        } else {\n            mMonthYearTitleView.setCompoundDrawablesWithIntrinsicBounds(null, null, arrow, null);\n        }\n    }\n\n    private void animateArrow(AnimatedVectorDrawableCompat arrow) {\n        setArrowDrawableOnTitle(arrow);\n        arrow.start();\n    }\n\n    private void setCurrentView(final int viewIndex, boolean animate) {\n        switch (viewIndex) {\n            case DAY_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    mMonthAnimator.setDisplayedChild(DAY_PICKER_INDEX, animate);\n                    animateArrow(mArrowUpDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n            case MONTH_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    prepareMonthPickerForDisplay(mCurrentYearDisplayed);\n                    mMonthAnimator.setDisplayedChild(MONTH_PICKER_INDEX, animate);\n                    animateArrow(mArrowDownDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n        }\n    }\n\n    private void prepareMonthPickerForDisplay(int currentYear) {\n        mMonthPickerView.setDisplayParams(mSelectedDay, currentYear);\n    }\n\n    @Override\n    public void onMonthClick(MonthPickerView view, int month, int year) {\n\n\n\n\n\n        setCurrentView(DAY_PICKER_INDEX, true);\n\n\n\n\n\n\n\n\n\n\n        if (month == mCurrentMonthDisplayed) {\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        mController.tryVibrate();\n        mController.onMonthYearSelected(month, year);\n    }\n}\n\n'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\n\nimport java.util.Calendar;\n\n\npublic interface DatePickerController {\n\n    void onYearSelected(int year);\n\n    void onDayOfMonthSelected(int year, int month, int day);\n\n    void onMonthYearSelected(int month, int year);\n\n    void registerOnDateChangedListener(OnDateChangedListener listener);\n\n    void unregisterOnDateChangedListener(OnDateChangedListener listener);\n\n    CalendarDay getSelectedDay();\n\n    int getFirstDayOfWeek();\n\n    int getMinYear();\n\n    int getMaxYear();\n\n    Calendar getMinDate();\n\n    Calendar getMaxDate();\n\n    void tryVibrate();\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ]
    },
    {
        "files": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'"
        ],
        "content": "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'\n:package io.advantageous.qbit.service.discovery;\n\nimport io.advantageous.qbit.reactive.Callback;\nimport io.advantageous.qbit.service.Startable;\nimport io.advantageous.qbit.service.Stoppable;\nimport io.advantageous.qbit.service.health.HealthStatus;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.*;\n\n\npublic interface ServiceDiscovery extends Startable, Stoppable {\n\n\n    static String uniqueString(int port) {\n        try {\n            return port + \"-\" + InetAddress.getLocalHost().getHostName().replace('.', '-');\n        } catch (UnknownHostException e) {\n            return port + \"-\" + UUID.randomUUID().toString();\n        }\n    }\n\n\n    default EndpointDefinition register(\n            final String serviceName,\n            final String host,\n            final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceName + \".\" + uniqueString(port),\n                serviceName, host, port);\n    }\n\n\n    default EndpointDefinition registerWithTTL(\n            final String serviceName,\n            final String host,\n            final int port,\n            final int timeToLiveSeconds) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceName + \".\" + uniqueString(port),\n                serviceName, host, port, timeToLiveSeconds);\n    }\n\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default EndpointDefinition registerWithIdAndTimeToLive(\n            final String serviceName, final String serviceId, String host, final int port, final int timeToLiveSeconds) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceId,\n                serviceName, host, port, timeToLiveSeconds);\n    }\n\n\n    default EndpointDefinition registerWithId(final String serviceName, final String serviceId, String host, final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                serviceId,\n                serviceName, host, port);\n    }\n\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    default EndpointDefinition registerWithIdAndTTLAndTags(String serviceName, String serviceId, String host, int port, int timeToLiveSeconds,\n                                                           List<String> endpointTags) {\n        return new EndpointDefinition(HealthStatus.PASS, serviceId, serviceName, host, port, timeToLiveSeconds, endpointTags);\n    }\n\n\n    default void watch(String serviceName) {\n    }\n\n\n    default void checkIn(String serviceId, HealthStatus healthStatus) {\n\n    }\n\n\n    default void checkInOk(String serviceId) {\n\n    }\n\n\n    default List<EndpointDefinition> loadServices(final String serviceName) {\n\n        return Collections.emptyList();\n    }\n\n\n    default void loadServicesAsync(Callback<List<EndpointDefinition>> callback, final String serviceName) {\n\n    }\n\n\n    default List<EndpointDefinition> loadServicesNow(final String serviceName) {\n\n        return Collections.emptyList();\n    }\n\n\n    default void start() {\n    }\n\n\n    default void stop() {\n    }\n\n\n    default Set<EndpointDefinition> localDefinitions() {\n        return Collections.emptySet();\n    }\n\n}\n\n'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'\n:package io.advantageous.qbit.metrics;\n\nimport io.advantageous.boon.core.Sys;\nimport io.advantageous.qbit.metrics.support.DebugReplicator;\nimport io.advantageous.qbit.service.discovery.EndpointDefinition;\nimport io.advantageous.qbit.service.discovery.ServiceDiscovery;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.time.Clock;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static io.advantageous.boon.core.IO.puts;\nimport static io.advantageous.qbit.service.discovery.EndpointDefinition.*;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\npublic class ClusteredStatReplicatorTest {\n\n    private final String localServiceId = \"fooBar-\" + Clock.systemUTC().millis();\n    private final String serviceName = \"fooBar\";\n    private ClusteredStatReplicator clusteredStatReplicator;\n    private AtomicReference<List<EndpointDefinition>> services;\n    private ConcurrentHashMap<String, DebugReplicator> statReplicatorMap;\n\n    private TestTimer timer = new TestTimer();\n    private ServiceDiscovery serviceDiscovery = new ServiceDiscovery() {\n        @Override\n        public void watch(String serviceName) {\n\n        }\n\n        @Override\n        public List<EndpointDefinition> loadServices(String serviceName) {\n            return services.get() == null ? Collections.emptyList() : services.get();\n        }\n    };\n    private StatReplicatorProvider provider = new StatReplicatorProvider() {\n        @Override\n        public StatReplicator provide(EndpointDefinition endpointDefinition) {\n\n            puts(\"Creating \", endpointDefinition);\n            DebugReplicator debugReplicator = new DebugReplicator(true);\n            statReplicatorMap.put(endpointDefinition.getId(), debugReplicator);\n            return debugReplicator;\n        }\n    };\n\n    @Before\n    public void setup() throws Exception {\n\n        services = new AtomicReference<>();\n        statReplicatorMap = new ConcurrentHashMap<>();\n\n        timer.setTime();\n\n        clusteredStatReplicator = new ClusteredStatReplicator(serviceName, serviceDiscovery,\n                provider, localServiceId, timer, 100, 333);\n\n    }\n\n    @Test\n    public void testDiscovery() {\n\n\n        EndpointDefinition endpointDefinition1 = serviceDefinition(serviceName, \"host1\");\n        EndpointDefinition endpointDefinition2 = serviceDefinition(serviceName, \"host2\");\n        EndpointDefinition endpointDefinition3 = serviceDefinition(serviceName, \"host3\");\n\n\n        List<EndpointDefinition> fooServices = serviceDefinitions(\n                endpointDefinition1,\n                endpointDefinition2,\n                endpointDefinition3\n        );\n\n        services.set(fooServices);\n\n        clusteredStatReplicator.servicePoolChanged(serviceName);\n\n        Sys.sleep(100);\n\n        final DebugReplicator debugReplicator1 = statReplicatorMap.get(endpointDefinition1.getId());\n        final DebugReplicator debugReplicator2 = statReplicatorMap.get(endpointDefinition1.getId());\n        final DebugReplicator debugReplicator3 = statReplicatorMap.get(endpointDefinition1.getId());\n\n        assertNotNull(debugReplicator1);\n        assertNotNull(debugReplicator2);\n        assertNotNull(debugReplicator3);\n\n    }\n\n\n    @Test\n    public void testDiscoveryAndSends() {\n\n\n        EndpointDefinition endpointDefinition1 = serviceDefinition(serviceName, \"host1\");\n        EndpointDefinition endpointDefinition2 = serviceDefinition(serviceName, \"host2\");\n        EndpointDefinition endpointDefinition3 = serviceDefinition(serviceName, \"host3\");\n\n\n        List<EndpointDefinition> fooServices = serviceDefinitions(\n                endpointDefinition1,\n                endpointDefinition2,\n                endpointDefinition3\n        );\n\n        services.set(fooServices);\n\n        clusteredStatReplicator.servicePoolChanged(serviceName);\n\n        Sys.sleep(100);\n\n        final DebugReplicator debugReplicator1 = statReplicatorMap.get(endpointDefinition1.getId());\n        final DebugReplicator debugReplicator2 = statReplicatorMap.get(endpointDefinition1.getId());\n        final DebugReplicator debugReplicator3 = statReplicatorMap.get(endpointDefinition1.getId());\n\n        assertNotNull(debugReplicator1);\n        assertNotNull(debugReplicator2);\n        assertNotNull(debugReplicator3);\n\n        clusteredStatReplicator.replicateCount(\"foo\", 5, Clock.systemUTC().millis());\n\n        timer.seconds(2);\n        clusteredStatReplicator.process();\n\n        assertEquals(5, debugReplicator1.count.get());\n        assertEquals(5, debugReplicator2.count.get());\n        assertEquals(5, debugReplicator3.count.get());\n\n\n    }\n\n\n    @Test\n    public void testDiscoveryAndSendsAndRemove() {\n\n\n        EndpointDefinition endpointDefinition1 = serviceDefinitionWithId(serviceName, \"host1\",\n                UUID.randomUUID().toString());\n        EndpointDefinition endpointDefinition2 = serviceDefinitionWithId(serviceName, \"host2\",\n                UUID.randomUUID().toString());\n        EndpointDefinition endpointDefinition3 = serviceDefinitionWithId(serviceName, \"host3\",\n                UUID.randomUUID().toString());\n        EndpointDefinition localService = serviceDefinition(localServiceId, serviceName, \"host3\", 0);\n\n\n        List<EndpointDefinition> fooServices = serviceDefinitions(\n                endpointDefinition1,\n                endpointDefinition2,\n                endpointDefinition3,\n                localService\n        );\n\n        services.set(fooServices);\n\n        clusteredStatReplicator.servicePoolChanged(serviceName);\n\n        Sys.sleep(100);\n\n        final DebugReplicator debugReplicator1 = statReplicatorMap.get(endpointDefinition1.getId());\n        final DebugReplicator debugReplicator2 = statReplicatorMap.get(endpointDefinition2.getId());\n        final DebugReplicator debugReplicator3 = statReplicatorMap.get(endpointDefinition3.getId());\n\n        assertNotNull(debugReplicator1);\n        assertNotNull(debugReplicator2);\n        assertNotNull(debugReplicator3);\n\n        clusteredStatReplicator.replicateCount(\"foo\", 5, 100);\n\n\n        timer.seconds(2);\n        clusteredStatReplicator.process();\n\n        assertEquals(5, debugReplicator1.count.get());\n        assertEquals(5, debugReplicator2.count.get());\n        assertEquals(5, debugReplicator3.count.get());\n\n\n        fooServices = serviceDefinitions(\n                endpointDefinition1,\n                endpointDefinition3\n        );\n\n\n        services.set(fooServices);\n\n        clusteredStatReplicator.servicePoolChanged(serviceName);\n\n        clusteredStatReplicator.servicePoolChanged(\"foo\");\n\n\n        Sys.sleep(200);\n\n\n        clusteredStatReplicator.replicateCount(\"foo\", 5, 200);\n        Sys.sleep(100);\n\n\n        timer.seconds(2);\n        clusteredStatReplicator.process();\n\n        assertEquals(10, debugReplicator1.count.get());\n        assertEquals(5, debugReplicator2.count.get());\n        assertEquals(10, debugReplicator3.count.get());\n\n        clusteredStatReplicator.flush();\n\n\n    }\n\n\n}\n'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'\n:package io.advantageous.qbit.service.discovery;\n\nimport io.advantageous.boon.core.Lists;\nimport io.advantageous.boon.core.Sys;\nimport io.advantageous.qbit.service.health.HealthStatus;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.*;\n\nimport static io.advantageous.qbit.service.discovery.ServiceDiscovery.uniqueString;\n\n\npublic class EndpointDefinition {\n\n\n    private final HealthStatus healthStatus;\n\n\n    private final String id;\n\n\n    private final String name;\n\n\n    private final String host;\n\n\n    private final int port;\n\n\n    private final List<String> tags;\n\n\n    private final long timeToLive;\n\n\n    public EndpointDefinition(\n            final HealthStatus healthStatus,\n            final String id,\n            final String name,\n            final String host,\n            final int port,\n            final long timeToLive,\n            final List<String> tags) {\n        this.healthStatus = healthStatus;\n        this.id = id;\n        this.name = name;\n        this.host = host;\n        this.port = port;\n        this.timeToLive = timeToLive;\n        this.tags = tags;\n    }\n\n\n    public EndpointDefinition(\n            final HealthStatus healthStatus,\n            final String id,\n            final String name,\n            final String host,\n            final int port,\n            final List<String> tags) {\n        this(healthStatus, id, name, host, port, Sys.sysProp(EndpointDefinition.class.getName() + \".timeToLive\", 20L), tags);\n    }\n\n\n    public EndpointDefinition(\n            final HealthStatus healthStatus,\n            final String id,\n            final String name,\n            final String host,\n            final int port) {\n        this(healthStatus, id, name, host, port, Sys.sysProp(EndpointDefinition.class.getName() + \".timeToLive\", 20L), null);\n    }\n\n\n    public EndpointDefinition(\n            final String name,\n            final String host,\n            final int port) {\n        this(HealthStatus.PASS, name + \"-\" + port + \"-\" + host.replace('.', '-'), name, host, port);\n    }\n\n\n    public EndpointDefinition(\n            final HealthStatus healthStatus,\n            final String id,\n            final String name,\n            final String host,\n            final int port,\n            final long timeToLive) {\n        this(healthStatus, id, name, host, port, timeToLive, null);\n    }\n\n\n    static String findHostName() {\n        try {\n            return InetAddress.getLocalHost().getHostName();\n        } catch (UnknownHostException e) {\n            throw new IllegalStateException(\"unable to find host name\");\n        }\n    }\n\n\n    public static List<EndpointDefinition> serviceDefinitions(final EndpointDefinition... endpointDefinitions) {\n        return Lists.list(endpointDefinitions);\n    }\n\n\n    public static EndpointDefinition serviceDefinition(final String name) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                name + \"-\" + uniqueString(0), name, findHostName(), 0);\n    }\n\n\n    public static EndpointDefinition serviceDefinition(final String name, int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                name + \"-\" + uniqueString(port), name, findHostName(), 0);\n    }\n\n\n    public static EndpointDefinition serviceDefinition(\n            final String id,\n            final String name,\n            final String host,\n            final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                id, name, host, port);\n    }\n\n\n    public static EndpointDefinition serviceDefinition(\n            final String id,\n            final String name,\n            final String host,\n            final int port,\n            List<String> tags) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                id, name, host, port, tags);\n    }\n\n\n    public static EndpointDefinition serviceDefinition(\n            final String name,\n            final String host,\n            final int port) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                name + \"-\" + uniqueString(port), name, host, port);\n    }\n\n\n    public static EndpointDefinition serviceDefinition(\n            final String name,\n            final String host\n    ) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                name + \"-\" + uniqueString(0), name, host, 0);\n    }\n\n\n    public static EndpointDefinition serviceDefinitionWithId(\n            final String name,\n            final String host,\n            final String id) {\n\n        return new EndpointDefinition(HealthStatus.PASS,\n                id, name, host, 0);\n    }\n\n    public HealthStatus getHealthStatus() {\n        return healthStatus;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public int getPort() {\n        return port;\n    }\n\n    public List<String> getTags() {\n        return tags;\n    }\n\n    @SuppressWarnings(\"SimplifiableIfStatement\")\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof EndpointDefinition)) return false;\n\n        EndpointDefinition that = (EndpointDefinition) o;\n\n        if (port != that.port) return false;\n        if (healthStatus != that.healthStatus) return false;\n        if (host != null ? !host.equals(that.host) : that.host != null) return false;\n        if (id != null ? !id.equals(that.id) : that.id != null) return false;\n        return !(name != null ? !name.equals(that.name) : that.name != null);\n\n    }\n\n    @Override\n    public int hashCode() {\n        int result = healthStatus != null ? healthStatus.hashCode() : 0;\n        result = 31 * result + (id != null ? id.hashCode() : 0);\n        result = 31 * result + (name != null ? name.hashCode() : 0);\n        result = 31 * result + (host != null ? host.hashCode() : 0);\n        result = 31 * result + port;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"ServiceDefinition{\" +\n                \"status=\" + healthStatus +\n                \", id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", host='\" + host + '\\'' +\n                \", port=\" + port +\n                \", tags=\" + tags +\n                '}';\n    }\n\n    public long getTimeToLive() {\n        return timeToLive;\n    }\n\n}\n",
        "gt": [
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/ServiceDiscovery.java'",
            "'qbit/qbit/core/src/main/java/io/advantageous/qbit/service/discovery/EndpointDefinition.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/ClusteredStatReplicatorTest.java'"
        ]
    },
    {
        "files": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetSchemaUtil.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'"
        ],
        "content": "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.parquet;\n\nimport com.google.common.collect.Sets;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.parquet.schema.MessageType;\nimport org.apache.parquet.schema.Type;\nimport org.apache.parquet.schema.Types.MessageTypeBuilder;\nimport java.util.Set;\n\npublic class ParquetSchemaUtil {\n  public static MessageType convert(Schema schema, String name) {\n    return new TypeToMessageType().convert(schema, name);\n  }\n\n  public static Schema convert(MessageType parquetSchema) {\n    MessageTypeToType converter = new MessageTypeToType(parquetSchema);\n    return new Schema(\n        ParquetTypeVisitor.visit(parquetSchema, converter).asNestedType().fields(),\n        converter.getAliases());\n  }\n\n  public static MessageType pruneColumns(MessageType fileSchema, Schema expectedSchema) {\n\n    Set<Integer> selectedIds = TypeUtil.getProjectedIds(expectedSchema);\n    return (MessageType) ParquetTypeVisitor.visit(fileSchema, new PruneColumns(selectedIds));\n  }\n\n\n  public static MessageType pruneColumnsFallback(MessageType fileSchema, Schema expectedSchema) {\n    Set<Integer> selectedIds = Sets.newHashSet();\n\n    for (Types.NestedField field : expectedSchema.columns()) {\n      selectedIds.add(field.fieldId());\n    }\n\n    MessageTypeBuilder builder = org.apache.parquet.schema.Types.buildMessage();\n\n    int ordinal = 1;\n    for (Type type : fileSchema.getFields()) {\n      if (selectedIds.contains(ordinal)) {\n        builder.addField(type.withId(ordinal));\n      }\n      ordinal += 1;\n    }\n\n    return builder.named(fileSchema.getName());\n  }\n\n  public static boolean hasIds(MessageType fileSchema) {\n    try {\n\n      ParquetTypeVisitor.visit(fileSchema, new MessageTypeToType(fileSchema) {\n        @Override\n        protected int nextId() {\n          throw new IllegalStateException(\"Needed to assign ID\");\n        }\n      });\n\n\n      return true;\n\n    } catch (IllegalStateException e) {\n\n      return false;\n    }\n  }\n\n  public static MessageType addFallbackIds(MessageType fileSchema) {\n    MessageTypeBuilder builder = org.apache.parquet.schema.Types.buildMessage();\n\n    int ordinal = 1;\n    for (Type type : fileSchema.getFields()) {\n      builder.addField(type.withId(ordinal));\n      ordinal += 1;\n    }\n\n    return builder.named(fileSchema.getName());\n  }\n}\n\n'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'\n:\n\npackage com.netflix.iceberg.data;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.CombinedScanTask;\nimport com.netflix.iceberg.FileScanTask;\nimport com.netflix.iceberg.HasTableOperations;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.TableOperations;\nimport com.netflix.iceberg.TableScan;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.data.avro.DataReader;\nimport com.netflix.iceberg.exceptions.RuntimeIOException;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Evaluator;\nimport com.netflix.iceberg.expressions.Expressions;\nimport com.netflix.iceberg.io.CloseableGroup;\nimport com.netflix.iceberg.io.CloseableIterable;\nimport com.netflix.iceberg.io.InputFile;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.types.TypeUtil;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Iterables.filter;\nimport static com.google.common.collect.Iterables.transform;\nimport static com.netflix.iceberg.data.parquet.GenericParquetReaders.buildReader;\nimport static java.util.Collections.emptyIterator;\n\nclass TableScanIterable extends CloseableGroup implements CloseableIterable<Record> {\n  private final TableOperations ops;\n  private final Schema projection;\n  private final boolean reuseContainers;\n  private final CloseableIterable<CombinedScanTask> tasks;\n\n  TableScanIterable(TableScan scan, boolean reuseContainers) {\n    Preconditions.checkArgument(scan.table() instanceof HasTableOperations,\n        \"Cannot scan table that doesn't expose its TableOperations\");\n    this.ops = ((HasTableOperations) scan.table()).operations();\n    this.projection = scan.schema();\n    this.reuseContainers = reuseContainers;\n\n\n    this.tasks = scan.planTasks();\n  }\n\n  @Override\n  public Iterator<Record> iterator() {\n    ScanIterator iter = new ScanIterator(tasks);\n    addCloseable(iter);\n    return iter;\n  }\n\n  private CloseableIterable<Record> open(FileScanTask task) {\n    InputFile input = ops.io().newInputFile(task.file().path().toString());\n\n\n    switch (task.file().format()) {\n      case AVRO:\n        Avro.ReadBuilder avro = Avro.read(input)\n            .project(projection)\n            .createReaderFunc(DataReader::create)\n            .split(task.start(), task.length());\n\n        if (reuseContainers) {\n          avro.reuseContainers();\n        }\n\n        return avro.build();\n\n      case PARQUET:\n        Parquet.ReadBuilder parquet = Parquet.read(input)\n            .project(projection)\n            .createReaderFunc(fileSchema -> buildReader(projection, fileSchema))\n            .split(task.start(), task.length());\n\n        if (reuseContainers) {\n          parquet.reuseContainers();\n        }\n\n        return parquet.build();\n\n      default:\n        throw new UnsupportedOperationException(String.format(\"Cannot read %s file: %s\",\n            task.file().format().name(), task.file().path()));\n    }\n  }\n\n  @Override\n  public void close() throws IOException {\n    tasks.close();\n    super.close();\n  }\n\n  private class ScanIterator implements Iterator<Record>, Closeable {\n    private final Iterator<FileScanTask> tasks;\n    private Closeable currentCloseable = null;\n    private Iterator<Record> currentIterator = emptyIterator();\n\n    private ScanIterator(Iterable<CombinedScanTask> tasks) {\n      this.tasks = Lists.newArrayList(concat(transform(tasks, CombinedScanTask::files))).iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n      while (true) {\n        if (currentIterator.hasNext()) {\n          return true;\n\n        } else if (tasks.hasNext()) {\n          if (currentCloseable != null) {\n            try {\n              currentCloseable.close();\n            } catch (IOException e) {\n              throw new RuntimeIOException(e, \"Failed to close task\");\n            }\n          }\n\n          FileScanTask task = tasks.next();\n          CloseableIterable<Record> reader = open(task);\n          this.currentCloseable = reader;\n\n          if (task.residual() != null && task.residual() != Expressions.alwaysTrue()) {\n            Evaluator filter = new Evaluator(projection.asStruct(), task.residual());\n            this.currentIterator = filter(reader, filter::eval).iterator();\n          } else {\n            this.currentIterator = reader.iterator();\n          }\n\n        } else {\n          return false;\n        }\n      }\n    }\n\n    @Override\n    public Record next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n\n      return currentIterator.next();\n    }\n\n    @Override\n    public void close() throws IOException {\n      if (currentCloseable != null) {\n        currentCloseable.close();\n      }\n    }\n  }\n}\n\n'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'\n:\n\npackage com.netflix.iceberg.data.parquet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.data.GenericRecord;\nimport com.netflix.iceberg.data.Record;\nimport com.netflix.iceberg.parquet.ParquetValueReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.BinaryAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.BytesReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.IntAsLongReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.IntegerAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.ListReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.LongAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.MapReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.PrimitiveReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.StringReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.StructReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.UnboxedReader;\nimport com.netflix.iceberg.parquet.TypeWithSchemaVisitor;\nimport com.netflix.iceberg.types.Type.TypeID;\nimport com.netflix.iceberg.types.Types;\nimport com.netflix.iceberg.types.Types.StructType;\nimport com.netflix.iceberg.types.Types.TimestampType;\nimport org.apache.parquet.column.ColumnDescriptor;\nimport org.apache.parquet.schema.DecimalMetadata;\nimport org.apache.parquet.schema.GroupType;\nimport org.apache.parquet.schema.MessageType;\nimport org.apache.parquet.schema.PrimitiveType;\nimport org.apache.parquet.schema.Type;\n\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.parquet.ParquetSchemaUtil.hasIds;\nimport static com.netflix.iceberg.parquet.ParquetValueReaders.option;\n\npublic class GenericParquetReaders {\n  private GenericParquetReaders() {\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static ParquetValueReader<GenericRecord> buildReader(Schema expectedSchema,\n                                                              MessageType fileSchema) {\n    if (hasIds(fileSchema)) {\n      return (ParquetValueReader<GenericRecord>)\n          TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n              new ReadBuilder(fileSchema));\n    } else {\n      return (ParquetValueReader<GenericRecord>)\n          TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n              new FallbackReadBuilder(fileSchema));\n    }\n  }\n\n  private static class FallbackReadBuilder extends ReadBuilder {\n    FallbackReadBuilder(MessageType type) {\n      super(type);\n    }\n\n    @Override\n    public ParquetValueReader<?> message(StructType expected, MessageType message,\n                                         List<ParquetValueReader<?>> fieldReaders) {\n\n      return super.struct(expected, message, fieldReaders);\n    }\n\n    @Override\n    public ParquetValueReader<?> struct(StructType expected, GroupType struct,\n                                        List<ParquetValueReader<?>> fieldReaders) {\n\n      List<ParquetValueReader<?>> newFields = Lists.newArrayListWithExpectedSize(\n          fieldReaders.size());\n      List<Type> types = Lists.newArrayListWithExpectedSize(fieldReaders.size());\n      List<Type> fields = struct.getFields();\n      for (int i = 0; i < fields.size(); i += 1) {\n        Type fieldType = fields.get(i);\n        int fieldD = type.getMaxDefinitionLevel(path(fieldType.getName()))-1;\n        newFields.add(option(fieldType, fieldD, fieldReaders.get(i)));\n        types.add(fieldType);\n      }\n\n      return new RecordReader(types, newFields, expected);\n    }\n  }\n\n  private static class ReadBuilder extends TypeWithSchemaVisitor<ParquetValueReader<?>> {\n    final MessageType type;\n\n    ReadBuilder(MessageType type) {\n      this.type = type;\n    }\n\n    @Override\n    public ParquetValueReader<?> message(StructType expected, MessageType message,\n                                         List<ParquetValueReader<?>> fieldReaders) {\n      return struct(expected, message.asGroupType(), fieldReaders);\n    }\n\n    @Override\n    public ParquetValueReader<?> struct(StructType expected, GroupType struct,\n                                        List<ParquetValueReader<?>> fieldReaders) {\n\n      Map<Integer, ParquetValueReader<?>> readersById = Maps.newHashMap();\n      Map<Integer, Type> typesById = Maps.newHashMap();\n      List<Type> fields = struct.getFields();\n      for (int i = 0; i < fields.size(); i += 1) {\n        Type fieldType = fields.get(i);\n        int fieldD = type.getMaxDefinitionLevel(path(fieldType.getName()))-1;\n        int id = fieldType.getId().intValue();\n        readersById.put(id, option(fieldType, fieldD, fieldReaders.get(i)));\n        typesById.put(id, fieldType);\n      }\n\n      List<Types.NestedField> expectedFields = expected != null ?\n          expected.fields() : ImmutableList.of();\n      List<ParquetValueReader<?>> reorderedFields = Lists.newArrayListWithExpectedSize(\n          expectedFields.size());\n      List<Type> types = Lists.newArrayListWithExpectedSize(expectedFields.size());\n      for (Types.NestedField field : expectedFields) {\n        int id = field.fieldId();\n        ParquetValueReader<?> reader = readersById.get(id);\n        if (reader != null) {\n          reorderedFields.add(reader);\n          types.add(typesById.get(id));\n        } else {\n          reorderedFields.add(ParquetValueReaders.nulls());\n          types.add(null);\n        }\n      }\n\n      return new RecordReader(types, reorderedFields, expected);\n    }\n\n    @Override\n    public ParquetValueReader<?> list(Types.ListType expectedList, GroupType array,\n                                      ParquetValueReader<?> elementReader) {\n      GroupType repeated = array.getFields().get(0).asGroupType();\n      String[] repeatedPath = currentPath();\n\n      int repeatedD = type.getMaxDefinitionLevel(repeatedPath)-1;\n      int repeatedR = type.getMaxRepetitionLevel(repeatedPath)-1;\n\n      Type elementType = repeated.getType(0);\n      int elementD = type.getMaxDefinitionLevel(path(elementType.getName()))-1;\n\n      return new ListReader<>(repeatedD, repeatedR, option(elementType, elementD, elementReader));\n    }\n\n    @Override\n    public ParquetValueReader<?> map(Types.MapType expectedMap, GroupType map,\n                                     ParquetValueReader<?> keyReader,\n                                     ParquetValueReader<?> valueReader) {\n      GroupType repeatedKeyValue = map.getFields().get(0).asGroupType();\n      String[] repeatedPath = currentPath();\n\n      int repeatedD = type.getMaxDefinitionLevel(repeatedPath)-1;\n      int repeatedR = type.getMaxRepetitionLevel(repeatedPath)-1;\n\n      Type keyType = repeatedKeyValue.getType(0);\n      int keyD = type.getMaxDefinitionLevel(path(keyType.getName()))-1;\n      Type valueType = repeatedKeyValue.getType(1);\n      int valueD = type.getMaxDefinitionLevel(path(valueType.getName()))-1;\n\n      return new MapReader<>(repeatedD, repeatedR,\n          option(keyType, keyD, keyReader), option(valueType, valueD, valueReader));\n    }\n\n    @Override\n    public ParquetValueReader<?> primitive(com.netflix.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected.typeId() == TypeID.LONG) {\n              return new IntAsLongReader(desc);\n            } else {\n              return new UnboxedReader<>(desc);\n            }\n          case INT_64:\n            return new UnboxedReader<>(desc);\n          case DATE:\n            return new DateReader(desc);\n          case TIMESTAMP_MICROS:\n            TimestampType tsMicrosType = (TimestampType) expected;\n            if (tsMicrosType.shouldAdjustToUTC()) {\n              return new TimestamptzReader(desc);\n            } else {\n              return new TimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            TimestampType tsMillisType = (TimestampType) expected;\n            if (tsMillisType.shouldAdjustToUTC()) {\n              return new TimestamptzMillisReader(desc);\n            } else {\n              return new TimestampMillisReader(desc);\n            }\n          case DECIMAL:\n            DecimalMetadata decimal = primitive.getDecimalMetadata();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new BinaryAsDecimalReader(desc, decimal.getScale());\n              case INT64:\n                return new LongAsDecimalReader(desc, decimal.getScale());\n              case INT32:\n                return new IntegerAsDecimalReader(desc, decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new BytesReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n          return new FixedReader(desc);\n        case BINARY:\n          return new BytesReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == TypeID.LONG) {\n            return new IntAsLongReader(desc);\n          } else {\n            return new UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new UnboxedReader<>(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n\n    private String[] currentPath() {\n      String[] path = new String[fieldNames.size()];\n      if (!fieldNames.isEmpty()) {\n        Iterator<String> iter = fieldNames.descendingIterator();\n        for (int i = 0; iter.hasNext(); i += 1) {\n          path[i] = iter.next();\n        }\n      }\n\n      return path;\n    }\n\n    protected String[] path(String name) {\n      String[] path = new String[fieldNames.size() + 1];\n      path[fieldNames.size()] = name;\n\n      if (!fieldNames.isEmpty()) {\n        Iterator<String> iter = fieldNames.descendingIterator();\n        for (int i = 0; iter.hasNext(); i += 1) {\n          path[i] = iter.next();\n        }\n      }\n\n      return path;\n    }\n  }\n\n  private static final OffsetDateTime EPOCH = Instant.ofEpochSecond(0).atOffset(ZoneOffset.UTC);\n  private static final LocalDate EPOCH_DAY = EPOCH.toLocalDate();\n\n  private static class DateReader extends PrimitiveReader<LocalDate> {\n    private DateReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDate read(LocalDate reuse) {\n      return EPOCH_DAY.plusDays(column.nextInteger());\n    }\n  }\n\n  private static class TimestampReader extends PrimitiveReader<LocalDateTime> {\n    private TimestampReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDateTime read(LocalDateTime reuse) {\n      return EPOCH.plus(column.nextLong(), ChronoUnit.MICROS).toLocalDateTime();\n    }\n  }\n\n  private static class TimestampMillisReader extends PrimitiveReader<LocalDateTime> {\n    private TimestampMillisReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDateTime read(LocalDateTime reuse) {\n      return EPOCH.plus(column.nextLong() * 1000, ChronoUnit.MICROS).toLocalDateTime();\n    }\n  }\n\n  private static class TimestamptzReader extends PrimitiveReader<OffsetDateTime> {\n    private TimestamptzReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public OffsetDateTime read(OffsetDateTime reuse) {\n      return EPOCH.plus(column.nextLong(), ChronoUnit.MICROS);\n    }\n  }\n\n  private static class TimestamptzMillisReader extends PrimitiveReader<OffsetDateTime> {\n    private TimestamptzMillisReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public OffsetDateTime read(OffsetDateTime reuse) {\n      return EPOCH.plus(column.nextLong() * 1000, ChronoUnit.MICROS);\n    }\n  }\n\n  private static class FixedReader extends PrimitiveReader<byte[]> {\n    private FixedReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public byte[] read(byte[] reuse) {\n      if (reuse != null) {\n        column.nextBinary().toByteBuffer().duplicate().get(reuse);\n        return reuse;\n      } else {\n        return column.nextBinary().getBytes();\n      }\n    }\n  }\n\n  static class RecordReader extends StructReader<Record, Record> {\n    private final StructType struct;\n\n    RecordReader(List<Type> types,\n                 List<ParquetValueReader<?>> readers,\n                 StructType struct) {\n      super(types, readers);\n      this.struct = struct;\n    }\n\n    @Override\n    protected Record newStructData(Record reuse) {\n      if (reuse != null) {\n        return reuse;\n      } else {\n        return GenericRecord.create(struct);\n      }\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Object getField(Record intermediate, int pos) {\n      return intermediate.get(pos);\n    }\n\n    @Override\n    protected Record buildStruct(Record struct) {\n      return struct;\n    }\n\n    @Override\n    protected void set(Record struct, int pos, Object value) {\n      struct.set(pos, value);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetSchemaUtil.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ]
    },
    {
        "files": [
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'"
        ],
        "content": "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'\n:\n\npackage github.daneren2005.dsub.adapter;\n\nimport android.content.Context;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport java.util.List;\n\nimport github.daneren2005.dsub.R;\nimport github.daneren2005.dsub.domain.MusicDirectory;\nimport github.daneren2005.dsub.domain.MusicDirectory.Entry;\nimport github.daneren2005.dsub.util.ImageLoader;\nimport github.daneren2005.dsub.util.Util;\nimport github.daneren2005.dsub.view.AlbumView;\nimport github.daneren2005.dsub.view.SongView;\nimport github.daneren2005.dsub.view.UpdateView;\nimport github.daneren2005.dsub.view.UpdateView.UpdateViewHolder;\n\npublic class EntryGridAdapter extends SectionAdapter<Entry> {\n\tprivate static String TAG = EntryGridAdapter.class.getSimpleName();\n\n\tpublic static int VIEW_TYPE_ALBUM_CELL = 1;\n\tpublic static int VIEW_TYPE_ALBUM_LINE = 2;\n\tpublic static int VIEW_TYPE_SONG = 3;\n\n\tprivate ImageLoader imageLoader;\n\tprivate boolean largeAlbums;\n\tprivate boolean showArtist = false;\n\tprivate boolean showAlbum = false;\n\tprivate boolean removeFromPlaylist = false;\n\tprivate View header;\n\n\tpublic EntryGridAdapter(Context context, List<Entry> entries, ImageLoader imageLoader, boolean largeCell) {\n\t\tsuper(context, entries);\n\t\tthis.imageLoader = imageLoader;\n\t\tthis.largeAlbums = largeCell;\n\n\n\t\tString artist = null;\n\t\tfor(MusicDirectory.Entry entry: entries) {\n\t\t\tif(artist == null) {\n\t\t\t\tartist = entry.getArtist();\n\t\t\t}\n\n\t\t\tif(artist != null && !artist.equals(entry.getArtist())) {\n\t\t\t\tshowArtist = true;\n\t\t\t}\n\t\t}\n\t\tcheckable = true;\n\t}\n\n\t@Override\n\tpublic UpdateViewHolder onCreateSectionViewHolder(ViewGroup parent, int viewType) {\n\t\tUpdateView updateView = null;\n\t\tif(viewType == VIEW_TYPE_ALBUM_LINE || viewType == VIEW_TYPE_ALBUM_CELL) {\n\t\t\tupdateView = new AlbumView(context, viewType == VIEW_TYPE_ALBUM_CELL);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tupdateView = new SongView(context);\n\t\t}\n\n\t\treturn new UpdateViewHolder(updateView);\n\t}\n\n\t@Override\n\tpublic void onBindViewHolder(UpdateViewHolder holder, Entry entry, int viewType) {\n\t\tUpdateView view = holder.getUpdateView();\n\t\tif(viewType == VIEW_TYPE_ALBUM_CELL || viewType == VIEW_TYPE_ALBUM_LINE) {\n\t\t\tAlbumView albumView = (AlbumView) view;\n\t\t\talbumView.setShowArtist(showArtist);\n\t\t\talbumView.setObject(entry, imageLoader);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tSongView songView = (SongView) view;\n\t\t\tsongView.setShowAlbum(showAlbum);\n\t\t\tsongView.setObject(entry, checkable && !entry.isVideo());\n\t\t}\n\t}\n\n\tpublic UpdateViewHolder onCreateHeaderHolder(ViewGroup parent) {\n\t\treturn new UpdateViewHolder(header, false);\n\t}\n\tpublic void onBindHeaderHolder(UpdateViewHolder holder, String header, int sectionIndex) {\n\n\t}\n\n\t@Override\n\tpublic int getItemViewType(Entry entry) {\n\t\tif(entry.isDirectory()) {\n\t\t\tif (largeAlbums) {\n\t\t\t\treturn VIEW_TYPE_ALBUM_CELL;\n\t\t\t} else {\n\t\t\t\treturn VIEW_TYPE_ALBUM_LINE;\n\t\t\t}\n\t\t} else {\n\t\t\treturn VIEW_TYPE_SONG;\n\t\t}\n\t}\n\n\tpublic void setHeader(View header) {\n\t\tthis.header = header;\n\t\tthis.singleSectionHeader = true;\n\t}\n\tpublic View getHeader() {\n\t\treturn header;\n\t}\n\n\tpublic void setShowArtist(boolean showArtist) {\n\t\tthis.showArtist = showArtist;\n\t}\n\n\tpublic void setShowAlbum(boolean showAlbum) {\n\t\tthis.showAlbum = showAlbum;\n\t}\n\n\tpublic void removeAt(int index) {\n\t\tsections.get(0).remove(index);\n\t\tif(header != null) {\n\t\t\tindex++;\n\t\t}\n\t\tnotifyItemRemoved(index);\n\t}\n\n\tpublic void setRemoveFromPlaylist(boolean removeFromPlaylist) {\n\t\tthis.removeFromPlaylist = removeFromPlaylist;\n\t}\n\n\t@Override\n\tpublic void onCreateActionModeMenu(Menu menu, MenuInflater menuInflater) {\n\t\tif(Util.isOffline(context)) {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media_offline, menu);\n\t\t} else {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media, menu);\n\t\t}\n\n\t\tif(!removeFromPlaylist) {\n\t\t\tmenu.removeItem(R.id.menu_remove_playlist);\n\t\t}\n\n\t\tif(!selected.isEmpty()) {\n\t\t\tMenuItem starItem = menu.findItem(R.id.menu_star);\n\t\t\tif(starItem != null) {\n\t\t\t\tboolean isStarred = selected.get(0).isStarred();\n\t\t\t\tstarItem.setTitle(isStarred ? R.string.common_unstar : R.string.common_star);\n\t\t\t}\n\t\t}\n\t}\n}\n\n'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'\n:\npackage github.daneren2005.dsub.domain;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.media.MediaMetadataRetriever;\nimport android.os.Build;\nimport android.util.Log;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Locale;\n\nimport github.daneren2005.dsub.service.DownloadService;\nimport github.daneren2005.dsub.util.Constants;\nimport github.daneren2005.dsub.util.UpdateHelper;\nimport github.daneren2005.dsub.util.Util;\n\n\npublic class MusicDirectory implements Serializable {\n\tprivate static final String TAG = MusicDirectory.class.getSimpleName();\n\n    private String name;\n\tprivate String id;\n\tprivate String parent;\n    private List<Entry> children;\n\n\tpublic MusicDirectory() {\n\t\tchildren = new ArrayList<Entry>();\n\t}\n\tpublic MusicDirectory(List<Entry> children) {\n\t\tthis.children = children;\n\t}\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n\t public String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getParent() {\n\t\treturn parent;\n\t}\n\n\tpublic void setParent(String parent) {\n\t\tthis.parent = parent;\n\t}\n\n\tpublic void addChild(Entry child) {\n\t\tif(child != null) {\n\t\t\tchildren.add(child);\n\t\t}\n\t}\n\tpublic void addChildren(List<Entry> children) {\n\t\tthis.children.addAll(children);\n\t}\n\n\tpublic void replaceChildren(List<Entry> children) {\n\t\tthis.children = children;\n\t}\n\n    public synchronized List<Entry> getChildren() {\n        return getChildren(true, true);\n    }\n\n    public synchronized List<Entry> getChildren(boolean includeDirs, boolean includeFiles) {\n        if (includeDirs && includeFiles) {\n            return children;\n        }\n\n        List<Entry> result = new ArrayList<Entry>(children.size());\n        for (Entry child : children) {\n            if (child != null && child.isDirectory() && includeDirs || !child.isDirectory() && includeFiles) {\n                result.add(child);\n            }\n        }\n        return result;\n    }\n\tpublic synchronized List<Entry> getSongs() {\n\t\tList<Entry> result = new ArrayList<Entry>();\n\t\tfor (Entry child : children) {\n\t\t\tif (child != null && !child.isDirectory() && !child.isVideo()) {\n\t\t\t\tresult.add(child);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic synchronized int getChildrenSize() {\n\t\treturn children.size();\n\t}\n\n\tpublic void shuffleChildren() {\n\t\tCollections.shuffle(this.children);\n\t}\n\n\tpublic void sortChildren(Context context, int instance) {\n\n\t\tif(ServerInfo.checkServerVersion(context, \"1.8\", instance)) {\n\t\t\tsortChildren(Util.getPreferences(context).getBoolean(Constants.PREFERENCES_KEY_CUSTOM_SORT_ENABLED, true));\n\t\t}\n\t}\n\tpublic void sortChildren(boolean byYear) {\n\t\tEntryComparator.sort(children, byYear);\n\t}\n\n\tpublic synchronized boolean updateMetadata(MusicDirectory refreshedDirectory) {\n\t\tboolean metadataUpdated = false;\n\t\tIterator<Entry> it = children.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tEntry entry = it.next();\n\t\t\tint index = refreshedDirectory.children.indexOf(entry);\n\t\t\tif(index != -1) {\n\t\t\t\tfinal Entry refreshed = refreshedDirectory.children.get(index);\n\n\t\t\t\tentry.setTitle(refreshed.getTitle());\n\t\t\t\tentry.setAlbum(refreshed.getAlbum());\n\t\t\t\tentry.setArtist(refreshed.getArtist());\n\t\t\t\tentry.setTrack(refreshed.getTrack());\n\t\t\t\tentry.setYear(refreshed.getYear());\n\t\t\t\tentry.setGenre(refreshed.getGenre());\n\t\t\t\tentry.setTranscodedContentType(refreshed.getTranscodedContentType());\n\t\t\t\tentry.setTranscodedSuffix(refreshed.getTranscodedSuffix());\n\t\t\t\tentry.setDiscNumber(refreshed.getDiscNumber());\n\t\t\t\tentry.setStarred(refreshed.isStarred());\n\t\t\t\tentry.setRating(refreshed.getRating());\n\t\t\t\tentry.setType(refreshed.getType());\n\t\t\t\tif(!Util.equals(entry.getCoverArt(), refreshed.getCoverArt())) {\n\t\t\t\t\tmetadataUpdated = true;\n\t\t\t\t\tentry.setCoverArt(refreshed.getCoverArt());\n\t\t\t\t}\n\n\t\t\t\tnew UpdateHelper.EntryInstanceUpdater(entry) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void update(Entry found) {\n\t\t\t\t\t\tfound.setTitle(refreshed.getTitle());\n\t\t\t\t\t\tfound.setAlbum(refreshed.getAlbum());\n\t\t\t\t\t\tfound.setArtist(refreshed.getArtist());\n\t\t\t\t\t\tfound.setTrack(refreshed.getTrack());\n\t\t\t\t\t\tfound.setYear(refreshed.getYear());\n\t\t\t\t\t\tfound.setGenre(refreshed.getGenre());\n\t\t\t\t\t\tfound.setTranscodedContentType(refreshed.getTranscodedContentType());\n\t\t\t\t\t\tfound.setTranscodedSuffix(refreshed.getTranscodedSuffix());\n\t\t\t\t\t\tfound.setDiscNumber(refreshed.getDiscNumber());\n\t\t\t\t\t\tfound.setStarred(refreshed.isStarred());\n\t\t\t\t\t\tfound.setRating(refreshed.getRating());\n\t\t\t\t\t\tfound.setType(refreshed.getType());\n\t\t\t\t\t\tif(!Util.equals(found.getCoverArt(), refreshed.getCoverArt())) {\n\t\t\t\t\t\t\tfound.setCoverArt(refreshed.getCoverArt());\n\t\t\t\t\t\t\tmetadataUpdate = DownloadService.METADATA_UPDATED_COVER_ART;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.execute();\n\t\t\t}\n\t\t}\n\n\t\treturn metadataUpdated;\n\t}\n\tpublic synchronized boolean updateEntriesList(Context context, int instance, MusicDirectory refreshedDirectory) {\n\t\tboolean changed = false;\n\t\tIterator<Entry> it = children.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tEntry entry = it.next();\n\n\t\t\tif(refreshedDirectory.children.indexOf(entry) == -1) {\n\t\t\t\tit.remove();\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\n\t\tboolean resort = false;\n\t\tfor(Entry refreshed: refreshedDirectory.children) {\n\t\t\tif(!this.children.contains(refreshed)) {\n\t\t\t\tthis.children.add(refreshed);\n\t\t\t\tresort = true;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif(resort) {\n\t\t\tthis.sortChildren(context, instance);\n\t\t}\n\n\t\treturn changed;\n\t}\n\n    public static class Entry implements Serializable {\n\t\tpublic static final int TYPE_SONG = 0;\n\t\tpublic static final int TYPE_PODCAST = 1;\n\t\tpublic static final int TYPE_AUDIO_BOOK = 2;\n\n\t\tprivate String id;\n\t\tprivate String parent;\n\t\tprivate String grandParent;\n\t\tprivate String albumId;\n\t\tprivate String artistId;\n\t\tprivate boolean directory;\n\t\tprivate String title;\n\t\tprivate String album;\n\t\tprivate String artist;\n\t\tprivate Integer track;\n\t\tprivate Integer customOrder;\n\t\tprivate Integer year;\n\t\tprivate String genre;\n\t\tprivate String contentType;\n\t\tprivate String suffix;\n\t\tprivate String transcodedContentType;\n\t\tprivate String transcodedSuffix;\n\t\tprivate String coverArt;\n\t\tprivate Long size;\n\t\tprivate Integer duration;\n\t\tprivate Integer bitRate;\n\t\tprivate String path;\n\t\tprivate boolean video;\n\t\tprivate Integer discNumber;\n\t\tprivate boolean starred;\n\t\tprivate Integer rating;\n\t\tprivate Bookmark bookmark;\n\t\tprivate int type = 0;\n\t\tprivate int closeness;\n\t\tprivate transient Artist linkedArtist;\n\n\t\tpublic Entry() {\n\n\t\t}\n\t\tpublic Entry(String id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\tpublic Entry(Artist artist) {\n\t\t\tthis.id = artist.getId();\n\t\t\tthis.title = artist.getName();\n\t\t\tthis.directory = true;\n\t\t\tthis.starred = artist.isStarred();\n\t\t\tthis.rating = artist.getRating();\n\t\t\tthis.linkedArtist = artist;\n\t\t}\n\n\t\t@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)\n\t\tpublic void loadMetadata(File file) {\n\t\t\ttry {\n\t\t\t\tMediaMetadataRetriever metadata = new MediaMetadataRetriever();\n\t\t\t\tmetadata.setDataSource(file.getAbsolutePath());\n\t\t\t\tString discNumber = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DISC_NUMBER);\n\t\t\t\tif(discNumber == null) {\n\t\t\t\t\tdiscNumber = \"1/1\";\n\t\t\t\t}\n\t\t\t\tint slashIndex = discNumber.indexOf(\"/\");\n\t\t\t\tif(slashIndex > 0) {\n\t\t\t\t\tdiscNumber = discNumber.substring(0, slashIndex);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tsetDiscNumber(Integer.parseInt(discNumber));\n\t\t\t\t} catch(Exception e) {\n\t\t\t\t\tLog.w(TAG, \"Non numbers in disc field!\");\n\t\t\t\t}\n\t\t\t\tString bitrate = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE);\n\t\t\t\tsetBitRate(Integer.parseInt((bitrate != null) ? bitrate : \"0\") / 1000);\n\t\t\t\tString length = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);\n\t\t\t\tsetDuration(Integer.parseInt(length) / 1000);\n\t\t\t\tString artist = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);\n\t\t\t\tif(artist != null) {\n\t\t\t\t\tsetArtist(artist);\n\t\t\t\t}\n\t\t\t\tString album = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);\n\t\t\t\tif(album != null) {\n\t\t\t\t\tsetAlbum(album);\n\t\t\t\t}\n\t\t\t\tmetadata.release();\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.i(TAG, \"Device doesn't properly support MediaMetadataRetreiver\", e);\n\t\t\t}\n\t\t}\n\t\tpublic void rebaseTitleOffPath() {\n\t\t\ttry {\n\t\t\t\tString filename = getPath();\n\t\t\t\tif(filename == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tint index = filename.lastIndexOf('/');\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tfilename = filename.substring(index + 1);\n\t\t\t\t\tif (getTrack() != null) {\n\t\t\t\t\t\tfilename = filename.replace(String.format(\"%02d \", getTrack()), \"\");\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = filename.lastIndexOf('.');\n\t\t\t\t\tif(index != -1) {\n\t\t\t\t\t\tfilename = filename.substring(0, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tsetTitle(filename);\n\t\t\t\t}\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to update title based off of path\", e);\n\t\t\t}\n\t\t}\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public String getParent() {\n            return parent;\n        }\n\n        public void setParent(String parent) {\n            this.parent = parent;\n        }\n\n\t\tpublic String getGrandParent() {\n            return grandParent;\n        }\n\n        public void setGrandParent(String grandParent) {\n            this.grandParent = grandParent;\n        }\n\n\t\tpublic String getAlbumId() {\n\t\t\treturn albumId;\n\t\t}\n\n\t\tpublic void setAlbumId(String albumId) {\n\t\t\tthis.albumId = albumId;\n\t\t}\n\n\t\tpublic String getArtistId() {\n\t\t\treturn artistId;\n\t\t}\n\n\t\tpublic void setArtistId(String artistId) {\n\t\t\tthis.artistId = artistId;\n\t\t}\n\n        public boolean isDirectory() {\n            return directory;\n        }\n\n        public void setDirectory(boolean directory) {\n            this.directory = directory;\n        }\n\n        public String getTitle() {\n            return title;\n        }\n\n        public void setTitle(String title) {\n            this.title = title;\n        }\n\n        public String getAlbum() {\n            return album;\n        }\n\n\t\tpublic boolean isAlbum() {\n\t\t\treturn getParent() != null || getArtist() != null;\n\t\t}\n\n\t\tpublic String getAlbumDisplay() {\n\t\t\tif(album != null && title.startsWith(\"Disc \")) {\n\t\t\t\treturn album;\n\t\t\t} else {\n\t\t\t\treturn title;\n\t\t\t}\n\t\t}\n\n        public void setAlbum(String album) {\n            this.album = album;\n        }\n\n        public String getArtist() {\n            return artist;\n        }\n\n        public void setArtist(String artist) {\n            this.artist = artist;\n        }\n\n        public Integer getTrack() {\n            return track;\n        }\n\n        public void setTrack(Integer track) {\n            this.track = track;\n        }\n\n\t\tpublic Integer getCustomOrder() {\n\t\t\treturn customOrder;\n\t\t}\n\t\tpublic void setCustomOrder(Integer customOrder) {\n\t\t\tthis.customOrder = customOrder;\n\t\t}\n\n        public Integer getYear() {\n            return year;\n        }\n\n        public void setYear(Integer year) {\n            this.year = year;\n        }\n\n        public String getGenre() {\n            return genre;\n        }\n\n        public void setGenre(String genre) {\n            this.genre = genre;\n        }\n\n        public String getContentType() {\n            return contentType;\n        }\n\n        public void setContentType(String contentType) {\n            this.contentType = contentType;\n        }\n\n        public String getSuffix() {\n            return suffix;\n        }\n\n        public void setSuffix(String suffix) {\n            this.suffix = suffix;\n        }\n\n        public String getTranscodedContentType() {\n            return transcodedContentType;\n        }\n\n        public void setTranscodedContentType(String transcodedContentType) {\n            this.transcodedContentType = transcodedContentType;\n        }\n\n        public String getTranscodedSuffix() {\n            return transcodedSuffix;\n        }\n\n        public void setTranscodedSuffix(String transcodedSuffix) {\n            this.transcodedSuffix = transcodedSuffix;\n        }\n\n        public Long getSize() {\n            return size;\n        }\n\n        public void setSize(Long size) {\n            this.size = size;\n        }\n\n        public Integer getDuration() {\n            return duration;\n        }\n\n        public void setDuration(Integer duration) {\n            this.duration = duration;\n        }\n\n        public Integer getBitRate() {\n            return bitRate;\n        }\n\n        public void setBitRate(Integer bitRate) {\n            this.bitRate = bitRate;\n        }\n\n        public String getCoverArt() {\n            return coverArt;\n        }\n\n        public void setCoverArt(String coverArt) {\n            this.coverArt = coverArt;\n        }\n\n        public String getPath() {\n            return path;\n        }\n\n        public void setPath(String path) {\n            this.path = path;\n        }\n\n        public boolean isVideo() {\n            return video;\n        }\n\n        public void setVideo(boolean video) {\n            this.video = video;\n        }\n\n\t\tpublic Integer getDiscNumber() {\n\t\t\treturn discNumber;\n\t\t}\n\n\t\tpublic void setDiscNumber(Integer discNumber) {\n\t\t\tthis.discNumber = discNumber;\n\t\t}\n\n        public boolean isStarred() {\n            return starred;\n        }\n\n        public void setStarred(boolean starred) {\n            this.starred = starred;\n\n\t\t\tif(linkedArtist != null) {\n\t\t\t\tlinkedArtist.setStarred(starred);\n\t\t\t}\n        }\n\n\t\tpublic int getRating() {\n\t\t\treturn rating == null ? 0 : rating;\n\t\t}\n\t\tpublic void setRating(Integer rating) {\n\t\t\tif(rating == null || rating == 0) {\n\t\t\t\tthis.rating = null;\n\t\t\t} else {\n\t\t\t\tthis.rating = rating;\n\t\t\t}\n\n\t\t\tif(linkedArtist != null) {\n\t\t\t\tlinkedArtist.setRating(rating);\n\t\t\t}\n\t\t}\n\n\t\tpublic Bookmark getBookmark() {\n\t\t\treturn bookmark;\n\t\t}\n\t\tpublic void setBookmark(Bookmark bookmark) {\n\t\t\tthis.bookmark = bookmark;\n\t\t}\n\n\t\tpublic int getType() {\n\t\t\treturn type;\n\t\t}\n\t\tpublic void setType(int type) {\n\t\t\tthis.type = type;\n\t\t}\n\t\tpublic boolean isSong() {\n\t\t\treturn type == TYPE_SONG;\n\t\t}\n\t\tpublic boolean isPodcast() {\n\t\t\treturn this instanceof PodcastEpisode || type == TYPE_PODCAST;\n\t\t}\n\t\tpublic boolean isAudioBook() {\n\t\t\treturn type == TYPE_AUDIO_BOOK;\n\t\t}\n\n\t\tpublic int getCloseness() {\n\t\t\treturn closeness;\n\t\t}\n\n\t\tpublic void setCloseness(int closeness) {\n\t\t\tthis.closeness = closeness;\n\t\t}\n\n\t\tpublic boolean isOnlineId(Context context) {\n\t\t\ttry {\n\t\t\t\tString cacheLocation = Util.getPreferences(context).getString(Constants.PREFERENCES_KEY_CACHE_LOCATION, null);\n\t\t\t\treturn cacheLocation == null || id == null || id.indexOf(cacheLocation) == -1;\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to check online id validity\");\n\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            Entry entry = (Entry) o;\n            return id.equals(entry.id);\n        }\n\n        @Override\n        public int hashCode() {\n            return id.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return title;\n        }\n\n        public byte[] toByteArray() throws IOException {\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tObjectOutput out = null;\n\t\t\ttry {\n\t\t\t\tout = new ObjectOutputStream(bos);\n\t\t\t\tout.writeObject(this);\n\t\t\t\tout.flush();\n\t\t\t\treturn bos.toByteArray();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tbos.close();\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static Entry fromByteArray(byte[] byteArray) throws IOException, ClassNotFoundException {\n\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(byteArray);\n\t\t\tObjectInput in = null;\n\t\t\ttry {\n\t\t\t\tin = new ObjectInputStream(bis);\n\t\t\t\treturn (Entry) in.readObject();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static class EntryComparator implements Comparator<Entry> {\n\t\tprivate boolean byYear;\n\t\tprivate Collator collator;\n\n\t\tpublic EntryComparator(boolean byYear) {\n\t\t\tthis.byYear = byYear;\n\t\t\tthis.collator = Collator.getInstance(Locale.US);\n\t\t\tthis.collator.setStrength(Collator.PRIMARY);\n\t\t}\n\n\t\tpublic int compare(Entry lhs, Entry rhs) {\n\t\t\tif(lhs.isDirectory() && !rhs.isDirectory()) {\n\t\t\t\treturn -1;\n\t\t\t} else if(!lhs.isDirectory() && rhs.isDirectory()) {\n\t\t\t\treturn 1;\n\t\t\t} else if(lhs.isDirectory() && rhs.isDirectory()) {\n\t\t\t\tif(byYear) {\n\t\t\t\t\tInteger lhsYear = lhs.getYear();\n\t\t\t\t\tInteger rhsYear = rhs.getYear();\n\t\t\t\t\tif(lhsYear != null && rhsYear != null) {\n\t\t\t\t\t\treturn lhsYear.compareTo(rhsYear);\n\t\t\t\t\t} else if(lhsYear != null) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else if(rhsYear != null) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn collator.compare(lhs.getAlbumDisplay(), rhs.getAlbumDisplay());\n\t\t\t}\n\n\t\t\tInteger lhsDisc = lhs.getDiscNumber();\n\t\t\tInteger rhsDisc = rhs.getDiscNumber();\n\n\t\t\tif(lhsDisc != null && rhsDisc != null) {\n\t\t\t\tif(lhsDisc < rhsDisc) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if(lhsDisc > rhsDisc) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInteger lhsTrack = lhs.getTrack();\n\t\t\tInteger rhsTrack = rhs.getTrack();\n\t\t\tif(lhsTrack == rhsTrack) {\n\t\t\t\treturn collator.compare(lhs.getTitle(), rhs.getTitle());\n\t\t\t} else if(lhsTrack != null && rhsTrack != null) {\n\t\t\t\treturn lhsTrack.compareTo(rhsTrack);\n\t\t\t} else if(lhsTrack != null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic static void sort(List<Entry> entries) {\n\t\t\tsort(entries, true);\n\t\t}\n\t\tpublic static void sort(List<Entry> entries, boolean byYear) {\n\t\t\ttry {\n\t\t\t\tCollections.sort(entries, new EntryComparator(byYear));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to sort MusicDirectory\");\n\t\t\t}\n\t\t}\n\t}\n}\n",
        "gt": [
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.NonNull;\nimport android.support.graphics.drawable.AnimatedVectorDrawableCompat;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.ImageButton;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\nimport com.philliphsu.bottomsheetpickers.date.MonthPickerView.OnMonthClickListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\n\n\nclass PagingDayPickerView extends LinearLayout implements OnDateChangedListener, OnPageChangeListener, OnMonthClickListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n    static final int DAY_PICKER_INDEX = 0;\n    static final int MONTH_PICKER_INDEX = 1;\n\n    static int MONTH_NAVIGATION_BAR_SIZE;\n\n    private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected PagingMonthAdapter mAdapter;\n\n    private DayPickerViewAnimator mMonthAnimator;\n    private ViewPager mViewPager;\n    private MonthPickerView mMonthPickerView;\n    private TextView mMonthYearTitleView;\n    private ImageButton mPreviousButton;\n    private ImageButton mNextButton;\n    private View mTitleContainer;\n\n\n    private AnimatedVectorDrawableCompat mArrowDownDrawable;\n\n    private AnimatedVectorDrawableCompat mArrowUpDrawable;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mCurrentMonthDisplayed;\n\n    private int mCurrentView = DAY_PICKER_INDEX;\n\n    private int mCurrentYearDisplayed;\n\n    private DatePickerController mController;\n\n    private boolean mThemeDark;\n    private int mAccentColor;\n\n    public PagingDayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        this(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark,\n                               int accentColor) {\n        super(context);\n\n        mThemeDark = themeDark;\n        mAccentColor = accentColor;\n        init(context);\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n        mMonthPickerView.setDatePickerController(mController);\n    }\n\n    private void init(Context context) {\n        mHandler = new Handler();\n        setOrientation(VERTICAL);\n        setLayoutParams(new LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        Resources res = getResources();\n        MONTH_NAVIGATION_BAR_SIZE = res.getDimensionPixelOffset(R.dimen.bsp_month_navigation_bar_height)\n                + res.getDimensionPixelOffset(R.dimen.bsp_month_view_top_padding);\n\n        final View view = LayoutInflater.from(context).inflate(R.layout.bsp_day_picker_content, this, true);\n        mMonthAnimator = (DayPickerViewAnimator) findViewById(R.id.bsp_month_animator);\n        mMonthPickerView = (MonthPickerView) findViewById(R.id.bsp_month_picker);\n        mMonthPickerView.setOnMonthClickListener(this);\n        mViewPager = (ViewPager) findViewById(R.id.bsp_viewpager);\n        mViewPager.addOnPageChangeListener(this);\n        mMonthYearTitleView = (TextView) view.findViewById(R.id.bsp_month_year_title);\n        mTitleContainer = view.findViewById(R.id.bsp_month_year_title_container);\n        mTitleContainer.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int newIndex = mCurrentView == DAY_PICKER_INDEX ? MONTH_PICKER_INDEX : DAY_PICKER_INDEX;\n                setupCurrentView(newIndex, true);\n            }\n        });\n        mPreviousButton = (ImageButton) view.findViewById(R.id.bsp_prev);\n        mPreviousButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int previousItem = mViewPager.getCurrentItem() - 1;\n                if (previousItem >= 0) {\n                    mViewPager.setCurrentItem(previousItem, true);\n                }\n            }\n        });\n        mNextButton = (ImageButton) view.findViewById(R.id.bsp_next);\n        mNextButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int nextItem = mViewPager.getCurrentItem() + 1;\n                if (nextItem < mAdapter.getCount()) {\n                    mViewPager.setCurrentItem(nextItem, true);\n                }\n            }\n        });\n\n        mArrowDownDrawable = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_down);\n        mArrowUpDrawable   = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_up);\n        setArrowDrawableOnTitle(mArrowDownDrawable);\n\n\n        if (mThemeDark) {\n            int selectableItemBg = getColor(context, R.color.bsp_selectable_item_background_dark);\n            Utils.setColorControlHighlight(mPreviousButton, selectableItemBg);\n            Utils.setColorControlHighlight(mNextButton, selectableItemBg);\n            Utils.setColorControlHighlight(mTitleContainer, selectableItemBg);\n            int cursor = getColor(context, R.color.bsp_text_color_secondary_dark);\n            Utils.applyTint(mPreviousButton, cursor);\n            Utils.applyTint(mNextButton, cursor);\n        }\n\n\n        int monthYearTitleColor = getColor(context, mThemeDark?\n                R.color.bsp_text_color_primary_dark : R.color.bsp_text_color_primary_light);\n        int dropdownArrowColor = getColor(context, mThemeDark?\n                R.color.bsp_icon_color_active_dark : R.color.bsp_icon_color_active_light);\n\n        mMonthYearTitleView.setTextColor(monthYearTitleColor);\n        mArrowDownDrawable.setTint(dropdownArrowColor);\n        mArrowUpDrawable.setTint(dropdownArrowColor);\n\n        mMonthPickerView.setTheme(context, mThemeDark);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mViewPager.removeOnPageChangeListener(this);\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    void setAccentColor(@ColorInt int color) {\n        mAccentColor = color;\n        mMonthPickerView.setCurrentMonthTextColor(color);\n        mMonthPickerView.setSelectedCirclePaintColor(color);\n    }\n\n    public void onChange() {\n        refreshAdapter();\n        refreshMonthPicker();\n    }\n\n\n    void setupCurrentView(int currentView, boolean animate) {\n        if (currentView == DAY_PICKER_INDEX || currentView == MONTH_PICKER_INDEX) {\n            boolean isDayPicker = currentView == DAY_PICKER_INDEX;\n            setCurrentView(currentView, animate);\n            if (isDayPicker) {\n                setTitle(mAdapter.getPageTitle(mViewPager.getCurrentItem()));\n                toggleArrowsVisibility(getPagerPosition());\n            } else {\n\n\n\n                setTitle(String.valueOf(mCurrentYearDisplayed));\n                toggleArrowsVisibility(false, false);\n            }\n        } else {\n            Log.e(TAG, \"Error restoring current view\");\n        }\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            if (mAccentColor != 0) {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark, mAccentColor);\n            } else {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n            }\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        mViewPager.setAdapter(mAdapter);\n    }\n\n\n    private void refreshMonthPicker() {\n        prepareMonthPickerForDisplay(mSelectedDay.year);\n        mMonthPickerView.invalidate();\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller) {\n        return new PagingMonthAdapter(context, controller);\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark) {\n        return createMonthAdapter(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark,\n                                                 int accentColor) {\n        return new PagingMonthAdapter(context, controller, themeDark, accentColor);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n        final int selectedPosition = getPosition(mSelectedDay);\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = getPosition(day);\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthAndYearDisplayed(mTempDay);\n            if (animate) {\n                mViewPager.setCurrentItem(position, true);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n                return true;\n            } else {\n                postSetSelection(position, setSelected);\n            }\n        } else if (setSelected) {\n            setMonthAndYearDisplayed(mSelectedDay);\n            setSelectedDay(mSelectedDay);\n        }\n        return false;\n    }\n\n\n    private int getPosition(CalendarDay day) {\n        return mAdapter.getPosition(day);\n    }\n\n    public void postSetSelection(final int position, final boolean setSelected) {\n        clearFocus();\n        post(new Runnable() {\n            @Override\n            public void run() {\n                mViewPager.setCurrentItem(position, false);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n            }\n        });\n    }\n\n    void postSetupCurrentView(final int currentView, final boolean animate) {\n        post(new Runnable() {\n            @Override\n            public void run() {\n                setupCurrentView(currentView, animate);\n            }\n        });\n    }\n\n\n    protected void setMonthAndYearDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        mCurrentYearDisplayed = date.year;\n    }\n\n    private void setSelectedDay(CalendarDay day) {\n        mAdapter.setSelectedDay(day);\n    }\n\n    @Override\n    public void onDateChanged() {\n        if (mCurrentView != DAY_PICKER_INDEX) {\n            setCurrentView(DAY_PICKER_INDEX, false);\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getPagerPosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        return true;\n    }\n\n    int getPagerPosition() {\n        return mViewPager.getCurrentItem();\n    }\n\n    int getCurrentView() {\n        return mCurrentView;\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mCurrentView == DAY_PICKER_INDEX) {\n            setTitle(mAdapter.getPageTitle(position));\n            toggleArrowsVisibility(position);\n            final int month = mAdapter.getMonth(position);\n            final int year = mAdapter.getYear(position);\n            if (mCurrentYearDisplayed != year) {\n                mCurrentYearDisplayed = year;\n            }\n            if (mCurrentMonthDisplayed != month) {\n                mCurrentMonthDisplayed = month;\n            }\n        }\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n\n    private void setTitle(CharSequence title) {\n        mMonthYearTitleView.setText(title);\n    }\n\n\n    private void toggleArrowsVisibility(int position) {\n        toggleArrowsVisibility(position > 0, position + 1 < mAdapter.getCount());\n    }\n\n    private void toggleArrowsVisibility(boolean leftVisible, boolean rightVisible) {\n        mPreviousButton.setVisibility(leftVisible ? VISIBLE : INVISIBLE);\n        mNextButton.setVisibility(rightVisible ? VISIBLE : INVISIBLE);\n    }\n\n    private void setArrowDrawableOnTitle(@NonNull Drawable arrow) {\n        if (Utils.checkApiLevel(17)) {\n            mMonthYearTitleView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, arrow, null);\n        } else {\n            mMonthYearTitleView.setCompoundDrawablesWithIntrinsicBounds(null, null, arrow, null);\n        }\n    }\n\n    private void animateArrow(AnimatedVectorDrawableCompat arrow) {\n        setArrowDrawableOnTitle(arrow);\n        arrow.start();\n    }\n\n    private void setCurrentView(final int viewIndex, boolean animate) {\n        switch (viewIndex) {\n            case DAY_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    mMonthAnimator.setDisplayedChild(DAY_PICKER_INDEX, animate);\n                    animateArrow(mArrowUpDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n            case MONTH_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    prepareMonthPickerForDisplay(mCurrentYearDisplayed);\n                    mMonthAnimator.setDisplayedChild(MONTH_PICKER_INDEX, animate);\n                    animateArrow(mArrowDownDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n        }\n    }\n\n    private void prepareMonthPickerForDisplay(int currentYear) {\n        mMonthPickerView.setDisplayParams(mSelectedDay, currentYear);\n    }\n\n    @Override\n    public void onMonthClick(MonthPickerView view, int month, int year) {\n\n\n\n\n\n        setCurrentView(DAY_PICKER_INDEX, true);\n\n\n\n\n\n\n\n\n\n\n        if (month == mCurrentMonthDisplayed) {\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        mController.tryVibrate();\n        mController.onMonthYearSelected(month, year);\n    }\n}\n\n'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\n\nimport java.util.Calendar;\n\n\npublic interface DatePickerController {\n\n    void onYearSelected(int year);\n\n    void onDayOfMonthSelected(int year, int month, int day);\n\n    void onMonthYearSelected(int month, int year);\n\n    void registerOnDateChangedListener(OnDateChangedListener listener);\n\n    void unregisterOnDateChangedListener(OnDateChangedListener listener);\n\n    CalendarDay getSelectedDay();\n\n    int getFirstDayOfWeek();\n\n    int getMinYear();\n\n    int getMaxYear();\n\n    Calendar getMinDate();\n\n    Calendar getMaxDate();\n\n    void tryVibrate();\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ]
    },
    {
        "files": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ],
        "content": "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'\n:\n\npackage com.netflix.iceberg.parquet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.parquet.column.ColumnDescriptor;\nimport org.apache.parquet.column.page.PageReadStore;\nimport org.apache.parquet.io.api.Binary;\nimport org.apache.parquet.schema.Type;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static java.util.Collections.emptyIterator;\n\npublic class ParquetValueReaders {\n  private ParquetValueReaders() {\n  }\n\n  public static <T> ParquetValueReader<T> option(Type type, int definitionLevel,\n                                                 ParquetValueReader<T> reader) {\n    if (type.isRepetition(Type.Repetition.OPTIONAL)) {\n      return new OptionReader<>(definitionLevel, reader);\n    }\n    return reader;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static <T> ParquetValueReader<T> nulls() {\n    return (ParquetValueReader<T>) NullReader.INSTANCE;\n  }\n\n  private static class NullReader<T> implements ParquetValueReader<T> {\n    private static final NullReader<Void> INSTANCE = new NullReader<>();\n    private static final List<TripleIterator<?>> COLUMNS = ImmutableList.of();\n    private static final TripleIterator<?> NULL_COLUMN = new TripleIterator<Object> () {\n      @Override\n      public int currentDefinitionLevel() {\n        return 0;\n      }\n\n      @Override\n      public int currentRepetitionLevel() {\n        return 0;\n      }\n\n      @Override\n      public <N> N nextNull() {\n        return null;\n      }\n\n      @Override\n      public boolean hasNext() {\n        return false;\n      }\n\n      @Override\n      public Object next() {\n        return null;\n      }\n    };\n\n    private NullReader() {\n    }\n\n    @Override\n    public T read(T reuse) {\n      return null;\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return NULL_COLUMN;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return COLUMNS;\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n    }\n  }\n\n  public abstract static class PrimitiveReader<T> implements ParquetValueReader<T> {\n    private final ColumnDescriptor desc;\n    protected final ColumnIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected PrimitiveReader(ColumnDescriptor desc) {\n      this.desc = desc;\n      this.column = ColumnIterator.newIterator(desc, \"\");\n      this.children = ImmutableList.of(column);\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      column.setPageSource(pageStore.getPageReader(desc));\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n  }\n\n  public static class UnboxedReader<T> extends PrimitiveReader<T> {\n    public UnboxedReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T read(T ignored) {\n      return (T) column.next();\n    }\n\n    public boolean readBoolean() {\n      return column.nextBoolean();\n    }\n\n    public int readInteger() {\n      return column.nextInteger();\n    }\n\n    public long readLong() {\n      return column.nextLong();\n    }\n\n    public float readFloat() {\n      return column.nextFloat();\n    }\n\n    public double readDouble() {\n      return column.nextDouble();\n    }\n\n    public Binary readBinary() {\n      return column.nextBinary();\n    }\n  }\n\n  public static class StringReader extends PrimitiveReader<String> {\n    public StringReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public String read(String reuse) {\n      return column.nextBinary().toStringUsingUTF8();\n    }\n  }\n\n  public static class IntAsLongReader extends UnboxedReader<Long> {\n    public IntAsLongReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public Long read(Long ignored) {\n      return readLong();\n    }\n\n    @Override\n    public long readLong() {\n      return super.readInteger();\n    }\n  }\n\n  public static class FloatAsDoubleReader extends UnboxedReader<Double> {\n    public FloatAsDoubleReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public Double read(Double ignored) {\n      return readDouble();\n    }\n\n    @Override\n    public double readDouble() {\n      return super.readFloat();\n    }\n  }\n\n  public static class IntegerAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private final int scale;\n\n    public IntegerAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal ignored) {\n      return new BigDecimal(BigInteger.valueOf(column.nextInteger()), scale);\n    }\n  }\n\n  public static class LongAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private final int scale;\n\n    public LongAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal ignored) {\n      return new BigDecimal(BigInteger.valueOf(column.nextLong()), scale);\n    }\n  }\n\n  public static class BinaryAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private int scale;\n\n    public BinaryAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal reuse) {\n      byte[] bytes = column.nextBinary().getBytesUnsafe();\n      return new BigDecimal(new BigInteger(bytes), scale);\n    }\n  }\n\n  public static class BytesReader extends PrimitiveReader<ByteBuffer> {\n    public BytesReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public ByteBuffer read(ByteBuffer reuse) {\n      Binary binary = column.nextBinary();\n      ByteBuffer data = binary.toByteBuffer();\n      if (reuse != null && reuse.hasArray() && reuse.capacity() >= data.remaining()) {\n        data.get(reuse.array(), reuse.arrayOffset(), data.remaining());\n        reuse.position(0);\n        reuse.limit(data.remaining());\n        return reuse;\n      } else {\n        byte[] array = new byte[data.remaining()];\n        data.get(array, 0, data.remaining());\n        return ByteBuffer.wrap(array);\n      }\n    }\n  }\n\n  private static class OptionReader<T> implements ParquetValueReader<T> {\n    private final int definitionLevel;\n    private final ParquetValueReader<T> reader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    OptionReader(int definitionLevel, ParquetValueReader<T> reader) {\n      this.definitionLevel = definitionLevel;\n      this.reader = reader;\n      this.column = reader.column();\n      this.children = reader.columns();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      reader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public T read(T reuse) {\n      if (column.currentDefinitionLevel() > definitionLevel) {\n        return reader.read(reuse);\n      }\n\n      for (TripleIterator<?> column : children) {\n        column.nextNull();\n      }\n\n      return null;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n  }\n\n  public abstract static class RepeatedReader<T, I, E> implements ParquetValueReader<T> {\n    private final int definitionLevel;\n    private final int repetitionLevel;\n    private final ParquetValueReader<E> reader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected RepeatedReader(int definitionLevel, int repetitionLevel, ParquetValueReader<E> reader) {\n      this.definitionLevel = definitionLevel;\n      this.repetitionLevel = repetitionLevel;\n      this.reader = reader;\n      this.column = reader.column();\n      this.children = reader.columns();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      reader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public T read(T reuse) {\n      I intermediate = newListData(reuse);\n\n      do {\n        if (column.currentDefinitionLevel() > definitionLevel) {\n          addElement(intermediate, reader.read(getElement(intermediate)));\n        } else {\n\n          for (TripleIterator<?> column : children) {\n            column.nextNull();\n          }\n\n\n          break;\n        }\n      } while (column.currentRepetitionLevel() > repetitionLevel);\n\n      return buildList(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    protected abstract I newListData(T reuse);\n\n    protected abstract E getElement(I list);\n\n    protected abstract void addElement(I list, E element);\n\n    protected abstract T buildList(I list);\n  }\n\n  public static class ListReader<E> extends RepeatedReader<List<E>, List<E>, E> {\n    private List<E> lastList = null;\n    private Iterator<E> elements = null;\n\n    public ListReader(int definitionLevel, int repetitionLevel,\n                      ParquetValueReader<E> reader) {\n      super(definitionLevel, repetitionLevel, reader);\n    }\n\n    @Override\n    protected List<E> newListData(List<E> reuse) {\n      List<E> list;\n      if (lastList != null) {\n        lastList.clear();\n        list = lastList;\n      } else {\n        list = Lists.newArrayList();\n      }\n\n      if (reuse != null) {\n        this.lastList = reuse;\n        this.elements = reuse.iterator();\n      } else {\n        this.lastList = null;\n        this.elements = emptyIterator();\n      }\n\n      return list;\n    }\n\n    @Override\n    protected E getElement(List<E> reuse) {\n      if (elements.hasNext()) {\n        return elements.next();\n      }\n\n      return null;\n    }\n\n    @Override\n    protected void addElement(List<E> list, E element) {\n      list.add(element);\n    }\n\n    @Override\n    protected List<E> buildList(List<E> list) {\n      return list;\n    }\n  }\n\n  public abstract static class RepeatedKeyValueReader<M, I, K, V> implements ParquetValueReader<M> {\n    private final int definitionLevel;\n    private final int repetitionLevel;\n    private final ParquetValueReader<K> keyReader;\n    private final ParquetValueReader<V> valueReader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected RepeatedKeyValueReader(int definitionLevel, int repetitionLevel,\n                           ParquetValueReader<K> keyReader, ParquetValueReader<V> valueReader) {\n      this.definitionLevel = definitionLevel;\n      this.repetitionLevel = repetitionLevel;\n      this.keyReader = keyReader;\n      this.valueReader = valueReader;\n      this.column = keyReader.column();\n      this.children = ImmutableList.<TripleIterator<?>>builder()\n          .addAll(keyReader.columns())\n          .addAll(valueReader.columns())\n          .build();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      keyReader.setPageSource(pageStore);\n      valueReader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public M read(M reuse) {\n      I intermediate = newMapData(reuse);\n\n      do {\n        if (column.currentDefinitionLevel() > definitionLevel) {\n          Map.Entry<K, V> pair = getPair(intermediate);\n          addPair(intermediate, keyReader.read(pair.getKey()), valueReader.read(pair.getValue()));\n        } else {\n\n          for (TripleIterator<?> column : children) {\n            column.nextNull();\n          }\n\n\n          break;\n        }\n      } while (column.currentRepetitionLevel() > repetitionLevel);\n\n      return buildMap(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    protected abstract I newMapData(M reuse);\n\n    protected abstract Map.Entry<K, V> getPair(I map);\n\n    protected abstract void addPair(I map, K key, V value);\n\n    protected abstract M buildMap(I map);\n  }\n\n  public static class MapReader<K, V> extends RepeatedKeyValueReader<Map<K, V>, Map<K, V>, K, V> {\n    private final ReusableEntry<K, V> nullEntry = new ReusableEntry<>();\n    private Map<K, V> lastMap = null;\n    private Iterator<Map.Entry<K, V>> pairs = null;\n\n    public MapReader(int definitionLevel, int repetitionLevel,\n                     ParquetValueReader<K> keyReader,\n                     ParquetValueReader<V> valueReader) {\n      super(definitionLevel, repetitionLevel, keyReader, valueReader);\n    }\n\n    @Override\n    protected Map<K, V> newMapData(Map<K, V> reuse) {\n      Map<K, V> map;\n      if (lastMap != null) {\n        lastMap.clear();\n        map = lastMap;\n      } else {\n        map = Maps.newLinkedHashMap();\n      }\n\n      if (reuse != null) {\n        this.lastMap = reuse;\n        this.pairs = reuse.entrySet().iterator();\n      } else {\n        this.lastMap = null;\n        this.pairs = emptyIterator();\n      }\n\n      return map;\n    }\n\n    @Override\n    protected Map.Entry<K, V> getPair(Map<K, V> map) {\n      if (pairs.hasNext()) {\n        return pairs.next();\n      } else {\n        return nullEntry;\n      }\n    }\n\n    @Override\n    protected void addPair(Map<K, V> map, K key, V value) {\n      map.put(key, value);\n    }\n\n    @Override\n    protected Map<K, V> buildMap(Map<K, V> map) {\n      return map;\n    }\n  }\n\n  public static class ReusableEntry<K, V> implements Map.Entry<K, V> {\n    private K key = null;\n    private V value = null;\n\n    public void set(K key, V value) {\n      this.key = key;\n      this.value = value;\n    }\n\n    @Override\n    public K getKey() {\n      return key;\n    }\n\n    @Override\n    public V getValue() {\n      return value;\n    }\n\n    @Override\n    public V setValue(V value) {\n      V lastValue = this.value;\n      this.value = value;\n      return lastValue;\n    }\n  }\n\n  public abstract static class StructReader<T, I> implements ParquetValueReader<T> {\n    private interface Setter<R> {\n      void set(R record, int pos, Object reuse);\n    }\n\n    private final ParquetValueReader<?>[] readers;\n    private final TripleIterator<?> column;\n    private final TripleIterator<?>[] columns;\n    private final Setter<I>[] setters;\n    private final List<TripleIterator<?>> children;\n\n    @SuppressWarnings(\"unchecked\")\n    protected StructReader(List<Type> types, List<ParquetValueReader<?>> readers) {\n      this.readers = (ParquetValueReader<?>[]) Array.newInstance(\n          ParquetValueReader.class, readers.size());\n      this.columns = (TripleIterator<?>[]) Array.newInstance(TripleIterator.class, readers.size());\n      this.setters = (Setter<I>[]) Array.newInstance(Setter.class, readers.size());\n\n      ImmutableList.Builder<TripleIterator<?>> columnsBuilder = ImmutableList.builder();\n      for (int i = 0; i < readers.size(); i += 1) {\n        ParquetValueReader<?> reader = readers.get(i);\n        this.readers[i] = readers.get(i);\n        this.columns[i] = reader.column();\n        this.setters[i] = newSetter(reader, types.get(i));\n        columnsBuilder.addAll(reader.columns());\n      }\n\n      this.children = columnsBuilder.build();\n      if (children.size() > 0) {\n        this.column = children.get(0);\n      } else {\n        this.column = NullReader.NULL_COLUMN;\n      }\n    }\n\n    @Override\n    public final void setPageSource(PageReadStore pageStore) {\n      for (int i = 0; i < readers.length; i += 1) {\n        readers[i].setPageSource(pageStore);\n      }\n    }\n\n    @Override\n    public final TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public final T read(T reuse) {\n      I intermediate = newStructData(reuse);\n\n      for (int i = 0; i < readers.length; i += 1) {\n        set(intermediate, i, readers[i].read(get(intermediate, i)));\n\n      }\n\n      return buildStruct(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <E> Setter<I> newSetter(ParquetValueReader<E> reader, Type type) {\n      if (reader instanceof UnboxedReader && type.isPrimitive()) {\n        UnboxedReader<?> unboxed  = (UnboxedReader<?>) reader;\n        switch (type.asPrimitiveType().getPrimitiveTypeName()) {\n          case BOOLEAN:\n            return (record, pos, ignored) -> setBoolean(record, pos, unboxed.readBoolean());\n          case INT32:\n            return (record, pos, ignored) -> setInteger(record, pos, unboxed.readInteger());\n          case INT64:\n            return (record, pos, ignored) -> setLong(record, pos, unboxed.readLong());\n          case FLOAT:\n            return (record, pos, ignored) -> setFloat(record, pos, unboxed.readFloat());\n          case DOUBLE:\n            return (record, pos, ignored) -> setDouble(record, pos, unboxed.readDouble());\n          case FIXED_LEN_BYTE_ARRAY:\n          case BINARY:\n            return (record, pos, ignored) -> set(record, pos, unboxed.readBinary());\n          default:\n            throw new UnsupportedOperationException(\"Unsupported type: \" + type);\n        }\n      }\n\n\n      return (record, pos, reuse) -> {\n        Object obj = reader.read((E) reuse);\n        if (obj != null) {\n          set(record, pos, obj);\n        } else {\n          setNull(record, pos);\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <E> E get(I intermediate, int pos) {\n      return (E) getField(intermediate, pos);\n    }\n\n    protected abstract I newStructData(T reuse);\n\n    protected abstract Object getField(I intermediate, int pos);\n\n    protected abstract T buildStruct(I struct);\n\n\n    protected abstract void set(I struct, int pos, Object value);\n\n    protected void setNull(I struct, int pos) {\n      set(struct, pos, null);\n    }\n\n    protected void setBoolean(I struct, int pos, boolean value) {\n      set(struct, pos, value);\n    }\n\n    protected void setInteger(I struct, int pos, int value) {\n      set(struct, pos, value);\n    }\n\n    protected void setLong(I struct, int pos, long value) {\n      set(struct, pos, value);\n    }\n\n    protected void setFloat(I struct, int pos, float value) {\n      set(struct, pos, value);\n    }\n\n    protected void setDouble(I struct, int pos, double value) {\n      set(struct, pos, value);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/PruneColumns.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/avro/PruneColumns.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getElementId;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getFieldId;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getKeyId;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getValueId;\n\nclass PruneColumns extends AvroSchemaVisitor<Schema> {\n  private final Set<Integer> selectedIds;\n\n  PruneColumns(Set<Integer> selectedIds) {\n    this.selectedIds = selectedIds;\n  }\n\n  public Schema rootSchema(Schema record) {\n    Schema result = visit(record, this);\n    if (result != null) {\n      return result;\n    }\n\n    return copyRecord(record, ImmutableList.of());\n  }\n\n  @Override\n  public Schema record(Schema record, List<String> names, List<Schema> fields) {\n\n    List<Schema.Field> filteredFields = Lists.newArrayListWithExpectedSize(fields.size());\n    boolean hasChange = false;\n    for (Schema.Field field : record.getFields()) {\n      int fieldId = getFieldId(field);\n      Schema fieldSchema = fields.get(field.pos());\n\n\n\n\n\n\n      if (selectedIds.contains(fieldId)) {\n        filteredFields.add(copyField(field, field.schema()));\n      } else if (fieldSchema != null) {\n        hasChange = true;\n        filteredFields.add(copyField(field, fieldSchema));\n      }\n    }\n\n    if (hasChange) {\n      return copyRecord(record, filteredFields);\n    } else if (filteredFields.size() == record.getFields().size()) {\n      return record;\n    } else if (!filteredFields.isEmpty()) {\n      return copyRecord(record, filteredFields);\n    }\n\n    return null;\n  }\n\n  @Override\n  public Schema union(Schema union, List<Schema> options) {\n    Preconditions.checkState(AvroSchemaUtil.isOptionSchema(union),\n        \"Invalid schema: non-option unions are not supported: {}\", union);\n\n\n    Schema pruned = null;\n    if (options.get(0) != null) {\n      pruned = options.get(0);\n    } else if (options.get(1) != null) {\n      pruned = options.get(1);\n    }\n\n    if (pruned != null) {\n      if (pruned != AvroSchemaUtil.fromOption(union)) {\n        return AvroSchemaUtil.toOption(pruned);\n      }\n      return union;\n    }\n\n    return null;\n  }\n\n  @Override\n  public Schema array(Schema array, Schema element) {\n    if (array.getLogicalType() instanceof LogicalMap) {\n      Schema keyValue = array.getElementType();\n      int keyId = getFieldId(keyValue.getField(\"key\"));\n      int valueId = getFieldId(keyValue.getField(\"value\"));\n\n\n      if (selectedIds.contains(keyId) || selectedIds.contains(valueId)) {\n        return array;\n      } else if (element != null) {\n        if (keyValue.getField(\"value\").schema() != element.getField(\"value\").schema()) {\n\n          return AvroSchemaUtil.createMap(\n              keyId, keyValue.getField(\"key\").schema(),\n              valueId, element.getField(\"value\").schema());\n        } else {\n          return array;\n        }\n      }\n\n    } else {\n      int elementId = getElementId(array);\n      if (selectedIds.contains(elementId)) {\n        return array;\n      } else if (element != null) {\n        if (element != array.getElementType()) {\n\n          return Schema.createArray(element);\n        }\n        return array;\n      }\n    }\n\n    return null;\n  }\n\n  @Override\n  public Schema map(Schema map, Schema value) {\n    int keyId = getKeyId(map);\n    int valueId = getValueId(map);\n\n    if (selectedIds.contains(keyId) || selectedIds.contains(valueId)) {\n      return map;\n    } else if (value != null) {\n      if (value != map.getValueType()) {\n\n        return Schema.createMap(value);\n      }\n      return map;\n    }\n\n    return null;\n  }\n\n  @Override\n  public Schema primitive(Schema primitive) {\n\n    return null;\n  }\n\n  private static Schema copyRecord(Schema record, List<Schema.Field> newFields) {\n    Schema copy = Schema.createRecord(record.getName(),\n        record.getDoc(), record.getNamespace(), record.isError(), newFields);\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  private static Schema.Field copyField(Schema.Field field, Schema newSchema) {\n    Schema.Field copy = new Schema.Field(field.name(),\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\nimport static org.apache.avro.Schema.Type.MAP;\nimport static org.apache.avro.Schema.Type.RECORD;\nimport static org.apache.avro.Schema.Type.UNION;\n\npublic class AvroSchemaUtil {\n  public static final String FIELD_ID_PROP = \"field-id\";\n  public static final String KEY_ID_PROP = \"key-id\";\n  public static final String VALUE_ID_PROP = \"value-id\";\n  public static final String ELEMENT_ID_PROP = \"element-id\";\n  public static final String ADJUST_TO_UTC_PROP = \"adjust-to-utc\";\n\n  private static final Schema NULL = Schema.create(Schema.Type.NULL);\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               String tableName) {\n    return convert(schema, ImmutableMap.of(schema.asStruct(), tableName));\n  }\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               Map<Types.StructType, String> names) {\n    return TypeUtil.visit(schema, new TypeToSchema(names));\n  }\n\n  public static Schema convert(Type type) {\n    return convert(type, ImmutableMap.of());\n  }\n\n  public static Schema convert(Types.StructType type, String name) {\n    return convert(type, ImmutableMap.of(type, name));\n  }\n\n  public static Schema convert(Type type, Map<Types.StructType, String> names) {\n    return TypeUtil.visit(type, new TypeToSchema(names));\n  }\n\n  public static Type convert(Schema schema) {\n    return AvroSchemaVisitor.visit(schema, new SchemaToType(schema));\n  }\n\n  public static Map<Type, Schema> convertTypes(Types.StructType type, String name) {\n    TypeToSchema converter = new TypeToSchema(ImmutableMap.of(type, name));\n    TypeUtil.visit(type, converter);\n    return ImmutableMap.copyOf(converter.getConversionMap());\n  }\n\n  public static Schema pruneColumns(Schema schema, Set<Integer> selectedIds) {\n    return new PruneColumns(selectedIds).rootSchema(schema);\n  }\n\n  public static Schema buildAvroProjection(Schema schema, com.netflix.iceberg.Schema expected,\n                                           Map<String, String> renames) {\n    return AvroCustomOrderSchemaVisitor.visit(schema, new BuildAvroProjection(expected, renames));\n  }\n\n  public static boolean isTimestamptz(Schema schema) {\n    LogicalType logicalType = schema.getLogicalType();\n    if (logicalType != null && logicalType instanceof LogicalTypes.TimestampMicros) {\n\n      Object value = schema.getObjectProp(ADJUST_TO_UTC_PROP);\n      if (value instanceof Boolean) {\n        return (Boolean) value;\n      } else if (value instanceof String) {\n        return Boolean.parseBoolean((String) value);\n      }\n    }\n\n    return false;\n  }\n\n  static boolean isOptionSchema(Schema schema) {\n    if (schema.getType() == UNION && schema.getTypes().size() == 2) {\n      if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return true;\n      } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Schema toOption(Schema schema) {\n    if (schema.getType() == UNION) {\n      Preconditions.checkArgument(isOptionSchema(schema),\n          \"Union schemas are not supported: \" + schema);\n      return schema;\n    } else {\n      return Schema.createUnion(NULL, schema);\n    }\n  }\n\n  static Schema fromOption(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == UNION,\n        \"Expected union schema but was passed: {}\", schema);\n    Preconditions.checkArgument(schema.getTypes().size() == 2,\n        \"Expected optional schema, but was passed: {}\", schema);\n    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n      return schema.getTypes().get(1);\n    } else {\n      return schema.getTypes().get(0);\n    }\n  }\n\n  static Schema fromOptions(List<Schema> options) {\n    Preconditions.checkArgument(options.size() == 2,\n        \"Expected two schemas, but was passed: {} options\", options.size());\n    if (options.get(0).getType() == Schema.Type.NULL) {\n      return options.get(1);\n    } else {\n      return options.get(0);\n    }\n  }\n\n  static boolean isKeyValueSchema(Schema schema) {\n    return (schema.getType() == RECORD && schema.getFields().size() == 2);\n  }\n\n  static Schema createMap(int keyId, Schema keySchema,\n                          int valueId, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n\n    return LogicalMap.get().addToSchema(Schema.createArray(Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField))));\n  }\n\n  static Schema createProjectionMap(String recordName,\n                          int keyId, String keyName, Schema keySchema,\n                          int valueId, String valueName, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    if (!\"key\".equals(keyName)) {\n      keyField.addAlias(keyName);\n    }\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n    if (!\"value\".equals(valueName)) {\n      valueField.addAlias(valueName);\n    }\n\n    Schema keyValueRecord = Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField));\n    if (!keyValueName.equals(recordName)) {\n      keyValueRecord.addAlias(recordName);\n    }\n\n    return LogicalMap.get().addToSchema(Schema.createArray(keyValueRecord));\n  }\n\n  private static int getId(Schema schema, String propertyName) {\n    if (schema.getType() == UNION) {\n      return getId(fromOption(schema), propertyName);\n    }\n\n    Object id = schema.getObjectProp(propertyName);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", propertyName);\n\n    return toInt(id);\n  }\n\n  public static int getKeyId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map key id for non-map schema: \" + schema);\n    return getId(schema, KEY_ID_PROP);\n  }\n\n  public static int getValueId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map value id for non-map schema: \" + schema);\n    return getId(schema, VALUE_ID_PROP);\n  }\n\n  public static int getElementId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Cannot get array element id for non-array schema: \" + schema);\n    return getId(schema, ELEMENT_ID_PROP);\n  }\n\n  public static int getFieldId(Schema.Field field) {\n    Object id = field.getObjectProp(FIELD_ID_PROP);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", FIELD_ID_PROP);\n\n    return toInt(id);\n  }\n\n  private static int toInt(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).intValue();\n    } else if (value instanceof String) {\n      return Integer.parseInt((String) value);\n    }\n\n    throw new UnsupportedOperationException(\"Cannot coerce value to int: \" + value);\n  }\n\n  static Schema copyRecord(Schema record, List<Schema.Field> newFields, String newName) {\n    Schema copy;\n    if (newName != null) {\n      copy = Schema.createRecord(newName, record.getDoc(), null, record.isError(), newFields);\n\n\n\n      copy.addAlias(record.getName(), record.getNamespace() == null ? \"\" : record.getNamespace());\n    } else {\n      copy = Schema.createRecord(record.getName(),\n          record.getDoc(), record.getNamespace(), record.isError(), newFields);\n    }\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  static Schema.Field copyField(Schema.Field field, Schema newSchema, String newName) {\n    Schema.Field copy = new Schema.Field(newName,\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    if (!newName.equals(field.name())) {\n      copy.addAlias(field.name());\n    }\n\n    return copy;\n  }\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.toOption;\nimport static org.apache.avro.JsonProperties.NULL_VALUE;\n\nclass TypeToSchema extends TypeUtil.SchemaVisitor<Schema> {\n  private static final Schema BOOLEAN_SCHEMA = Schema.create(Schema.Type.BOOLEAN);\n  private static final Schema INTEGER_SCHEMA = Schema.create(Schema.Type.INT);\n  private static final Schema LONG_SCHEMA = Schema.create(Schema.Type.LONG);\n  private static final Schema FLOAT_SCHEMA = Schema.create(Schema.Type.FLOAT);\n  private static final Schema DOUBLE_SCHEMA = Schema.create(Schema.Type.DOUBLE);\n  private static final Schema DATE_SCHEMA = LogicalTypes.date()\n      .addToSchema(Schema.create(Schema.Type.INT));\n  private static final Schema TIME_SCHEMA = LogicalTypes.timeMicros()\n      .addToSchema(Schema.create(Schema.Type.LONG));\n  private static final Schema TIMESTAMP_SCHEMA = LogicalTypes.timestampMicros()\n      .addToSchema(Schema.create(Schema.Type.LONG));\n  private static final Schema TIMESTAMPTZ_SCHEMA = LogicalTypes.timestampMicros()\n      .addToSchema(Schema.create(Schema.Type.LONG));\n  private static final Schema STRING_SCHEMA = Schema.create(Schema.Type.STRING);\n  private static final Schema UUID_SCHEMA = LogicalTypes.uuid()\n      .addToSchema(Schema.createFixed(\"uuid_fixed\", null, null, 16));\n  private static final Schema BINARY_SCHEMA = Schema.create(Schema.Type.BYTES);\n\n  static {\n    TIMESTAMP_SCHEMA.addProp(AvroSchemaUtil.ADJUST_TO_UTC_PROP, false);\n    TIMESTAMPTZ_SCHEMA.addProp(AvroSchemaUtil.ADJUST_TO_UTC_PROP, true);\n  }\n\n  private final Map<Type, Schema> results = Maps.newHashMap();\n  private final Map<Types.StructType, String> names;\n\n  TypeToSchema(Map<Types.StructType, String> names) {\n    this.names = names;\n  }\n\n  Map<Type, Schema> getConversionMap() {\n    return results;\n  }\n\n  @Override\n  public Schema schema(com.netflix.iceberg.Schema schema, Schema structSchema) {\n    return structSchema;\n  }\n\n  @Override\n  public Schema struct(Types.StructType struct, List<Schema> fieldSchemas) {\n    Schema recordSchema = results.get(struct);\n    if (recordSchema != null) {\n      return recordSchema;\n    }\n\n    String recordName = names.get(struct);\n    if (recordName == null) {\n      recordName = \"r\" + fieldIds.peek();\n    }\n\n    List<Types.NestedField> structFields = struct.fields();\n    List<Schema.Field> fields = Lists.newArrayListWithExpectedSize(fieldSchemas.size());\n    for (int i = 0; i < structFields.size(); i += 1) {\n      Types.NestedField structField = structFields.get(i);\n      Schema.Field field = new Schema.Field(\n          structField.name(), fieldSchemas.get(i), null,\n          structField.isOptional() ? NULL_VALUE : null);\n      field.addProp(AvroSchemaUtil.FIELD_ID_PROP, structField.fieldId());\n      fields.add(field);\n    }\n\n    recordSchema = Schema.createRecord(recordName, null, null, false, fields);\n\n    results.put(struct, recordSchema);\n\n    return recordSchema;\n  }\n\n  @Override\n  public Schema field(Types.NestedField field, Schema fieldSchema) {\n    if (field.isOptional()) {\n      return toOption(fieldSchema);\n    } else {\n      return fieldSchema;\n    }\n  }\n\n  @Override\n  public Schema list(Types.ListType list, Schema elementSchema) {\n    Schema listSchema = results.get(list);\n    if (listSchema != null) {\n      return listSchema;\n    }\n\n    if (list.isElementOptional()) {\n      listSchema = Schema.createArray(toOption(elementSchema));\n    } else {\n      listSchema = Schema.createArray(elementSchema);\n    }\n\n    listSchema.addProp(AvroSchemaUtil.ELEMENT_ID_PROP, list.elementId());\n\n    results.put(list, listSchema);\n\n    return listSchema;\n  }\n\n  @Override\n  public Schema map(Types.MapType map, Schema keySchema, Schema valueSchema) {\n    Schema mapSchema = results.get(map);\n    if (mapSchema != null) {\n      return mapSchema;\n    }\n\n    if (keySchema.getType() == Schema.Type.STRING) {\n\n      mapSchema = Schema.createMap(\n          map.isValueOptional() ? toOption(valueSchema) : valueSchema);\n      mapSchema.addProp(AvroSchemaUtil.KEY_ID_PROP, map.keyId());\n      mapSchema.addProp(AvroSchemaUtil.VALUE_ID_PROP, map.valueId());\n\n    } else {\n      mapSchema = AvroSchemaUtil.createMap(map.keyId(), keySchema,\n          map.valueId(), map.isValueOptional() ? toOption(valueSchema) : valueSchema);\n    }\n\n    results.put(map, mapSchema);\n\n    return mapSchema;\n  }\n\n  @Override\n  public Schema primitive(Type.PrimitiveType primitive) {\n    Schema primitiveSchema;\n    switch (primitive.typeId()) {\n      case BOOLEAN:\n        primitiveSchema = BOOLEAN_SCHEMA;\n        break;\n      case INTEGER:\n        primitiveSchema = INTEGER_SCHEMA;\n        break;\n      case LONG:\n        primitiveSchema = LONG_SCHEMA;\n        break;\n      case FLOAT:\n        primitiveSchema = FLOAT_SCHEMA;\n        break;\n      case DOUBLE:\n        primitiveSchema = DOUBLE_SCHEMA;\n        break;\n      case DATE:\n        primitiveSchema = DATE_SCHEMA;\n        break;\n      case TIME:\n        primitiveSchema = TIME_SCHEMA;\n        break;\n      case TIMESTAMP:\n        if (((Types.TimestampType) primitive).shouldAdjustToUTC()) {\n          primitiveSchema = TIMESTAMPTZ_SCHEMA;\n        } else {\n          primitiveSchema = TIMESTAMP_SCHEMA;\n        }\n        break;\n      case STRING:\n        primitiveSchema = STRING_SCHEMA;\n        break;\n      case UUID:\n        primitiveSchema = UUID_SCHEMA;\n        break;\n      case FIXED:\n        Types.FixedType fixed = (Types.FixedType) primitive;\n        primitiveSchema = Schema.createFixed(\"fixed_\" + fixed.length(), null, null, fixed.length());\n        break;\n      case BINARY:\n        primitiveSchema = BINARY_SCHEMA;\n        break;\n      case DECIMAL:\n        Types.DecimalType decimal = (Types.DecimalType) primitive;\n        primitiveSchema = LogicalTypes.decimal(decimal.precision(), decimal.scale())\n            .addToSchema(Schema.createFixed(\n                \"decimal_\" + decimal.precision() + \"_\" + decimal.scale(),\n                null, null, TypeUtil.decimalRequriedBytes(decimal.precision())));\n        break;\n      default:\n        throw new UnsupportedOperationException(\n            \"Unsupported type ID: \" + primitive.typeId());\n    }\n\n    results.put(primitive, primitiveSchema);\n\n    return primitiveSchema;\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/TypeToSchema.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/PruneColumns.java'"
        ]
    },
    {
        "files": [
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/RemoteCodes.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/ExecutionControlForwarder.java'"
        ],
        "content": "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'\n:\npackage jdk.jshell.execution;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport jdk.jshell.JShellException;\nimport jdk.jshell.spi.ExecutionControl;\nimport static jdk.jshell.execution.ExecutionControlForwarder.NULL_MARKER;\nimport static jdk.jshell.execution.RemoteCodes.*;\n\n\npublic class StreamingExecutionControl implements ExecutionControl {\n\n    private final ObjectOutput out;\n    private final ObjectInput in;\n\n\n    public StreamingExecutionControl(ObjectOutput out, ObjectInput in) {\n        this.out = out;\n        this.in = in;\n    }\n\n    @Override\n    public void load(ClassBytecodes[] cbcs)\n            throws ClassInstallException, NotImplementedException, EngineTerminationException {\n        try {\n\n            writeCommand(CMD_LOAD);\n            out.writeObject(cbcs);\n            out.flush();\n\n            readAndReportClassInstallResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote load: \" + ex);\n        }\n    }\n\n    @Override\n    public void redefine(ClassBytecodes[] cbcs)\n            throws ClassInstallException, NotImplementedException, EngineTerminationException {\n        try {\n\n            writeCommand(CMD_REDEFINE);\n            out.writeObject(cbcs);\n            out.flush();\n\n            readAndReportClassInstallResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote redefine: \" + ex);\n        }\n    }\n\n    @Override\n    public String invoke(String classname, String methodname)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_INVOKE);\n            out.writeUTF(classname);\n            out.writeUTF(methodname);\n            out.flush();\n\n            readAndReportExecutionResult();\n            String result = in.readUTF();\n            return result;\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote invoke: \" + ex);\n        }\n    }\n\n    @Override\n    public String varValue(String classname, String varname)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_VAR_VALUE);\n            out.writeUTF(classname);\n            out.writeUTF(varname);\n            out.flush();\n\n            readAndReportExecutionResult();\n            String result = in.readUTF();\n            return result;\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote varValue: \" + ex);\n        }\n    }\n\n\n    @Override\n    public void addToClasspath(String path)\n            throws EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_ADD_CLASSPATH);\n            out.writeUTF(path);\n            out.flush();\n\n            readAndReportClassSimpleResult();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote add to classpath: \" + ex);\n        }\n    }\n\n    @Override\n    public void stop()\n            throws EngineTerminationException, InternalException {\n        try {\n\n            writeCommand(CMD_STOP);\n            out.flush();\n        } catch (IOException ex) {\n            throw new EngineTerminationException(\"Exception writing remote stop: \" + ex);\n        }\n    }\n\n    @Override\n    public Object extensionCommand(String command, Object arg)\n            throws RunException, EngineTerminationException, InternalException {\n        try {\n            writeCommand(command);\n            out.writeObject(arg);\n            out.flush();\n\n            readAndReportExecutionResult();\n            Object result = in.readObject();\n            return result;\n        } catch (IOException | ClassNotFoundException ex) {\n            throw new EngineTerminationException(\"Exception transmitting remote extensionCommand: \"\n                    + command + \" -- \" + ex);\n        }\n    }\n\n\n    @Override\n    public void close() {\n        try {\n            writeCommand(CMD_CLOSE);\n            out.flush();\n        } catch (IOException ex) {\n\n        }\n    }\n\n    private void writeCommand(String cmd) throws IOException {\n        out.writeInt(COMMAND_PREFIX);\n        out.writeUTF(cmd);\n    }\n\n\n    private String readNullOrUTF() throws IOException {\n        String s = in.readUTF();\n        return s.equals(NULL_MARKER) ? null : s;\n    }\n\n\n    private void readAndReportClassSimpleResult() throws EngineTerminationException, InternalException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_INTERNAL_PROBLEM: {\n                    String message = in.readUTF();\n                    throw new InternalException(message);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException ex) {\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n\n    private void readAndReportClassInstallResult() throws ClassInstallException,\n            NotImplementedException, EngineTerminationException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_CLASS_INSTALL_EXCEPTION: {\n                    String message = in.readUTF();\n                    boolean[] loaded = (boolean[]) in.readObject();\n                    throw new ClassInstallException(message, loaded);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException | ClassNotFoundException ex) {\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n\n    private void readAndReportExecutionResult() throws RunException,\n            EngineTerminationException, InternalException {\n        try {\n            int status = in.readInt();\n            switch (status) {\n                case RESULT_SUCCESS:\n                    return;\n                case RESULT_NOT_IMPLEMENTED: {\n                    String message = in.readUTF();\n                    throw new NotImplementedException(message);\n                }\n                case RESULT_USER_EXCEPTION: {\n\n                    throw readUserException();\n                }\n                case RESULT_CORRALLED: {\n\n                    throw readResolutionException();\n                }\n                case RESULT_USER_EXCEPTION_CHAINED: {\n\n                    in.readInt();\n                    UserException result = readUserException();\n                    RunException caused = result;\n\n                    loop: while (true) {\n                        RunException ex;\n                        int cstatus = in.readInt();\n                        switch (cstatus) {\n                            case RESULT_USER_EXCEPTION: {\n\n                                ex = readUserException();\n                                break;\n                            }\n                            case RESULT_CORRALLED: {\n\n                                ex = readResolutionException();\n                                break;\n                            }\n                            case RESULT_SUCCESS: {\n\n                                break loop;\n                            }\n                            default: {\n                                throw new EngineTerminationException(\"Bad chained remote result code: \" + cstatus);\n                            }\n                        }\n                        caused.initCause(ex);\n                        caused = ex;\n                    }\n                    caused.initCause(null);\n                    throw result;\n                }\n                case RESULT_STOPPED: {\n\n                    throw new StoppedException();\n                }\n                case RESULT_INTERNAL_PROBLEM: {\n\n                    String message = in.readUTF();\n                    throw new InternalException(message);\n                }\n                case RESULT_TERMINATED: {\n                    String message = in.readUTF();\n                    throw new EngineTerminationException(message);\n                }\n                default: {\n                    throw new EngineTerminationException(\"Bad remote result code: \" + status);\n                }\n            }\n        } catch (IOException | ClassNotFoundException ex) {\n            ex.printStackTrace();\n            throw new EngineTerminationException(ex.toString());\n        }\n    }\n\n    private UserException readUserException() throws IOException, ClassNotFoundException {\n        String message = readNullOrUTF();\n        String exceptionClassName = in.readUTF();\n        StackTraceElement[] elems = (StackTraceElement[]) in.readObject();\n        return new UserException(message, exceptionClassName, elems);\n    }\n\n    private ResolutionException readResolutionException() throws IOException, ClassNotFoundException {\n        int id = in.readInt();\n        StackTraceElement[] elems = (StackTraceElement[]) in.readObject();\n        return new ResolutionException(id, elems);\n    }\n}\n\n'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/RemoteCodes.java'\n:\n\npackage jdk.jshell.execution;\n\n\nclass RemoteCodes {\n\n\n    static final int COMMAND_PREFIX = 0xC03DC03D;\n\n\n\n\n    static final String CMD_CLOSE          = \"CMD_CLOSE\";\n\n    static final String CMD_LOAD           = \"CMD_LOAD\";\n\n    static final String CMD_REDEFINE       = \"CMD_REDEFINE\";\n\n    static final String CMD_INVOKE         = \"CMD_INVOKE\";\n\n    static final String CMD_VAR_VALUE      = \"CMD_VAR_VALUE\";\n\n    static final String CMD_ADD_CLASSPATH  = \"CMD_ADD_CLASSPATH\";\n\n    static final String CMD_STOP           = \"CMD_STOP\";\n\n\n\n\n    static final int RESULT_SUCCESS                 = 100;\n\n    static final int RESULT_TERMINATED              = 101;\n\n    static final int RESULT_NOT_IMPLEMENTED         = 102;\n\n    static final int RESULT_INTERNAL_PROBLEM        = 103;\n\n    static final int RESULT_USER_EXCEPTION          = 104;\n\n    static final int RESULT_CORRALLED               = 105;\n\n    static final int RESULT_CLASS_INSTALL_EXCEPTION = 106;\n\n    static final int RESULT_STOPPED                 = 107;\n\n    static final int RESULT_USER_EXCEPTION_CHAINED  = 108;\n}\n\n'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/ExecutionControlForwarder.java'\n:\npackage jdk.jshell.execution;\n\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport jdk.jshell.spi.ExecutionControl;\nimport jdk.jshell.spi.ExecutionControl.ClassBytecodes;\nimport jdk.jshell.spi.ExecutionControl.ClassInstallException;\nimport jdk.jshell.spi.ExecutionControl.EngineTerminationException;\nimport jdk.jshell.spi.ExecutionControl.InternalException;\nimport jdk.jshell.spi.ExecutionControl.NotImplementedException;\nimport jdk.jshell.spi.ExecutionControl.ResolutionException;\nimport jdk.jshell.spi.ExecutionControl.StoppedException;\nimport jdk.jshell.spi.ExecutionControl.UserException;\nimport static jdk.jshell.execution.RemoteCodes.*;\n\n\nclass ExecutionControlForwarder {\n\n\n    static final String NULL_MARKER = \"\\u0002*\\u03C0*NULL*\\u03C0*\\u0003\";\n\n\n    private static final int MAX_UTF_CHARS = 21844;\n\n    private final ExecutionControl ec;\n    private final ObjectInput in;\n    private final ObjectOutput out;\n\n    ExecutionControlForwarder(ExecutionControl ec, ObjectInput in, ObjectOutput out) {\n        this.ec = ec;\n        this.in = in;\n        this.out = out;\n    }\n\n    private boolean writeSuccess() throws IOException {\n        writeStatus(RESULT_SUCCESS);\n        flush();\n        return true;\n    }\n\n    private boolean writeSuccessAndResult(String result) throws IOException {\n        writeStatus(RESULT_SUCCESS);\n        writeUTF(result);\n        flush();\n        return true;\n    }\n\n    private boolean writeSuccessAndResult(Object result) throws IOException {\n        writeStatus(RESULT_SUCCESS);\n        writeObject(result);\n        flush();\n        return true;\n    }\n\n    private void writeStatus(int status) throws IOException {\n        out.writeInt(status);\n    }\n\n    private void writeObject(Object o) throws IOException {\n        out.writeObject(o);\n    }\n\n    private void writeInt(int i) throws IOException {\n        out.writeInt(i);\n    }\n\n    private void writeNullOrUTF(String s) throws IOException {\n        writeUTF(s == null ? NULL_MARKER : s);\n    }\n\n    private void writeUTF(String s) throws IOException {\n        if (s == null) {\n            s = \"\";\n        } else if (s.length() > MAX_UTF_CHARS) {\n\n            s = s.substring(0, MAX_UTF_CHARS);\n        }\n        out.writeUTF(s);\n    }\n\n    private void flush() throws IOException {\n        out.flush();\n    }\n\n    private boolean processCommand() throws IOException {\n        try {\n            int prefix = in.readInt();\n            if (prefix != COMMAND_PREFIX) {\n                throw new EngineTerminationException(\"Invalid command prefix: \" + prefix);\n            }\n            String cmd = in.readUTF();\n            switch (cmd) {\n                case CMD_LOAD: {\n\n                    ClassBytecodes[] cbcs = (ClassBytecodes[]) in.readObject();\n                    ec.load(cbcs);\n                    return writeSuccess();\n                }\n                case CMD_REDEFINE: {\n\n                    ClassBytecodes[] cbcs = (ClassBytecodes[]) in.readObject();\n                    ec.redefine(cbcs);\n                    return writeSuccess();\n                }\n                case CMD_INVOKE: {\n\n                    String className = in.readUTF();\n                    String methodName = in.readUTF();\n                    String res = ec.invoke(className, methodName);\n                    return writeSuccessAndResult(res);\n                }\n                case CMD_VAR_VALUE: {\n\n                    String className = in.readUTF();\n                    String varName = in.readUTF();\n                    String res = ec.varValue(className, varName);\n                    return writeSuccessAndResult(res);\n                }\n                case CMD_ADD_CLASSPATH: {\n\n                    String cp = in.readUTF();\n                    ec.addToClasspath(cp);\n                    return writeSuccess();\n                }\n                case CMD_STOP: {\n\n                    try {\n                        ec.stop();\n                    } catch (Throwable ex) {\n\n                    }\n                    return true;\n                }\n                case CMD_CLOSE: {\n\n                    try {\n                        ec.close();\n                    } catch (Throwable ex) {\n\n                    }\n                    return true;\n                }\n                default: {\n                    Object arg = in.readObject();\n                    Object res = ec.extensionCommand(cmd, arg);\n                    return writeSuccessAndResult(res);\n                }\n            }\n        } catch (IOException ex) {\n\n            throw ex;\n        } catch (EngineTerminationException ex) {\n            writeStatus(RESULT_TERMINATED);\n            writeUTF(ex.getMessage());\n            flush();\n            return false;\n        } catch (NotImplementedException ex) {\n            writeStatus(RESULT_NOT_IMPLEMENTED);\n            writeUTF(ex.getMessage());\n            flush();\n            return true;\n        } catch (InternalException ex) {\n            writeInternalException(ex);\n            flush();\n            return true;\n        } catch (ClassInstallException ex) {\n            writeStatus(RESULT_CLASS_INSTALL_EXCEPTION);\n            writeUTF(ex.getMessage());\n            writeObject(ex.installed());\n            flush();\n            return true;\n        } catch (UserException ex) {\n            writeStatus(RESULT_USER_EXCEPTION_CHAINED);\n            for (Throwable e = ex; e != null; ) {\n                if (e instanceof UserException) {\n                    writeUserException((UserException) e);\n                    e = e.getCause();\n                } else if (e instanceof ResolutionException) {\n                    writeResolutionException((ResolutionException) e);\n                    e = null;\n                } else {\n                    writeInternalException(e);\n                    e = null;\n                }\n            }\n            writeStatus(RESULT_SUCCESS);\n            flush();\n            return true;\n        } catch (ResolutionException ex) {\n            writeResolutionException(ex);\n            flush();\n            return true;\n        } catch (StoppedException ex) {\n            writeStatus(RESULT_STOPPED);\n            flush();\n            return true;\n        } catch (Throwable ex) {\n\n            writeStatus(RESULT_TERMINATED);\n            String msg = ex.getMessage();\n            writeUTF(msg == null? ex.toString() : msg);\n            flush();\n            return false;\n        }\n    }\n\n    void writeInternalException(Throwable ex) throws IOException {\n        writeStatus(RESULT_INTERNAL_PROBLEM);\n        writeUTF(ex.getMessage());\n    }\n\n    void writeUserException(UserException ex) throws IOException {\n        writeStatus(RESULT_USER_EXCEPTION);\n        writeNullOrUTF(ex.getMessage());\n        writeUTF(ex.causeExceptionClass());\n        writeObject(ex.getStackTrace());\n    }\n\n    void writeResolutionException(ResolutionException ex) throws IOException {\n        writeStatus(RESULT_CORRALLED);\n        writeInt(ex.id());\n        writeObject(ex.getStackTrace());\n    }\n\n    void commandLoop() {\n        try {\n            while (processCommand()) {\n\n            }\n        } catch (IOException ex) {\n\n        }\n    }\n\n}\n",
        "gt": [
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/RemoteCodes.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/ExecutionControlForwarder.java'",
            "'graalvm-demos/espresso-jshell/jshell8/jdk/jshell/execution/StreamingExecutionControl.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.NonNull;\nimport android.support.graphics.drawable.AnimatedVectorDrawableCompat;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.ImageButton;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\nimport com.philliphsu.bottomsheetpickers.date.MonthPickerView.OnMonthClickListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\n\n\nclass PagingDayPickerView extends LinearLayout implements OnDateChangedListener, OnPageChangeListener, OnMonthClickListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n    static final int DAY_PICKER_INDEX = 0;\n    static final int MONTH_PICKER_INDEX = 1;\n\n    static int MONTH_NAVIGATION_BAR_SIZE;\n\n    private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected PagingMonthAdapter mAdapter;\n\n    private DayPickerViewAnimator mMonthAnimator;\n    private ViewPager mViewPager;\n    private MonthPickerView mMonthPickerView;\n    private TextView mMonthYearTitleView;\n    private ImageButton mPreviousButton;\n    private ImageButton mNextButton;\n    private View mTitleContainer;\n\n\n    private AnimatedVectorDrawableCompat mArrowDownDrawable;\n\n    private AnimatedVectorDrawableCompat mArrowUpDrawable;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mCurrentMonthDisplayed;\n\n    private int mCurrentView = DAY_PICKER_INDEX;\n\n    private int mCurrentYearDisplayed;\n\n    private DatePickerController mController;\n\n    private boolean mThemeDark;\n    private int mAccentColor;\n\n    public PagingDayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        this(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark,\n                               int accentColor) {\n        super(context);\n\n        mThemeDark = themeDark;\n        mAccentColor = accentColor;\n        init(context);\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n        mMonthPickerView.setDatePickerController(mController);\n    }\n\n    private void init(Context context) {\n        mHandler = new Handler();\n        setOrientation(VERTICAL);\n        setLayoutParams(new LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        Resources res = getResources();\n        MONTH_NAVIGATION_BAR_SIZE = res.getDimensionPixelOffset(R.dimen.bsp_month_navigation_bar_height)\n                + res.getDimensionPixelOffset(R.dimen.bsp_month_view_top_padding);\n\n        final View view = LayoutInflater.from(context).inflate(R.layout.bsp_day_picker_content, this, true);\n        mMonthAnimator = (DayPickerViewAnimator) findViewById(R.id.bsp_month_animator);\n        mMonthPickerView = (MonthPickerView) findViewById(R.id.bsp_month_picker);\n        mMonthPickerView.setOnMonthClickListener(this);\n        mViewPager = (ViewPager) findViewById(R.id.bsp_viewpager);\n        mViewPager.addOnPageChangeListener(this);\n        mMonthYearTitleView = (TextView) view.findViewById(R.id.bsp_month_year_title);\n        mTitleContainer = view.findViewById(R.id.bsp_month_year_title_container);\n        mTitleContainer.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int newIndex = mCurrentView == DAY_PICKER_INDEX ? MONTH_PICKER_INDEX : DAY_PICKER_INDEX;\n                setupCurrentView(newIndex, true);\n            }\n        });\n        mPreviousButton = (ImageButton) view.findViewById(R.id.bsp_prev);\n        mPreviousButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int previousItem = mViewPager.getCurrentItem() - 1;\n                if (previousItem >= 0) {\n                    mViewPager.setCurrentItem(previousItem, true);\n                }\n            }\n        });\n        mNextButton = (ImageButton) view.findViewById(R.id.bsp_next);\n        mNextButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int nextItem = mViewPager.getCurrentItem() + 1;\n                if (nextItem < mAdapter.getCount()) {\n                    mViewPager.setCurrentItem(nextItem, true);\n                }\n            }\n        });\n\n        mArrowDownDrawable = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_down);\n        mArrowUpDrawable   = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_up);\n        setArrowDrawableOnTitle(mArrowDownDrawable);\n\n\n        if (mThemeDark) {\n            int selectableItemBg = getColor(context, R.color.bsp_selectable_item_background_dark);\n            Utils.setColorControlHighlight(mPreviousButton, selectableItemBg);\n            Utils.setColorControlHighlight(mNextButton, selectableItemBg);\n            Utils.setColorControlHighlight(mTitleContainer, selectableItemBg);\n            int cursor = getColor(context, R.color.bsp_text_color_secondary_dark);\n            Utils.applyTint(mPreviousButton, cursor);\n            Utils.applyTint(mNextButton, cursor);\n        }\n\n\n        int monthYearTitleColor = getColor(context, mThemeDark?\n                R.color.bsp_text_color_primary_dark : R.color.bsp_text_color_primary_light);\n        int dropdownArrowColor = getColor(context, mThemeDark?\n                R.color.bsp_icon_color_active_dark : R.color.bsp_icon_color_active_light);\n\n        mMonthYearTitleView.setTextColor(monthYearTitleColor);\n        mArrowDownDrawable.setTint(dropdownArrowColor);\n        mArrowUpDrawable.setTint(dropdownArrowColor);\n\n        mMonthPickerView.setTheme(context, mThemeDark);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mViewPager.removeOnPageChangeListener(this);\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    void setAccentColor(@ColorInt int color) {\n        mAccentColor = color;\n        mMonthPickerView.setCurrentMonthTextColor(color);\n        mMonthPickerView.setSelectedCirclePaintColor(color);\n    }\n\n    public void onChange() {\n        refreshAdapter();\n        refreshMonthPicker();\n    }\n\n\n    void setupCurrentView(int currentView, boolean animate) {\n        if (currentView == DAY_PICKER_INDEX || currentView == MONTH_PICKER_INDEX) {\n            boolean isDayPicker = currentView == DAY_PICKER_INDEX;\n            setCurrentView(currentView, animate);\n            if (isDayPicker) {\n                setTitle(mAdapter.getPageTitle(mViewPager.getCurrentItem()));\n                toggleArrowsVisibility(getPagerPosition());\n            } else {\n\n\n\n                setTitle(String.valueOf(mCurrentYearDisplayed));\n                toggleArrowsVisibility(false, false);\n            }\n        } else {\n            Log.e(TAG, \"Error restoring current view\");\n        }\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            if (mAccentColor != 0) {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark, mAccentColor);\n            } else {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n            }\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        mViewPager.setAdapter(mAdapter);\n    }\n\n\n    private void refreshMonthPicker() {\n        prepareMonthPickerForDisplay(mSelectedDay.year);\n        mMonthPickerView.invalidate();\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller) {\n        return new PagingMonthAdapter(context, controller);\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark) {\n        return createMonthAdapter(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark,\n                                                 int accentColor) {\n        return new PagingMonthAdapter(context, controller, themeDark, accentColor);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n        final int selectedPosition = getPosition(mSelectedDay);\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = getPosition(day);\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthAndYearDisplayed(mTempDay);\n            if (animate) {\n                mViewPager.setCurrentItem(position, true);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n                return true;\n            } else {\n                postSetSelection(position, setSelected);\n            }\n        } else if (setSelected) {\n            setMonthAndYearDisplayed(mSelectedDay);\n            setSelectedDay(mSelectedDay);\n        }\n        return false;\n    }\n\n\n    private int getPosition(CalendarDay day) {\n        return mAdapter.getPosition(day);\n    }\n\n    public void postSetSelection(final int position, final boolean setSelected) {\n        clearFocus();\n        post(new Runnable() {\n            @Override\n            public void run() {\n                mViewPager.setCurrentItem(position, false);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n            }\n        });\n    }\n\n    void postSetupCurrentView(final int currentView, final boolean animate) {\n        post(new Runnable() {\n            @Override\n            public void run() {\n                setupCurrentView(currentView, animate);\n            }\n        });\n    }\n\n\n    protected void setMonthAndYearDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        mCurrentYearDisplayed = date.year;\n    }\n\n    private void setSelectedDay(CalendarDay day) {\n        mAdapter.setSelectedDay(day);\n    }\n\n    @Override\n    public void onDateChanged() {\n        if (mCurrentView != DAY_PICKER_INDEX) {\n            setCurrentView(DAY_PICKER_INDEX, false);\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getPagerPosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        return true;\n    }\n\n    int getPagerPosition() {\n        return mViewPager.getCurrentItem();\n    }\n\n    int getCurrentView() {\n        return mCurrentView;\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mCurrentView == DAY_PICKER_INDEX) {\n            setTitle(mAdapter.getPageTitle(position));\n            toggleArrowsVisibility(position);\n            final int month = mAdapter.getMonth(position);\n            final int year = mAdapter.getYear(position);\n            if (mCurrentYearDisplayed != year) {\n                mCurrentYearDisplayed = year;\n            }\n            if (mCurrentMonthDisplayed != month) {\n                mCurrentMonthDisplayed = month;\n            }\n        }\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n\n    private void setTitle(CharSequence title) {\n        mMonthYearTitleView.setText(title);\n    }\n\n\n    private void toggleArrowsVisibility(int position) {\n        toggleArrowsVisibility(position > 0, position + 1 < mAdapter.getCount());\n    }\n\n    private void toggleArrowsVisibility(boolean leftVisible, boolean rightVisible) {\n        mPreviousButton.setVisibility(leftVisible ? VISIBLE : INVISIBLE);\n        mNextButton.setVisibility(rightVisible ? VISIBLE : INVISIBLE);\n    }\n\n    private void setArrowDrawableOnTitle(@NonNull Drawable arrow) {\n        if (Utils.checkApiLevel(17)) {\n            mMonthYearTitleView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, arrow, null);\n        } else {\n            mMonthYearTitleView.setCompoundDrawablesWithIntrinsicBounds(null, null, arrow, null);\n        }\n    }\n\n    private void animateArrow(AnimatedVectorDrawableCompat arrow) {\n        setArrowDrawableOnTitle(arrow);\n        arrow.start();\n    }\n\n    private void setCurrentView(final int viewIndex, boolean animate) {\n        switch (viewIndex) {\n            case DAY_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    mMonthAnimator.setDisplayedChild(DAY_PICKER_INDEX, animate);\n                    animateArrow(mArrowUpDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n            case MONTH_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    prepareMonthPickerForDisplay(mCurrentYearDisplayed);\n                    mMonthAnimator.setDisplayedChild(MONTH_PICKER_INDEX, animate);\n                    animateArrow(mArrowDownDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n        }\n    }\n\n    private void prepareMonthPickerForDisplay(int currentYear) {\n        mMonthPickerView.setDisplayParams(mSelectedDay, currentYear);\n    }\n\n    @Override\n    public void onMonthClick(MonthPickerView view, int month, int year) {\n\n\n\n\n\n        setCurrentView(DAY_PICKER_INDEX, true);\n\n\n\n\n\n\n\n\n\n\n        if (month == mCurrentMonthDisplayed) {\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        mController.tryVibrate();\n        mController.onMonthYearSelected(month, year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestTableMetadataJson.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.base.Objects;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.types.Types.IntegerType;\nimport com.netflix.iceberg.types.Types.LongType;\nimport com.netflix.iceberg.types.Types.StructType;\nimport org.apache.avro.generic.IndexedRecord;\nimport org.apache.avro.specific.SpecificData;\n\nimport java.util.Collection;\n\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\nclass ManifestEntry implements IndexedRecord, SpecificData.SchemaConstructable{\n  enum Status {\n    EXISTING(0),\n    ADDED(1),\n    DELETED(2);\n\n    public static Status[] values = new Status[3];\n    static {\n      for (Status status : Status.values()) {\n        values[status.id] = status;\n      }\n    }\n\n    private final int id;\n\n    Status(int id) {\n      this.id = id;\n    }\n\n    public int id() {\n      return id;\n    }\n\n    public static Status fromId(int id) {\n      return values[id];\n    }\n  }\n\n  private final org.apache.avro.Schema schema;\n  private Status status = Status.EXISTING;\n  private long snapshotId = 0L;\n  private DataFile file = null;\n\n  public ManifestEntry(org.apache.avro.Schema schema) {\n    this.schema = schema;\n  }\n\n  ManifestEntry(StructType partitionType) {\n    this.schema = AvroSchemaUtil.convert(getSchema(partitionType), \"manifest_entry\");\n  }\n\n  private ManifestEntry(ManifestEntry toCopy) {\n    this.schema = toCopy.schema;\n    this.status = toCopy.status;\n    this.snapshotId = toCopy.snapshotId;\n    this.file = toCopy.file().copy();\n  }\n\n  ManifestEntry wrapExisting(long snapshotId, DataFile file) {\n    this.status = Status.EXISTING;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapAppend(long snapshotId, DataFile file) {\n    this.status = Status.ADDED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapDelete(long snapshotId, DataFile file) {\n    this.status = Status.DELETED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n\n  public Status status() {\n    return status;\n  }\n\n\n  public long snapshotId() {\n    return snapshotId;\n  }\n\n\n  public DataFile file() {\n    return file;\n  }\n\n  public ManifestEntry copy() {\n    return new ManifestEntry(this);\n  }\n\n  @Override\n  public void put(int i, Object v) {\n    switch (i) {\n      case 0:\n        this.status = Status.fromId((Integer) v);\n        return;\n      case 1:\n        this.snapshotId = (Long) v;\n        return;\n      case 2:\n        this.file = (DataFile) v;\n        return;\n      default:\n\n    }\n  }\n\n  @Override\n  public Object get(int i) {\n    switch (i) {\n      case 0:\n        return status.id();\n      case 1:\n        return snapshotId;\n      case 2:\n        return file;\n      default:\n        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n    }\n  }\n\n  @Override\n  public org.apache.avro.Schema getSchema() {\n    return schema;\n  }\n\n  static Schema projectSchema(StructType partitionType, Collection<String> columns) {\n    return wrapFileSchema(\n        new Schema(DataFile.getType(partitionType).fields()).select(columns).asStruct());\n  }\n\n  static Schema getSchema(StructType partitionType) {\n    return wrapFileSchema(DataFile.getType(partitionType));\n  }\n\n  private static Schema wrapFileSchema(StructType fileStruct) {\n\n    return new Schema(\n        required(0, \"status\", IntegerType.get()),\n        required(1, \"snapshot_id\", LongType.get()),\n        required(2, \"data_file\", fileStruct));\n  }\n\n  @Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n        .add(\"status\", status)\n        .add(\"snapshot_id\", snapshotId)\n        .add(\"file\", file)\n        .toString();\n  }\n}\n\n'iceberg/core/src/test/java/com/netflix/iceberg/TestTableMetadataJson.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.fasterxml.jackson.core.JsonGenerator;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.TableMetadata.SnapshotLogEntry;\nimport com.netflix.iceberg.exceptions.RuntimeIOException;\nimport com.netflix.iceberg.types.Types;\nimport com.netflix.iceberg.util.JsonUtil;\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\nimport static com.netflix.iceberg.Files.localInput;\nimport static com.netflix.iceberg.TableMetadataParser.CURRENT_SNAPSHOT_ID;\nimport static com.netflix.iceberg.TableMetadataParser.FORMAT_VERSION;\nimport static com.netflix.iceberg.TableMetadataParser.LAST_COLUMN_ID;\nimport static com.netflix.iceberg.TableMetadataParser.LAST_UPDATED_MILLIS;\nimport static com.netflix.iceberg.TableMetadataParser.LOCATION;\nimport static com.netflix.iceberg.TableMetadataParser.PARTITION_SPEC;\nimport static com.netflix.iceberg.TableMetadataParser.PROPERTIES;\nimport static com.netflix.iceberg.TableMetadataParser.SCHEMA;\nimport static com.netflix.iceberg.TableMetadataParser.SNAPSHOTS;\n\npublic class TestTableMetadataJson {\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();\n\n  public TableOperations ops = new LocalTableOperations(temp);\n\n  @Test\n  public void testJsonConversion() throws Exception {\n    Schema schema = new Schema(\n        Types.NestedField.required(1, \"x\", Types.LongType.get()),\n        Types.NestedField.required(2, \"y\", Types.LongType.get()),\n        Types.NestedField.required(3, \"z\", Types.LongType.get())\n    );\n\n    PartitionSpec spec = PartitionSpec.builderFor(schema).withSpecId(5).build();\n\n    long previousSnapshotId = System.currentTimeMillis() - new Random(1234).nextInt(3600);\n    Snapshot previousSnapshot = new BaseSnapshot(\n        null, previousSnapshotId, null, previousSnapshotId, ImmutableList.of(\n        new GenericManifestFile(localInput(\"file:/tmp/manfiest.1.avro\"), spec.specId())));\n    long currentSnapshotId = System.currentTimeMillis();\n    Snapshot currentSnapshot = new BaseSnapshot(\n        null, currentSnapshotId, previousSnapshotId, currentSnapshotId, ImmutableList.of(\n        new GenericManifestFile(localInput(\"file:/tmp/manfiest.2.avro\"), spec.specId())));\n\n    List<SnapshotLogEntry> snapshotLog = ImmutableList.<SnapshotLogEntry>builder()\n        .add(new SnapshotLogEntry(previousSnapshot.timestampMillis(), previousSnapshot.snapshotId()))\n        .add(new SnapshotLogEntry(currentSnapshot.timestampMillis(), currentSnapshot.snapshotId()))\n        .build();\n\n    TableMetadata expected = new TableMetadata(ops, null, \"s3:\n        System.currentTimeMillis(), 3, schema, 5, ImmutableList.of(spec),\n        ImmutableMap.of(\"property\", \"value\"), currentSnapshotId,\n        Arrays.asList(previousSnapshot, currentSnapshot), snapshotLog);\n\n    String asJson = TableMetadataParser.toJson(expected);\n    TableMetadata metadata = TableMetadataParser.fromJson(ops, null,\n        JsonUtil.mapper().readValue(asJson, JsonNode.class));\n\n    Assert.assertEquals(\"Table location should match\",\n        expected.location(), metadata.location());\n    Assert.assertEquals(\"Last column ID should match\",\n        expected.lastColumnId(), metadata.lastColumnId());\n    Assert.assertEquals(\"Schema should match\",\n        expected.schema().asStruct(), metadata.schema().asStruct());\n    Assert.assertEquals(\"Partition spec should match\",\n        expected.spec().toString(), metadata.spec().toString());\n    Assert.assertEquals(\"Default spec ID should match\",\n        expected.defaultSpecId(), metadata.defaultSpecId());\n    Assert.assertEquals(\"PartitionSpec map should match\",\n        expected.specs(), metadata.specs());\n    Assert.assertEquals(\"Properties should match\",\n        expected.properties(), metadata.properties());\n    Assert.assertEquals(\"Snapshot logs should match\",\n        expected.snapshotLog(), metadata.snapshotLog());\n    Assert.assertEquals(\"Current snapshot ID should match\",\n        currentSnapshotId, metadata.currentSnapshot().snapshotId());\n    Assert.assertEquals(\"Parent snapshot ID should match\",\n        (Long) previousSnapshotId, metadata.currentSnapshot().parentId());\n    Assert.assertEquals(\"Current snapshot files should match\",\n        currentSnapshot.manifests(), metadata.currentSnapshot().manifests());\n    Assert.assertEquals(\"Previous snapshot ID should match\",\n        previousSnapshotId, metadata.snapshot(previousSnapshotId).snapshotId());\n    Assert.assertEquals(\"Previous snapshot files should match\",\n        previousSnapshot.manifests(),\n        metadata.snapshot(previousSnapshotId).manifests());\n  }\n\n  @Test\n  public void testFromJsonSortsSnapshotLog() throws Exception {\n    Schema schema = new Schema(\n        Types.NestedField.required(1, \"x\", Types.LongType.get()),\n        Types.NestedField.required(2, \"y\", Types.LongType.get()),\n        Types.NestedField.required(3, \"z\", Types.LongType.get())\n    );\n\n    PartitionSpec spec = PartitionSpec.builderFor(schema).withSpecId(5).build();\n\n    long previousSnapshotId = System.currentTimeMillis() - new Random(1234).nextInt(3600);\n    Snapshot previousSnapshot = new BaseSnapshot(\n        ops, previousSnapshotId, null, previousSnapshotId, ImmutableList.of(\n        new GenericManifestFile(localInput(\"file:/tmp/manfiest.1.avro\"), spec.specId())));\n    long currentSnapshotId = System.currentTimeMillis();\n    Snapshot currentSnapshot = new BaseSnapshot(\n        ops, currentSnapshotId, previousSnapshotId, currentSnapshotId, ImmutableList.of(\n        new GenericManifestFile(localInput(\"file:/tmp/manfiest.2.avro\"), spec.specId())));\n\n    List<SnapshotLogEntry> reversedSnapshotLog = Lists.newArrayList();\n\n    TableMetadata expected = new TableMetadata(ops, null, \"s3:\n        System.currentTimeMillis(), 3, schema, 5, ImmutableList.of(spec),\n        ImmutableMap.of(\"property\", \"value\"), currentSnapshotId,\n        Arrays.asList(previousSnapshot, currentSnapshot), reversedSnapshotLog);\n\n\n    reversedSnapshotLog.add(\n        new SnapshotLogEntry(currentSnapshot.timestampMillis(), currentSnapshot.snapshotId()));\n    reversedSnapshotLog.add(\n        new SnapshotLogEntry(previousSnapshot.timestampMillis(), previousSnapshot.snapshotId()));\n\n    String asJson = TableMetadataParser.toJson(expected);\n    TableMetadata metadata = TableMetadataParser.fromJson(ops, null,\n        JsonUtil.mapper().readValue(asJson, JsonNode.class));\n\n    List<SnapshotLogEntry> expectedSnapshotLog = ImmutableList.<SnapshotLogEntry>builder()\n        .add(new SnapshotLogEntry(previousSnapshot.timestampMillis(), previousSnapshot.snapshotId()))\n        .add(new SnapshotLogEntry(currentSnapshot.timestampMillis(), currentSnapshot.snapshotId()))\n        .build();\n\n    Assert.assertEquals(\"Snapshot logs should match\",\n        expectedSnapshotLog, metadata.snapshotLog());\n  }\n\n  @Test\n  public void testBackwardCompatMissingPartitionSpecList() throws Exception {\n    Schema schema = new Schema(\n        Types.NestedField.required(1, \"x\", Types.LongType.get()),\n        Types.NestedField.required(2, \"y\", Types.LongType.get()),\n        Types.NestedField.required(3, \"z\", Types.LongType.get())\n    );\n\n    PartitionSpec spec = PartitionSpec.builderFor(schema).identity(\"x\").withSpecId(6).build();\n\n    long previousSnapshotId = System.currentTimeMillis() - new Random(1234).nextInt(3600);\n    Snapshot previousSnapshot = new BaseSnapshot(\n        ops, previousSnapshotId, null, previousSnapshotId, ImmutableList.of(\n        new GenericManifestFile(localInput(\"file:/tmp/manfiest.1.avro\"), spec.specId())));\n    long currentSnapshotId = System.currentTimeMillis();\n    Snapshot currentSnapshot = new BaseSnapshot(\n        ops, currentSnapshotId, previousSnapshotId, currentSnapshotId, ImmutableList.of(\n        new GenericManifestFile(localInput(\"file:/tmp/manfiest.2.avro\"), spec.specId())));\n\n    TableMetadata expected = new TableMetadata(ops, null, \"s3:\n        System.currentTimeMillis(), 3, schema, 6, ImmutableList.of(spec),\n        ImmutableMap.of(\"property\", \"value\"), currentSnapshotId,\n        Arrays.asList(previousSnapshot, currentSnapshot), ImmutableList.of());\n\n    String asJson = toJsonWithoutSpecList(expected);\n    TableMetadata metadata = TableMetadataParser.fromJson(ops, null,\n        JsonUtil.mapper().readValue(asJson, JsonNode.class));\n\n    Assert.assertEquals(\"Table location should match\",\n        expected.location(), metadata.location());\n    Assert.assertEquals(\"Last column ID should match\",\n        expected.lastColumnId(), metadata.lastColumnId());\n    Assert.assertEquals(\"Schema should match\",\n        expected.schema().asStruct(), metadata.schema().asStruct());\n    Assert.assertEquals(\"Partition spec should be the default\",\n        expected.spec().toString(), metadata.spec().toString());\n    Assert.assertEquals(\"Default spec ID should default to TableMetadata.INITIAL_SPEC_ID\",\n        TableMetadata.INITIAL_SPEC_ID, metadata.defaultSpecId());\n    Assert.assertEquals(\"PartitionSpec should contain the spec\",\n        1, metadata.specs().size());\n    Assert.assertTrue(\"PartitionSpec should contain the spec\",\n        metadata.specs().get(0).compatibleWith(spec));\n    Assert.assertEquals(\"PartitionSpec should have ID TableMetadata.INITIAL_SPEC_ID\",\n        TableMetadata.INITIAL_SPEC_ID, metadata.specs().get(0).specId());\n    Assert.assertEquals(\"Properties should match\",\n        expected.properties(), metadata.properties());\n    Assert.assertEquals(\"Snapshot logs should match\",\n        expected.snapshotLog(), metadata.snapshotLog());\n    Assert.assertEquals(\"Current snapshot ID should match\",\n        currentSnapshotId, metadata.currentSnapshot().snapshotId());\n    Assert.assertEquals(\"Parent snapshot ID should match\",\n        (Long) previousSnapshotId, metadata.currentSnapshot().parentId());\n    Assert.assertEquals(\"Current snapshot files should match\",\n        currentSnapshot.manifests(), metadata.currentSnapshot().manifests());\n    Assert.assertEquals(\"Previous snapshot ID should match\",\n        previousSnapshotId, metadata.snapshot(previousSnapshotId).snapshotId());\n    Assert.assertEquals(\"Previous snapshot files should match\",\n        previousSnapshot.manifests(),\n        metadata.snapshot(previousSnapshotId).manifests());\n  }\n\n  public static String toJsonWithoutSpecList(TableMetadata metadata) {\n    StringWriter writer = new StringWriter();\n    try {\n      JsonGenerator generator = JsonUtil.factory().createGenerator(writer);\n\n      generator.writeStartObject();\n\n      generator.writeNumberField(FORMAT_VERSION, TableMetadata.TABLE_FORMAT_VERSION);\n      generator.writeStringField(LOCATION, metadata.location());\n      generator.writeNumberField(LAST_UPDATED_MILLIS, metadata.lastUpdatedMillis());\n      generator.writeNumberField(LAST_COLUMN_ID, metadata.lastColumnId());\n\n      generator.writeFieldName(SCHEMA);\n      SchemaParser.toJson(metadata.schema(), generator);\n\n\n      generator.writeFieldName(PARTITION_SPEC);\n      PartitionSpecParser.toJsonFields(metadata.spec(), generator);\n\n      generator.writeObjectFieldStart(PROPERTIES);\n      for (Map.Entry<String, String> keyValue : metadata.properties().entrySet()) {\n        generator.writeStringField(keyValue.getKey(), keyValue.getValue());\n      }\n      generator.writeEndObject();\n\n      generator.writeNumberField(CURRENT_SNAPSHOT_ID,\n          metadata.currentSnapshot() != null ? metadata.currentSnapshot().snapshotId() : -1);\n\n      generator.writeArrayFieldStart(SNAPSHOTS);\n      for (Snapshot snapshot : metadata.snapshots()) {\n        SnapshotParser.toJson(snapshot, generator);\n      }\n      generator.writeEndArray();\n\n\n\n      generator.writeEndObject();\n\n      generator.flush();\n    } catch (IOException e) {\n      throw new RuntimeIOException(e, \"Failed to write json for: %s\", metadata);\n    }\n    return writer.toString();\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestTableMetadataJson.java'"
        ]
    },
    {
        "files": [
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/ExternalPreview.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/MarkdownPreviewPane.java'"
        ],
        "content": "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'\n:\n\npackage org.markdownwriterfx.options;\n\nimport java.io.File;\nimport java.util.List;\nimport java.util.prefs.Preferences;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javafx.beans.property.BooleanProperty;\nimport javafx.beans.property.IntegerProperty;\nimport javafx.beans.property.ObjectProperty;\nimport javafx.beans.property.StringProperty;\nimport javafx.scene.text.Font;\nimport org.markdownwriterfx.projects.ProjectManager;\nimport org.markdownwriterfx.projects.ProjectSettings;\nimport org.markdownwriterfx.util.PrefsBooleanProperty;\nimport org.markdownwriterfx.util.PrefsEnumProperty;\nimport org.markdownwriterfx.util.PrefsIntegerProperty;\nimport org.markdownwriterfx.util.PrefsStringProperty;\nimport org.markdownwriterfx.util.PrefsStringsProperty;\nimport org.markdownwriterfx.util.Utils;\n\n\npublic class Options\n{\n\tpublic static final String[] DEF_FONT_FAMILIES = {\n\t\t\"Consolas\",\n\t\t\"DejaVu Sans Mono\",\n\t\t\"Lucida Sans Typewriter\",\n\t\t\"Lucida Console\",\n\t};\n\n\tpublic static final int DEF_FONT_SIZE = 12;\n\tpublic static final int MIN_FONT_SIZE = 8;\n\tpublic static final int MAX_FONT_SIZE = 36;\n\tpublic static final String DEF_MARKDOWN_FILE_EXTENSIONS = \"*.md,*.markdown,*.txt\";\n\tpublic enum RendererType { CommonMark, FlexMark }\n\tpublic static final int DEF_WRAP_LINE_LENGTH = 80;\n\tpublic static final int MIN_WRAP_LINE_LENGTH = 10;\n\n\tprivate static Preferences globalOptions;\n\tprivate static Preferences options;\n\n\tpublic static void load(Preferences globalOptions) {\n\t\tOptions.globalOptions = globalOptions;\n\n\t\toptions = getProjectOptions(ProjectManager.getActiveProject());\n\n\t\tfontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\n\t\tfontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\n\t\tlineSeparator.init(options, \"lineSeparator\", null);\n\t\tencoding.init(options, \"encoding\", null);\n\t\tmarkdownFileExtensions.init(options, \"markdownFileExtensions\", DEF_MARKDOWN_FILE_EXTENSIONS);\n\t\tmarkdownExtensions.init(options, \"markdownExtensions\");\n\t\tmarkdownRenderer.init(options, \"markdownRenderer\", RendererType.CommonMark);\n\t\tshowLineNo.init(options, \"showLineNo\", false);\n\t\tshowWhitespace.init(options, \"showWhitespace\", false);\n\t\tshowImagesEmbedded.init(options, \"showImagesEmbedded\", false);\n\n\t\temphasisMarker.init(options, \"emphasisMarker\", \"_\");\n\t\tstrongEmphasisMarker.init(options, \"strongEmphasisMarker\", \"**\");\n\t\tbulletListMarker.init(options, \"bulletListMarker\", \"-\");\n\n\t\twrapLineLength.init(options, \"wrapLineLength\", DEF_WRAP_LINE_LENGTH);\n\t\tformatOnSave.init(options, \"formatOnSave\", false);\n\t\tformatOnlyModifiedParagraphs.init(options, \"formatOnlyModifiedParagraphs\", false);\n\n\t\tspellChecker.init(options, \"spellChecker\", true);\n\t\tgrammarChecker.init(options, \"grammarChecker\", true);\n\t\tlanguage.init(options, \"language\", null);\n\t\tuserDictionary.init(options, \"userDictionary\", getDefaultUserDictionary());\n\t\tdisabledRules.init(options, \"disabledRules\");\n\n\t\tadditionalCSS.init(options, \"additionalCSS\", null);\n\n\n\t\taddonsPath.init(globalOptions, \"addonsPath\", null);\n\n\n\t\tProjectManager.activeProjectProperty().addListener((observer, oldProject, newProject) -> {\n\t\t\tset(getProjectOptions(newProject));\n\t\t});\n\t}\n\n\tprivate static void set(Preferences options) {\n\t\tif (Options.options == options)\n\t\t\treturn;\n\n\t\tOptions.options = options;\n\n\t\tfontFamily.setPreferences(options);\n\t\tfontSize.setPreferences(options);\n\t\tlineSeparator.setPreferences(options);\n\t\tencoding.setPreferences(options);\n\t\tmarkdownFileExtensions.setPreferences(options);\n\t\tmarkdownExtensions.setPreferences(options);\n\t\tmarkdownRenderer.setPreferences(options);\n\t\tshowLineNo.setPreferences(options);\n\t\tshowWhitespace.setPreferences(options);\n\t\tshowImagesEmbedded.setPreferences(options);\n\n\t\temphasisMarker.setPreferences(options);\n\t\tstrongEmphasisMarker.setPreferences(options);\n\t\tbulletListMarker.setPreferences(options);\n\n\t\twrapLineLength.setPreferences(options);\n\t\tformatOnSave.setPreferences(options);\n\t\tformatOnlyModifiedParagraphs.setPreferences(options);\n\n\t\tspellChecker.setPreferences(options);\n\t\tgrammarChecker.setPreferences(options);\n\t\tlanguage.setPreferences(options);\n\t\tuserDictionary.setPreferences(options);\n\t\tdisabledRules.setPreferences(options);\n\n\t\tadditionalCSS.setPreferences(options);\n\n\t\taddonsPath.setPreferences(globalOptions);\n\t}\n\n\tprivate static Preferences getProjectOptions(File project) {\n\t\tif (project != null) {\n\t\t\tPreferences projectOptions = ProjectSettings.get(project).getOptions();\n\t\t\tif (projectOptions != null)\n\t\t\t\treturn projectOptions;\n\t\t}\n\n\t\treturn globalOptions;\n\t}\n\n\tstatic boolean isStoreInProject() {\n\t\treturn options != globalOptions;\n\t}\n\n\tstatic void storeInProject(boolean enable) {\n\t\tProjectSettings projectSettings = ProjectSettings.get(ProjectManager.getActiveProject());\n\t\tprojectSettings.enableOptions(enable);\n\t\tset(enable ? projectSettings.getOptions() : globalOptions);\n\t}\n\n\n\tprivate static String safeFontFamily(String fontFamily) {\n\t\tList<String> fontFamilies = Font.getFamilies();\n\t\tif (fontFamily != null && fontFamilies.contains(fontFamily))\n\t\t\treturn fontFamily;\n\n\t\tfor (String family : DEF_FONT_FAMILIES) {\n\t\t\tif (fontFamilies.contains(family))\n\t\t\t\treturn family;\n\t\t}\n\t\treturn \"Monospaced\";\n\t}\n\n\n\tprivate static final PrefsStringProperty fontFamily = new PrefsStringProperty();\n\tpublic static String getFontFamily() { return fontFamily.get(); }\n\tpublic static void setFontFamily(String fontFamily) { Options.fontFamily.set(fontFamily); }\n\tpublic static StringProperty fontFamilyProperty() { return fontFamily; }\n\n\n\tprivate static final PrefsIntegerProperty fontSize = new PrefsIntegerProperty();\n\tpublic static int getFontSize() { return fontSize.get(); }\n\tpublic static void setFontSize(int fontSize) { Options.fontSize.set(Math.min(Math.max(fontSize,  MIN_FONT_SIZE), MAX_FONT_SIZE)); }\n\tpublic static IntegerProperty fontSizeProperty() { return fontSize; }\n\n\n\tprivate static final PrefsStringProperty lineSeparator = new PrefsStringProperty();\n\tpublic static String getLineSeparator() { return lineSeparator.get(); }\n\tpublic static void setLineSeparator(String lineSeparator) { Options.lineSeparator.set(lineSeparator); }\n\tpublic static StringProperty lineSeparatorProperty() { return lineSeparator; }\n\n\n\tprivate static final PrefsStringProperty encoding = new PrefsStringProperty();\n\tpublic static String getEncoding() { return encoding.get(); }\n\tpublic static void setEncoding(String encoding) { Options.encoding.set(encoding); }\n\tpublic static StringProperty encodingProperty() { return encoding; }\n\n\n\tprivate static final PrefsStringProperty markdownFileExtensions = new PrefsStringProperty();\n\tpublic static String getMarkdownFileExtensions() { return markdownFileExtensions.get(); }\n\tpublic static void setMarkdownFileExtensions(String markdownFileExtensions) { Options.markdownFileExtensions.set(markdownFileExtensions); }\n\tpublic static StringProperty markdownFileExtensionsProperty() { return markdownFileExtensions; }\n\n\n\tprivate static final PrefsStringsProperty markdownExtensions = new PrefsStringsProperty();\n\tpublic static String[] getMarkdownExtensions() { return markdownExtensions.get(); }\n\tpublic static void setMarkdownExtensions(String[] markdownExtensions) { Options.markdownExtensions.set(markdownExtensions); }\n\tpublic static ObjectProperty<String[]> markdownExtensionsProperty() { return markdownExtensions; }\n\n\n\tprivate static final PrefsEnumProperty<RendererType> markdownRenderer = new PrefsEnumProperty<>( RendererType.CommonMark );\n\tpublic static RendererType getMarkdownRenderer() { return markdownRenderer.get(); }\n\tpublic static void setMarkdownRenderer(RendererType markdownRenderer) { Options.markdownRenderer.set(markdownRenderer); }\n\tpublic static ObjectProperty<RendererType> markdownRendererProperty() { return markdownRenderer; }\n\n\n\tprivate static final PrefsBooleanProperty showLineNo = new PrefsBooleanProperty();\n\tpublic static boolean isShowLineNo() { return showLineNo.get(); }\n\tpublic static void setShowLineNo(boolean showLineNo) { Options.showLineNo.set(showLineNo); }\n\tpublic static BooleanProperty showLineNoProperty() { return showLineNo; }\n\n\n\tprivate static final PrefsBooleanProperty showWhitespace = new PrefsBooleanProperty();\n\tpublic static boolean isShowWhitespace() { return showWhitespace.get(); }\n\tpublic static void setShowWhitespace(boolean showWhitespace) { Options.showWhitespace.set(showWhitespace); }\n\tpublic static BooleanProperty showWhitespaceProperty() { return showWhitespace; }\n\n\n\tprivate static final PrefsBooleanProperty showImagesEmbedded = new PrefsBooleanProperty();\n\tpublic static boolean isShowImagesEmbedded() { return showImagesEmbedded.get(); }\n\tpublic static void setShowImagesEmbedded(boolean showImagesEmbedded) { Options.showImagesEmbedded.set(showImagesEmbedded); }\n\tpublic static BooleanProperty showImagesEmbeddedProperty() { return showImagesEmbedded; }\n\n\n\tprivate static final PrefsStringProperty emphasisMarker = new PrefsStringProperty();\n\tpublic static String getEmphasisMarker() { return emphasisMarker.get(); }\n\tpublic static void setEmphasisMarker(String emphasisMarker) { Options.emphasisMarker.set(emphasisMarker); }\n\tpublic static StringProperty emphasisMarkerProperty() { return emphasisMarker; }\n\n\n\tprivate static final PrefsStringProperty strongEmphasisMarker = new PrefsStringProperty();\n\tpublic static String getStrongEmphasisMarker() { return strongEmphasisMarker.get(); }\n\tpublic static void setStrongEmphasisMarker(String strongEmphasisMarker) { Options.strongEmphasisMarker.set(strongEmphasisMarker); }\n\tpublic static StringProperty strongEmphasisMarkerProperty() { return strongEmphasisMarker; }\n\n\n\tprivate static final PrefsStringProperty bulletListMarker = new PrefsStringProperty();\n\tpublic static String getBulletListMarker() { return bulletListMarker.get(); }\n\tpublic static void setBulletListMarker(String bulletListMarker) { Options.bulletListMarker.set(bulletListMarker); }\n\tpublic static StringProperty bulletListMarkerProperty() { return bulletListMarker; }\n\n\n\tprivate static final PrefsIntegerProperty wrapLineLength = new PrefsIntegerProperty();\n\tpublic static int getWrapLineLength() { return wrapLineLength.get(); }\n\tpublic static void setWrapLineLength(int wrapLineLength) { Options.wrapLineLength.set(Math.max(wrapLineLength, MIN_WRAP_LINE_LENGTH)); }\n\tpublic static IntegerProperty wrapLineLengthProperty() { return wrapLineLength; }\n\n\n\tprivate static final PrefsBooleanProperty formatOnSave = new PrefsBooleanProperty();\n\tpublic static boolean isFormatOnSave() { return formatOnSave.get(); }\n\tpublic static void setFormatOnSave(boolean formatOnSave) { Options.formatOnSave.set(formatOnSave); }\n\tpublic static BooleanProperty formatOnSaveProperty() { return formatOnSave; }\n\n\n\tprivate static final PrefsBooleanProperty formatOnlyModifiedParagraphs = new PrefsBooleanProperty();\n\tpublic static boolean isFormatOnlyModifiedParagraphs() { return formatOnlyModifiedParagraphs.get(); }\n\tpublic static void setFormatOnlyModifiedParagraphs(boolean formatOnlyModifiedParagraphs) { Options.formatOnlyModifiedParagraphs.set(formatOnlyModifiedParagraphs); }\n\tpublic static BooleanProperty formatOnlyModifiedParagraphsProperty() { return formatOnlyModifiedParagraphs; }\n\n\n\tprivate static final PrefsBooleanProperty spellChecker = new PrefsBooleanProperty();\n\tpublic static boolean isSpellChecker() { return spellChecker.get(); }\n\tpublic static void setSpellChecker(boolean spellChecker) { Options.spellChecker.set(spellChecker); }\n\tpublic static BooleanProperty spellCheckerProperty() { return spellChecker; }\n\n\n\tprivate static final PrefsBooleanProperty grammarChecker = new PrefsBooleanProperty();\n\tpublic static boolean isGrammarChecker() { return grammarChecker.get(); }\n\tpublic static void setGrammarChecker(boolean grammarChecker) { Options.grammarChecker.set(grammarChecker); }\n\tpublic static BooleanProperty grammarCheckerProperty() { return grammarChecker; }\n\n\n\tprivate static final PrefsStringProperty language = new PrefsStringProperty();\n\tpublic static String getLanguage() { return language.get(); }\n\tpublic static void setLanguage(String language) { Options.language.set(language); }\n\tpublic static StringProperty languageProperty() { return language; }\n\n\n\tprivate static final PrefsStringProperty userDictionary = new PrefsStringProperty();\n\tpublic static String getUserDictionary() { return userDictionaryOrDefault(userDictionary.get()); }\n\tpublic static void setUserDictionary(String userDictionary) { Options.userDictionary.set(userDictionaryOrDefault(userDictionary)); }\n\tpublic static StringProperty userDictionaryProperty() { return userDictionary; }\n\tprivate static String getDefaultUserDictionary() {\n\t\treturn System.getProperty(\"user.home\") + System.getProperty(\"file.separator\") + \"dictionary-mwfx.txt\";\n\t}\n\tprivate static String userDictionaryOrDefault(String userDictionary) {\n\t\treturn !Utils.isNullOrEmpty(userDictionary) ? userDictionary : getDefaultUserDictionary();\n\t}\n\n\n\n\tprivate static final PrefsStringsProperty disabledRules = new PrefsStringsProperty();\n\tpublic static String[] getDisabledRules() { return disabledRules.get(); }\n\tpublic static void setDisabledRules(String[] disabledRules) { Options.disabledRules.set(disabledRules); }\n\tpublic static ObjectProperty<String[]> disabledRulesProperty() { return disabledRules; }\n\n\tpublic static String ruleIdDesc2id(String str) {\n\t\treturn str.contains(\"=\") ? str.substring(0, str.indexOf('=')) : str;\n\t}\n\n\tpublic static String ruleIdDesc2desc(String str) {\n\t\treturn str.contains(\"=\") ? str.substring(str.indexOf('=') + 1) : str;\n\t}\n\n\tpublic static List<String> ruleIdDescs2ids(String[] strs) {\n\t\treturn Stream.of(strs)\n\t\t\t.map(Options::ruleIdDesc2id)\n\t\t\t.collect(Collectors.toList());\n\t}\n\n\n\tprivate static final PrefsStringProperty additionalCSS = new PrefsStringProperty();\n\tpublic static String getAdditionalCSS() { return additionalCSS.get(); }\n\tpublic static void setAdditionalCSS(String additionalCSS) { Options.additionalCSS.set(additionalCSS); }\n\tpublic static StringProperty additionalCSSProperty() { return additionalCSS; }\n\n\n\tprivate static final PrefsStringProperty addonsPath = new PrefsStringProperty();\n\tpublic static String getAddonsPath() { return addonsPath.get(); }\n\tpublic static void setAddonsPath(String addonsPath) { Options.addonsPath.set(addonsPath); }\n\tpublic static StringProperty addonsPathProperty() { return addonsPath; }\n}\n\n'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/ExternalPreview.java'\n:\n\npackage org.markdownwriterfx.preview;\n\nimport java.util.Iterator;\nimport java.util.ServiceLoader;\n\nimport javafx.scene.control.IndexRange;\nimport javafx.scene.control.Label;\n\nimport org.markdownwriterfx.Messages;\nimport org.markdownwriterfx.addons.PreviewViewAddon;\nimport org.markdownwriterfx.preview.MarkdownPreviewPane.PreviewContext;\nimport org.markdownwriterfx.preview.MarkdownPreviewPane.Renderer;\nimport org.markdownwriterfx.util.Addons;\n\n\nclass ExternalPreview\n\timplements MarkdownPreviewPane.Preview\n{\n\tprivate static final boolean hasExternalPreview =\n\t\tServiceLoader.load( PreviewViewAddon.class, Addons.getAddonsClassLoader() ).iterator().hasNext();\n\n\tprivate PreviewViewAddon previewView;\n\n\tExternalPreview() {\n\n\n\n\t\tServiceLoader<PreviewViewAddon> addons = ServiceLoader.load( PreviewViewAddon.class, Addons.getAddonsClassLoader() );\n\t\tIterator<PreviewViewAddon> it = addons.iterator();\n\t\tif (it.hasNext())\n\t\t\tpreviewView = it.next();\n\t}\n\n\tstatic boolean hasExternalPreview() {\n\t\treturn hasExternalPreview;\n\t}\n\n\t@Override\n\tpublic javafx.scene.Node getNode() {\n\t\tif (previewView != null)\n\t\t\treturn previewView.getNode();\n\t\telse\n\t\t\treturn new Label(Messages.get(\"ExternalPreview.notAvailable\"));\n\t}\n\n\t@Override\n\tpublic void update(PreviewContext context, Renderer renderer) {\n\t\tif (previewView != null)\n\t\t\tpreviewView.update(context.getMarkdownText(), context.getPath());\n\t}\n\n\t@Override\n\tpublic void scrollY(PreviewContext context, double value) {\n\t\tif (previewView != null)\n\t\t\tpreviewView.scrollY(value);\n\t}\n\n\t@Override\n\tpublic void editorSelectionChanged(PreviewContext context, IndexRange range) {\n\t\tif (previewView != null)\n\t\t\tpreviewView.editorSelectionChanged(range);\n\t}\n}\n",
        "gt": [
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/MarkdownPreviewPane.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/ExternalPreview.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/Writer.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/Writer.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.netflix.iceberg.AppendFiles;\nimport com.netflix.iceberg.DataFile;\nimport com.netflix.iceberg.DataFiles;\nimport com.netflix.iceberg.FileFormat;\nimport com.netflix.iceberg.Metrics;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.Table;\nimport com.netflix.iceberg.TableProperties;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.exceptions.RuntimeIOException;\nimport com.netflix.iceberg.hadoop.HadoopInputFile;\nimport com.netflix.iceberg.hadoop.HadoopOutputFile;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.io.InputFile;\nimport com.netflix.iceberg.io.OutputFile;\nimport com.netflix.iceberg.orc.ORC;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.spark.data.SparkAvroWriter;\nimport com.netflix.iceberg.spark.data.SparkOrcWriter;\nimport com.netflix.iceberg.transforms.Transform;\nimport com.netflix.iceberg.transforms.Transforms;\nimport com.netflix.iceberg.types.Types.StringType;\nimport com.netflix.iceberg.util.Tasks;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.execution.datasources.parquet.ParquetWriteSupport;\nimport org.apache.spark.sql.sources.v2.writer.DataSourceWriter;\nimport org.apache.spark.sql.sources.v2.writer.DataWriter;\nimport org.apache.spark.sql.sources.v2.writer.DataWriterFactory;\nimport org.apache.spark.sql.sources.v2.writer.SupportsWriteInternalRow;\nimport org.apache.spark.sql.sources.v2.writer.WriterCommitMessage;\nimport org.apache.spark.util.SerializableConfiguration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.function.Function;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Iterables.transform;\nimport static com.netflix.iceberg.TableProperties.COMMIT_MAX_RETRY_WAIT_MS;\nimport static com.netflix.iceberg.TableProperties.COMMIT_MAX_RETRY_WAIT_MS_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.COMMIT_MIN_RETRY_WAIT_MS;\nimport static com.netflix.iceberg.TableProperties.COMMIT_MIN_RETRY_WAIT_MS_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.COMMIT_NUM_RETRIES;\nimport static com.netflix.iceberg.TableProperties.COMMIT_NUM_RETRIES_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.COMMIT_TOTAL_RETRY_TIME_MS;\nimport static com.netflix.iceberg.TableProperties.COMMIT_TOTAL_RETRY_TIME_MS_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.OBJECT_STORE_ENABLED;\nimport static com.netflix.iceberg.TableProperties.OBJECT_STORE_ENABLED_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.OBJECT_STORE_PATH;\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\n\nclass Writer implements DataSourceWriter, SupportsWriteInternalRow {\n  private static final Transform<String, Integer> HASH_FUNC = Transforms\n      .bucket(StringType.get(), Integer.MAX_VALUE);\n  private static final Logger LOG = LoggerFactory.getLogger(Writer.class);\n\n  private final Table table;\n  private final Configuration conf;\n  private final FileFormat format;\n\n  Writer(Table table, Configuration conf, FileFormat format) {\n    this.table = table;\n    this.conf = conf;\n    this.format = format;\n  }\n\n  @Override\n  public DataWriterFactory<InternalRow> createInternalRowWriterFactory() {\n    return new WriterFactory(table.spec(), format, dataLocation(), table.properties(), conf);\n  }\n\n  @Override\n  public void commit(WriterCommitMessage[] messages) {\n    AppendFiles append = table.newAppend();\n\n    int numFiles = 0;\n    for (DataFile file : files(messages)) {\n      numFiles += 1;\n      append.appendFile(file);\n    }\n\n    LOG.info(\"Appending {} files to {}\", numFiles, table);\n    long start = System.currentTimeMillis();\n    append.commit();\n    long duration = System.currentTimeMillis() - start;\n    LOG.info(\"Committed in {} ms\", duration);\n  }\n\n  @Override\n  public void abort(WriterCommitMessage[] messages) {\n    FileSystem fs;\n    try {\n      fs = new Path(table.location()).getFileSystem(conf);\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n\n    Tasks.foreach(files(messages))\n        .retry(propertyAsInt(COMMIT_NUM_RETRIES, COMMIT_NUM_RETRIES_DEFAULT))\n        .exponentialBackoff(\n            propertyAsInt(COMMIT_MIN_RETRY_WAIT_MS, COMMIT_MIN_RETRY_WAIT_MS_DEFAULT),\n            propertyAsInt(COMMIT_MAX_RETRY_WAIT_MS, COMMIT_MAX_RETRY_WAIT_MS_DEFAULT),\n            propertyAsInt(COMMIT_TOTAL_RETRY_TIME_MS, COMMIT_TOTAL_RETRY_TIME_MS_DEFAULT),\n            2.0  )\n        .throwFailureWhenFinished()\n        .run(file -> {\n          try {\n            fs.delete(new Path(file.path().toString()), false  );\n          } catch (IOException e) {\n            throw new RuntimeIOException(e);\n          }\n        });\n  }\n\n  private Iterable<DataFile> files(WriterCommitMessage[] messages) {\n    if (messages.length > 0) {\n      return concat(transform(Arrays.asList(messages), message -> message != null\n          ? ImmutableList.copyOf(((TaskCommit) message).files())\n          : ImmutableList.of()));\n    }\n    return ImmutableList.of();\n  }\n\n  private int propertyAsInt(String property, int defaultValue) {\n    Map<String, String> properties = table.properties();\n    String value = properties.get(property);\n    if (value != null) {\n      return Integer.parseInt(properties.get(property));\n    }\n    return defaultValue;\n  }\n\n  private String dataLocation() {\n    return table.properties().getOrDefault(\n        TableProperties.WRITE_NEW_DATA_LOCATION,\n        new Path(new Path(table.location()), \"data\").toString());\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"IcebergWrite(table=%s, type=%s, format=%s)\",\n        table, table.schema().asStruct(), format);\n  }\n\n\n  private static class TaskCommit implements WriterCommitMessage {\n    private final DataFile[] files;\n\n    TaskCommit() {\n      this.files = new DataFile[0];\n    }\n\n    TaskCommit(DataFile file) {\n      this.files = new DataFile[] { file };\n    }\n\n    TaskCommit(List<DataFile> files) {\n      this.files = files.toArray(new DataFile[files.size()]);\n    }\n\n    DataFile[] files() {\n      return files;\n    }\n  }\n\n  private static class WriterFactory implements DataWriterFactory<InternalRow> {\n    private final PartitionSpec spec;\n    private final FileFormat format;\n    private final String dataLocation;\n    private final Map<String, String> properties;\n    private final SerializableConfiguration conf;\n    private final String uuid = UUID.randomUUID().toString();\n\n    private transient Path dataPath = null;\n\n    WriterFactory(PartitionSpec spec, FileFormat format, String dataLocation,\n                  Map<String, String> properties, Configuration conf) {\n      this.spec = spec;\n      this.format = format;\n      this.dataLocation = dataLocation;\n      this.properties = properties;\n      this.conf = new SerializableConfiguration(conf);\n    }\n\n    @Override\n    public DataWriter<InternalRow> createDataWriter(int partitionId, int attemptNumber) {\n      String filename = format.addExtension(String.format(\"%05d-%d-%s\",\n          partitionId, attemptNumber, uuid));\n      AppenderFactory<InternalRow> factory = new SparkAppenderFactory();\n      if (spec.fields().isEmpty()) {\n        return new UnpartitionedWriter(lazyDataPath(), filename, format, conf.value(), factory);\n\n      } else {\n        Path baseDataPath = lazyDataPath();\n        Function<PartitionKey, Path> outputPathFunc = key ->\n            new Path(new Path(baseDataPath, key.toPath()), filename);\n\n        boolean useObjectStorage = (\n            Boolean.parseBoolean(properties.get(OBJECT_STORE_ENABLED)) ||\n            OBJECT_STORE_ENABLED_DEFAULT\n        );\n\n        if (useObjectStorage) {\n\n          String context = pathContext(baseDataPath);\n          String objectStore = properties.get(OBJECT_STORE_PATH);\n          Preconditions.checkNotNull(objectStore,\n              \"Cannot use object storage, missing location: \" + OBJECT_STORE_PATH);\n          Path objectStorePath = new Path(objectStore);\n\n          outputPathFunc = key -> {\n            String partitionAndFilename = key.toPath() + \"/\" + filename;\n            int hash = HASH_FUNC.apply(partitionAndFilename);\n            return new Path(objectStorePath,\n                String.format(\"%08x/%s/%s\", hash, context, partitionAndFilename));\n          };\n        }\n\n        return new PartitionedWriter(spec, format, conf.value(), factory, outputPathFunc);\n      }\n    }\n\n    private static String pathContext(Path dataPath) {\n      Path parent = dataPath.getParent();\n      if (parent != null) {\n\n        if (dataPath.getName().equals(\"data\")) {\n          return pathContext(parent);\n        }\n\n        return parent.getName() + \"/\" + dataPath.getName();\n      }\n\n      return dataPath.getName();\n    }\n\n    private Path lazyDataPath() {\n      if (dataPath == null) {\n        this.dataPath = new Path(dataLocation);\n      }\n      return dataPath;\n    }\n\n    private class SparkAppenderFactory implements AppenderFactory<InternalRow> {\n      public FileAppender<InternalRow> newAppender(OutputFile file, FileFormat format) {\n        Schema schema = spec.schema();\n        try {\n          switch (format) {\n            case PARQUET:\n              String jsonSchema = convert(schema).json();\n              return Parquet.write(file)\n                  .writeSupport(new ParquetWriteSupport())\n                  .set(\"org.apache.spark.sql.parquet.row.attributes\", jsonSchema)\n                  .set(\"spark.sql.parquet.writeLegacyFormat\", \"false\")\n                  .set(\"spark.sql.parquet.binaryAsString\", \"false\")\n                  .set(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n                  .set(\"spark.sql.parquet.outputTimestampType\", \"TIMESTAMP_MICROS\")\n                  .setAll(properties)\n                  .schema(schema)\n                  .build();\n\n            case AVRO:\n              return Avro.write(file)\n                  .createWriterFunc(ignored -> new SparkAvroWriter(schema))\n                  .setAll(properties)\n                  .schema(schema)\n                  .build();\n\n            case ORC: {\n              @SuppressWarnings(\"unchecked\")\n              SparkOrcWriter writer = new SparkOrcWriter(ORC.write(file)\n                  .schema(schema)\n                  .build());\n              return writer;\n            }\n            default:\n              throw new UnsupportedOperationException(\"Cannot write unknown format: \" + format);\n          }\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n      }\n    }\n  }\n\n  private interface AppenderFactory<T> {\n    FileAppender<T> newAppender(OutputFile file, FileFormat format);\n  }\n\n  private static class UnpartitionedWriter implements DataWriter<InternalRow>, Closeable {\n    private final Path file;\n    private final Configuration conf;\n    private FileAppender<InternalRow> appender = null;\n    private Metrics metrics = null;\n\n    UnpartitionedWriter(Path dataPath, String filename, FileFormat format,\n                        Configuration conf, AppenderFactory<InternalRow> factory) {\n      this.file = new Path(dataPath, filename);\n      this.appender = factory.newAppender(HadoopOutputFile.fromPath(file, conf), format);\n      this.conf = conf;\n    }\n\n    @Override\n    public void write(InternalRow record) {\n      appender.add(record);\n    }\n\n    @Override\n    public WriterCommitMessage commit() throws IOException {\n      Preconditions.checkArgument(appender != null, \"Commit called on a closed writer: %s\", this);\n\n      close();\n\n      if (metrics.recordCount() == 0L) {\n        FileSystem fs = file.getFileSystem(conf);\n        fs.delete(file, false);\n        return new TaskCommit();\n      }\n\n      InputFile inFile = HadoopInputFile.fromPath(file, conf);\n      DataFile dataFile = DataFiles.fromInputFile(inFile, null, metrics);\n\n      return new TaskCommit(dataFile);\n    }\n\n    @Override\n    public void abort() throws IOException {\n      Preconditions.checkArgument(appender != null, \"Abort called on a closed writer: %s\", this);\n\n      close();\n\n      FileSystem fs = file.getFileSystem(conf);\n      fs.delete(file, false);\n    }\n\n    @Override\n    public void close() throws IOException {\n      if (this.appender != null) {\n        this.appender.close();\n        this.metrics = appender.metrics();\n        this.appender = null;\n      }\n    }\n  }\n\n  private static class PartitionedWriter implements DataWriter<InternalRow> {\n    private final Set<PartitionKey> completedPartitions = Sets.newHashSet();\n    private final List<DataFile> completedFiles = Lists.newArrayList();\n    private final PartitionSpec spec;\n    private final FileFormat format;\n    private final Configuration conf;\n    private final AppenderFactory<InternalRow> factory;\n    private final Function<PartitionKey, Path> outputPathFunc;\n    private final PartitionKey key;\n\n    private PartitionKey currentKey = null;\n    private FileAppender<InternalRow> currentAppender = null;\n    private Path currentPath = null;\n\n    PartitionedWriter(PartitionSpec spec, FileFormat format, Configuration conf,\n                      AppenderFactory<InternalRow> factory,\n                      Function<PartitionKey, Path> outputPathFunc) {\n      this.spec = spec;\n      this.format = format;\n      this.conf = conf;\n      this.factory = factory;\n      this.outputPathFunc = outputPathFunc;\n      this.key = new PartitionKey(spec);\n    }\n\n    @Override\n    public void write(InternalRow row) throws IOException {\n      key.partition(row);\n\n      if (!key.equals(currentKey)) {\n        closeCurrent();\n\n        if (completedPartitions.contains(key)) {\n\n          PartitionKey existingKey = Iterables.find(completedPartitions, key::equals, null);\n          LOG.warn(\"Duplicate key: {} == {}\", existingKey, key);\n          throw new IllegalStateException(\"Already closed file for partition: \" + key.toPath());\n        }\n\n        this.currentKey = key.copy();\n        this.currentPath = outputPathFunc.apply(currentKey);\n        OutputFile file = HadoopOutputFile.fromPath(currentPath, conf);\n        this.currentAppender = factory.newAppender(file, format);\n      }\n\n      currentAppender.add(row);\n    }\n\n    @Override\n    public WriterCommitMessage commit() throws IOException {\n      closeCurrent();\n      return new TaskCommit(completedFiles);\n    }\n\n    @Override\n    public void abort() throws IOException {\n      FileSystem fs = currentPath.getFileSystem(conf);\n\n\n      Tasks.foreach(completedFiles)\n          .throwFailureWhenFinished()\n          .noRetry()\n          .run(file -> fs.delete(new Path(file.path().toString())), IOException.class);\n\n      if (currentAppender != null) {\n        currentAppender.close();\n        this.currentAppender = null;\n        fs.delete(currentPath);\n      }\n    }\n\n    private void closeCurrent() throws IOException {\n      if (currentAppender != null) {\n        currentAppender.close();\n\n        Metrics metrics = currentAppender.metrics();\n        this.currentAppender = null;\n\n        InputFile inFile = HadoopInputFile.fromPath(currentPath, conf);\n        DataFile dataFile = DataFiles.builder(spec)\n            .withInputFile(inFile)\n            .withPartition(currentKey)\n            .withMetrics(metrics)\n            .build();\n\n        completedPartitions.add(currentKey);\n        completedFiles.add(dataFile);\n      }\n    }\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/Writer.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'"
        ],
        "content": "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport java.util.List;\n\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Core;\nimport org.opencv.core.CvType;\nimport org.opencv.core.Mat;\nimport org.opencv.core.MatOfPoint;\nimport org.opencv.core.Rect;\nimport org.opencv.core.Scalar;\nimport org.opencv.core.Size;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport org.opencv.imgproc.Imgproc;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.WindowManager;\nimport android.view.View.OnTouchListener;\n\nimport com.jnardari.opencv_androidsamples.R;\nimport com.jnardari.opencv_androidsamples.utils.ColorBlobDetector;\n\npublic class ColorBlobDetectionActivity extends AppCompatActivity implements OnTouchListener, CvCameraViewListener2 {\n    private static final String  TAG              = \"OCVSample::Activity\";\n\n    private boolean              mIsColorSelected = false;\n    private Mat                  mRgba;\n    private Scalar               mBlobColorRgba;\n    private Scalar               mBlobColorHsv;\n    private ColorBlobDetector    mDetector;\n    private Mat                  mSpectrum;\n    private Size                 SPECTRUM_SIZE;\n    private Scalar               CONTOUR_COLOR;\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n\n    private BaseLoaderCallback  mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                    mOpenCvCameraView.setOnTouchListener(ColorBlobDetectionActivity.this);\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public ColorBlobDetectionActivity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_color_blob_detection);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.color_blob_detection_activity_surface_view);\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n        mRgba = new Mat(height, width, CvType.CV_8UC4);\n        mDetector = new ColorBlobDetector();\n        mSpectrum = new Mat();\n        mBlobColorRgba = new Scalar(255);\n        mBlobColorHsv = new Scalar(255);\n        SPECTRUM_SIZE = new Size(200, 64);\n        CONTOUR_COLOR = new Scalar(255,0,0,255);\n    }\n\n    public void onCameraViewStopped() {\n        mRgba.release();\n    }\n\n    public boolean onTouch(View v, MotionEvent event) {\n        int cols = mRgba.cols();\n        int rows = mRgba.rows();\n\n        int xOffset = (mOpenCvCameraView.getWidth() - cols) / 2;\n        int yOffset = (mOpenCvCameraView.getHeight() - rows) / 2;\n\n        int x = (int)event.getX() - xOffset;\n        int y = (int)event.getY() - yOffset;\n\n        Log.i(TAG, \"Touch image coordinates: (\" + x + \", \" + y + \")\");\n\n        if ((x < 0) || (y < 0) || (x > cols) || (y > rows)) return false;\n\n        Rect touchedRect = new Rect();\n\n        touchedRect.x = (x>4) ? x-4 : 0;\n        touchedRect.y = (y>4) ? y-4 : 0;\n\n        touchedRect.width = (x+4 < cols) ? x + 4 - touchedRect.x : cols - touchedRect.x;\n        touchedRect.height = (y+4 < rows) ? y + 4 - touchedRect.y : rows - touchedRect.y;\n\n        Mat touchedRegionRgba = mRgba.submat(touchedRect);\n\n        Mat touchedRegionHsv = new Mat();\n        Imgproc.cvtColor(touchedRegionRgba, touchedRegionHsv, Imgproc.COLOR_RGB2HSV_FULL);\n\n\n        mBlobColorHsv = Core.sumElems(touchedRegionHsv);\n        int pointCount = touchedRect.width*touchedRect.height;\n        for (int i = 0; i < mBlobColorHsv.val.length; i++)\n            mBlobColorHsv.val[i] /= pointCount;\n\n        mBlobColorRgba = converScalarHsv2Rgba(mBlobColorHsv);\n\n        Log.i(TAG, \"Touched rgba color: (\" + mBlobColorRgba.val[0] + \", \" + mBlobColorRgba.val[1] +\n                \", \" + mBlobColorRgba.val[2] + \", \" + mBlobColorRgba.val[3] + \")\");\n\n        mDetector.setHsvColor(mBlobColorHsv);\n\n        Imgproc.resize(mDetector.getSpectrum(), mSpectrum, SPECTRUM_SIZE);\n\n        mIsColorSelected = true;\n\n        touchedRegionRgba.release();\n        touchedRegionHsv.release();\n\n        return false;\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        mRgba = inputFrame.rgba();\n\n        if (mIsColorSelected) {\n            mDetector.process(mRgba);\n            List<MatOfPoint> contours = mDetector.getContours();\n            Log.e(TAG, \"Contours count: \" + contours.size());\n            Imgproc.drawContours(mRgba, contours, -1, CONTOUR_COLOR);\n\n            Mat colorLabel = mRgba.submat(4, 68, 4, 68);\n            colorLabel.setTo(mBlobColorRgba);\n\n            Mat spectrumLabel = mRgba.submat(4, 4 + mSpectrum.rows(), 70, 70 + mSpectrum.cols());\n            mSpectrum.copyTo(spectrumLabel);\n        }\n\n        return mRgba;\n    }\n\n    private Scalar converScalarHsv2Rgba(Scalar hsvColor) {\n        Mat pointMatRgba = new Mat();\n        Mat pointMatHsv = new Mat(1, 1, CvType.CV_8UC3, hsvColor);\n        Imgproc.cvtColor(pointMatHsv, pointMatRgba, Imgproc.COLOR_HSV2RGB_FULL, 4);\n\n        return new Scalar(pointMatRgba.get(0, 0));\n    }\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'"
        ],
        "content": "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterators;\nimport com.google.common.collect.Lists;\nimport com.google.common.io.Files;\nimport com.netflix.iceberg.types.Types;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport java.io.File;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport static com.netflix.iceberg.Files.localInput;\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\npublic class TableTestBase {\n\n  static final Schema SCHEMA = new Schema(\n      required(3, \"id\", Types.IntegerType.get()),\n      required(4, \"data\", Types.StringType.get())\n  );\n\n\n  static final PartitionSpec SPEC = PartitionSpec.builderFor(SCHEMA)\n      .bucket(\"data\", 16)\n      .build();\n\n  static final DataFile FILE_A = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-a.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=0\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_B = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-b.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=1\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_C = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-c.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=2\")\n      .withRecordCount(0)\n      .build();\n  static final DataFile FILE_D = DataFiles.builder(SPEC)\n      .withPath(\"/path/to/data-d.parquet\")\n      .withFileSizeInBytes(0)\n      .withPartitionPath(\"data_bucket=3\")\n      .withRecordCount(0)\n      .build();\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();\n\n  File tableDir = null;\n  File metadataDir = null;\n  TestTables.TestTable table = null;\n\n  @Before\n  public void setupTable() throws Exception {\n    this.tableDir = temp.newFolder();\n    tableDir.delete();\n\n    this.metadataDir = new File(tableDir, \"metadata\");\n    this.table = create(SCHEMA, SPEC);\n  }\n\n  @After\n  public void cleanupTables() {\n    TestTables.clearTables();\n  }\n\n  List<File> listManifestFiles() {\n    return listManifestFiles(tableDir);\n  }\n\n  List<File> listManifestFiles(File tableDir) {\n    return Lists.newArrayList(new File(tableDir, \"metadata\").listFiles((dir, name) ->\n        !name.startsWith(\"snap\") && Files.getFileExtension(name).equalsIgnoreCase(\"avro\")));\n  }\n\n  private TestTables.TestTable create(Schema schema, PartitionSpec spec) {\n    return TestTables.create(tableDir, \"test\", schema, spec);\n  }\n\n  TestTables.TestTable load() {\n    return TestTables.load(tableDir, \"test\");\n  }\n\n  Integer version() {\n    return TestTables.metadataVersion(\"test\");\n  }\n\n  TableMetadata readMetadata() {\n    return TestTables.readMetadata(\"test\");\n  }\n\n  void validateSnapshot(Snapshot old, Snapshot snap, DataFile... newFiles) {\n    List<ManifestFile> oldManifests = old != null ? old.manifests() : ImmutableList.of();\n\n\n    List<ManifestFile> newManifests = Lists.newArrayList(snap.manifests());\n    for (ManifestFile oldManifest : oldManifests) {\n      Assert.assertTrue(\"New snapshot should contain old manifests\",\n          newManifests.remove(oldManifest));\n    }\n\n    Assert.assertEquals(\"Should create 1 new manifest and reuse old manifests\",\n        1, newManifests.size());\n    ManifestFile manifest = newManifests.get(0);\n\n    long id = snap.snapshotId();\n    Iterator<String> newPaths = paths(newFiles).iterator();\n\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest.path())).entries()) {\n      DataFile file = entry.file();\n      Assert.assertEquals(\"Path should match expected\", newPaths.next(), file.path().toString());\n      Assert.assertEquals(\"File's snapshot ID should match\", id, entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", newPaths.hasNext());\n  }\n\n  List<String> paths(DataFile... dataFiles) {\n    List<String> paths = Lists.newArrayListWithExpectedSize(dataFiles.length);\n    for (DataFile file : dataFiles) {\n      paths.add(file.path().toString());\n    }\n    return paths;\n  }\n\n  static void validateManifest(ManifestFile manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    validateManifest(manifest.path(), ids, expectedFiles);\n  }\n\n  static void validateManifest(String manifest,\n                               Iterator<Long> ids,\n                               Iterator<DataFile> expectedFiles) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static void validateManifestEntries(ManifestFile manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    validateManifestEntries(manifest.path(), ids, expectedFiles, expectedStatuses);\n  }\n\n  static void validateManifestEntries(String manifest,\n                                      Iterator<Long> ids,\n                                      Iterator<DataFile> expectedFiles,\n                                      Iterator<ManifestEntry.Status> expectedStatuses) {\n    for (ManifestEntry entry : ManifestReader.read(localInput(manifest)).entries()) {\n      DataFile file = entry.file();\n      DataFile expected = expectedFiles.next();\n      final ManifestEntry.Status expectedStatus = expectedStatuses.next();\n      Assert.assertEquals(\"Path should match expected\",\n          expected.path().toString(), file.path().toString());\n      Assert.assertEquals(\"Snapshot ID should match expected ID\",\n          (long) ids.next(), entry.snapshotId());\n      Assert.assertEquals(\"Entry status should match expected ID\",\n          expectedStatus, entry.status());\n    }\n\n    Assert.assertFalse(\"Should find all files in the manifest\", expectedFiles.hasNext());\n  }\n\n  static Iterator<ManifestEntry.Status> statuses(ManifestEntry.Status... statuses) {\n    return Iterators.forArray(statuses);\n  }\n\n  static Iterator<Long> ids(Long... ids) {\n    return Iterators.forArray(ids);\n  }\n\n  static Iterator<DataFile> files(DataFile... files) {\n    return Iterators.forArray(files);\n  }\n\n  static Iterator<DataFile> files(ManifestFile manifest) {\n    return ManifestReader.read(localInput(manifest.path())).iterator();\n  }\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.base.Objects;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.types.Types.IntegerType;\nimport com.netflix.iceberg.types.Types.LongType;\nimport com.netflix.iceberg.types.Types.StructType;\nimport org.apache.avro.generic.IndexedRecord;\nimport org.apache.avro.specific.SpecificData;\n\nimport java.util.Collection;\n\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\nclass ManifestEntry implements IndexedRecord, SpecificData.SchemaConstructable{\n  enum Status {\n    EXISTING(0),\n    ADDED(1),\n    DELETED(2);\n\n    public static Status[] values = new Status[3];\n    static {\n      for (Status status : Status.values()) {\n        values[status.id] = status;\n      }\n    }\n\n    private final int id;\n\n    Status(int id) {\n      this.id = id;\n    }\n\n    public int id() {\n      return id;\n    }\n\n    public static Status fromId(int id) {\n      return values[id];\n    }\n  }\n\n  private final org.apache.avro.Schema schema;\n  private Status status = Status.EXISTING;\n  private long snapshotId = 0L;\n  private DataFile file = null;\n\n  public ManifestEntry(org.apache.avro.Schema schema) {\n    this.schema = schema;\n  }\n\n  ManifestEntry(StructType partitionType) {\n    this.schema = AvroSchemaUtil.convert(getSchema(partitionType), \"manifest_entry\");\n  }\n\n  private ManifestEntry(ManifestEntry toCopy) {\n    this.schema = toCopy.schema;\n    this.status = toCopy.status;\n    this.snapshotId = toCopy.snapshotId;\n    this.file = toCopy.file().copy();\n  }\n\n  ManifestEntry wrapExisting(long snapshotId, DataFile file) {\n    this.status = Status.EXISTING;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapAppend(long snapshotId, DataFile file) {\n    this.status = Status.ADDED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapDelete(long snapshotId, DataFile file) {\n    this.status = Status.DELETED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n\n  public Status status() {\n    return status;\n  }\n\n\n  public long snapshotId() {\n    return snapshotId;\n  }\n\n\n  public DataFile file() {\n    return file;\n  }\n\n  public ManifestEntry copy() {\n    return new ManifestEntry(this);\n  }\n\n  @Override\n  public void put(int i, Object v) {\n    switch (i) {\n      case 0:\n        this.status = Status.fromId((Integer) v);\n        return;\n      case 1:\n        this.snapshotId = (Long) v;\n        return;\n      case 2:\n        this.file = (DataFile) v;\n        return;\n      default:\n\n    }\n  }\n\n  @Override\n  public Object get(int i) {\n    switch (i) {\n      case 0:\n        return status.id();\n      case 1:\n        return snapshotId;\n      case 2:\n        return file;\n      default:\n        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n    }\n  }\n\n  @Override\n  public org.apache.avro.Schema getSchema() {\n    return schema;\n  }\n\n  static Schema projectSchema(StructType partitionType, Collection<String> columns) {\n    return wrapFileSchema(\n        new Schema(DataFile.getType(partitionType).fields()).select(columns).asStruct());\n  }\n\n  static Schema getSchema(StructType partitionType) {\n    return wrapFileSchema(DataFile.getType(partitionType));\n  }\n\n  private static Schema wrapFileSchema(StructType fileStruct) {\n\n    return new Schema(\n        required(0, \"status\", IntegerType.get()),\n        required(1, \"snapshot_id\", LongType.get()),\n        required(2, \"data_file\", fileStruct));\n  }\n\n  @Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n        .add(\"status\", status)\n        .add(\"snapshot_id\", snapshotId)\n        .add(\"file\", file)\n        .toString();\n  }\n}\n\n'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.netflix.iceberg.exceptions.CommitFailedException;\nimport com.netflix.iceberg.exceptions.ValidationException;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.mockito.internal.util.collections.Sets;\n\nimport java.io.File;\nimport java.util.Collections;\n\nimport static com.netflix.iceberg.ManifestEntry.Status.ADDED;\nimport static com.netflix.iceberg.ManifestEntry.Status.DELETED;\nimport static com.netflix.iceberg.ManifestEntry.Status.EXISTING;\n\npublic class TestReplaceFiles extends TableTestBase {\n\n  @Test\n  public void testEmptyTable() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    TableMetadata base = readMetadata();\n    Assert.assertNull(\"Should not have a current snapshot\", base.currentSnapshot());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-a.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B))\n            .commit());\n  }\n\n  @Test\n  public void testAddOnly() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        IllegalArgumentException.class,\n        \"Files to add can not be null or empty\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Collections.emptySet())\n            .apply());\n  }\n\n  @Test\n  public void testDeleteOnly() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        IllegalArgumentException.class,\n        \"Files to delete cannot be null or empty\",\n        () -> table.newRewrite()\n            .rewriteFiles(Collections.emptySet(), Sets.newSet(FILE_A))\n            .apply());\n  }\n\n  @Test\n  public void testDeleteWithDuplicateEntriesInManifest() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    long baseSnapshotId = base.currentSnapshot().snapshotId();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    Snapshot pending = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_C))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n    Assert.assertFalse(\"Should not contain manifest from initial write\",\n        pending.manifests().contains(initialManifest));\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_C),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId,pendingId, baseSnapshotId),\n        files(FILE_A, FILE_A, FILE_B),\n        statuses(DELETED, DELETED, EXISTING));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testAddAndDelete() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    long baseSnapshotId = base.currentSnapshot().snapshotId();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    Snapshot pending = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_C))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n    Assert.assertFalse(\"Should not contain manifest from initial write\",\n        pending.manifests().contains(initialManifest));\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_C),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId, baseSnapshotId),\n        files(FILE_A, FILE_B),\n        statuses(DELETED, EXISTING));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testFailure() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.ops().failCommits(5);\n\n    RewriteFiles rewrite = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B));\n    Snapshot pending = rewrite.apply();\n\n    Assert.assertEquals(\"Should produce 2 manifests\", 2, pending.manifests().size());\n    ManifestFile manifest1 = pending.manifests().get(0);\n    ManifestFile manifest2 = pending.manifests().get(1);\n\n    validateManifestEntries(manifest1,\n        ids(pending.snapshotId()), files(FILE_B), statuses(ADDED));\n    validateManifestEntries(manifest2,\n        ids(pending.snapshotId()), files(FILE_A), statuses(DELETED));\n\n    AssertHelpers.assertThrows(\"Should retry 4 times and throw last failure\",\n        CommitFailedException.class, \"Injected failure\", rewrite::commit);\n\n    Assert.assertFalse(\"Should clean up new manifest\", new File(manifest1.path()).exists());\n    Assert.assertFalse(\"Should clean up new manifest\", new File(manifest2.path()).exists());\n\n\n    Assert.assertEquals(\"Only 1 manifest should exist\", 1, listManifestFiles().size());\n  }\n\n  @Test\n  public void testRecovery() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.ops().failCommits(3);\n\n    RewriteFiles rewrite = table.newRewrite().rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B));\n    Snapshot pending = rewrite.apply();\n\n    Assert.assertEquals(\"Should produce 2 manifests\", 2, pending.manifests().size());\n    ManifestFile manifest1 = pending.manifests().get(0);\n    ManifestFile manifest2 = pending.manifests().get(1);\n\n    validateManifestEntries(manifest1,\n        ids(pending.snapshotId()), files(FILE_B), statuses(ADDED));\n    validateManifestEntries(manifest2,\n        ids(pending.snapshotId()), files(FILE_A), statuses(DELETED));\n\n    rewrite.commit();\n\n    Assert.assertTrue(\"Should reuse the manifest for appends\", new File(manifest1.path()).exists());\n    Assert.assertTrue(\"Should reuse the manifest with deletes\", new File(manifest2.path()).exists());\n\n    TableMetadata metadata = readMetadata();\n    Assert.assertTrue(\"Should commit the manifest for append\",\n        metadata.currentSnapshot().manifests().contains(manifest2));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testDeleteNonExistentFile() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-c.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_C), Sets.newSet(FILE_D))\n            .commit());\n\n    Assert.assertEquals(\"Only 1 manifests should exist\", 1, listManifestFiles().size());\n  }\n\n  @Test\n  public void testAlreadyDeletedFile() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n\n    RewriteFiles rewrite = table.newRewrite();\n    Snapshot pending = rewrite\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_B),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId, base.currentSnapshot().snapshotId()),\n        files(FILE_A),\n        statuses(DELETED));\n\n    rewrite.commit();\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-a.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_D))\n            .commit());\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TableTestBase.java'"
        ]
    },
    {
        "files": [
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'"
        ],
        "content": "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'\n:\n\npackage github.daneren2005.dsub.adapter;\n\nimport android.content.Context;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport java.util.List;\n\nimport github.daneren2005.dsub.R;\nimport github.daneren2005.dsub.domain.MusicDirectory;\nimport github.daneren2005.dsub.domain.MusicDirectory.Entry;\nimport github.daneren2005.dsub.util.ImageLoader;\nimport github.daneren2005.dsub.util.Util;\nimport github.daneren2005.dsub.view.AlbumView;\nimport github.daneren2005.dsub.view.SongView;\nimport github.daneren2005.dsub.view.UpdateView;\nimport github.daneren2005.dsub.view.UpdateView.UpdateViewHolder;\n\npublic class EntryGridAdapter extends SectionAdapter<Entry> {\n\tprivate static String TAG = EntryGridAdapter.class.getSimpleName();\n\n\tpublic static int VIEW_TYPE_ALBUM_CELL = 1;\n\tpublic static int VIEW_TYPE_ALBUM_LINE = 2;\n\tpublic static int VIEW_TYPE_SONG = 3;\n\n\tprivate ImageLoader imageLoader;\n\tprivate boolean largeAlbums;\n\tprivate boolean showArtist = false;\n\tprivate boolean showAlbum = false;\n\tprivate boolean removeFromPlaylist = false;\n\tprivate View header;\n\n\tpublic EntryGridAdapter(Context context, List<Entry> entries, ImageLoader imageLoader, boolean largeCell) {\n\t\tsuper(context, entries);\n\t\tthis.imageLoader = imageLoader;\n\t\tthis.largeAlbums = largeCell;\n\n\n\t\tString artist = null;\n\t\tfor(MusicDirectory.Entry entry: entries) {\n\t\t\tif(artist == null) {\n\t\t\t\tartist = entry.getArtist();\n\t\t\t}\n\n\t\t\tif(artist != null && !artist.equals(entry.getArtist())) {\n\t\t\t\tshowArtist = true;\n\t\t\t}\n\t\t}\n\t\tcheckable = true;\n\t}\n\n\t@Override\n\tpublic UpdateViewHolder onCreateSectionViewHolder(ViewGroup parent, int viewType) {\n\t\tUpdateView updateView = null;\n\t\tif(viewType == VIEW_TYPE_ALBUM_LINE || viewType == VIEW_TYPE_ALBUM_CELL) {\n\t\t\tupdateView = new AlbumView(context, viewType == VIEW_TYPE_ALBUM_CELL);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tupdateView = new SongView(context);\n\t\t}\n\n\t\treturn new UpdateViewHolder(updateView);\n\t}\n\n\t@Override\n\tpublic void onBindViewHolder(UpdateViewHolder holder, Entry entry, int viewType) {\n\t\tUpdateView view = holder.getUpdateView();\n\t\tif(viewType == VIEW_TYPE_ALBUM_CELL || viewType == VIEW_TYPE_ALBUM_LINE) {\n\t\t\tAlbumView albumView = (AlbumView) view;\n\t\t\talbumView.setShowArtist(showArtist);\n\t\t\talbumView.setObject(entry, imageLoader);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tSongView songView = (SongView) view;\n\t\t\tsongView.setShowAlbum(showAlbum);\n\t\t\tsongView.setObject(entry, checkable && !entry.isVideo());\n\t\t}\n\t}\n\n\tpublic UpdateViewHolder onCreateHeaderHolder(ViewGroup parent) {\n\t\treturn new UpdateViewHolder(header, false);\n\t}\n\tpublic void onBindHeaderHolder(UpdateViewHolder holder, String header, int sectionIndex) {\n\n\t}\n\n\t@Override\n\tpublic int getItemViewType(Entry entry) {\n\t\tif(entry.isDirectory()) {\n\t\t\tif (largeAlbums) {\n\t\t\t\treturn VIEW_TYPE_ALBUM_CELL;\n\t\t\t} else {\n\t\t\t\treturn VIEW_TYPE_ALBUM_LINE;\n\t\t\t}\n\t\t} else {\n\t\t\treturn VIEW_TYPE_SONG;\n\t\t}\n\t}\n\n\tpublic void setHeader(View header) {\n\t\tthis.header = header;\n\t\tthis.singleSectionHeader = true;\n\t}\n\tpublic View getHeader() {\n\t\treturn header;\n\t}\n\n\tpublic void setShowArtist(boolean showArtist) {\n\t\tthis.showArtist = showArtist;\n\t}\n\n\tpublic void setShowAlbum(boolean showAlbum) {\n\t\tthis.showAlbum = showAlbum;\n\t}\n\n\tpublic void removeAt(int index) {\n\t\tsections.get(0).remove(index);\n\t\tif(header != null) {\n\t\t\tindex++;\n\t\t}\n\t\tnotifyItemRemoved(index);\n\t}\n\n\tpublic void setRemoveFromPlaylist(boolean removeFromPlaylist) {\n\t\tthis.removeFromPlaylist = removeFromPlaylist;\n\t}\n\n\t@Override\n\tpublic void onCreateActionModeMenu(Menu menu, MenuInflater menuInflater) {\n\t\tif(Util.isOffline(context)) {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media_offline, menu);\n\t\t} else {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media, menu);\n\t\t}\n\n\t\tif(!removeFromPlaylist) {\n\t\t\tmenu.removeItem(R.id.menu_remove_playlist);\n\t\t}\n\n\t\tif(!selected.isEmpty()) {\n\t\t\tMenuItem starItem = menu.findItem(R.id.menu_star);\n\t\t\tif(starItem != null) {\n\t\t\t\tboolean isStarred = selected.get(0).isStarred();\n\t\t\t\tstarItem.setTitle(isStarred ? R.string.common_unstar : R.string.common_star);\n\t\t\t}\n\t\t}\n\t}\n}\n\n'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'\n:\npackage github.daneren2005.dsub.domain;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.media.MediaMetadataRetriever;\nimport android.os.Build;\nimport android.util.Log;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Locale;\n\nimport github.daneren2005.dsub.service.DownloadService;\nimport github.daneren2005.dsub.util.Constants;\nimport github.daneren2005.dsub.util.UpdateHelper;\nimport github.daneren2005.dsub.util.Util;\n\n\npublic class MusicDirectory implements Serializable {\n\tprivate static final String TAG = MusicDirectory.class.getSimpleName();\n\n    private String name;\n\tprivate String id;\n\tprivate String parent;\n    private List<Entry> children;\n\n\tpublic MusicDirectory() {\n\t\tchildren = new ArrayList<Entry>();\n\t}\n\tpublic MusicDirectory(List<Entry> children) {\n\t\tthis.children = children;\n\t}\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n\t public String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getParent() {\n\t\treturn parent;\n\t}\n\n\tpublic void setParent(String parent) {\n\t\tthis.parent = parent;\n\t}\n\n\tpublic void addChild(Entry child) {\n\t\tif(child != null) {\n\t\t\tchildren.add(child);\n\t\t}\n\t}\n\tpublic void addChildren(List<Entry> children) {\n\t\tthis.children.addAll(children);\n\t}\n\n\tpublic void replaceChildren(List<Entry> children) {\n\t\tthis.children = children;\n\t}\n\n    public synchronized List<Entry> getChildren() {\n        return getChildren(true, true);\n    }\n\n    public synchronized List<Entry> getChildren(boolean includeDirs, boolean includeFiles) {\n        if (includeDirs && includeFiles) {\n            return children;\n        }\n\n        List<Entry> result = new ArrayList<Entry>(children.size());\n        for (Entry child : children) {\n            if (child != null && child.isDirectory() && includeDirs || !child.isDirectory() && includeFiles) {\n                result.add(child);\n            }\n        }\n        return result;\n    }\n\tpublic synchronized List<Entry> getSongs() {\n\t\tList<Entry> result = new ArrayList<Entry>();\n\t\tfor (Entry child : children) {\n\t\t\tif (child != null && !child.isDirectory() && !child.isVideo()) {\n\t\t\t\tresult.add(child);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic synchronized int getChildrenSize() {\n\t\treturn children.size();\n\t}\n\n\tpublic void shuffleChildren() {\n\t\tCollections.shuffle(this.children);\n\t}\n\n\tpublic void sortChildren(Context context, int instance) {\n\n\t\tif(ServerInfo.checkServerVersion(context, \"1.8\", instance)) {\n\t\t\tsortChildren(Util.getPreferences(context).getBoolean(Constants.PREFERENCES_KEY_CUSTOM_SORT_ENABLED, true));\n\t\t}\n\t}\n\tpublic void sortChildren(boolean byYear) {\n\t\tEntryComparator.sort(children, byYear);\n\t}\n\n\tpublic synchronized boolean updateMetadata(MusicDirectory refreshedDirectory) {\n\t\tboolean metadataUpdated = false;\n\t\tIterator<Entry> it = children.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tEntry entry = it.next();\n\t\t\tint index = refreshedDirectory.children.indexOf(entry);\n\t\t\tif(index != -1) {\n\t\t\t\tfinal Entry refreshed = refreshedDirectory.children.get(index);\n\n\t\t\t\tentry.setTitle(refreshed.getTitle());\n\t\t\t\tentry.setAlbum(refreshed.getAlbum());\n\t\t\t\tentry.setArtist(refreshed.getArtist());\n\t\t\t\tentry.setTrack(refreshed.getTrack());\n\t\t\t\tentry.setYear(refreshed.getYear());\n\t\t\t\tentry.setGenre(refreshed.getGenre());\n\t\t\t\tentry.setTranscodedContentType(refreshed.getTranscodedContentType());\n\t\t\t\tentry.setTranscodedSuffix(refreshed.getTranscodedSuffix());\n\t\t\t\tentry.setDiscNumber(refreshed.getDiscNumber());\n\t\t\t\tentry.setStarred(refreshed.isStarred());\n\t\t\t\tentry.setRating(refreshed.getRating());\n\t\t\t\tentry.setType(refreshed.getType());\n\t\t\t\tif(!Util.equals(entry.getCoverArt(), refreshed.getCoverArt())) {\n\t\t\t\t\tmetadataUpdated = true;\n\t\t\t\t\tentry.setCoverArt(refreshed.getCoverArt());\n\t\t\t\t}\n\n\t\t\t\tnew UpdateHelper.EntryInstanceUpdater(entry) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void update(Entry found) {\n\t\t\t\t\t\tfound.setTitle(refreshed.getTitle());\n\t\t\t\t\t\tfound.setAlbum(refreshed.getAlbum());\n\t\t\t\t\t\tfound.setArtist(refreshed.getArtist());\n\t\t\t\t\t\tfound.setTrack(refreshed.getTrack());\n\t\t\t\t\t\tfound.setYear(refreshed.getYear());\n\t\t\t\t\t\tfound.setGenre(refreshed.getGenre());\n\t\t\t\t\t\tfound.setTranscodedContentType(refreshed.getTranscodedContentType());\n\t\t\t\t\t\tfound.setTranscodedSuffix(refreshed.getTranscodedSuffix());\n\t\t\t\t\t\tfound.setDiscNumber(refreshed.getDiscNumber());\n\t\t\t\t\t\tfound.setStarred(refreshed.isStarred());\n\t\t\t\t\t\tfound.setRating(refreshed.getRating());\n\t\t\t\t\t\tfound.setType(refreshed.getType());\n\t\t\t\t\t\tif(!Util.equals(found.getCoverArt(), refreshed.getCoverArt())) {\n\t\t\t\t\t\t\tfound.setCoverArt(refreshed.getCoverArt());\n\t\t\t\t\t\t\tmetadataUpdate = DownloadService.METADATA_UPDATED_COVER_ART;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.execute();\n\t\t\t}\n\t\t}\n\n\t\treturn metadataUpdated;\n\t}\n\tpublic synchronized boolean updateEntriesList(Context context, int instance, MusicDirectory refreshedDirectory) {\n\t\tboolean changed = false;\n\t\tIterator<Entry> it = children.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tEntry entry = it.next();\n\n\t\t\tif(refreshedDirectory.children.indexOf(entry) == -1) {\n\t\t\t\tit.remove();\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\n\t\tboolean resort = false;\n\t\tfor(Entry refreshed: refreshedDirectory.children) {\n\t\t\tif(!this.children.contains(refreshed)) {\n\t\t\t\tthis.children.add(refreshed);\n\t\t\t\tresort = true;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif(resort) {\n\t\t\tthis.sortChildren(context, instance);\n\t\t}\n\n\t\treturn changed;\n\t}\n\n    public static class Entry implements Serializable {\n\t\tpublic static final int TYPE_SONG = 0;\n\t\tpublic static final int TYPE_PODCAST = 1;\n\t\tpublic static final int TYPE_AUDIO_BOOK = 2;\n\n\t\tprivate String id;\n\t\tprivate String parent;\n\t\tprivate String grandParent;\n\t\tprivate String albumId;\n\t\tprivate String artistId;\n\t\tprivate boolean directory;\n\t\tprivate String title;\n\t\tprivate String album;\n\t\tprivate String artist;\n\t\tprivate Integer track;\n\t\tprivate Integer customOrder;\n\t\tprivate Integer year;\n\t\tprivate String genre;\n\t\tprivate String contentType;\n\t\tprivate String suffix;\n\t\tprivate String transcodedContentType;\n\t\tprivate String transcodedSuffix;\n\t\tprivate String coverArt;\n\t\tprivate Long size;\n\t\tprivate Integer duration;\n\t\tprivate Integer bitRate;\n\t\tprivate String path;\n\t\tprivate boolean video;\n\t\tprivate Integer discNumber;\n\t\tprivate boolean starred;\n\t\tprivate Integer rating;\n\t\tprivate Bookmark bookmark;\n\t\tprivate int type = 0;\n\t\tprivate int closeness;\n\t\tprivate transient Artist linkedArtist;\n\n\t\tpublic Entry() {\n\n\t\t}\n\t\tpublic Entry(String id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\tpublic Entry(Artist artist) {\n\t\t\tthis.id = artist.getId();\n\t\t\tthis.title = artist.getName();\n\t\t\tthis.directory = true;\n\t\t\tthis.starred = artist.isStarred();\n\t\t\tthis.rating = artist.getRating();\n\t\t\tthis.linkedArtist = artist;\n\t\t}\n\n\t\t@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)\n\t\tpublic void loadMetadata(File file) {\n\t\t\ttry {\n\t\t\t\tMediaMetadataRetriever metadata = new MediaMetadataRetriever();\n\t\t\t\tmetadata.setDataSource(file.getAbsolutePath());\n\t\t\t\tString discNumber = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DISC_NUMBER);\n\t\t\t\tif(discNumber == null) {\n\t\t\t\t\tdiscNumber = \"1/1\";\n\t\t\t\t}\n\t\t\t\tint slashIndex = discNumber.indexOf(\"/\");\n\t\t\t\tif(slashIndex > 0) {\n\t\t\t\t\tdiscNumber = discNumber.substring(0, slashIndex);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tsetDiscNumber(Integer.parseInt(discNumber));\n\t\t\t\t} catch(Exception e) {\n\t\t\t\t\tLog.w(TAG, \"Non numbers in disc field!\");\n\t\t\t\t}\n\t\t\t\tString bitrate = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE);\n\t\t\t\tsetBitRate(Integer.parseInt((bitrate != null) ? bitrate : \"0\") / 1000);\n\t\t\t\tString length = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);\n\t\t\t\tsetDuration(Integer.parseInt(length) / 1000);\n\t\t\t\tString artist = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);\n\t\t\t\tif(artist != null) {\n\t\t\t\t\tsetArtist(artist);\n\t\t\t\t}\n\t\t\t\tString album = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);\n\t\t\t\tif(album != null) {\n\t\t\t\t\tsetAlbum(album);\n\t\t\t\t}\n\t\t\t\tmetadata.release();\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.i(TAG, \"Device doesn't properly support MediaMetadataRetreiver\", e);\n\t\t\t}\n\t\t}\n\t\tpublic void rebaseTitleOffPath() {\n\t\t\ttry {\n\t\t\t\tString filename = getPath();\n\t\t\t\tif(filename == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tint index = filename.lastIndexOf('/');\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tfilename = filename.substring(index + 1);\n\t\t\t\t\tif (getTrack() != null) {\n\t\t\t\t\t\tfilename = filename.replace(String.format(\"%02d \", getTrack()), \"\");\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = filename.lastIndexOf('.');\n\t\t\t\t\tif(index != -1) {\n\t\t\t\t\t\tfilename = filename.substring(0, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tsetTitle(filename);\n\t\t\t\t}\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to update title based off of path\", e);\n\t\t\t}\n\t\t}\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public String getParent() {\n            return parent;\n        }\n\n        public void setParent(String parent) {\n            this.parent = parent;\n        }\n\n\t\tpublic String getGrandParent() {\n            return grandParent;\n        }\n\n        public void setGrandParent(String grandParent) {\n            this.grandParent = grandParent;\n        }\n\n\t\tpublic String getAlbumId() {\n\t\t\treturn albumId;\n\t\t}\n\n\t\tpublic void setAlbumId(String albumId) {\n\t\t\tthis.albumId = albumId;\n\t\t}\n\n\t\tpublic String getArtistId() {\n\t\t\treturn artistId;\n\t\t}\n\n\t\tpublic void setArtistId(String artistId) {\n\t\t\tthis.artistId = artistId;\n\t\t}\n\n        public boolean isDirectory() {\n            return directory;\n        }\n\n        public void setDirectory(boolean directory) {\n            this.directory = directory;\n        }\n\n        public String getTitle() {\n            return title;\n        }\n\n        public void setTitle(String title) {\n            this.title = title;\n        }\n\n        public String getAlbum() {\n            return album;\n        }\n\n\t\tpublic boolean isAlbum() {\n\t\t\treturn getParent() != null || getArtist() != null;\n\t\t}\n\n\t\tpublic String getAlbumDisplay() {\n\t\t\tif(album != null && title.startsWith(\"Disc \")) {\n\t\t\t\treturn album;\n\t\t\t} else {\n\t\t\t\treturn title;\n\t\t\t}\n\t\t}\n\n        public void setAlbum(String album) {\n            this.album = album;\n        }\n\n        public String getArtist() {\n            return artist;\n        }\n\n        public void setArtist(String artist) {\n            this.artist = artist;\n        }\n\n        public Integer getTrack() {\n            return track;\n        }\n\n        public void setTrack(Integer track) {\n            this.track = track;\n        }\n\n\t\tpublic Integer getCustomOrder() {\n\t\t\treturn customOrder;\n\t\t}\n\t\tpublic void setCustomOrder(Integer customOrder) {\n\t\t\tthis.customOrder = customOrder;\n\t\t}\n\n        public Integer getYear() {\n            return year;\n        }\n\n        public void setYear(Integer year) {\n            this.year = year;\n        }\n\n        public String getGenre() {\n            return genre;\n        }\n\n        public void setGenre(String genre) {\n            this.genre = genre;\n        }\n\n        public String getContentType() {\n            return contentType;\n        }\n\n        public void setContentType(String contentType) {\n            this.contentType = contentType;\n        }\n\n        public String getSuffix() {\n            return suffix;\n        }\n\n        public void setSuffix(String suffix) {\n            this.suffix = suffix;\n        }\n\n        public String getTranscodedContentType() {\n            return transcodedContentType;\n        }\n\n        public void setTranscodedContentType(String transcodedContentType) {\n            this.transcodedContentType = transcodedContentType;\n        }\n\n        public String getTranscodedSuffix() {\n            return transcodedSuffix;\n        }\n\n        public void setTranscodedSuffix(String transcodedSuffix) {\n            this.transcodedSuffix = transcodedSuffix;\n        }\n\n        public Long getSize() {\n            return size;\n        }\n\n        public void setSize(Long size) {\n            this.size = size;\n        }\n\n        public Integer getDuration() {\n            return duration;\n        }\n\n        public void setDuration(Integer duration) {\n            this.duration = duration;\n        }\n\n        public Integer getBitRate() {\n            return bitRate;\n        }\n\n        public void setBitRate(Integer bitRate) {\n            this.bitRate = bitRate;\n        }\n\n        public String getCoverArt() {\n            return coverArt;\n        }\n\n        public void setCoverArt(String coverArt) {\n            this.coverArt = coverArt;\n        }\n\n        public String getPath() {\n            return path;\n        }\n\n        public void setPath(String path) {\n            this.path = path;\n        }\n\n        public boolean isVideo() {\n            return video;\n        }\n\n        public void setVideo(boolean video) {\n            this.video = video;\n        }\n\n\t\tpublic Integer getDiscNumber() {\n\t\t\treturn discNumber;\n\t\t}\n\n\t\tpublic void setDiscNumber(Integer discNumber) {\n\t\t\tthis.discNumber = discNumber;\n\t\t}\n\n        public boolean isStarred() {\n            return starred;\n        }\n\n        public void setStarred(boolean starred) {\n            this.starred = starred;\n\n\t\t\tif(linkedArtist != null) {\n\t\t\t\tlinkedArtist.setStarred(starred);\n\t\t\t}\n        }\n\n\t\tpublic int getRating() {\n\t\t\treturn rating == null ? 0 : rating;\n\t\t}\n\t\tpublic void setRating(Integer rating) {\n\t\t\tif(rating == null || rating == 0) {\n\t\t\t\tthis.rating = null;\n\t\t\t} else {\n\t\t\t\tthis.rating = rating;\n\t\t\t}\n\n\t\t\tif(linkedArtist != null) {\n\t\t\t\tlinkedArtist.setRating(rating);\n\t\t\t}\n\t\t}\n\n\t\tpublic Bookmark getBookmark() {\n\t\t\treturn bookmark;\n\t\t}\n\t\tpublic void setBookmark(Bookmark bookmark) {\n\t\t\tthis.bookmark = bookmark;\n\t\t}\n\n\t\tpublic int getType() {\n\t\t\treturn type;\n\t\t}\n\t\tpublic void setType(int type) {\n\t\t\tthis.type = type;\n\t\t}\n\t\tpublic boolean isSong() {\n\t\t\treturn type == TYPE_SONG;\n\t\t}\n\t\tpublic boolean isPodcast() {\n\t\t\treturn this instanceof PodcastEpisode || type == TYPE_PODCAST;\n\t\t}\n\t\tpublic boolean isAudioBook() {\n\t\t\treturn type == TYPE_AUDIO_BOOK;\n\t\t}\n\n\t\tpublic int getCloseness() {\n\t\t\treturn closeness;\n\t\t}\n\n\t\tpublic void setCloseness(int closeness) {\n\t\t\tthis.closeness = closeness;\n\t\t}\n\n\t\tpublic boolean isOnlineId(Context context) {\n\t\t\ttry {\n\t\t\t\tString cacheLocation = Util.getPreferences(context).getString(Constants.PREFERENCES_KEY_CACHE_LOCATION, null);\n\t\t\t\treturn cacheLocation == null || id == null || id.indexOf(cacheLocation) == -1;\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to check online id validity\");\n\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            Entry entry = (Entry) o;\n            return id.equals(entry.id);\n        }\n\n        @Override\n        public int hashCode() {\n            return id.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return title;\n        }\n\n        public byte[] toByteArray() throws IOException {\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tObjectOutput out = null;\n\t\t\ttry {\n\t\t\t\tout = new ObjectOutputStream(bos);\n\t\t\t\tout.writeObject(this);\n\t\t\t\tout.flush();\n\t\t\t\treturn bos.toByteArray();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tbos.close();\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static Entry fromByteArray(byte[] byteArray) throws IOException, ClassNotFoundException {\n\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(byteArray);\n\t\t\tObjectInput in = null;\n\t\t\ttry {\n\t\t\t\tin = new ObjectInputStream(bis);\n\t\t\t\treturn (Entry) in.readObject();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static class EntryComparator implements Comparator<Entry> {\n\t\tprivate boolean byYear;\n\t\tprivate Collator collator;\n\n\t\tpublic EntryComparator(boolean byYear) {\n\t\t\tthis.byYear = byYear;\n\t\t\tthis.collator = Collator.getInstance(Locale.US);\n\t\t\tthis.collator.setStrength(Collator.PRIMARY);\n\t\t}\n\n\t\tpublic int compare(Entry lhs, Entry rhs) {\n\t\t\tif(lhs.isDirectory() && !rhs.isDirectory()) {\n\t\t\t\treturn -1;\n\t\t\t} else if(!lhs.isDirectory() && rhs.isDirectory()) {\n\t\t\t\treturn 1;\n\t\t\t} else if(lhs.isDirectory() && rhs.isDirectory()) {\n\t\t\t\tif(byYear) {\n\t\t\t\t\tInteger lhsYear = lhs.getYear();\n\t\t\t\t\tInteger rhsYear = rhs.getYear();\n\t\t\t\t\tif(lhsYear != null && rhsYear != null) {\n\t\t\t\t\t\treturn lhsYear.compareTo(rhsYear);\n\t\t\t\t\t} else if(lhsYear != null) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else if(rhsYear != null) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn collator.compare(lhs.getAlbumDisplay(), rhs.getAlbumDisplay());\n\t\t\t}\n\n\t\t\tInteger lhsDisc = lhs.getDiscNumber();\n\t\t\tInteger rhsDisc = rhs.getDiscNumber();\n\n\t\t\tif(lhsDisc != null && rhsDisc != null) {\n\t\t\t\tif(lhsDisc < rhsDisc) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if(lhsDisc > rhsDisc) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInteger lhsTrack = lhs.getTrack();\n\t\t\tInteger rhsTrack = rhs.getTrack();\n\t\t\tif(lhsTrack == rhsTrack) {\n\t\t\t\treturn collator.compare(lhs.getTitle(), rhs.getTitle());\n\t\t\t} else if(lhsTrack != null && rhsTrack != null) {\n\t\t\t\treturn lhsTrack.compareTo(rhsTrack);\n\t\t\t} else if(lhsTrack != null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic static void sort(List<Entry> entries) {\n\t\t\tsort(entries, true);\n\t\t}\n\t\tpublic static void sort(List<Entry> entries, boolean byYear) {\n\t\t\ttry {\n\t\t\t\tCollections.sort(entries, new EntryComparator(byYear));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to sort MusicDirectory\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'\n:\n\npackage github.daneren2005.dsub.adapter;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport github.daneren2005.dsub.R;\nimport github.daneren2005.dsub.domain.MusicDirectory.Entry;\nimport github.daneren2005.dsub.domain.SearchResult;\nimport github.daneren2005.dsub.util.DrawableTint;\nimport github.daneren2005.dsub.util.ImageLoader;\nimport github.daneren2005.dsub.util.Util;\nimport github.daneren2005.dsub.view.AlbumView;\nimport github.daneren2005.dsub.view.ArtistView;\nimport github.daneren2005.dsub.view.BasicHeaderView;\nimport github.daneren2005.dsub.view.SongView;\nimport github.daneren2005.dsub.view.UpdateView;\n\nimport static github.daneren2005.dsub.adapter.ArtistAdapter.VIEW_TYPE_ARTIST;\nimport static github.daneren2005.dsub.adapter.EntryGridAdapter.VIEW_TYPE_ALBUM_CELL;\nimport static github.daneren2005.dsub.adapter.EntryGridAdapter.VIEW_TYPE_ALBUM_LINE;\nimport static github.daneren2005.dsub.adapter.EntryGridAdapter.VIEW_TYPE_SONG;\n\npublic class SearchAdapter extends ExpandableSectionAdapter<Serializable> {\n\tprivate ImageLoader imageLoader;\n\tprivate boolean largeAlbums;\n\n\tprivate static final int MAX_ARTISTS = 10;\n\tprivate static final int MAX_ALBUMS = 4;\n\tprivate static final int MAX_SONGS = 10;\n\n\tpublic SearchAdapter(Context context, SearchResult searchResult, ImageLoader imageLoader, boolean largeAlbums, OnItemClickedListener listener) {\n\t\tthis.imageLoader = imageLoader;\n\t\tthis.largeAlbums = largeAlbums;\n\n\t\tList<List<Serializable>> sections = new ArrayList<>();\n\t\tList<String> headers = new ArrayList<>();\n\t\tList<Integer> defaultVisible = new ArrayList<>();\n\t\tResources res = context.getResources();\n\t\tif(!searchResult.getArtists().isEmpty()) {\n\t\t\tsections.add((List<Serializable>) (List<?>) searchResult.getArtists());\n\t\t\theaders.add(res.getString(R.string.search_artists));\n\t\t\tdefaultVisible.add(MAX_ARTISTS);\n\t\t}\n\t\tif(!searchResult.getAlbums().isEmpty()) {\n\t\t\tsections.add((List<Serializable>) (List<?>) searchResult.getAlbums());\n\t\t\theaders.add(res.getString(R.string.search_albums));\n\t\t\tdefaultVisible.add(MAX_ALBUMS);\n\t\t}\n\t\tif(!searchResult.getSongs().isEmpty()) {\n\t\t\tsections.add((List<Serializable>) (List<?>) searchResult.getSongs());\n\t\t\theaders.add(res.getString(R.string.search_songs));\n\t\t\tdefaultVisible.add(MAX_SONGS);\n\t\t}\n\t\tinit(context, headers, sections, defaultVisible);\n\n\t\tthis.onItemClickedListener = listener;\n\t\tcheckable = true;\n\t}\n\n\t@Override\n\tpublic UpdateView.UpdateViewHolder onCreateSectionViewHolder(ViewGroup parent, int viewType) {\n\t\tUpdateView updateView = null;\n\t\tif(viewType == VIEW_TYPE_ALBUM_CELL || viewType == VIEW_TYPE_ALBUM_LINE) {\n\t\t\tupdateView = new AlbumView(context, viewType == VIEW_TYPE_ALBUM_CELL);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tupdateView = new SongView(context);\n\t\t} else if(viewType == VIEW_TYPE_ARTIST) {\n\t\t\tupdateView = new ArtistView(context);\n\t\t}\n\n\t\treturn new UpdateView.UpdateViewHolder(updateView);\n\t}\n\n\t@Override\n\tpublic void onBindViewHolder(UpdateView.UpdateViewHolder holder, Serializable item, int viewType) {\n\t\tUpdateView view = holder.getUpdateView();\n\t\tif(viewType == VIEW_TYPE_ALBUM_CELL || viewType == VIEW_TYPE_ALBUM_LINE) {\n\t\t\tAlbumView albumView = (AlbumView) view;\n\t\t\talbumView.setObject((Entry) item, imageLoader);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tSongView songView = (SongView) view;\n\t\t\tsongView.setObject((Entry) item, true);\n\t\t} else if(viewType == VIEW_TYPE_ARTIST) {\n\t\t\tview.setObject(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getItemViewType(Serializable item) {\n\t\tif(item instanceof Entry) {\n\t\t\tEntry entry = (Entry) item;\n\t\t\tif (entry.isDirectory()) {\n\t\t\t\tif (largeAlbums) {\n\t\t\t\t\treturn VIEW_TYPE_ALBUM_CELL;\n\t\t\t\t} else {\n\t\t\t\t\treturn VIEW_TYPE_ALBUM_LINE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn VIEW_TYPE_SONG;\n\t\t\t}\n\t\t} else {\n\t\t\treturn VIEW_TYPE_ARTIST;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onCreateActionModeMenu(Menu menu, MenuInflater menuInflater) {\n\t\tif(Util.isOffline(context)) {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media_offline, menu);\n\t\t} else {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media, menu);\n\t\t}\n\n\t\tmenu.removeItem(R.id.menu_remove_playlist);\n\t}\n}\n",
        "gt": [
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.NonNull;\nimport android.support.graphics.drawable.AnimatedVectorDrawableCompat;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.ImageButton;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\nimport com.philliphsu.bottomsheetpickers.date.MonthPickerView.OnMonthClickListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\n\n\nclass PagingDayPickerView extends LinearLayout implements OnDateChangedListener, OnPageChangeListener, OnMonthClickListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n    static final int DAY_PICKER_INDEX = 0;\n    static final int MONTH_PICKER_INDEX = 1;\n\n    static int MONTH_NAVIGATION_BAR_SIZE;\n\n    private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected PagingMonthAdapter mAdapter;\n\n    private DayPickerViewAnimator mMonthAnimator;\n    private ViewPager mViewPager;\n    private MonthPickerView mMonthPickerView;\n    private TextView mMonthYearTitleView;\n    private ImageButton mPreviousButton;\n    private ImageButton mNextButton;\n    private View mTitleContainer;\n\n\n    private AnimatedVectorDrawableCompat mArrowDownDrawable;\n\n    private AnimatedVectorDrawableCompat mArrowUpDrawable;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mCurrentMonthDisplayed;\n\n    private int mCurrentView = DAY_PICKER_INDEX;\n\n    private int mCurrentYearDisplayed;\n\n    private DatePickerController mController;\n\n    private boolean mThemeDark;\n    private int mAccentColor;\n\n    public PagingDayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        this(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark,\n                               int accentColor) {\n        super(context);\n\n        mThemeDark = themeDark;\n        mAccentColor = accentColor;\n        init(context);\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n        mMonthPickerView.setDatePickerController(mController);\n    }\n\n    private void init(Context context) {\n        mHandler = new Handler();\n        setOrientation(VERTICAL);\n        setLayoutParams(new LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        Resources res = getResources();\n        MONTH_NAVIGATION_BAR_SIZE = res.getDimensionPixelOffset(R.dimen.bsp_month_navigation_bar_height)\n                + res.getDimensionPixelOffset(R.dimen.bsp_month_view_top_padding);\n\n        final View view = LayoutInflater.from(context).inflate(R.layout.bsp_day_picker_content, this, true);\n        mMonthAnimator = (DayPickerViewAnimator) findViewById(R.id.bsp_month_animator);\n        mMonthPickerView = (MonthPickerView) findViewById(R.id.bsp_month_picker);\n        mMonthPickerView.setOnMonthClickListener(this);\n        mViewPager = (ViewPager) findViewById(R.id.bsp_viewpager);\n        mViewPager.addOnPageChangeListener(this);\n        mMonthYearTitleView = (TextView) view.findViewById(R.id.bsp_month_year_title);\n        mTitleContainer = view.findViewById(R.id.bsp_month_year_title_container);\n        mTitleContainer.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int newIndex = mCurrentView == DAY_PICKER_INDEX ? MONTH_PICKER_INDEX : DAY_PICKER_INDEX;\n                setupCurrentView(newIndex, true);\n            }\n        });\n        mPreviousButton = (ImageButton) view.findViewById(R.id.bsp_prev);\n        mPreviousButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int previousItem = mViewPager.getCurrentItem() - 1;\n                if (previousItem >= 0) {\n                    mViewPager.setCurrentItem(previousItem, true);\n                }\n            }\n        });\n        mNextButton = (ImageButton) view.findViewById(R.id.bsp_next);\n        mNextButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int nextItem = mViewPager.getCurrentItem() + 1;\n                if (nextItem < mAdapter.getCount()) {\n                    mViewPager.setCurrentItem(nextItem, true);\n                }\n            }\n        });\n\n        mArrowDownDrawable = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_down);\n        mArrowUpDrawable   = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_up);\n        setArrowDrawableOnTitle(mArrowDownDrawable);\n\n\n        if (mThemeDark) {\n            int selectableItemBg = getColor(context, R.color.bsp_selectable_item_background_dark);\n            Utils.setColorControlHighlight(mPreviousButton, selectableItemBg);\n            Utils.setColorControlHighlight(mNextButton, selectableItemBg);\n            Utils.setColorControlHighlight(mTitleContainer, selectableItemBg);\n            int cursor = getColor(context, R.color.bsp_text_color_secondary_dark);\n            Utils.applyTint(mPreviousButton, cursor);\n            Utils.applyTint(mNextButton, cursor);\n        }\n\n\n        int monthYearTitleColor = getColor(context, mThemeDark?\n                R.color.bsp_text_color_primary_dark : R.color.bsp_text_color_primary_light);\n        int dropdownArrowColor = getColor(context, mThemeDark?\n                R.color.bsp_icon_color_active_dark : R.color.bsp_icon_color_active_light);\n\n        mMonthYearTitleView.setTextColor(monthYearTitleColor);\n        mArrowDownDrawable.setTint(dropdownArrowColor);\n        mArrowUpDrawable.setTint(dropdownArrowColor);\n\n        mMonthPickerView.setTheme(context, mThemeDark);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mViewPager.removeOnPageChangeListener(this);\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    void setAccentColor(@ColorInt int color) {\n        mAccentColor = color;\n        mMonthPickerView.setCurrentMonthTextColor(color);\n        mMonthPickerView.setSelectedCirclePaintColor(color);\n    }\n\n    public void onChange() {\n        refreshAdapter();\n        refreshMonthPicker();\n    }\n\n\n    void setupCurrentView(int currentView, boolean animate) {\n        if (currentView == DAY_PICKER_INDEX || currentView == MONTH_PICKER_INDEX) {\n            boolean isDayPicker = currentView == DAY_PICKER_INDEX;\n            setCurrentView(currentView, animate);\n            if (isDayPicker) {\n                setTitle(mAdapter.getPageTitle(mViewPager.getCurrentItem()));\n                toggleArrowsVisibility(getPagerPosition());\n            } else {\n\n\n\n                setTitle(String.valueOf(mCurrentYearDisplayed));\n                toggleArrowsVisibility(false, false);\n            }\n        } else {\n            Log.e(TAG, \"Error restoring current view\");\n        }\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            if (mAccentColor != 0) {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark, mAccentColor);\n            } else {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n            }\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        mViewPager.setAdapter(mAdapter);\n    }\n\n\n    private void refreshMonthPicker() {\n        prepareMonthPickerForDisplay(mSelectedDay.year);\n        mMonthPickerView.invalidate();\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller) {\n        return new PagingMonthAdapter(context, controller);\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark) {\n        return createMonthAdapter(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark,\n                                                 int accentColor) {\n        return new PagingMonthAdapter(context, controller, themeDark, accentColor);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n        final int selectedPosition = getPosition(mSelectedDay);\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = getPosition(day);\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthAndYearDisplayed(mTempDay);\n            if (animate) {\n                mViewPager.setCurrentItem(position, true);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n                return true;\n            } else {\n                postSetSelection(position, setSelected);\n            }\n        } else if (setSelected) {\n            setMonthAndYearDisplayed(mSelectedDay);\n            setSelectedDay(mSelectedDay);\n        }\n        return false;\n    }\n\n\n    private int getPosition(CalendarDay day) {\n        return mAdapter.getPosition(day);\n    }\n\n    public void postSetSelection(final int position, final boolean setSelected) {\n        clearFocus();\n        post(new Runnable() {\n            @Override\n            public void run() {\n                mViewPager.setCurrentItem(position, false);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n            }\n        });\n    }\n\n    void postSetupCurrentView(final int currentView, final boolean animate) {\n        post(new Runnable() {\n            @Override\n            public void run() {\n                setupCurrentView(currentView, animate);\n            }\n        });\n    }\n\n\n    protected void setMonthAndYearDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        mCurrentYearDisplayed = date.year;\n    }\n\n    private void setSelectedDay(CalendarDay day) {\n        mAdapter.setSelectedDay(day);\n    }\n\n    @Override\n    public void onDateChanged() {\n        if (mCurrentView != DAY_PICKER_INDEX) {\n            setCurrentView(DAY_PICKER_INDEX, false);\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getPagerPosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        return true;\n    }\n\n    int getPagerPosition() {\n        return mViewPager.getCurrentItem();\n    }\n\n    int getCurrentView() {\n        return mCurrentView;\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mCurrentView == DAY_PICKER_INDEX) {\n            setTitle(mAdapter.getPageTitle(position));\n            toggleArrowsVisibility(position);\n            final int month = mAdapter.getMonth(position);\n            final int year = mAdapter.getYear(position);\n            if (mCurrentYearDisplayed != year) {\n                mCurrentYearDisplayed = year;\n            }\n            if (mCurrentMonthDisplayed != month) {\n                mCurrentMonthDisplayed = month;\n            }\n        }\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n\n    private void setTitle(CharSequence title) {\n        mMonthYearTitleView.setText(title);\n    }\n\n\n    private void toggleArrowsVisibility(int position) {\n        toggleArrowsVisibility(position > 0, position + 1 < mAdapter.getCount());\n    }\n\n    private void toggleArrowsVisibility(boolean leftVisible, boolean rightVisible) {\n        mPreviousButton.setVisibility(leftVisible ? VISIBLE : INVISIBLE);\n        mNextButton.setVisibility(rightVisible ? VISIBLE : INVISIBLE);\n    }\n\n    private void setArrowDrawableOnTitle(@NonNull Drawable arrow) {\n        if (Utils.checkApiLevel(17)) {\n            mMonthYearTitleView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, arrow, null);\n        } else {\n            mMonthYearTitleView.setCompoundDrawablesWithIntrinsicBounds(null, null, arrow, null);\n        }\n    }\n\n    private void animateArrow(AnimatedVectorDrawableCompat arrow) {\n        setArrowDrawableOnTitle(arrow);\n        arrow.start();\n    }\n\n    private void setCurrentView(final int viewIndex, boolean animate) {\n        switch (viewIndex) {\n            case DAY_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    mMonthAnimator.setDisplayedChild(DAY_PICKER_INDEX, animate);\n                    animateArrow(mArrowUpDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n            case MONTH_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    prepareMonthPickerForDisplay(mCurrentYearDisplayed);\n                    mMonthAnimator.setDisplayedChild(MONTH_PICKER_INDEX, animate);\n                    animateArrow(mArrowDownDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n        }\n    }\n\n    private void prepareMonthPickerForDisplay(int currentYear) {\n        mMonthPickerView.setDisplayParams(mSelectedDay, currentYear);\n    }\n\n    @Override\n    public void onMonthClick(MonthPickerView view, int month, int year) {\n\n\n\n\n\n        setCurrentView(DAY_PICKER_INDEX, true);\n\n\n\n\n\n\n\n\n\n\n        if (month == mCurrentMonthDisplayed) {\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        mController.tryVibrate();\n        mController.onMonthYearSelected(month, year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/MonthPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/FaceDetectionActivity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'"
        ],
        "content": "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n\n'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/FaceDetectionActivity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Core;\nimport org.opencv.core.Mat;\nimport org.opencv.core.MatOfRect;\nimport org.opencv.core.Rect;\nimport org.opencv.core.Scalar;\nimport org.opencv.core.Size;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport org.opencv.objdetect.CascadeClassifier;\nimport org.opencv.imgproc.Imgproc;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.WindowManager;\n\nimport com.jnardari.opencv_androidsamples.R;\nimport com.jnardari.opencv_androidsamples.utils.DetectionBasedTracker;\n\npublic class FaceDetectionActivity extends AppCompatActivity implements CvCameraViewListener2 {\n\n    private static final String    TAG                 = \"OCVSample::Activity\";\n    private static final Scalar    FACE_RECT_COLOR     = new Scalar(0, 255, 0, 255);\n    public static final int        JAVA_DETECTOR       = 0;\n    public static final int        NATIVE_DETECTOR     = 1;\n\n    private MenuItem               mItemFace50;\n    private MenuItem               mItemFace40;\n    private MenuItem               mItemFace30;\n    private MenuItem               mItemFace20;\n    private MenuItem               mItemType;\n\n    private Mat                    mRgba;\n    private Mat                    mGray;\n    private File                   mCascadeFile;\n    private CascadeClassifier      mJavaDetector;\n    private DetectionBasedTracker  mNativeDetector;\n\n    private int                    mDetectorType       = JAVA_DETECTOR;\n    private String[]               mDetectorName;\n\n    private float                  mRelativeFaceSize   = 0.2f;\n    private int                    mAbsoluteFaceSize   = 0;\n\n    private CameraBridgeViewBase   mOpenCvCameraView;\n\n    private BaseLoaderCallback  mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n\n\n                    System.loadLibrary(\"ndklibrarysample\");\n\n                    try {\n\n                        InputStream is = getResources().openRawResource(R.raw.lbpcascade_frontalface);\n                        File cascadeDir = getDir(\"cascade\", Context.MODE_PRIVATE);\n                        mCascadeFile = new File(cascadeDir, \"lbpcascade_frontalface.xml\");\n                        FileOutputStream os = new FileOutputStream(mCascadeFile);\n\n                        byte[] buffer = new byte[4096];\n                        int bytesRead;\n                        while ((bytesRead = is.read(buffer)) != -1) {\n                            os.write(buffer, 0, bytesRead);\n                        }\n                        is.close();\n                        os.close();\n\n                        mJavaDetector = new CascadeClassifier(mCascadeFile.getAbsolutePath());\n                        if (mJavaDetector.empty()) {\n                            Log.e(TAG, \"Failed to load cascade classifier\");\n                            mJavaDetector = null;\n                        } else\n                            Log.i(TAG, \"Loaded cascade classifier from \" + mCascadeFile.getAbsolutePath());\n\n                        mNativeDetector = new DetectionBasedTracker(mCascadeFile.getAbsolutePath(), 0);\n\n                        cascadeDir.delete();\n\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                        Log.e(TAG, \"Failed to load cascade. Exception thrown: \" + e);\n                    }\n\n                    mOpenCvCameraView.enableView();\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public FaceDetectionActivity() {\n        mDetectorName = new String[2];\n        mDetectorName[JAVA_DETECTOR] = \"Java\";\n        mDetectorName[NATIVE_DETECTOR] = \"Native (tracking)\";\n\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_face_detection);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.fd_activity_surface_view);\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n        mGray = new Mat();\n        mRgba = new Mat();\n    }\n\n    public void onCameraViewStopped() {\n        mGray.release();\n        mRgba.release();\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n\n        mRgba = inputFrame.rgba();\n        mGray = inputFrame.gray();\n\n        if (mAbsoluteFaceSize == 0) {\n            int height = mGray.rows();\n            if (Math.round(height * mRelativeFaceSize) > 0) {\n                mAbsoluteFaceSize = Math.round(height * mRelativeFaceSize);\n            }\n            mNativeDetector.setMinFaceSize(mAbsoluteFaceSize);\n        }\n\n        MatOfRect faces = new MatOfRect();\n\n        if (mDetectorType == JAVA_DETECTOR) {\n            if (mJavaDetector != null)\n                mJavaDetector.detectMultiScale(mGray, faces, 1.1, 2, 2,\n                        new Size(mAbsoluteFaceSize, mAbsoluteFaceSize), new Size());\n        }\n        else if (mDetectorType == NATIVE_DETECTOR) {\n            if (mNativeDetector != null)\n                mNativeDetector.detect(mGray, faces);\n        }\n        else {\n            Log.e(TAG, \"Detection method is not selected!\");\n        }\n\n        Rect[] facesArray = faces.toArray();\n        for (int i = 0; i < facesArray.length; i++)\n            Imgproc.rectangle(mRgba, facesArray[i].tl(), facesArray[i].br(), FACE_RECT_COLOR, 3);\n\n        return mRgba;\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        Log.i(TAG, \"called onCreateOptionsMenu\");\n        mItemFace50 = menu.add(\"Face size 50%\");\n        mItemFace40 = menu.add(\"Face size 40%\");\n        mItemFace30 = menu.add(\"Face size 30%\");\n        mItemFace20 = menu.add(\"Face size 20%\");\n        mItemType   = menu.add(mDetectorName[mDetectorType]);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Log.i(TAG, \"called onOptionsItemSelected; selected item: \" + item);\n        if (item == mItemFace50)\n            setMinFaceSize(0.5f);\n        else if (item == mItemFace40)\n            setMinFaceSize(0.4f);\n        else if (item == mItemFace30)\n            setMinFaceSize(0.3f);\n        else if (item == mItemFace20)\n            setMinFaceSize(0.2f);\n        else if (item == mItemType) {\n            int tmpDetectorType = (mDetectorType + 1) % mDetectorName.length;\n            item.setTitle(mDetectorName[tmpDetectorType]);\n            setDetectorType(tmpDetectorType);\n        }\n        else if (item.getItemId() == android.R.id.home) {\n            finish();\n        }\n\n        return true;\n    }\n\n    private void setMinFaceSize(float faceSize) {\n        mRelativeFaceSize = faceSize;\n        mAbsoluteFaceSize = 0;\n    }\n\n    private void setDetectorType(int type) {\n        if (mDetectorType != type) {\n            mDetectorType = type;\n\n            if (type == NATIVE_DETECTOR) {\n                Log.i(TAG, \"Detection Based Tracker enabled\");\n                mNativeDetector.start();\n            } else {\n                Log.i(TAG, \"Cascade detector enabled\");\n                mNativeDetector.stop();\n            }\n        }\n    }\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/FaceDetectionActivity.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/api/src/test/java/com/netflix/iceberg/transforms/TestProjection.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'"
        ],
        "content": "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.generic.GenericData.Record;\nimport org.apache.orc.storage.serde2.io.DateWritable;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.catalyst.expressions.GenericRow;\nimport org.apache.spark.sql.catalyst.expressions.SpecializedGetters;\nimport org.apache.spark.sql.catalyst.util.ArrayData;\nimport org.apache.spark.sql.catalyst.util.DateTimeUtils;\nimport org.apache.spark.sql.catalyst.util.MapData;\nimport org.apache.spark.sql.types.Decimal;\nimport org.apache.spark.unsafe.types.UTF8String;\nimport org.junit.Assert;\nimport scala.collection.Seq;\nimport java.math.BigDecimal;\nimport java.nio.ByteBuffer;\nimport java.sql.Timestamp;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\nimport static scala.collection.JavaConverters.mapAsJavaMapConverter;\nimport static scala.collection.JavaConverters.seqAsJavaListConverter;\n\npublic class TestHelpers {\n\n  public static void assertEqualsSafe(Types.StructType struct, Record rec, Row row) {\n    List<Types.NestedField> fields = struct.fields();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Type fieldType = fields.get(i).type();\n\n      Object expectedValue = rec.get(i);\n      Object actualValue = row.get(i);\n\n      assertEqualsSafe(fieldType, expectedValue, actualValue);\n    }\n  }\n\n  private static void assertEqualsSafe(Types.ListType list, Collection<?> expected, List actual) {\n    Type elementType = list.elementType();\n    List<?> expectedElements = Lists.newArrayList(expected);\n    for (int i = 0; i < expectedElements.size(); i += 1) {\n      Object expectedValue = expectedElements.get(i);\n      Object actualValue = actual.get(i);\n\n      assertEqualsSafe(elementType, expectedValue, actualValue);\n    }\n  }\n\n  private static void assertEqualsSafe(Types.MapType map,\n                                       Map<?, ?> expected, Map<?, ?> actual) {\n    Type keyType = map.keyType();\n    Type valueType = map.valueType();\n\n    for (Object expectedKey : expected.keySet()) {\n      Object matchingKey = null;\n      for (Object actualKey : actual.keySet()) {\n        try {\n          assertEqualsSafe(keyType, expectedKey, actualKey);\n          matchingKey = actualKey;\n        } catch (AssertionError e) {\n\n        }\n      }\n\n      Assert.assertNotNull(\"Should have a matching key\", matchingKey);\n      assertEqualsSafe(valueType, expected.get(expectedKey), actual.get(matchingKey));\n    }\n  }\n\n  private static final OffsetDateTime EPOCH = Instant.ofEpochMilli(0L).atOffset(ZoneOffset.UTC);\n  private static final LocalDate EPOCH_DAY = EPOCH.toLocalDate();\n\n  @SuppressWarnings(\"unchecked\")\n  private static void assertEqualsSafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case DATE:\n        Assert.assertTrue(\"Should be an int\", expected instanceof Integer);\n        Assert.assertTrue(\"Should be a Date\", actual instanceof Date);\n        int daysFrom1970_01_01 = (Integer) expected;\n        LocalDate date = ChronoUnit.DAYS.addTo(EPOCH_DAY, daysFrom1970_01_01);\n        Assert.assertEquals(\"ISO-8601 date should be equal\", date.toString(), actual.toString());\n        break;\n      case TIMESTAMP:\n        Assert.assertTrue(\"Should be a long\", expected instanceof Long);\n        Assert.assertTrue(\"Should be a Timestamp\", actual instanceof Timestamp);\n        Timestamp ts = (Timestamp) actual;\n\n        long tsMicros = (ts.getTime() * 1000) + ((ts.getNanos() / 1000) % 1000);\n        Assert.assertEquals(\"Timestamp micros should be equal\", expected, tsMicros);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual);\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a String\", actual instanceof String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual);\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a BigDecimal\", actual instanceof BigDecimal);\n        Assert.assertEquals(\"BigDecimals should be equal\", expected, actual);\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be a Row\", actual instanceof Row);\n        assertEqualsSafe(type.asNestedType().asStructType(), (Record) expected, (Row) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be a Seq\", actual instanceof Seq);\n        List<?> asList = seqAsJavaListConverter((Seq<?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asListType(), (Collection) expected, asList);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Map);\n        Assert.assertTrue(\"Should be a Map\", actual instanceof scala.collection.Map);\n        Map<String, ?> asMap = mapAsJavaMapConverter(\n            (scala.collection.Map<String, ?>) actual).asJava();\n        assertEqualsSafe(type.asNestedType().asMapType(), (Map<String, ?>) expected, asMap);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n\n  public static void assertEqualsUnsafe(Types.StructType struct, Record rec, InternalRow row) {\n    List<Types.NestedField> fields = struct.fields();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Type fieldType = fields.get(i).type();\n\n      Object expectedValue = rec.get(i);\n      Object actualValue = row.get(i, convert(fieldType));\n\n      assertEqualsUnsafe(fieldType, expectedValue, actualValue);\n    }\n  }\n\n  private static void assertEqualsUnsafe(Types.ListType list, Collection<?> expected, ArrayData actual) {\n    Type elementType = list.elementType();\n    List<?> expectedElements = Lists.newArrayList(expected);\n    for (int i = 0; i < expectedElements.size(); i += 1) {\n      Object expectedValue = expectedElements.get(i);\n      Object actualValue = actual.get(i, convert(elementType));\n\n      assertEqualsUnsafe(elementType, expectedValue, actualValue);\n    }\n  }\n\n  private static void assertEqualsUnsafe(Types.MapType map, Map<?, ?> expected, MapData actual) {\n    Type keyType = map.keyType();\n    Type valueType = map.valueType();\n\n    List<Map.Entry<?, ?>> expectedElements = Lists.newArrayList(expected.entrySet());\n    ArrayData actualKeys = actual.keyArray();\n    ArrayData actualValues = actual.valueArray();\n\n    for (int i = 0; i < expectedElements.size(); i += 1) {\n      Map.Entry<?, ?> expectedPair = expectedElements.get(i);\n      Object actualKey = actualKeys.get(i, convert(keyType));\n      Object actualValue = actualValues.get(i, convert(keyType));\n\n      assertEqualsUnsafe(keyType, expectedPair.getKey(), actualKey);\n      assertEqualsUnsafe(valueType, expectedPair.getValue(), actualValue);\n    }\n  }\n\n  private static void assertEqualsUnsafe(Type type, Object expected, Object actual) {\n    if (expected == null && actual == null) {\n      return;\n    }\n\n    switch (type.typeId()) {\n      case BOOLEAN:\n      case INTEGER:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n      case DATE:\n      case TIMESTAMP:\n        Assert.assertEquals(\"Primitive value should be equal to expected\", expected, actual);\n        break;\n      case STRING:\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"Strings should be equal\", expected, actual.toString());\n        break;\n      case UUID:\n        Assert.assertTrue(\"Should expect a UUID\", expected instanceof UUID);\n        Assert.assertTrue(\"Should be a UTF8String\", actual instanceof UTF8String);\n        Assert.assertEquals(\"UUID string representation should match\",\n            expected.toString(), actual.toString());\n        break;\n      case FIXED:\n        Assert.assertTrue(\"Should expect a Fixed\", expected instanceof GenericData.Fixed);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((GenericData.Fixed) expected).bytes(), (byte[]) actual);\n        break;\n      case BINARY:\n        Assert.assertTrue(\"Should expect a ByteBuffer\", expected instanceof ByteBuffer);\n        Assert.assertTrue(\"Should be a byte[]\", actual instanceof byte[]);\n        Assert.assertArrayEquals(\"Bytes should match\",\n            ((ByteBuffer) expected).array(), (byte[]) actual);\n        break;\n      case DECIMAL:\n        Assert.assertTrue(\"Should expect a BigDecimal\", expected instanceof BigDecimal);\n        Assert.assertTrue(\"Should be a Decimal\", actual instanceof Decimal);\n        Assert.assertEquals(\"BigDecimals should be equal\",\n            expected, ((Decimal) actual).toJavaBigDecimal());\n        break;\n      case STRUCT:\n        Assert.assertTrue(\"Should expect a Record\", expected instanceof Record);\n        Assert.assertTrue(\"Should be an InternalRow\", actual instanceof InternalRow);\n        assertEqualsUnsafe(type.asNestedType().asStructType(), (Record) expected, (InternalRow) actual);\n        break;\n      case LIST:\n        Assert.assertTrue(\"Should expect a Collection\", expected instanceof Collection);\n        Assert.assertTrue(\"Should be an ArrayData\", actual instanceof ArrayData);\n        assertEqualsUnsafe(type.asNestedType().asListType(), (Collection) expected, (ArrayData) actual);\n        break;\n      case MAP:\n        Assert.assertTrue(\"Should expect a Map\", expected instanceof Map);\n        Assert.assertTrue(\"Should be an ArrayBasedMapData\", actual instanceof MapData);\n        assertEqualsUnsafe(type.asNestedType().asMapType(), (Map) expected, (MapData) actual);\n        break;\n      case TIME:\n      default:\n        throw new IllegalArgumentException(\"Not a supported type: \" + type);\n    }\n  }\n\n\n  public static void assertEquals(String prefix, Types.StructType type,\n                                  InternalRow expected, Row actual) {\n    if (expected == null || actual == null) {\n      Assert.assertEquals(prefix, expected, actual);\n    } else {\n      List<Types.NestedField> fields = type.fields();\n      for (int c = 0; c < fields.size(); ++c) {\n        String fieldName = fields.get(c).name();\n        Type childType = fields.get(c).type();\n        switch (childType.typeId()) {\n          case BOOLEAN:\n          case INTEGER:\n          case LONG:\n          case FLOAT:\n          case DOUBLE:\n          case STRING:\n          case DECIMAL:\n          case DATE:\n          case TIMESTAMP:\n            Assert.assertEquals(prefix + \".\" + fieldName + \" - \" + childType,\n                getValue(expected, c, childType),\n                getPrimitiveValue(actual, c, childType));\n            break;\n          case UUID:\n          case FIXED:\n          case BINARY:\n            assertEqualBytes(prefix + \".\" + fieldName,\n                (byte[]) getValue(expected, c, childType),\n                (byte[]) actual.get(c));\n            break;\n          case STRUCT: {\n            Types.StructType st = (Types.StructType) childType;\n            assertEquals(prefix + \".\" + fieldName, st,\n                expected.getStruct(c, st.fields().size()), actual.getStruct(c));\n            break;\n          }\n          case LIST:\n            assertEqualsLists(prefix + \".\" + fieldName, childType.asListType(),\n                expected.getArray(c),\n                toList((Seq<?>) actual.get(c)));\n            break;\n          case MAP:\n            assertEqualsMaps(prefix + \".\" + fieldName, childType.asMapType(), expected.getMap(c),\n                toJavaMap((scala.collection.Map<?, ?>) actual.getMap(c)));\n            break;\n          default:\n            throw new IllegalArgumentException(\"Unhandled type \" + childType);\n        }\n      }\n    }\n  }\n\n  private static void assertEqualsLists(String prefix, Types.ListType type,\n                                        ArrayData expected, List actual) {\n    if (expected == null || actual == null) {\n      Assert.assertEquals(prefix, expected, actual);\n    } else {\n      Assert.assertEquals(prefix + \" length\", expected.numElements(), actual.size());\n      Type childType = type.elementType();\n      for (int e = 0; e < expected.numElements(); ++e) {\n        switch (childType.typeId()) {\n          case BOOLEAN:\n          case INTEGER:\n          case LONG:\n          case FLOAT:\n          case DOUBLE:\n          case STRING:\n          case DECIMAL:\n          case DATE:\n          case TIMESTAMP:\n            Assert.assertEquals(prefix + \".elem \" + e + \" - \" + childType,\n                getValue(expected, e, childType),\n                actual.get(e));\n            break;\n          case UUID:\n          case FIXED:\n          case BINARY:\n            assertEqualBytes(prefix + \".elem \" + e,\n                (byte[]) getValue(expected, e, childType),\n                (byte[]) actual.get(e));\n            break;\n          case STRUCT: {\n            Types.StructType st = (Types.StructType) childType;\n            assertEquals(prefix + \".elem \" + e, st,\n                expected.getStruct(e, st.fields().size()), (Row) actual.get(e));\n            break;\n          }\n          case LIST:\n            assertEqualsLists(prefix + \".elem \" + e, childType.asListType(),\n                expected.getArray(e),\n                toList((Seq<?>) actual.get(e)));\n            break;\n          case MAP:\n            assertEqualsMaps(prefix + \".elem \" + e, childType.asMapType(),\n                expected.getMap(e), toJavaMap((scala.collection.Map<?, ?>) actual.get(e)));\n            break;\n          default:\n            throw new IllegalArgumentException(\"Unhandled type \" + childType);\n        }\n      }\n    }\n  }\n\n  private static void assertEqualsMaps(String prefix, Types.MapType type,\n                                       MapData expected, Map<?, ?> actual) {\n    if (expected == null || actual == null) {\n      Assert.assertEquals(prefix, expected, actual);\n    } else {\n      Type keyType = type.keyType();\n      Type valueType = type.valueType();\n      ArrayData expectedKeyArray = expected.keyArray();\n      ArrayData expectedValueArray = expected.valueArray();\n      Assert.assertEquals(prefix + \" length\", expected.numElements(), actual.size());\n      for (int e = 0; e < expected.numElements(); ++e) {\n        Object expectedKey = getValue(expectedKeyArray, e, keyType);\n        Object actualValue = actual.get(expectedKey);\n        if (actualValue == null) {\n          Assert.assertEquals(prefix + \".key=\" + expectedKey + \" has null\", true,\n              expected.valueArray().isNullAt(e));\n        } else {\n          switch (valueType.typeId()) {\n            case BOOLEAN:\n            case INTEGER:\n            case LONG:\n            case FLOAT:\n            case DOUBLE:\n            case STRING:\n            case DECIMAL:\n            case DATE:\n            case TIMESTAMP:\n              Assert.assertEquals(prefix + \".key=\" + expectedKey + \" - \" + valueType,\n                  getValue(expectedValueArray, e, valueType),\n                  actual.get(expectedKey));\n              break;\n            case UUID:\n            case FIXED:\n            case BINARY:\n              assertEqualBytes(prefix + \".key=\" + expectedKey,\n                  (byte[]) getValue(expectedValueArray, e, valueType),\n                  (byte[]) actual.get(expectedKey));\n              break;\n            case STRUCT: {\n              Types.StructType st = (Types.StructType) valueType;\n              assertEquals(prefix + \".key=\" + expectedKey, st,\n                  expectedValueArray.getStruct(e, st.fields().size()),\n                  (Row) actual.get(expectedKey));\n              break;\n            }\n            case LIST:\n              assertEqualsLists(prefix + \".key=\" + expectedKey,\n                  valueType.asListType(),\n                  expectedValueArray.getArray(e),\n                  toList((Seq<?>) actual.get(expectedKey)));\n              break;\n            case MAP:\n              assertEqualsMaps(prefix + \".key=\" + expectedKey, valueType.asMapType(),\n                  expectedValueArray.getMap(e),\n                  toJavaMap((scala.collection.Map<?, ?>) actual.get(expectedKey)));\n              break;\n            default:\n              throw new IllegalArgumentException(\"Unhandled type \" + valueType);\n          }\n        }\n      }\n    }\n  }\n\n  private static Object getValue(SpecializedGetters container, int ord,\n                                 Type type) {\n    if (container.isNullAt(ord)) {\n      return null;\n    }\n    switch (type.typeId()) {\n      case BOOLEAN:\n        return container.getBoolean(ord);\n      case INTEGER:\n        return container.getInt(ord);\n      case LONG:\n        return container.getLong(ord);\n      case FLOAT:\n        return container.getFloat(ord);\n      case DOUBLE:\n        return container.getDouble(ord);\n      case STRING:\n        return container.getUTF8String(ord).toString();\n      case BINARY:\n      case FIXED:\n      case UUID:\n        return container.getBinary(ord);\n      case DATE:\n        return new DateWritable(container.getInt(ord)).get();\n      case TIMESTAMP:\n        return DateTimeUtils.toJavaTimestamp(container.getLong(ord));\n      case DECIMAL: {\n        Types.DecimalType dt = (Types.DecimalType) type;\n        return container.getDecimal(ord, dt.precision(), dt.scale()).toJavaBigDecimal();\n      }\n      case STRUCT:\n        Types.StructType struct = type.asStructType();\n        InternalRow internalRow = container.getStruct(ord, struct.fields().size());\n        Object[] data = new Object[struct.fields().size()];\n        for (int i = 0; i < data.length; i += 1) {\n          if (internalRow.isNullAt(i)) {\n            data[i] = null;\n          } else {\n            data[i] = getValue(internalRow, i, struct.fields().get(i).type());\n          }\n        }\n        return new GenericRow(data);\n      default:\n        throw new IllegalArgumentException(\"Unhandled type \" + type);\n    }\n  }\n\n  private static Object getPrimitiveValue(Row row, int ord, Type type) {\n    if (row.isNullAt(ord)) {\n      return null;\n    }\n    switch (type.typeId()) {\n      case BOOLEAN:\n        return row.getBoolean(ord);\n      case INTEGER:\n        return row.getInt(ord);\n      case LONG:\n        return row.getLong(ord);\n      case FLOAT:\n        return row.getFloat(ord);\n      case DOUBLE:\n        return row.getDouble(ord);\n      case STRING:\n        return row.getString(ord);\n      case BINARY:\n      case FIXED:\n      case UUID:\n        return row.get(ord);\n      case DATE:\n        return row.getDate(ord);\n      case TIMESTAMP:\n        return row.getTimestamp(ord);\n      case DECIMAL:\n        return row.getDecimal(ord);\n      default:\n        throw new IllegalArgumentException(\"Unhandled type \" + type);\n    }\n  }\n\n  private static <K, V> Map<K, V> toJavaMap(scala.collection.Map<K, V> map) {\n    return map == null ? null : mapAsJavaMapConverter(map).asJava();\n  }\n\n  private static List toList(Seq<?> val) {\n    return val == null ? null : seqAsJavaListConverter(val).asJava();\n  }\n\n  private static void assertEqualBytes(String context, byte[] expected,\n                                       byte[] actual) {\n    if (expected == null || actual == null) {\n      Assert.assertEquals(context, expected, actual);\n    } else {\n      Assert.assertArrayEquals(context, expected, actual);\n    }\n  }\n}\n\n'iceberg/api/src/test/java/com/netflix/iceberg/transforms/TestProjection.java'\n:\n\npackage com.netflix.iceberg.transforms;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.BoundPredicate;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.expressions.Expressions;\nimport com.netflix.iceberg.expressions.Or;\nimport com.netflix.iceberg.expressions.Projections;\nimport com.netflix.iceberg.expressions.UnboundPredicate;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.types.Types;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport java.util.List;\n\nimport static com.netflix.iceberg.TestHelpers.assertAndUnwrap;\nimport static com.netflix.iceberg.TestHelpers.assertAndUnwrapUnbound;\nimport static com.netflix.iceberg.expressions.Expressions.and;\nimport static com.netflix.iceberg.expressions.Expressions.equal;\nimport static com.netflix.iceberg.expressions.Expressions.greaterThanOrEqual;\nimport static com.netflix.iceberg.expressions.Expressions.lessThanOrEqual;\nimport static com.netflix.iceberg.expressions.Expressions.or;\nimport static com.netflix.iceberg.types.Types.NestedField.optional;\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\npublic class TestProjection {\n  private static final Schema SCHEMA = new Schema(\n      optional(16, \"id\", Types.LongType.get())\n  );\n\n  @Test\n  public void testIdentityProjection() {\n    List<UnboundPredicate<?>> predicates = Lists.newArrayList(\n        Expressions.notNull(\"id\"),\n        Expressions.isNull(\"id\"),\n        Expressions.lessThan(\"id\", 100),\n        Expressions.lessThanOrEqual(\"id\", 101),\n        Expressions.greaterThan(\"id\", 102),\n        Expressions.greaterThanOrEqual(\"id\", 103),\n        Expressions.equal(\"id\", 104),\n        Expressions.notEqual(\"id\", 105)\n    );\n\n    PartitionSpec spec = PartitionSpec.builderFor(SCHEMA)\n        .identity(\"id\")\n        .build();\n\n    for (UnboundPredicate<?> predicate : predicates) {\n\n      Expression expr = Projections.inclusive(spec).project(predicate);\n      UnboundPredicate<?> projected = assertAndUnwrapUnbound(expr);\n\n\n      BoundPredicate<?> bound = assertAndUnwrap(predicate.bind(spec.schema().asStruct()));\n\n      Assert.assertEquals(\"Field name should match partition struct field\",\n          \"id\", projected.ref().name());\n      Assert.assertEquals(\"Operation should match\", bound.op(), projected.op());\n\n      if (bound.literal() != null) {\n        Assert.assertEquals(\"Literal should be equal\",\n            bound.literal().value(), projected.literal().value());\n      } else {\n        Assert.assertNull(\"Literal should be null\", projected.literal());\n      }\n    }\n  }\n\n  @Test\n  public void testStrictIdentityProjection() {\n    List<UnboundPredicate<?>> predicates = Lists.newArrayList(\n        Expressions.notNull(\"id\"),\n        Expressions.isNull(\"id\"),\n        Expressions.lessThan(\"id\", 100),\n        Expressions.lessThanOrEqual(\"id\", 101),\n        Expressions.greaterThan(\"id\", 102),\n        Expressions.greaterThanOrEqual(\"id\", 103),\n        Expressions.equal(\"id\", 104),\n        Expressions.notEqual(\"id\", 105)\n    );\n\n    PartitionSpec spec = PartitionSpec.builderFor(SCHEMA)\n        .identity(\"id\")\n        .build();\n\n    for (UnboundPredicate<?> predicate : predicates) {\n\n      Expression expr = Projections.strict(spec).project(predicate);\n      UnboundPredicate<?> projected = assertAndUnwrapUnbound(expr);\n\n\n      BoundPredicate<?> bound = assertAndUnwrap(predicate.bind(spec.schema().asStruct()));\n\n      Assert.assertEquals(\"Field name should match partition struct field\",\n          \"id\", projected.ref().name());\n      Assert.assertEquals(\"Operation should match\", bound.op(), projected.op());\n\n      if (bound.literal() != null) {\n        Assert.assertEquals(\"Literal should be equal\",\n            bound.literal().value(), projected.literal().value());\n      } else {\n        Assert.assertNull(\"Literal should be null\", projected.literal());\n      }\n    }\n  }\n\n  @Test\n  public void testBadSparkPartitionFilter() {\n\n\n\n\n\n\n\n\n\n    Schema schema = new Schema(\n        required(1, \"id\", Types.LongType.get()),\n        optional(2, \"data\", Types.StringType.get()),\n        required(3, \"hour\", Types.IntegerType.get()),\n        required(4, \"dateint\", Types.IntegerType.get()));\n\n    PartitionSpec spec = PartitionSpec.builderFor(schema)\n        .identity(\"dateint\")\n        .build();\n\n    Expression filter = or(equal(\"dateint\", 20180416), or(\n        and(equal(\"dateint\", 20180415), greaterThanOrEqual(\"hour\", 20)),\n        and(equal(\"dateint\", 20180417), lessThanOrEqual(\"hour\", 4))));\n\n    Expression projection = Projections.inclusive(spec).project(filter);\n\n    Assert.assertTrue(projection instanceof Or);\n    Or or1 = (Or) projection;\n    UnboundPredicate<?> dateint1 = assertAndUnwrapUnbound(or1.left());\n    Assert.assertEquals(\"Should be a dateint predicate\", \"dateint\", dateint1.ref().name());\n    Assert.assertEquals(\"Should be dateint=20180416\", 20180416, dateint1.literal().value());\n    Assert.assertTrue(or1.right() instanceof Or);\n    Or or2 = (Or) or1.right();\n    UnboundPredicate<?> dateint2 = assertAndUnwrapUnbound(or2.left());\n    Assert.assertEquals(\"Should be a dateint predicate\", \"dateint\", dateint2.ref().name());\n    Assert.assertEquals(\"Should be dateint=20180415\", 20180415, dateint2.literal().value());\n    UnboundPredicate<?> dateint3 = assertAndUnwrapUnbound(or2.right());\n    Assert.assertEquals(\"Should be a dateint predicate\", \"dateint\", dateint3.ref().name());\n    Assert.assertEquals(\"Should be dateint=20180417\", 20180417, dateint3.literal().value());\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/data/TestHelpers.java'",
            "'iceberg/api/src/test/java/com/netflix/iceberg/transforms/TestProjection.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkExpressions.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/expressions/InclusiveMetricsEvaluator.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/expressions/ExpressionVisitors.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkExpressions.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.BoundReference;\nimport com.netflix.iceberg.expressions.Expression.Operation;\nimport com.netflix.iceberg.expressions.ExpressionVisitors;\nimport com.netflix.iceberg.types.Types.TimestampType;\nimport com.netflix.iceberg.util.Pair;\nimport org.apache.spark.sql.Column;\nimport org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute;\nimport org.apache.spark.sql.catalyst.expressions.And;\nimport org.apache.spark.sql.catalyst.expressions.And$;\nimport org.apache.spark.sql.catalyst.expressions.Attribute;\nimport org.apache.spark.sql.catalyst.expressions.AttributeReference;\nimport org.apache.spark.sql.catalyst.expressions.BinaryExpression;\nimport org.apache.spark.sql.catalyst.expressions.Cast;\nimport org.apache.spark.sql.catalyst.expressions.EqualNullSafe;\nimport org.apache.spark.sql.catalyst.expressions.EqualTo;\nimport org.apache.spark.sql.catalyst.expressions.Expression;\nimport org.apache.spark.sql.catalyst.expressions.GreaterThan;\nimport org.apache.spark.sql.catalyst.expressions.GreaterThanOrEqual;\nimport org.apache.spark.sql.catalyst.expressions.In;\nimport org.apache.spark.sql.catalyst.expressions.InSet;\nimport org.apache.spark.sql.catalyst.expressions.IsNotNull;\nimport org.apache.spark.sql.catalyst.expressions.IsNull;\nimport org.apache.spark.sql.catalyst.expressions.LessThan;\nimport org.apache.spark.sql.catalyst.expressions.LessThanOrEqual;\nimport org.apache.spark.sql.catalyst.expressions.Literal;\nimport org.apache.spark.sql.catalyst.expressions.Not;\nimport org.apache.spark.sql.catalyst.expressions.Not$;\nimport org.apache.spark.sql.catalyst.expressions.Or;\nimport org.apache.spark.sql.catalyst.expressions.Or$;\nimport org.apache.spark.sql.catalyst.expressions.ParseToDate;\nimport org.apache.spark.sql.catalyst.expressions.UnaryExpression;\nimport org.apache.spark.sql.catalyst.expressions.Year;\nimport org.apache.spark.sql.functions$;\nimport org.apache.spark.sql.types.DateType$;\nimport org.apache.spark.sql.types.Decimal;\nimport org.apache.spark.unsafe.types.UTF8String;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport static com.netflix.iceberg.expressions.ExpressionVisitors.visit;\nimport static com.netflix.iceberg.expressions.Expressions.alwaysFalse;\nimport static com.netflix.iceberg.expressions.Expressions.and;\nimport static com.netflix.iceberg.expressions.Expressions.equal;\nimport static com.netflix.iceberg.expressions.Expressions.not;\nimport static com.netflix.iceberg.expressions.Expressions.or;\nimport static com.netflix.iceberg.expressions.Expressions.predicate;\nimport static scala.collection.JavaConverters.seqAsJavaListConverter;\nimport static scala.collection.JavaConverters.setAsJavaSetConverter;\n\n\npublic class SparkExpressions {\n  private SparkExpressions() {\n  }\n\n  private static final Map<Class<? extends Expression>, Operation> FILTERS = ImmutableMap\n      .<Class<? extends Expression>, Operation>builder()\n      .put(EqualTo.class, Operation.EQ)\n      .put(EqualNullSafe.class, Operation.EQ)\n      .put(GreaterThan.class, Operation.GT)\n      .put(GreaterThanOrEqual.class, Operation.GT_EQ)\n      .put(LessThan.class, Operation.LT)\n      .put(LessThanOrEqual.class, Operation.LT_EQ)\n      .put(In.class, Operation.IN)\n      .put(InSet.class, Operation.IN)\n      .put(IsNull.class, Operation.IS_NULL)\n      .put(IsNotNull.class, Operation.NOT_NULL)\n      .put(And.class, Operation.AND)\n      .put(Or.class, Operation.OR)\n      .put(Not.class, Operation.NOT)\n      .build();\n\n  public static com.netflix.iceberg.expressions.Expression convert(Expression expr) {\n    Class<? extends Expression> exprClass = expr.getClass();\n    Operation op = FILTERS.get(exprClass);\n    if (op != null) {\n      switch (op) {\n        case IS_NULL:\n        case NOT_NULL:\n          UnaryExpression unary = (UnaryExpression) expr;\n          if (unary.child() instanceof Attribute) {\n            Attribute attr = (Attribute) unary.child();\n            return predicate(op, attr.name());\n          }\n          return null;\n        case LT:\n        case LT_EQ:\n        case GT:\n        case GT_EQ:\n        case EQ:\n        case NOT_EQ:\n          BinaryExpression binary = (BinaryExpression) expr;\n          return convert(op, binary.left(), binary.right());\n        case NOT:\n          com.netflix.iceberg.expressions.Expression child = convert(((Not) expr).child());\n          if (child != null) {\n            return not(child);\n          }\n          return null;\n        case AND:\n          And andExpr = (And) expr;\n          com.netflix.iceberg.expressions.Expression andLeft = convert(andExpr.left());\n          com.netflix.iceberg.expressions.Expression andRight = convert(andExpr.right());\n          if (andLeft != null && andRight != null) {\n            return and(convert(andExpr.left()), convert(andExpr.right()));\n          }\n          return null;\n        case OR:\n          Or orExpr = (Or) expr;\n          com.netflix.iceberg.expressions.Expression orLeft = convert(orExpr.left());\n          com.netflix.iceberg.expressions.Expression orRight = convert(orExpr.right());\n          if (orLeft != null && orRight != null) {\n            return or(orLeft, orRight);\n          }\n          return null;\n        case IN:\n          if (expr instanceof In) {\n            In inExpr = (In) expr;\n            List<Object> literals = convertLiterals(seqAsJavaListConverter(inExpr.list()).asJava());\n            if (literals != null) {\n              return convertIn(inExpr.value(), literals);\n            } else {\n\n              return null;\n            }\n          } else if (expr instanceof InSet) {\n            InSet inExpr = (InSet) expr;\n\n            Set<Object> literals = setAsJavaSetConverter(inExpr.hset()).asJava();\n            return convertIn(inExpr.child(), literals);\n          }\n        default:\n      }\n    }\n\n    return null;\n  }\n\n  private enum Transform {\n    IDENTITY,\n    YEAR,\n    DAY,\n  }\n\n  private static final Map<Class<? extends Expression>, Transform> TRANSFORMS = ImmutableMap\n      .<Class<? extends Expression>, Transform>builder()\n      .put(UnresolvedAttribute.class, Transform.IDENTITY)\n      .put(AttributeReference.class, Transform.IDENTITY)\n      .put(Year.class, Transform.YEAR)\n      .put(ParseToDate.class, Transform.DAY)\n      .put(Cast.class, Transform.DAY)\n      .build();\n\n  private static com.netflix.iceberg.expressions.Expression convertIn(Expression expr,\n                                                                      Collection<Object> values) {\n    if (expr instanceof Attribute) {\n      Attribute attr = (Attribute) expr;\n      com.netflix.iceberg.expressions.Expression converted = alwaysFalse();\n      for (Object item : values) {\n        converted = or(converted, equal(attr.name(), item));\n      }\n      return converted;\n    }\n\n    return null;\n  }\n\n  private static List<Object> convertLiterals(List<Expression> values) {\n    List<Object> converted = Lists.newArrayListWithExpectedSize(values.size());\n\n    for (Expression value : values) {\n      if (value instanceof Literal) {\n        Literal lit = (Literal) value;\n        converted.add(valueFromSpark(lit));\n      } else {\n        return null;\n      }\n    }\n\n    return converted;\n  }\n\n  private static com.netflix.iceberg.expressions.Expression convert(Operation op,\n                                                                    Expression left,\n                                                                    Expression right) {\n    Pair<Transform, String> attrPair = null;\n    Operation leftOperation = null;\n    Literal lit = null;\n\n    if (right instanceof Literal) {\n      lit = (Literal) right;\n      attrPair = convertAttr(left);\n      leftOperation = op;\n    } else if (left instanceof Literal) {\n      lit = (Literal) left;\n      attrPair = convertAttr(right);\n      leftOperation = op.flipLR();\n    }\n\n    if (attrPair != null) {\n      switch (attrPair.first()) {\n        case IDENTITY:\n          return predicate(leftOperation, attrPair.second(), valueFromSpark(lit));\n        case YEAR:\n          return filter(leftOperation, attrPair.second(), (int) lit.value(),\n              SparkExpressions::yearToTimestampMicros);\n        case DAY:\n          return filter(leftOperation, attrPair.second(), (int) lit.value(),\n              SparkExpressions::dayToTimestampMicros);\n        default:\n      }\n    }\n\n    return null;\n  }\n\n  private static Object valueFromSpark(Literal lit) {\n    if (lit.value() instanceof UTF8String) {\n      return lit.value().toString();\n    } else if (lit.value() instanceof Decimal) {\n      return ((Decimal) lit.value()).toJavaBigDecimal();\n    }\n    return lit.value();\n  }\n\n  private static Pair<Transform, String> convertAttr(Expression expr) {\n    Transform type = TRANSFORMS.get(expr.getClass());\n    if (type == Transform.IDENTITY) {\n      Attribute attr = (Attribute) expr;\n      return Pair.of(type, attr.name());\n\n    } else if (expr instanceof Cast) {\n      Cast cast = (Cast) expr;\n      if (DateType$.MODULE$.sameType(cast.dataType()) && cast.child() instanceof Attribute) {\n        Attribute attr = (Attribute) cast.child();\n        return Pair.of(Transform.DAY, attr.name());\n      }\n\n    } else if (expr instanceof ParseToDate) {\n      ParseToDate toDate = (ParseToDate) expr;\n      if (toDate.left() instanceof Attribute) {\n        Attribute attr = (Attribute) toDate.left();\n        return Pair.of(Transform.DAY, attr.name());\n      }\n\n    } else if (expr instanceof UnaryExpression) {\n      UnaryExpression func = (UnaryExpression) expr;\n      if (func.child() instanceof Attribute) {\n        Attribute attr = (Attribute) func.child();\n        return Pair.of(type, attr.name());\n      }\n    }\n\n    return null;\n  }\n\n  private static final OffsetDateTime EPOCH = Instant.ofEpochSecond(0).atOffset(ZoneOffset.UTC);\n  private static final LocalDate EPOCH_DAY = EPOCH.toLocalDate();\n\n  private static long yearToTimestampMicros(int year) {\n    return ChronoUnit.MICROS.between(EPOCH,\n        LocalDateTime.of(year, 1, 1, 0, 0).atOffset(ZoneOffset.UTC));\n  }\n\n  private static long dayToTimestampMicros(int daysFromEpoch) {\n    return ChronoUnit.MICROS.between(EPOCH,\n        EPOCH_DAY.plusDays(daysFromEpoch).atStartOfDay().atOffset(ZoneOffset.UTC));\n  }\n\n  private static com.netflix.iceberg.expressions.Literal<Long> tsLiteral(long timestampMicros) {\n    return com.netflix.iceberg.expressions.Literal\n        .of(timestampMicros)\n        .to(TimestampType.withoutZone());\n  }\n\n  private static com.netflix.iceberg.expressions.Expression filter(\n      Operation op, String name, int value, Function<Integer, Long> startTsMicros) {\n    switch (op) {\n      case LT:\n        return predicate(Operation.LT, name, tsLiteral(startTsMicros.apply(value)));\n      case LT_EQ:\n        return predicate(Operation.LT, name, tsLiteral(startTsMicros.apply(value + 1)));\n      case GT:\n        return predicate(Operation.GT_EQ, name, tsLiteral(startTsMicros.apply(value + 1)));\n      case GT_EQ:\n        return predicate(Operation.GT_EQ, name, tsLiteral(startTsMicros.apply(value)));\n      case EQ:\n        return and(\n            predicate(Operation.GT_EQ, name, tsLiteral(startTsMicros.apply(value))),\n            predicate(Operation.LT, name, tsLiteral(startTsMicros.apply(value + 1)))\n        );\n      case NOT_EQ:\n        return or(\n            predicate(Operation.GT_EQ, name, tsLiteral(startTsMicros.apply(value + 1))),\n            predicate(Operation.LT, name, tsLiteral(startTsMicros.apply(value)))\n        );\n      case IN:\n      case NOT_IN:\n      default:\n        throw new IllegalArgumentException(\"Cannot convert operation to year filter: \" + op);\n    }\n  }\n\n  public static Expression convert(com.netflix.iceberg.expressions.Expression filter,\n                                   Schema schema) {\n    return visit(Binder.bind(schema.asStruct(), filter), new ExpressionToSpark(schema));\n  }\n\n  private static class ExpressionToSpark extends ExpressionVisitors.\n      BoundExpressionVisitor<Expression> {\n    private final Schema schema;\n\n    public ExpressionToSpark(Schema schema) {\n      this.schema = schema;\n    }\n\n    @Override\n    public Expression alwaysTrue() {\n      return functions$.MODULE$.lit(true).expr();\n    }\n\n    @Override\n    public Expression alwaysFalse() {\n      return functions$.MODULE$.lit(false).expr();\n    }\n\n    @Override\n    public Expression not(Expression child) {\n      return Not$.MODULE$.apply(child);\n    }\n\n    @Override\n    public Expression and(Expression left, Expression right) {\n      return And$.MODULE$.apply(left, right);\n    }\n\n    @Override\n    public Expression or(Expression left, Expression right) {\n      return Or$.MODULE$.apply(left, right);\n    }\n\n    @Override\n    public <T> Expression isNull(BoundReference<T> ref) {\n      return column(ref).isNull().expr();\n    }\n\n    @Override\n    public <T> Expression notNull(BoundReference<T> ref) {\n      return column(ref).isNotNull().expr();\n    }\n\n    @Override\n    public <T> Expression lt(BoundReference<T> ref,\n                             com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).lt(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression ltEq(BoundReference<T> ref,\n                               com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).leq(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression gt(BoundReference<T> ref,\n                             com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).gt(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression gtEq(BoundReference<T> ref,\n                               com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).geq(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression eq(BoundReference<T> ref,\n                             com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).equalTo(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression notEq(BoundReference<T> ref,\n                                com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).notEqual(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression in(BoundReference<T> ref,\n                             com.netflix.iceberg.expressions.Literal<T> lit) {\n      throw new UnsupportedOperationException(\"Not implemented: in\");\n    }\n\n    @Override\n    public <T> Expression notIn(BoundReference<T> ref,\n                                com.netflix.iceberg.expressions.Literal<T> lit) {\n      throw new UnsupportedOperationException(\"Not implemented: notIn\");\n    }\n\n    private Column column(BoundReference ref) {\n      return functions$.MODULE$.column(schema.findColumnName(ref.fieldId()));\n    }\n  }\n}\n\n'iceberg/api/src/main/java/com/netflix/iceberg/expressions/InclusiveMetricsEvaluator.java'\n:\n\npackage com.netflix.iceberg.expressions;\n\nimport com.google.common.base.Preconditions;\nimport com.netflix.iceberg.DataFile;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.ExpressionVisitors.BoundExpressionVisitor;\nimport com.netflix.iceberg.types.Conversions;\nimport com.netflix.iceberg.types.Types;\nimport com.netflix.iceberg.types.Types.StructType;\nimport java.nio.ByteBuffer;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.expressions.Expressions.rewriteNot;\n\n\npublic class InclusiveMetricsEvaluator {\n  private final Schema schema;\n  private final StructType struct;\n  private final Expression expr;\n  private transient ThreadLocal<MetricsEvalVisitor> visitors = null;\n\n  private MetricsEvalVisitor visitor() {\n    if (visitors == null) {\n      this.visitors = ThreadLocal.withInitial(MetricsEvalVisitor::new);\n    }\n    return visitors.get();\n  }\n\n  public InclusiveMetricsEvaluator(Schema schema, Expression unbound) {\n    this.schema = schema;\n    this.struct = schema.asStruct();\n    this.expr = Binder.bind(struct, rewriteNot(unbound));\n  }\n\n\n  public boolean eval(DataFile file) {\n\n    return visitor().eval(file);\n  }\n\n  private static final boolean ROWS_MIGHT_MATCH = true;\n  private static final boolean ROWS_CANNOT_MATCH = false;\n\n  private class MetricsEvalVisitor extends BoundExpressionVisitor<Boolean> {\n    private Map<Integer, Long> valueCounts = null;\n    private Map<Integer, Long> nullCounts = null;\n    private Map<Integer, ByteBuffer> lowerBounds = null;\n    private Map<Integer, ByteBuffer> upperBounds = null;\n\n    private boolean eval(DataFile file) {\n      if (file.recordCount() <= 0) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      this.valueCounts = file.valueCounts();\n      this.nullCounts = file.nullValueCounts();\n      this.lowerBounds = file.lowerBounds();\n      this.upperBounds = file.upperBounds();\n\n      return ExpressionVisitors.visit(expr, this);\n    }\n\n    @Override\n    public Boolean alwaysTrue() {\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public Boolean alwaysFalse() {\n      return ROWS_CANNOT_MATCH;\n    }\n\n    @Override\n    public Boolean not(Boolean result) {\n      return !result;\n    }\n\n    @Override\n    public Boolean and(Boolean leftResult, Boolean rightResult) {\n      return leftResult && rightResult;\n    }\n\n    @Override\n    public Boolean or(Boolean leftResult, Boolean rightResult) {\n      return leftResult || rightResult;\n    }\n\n    @Override\n    public <T> Boolean isNull(BoundReference<T> ref) {\n\n\n      Integer id = ref.fieldId();\n      Preconditions.checkNotNull(struct.field(id),\n          \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (nullCounts != null && nullCounts.containsKey(id) && nullCounts.get(id) == 0) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean notNull(BoundReference<T> ref) {\n\n\n      Integer id = ref.fieldId();\n      Preconditions.checkNotNull(struct.field(id),\n          \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (valueCounts != null && valueCounts.containsKey(id) &&\n          nullCounts != null && nullCounts.containsKey(id) &&\n          valueCounts.get(id) - nullCounts.get(id) == 0) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean ltEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean gt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp <= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean gtEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean in(BoundReference<T> ref, Literal<T> lit) {\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean notIn(BoundReference<T> ref, Literal<T> lit) {\n      return ROWS_MIGHT_MATCH;\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/expressions/ExpressionVisitors.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkExpressions.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/expressions/InclusiveMetricsEvaluator.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'\n:\n\npackage com.netflix.iceberg.spark.data;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.avro.AvroSchemaVisitor;\nimport com.netflix.iceberg.avro.ValueWriter;\nimport com.netflix.iceberg.avro.ValueWriters;\nimport com.netflix.iceberg.types.Type;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.io.Encoder;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.types.DataType;\nimport java.io.IOException;\nimport java.util.List;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getFieldId;\nimport static com.netflix.iceberg.avro.AvroSchemaVisitor.visit;\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\npublic class SparkAvroWriter implements DatumWriter<InternalRow> {\n  private final com.netflix.iceberg.Schema schema;\n  private ValueWriter<InternalRow> writer = null;\n\n  public SparkAvroWriter(com.netflix.iceberg.Schema schema) {\n    this.schema = schema;\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void setSchema(Schema schema) {\n    this.writer = (ValueWriter<InternalRow>) visit(schema, new WriteBuilder(this.schema));\n  }\n\n  @Override\n  public void write(InternalRow datum, Encoder out) throws IOException {\n    writer.write(datum, out);\n  }\n\n  private static class WriteBuilder extends AvroSchemaVisitor<ValueWriter<?>> {\n    private final com.netflix.iceberg.Schema schema;\n\n    private WriteBuilder(com.netflix.iceberg.Schema schema) {\n      this.schema = schema;\n    }\n\n    @Override\n    public ValueWriter<?> record(Schema record, List<String> names, List<ValueWriter<?>> fields) {\n      List<DataType> types = Lists.newArrayList();\n      for (Schema.Field field : record.getFields()) {\n        types.add(convert(schema.findType(getFieldId(field))));\n      }\n      return SparkValueWriters.struct(fields, types);\n    }\n\n    @Override\n    public ValueWriter<?> union(Schema union, List<ValueWriter<?>> options) {\n      Preconditions.checkArgument(options.contains(ValueWriters.nulls()),\n          \"Cannot create writer for non-option union: \" + union);\n      Preconditions.checkArgument(options.size() == 2,\n          \"Cannot create writer for non-option union: \" + union);\n      if (union.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return ValueWriters.option(0, options.get(1));\n      } else {\n        return ValueWriters.option(1, options.get(0));\n      }\n    }\n\n    @Override\n    public ValueWriter<?> array(Schema array, ValueWriter<?> elementWriter) {\n      LogicalType logical = array.getLogicalType();\n      if (logical != null && \"map\".equals(logical.getName())) {\n        Type keyType = schema.findType(getFieldId(array.getElementType().getField(\"key\")));\n        Type valueType = schema.findType(getFieldId(array.getElementType().getField(\"value\")));\n        ValueWriter<?>[] writers = ((SparkValueWriters.StructWriter) elementWriter).writers;\n        return SparkValueWriters.arrayMap(\n            writers[0], convert(keyType), writers[1], convert(valueType));\n      }\n\n      Type elementType = schema.findType(AvroSchemaUtil.getElementId(array));\n      return SparkValueWriters.array(elementWriter, convert(elementType));\n    }\n\n    @Override\n    public ValueWriter<?> map(Schema map, ValueWriter<?> valueReader) {\n      Type keyType = schema.findType(AvroSchemaUtil.getKeyId(map));\n      Type valueType = schema.findType(AvroSchemaUtil.getValueId(map));\n      return SparkValueWriters.map(\n          SparkValueWriters.strings(), convert(keyType), valueReader, convert(valueType));\n    }\n\n    @Override\n    public ValueWriter<?> primitive(Schema primitive) {\n      LogicalType logicalType = primitive.getLogicalType();\n      if (logicalType != null) {\n        switch (logicalType.getName()) {\n          case \"date\":\n\n            return ValueWriters.ints();\n\n          case \"timestamp-micros\":\n\n            return ValueWriters.longs();\n\n          case \"decimal\":\n            LogicalTypes.Decimal decimal = (LogicalTypes.Decimal) logicalType;\n            return SparkValueWriters.decimal(decimal.getPrecision(), decimal.getScale());\n\n          case \"uuid\":\n            return ValueWriters.uuids();\n\n          default:\n            throw new IllegalArgumentException(\"Unsupported logical type: \" + logicalType);\n        }\n      }\n\n      switch (primitive.getType()) {\n        case NULL:\n          return ValueWriters.nulls();\n        case BOOLEAN:\n          return ValueWriters.booleans();\n        case INT:\n          return ValueWriters.ints();\n        case LONG:\n          return ValueWriters.longs();\n        case FLOAT:\n          return ValueWriters.floats();\n        case DOUBLE:\n          return ValueWriters.doubles();\n        case STRING:\n          return SparkValueWriters.strings();\n        case FIXED:\n          return ValueWriters.fixed(primitive.getFixedSize());\n        case BYTES:\n          return ValueWriters.bytes();\n        default:\n          throw new IllegalArgumentException(\"Unsupported type: \" + primitive);\n      }\n    }\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'\n:\n\npackage com.netflix.iceberg.types;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic class TypeUtil {\n  public static Schema select(Schema schema, Set<Integer> fieldIds) {\n    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n    Preconditions.checkNotNull(fieldIds, \"Field ids cannot be null\");\n\n    Type result = visit(schema, new PruneColumns(fieldIds));\n    if (schema.asStruct() == result) {\n      return schema;\n    } else if (result != null) {\n      if (schema.getAliases() != null) {\n        return new Schema(result.asNestedType().fields(), schema.getAliases());\n      } else {\n        return new Schema(result.asNestedType().fields());\n      }\n    }\n\n    return new Schema(ImmutableList.of(), schema.getAliases());\n  }\n\n  public static Set<Integer> getProjectedIds(Schema schema) {\n    return visit(schema, new GetProjectedIds());\n  }\n\n  public static Set<Integer> getProjectedIds(Type schema) {\n    if (schema.isPrimitiveType()) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(visit(schema, new GetProjectedIds()));\n  }\n\n  public static Schema selectNot(Schema schema, Set<Integer> fieldIds) {\n    Set<Integer> projectedIds = getProjectedIds(schema);\n    projectedIds.removeAll(fieldIds);\n    return select(schema, projectedIds);\n  }\n\n  public static Schema join(Schema left, Schema right) {\n    List<Types.NestedField> joinedColumns = Lists.newArrayList();\n    joinedColumns.addAll(left.columns());\n    joinedColumns.addAll(right.columns());\n    return new Schema(joinedColumns);\n  }\n\n  public static Map<String, Integer> indexByName(Types.StructType struct) {\n    return visit(struct, new IndexByName());\n  }\n\n  public static Map<Integer, Types.NestedField> indexById(Types.StructType struct) {\n    return visit(struct, new IndexById());\n  }\n\n\n  public static Type assignFreshIds(Type type, NextID nextId) {\n    return TypeUtil.visit(type, new AssignFreshIds(nextId));\n  }\n\n\n  public static Schema assignFreshIds(Schema schema, NextID nextId) {\n    return new Schema(TypeUtil\n        .visit(schema.asStruct(), new AssignFreshIds(nextId))\n        .asNestedType()\n        .fields());\n  }\n\n\n  public static Schema reassignIds(Schema schema, Schema idSourceSchema) {\n    Types.StructType struct = visit(schema, new ReassignIds(idSourceSchema)).asStructType();\n    return new Schema(struct.fields());\n  }\n\n  public static Type find(Schema schema, Predicate<Type> predicate) {\n    return visit(schema, new FindTypeVisitor(predicate));\n  }\n\n  public static boolean isPromotionAllowed(Type from, Type.PrimitiveType to) {\n\n\n    if (from.equals(to)) {\n      return true;\n    }\n\n    switch (from.typeId()) {\n      case INTEGER:\n        return to == Types.LongType.get();\n\n      case FLOAT:\n        return to == Types.DoubleType.get();\n\n      case DECIMAL:\n        Types.DecimalType fromDecimal = (Types.DecimalType) from;\n        if (to.typeId() != Type.TypeID.DECIMAL) {\n          return false;\n        }\n\n        Types.DecimalType toDecimal = (Types.DecimalType) to;\n        return (fromDecimal.scale() == toDecimal.scale() &&\n            fromDecimal.precision() <= toDecimal.precision());\n    }\n\n    return false;\n  }\n\n\n  public interface NextID {\n    int get();\n  }\n\n  public static class SchemaVisitor<T> {\n    protected LinkedList<String> fieldNames = Lists.newLinkedList();\n    protected LinkedList<Integer> fieldIds = Lists.newLinkedList();\n\n    public T schema(Schema schema, T structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, List<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, T fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, T elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, T keyResult, T valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  public static <T> T visit(Schema schema, SchemaVisitor<T> visitor) {\n    return visitor.schema(schema, visit(schema.asStruct(), visitor));\n  }\n\n  public static <T> T visit(Type type, SchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<T> results = Lists.newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          visitor.fieldIds.push(field.fieldId());\n          visitor.fieldNames.push(field.name());\n          T result;\n          try {\n            result = visit(field.type(), visitor);\n          } finally {\n            visitor.fieldIds.pop();\n            visitor.fieldNames.pop();\n          }\n          results.add(visitor.field(field, result));\n        }\n        return visitor.struct(struct, results);\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        T elementResult;\n\n        visitor.fieldIds.push(list.elementId());\n        try {\n          elementResult = visit(list.elementType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.list(list, elementResult);\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        T keyResult;\n        T valueResult;\n\n        visitor.fieldIds.push(map.keyId());\n        try {\n          keyResult = visit(map.keyType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        visitor.fieldIds.push(map.valueId());\n        try {\n          valueResult = visit(map.valueType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.map(map, keyResult, valueResult);\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  public static class CustomOrderSchemaVisitor<T> {\n    public T schema(Schema schema, Supplier<T> structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, Iterable<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, Supplier<T> fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, Supplier<T> elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, Supplier<T> keyResult, Supplier<T> valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  private static class VisitFuture<T> implements Supplier<T> {\n    private final Type type;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFuture(Type type, CustomOrderSchemaVisitor<T> visitor) {\n      this.type = type;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visit(type, visitor);\n    }\n  }\n\n  private static class VisitFieldFuture<T> implements Supplier<T> {\n    private final Types.NestedField field;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFieldFuture(Types.NestedField field, CustomOrderSchemaVisitor<T> visitor) {\n      this.field = field;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visitor.field(field, new VisitFuture<>(field.type(), visitor));\n    }\n  }\n\n  public static <T> T visit(Schema schema, CustomOrderSchemaVisitor<T> visitor) {\n    return visitor.schema(schema, new VisitFuture<>(schema.asStruct(), visitor));\n  }\n\n\n  public static <T> T visit(Type type, CustomOrderSchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<VisitFieldFuture<T>> results = Lists\n            .newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          results.add(\n              new VisitFieldFuture<>(field, visitor));\n        }\n\n        return visitor.struct(struct, Iterables.transform(results, VisitFieldFuture::get));\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        return visitor.list(list, new VisitFuture<>(list.elementType(), visitor));\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        return visitor.map(map,\n            new VisitFuture<>(map.keyType(), visitor),\n            new VisitFuture<>(map.valueType(), visitor));\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  static int decimalMaxPrecision(int numBytes) {\n    Preconditions.checkArgument(numBytes >= 0 && numBytes < 24,\n        \"Unsupported decimal length: \" + numBytes);\n    return MAX_PRECISION[numBytes];\n  }\n\n  public static int decimalRequriedBytes(int precision) {\n    Preconditions.checkArgument(precision >= 0 && precision < 40,\n        \"Unsupported decimal precision: \" + precision);\n    return REQUIRED_LENGTH[precision];\n  }\n\n  private static int[] MAX_PRECISION = new int[24];\n  private static int[] REQUIRED_LENGTH = new int[40];\n\n  static {\n\n    for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n      MAX_PRECISION[len] = (int) Math.floor(Math.log10(Math.pow(2, 8*len - 1) - 1));\n    }\n\n\n    for (int precision = 0; precision < REQUIRED_LENGTH.length; precision += 1) {\n      REQUIRED_LENGTH[precision] = -1;\n      for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n\n        if (precision <= MAX_PRECISION[len]) {\n          REQUIRED_LENGTH[precision] = len;\n          break;\n        }\n      }\n      if (REQUIRED_LENGTH[precision] < 0) {\n        throw new IllegalStateException(\n            \"Could not find required length for precision \" + precision);\n      }\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/data/SparkAvroWriter.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/BuildAvroProjection.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/avro/BuildAvroProjection.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.convert;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.copyField;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.copyRecord;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.fromOption;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.fromOptions;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getFieldId;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.isKeyValueSchema;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.isOptionSchema;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.toOption;\n\n\nclass BuildAvroProjection extends AvroCustomOrderSchemaVisitor<Schema, Schema.Field> {\n  private final Map<String, String> renames;\n  private Type current = null;\n\n  BuildAvroProjection(com.netflix.iceberg.Schema expectedSchema, Map<String, String> renames) {\n    this.renames = renames;\n    this.current = expectedSchema.asStruct();\n  }\n\n  @Override\n  public Schema record(Schema record, List<String> names, Iterable<Schema.Field> schemaIterable) {\n    Preconditions.checkArgument(\n        current.isNestedType() && current.asNestedType().isStructType(),\n        \"Cannot project non-struct: %s\", current);\n\n    Types.StructType struct = current.asNestedType().asStructType();\n\n    boolean hasChange = false;\n    List<Schema.Field> fields = record.getFields();\n    List<Schema.Field> fieldResults = Lists.newArrayList(schemaIterable);\n\n    Map<String, Schema.Field> updateMap = Maps.newHashMap();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Schema.Field field = fields.get(i);\n      Schema.Field updatedField = fieldResults.get(i);\n\n      if (updatedField != null) {\n        updateMap.put(updatedField.name(), updatedField);\n\n        if (!updatedField.schema().equals(field.schema()) ||\n            !updatedField.name().equals(field.name())) {\n          hasChange = true;\n        }\n      } else {\n        hasChange = true;\n      }\n    }\n\n\n    List<Schema.Field> updatedFields = Lists.newArrayListWithExpectedSize(struct.fields().size());\n    List<Types.NestedField> expectedFields = struct.fields();\n    for (int i = 0; i < expectedFields.size(); i += 1) {\n      Types.NestedField field = expectedFields.get(i);\n\n\n      if (i < fields.size() && !field.name().equals(fields.get(i).name())) {\n        hasChange = true;\n      }\n\n      Schema.Field avroField = updateMap.get(field.name());\n\n      if (avroField != null) {\n        updatedFields.add(avroField);\n\n      } else {\n        Preconditions.checkArgument(field.isOptional(), \"Missing required field: %s\", field.name());\n\n        Schema.Field newField = new Schema.Field(\n            field.name(), toOption(convert(field.type())), null, JsonProperties.NULL_VALUE);\n        newField.addProp(AvroSchemaUtil.FIELD_ID_PROP, field.fieldId());\n        updatedFields.add(newField);\n        hasChange = true;\n      }\n    }\n\n    if (hasChange || renames.containsKey(record.getFullName())) {\n      return copyRecord(record, updatedFields, renames.get(record.getFullName()));\n    }\n\n    return record;\n  }\n\n  @Override\n  public Schema.Field field(Schema.Field field, Supplier<Schema> fieldResult) {\n    Types.StructType struct = current.asNestedType().asStructType();\n    int fieldId = AvroSchemaUtil.getFieldId(field);\n    Types.NestedField expectedField = struct.field(fieldId);\n\n\n    if (expectedField == null) {\n      return null;\n    }\n\n    String expectedName = expectedField.name();\n\n    this.current = expectedField.type();\n    try {\n      Schema schema = fieldResult.get();\n\n      if (schema != field.schema() || !expectedName.equals(field.name())) {\n\n        return copyField(field, schema, expectedName);\n      } else {\n\n        return copyField(field, field.schema(), field.name());\n      }\n\n    } finally {\n      this.current = struct;\n    }\n  }\n\n  @Override\n  public Schema union(Schema union, Iterable<Schema> options) {\n    Preconditions.checkState(isOptionSchema(union),\n        \"Invalid schema: non-option unions are not supported: {}\", union);\n    Schema nonNullOriginal = fromOption(union);\n    Schema nonNullResult = fromOptions(Lists.newArrayList(options));\n\n    if (nonNullOriginal != nonNullResult) {\n      return toOption(nonNullResult);\n    }\n\n    return union;\n  }\n\n  @Override\n  public Schema array(Schema array, Supplier<Schema> element) {\n    if (array.getLogicalType() instanceof LogicalMap ||\n        (current.isMapType() && isKeyValueSchema(array.getElementType()))) {\n      Preconditions.checkArgument(current.isMapType(), \"Incompatible projected type: %s\", current);\n      Types.MapType m = current.asNestedType().asMapType();\n      this.current = Types.StructType.of(m.fields());\n      try {\n        Schema keyValueSchema = array.getElementType();\n        Schema.Field keyField = keyValueSchema.getFields().get(0);\n        Schema.Field valueField = keyValueSchema.getFields().get(1);\n        Schema.Field valueProjection = element.get().getField(\"value\");\n\n\n        if (valueProjection.schema() != valueField.schema()) {\n          return AvroSchemaUtil.createProjectionMap(keyValueSchema.getFullName(),\n              getFieldId(keyField), keyField.name(), keyField.schema(),\n              getFieldId(valueField), valueField.name(), valueProjection.schema());\n        } else if (!(array.getLogicalType() instanceof LogicalMap)) {\n          return AvroSchemaUtil.createProjectionMap(keyValueSchema.getFullName(),\n              getFieldId(keyField), keyField.name(), keyField.schema(),\n              getFieldId(valueField), valueField.name(), valueField.schema());\n        }\n\n        return array;\n\n      } finally {\n        this.current = m;\n      }\n\n    } else {\n      Preconditions.checkArgument(current.isListType(),\n          \"Incompatible projected type: %s\", current);\n      Types.ListType list = current.asNestedType().asListType();\n      this.current = list.elementType();\n      try {\n        Schema elementSchema = element.get();\n\n\n        if (elementSchema != array.getElementType()) {\n          return Schema.createArray(elementSchema);\n        }\n\n        return array;\n\n      } finally {\n        this.current = list;\n      }\n    }\n  }\n\n  @Override\n  public Schema map(Schema map, Supplier<Schema> value) {\n    Preconditions.checkArgument(current.isNestedType() && current.asNestedType().isMapType(),\n        \"Incompatible projected type: %s\", current);\n    Types.MapType m = current.asNestedType().asMapType();\n    Preconditions.checkArgument(m.keyType() == Types.StringType.get(),\n        \"Incompatible projected type: key type %s is not string\", m.keyType());\n    this.current = m.valueType();\n    try {\n      Schema valueSchema = value.get();\n\n\n      if (valueSchema != map.getValueType()) {\n        return Schema.createMap(valueSchema);\n      }\n\n      return map;\n\n    } finally {\n      this.current = m;\n    }\n  }\n\n  @Override\n  public Schema primitive(Schema primitive) {\n\n    switch (primitive.getType()) {\n      case INT:\n        if (current.typeId() == Type.TypeID.LONG) {\n          return Schema.create(Schema.Type.LONG);\n        }\n        return primitive;\n\n      case FLOAT:\n        if (current.typeId() == Type.TypeID.DOUBLE) {\n          return Schema.create(Schema.Type.DOUBLE);\n        }\n        return primitive;\n\n      default:\n        return primitive;\n    }\n  }\n\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\nimport static org.apache.avro.Schema.Type.MAP;\nimport static org.apache.avro.Schema.Type.RECORD;\nimport static org.apache.avro.Schema.Type.UNION;\n\npublic class AvroSchemaUtil {\n  public static final String FIELD_ID_PROP = \"field-id\";\n  public static final String KEY_ID_PROP = \"key-id\";\n  public static final String VALUE_ID_PROP = \"value-id\";\n  public static final String ELEMENT_ID_PROP = \"element-id\";\n  public static final String ADJUST_TO_UTC_PROP = \"adjust-to-utc\";\n\n  private static final Schema NULL = Schema.create(Schema.Type.NULL);\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               String tableName) {\n    return convert(schema, ImmutableMap.of(schema.asStruct(), tableName));\n  }\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               Map<Types.StructType, String> names) {\n    return TypeUtil.visit(schema, new TypeToSchema(names));\n  }\n\n  public static Schema convert(Type type) {\n    return convert(type, ImmutableMap.of());\n  }\n\n  public static Schema convert(Types.StructType type, String name) {\n    return convert(type, ImmutableMap.of(type, name));\n  }\n\n  public static Schema convert(Type type, Map<Types.StructType, String> names) {\n    return TypeUtil.visit(type, new TypeToSchema(names));\n  }\n\n  public static Type convert(Schema schema) {\n    return AvroSchemaVisitor.visit(schema, new SchemaToType(schema));\n  }\n\n  public static Map<Type, Schema> convertTypes(Types.StructType type, String name) {\n    TypeToSchema converter = new TypeToSchema(ImmutableMap.of(type, name));\n    TypeUtil.visit(type, converter);\n    return ImmutableMap.copyOf(converter.getConversionMap());\n  }\n\n  public static Schema pruneColumns(Schema schema, Set<Integer> selectedIds) {\n    return new PruneColumns(selectedIds).rootSchema(schema);\n  }\n\n  public static Schema buildAvroProjection(Schema schema, com.netflix.iceberg.Schema expected,\n                                           Map<String, String> renames) {\n    return AvroCustomOrderSchemaVisitor.visit(schema, new BuildAvroProjection(expected, renames));\n  }\n\n  public static boolean isTimestamptz(Schema schema) {\n    LogicalType logicalType = schema.getLogicalType();\n    if (logicalType != null && logicalType instanceof LogicalTypes.TimestampMicros) {\n\n      Object value = schema.getObjectProp(ADJUST_TO_UTC_PROP);\n      if (value instanceof Boolean) {\n        return (Boolean) value;\n      } else if (value instanceof String) {\n        return Boolean.parseBoolean((String) value);\n      }\n    }\n\n    return false;\n  }\n\n  static boolean isOptionSchema(Schema schema) {\n    if (schema.getType() == UNION && schema.getTypes().size() == 2) {\n      if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return true;\n      } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Schema toOption(Schema schema) {\n    if (schema.getType() == UNION) {\n      Preconditions.checkArgument(isOptionSchema(schema),\n          \"Union schemas are not supported: \" + schema);\n      return schema;\n    } else {\n      return Schema.createUnion(NULL, schema);\n    }\n  }\n\n  static Schema fromOption(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == UNION,\n        \"Expected union schema but was passed: {}\", schema);\n    Preconditions.checkArgument(schema.getTypes().size() == 2,\n        \"Expected optional schema, but was passed: {}\", schema);\n    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n      return schema.getTypes().get(1);\n    } else {\n      return schema.getTypes().get(0);\n    }\n  }\n\n  static Schema fromOptions(List<Schema> options) {\n    Preconditions.checkArgument(options.size() == 2,\n        \"Expected two schemas, but was passed: {} options\", options.size());\n    if (options.get(0).getType() == Schema.Type.NULL) {\n      return options.get(1);\n    } else {\n      return options.get(0);\n    }\n  }\n\n  static boolean isKeyValueSchema(Schema schema) {\n    return (schema.getType() == RECORD && schema.getFields().size() == 2);\n  }\n\n  static Schema createMap(int keyId, Schema keySchema,\n                          int valueId, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n\n    return LogicalMap.get().addToSchema(Schema.createArray(Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField))));\n  }\n\n  static Schema createProjectionMap(String recordName,\n                          int keyId, String keyName, Schema keySchema,\n                          int valueId, String valueName, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    if (!\"key\".equals(keyName)) {\n      keyField.addAlias(keyName);\n    }\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n    if (!\"value\".equals(valueName)) {\n      valueField.addAlias(valueName);\n    }\n\n    Schema keyValueRecord = Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField));\n    if (!keyValueName.equals(recordName)) {\n      keyValueRecord.addAlias(recordName);\n    }\n\n    return LogicalMap.get().addToSchema(Schema.createArray(keyValueRecord));\n  }\n\n  private static int getId(Schema schema, String propertyName) {\n    if (schema.getType() == UNION) {\n      return getId(fromOption(schema), propertyName);\n    }\n\n    Object id = schema.getObjectProp(propertyName);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", propertyName);\n\n    return toInt(id);\n  }\n\n  public static int getKeyId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map key id for non-map schema: \" + schema);\n    return getId(schema, KEY_ID_PROP);\n  }\n\n  public static int getValueId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map value id for non-map schema: \" + schema);\n    return getId(schema, VALUE_ID_PROP);\n  }\n\n  public static int getElementId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Cannot get array element id for non-array schema: \" + schema);\n    return getId(schema, ELEMENT_ID_PROP);\n  }\n\n  public static int getFieldId(Schema.Field field) {\n    Object id = field.getObjectProp(FIELD_ID_PROP);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", FIELD_ID_PROP);\n\n    return toInt(id);\n  }\n\n  private static int toInt(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).intValue();\n    } else if (value instanceof String) {\n      return Integer.parseInt((String) value);\n    }\n\n    throw new UnsupportedOperationException(\"Cannot coerce value to int: \" + value);\n  }\n\n  static Schema copyRecord(Schema record, List<Schema.Field> newFields, String newName) {\n    Schema copy;\n    if (newName != null) {\n      copy = Schema.createRecord(newName, record.getDoc(), null, record.isError(), newFields);\n\n\n\n      copy.addAlias(record.getName(), record.getNamespace() == null ? \"\" : record.getNamespace());\n    } else {\n      copy = Schema.createRecord(record.getName(),\n          record.getDoc(), record.getNamespace(), record.isError(), newFields);\n    }\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  static Schema.Field copyField(Schema.Field field, Schema newSchema, String newName) {\n    Schema.Field copy = new Schema.Field(newName,\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    if (!newName.equals(field.name())) {\n      copy.addAlias(field.name());\n    }\n\n    return copy;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.types.ArrayType$;\nimport org.apache.spark.sql.types.BinaryType$;\nimport org.apache.spark.sql.types.BooleanType$;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.DateType$;\nimport org.apache.spark.sql.types.DecimalType$;\nimport org.apache.spark.sql.types.DoubleType$;\nimport org.apache.spark.sql.types.FloatType$;\nimport org.apache.spark.sql.types.IntegerType$;\nimport org.apache.spark.sql.types.LongType$;\nimport org.apache.spark.sql.types.MapType$;\nimport org.apache.spark.sql.types.Metadata;\nimport org.apache.spark.sql.types.StringType$;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType$;\nimport org.apache.spark.sql.types.TimestampType$;\nimport java.util.List;\n\nclass TypeToSparkType extends TypeUtil.SchemaVisitor<DataType> {\n  TypeToSparkType() {\n  }\n\n  @Override\n  public DataType schema(Schema schema, DataType structType) {\n    return structType;\n  }\n\n  @Override\n  public DataType struct(Types.StructType struct, List<DataType> fieldResults) {\n    List<Types.NestedField> fields = struct.fields();\n\n    List<StructField> sparkFields = Lists.newArrayListWithExpectedSize(fieldResults.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      DataType type = fieldResults.get(i);\n      sparkFields.add(StructField.apply(field.name(), type, field.isOptional(), Metadata.empty()));\n    }\n\n    return StructType$.MODULE$.apply(sparkFields);\n  }\n\n  @Override\n  public DataType field(Types.NestedField field, DataType fieldResult) {\n    return fieldResult;\n  }\n\n  @Override\n  public DataType list(Types.ListType list, DataType elementResult) {\n    return ArrayType$.MODULE$.apply(elementResult, list.isElementOptional());\n  }\n\n  @Override\n  public DataType map(Types.MapType map, DataType keyResult, DataType valueResult) {\n    return MapType$.MODULE$.apply(keyResult, valueResult, map.isValueOptional());\n  }\n\n  @Override\n  public DataType primitive(Type.PrimitiveType primitive) {\n    switch (primitive.typeId()) {\n      case BOOLEAN:\n        return BooleanType$.MODULE$;\n      case INTEGER:\n        return IntegerType$.MODULE$;\n      case LONG:\n        return LongType$.MODULE$;\n      case FLOAT:\n        return FloatType$.MODULE$;\n      case DOUBLE:\n        return DoubleType$.MODULE$;\n      case DATE:\n        return DateType$.MODULE$;\n      case TIME:\n        throw new UnsupportedOperationException(\n            \"Spark does not support time fields\");\n      case TIMESTAMP:\n        Types.TimestampType timestamp = (Types.TimestampType) primitive;\n        if (timestamp.shouldAdjustToUTC()) {\n          return TimestampType$.MODULE$;\n        }\n        throw new UnsupportedOperationException(\n            \"Spark does not support timestamp without time zone fields\");\n      case STRING:\n        return StringType$.MODULE$;\n      case UUID:\n\n        return StringType$.MODULE$;\n      case FIXED:\n        return BinaryType$.MODULE$;\n      case BINARY:\n        return BinaryType$.MODULE$;\n      case DECIMAL:\n        Types.DecimalType decimal = (Types.DecimalType) primitive;\n        return DecimalType$.MODULE$.apply(decimal.precision(), decimal.scale());\n      default:\n        throw new UnsupportedOperationException(\n            \"Cannot convert unknown type to Spark: \" + primitive);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/BuildAvroProjection.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'"
        ],
        "content": "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport java.util.List;\n\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Core;\nimport org.opencv.core.CvType;\nimport org.opencv.core.Mat;\nimport org.opencv.core.MatOfPoint;\nimport org.opencv.core.Rect;\nimport org.opencv.core.Scalar;\nimport org.opencv.core.Size;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport org.opencv.imgproc.Imgproc;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.WindowManager;\nimport android.view.View.OnTouchListener;\n\nimport com.jnardari.opencv_androidsamples.R;\nimport com.jnardari.opencv_androidsamples.utils.ColorBlobDetector;\n\npublic class ColorBlobDetectionActivity extends AppCompatActivity implements OnTouchListener, CvCameraViewListener2 {\n    private static final String  TAG              = \"OCVSample::Activity\";\n\n    private boolean              mIsColorSelected = false;\n    private Mat                  mRgba;\n    private Scalar               mBlobColorRgba;\n    private Scalar               mBlobColorHsv;\n    private ColorBlobDetector    mDetector;\n    private Mat                  mSpectrum;\n    private Size                 SPECTRUM_SIZE;\n    private Scalar               CONTOUR_COLOR;\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n\n    private BaseLoaderCallback  mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                    mOpenCvCameraView.setOnTouchListener(ColorBlobDetectionActivity.this);\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public ColorBlobDetectionActivity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_color_blob_detection);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.color_blob_detection_activity_surface_view);\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n        mRgba = new Mat(height, width, CvType.CV_8UC4);\n        mDetector = new ColorBlobDetector();\n        mSpectrum = new Mat();\n        mBlobColorRgba = new Scalar(255);\n        mBlobColorHsv = new Scalar(255);\n        SPECTRUM_SIZE = new Size(200, 64);\n        CONTOUR_COLOR = new Scalar(255,0,0,255);\n    }\n\n    public void onCameraViewStopped() {\n        mRgba.release();\n    }\n\n    public boolean onTouch(View v, MotionEvent event) {\n        int cols = mRgba.cols();\n        int rows = mRgba.rows();\n\n        int xOffset = (mOpenCvCameraView.getWidth() - cols) / 2;\n        int yOffset = (mOpenCvCameraView.getHeight() - rows) / 2;\n\n        int x = (int)event.getX() - xOffset;\n        int y = (int)event.getY() - yOffset;\n\n        Log.i(TAG, \"Touch image coordinates: (\" + x + \", \" + y + \")\");\n\n        if ((x < 0) || (y < 0) || (x > cols) || (y > rows)) return false;\n\n        Rect touchedRect = new Rect();\n\n        touchedRect.x = (x>4) ? x-4 : 0;\n        touchedRect.y = (y>4) ? y-4 : 0;\n\n        touchedRect.width = (x+4 < cols) ? x + 4 - touchedRect.x : cols - touchedRect.x;\n        touchedRect.height = (y+4 < rows) ? y + 4 - touchedRect.y : rows - touchedRect.y;\n\n        Mat touchedRegionRgba = mRgba.submat(touchedRect);\n\n        Mat touchedRegionHsv = new Mat();\n        Imgproc.cvtColor(touchedRegionRgba, touchedRegionHsv, Imgproc.COLOR_RGB2HSV_FULL);\n\n\n        mBlobColorHsv = Core.sumElems(touchedRegionHsv);\n        int pointCount = touchedRect.width*touchedRect.height;\n        for (int i = 0; i < mBlobColorHsv.val.length; i++)\n            mBlobColorHsv.val[i] /= pointCount;\n\n        mBlobColorRgba = converScalarHsv2Rgba(mBlobColorHsv);\n\n        Log.i(TAG, \"Touched rgba color: (\" + mBlobColorRgba.val[0] + \", \" + mBlobColorRgba.val[1] +\n                \", \" + mBlobColorRgba.val[2] + \", \" + mBlobColorRgba.val[3] + \")\");\n\n        mDetector.setHsvColor(mBlobColorHsv);\n\n        Imgproc.resize(mDetector.getSpectrum(), mSpectrum, SPECTRUM_SIZE);\n\n        mIsColorSelected = true;\n\n        touchedRegionRgba.release();\n        touchedRegionHsv.release();\n\n        return false;\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        mRgba = inputFrame.rgba();\n\n        if (mIsColorSelected) {\n            mDetector.process(mRgba);\n            List<MatOfPoint> contours = mDetector.getContours();\n            Log.e(TAG, \"Contours count: \" + contours.size());\n            Imgproc.drawContours(mRgba, contours, -1, CONTOUR_COLOR);\n\n            Mat colorLabel = mRgba.submat(4, 68, 4, 68);\n            colorLabel.setTo(mBlobColorRgba);\n\n            Mat spectrumLabel = mRgba.submat(4, 4 + mSpectrum.rows(), 70, 70 + mSpectrum.cols());\n            mSpectrum.copyTo(spectrumLabel);\n        }\n\n        return mRgba;\n    }\n\n    private Scalar converScalarHsv2Rgba(Scalar hsvColor) {\n        Mat pointMatRgba = new Mat();\n        Mat pointMatHsv = new Mat(1, 1, CvType.CV_8UC3, hsvColor);\n        Imgproc.cvtColor(pointMatHsv, pointMatRgba, Imgproc.COLOR_HSV2RGB_FULL, 4);\n\n        return new Scalar(pointMatRgba.get(0, 0));\n    }\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/ssl/SslContextFactory.java'",
            "'drift/drift-transport-netty/src/test/java/io/airlift/drift/transport/netty/client/TestDriftNettyMethodInvoker.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/ConnectionManager.java'"
        ],
        "content": "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/ssl/SslContextFactory.java'\n:\npackage io.airlift.drift.transport.netty.ssl;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.util.concurrent.ExecutionError;\nimport com.google.common.util.concurrent.UncheckedExecutionException;\nimport io.airlift.units.Duration;\n\nimport java.io.File;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\nimport static java.util.Objects.requireNonNull;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\npublic class SslContextFactory\n{\n    private final LoadingCache<SslContextParameters, ReloadableSslContext> cache;\n\n    public static SslContextFactory createSslContextFactory(boolean forClient, Duration refreshTime, ScheduledExecutorService scheduledExecutor)\n    {\n        SslContextFactory sslContextFactory = new SslContextFactory(forClient);\n        scheduledExecutor.scheduleWithFixedDelay(sslContextFactory::refresh, refreshTime.toMillis(), refreshTime.toMillis(), MILLISECONDS);\n        return sslContextFactory;\n    }\n\n    private SslContextFactory(boolean forClient)\n    {\n        this.cache = CacheBuilder.newBuilder()\n                .expireAfterAccess(1, TimeUnit.HOURS)\n                .build(CacheLoader.from(key ->\n                        new ReloadableSslContext(\n                                forClient,\n                                key.getTrustCertificatesFile(),\n                                key.getClientCertificatesFile(),\n                                key.getPrivateKeyFile(),\n                                key.getPrivateKeyPassword(),\n                                key.getSessionCacheSize(),\n                                key.getSessionTimeout(),\n                                key.getCiphers())));\n    }\n\n    public ReloadableSslContext get(\n            File trustCertificatesFile,\n            Optional<File> clientCertificatesFile,\n            Optional<File> privateKeyFile,\n            Optional<String> privateKeyPassword,\n            long sessionCacheSize,\n            Duration sessionTimeout,\n            List<String> ciphers)\n    {\n        return get(new SslContextParameters(\n                trustCertificatesFile,\n                clientCertificatesFile,\n                privateKeyFile,\n                privateKeyPassword,\n                sessionCacheSize,\n                sessionTimeout,\n                ciphers));\n    }\n\n    public ReloadableSslContext get(SslContextParameters sslContextParameters)\n    {\n        try {\n            return cache.getUnchecked(sslContextParameters);\n        }\n        catch (UncheckedExecutionException | ExecutionError e) {\n            throw new RuntimeException(\"Error initializing SSL context\", e.getCause());\n        }\n    }\n\n    private void refresh()\n    {\n        cache.asMap().values().forEach(ReloadableSslContext::reload);\n    }\n\n    public static class SslContextParameters\n    {\n        private final File trustCertificatesFile;\n        private final Optional<File> clientCertificatesFile;\n        private final Optional<File> privateKeyFile;\n        private final Optional<String> privateKeyPassword;\n\n        private final long sessionCacheSize;\n        private final Duration sessionTimeout;\n        private final List<String> ciphers;\n\n        public SslContextParameters(\n                File trustCertificatesFile,\n                Optional<File> clientCertificatesFile,\n                Optional<File> privateKeyFile,\n                Optional<String> privateKeyPassword,\n                long sessionCacheSize,\n                Duration sessionTimeout, List<String> ciphers)\n        {\n            this.trustCertificatesFile = requireNonNull(trustCertificatesFile, \"trustCertificatesFile is null\");\n            this.clientCertificatesFile = requireNonNull(clientCertificatesFile, \"clientCertificatesFile is null\");\n            this.privateKeyFile = requireNonNull(privateKeyFile, \"privateKeyFile is null\");\n            this.privateKeyPassword = requireNonNull(privateKeyPassword, \"privateKeyPassword is null\");\n            this.sessionCacheSize = sessionCacheSize;\n            this.sessionTimeout = requireNonNull(sessionTimeout, \"sessionTimeout is null\");\n            this.ciphers = ImmutableList.copyOf(requireNonNull(ciphers, \"ciphers is null\"));\n        }\n\n        public File getTrustCertificatesFile()\n        {\n            return trustCertificatesFile;\n        }\n\n        public Optional<File> getClientCertificatesFile()\n        {\n            return clientCertificatesFile;\n        }\n\n        public Optional<File> getPrivateKeyFile()\n        {\n            return privateKeyFile;\n        }\n\n        public Optional<String> getPrivateKeyPassword()\n        {\n            return privateKeyPassword;\n        }\n\n        public long getSessionCacheSize()\n        {\n            return sessionCacheSize;\n        }\n\n        public Duration getSessionTimeout()\n        {\n            return sessionTimeout;\n        }\n\n        public List<String> getCiphers()\n        {\n            return ciphers;\n        }\n\n        @Override\n        public boolean equals(Object o)\n        {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n            SslContextParameters that = (SslContextParameters) o;\n            return sessionCacheSize == that.sessionCacheSize &&\n                    Objects.equals(trustCertificatesFile, that.trustCertificatesFile) &&\n                    Objects.equals(clientCertificatesFile, that.clientCertificatesFile) &&\n                    Objects.equals(privateKeyFile, that.privateKeyFile) &&\n                    Objects.equals(privateKeyPassword, that.privateKeyPassword) &&\n                    Objects.equals(sessionTimeout, that.sessionTimeout) &&\n                    Objects.equals(ciphers, that.ciphers);\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return Objects.hash(trustCertificatesFile, clientCertificatesFile, privateKeyFile, privateKeyPassword, sessionCacheSize, sessionTimeout, ciphers);\n        }\n    }\n}\n\n'drift/drift-transport-netty/src/test/java/io/airlift/drift/transport/netty/client/TestDriftNettyMethodInvoker.java'\n:\npackage io.airlift.drift.transport.netty.client;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport com.google.common.util.concurrent.SettableFuture;\nimport io.airlift.drift.TApplicationException;\nimport io.airlift.drift.codec.ThriftCodec;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.codec.internal.builtin.VoidThriftCodec;\nimport io.airlift.drift.codec.metadata.ThriftType;\nimport io.airlift.drift.transport.MethodMetadata;\nimport io.airlift.drift.transport.ParameterMetadata;\nimport io.airlift.drift.transport.client.InvokeRequest;\nimport io.airlift.drift.transport.client.MethodInvoker;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.client.ConnectionManager.ConnectionParameters;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.drift.transport.netty.scribe.apache.LogEntry;\nimport io.airlift.drift.transport.netty.scribe.apache.ResultCode;\nimport io.airlift.drift.transport.netty.scribe.apache.ScribeService;\nimport io.airlift.drift.transport.netty.scribe.apache.scribe;\nimport io.airlift.drift.transport.netty.scribe.apache.scribe.Client;\nimport io.airlift.drift.transport.netty.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.transport.netty.scribe.drift.DriftResultCode;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerConfig;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransportFactory;\nimport io.airlift.drift.transport.server.ServerInvokeRequest;\nimport io.airlift.drift.transport.server.ServerMethodInvoker;\nimport io.airlift.drift.transport.server.ServerTransport;\nimport io.airlift.units.DataSize;\nimport io.airlift.units.DataSize.Unit;\nimport io.airlift.units.Duration;\nimport io.netty.channel.Channel;\nimport io.netty.util.concurrent.DefaultEventExecutor;\nimport io.netty.util.concurrent.Future;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.TProcessor;\nimport org.apache.thrift.async.AsyncMethodCallback;\nimport org.apache.thrift.async.TAsyncClientManager;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.apache.thrift.protocol.TCompactProtocol;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.protocol.TProtocolFactory;\nimport org.apache.thrift.server.TServer;\nimport org.apache.thrift.server.TServer.Args;\nimport org.apache.thrift.server.TSimpleServer;\nimport org.apache.thrift.transport.TNonblockingSocket;\nimport org.apache.thrift.transport.TServerSocket;\nimport org.apache.thrift.transport.TSocket;\nimport org.apache.thrift.transport.TTransportFactory;\nimport org.apache.thrift.transport.layered.TFramedTransport;\nimport org.testng.annotations.Test;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.function.ToIntFunction;\nimport java.util.stream.Collectors;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static com.google.common.collect.Lists.newArrayList;\nimport static io.airlift.concurrent.Threads.daemonThreadsNamed;\nimport static io.airlift.drift.TApplicationException.Type.UNSUPPORTED_CLIENT_TYPE;\nimport static io.airlift.drift.codec.metadata.ThriftType.list;\nimport static io.airlift.drift.codec.metadata.ThriftType.optional;\nimport static io.airlift.drift.transport.netty.codec.Protocol.BINARY;\nimport static io.airlift.drift.transport.netty.codec.Transport.FRAMED;\nimport static io.airlift.testing.Assertions.assertInstanceOf;\nimport static java.util.Collections.nCopies;\nimport static java.util.concurrent.Executors.newSingleThreadScheduledExecutor;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.fail;\n\npublic class TestDriftNettyMethodInvoker\n{\n    private static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n\n    private static final MethodMetadata LOG_METHOD_METADATA = new MethodMetadata(\n            \"Log\",\n            ImmutableList.of(new ParameterMetadata(\n                    (short) 1,\n                    \"messages\",\n                    (ThriftCodec<Object>) CODEC_MANAGER.getCodec(list(CODEC_MANAGER.getCodec(DriftLogEntry.class).getType())))),\n            (ThriftCodec<Object>) (Object) CODEC_MANAGER.getCodec(DriftResultCode.class),\n            ImmutableMap.of(),\n            ImmutableMap.of(),\n            false,\n            true);\n\n    private static final List<LogEntry> MESSAGES = ImmutableList.of(\n            new LogEntry(\"hello\", \"world\"),\n            new LogEntry(\"bye\", \"world\"));\n    private static final List<DriftLogEntry> DRIFT_MESSAGES = ImmutableList.copyOf(\n            MESSAGES.stream()\n                    .map(input -> new DriftLogEntry(input.category, input.message))\n                    .collect(Collectors.toList()));\n    private static final DriftResultCode DRIFT_OK = DriftResultCode.OK;\n\n    @Test\n    public void testThriftService()\n            throws Exception\n    {\n        ScribeService scribeService = new ScribeService();\n        TProcessor processor = new scribe.Processor<>(scribeService);\n\n        List<LogEntry> expectedMessages = testProcessor(processor);\n        assertEquals(scribeService.getMessages(), expectedMessages);\n    }\n\n    private static List<LogEntry> testProcessor(TProcessor processor)\n            throws Exception\n    {\n        int invocationCount = testProcessor(processor, ImmutableList.of(\n                address -> logThrift(address, MESSAGES, new TFramedTransport.Factory(), new TBinaryProtocol.Factory()),\n                address -> logThriftAsync(address, MESSAGES),\n                address -> logNiftyInvocationHandlerOptional(address, DRIFT_MESSAGES),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, FRAMED, BINARY)));\n\n        return newArrayList(concat(nCopies(invocationCount, MESSAGES)));\n    }\n\n    private static int testProcessor(TProcessor processor, List<ToIntFunction<HostAndPort>> clients)\n            throws Exception\n    {\n        try (TServerSocket serverTransport = new TServerSocket(0)) {\n            TProtocolFactory protocolFactory = new TBinaryProtocol.Factory();\n            TTransportFactory transportFactory = new TFramedTransport.Factory();\n            TServer server = new TSimpleServer(new Args(serverTransport)\n                    .protocolFactory(protocolFactory)\n                    .transportFactory(transportFactory)\n                    .processor(processor));\n\n            Thread serverThread = new Thread(server::serve);\n            try {\n                serverThread.start();\n\n                int localPort = serverTransport.getServerSocket().getLocalPort();\n                HostAndPort address = HostAndPort.fromParts(\"localhost\", localPort);\n\n                int sum = 0;\n                for (ToIntFunction<HostAndPort> client : clients) {\n                    sum += client.applyAsInt(address);\n                }\n                return sum;\n            }\n            finally {\n                server.stop();\n                serverThread.interrupt();\n            }\n        }\n    }\n\n    @Test\n    public void testDriftNettyService()\n    {\n        TestServerMethodInvoker methodInvoker = new TestServerMethodInvoker();\n        List<DriftLogEntry> expectedMessages = testMethodInvoker(methodInvoker);\n        assertEquals(ImmutableList.copyOf(methodInvoker.getMessages()), expectedMessages);\n    }\n\n    private static List<DriftLogEntry> testMethodInvoker(ServerMethodInvoker methodInvoker)\n    {\n        int invocationCount = testMethodInvoker(methodInvoker, ImmutableList.of(\n                address -> logThrift(address, MESSAGES, new TTransportFactory(), new TBinaryProtocol.Factory()),\n                address -> logThrift(address, MESSAGES, new TTransportFactory(), new TCompactProtocol.Factory()),\n                address -> logThrift(address, MESSAGES, new TFramedTransport.Factory(), new TBinaryProtocol.Factory()),\n                address -> logThrift(address, MESSAGES, new TFramedTransport.Factory(), new TCompactProtocol.Factory()),\n                address -> logThriftAsync(address, MESSAGES),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, Transport.UNFRAMED, BINARY),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, Transport.UNFRAMED, Protocol.COMPACT),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, Transport.UNFRAMED, Protocol.FB_COMPACT),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, FRAMED, BINARY),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, FRAMED, Protocol.COMPACT),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, FRAMED, Protocol.FB_COMPACT),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, Transport.HEADER, BINARY),\n                address -> logNiftyInvocationHandler(address, DRIFT_MESSAGES, Transport.HEADER, Protocol.FB_COMPACT)));\n\n        return newArrayList(concat(nCopies(invocationCount, DRIFT_MESSAGES)));\n    }\n\n    private static int testMethodInvoker(ServerMethodInvoker methodInvoker, List<ToIntFunction<HostAndPort>> clients)\n    {\n        TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n        ServerTransport serverTransport = new DriftNettyServerTransportFactory(new DriftNettyServerConfig(), testingAllocator).createServerTransport(methodInvoker);\n        try {\n            serverTransport.start();\n\n            HostAndPort address = HostAndPort.fromParts(\"localhost\", ((DriftNettyServerTransport) serverTransport).getPort());\n\n            int sum = 0;\n            for (ToIntFunction<HostAndPort> client : clients) {\n                sum += client.applyAsInt(address);\n            }\n            return sum;\n        }\n        finally {\n            serverTransport.shutdown();\n            testingAllocator.close();\n        }\n    }\n\n    private static int logThrift(HostAndPort address, List<LogEntry> messages, TTransportFactory framingFactory, TProtocolFactory protocolFactory)\n    {\n        try {\n            TSocket socket = new TSocket(address.getHost(), address.getPort());\n            socket.open();\n            try {\n                TProtocol tp = protocolFactory.getProtocol(framingFactory.getTransport(socket));\n                Client client = new Client(tp);\n                assertEquals(client.Log(messages), ResultCode.OK);\n\n                try {\n                    client.Log(ImmutableList.of(new LogEntry(\"exception\", \"test\")));\n                    fail(\"Expected exception\");\n                }\n                catch (org.apache.thrift.TApplicationException e) {\n                    assertEquals(e.getType(), org.apache.thrift.TApplicationException.UNSUPPORTED_CLIENT_TYPE);\n                }\n            }\n            finally {\n                socket.close();\n            }\n        }\n        catch (TException e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logThriftAsync(HostAndPort address, List<LogEntry> messages)\n    {\n        try {\n            TAsyncClientManager asyncClientManager = new TAsyncClientManager();\n            try (TNonblockingSocket socket = new TNonblockingSocket(address.getHost(), address.getPort())) {\n                scribe.AsyncClient client = new scribe.AsyncClient(new TBinaryProtocol.Factory(), asyncClientManager, socket);\n\n                SettableFuture<ResultCode> futureResult = SettableFuture.create();\n                client.Log(messages, new AsyncMethodCallback<ResultCode>()\n                {\n                    @Override\n                    public void onComplete(ResultCode resultCode)\n                    {\n                        try {\n                            futureResult.set(resultCode);\n                        }\n                        catch (Throwable exception) {\n                            futureResult.setException(exception);\n                        }\n                    }\n\n                    @Override\n                    public void onError(Exception exception)\n                    {\n                        futureResult.setException(exception);\n                    }\n                });\n                assertEquals(futureResult.get(), ResultCode.OK);\n            }\n            finally {\n                asyncClientManager.stop();\n            }\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNiftyInvocationHandler(HostAndPort address, List<DriftLogEntry> entries, Transport transport, Protocol protocol)\n    {\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<Void> methodInvokerFactory = new DriftNettyMethodInvokerFactory<>(\n                        new DriftNettyConnectionFactoryConfig(),\n                        clientIdentity -> config,\n                        testingAllocator)) {\n            MethodInvoker methodInvoker = methodInvokerFactory.createMethodInvoker(null);\n\n            ListenableFuture<Object> future = methodInvoker.invoke(new InvokeRequest(LOG_METHOD_METADATA, () -> address, ImmutableMap.of(), ImmutableList.of(entries)));\n            assertEquals(future.get(), DRIFT_OK);\n\n            try {\n                future = methodInvoker.invoke(new InvokeRequest(LOG_METHOD_METADATA, () -> address, ImmutableMap.of(), ImmutableList.of(ImmutableList.of(new DriftLogEntry(\"exception\", \"test\")))));\n                assertEquals(future.get(), DRIFT_OK);\n                fail(\"Expected exception\");\n            }\n            catch (ExecutionException e) {\n                Throwable cause = e.getCause();\n                assertInstanceOf(cause, TApplicationException.class);\n                TApplicationException applicationException = (TApplicationException) cause;\n                assertEquals(applicationException.getTypeValue(), UNSUPPORTED_CLIENT_TYPE.getType());\n            }\n            return 1;\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    @Test\n    public void testTimeout()\n            throws Exception\n    {\n        ScheduledExecutorService executor = newSingleThreadScheduledExecutor(daemonThreadsNamed(\"test-timeout\"));\n\n        DriftNettyMethodInvoker invoker = new DriftNettyMethodInvoker(\n                new ConnectionParameters(\n                        FRAMED,\n                        BINARY,\n                        new DataSize(16, Unit.MEGABYTE),\n                        new Duration(11, MILLISECONDS),\n                        new Duration(13, MILLISECONDS),\n                        Optional.empty(),\n                        Optional.empty()),\n                new HangingConnectionManager(),\n                executor,\n                new Duration(17, MILLISECONDS));\n\n        ListenableFuture<Object> response = invoker.invoke(new InvokeRequest(\n                new MethodMetadata(\n                        \"test\",\n                        ImmutableList.of(),\n                        (ThriftCodec<Object>) (Object) new VoidThriftCodec(),\n                        ImmutableMap.of(),\n                        ImmutableMap.of(),\n                        false,\n                        true),\n                () -> HostAndPort.fromParts(\"localhost\", 1234),\n                ImmutableMap.of(),\n                ImmutableList.of()));\n\n        try {\n            response.get();\n            fail(\"expected exception\");\n        }\n        catch (ExecutionException e) {\n            assertInstanceOf(e.getCause(), io.airlift.drift.TException.class);\n            assertEquals(e.getCause().getMessage(), \"Invocation response future did not complete after 41.00ms\");\n        }\n        finally {\n            executor.shutdown();\n        }\n    }\n\n    private static int logNiftyInvocationHandlerOptional(HostAndPort address, List<DriftLogEntry> entries)\n    {\n        DriftNettyClientConfig config = new DriftNettyClientConfig();\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<Void> methodInvokerFactory = new DriftNettyMethodInvokerFactory<>(\n                        new DriftNettyConnectionFactoryConfig(),\n                        clientIdentity -> config,\n                        testingAllocator)) {\n            MethodInvoker methodInvoker = methodInvokerFactory.createMethodInvoker(null);\n\n            ThriftType optionalType = optional(list(CODEC_MANAGER.getCatalog().getThriftType(DriftLogEntry.class)));\n            ParameterMetadata parameter = new ParameterMetadata(\n                    (short) 1,\n                    \"messages\",\n                    (ThriftCodec<Object>) CODEC_MANAGER.getCodec(optionalType));\n\n            MethodMetadata methodMetadata = new MethodMetadata(\n                    \"Log\",\n                    ImmutableList.of(parameter),\n                    (ThriftCodec<Object>) (Object) CODEC_MANAGER.getCodec(DriftResultCode.class),\n                    ImmutableMap.of(),\n                    ImmutableMap.of(),\n                    false,\n                    true);\n\n            ListenableFuture<Object> future = methodInvoker.invoke(new InvokeRequest(methodMetadata, () -> address, ImmutableMap.of(), ImmutableList.of(Optional.of(entries))));\n            assertEquals(future.get(), DRIFT_OK);\n\n            future = methodInvoker.invoke(new InvokeRequest(methodMetadata, () -> address, ImmutableMap.of(), ImmutableList.of(Optional.empty())));\n            assertEquals(future.get(), DRIFT_OK);\n\n            try {\n                future = methodInvoker.invoke(new InvokeRequest(\n                        methodMetadata,\n                        () -> address,\n                        ImmutableMap.of(),\n                        ImmutableList.of(Optional.of(ImmutableList.of(new DriftLogEntry(\"exception\", \"test\"))))));\n                assertEquals(future.get(), DRIFT_OK);\n            }\n            catch (ExecutionException e) {\n                Throwable cause = e.getCause();\n                assertInstanceOf(cause, io.airlift.drift.TApplicationException.class);\n                io.airlift.drift.TApplicationException applicationException = (io.airlift.drift.TApplicationException) cause;\n                assertEquals(applicationException.getTypeValue(), UNSUPPORTED_CLIENT_TYPE.getType());\n            }\n            return 1;\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static class HangingConnectionManager\n            implements ConnectionManager\n    {\n        @Override\n        public Future<Channel> getConnection(ConnectionParameters connectionParameters, HostAndPort address)\n        {\n            return new DefaultEventExecutor().newPromise();\n        }\n\n        @Override\n        public void returnConnection(Channel connection)\n        {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public void close() {}\n    }\n\n    private static class TestServerMethodInvoker\n            implements ServerMethodInvoker\n    {\n        private final List<DriftLogEntry> messages = new CopyOnWriteArrayList<>();\n\n        private List<DriftLogEntry> getMessages()\n        {\n            return messages;\n        }\n\n        @Override\n        public Optional<MethodMetadata> getMethodMetadata(String name)\n        {\n            if (LOG_METHOD_METADATA.getName().equals(name)) {\n                return Optional.of(LOG_METHOD_METADATA);\n            }\n            return Optional.empty();\n        }\n\n        @Override\n        public ListenableFuture<Object> invoke(ServerInvokeRequest request)\n        {\n            MethodMetadata method = request.getMethod();\n            if (!LOG_METHOD_METADATA.getName().equals(method.getName())) {\n                return Futures.immediateFailedFuture(new IllegalArgumentException(\"unknown method \" + method));\n            }\n\n            Map<Short, Object> parameters = request.getParameters();\n            if (parameters.size() != 1 || !parameters.containsKey((short) 1) || !(getOnlyElement(parameters.values()) instanceof List)) {\n                return Futures.immediateFailedFuture(new IllegalArgumentException(\"invalid parameters\"));\n            }\n            List<DriftLogEntry> messages = (List<DriftLogEntry>) getOnlyElement(parameters.values());\n\n            for (DriftLogEntry message : messages) {\n                if (message.getCategory().equals(\"exception\")) {\n                    return Futures.immediateFailedFuture(new TApplicationException(UNSUPPORTED_CLIENT_TYPE, message.getMessage()));\n                }\n            }\n            this.messages.addAll(messages);\n            return Futures.immediateFuture(DRIFT_OK);\n        }\n\n        @Override\n        public void recordResult(String methodName, long startTime, ListenableFuture<Object> result)\n        {\n\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/ssl/SslContextFactory.java'",
            "'drift/drift-transport-netty/src/main/java/io/airlift/drift/transport/netty/client/ConnectionManager.java'",
            "'drift/drift-transport-netty/src/test/java/io/airlift/drift/transport/netty/client/TestDriftNettyMethodInvoker.java'"
        ]
    },
    {
        "files": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetSchemaUtil.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'"
        ],
        "content": "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.parquet;\n\nimport com.google.common.collect.Sets;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.parquet.schema.MessageType;\nimport org.apache.parquet.schema.Type;\nimport org.apache.parquet.schema.Types.MessageTypeBuilder;\nimport java.util.Set;\n\npublic class ParquetSchemaUtil {\n  public static MessageType convert(Schema schema, String name) {\n    return new TypeToMessageType().convert(schema, name);\n  }\n\n  public static Schema convert(MessageType parquetSchema) {\n    MessageTypeToType converter = new MessageTypeToType(parquetSchema);\n    return new Schema(\n        ParquetTypeVisitor.visit(parquetSchema, converter).asNestedType().fields(),\n        converter.getAliases());\n  }\n\n  public static MessageType pruneColumns(MessageType fileSchema, Schema expectedSchema) {\n\n    Set<Integer> selectedIds = TypeUtil.getProjectedIds(expectedSchema);\n    return (MessageType) ParquetTypeVisitor.visit(fileSchema, new PruneColumns(selectedIds));\n  }\n\n\n  public static MessageType pruneColumnsFallback(MessageType fileSchema, Schema expectedSchema) {\n    Set<Integer> selectedIds = Sets.newHashSet();\n\n    for (Types.NestedField field : expectedSchema.columns()) {\n      selectedIds.add(field.fieldId());\n    }\n\n    MessageTypeBuilder builder = org.apache.parquet.schema.Types.buildMessage();\n\n    int ordinal = 1;\n    for (Type type : fileSchema.getFields()) {\n      if (selectedIds.contains(ordinal)) {\n        builder.addField(type.withId(ordinal));\n      }\n      ordinal += 1;\n    }\n\n    return builder.named(fileSchema.getName());\n  }\n\n  public static boolean hasIds(MessageType fileSchema) {\n    try {\n\n      ParquetTypeVisitor.visit(fileSchema, new MessageTypeToType(fileSchema) {\n        @Override\n        protected int nextId() {\n          throw new IllegalStateException(\"Needed to assign ID\");\n        }\n      });\n\n\n      return true;\n\n    } catch (IllegalStateException e) {\n\n      return false;\n    }\n  }\n\n  public static MessageType addFallbackIds(MessageType fileSchema) {\n    MessageTypeBuilder builder = org.apache.parquet.schema.Types.buildMessage();\n\n    int ordinal = 1;\n    for (Type type : fileSchema.getFields()) {\n      builder.addField(type.withId(ordinal));\n      ordinal += 1;\n    }\n\n    return builder.named(fileSchema.getName());\n  }\n}\n\n'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'\n:\n\npackage com.netflix.iceberg.data;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.CombinedScanTask;\nimport com.netflix.iceberg.FileScanTask;\nimport com.netflix.iceberg.HasTableOperations;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.TableOperations;\nimport com.netflix.iceberg.TableScan;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.data.avro.DataReader;\nimport com.netflix.iceberg.exceptions.RuntimeIOException;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Evaluator;\nimport com.netflix.iceberg.expressions.Expressions;\nimport com.netflix.iceberg.io.CloseableGroup;\nimport com.netflix.iceberg.io.CloseableIterable;\nimport com.netflix.iceberg.io.InputFile;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.types.TypeUtil;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Iterables.filter;\nimport static com.google.common.collect.Iterables.transform;\nimport static com.netflix.iceberg.data.parquet.GenericParquetReaders.buildReader;\nimport static java.util.Collections.emptyIterator;\n\nclass TableScanIterable extends CloseableGroup implements CloseableIterable<Record> {\n  private final TableOperations ops;\n  private final Schema projection;\n  private final boolean reuseContainers;\n  private final CloseableIterable<CombinedScanTask> tasks;\n\n  TableScanIterable(TableScan scan, boolean reuseContainers) {\n    Preconditions.checkArgument(scan.table() instanceof HasTableOperations,\n        \"Cannot scan table that doesn't expose its TableOperations\");\n    this.ops = ((HasTableOperations) scan.table()).operations();\n    this.projection = scan.schema();\n    this.reuseContainers = reuseContainers;\n\n\n    this.tasks = scan.planTasks();\n  }\n\n  @Override\n  public Iterator<Record> iterator() {\n    ScanIterator iter = new ScanIterator(tasks);\n    addCloseable(iter);\n    return iter;\n  }\n\n  private CloseableIterable<Record> open(FileScanTask task) {\n    InputFile input = ops.io().newInputFile(task.file().path().toString());\n\n\n    switch (task.file().format()) {\n      case AVRO:\n        Avro.ReadBuilder avro = Avro.read(input)\n            .project(projection)\n            .createReaderFunc(DataReader::create)\n            .split(task.start(), task.length());\n\n        if (reuseContainers) {\n          avro.reuseContainers();\n        }\n\n        return avro.build();\n\n      case PARQUET:\n        Parquet.ReadBuilder parquet = Parquet.read(input)\n            .project(projection)\n            .createReaderFunc(fileSchema -> buildReader(projection, fileSchema))\n            .split(task.start(), task.length());\n\n        if (reuseContainers) {\n          parquet.reuseContainers();\n        }\n\n        return parquet.build();\n\n      default:\n        throw new UnsupportedOperationException(String.format(\"Cannot read %s file: %s\",\n            task.file().format().name(), task.file().path()));\n    }\n  }\n\n  @Override\n  public void close() throws IOException {\n    tasks.close();\n    super.close();\n  }\n\n  private class ScanIterator implements Iterator<Record>, Closeable {\n    private final Iterator<FileScanTask> tasks;\n    private Closeable currentCloseable = null;\n    private Iterator<Record> currentIterator = emptyIterator();\n\n    private ScanIterator(Iterable<CombinedScanTask> tasks) {\n      this.tasks = Lists.newArrayList(concat(transform(tasks, CombinedScanTask::files))).iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n      while (true) {\n        if (currentIterator.hasNext()) {\n          return true;\n\n        } else if (tasks.hasNext()) {\n          if (currentCloseable != null) {\n            try {\n              currentCloseable.close();\n            } catch (IOException e) {\n              throw new RuntimeIOException(e, \"Failed to close task\");\n            }\n          }\n\n          FileScanTask task = tasks.next();\n          CloseableIterable<Record> reader = open(task);\n          this.currentCloseable = reader;\n\n          if (task.residual() != null && task.residual() != Expressions.alwaysTrue()) {\n            Evaluator filter = new Evaluator(projection.asStruct(), task.residual());\n            this.currentIterator = filter(reader, filter::eval).iterator();\n          } else {\n            this.currentIterator = reader.iterator();\n          }\n\n        } else {\n          return false;\n        }\n      }\n    }\n\n    @Override\n    public Record next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n\n      return currentIterator.next();\n    }\n\n    @Override\n    public void close() throws IOException {\n      if (currentCloseable != null) {\n        currentCloseable.close();\n      }\n    }\n  }\n}\n\n'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'\n:\n\npackage com.netflix.iceberg.data.parquet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.data.GenericRecord;\nimport com.netflix.iceberg.data.Record;\nimport com.netflix.iceberg.parquet.ParquetValueReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.BinaryAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.BytesReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.IntAsLongReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.IntegerAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.ListReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.LongAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.MapReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.PrimitiveReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.StringReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.StructReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.UnboxedReader;\nimport com.netflix.iceberg.parquet.TypeWithSchemaVisitor;\nimport com.netflix.iceberg.types.Type.TypeID;\nimport com.netflix.iceberg.types.Types;\nimport com.netflix.iceberg.types.Types.StructType;\nimport com.netflix.iceberg.types.Types.TimestampType;\nimport org.apache.parquet.column.ColumnDescriptor;\nimport org.apache.parquet.schema.DecimalMetadata;\nimport org.apache.parquet.schema.GroupType;\nimport org.apache.parquet.schema.MessageType;\nimport org.apache.parquet.schema.PrimitiveType;\nimport org.apache.parquet.schema.Type;\n\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.parquet.ParquetSchemaUtil.hasIds;\nimport static com.netflix.iceberg.parquet.ParquetValueReaders.option;\n\npublic class GenericParquetReaders {\n  private GenericParquetReaders() {\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static ParquetValueReader<GenericRecord> buildReader(Schema expectedSchema,\n                                                              MessageType fileSchema) {\n    if (hasIds(fileSchema)) {\n      return (ParquetValueReader<GenericRecord>)\n          TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n              new ReadBuilder(fileSchema));\n    } else {\n      return (ParquetValueReader<GenericRecord>)\n          TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n              new FallbackReadBuilder(fileSchema));\n    }\n  }\n\n  private static class FallbackReadBuilder extends ReadBuilder {\n    FallbackReadBuilder(MessageType type) {\n      super(type);\n    }\n\n    @Override\n    public ParquetValueReader<?> message(StructType expected, MessageType message,\n                                         List<ParquetValueReader<?>> fieldReaders) {\n\n      return super.struct(expected, message, fieldReaders);\n    }\n\n    @Override\n    public ParquetValueReader<?> struct(StructType expected, GroupType struct,\n                                        List<ParquetValueReader<?>> fieldReaders) {\n\n      List<ParquetValueReader<?>> newFields = Lists.newArrayListWithExpectedSize(\n          fieldReaders.size());\n      List<Type> types = Lists.newArrayListWithExpectedSize(fieldReaders.size());\n      List<Type> fields = struct.getFields();\n      for (int i = 0; i < fields.size(); i += 1) {\n        Type fieldType = fields.get(i);\n        int fieldD = type.getMaxDefinitionLevel(path(fieldType.getName()))-1;\n        newFields.add(option(fieldType, fieldD, fieldReaders.get(i)));\n        types.add(fieldType);\n      }\n\n      return new RecordReader(types, newFields, expected);\n    }\n  }\n\n  private static class ReadBuilder extends TypeWithSchemaVisitor<ParquetValueReader<?>> {\n    final MessageType type;\n\n    ReadBuilder(MessageType type) {\n      this.type = type;\n    }\n\n    @Override\n    public ParquetValueReader<?> message(StructType expected, MessageType message,\n                                         List<ParquetValueReader<?>> fieldReaders) {\n      return struct(expected, message.asGroupType(), fieldReaders);\n    }\n\n    @Override\n    public ParquetValueReader<?> struct(StructType expected, GroupType struct,\n                                        List<ParquetValueReader<?>> fieldReaders) {\n\n      Map<Integer, ParquetValueReader<?>> readersById = Maps.newHashMap();\n      Map<Integer, Type> typesById = Maps.newHashMap();\n      List<Type> fields = struct.getFields();\n      for (int i = 0; i < fields.size(); i += 1) {\n        Type fieldType = fields.get(i);\n        int fieldD = type.getMaxDefinitionLevel(path(fieldType.getName()))-1;\n        int id = fieldType.getId().intValue();\n        readersById.put(id, option(fieldType, fieldD, fieldReaders.get(i)));\n        typesById.put(id, fieldType);\n      }\n\n      List<Types.NestedField> expectedFields = expected != null ?\n          expected.fields() : ImmutableList.of();\n      List<ParquetValueReader<?>> reorderedFields = Lists.newArrayListWithExpectedSize(\n          expectedFields.size());\n      List<Type> types = Lists.newArrayListWithExpectedSize(expectedFields.size());\n      for (Types.NestedField field : expectedFields) {\n        int id = field.fieldId();\n        ParquetValueReader<?> reader = readersById.get(id);\n        if (reader != null) {\n          reorderedFields.add(reader);\n          types.add(typesById.get(id));\n        } else {\n          reorderedFields.add(ParquetValueReaders.nulls());\n          types.add(null);\n        }\n      }\n\n      return new RecordReader(types, reorderedFields, expected);\n    }\n\n    @Override\n    public ParquetValueReader<?> list(Types.ListType expectedList, GroupType array,\n                                      ParquetValueReader<?> elementReader) {\n      GroupType repeated = array.getFields().get(0).asGroupType();\n      String[] repeatedPath = currentPath();\n\n      int repeatedD = type.getMaxDefinitionLevel(repeatedPath)-1;\n      int repeatedR = type.getMaxRepetitionLevel(repeatedPath)-1;\n\n      Type elementType = repeated.getType(0);\n      int elementD = type.getMaxDefinitionLevel(path(elementType.getName()))-1;\n\n      return new ListReader<>(repeatedD, repeatedR, option(elementType, elementD, elementReader));\n    }\n\n    @Override\n    public ParquetValueReader<?> map(Types.MapType expectedMap, GroupType map,\n                                     ParquetValueReader<?> keyReader,\n                                     ParquetValueReader<?> valueReader) {\n      GroupType repeatedKeyValue = map.getFields().get(0).asGroupType();\n      String[] repeatedPath = currentPath();\n\n      int repeatedD = type.getMaxDefinitionLevel(repeatedPath)-1;\n      int repeatedR = type.getMaxRepetitionLevel(repeatedPath)-1;\n\n      Type keyType = repeatedKeyValue.getType(0);\n      int keyD = type.getMaxDefinitionLevel(path(keyType.getName()))-1;\n      Type valueType = repeatedKeyValue.getType(1);\n      int valueD = type.getMaxDefinitionLevel(path(valueType.getName()))-1;\n\n      return new MapReader<>(repeatedD, repeatedR,\n          option(keyType, keyD, keyReader), option(valueType, valueD, valueReader));\n    }\n\n    @Override\n    public ParquetValueReader<?> primitive(com.netflix.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected.typeId() == TypeID.LONG) {\n              return new IntAsLongReader(desc);\n            } else {\n              return new UnboxedReader<>(desc);\n            }\n          case INT_64:\n            return new UnboxedReader<>(desc);\n          case DATE:\n            return new DateReader(desc);\n          case TIMESTAMP_MICROS:\n            TimestampType tsMicrosType = (TimestampType) expected;\n            if (tsMicrosType.shouldAdjustToUTC()) {\n              return new TimestamptzReader(desc);\n            } else {\n              return new TimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            TimestampType tsMillisType = (TimestampType) expected;\n            if (tsMillisType.shouldAdjustToUTC()) {\n              return new TimestamptzMillisReader(desc);\n            } else {\n              return new TimestampMillisReader(desc);\n            }\n          case DECIMAL:\n            DecimalMetadata decimal = primitive.getDecimalMetadata();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new BinaryAsDecimalReader(desc, decimal.getScale());\n              case INT64:\n                return new LongAsDecimalReader(desc, decimal.getScale());\n              case INT32:\n                return new IntegerAsDecimalReader(desc, decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new BytesReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n          return new FixedReader(desc);\n        case BINARY:\n          return new BytesReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == TypeID.LONG) {\n            return new IntAsLongReader(desc);\n          } else {\n            return new UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new UnboxedReader<>(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n\n    private String[] currentPath() {\n      String[] path = new String[fieldNames.size()];\n      if (!fieldNames.isEmpty()) {\n        Iterator<String> iter = fieldNames.descendingIterator();\n        for (int i = 0; iter.hasNext(); i += 1) {\n          path[i] = iter.next();\n        }\n      }\n\n      return path;\n    }\n\n    protected String[] path(String name) {\n      String[] path = new String[fieldNames.size() + 1];\n      path[fieldNames.size()] = name;\n\n      if (!fieldNames.isEmpty()) {\n        Iterator<String> iter = fieldNames.descendingIterator();\n        for (int i = 0; iter.hasNext(); i += 1) {\n          path[i] = iter.next();\n        }\n      }\n\n      return path;\n    }\n  }\n\n  private static final OffsetDateTime EPOCH = Instant.ofEpochSecond(0).atOffset(ZoneOffset.UTC);\n  private static final LocalDate EPOCH_DAY = EPOCH.toLocalDate();\n\n  private static class DateReader extends PrimitiveReader<LocalDate> {\n    private DateReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDate read(LocalDate reuse) {\n      return EPOCH_DAY.plusDays(column.nextInteger());\n    }\n  }\n\n  private static class TimestampReader extends PrimitiveReader<LocalDateTime> {\n    private TimestampReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDateTime read(LocalDateTime reuse) {\n      return EPOCH.plus(column.nextLong(), ChronoUnit.MICROS).toLocalDateTime();\n    }\n  }\n\n  private static class TimestampMillisReader extends PrimitiveReader<LocalDateTime> {\n    private TimestampMillisReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDateTime read(LocalDateTime reuse) {\n      return EPOCH.plus(column.nextLong() * 1000, ChronoUnit.MICROS).toLocalDateTime();\n    }\n  }\n\n  private static class TimestamptzReader extends PrimitiveReader<OffsetDateTime> {\n    private TimestamptzReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public OffsetDateTime read(OffsetDateTime reuse) {\n      return EPOCH.plus(column.nextLong(), ChronoUnit.MICROS);\n    }\n  }\n\n  private static class TimestamptzMillisReader extends PrimitiveReader<OffsetDateTime> {\n    private TimestamptzMillisReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public OffsetDateTime read(OffsetDateTime reuse) {\n      return EPOCH.plus(column.nextLong() * 1000, ChronoUnit.MICROS);\n    }\n  }\n\n  private static class FixedReader extends PrimitiveReader<byte[]> {\n    private FixedReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public byte[] read(byte[] reuse) {\n      if (reuse != null) {\n        column.nextBinary().toByteBuffer().duplicate().get(reuse);\n        return reuse;\n      } else {\n        return column.nextBinary().getBytes();\n      }\n    }\n  }\n\n  static class RecordReader extends StructReader<Record, Record> {\n    private final StructType struct;\n\n    RecordReader(List<Type> types,\n                 List<ParquetValueReader<?>> readers,\n                 StructType struct) {\n      super(types, readers);\n      this.struct = struct;\n    }\n\n    @Override\n    protected Record newStructData(Record reuse) {\n      if (reuse != null) {\n        return reuse;\n      } else {\n        return GenericRecord.create(struct);\n      }\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Object getField(Record intermediate, int pos) {\n      return intermediate.get(pos);\n    }\n\n    @Override\n    protected Record buildStruct(Record struct) {\n      return struct;\n    }\n\n    @Override\n    protected void set(Record struct, int pos, Object value) {\n      struct.set(pos, value);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetSchemaUtil.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ]
    },
    {
        "files": [
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/ExternalPreview.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/MarkdownPreviewPane.java'"
        ],
        "content": "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'\n:\n\npackage org.markdownwriterfx.options;\n\nimport java.io.File;\nimport java.util.List;\nimport java.util.prefs.Preferences;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport javafx.beans.property.BooleanProperty;\nimport javafx.beans.property.IntegerProperty;\nimport javafx.beans.property.ObjectProperty;\nimport javafx.beans.property.StringProperty;\nimport javafx.scene.text.Font;\nimport org.markdownwriterfx.projects.ProjectManager;\nimport org.markdownwriterfx.projects.ProjectSettings;\nimport org.markdownwriterfx.util.PrefsBooleanProperty;\nimport org.markdownwriterfx.util.PrefsEnumProperty;\nimport org.markdownwriterfx.util.PrefsIntegerProperty;\nimport org.markdownwriterfx.util.PrefsStringProperty;\nimport org.markdownwriterfx.util.PrefsStringsProperty;\nimport org.markdownwriterfx.util.Utils;\n\n\npublic class Options\n{\n\tpublic static final String[] DEF_FONT_FAMILIES = {\n\t\t\"Consolas\",\n\t\t\"DejaVu Sans Mono\",\n\t\t\"Lucida Sans Typewriter\",\n\t\t\"Lucida Console\",\n\t};\n\n\tpublic static final int DEF_FONT_SIZE = 12;\n\tpublic static final int MIN_FONT_SIZE = 8;\n\tpublic static final int MAX_FONT_SIZE = 36;\n\tpublic static final String DEF_MARKDOWN_FILE_EXTENSIONS = \"*.md,*.markdown,*.txt\";\n\tpublic enum RendererType { CommonMark, FlexMark }\n\tpublic static final int DEF_WRAP_LINE_LENGTH = 80;\n\tpublic static final int MIN_WRAP_LINE_LENGTH = 10;\n\n\tprivate static Preferences globalOptions;\n\tprivate static Preferences options;\n\n\tpublic static void load(Preferences globalOptions) {\n\t\tOptions.globalOptions = globalOptions;\n\n\t\toptions = getProjectOptions(ProjectManager.getActiveProject());\n\n\t\tfontFamily.init(options, \"fontFamily\", null, value -> safeFontFamily(value));\n\t\tfontSize.init(options, \"fontSize\", DEF_FONT_SIZE);\n\t\tlineSeparator.init(options, \"lineSeparator\", null);\n\t\tencoding.init(options, \"encoding\", null);\n\t\tmarkdownFileExtensions.init(options, \"markdownFileExtensions\", DEF_MARKDOWN_FILE_EXTENSIONS);\n\t\tmarkdownExtensions.init(options, \"markdownExtensions\");\n\t\tmarkdownRenderer.init(options, \"markdownRenderer\", RendererType.CommonMark);\n\t\tshowLineNo.init(options, \"showLineNo\", false);\n\t\tshowWhitespace.init(options, \"showWhitespace\", false);\n\t\tshowImagesEmbedded.init(options, \"showImagesEmbedded\", false);\n\n\t\temphasisMarker.init(options, \"emphasisMarker\", \"_\");\n\t\tstrongEmphasisMarker.init(options, \"strongEmphasisMarker\", \"**\");\n\t\tbulletListMarker.init(options, \"bulletListMarker\", \"-\");\n\n\t\twrapLineLength.init(options, \"wrapLineLength\", DEF_WRAP_LINE_LENGTH);\n\t\tformatOnSave.init(options, \"formatOnSave\", false);\n\t\tformatOnlyModifiedParagraphs.init(options, \"formatOnlyModifiedParagraphs\", false);\n\n\t\tspellChecker.init(options, \"spellChecker\", true);\n\t\tgrammarChecker.init(options, \"grammarChecker\", true);\n\t\tlanguage.init(options, \"language\", null);\n\t\tuserDictionary.init(options, \"userDictionary\", getDefaultUserDictionary());\n\t\tdisabledRules.init(options, \"disabledRules\");\n\n\t\tadditionalCSS.init(options, \"additionalCSS\", null);\n\n\n\t\taddonsPath.init(globalOptions, \"addonsPath\", null);\n\n\n\t\tProjectManager.activeProjectProperty().addListener((observer, oldProject, newProject) -> {\n\t\t\tset(getProjectOptions(newProject));\n\t\t});\n\t}\n\n\tprivate static void set(Preferences options) {\n\t\tif (Options.options == options)\n\t\t\treturn;\n\n\t\tOptions.options = options;\n\n\t\tfontFamily.setPreferences(options);\n\t\tfontSize.setPreferences(options);\n\t\tlineSeparator.setPreferences(options);\n\t\tencoding.setPreferences(options);\n\t\tmarkdownFileExtensions.setPreferences(options);\n\t\tmarkdownExtensions.setPreferences(options);\n\t\tmarkdownRenderer.setPreferences(options);\n\t\tshowLineNo.setPreferences(options);\n\t\tshowWhitespace.setPreferences(options);\n\t\tshowImagesEmbedded.setPreferences(options);\n\n\t\temphasisMarker.setPreferences(options);\n\t\tstrongEmphasisMarker.setPreferences(options);\n\t\tbulletListMarker.setPreferences(options);\n\n\t\twrapLineLength.setPreferences(options);\n\t\tformatOnSave.setPreferences(options);\n\t\tformatOnlyModifiedParagraphs.setPreferences(options);\n\n\t\tspellChecker.setPreferences(options);\n\t\tgrammarChecker.setPreferences(options);\n\t\tlanguage.setPreferences(options);\n\t\tuserDictionary.setPreferences(options);\n\t\tdisabledRules.setPreferences(options);\n\n\t\tadditionalCSS.setPreferences(options);\n\n\t\taddonsPath.setPreferences(globalOptions);\n\t}\n\n\tprivate static Preferences getProjectOptions(File project) {\n\t\tif (project != null) {\n\t\t\tPreferences projectOptions = ProjectSettings.get(project).getOptions();\n\t\t\tif (projectOptions != null)\n\t\t\t\treturn projectOptions;\n\t\t}\n\n\t\treturn globalOptions;\n\t}\n\n\tstatic boolean isStoreInProject() {\n\t\treturn options != globalOptions;\n\t}\n\n\tstatic void storeInProject(boolean enable) {\n\t\tProjectSettings projectSettings = ProjectSettings.get(ProjectManager.getActiveProject());\n\t\tprojectSettings.enableOptions(enable);\n\t\tset(enable ? projectSettings.getOptions() : globalOptions);\n\t}\n\n\n\tprivate static String safeFontFamily(String fontFamily) {\n\t\tList<String> fontFamilies = Font.getFamilies();\n\t\tif (fontFamily != null && fontFamilies.contains(fontFamily))\n\t\t\treturn fontFamily;\n\n\t\tfor (String family : DEF_FONT_FAMILIES) {\n\t\t\tif (fontFamilies.contains(family))\n\t\t\t\treturn family;\n\t\t}\n\t\treturn \"Monospaced\";\n\t}\n\n\n\tprivate static final PrefsStringProperty fontFamily = new PrefsStringProperty();\n\tpublic static String getFontFamily() { return fontFamily.get(); }\n\tpublic static void setFontFamily(String fontFamily) { Options.fontFamily.set(fontFamily); }\n\tpublic static StringProperty fontFamilyProperty() { return fontFamily; }\n\n\n\tprivate static final PrefsIntegerProperty fontSize = new PrefsIntegerProperty();\n\tpublic static int getFontSize() { return fontSize.get(); }\n\tpublic static void setFontSize(int fontSize) { Options.fontSize.set(Math.min(Math.max(fontSize,  MIN_FONT_SIZE), MAX_FONT_SIZE)); }\n\tpublic static IntegerProperty fontSizeProperty() { return fontSize; }\n\n\n\tprivate static final PrefsStringProperty lineSeparator = new PrefsStringProperty();\n\tpublic static String getLineSeparator() { return lineSeparator.get(); }\n\tpublic static void setLineSeparator(String lineSeparator) { Options.lineSeparator.set(lineSeparator); }\n\tpublic static StringProperty lineSeparatorProperty() { return lineSeparator; }\n\n\n\tprivate static final PrefsStringProperty encoding = new PrefsStringProperty();\n\tpublic static String getEncoding() { return encoding.get(); }\n\tpublic static void setEncoding(String encoding) { Options.encoding.set(encoding); }\n\tpublic static StringProperty encodingProperty() { return encoding; }\n\n\n\tprivate static final PrefsStringProperty markdownFileExtensions = new PrefsStringProperty();\n\tpublic static String getMarkdownFileExtensions() { return markdownFileExtensions.get(); }\n\tpublic static void setMarkdownFileExtensions(String markdownFileExtensions) { Options.markdownFileExtensions.set(markdownFileExtensions); }\n\tpublic static StringProperty markdownFileExtensionsProperty() { return markdownFileExtensions; }\n\n\n\tprivate static final PrefsStringsProperty markdownExtensions = new PrefsStringsProperty();\n\tpublic static String[] getMarkdownExtensions() { return markdownExtensions.get(); }\n\tpublic static void setMarkdownExtensions(String[] markdownExtensions) { Options.markdownExtensions.set(markdownExtensions); }\n\tpublic static ObjectProperty<String[]> markdownExtensionsProperty() { return markdownExtensions; }\n\n\n\tprivate static final PrefsEnumProperty<RendererType> markdownRenderer = new PrefsEnumProperty<>( RendererType.CommonMark );\n\tpublic static RendererType getMarkdownRenderer() { return markdownRenderer.get(); }\n\tpublic static void setMarkdownRenderer(RendererType markdownRenderer) { Options.markdownRenderer.set(markdownRenderer); }\n\tpublic static ObjectProperty<RendererType> markdownRendererProperty() { return markdownRenderer; }\n\n\n\tprivate static final PrefsBooleanProperty showLineNo = new PrefsBooleanProperty();\n\tpublic static boolean isShowLineNo() { return showLineNo.get(); }\n\tpublic static void setShowLineNo(boolean showLineNo) { Options.showLineNo.set(showLineNo); }\n\tpublic static BooleanProperty showLineNoProperty() { return showLineNo; }\n\n\n\tprivate static final PrefsBooleanProperty showWhitespace = new PrefsBooleanProperty();\n\tpublic static boolean isShowWhitespace() { return showWhitespace.get(); }\n\tpublic static void setShowWhitespace(boolean showWhitespace) { Options.showWhitespace.set(showWhitespace); }\n\tpublic static BooleanProperty showWhitespaceProperty() { return showWhitespace; }\n\n\n\tprivate static final PrefsBooleanProperty showImagesEmbedded = new PrefsBooleanProperty();\n\tpublic static boolean isShowImagesEmbedded() { return showImagesEmbedded.get(); }\n\tpublic static void setShowImagesEmbedded(boolean showImagesEmbedded) { Options.showImagesEmbedded.set(showImagesEmbedded); }\n\tpublic static BooleanProperty showImagesEmbeddedProperty() { return showImagesEmbedded; }\n\n\n\tprivate static final PrefsStringProperty emphasisMarker = new PrefsStringProperty();\n\tpublic static String getEmphasisMarker() { return emphasisMarker.get(); }\n\tpublic static void setEmphasisMarker(String emphasisMarker) { Options.emphasisMarker.set(emphasisMarker); }\n\tpublic static StringProperty emphasisMarkerProperty() { return emphasisMarker; }\n\n\n\tprivate static final PrefsStringProperty strongEmphasisMarker = new PrefsStringProperty();\n\tpublic static String getStrongEmphasisMarker() { return strongEmphasisMarker.get(); }\n\tpublic static void setStrongEmphasisMarker(String strongEmphasisMarker) { Options.strongEmphasisMarker.set(strongEmphasisMarker); }\n\tpublic static StringProperty strongEmphasisMarkerProperty() { return strongEmphasisMarker; }\n\n\n\tprivate static final PrefsStringProperty bulletListMarker = new PrefsStringProperty();\n\tpublic static String getBulletListMarker() { return bulletListMarker.get(); }\n\tpublic static void setBulletListMarker(String bulletListMarker) { Options.bulletListMarker.set(bulletListMarker); }\n\tpublic static StringProperty bulletListMarkerProperty() { return bulletListMarker; }\n\n\n\tprivate static final PrefsIntegerProperty wrapLineLength = new PrefsIntegerProperty();\n\tpublic static int getWrapLineLength() { return wrapLineLength.get(); }\n\tpublic static void setWrapLineLength(int wrapLineLength) { Options.wrapLineLength.set(Math.max(wrapLineLength, MIN_WRAP_LINE_LENGTH)); }\n\tpublic static IntegerProperty wrapLineLengthProperty() { return wrapLineLength; }\n\n\n\tprivate static final PrefsBooleanProperty formatOnSave = new PrefsBooleanProperty();\n\tpublic static boolean isFormatOnSave() { return formatOnSave.get(); }\n\tpublic static void setFormatOnSave(boolean formatOnSave) { Options.formatOnSave.set(formatOnSave); }\n\tpublic static BooleanProperty formatOnSaveProperty() { return formatOnSave; }\n\n\n\tprivate static final PrefsBooleanProperty formatOnlyModifiedParagraphs = new PrefsBooleanProperty();\n\tpublic static boolean isFormatOnlyModifiedParagraphs() { return formatOnlyModifiedParagraphs.get(); }\n\tpublic static void setFormatOnlyModifiedParagraphs(boolean formatOnlyModifiedParagraphs) { Options.formatOnlyModifiedParagraphs.set(formatOnlyModifiedParagraphs); }\n\tpublic static BooleanProperty formatOnlyModifiedParagraphsProperty() { return formatOnlyModifiedParagraphs; }\n\n\n\tprivate static final PrefsBooleanProperty spellChecker = new PrefsBooleanProperty();\n\tpublic static boolean isSpellChecker() { return spellChecker.get(); }\n\tpublic static void setSpellChecker(boolean spellChecker) { Options.spellChecker.set(spellChecker); }\n\tpublic static BooleanProperty spellCheckerProperty() { return spellChecker; }\n\n\n\tprivate static final PrefsBooleanProperty grammarChecker = new PrefsBooleanProperty();\n\tpublic static boolean isGrammarChecker() { return grammarChecker.get(); }\n\tpublic static void setGrammarChecker(boolean grammarChecker) { Options.grammarChecker.set(grammarChecker); }\n\tpublic static BooleanProperty grammarCheckerProperty() { return grammarChecker; }\n\n\n\tprivate static final PrefsStringProperty language = new PrefsStringProperty();\n\tpublic static String getLanguage() { return language.get(); }\n\tpublic static void setLanguage(String language) { Options.language.set(language); }\n\tpublic static StringProperty languageProperty() { return language; }\n\n\n\tprivate static final PrefsStringProperty userDictionary = new PrefsStringProperty();\n\tpublic static String getUserDictionary() { return userDictionaryOrDefault(userDictionary.get()); }\n\tpublic static void setUserDictionary(String userDictionary) { Options.userDictionary.set(userDictionaryOrDefault(userDictionary)); }\n\tpublic static StringProperty userDictionaryProperty() { return userDictionary; }\n\tprivate static String getDefaultUserDictionary() {\n\t\treturn System.getProperty(\"user.home\") + System.getProperty(\"file.separator\") + \"dictionary-mwfx.txt\";\n\t}\n\tprivate static String userDictionaryOrDefault(String userDictionary) {\n\t\treturn !Utils.isNullOrEmpty(userDictionary) ? userDictionary : getDefaultUserDictionary();\n\t}\n\n\n\n\tprivate static final PrefsStringsProperty disabledRules = new PrefsStringsProperty();\n\tpublic static String[] getDisabledRules() { return disabledRules.get(); }\n\tpublic static void setDisabledRules(String[] disabledRules) { Options.disabledRules.set(disabledRules); }\n\tpublic static ObjectProperty<String[]> disabledRulesProperty() { return disabledRules; }\n\n\tpublic static String ruleIdDesc2id(String str) {\n\t\treturn str.contains(\"=\") ? str.substring(0, str.indexOf('=')) : str;\n\t}\n\n\tpublic static String ruleIdDesc2desc(String str) {\n\t\treturn str.contains(\"=\") ? str.substring(str.indexOf('=') + 1) : str;\n\t}\n\n\tpublic static List<String> ruleIdDescs2ids(String[] strs) {\n\t\treturn Stream.of(strs)\n\t\t\t.map(Options::ruleIdDesc2id)\n\t\t\t.collect(Collectors.toList());\n\t}\n\n\n\tprivate static final PrefsStringProperty additionalCSS = new PrefsStringProperty();\n\tpublic static String getAdditionalCSS() { return additionalCSS.get(); }\n\tpublic static void setAdditionalCSS(String additionalCSS) { Options.additionalCSS.set(additionalCSS); }\n\tpublic static StringProperty additionalCSSProperty() { return additionalCSS; }\n\n\n\tprivate static final PrefsStringProperty addonsPath = new PrefsStringProperty();\n\tpublic static String getAddonsPath() { return addonsPath.get(); }\n\tpublic static void setAddonsPath(String addonsPath) { Options.addonsPath.set(addonsPath); }\n\tpublic static StringProperty addonsPathProperty() { return addonsPath; }\n}\n\n'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/ExternalPreview.java'\n:\n\npackage org.markdownwriterfx.preview;\n\nimport java.util.Iterator;\nimport java.util.ServiceLoader;\n\nimport javafx.scene.control.IndexRange;\nimport javafx.scene.control.Label;\n\nimport org.markdownwriterfx.Messages;\nimport org.markdownwriterfx.addons.PreviewViewAddon;\nimport org.markdownwriterfx.preview.MarkdownPreviewPane.PreviewContext;\nimport org.markdownwriterfx.preview.MarkdownPreviewPane.Renderer;\nimport org.markdownwriterfx.util.Addons;\n\n\nclass ExternalPreview\n\timplements MarkdownPreviewPane.Preview\n{\n\tprivate static final boolean hasExternalPreview =\n\t\tServiceLoader.load( PreviewViewAddon.class, Addons.getAddonsClassLoader() ).iterator().hasNext();\n\n\tprivate PreviewViewAddon previewView;\n\n\tExternalPreview() {\n\n\n\n\t\tServiceLoader<PreviewViewAddon> addons = ServiceLoader.load( PreviewViewAddon.class, Addons.getAddonsClassLoader() );\n\t\tIterator<PreviewViewAddon> it = addons.iterator();\n\t\tif (it.hasNext())\n\t\t\tpreviewView = it.next();\n\t}\n\n\tstatic boolean hasExternalPreview() {\n\t\treturn hasExternalPreview;\n\t}\n\n\t@Override\n\tpublic javafx.scene.Node getNode() {\n\t\tif (previewView != null)\n\t\t\treturn previewView.getNode();\n\t\telse\n\t\t\treturn new Label(Messages.get(\"ExternalPreview.notAvailable\"));\n\t}\n\n\t@Override\n\tpublic void update(PreviewContext context, Renderer renderer) {\n\t\tif (previewView != null)\n\t\t\tpreviewView.update(context.getMarkdownText(), context.getPath());\n\t}\n\n\t@Override\n\tpublic void scrollY(PreviewContext context, double value) {\n\t\tif (previewView != null)\n\t\t\tpreviewView.scrollY(value);\n\t}\n\n\t@Override\n\tpublic void editorSelectionChanged(PreviewContext context, IndexRange range) {\n\t\tif (previewView != null)\n\t\t\tpreviewView.editorSelectionChanged(range);\n\t}\n}\n",
        "gt": [
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/options/Options.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/MarkdownPreviewPane.java'",
            "'markdown-writer-fx/src/main/java/org/markdownwriterfx/preview/ExternalPreview.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'"
        ],
        "content": "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport java.util.List;\n\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Core;\nimport org.opencv.core.CvType;\nimport org.opencv.core.Mat;\nimport org.opencv.core.MatOfPoint;\nimport org.opencv.core.Rect;\nimport org.opencv.core.Scalar;\nimport org.opencv.core.Size;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport org.opencv.imgproc.Imgproc;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.WindowManager;\nimport android.view.View.OnTouchListener;\n\nimport com.jnardari.opencv_androidsamples.R;\nimport com.jnardari.opencv_androidsamples.utils.ColorBlobDetector;\n\npublic class ColorBlobDetectionActivity extends AppCompatActivity implements OnTouchListener, CvCameraViewListener2 {\n    private static final String  TAG              = \"OCVSample::Activity\";\n\n    private boolean              mIsColorSelected = false;\n    private Mat                  mRgba;\n    private Scalar               mBlobColorRgba;\n    private Scalar               mBlobColorHsv;\n    private ColorBlobDetector    mDetector;\n    private Mat                  mSpectrum;\n    private Size                 SPECTRUM_SIZE;\n    private Scalar               CONTOUR_COLOR;\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n\n    private BaseLoaderCallback  mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                    mOpenCvCameraView.setOnTouchListener(ColorBlobDetectionActivity.this);\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public ColorBlobDetectionActivity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_color_blob_detection);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.color_blob_detection_activity_surface_view);\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n        mRgba = new Mat(height, width, CvType.CV_8UC4);\n        mDetector = new ColorBlobDetector();\n        mSpectrum = new Mat();\n        mBlobColorRgba = new Scalar(255);\n        mBlobColorHsv = new Scalar(255);\n        SPECTRUM_SIZE = new Size(200, 64);\n        CONTOUR_COLOR = new Scalar(255,0,0,255);\n    }\n\n    public void onCameraViewStopped() {\n        mRgba.release();\n    }\n\n    public boolean onTouch(View v, MotionEvent event) {\n        int cols = mRgba.cols();\n        int rows = mRgba.rows();\n\n        int xOffset = (mOpenCvCameraView.getWidth() - cols) / 2;\n        int yOffset = (mOpenCvCameraView.getHeight() - rows) / 2;\n\n        int x = (int)event.getX() - xOffset;\n        int y = (int)event.getY() - yOffset;\n\n        Log.i(TAG, \"Touch image coordinates: (\" + x + \", \" + y + \")\");\n\n        if ((x < 0) || (y < 0) || (x > cols) || (y > rows)) return false;\n\n        Rect touchedRect = new Rect();\n\n        touchedRect.x = (x>4) ? x-4 : 0;\n        touchedRect.y = (y>4) ? y-4 : 0;\n\n        touchedRect.width = (x+4 < cols) ? x + 4 - touchedRect.x : cols - touchedRect.x;\n        touchedRect.height = (y+4 < rows) ? y + 4 - touchedRect.y : rows - touchedRect.y;\n\n        Mat touchedRegionRgba = mRgba.submat(touchedRect);\n\n        Mat touchedRegionHsv = new Mat();\n        Imgproc.cvtColor(touchedRegionRgba, touchedRegionHsv, Imgproc.COLOR_RGB2HSV_FULL);\n\n\n        mBlobColorHsv = Core.sumElems(touchedRegionHsv);\n        int pointCount = touchedRect.width*touchedRect.height;\n        for (int i = 0; i < mBlobColorHsv.val.length; i++)\n            mBlobColorHsv.val[i] /= pointCount;\n\n        mBlobColorRgba = converScalarHsv2Rgba(mBlobColorHsv);\n\n        Log.i(TAG, \"Touched rgba color: (\" + mBlobColorRgba.val[0] + \", \" + mBlobColorRgba.val[1] +\n                \", \" + mBlobColorRgba.val[2] + \", \" + mBlobColorRgba.val[3] + \")\");\n\n        mDetector.setHsvColor(mBlobColorHsv);\n\n        Imgproc.resize(mDetector.getSpectrum(), mSpectrum, SPECTRUM_SIZE);\n\n        mIsColorSelected = true;\n\n        touchedRegionRgba.release();\n        touchedRegionHsv.release();\n\n        return false;\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        mRgba = inputFrame.rgba();\n\n        if (mIsColorSelected) {\n            mDetector.process(mRgba);\n            List<MatOfPoint> contours = mDetector.getContours();\n            Log.e(TAG, \"Contours count: \" + contours.size());\n            Imgproc.drawContours(mRgba, contours, -1, CONTOUR_COLOR);\n\n            Mat colorLabel = mRgba.submat(4, 68, 4, 68);\n            colorLabel.setTo(mBlobColorRgba);\n\n            Mat spectrumLabel = mRgba.submat(4, 4 + mSpectrum.rows(), 70, 70 + mSpectrum.cols());\n            mSpectrum.copyTo(spectrumLabel);\n        }\n\n        return mRgba;\n    }\n\n    private Scalar converScalarHsv2Rgba(Scalar hsvColor) {\n        Mat pointMatRgba = new Mat();\n        Mat pointMatHsv = new Mat(1, 1, CvType.CV_8UC3, hsvColor);\n        Imgproc.cvtColor(pointMatHsv, pointMatRgba, Imgproc.COLOR_HSV2RGB_FULL, 4);\n\n        return new Scalar(pointMatRgba.get(0, 0));\n    }\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'"
        ]
    },
    {
        "files": [
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'"
        ],
        "content": "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'\n:\n\npackage github.daneren2005.dsub.adapter;\n\nimport android.content.Context;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport java.util.List;\n\nimport github.daneren2005.dsub.R;\nimport github.daneren2005.dsub.domain.MusicDirectory;\nimport github.daneren2005.dsub.domain.MusicDirectory.Entry;\nimport github.daneren2005.dsub.util.ImageLoader;\nimport github.daneren2005.dsub.util.Util;\nimport github.daneren2005.dsub.view.AlbumView;\nimport github.daneren2005.dsub.view.SongView;\nimport github.daneren2005.dsub.view.UpdateView;\nimport github.daneren2005.dsub.view.UpdateView.UpdateViewHolder;\n\npublic class EntryGridAdapter extends SectionAdapter<Entry> {\n\tprivate static String TAG = EntryGridAdapter.class.getSimpleName();\n\n\tpublic static int VIEW_TYPE_ALBUM_CELL = 1;\n\tpublic static int VIEW_TYPE_ALBUM_LINE = 2;\n\tpublic static int VIEW_TYPE_SONG = 3;\n\n\tprivate ImageLoader imageLoader;\n\tprivate boolean largeAlbums;\n\tprivate boolean showArtist = false;\n\tprivate boolean showAlbum = false;\n\tprivate boolean removeFromPlaylist = false;\n\tprivate View header;\n\n\tpublic EntryGridAdapter(Context context, List<Entry> entries, ImageLoader imageLoader, boolean largeCell) {\n\t\tsuper(context, entries);\n\t\tthis.imageLoader = imageLoader;\n\t\tthis.largeAlbums = largeCell;\n\n\n\t\tString artist = null;\n\t\tfor(MusicDirectory.Entry entry: entries) {\n\t\t\tif(artist == null) {\n\t\t\t\tartist = entry.getArtist();\n\t\t\t}\n\n\t\t\tif(artist != null && !artist.equals(entry.getArtist())) {\n\t\t\t\tshowArtist = true;\n\t\t\t}\n\t\t}\n\t\tcheckable = true;\n\t}\n\n\t@Override\n\tpublic UpdateViewHolder onCreateSectionViewHolder(ViewGroup parent, int viewType) {\n\t\tUpdateView updateView = null;\n\t\tif(viewType == VIEW_TYPE_ALBUM_LINE || viewType == VIEW_TYPE_ALBUM_CELL) {\n\t\t\tupdateView = new AlbumView(context, viewType == VIEW_TYPE_ALBUM_CELL);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tupdateView = new SongView(context);\n\t\t}\n\n\t\treturn new UpdateViewHolder(updateView);\n\t}\n\n\t@Override\n\tpublic void onBindViewHolder(UpdateViewHolder holder, Entry entry, int viewType) {\n\t\tUpdateView view = holder.getUpdateView();\n\t\tif(viewType == VIEW_TYPE_ALBUM_CELL || viewType == VIEW_TYPE_ALBUM_LINE) {\n\t\t\tAlbumView albumView = (AlbumView) view;\n\t\t\talbumView.setShowArtist(showArtist);\n\t\t\talbumView.setObject(entry, imageLoader);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tSongView songView = (SongView) view;\n\t\t\tsongView.setShowAlbum(showAlbum);\n\t\t\tsongView.setObject(entry, checkable && !entry.isVideo());\n\t\t}\n\t}\n\n\tpublic UpdateViewHolder onCreateHeaderHolder(ViewGroup parent) {\n\t\treturn new UpdateViewHolder(header, false);\n\t}\n\tpublic void onBindHeaderHolder(UpdateViewHolder holder, String header, int sectionIndex) {\n\n\t}\n\n\t@Override\n\tpublic int getItemViewType(Entry entry) {\n\t\tif(entry.isDirectory()) {\n\t\t\tif (largeAlbums) {\n\t\t\t\treturn VIEW_TYPE_ALBUM_CELL;\n\t\t\t} else {\n\t\t\t\treturn VIEW_TYPE_ALBUM_LINE;\n\t\t\t}\n\t\t} else {\n\t\t\treturn VIEW_TYPE_SONG;\n\t\t}\n\t}\n\n\tpublic void setHeader(View header) {\n\t\tthis.header = header;\n\t\tthis.singleSectionHeader = true;\n\t}\n\tpublic View getHeader() {\n\t\treturn header;\n\t}\n\n\tpublic void setShowArtist(boolean showArtist) {\n\t\tthis.showArtist = showArtist;\n\t}\n\n\tpublic void setShowAlbum(boolean showAlbum) {\n\t\tthis.showAlbum = showAlbum;\n\t}\n\n\tpublic void removeAt(int index) {\n\t\tsections.get(0).remove(index);\n\t\tif(header != null) {\n\t\t\tindex++;\n\t\t}\n\t\tnotifyItemRemoved(index);\n\t}\n\n\tpublic void setRemoveFromPlaylist(boolean removeFromPlaylist) {\n\t\tthis.removeFromPlaylist = removeFromPlaylist;\n\t}\n\n\t@Override\n\tpublic void onCreateActionModeMenu(Menu menu, MenuInflater menuInflater) {\n\t\tif(Util.isOffline(context)) {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media_offline, menu);\n\t\t} else {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media, menu);\n\t\t}\n\n\t\tif(!removeFromPlaylist) {\n\t\t\tmenu.removeItem(R.id.menu_remove_playlist);\n\t\t}\n\n\t\tif(!selected.isEmpty()) {\n\t\t\tMenuItem starItem = menu.findItem(R.id.menu_star);\n\t\t\tif(starItem != null) {\n\t\t\t\tboolean isStarred = selected.get(0).isStarred();\n\t\t\t\tstarItem.setTitle(isStarred ? R.string.common_unstar : R.string.common_star);\n\t\t\t}\n\t\t}\n\t}\n}\n\n'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'\n:\npackage github.daneren2005.dsub.domain;\n\nimport android.annotation.TargetApi;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.media.MediaMetadataRetriever;\nimport android.os.Build;\nimport android.util.Log;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutput;\nimport java.io.ObjectOutputStream;\nimport java.text.Collator;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.io.File;\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Locale;\n\nimport github.daneren2005.dsub.service.DownloadService;\nimport github.daneren2005.dsub.util.Constants;\nimport github.daneren2005.dsub.util.UpdateHelper;\nimport github.daneren2005.dsub.util.Util;\n\n\npublic class MusicDirectory implements Serializable {\n\tprivate static final String TAG = MusicDirectory.class.getSimpleName();\n\n    private String name;\n\tprivate String id;\n\tprivate String parent;\n    private List<Entry> children;\n\n\tpublic MusicDirectory() {\n\t\tchildren = new ArrayList<Entry>();\n\t}\n\tpublic MusicDirectory(List<Entry> children) {\n\t\tthis.children = children;\n\t}\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n\t public String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getParent() {\n\t\treturn parent;\n\t}\n\n\tpublic void setParent(String parent) {\n\t\tthis.parent = parent;\n\t}\n\n\tpublic void addChild(Entry child) {\n\t\tif(child != null) {\n\t\t\tchildren.add(child);\n\t\t}\n\t}\n\tpublic void addChildren(List<Entry> children) {\n\t\tthis.children.addAll(children);\n\t}\n\n\tpublic void replaceChildren(List<Entry> children) {\n\t\tthis.children = children;\n\t}\n\n    public synchronized List<Entry> getChildren() {\n        return getChildren(true, true);\n    }\n\n    public synchronized List<Entry> getChildren(boolean includeDirs, boolean includeFiles) {\n        if (includeDirs && includeFiles) {\n            return children;\n        }\n\n        List<Entry> result = new ArrayList<Entry>(children.size());\n        for (Entry child : children) {\n            if (child != null && child.isDirectory() && includeDirs || !child.isDirectory() && includeFiles) {\n                result.add(child);\n            }\n        }\n        return result;\n    }\n\tpublic synchronized List<Entry> getSongs() {\n\t\tList<Entry> result = new ArrayList<Entry>();\n\t\tfor (Entry child : children) {\n\t\t\tif (child != null && !child.isDirectory() && !child.isVideo()) {\n\t\t\t\tresult.add(child);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic synchronized int getChildrenSize() {\n\t\treturn children.size();\n\t}\n\n\tpublic void shuffleChildren() {\n\t\tCollections.shuffle(this.children);\n\t}\n\n\tpublic void sortChildren(Context context, int instance) {\n\n\t\tif(ServerInfo.checkServerVersion(context, \"1.8\", instance)) {\n\t\t\tsortChildren(Util.getPreferences(context).getBoolean(Constants.PREFERENCES_KEY_CUSTOM_SORT_ENABLED, true));\n\t\t}\n\t}\n\tpublic void sortChildren(boolean byYear) {\n\t\tEntryComparator.sort(children, byYear);\n\t}\n\n\tpublic synchronized boolean updateMetadata(MusicDirectory refreshedDirectory) {\n\t\tboolean metadataUpdated = false;\n\t\tIterator<Entry> it = children.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tEntry entry = it.next();\n\t\t\tint index = refreshedDirectory.children.indexOf(entry);\n\t\t\tif(index != -1) {\n\t\t\t\tfinal Entry refreshed = refreshedDirectory.children.get(index);\n\n\t\t\t\tentry.setTitle(refreshed.getTitle());\n\t\t\t\tentry.setAlbum(refreshed.getAlbum());\n\t\t\t\tentry.setArtist(refreshed.getArtist());\n\t\t\t\tentry.setTrack(refreshed.getTrack());\n\t\t\t\tentry.setYear(refreshed.getYear());\n\t\t\t\tentry.setGenre(refreshed.getGenre());\n\t\t\t\tentry.setTranscodedContentType(refreshed.getTranscodedContentType());\n\t\t\t\tentry.setTranscodedSuffix(refreshed.getTranscodedSuffix());\n\t\t\t\tentry.setDiscNumber(refreshed.getDiscNumber());\n\t\t\t\tentry.setStarred(refreshed.isStarred());\n\t\t\t\tentry.setRating(refreshed.getRating());\n\t\t\t\tentry.setType(refreshed.getType());\n\t\t\t\tif(!Util.equals(entry.getCoverArt(), refreshed.getCoverArt())) {\n\t\t\t\t\tmetadataUpdated = true;\n\t\t\t\t\tentry.setCoverArt(refreshed.getCoverArt());\n\t\t\t\t}\n\n\t\t\t\tnew UpdateHelper.EntryInstanceUpdater(entry) {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void update(Entry found) {\n\t\t\t\t\t\tfound.setTitle(refreshed.getTitle());\n\t\t\t\t\t\tfound.setAlbum(refreshed.getAlbum());\n\t\t\t\t\t\tfound.setArtist(refreshed.getArtist());\n\t\t\t\t\t\tfound.setTrack(refreshed.getTrack());\n\t\t\t\t\t\tfound.setYear(refreshed.getYear());\n\t\t\t\t\t\tfound.setGenre(refreshed.getGenre());\n\t\t\t\t\t\tfound.setTranscodedContentType(refreshed.getTranscodedContentType());\n\t\t\t\t\t\tfound.setTranscodedSuffix(refreshed.getTranscodedSuffix());\n\t\t\t\t\t\tfound.setDiscNumber(refreshed.getDiscNumber());\n\t\t\t\t\t\tfound.setStarred(refreshed.isStarred());\n\t\t\t\t\t\tfound.setRating(refreshed.getRating());\n\t\t\t\t\t\tfound.setType(refreshed.getType());\n\t\t\t\t\t\tif(!Util.equals(found.getCoverArt(), refreshed.getCoverArt())) {\n\t\t\t\t\t\t\tfound.setCoverArt(refreshed.getCoverArt());\n\t\t\t\t\t\t\tmetadataUpdate = DownloadService.METADATA_UPDATED_COVER_ART;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.execute();\n\t\t\t}\n\t\t}\n\n\t\treturn metadataUpdated;\n\t}\n\tpublic synchronized boolean updateEntriesList(Context context, int instance, MusicDirectory refreshedDirectory) {\n\t\tboolean changed = false;\n\t\tIterator<Entry> it = children.iterator();\n\t\twhile(it.hasNext()) {\n\t\t\tEntry entry = it.next();\n\n\t\t\tif(refreshedDirectory.children.indexOf(entry) == -1) {\n\t\t\t\tit.remove();\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\n\t\tboolean resort = false;\n\t\tfor(Entry refreshed: refreshedDirectory.children) {\n\t\t\tif(!this.children.contains(refreshed)) {\n\t\t\t\tthis.children.add(refreshed);\n\t\t\t\tresort = true;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif(resort) {\n\t\t\tthis.sortChildren(context, instance);\n\t\t}\n\n\t\treturn changed;\n\t}\n\n    public static class Entry implements Serializable {\n\t\tpublic static final int TYPE_SONG = 0;\n\t\tpublic static final int TYPE_PODCAST = 1;\n\t\tpublic static final int TYPE_AUDIO_BOOK = 2;\n\n\t\tprivate String id;\n\t\tprivate String parent;\n\t\tprivate String grandParent;\n\t\tprivate String albumId;\n\t\tprivate String artistId;\n\t\tprivate boolean directory;\n\t\tprivate String title;\n\t\tprivate String album;\n\t\tprivate String artist;\n\t\tprivate Integer track;\n\t\tprivate Integer customOrder;\n\t\tprivate Integer year;\n\t\tprivate String genre;\n\t\tprivate String contentType;\n\t\tprivate String suffix;\n\t\tprivate String transcodedContentType;\n\t\tprivate String transcodedSuffix;\n\t\tprivate String coverArt;\n\t\tprivate Long size;\n\t\tprivate Integer duration;\n\t\tprivate Integer bitRate;\n\t\tprivate String path;\n\t\tprivate boolean video;\n\t\tprivate Integer discNumber;\n\t\tprivate boolean starred;\n\t\tprivate Integer rating;\n\t\tprivate Bookmark bookmark;\n\t\tprivate int type = 0;\n\t\tprivate int closeness;\n\t\tprivate transient Artist linkedArtist;\n\n\t\tpublic Entry() {\n\n\t\t}\n\t\tpublic Entry(String id) {\n\t\t\tthis.id = id;\n\t\t}\n\t\tpublic Entry(Artist artist) {\n\t\t\tthis.id = artist.getId();\n\t\t\tthis.title = artist.getName();\n\t\t\tthis.directory = true;\n\t\t\tthis.starred = artist.isStarred();\n\t\t\tthis.rating = artist.getRating();\n\t\t\tthis.linkedArtist = artist;\n\t\t}\n\n\t\t@TargetApi(Build.VERSION_CODES.GINGERBREAD_MR1)\n\t\tpublic void loadMetadata(File file) {\n\t\t\ttry {\n\t\t\t\tMediaMetadataRetriever metadata = new MediaMetadataRetriever();\n\t\t\t\tmetadata.setDataSource(file.getAbsolutePath());\n\t\t\t\tString discNumber = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DISC_NUMBER);\n\t\t\t\tif(discNumber == null) {\n\t\t\t\t\tdiscNumber = \"1/1\";\n\t\t\t\t}\n\t\t\t\tint slashIndex = discNumber.indexOf(\"/\");\n\t\t\t\tif(slashIndex > 0) {\n\t\t\t\t\tdiscNumber = discNumber.substring(0, slashIndex);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tsetDiscNumber(Integer.parseInt(discNumber));\n\t\t\t\t} catch(Exception e) {\n\t\t\t\t\tLog.w(TAG, \"Non numbers in disc field!\");\n\t\t\t\t}\n\t\t\t\tString bitrate = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_BITRATE);\n\t\t\t\tsetBitRate(Integer.parseInt((bitrate != null) ? bitrate : \"0\") / 1000);\n\t\t\t\tString length = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION);\n\t\t\t\tsetDuration(Integer.parseInt(length) / 1000);\n\t\t\t\tString artist = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);\n\t\t\t\tif(artist != null) {\n\t\t\t\t\tsetArtist(artist);\n\t\t\t\t}\n\t\t\t\tString album = metadata.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);\n\t\t\t\tif(album != null) {\n\t\t\t\t\tsetAlbum(album);\n\t\t\t\t}\n\t\t\t\tmetadata.release();\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.i(TAG, \"Device doesn't properly support MediaMetadataRetreiver\", e);\n\t\t\t}\n\t\t}\n\t\tpublic void rebaseTitleOffPath() {\n\t\t\ttry {\n\t\t\t\tString filename = getPath();\n\t\t\t\tif(filename == null) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tint index = filename.lastIndexOf('/');\n\t\t\t\tif (index != -1) {\n\t\t\t\t\tfilename = filename.substring(index + 1);\n\t\t\t\t\tif (getTrack() != null) {\n\t\t\t\t\t\tfilename = filename.replace(String.format(\"%02d \", getTrack()), \"\");\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = filename.lastIndexOf('.');\n\t\t\t\t\tif(index != -1) {\n\t\t\t\t\t\tfilename = filename.substring(0, index);\n\t\t\t\t\t}\n\n\t\t\t\t\tsetTitle(filename);\n\t\t\t\t}\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to update title based off of path\", e);\n\t\t\t}\n\t\t}\n\n        public String getId() {\n            return id;\n        }\n\n        public void setId(String id) {\n            this.id = id;\n        }\n\n        public String getParent() {\n            return parent;\n        }\n\n        public void setParent(String parent) {\n            this.parent = parent;\n        }\n\n\t\tpublic String getGrandParent() {\n            return grandParent;\n        }\n\n        public void setGrandParent(String grandParent) {\n            this.grandParent = grandParent;\n        }\n\n\t\tpublic String getAlbumId() {\n\t\t\treturn albumId;\n\t\t}\n\n\t\tpublic void setAlbumId(String albumId) {\n\t\t\tthis.albumId = albumId;\n\t\t}\n\n\t\tpublic String getArtistId() {\n\t\t\treturn artistId;\n\t\t}\n\n\t\tpublic void setArtistId(String artistId) {\n\t\t\tthis.artistId = artistId;\n\t\t}\n\n        public boolean isDirectory() {\n            return directory;\n        }\n\n        public void setDirectory(boolean directory) {\n            this.directory = directory;\n        }\n\n        public String getTitle() {\n            return title;\n        }\n\n        public void setTitle(String title) {\n            this.title = title;\n        }\n\n        public String getAlbum() {\n            return album;\n        }\n\n\t\tpublic boolean isAlbum() {\n\t\t\treturn getParent() != null || getArtist() != null;\n\t\t}\n\n\t\tpublic String getAlbumDisplay() {\n\t\t\tif(album != null && title.startsWith(\"Disc \")) {\n\t\t\t\treturn album;\n\t\t\t} else {\n\t\t\t\treturn title;\n\t\t\t}\n\t\t}\n\n        public void setAlbum(String album) {\n            this.album = album;\n        }\n\n        public String getArtist() {\n            return artist;\n        }\n\n        public void setArtist(String artist) {\n            this.artist = artist;\n        }\n\n        public Integer getTrack() {\n            return track;\n        }\n\n        public void setTrack(Integer track) {\n            this.track = track;\n        }\n\n\t\tpublic Integer getCustomOrder() {\n\t\t\treturn customOrder;\n\t\t}\n\t\tpublic void setCustomOrder(Integer customOrder) {\n\t\t\tthis.customOrder = customOrder;\n\t\t}\n\n        public Integer getYear() {\n            return year;\n        }\n\n        public void setYear(Integer year) {\n            this.year = year;\n        }\n\n        public String getGenre() {\n            return genre;\n        }\n\n        public void setGenre(String genre) {\n            this.genre = genre;\n        }\n\n        public String getContentType() {\n            return contentType;\n        }\n\n        public void setContentType(String contentType) {\n            this.contentType = contentType;\n        }\n\n        public String getSuffix() {\n            return suffix;\n        }\n\n        public void setSuffix(String suffix) {\n            this.suffix = suffix;\n        }\n\n        public String getTranscodedContentType() {\n            return transcodedContentType;\n        }\n\n        public void setTranscodedContentType(String transcodedContentType) {\n            this.transcodedContentType = transcodedContentType;\n        }\n\n        public String getTranscodedSuffix() {\n            return transcodedSuffix;\n        }\n\n        public void setTranscodedSuffix(String transcodedSuffix) {\n            this.transcodedSuffix = transcodedSuffix;\n        }\n\n        public Long getSize() {\n            return size;\n        }\n\n        public void setSize(Long size) {\n            this.size = size;\n        }\n\n        public Integer getDuration() {\n            return duration;\n        }\n\n        public void setDuration(Integer duration) {\n            this.duration = duration;\n        }\n\n        public Integer getBitRate() {\n            return bitRate;\n        }\n\n        public void setBitRate(Integer bitRate) {\n            this.bitRate = bitRate;\n        }\n\n        public String getCoverArt() {\n            return coverArt;\n        }\n\n        public void setCoverArt(String coverArt) {\n            this.coverArt = coverArt;\n        }\n\n        public String getPath() {\n            return path;\n        }\n\n        public void setPath(String path) {\n            this.path = path;\n        }\n\n        public boolean isVideo() {\n            return video;\n        }\n\n        public void setVideo(boolean video) {\n            this.video = video;\n        }\n\n\t\tpublic Integer getDiscNumber() {\n\t\t\treturn discNumber;\n\t\t}\n\n\t\tpublic void setDiscNumber(Integer discNumber) {\n\t\t\tthis.discNumber = discNumber;\n\t\t}\n\n        public boolean isStarred() {\n            return starred;\n        }\n\n        public void setStarred(boolean starred) {\n            this.starred = starred;\n\n\t\t\tif(linkedArtist != null) {\n\t\t\t\tlinkedArtist.setStarred(starred);\n\t\t\t}\n        }\n\n\t\tpublic int getRating() {\n\t\t\treturn rating == null ? 0 : rating;\n\t\t}\n\t\tpublic void setRating(Integer rating) {\n\t\t\tif(rating == null || rating == 0) {\n\t\t\t\tthis.rating = null;\n\t\t\t} else {\n\t\t\t\tthis.rating = rating;\n\t\t\t}\n\n\t\t\tif(linkedArtist != null) {\n\t\t\t\tlinkedArtist.setRating(rating);\n\t\t\t}\n\t\t}\n\n\t\tpublic Bookmark getBookmark() {\n\t\t\treturn bookmark;\n\t\t}\n\t\tpublic void setBookmark(Bookmark bookmark) {\n\t\t\tthis.bookmark = bookmark;\n\t\t}\n\n\t\tpublic int getType() {\n\t\t\treturn type;\n\t\t}\n\t\tpublic void setType(int type) {\n\t\t\tthis.type = type;\n\t\t}\n\t\tpublic boolean isSong() {\n\t\t\treturn type == TYPE_SONG;\n\t\t}\n\t\tpublic boolean isPodcast() {\n\t\t\treturn this instanceof PodcastEpisode || type == TYPE_PODCAST;\n\t\t}\n\t\tpublic boolean isAudioBook() {\n\t\t\treturn type == TYPE_AUDIO_BOOK;\n\t\t}\n\n\t\tpublic int getCloseness() {\n\t\t\treturn closeness;\n\t\t}\n\n\t\tpublic void setCloseness(int closeness) {\n\t\t\tthis.closeness = closeness;\n\t\t}\n\n\t\tpublic boolean isOnlineId(Context context) {\n\t\t\ttry {\n\t\t\t\tString cacheLocation = Util.getPreferences(context).getString(Constants.PREFERENCES_KEY_CACHE_LOCATION, null);\n\t\t\t\treturn cacheLocation == null || id == null || id.indexOf(cacheLocation) == -1;\n\t\t\t} catch(Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to check online id validity\");\n\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            Entry entry = (Entry) o;\n            return id.equals(entry.id);\n        }\n\n        @Override\n        public int hashCode() {\n            return id.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return title;\n        }\n\n        public byte[] toByteArray() throws IOException {\n\t\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\t\tObjectOutput out = null;\n\t\t\ttry {\n\t\t\t\tout = new ObjectOutputStream(bos);\n\t\t\t\tout.writeObject(this);\n\t\t\t\tout.flush();\n\t\t\t\treturn bos.toByteArray();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tbos.close();\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic static Entry fromByteArray(byte[] byteArray) throws IOException, ClassNotFoundException {\n\t\t\tByteArrayInputStream bis = new ByteArrayInputStream(byteArray);\n\t\t\tObjectInput in = null;\n\t\t\ttry {\n\t\t\t\tin = new ObjectInputStream(bis);\n\t\t\t\treturn (Entry) in.readObject();\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (in != null) {\n\t\t\t\t\t\tin.close();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException ex) {\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static class EntryComparator implements Comparator<Entry> {\n\t\tprivate boolean byYear;\n\t\tprivate Collator collator;\n\n\t\tpublic EntryComparator(boolean byYear) {\n\t\t\tthis.byYear = byYear;\n\t\t\tthis.collator = Collator.getInstance(Locale.US);\n\t\t\tthis.collator.setStrength(Collator.PRIMARY);\n\t\t}\n\n\t\tpublic int compare(Entry lhs, Entry rhs) {\n\t\t\tif(lhs.isDirectory() && !rhs.isDirectory()) {\n\t\t\t\treturn -1;\n\t\t\t} else if(!lhs.isDirectory() && rhs.isDirectory()) {\n\t\t\t\treturn 1;\n\t\t\t} else if(lhs.isDirectory() && rhs.isDirectory()) {\n\t\t\t\tif(byYear) {\n\t\t\t\t\tInteger lhsYear = lhs.getYear();\n\t\t\t\t\tInteger rhsYear = rhs.getYear();\n\t\t\t\t\tif(lhsYear != null && rhsYear != null) {\n\t\t\t\t\t\treturn lhsYear.compareTo(rhsYear);\n\t\t\t\t\t} else if(lhsYear != null) {\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t} else if(rhsYear != null) {\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn collator.compare(lhs.getAlbumDisplay(), rhs.getAlbumDisplay());\n\t\t\t}\n\n\t\t\tInteger lhsDisc = lhs.getDiscNumber();\n\t\t\tInteger rhsDisc = rhs.getDiscNumber();\n\n\t\t\tif(lhsDisc != null && rhsDisc != null) {\n\t\t\t\tif(lhsDisc < rhsDisc) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if(lhsDisc > rhsDisc) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tInteger lhsTrack = lhs.getTrack();\n\t\t\tInteger rhsTrack = rhs.getTrack();\n\t\t\tif(lhsTrack == rhsTrack) {\n\t\t\t\treturn collator.compare(lhs.getTitle(), rhs.getTitle());\n\t\t\t} else if(lhsTrack != null && rhsTrack != null) {\n\t\t\t\treturn lhsTrack.compareTo(rhsTrack);\n\t\t\t} else if(lhsTrack != null) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic static void sort(List<Entry> entries) {\n\t\t\tsort(entries, true);\n\t\t}\n\t\tpublic static void sort(List<Entry> entries, boolean byYear) {\n\t\t\ttry {\n\t\t\t\tCollections.sort(entries, new EntryComparator(byYear));\n\t\t\t} catch (Exception e) {\n\t\t\t\tLog.w(TAG, \"Failed to sort MusicDirectory\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'\n:\n\npackage github.daneren2005.dsub.adapter;\n\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport github.daneren2005.dsub.R;\nimport github.daneren2005.dsub.domain.MusicDirectory.Entry;\nimport github.daneren2005.dsub.domain.SearchResult;\nimport github.daneren2005.dsub.util.DrawableTint;\nimport github.daneren2005.dsub.util.ImageLoader;\nimport github.daneren2005.dsub.util.Util;\nimport github.daneren2005.dsub.view.AlbumView;\nimport github.daneren2005.dsub.view.ArtistView;\nimport github.daneren2005.dsub.view.BasicHeaderView;\nimport github.daneren2005.dsub.view.SongView;\nimport github.daneren2005.dsub.view.UpdateView;\n\nimport static github.daneren2005.dsub.adapter.ArtistAdapter.VIEW_TYPE_ARTIST;\nimport static github.daneren2005.dsub.adapter.EntryGridAdapter.VIEW_TYPE_ALBUM_CELL;\nimport static github.daneren2005.dsub.adapter.EntryGridAdapter.VIEW_TYPE_ALBUM_LINE;\nimport static github.daneren2005.dsub.adapter.EntryGridAdapter.VIEW_TYPE_SONG;\n\npublic class SearchAdapter extends ExpandableSectionAdapter<Serializable> {\n\tprivate ImageLoader imageLoader;\n\tprivate boolean largeAlbums;\n\n\tprivate static final int MAX_ARTISTS = 10;\n\tprivate static final int MAX_ALBUMS = 4;\n\tprivate static final int MAX_SONGS = 10;\n\n\tpublic SearchAdapter(Context context, SearchResult searchResult, ImageLoader imageLoader, boolean largeAlbums, OnItemClickedListener listener) {\n\t\tthis.imageLoader = imageLoader;\n\t\tthis.largeAlbums = largeAlbums;\n\n\t\tList<List<Serializable>> sections = new ArrayList<>();\n\t\tList<String> headers = new ArrayList<>();\n\t\tList<Integer> defaultVisible = new ArrayList<>();\n\t\tResources res = context.getResources();\n\t\tif(!searchResult.getArtists().isEmpty()) {\n\t\t\tsections.add((List<Serializable>) (List<?>) searchResult.getArtists());\n\t\t\theaders.add(res.getString(R.string.search_artists));\n\t\t\tdefaultVisible.add(MAX_ARTISTS);\n\t\t}\n\t\tif(!searchResult.getAlbums().isEmpty()) {\n\t\t\tsections.add((List<Serializable>) (List<?>) searchResult.getAlbums());\n\t\t\theaders.add(res.getString(R.string.search_albums));\n\t\t\tdefaultVisible.add(MAX_ALBUMS);\n\t\t}\n\t\tif(!searchResult.getSongs().isEmpty()) {\n\t\t\tsections.add((List<Serializable>) (List<?>) searchResult.getSongs());\n\t\t\theaders.add(res.getString(R.string.search_songs));\n\t\t\tdefaultVisible.add(MAX_SONGS);\n\t\t}\n\t\tinit(context, headers, sections, defaultVisible);\n\n\t\tthis.onItemClickedListener = listener;\n\t\tcheckable = true;\n\t}\n\n\t@Override\n\tpublic UpdateView.UpdateViewHolder onCreateSectionViewHolder(ViewGroup parent, int viewType) {\n\t\tUpdateView updateView = null;\n\t\tif(viewType == VIEW_TYPE_ALBUM_CELL || viewType == VIEW_TYPE_ALBUM_LINE) {\n\t\t\tupdateView = new AlbumView(context, viewType == VIEW_TYPE_ALBUM_CELL);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tupdateView = new SongView(context);\n\t\t} else if(viewType == VIEW_TYPE_ARTIST) {\n\t\t\tupdateView = new ArtistView(context);\n\t\t}\n\n\t\treturn new UpdateView.UpdateViewHolder(updateView);\n\t}\n\n\t@Override\n\tpublic void onBindViewHolder(UpdateView.UpdateViewHolder holder, Serializable item, int viewType) {\n\t\tUpdateView view = holder.getUpdateView();\n\t\tif(viewType == VIEW_TYPE_ALBUM_CELL || viewType == VIEW_TYPE_ALBUM_LINE) {\n\t\t\tAlbumView albumView = (AlbumView) view;\n\t\t\talbumView.setObject((Entry) item, imageLoader);\n\t\t} else if(viewType == VIEW_TYPE_SONG) {\n\t\t\tSongView songView = (SongView) view;\n\t\t\tsongView.setObject((Entry) item, true);\n\t\t} else if(viewType == VIEW_TYPE_ARTIST) {\n\t\t\tview.setObject(item);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getItemViewType(Serializable item) {\n\t\tif(item instanceof Entry) {\n\t\t\tEntry entry = (Entry) item;\n\t\t\tif (entry.isDirectory()) {\n\t\t\t\tif (largeAlbums) {\n\t\t\t\t\treturn VIEW_TYPE_ALBUM_CELL;\n\t\t\t\t} else {\n\t\t\t\t\treturn VIEW_TYPE_ALBUM_LINE;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn VIEW_TYPE_SONG;\n\t\t\t}\n\t\t} else {\n\t\t\treturn VIEW_TYPE_ARTIST;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void onCreateActionModeMenu(Menu menu, MenuInflater menuInflater) {\n\t\tif(Util.isOffline(context)) {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media_offline, menu);\n\t\t} else {\n\t\t\tmenuInflater.inflate(R.menu.multiselect_media, menu);\n\t\t}\n\n\t\tmenu.removeItem(R.id.menu_remove_playlist);\n\t}\n}\n",
        "gt": [
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/domain/MusicDirectory.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/EntryGridAdapter.java'",
            "'Subsonic/app/src/main/java/github/daneren2005/dsub/adapter/SearchAdapter.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassification.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'"
        ],
        "content": "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.codec.ThriftCodec;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftResultCode;\nimport io.airlift.drift.transport.MethodMetadata;\nimport io.airlift.drift.transport.ParameterMetadata;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerConfig;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransport;\nimport io.airlift.drift.transport.netty.server.DriftNettyServerTransportFactory;\nimport io.airlift.drift.transport.server.ServerInvokeRequest;\nimport io.airlift.drift.transport.server.ServerMethodInvoker;\nimport io.airlift.drift.transport.server.ServerTransport;\nimport org.testng.annotations.Test;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.ToIntFunction;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static com.google.common.collect.Lists.newArrayList;\nimport static io.airlift.drift.codec.metadata.ThriftType.list;\nimport static io.airlift.drift.integration.ApacheThriftTesterUtil.apacheThriftTestClients;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_OK;\nimport static io.airlift.drift.integration.ClientTestUtils.MESSAGES;\nimport static io.airlift.drift.integration.DriftNettyTesterUtil.driftNettyTestClients;\nimport static io.airlift.drift.integration.LegacyApacheThriftTesterUtil.legacyApacheThriftTestClients;\nimport static java.util.Collections.nCopies;\nimport static org.testng.Assert.assertEquals;\n\npublic class TestClientsWithDriftNettyServerTransport\n{\n    @Test\n    public void testDriftServer()\n    {\n        testDriftServer(ImmutableList.of());\n    }\n\n    @Test\n    public void testHandlersWithDriftServer()\n    {\n        TestingFilter firstFilter = new TestingFilter();\n        TestingFilter secondFilter = new TestingFilter();\n        List<MethodInvocationFilter> filters = ImmutableList.of(firstFilter, secondFilter);\n\n        int invocationCount = testDriftServer(filters);\n\n        firstFilter.assertCounts(invocationCount);\n        secondFilter.assertCounts(invocationCount);\n    }\n\n    private static int testDriftServer(List<MethodInvocationFilter> filters)\n    {\n        TestServerMethodInvoker methodInvoker = new TestServerMethodInvoker();\n\n        ImmutableList.Builder<ToIntFunction<HostAndPort>> clients = ImmutableList.builder();\n        for (boolean secure : ImmutableList.of(true, false)) {\n            for (Transport transport : Transport.values()) {\n                for (Protocol protocol : Protocol.values()) {\n                    clients.addAll(legacyApacheThriftTestClients(filters, transport, protocol, secure))\n                            .addAll(driftNettyTestClients(filters, transport, protocol, secure))\n                            .addAll(apacheThriftTestClients(filters, transport, protocol, secure));\n                }\n            }\n        }\n        int invocationCount = testDriftServer(methodInvoker, clients.build());\n\n        assertEquals(methodInvoker.getMessages(), newArrayList(concat(nCopies(invocationCount, MESSAGES))));\n\n        return invocationCount;\n    }\n\n    private static int testDriftServer(ServerMethodInvoker methodInvoker, List<ToIntFunction<HostAndPort>> clients)\n    {\n        DriftNettyServerConfig config = new DriftNettyServerConfig()\n                .setSslEnabled(true)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setKey(ClientTestUtils.getPrivateKeyFile());\n        TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n        ServerTransport serverTransport = new DriftNettyServerTransportFactory(config, testingAllocator).createServerTransport(methodInvoker);\n        try {\n            serverTransport.start();\n\n            HostAndPort address = HostAndPort.fromParts(\"localhost\", ((DriftNettyServerTransport) serverTransport).getPort());\n\n            int sum = 0;\n            for (ToIntFunction<HostAndPort> client : clients) {\n                sum += client.applyAsInt(address);\n            }\n            return sum;\n        }\n        finally {\n            serverTransport.shutdown();\n            testingAllocator.close();\n        }\n    }\n\n    private static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n    private static final MethodMetadata LOG_METHOD_METADATA = new MethodMetadata(\n            \"Log\",\n            ImmutableList.of(new ParameterMetadata(\n                    (short) 1,\n                    \"messages\",\n                    (ThriftCodec<Object>) CODEC_MANAGER.getCodec(list(CODEC_MANAGER.getCodec(DriftLogEntry.class).getType())))),\n            (ThriftCodec<Object>) (Object) CODEC_MANAGER.getCodec(DriftResultCode.class),\n            ImmutableMap.of(),\n            ImmutableMap.of(),\n            false,\n            true);\n\n    private static class TestServerMethodInvoker\n            implements ServerMethodInvoker\n    {\n        private final List<LogEntry> messages = new CopyOnWriteArrayList<>();\n\n        private List<LogEntry> getMessages()\n        {\n            return messages;\n        }\n\n        @Override\n        public Optional<MethodMetadata> getMethodMetadata(String name)\n        {\n            if (LOG_METHOD_METADATA.getName().equals(name)) {\n                return Optional.of(LOG_METHOD_METADATA);\n            }\n            return Optional.empty();\n        }\n\n        @Override\n        public ListenableFuture<Object> invoke(ServerInvokeRequest request)\n        {\n            MethodMetadata method = request.getMethod();\n            if (!LOG_METHOD_METADATA.getName().equals(method.getName())) {\n                return Futures.immediateFailedFuture(new IllegalArgumentException(\"unknown method \" + method));\n            }\n\n            Map<Short, Object> parameters = request.getParameters();\n            if (parameters.size() != 1 || !parameters.containsKey((short) 1) || !(getOnlyElement(parameters.values()) instanceof List)) {\n                return Futures.immediateFailedFuture(new IllegalArgumentException(\"invalid parameters\"));\n            }\n            for (DriftLogEntry driftLogEntry : (List<DriftLogEntry>) getOnlyElement(parameters.values())) {\n                messages.add(new LogEntry(driftLogEntry.getCategory(), driftLogEntry.getMessage()));\n            }\n\n            return Futures.immediateFuture(DRIFT_OK);\n        }\n\n        @Override\n        public void recordResult(String methodName, long startTime, ListenableFuture<Object> result)\n        {\n\n        }\n    }\n}\n\n'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassification.java'\n:\npackage io.airlift.drift.client;\n\nimport java.util.EnumSet;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.function.BiConsumer;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Collector;\n\nimport static com.google.common.base.MoreObjects.toStringHelper;\nimport static com.google.common.collect.Ordering.natural;\nimport static io.airlift.drift.client.ExceptionClassification.HostStatus.NORMAL;\nimport static java.util.Objects.requireNonNull;\nimport static java.util.stream.Collector.Characteristics.CONCURRENT;\nimport static java.util.stream.Collector.Characteristics.UNORDERED;\n\npublic final class ExceptionClassification\n{\n    public static final ExceptionClassification NORMAL_EXCEPTION = new ExceptionClassification(Optional.empty(), NORMAL);\n\n    public enum HostStatus\n    {\n        NORMAL, OVERLOADED, DOWN\n    }\n\n    private final Optional<Boolean> retry;\n    private final HostStatus hostStatus;\n\n    public ExceptionClassification(Optional<Boolean> retry, HostStatus hostStatus)\n    {\n        this.retry = requireNonNull(retry, \"retry is null\");\n        this.hostStatus = requireNonNull(hostStatus, \"hostStatus is null\");\n    }\n\n    public Optional<Boolean> isRetry()\n    {\n        return retry;\n    }\n\n    public HostStatus getHostStatus()\n    {\n        return hostStatus;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        ExceptionClassification that = (ExceptionClassification) o;\n        return Objects.equals(retry, that.retry) &&\n                hostStatus == that.hostStatus;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return Objects.hash(retry, hostStatus);\n    }\n\n    @Override\n    public String toString()\n    {\n        return toStringHelper(this)\n                .add(\"retry\", retry)\n                .add(\"hostStatus\", hostStatus)\n                .toString();\n    }\n\n    public static Collector<ExceptionClassification, ?, ExceptionClassification> mergeExceptionClassifications()\n    {\n        return new MergeExceptionClassificationsCollector();\n    }\n\n    private static class MergeExceptionClassificationsCollector\n            implements Collector<ExceptionClassification, MergeExceptionClassificationsCollector.Accumulator, ExceptionClassification>\n    {\n        @Override\n        public Supplier<Accumulator> supplier()\n        {\n            return Accumulator::new;\n        }\n\n        @Override\n        public BiConsumer<Accumulator, ExceptionClassification> accumulator()\n        {\n            return Accumulator::add;\n        }\n\n        @Override\n        public BinaryOperator<Accumulator> combiner()\n        {\n            return Accumulator::add;\n        }\n\n        @Override\n        public Function<Accumulator, ExceptionClassification> finisher()\n        {\n            return Accumulator::toExceptionClassification;\n        }\n\n        @Override\n        public Set<Characteristics> characteristics()\n        {\n            return EnumSet.of(CONCURRENT, UNORDERED);\n        }\n\n        public static class Accumulator\n        {\n            private Optional<Boolean> retry = Optional.empty();\n            private HostStatus hostStatus = NORMAL;\n\n            public void add(ExceptionClassification classification)\n            {\n                retry = mergeRetry(retry, classification.isRetry());\n                hostStatus = natural().max(hostStatus, classification.getHostStatus());\n            }\n\n            public Accumulator add(Accumulator accumulation)\n            {\n                retry = mergeRetry(retry, accumulation.retry);\n                hostStatus = natural().max(hostStatus, accumulation.hostStatus);\n                return this;\n            }\n\n            public ExceptionClassification toExceptionClassification()\n            {\n                return new ExceptionClassification(retry, hostStatus);\n            }\n\n            @SuppressWarnings(\"OptionalIsPresent\")\n            public static Optional<Boolean> mergeRetry(Optional<Boolean> oldRetry, Optional<Boolean> newRetry)\n            {\n                if (!oldRetry.isPresent()) {\n                    return newRetry;\n                }\n                if (!newRetry.isPresent()) {\n                    return oldRetry;\n                }\n                return Optional.of(oldRetry.get() && newRetry.get());\n            }\n        }\n    }\n}\n\n'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'\n:\npackage io.airlift.drift.client;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.List;\n\nimport static io.airlift.drift.client.ExceptionClassification.NORMAL_EXCEPTION;\nimport static io.airlift.drift.client.ExceptionClassification.mergeExceptionClassifications;\nimport static java.util.Objects.requireNonNull;\n\npublic interface ExceptionClassifier\n{\n    ExceptionClassifier NORMAL_RESULT = throwable -> NORMAL_EXCEPTION;\n\n    static ExceptionClassifier mergeExceptionClassifiers(Iterable<? extends ExceptionClassifier> classifiers)\n    {\n        List<ExceptionClassifier> exceptionClassifiers = ImmutableList.copyOf(requireNonNull(classifiers, \"classifiers is null\"));\n        return throwable -> exceptionClassifiers.stream()\n                .map(classifier -> classifier.classifyException(throwable))\n                .collect(mergeExceptionClassifications());\n    }\n\n    ExceptionClassification classifyException(Throwable throwable);\n}\n\n'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.net.HostAndPort;\nimport io.airlift.drift.client.DriftClientFactory;\nimport io.airlift.drift.client.DriftClientFactoryManager;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.integration.scribe.drift.DriftAsyncScribe;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftScribe;\nimport io.airlift.drift.transport.client.DriftClientConfig;\nimport io.airlift.drift.transport.netty.buffer.TestingPooledByteBufAllocator;\nimport io.airlift.drift.transport.netty.client.DriftNettyClientConfig;\nimport io.airlift.drift.transport.netty.client.DriftNettyClientModule;\nimport io.airlift.drift.transport.netty.client.DriftNettyConnectionFactoryConfig;\nimport io.airlift.drift.transport.netty.client.DriftNettyMethodInvokerFactory;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\n\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.ToIntFunction;\n\nimport static io.airlift.drift.client.ExceptionClassifier.NORMAL_RESULT;\nimport static io.airlift.drift.integration.ClientTestUtils.CODEC_MANAGER;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_MESSAGES;\nimport static io.airlift.drift.integration.ClientTestUtils.DRIFT_OK;\nimport static io.airlift.drift.integration.ClientTestUtils.HEADER_VALUE;\nimport static io.airlift.drift.integration.ClientTestUtils.logDriftClientBinder;\nimport static io.airlift.drift.transport.netty.client.DriftNettyMethodInvokerFactory.createStaticDriftNettyMethodInvokerFactory;\nimport static io.airlift.drift.transport.netty.codec.Protocol.COMPACT;\nimport static io.airlift.drift.transport.netty.codec.Transport.HEADER;\nimport static org.testng.Assert.assertEquals;\n\nfinal class DriftNettyTesterUtil\n{\n    private DriftNettyTesterUtil() {}\n\n    public static List<ToIntFunction<HostAndPort>> driftNettyTestClients(List<MethodInvocationFilter> filters, Transport transport, Protocol protocol, boolean secure)\n    {\n        return ImmutableList.of(\n                address -> logNettyDriftClient(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyStaticDriftClient(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyDriftClientAsync(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure),\n                address -> logNettyClientBinder(address, HEADER_VALUE, DRIFT_MESSAGES, filters, transport, protocol, secure));\n    }\n\n    private static int logNettyDriftClient(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<String> methodInvokerFactory = new DriftNettyMethodInvokerFactory<>(\n                        new DriftNettyConnectionFactoryConfig(),\n                        clientIdentity -> config,\n                        testingAllocator)) {\n            DriftClientFactoryManager<String> clientFactoryManager = new DriftClientFactoryManager<>(CODEC_MANAGER, methodInvokerFactory);\n            DriftClientFactory proxyFactory = clientFactoryManager.createDriftClientFactory(\"clientIdentity\", addressSelector, NORMAL_RESULT);\n\n            DriftScribe scribe = proxyFactory.createDriftClient(DriftScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyStaticDriftClient(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<?> methodInvokerFactory = createStaticDriftNettyMethodInvokerFactory(config, testingAllocator)) {\n            DriftClientFactory proxyFactory = new DriftClientFactory(CODEC_MANAGER, methodInvokerFactory, addressSelector);\n\n            DriftScribe scribe = proxyFactory.createDriftClient(DriftScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyDriftClientAsync(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n        DriftNettyClientConfig config = new DriftNettyClientConfig()\n                .setTransport(transport)\n                .setProtocol(protocol)\n                .setTrustCertificate(ClientTestUtils.getCertificateChainFile())\n                .setSslEnabled(secure);\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator();\n                DriftNettyMethodInvokerFactory<String> methodInvokerFactory = new DriftNettyMethodInvokerFactory<>(\n                        new DriftNettyConnectionFactoryConfig(),\n                        clientIdentity -> config,\n                        testingAllocator)) {\n            DriftClientFactoryManager<String> proxyFactoryManager = new DriftClientFactoryManager<>(CODEC_MANAGER, methodInvokerFactory);\n            DriftClientFactory proxyFactory = proxyFactoryManager.createDriftClientFactory(\"myFactory\", addressSelector, NORMAL_RESULT);\n\n            DriftAsyncScribe scribe = proxyFactory.createDriftClient(DriftAsyncScribe.class, Optional.empty(), filters, new DriftClientConfig()).get();\n\n            assertEquals(scribe.log(headerValue, entries).get(), DRIFT_OK);\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return 1;\n    }\n\n    private static int logNettyClientBinder(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n        if (!isValidConfiguration(transport, protocol)) {\n            return 0;\n        }\n\n        try (TestingPooledByteBufAllocator testingAllocator = new TestingPooledByteBufAllocator()) {\n            return logDriftClientBinder(address, headerValue, entries, new DriftNettyClientModule(testingAllocator), filters, transport, protocol, secure);\n        }\n    }\n\n    private static boolean isValidConfiguration(Transport transport, Protocol protocol)\n    {\n\n        return transport != HEADER || protocol != COMPACT;\n    }\n}\n",
        "gt": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassification.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/DriftNettyTesterUtil.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/TestClientsWithDriftNettyServerTransport.java'"
        ]
    },
    {
        "files": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'"
        ],
        "content": "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'\n:\n\npackage com.netflix.iceberg.types;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\npublic class TypeUtil {\n  public static Schema select(Schema schema, Set<Integer> fieldIds) {\n    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n    Preconditions.checkNotNull(fieldIds, \"Field ids cannot be null\");\n\n    Type result = visit(schema, new PruneColumns(fieldIds));\n    if (schema.asStruct() == result) {\n      return schema;\n    } else if (result != null) {\n      if (schema.getAliases() != null) {\n        return new Schema(result.asNestedType().fields(), schema.getAliases());\n      } else {\n        return new Schema(result.asNestedType().fields());\n      }\n    }\n\n    return new Schema(ImmutableList.of(), schema.getAliases());\n  }\n\n  public static Set<Integer> getProjectedIds(Schema schema) {\n    return visit(schema, new GetProjectedIds());\n  }\n\n  public static Set<Integer> getProjectedIds(Type schema) {\n    if (schema.isPrimitiveType()) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(visit(schema, new GetProjectedIds()));\n  }\n\n  public static Schema selectNot(Schema schema, Set<Integer> fieldIds) {\n    Set<Integer> projectedIds = getProjectedIds(schema);\n    projectedIds.removeAll(fieldIds);\n    return select(schema, projectedIds);\n  }\n\n  public static Schema join(Schema left, Schema right) {\n    List<Types.NestedField> joinedColumns = Lists.newArrayList();\n    joinedColumns.addAll(left.columns());\n    joinedColumns.addAll(right.columns());\n    return new Schema(joinedColumns);\n  }\n\n  public static Map<String, Integer> indexByName(Types.StructType struct) {\n    return visit(struct, new IndexByName());\n  }\n\n  public static Map<Integer, Types.NestedField> indexById(Types.StructType struct) {\n    return visit(struct, new IndexById());\n  }\n\n\n  public static Type assignFreshIds(Type type, NextID nextId) {\n    return TypeUtil.visit(type, new AssignFreshIds(nextId));\n  }\n\n\n  public static Schema assignFreshIds(Schema schema, NextID nextId) {\n    return new Schema(TypeUtil\n        .visit(schema.asStruct(), new AssignFreshIds(nextId))\n        .asNestedType()\n        .fields());\n  }\n\n\n  public static Schema reassignIds(Schema schema, Schema idSourceSchema) {\n    Types.StructType struct = visit(schema, new ReassignIds(idSourceSchema)).asStructType();\n    return new Schema(struct.fields());\n  }\n\n  public static Type find(Schema schema, Predicate<Type> predicate) {\n    return visit(schema, new FindTypeVisitor(predicate));\n  }\n\n  public static boolean isPromotionAllowed(Type from, Type.PrimitiveType to) {\n\n\n    if (from.equals(to)) {\n      return true;\n    }\n\n    switch (from.typeId()) {\n      case INTEGER:\n        return to == Types.LongType.get();\n\n      case FLOAT:\n        return to == Types.DoubleType.get();\n\n      case DECIMAL:\n        Types.DecimalType fromDecimal = (Types.DecimalType) from;\n        if (to.typeId() != Type.TypeID.DECIMAL) {\n          return false;\n        }\n\n        Types.DecimalType toDecimal = (Types.DecimalType) to;\n        return (fromDecimal.scale() == toDecimal.scale() &&\n            fromDecimal.precision() <= toDecimal.precision());\n    }\n\n    return false;\n  }\n\n\n  public interface NextID {\n    int get();\n  }\n\n  public static class SchemaVisitor<T> {\n    protected LinkedList<String> fieldNames = Lists.newLinkedList();\n    protected LinkedList<Integer> fieldIds = Lists.newLinkedList();\n\n    public T schema(Schema schema, T structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, List<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, T fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, T elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, T keyResult, T valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  public static <T> T visit(Schema schema, SchemaVisitor<T> visitor) {\n    return visitor.schema(schema, visit(schema.asStruct(), visitor));\n  }\n\n  public static <T> T visit(Type type, SchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<T> results = Lists.newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          visitor.fieldIds.push(field.fieldId());\n          visitor.fieldNames.push(field.name());\n          T result;\n          try {\n            result = visit(field.type(), visitor);\n          } finally {\n            visitor.fieldIds.pop();\n            visitor.fieldNames.pop();\n          }\n          results.add(visitor.field(field, result));\n        }\n        return visitor.struct(struct, results);\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        T elementResult;\n\n        visitor.fieldIds.push(list.elementId());\n        try {\n          elementResult = visit(list.elementType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.list(list, elementResult);\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        T keyResult;\n        T valueResult;\n\n        visitor.fieldIds.push(map.keyId());\n        try {\n          keyResult = visit(map.keyType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        visitor.fieldIds.push(map.valueId());\n        try {\n          valueResult = visit(map.valueType(), visitor);\n        } finally {\n          visitor.fieldIds.pop();\n        }\n\n        return visitor.map(map, keyResult, valueResult);\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  public static class CustomOrderSchemaVisitor<T> {\n    public T schema(Schema schema, Supplier<T> structResult) {\n      return null;\n    }\n\n    public T struct(Types.StructType struct, Iterable<T> fieldResults) {\n      return null;\n    }\n\n    public T field(Types.NestedField field, Supplier<T> fieldResult) {\n      return null;\n    }\n\n    public T list(Types.ListType list, Supplier<T> elementResult) {\n      return null;\n    }\n\n    public T map(Types.MapType map, Supplier<T> keyResult, Supplier<T> valueResult) {\n      return null;\n    }\n\n    public T primitive(Type.PrimitiveType primitive) {\n      return null;\n    }\n  }\n\n  private static class VisitFuture<T> implements Supplier<T> {\n    private final Type type;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFuture(Type type, CustomOrderSchemaVisitor<T> visitor) {\n      this.type = type;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visit(type, visitor);\n    }\n  }\n\n  private static class VisitFieldFuture<T> implements Supplier<T> {\n    private final Types.NestedField field;\n    private final CustomOrderSchemaVisitor<T> visitor;\n\n    private VisitFieldFuture(Types.NestedField field, CustomOrderSchemaVisitor<T> visitor) {\n      this.field = field;\n      this.visitor = visitor;\n    }\n\n    @Override\n    public T get() {\n      return visitor.field(field, new VisitFuture<>(field.type(), visitor));\n    }\n  }\n\n  public static <T> T visit(Schema schema, CustomOrderSchemaVisitor<T> visitor) {\n    return visitor.schema(schema, new VisitFuture<>(schema.asStruct(), visitor));\n  }\n\n\n  public static <T> T visit(Type type, CustomOrderSchemaVisitor<T> visitor) {\n    switch (type.typeId()) {\n      case STRUCT:\n        Types.StructType struct = type.asNestedType().asStructType();\n        List<VisitFieldFuture<T>> results = Lists\n            .newArrayListWithExpectedSize(struct.fields().size());\n        for (Types.NestedField field : struct.fields()) {\n          results.add(\n              new VisitFieldFuture<>(field, visitor));\n        }\n\n        return visitor.struct(struct, Iterables.transform(results, VisitFieldFuture::get));\n\n      case LIST:\n        Types.ListType list = type.asNestedType().asListType();\n        return visitor.list(list, new VisitFuture<>(list.elementType(), visitor));\n\n      case MAP:\n        Types.MapType map = type.asNestedType().asMapType();\n        return visitor.map(map,\n            new VisitFuture<>(map.keyType(), visitor),\n            new VisitFuture<>(map.valueType(), visitor));\n\n      default:\n        return visitor.primitive(type.asPrimitiveType());\n    }\n  }\n\n  static int decimalMaxPrecision(int numBytes) {\n    Preconditions.checkArgument(numBytes >= 0 && numBytes < 24,\n        \"Unsupported decimal length: \" + numBytes);\n    return MAX_PRECISION[numBytes];\n  }\n\n  public static int decimalRequriedBytes(int precision) {\n    Preconditions.checkArgument(precision >= 0 && precision < 40,\n        \"Unsupported decimal precision: \" + precision);\n    return REQUIRED_LENGTH[precision];\n  }\n\n  private static int[] MAX_PRECISION = new int[24];\n  private static int[] REQUIRED_LENGTH = new int[40];\n\n  static {\n\n    for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n      MAX_PRECISION[len] = (int) Math.floor(Math.log10(Math.pow(2, 8*len - 1) - 1));\n    }\n\n\n    for (int precision = 0; precision < REQUIRED_LENGTH.length; precision += 1) {\n      REQUIRED_LENGTH[precision] = -1;\n      for (int len = 0; len < MAX_PRECISION.length; len += 1) {\n\n        if (precision <= MAX_PRECISION[len]) {\n          REQUIRED_LENGTH[precision] = len;\n          break;\n        }\n      }\n      if (REQUIRED_LENGTH[precision] < 0) {\n        throw new IllegalStateException(\n            \"Could not find required length for precision \" + precision);\n      }\n    }\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.PartitionField;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.StructLike;\nimport com.netflix.iceberg.transforms.Transform;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.Decimal;\nimport org.apache.spark.unsafe.types.UTF8String;\nimport java.lang.reflect.Array;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\nclass PartitionKey implements StructLike {\n\n  private final PartitionSpec spec;\n  private final int size;\n  private final Object[] partitionTuple;\n  private final Transform[] transforms;\n  private final Accessor<InternalRow>[] accessors;\n\n  @SuppressWarnings(\"unchecked\")\n  PartitionKey(PartitionSpec spec) {\n    this.spec = spec;\n\n    List<PartitionField> fields = spec.fields();\n    this.size = fields.size();\n    this.partitionTuple = new Object[size];\n    this.transforms = new Transform[size];\n    this.accessors = (Accessor<InternalRow>[]) Array.newInstance(Accessor.class, size);\n\n    Schema schema = spec.schema();\n    Map<Integer, Accessor<InternalRow>> accessors = buildAccessors(schema);\n    for (int i = 0; i < size; i += 1) {\n      PartitionField field = fields.get(i);\n      Accessor<InternalRow> accessor = accessors.get(field.sourceId());\n      if (accessor == null) {\n        throw new RuntimeException(\n            \"Cannot build accessor for field: \" + schema.findField(field.sourceId()));\n      }\n      this.accessors[i] = accessor;\n      this.transforms[i] = field.transform();\n    }\n  }\n\n  private PartitionKey(PartitionKey toCopy) {\n    this.spec = toCopy.spec;\n    this.size = toCopy.size;\n    this.partitionTuple = new Object[toCopy.partitionTuple.length];\n    this.transforms = toCopy.transforms;\n    this.accessors = toCopy.accessors;\n\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      this.partitionTuple[i] = defensiveCopyIfNeeded(toCopy.partitionTuple[i]);\n    }\n  }\n\n  private Object defensiveCopyIfNeeded(Object obj) {\n    if (obj instanceof UTF8String) {\n\n      byte[] bytes = ((UTF8String) obj).getBytes();\n      return UTF8String.fromBytes(Arrays.copyOf(bytes, bytes.length));\n    }\n    return obj;\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"[\");\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      if (i > 0) {\n        sb.append(\", \");\n      }\n      sb.append(partitionTuple[i]);\n    }\n    sb.append(\"]\");\n    return sb.toString();\n  }\n\n  PartitionKey copy() {\n    return new PartitionKey(this);\n  }\n\n  String toPath() {\n    return spec.partitionToPath(this);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  void partition(InternalRow row) {\n    for (int i = 0; i < partitionTuple.length; i += 1) {\n      Transform<Object, Object> transform = transforms[i];\n      partitionTuple[i] = transform.apply(accessors[i].get(row));\n    }\n  }\n\n  @Override\n  public int size() {\n    return size;\n  }\n\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public <T> T get(int pos, Class<T> javaClass) {\n    return javaClass.cast(partitionTuple[pos]);\n  }\n\n  @Override\n  public <T> void set(int pos, T value) {\n    partitionTuple[pos] = value;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    PartitionKey that = (PartitionKey) o;\n    return Arrays.equals(partitionTuple, that.partitionTuple);\n  }\n\n  @Override\n  public int hashCode() {\n    return Arrays.hashCode(partitionTuple);\n  }\n\n  private interface Accessor<T> {\n    Object get(T container);\n  }\n\n  private static Map<Integer, Accessor<InternalRow>> buildAccessors(Schema schema) {\n    return TypeUtil.visit(schema, new BuildPositionAccessors());\n  }\n\n  private static Accessor<InternalRow> newAccessor(int p, Type type) {\n    switch (type.typeId()) {\n      case STRING:\n        return new StringAccessor(p, convert(type));\n      case DECIMAL:\n        return new DecimalAccessor(p, convert(type));\n      default:\n        return new PositionAccessor(p, convert(type));\n    }\n  }\n\n  private static Accessor<InternalRow> newAccessor(int p, boolean isOptional, Types.StructType type,\n                                                   Accessor<InternalRow> accessor) {\n    int size = type.fields().size();\n    if (isOptional) {\n\n      return new WrappedPositionAccessor(p, size, accessor);\n    } else if (accessor instanceof PositionAccessor) {\n      return new Position2Accessor(p, size, (PositionAccessor) accessor);\n    } else if (accessor instanceof Position2Accessor) {\n      return new Position3Accessor(p, size, (Position2Accessor) accessor);\n    } else {\n      return new WrappedPositionAccessor(p, size, accessor);\n    }\n  }\n\n  private static class BuildPositionAccessors\n      extends TypeUtil.SchemaVisitor<Map<Integer, Accessor<InternalRow>>> {\n    @Override\n    public Map<Integer, Accessor<InternalRow>> schema(\n        Schema schema, Map<Integer, Accessor<InternalRow>> structResult) {\n      return structResult;\n    }\n\n    @Override\n    public Map<Integer, Accessor<InternalRow>> struct(\n        Types.StructType struct, List<Map<Integer, Accessor<InternalRow>>> fieldResults) {\n      Map<Integer, Accessor<InternalRow>> accessors = Maps.newHashMap();\n      List<Types.NestedField> fields = struct.fields();\n      for (int i = 0; i < fieldResults.size(); i += 1) {\n        Types.NestedField field = fields.get(i);\n        Map<Integer, Accessor<InternalRow>> result = fieldResults.get(i);\n        if (result != null) {\n          for (Map.Entry<Integer, Accessor<InternalRow>> entry : result.entrySet()) {\n            accessors.put(entry.getKey(), newAccessor(i, field.isOptional(),\n                field.type().asNestedType().asStructType(), entry.getValue()));\n          }\n        } else {\n          accessors.put(field.fieldId(), newAccessor(i, field.type()));\n        }\n      }\n\n      if (accessors.isEmpty()) {\n        return null;\n      }\n\n      return accessors;\n    }\n\n    @Override\n    public Map<Integer, Accessor<InternalRow>> field(\n        Types.NestedField field, Map<Integer, Accessor<InternalRow>> fieldResult) {\n      return fieldResult;\n    }\n  }\n\n  private static class PositionAccessor implements Accessor<InternalRow> {\n    protected final DataType type;\n    protected int p;\n\n    private PositionAccessor(int p, DataType type) {\n      this.p = p;\n      this.type = type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return row.get(p, type);\n    }\n  }\n\n  private static class StringAccessor extends PositionAccessor {\n    private StringAccessor(int p, DataType type) {\n      super(p, type);\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return row.get(p, type).toString();\n    }\n  }\n\n  private static class DecimalAccessor extends PositionAccessor {\n    private DecimalAccessor(int p, DataType type) {\n      super(p, type);\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      if (row.isNullAt(p)) {\n        return null;\n      }\n      return ((Decimal) row.get(p, type)).toJavaBigDecimal();\n    }\n  }\n\n  private static class Position2Accessor implements Accessor<InternalRow> {\n    private final int p0;\n    private final int size0;\n    private final int p1;\n    private final DataType type;\n\n    private Position2Accessor(int p, int size, PositionAccessor wrapped) {\n      this.p0 = p;\n      this.size0 = size;\n      this.p1 = wrapped.p;\n      this.type = wrapped.type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      return row.getStruct(p0, size0).get(p1, type);\n    }\n  }\n\n  private static class Position3Accessor implements Accessor<InternalRow> {\n    private final int p0;\n    private final int size0;\n    private final int p1;\n    private final int size1;\n    private final int p2;\n    private final DataType type;\n\n    private Position3Accessor(int p, int size, Position2Accessor wrapped) {\n      this.p0 = p;\n      this.size0 = size;\n      this.p1 = wrapped.p0;\n      this.size1 = wrapped.size0;\n      this.p2 = wrapped.p1;\n      this.type = wrapped.type;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      return row.getStruct(p0, size0).getStruct(p1, size1).get(p2, type);\n    }\n  }\n\n  private static class WrappedPositionAccessor implements Accessor<InternalRow> {\n    private final int p;\n    private final int size;\n    private final Accessor<InternalRow> accessor;\n\n    private WrappedPositionAccessor(int p, int size, Accessor<InternalRow> accessor) {\n      this.p = p;\n      this.size = size;\n      this.accessor = accessor;\n    }\n\n    @Override\n    public Object get(InternalRow row) {\n      InternalRow inner = row.getStruct(p, size);\n      if (inner != null) {\n        return accessor.get(inner);\n      }\n      return null;\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/types/TypeUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/PartitionKey.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-idl-generator/src/main/java/io/airlift/drift/idl/generator/ThriftIdlGenerator.java'",
            "'drift/drift-codec/src/test/java/io/airlift/drift/codec/metadata/TestToString.java'",
            "'drift/drift-idl-generator/src/main/java/io/airlift/drift/idl/generator/ThriftIdlRenderer.java'"
        ],
        "content": "'drift/drift-idl-generator/src/main/java/io/airlift/drift/idl/generator/ThriftIdlGenerator.java'\n:\npackage io.airlift.drift.idl.generator;\n\nimport com.google.common.base.VerifyException;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\nimport io.airlift.drift.annotations.ThriftService;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.codec.ThriftProtocolType;\nimport io.airlift.drift.codec.metadata.FieldKind;\nimport io.airlift.drift.codec.metadata.MetadataErrorException;\nimport io.airlift.drift.codec.metadata.MetadataErrors.Monitor;\nimport io.airlift.drift.codec.metadata.MetadataWarningException;\nimport io.airlift.drift.codec.metadata.ThriftCatalog;\nimport io.airlift.drift.codec.metadata.ThriftFieldMetadata;\nimport io.airlift.drift.codec.metadata.ThriftMethodMetadata;\nimport io.airlift.drift.codec.metadata.ThriftMethodMetadata.ExceptionInfo;\nimport io.airlift.drift.codec.metadata.ThriftServiceMetadata;\nimport io.airlift.drift.codec.metadata.ThriftStructMetadata;\nimport io.airlift.drift.codec.metadata.ThriftType;\nimport io.airlift.drift.codec.metadata.ThriftTypeReference;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\nimport static com.google.common.base.MoreObjects.firstNonNull;\nimport static com.google.common.io.Files.getNameWithoutExtension;\nimport static io.airlift.drift.codec.metadata.ReflectionHelper.getEffectiveClassAnnotations;\nimport static io.airlift.drift.idl.generator.ThriftIdlRenderer.renderThriftIdl;\nimport static java.lang.String.format;\nimport static java.util.Objects.requireNonNull;\n\npublic class ThriftIdlGenerator\n{\n    private static final Set<ThriftType> BUILT_IN_TYPES = ImmutableSet.<ThriftType>builder()\n            .add(ThriftType.BOOL)\n            .add(ThriftType.BYTE)\n            .add(ThriftType.I16)\n            .add(ThriftType.I32)\n            .add(ThriftType.I64)\n            .add(ThriftType.DOUBLE)\n            .add(ThriftType.STRING)\n            .add(ThriftType.BINARY)\n            .add(new ThriftType(ThriftType.BOOL, Boolean.class))\n            .add(new ThriftType(ThriftType.BYTE, Byte.class))\n            .add(new ThriftType(ThriftType.I16, Short.class))\n            .add(new ThriftType(ThriftType.I32, Integer.class))\n            .add(new ThriftType(ThriftType.I64, Long.class))\n            .add(new ThriftType(ThriftType.DOUBLE, Double.class))\n            .add(new ThriftType(ThriftType.STRING, String.class))\n            .add(new ThriftType(ThriftType.BINARY, byte[].class))\n            .build();\n\n    private final ClassLoader classLoader;\n    private final Consumer<String> verboseLogger;\n    private final ThriftCodecManager codecManager;\n    private final String defaultPackage;\n    private final Map<Object, String> includes = new HashMap<>();\n    private final Set<ThriftType> usedIncludedTypes = new HashSet<>();\n    private final Map<String, String> namespaces;\n\n    private Set<ThriftType> knownTypes = new HashSet<>(BUILT_IN_TYPES);\n    private ThriftTypeRenderer typeRenderer = new ThriftTypeRenderer(ImmutableMap.of());\n    private List<ThriftType> thriftTypes = new CopyOnWriteArrayList<>();\n    private List<ThriftServiceMetadata> thriftServices = new CopyOnWriteArrayList<>();\n    private boolean recursive;\n\n    public ThriftIdlGenerator(ThriftIdlGeneratorConfig config)\n    {\n        this(config, firstNonNull(Thread.currentThread().getContextClassLoader(), ClassLoader.getSystemClassLoader()));\n    }\n\n    public ThriftIdlGenerator(ThriftIdlGeneratorConfig config, ClassLoader classLoader)\n    {\n        this.classLoader = requireNonNull(classLoader, \"classLoader is null\");\n\n        Monitor monitor = createMonitor(config.getErrorLogger(), config.getWarningLogger());\n        this.codecManager = new ThriftCodecManager(new ThriftCatalog(monitor));\n\n        this.verboseLogger = config.getVerboseLogger();\n        String defaultPackage = config.getDefaultPackage();\n\n        if (defaultPackage.isEmpty()) {\n            this.defaultPackage = \"\";\n        }\n        else {\n            this.defaultPackage = defaultPackage + \".\";\n        }\n\n        Map<String, String> paramIncludeMap = config.getIncludes();\n        for (Map.Entry<String, String> entry : paramIncludeMap.entrySet()) {\n            Class<?> clazz = load(entry.getKey());\n            if (clazz == null) {\n                continue;\n            }\n\n            Object result = convertToThrift(clazz);\n            this.includes.put(result, entry.getValue());\n        }\n\n        this.namespaces = config.getNamespaces();\n        this.recursive = config.isRecursive();\n    }\n\n    public String generate(Iterable<String> inputs)\n    {\n        for (String className : inputs) {\n            Object result = convertToThrift(load(className));\n            if (result instanceof ThriftType) {\n                thriftTypes.add((ThriftType) result);\n            }\n            else {\n                thriftServices.add((ThriftServiceMetadata) result);\n            }\n\n            includes.remove(result);\n        }\n\n        if (!verify()) {\n            throw new ThriftIdlGeneratorException(\"Errors found during verification.\");\n        }\n\n        return generate();\n    }\n\n    private String getFullClassName(String className)\n    {\n        if (className.indexOf('.') == -1) {\n            return defaultPackage + className;\n        }\n        return className;\n    }\n\n    @SuppressWarnings(\"NonShortCircuitBooleanExpression\")\n    @SuppressFBWarnings(\"NS_DANGEROUS_NON_SHORT_CIRCUIT\")\n    private boolean verify()\n    {\n        if (recursive) {\n\n\n\n            while (true) {\n                int size = thriftTypes.size();\n                for (ThriftType type : thriftTypes) {\n                    verifyStruct(type, true);\n                }\n                if (size == thriftTypes.size()) {\n                    break;\n                }\n            }\n\n            while (true) {\n                int size = thriftServices.size();\n                for (ThriftServiceMetadata service : thriftServices) {\n                    verifyService(service, true);\n                }\n                if (size == thriftServices.size()) {\n                    break;\n                }\n            }\n\n            recursive = false;\n            usedIncludedTypes.clear();\n            knownTypes = new HashSet<>(BUILT_IN_TYPES);\n        }\n        return verifyTypes() & verifyServices();\n    }\n\n\n\n    private boolean verifyTypes()\n    {\n        SuccessAndResult<ThriftType> output = topologicalSort(thriftTypes, type -> {\n            ThriftProtocolType proto = type.getProtocolType();\n            if (proto == ThriftProtocolType.ENUM || proto == ThriftProtocolType.STRUCT) {\n                return verifyStruct(type, true);\n            }\n            throw new VerifyException(\"Top-level non-enum and non-struct?\");\n        });\n        if (output.isSuccess()) {\n            thriftTypes = output.getResult();\n            return true;\n        }\n        for (ThriftType type : output.getResult()) {\n\n            verifyStruct(type, false);\n        }\n        return false;\n    }\n\n    private boolean verifyServices()\n    {\n        SuccessAndResult<ThriftServiceMetadata> output = topologicalSort(thriftServices, metadata -> verifyService(metadata, true));\n        if (output.isSuccess()) {\n            thriftServices = output.getResult();\n            return true;\n        }\n        for (ThriftServiceMetadata s : output.getResult()) {\n\n            verifyService(s, false);\n        }\n        return false;\n    }\n\n    private static class SuccessAndResult<T>\n    {\n        private final boolean success;\n        private final List<T> result;\n\n        SuccessAndResult(boolean success, List<T> result)\n        {\n            this.success = success;\n            this.result = ImmutableList.copyOf(result);\n        }\n\n        public boolean isSuccess()\n        {\n            return success;\n        }\n\n        public List<T> getResult()\n        {\n            return result;\n        }\n    }\n\n    private static <T> SuccessAndResult<T> topologicalSort(List<T> list, Predicate<T> isKnown)\n    {\n        List<T> remaining = list;\n        List<T> newList = new ArrayList<>();\n        int prevSize = 0;\n        while (prevSize != remaining.size()) {\n            prevSize = remaining.size();\n            List<T> bad = new ArrayList<>();\n            for (T value : remaining) {\n                if (isKnown.test(value)) {\n                    newList.add(value);\n                }\n                else {\n                    bad.add(value);\n                }\n            }\n            remaining = bad;\n        }\n        if (prevSize == 0) {\n            return new SuccessAndResult<>(true, newList);\n        }\n        return new SuccessAndResult<>(false, remaining);\n    }\n\n    private boolean verifyService(ThriftServiceMetadata service, boolean quiet)\n    {\n        boolean ok = true;\n\n        for (Map.Entry<String, ThriftMethodMetadata> method : service.getMethods().entrySet()) {\n            for (ThriftFieldMetadata field : method.getValue().getParameters()) {\n                if (!verifyField(field.getThriftType())) {\n                    ok = false;\n                    if (!quiet) {\n                        throw new ThriftIdlGeneratorException(format(\"Unknown argument type %s in %s.%s\", typeName(field.getThriftType()), service.getName(), method.getKey()));\n                    }\n                }\n            }\n\n            for (ExceptionInfo exceptionInfo : method.getValue().getExceptions().values()) {\n                ThriftType exception = exceptionInfo.getThriftType();\n                if (!verifyField(exception)) {\n                    ok = false;\n                    if (!quiet) {\n                        throw new ThriftIdlGeneratorException(format(\"Unknown exception type %s in %s.%s\", typeName(exception), service.getName(), method.getKey()));\n                    }\n                }\n            }\n\n            if (!method.getValue().getReturnType().equals(ThriftType.VOID) && !verifyField(method.getValue().getReturnType())) {\n                ok = false;\n                if (!quiet) {\n                    throw new ThriftIdlGeneratorException(format(\"Unknown return type %s in %s.%s\", typeName(method.getValue().getReturnType()), service.getName(), method.getKey()));\n                }\n            }\n        }\n\n        return ok;\n    }\n\n    private boolean verifyElementType(ThriftTypeReference type)\n    {\n        if (!recursive && type.isRecursive()) {\n            return true;\n        }\n        return verifyField(type.get());\n    }\n\n    @SuppressWarnings(\"NonShortCircuitBooleanExpression\")\n    @SuppressFBWarnings(\"NS_DANGEROUS_NON_SHORT_CIRCUIT\")\n    private boolean verifyField(ThriftType type)\n    {\n        ThriftProtocolType proto = type.getProtocolType();\n        if (proto == ThriftProtocolType.SET || proto == ThriftProtocolType.LIST) {\n            return verifyElementType(type.getValueTypeReference());\n        }\n        if (proto == ThriftProtocolType.MAP) {\n            return verifyElementType(type.getKeyTypeReference()) & verifyElementType(type.getValueTypeReference());\n        }\n\n        if (knownTypes.contains(type)) {\n            return true;\n        }\n\n        if (includes.containsKey(type)) {\n            usedIncludedTypes.add(type);\n            return true;\n        }\n\n        if (recursive) {\n\n            thriftTypes.add(type);\n            return verifyStruct(type, true);\n        }\n        return false;\n    }\n\n    private boolean verifyStruct(ThriftType type, boolean quiet)\n    {\n        if (type.getProtocolType() == ThriftProtocolType.ENUM) {\n            knownTypes.add(type);\n            return true;\n        }\n        ThriftStructMetadata metadata = type.getStructMetadata();\n        boolean ok = true;\n\n        knownTypes.add(type);\n\n        for (ThriftFieldMetadata fieldMetadata : metadata.getFields(FieldKind.THRIFT_FIELD)) {\n            if (!recursive && fieldMetadata.isTypeReferenceRecursive()) {\n                continue;\n            }\n\n            boolean fieldOk = verifyField(fieldMetadata.getThriftType());\n            if (!fieldOk) {\n                ok = false;\n                if (!quiet) {\n                    throw new ThriftIdlGeneratorException(format(\"Unknown type %s in %s.%s\", typeName(fieldMetadata.getThriftType()), metadata.getStructName(), fieldMetadata.getName()));\n                }\n            }\n        }\n\n        if (!ok) {\n            knownTypes.remove(type);\n        }\n        return ok;\n    }\n\n    private Class<?> load(String className)\n    {\n        className = getFullClassName(className);\n        try {\n            return classLoader.loadClass(className);\n        }\n        catch (ClassNotFoundException e) {\n            throw new ThriftIdlGeneratorException(\"Class not found: \" + className);\n        }\n    }\n\n    private Object convertToThrift(Class<?> clazz)\n    {\n        try {\n            return getThriftType(clazz);\n        }\n        catch (MetadataErrorException e) {\n            throw new ThriftIdlGeneratorException(e);\n        }\n    }\n\n    private Object getThriftType(Class<?> clazz)\n    {\n        Set<ThriftService> serviceAnnotations = getEffectiveClassAnnotations(clazz, ThriftService.class);\n        if (serviceAnnotations.isEmpty()) {\n            ThriftType thriftType = codecManager.getCatalog().getThriftType(clazz);\n            verboseLogger.accept(\"Found Thrift type: \" + typeName(thriftType));\n            return thriftType;\n        }\n\n        ThriftServiceMetadata serviceMetadata = new ThriftServiceMetadata(clazz, codecManager.getCatalog());\n        verboseLogger.accept(\"Found Thrift service: \" + clazz.getSimpleName());\n        return serviceMetadata;\n    }\n\n    private String generate()\n    {\n        ImmutableMap.Builder<ThriftType, String> typesBuilder = ImmutableMap.builder();\n        ImmutableSet.Builder<String> includesBuilder = ImmutableSet.builder();\n        for (ThriftType type : usedIncludedTypes) {\n            String filename = includes.get(type);\n            includesBuilder.add(filename);\n            typesBuilder.put(type, getNameWithoutExtension(filename));\n        }\n        typeRenderer = new ThriftTypeRenderer(typesBuilder.build());\n        return renderThriftIdl(namespaces, includesBuilder.build(), thriftTypes, thriftServices, typeRenderer);\n    }\n\n    private String typeName(ThriftType type)\n    {\n        return typeRenderer.toString(type);\n    }\n\n    private static Monitor createMonitor(Consumer<String> errorLogger, Consumer<String> warningLogger)\n    {\n        return new Monitor()\n        {\n            @Override\n            public void onError(MetadataErrorException e)\n            {\n                errorLogger.accept(e.getMessage());\n            }\n\n            @Override\n            public void onWarning(MetadataWarningException e)\n            {\n                warningLogger.accept(e.getMessage());\n            }\n        };\n    }\n}\n\n'drift/drift-codec/src/test/java/io/airlift/drift/codec/metadata/TestToString.java'\n:\npackage io.airlift.drift.codec.metadata;\n\nimport io.airlift.drift.codec.BonkBuilder;\nimport io.airlift.drift.codec.OneOfEverything;\nimport io.airlift.drift.codec.UnionBean;\nimport io.airlift.drift.codec.recursion.CoRecursive;\nimport io.airlift.drift.codec.recursion.CoRecursiveTree;\nimport org.testng.annotations.Test;\n\nimport static org.testng.Assert.assertNotNull;\n\npublic class TestToString\n{\n    @Test\n    public void testToString()\n    {\n        assertToString(BonkBuilder.class);\n        assertToString(UnionBean.class);\n        assertToString(OneOfEverything.class);\n        assertToString(CoRecursive.class);\n        assertToString(CoRecursiveTree.class);\n    }\n\n    private static void assertToString(Class<?> clazz)\n    {\n        ThriftType type = new ThriftCatalog().getThriftType(clazz);\n        assertNotNull(type.toString());\n        assertNotNull(type.getStructMetadata().toString());\n        for (ThriftFieldMetadata fieldMetadata : type.getStructMetadata().getFields()) {\n            assertNotNull(fieldMetadata.toString());\n        }\n    }\n}\n\n'drift/drift-idl-generator/src/main/java/io/airlift/drift/idl/generator/ThriftIdlRenderer.java'\n:\npackage io.airlift.drift.idl.generator;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.ImmutableList;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\nimport io.airlift.drift.annotations.ThriftField.Requiredness;\nimport io.airlift.drift.codec.ThriftProtocolType;\nimport io.airlift.drift.codec.metadata.ThriftEnumMetadata;\nimport io.airlift.drift.codec.metadata.ThriftFieldMetadata;\nimport io.airlift.drift.codec.metadata.ThriftMethodMetadata;\nimport io.airlift.drift.codec.metadata.ThriftServiceMetadata;\nimport io.airlift.drift.codec.metadata.ThriftStructMetadata;\nimport io.airlift.drift.codec.metadata.ThriftType;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\n\nimport static com.google.common.base.Strings.emptyToNull;\nimport static com.google.common.collect.Streams.mapWithIndex;\nimport static java.lang.String.format;\nimport static java.util.Objects.requireNonNull;\nimport static java.util.stream.Collectors.joining;\nimport static java.util.stream.Collectors.toList;\n\n@SuppressFBWarnings(\"VA_FORMAT_STRING_USES_NEWLINE\")\npublic final class ThriftIdlRenderer\n{\n    private final ThriftTypeRenderer typeRenderer;\n\n    private ThriftIdlRenderer(ThriftTypeRenderer typeRenderer)\n    {\n        this.typeRenderer = requireNonNull(typeRenderer, \"typeRenderer is null\");\n    }\n\n    public static String renderThriftIdl(\n            Map<String, String> namespaces,\n            Set<String> includes,\n            List<ThriftType> thriftTypes,\n            List<ThriftServiceMetadata> services,\n            ThriftTypeRenderer typeRenderer)\n    {\n        List<ThriftEnumMetadata<?>> enums = thriftTypes.stream()\n                .filter(type -> type.getProtocolType() == ThriftProtocolType.ENUM)\n                .map(ThriftType::getEnumMetadata)\n                .collect(toList());\n\n        List<ThriftStructMetadata> structs = thriftTypes.stream()\n                .filter(type -> type.getProtocolType() == ThriftProtocolType.STRUCT)\n                .map(ThriftType::getStructMetadata)\n                .collect(toList());\n\n        return new ThriftIdlRenderer(typeRenderer)\n                .render(namespaces, includes, enums, structs, services);\n    }\n\n    private String render(\n            Map<String, String> namespaces,\n            Set<String> includes,\n            List<ThriftEnumMetadata<?>> enums,\n            List<ThriftStructMetadata> structs,\n            List<ThriftServiceMetadata> services)\n    {\n        return Joiner.on(\"\\n\").skipNulls().join(\n                renderNamespaces(namespaces),\n                renderIncludes(includes),\n                renderEnums(enums),\n                renderStructs(structs),\n                renderServices(services));\n    }\n\n    private static String renderNamespaces(Map<String, String> namespaces)\n    {\n        if (namespaces.isEmpty()) {\n            return null;\n        }\n        return namespaces.entrySet().stream()\n                .map(entry -> format(\"namespace %s %s\", entry.getKey(), entry.getValue()))\n                .collect(joining(\"\\n\")) + \"\\n\";\n    }\n\n    private static String renderIncludes(Set<String> includes)\n    {\n        if (includes.isEmpty()) {\n            return null;\n        }\n        return includes.stream()\n                .map(include -> format(\"include \\\"%s\\\"\", include))\n                .collect(joining(\"\\n\")) + \"\\n\";\n    }\n\n    private static String renderEnums(List<ThriftEnumMetadata<?>> enums)\n    {\n        return emptyToNull(enums.stream()\n                .map(ThriftIdlRenderer::renderEnum)\n                .collect(joining(\"\\n\")));\n    }\n\n    private static String renderEnum(ThriftEnumMetadata<?> metadata)\n    {\n        return documentation(metadata.getDocumentation(), \"\") +\n                format(\"enum %s {\\n%s}\\n\", metadata.getEnumName(), renderEnumElements(metadata));\n    }\n\n    private static <T extends Enum<T>> String renderEnumElements(ThriftEnumMetadata<T> metadata)\n    {\n        if (metadata.getElementsDocumentation().values().stream().allMatch(Collection::isEmpty) &&\n                (metadata.getByEnumConstant() == null)) {\n            return \"  \" + metadata.getElementsDocumentation().keySet().stream()\n                    .map(Enum::name)\n                    .collect(joining(\", \")) + \"\\n\";\n        }\n\n        LineSeparator separator = new LineSeparator();\n        StringBuilder builder = new StringBuilder();\n        for (Entry<T, ImmutableList<String>> entry : metadata.getElementsDocumentation().entrySet()) {\n            builder.append(separator.getAndUpdate(!entry.getValue().isEmpty()))\n                    .append(documentation(entry.getValue(), \"  \"))\n                    .append(\"  \").append(entry.getKey().name());\n            if (metadata.getByEnumConstant() != null) {\n                builder.append(\" = \").append(metadata.getByEnumConstant().get(entry.getKey()));\n            }\n            builder.append(\";\\n\");\n        }\n        return builder.toString();\n    }\n\n    private String renderStructs(List<ThriftStructMetadata> structs)\n    {\n        return emptyToNull(structs.stream()\n                .map(this::renderStruct)\n                .collect(joining(\"\\n\")));\n    }\n\n    private String renderStruct(ThriftStructMetadata struct)\n    {\n        StringBuilder builder = new StringBuilder()\n                .append(documentation(struct.getDocumentation(), \"\"))\n                .append(format(\"%s %s {\\n\", structKind(struct), struct.getStructName()));\n\n        LineSeparator separator = new LineSeparator();\n        for (ThriftFieldMetadata field : struct.getFields()) {\n            if (field.isInternal()) {\n                continue;\n            }\n            builder.append(separator.getAndUpdate(!field.getDocumentation().isEmpty()))\n                    .append(documentation(field.getDocumentation(), \"  \"))\n                    .append(format(\"  %s: %s%s %s;\\n\",\n                            field.getId(),\n                            requiredness(field.getRequiredness()),\n                            typeName(field.getThriftType()),\n                            field.getName()));\n        }\n\n        return builder.append(\"}\\n\").toString();\n    }\n\n    private static String structKind(ThriftStructMetadata struct)\n    {\n        if (struct.isStruct()) {\n            return \"struct\";\n        }\n        if (struct.isException()) {\n            return \"exception\";\n        }\n        if (struct.isUnion()) {\n            return \"union\";\n        }\n        throw new IllegalArgumentException(\"Unknown type: \" + struct);\n    }\n\n    private static String requiredness(Requiredness requiredness)\n    {\n        switch (requiredness) {\n            case REQUIRED:\n                return \"required \";\n            case OPTIONAL:\n                return \"optional \";\n        }\n        return \"\";\n    }\n\n    private String renderServices(List<ThriftServiceMetadata> services)\n    {\n        return emptyToNull(services.stream()\n                .map(this::renderService)\n                .collect(joining(\"\\n\")));\n    }\n\n    private String renderService(ThriftServiceMetadata service)\n    {\n        return documentation(service.getDocumentation(), \"\") +\n                format(\"service %s {\\n\", service.getIdlName()) +\n                service.getMethods().values().stream()\n                        .map(this::renderMethod)\n                        .collect(joining(\"\\n\")) +\n                \"}\\n\";\n    }\n\n    private String renderMethod(ThriftMethodMetadata method)\n    {\n        StringBuilder builder = new StringBuilder()\n                .append(documentation(method.getDocumentation(), \"  \"));\n\n        String methodStart = format(\"  %s%s %s(\",\n                method.getOneway() ? \"oneway \" : \"\",\n                typeName(method.getReturnType()),\n                method.getName());\n\n        List<String> parameters = method.getParameters().stream()\n                .map(parameter -> format(\"%s: %s %s\",\n                        parameter.getId(),\n                        typeName(parameter.getThriftType()),\n                        parameter.getName()))\n                .collect(toList());\n\n        builder.append(renderParameters(methodStart, parameters));\n\n        if (!method.getExceptions().isEmpty()) {\n            List<String> exceptions = mapWithIndex(method.getExceptions().entrySet().stream(),\n                    (entry, index) -> format(\"%s: %s ex%s\",\n                            entry.getKey(),\n                            typeName(entry.getValue().getThriftType()),\n                            index + 1))\n                    .collect(toList());\n            builder.append(\"\\n\")\n                    .append(renderParameters(\"    throws (\", exceptions));\n        }\n\n        return builder.append(\";\\n\").toString();\n    }\n\n    private static String renderParameters(String start, List<String> parameters)\n    {\n        String joined = Joiner.on(\", \").join(parameters) + \")\";\n        if ((start.length() + joined.length()) <= 80) {\n            return start + joined;\n        }\n        return start + \"\\n      \" + Joiner.on(\",\\n      \").join(parameters) + \")\";\n    }\n\n    private String typeName(ThriftType type)\n    {\n        return typeRenderer.toString(type);\n    }\n\n    private static String documentation(List<String> documentation, String indent)\n    {\n        if (documentation.isEmpty()) {\n            return \"\";\n        }\n        StringBuilder builder = new StringBuilder()\n                .append(indent).append(\"\\n\").toString();\n    }\n\n    private static class LineSeparator\n    {\n        private boolean first = true;\n        private boolean wasDocumented;\n\n        public String getAndUpdate(boolean documented)\n        {\n            boolean needed = !first && (wasDocumented || documented);\n            first = false;\n            wasDocumented = documented;\n            return needed ? \"\\n\" : \"\";\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-codec/src/test/java/io/airlift/drift/codec/metadata/TestToString.java'",
            "'drift/drift-idl-generator/src/main/java/io/airlift/drift/idl/generator/ThriftIdlRenderer.java'",
            "'drift/drift-idl-generator/src/main/java/io/airlift/drift/idl/generator/ThriftIdlGenerator.java'"
        ]
    },
    {
        "files": [
            "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'",
            "'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'"
        ],
        "content": "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'\n:\npackage org.intellij.jflex.psi;\n\nimport com.intellij.psi.tree.IElementType;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.lang.ASTNode;\nimport org.intellij.jflex.psi.impl.*;\nimport com.intellij.psi.impl.source.tree.CompositePsiElement;\n\npublic interface JFlexTypes {\n\n  IElementType FLEX_CHAR_RANGE = new JFlexCompositeElementType(\"FLEX_CHAR_RANGE\");\n  IElementType FLEX_CHOICE_EXPRESSION = new JFlexCompositeElementType(\"FLEX_CHOICE_EXPRESSION\");\n  IElementType FLEX_CLASS_EXPRESSION = new JFlexCompositeElementType(\"FLEX_CLASS_EXPRESSION\");\n  IElementType FLEX_DECLARATIONS_SECTION = new JFlexCompositeElementType(\"FLEX_DECLARATIONS_SECTION\");\n  IElementType FLEX_EXPRESSION = new JFlexCompositeElementType(\"FLEX_EXPRESSION\");\n  IElementType FLEX_JAVA_CODE = new JFlexCompositeElementType(\"FLEX_JAVA_CODE\");\n  IElementType FLEX_JAVA_NAME = new JFlexCompositeElementType(\"FLEX_JAVA_NAME\");\n  IElementType FLEX_JAVA_TYPE = new JFlexCompositeElementType(\"FLEX_JAVA_TYPE\");\n  IElementType FLEX_JAVA_TYPE_PARAMETERS = new JFlexCompositeElementType(\"FLEX_JAVA_TYPE_PARAMETERS\");\n  IElementType FLEX_LEXICAL_RULES_SECTION = new JFlexCompositeElementType(\"FLEX_LEXICAL_RULES_SECTION\");\n  IElementType FLEX_LITERAL_EXPRESSION = new JFlexCompositeElementType(\"FLEX_LITERAL_EXPRESSION\");\n  IElementType FLEX_LOOK_AHEAD = new JFlexCompositeElementType(\"FLEX_LOOK_AHEAD\");\n  IElementType FLEX_MACRO_DEFINITION = new JFlexCompositeElementType(\"FLEX_MACRO_DEFINITION\");\n  IElementType FLEX_MACRO_REFERENCE = new JFlexCompositeElementType(\"FLEX_MACRO_REFERENCE\");\n  IElementType FLEX_MACRO_REF_EXPRESSION = new JFlexCompositeElementType(\"FLEX_MACRO_REF_EXPRESSION\");\n  IElementType FLEX_NOT_EXPRESSION = new JFlexCompositeElementType(\"FLEX_NOT_EXPRESSION\");\n  IElementType FLEX_OPTION = new JFlexCompositeElementType(\"FLEX_OPTION\");\n  IElementType FLEX_PAREN_EXPRESSION = new JFlexCompositeElementType(\"FLEX_PAREN_EXPRESSION\");\n  IElementType FLEX_PREDEFINED_CLASS_EXPRESSION = new JFlexCompositeElementType(\"FLEX_PREDEFINED_CLASS_EXPRESSION\");\n  IElementType FLEX_QUANTIFIER_EXPRESSION = new JFlexCompositeElementType(\"FLEX_QUANTIFIER_EXPRESSION\");\n  IElementType FLEX_RULE = new JFlexCompositeElementType(\"FLEX_RULE\");\n  IElementType FLEX_SEQUENCE_EXPRESSION = new JFlexCompositeElementType(\"FLEX_SEQUENCE_EXPRESSION\");\n  IElementType FLEX_STATE_DECLARATION = new JFlexCompositeElementType(\"FLEX_STATE_DECLARATION\");\n  IElementType FLEX_STATE_DEFINITION = new JFlexCompositeElementType(\"FLEX_STATE_DEFINITION\");\n  IElementType FLEX_STATE_LIST = new JFlexCompositeElementType(\"FLEX_STATE_LIST\");\n  IElementType FLEX_STATE_REFERENCE = new JFlexCompositeElementType(\"FLEX_STATE_REFERENCE\");\n  IElementType FLEX_USER_CODE_SECTION = new JFlexCompositeElementType(\"FLEX_USER_CODE_SECTION\");\n  IElementType FLEX_USER_VALUE = new JFlexCompositeElementType(\"FLEX_USER_VALUE\");\n\n  IElementType FLEX_AMPAMP = new JFlexTokenType(\"&&\");\n  IElementType FLEX_ANGLE1 = new JFlexTokenType(\"<\");\n  IElementType FLEX_ANGLE2 = new JFlexTokenType(\">\");\n  IElementType FLEX_BANG = new JFlexTokenType(\"!\");\n  IElementType FLEX_BAR = new JFlexTokenType(\"|\");\n  IElementType FLEX_BARBAR = new JFlexTokenType(\"||\");\n  IElementType FLEX_BLOCK_COMMENT = new JFlexTokenType(\"block_comment\");\n  IElementType FLEX_BRACE1 = new JFlexTokenType(\"{\");\n  IElementType FLEX_BRACE2 = new JFlexTokenType(\"}\");\n  IElementType FLEX_BRACK1 = new JFlexTokenType(\"[\");\n  IElementType FLEX_BRACK2 = new JFlexTokenType(\"]\");\n  IElementType FLEX_CHAR = new JFlexTokenType(\"char\");\n  IElementType FLEX_CHAR_CLASS = new JFlexTokenType(\"char_class\");\n  IElementType FLEX_CHAR_ESC = new JFlexTokenType(\"char_esc\");\n  IElementType FLEX_COMMA = new JFlexTokenType(\",\");\n  IElementType FLEX_DASH = new JFlexTokenType(\"-\");\n  IElementType FLEX_DASHDASH = new JFlexTokenType(\"--\");\n  IElementType FLEX_DOLLAR = new JFlexTokenType(\"$\");\n  IElementType FLEX_DOT = new JFlexTokenType(\".\");\n  IElementType FLEX_EOF = new JFlexTokenType(\"<<EOF>>\");\n  IElementType FLEX_EQ = new JFlexTokenType(\"=\");\n  IElementType FLEX_FSLASH = new JFlexTokenType(\"/\");\n  IElementType FLEX_HAT = new JFlexTokenType(\"^\");\n  IElementType FLEX_ID = new JFlexTokenType(\"id\");\n  IElementType FLEX_LINE_COMMENT = new JFlexTokenType(\"line_comment\");\n  IElementType FLEX_NUMBER = new JFlexTokenType(\"number\");\n  IElementType FLEX_OPT16BIT = new JFlexTokenType(\"%16bit\");\n  IElementType FLEX_OPT_7BIT = new JFlexTokenType(\"%7bit\");\n  IElementType FLEX_OPT_8BIT = new JFlexTokenType(\"%8bit\");\n  IElementType FLEX_OPT_ABSTRACT = new JFlexTokenType(\"%abstract\");\n  IElementType FLEX_OPT_APIPRIVATE = new JFlexTokenType(\"%apiprivate\");\n  IElementType FLEX_OPT_BUFFER = new JFlexTokenType(\"%buffer\");\n  IElementType FLEX_OPT_CASELESS = new JFlexTokenType(\"%caseless\");\n  IElementType FLEX_OPT_CHAR = new JFlexTokenType(\"%char\");\n  IElementType FLEX_OPT_CLASS = new JFlexTokenType(\"%class\");\n  IElementType FLEX_OPT_CODE1 = new JFlexTokenType(\"%{\");\n  IElementType FLEX_OPT_CODE2 = new JFlexTokenType(\"%}\");\n  IElementType FLEX_OPT_COLUMN = new JFlexTokenType(\"%column\");\n  IElementType FLEX_OPT_CTORARG = new JFlexTokenType(\"%ctorarg\");\n  IElementType FLEX_OPT_CUP = new JFlexTokenType(\"%cup\");\n  IElementType FLEX_OPT_CUPDEBUG = new JFlexTokenType(\"%cupdebug\");\n  IElementType FLEX_OPT_CUPSYM = new JFlexTokenType(\"%cupsym\");\n  IElementType FLEX_OPT_DEBUG = new JFlexTokenType(\"%debug\");\n  IElementType FLEX_OPT_EOF1 = new JFlexTokenType(\"%eof{\");\n  IElementType FLEX_OPT_EOF2 = new JFlexTokenType(\"%eof}\");\n  IElementType FLEX_OPT_EOFCLOSE = new JFlexTokenType(\"%eofclose\");\n  IElementType FLEX_OPT_EOFTHROW = new JFlexTokenType(\"%eofthrow\");\n  IElementType FLEX_OPT_EOFTHROW1 = new JFlexTokenType(\"%eofthrow{\");\n  IElementType FLEX_OPT_EOFTHROW2 = new JFlexTokenType(\"%eofthrow}\");\n  IElementType FLEX_OPT_EOFVAL1 = new JFlexTokenType(\"%eofval{\");\n  IElementType FLEX_OPT_EOFVAL2 = new JFlexTokenType(\"%eofval}\");\n  IElementType FLEX_OPT_EXTENDS = new JFlexTokenType(\"%extends\");\n  IElementType FLEX_OPT_FINAL = new JFlexTokenType(\"%final\");\n  IElementType FLEX_OPT_FULL = new JFlexTokenType(\"%full\");\n  IElementType FLEX_OPT_FUNCTION = new JFlexTokenType(\"%function\");\n  IElementType FLEX_OPT_IGNORECASE = new JFlexTokenType(\"%ignorecase\");\n  IElementType FLEX_OPT_IMPLEMENTS = new JFlexTokenType(\"%implements\");\n  IElementType FLEX_OPT_INCLUDE = new JFlexTokenType(\"%include\");\n  IElementType FLEX_OPT_INIT1 = new JFlexTokenType(\"%init{\");\n  IElementType FLEX_OPT_INIT2 = new JFlexTokenType(\"%init}\");\n  IElementType FLEX_OPT_INITTHROW = new JFlexTokenType(\"%initthrow\");\n  IElementType FLEX_OPT_INITTHROW1 = new JFlexTokenType(\"%initthrow{\");\n  IElementType FLEX_OPT_INITTHROW2 = new JFlexTokenType(\"%initthrow}\");\n  IElementType FLEX_OPT_INT = new JFlexTokenType(\"%int\");\n  IElementType FLEX_OPT_INTEGER = new JFlexTokenType(\"%integer\");\n  IElementType FLEX_OPT_INTWRAP = new JFlexTokenType(\"%intwrap\");\n  IElementType FLEX_OPT_LINE = new JFlexTokenType(\"%line\");\n  IElementType FLEX_OPT_NOTUNIX = new JFlexTokenType(\"%notunix\");\n  IElementType FLEX_OPT_PUBLIC = new JFlexTokenType(\"%public\");\n  IElementType FLEX_OPT_SCANERROR = new JFlexTokenType(\"%scanerror\");\n  IElementType FLEX_OPT_STANDALONE = new JFlexTokenType(\"%standalone\");\n  IElementType FLEX_OPT_STATE = new JFlexTokenType(\"%state\");\n  IElementType FLEX_OPT_TYPE = new JFlexTokenType(\"%type\");\n  IElementType FLEX_OPT_UNICODE = new JFlexTokenType(\"%unicode\");\n  IElementType FLEX_OPT_XSTATE = new JFlexTokenType(\"%xstate\");\n  IElementType FLEX_OPT_YYEOF = new JFlexTokenType(\"%yyeof\");\n  IElementType FLEX_OPT_YYLEXTHROW = new JFlexTokenType(\"%yylexthrow\");\n  IElementType FLEX_OPT_YYLEXTHROW1 = new JFlexTokenType(\"%yylexthrow{\");\n  IElementType FLEX_OPT_YYLEXTHROW2 = new JFlexTokenType(\"%yylexthrow}\");\n  IElementType FLEX_PAREN1 = new JFlexTokenType(\"(\");\n  IElementType FLEX_PAREN2 = new JFlexTokenType(\")\");\n  IElementType FLEX_PLUS = new JFlexTokenType(\"+\");\n  IElementType FLEX_QUESTION = new JFlexTokenType(\"?\");\n  IElementType FLEX_RAW = new JFlexTokenType(\"code block\");\n  IElementType FLEX_STAR = new JFlexTokenType(\"*\");\n  IElementType FLEX_STRING = new JFlexTokenType(\"string\");\n  IElementType FLEX_TILDE = new JFlexTokenType(\"~\");\n  IElementType FLEX_TILDETILDE = new JFlexTokenType(\"~~\");\n  IElementType FLEX_TWO_PERCS = new JFlexTokenType(\"%%\");\n  IElementType FLEX_UNCLOSED = new JFlexTokenType(\"unclosed\");\n  IElementType FLEX_VERSION = new JFlexTokenType(\"version\");\n\n  class Factory {\n    public static CompositePsiElement createElement(IElementType type) {\n       if (type == FLEX_CHAR_RANGE) {\n        return new JFlexCharRangeImpl(type);\n      }\n      else if (type == FLEX_CHOICE_EXPRESSION) {\n        return new JFlexChoiceExpressionImpl(type);\n      }\n      else if (type == FLEX_CLASS_EXPRESSION) {\n        return new JFlexClassExpressionImpl(type);\n      }\n      else if (type == FLEX_DECLARATIONS_SECTION) {\n        return new JFlexDeclarationsSectionImpl(type);\n      }\n      else if (type == FLEX_JAVA_CODE) {\n        return new JFlexJavaCodeImpl(type);\n      }\n      else if (type == FLEX_JAVA_NAME) {\n        return new JFlexJavaNameImpl(type);\n      }\n      else if (type == FLEX_JAVA_TYPE) {\n        return new JFlexJavaTypeImpl(type);\n      }\n      else if (type == FLEX_JAVA_TYPE_PARAMETERS) {\n        return new JFlexJavaTypeParametersImpl(type);\n      }\n      else if (type == FLEX_LEXICAL_RULES_SECTION) {\n        return new JFlexLexicalRulesSectionImpl(type);\n      }\n      else if (type == FLEX_LITERAL_EXPRESSION) {\n        return new JFlexLiteralExpressionImpl(type);\n      }\n      else if (type == FLEX_LOOK_AHEAD) {\n        return new JFlexLookAheadImpl(type);\n      }\n      else if (type == FLEX_MACRO_DEFINITION) {\n        return new JFlexMacroDefinitionImpl(type);\n      }\n      else if (type == FLEX_MACRO_REFERENCE) {\n        return new JFlexMacroReferenceImpl(type);\n      }\n      else if (type == FLEX_MACRO_REF_EXPRESSION) {\n        return new JFlexMacroRefExpressionImpl(type);\n      }\n      else if (type == FLEX_NOT_EXPRESSION) {\n        return new JFlexNotExpressionImpl(type);\n      }\n      else if (type == FLEX_OPTION) {\n        return new JFlexOptionImpl(type);\n      }\n      else if (type == FLEX_PAREN_EXPRESSION) {\n        return new JFlexParenExpressionImpl(type);\n      }\n      else if (type == FLEX_PREDEFINED_CLASS_EXPRESSION) {\n        return new JFlexPredefinedClassExpressionImpl(type);\n      }\n      else if (type == FLEX_QUANTIFIER_EXPRESSION) {\n        return new JFlexQuantifierExpressionImpl(type);\n      }\n      else if (type == FLEX_RULE) {\n        return new JFlexRuleImpl(type);\n      }\n      else if (type == FLEX_SEQUENCE_EXPRESSION) {\n        return new JFlexSequenceExpressionImpl(type);\n      }\n      else if (type == FLEX_STATE_DECLARATION) {\n        return new JFlexStateDeclarationImpl(type);\n      }\n      else if (type == FLEX_STATE_DEFINITION) {\n        return new JFlexStateDefinitionImpl(type);\n      }\n      else if (type == FLEX_STATE_LIST) {\n        return new JFlexStateListImpl(type);\n      }\n      else if (type == FLEX_STATE_REFERENCE) {\n        return new JFlexStateReferenceImpl(type);\n      }\n      else if (type == FLEX_USER_CODE_SECTION) {\n        return new JFlexUserCodeSectionImpl(type);\n      }\n      else if (type == FLEX_USER_VALUE) {\n        return new JFlexUserValueImpl(type);\n      }\n      throw new AssertionError(\"Unknown element type: \" + type);\n    }\n  }\n}\n\n'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'\n:\n\npackage org.intellij.jflex.editor;\n\nimport com.intellij.lexer.Lexer;\nimport com.intellij.openapi.editor.DefaultLanguageHighlighterColors;\nimport com.intellij.openapi.editor.HighlighterColors;\nimport com.intellij.openapi.editor.colors.EditorColors;\nimport com.intellij.openapi.editor.colors.TextAttributesKey;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighter;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighterBase;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighterFactory;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.TokenType;\nimport com.intellij.psi.tree.IElementType;\nimport org.intellij.jflex.parser.JFlexLexer;\nimport org.jetbrains.annotations.NotNull;\n\nimport static com.intellij.openapi.editor.colors.TextAttributesKey.createTextAttributesKey;\nimport static org.intellij.jflex.psi.JFlexTokenSets.CHAR_CLASS_OPERATORS;\nimport static org.intellij.jflex.psi.JFlexTokenSets.PATTERN_OPERATORS;\nimport static org.intellij.jflex.psi.JFlexTypes.*;\n\nfinal class JFlexSyntaxHighlighterFactory extends SyntaxHighlighterFactory {\n  public static final TextAttributesKey ILLEGAL    = createTextAttributesKey(\"FLEX_ILLEGAL\", HighlighterColors.BAD_CHARACTER);\n\n  public static final TextAttributesKey MACRO      = createTextAttributesKey(\"FLEX_MACRO\", DefaultLanguageHighlighterColors.INSTANCE_FIELD);\n  public static final TextAttributesKey STATE      = createTextAttributesKey(\"FLEX_STATE\", DefaultLanguageHighlighterColors.CLASS_NAME);\n  public static final TextAttributesKey CLASS      = createTextAttributesKey(\"FLEX_CLASS\");\n  public static final TextAttributesKey PATTERN_OP = createTextAttributesKey(\"FLEX_PATTERN_OP\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey CLASS_OP   = createTextAttributesKey(\"FLEX_CHAR_CLASS_OP\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey OP_RANGE   = createTextAttributesKey(\"FLEX_OP_RANGE\", DefaultLanguageHighlighterColors.KEYWORD);\n\n  public static final TextAttributesKey COMMENT    = createTextAttributesKey(\"FLEX_COMMENT\", DefaultLanguageHighlighterColors.LINE_COMMENT);\n  public static final TextAttributesKey OPTION     = createTextAttributesKey(\"FLEX_OPTION\", DefaultLanguageHighlighterColors.LABEL);\n  public static final TextAttributesKey RAW_CODE   = createTextAttributesKey(\"FLEX_RAW_CODE\", EditorColors.INJECTED_LANGUAGE_FRAGMENT);\n  public static final TextAttributesKey SECT_DIV   = createTextAttributesKey(\"FLEX_SECTION_DIV\", DefaultLanguageHighlighterColors.LABEL);\n\n  public static final TextAttributesKey STRING     = createTextAttributesKey(\"FLEX_STRING\", DefaultLanguageHighlighterColors.STRING);\n  public static final TextAttributesKey CHAR       = createTextAttributesKey(\"FLEX_CHAR\", DefaultLanguageHighlighterColors.STRING);\n  public static final TextAttributesKey CHAR_ESC   = createTextAttributesKey(\"FLEX_CHAR_ESC\", DefaultLanguageHighlighterColors.VALID_STRING_ESCAPE);\n  public static final TextAttributesKey NUMBER     = createTextAttributesKey(\"FLEX_NUMBER\", DefaultLanguageHighlighterColors.NUMBER);\n\n  public static final TextAttributesKey CLASS_STD  = createTextAttributesKey(\"FLEX_PREDEFINED_CLASS\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey DOT        = createTextAttributesKey(\"FLEX_DOT\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey EOF        = createTextAttributesKey(\"FLEX_SECTION_DIV\", DefaultLanguageHighlighterColors.LABEL);\n  public static final TextAttributesKey LOOKAHEAD  = createTextAttributesKey(\"FLEX_LOOKAHEAD\", DefaultLanguageHighlighterColors.OPERATION_SIGN);\n\n  public static final TextAttributesKey COMMA      = createTextAttributesKey(\"FLEX_COMMA\", DefaultLanguageHighlighterColors.COMMA);\n  public static final TextAttributesKey OP_EQUAL   = createTextAttributesKey(\"FLEX_OP_EQUAL\", DefaultLanguageHighlighterColors.OPERATION_SIGN);\n  public static final TextAttributesKey PARENS     = createTextAttributesKey(\"FLEX_PARENS\", DefaultLanguageHighlighterColors.PARENTHESES);\n  public static final TextAttributesKey BRACES     = createTextAttributesKey(\"FLEX_BRACES\", DefaultLanguageHighlighterColors.BRACES);\n  public static final TextAttributesKey BRACKETS   = createTextAttributesKey(\"FLEX_BRACKETS\", DefaultLanguageHighlighterColors.BRACKETS);\n  public static final TextAttributesKey ANGLES     = createTextAttributesKey(\"FLEX_ANGLES\", DefaultLanguageHighlighterColors.BRACKETS);\n\n\n  @Override\n  public @NotNull SyntaxHighlighter getSyntaxHighlighter(Project project, VirtualFile virtualFile) {\n    return new JFlexSyntaxHighlighter();\n  }\n\n  private static class JFlexSyntaxHighlighter extends SyntaxHighlighterBase {\n    @Override\n    public @NotNull Lexer getHighlightingLexer() {\n      return new JFlexLexer();\n    }\n\n    @Override\n    public @NotNull TextAttributesKey @NotNull [] getTokenHighlights(IElementType o) {\n      if (o == FLEX_LINE_COMMENT || o == FLEX_BLOCK_COMMENT) return pack(COMMENT);\n      if (o == FLEX_RAW) return pack(RAW_CODE);\n      if (o == FLEX_TWO_PERCS) return pack(SECT_DIV);\n      if (o == FLEX_STRING) return pack(STRING);\n      if (o == FLEX_CHAR) return pack(CHAR);\n      if (o == FLEX_CHAR_ESC) return pack(CHAR_ESC);\n      if (o == FLEX_NUMBER || o == FLEX_VERSION) return pack(NUMBER);\n      if (o == FLEX_CHAR_CLASS) return pack(CLASS_STD);\n      if (o == FLEX_EOF) return pack(EOF);\n      if (o == FLEX_FSLASH) return pack(LOOKAHEAD);\n      if (o == FLEX_COMMA) return pack(COMMA);\n      if (o == FLEX_DOT) return pack(DOT);\n      if (o == FLEX_EQ) return pack(OP_EQUAL);\n      if (o == FLEX_DASH) return pack(OP_RANGE);\n      if (o == FLEX_PAREN1 || o == FLEX_PAREN2) return pack(PARENS);\n      if (o == FLEX_BRACE1 || o == FLEX_BRACE2) return pack(BRACES);\n      if (o == FLEX_BRACK1 || o == FLEX_BRACK2) return pack(BRACKETS);\n      if (o == FLEX_ANGLE1 || o == FLEX_ANGLE2) return pack(ANGLES);\n      if (PATTERN_OPERATORS.contains(o)) return pack(PATTERN_OP);\n      if (CHAR_CLASS_OPERATORS.contains(o)) return pack(CLASS_OP);\n      if (o == FLEX_UNCLOSED || o == TokenType.BAD_CHARACTER) return pack(ILLEGAL);\n      if (o.toString().startsWith(\"%\")) return pack(OPTION);\n      return TextAttributesKey.EMPTY_ARRAY;\n    }\n  }\n}\n",
        "gt": [
            "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'",
            "'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'"
        ]
    },
    {
        "files": [
            "'java-object-diff/src/main/java/de/danielbechler/diff/node/DiffNode.java'",
            "'java-object-diff/src/integration-test/java/de/danielbechler/diff/example/CanonicalAccessorExample.java'",
            "'java-object-diff/src/main/java/de/danielbechler/util/Collections.java'"
        ],
        "content": "'java-object-diff/src/main/java/de/danielbechler/diff/node/DiffNode.java'\n:\n\npackage de.danielbechler.diff.node;\n\nimport de.danielbechler.diff.access.Accessor;\nimport de.danielbechler.diff.access.CategoryAware;\nimport de.danielbechler.diff.access.ExclusionAware;\nimport de.danielbechler.diff.access.PropertyAwareAccessor;\nimport de.danielbechler.diff.access.RootAccessor;\nimport de.danielbechler.diff.access.TypeAwareAccessor;\nimport de.danielbechler.diff.identity.IdentityStrategy;\nimport de.danielbechler.diff.instantiation.TypeInfo;\nimport de.danielbechler.diff.path.NodePath;\nimport de.danielbechler.diff.selector.BeanPropertyElementSelector;\nimport de.danielbechler.diff.selector.CollectionItemElementSelector;\nimport de.danielbechler.diff.selector.ElementSelector;\nimport de.danielbechler.diff.selector.RootElementSelector;\nimport de.danielbechler.util.Assert;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport java.util.Collection;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static java.util.Collections.unmodifiableSet;\n\n\n\n@SuppressWarnings(\"UnusedDeclaration\")\npublic class DiffNode\n{\n\tpublic static final DiffNode ROOT = null;\n\n\tprivate final Accessor accessor;\n\tprivate final Map<ElementSelector, DiffNode> children = new LinkedHashMap<ElementSelector, DiffNode>(10);\n\n\tprivate State state = State.UNTOUCHED;\n\tprivate DiffNode parentNode;\n\tprivate NodePath circleStartPath;\n\tprivate DiffNode circleStartNode;\n\tprivate Class<?> valueType;\n\tprivate TypeInfo valueTypeInfo;\n\tprivate IdentityStrategy childIdentityStrategy;\n\tprivate final Collection<String> additionalCategories = new TreeSet<String>();\n\n\tpublic void setChildIdentityStrategy(final IdentityStrategy identityStrategy)\n\t{\n\t\tthis.childIdentityStrategy = identityStrategy;\n\t}\n\n\tpublic static DiffNode newRootNode()\n\t{\n\t\treturn new DiffNode();\n\t}\n\n\tpublic static DiffNode newRootNodeWithType(final Class<?> valueType)\n\t{\n\t\tfinal DiffNode rootNode = newRootNode();\n\t\trootNode.setType(valueType);\n\t\treturn rootNode;\n\t}\n\n\tpublic DiffNode(final DiffNode parentNode, final Accessor accessor, final Class<?> valueType)\n\t{\n\t\tAssert.notNull(accessor, \"accessor\");\n\t\tthis.accessor = accessor;\n\t\tthis.valueType = valueType;\n\t\tsetParentNode(parentNode);\n\t}\n\n\tpublic DiffNode(final DiffNode parentNode, final Accessor accessor)\n\t{\n\t\tthis(parentNode, accessor, null);\n\t}\n\n\tprivate DiffNode()\n\t{\n\t\tthis.parentNode = ROOT;\n\t\tthis.accessor = RootAccessor.getInstance();\n\t}\n\n\n\tpublic State getState()\n\t{\n\t\treturn this.state;\n\t}\n\n\n\tpublic void setState(final State state)\n\t{\n\t\tAssert.notNull(state, \"state\");\n\t\tthis.state = state;\n\t}\n\n\tpublic boolean matches(final NodePath path)\n\t{\n\t\treturn path.matches(getPath());\n\t}\n\n\tpublic boolean hasChanges()\n\t{\n\t\tif (isAdded() || isChanged() || isRemoved())\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tfinal AtomicBoolean result = new AtomicBoolean(false);\n\t\tvisitChildren(new Visitor()\n\t\t{\n\t\t\tpublic void node(final DiffNode node, final Visit visit)\n\t\t\t{\n\t\t\t\tif (node.hasChanges())\n\t\t\t\t{\n\t\t\t\t\tresult.set(true);\n\t\t\t\t\tvisit.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn result.get();\n\t}\n\n\n\tpublic final boolean isAdded()\n\t{\n\t\treturn state == State.ADDED;\n\t}\n\n\n\tpublic final boolean isChanged()\n\t{\n\t\treturn state == State.CHANGED;\n\t}\n\n\n\tpublic final boolean isRemoved()\n\t{\n\t\treturn state == State.REMOVED;\n\t}\n\n\n\tpublic final boolean isUntouched()\n\t{\n\t\treturn state == State.UNTOUCHED;\n\t}\n\n\n\tpublic boolean isCircular()\n\t{\n\t\treturn state == State.CIRCULAR;\n\t}\n\n\n\tpublic NodePath getPath()\n\t{\n\t\tif (parentNode != null)\n\t\t{\n\t\t\treturn NodePath.startBuildingFrom(parentNode.getPath())\n\t\t\t\t\t.element(accessor.getElementSelector())\n\t\t\t\t\t.build();\n\t\t}\n\t\telse if (accessor instanceof RootAccessor)\n\t\t{\n\t\t\treturn NodePath.withRoot();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn NodePath.startBuilding().element(accessor.getElementSelector()).build();\n\t\t}\n\t}\n\n\tpublic ElementSelector getElementSelector()\n\t{\n\t\treturn accessor.getElementSelector();\n\t}\n\n\n\tpublic Class<?> getValueType()\n\t{\n\t\tif (valueType != null)\n\t\t{\n\t\t\treturn valueType;\n\t\t}\n\t\tif (valueTypeInfo != null)\n\t\t{\n\t\t\treturn valueTypeInfo.getType();\n\t\t}\n\t\tif (accessor instanceof TypeAwareAccessor)\n\t\t{\n\t\t\treturn ((TypeAwareAccessor) accessor).getType();\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tpublic final void setType(final Class<?> aClass)\n\t{\n\t\tthis.valueType = aClass;\n\t}\n\n\tpublic TypeInfo getValueTypeInfo()\n\t{\n\t\treturn valueTypeInfo;\n\t}\n\n\tpublic void setValueTypeInfo(final TypeInfo typeInfo)\n\t{\n\t\tthis.valueTypeInfo = typeInfo;\n\t}\n\n\n\tpublic boolean hasChildren()\n\t{\n\t\treturn !children.isEmpty();\n\t}\n\n\tpublic int childCount()\n\t{\n\t\treturn children.size();\n\t}\n\n\n\tpublic DiffNode getChild(final String propertyName)\n\t{\n\t\treturn getChild(new BeanPropertyElementSelector(propertyName));\n\t}\n\n\n\tpublic DiffNode getChild(final ElementSelector elementSelector)\n\t{\n\t\tif (elementSelector instanceof CollectionItemElementSelector && childIdentityStrategy != null)\n\t\t{\n\t\t\treturn children.get(((CollectionItemElementSelector) elementSelector).copyWithIdentityStrategy(childIdentityStrategy));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn children.get(elementSelector);\n\t\t}\n\t}\n\n\n\tpublic DiffNode getChild(final NodePath nodePath)\n\t{\n\t\tif (parentNode != null)\n\t\t{\n\t\t\treturn parentNode.getChild(nodePath.getElementSelectors());\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn getChild(nodePath.getElementSelectors());\n\t\t}\n\t}\n\n\n\tpublic DiffNode getChild(final List<ElementSelector> selectors)\n\t{\n\t\tAssert.notEmpty(selectors, \"selectors\");\n\t\tfinal ElementSelector selector = selectors.get(0);\n\t\tif (selectors.size() == 1)\n\t\t{\n\t\t\tif (selector == RootElementSelector.getInstance())\n\t\t\t{\n\t\t\t\treturn isRootNode() ? this : null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn getChild(selector);\n\t\t\t}\n\t\t}\n\t\telse if (selectors.size() > 1)\n\t\t{\n\t\t\tfinal DiffNode child;\n\t\t\tif (selector == RootElementSelector.getInstance())\n\t\t\t{\n\t\t\t\tchild = isRootNode() ? this : null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchild = getChild(selector);\n\t\t\t}\n\t\t\tif (child != null)\n\t\t\t{\n\t\t\t\treturn child.getChild(selectors.subList(1, selectors.size()));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tpublic void addChild(final DiffNode node)\n\t{\n\t\tif (node == this)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Detected attempt to add a node to itself. \" +\n\t\t\t\t\t\"This would cause inifite loops and must never happen.\");\n\t\t}\n\t\telse if (node.isRootNode())\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Detected attempt to add root node as child. \" +\n\t\t\t\t\t\"This is not allowed and must be a mistake.\");\n\t\t}\n\t\telse if (node.getParentNode() != null && node.getParentNode() != this)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Detected attempt to add child node that is already the \" +\n\t\t\t\t\t\"child of another node. Adding nodes multiple times is not allowed, since it could \" +\n\t\t\t\t\t\"cause infinite loops.\");\n\t\t}\n\t\tif (node.getParentNode() == null)\n\t\t{\n\t\t\tnode.setParentNode(this);\n\t\t}\n\t\tchildren.put(node.getElementSelector(), node);\n\t\tif (state == State.UNTOUCHED && node.hasChanges())\n\t\t{\n\t\t\tstate = State.CHANGED;\n\t\t}\n\t}\n\n\n\tpublic final void visit(final Visitor visitor)\n\t{\n\t\tfinal Visit visit = new Visit();\n\t\ttry\n\t\t{\n\t\t\tvisit(visitor, visit);\n\t\t}\n\t\tcatch (final StopVisitationException ignored)\n\t\t{\n\t\t}\n\t}\n\n\tprotected final void visit(final Visitor visitor, final Visit visit)\n\t{\n\t\ttry\n\t\t{\n\t\t\tvisitor.node(this, visit);\n\t\t}\n\t\tcatch (final StopVisitationException e)\n\t\t{\n\t\t\tvisit.stop();\n\t\t}\n\t\tif (visit.isAllowedToGoDeeper() && hasChildren())\n\t\t{\n\t\t\tvisitChildren(visitor);\n\t\t}\n\t\tif (visit.isStopped())\n\t\t{\n\t\t\tthrow new StopVisitationException();\n\t\t}\n\t}\n\n\n\tpublic final void visitChildren(final Visitor visitor)\n\t{\n\t\tfor (final DiffNode child : children.values())\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tchild.visit(visitor);\n\t\t\t}\n\t\t\tcatch (final StopVisitationException e)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic final void visitParents(final Visitor visitor)\n\t{\n\t\tfinal Visit visit = new Visit();\n\t\tif (parentNode != null)\n\t\t{\n\t\t\tvisitor.node(parentNode, visit);\n\t\t\tif (!visit.isStopped())\n\t\t\t{\n\t\t\t\tparentNode.visitParents(visitor);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tpublic Set<Annotation> getFieldAnnotations()\n\t{\n\t\tif (accessor instanceof PropertyAwareAccessor)\n\t\t{\n\t\t\treturn unmodifiableSet(((PropertyAwareAccessor) accessor).getFieldAnnotations());\n\t\t}\n\t\treturn unmodifiableSet(Collections.<Annotation>emptySet());\n\t}\n\n\n\tpublic <T extends Annotation> T getFieldAnnotation(final Class<T> annotationClass)\n\t{\n\t\tif (accessor instanceof PropertyAwareAccessor)\n\t\t{\n\t\t\treturn ((PropertyAwareAccessor) accessor).getFieldAnnotation(annotationClass);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tpublic Set<Annotation> getPropertyAnnotations()\n\t{\n\t\tif (accessor instanceof PropertyAwareAccessor)\n\t\t{\n\t\t\treturn unmodifiableSet(((PropertyAwareAccessor) accessor).getReadMethodAnnotations());\n\t\t}\n\t\treturn unmodifiableSet(Collections.<Annotation>emptySet());\n\t}\n\n\tpublic <T extends Annotation> T getPropertyAnnotation(final Class<T> annotationClass)\n\t{\n\t\tif (accessor instanceof PropertyAwareAccessor)\n\t\t{\n\t\t\treturn ((PropertyAwareAccessor) accessor).getReadMethodAnnotation(annotationClass);\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tpublic String getPropertyName()\n\t{\n\t\tif (isPropertyAware())\n\t\t{\n\t\t\treturn ((PropertyAwareAccessor) accessor).getPropertyName();\n\t\t}\n\t\telse if (parentNode != null)\n\t\t{\n\t\t\treturn parentNode.getPropertyName();\n\t\t}\n\t\treturn null;\n\t}\n\n\n\tpublic final boolean isPropertyAware()\n\t{\n\t\treturn accessor instanceof PropertyAwareAccessor;\n\t}\n\n\tpublic final boolean isRootNode()\n\t{\n\t\treturn accessor instanceof RootAccessor;\n\t}\n\n\n\tpublic final boolean isIgnored()\n\t{\n\t\treturn state == State.IGNORED;\n\t}\n\n\n\t@Deprecated\n\tpublic boolean isExcluded()\n\t{\n\t\tif (accessor instanceof ExclusionAware)\n\t\t{\n\t\t\treturn ((ExclusionAware) accessor).isExcludedByAnnotation();\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic final Set<String> getCategories()\n\t{\n\t\tfinal Set<String> categories = new TreeSet<String>();\n\t\tif (parentNode != null)\n\t\t{\n\t\t\tcategories.addAll(parentNode.getCategories());\n\t\t}\n\t\tif (accessor instanceof CategoryAware)\n\t\t{\n\t\t\tfinal Set<String> categoriesFromAccessor = ((CategoryAware) accessor).getCategoriesFromAnnotation();\n\t\t\tif (categoriesFromAccessor != null)\n\t\t\t{\n\t\t\t\tcategories.addAll(categoriesFromAccessor);\n\t\t\t}\n\t\t}\n\t\tcategories.addAll(additionalCategories);\n\n\t\treturn unmodifiableSet(categories);\n\t}\n\n\n\tpublic DiffNode getParentNode()\n\t{\n\t\treturn parentNode;\n\t}\n\n\n\tprotected final void setParentNode(final DiffNode parentNode)\n\t{\n\t\tif (this.parentNode != null && this.parentNode != parentNode)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"The parent of a node cannot be changed, once it's set.\");\n\t\t}\n\t\tthis.parentNode = parentNode;\n\t}\n\n\tpublic Object get(final Object target)\n\t{\n\t\treturn accessor.get(target);\n\t}\n\n\tpublic void set(final Object target, final Object value)\n\t{\n\t\taccessor.set(target, value);\n\t}\n\n\tpublic void unset(final Object target)\n\t{\n\t\taccessor.unset(target);\n\t}\n\n\tpublic Object canonicalGet(Object target)\n\t{\n\t\tif (parentNode != null)\n\t\t{\n\t\t\ttarget = parentNode.canonicalGet(target);\n\t\t}\n\t\treturn get(target);\n\t}\n\n\tpublic void canonicalSet(Object target, final Object value)\n\t{\n\t\tif (parentNode != null)\n\t\t{\n\t\t\tObject parent = parentNode.canonicalGet(target);\n\t\t\tif (parent == null)\n\t\t\t{\n\t\t\t\tparent = parentNode.newInstance();\n\t\t\t\tparentNode.canonicalSet(target, parent);\n\t\t\t}\n\t\t\ttarget = parent;\n\t\t}\n\t\tset(target, value);\n\t}\n\n\tprivate Object newInstance()\n\t{\n\t\tif (valueTypeInfo != null)\n\t\t{\n\t\t\treturn valueTypeInfo.newInstance();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void canonicalUnset(Object target)\n\t{\n\t\tif (parentNode != null)\n\t\t{\n\t\t\ttarget = parentNode.canonicalGet(target);\n\t\t}\n\t\tunset(target);\n\t}\n\n\t@Override\n\tpublic int hashCode()\n\t{\n\t\treturn accessor.hashCode();\n\t}\n\n\t@Override\n\tpublic boolean equals(final Object o)\n\t{\n\t\tif (this == o)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tif (o == null || getClass() != o.getClass())\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\tfinal DiffNode that = (DiffNode) o;\n\n\t\tif (!accessor.equals(that.accessor))\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\tfinal StringBuilder sb = new StringBuilder();\n\t\tsb.append(getClass().getSimpleName());\n\t\tsb.append(\"(\");\n\t\tsb.append(\"state=\");\n\t\tsb.append(getState().toString());\n\t\tif (getValueType() != null)\n\t\t{\n\t\t\tsb.append(\", type=\").append(getValueType().getCanonicalName());\n\t\t}\n\t\tif (childCount() == 1)\n\t\t{\n\t\t\tsb.append(\", \").append(childCount()).append(\" child\");\n\t\t}\n\t\telse if (childCount() > 1)\n\t\t{\n\t\t\tsb.append(\", \").append(childCount()).append(\" children\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsb.append(\", no children\");\n\t\t}\n\t\tif (!getCategories().isEmpty())\n\t\t{\n\t\t\tsb.append(\", categorized as \").append(getCategories());\n\t\t}\n\t\tsb.append(\", accessed via \").append(accessor);\n\t\tsb.append(')');\n\t\treturn sb.toString();\n\t}\n\n\tpublic void addCategories(final Collection<String> additionalCategories)\n\t{\n\t\tAssert.notNull(additionalCategories, \"additionalCategories\");\n\t\tthis.additionalCategories.addAll(additionalCategories);\n\t}\n\n\n\tpublic NodePath getCircleStartPath()\n\t{\n\t\treturn circleStartPath;\n\t}\n\n\tpublic void setCircleStartPath(final NodePath circularStartPath)\n\t{\n\t\tthis.circleStartPath = circularStartPath;\n\t}\n\n\tpublic DiffNode getCircleStartNode()\n\t{\n\t\treturn circleStartNode;\n\t}\n\n\tpublic void setCircleStartNode(final DiffNode circleStartNode)\n\t{\n\t\tthis.circleStartNode = circleStartNode;\n\t}\n\n\n\tpublic enum State\n\t{\n\t\tADDED(\"The value has been added to the working object\"),\n\t\tCHANGED(\"The value exists but differs between the base and working object\"),\n\t\tREMOVED(\"The value has been removed from the working object\"),\n\t\tUNTOUCHED(\"The value is identical in the working and base object\"),\n\t\tCIRCULAR(\"Special state to mark circular references\"),\n\t\tIGNORED(\"The value has not been looked at and has been ignored\"),\n\t\tINACCESSIBLE(\"When a comparison was not possible because the underlying value was not accessible\");\n\n\t\tprivate final String reason;\n\n\t\tState(final String reason)\n\t\t{\n\t\t\tthis.reason = reason;\n\t\t}\n\n\t\tpublic String getReason()\n\t\t{\n\t\t\treturn reason;\n\t\t}\n\t}\n\n\n\tpublic interface Visitor\n\t{\n\t\tvoid node(DiffNode node, Visit visit);\n\t}\n}\n\n'java-object-diff/src/integration-test/java/de/danielbechler/diff/example/CanonicalAccessorExample.java'\n:\n\npackage de.danielbechler.diff.example;\n\nimport de.danielbechler.diff.ObjectDifferBuilder;\nimport de.danielbechler.diff.node.DiffNode;\nimport de.danielbechler.diff.node.NodeHierarchyVisitor;\nimport de.danielbechler.diff.selector.CollectionItemElementSelector;\n\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport static java.util.Arrays.asList;\n\n\nclass CanonicalAccessorExample\n{\n\tprivate CanonicalAccessorExample()\n\t{\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(final String[] args)\n\t{\n\t\tfinal AddressBook workingAddressBook = new AddressBook();\n\t\tfinal Contact workingContact = new Contact(\"Walter White\", \"Heisenberg\");\n\t\tworkingAddressBook.setContacts(asList(workingContact));\n\n\t\tfinal AddressBook baseAddressBook = new AddressBook();\n\t\tfinal Contact baseContact = new Contact(\"Walter White\");\n\t\tbaseAddressBook.setContacts(asList(baseContact));\n\n\t\tfinal DiffNode rootNode = ObjectDifferBuilder.buildDefault()\n\t\t\t\t.compare(workingAddressBook, baseAddressBook);\n\t\tfinal DiffNode contactsNode = rootNode.getChild(\"contacts\");\n\t\tfinal DiffNode contactNode = contactsNode.getChild(new CollectionItemElementSelector(baseContact));\n\t\tfinal DiffNode nicknameNode = contactNode.getChild(\"nickname\");\n\n\t\trootNode.visit(new NodeHierarchyVisitor());\n\n\n\n\t\tfinal AddressBook addressBook = (AddressBook) rootNode.get(workingAddressBook);\n\t\tfinal List<Contact> contacts = (List<Contact>) contactsNode.get(addressBook);\n\t\tfinal Contact contact = (Contact) contactNode.get(contacts);\n\n\t\tassert rootNode.get(workingAddressBook) == rootNode.canonicalGet(workingAddressBook);\n\t\tassert contactsNode.get(addressBook) == contactsNode.canonicalGet(workingAddressBook);\n\t\tassert contactNode.get(contacts) == contactNode.canonicalGet(workingAddressBook);\n\t\tassert nicknameNode.get(contact) == nicknameNode.canonicalGet(workingAddressBook);\n\t}\n\n\tpublic static class AddressBook\n\t{\n\t\tprivate List<Contact> contacts = new LinkedList<Contact>();\n\n\t\tpublic List<Contact> getContacts()\n\t\t{\n\t\t\treturn contacts;\n\t\t}\n\n\t\tpublic void setContacts(final List<Contact> contacts)\n\t\t{\n\t\t\tthis.contacts = contacts;\n\t\t}\n\t}\n\n\tpublic static class Contact\n\t{\n\t\tprivate final String name;\n\t\tprivate String nickname;\n\n\t\tpublic Contact(final String name)\n\t\t{\n\t\t\tthis.name = name;\n\t\t}\n\n\t\tpublic Contact(final String name, final String nickname)\n\t\t{\n\t\t\tthis.name = name;\n\t\t\tthis.nickname = nickname;\n\t\t}\n\n\t\tpublic String getName()\n\t\t{\n\t\t\treturn name;\n\t\t}\n\n\t\tpublic String getNickname()\n\t\t{\n\t\t\treturn nickname;\n\t\t}\n\n\t\tpublic void setNickname(final String nickname)\n\t\t{\n\t\t\tthis.nickname = nickname;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(final Object o)\n\t\t{\n\t\t\tif (this == o)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!(o instanceof Contact))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfinal Contact contact = (Contact) o;\n\n\t\t\tif (name != null ? !name.equals(contact.name) : contact.name != null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode()\n\t\t{\n\t\t\treturn name != null ? name.hashCode() : 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString()\n\t\t{\n\t\t\tfinal StringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"Contact\");\n\t\t\tsb.append(\"{name='\").append(name).append('\\'');\n\t\t\tsb.append('}');\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n}\n\n'java-object-diff/src/main/java/de/danielbechler/util/Collections.java'\n:\n\npackage de.danielbechler.util;\n\nimport java.util.*;\n\n\npublic class Collections\n{\n\tprivate Collections()\n\t{\n\t}\n\n\n\n\n\n\n\tpublic static <T> Set<T> setOf(final Collection<T> c)\n\t{\n\t\treturn new LinkedHashSet<T>(c);\n\t}\n\n\tpublic static boolean isEmpty(final Collection<?> c)\n\t{\n\t\treturn c == null || c.isEmpty();\n\t}\n\n\tpublic static <T> boolean containsAny(final Iterable<T> haystack, final Iterable<T> needles)\n\t{\n\t\tif (haystack == null || needles == null)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tfor (final T straw : haystack)\n\t\t{\n\t\t\tfor (final T needle : needles)\n\t\t\t{\n\t\t\t\tif (straw.equals(needle))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tpublic static <T> Collection<? extends T> filteredCopyOf(final Collection<? extends T> source,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t final Collection<? extends T> filter)\n\t{\n\t\tfinal Collection<T> copy;\n\t\tif (source != null)\n\t\t{\n\t\t\tcopy = new LinkedList<T>(source);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcopy = new LinkedList<T>();\n\t\t}\n\t\tif (filter != null)\n\t\t{\n\t\t\tcopy.removeAll(new ArrayList<T>(filter));\n\t\t}\n\t\treturn copy;\n\t}\n\n\n\n\n\n\n\n\n\n\tpublic static <T> T firstElementOf(final Collection<? extends T> items)\n\t{\n\t\tif (items != null && !items.isEmpty())\n\t\t{\n\t\t\treturn items.iterator().next();\n\t\t}\n\t\treturn null;\n\t}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n}\n",
        "gt": [
            "'java-object-diff/src/main/java/de/danielbechler/util/Collections.java'",
            "'java-object-diff/src/main/java/de/danielbechler/diff/node/DiffNode.java'",
            "'java-object-diff/src/integration-test/java/de/danielbechler/diff/example/CanonicalAccessorExample.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/Writer.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/Writer.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.netflix.iceberg.AppendFiles;\nimport com.netflix.iceberg.DataFile;\nimport com.netflix.iceberg.DataFiles;\nimport com.netflix.iceberg.FileFormat;\nimport com.netflix.iceberg.Metrics;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.Table;\nimport com.netflix.iceberg.TableProperties;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.exceptions.RuntimeIOException;\nimport com.netflix.iceberg.hadoop.HadoopInputFile;\nimport com.netflix.iceberg.hadoop.HadoopOutputFile;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.io.InputFile;\nimport com.netflix.iceberg.io.OutputFile;\nimport com.netflix.iceberg.orc.ORC;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.spark.data.SparkAvroWriter;\nimport com.netflix.iceberg.spark.data.SparkOrcWriter;\nimport com.netflix.iceberg.transforms.Transform;\nimport com.netflix.iceberg.transforms.Transforms;\nimport com.netflix.iceberg.types.Types.StringType;\nimport com.netflix.iceberg.util.Tasks;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.spark.sql.catalyst.InternalRow;\nimport org.apache.spark.sql.execution.datasources.parquet.ParquetWriteSupport;\nimport org.apache.spark.sql.sources.v2.writer.DataSourceWriter;\nimport org.apache.spark.sql.sources.v2.writer.DataWriter;\nimport org.apache.spark.sql.sources.v2.writer.DataWriterFactory;\nimport org.apache.spark.sql.sources.v2.writer.SupportsWriteInternalRow;\nimport org.apache.spark.sql.sources.v2.writer.WriterCommitMessage;\nimport org.apache.spark.util.SerializableConfiguration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.function.Function;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Iterables.transform;\nimport static com.netflix.iceberg.TableProperties.COMMIT_MAX_RETRY_WAIT_MS;\nimport static com.netflix.iceberg.TableProperties.COMMIT_MAX_RETRY_WAIT_MS_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.COMMIT_MIN_RETRY_WAIT_MS;\nimport static com.netflix.iceberg.TableProperties.COMMIT_MIN_RETRY_WAIT_MS_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.COMMIT_NUM_RETRIES;\nimport static com.netflix.iceberg.TableProperties.COMMIT_NUM_RETRIES_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.COMMIT_TOTAL_RETRY_TIME_MS;\nimport static com.netflix.iceberg.TableProperties.COMMIT_TOTAL_RETRY_TIME_MS_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.OBJECT_STORE_ENABLED;\nimport static com.netflix.iceberg.TableProperties.OBJECT_STORE_ENABLED_DEFAULT;\nimport static com.netflix.iceberg.TableProperties.OBJECT_STORE_PATH;\nimport static com.netflix.iceberg.spark.SparkSchemaUtil.convert;\n\n\nclass Writer implements DataSourceWriter, SupportsWriteInternalRow {\n  private static final Transform<String, Integer> HASH_FUNC = Transforms\n      .bucket(StringType.get(), Integer.MAX_VALUE);\n  private static final Logger LOG = LoggerFactory.getLogger(Writer.class);\n\n  private final Table table;\n  private final Configuration conf;\n  private final FileFormat format;\n\n  Writer(Table table, Configuration conf, FileFormat format) {\n    this.table = table;\n    this.conf = conf;\n    this.format = format;\n  }\n\n  @Override\n  public DataWriterFactory<InternalRow> createInternalRowWriterFactory() {\n    return new WriterFactory(table.spec(), format, dataLocation(), table.properties(), conf);\n  }\n\n  @Override\n  public void commit(WriterCommitMessage[] messages) {\n    AppendFiles append = table.newAppend();\n\n    int numFiles = 0;\n    for (DataFile file : files(messages)) {\n      numFiles += 1;\n      append.appendFile(file);\n    }\n\n    LOG.info(\"Appending {} files to {}\", numFiles, table);\n    long start = System.currentTimeMillis();\n    append.commit();\n    long duration = System.currentTimeMillis() - start;\n    LOG.info(\"Committed in {} ms\", duration);\n  }\n\n  @Override\n  public void abort(WriterCommitMessage[] messages) {\n    FileSystem fs;\n    try {\n      fs = new Path(table.location()).getFileSystem(conf);\n    } catch (IOException e) {\n      throw new RuntimeIOException(e);\n    }\n\n    Tasks.foreach(files(messages))\n        .retry(propertyAsInt(COMMIT_NUM_RETRIES, COMMIT_NUM_RETRIES_DEFAULT))\n        .exponentialBackoff(\n            propertyAsInt(COMMIT_MIN_RETRY_WAIT_MS, COMMIT_MIN_RETRY_WAIT_MS_DEFAULT),\n            propertyAsInt(COMMIT_MAX_RETRY_WAIT_MS, COMMIT_MAX_RETRY_WAIT_MS_DEFAULT),\n            propertyAsInt(COMMIT_TOTAL_RETRY_TIME_MS, COMMIT_TOTAL_RETRY_TIME_MS_DEFAULT),\n            2.0  )\n        .throwFailureWhenFinished()\n        .run(file -> {\n          try {\n            fs.delete(new Path(file.path().toString()), false  );\n          } catch (IOException e) {\n            throw new RuntimeIOException(e);\n          }\n        });\n  }\n\n  private Iterable<DataFile> files(WriterCommitMessage[] messages) {\n    if (messages.length > 0) {\n      return concat(transform(Arrays.asList(messages), message -> message != null\n          ? ImmutableList.copyOf(((TaskCommit) message).files())\n          : ImmutableList.of()));\n    }\n    return ImmutableList.of();\n  }\n\n  private int propertyAsInt(String property, int defaultValue) {\n    Map<String, String> properties = table.properties();\n    String value = properties.get(property);\n    if (value != null) {\n      return Integer.parseInt(properties.get(property));\n    }\n    return defaultValue;\n  }\n\n  private String dataLocation() {\n    return table.properties().getOrDefault(\n        TableProperties.WRITE_NEW_DATA_LOCATION,\n        new Path(new Path(table.location()), \"data\").toString());\n  }\n\n  @Override\n  public String toString() {\n    return String.format(\"IcebergWrite(table=%s, type=%s, format=%s)\",\n        table, table.schema().asStruct(), format);\n  }\n\n\n  private static class TaskCommit implements WriterCommitMessage {\n    private final DataFile[] files;\n\n    TaskCommit() {\n      this.files = new DataFile[0];\n    }\n\n    TaskCommit(DataFile file) {\n      this.files = new DataFile[] { file };\n    }\n\n    TaskCommit(List<DataFile> files) {\n      this.files = files.toArray(new DataFile[files.size()]);\n    }\n\n    DataFile[] files() {\n      return files;\n    }\n  }\n\n  private static class WriterFactory implements DataWriterFactory<InternalRow> {\n    private final PartitionSpec spec;\n    private final FileFormat format;\n    private final String dataLocation;\n    private final Map<String, String> properties;\n    private final SerializableConfiguration conf;\n    private final String uuid = UUID.randomUUID().toString();\n\n    private transient Path dataPath = null;\n\n    WriterFactory(PartitionSpec spec, FileFormat format, String dataLocation,\n                  Map<String, String> properties, Configuration conf) {\n      this.spec = spec;\n      this.format = format;\n      this.dataLocation = dataLocation;\n      this.properties = properties;\n      this.conf = new SerializableConfiguration(conf);\n    }\n\n    @Override\n    public DataWriter<InternalRow> createDataWriter(int partitionId, int attemptNumber) {\n      String filename = format.addExtension(String.format(\"%05d-%d-%s\",\n          partitionId, attemptNumber, uuid));\n      AppenderFactory<InternalRow> factory = new SparkAppenderFactory();\n      if (spec.fields().isEmpty()) {\n        return new UnpartitionedWriter(lazyDataPath(), filename, format, conf.value(), factory);\n\n      } else {\n        Path baseDataPath = lazyDataPath();\n        Function<PartitionKey, Path> outputPathFunc = key ->\n            new Path(new Path(baseDataPath, key.toPath()), filename);\n\n        boolean useObjectStorage = (\n            Boolean.parseBoolean(properties.get(OBJECT_STORE_ENABLED)) ||\n            OBJECT_STORE_ENABLED_DEFAULT\n        );\n\n        if (useObjectStorage) {\n\n          String context = pathContext(baseDataPath);\n          String objectStore = properties.get(OBJECT_STORE_PATH);\n          Preconditions.checkNotNull(objectStore,\n              \"Cannot use object storage, missing location: \" + OBJECT_STORE_PATH);\n          Path objectStorePath = new Path(objectStore);\n\n          outputPathFunc = key -> {\n            String partitionAndFilename = key.toPath() + \"/\" + filename;\n            int hash = HASH_FUNC.apply(partitionAndFilename);\n            return new Path(objectStorePath,\n                String.format(\"%08x/%s/%s\", hash, context, partitionAndFilename));\n          };\n        }\n\n        return new PartitionedWriter(spec, format, conf.value(), factory, outputPathFunc);\n      }\n    }\n\n    private static String pathContext(Path dataPath) {\n      Path parent = dataPath.getParent();\n      if (parent != null) {\n\n        if (dataPath.getName().equals(\"data\")) {\n          return pathContext(parent);\n        }\n\n        return parent.getName() + \"/\" + dataPath.getName();\n      }\n\n      return dataPath.getName();\n    }\n\n    private Path lazyDataPath() {\n      if (dataPath == null) {\n        this.dataPath = new Path(dataLocation);\n      }\n      return dataPath;\n    }\n\n    private class SparkAppenderFactory implements AppenderFactory<InternalRow> {\n      public FileAppender<InternalRow> newAppender(OutputFile file, FileFormat format) {\n        Schema schema = spec.schema();\n        try {\n          switch (format) {\n            case PARQUET:\n              String jsonSchema = convert(schema).json();\n              return Parquet.write(file)\n                  .writeSupport(new ParquetWriteSupport())\n                  .set(\"org.apache.spark.sql.parquet.row.attributes\", jsonSchema)\n                  .set(\"spark.sql.parquet.writeLegacyFormat\", \"false\")\n                  .set(\"spark.sql.parquet.binaryAsString\", \"false\")\n                  .set(\"spark.sql.parquet.int96AsTimestamp\", \"false\")\n                  .set(\"spark.sql.parquet.outputTimestampType\", \"TIMESTAMP_MICROS\")\n                  .setAll(properties)\n                  .schema(schema)\n                  .build();\n\n            case AVRO:\n              return Avro.write(file)\n                  .createWriterFunc(ignored -> new SparkAvroWriter(schema))\n                  .setAll(properties)\n                  .schema(schema)\n                  .build();\n\n            case ORC: {\n              @SuppressWarnings(\"unchecked\")\n              SparkOrcWriter writer = new SparkOrcWriter(ORC.write(file)\n                  .schema(schema)\n                  .build());\n              return writer;\n            }\n            default:\n              throw new UnsupportedOperationException(\"Cannot write unknown format: \" + format);\n          }\n        } catch (IOException e) {\n          throw new RuntimeIOException(e);\n        }\n      }\n    }\n  }\n\n  private interface AppenderFactory<T> {\n    FileAppender<T> newAppender(OutputFile file, FileFormat format);\n  }\n\n  private static class UnpartitionedWriter implements DataWriter<InternalRow>, Closeable {\n    private final Path file;\n    private final Configuration conf;\n    private FileAppender<InternalRow> appender = null;\n    private Metrics metrics = null;\n\n    UnpartitionedWriter(Path dataPath, String filename, FileFormat format,\n                        Configuration conf, AppenderFactory<InternalRow> factory) {\n      this.file = new Path(dataPath, filename);\n      this.appender = factory.newAppender(HadoopOutputFile.fromPath(file, conf), format);\n      this.conf = conf;\n    }\n\n    @Override\n    public void write(InternalRow record) {\n      appender.add(record);\n    }\n\n    @Override\n    public WriterCommitMessage commit() throws IOException {\n      Preconditions.checkArgument(appender != null, \"Commit called on a closed writer: %s\", this);\n\n      close();\n\n      if (metrics.recordCount() == 0L) {\n        FileSystem fs = file.getFileSystem(conf);\n        fs.delete(file, false);\n        return new TaskCommit();\n      }\n\n      InputFile inFile = HadoopInputFile.fromPath(file, conf);\n      DataFile dataFile = DataFiles.fromInputFile(inFile, null, metrics);\n\n      return new TaskCommit(dataFile);\n    }\n\n    @Override\n    public void abort() throws IOException {\n      Preconditions.checkArgument(appender != null, \"Abort called on a closed writer: %s\", this);\n\n      close();\n\n      FileSystem fs = file.getFileSystem(conf);\n      fs.delete(file, false);\n    }\n\n    @Override\n    public void close() throws IOException {\n      if (this.appender != null) {\n        this.appender.close();\n        this.metrics = appender.metrics();\n        this.appender = null;\n      }\n    }\n  }\n\n  private static class PartitionedWriter implements DataWriter<InternalRow> {\n    private final Set<PartitionKey> completedPartitions = Sets.newHashSet();\n    private final List<DataFile> completedFiles = Lists.newArrayList();\n    private final PartitionSpec spec;\n    private final FileFormat format;\n    private final Configuration conf;\n    private final AppenderFactory<InternalRow> factory;\n    private final Function<PartitionKey, Path> outputPathFunc;\n    private final PartitionKey key;\n\n    private PartitionKey currentKey = null;\n    private FileAppender<InternalRow> currentAppender = null;\n    private Path currentPath = null;\n\n    PartitionedWriter(PartitionSpec spec, FileFormat format, Configuration conf,\n                      AppenderFactory<InternalRow> factory,\n                      Function<PartitionKey, Path> outputPathFunc) {\n      this.spec = spec;\n      this.format = format;\n      this.conf = conf;\n      this.factory = factory;\n      this.outputPathFunc = outputPathFunc;\n      this.key = new PartitionKey(spec);\n    }\n\n    @Override\n    public void write(InternalRow row) throws IOException {\n      key.partition(row);\n\n      if (!key.equals(currentKey)) {\n        closeCurrent();\n\n        if (completedPartitions.contains(key)) {\n\n          PartitionKey existingKey = Iterables.find(completedPartitions, key::equals, null);\n          LOG.warn(\"Duplicate key: {} == {}\", existingKey, key);\n          throw new IllegalStateException(\"Already closed file for partition: \" + key.toPath());\n        }\n\n        this.currentKey = key.copy();\n        this.currentPath = outputPathFunc.apply(currentKey);\n        OutputFile file = HadoopOutputFile.fromPath(currentPath, conf);\n        this.currentAppender = factory.newAppender(file, format);\n      }\n\n      currentAppender.add(row);\n    }\n\n    @Override\n    public WriterCommitMessage commit() throws IOException {\n      closeCurrent();\n      return new TaskCommit(completedFiles);\n    }\n\n    @Override\n    public void abort() throws IOException {\n      FileSystem fs = currentPath.getFileSystem(conf);\n\n\n      Tasks.foreach(completedFiles)\n          .throwFailureWhenFinished()\n          .noRetry()\n          .run(file -> fs.delete(new Path(file.path().toString())), IOException.class);\n\n      if (currentAppender != null) {\n        currentAppender.close();\n        this.currentAppender = null;\n        fs.delete(currentPath);\n      }\n    }\n\n    private void closeCurrent() throws IOException {\n      if (currentAppender != null) {\n        currentAppender.close();\n\n        Metrics metrics = currentAppender.metrics();\n        this.currentAppender = null;\n\n        InputFile inFile = HadoopInputFile.fromPath(currentPath, conf);\n        DataFile dataFile = DataFiles.builder(spec)\n            .withInputFile(inFile)\n            .withPartition(currentKey)\n            .withMetrics(metrics)\n            .build();\n\n        completedPartitions.add(currentKey);\n        completedFiles.add(dataFile);\n      }\n    }\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/source/Writer.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/BuildAvroProjection.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/avro/BuildAvroProjection.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Supplier;\n\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.convert;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.copyField;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.copyRecord;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.fromOption;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.fromOptions;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.getFieldId;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.isKeyValueSchema;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.isOptionSchema;\nimport static com.netflix.iceberg.avro.AvroSchemaUtil.toOption;\n\n\nclass BuildAvroProjection extends AvroCustomOrderSchemaVisitor<Schema, Schema.Field> {\n  private final Map<String, String> renames;\n  private Type current = null;\n\n  BuildAvroProjection(com.netflix.iceberg.Schema expectedSchema, Map<String, String> renames) {\n    this.renames = renames;\n    this.current = expectedSchema.asStruct();\n  }\n\n  @Override\n  public Schema record(Schema record, List<String> names, Iterable<Schema.Field> schemaIterable) {\n    Preconditions.checkArgument(\n        current.isNestedType() && current.asNestedType().isStructType(),\n        \"Cannot project non-struct: %s\", current);\n\n    Types.StructType struct = current.asNestedType().asStructType();\n\n    boolean hasChange = false;\n    List<Schema.Field> fields = record.getFields();\n    List<Schema.Field> fieldResults = Lists.newArrayList(schemaIterable);\n\n    Map<String, Schema.Field> updateMap = Maps.newHashMap();\n    for (int i = 0; i < fields.size(); i += 1) {\n      Schema.Field field = fields.get(i);\n      Schema.Field updatedField = fieldResults.get(i);\n\n      if (updatedField != null) {\n        updateMap.put(updatedField.name(), updatedField);\n\n        if (!updatedField.schema().equals(field.schema()) ||\n            !updatedField.name().equals(field.name())) {\n          hasChange = true;\n        }\n      } else {\n        hasChange = true;\n      }\n    }\n\n\n    List<Schema.Field> updatedFields = Lists.newArrayListWithExpectedSize(struct.fields().size());\n    List<Types.NestedField> expectedFields = struct.fields();\n    for (int i = 0; i < expectedFields.size(); i += 1) {\n      Types.NestedField field = expectedFields.get(i);\n\n\n      if (i < fields.size() && !field.name().equals(fields.get(i).name())) {\n        hasChange = true;\n      }\n\n      Schema.Field avroField = updateMap.get(field.name());\n\n      if (avroField != null) {\n        updatedFields.add(avroField);\n\n      } else {\n        Preconditions.checkArgument(field.isOptional(), \"Missing required field: %s\", field.name());\n\n        Schema.Field newField = new Schema.Field(\n            field.name(), toOption(convert(field.type())), null, JsonProperties.NULL_VALUE);\n        newField.addProp(AvroSchemaUtil.FIELD_ID_PROP, field.fieldId());\n        updatedFields.add(newField);\n        hasChange = true;\n      }\n    }\n\n    if (hasChange || renames.containsKey(record.getFullName())) {\n      return copyRecord(record, updatedFields, renames.get(record.getFullName()));\n    }\n\n    return record;\n  }\n\n  @Override\n  public Schema.Field field(Schema.Field field, Supplier<Schema> fieldResult) {\n    Types.StructType struct = current.asNestedType().asStructType();\n    int fieldId = AvroSchemaUtil.getFieldId(field);\n    Types.NestedField expectedField = struct.field(fieldId);\n\n\n    if (expectedField == null) {\n      return null;\n    }\n\n    String expectedName = expectedField.name();\n\n    this.current = expectedField.type();\n    try {\n      Schema schema = fieldResult.get();\n\n      if (schema != field.schema() || !expectedName.equals(field.name())) {\n\n        return copyField(field, schema, expectedName);\n      } else {\n\n        return copyField(field, field.schema(), field.name());\n      }\n\n    } finally {\n      this.current = struct;\n    }\n  }\n\n  @Override\n  public Schema union(Schema union, Iterable<Schema> options) {\n    Preconditions.checkState(isOptionSchema(union),\n        \"Invalid schema: non-option unions are not supported: {}\", union);\n    Schema nonNullOriginal = fromOption(union);\n    Schema nonNullResult = fromOptions(Lists.newArrayList(options));\n\n    if (nonNullOriginal != nonNullResult) {\n      return toOption(nonNullResult);\n    }\n\n    return union;\n  }\n\n  @Override\n  public Schema array(Schema array, Supplier<Schema> element) {\n    if (array.getLogicalType() instanceof LogicalMap ||\n        (current.isMapType() && isKeyValueSchema(array.getElementType()))) {\n      Preconditions.checkArgument(current.isMapType(), \"Incompatible projected type: %s\", current);\n      Types.MapType m = current.asNestedType().asMapType();\n      this.current = Types.StructType.of(m.fields());\n      try {\n        Schema keyValueSchema = array.getElementType();\n        Schema.Field keyField = keyValueSchema.getFields().get(0);\n        Schema.Field valueField = keyValueSchema.getFields().get(1);\n        Schema.Field valueProjection = element.get().getField(\"value\");\n\n\n        if (valueProjection.schema() != valueField.schema()) {\n          return AvroSchemaUtil.createProjectionMap(keyValueSchema.getFullName(),\n              getFieldId(keyField), keyField.name(), keyField.schema(),\n              getFieldId(valueField), valueField.name(), valueProjection.schema());\n        } else if (!(array.getLogicalType() instanceof LogicalMap)) {\n          return AvroSchemaUtil.createProjectionMap(keyValueSchema.getFullName(),\n              getFieldId(keyField), keyField.name(), keyField.schema(),\n              getFieldId(valueField), valueField.name(), valueField.schema());\n        }\n\n        return array;\n\n      } finally {\n        this.current = m;\n      }\n\n    } else {\n      Preconditions.checkArgument(current.isListType(),\n          \"Incompatible projected type: %s\", current);\n      Types.ListType list = current.asNestedType().asListType();\n      this.current = list.elementType();\n      try {\n        Schema elementSchema = element.get();\n\n\n        if (elementSchema != array.getElementType()) {\n          return Schema.createArray(elementSchema);\n        }\n\n        return array;\n\n      } finally {\n        this.current = list;\n      }\n    }\n  }\n\n  @Override\n  public Schema map(Schema map, Supplier<Schema> value) {\n    Preconditions.checkArgument(current.isNestedType() && current.asNestedType().isMapType(),\n        \"Incompatible projected type: %s\", current);\n    Types.MapType m = current.asNestedType().asMapType();\n    Preconditions.checkArgument(m.keyType() == Types.StringType.get(),\n        \"Incompatible projected type: key type %s is not string\", m.keyType());\n    this.current = m.valueType();\n    try {\n      Schema valueSchema = value.get();\n\n\n      if (valueSchema != map.getValueType()) {\n        return Schema.createMap(valueSchema);\n      }\n\n      return map;\n\n    } finally {\n      this.current = m;\n    }\n  }\n\n  @Override\n  public Schema primitive(Schema primitive) {\n\n    switch (primitive.getType()) {\n      case INT:\n        if (current.typeId() == Type.TypeID.LONG) {\n          return Schema.create(Schema.Type.LONG);\n        }\n        return primitive;\n\n      case FLOAT:\n        if (current.typeId() == Type.TypeID.DOUBLE) {\n          return Schema.create(Schema.Type.DOUBLE);\n        }\n        return primitive;\n\n      default:\n        return primitive;\n    }\n  }\n\n}\n\n'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.avro;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.LogicalTypes;\nimport org.apache.avro.Schema;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport static org.apache.avro.Schema.Type.ARRAY;\nimport static org.apache.avro.Schema.Type.MAP;\nimport static org.apache.avro.Schema.Type.RECORD;\nimport static org.apache.avro.Schema.Type.UNION;\n\npublic class AvroSchemaUtil {\n  public static final String FIELD_ID_PROP = \"field-id\";\n  public static final String KEY_ID_PROP = \"key-id\";\n  public static final String VALUE_ID_PROP = \"value-id\";\n  public static final String ELEMENT_ID_PROP = \"element-id\";\n  public static final String ADJUST_TO_UTC_PROP = \"adjust-to-utc\";\n\n  private static final Schema NULL = Schema.create(Schema.Type.NULL);\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               String tableName) {\n    return convert(schema, ImmutableMap.of(schema.asStruct(), tableName));\n  }\n\n  public static Schema convert(com.netflix.iceberg.Schema schema,\n                               Map<Types.StructType, String> names) {\n    return TypeUtil.visit(schema, new TypeToSchema(names));\n  }\n\n  public static Schema convert(Type type) {\n    return convert(type, ImmutableMap.of());\n  }\n\n  public static Schema convert(Types.StructType type, String name) {\n    return convert(type, ImmutableMap.of(type, name));\n  }\n\n  public static Schema convert(Type type, Map<Types.StructType, String> names) {\n    return TypeUtil.visit(type, new TypeToSchema(names));\n  }\n\n  public static Type convert(Schema schema) {\n    return AvroSchemaVisitor.visit(schema, new SchemaToType(schema));\n  }\n\n  public static Map<Type, Schema> convertTypes(Types.StructType type, String name) {\n    TypeToSchema converter = new TypeToSchema(ImmutableMap.of(type, name));\n    TypeUtil.visit(type, converter);\n    return ImmutableMap.copyOf(converter.getConversionMap());\n  }\n\n  public static Schema pruneColumns(Schema schema, Set<Integer> selectedIds) {\n    return new PruneColumns(selectedIds).rootSchema(schema);\n  }\n\n  public static Schema buildAvroProjection(Schema schema, com.netflix.iceberg.Schema expected,\n                                           Map<String, String> renames) {\n    return AvroCustomOrderSchemaVisitor.visit(schema, new BuildAvroProjection(expected, renames));\n  }\n\n  public static boolean isTimestamptz(Schema schema) {\n    LogicalType logicalType = schema.getLogicalType();\n    if (logicalType != null && logicalType instanceof LogicalTypes.TimestampMicros) {\n\n      Object value = schema.getObjectProp(ADJUST_TO_UTC_PROP);\n      if (value instanceof Boolean) {\n        return (Boolean) value;\n      } else if (value instanceof String) {\n        return Boolean.parseBoolean((String) value);\n      }\n    }\n\n    return false;\n  }\n\n  static boolean isOptionSchema(Schema schema) {\n    if (schema.getType() == UNION && schema.getTypes().size() == 2) {\n      if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n        return true;\n      } else if (schema.getTypes().get(1).getType() == Schema.Type.NULL) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  static Schema toOption(Schema schema) {\n    if (schema.getType() == UNION) {\n      Preconditions.checkArgument(isOptionSchema(schema),\n          \"Union schemas are not supported: \" + schema);\n      return schema;\n    } else {\n      return Schema.createUnion(NULL, schema);\n    }\n  }\n\n  static Schema fromOption(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == UNION,\n        \"Expected union schema but was passed: {}\", schema);\n    Preconditions.checkArgument(schema.getTypes().size() == 2,\n        \"Expected optional schema, but was passed: {}\", schema);\n    if (schema.getTypes().get(0).getType() == Schema.Type.NULL) {\n      return schema.getTypes().get(1);\n    } else {\n      return schema.getTypes().get(0);\n    }\n  }\n\n  static Schema fromOptions(List<Schema> options) {\n    Preconditions.checkArgument(options.size() == 2,\n        \"Expected two schemas, but was passed: {} options\", options.size());\n    if (options.get(0).getType() == Schema.Type.NULL) {\n      return options.get(1);\n    } else {\n      return options.get(0);\n    }\n  }\n\n  static boolean isKeyValueSchema(Schema schema) {\n    return (schema.getType() == RECORD && schema.getFields().size() == 2);\n  }\n\n  static Schema createMap(int keyId, Schema keySchema,\n                          int valueId, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n\n    return LogicalMap.get().addToSchema(Schema.createArray(Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField))));\n  }\n\n  static Schema createProjectionMap(String recordName,\n                          int keyId, String keyName, Schema keySchema,\n                          int valueId, String valueName, Schema valueSchema) {\n    String keyValueName = \"k\" + keyId + \"_v\" + valueId;\n\n    Schema.Field keyField = new Schema.Field(\"key\", keySchema, null, null);\n    if (!\"key\".equals(keyName)) {\n      keyField.addAlias(keyName);\n    }\n    keyField.addProp(FIELD_ID_PROP, keyId);\n\n    Schema.Field valueField = new Schema.Field(\"value\", valueSchema, null,\n        isOptionSchema(valueSchema) ? JsonProperties.NULL_VALUE: null);\n    valueField.addProp(FIELD_ID_PROP, valueId);\n    if (!\"value\".equals(valueName)) {\n      valueField.addAlias(valueName);\n    }\n\n    Schema keyValueRecord = Schema.createRecord(\n        keyValueName, null, null, false, ImmutableList.of(keyField, valueField));\n    if (!keyValueName.equals(recordName)) {\n      keyValueRecord.addAlias(recordName);\n    }\n\n    return LogicalMap.get().addToSchema(Schema.createArray(keyValueRecord));\n  }\n\n  private static int getId(Schema schema, String propertyName) {\n    if (schema.getType() == UNION) {\n      return getId(fromOption(schema), propertyName);\n    }\n\n    Object id = schema.getObjectProp(propertyName);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", propertyName);\n\n    return toInt(id);\n  }\n\n  public static int getKeyId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map key id for non-map schema: \" + schema);\n    return getId(schema, KEY_ID_PROP);\n  }\n\n  public static int getValueId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == MAP,\n        \"Cannot get map value id for non-map schema: \" + schema);\n    return getId(schema, VALUE_ID_PROP);\n  }\n\n  public static int getElementId(Schema schema) {\n    Preconditions.checkArgument(schema.getType() == ARRAY,\n        \"Cannot get array element id for non-array schema: \" + schema);\n    return getId(schema, ELEMENT_ID_PROP);\n  }\n\n  public static int getFieldId(Schema.Field field) {\n    Object id = field.getObjectProp(FIELD_ID_PROP);\n    Preconditions.checkNotNull(id, \"Missing expected '%s' property\", FIELD_ID_PROP);\n\n    return toInt(id);\n  }\n\n  private static int toInt(Object value) {\n    if (value instanceof Number) {\n      return ((Number) value).intValue();\n    } else if (value instanceof String) {\n      return Integer.parseInt((String) value);\n    }\n\n    throw new UnsupportedOperationException(\"Cannot coerce value to int: \" + value);\n  }\n\n  static Schema copyRecord(Schema record, List<Schema.Field> newFields, String newName) {\n    Schema copy;\n    if (newName != null) {\n      copy = Schema.createRecord(newName, record.getDoc(), null, record.isError(), newFields);\n\n\n\n      copy.addAlias(record.getName(), record.getNamespace() == null ? \"\" : record.getNamespace());\n    } else {\n      copy = Schema.createRecord(record.getName(),\n          record.getDoc(), record.getNamespace(), record.isError(), newFields);\n    }\n\n    for (Map.Entry<String, Object> prop : record.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    return copy;\n  }\n\n  static Schema.Field copyField(Schema.Field field, Schema newSchema, String newName) {\n    Schema.Field copy = new Schema.Field(newName,\n        newSchema, field.doc(), field.defaultVal(), field.order());\n\n    for (Map.Entry<String, Object> prop : field.getObjectProps().entrySet()) {\n      copy.addProp(prop.getKey(), prop.getValue());\n    }\n\n    if (!newName.equals(field.name())) {\n      copy.addAlias(field.name());\n    }\n\n    return copy;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.types.ArrayType$;\nimport org.apache.spark.sql.types.BinaryType$;\nimport org.apache.spark.sql.types.BooleanType$;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.DateType$;\nimport org.apache.spark.sql.types.DecimalType$;\nimport org.apache.spark.sql.types.DoubleType$;\nimport org.apache.spark.sql.types.FloatType$;\nimport org.apache.spark.sql.types.IntegerType$;\nimport org.apache.spark.sql.types.LongType$;\nimport org.apache.spark.sql.types.MapType$;\nimport org.apache.spark.sql.types.Metadata;\nimport org.apache.spark.sql.types.StringType$;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType$;\nimport org.apache.spark.sql.types.TimestampType$;\nimport java.util.List;\n\nclass TypeToSparkType extends TypeUtil.SchemaVisitor<DataType> {\n  TypeToSparkType() {\n  }\n\n  @Override\n  public DataType schema(Schema schema, DataType structType) {\n    return structType;\n  }\n\n  @Override\n  public DataType struct(Types.StructType struct, List<DataType> fieldResults) {\n    List<Types.NestedField> fields = struct.fields();\n\n    List<StructField> sparkFields = Lists.newArrayListWithExpectedSize(fieldResults.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      DataType type = fieldResults.get(i);\n      sparkFields.add(StructField.apply(field.name(), type, field.isOptional(), Metadata.empty()));\n    }\n\n    return StructType$.MODULE$.apply(sparkFields);\n  }\n\n  @Override\n  public DataType field(Types.NestedField field, DataType fieldResult) {\n    return fieldResult;\n  }\n\n  @Override\n  public DataType list(Types.ListType list, DataType elementResult) {\n    return ArrayType$.MODULE$.apply(elementResult, list.isElementOptional());\n  }\n\n  @Override\n  public DataType map(Types.MapType map, DataType keyResult, DataType valueResult) {\n    return MapType$.MODULE$.apply(keyResult, valueResult, map.isValueOptional());\n  }\n\n  @Override\n  public DataType primitive(Type.PrimitiveType primitive) {\n    switch (primitive.typeId()) {\n      case BOOLEAN:\n        return BooleanType$.MODULE$;\n      case INTEGER:\n        return IntegerType$.MODULE$;\n      case LONG:\n        return LongType$.MODULE$;\n      case FLOAT:\n        return FloatType$.MODULE$;\n      case DOUBLE:\n        return DoubleType$.MODULE$;\n      case DATE:\n        return DateType$.MODULE$;\n      case TIME:\n        throw new UnsupportedOperationException(\n            \"Spark does not support time fields\");\n      case TIMESTAMP:\n        Types.TimestampType timestamp = (Types.TimestampType) primitive;\n        if (timestamp.shouldAdjustToUTC()) {\n          return TimestampType$.MODULE$;\n        }\n        throw new UnsupportedOperationException(\n            \"Spark does not support timestamp without time zone fields\");\n      case STRING:\n        return StringType$.MODULE$;\n      case UUID:\n\n        return StringType$.MODULE$;\n      case FIXED:\n        return BinaryType$.MODULE$;\n      case BINARY:\n        return BinaryType$.MODULE$;\n      case DECIMAL:\n        Types.DecimalType decimal = (Types.DecimalType) primitive;\n        return DecimalType$.MODULE$.apply(decimal.precision(), decimal.scale());\n      default:\n        throw new UnsupportedOperationException(\n            \"Cannot convert unknown type to Spark: \" + primitive);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/AvroSchemaUtil.java'",
            "'iceberg/core/src/main/java/com/netflix/iceberg/avro/BuildAvroProjection.java'"
        ]
    },
    {
        "files": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ],
        "content": "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'\n:\n\npackage com.netflix.iceberg.parquet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.parquet.column.ColumnDescriptor;\nimport org.apache.parquet.column.page.PageReadStore;\nimport org.apache.parquet.io.api.Binary;\nimport org.apache.parquet.schema.Type;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static java.util.Collections.emptyIterator;\n\npublic class ParquetValueReaders {\n  private ParquetValueReaders() {\n  }\n\n  public static <T> ParquetValueReader<T> option(Type type, int definitionLevel,\n                                                 ParquetValueReader<T> reader) {\n    if (type.isRepetition(Type.Repetition.OPTIONAL)) {\n      return new OptionReader<>(definitionLevel, reader);\n    }\n    return reader;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static <T> ParquetValueReader<T> nulls() {\n    return (ParquetValueReader<T>) NullReader.INSTANCE;\n  }\n\n  private static class NullReader<T> implements ParquetValueReader<T> {\n    private static final NullReader<Void> INSTANCE = new NullReader<>();\n    private static final List<TripleIterator<?>> COLUMNS = ImmutableList.of();\n    private static final TripleIterator<?> NULL_COLUMN = new TripleIterator<Object> () {\n      @Override\n      public int currentDefinitionLevel() {\n        return 0;\n      }\n\n      @Override\n      public int currentRepetitionLevel() {\n        return 0;\n      }\n\n      @Override\n      public <N> N nextNull() {\n        return null;\n      }\n\n      @Override\n      public boolean hasNext() {\n        return false;\n      }\n\n      @Override\n      public Object next() {\n        return null;\n      }\n    };\n\n    private NullReader() {\n    }\n\n    @Override\n    public T read(T reuse) {\n      return null;\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return NULL_COLUMN;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return COLUMNS;\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n    }\n  }\n\n  public abstract static class PrimitiveReader<T> implements ParquetValueReader<T> {\n    private final ColumnDescriptor desc;\n    protected final ColumnIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected PrimitiveReader(ColumnDescriptor desc) {\n      this.desc = desc;\n      this.column = ColumnIterator.newIterator(desc, \"\");\n      this.children = ImmutableList.of(column);\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      column.setPageSource(pageStore.getPageReader(desc));\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n  }\n\n  public static class UnboxedReader<T> extends PrimitiveReader<T> {\n    public UnboxedReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T read(T ignored) {\n      return (T) column.next();\n    }\n\n    public boolean readBoolean() {\n      return column.nextBoolean();\n    }\n\n    public int readInteger() {\n      return column.nextInteger();\n    }\n\n    public long readLong() {\n      return column.nextLong();\n    }\n\n    public float readFloat() {\n      return column.nextFloat();\n    }\n\n    public double readDouble() {\n      return column.nextDouble();\n    }\n\n    public Binary readBinary() {\n      return column.nextBinary();\n    }\n  }\n\n  public static class StringReader extends PrimitiveReader<String> {\n    public StringReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public String read(String reuse) {\n      return column.nextBinary().toStringUsingUTF8();\n    }\n  }\n\n  public static class IntAsLongReader extends UnboxedReader<Long> {\n    public IntAsLongReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public Long read(Long ignored) {\n      return readLong();\n    }\n\n    @Override\n    public long readLong() {\n      return super.readInteger();\n    }\n  }\n\n  public static class FloatAsDoubleReader extends UnboxedReader<Double> {\n    public FloatAsDoubleReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public Double read(Double ignored) {\n      return readDouble();\n    }\n\n    @Override\n    public double readDouble() {\n      return super.readFloat();\n    }\n  }\n\n  public static class IntegerAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private final int scale;\n\n    public IntegerAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal ignored) {\n      return new BigDecimal(BigInteger.valueOf(column.nextInteger()), scale);\n    }\n  }\n\n  public static class LongAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private final int scale;\n\n    public LongAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal ignored) {\n      return new BigDecimal(BigInteger.valueOf(column.nextLong()), scale);\n    }\n  }\n\n  public static class BinaryAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private int scale;\n\n    public BinaryAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal reuse) {\n      byte[] bytes = column.nextBinary().getBytesUnsafe();\n      return new BigDecimal(new BigInteger(bytes), scale);\n    }\n  }\n\n  public static class BytesReader extends PrimitiveReader<ByteBuffer> {\n    public BytesReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public ByteBuffer read(ByteBuffer reuse) {\n      Binary binary = column.nextBinary();\n      ByteBuffer data = binary.toByteBuffer();\n      if (reuse != null && reuse.hasArray() && reuse.capacity() >= data.remaining()) {\n        data.get(reuse.array(), reuse.arrayOffset(), data.remaining());\n        reuse.position(0);\n        reuse.limit(data.remaining());\n        return reuse;\n      } else {\n        byte[] array = new byte[data.remaining()];\n        data.get(array, 0, data.remaining());\n        return ByteBuffer.wrap(array);\n      }\n    }\n  }\n\n  private static class OptionReader<T> implements ParquetValueReader<T> {\n    private final int definitionLevel;\n    private final ParquetValueReader<T> reader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    OptionReader(int definitionLevel, ParquetValueReader<T> reader) {\n      this.definitionLevel = definitionLevel;\n      this.reader = reader;\n      this.column = reader.column();\n      this.children = reader.columns();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      reader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public T read(T reuse) {\n      if (column.currentDefinitionLevel() > definitionLevel) {\n        return reader.read(reuse);\n      }\n\n      for (TripleIterator<?> column : children) {\n        column.nextNull();\n      }\n\n      return null;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n  }\n\n  public abstract static class RepeatedReader<T, I, E> implements ParquetValueReader<T> {\n    private final int definitionLevel;\n    private final int repetitionLevel;\n    private final ParquetValueReader<E> reader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected RepeatedReader(int definitionLevel, int repetitionLevel, ParquetValueReader<E> reader) {\n      this.definitionLevel = definitionLevel;\n      this.repetitionLevel = repetitionLevel;\n      this.reader = reader;\n      this.column = reader.column();\n      this.children = reader.columns();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      reader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public T read(T reuse) {\n      I intermediate = newListData(reuse);\n\n      do {\n        if (column.currentDefinitionLevel() > definitionLevel) {\n          addElement(intermediate, reader.read(getElement(intermediate)));\n        } else {\n\n          for (TripleIterator<?> column : children) {\n            column.nextNull();\n          }\n\n\n          break;\n        }\n      } while (column.currentRepetitionLevel() > repetitionLevel);\n\n      return buildList(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    protected abstract I newListData(T reuse);\n\n    protected abstract E getElement(I list);\n\n    protected abstract void addElement(I list, E element);\n\n    protected abstract T buildList(I list);\n  }\n\n  public static class ListReader<E> extends RepeatedReader<List<E>, List<E>, E> {\n    private List<E> lastList = null;\n    private Iterator<E> elements = null;\n\n    public ListReader(int definitionLevel, int repetitionLevel,\n                      ParquetValueReader<E> reader) {\n      super(definitionLevel, repetitionLevel, reader);\n    }\n\n    @Override\n    protected List<E> newListData(List<E> reuse) {\n      List<E> list;\n      if (lastList != null) {\n        lastList.clear();\n        list = lastList;\n      } else {\n        list = Lists.newArrayList();\n      }\n\n      if (reuse != null) {\n        this.lastList = reuse;\n        this.elements = reuse.iterator();\n      } else {\n        this.lastList = null;\n        this.elements = emptyIterator();\n      }\n\n      return list;\n    }\n\n    @Override\n    protected E getElement(List<E> reuse) {\n      if (elements.hasNext()) {\n        return elements.next();\n      }\n\n      return null;\n    }\n\n    @Override\n    protected void addElement(List<E> list, E element) {\n      list.add(element);\n    }\n\n    @Override\n    protected List<E> buildList(List<E> list) {\n      return list;\n    }\n  }\n\n  public abstract static class RepeatedKeyValueReader<M, I, K, V> implements ParquetValueReader<M> {\n    private final int definitionLevel;\n    private final int repetitionLevel;\n    private final ParquetValueReader<K> keyReader;\n    private final ParquetValueReader<V> valueReader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected RepeatedKeyValueReader(int definitionLevel, int repetitionLevel,\n                           ParquetValueReader<K> keyReader, ParquetValueReader<V> valueReader) {\n      this.definitionLevel = definitionLevel;\n      this.repetitionLevel = repetitionLevel;\n      this.keyReader = keyReader;\n      this.valueReader = valueReader;\n      this.column = keyReader.column();\n      this.children = ImmutableList.<TripleIterator<?>>builder()\n          .addAll(keyReader.columns())\n          .addAll(valueReader.columns())\n          .build();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      keyReader.setPageSource(pageStore);\n      valueReader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public M read(M reuse) {\n      I intermediate = newMapData(reuse);\n\n      do {\n        if (column.currentDefinitionLevel() > definitionLevel) {\n          Map.Entry<K, V> pair = getPair(intermediate);\n          addPair(intermediate, keyReader.read(pair.getKey()), valueReader.read(pair.getValue()));\n        } else {\n\n          for (TripleIterator<?> column : children) {\n            column.nextNull();\n          }\n\n\n          break;\n        }\n      } while (column.currentRepetitionLevel() > repetitionLevel);\n\n      return buildMap(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    protected abstract I newMapData(M reuse);\n\n    protected abstract Map.Entry<K, V> getPair(I map);\n\n    protected abstract void addPair(I map, K key, V value);\n\n    protected abstract M buildMap(I map);\n  }\n\n  public static class MapReader<K, V> extends RepeatedKeyValueReader<Map<K, V>, Map<K, V>, K, V> {\n    private final ReusableEntry<K, V> nullEntry = new ReusableEntry<>();\n    private Map<K, V> lastMap = null;\n    private Iterator<Map.Entry<K, V>> pairs = null;\n\n    public MapReader(int definitionLevel, int repetitionLevel,\n                     ParquetValueReader<K> keyReader,\n                     ParquetValueReader<V> valueReader) {\n      super(definitionLevel, repetitionLevel, keyReader, valueReader);\n    }\n\n    @Override\n    protected Map<K, V> newMapData(Map<K, V> reuse) {\n      Map<K, V> map;\n      if (lastMap != null) {\n        lastMap.clear();\n        map = lastMap;\n      } else {\n        map = Maps.newLinkedHashMap();\n      }\n\n      if (reuse != null) {\n        this.lastMap = reuse;\n        this.pairs = reuse.entrySet().iterator();\n      } else {\n        this.lastMap = null;\n        this.pairs = emptyIterator();\n      }\n\n      return map;\n    }\n\n    @Override\n    protected Map.Entry<K, V> getPair(Map<K, V> map) {\n      if (pairs.hasNext()) {\n        return pairs.next();\n      } else {\n        return nullEntry;\n      }\n    }\n\n    @Override\n    protected void addPair(Map<K, V> map, K key, V value) {\n      map.put(key, value);\n    }\n\n    @Override\n    protected Map<K, V> buildMap(Map<K, V> map) {\n      return map;\n    }\n  }\n\n  public static class ReusableEntry<K, V> implements Map.Entry<K, V> {\n    private K key = null;\n    private V value = null;\n\n    public void set(K key, V value) {\n      this.key = key;\n      this.value = value;\n    }\n\n    @Override\n    public K getKey() {\n      return key;\n    }\n\n    @Override\n    public V getValue() {\n      return value;\n    }\n\n    @Override\n    public V setValue(V value) {\n      V lastValue = this.value;\n      this.value = value;\n      return lastValue;\n    }\n  }\n\n  public abstract static class StructReader<T, I> implements ParquetValueReader<T> {\n    private interface Setter<R> {\n      void set(R record, int pos, Object reuse);\n    }\n\n    private final ParquetValueReader<?>[] readers;\n    private final TripleIterator<?> column;\n    private final TripleIterator<?>[] columns;\n    private final Setter<I>[] setters;\n    private final List<TripleIterator<?>> children;\n\n    @SuppressWarnings(\"unchecked\")\n    protected StructReader(List<Type> types, List<ParquetValueReader<?>> readers) {\n      this.readers = (ParquetValueReader<?>[]) Array.newInstance(\n          ParquetValueReader.class, readers.size());\n      this.columns = (TripleIterator<?>[]) Array.newInstance(TripleIterator.class, readers.size());\n      this.setters = (Setter<I>[]) Array.newInstance(Setter.class, readers.size());\n\n      ImmutableList.Builder<TripleIterator<?>> columnsBuilder = ImmutableList.builder();\n      for (int i = 0; i < readers.size(); i += 1) {\n        ParquetValueReader<?> reader = readers.get(i);\n        this.readers[i] = readers.get(i);\n        this.columns[i] = reader.column();\n        this.setters[i] = newSetter(reader, types.get(i));\n        columnsBuilder.addAll(reader.columns());\n      }\n\n      this.children = columnsBuilder.build();\n      if (children.size() > 0) {\n        this.column = children.get(0);\n      } else {\n        this.column = NullReader.NULL_COLUMN;\n      }\n    }\n\n    @Override\n    public final void setPageSource(PageReadStore pageStore) {\n      for (int i = 0; i < readers.length; i += 1) {\n        readers[i].setPageSource(pageStore);\n      }\n    }\n\n    @Override\n    public final TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public final T read(T reuse) {\n      I intermediate = newStructData(reuse);\n\n      for (int i = 0; i < readers.length; i += 1) {\n        set(intermediate, i, readers[i].read(get(intermediate, i)));\n\n      }\n\n      return buildStruct(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <E> Setter<I> newSetter(ParquetValueReader<E> reader, Type type) {\n      if (reader instanceof UnboxedReader && type.isPrimitive()) {\n        UnboxedReader<?> unboxed  = (UnboxedReader<?>) reader;\n        switch (type.asPrimitiveType().getPrimitiveTypeName()) {\n          case BOOLEAN:\n            return (record, pos, ignored) -> setBoolean(record, pos, unboxed.readBoolean());\n          case INT32:\n            return (record, pos, ignored) -> setInteger(record, pos, unboxed.readInteger());\n          case INT64:\n            return (record, pos, ignored) -> setLong(record, pos, unboxed.readLong());\n          case FLOAT:\n            return (record, pos, ignored) -> setFloat(record, pos, unboxed.readFloat());\n          case DOUBLE:\n            return (record, pos, ignored) -> setDouble(record, pos, unboxed.readDouble());\n          case FIXED_LEN_BYTE_ARRAY:\n          case BINARY:\n            return (record, pos, ignored) -> set(record, pos, unboxed.readBinary());\n          default:\n            throw new UnsupportedOperationException(\"Unsupported type: \" + type);\n        }\n      }\n\n\n      return (record, pos, reuse) -> {\n        Object obj = reader.read((E) reuse);\n        if (obj != null) {\n          set(record, pos, obj);\n        } else {\n          setNull(record, pos);\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <E> E get(I intermediate, int pos) {\n      return (E) getField(intermediate, pos);\n    }\n\n    protected abstract I newStructData(T reuse);\n\n    protected abstract Object getField(I intermediate, int pos);\n\n    protected abstract T buildStruct(I struct);\n\n\n    protected abstract void set(I struct, int pos, Object value);\n\n    protected void setNull(I struct, int pos) {\n      set(struct, pos, null);\n    }\n\n    protected void setBoolean(I struct, int pos, boolean value) {\n      set(struct, pos, value);\n    }\n\n    protected void setInteger(I struct, int pos, int value) {\n      set(struct, pos, value);\n    }\n\n    protected void setLong(I struct, int pos, long value) {\n      set(struct, pos, value);\n    }\n\n    protected void setFloat(I struct, int pos, float value) {\n      set(struct, pos, value);\n    }\n\n    protected void setDouble(I struct, int pos, double value) {\n      set(struct, pos, value);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ]
    },
    {
        "files": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ],
        "content": "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'\n:\n\npackage com.netflix.iceberg.parquet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.parquet.column.ColumnDescriptor;\nimport org.apache.parquet.column.page.PageReadStore;\nimport org.apache.parquet.io.api.Binary;\nimport org.apache.parquet.schema.Type;\n\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static java.util.Collections.emptyIterator;\n\npublic class ParquetValueReaders {\n  private ParquetValueReaders() {\n  }\n\n  public static <T> ParquetValueReader<T> option(Type type, int definitionLevel,\n                                                 ParquetValueReader<T> reader) {\n    if (type.isRepetition(Type.Repetition.OPTIONAL)) {\n      return new OptionReader<>(definitionLevel, reader);\n    }\n    return reader;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static <T> ParquetValueReader<T> nulls() {\n    return (ParquetValueReader<T>) NullReader.INSTANCE;\n  }\n\n  private static class NullReader<T> implements ParquetValueReader<T> {\n    private static final NullReader<Void> INSTANCE = new NullReader<>();\n    private static final List<TripleIterator<?>> COLUMNS = ImmutableList.of();\n    private static final TripleIterator<?> NULL_COLUMN = new TripleIterator<Object> () {\n      @Override\n      public int currentDefinitionLevel() {\n        return 0;\n      }\n\n      @Override\n      public int currentRepetitionLevel() {\n        return 0;\n      }\n\n      @Override\n      public <N> N nextNull() {\n        return null;\n      }\n\n      @Override\n      public boolean hasNext() {\n        return false;\n      }\n\n      @Override\n      public Object next() {\n        return null;\n      }\n    };\n\n    private NullReader() {\n    }\n\n    @Override\n    public T read(T reuse) {\n      return null;\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return NULL_COLUMN;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return COLUMNS;\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n    }\n  }\n\n  public abstract static class PrimitiveReader<T> implements ParquetValueReader<T> {\n    private final ColumnDescriptor desc;\n    protected final ColumnIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected PrimitiveReader(ColumnDescriptor desc) {\n      this.desc = desc;\n      this.column = ColumnIterator.newIterator(desc, \"\");\n      this.children = ImmutableList.of(column);\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      column.setPageSource(pageStore.getPageReader(desc));\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n  }\n\n  public static class UnboxedReader<T> extends PrimitiveReader<T> {\n    public UnboxedReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T read(T ignored) {\n      return (T) column.next();\n    }\n\n    public boolean readBoolean() {\n      return column.nextBoolean();\n    }\n\n    public int readInteger() {\n      return column.nextInteger();\n    }\n\n    public long readLong() {\n      return column.nextLong();\n    }\n\n    public float readFloat() {\n      return column.nextFloat();\n    }\n\n    public double readDouble() {\n      return column.nextDouble();\n    }\n\n    public Binary readBinary() {\n      return column.nextBinary();\n    }\n  }\n\n  public static class StringReader extends PrimitiveReader<String> {\n    public StringReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public String read(String reuse) {\n      return column.nextBinary().toStringUsingUTF8();\n    }\n  }\n\n  public static class IntAsLongReader extends UnboxedReader<Long> {\n    public IntAsLongReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public Long read(Long ignored) {\n      return readLong();\n    }\n\n    @Override\n    public long readLong() {\n      return super.readInteger();\n    }\n  }\n\n  public static class FloatAsDoubleReader extends UnboxedReader<Double> {\n    public FloatAsDoubleReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public Double read(Double ignored) {\n      return readDouble();\n    }\n\n    @Override\n    public double readDouble() {\n      return super.readFloat();\n    }\n  }\n\n  public static class IntegerAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private final int scale;\n\n    public IntegerAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal ignored) {\n      return new BigDecimal(BigInteger.valueOf(column.nextInteger()), scale);\n    }\n  }\n\n  public static class LongAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private final int scale;\n\n    public LongAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal ignored) {\n      return new BigDecimal(BigInteger.valueOf(column.nextLong()), scale);\n    }\n  }\n\n  public static class BinaryAsDecimalReader extends PrimitiveReader<BigDecimal> {\n    private int scale;\n\n    public BinaryAsDecimalReader(ColumnDescriptor desc, int scale) {\n      super(desc);\n      this.scale = scale;\n    }\n\n    @Override\n    public BigDecimal read(BigDecimal reuse) {\n      byte[] bytes = column.nextBinary().getBytesUnsafe();\n      return new BigDecimal(new BigInteger(bytes), scale);\n    }\n  }\n\n  public static class BytesReader extends PrimitiveReader<ByteBuffer> {\n    public BytesReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public ByteBuffer read(ByteBuffer reuse) {\n      Binary binary = column.nextBinary();\n      ByteBuffer data = binary.toByteBuffer();\n      if (reuse != null && reuse.hasArray() && reuse.capacity() >= data.remaining()) {\n        data.get(reuse.array(), reuse.arrayOffset(), data.remaining());\n        reuse.position(0);\n        reuse.limit(data.remaining());\n        return reuse;\n      } else {\n        byte[] array = new byte[data.remaining()];\n        data.get(array, 0, data.remaining());\n        return ByteBuffer.wrap(array);\n      }\n    }\n  }\n\n  private static class OptionReader<T> implements ParquetValueReader<T> {\n    private final int definitionLevel;\n    private final ParquetValueReader<T> reader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    OptionReader(int definitionLevel, ParquetValueReader<T> reader) {\n      this.definitionLevel = definitionLevel;\n      this.reader = reader;\n      this.column = reader.column();\n      this.children = reader.columns();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      reader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public T read(T reuse) {\n      if (column.currentDefinitionLevel() > definitionLevel) {\n        return reader.read(reuse);\n      }\n\n      for (TripleIterator<?> column : children) {\n        column.nextNull();\n      }\n\n      return null;\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n  }\n\n  public abstract static class RepeatedReader<T, I, E> implements ParquetValueReader<T> {\n    private final int definitionLevel;\n    private final int repetitionLevel;\n    private final ParquetValueReader<E> reader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected RepeatedReader(int definitionLevel, int repetitionLevel, ParquetValueReader<E> reader) {\n      this.definitionLevel = definitionLevel;\n      this.repetitionLevel = repetitionLevel;\n      this.reader = reader;\n      this.column = reader.column();\n      this.children = reader.columns();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      reader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public T read(T reuse) {\n      I intermediate = newListData(reuse);\n\n      do {\n        if (column.currentDefinitionLevel() > definitionLevel) {\n          addElement(intermediate, reader.read(getElement(intermediate)));\n        } else {\n\n          for (TripleIterator<?> column : children) {\n            column.nextNull();\n          }\n\n\n          break;\n        }\n      } while (column.currentRepetitionLevel() > repetitionLevel);\n\n      return buildList(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    protected abstract I newListData(T reuse);\n\n    protected abstract E getElement(I list);\n\n    protected abstract void addElement(I list, E element);\n\n    protected abstract T buildList(I list);\n  }\n\n  public static class ListReader<E> extends RepeatedReader<List<E>, List<E>, E> {\n    private List<E> lastList = null;\n    private Iterator<E> elements = null;\n\n    public ListReader(int definitionLevel, int repetitionLevel,\n                      ParquetValueReader<E> reader) {\n      super(definitionLevel, repetitionLevel, reader);\n    }\n\n    @Override\n    protected List<E> newListData(List<E> reuse) {\n      List<E> list;\n      if (lastList != null) {\n        lastList.clear();\n        list = lastList;\n      } else {\n        list = Lists.newArrayList();\n      }\n\n      if (reuse != null) {\n        this.lastList = reuse;\n        this.elements = reuse.iterator();\n      } else {\n        this.lastList = null;\n        this.elements = emptyIterator();\n      }\n\n      return list;\n    }\n\n    @Override\n    protected E getElement(List<E> reuse) {\n      if (elements.hasNext()) {\n        return elements.next();\n      }\n\n      return null;\n    }\n\n    @Override\n    protected void addElement(List<E> list, E element) {\n      list.add(element);\n    }\n\n    @Override\n    protected List<E> buildList(List<E> list) {\n      return list;\n    }\n  }\n\n  public abstract static class RepeatedKeyValueReader<M, I, K, V> implements ParquetValueReader<M> {\n    private final int definitionLevel;\n    private final int repetitionLevel;\n    private final ParquetValueReader<K> keyReader;\n    private final ParquetValueReader<V> valueReader;\n    private final TripleIterator<?> column;\n    private final List<TripleIterator<?>> children;\n\n    protected RepeatedKeyValueReader(int definitionLevel, int repetitionLevel,\n                           ParquetValueReader<K> keyReader, ParquetValueReader<V> valueReader) {\n      this.definitionLevel = definitionLevel;\n      this.repetitionLevel = repetitionLevel;\n      this.keyReader = keyReader;\n      this.valueReader = valueReader;\n      this.column = keyReader.column();\n      this.children = ImmutableList.<TripleIterator<?>>builder()\n          .addAll(keyReader.columns())\n          .addAll(valueReader.columns())\n          .build();\n    }\n\n    @Override\n    public void setPageSource(PageReadStore pageStore) {\n      keyReader.setPageSource(pageStore);\n      valueReader.setPageSource(pageStore);\n    }\n\n    @Override\n    public TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public M read(M reuse) {\n      I intermediate = newMapData(reuse);\n\n      do {\n        if (column.currentDefinitionLevel() > definitionLevel) {\n          Map.Entry<K, V> pair = getPair(intermediate);\n          addPair(intermediate, keyReader.read(pair.getKey()), valueReader.read(pair.getValue()));\n        } else {\n\n          for (TripleIterator<?> column : children) {\n            column.nextNull();\n          }\n\n\n          break;\n        }\n      } while (column.currentRepetitionLevel() > repetitionLevel);\n\n      return buildMap(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    protected abstract I newMapData(M reuse);\n\n    protected abstract Map.Entry<K, V> getPair(I map);\n\n    protected abstract void addPair(I map, K key, V value);\n\n    protected abstract M buildMap(I map);\n  }\n\n  public static class MapReader<K, V> extends RepeatedKeyValueReader<Map<K, V>, Map<K, V>, K, V> {\n    private final ReusableEntry<K, V> nullEntry = new ReusableEntry<>();\n    private Map<K, V> lastMap = null;\n    private Iterator<Map.Entry<K, V>> pairs = null;\n\n    public MapReader(int definitionLevel, int repetitionLevel,\n                     ParquetValueReader<K> keyReader,\n                     ParquetValueReader<V> valueReader) {\n      super(definitionLevel, repetitionLevel, keyReader, valueReader);\n    }\n\n    @Override\n    protected Map<K, V> newMapData(Map<K, V> reuse) {\n      Map<K, V> map;\n      if (lastMap != null) {\n        lastMap.clear();\n        map = lastMap;\n      } else {\n        map = Maps.newLinkedHashMap();\n      }\n\n      if (reuse != null) {\n        this.lastMap = reuse;\n        this.pairs = reuse.entrySet().iterator();\n      } else {\n        this.lastMap = null;\n        this.pairs = emptyIterator();\n      }\n\n      return map;\n    }\n\n    @Override\n    protected Map.Entry<K, V> getPair(Map<K, V> map) {\n      if (pairs.hasNext()) {\n        return pairs.next();\n      } else {\n        return nullEntry;\n      }\n    }\n\n    @Override\n    protected void addPair(Map<K, V> map, K key, V value) {\n      map.put(key, value);\n    }\n\n    @Override\n    protected Map<K, V> buildMap(Map<K, V> map) {\n      return map;\n    }\n  }\n\n  public static class ReusableEntry<K, V> implements Map.Entry<K, V> {\n    private K key = null;\n    private V value = null;\n\n    public void set(K key, V value) {\n      this.key = key;\n      this.value = value;\n    }\n\n    @Override\n    public K getKey() {\n      return key;\n    }\n\n    @Override\n    public V getValue() {\n      return value;\n    }\n\n    @Override\n    public V setValue(V value) {\n      V lastValue = this.value;\n      this.value = value;\n      return lastValue;\n    }\n  }\n\n  public abstract static class StructReader<T, I> implements ParquetValueReader<T> {\n    private interface Setter<R> {\n      void set(R record, int pos, Object reuse);\n    }\n\n    private final ParquetValueReader<?>[] readers;\n    private final TripleIterator<?> column;\n    private final TripleIterator<?>[] columns;\n    private final Setter<I>[] setters;\n    private final List<TripleIterator<?>> children;\n\n    @SuppressWarnings(\"unchecked\")\n    protected StructReader(List<Type> types, List<ParquetValueReader<?>> readers) {\n      this.readers = (ParquetValueReader<?>[]) Array.newInstance(\n          ParquetValueReader.class, readers.size());\n      this.columns = (TripleIterator<?>[]) Array.newInstance(TripleIterator.class, readers.size());\n      this.setters = (Setter<I>[]) Array.newInstance(Setter.class, readers.size());\n\n      ImmutableList.Builder<TripleIterator<?>> columnsBuilder = ImmutableList.builder();\n      for (int i = 0; i < readers.size(); i += 1) {\n        ParquetValueReader<?> reader = readers.get(i);\n        this.readers[i] = readers.get(i);\n        this.columns[i] = reader.column();\n        this.setters[i] = newSetter(reader, types.get(i));\n        columnsBuilder.addAll(reader.columns());\n      }\n\n      this.children = columnsBuilder.build();\n      if (children.size() > 0) {\n        this.column = children.get(0);\n      } else {\n        this.column = NullReader.NULL_COLUMN;\n      }\n    }\n\n    @Override\n    public final void setPageSource(PageReadStore pageStore) {\n      for (int i = 0; i < readers.length; i += 1) {\n        readers[i].setPageSource(pageStore);\n      }\n    }\n\n    @Override\n    public final TripleIterator<?> column() {\n      return column;\n    }\n\n    @Override\n    public final T read(T reuse) {\n      I intermediate = newStructData(reuse);\n\n      for (int i = 0; i < readers.length; i += 1) {\n        set(intermediate, i, readers[i].read(get(intermediate, i)));\n\n      }\n\n      return buildStruct(intermediate);\n    }\n\n    @Override\n    public List<TripleIterator<?>> columns() {\n      return children;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <E> Setter<I> newSetter(ParquetValueReader<E> reader, Type type) {\n      if (reader instanceof UnboxedReader && type.isPrimitive()) {\n        UnboxedReader<?> unboxed  = (UnboxedReader<?>) reader;\n        switch (type.asPrimitiveType().getPrimitiveTypeName()) {\n          case BOOLEAN:\n            return (record, pos, ignored) -> setBoolean(record, pos, unboxed.readBoolean());\n          case INT32:\n            return (record, pos, ignored) -> setInteger(record, pos, unboxed.readInteger());\n          case INT64:\n            return (record, pos, ignored) -> setLong(record, pos, unboxed.readLong());\n          case FLOAT:\n            return (record, pos, ignored) -> setFloat(record, pos, unboxed.readFloat());\n          case DOUBLE:\n            return (record, pos, ignored) -> setDouble(record, pos, unboxed.readDouble());\n          case FIXED_LEN_BYTE_ARRAY:\n          case BINARY:\n            return (record, pos, ignored) -> set(record, pos, unboxed.readBinary());\n          default:\n            throw new UnsupportedOperationException(\"Unsupported type: \" + type);\n        }\n      }\n\n\n      return (record, pos, reuse) -> {\n        Object obj = reader.read((E) reuse);\n        if (obj != null) {\n          set(record, pos, obj);\n        } else {\n          setNull(record, pos);\n        }\n      };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private <E> E get(I intermediate, int pos) {\n      return (E) getField(intermediate, pos);\n    }\n\n    protected abstract I newStructData(T reuse);\n\n    protected abstract Object getField(I intermediate, int pos);\n\n    protected abstract T buildStruct(I struct);\n\n\n    protected abstract void set(I struct, int pos, Object value);\n\n    protected void setNull(I struct, int pos) {\n      set(struct, pos, null);\n    }\n\n    protected void setBoolean(I struct, int pos, boolean value) {\n      set(struct, pos, value);\n    }\n\n    protected void setInteger(I struct, int pos, int value) {\n      set(struct, pos, value);\n    }\n\n    protected void setLong(I struct, int pos, long value) {\n      set(struct, pos, value);\n    }\n\n    protected void setFloat(I struct, int pos, float value) {\n      set(struct, pos, value);\n    }\n\n    protected void setDouble(I struct, int pos, double value) {\n      set(struct, pos, value);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/parquet/src/main/java/com/netflix/iceberg/parquet/ParquetValueReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.NonNull;\nimport android.support.graphics.drawable.AnimatedVectorDrawableCompat;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.ImageButton;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\nimport com.philliphsu.bottomsheetpickers.date.MonthPickerView.OnMonthClickListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\n\n\nclass PagingDayPickerView extends LinearLayout implements OnDateChangedListener, OnPageChangeListener, OnMonthClickListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n    static final int DAY_PICKER_INDEX = 0;\n    static final int MONTH_PICKER_INDEX = 1;\n\n    static int MONTH_NAVIGATION_BAR_SIZE;\n\n    private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected PagingMonthAdapter mAdapter;\n\n    private DayPickerViewAnimator mMonthAnimator;\n    private ViewPager mViewPager;\n    private MonthPickerView mMonthPickerView;\n    private TextView mMonthYearTitleView;\n    private ImageButton mPreviousButton;\n    private ImageButton mNextButton;\n    private View mTitleContainer;\n\n\n    private AnimatedVectorDrawableCompat mArrowDownDrawable;\n\n    private AnimatedVectorDrawableCompat mArrowUpDrawable;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mCurrentMonthDisplayed;\n\n    private int mCurrentView = DAY_PICKER_INDEX;\n\n    private int mCurrentYearDisplayed;\n\n    private DatePickerController mController;\n\n    private boolean mThemeDark;\n    private int mAccentColor;\n\n    public PagingDayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        this(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark,\n                               int accentColor) {\n        super(context);\n\n        mThemeDark = themeDark;\n        mAccentColor = accentColor;\n        init(context);\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n        mMonthPickerView.setDatePickerController(mController);\n    }\n\n    private void init(Context context) {\n        mHandler = new Handler();\n        setOrientation(VERTICAL);\n        setLayoutParams(new LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        Resources res = getResources();\n        MONTH_NAVIGATION_BAR_SIZE = res.getDimensionPixelOffset(R.dimen.bsp_month_navigation_bar_height)\n                + res.getDimensionPixelOffset(R.dimen.bsp_month_view_top_padding);\n\n        final View view = LayoutInflater.from(context).inflate(R.layout.bsp_day_picker_content, this, true);\n        mMonthAnimator = (DayPickerViewAnimator) findViewById(R.id.bsp_month_animator);\n        mMonthPickerView = (MonthPickerView) findViewById(R.id.bsp_month_picker);\n        mMonthPickerView.setOnMonthClickListener(this);\n        mViewPager = (ViewPager) findViewById(R.id.bsp_viewpager);\n        mViewPager.addOnPageChangeListener(this);\n        mMonthYearTitleView = (TextView) view.findViewById(R.id.bsp_month_year_title);\n        mTitleContainer = view.findViewById(R.id.bsp_month_year_title_container);\n        mTitleContainer.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int newIndex = mCurrentView == DAY_PICKER_INDEX ? MONTH_PICKER_INDEX : DAY_PICKER_INDEX;\n                setupCurrentView(newIndex, true);\n            }\n        });\n        mPreviousButton = (ImageButton) view.findViewById(R.id.bsp_prev);\n        mPreviousButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int previousItem = mViewPager.getCurrentItem() - 1;\n                if (previousItem >= 0) {\n                    mViewPager.setCurrentItem(previousItem, true);\n                }\n            }\n        });\n        mNextButton = (ImageButton) view.findViewById(R.id.bsp_next);\n        mNextButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int nextItem = mViewPager.getCurrentItem() + 1;\n                if (nextItem < mAdapter.getCount()) {\n                    mViewPager.setCurrentItem(nextItem, true);\n                }\n            }\n        });\n\n        mArrowDownDrawable = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_down);\n        mArrowUpDrawable   = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_up);\n        setArrowDrawableOnTitle(mArrowDownDrawable);\n\n\n        if (mThemeDark) {\n            int selectableItemBg = getColor(context, R.color.bsp_selectable_item_background_dark);\n            Utils.setColorControlHighlight(mPreviousButton, selectableItemBg);\n            Utils.setColorControlHighlight(mNextButton, selectableItemBg);\n            Utils.setColorControlHighlight(mTitleContainer, selectableItemBg);\n            int cursor = getColor(context, R.color.bsp_text_color_secondary_dark);\n            Utils.applyTint(mPreviousButton, cursor);\n            Utils.applyTint(mNextButton, cursor);\n        }\n\n\n        int monthYearTitleColor = getColor(context, mThemeDark?\n                R.color.bsp_text_color_primary_dark : R.color.bsp_text_color_primary_light);\n        int dropdownArrowColor = getColor(context, mThemeDark?\n                R.color.bsp_icon_color_active_dark : R.color.bsp_icon_color_active_light);\n\n        mMonthYearTitleView.setTextColor(monthYearTitleColor);\n        mArrowDownDrawable.setTint(dropdownArrowColor);\n        mArrowUpDrawable.setTint(dropdownArrowColor);\n\n        mMonthPickerView.setTheme(context, mThemeDark);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mViewPager.removeOnPageChangeListener(this);\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    void setAccentColor(@ColorInt int color) {\n        mAccentColor = color;\n        mMonthPickerView.setCurrentMonthTextColor(color);\n        mMonthPickerView.setSelectedCirclePaintColor(color);\n    }\n\n    public void onChange() {\n        refreshAdapter();\n        refreshMonthPicker();\n    }\n\n\n    void setupCurrentView(int currentView, boolean animate) {\n        if (currentView == DAY_PICKER_INDEX || currentView == MONTH_PICKER_INDEX) {\n            boolean isDayPicker = currentView == DAY_PICKER_INDEX;\n            setCurrentView(currentView, animate);\n            if (isDayPicker) {\n                setTitle(mAdapter.getPageTitle(mViewPager.getCurrentItem()));\n                toggleArrowsVisibility(getPagerPosition());\n            } else {\n\n\n\n                setTitle(String.valueOf(mCurrentYearDisplayed));\n                toggleArrowsVisibility(false, false);\n            }\n        } else {\n            Log.e(TAG, \"Error restoring current view\");\n        }\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            if (mAccentColor != 0) {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark, mAccentColor);\n            } else {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n            }\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        mViewPager.setAdapter(mAdapter);\n    }\n\n\n    private void refreshMonthPicker() {\n        prepareMonthPickerForDisplay(mSelectedDay.year);\n        mMonthPickerView.invalidate();\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller) {\n        return new PagingMonthAdapter(context, controller);\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark) {\n        return createMonthAdapter(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark,\n                                                 int accentColor) {\n        return new PagingMonthAdapter(context, controller, themeDark, accentColor);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n        final int selectedPosition = getPosition(mSelectedDay);\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = getPosition(day);\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthAndYearDisplayed(mTempDay);\n            if (animate) {\n                mViewPager.setCurrentItem(position, true);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n                return true;\n            } else {\n                postSetSelection(position, setSelected);\n            }\n        } else if (setSelected) {\n            setMonthAndYearDisplayed(mSelectedDay);\n            setSelectedDay(mSelectedDay);\n        }\n        return false;\n    }\n\n\n    private int getPosition(CalendarDay day) {\n        return mAdapter.getPosition(day);\n    }\n\n    public void postSetSelection(final int position, final boolean setSelected) {\n        clearFocus();\n        post(new Runnable() {\n            @Override\n            public void run() {\n                mViewPager.setCurrentItem(position, false);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n            }\n        });\n    }\n\n    void postSetupCurrentView(final int currentView, final boolean animate) {\n        post(new Runnable() {\n            @Override\n            public void run() {\n                setupCurrentView(currentView, animate);\n            }\n        });\n    }\n\n\n    protected void setMonthAndYearDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        mCurrentYearDisplayed = date.year;\n    }\n\n    private void setSelectedDay(CalendarDay day) {\n        mAdapter.setSelectedDay(day);\n    }\n\n    @Override\n    public void onDateChanged() {\n        if (mCurrentView != DAY_PICKER_INDEX) {\n            setCurrentView(DAY_PICKER_INDEX, false);\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getPagerPosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        return true;\n    }\n\n    int getPagerPosition() {\n        return mViewPager.getCurrentItem();\n    }\n\n    int getCurrentView() {\n        return mCurrentView;\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mCurrentView == DAY_PICKER_INDEX) {\n            setTitle(mAdapter.getPageTitle(position));\n            toggleArrowsVisibility(position);\n            final int month = mAdapter.getMonth(position);\n            final int year = mAdapter.getYear(position);\n            if (mCurrentYearDisplayed != year) {\n                mCurrentYearDisplayed = year;\n            }\n            if (mCurrentMonthDisplayed != month) {\n                mCurrentMonthDisplayed = month;\n            }\n        }\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n\n    private void setTitle(CharSequence title) {\n        mMonthYearTitleView.setText(title);\n    }\n\n\n    private void toggleArrowsVisibility(int position) {\n        toggleArrowsVisibility(position > 0, position + 1 < mAdapter.getCount());\n    }\n\n    private void toggleArrowsVisibility(boolean leftVisible, boolean rightVisible) {\n        mPreviousButton.setVisibility(leftVisible ? VISIBLE : INVISIBLE);\n        mNextButton.setVisibility(rightVisible ? VISIBLE : INVISIBLE);\n    }\n\n    private void setArrowDrawableOnTitle(@NonNull Drawable arrow) {\n        if (Utils.checkApiLevel(17)) {\n            mMonthYearTitleView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, arrow, null);\n        } else {\n            mMonthYearTitleView.setCompoundDrawablesWithIntrinsicBounds(null, null, arrow, null);\n        }\n    }\n\n    private void animateArrow(AnimatedVectorDrawableCompat arrow) {\n        setArrowDrawableOnTitle(arrow);\n        arrow.start();\n    }\n\n    private void setCurrentView(final int viewIndex, boolean animate) {\n        switch (viewIndex) {\n            case DAY_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    mMonthAnimator.setDisplayedChild(DAY_PICKER_INDEX, animate);\n                    animateArrow(mArrowUpDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n            case MONTH_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    prepareMonthPickerForDisplay(mCurrentYearDisplayed);\n                    mMonthAnimator.setDisplayedChild(MONTH_PICKER_INDEX, animate);\n                    animateArrow(mArrowDownDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n        }\n    }\n\n    private void prepareMonthPickerForDisplay(int currentYear) {\n        mMonthPickerView.setDisplayParams(mSelectedDay, currentYear);\n    }\n\n    @Override\n    public void onMonthClick(MonthPickerView view, int month, int year) {\n\n\n\n\n\n        setCurrentView(DAY_PICKER_INDEX, true);\n\n\n\n\n\n\n\n\n\n\n        if (month == mCurrentMonthDisplayed) {\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        mController.tryVibrate();\n        mController.onMonthYearSelected(month, year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ]
    },
    {
        "files": [
            "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'",
            "'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'"
        ],
        "content": "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'\n:\npackage org.intellij.jflex.psi;\n\nimport com.intellij.psi.tree.IElementType;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.lang.ASTNode;\nimport org.intellij.jflex.psi.impl.*;\nimport com.intellij.psi.impl.source.tree.CompositePsiElement;\n\npublic interface JFlexTypes {\n\n  IElementType FLEX_CHAR_RANGE = new JFlexCompositeElementType(\"FLEX_CHAR_RANGE\");\n  IElementType FLEX_CHOICE_EXPRESSION = new JFlexCompositeElementType(\"FLEX_CHOICE_EXPRESSION\");\n  IElementType FLEX_CLASS_EXPRESSION = new JFlexCompositeElementType(\"FLEX_CLASS_EXPRESSION\");\n  IElementType FLEX_DECLARATIONS_SECTION = new JFlexCompositeElementType(\"FLEX_DECLARATIONS_SECTION\");\n  IElementType FLEX_EXPRESSION = new JFlexCompositeElementType(\"FLEX_EXPRESSION\");\n  IElementType FLEX_JAVA_CODE = new JFlexCompositeElementType(\"FLEX_JAVA_CODE\");\n  IElementType FLEX_JAVA_NAME = new JFlexCompositeElementType(\"FLEX_JAVA_NAME\");\n  IElementType FLEX_JAVA_TYPE = new JFlexCompositeElementType(\"FLEX_JAVA_TYPE\");\n  IElementType FLEX_JAVA_TYPE_PARAMETERS = new JFlexCompositeElementType(\"FLEX_JAVA_TYPE_PARAMETERS\");\n  IElementType FLEX_LEXICAL_RULES_SECTION = new JFlexCompositeElementType(\"FLEX_LEXICAL_RULES_SECTION\");\n  IElementType FLEX_LITERAL_EXPRESSION = new JFlexCompositeElementType(\"FLEX_LITERAL_EXPRESSION\");\n  IElementType FLEX_LOOK_AHEAD = new JFlexCompositeElementType(\"FLEX_LOOK_AHEAD\");\n  IElementType FLEX_MACRO_DEFINITION = new JFlexCompositeElementType(\"FLEX_MACRO_DEFINITION\");\n  IElementType FLEX_MACRO_REFERENCE = new JFlexCompositeElementType(\"FLEX_MACRO_REFERENCE\");\n  IElementType FLEX_MACRO_REF_EXPRESSION = new JFlexCompositeElementType(\"FLEX_MACRO_REF_EXPRESSION\");\n  IElementType FLEX_NOT_EXPRESSION = new JFlexCompositeElementType(\"FLEX_NOT_EXPRESSION\");\n  IElementType FLEX_OPTION = new JFlexCompositeElementType(\"FLEX_OPTION\");\n  IElementType FLEX_PAREN_EXPRESSION = new JFlexCompositeElementType(\"FLEX_PAREN_EXPRESSION\");\n  IElementType FLEX_PREDEFINED_CLASS_EXPRESSION = new JFlexCompositeElementType(\"FLEX_PREDEFINED_CLASS_EXPRESSION\");\n  IElementType FLEX_QUANTIFIER_EXPRESSION = new JFlexCompositeElementType(\"FLEX_QUANTIFIER_EXPRESSION\");\n  IElementType FLEX_RULE = new JFlexCompositeElementType(\"FLEX_RULE\");\n  IElementType FLEX_SEQUENCE_EXPRESSION = new JFlexCompositeElementType(\"FLEX_SEQUENCE_EXPRESSION\");\n  IElementType FLEX_STATE_DECLARATION = new JFlexCompositeElementType(\"FLEX_STATE_DECLARATION\");\n  IElementType FLEX_STATE_DEFINITION = new JFlexCompositeElementType(\"FLEX_STATE_DEFINITION\");\n  IElementType FLEX_STATE_LIST = new JFlexCompositeElementType(\"FLEX_STATE_LIST\");\n  IElementType FLEX_STATE_REFERENCE = new JFlexCompositeElementType(\"FLEX_STATE_REFERENCE\");\n  IElementType FLEX_USER_CODE_SECTION = new JFlexCompositeElementType(\"FLEX_USER_CODE_SECTION\");\n  IElementType FLEX_USER_VALUE = new JFlexCompositeElementType(\"FLEX_USER_VALUE\");\n\n  IElementType FLEX_AMPAMP = new JFlexTokenType(\"&&\");\n  IElementType FLEX_ANGLE1 = new JFlexTokenType(\"<\");\n  IElementType FLEX_ANGLE2 = new JFlexTokenType(\">\");\n  IElementType FLEX_BANG = new JFlexTokenType(\"!\");\n  IElementType FLEX_BAR = new JFlexTokenType(\"|\");\n  IElementType FLEX_BARBAR = new JFlexTokenType(\"||\");\n  IElementType FLEX_BLOCK_COMMENT = new JFlexTokenType(\"block_comment\");\n  IElementType FLEX_BRACE1 = new JFlexTokenType(\"{\");\n  IElementType FLEX_BRACE2 = new JFlexTokenType(\"}\");\n  IElementType FLEX_BRACK1 = new JFlexTokenType(\"[\");\n  IElementType FLEX_BRACK2 = new JFlexTokenType(\"]\");\n  IElementType FLEX_CHAR = new JFlexTokenType(\"char\");\n  IElementType FLEX_CHAR_CLASS = new JFlexTokenType(\"char_class\");\n  IElementType FLEX_CHAR_ESC = new JFlexTokenType(\"char_esc\");\n  IElementType FLEX_COMMA = new JFlexTokenType(\",\");\n  IElementType FLEX_DASH = new JFlexTokenType(\"-\");\n  IElementType FLEX_DASHDASH = new JFlexTokenType(\"--\");\n  IElementType FLEX_DOLLAR = new JFlexTokenType(\"$\");\n  IElementType FLEX_DOT = new JFlexTokenType(\".\");\n  IElementType FLEX_EOF = new JFlexTokenType(\"<<EOF>>\");\n  IElementType FLEX_EQ = new JFlexTokenType(\"=\");\n  IElementType FLEX_FSLASH = new JFlexTokenType(\"/\");\n  IElementType FLEX_HAT = new JFlexTokenType(\"^\");\n  IElementType FLEX_ID = new JFlexTokenType(\"id\");\n  IElementType FLEX_LINE_COMMENT = new JFlexTokenType(\"line_comment\");\n  IElementType FLEX_NUMBER = new JFlexTokenType(\"number\");\n  IElementType FLEX_OPT16BIT = new JFlexTokenType(\"%16bit\");\n  IElementType FLEX_OPT_7BIT = new JFlexTokenType(\"%7bit\");\n  IElementType FLEX_OPT_8BIT = new JFlexTokenType(\"%8bit\");\n  IElementType FLEX_OPT_ABSTRACT = new JFlexTokenType(\"%abstract\");\n  IElementType FLEX_OPT_APIPRIVATE = new JFlexTokenType(\"%apiprivate\");\n  IElementType FLEX_OPT_BUFFER = new JFlexTokenType(\"%buffer\");\n  IElementType FLEX_OPT_CASELESS = new JFlexTokenType(\"%caseless\");\n  IElementType FLEX_OPT_CHAR = new JFlexTokenType(\"%char\");\n  IElementType FLEX_OPT_CLASS = new JFlexTokenType(\"%class\");\n  IElementType FLEX_OPT_CODE1 = new JFlexTokenType(\"%{\");\n  IElementType FLEX_OPT_CODE2 = new JFlexTokenType(\"%}\");\n  IElementType FLEX_OPT_COLUMN = new JFlexTokenType(\"%column\");\n  IElementType FLEX_OPT_CTORARG = new JFlexTokenType(\"%ctorarg\");\n  IElementType FLEX_OPT_CUP = new JFlexTokenType(\"%cup\");\n  IElementType FLEX_OPT_CUPDEBUG = new JFlexTokenType(\"%cupdebug\");\n  IElementType FLEX_OPT_CUPSYM = new JFlexTokenType(\"%cupsym\");\n  IElementType FLEX_OPT_DEBUG = new JFlexTokenType(\"%debug\");\n  IElementType FLEX_OPT_EOF1 = new JFlexTokenType(\"%eof{\");\n  IElementType FLEX_OPT_EOF2 = new JFlexTokenType(\"%eof}\");\n  IElementType FLEX_OPT_EOFCLOSE = new JFlexTokenType(\"%eofclose\");\n  IElementType FLEX_OPT_EOFTHROW = new JFlexTokenType(\"%eofthrow\");\n  IElementType FLEX_OPT_EOFTHROW1 = new JFlexTokenType(\"%eofthrow{\");\n  IElementType FLEX_OPT_EOFTHROW2 = new JFlexTokenType(\"%eofthrow}\");\n  IElementType FLEX_OPT_EOFVAL1 = new JFlexTokenType(\"%eofval{\");\n  IElementType FLEX_OPT_EOFVAL2 = new JFlexTokenType(\"%eofval}\");\n  IElementType FLEX_OPT_EXTENDS = new JFlexTokenType(\"%extends\");\n  IElementType FLEX_OPT_FINAL = new JFlexTokenType(\"%final\");\n  IElementType FLEX_OPT_FULL = new JFlexTokenType(\"%full\");\n  IElementType FLEX_OPT_FUNCTION = new JFlexTokenType(\"%function\");\n  IElementType FLEX_OPT_IGNORECASE = new JFlexTokenType(\"%ignorecase\");\n  IElementType FLEX_OPT_IMPLEMENTS = new JFlexTokenType(\"%implements\");\n  IElementType FLEX_OPT_INCLUDE = new JFlexTokenType(\"%include\");\n  IElementType FLEX_OPT_INIT1 = new JFlexTokenType(\"%init{\");\n  IElementType FLEX_OPT_INIT2 = new JFlexTokenType(\"%init}\");\n  IElementType FLEX_OPT_INITTHROW = new JFlexTokenType(\"%initthrow\");\n  IElementType FLEX_OPT_INITTHROW1 = new JFlexTokenType(\"%initthrow{\");\n  IElementType FLEX_OPT_INITTHROW2 = new JFlexTokenType(\"%initthrow}\");\n  IElementType FLEX_OPT_INT = new JFlexTokenType(\"%int\");\n  IElementType FLEX_OPT_INTEGER = new JFlexTokenType(\"%integer\");\n  IElementType FLEX_OPT_INTWRAP = new JFlexTokenType(\"%intwrap\");\n  IElementType FLEX_OPT_LINE = new JFlexTokenType(\"%line\");\n  IElementType FLEX_OPT_NOTUNIX = new JFlexTokenType(\"%notunix\");\n  IElementType FLEX_OPT_PUBLIC = new JFlexTokenType(\"%public\");\n  IElementType FLEX_OPT_SCANERROR = new JFlexTokenType(\"%scanerror\");\n  IElementType FLEX_OPT_STANDALONE = new JFlexTokenType(\"%standalone\");\n  IElementType FLEX_OPT_STATE = new JFlexTokenType(\"%state\");\n  IElementType FLEX_OPT_TYPE = new JFlexTokenType(\"%type\");\n  IElementType FLEX_OPT_UNICODE = new JFlexTokenType(\"%unicode\");\n  IElementType FLEX_OPT_XSTATE = new JFlexTokenType(\"%xstate\");\n  IElementType FLEX_OPT_YYEOF = new JFlexTokenType(\"%yyeof\");\n  IElementType FLEX_OPT_YYLEXTHROW = new JFlexTokenType(\"%yylexthrow\");\n  IElementType FLEX_OPT_YYLEXTHROW1 = new JFlexTokenType(\"%yylexthrow{\");\n  IElementType FLEX_OPT_YYLEXTHROW2 = new JFlexTokenType(\"%yylexthrow}\");\n  IElementType FLEX_PAREN1 = new JFlexTokenType(\"(\");\n  IElementType FLEX_PAREN2 = new JFlexTokenType(\")\");\n  IElementType FLEX_PLUS = new JFlexTokenType(\"+\");\n  IElementType FLEX_QUESTION = new JFlexTokenType(\"?\");\n  IElementType FLEX_RAW = new JFlexTokenType(\"code block\");\n  IElementType FLEX_STAR = new JFlexTokenType(\"*\");\n  IElementType FLEX_STRING = new JFlexTokenType(\"string\");\n  IElementType FLEX_TILDE = new JFlexTokenType(\"~\");\n  IElementType FLEX_TILDETILDE = new JFlexTokenType(\"~~\");\n  IElementType FLEX_TWO_PERCS = new JFlexTokenType(\"%%\");\n  IElementType FLEX_UNCLOSED = new JFlexTokenType(\"unclosed\");\n  IElementType FLEX_VERSION = new JFlexTokenType(\"version\");\n\n  class Factory {\n    public static CompositePsiElement createElement(IElementType type) {\n       if (type == FLEX_CHAR_RANGE) {\n        return new JFlexCharRangeImpl(type);\n      }\n      else if (type == FLEX_CHOICE_EXPRESSION) {\n        return new JFlexChoiceExpressionImpl(type);\n      }\n      else if (type == FLEX_CLASS_EXPRESSION) {\n        return new JFlexClassExpressionImpl(type);\n      }\n      else if (type == FLEX_DECLARATIONS_SECTION) {\n        return new JFlexDeclarationsSectionImpl(type);\n      }\n      else if (type == FLEX_JAVA_CODE) {\n        return new JFlexJavaCodeImpl(type);\n      }\n      else if (type == FLEX_JAVA_NAME) {\n        return new JFlexJavaNameImpl(type);\n      }\n      else if (type == FLEX_JAVA_TYPE) {\n        return new JFlexJavaTypeImpl(type);\n      }\n      else if (type == FLEX_JAVA_TYPE_PARAMETERS) {\n        return new JFlexJavaTypeParametersImpl(type);\n      }\n      else if (type == FLEX_LEXICAL_RULES_SECTION) {\n        return new JFlexLexicalRulesSectionImpl(type);\n      }\n      else if (type == FLEX_LITERAL_EXPRESSION) {\n        return new JFlexLiteralExpressionImpl(type);\n      }\n      else if (type == FLEX_LOOK_AHEAD) {\n        return new JFlexLookAheadImpl(type);\n      }\n      else if (type == FLEX_MACRO_DEFINITION) {\n        return new JFlexMacroDefinitionImpl(type);\n      }\n      else if (type == FLEX_MACRO_REFERENCE) {\n        return new JFlexMacroReferenceImpl(type);\n      }\n      else if (type == FLEX_MACRO_REF_EXPRESSION) {\n        return new JFlexMacroRefExpressionImpl(type);\n      }\n      else if (type == FLEX_NOT_EXPRESSION) {\n        return new JFlexNotExpressionImpl(type);\n      }\n      else if (type == FLEX_OPTION) {\n        return new JFlexOptionImpl(type);\n      }\n      else if (type == FLEX_PAREN_EXPRESSION) {\n        return new JFlexParenExpressionImpl(type);\n      }\n      else if (type == FLEX_PREDEFINED_CLASS_EXPRESSION) {\n        return new JFlexPredefinedClassExpressionImpl(type);\n      }\n      else if (type == FLEX_QUANTIFIER_EXPRESSION) {\n        return new JFlexQuantifierExpressionImpl(type);\n      }\n      else if (type == FLEX_RULE) {\n        return new JFlexRuleImpl(type);\n      }\n      else if (type == FLEX_SEQUENCE_EXPRESSION) {\n        return new JFlexSequenceExpressionImpl(type);\n      }\n      else if (type == FLEX_STATE_DECLARATION) {\n        return new JFlexStateDeclarationImpl(type);\n      }\n      else if (type == FLEX_STATE_DEFINITION) {\n        return new JFlexStateDefinitionImpl(type);\n      }\n      else if (type == FLEX_STATE_LIST) {\n        return new JFlexStateListImpl(type);\n      }\n      else if (type == FLEX_STATE_REFERENCE) {\n        return new JFlexStateReferenceImpl(type);\n      }\n      else if (type == FLEX_USER_CODE_SECTION) {\n        return new JFlexUserCodeSectionImpl(type);\n      }\n      else if (type == FLEX_USER_VALUE) {\n        return new JFlexUserValueImpl(type);\n      }\n      throw new AssertionError(\"Unknown element type: \" + type);\n    }\n  }\n}\n\n'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'\n:\n\npackage org.intellij.jflex.editor;\n\nimport com.intellij.lexer.Lexer;\nimport com.intellij.openapi.editor.DefaultLanguageHighlighterColors;\nimport com.intellij.openapi.editor.HighlighterColors;\nimport com.intellij.openapi.editor.colors.EditorColors;\nimport com.intellij.openapi.editor.colors.TextAttributesKey;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighter;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighterBase;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighterFactory;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.TokenType;\nimport com.intellij.psi.tree.IElementType;\nimport org.intellij.jflex.parser.JFlexLexer;\nimport org.jetbrains.annotations.NotNull;\n\nimport static com.intellij.openapi.editor.colors.TextAttributesKey.createTextAttributesKey;\nimport static org.intellij.jflex.psi.JFlexTokenSets.CHAR_CLASS_OPERATORS;\nimport static org.intellij.jflex.psi.JFlexTokenSets.PATTERN_OPERATORS;\nimport static org.intellij.jflex.psi.JFlexTypes.*;\n\nfinal class JFlexSyntaxHighlighterFactory extends SyntaxHighlighterFactory {\n  public static final TextAttributesKey ILLEGAL    = createTextAttributesKey(\"FLEX_ILLEGAL\", HighlighterColors.BAD_CHARACTER);\n\n  public static final TextAttributesKey MACRO      = createTextAttributesKey(\"FLEX_MACRO\", DefaultLanguageHighlighterColors.INSTANCE_FIELD);\n  public static final TextAttributesKey STATE      = createTextAttributesKey(\"FLEX_STATE\", DefaultLanguageHighlighterColors.CLASS_NAME);\n  public static final TextAttributesKey CLASS      = createTextAttributesKey(\"FLEX_CLASS\");\n  public static final TextAttributesKey PATTERN_OP = createTextAttributesKey(\"FLEX_PATTERN_OP\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey CLASS_OP   = createTextAttributesKey(\"FLEX_CHAR_CLASS_OP\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey OP_RANGE   = createTextAttributesKey(\"FLEX_OP_RANGE\", DefaultLanguageHighlighterColors.KEYWORD);\n\n  public static final TextAttributesKey COMMENT    = createTextAttributesKey(\"FLEX_COMMENT\", DefaultLanguageHighlighterColors.LINE_COMMENT);\n  public static final TextAttributesKey OPTION     = createTextAttributesKey(\"FLEX_OPTION\", DefaultLanguageHighlighterColors.LABEL);\n  public static final TextAttributesKey RAW_CODE   = createTextAttributesKey(\"FLEX_RAW_CODE\", EditorColors.INJECTED_LANGUAGE_FRAGMENT);\n  public static final TextAttributesKey SECT_DIV   = createTextAttributesKey(\"FLEX_SECTION_DIV\", DefaultLanguageHighlighterColors.LABEL);\n\n  public static final TextAttributesKey STRING     = createTextAttributesKey(\"FLEX_STRING\", DefaultLanguageHighlighterColors.STRING);\n  public static final TextAttributesKey CHAR       = createTextAttributesKey(\"FLEX_CHAR\", DefaultLanguageHighlighterColors.STRING);\n  public static final TextAttributesKey CHAR_ESC   = createTextAttributesKey(\"FLEX_CHAR_ESC\", DefaultLanguageHighlighterColors.VALID_STRING_ESCAPE);\n  public static final TextAttributesKey NUMBER     = createTextAttributesKey(\"FLEX_NUMBER\", DefaultLanguageHighlighterColors.NUMBER);\n\n  public static final TextAttributesKey CLASS_STD  = createTextAttributesKey(\"FLEX_PREDEFINED_CLASS\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey DOT        = createTextAttributesKey(\"FLEX_DOT\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey EOF        = createTextAttributesKey(\"FLEX_SECTION_DIV\", DefaultLanguageHighlighterColors.LABEL);\n  public static final TextAttributesKey LOOKAHEAD  = createTextAttributesKey(\"FLEX_LOOKAHEAD\", DefaultLanguageHighlighterColors.OPERATION_SIGN);\n\n  public static final TextAttributesKey COMMA      = createTextAttributesKey(\"FLEX_COMMA\", DefaultLanguageHighlighterColors.COMMA);\n  public static final TextAttributesKey OP_EQUAL   = createTextAttributesKey(\"FLEX_OP_EQUAL\", DefaultLanguageHighlighterColors.OPERATION_SIGN);\n  public static final TextAttributesKey PARENS     = createTextAttributesKey(\"FLEX_PARENS\", DefaultLanguageHighlighterColors.PARENTHESES);\n  public static final TextAttributesKey BRACES     = createTextAttributesKey(\"FLEX_BRACES\", DefaultLanguageHighlighterColors.BRACES);\n  public static final TextAttributesKey BRACKETS   = createTextAttributesKey(\"FLEX_BRACKETS\", DefaultLanguageHighlighterColors.BRACKETS);\n  public static final TextAttributesKey ANGLES     = createTextAttributesKey(\"FLEX_ANGLES\", DefaultLanguageHighlighterColors.BRACKETS);\n\n\n  @Override\n  public @NotNull SyntaxHighlighter getSyntaxHighlighter(Project project, VirtualFile virtualFile) {\n    return new JFlexSyntaxHighlighter();\n  }\n\n  private static class JFlexSyntaxHighlighter extends SyntaxHighlighterBase {\n    @Override\n    public @NotNull Lexer getHighlightingLexer() {\n      return new JFlexLexer();\n    }\n\n    @Override\n    public @NotNull TextAttributesKey @NotNull [] getTokenHighlights(IElementType o) {\n      if (o == FLEX_LINE_COMMENT || o == FLEX_BLOCK_COMMENT) return pack(COMMENT);\n      if (o == FLEX_RAW) return pack(RAW_CODE);\n      if (o == FLEX_TWO_PERCS) return pack(SECT_DIV);\n      if (o == FLEX_STRING) return pack(STRING);\n      if (o == FLEX_CHAR) return pack(CHAR);\n      if (o == FLEX_CHAR_ESC) return pack(CHAR_ESC);\n      if (o == FLEX_NUMBER || o == FLEX_VERSION) return pack(NUMBER);\n      if (o == FLEX_CHAR_CLASS) return pack(CLASS_STD);\n      if (o == FLEX_EOF) return pack(EOF);\n      if (o == FLEX_FSLASH) return pack(LOOKAHEAD);\n      if (o == FLEX_COMMA) return pack(COMMA);\n      if (o == FLEX_DOT) return pack(DOT);\n      if (o == FLEX_EQ) return pack(OP_EQUAL);\n      if (o == FLEX_DASH) return pack(OP_RANGE);\n      if (o == FLEX_PAREN1 || o == FLEX_PAREN2) return pack(PARENS);\n      if (o == FLEX_BRACE1 || o == FLEX_BRACE2) return pack(BRACES);\n      if (o == FLEX_BRACK1 || o == FLEX_BRACK2) return pack(BRACKETS);\n      if (o == FLEX_ANGLE1 || o == FLEX_ANGLE2) return pack(ANGLES);\n      if (PATTERN_OPERATORS.contains(o)) return pack(PATTERN_OP);\n      if (CHAR_CLASS_OPERATORS.contains(o)) return pack(CLASS_OP);\n      if (o == FLEX_UNCLOSED || o == TokenType.BAD_CHARACTER) return pack(ILLEGAL);\n      if (o.toString().startsWith(\"%\")) return pack(OPTION);\n      return TextAttributesKey.EMPTY_ARRAY;\n    }\n  }\n}\n\n'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'\n:\n\npackage org.intellij.jflex.editor;\n\nimport com.intellij.openapi.editor.colors.TextAttributesKey;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighter;\nimport com.intellij.openapi.options.colors.AttributesDescriptor;\nimport com.intellij.openapi.options.colors.ColorDescriptor;\nimport com.intellij.openapi.options.colors.ColorSettingsPage;\nimport com.intellij.util.containers.ContainerUtil;\nimport org.intellij.grammar.GrammarKitBundle;\nimport org.intellij.jflex.parser.JFlexFileType;\nimport org.jetbrains.annotations.NotNull;\n\nimport javax.swing.*;\nimport java.util.Arrays;\nimport java.util.Map;\n\nimport static org.intellij.jflex.editor.JFlexSyntaxHighlighterFactory.*;\n\n\nfinal class JFlexColorSettingsPage implements ColorSettingsPage {\n  private static final AttributesDescriptor[] ATTRS;\n\n  static {\n    ATTRS = new AttributesDescriptor[]{\n      new AttributesDescriptor(\"Illegal symbol\", ILLEGAL),\n\n      new AttributesDescriptor(\"Macro\", MACRO),\n      new AttributesDescriptor(\"State\", STATE),\n      new AttributesDescriptor(\"Character class\", CLASS),\n      new AttributesDescriptor(\"Pattern operator\", PATTERN_OP),\n      new AttributesDescriptor(\"Character class operator\", CLASS_OP),\n\n      new AttributesDescriptor(\"Comment\", COMMENT),\n      new AttributesDescriptor(\"Lexer option\", OPTION),\n      new AttributesDescriptor(\"Java code\", RAW_CODE),\n      new AttributesDescriptor(\"Section divider\", SECT_DIV),\n\n      new AttributesDescriptor(\"String\", STRING),\n      new AttributesDescriptor(\"Character\", CHAR),\n      new AttributesDescriptor(\"Character escape\", CHAR_ESC),\n      new AttributesDescriptor(\"Number\", NUMBER),\n\n      new AttributesDescriptor(\"Predefined character class\", CLASS_STD),\n      new AttributesDescriptor(\"EOF matcher\", EOF),\n      new AttributesDescriptor(\"Lookahead separator\", LOOKAHEAD),\n\n      new AttributesDescriptor(\"Comma\", COMMA),\n      new AttributesDescriptor(\"Dot\", DOT),\n      new AttributesDescriptor(\"Equal sign\", OP_EQUAL),\n      new AttributesDescriptor(\"Range operator\", OP_RANGE),\n      new AttributesDescriptor(\"Parentheses\", PARENS),\n      new AttributesDescriptor(\"Curly braces\", BRACES),\n      new AttributesDescriptor(\"Square brackets\", BRACKETS),\n      new AttributesDescriptor(\"Angle brackets\", ANGLES),\n    };\n  }\n\n  @Override\n  public @NotNull String getDisplayName() {\n    return GrammarKitBundle.message(\"language.name.jflex\");\n  }\n\n  @Override\n  public Icon getIcon() {\n    return JFlexFileType.INSTANCE.getIcon();\n  }\n\n  @Override\n  public AttributesDescriptor @NotNull [] getAttributeDescriptors() {\n    return ATTRS;\n  }\n\n  @Override\n  public ColorDescriptor @NotNull [] getColorDescriptors() {\n    return ColorDescriptor.EMPTY_ARRAY;\n  }\n\n  @Override\n  public @NotNull SyntaxHighlighter getHighlighter() {\n    return new JFlexSyntaxHighlighterFactory().getSyntaxHighlighter(null, null);\n  }\n\n  @Override\n  public @NotNull String getDemoText() {\n    return \"\"\"\n\n      package sample.lexer;\n\n      %%\n      %public\n      %class _MyLexer\n      %unicode\n      %{\n        private int parenCount;\n      %}\n\n\n      %state <s>BLOCK</s>, <s>QUALIFICATION</s>\n\n\n      <m>WHITESPACE</m>=<c>[ \\\\n\\\\r\\\\t]</c>\n      <m>ESCAPED_CHAR</m>=\\\\\\\\.\n      <m>STRING</m>=\\\\\"(<c>[^\\\\\"\\\\\\\\]</c>|\\\\\\\\.)*\\\\\"\n      <m>ID</m> = [a-z_&&[A-Z]]([:letter:]|[:digit:]|_)*\n      <m>BLOCK_COMMENT</m>=\"\n      <m>NUMBER</m>=<c>[+-]</c>[:digit:]+\n      <m>FLOAT</m>=<m>{NUMBER}</m>(\\\\.[:digit:]){1, 3}\n\n      %%\n      <<s>YYINITIAL</s>, <s>BLOCK</s>> {\n          <m>{WHITESPACE}</m>      { return WHITESPACE; }\n          <m>{STRING}</m>          { return STRING; }\n          \"(\"               { return PAREN1; }\n          \")\"               { return PAREN2; }\n          \".\" / !<<EOF>>    { yybegin(QUALIFICATION); return DOT; }\n          <c>[^]</c>               { return BAD_CHARACTER; }\n      }\n      \"\"\";\n  }\n\n  @Override\n  public Map<String, TextAttributesKey> getAdditionalHighlightingTagToDescriptorMap() {\n    return ContainerUtil.newHashMap(Arrays.asList(\"s\", \"m\", \"c\"), Arrays.asList(STATE, MACRO, CLASS));\n  }\n}\n'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'\n:\n\npackage org.intellij.jflex.psi;\n\nimport com.intellij.psi.TokenType;\nimport com.intellij.psi.tree.IElementType;\nimport com.intellij.psi.tree.TokenSet;\n\nimport static org.intellij.jflex.psi.JFlexTypes.*;\n\npublic final class JFlexTokenSets {\n  public static final IElementType FLEX_NEWLINE = new JFlexTokenType(\"newline\");\n\n  public static final TokenSet WS = TokenSet.create(TokenType.WHITE_SPACE, FLEX_NEWLINE);\n\n  public static final TokenSet COMMENTS = TokenSet.create(FLEX_LINE_COMMENT, FLEX_BLOCK_COMMENT);\n  public static final TokenSet LITERALS = TokenSet.create(FLEX_STRING);\n\n  public static final TokenSet CHAR_CLASS_OPERATORS =\n    TokenSet.create(FLEX_AMPAMP, FLEX_BARBAR, FLEX_DASHDASH, FLEX_HAT, FLEX_TILDETILDE);\n  public static final TokenSet PATTERN_OPERATORS =\n    TokenSet.create(FLEX_BAR, FLEX_BANG, FLEX_DOLLAR, FLEX_PLUS, FLEX_QUESTION, FLEX_STAR, FLEX_TILDE);\n}\n",
        "gt": [
            "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'",
            "'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'"
        ]
    },
    {
        "files": [
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'"
        ],
        "content": "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'\n:\n\npackage com.netflix.iceberg.data.parquet;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.data.GenericRecord;\nimport com.netflix.iceberg.data.Record;\nimport com.netflix.iceberg.parquet.ParquetValueReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.BinaryAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.BytesReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.IntAsLongReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.IntegerAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.ListReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.LongAsDecimalReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.MapReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.PrimitiveReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.StringReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.StructReader;\nimport com.netflix.iceberg.parquet.ParquetValueReaders.UnboxedReader;\nimport com.netflix.iceberg.parquet.TypeWithSchemaVisitor;\nimport com.netflix.iceberg.types.Type.TypeID;\nimport com.netflix.iceberg.types.Types;\nimport com.netflix.iceberg.types.Types.StructType;\nimport com.netflix.iceberg.types.Types.TimestampType;\nimport org.apache.parquet.column.ColumnDescriptor;\nimport org.apache.parquet.schema.DecimalMetadata;\nimport org.apache.parquet.schema.GroupType;\nimport org.apache.parquet.schema.MessageType;\nimport org.apache.parquet.schema.PrimitiveType;\nimport org.apache.parquet.schema.Type;\n\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.parquet.ParquetSchemaUtil.hasIds;\nimport static com.netflix.iceberg.parquet.ParquetValueReaders.option;\n\npublic class GenericParquetReaders {\n  private GenericParquetReaders() {\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public static ParquetValueReader<GenericRecord> buildReader(Schema expectedSchema,\n                                                              MessageType fileSchema) {\n    if (hasIds(fileSchema)) {\n      return (ParquetValueReader<GenericRecord>)\n          TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n              new ReadBuilder(fileSchema));\n    } else {\n      return (ParquetValueReader<GenericRecord>)\n          TypeWithSchemaVisitor.visit(expectedSchema.asStruct(), fileSchema,\n              new FallbackReadBuilder(fileSchema));\n    }\n  }\n\n  private static class FallbackReadBuilder extends ReadBuilder {\n    FallbackReadBuilder(MessageType type) {\n      super(type);\n    }\n\n    @Override\n    public ParquetValueReader<?> message(StructType expected, MessageType message,\n                                         List<ParquetValueReader<?>> fieldReaders) {\n\n      return super.struct(expected, message, fieldReaders);\n    }\n\n    @Override\n    public ParquetValueReader<?> struct(StructType expected, GroupType struct,\n                                        List<ParquetValueReader<?>> fieldReaders) {\n\n      List<ParquetValueReader<?>> newFields = Lists.newArrayListWithExpectedSize(\n          fieldReaders.size());\n      List<Type> types = Lists.newArrayListWithExpectedSize(fieldReaders.size());\n      List<Type> fields = struct.getFields();\n      for (int i = 0; i < fields.size(); i += 1) {\n        Type fieldType = fields.get(i);\n        int fieldD = type.getMaxDefinitionLevel(path(fieldType.getName()))-1;\n        newFields.add(option(fieldType, fieldD, fieldReaders.get(i)));\n        types.add(fieldType);\n      }\n\n      return new RecordReader(types, newFields, expected);\n    }\n  }\n\n  private static class ReadBuilder extends TypeWithSchemaVisitor<ParquetValueReader<?>> {\n    final MessageType type;\n\n    ReadBuilder(MessageType type) {\n      this.type = type;\n    }\n\n    @Override\n    public ParquetValueReader<?> message(StructType expected, MessageType message,\n                                         List<ParquetValueReader<?>> fieldReaders) {\n      return struct(expected, message.asGroupType(), fieldReaders);\n    }\n\n    @Override\n    public ParquetValueReader<?> struct(StructType expected, GroupType struct,\n                                        List<ParquetValueReader<?>> fieldReaders) {\n\n      Map<Integer, ParquetValueReader<?>> readersById = Maps.newHashMap();\n      Map<Integer, Type> typesById = Maps.newHashMap();\n      List<Type> fields = struct.getFields();\n      for (int i = 0; i < fields.size(); i += 1) {\n        Type fieldType = fields.get(i);\n        int fieldD = type.getMaxDefinitionLevel(path(fieldType.getName()))-1;\n        int id = fieldType.getId().intValue();\n        readersById.put(id, option(fieldType, fieldD, fieldReaders.get(i)));\n        typesById.put(id, fieldType);\n      }\n\n      List<Types.NestedField> expectedFields = expected != null ?\n          expected.fields() : ImmutableList.of();\n      List<ParquetValueReader<?>> reorderedFields = Lists.newArrayListWithExpectedSize(\n          expectedFields.size());\n      List<Type> types = Lists.newArrayListWithExpectedSize(expectedFields.size());\n      for (Types.NestedField field : expectedFields) {\n        int id = field.fieldId();\n        ParquetValueReader<?> reader = readersById.get(id);\n        if (reader != null) {\n          reorderedFields.add(reader);\n          types.add(typesById.get(id));\n        } else {\n          reorderedFields.add(ParquetValueReaders.nulls());\n          types.add(null);\n        }\n      }\n\n      return new RecordReader(types, reorderedFields, expected);\n    }\n\n    @Override\n    public ParquetValueReader<?> list(Types.ListType expectedList, GroupType array,\n                                      ParquetValueReader<?> elementReader) {\n      GroupType repeated = array.getFields().get(0).asGroupType();\n      String[] repeatedPath = currentPath();\n\n      int repeatedD = type.getMaxDefinitionLevel(repeatedPath)-1;\n      int repeatedR = type.getMaxRepetitionLevel(repeatedPath)-1;\n\n      Type elementType = repeated.getType(0);\n      int elementD = type.getMaxDefinitionLevel(path(elementType.getName()))-1;\n\n      return new ListReader<>(repeatedD, repeatedR, option(elementType, elementD, elementReader));\n    }\n\n    @Override\n    public ParquetValueReader<?> map(Types.MapType expectedMap, GroupType map,\n                                     ParquetValueReader<?> keyReader,\n                                     ParquetValueReader<?> valueReader) {\n      GroupType repeatedKeyValue = map.getFields().get(0).asGroupType();\n      String[] repeatedPath = currentPath();\n\n      int repeatedD = type.getMaxDefinitionLevel(repeatedPath)-1;\n      int repeatedR = type.getMaxRepetitionLevel(repeatedPath)-1;\n\n      Type keyType = repeatedKeyValue.getType(0);\n      int keyD = type.getMaxDefinitionLevel(path(keyType.getName()))-1;\n      Type valueType = repeatedKeyValue.getType(1);\n      int valueD = type.getMaxDefinitionLevel(path(valueType.getName()))-1;\n\n      return new MapReader<>(repeatedD, repeatedR,\n          option(keyType, keyD, keyReader), option(valueType, valueD, valueReader));\n    }\n\n    @Override\n    public ParquetValueReader<?> primitive(com.netflix.iceberg.types.Type.PrimitiveType expected,\n                                           PrimitiveType primitive) {\n      ColumnDescriptor desc = type.getColumnDescription(currentPath());\n\n      if (primitive.getOriginalType() != null) {\n        switch (primitive.getOriginalType()) {\n          case ENUM:\n          case JSON:\n          case UTF8:\n            return new StringReader(desc);\n          case INT_8:\n          case INT_16:\n          case INT_32:\n            if (expected.typeId() == TypeID.LONG) {\n              return new IntAsLongReader(desc);\n            } else {\n              return new UnboxedReader<>(desc);\n            }\n          case INT_64:\n            return new UnboxedReader<>(desc);\n          case DATE:\n            return new DateReader(desc);\n          case TIMESTAMP_MICROS:\n            TimestampType tsMicrosType = (TimestampType) expected;\n            if (tsMicrosType.shouldAdjustToUTC()) {\n              return new TimestamptzReader(desc);\n            } else {\n              return new TimestampReader(desc);\n            }\n          case TIMESTAMP_MILLIS:\n            TimestampType tsMillisType = (TimestampType) expected;\n            if (tsMillisType.shouldAdjustToUTC()) {\n              return new TimestamptzMillisReader(desc);\n            } else {\n              return new TimestampMillisReader(desc);\n            }\n          case DECIMAL:\n            DecimalMetadata decimal = primitive.getDecimalMetadata();\n            switch (primitive.getPrimitiveTypeName()) {\n              case BINARY:\n              case FIXED_LEN_BYTE_ARRAY:\n                return new BinaryAsDecimalReader(desc, decimal.getScale());\n              case INT64:\n                return new LongAsDecimalReader(desc, decimal.getScale());\n              case INT32:\n                return new IntegerAsDecimalReader(desc, decimal.getScale());\n              default:\n                throw new UnsupportedOperationException(\n                    \"Unsupported base type for decimal: \" + primitive.getPrimitiveTypeName());\n            }\n          case BSON:\n            return new BytesReader(desc);\n          default:\n            throw new UnsupportedOperationException(\n                \"Unsupported logical type: \" + primitive.getOriginalType());\n        }\n      }\n\n      switch (primitive.getPrimitiveTypeName()) {\n        case FIXED_LEN_BYTE_ARRAY:\n          return new FixedReader(desc);\n        case BINARY:\n          return new BytesReader(desc);\n        case INT32:\n          if (expected != null && expected.typeId() == TypeID.LONG) {\n            return new IntAsLongReader(desc);\n          } else {\n            return new UnboxedReader<>(desc);\n          }\n        case FLOAT:\n          if (expected != null && expected.typeId() == TypeID.DOUBLE) {\n            return new ParquetValueReaders.FloatAsDoubleReader(desc);\n          } else {\n            return new UnboxedReader<>(desc);\n          }\n        case BOOLEAN:\n        case INT64:\n        case DOUBLE:\n          return new UnboxedReader<>(desc);\n        default:\n          throw new UnsupportedOperationException(\"Unsupported type: \" + primitive);\n      }\n    }\n\n    private String[] currentPath() {\n      String[] path = new String[fieldNames.size()];\n      if (!fieldNames.isEmpty()) {\n        Iterator<String> iter = fieldNames.descendingIterator();\n        for (int i = 0; iter.hasNext(); i += 1) {\n          path[i] = iter.next();\n        }\n      }\n\n      return path;\n    }\n\n    protected String[] path(String name) {\n      String[] path = new String[fieldNames.size() + 1];\n      path[fieldNames.size()] = name;\n\n      if (!fieldNames.isEmpty()) {\n        Iterator<String> iter = fieldNames.descendingIterator();\n        for (int i = 0; iter.hasNext(); i += 1) {\n          path[i] = iter.next();\n        }\n      }\n\n      return path;\n    }\n  }\n\n  private static final OffsetDateTime EPOCH = Instant.ofEpochSecond(0).atOffset(ZoneOffset.UTC);\n  private static final LocalDate EPOCH_DAY = EPOCH.toLocalDate();\n\n  private static class DateReader extends PrimitiveReader<LocalDate> {\n    private DateReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDate read(LocalDate reuse) {\n      return EPOCH_DAY.plusDays(column.nextInteger());\n    }\n  }\n\n  private static class TimestampReader extends PrimitiveReader<LocalDateTime> {\n    private TimestampReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDateTime read(LocalDateTime reuse) {\n      return EPOCH.plus(column.nextLong(), ChronoUnit.MICROS).toLocalDateTime();\n    }\n  }\n\n  private static class TimestampMillisReader extends PrimitiveReader<LocalDateTime> {\n    private TimestampMillisReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public LocalDateTime read(LocalDateTime reuse) {\n      return EPOCH.plus(column.nextLong() * 1000, ChronoUnit.MICROS).toLocalDateTime();\n    }\n  }\n\n  private static class TimestamptzReader extends PrimitiveReader<OffsetDateTime> {\n    private TimestamptzReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public OffsetDateTime read(OffsetDateTime reuse) {\n      return EPOCH.plus(column.nextLong(), ChronoUnit.MICROS);\n    }\n  }\n\n  private static class TimestamptzMillisReader extends PrimitiveReader<OffsetDateTime> {\n    private TimestamptzMillisReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public OffsetDateTime read(OffsetDateTime reuse) {\n      return EPOCH.plus(column.nextLong() * 1000, ChronoUnit.MICROS);\n    }\n  }\n\n  private static class FixedReader extends PrimitiveReader<byte[]> {\n    private FixedReader(ColumnDescriptor desc) {\n      super(desc);\n    }\n\n    @Override\n    public byte[] read(byte[] reuse) {\n      if (reuse != null) {\n        column.nextBinary().toByteBuffer().duplicate().get(reuse);\n        return reuse;\n      } else {\n        return column.nextBinary().getBytes();\n      }\n    }\n  }\n\n  static class RecordReader extends StructReader<Record, Record> {\n    private final StructType struct;\n\n    RecordReader(List<Type> types,\n                 List<ParquetValueReader<?>> readers,\n                 StructType struct) {\n      super(types, readers);\n      this.struct = struct;\n    }\n\n    @Override\n    protected Record newStructData(Record reuse) {\n      if (reuse != null) {\n        return reuse;\n      } else {\n        return GenericRecord.create(struct);\n      }\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Object getField(Record intermediate, int pos) {\n      return intermediate.get(pos);\n    }\n\n    @Override\n    protected Record buildStruct(Record struct) {\n      return struct;\n    }\n\n    @Override\n    protected void set(Record struct, int pos, Object value) {\n      struct.set(pos, value);\n    }\n  }\n}\n\n'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'\n:\n\npackage com.netflix.iceberg.data;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.CombinedScanTask;\nimport com.netflix.iceberg.FileScanTask;\nimport com.netflix.iceberg.HasTableOperations;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.TableOperations;\nimport com.netflix.iceberg.TableScan;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.data.avro.DataReader;\nimport com.netflix.iceberg.exceptions.RuntimeIOException;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Evaluator;\nimport com.netflix.iceberg.expressions.Expressions;\nimport com.netflix.iceberg.io.CloseableGroup;\nimport com.netflix.iceberg.io.CloseableIterable;\nimport com.netflix.iceberg.io.InputFile;\nimport com.netflix.iceberg.parquet.Parquet;\nimport com.netflix.iceberg.types.TypeUtil;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport static com.google.common.collect.Iterables.concat;\nimport static com.google.common.collect.Iterables.filter;\nimport static com.google.common.collect.Iterables.transform;\nimport static com.netflix.iceberg.data.parquet.GenericParquetReaders.buildReader;\nimport static java.util.Collections.emptyIterator;\n\nclass TableScanIterable extends CloseableGroup implements CloseableIterable<Record> {\n  private final TableOperations ops;\n  private final Schema projection;\n  private final boolean reuseContainers;\n  private final CloseableIterable<CombinedScanTask> tasks;\n\n  TableScanIterable(TableScan scan, boolean reuseContainers) {\n    Preconditions.checkArgument(scan.table() instanceof HasTableOperations,\n        \"Cannot scan table that doesn't expose its TableOperations\");\n    this.ops = ((HasTableOperations) scan.table()).operations();\n    this.projection = scan.schema();\n    this.reuseContainers = reuseContainers;\n\n\n    this.tasks = scan.planTasks();\n  }\n\n  @Override\n  public Iterator<Record> iterator() {\n    ScanIterator iter = new ScanIterator(tasks);\n    addCloseable(iter);\n    return iter;\n  }\n\n  private CloseableIterable<Record> open(FileScanTask task) {\n    InputFile input = ops.io().newInputFile(task.file().path().toString());\n\n\n    switch (task.file().format()) {\n      case AVRO:\n        Avro.ReadBuilder avro = Avro.read(input)\n            .project(projection)\n            .createReaderFunc(DataReader::create)\n            .split(task.start(), task.length());\n\n        if (reuseContainers) {\n          avro.reuseContainers();\n        }\n\n        return avro.build();\n\n      case PARQUET:\n        Parquet.ReadBuilder parquet = Parquet.read(input)\n            .project(projection)\n            .createReaderFunc(fileSchema -> buildReader(projection, fileSchema))\n            .split(task.start(), task.length());\n\n        if (reuseContainers) {\n          parquet.reuseContainers();\n        }\n\n        return parquet.build();\n\n      default:\n        throw new UnsupportedOperationException(String.format(\"Cannot read %s file: %s\",\n            task.file().format().name(), task.file().path()));\n    }\n  }\n\n  @Override\n  public void close() throws IOException {\n    tasks.close();\n    super.close();\n  }\n\n  private class ScanIterator implements Iterator<Record>, Closeable {\n    private final Iterator<FileScanTask> tasks;\n    private Closeable currentCloseable = null;\n    private Iterator<Record> currentIterator = emptyIterator();\n\n    private ScanIterator(Iterable<CombinedScanTask> tasks) {\n      this.tasks = Lists.newArrayList(concat(transform(tasks, CombinedScanTask::files))).iterator();\n    }\n\n    @Override\n    public boolean hasNext() {\n      while (true) {\n        if (currentIterator.hasNext()) {\n          return true;\n\n        } else if (tasks.hasNext()) {\n          if (currentCloseable != null) {\n            try {\n              currentCloseable.close();\n            } catch (IOException e) {\n              throw new RuntimeIOException(e, \"Failed to close task\");\n            }\n          }\n\n          FileScanTask task = tasks.next();\n          CloseableIterable<Record> reader = open(task);\n          this.currentCloseable = reader;\n\n          if (task.residual() != null && task.residual() != Expressions.alwaysTrue()) {\n            Evaluator filter = new Evaluator(projection.asStruct(), task.residual());\n            this.currentIterator = filter(reader, filter::eval).iterator();\n          } else {\n            this.currentIterator = reader.iterator();\n          }\n\n        } else {\n          return false;\n        }\n      }\n    }\n\n    @Override\n    public Record next() {\n      if (!hasNext()) {\n        throw new NoSuchElementException();\n      }\n\n      return currentIterator.next();\n    }\n\n    @Override\n    public void close() throws IOException {\n      if (currentCloseable != null) {\n        currentCloseable.close();\n      }\n    }\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.types.ArrayType$;\nimport org.apache.spark.sql.types.BinaryType$;\nimport org.apache.spark.sql.types.BooleanType$;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.DateType$;\nimport org.apache.spark.sql.types.DecimalType$;\nimport org.apache.spark.sql.types.DoubleType$;\nimport org.apache.spark.sql.types.FloatType$;\nimport org.apache.spark.sql.types.IntegerType$;\nimport org.apache.spark.sql.types.LongType$;\nimport org.apache.spark.sql.types.MapType$;\nimport org.apache.spark.sql.types.Metadata;\nimport org.apache.spark.sql.types.StringType$;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType$;\nimport org.apache.spark.sql.types.TimestampType$;\nimport java.util.List;\n\nclass TypeToSparkType extends TypeUtil.SchemaVisitor<DataType> {\n  TypeToSparkType() {\n  }\n\n  @Override\n  public DataType schema(Schema schema, DataType structType) {\n    return structType;\n  }\n\n  @Override\n  public DataType struct(Types.StructType struct, List<DataType> fieldResults) {\n    List<Types.NestedField> fields = struct.fields();\n\n    List<StructField> sparkFields = Lists.newArrayListWithExpectedSize(fieldResults.size());\n    for (int i = 0; i < fields.size(); i += 1) {\n      Types.NestedField field = fields.get(i);\n      DataType type = fieldResults.get(i);\n      sparkFields.add(StructField.apply(field.name(), type, field.isOptional(), Metadata.empty()));\n    }\n\n    return StructType$.MODULE$.apply(sparkFields);\n  }\n\n  @Override\n  public DataType field(Types.NestedField field, DataType fieldResult) {\n    return fieldResult;\n  }\n\n  @Override\n  public DataType list(Types.ListType list, DataType elementResult) {\n    return ArrayType$.MODULE$.apply(elementResult, list.isElementOptional());\n  }\n\n  @Override\n  public DataType map(Types.MapType map, DataType keyResult, DataType valueResult) {\n    return MapType$.MODULE$.apply(keyResult, valueResult, map.isValueOptional());\n  }\n\n  @Override\n  public DataType primitive(Type.PrimitiveType primitive) {\n    switch (primitive.typeId()) {\n      case BOOLEAN:\n        return BooleanType$.MODULE$;\n      case INTEGER:\n        return IntegerType$.MODULE$;\n      case LONG:\n        return LongType$.MODULE$;\n      case FLOAT:\n        return FloatType$.MODULE$;\n      case DOUBLE:\n        return DoubleType$.MODULE$;\n      case DATE:\n        return DateType$.MODULE$;\n      case TIME:\n        throw new UnsupportedOperationException(\n            \"Spark does not support time fields\");\n      case TIMESTAMP:\n        Types.TimestampType timestamp = (Types.TimestampType) primitive;\n        if (timestamp.shouldAdjustToUTC()) {\n          return TimestampType$.MODULE$;\n        }\n        throw new UnsupportedOperationException(\n            \"Spark does not support timestamp without time zone fields\");\n      case STRING:\n        return StringType$.MODULE$;\n      case UUID:\n\n        return StringType$.MODULE$;\n      case FIXED:\n        return BinaryType$.MODULE$;\n      case BINARY:\n        return BinaryType$.MODULE$;\n      case DECIMAL:\n        Types.DecimalType decimal = (Types.DecimalType) primitive;\n        return DecimalType$.MODULE$.apply(decimal.precision(), decimal.scale());\n      default:\n        throw new UnsupportedOperationException(\n            \"Cannot convert unknown type to Spark: \" + primitive);\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/TypeToSparkType.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/parquet/GenericParquetReaders.java'",
            "'iceberg/data/src/main/java/com/netflix/iceberg/data/TableScanIterable.java'"
        ]
    },
    {
        "files": [
            "'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/jspectrumanalyzer/ui/HackRFSweepSettingsUI.java'",
            "'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/shared/mvc/ModelValue.java'",
            "'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/jspectrumanalyzer/core/HackRFSettings.java'"
        ],
        "content": "'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/jspectrumanalyzer/ui/HackRFSweepSettingsUI.java'\n:package jspectrumanalyzer.ui;\n\n\n\nimport java.awt.BorderLayout;\n\nimport java.awt.Color;\n\nimport java.awt.Desktop;\n\nimport java.awt.Font;\n\nimport java.awt.GridLayout;\n\nimport java.awt.Label;\n\nimport java.beans.PropertyChangeEvent;\n\nimport java.math.BigDecimal;\n\nimport java.net.URI;\n\nimport java.util.Optional;\n\nimport java.util.Vector;\n\nimport java.util.function.Consumer;\n\nimport java.util.stream.Collectors;\n\nimport java.util.stream.IntStream;\n\nimport java.util.stream.Stream;\n\n\n\nimport javax.swing.DefaultBoundedRangeModel;\n\nimport javax.swing.DefaultComboBoxModel;\n\nimport javax.swing.JButton;\n\nimport javax.swing.JCheckBox;\n\nimport javax.swing.JLabel;\n\nimport javax.swing.JPanel;\n\nimport javax.swing.JSlider;\n\nimport javax.swing.JSpinner;\n\nimport javax.swing.JTabbedPane;\n\nimport javax.swing.JSpinner.ListEditor;\n\nimport javax.swing.JTextField;\n\nimport javax.swing.SpinnerListModel;\n\nimport javax.swing.UIManager;\n\n\n\nimport jspectrumanalyzer.HackRFSweepSpectrumAnalyzer;\n\nimport jspectrumanalyzer.Version;\n\nimport jspectrumanalyzer.core.FrequencyAllocationTable;\n\nimport jspectrumanalyzer.core.FrequencyAllocations;\n\nimport jspectrumanalyzer.core.FrequencyRange;\n\nimport jspectrumanalyzer.core.HackRFSettings;\n\nimport jspectrumanalyzer.core.HackRFSettings.HackRFEventAdapter;\n\nimport net.miginfocom.swing.MigLayout;\n\nimport shared.mvc.MVCController;\n\nimport javax.swing.border.BevelBorder;\n\nimport javax.swing.border.CompoundBorder;\n\nimport javax.swing.border.EmptyBorder;\n\nimport javax.swing.SpinnerNumberModel;\n\nimport javax.swing.SwingUtilities;\n\nimport javax.swing.JComboBox;\n\nimport javax.swing.SwingConstants;\n\n\n\npublic class HackRFSweepSettingsUI extends JPanel\n\n{\n\n\n\n\tprivate HackRFSettings hRF;\n\n\tprivate static final long serialVersionUID = 7721079457485020637L;\n\n\tprivate JLabel txtHackrfConnected;\n\n\tprivate FrequencySelectorPanel frequencySelectorStart;\n\n\tprivate FrequencySelectorPanel frequencySelectorEnd;\n\n\tprivate JSpinner spinnerFFTBinHz;\n\n\tprivate JSlider sliderGain;\n\n\tprivate JSpinner spinner_numberOfSamples;\n\n\tprivate JCheckBox chckbxAntennaPower;\n\n\tprivate JSlider slider_waterfallPaletteStart;\n\n\tprivate JSlider slider_waterfallPaletteSize;\n\n\tprivate JCheckBox chckbxShowPeaks;\n\n\tprivate JCheckBox chckbxRemoveSpurs;\n\n\tprivate JButton btnPause;\n\n\tprivate SpinnerListModel spinnerModelFFTBinHz;\n\n\tprivate FrequencySelectorRangeBinder frequencyRangeSelector;\n\n\tprivate JCheckBox chckbxFilterSpectrum;\n\n\tprivate JSpinner spinnerPeakFallSpeed;\n\n\tprivate JComboBox<FrequencyAllocationTable> comboBoxFrequencyAllocationBands;\n\n\tprivate JSlider sliderGainVGA;\n\n\tprivate JSlider sliderGainLNA;\n\n\tprivate JCheckBox chckbxAntennaLNA;\n\n\tprivate JLabel lblPeakFall;\n\n\tprivate JComboBox<BigDecimal> comboBoxLineThickness;\n\n\tprivate JLabel lblPersistentDisplay;\n\n\tprivate JCheckBox checkBoxPersistentDisplay;\n\n\tprivate JCheckBox checkBoxWaterfallEnabled;\n\n\tprivate JLabel lblDecayRate;\n\n\tprivate JComboBox comboBoxDecayRate;\n\n\tprivate JLabel lblDebugDisplay;\n\n\tprivate JCheckBox checkBoxDebugDisplay;\n\n\n\n\n\n\tpublic HackRFSweepSettingsUI(HackRFSettings hackRFSettings)\n\n\t{\n\n\t\tthis.hRF\t= hackRFSettings;\n\n\t\tsetForeground(Color.WHITE);\n\n\t\tsetBackground(Color.BLACK);\n\n\t\tint minFreq = 1;\n\n\t\tint maxFreq = 7250;\n\n\t\tint freqStep = 1;\n\n\n\n\t\tJPanel panelMainSettings\t= new JPanel(new MigLayout(\"\", \"[123.00px,grow,leading]\", \"[][][::0px][][]\"));\n\n\t\tpanelMainSettings.setBorder(new EmptyBorder(UIManager.getInsets(\"TabbedPane.tabAreaInsets\")));;\n\n\t\tpanelMainSettings.setBackground(Color.BLACK);\n\n\t\tJLabel lblNewLabel = new JLabel(\"Frequency start [MHz]\");\n\n\t\tlblNewLabel.setForeground(Color.WHITE);\n\n\t\tpanelMainSettings.add(lblNewLabel, \"cell 0 0,growx,aligny center\");\n\n\n\n\t\tfrequencySelectorStart = new FrequencySelectorPanel(minFreq, maxFreq, freqStep, minFreq);\n\n\t\tpanelMainSettings.add(frequencySelectorStart, \"cell 0 1,grow\");\n\n\n\n\t\tJLabel lblFrequencyEndmhz = new JLabel(\"Frequency end [MHz]\");\n\n\t\tlblFrequencyEndmhz.setForeground(Color.WHITE);\n\n\t\tpanelMainSettings.add(lblFrequencyEndmhz, \"cell 0 3,alignx left,aligny center\");\n\n\n\n\t\tfrequencySelectorEnd = new FrequencySelectorPanel(minFreq, maxFreq, freqStep, maxFreq);\n\n\t\tpanelMainSettings.add(frequencySelectorEnd, \"cell 0 4,grow\");\n\n\n\n\n\n\t\ttxtHackrfConnected = new JLabel();\n\n\t\ttxtHackrfConnected.setText(\"HackRF disconnected\");\n\n\t\ttxtHackrfConnected.setForeground(Color.WHITE);\n\n\t\ttxtHackrfConnected.setBackground(Color.BLACK);\n\n\t\tpanelMainSettings.add(txtHackrfConnected, \"cell 0 23,growx\");\n\n\t\ttxtHackrfConnected.setBorder(null);\n\n\n\n\t\tbtnPause = new JButton(\"Pause\");\n\n\t\tpanelMainSettings.add(btnPause, \"cell 0 25,growx\");\n\n\t\tbtnPause.setBackground(Color.black);\n\n\n\n\n\n\n\n\n\n\t\tJTabbedPane tabbedPane\t= new JTabbedPane(JTabbedPane.TOP);\n\n\t\tsetLayout(new BorderLayout());\n\n\t\tadd(panelMainSettings, BorderLayout.NORTH);\n\n\t\tadd(tabbedPane, BorderLayout.CENTER);\n\n\t\ttabbedPane.setForeground(Color.WHITE);\n\n\t\ttabbedPane.setBackground(Color.BLACK);\n\n\n\n\t\tJPanel tab1\t= new JPanel(new MigLayout(\"\", \"[123.00px,grow,leading]\", \"[][][0][][][0][][][0][][][0][][][0][][0][][grow,fill]\"));\n\n\t\ttab1.setForeground(Color.WHITE);\n\n\t\ttab1.setBackground(Color.BLACK);\n\n\n\n\t\tJPanel tab2\t= new JPanel(new MigLayout(\"\", \"[123.00px,grow,leading]\", \"[][0][][][0][][][0][][0][][][0][][0][][][0][0][][][0][][0][grow,fill]\"));\n\n\t\ttab2.setForeground(Color.WHITE);\n\n\t\ttab2.setBackground(Color.BLACK);\n\n\n\n\t\ttabbedPane.addTab(\"HackRF Settings\", tab1);\n\n\t\ttabbedPane.addTab(\"Chart options\", tab2);\n\n\t\ttabbedPane.setForegroundAt(1, Color.BLACK);\n\n\t\ttabbedPane.setBackgroundAt(1, Color.WHITE);\n\n\n\n\t\ttabbedPane.setForegroundAt(0, Color.BLACK);\n\n\t\ttabbedPane.setBackgroundAt(0, Color.WHITE);\n\n\n\n\n\n\t\t{\n\n\t\t\tJLabel lblGain = new JLabel(\"Gain [dB]\");\n\n\t\t\tlblGain.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(lblGain, \"cell 0 0\");\n\n\n\n\t\t\tsliderGain = new JSlider(JSlider.HORIZONTAL, 0, 100, 2);\n\n\t\t\tsliderGain.setFont(new Font(\"Monospaced\", Font.BOLD, 16));\n\n\t\t\tsliderGain.setBackground(Color.BLACK);\n\n\t\t\tsliderGain.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(sliderGain, \"flowy,cell 0 1,growx\");\n\n\n\n\t\t\tJLabel lbl_gainValue = new JLabel(hackRFSettings.getGain() + \"dB\");\n\n\t\t\tlbl_gainValue.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(lbl_gainValue, \"cell 0 1,alignx right\");\n\n\n\n\t\t\tJLabel lblNewLabel_2 = new JLabel(\"LNA Gain [dB]\");\n\n\t\t\tlblNewLabel_2.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(lblNewLabel_2, \"cell 0 3\");\n\n\n\n\t\t\tsliderGainLNA = new JSlider(SwingConstants.HORIZONTAL, 0, 100, 2);\n\n\t\t\tsliderGainLNA.setForeground(Color.WHITE);\n\n\t\t\tsliderGainLNA.setFont(new Font(\"Monospaced\", Font.BOLD, 16));\n\n\t\t\tsliderGainLNA.setBackground(Color.BLACK);\n\n\t\t\ttab1.add(sliderGainLNA, \"cell 0 4,growx\");\n\n\n\n\t\t\tJLabel lblVgfaGaindb = new JLabel(\"VGA Gain [dB]\");\n\n\t\t\tlblVgfaGaindb.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(lblVgfaGaindb, \"cell 0 6\");\n\n\n\n\t\t\tsliderGainVGA = new JSlider(SwingConstants.HORIZONTAL, 0, 100, 2);\n\n\t\t\tsliderGainVGA.setForeground(Color.WHITE);\n\n\t\t\tsliderGainVGA.setFont(new Font(\"Monospaced\", Font.BOLD, 16));\n\n\t\t\tsliderGainVGA.setBackground(Color.BLACK);\n\n\t\t\ttab1.add(sliderGainVGA, \"cell 0 7,growx\");\n\n\n\n\n\n\t\t\tJLabel lblLNAEnable = new JLabel(\"Antenna LNA +14dB\");\n\n\t\t\tlblLNAEnable.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(lblLNAEnable, \"flowx,cell 0 8,growx\");\n\n\n\n\t\t\tchckbxAntennaLNA = new JCheckBox(\"\");\n\n\t\t\tchckbxAntennaLNA.setHorizontalTextPosition(SwingConstants.LEADING);\n\n\t\t\tchckbxAntennaLNA.setBackground(Color.BLACK);\n\n\t\t\tchckbxAntennaLNA.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(chckbxAntennaLNA, \"cell 0 8,alignx right\");\n\n\n\n\n\n\t\t\tJLabel lblFftBinhz = new JLabel(\"FFT Bin [Hz]\");\n\n\t\t\tlblFftBinhz.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(lblFftBinhz, \"cell 0 10\");\n\n\n\n\t\t\tspinnerFFTBinHz = new JSpinner();\n\n\t\t\tspinnerFFTBinHz.setFont(new Font(\"Monospaced\", Font.BOLD, 16));\n\n\t\t\tspinnerModelFFTBinHz = new SpinnerListModel(new String[] { \"1 000\", \"2 000\", \"5 000\", \"10 000\", \"20 000\",\n\n\t\t\t\t\t\"50 000\", \"100 000\", \"200 000\", \"500 000\", \"1 000 000\", \"2 000 000\", \"5 000 000\" });\n\n\t\t\tspinnerFFTBinHz.setModel(spinnerModelFFTBinHz);\n\n\t\t\ttab1.add(spinnerFFTBinHz, \"cell 0 12,growx\");\n\n\t\t\t((ListEditor) spinnerFFTBinHz.getEditor()).getTextField().setHorizontalAlignment(JTextField.RIGHT);\n\n\n\n\n\n\t\t\thackRFSettings.getGain().addListener((gain) -> lbl_gainValue.setText(String.format(\" %ddB  [LNA: %ddB  VGA: %ddB]\",\n\n\t\t\t\t\tgain, hackRFSettings.getGainLNA().getValue(), hackRFSettings.getGainVGA().getValue())));\n\n\n\n\n\n\t\t\tJLabel lblNumberOfSamples = new JLabel(\"Number of samples\");\n\n\t\t\tlblNumberOfSamples.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(lblNumberOfSamples, \"cell 0 13\");\n\n\n\n\t\t\tspinner_numberOfSamples = new JSpinner();\n\n\t\t\tspinner_numberOfSamples.setModel(new SpinnerListModel(new String[] { \"8192\", \"16384\", \"32768\", \"65536\", \"131072\", \"262144\" }));\n\n\t\t\tspinner_numberOfSamples.setFont(new Font(\"Monospaced\", Font.BOLD, 16));\n\n\t\t\t((ListEditor) spinner_numberOfSamples.getEditor()).getTextField().setHorizontalAlignment(JTextField.RIGHT);\n\n\t\t\t((ListEditor) spinner_numberOfSamples.getEditor()).getTextField().setEditable(false);\n\n\t\t\ttab1.add(spinner_numberOfSamples, \"cell 0 14,growx\");\n\n\n\n\t\t\tJButton btnAbout = new JButton(\"Visit homepage\");\n\n\t\t\tbtnAbout.addActionListener(e -> {\n\n\t\t\t\t if (Desktop.isDesktopSupported()) {\n\n\t\t\t            Desktop desktop = Desktop.getDesktop();\n\n\t\t\t            try {\n\n\t\t\t                URI uri = new URI(Version.url);\n\n\t\t\t                desktop.browse(uri);\n\n\t\t\t            } catch (Exception ex) {\n\n\t\t\t                ex.printStackTrace();\n\n\t\t\t            }\n\n\t\t\t    }\n\n\t\t\t});\n\n\n\n\n\n\t\t\tJLabel lblAntennaPower = new JLabel(\"Antenna power output\");\n\n\t\t\tlblAntennaPower.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(lblAntennaPower, \"flowx,cell 0 16,growx\");\n\n\n\n\t\t\tchckbxAntennaPower = new JCheckBox(\"\");\n\n\t\t\tchckbxAntennaPower.setHorizontalTextPosition(SwingConstants.LEADING);\n\n\t\t\tchckbxAntennaPower.setBackground(Color.BLACK);\n\n\t\t\tchckbxAntennaPower.setForeground(Color.WHITE);\n\n\t\t\ttab1.add(chckbxAntennaPower, \"cell 0 16,alignx right\");\n\n\n\n\t\t\tLabel labelVersion = new Label(\"Version: v\"+Version.version);\n\n\t\t\ttab1.add(labelVersion, \"flowx,cell 0 17\");\n\n\t\t\tbtnAbout.setBackground(Color.BLACK);\n\n\t\t\ttab1.add(btnAbout, \"cell 0 17,alignx right\");\n\n\t\t}\n\n\n\n\t\tchckbxFilterSpectrum = new JCheckBox(\"Filter spectrum\");\n\n\t\tchckbxFilterSpectrum.setBackground(Color.BLACK);\n\n\t\tchckbxFilterSpectrum.setForeground(Color.WHITE);\n\n\n\n\t\tJLabel lblWaterfallEnabled = new JLabel(\"Waterfall enabled\");\n\n\t\tlblWaterfallEnabled.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblWaterfallEnabled, \"flowx,cell 0 0,growx\");\n\n\n\n\n\n\t\tJLabel lblWaterfallPaletteStart = new JLabel(\"Waterfall palette start [dB]\");\n\n\t\tlblWaterfallPaletteStart.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblWaterfallPaletteStart, \"cell 0 2\");\n\n\n\n\t\tslider_waterfallPaletteStart = new JSlider();\n\n\t\tslider_waterfallPaletteStart.setForeground(Color.WHITE);\n\n\t\tslider_waterfallPaletteStart.setBackground(Color.BLACK);\n\n\t\tslider_waterfallPaletteStart.setMinimum(-100);\n\n\t\tslider_waterfallPaletteStart.setMaximum(0);\n\n\t\tslider_waterfallPaletteStart.setValue(-30);\n\n\t\ttab2.add(slider_waterfallPaletteStart, \"cell 0 3,growx\");\n\n\n\n\n\n\t\tJLabel lblWaterfallPaletteLength = new JLabel(\"Waterfall palette length [dB]\");\n\n\t\tlblWaterfallPaletteLength.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblWaterfallPaletteLength, \"cell 0 5\");\n\n\n\n\t\tslider_waterfallPaletteSize = new JSlider(HackRFSweepSpectrumAnalyzer.SPECTRUM_PALETTE_SIZE_MIN, 100);\n\n\t\tslider_waterfallPaletteSize.setBackground(Color.BLACK);\n\n\t\tslider_waterfallPaletteSize.setForeground(Color.WHITE);\n\n\t\ttab2.add(slider_waterfallPaletteSize, \"cell 0 6,growx\");\n\n\n\n\t\tJLabel lblSpectrLineThickness = new JLabel(\"Spectr. Line Thickness\");\n\n\t\tlblSpectrLineThickness.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblSpectrLineThickness, \"flowx,cell 0 8,growx\");\n\n\n\n\t\tJLabel lblShowPeaks = new JLabel(\"Show peaks\");\n\n\t\tlblShowPeaks.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblShowPeaks, \"flowx,cell 0 10,growx\");\n\n\n\n\n\n\t\tchckbxShowPeaks = new JCheckBox(\"\");\n\n\t\tchckbxShowPeaks.setForeground(Color.WHITE);\n\n\t\tchckbxShowPeaks.setBackground(Color.BLACK);\n\n\t\ttab2.add(chckbxShowPeaks, \"cell 0 10,alignx right\");\n\n\n\n\t\tJLabel lblSpurFiltermay = new JLabel(\"Spur filter (may distort real signals)\");\n\n\t\tlblSpurFiltermay.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblSpurFiltermay, \"flowx,cell 0 13,growx\");\n\n\n\n\t\tchckbxRemoveSpurs = new JCheckBox(\"\");\n\n\t\tchckbxRemoveSpurs.setForeground(Color.WHITE);\n\n\t\tchckbxRemoveSpurs.setBackground(Color.BLACK);\n\n\t\ttab2.add(chckbxRemoveSpurs, \"cell 0 13,alignx right\");\n\n\n\n\t\tlblPeakFall = new JLabel(\"  Fall speed [s]\");\n\n\t\tlblPeakFall.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblPeakFall, \"flowx,cell 0 11,growx\");\n\n\n\n\t\tspinnerPeakFallSpeed = new JSpinner();\n\n\t\tspinnerPeakFallSpeed.setModel(new SpinnerNumberModel(10, 0, 500, 1));\n\n\t\ttab2.add(spinnerPeakFallSpeed, \"cell 0 11,alignx right\");\n\n\n\n\t\tlblPersistentDisplay = new JLabel(\"Persistent Display\");\n\n\t\tlblPersistentDisplay.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblPersistentDisplay, \"flowx,cell 0 15,growx\");\n\n\n\n\t\tlblDecayRate = new JLabel(\"  Persistence time [s]\");\n\n\t\tlblDecayRate.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblDecayRate, \"flowx,cell 0 16,growx\");\n\n\n\n\t\tJLabel lblDisplayFrequencyAllocation = new JLabel(\"Frequency Allocation Bands\");\n\n\t\tlblDisplayFrequencyAllocation.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblDisplayFrequencyAllocation, \"cell 0 19\");\n\n\n\n\n\n\t\tFrequencyAllocations frequencyAllocations\t= new FrequencyAllocations();\n\n\t\tVector<FrequencyAllocationTable> freqAllocValues\t= new Vector<>();\n\n\t\tfreqAllocValues.add(null);\n\n\t\tfreqAllocValues.addAll(frequencyAllocations.getTable().values());\n\n\t\tDefaultComboBoxModel<FrequencyAllocationTable> freqAllocModel\t= new  DefaultComboBoxModel<>(freqAllocValues);\n\n\t\tcomboBoxFrequencyAllocationBands = new JComboBox<FrequencyAllocationTable>(freqAllocModel);\n\n\t\ttab2.add(comboBoxFrequencyAllocationBands, \"cell 0 20,growx\");\n\n\n\n\t\tcomboBoxLineThickness = new JComboBox(new BigDecimal[] {\n\n\t\t\t\tnew BigDecimal(\"1\"), new BigDecimal(\"1.5\"), new BigDecimal(\"2\"), new BigDecimal(\"3\")\n\n\t\t\t\t});\n\n\t\ttab2.add(comboBoxLineThickness, \"cell 0 8,alignx right\");\n\n\n\n\t\tcheckBoxPersistentDisplay = new JCheckBox(\"\");\n\n\t\tcheckBoxPersistentDisplay.setForeground(Color.WHITE);\n\n\t\tcheckBoxPersistentDisplay.setBackground(Color.BLACK);\n\n\t\ttab2.add(checkBoxPersistentDisplay, \"cell 0 15,alignx right\");\n\n\n\n\t\tcheckBoxWaterfallEnabled = new JCheckBox(\"\");\n\n\t\tcheckBoxWaterfallEnabled.setForeground(Color.WHITE);\n\n\t\tcheckBoxWaterfallEnabled.setBackground(Color.BLACK);\n\n\t\ttab2.add(checkBoxWaterfallEnabled, \"cell 0 0,alignx right\");\n\n\n\n\t\tcomboBoxDecayRate = new JComboBox(\n\n\t\t\t\tnew Vector<>(IntStream.rangeClosed(hRF.getPersistentDisplayDecayRate().getMin(), hRF.getPersistentDisplayDecayRate().getMax()).\n\n\t\t\t\t\t\tboxed().collect(Collectors.toList())));\n\n\t\ttab2.add(comboBoxDecayRate, \"cell 0 16,alignx right\");\n\n\n\n\t\tlblDebugDisplay = new JLabel(\"Debug display\");\n\n\t\tlblDebugDisplay.setForeground(Color.WHITE);\n\n\t\ttab2.add(lblDebugDisplay, \"flowx,cell 0 22,growx\");\n\n\n\n\t\tcheckBoxDebugDisplay = new JCheckBox(\"\");\n\n\t\tcheckBoxDebugDisplay.setForeground(Color.WHITE);\n\n\t\tcheckBoxDebugDisplay.setBackground(Color.BLACK);\n\n\t\ttab2.add(checkBoxDebugDisplay, \"cell 0 22,alignx right\");\n\n\n\n\t\tbindViewToModel();\n\n\t}\n\n\n\n\tprivate void bindViewToModel() {\n\n\t\tfrequencyRangeSelector = new FrequencySelectorRangeBinder(frequencySelectorStart, frequencySelectorEnd);\n\n\n\n\t\tnew MVCController(spinnerFFTBinHz, hRF.getFFTBinHz(),\n\n\t\t\t\tviewValue -> Integer.parseInt(viewValue.toString().replaceAll(\"\\\\s\", \"\")),\n\n\t\t\t\tmodelValue -> {\n\n\t\t\t\t\tOptional<?> val = spinnerModelFFTBinHz.getList().stream().filter(value -> modelValue <= Integer.parseInt(value.toString().replaceAll(\"\\\\s\", \"\"))).findFirst();\n\n\t\t\t\t\tif (val.isPresent())\n\n\t\t\t\t\t\treturn val.get();\n\n\t\t\t\t\telse\n\n\t\t\t\t\t\treturn spinnerModelFFTBinHz.getList().get(0);\n\n\t\t\t\t});\n\n\t\tnew MVCController(sliderGain, hRF.getGain());\n\n\t\tnew MVCController(spinner_numberOfSamples, hRF.getSamples(), val -> Integer.parseInt(val.toString()), val -> val.toString());\n\n\t\tnew MVCController(chckbxAntennaPower, hRF.getAntennaPowerEnable());\n\n\t\tnew MVCController(chckbxAntennaLNA, hRF.getAntennaLNA());\n\n\t\tnew MVCController(slider_waterfallPaletteStart, hRF.getSpectrumPaletteStart());\n\n\t\tnew MVCController(slider_waterfallPaletteSize, hRF.getSpectrumPaletteSize());\n\n\t\tnew MVCController(\t(Consumer<FrequencyRange> valueChangedCall) ->\n\n\t\t\t\t\t\t\t\tfrequencyRangeSelector.addPropertyChangeListener((PropertyChangeEvent evt) -> valueChangedCall.accept(frequencyRangeSelector.getFrequencyRange()) ) ,\n\n\t\t\t\t\t\t\t(FrequencyRange newComponentValue) -> {\n\n\t\t\t\t\t\t\t\tif(frequencyRangeSelector.selFreqStart.getValue() != newComponentValue.getStartMHz())\n\n\t\t\t\t\t\t\t\t\tfrequencyRangeSelector.selFreqStart.setValue(newComponentValue.getStartMHz());\n\n\t\t\t\t\t\t\t\tif(frequencyRangeSelector.selFreqEnd.getValue() != newComponentValue.getEndMHz())\n\n\t\t\t\t\t\t\t\t\tfrequencyRangeSelector.selFreqEnd.setValue(newComponentValue.getEndMHz());\n\n\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\thRF.getFrequency()\n\n\t\t);\n\n\t\tnew MVCController(chckbxShowPeaks, hRF.isChartsPeaksVisible());\n\n\t\tnew MVCController(chckbxFilterSpectrum, hRF.isFilterSpectrum());\n\n\t\tnew MVCController(chckbxRemoveSpurs, hRF.isSpurRemoval());\n\n\n\n\t\tnew MVCController((valueChangedCall) -> btnPause.addActionListener((event) -> valueChangedCall.accept(!hRF.isCapturingPaused().getValue())),\n\n\t\t\t\tisCapt -> btnPause.setText(!isCapt ? \"Pause\"  : \"Resume\"),\n\n\t\t\t\thRF.isCapturingPaused());\n\n\n\n\t\tnew MVCController(spinnerPeakFallSpeed, hRF.getPeakFallRate(), in -> (Integer)in, in -> in);\n\n\n\n\t\tnew MVCController(comboBoxFrequencyAllocationBands, hRF.getFrequencyAllocationTable());\n\n\n\n\t\tsliderGainLNA.setModel(new DefaultBoundedRangeModel(hRF.getGainLNA().getValue(), 0, hRF.getGainLNA().getMin(), hRF.getGainLNA().getMax()));\n\n\t\tsliderGainVGA.setModel(new DefaultBoundedRangeModel(hRF.getGainVGA().getValue(), 0, hRF.getGainVGA().getMin(), hRF.getGainVGA().getMax()));\n\n\n\n\t\tsliderGainLNA.setSnapToTicks(true);\n\n\t\tsliderGainLNA.setMinorTickSpacing(hRF.getGainLNA().getStep());\n\n\n\n\t\tsliderGainVGA.setSnapToTicks(true);\n\n\t\tsliderGainVGA.setMinorTickSpacing(hRF.getGainVGA().getStep());\n\n\n\n\t\tnew MVCController(sliderGainLNA, hRF.getGainLNA());\n\n\t\tnew MVCController(sliderGainVGA, hRF.getGainVGA());\n\n\n\n\t\tnew MVCController(comboBoxLineThickness, hRF.getSpectrumLineThickness());\n\n\n\n\t\tnew MVCController(checkBoxPersistentDisplay, hRF.isPersistentDisplayVisible());\n\n\n\n\t\tnew MVCController(checkBoxWaterfallEnabled, hRF.isWaterfallVisible());\n\n\n\n\t\tnew MVCController(checkBoxDebugDisplay, hRF.isDebugDisplay());\n\n\n\n\t\thRF.isChartsPeaksVisible().addListener((enabled) -> {\n\n\t\t\tSwingUtilities.invokeLater(()->{\n\n\t\t\t\tspinnerPeakFallSpeed.setEnabled(enabled);\n\n\t\t\t\tspinnerPeakFallSpeed.setVisible(enabled);\n\n\t\t\t\tlblPeakFall.setVisible(enabled);\n\n\t\t\t});\n\n\t\t});\n\n\t\thRF.isChartsPeaksVisible().callObservers();\n\n\n\n\t\tnew MVCController(comboBoxDecayRate, hRF.getPersistentDisplayDecayRate());\n\n\t\thRF.isPersistentDisplayVisible().addListener((visible) -> {\n\n\t\t\tSwingUtilities.invokeLater(()->{\n\n\t\t\t\tcomboBoxDecayRate.setVisible(visible);\n\n\t\t\t\tlblDecayRate.setVisible(visible);\n\n\t\t\t});\n\n\t\t});\n\n\t\thRF.isPersistentDisplayVisible().callObservers();\n\n\n\n\t\thRF.registerListener(new HackRFSettings.HackRFEventAdapter()\n\n\t\t{\n\n\t\t\t@Override public void captureStateChanged(boolean isCapturing)\n\n\t\t\t{\n\n\n\n\t\t\t}\n\n\t\t\t@Override public void hardwareStatusChanged(boolean hardwareSendingData)\n\n\t\t\t{\n\n\t\t\t\ttxtHackrfConnected.setText(\"HackRF \"+(hardwareSendingData ? \"connected\":\"disconnected\"));\n\n\t\t\t}\n\n\t\t});;\n\n\n\n\t}\n\n\n\n}\n\n\n'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/shared/mvc/ModelValue.java'\n:package shared.mvc;\n\n\n\nimport java.util.Observable;\n\nimport java.util.Observer;\n\nimport java.util.function.Consumer;\n\n\n\n\n\npublic class ModelValue<T> extends Observable{\n\n\n\n\tpublic static class ModelValueInt extends ModelValue<Integer>{\n\n\t\tprotected final boolean isBounded;\n\n\t\tprotected final int min, max, step;\n\n\t\tpublic ModelValueInt(String name, int initialValue) {\n\n\t\t\tsuper(name, initialValue);\n\n\t\t\tisBounded\t= false;\n\n\t\t\tstep = min = max = 0;\n\n\t\t}\n\n\n\n\t\tpublic ModelValueInt(String name, int initialValue, int step, int min, int max) {\n\n\t\t\tsuper(name, initialValue);\n\n\t\t\tisBounded\t= true;\n\n\t\t\tthis.min\t= min;\n\n\t\t\tthis.max\t= max;\n\n\t\t\tthis.step\t= step;\n\n\t\t}\n\n\n\n\t\tpublic int getMax() {\n\n\t\t\treturn max;\n\n\t\t}\n\n\n\n\t\tpublic int getMin() {\n\n\t\t\treturn min;\n\n\t\t}\n\n\n\n\t\tpublic int getStep() {\n\n\t\t\treturn step;\n\n\t\t}\n\n\n\n\t\t@Override\n\n\t\tpublic void setValue(Integer value) {\n\n\t\t\tif (isBounded() && (value < min || value > max))\n\n\t\t\t\tthrow new IllegalStateException(\"New value of '\"+name+\"' '\"+value+\"' is outside of bounds <\"+min+\", \"+max+\">\");\n\n\t\t\tsuper.setValue(value);\n\n\t\t}\n\n\n\n\t\tpublic boolean isBounded() {\n\n\t\t\treturn isBounded;\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static class ModelValueBoolean extends ModelValue<Boolean>{\n\n\t\tpublic ModelValueBoolean(String name, Boolean initialValue) {\n\n\t\t\tsuper(name, initialValue);\n\n\t\t}\n\n\t}\n\n\n\n\tprivate T value;\n\n\tprotected final String name;\n\n\tpublic ModelValue(String name, T initialValue) {\n\n\t\tthis.value\t= initialValue;\n\n\t\tthis.name\t= name;\n\n\t}\n\n\n\n\n\n\tpublic void addListener(Consumer<T> listener) {\n\n\t\taddObserver((Observer) (o, arg) -> listener.accept(getValue()));\n\n\t}\n\n\n\n\tpublic void addListener(Runnable listener) {\n\n\t\taddObserver((Observer) (o, arg) -> listener.run());\n\n\t}\n\n\n\n\n\n\n\n\tpublic void setValue(T value) {\n\n\t\tif (value == null || this.value == null) {\n\n\t\t\tif (value == this.value)\n\n\t\t\t\treturn;\n\n\t\t}\n\n\t\telse if (this.value.equals(value)) {\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tthis.value\t= value;\n\n\n\n\t\tcallObservers();\n\n\t}\n\n\n\n\tpublic void callObservers() {\n\n\t\tsetChanged();\n\n\t\tnotifyObservers();\n\n\t}\n\n\n\n\tpublic T getValue() {\n\n\t\treturn value;\n\n\t}\n\n\n\n\t@Override public String toString() {\n\n\t\treturn name;\n\n\t}\n\n}\n'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/jspectrumanalyzer/core/HackRFSettings.java'\n:package jspectrumanalyzer.core;\n\n\n\nimport java.math.BigDecimal;\n\n\n\nimport shared.mvc.ModelValue;\n\nimport shared.mvc.ModelValue.ModelValueBoolean;\n\nimport shared.mvc.ModelValue.ModelValueInt;\n\n\n\npublic interface HackRFSettings {\n\n\tpublic static abstract class HackRFEventAdapter implements HackRFEventListener {\n\n\t\t@Override\n\n\t\tpublic void captureStateChanged(boolean isCapturing) {\n\n\n\n\t\t}\n\n\n\n\t\t@Override\n\n\t\tpublic void hardwareStatusChanged(boolean hardwareSendingData) {\n\n\n\n\t\t}\n\n\t}\n\n\n\n\tpublic static interface HackRFEventListener {\n\n\t\tpublic void captureStateChanged(boolean isCapturing);\n\n\n\n\t\tpublic void hardwareStatusChanged(boolean hardwareSendingData);\n\n\t}\n\n\n\n\tpublic ModelValueBoolean getAntennaPowerEnable();\n\n\n\n\tpublic ModelValueInt getFFTBinHz();\n\n\n\n\tpublic ModelValue<FrequencyRange> getFrequency();\n\n\n\n\tpublic ModelValueInt getGain();\n\n\n\n\tpublic ModelValueInt getGainLNA();\n\n\n\n\tpublic ModelValueBoolean getAntennaLNA();\n\n\n\n\tpublic ModelValueInt getPersistentDisplayDecayRate();\n\n\n\n\tpublic ModelValueBoolean isDebugDisplay();\n\n\n\n\tpublic ModelValueInt getSamples();\n\n\n\n\tpublic ModelValueInt getSpectrumPaletteSize();\n\n\n\n\tpublic ModelValueBoolean isPersistentDisplayVisible();\n\n\tpublic ModelValueBoolean isWaterfallVisible();\n\n\n\n\tpublic ModelValueInt getSpectrumPaletteStart();\n\n\n\n\tpublic ModelValueInt getPeakFallRate();\n\n\n\n\tpublic ModelValue<FrequencyAllocationTable> getFrequencyAllocationTable();\n\n\n\n\tpublic ModelValue<BigDecimal> getSpectrumLineThickness();\n\n\n\n\tpublic ModelValueInt getGainVGA();\n\n\n\n\tpublic ModelValueBoolean isCapturingPaused();\n\n\n\n\tpublic ModelValueBoolean isChartsPeaksVisible();\n\n\n\n\tpublic ModelValueBoolean isFilterSpectrum();\n\n\n\n\tpublic ModelValueBoolean isSpurRemoval();\n\n\n\n\tpublic void registerListener(HackRFEventListener listener);\n\n\n\n\tpublic void removeListener(HackRFEventListener listener);\n\n}\n\n",
        "gt": [
            "'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/shared/mvc/ModelValue.java'",
            "'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/jspectrumanalyzer/core/HackRFSettings.java'",
            "'hackrf-spectrum-analyzer/src/hackrf-sweep/src-java/jspectrumanalyzer/ui/HackRFSweepSettingsUI.java'"
        ]
    },
    {
        "files": [
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/support/Prototype.java'",
            "'qbit/qbit/admin/src/main/java/io/advantageous/qbit/metrics/support/StatServiceBuilder.java'",
            "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpClientBuilder.java'"
        ],
        "content": "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/support/Prototype.java'\n:package io.advantageous.qbit.metrics.support;\n\nimport io.advantageous.boon.core.Sys;\nimport io.advantageous.consul.discovery.ConsulServiceDiscoveryBuilder;\nimport io.advantageous.qbit.QBit;\nimport io.advantageous.qbit.events.EventBusProxyCreator;\nimport io.advantageous.qbit.events.EventManager;\nimport io.advantageous.qbit.metrics.StatService;\nimport io.advantageous.qbit.server.ServiceEndpointServer;\nimport io.advantageous.qbit.service.ServiceProxyUtils;\nimport io.advantageous.qbit.service.discovery.EndpointDefinition;\nimport io.advantageous.qbit.service.discovery.ServiceChangedEventChannel;\nimport io.advantageous.qbit.service.discovery.impl.ServiceDiscoveryImpl;\nimport io.advantageous.qbit.service.health.HealthStatus;\nimport io.advantageous.qbit.util.PortUtils;\n\nimport java.util.List;\n\nimport static io.advantageous.boon.core.IO.puts;\nimport static io.advantageous.consul.discovery.ConsulServiceDiscoveryBuilder.consulServiceDiscoveryBuilder;\nimport static io.advantageous.qbit.metrics.support.StatServiceBuilder.statServiceBuilder;\n\n\n@SuppressWarnings(\"ALL\")\npublic class Prototype {\n\n    public static void main(String... args) throws Exception {\n\n        final EventManager eventManager = QBit.factory().systemEventManager();\n\n        final EventBusProxyCreator eventBusProxyCreator = QBit.factory().eventBusProxyCreator();\n\n        final ServiceChangedEventChannel servicePoolUpdate = eventBusProxyCreator\n                .createProxy(eventManager, ServiceChangedEventChannel.class);\n\n\n        final ConsulServiceDiscoveryBuilder consulServiceDiscoveryBuilder = consulServiceDiscoveryBuilder()\n                .setServiceChangedEventChannel(servicePoolUpdate);\n\n        final ServiceDiscoveryImpl serviceDiscovery = consulServiceDiscoveryBuilder.setLongPollTimeSeconds(1).build();\n        serviceDiscovery.start();\n\n\n        final StatServiceBuilder statServiceBuilder = statServiceBuilder().setTimeToLiveCheckInterval(5_000)\n                .setServiceDiscovery(serviceDiscovery).setEventManager(eventManager);\n\n\n\n        int port = PortUtils.useOneOfThePortsInThisRange(8900, 9000);\n        statServiceBuilder.getEndpointServerBuilder().setPort(port);\n        final ServiceEndpointServer serviceEndpointServer = statServiceBuilder.buildServiceServer();\n\n\n        serviceEndpointServer.start();\n\n        final StatService statService = serviceEndpointServer.serviceBundle().createLocalProxy(StatService.class,\n                statServiceBuilder.getServiceName());\n\n        List<EndpointDefinition> endpointDefinitions = serviceDiscovery.loadServices(statServiceBuilder.getServiceName());\n\n        endpointDefinitions.forEach(serviceDefinition -> puts(serviceDefinition));\n\n        puts(\"Service statServiceBuilder.getLocalServiceId()\", statServiceBuilder.getLocalServiceId());\n\n        serviceDiscovery.checkIn(statServiceBuilder.getLocalServiceId(), HealthStatus.PASS);\n\n\n        for (int index = 0; index < 10; index++) {\n\n            final int fromIndex = index;\n            Sys.sleep(1000);\n            System.out.print(\".\");\n            statService.recordCount(\"foo\", 1);\n\n            statService.currentMinuteCount(count -> System.out.print(\n                    \"count \" + count + \" index \" + fromIndex + \"    \"), \"foo\");\n\n\n        }\n\n\n        ServiceProxyUtils.flushServiceProxy(statService);\n        endpointDefinitions = serviceDiscovery.loadServices(statServiceBuilder.getServiceName());\n        endpointDefinitions.forEach(serviceDefinition -> puts(serviceDefinition));\n\n\n        int index = 0;\n\n        while (true) {\n\n            index++;\n\n\n            statService.currentMinuteCount(count -> System.out.println(\n                    \"count \" + count + \"    \"), \"foo\");\n\n            ServiceProxyUtils.flushServiceProxy(statService);\n\n            Sys.sleep(1000);\n\n\n        }\n\n    }\n\n\n}\n\n'qbit/qbit/admin/src/main/java/io/advantageous/qbit/metrics/support/StatServiceBuilder.java'\n:\n\npackage io.advantageous.qbit.metrics.support;\n\n\nimport io.advantageous.boon.core.reflection.BeanUtils;\nimport io.advantageous.qbit.QBit;\nimport io.advantageous.qbit.client.Client;\nimport io.advantageous.qbit.client.ClientBuilder;\nimport io.advantageous.qbit.config.PropertyResolver;\nimport io.advantageous.qbit.events.EventManager;\nimport io.advantageous.qbit.metrics.*;\nimport io.advantageous.qbit.queue.QueueBuilder;\nimport io.advantageous.qbit.server.EndpointServerBuilder;\nimport io.advantageous.qbit.server.ServiceEndpointServer;\nimport io.advantageous.qbit.service.ServiceBuilder;\nimport io.advantageous.qbit.service.ServiceQueue;\nimport io.advantageous.qbit.service.discovery.ServiceDiscovery;\nimport io.advantageous.qbit.service.stats.StatsCollector;\nimport io.advantageous.qbit.service.stats.StatsCollectorBuffer;\nimport io.advantageous.qbit.util.Timer;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.concurrent.TimeUnit;\n\nimport static io.advantageous.qbit.client.ClientBuilder.clientBuilder;\n\n\npublic class StatServiceBuilder {\n\n\n    public static final String QBIT_STAT_SERVICE_BUILDER = \"qbit.statservice.builder.\";\n    private final List<StatReplicator> replicators = new ArrayList<>();\n    private EventManager eventManager;\n    private Timer timer = Timer.timer();\n    private StatRecorder recorder = new NoOpRecorder();\n    private StatReplicator replicator = new NoOpReplicator();\n    private ServiceDiscovery serviceDiscovery;\n    private StatReplicatorProvider statReplicatorProvider;\n    private ClientBuilder clientBuilder;\n    private ServiceQueue serviceQueue;\n    private ServiceBuilder serviceBuilder;\n    private EndpointServerBuilder endpointServerBuilder;\n    private QueueBuilder sendQueueBuilder;\n    private StatServiceImpl statServiceImpl;\n\n\n    private String serviceName;\n    private String localServiceId;\n    private int tallyInterval;\n    private int flushInterval;\n    private int timeToLiveCheckInterval;\n    private int numStats;\n\n\n    public StatServiceBuilder(PropertyResolver propertyResolver) {\n        this.serviceName = propertyResolver.getStringProperty(\"serviceName\", \"statsService\");\n        this.localServiceId = propertyResolver.getStringProperty(\"localServiceId\", \"\");\n        this.tallyInterval = propertyResolver.getIntegerProperty(\"tallyInterval\", 100);\n        this.flushInterval = propertyResolver.getIntegerProperty(\"flushInterval\", 333);\n        this.timeToLiveCheckInterval = propertyResolver\n                .getIntegerProperty(\"timeToLiveCheckInterval\", 5_000);\n        this.numStats = propertyResolver\n                .getIntegerProperty(\"numStats\", 100);\n\n    }\n\n    public StatServiceBuilder() {\n        this(PropertyResolver.createSystemPropertyResolver(QBIT_STAT_SERVICE_BUILDER));\n    }\n\n    public StatServiceBuilder(final Properties properties) {\n        this(PropertyResolver.createPropertiesPropertyResolver(\n                QBIT_STAT_SERVICE_BUILDER, properties));\n    }\n\n    public static StatServiceBuilder statServiceBuilder() {\n        return new StatServiceBuilder();\n    }\n\n    public int getTallyInterval() {\n        return tallyInterval;\n    }\n\n    public StatServiceBuilder setTallyInterval(int tallyInterval) {\n        this.tallyInterval = tallyInterval;\n        return this;\n    }\n\n    public int getFlushInterval() {\n        return flushInterval;\n    }\n\n    public StatServiceBuilder setFlushInterval(int flushInterval) {\n        this.flushInterval = flushInterval;\n        return this;\n    }\n\n    public int getTimeToLiveCheckInterval() {\n        return timeToLiveCheckInterval;\n    }\n\n    public StatServiceBuilder setTimeToLiveCheckInterval(int timeToLiveCheckInterval) {\n        this.timeToLiveCheckInterval = timeToLiveCheckInterval;\n        return this;\n    }\n\n    public int getNumStats() {\n        return numStats;\n    }\n\n    public void setNumStats(int numStats) {\n        this.numStats = numStats;\n    }\n\n    public QueueBuilder getSendQueueBuilder() {\n\n        if (sendQueueBuilder == null) {\n            sendQueueBuilder = QueueBuilder.queueBuilder().setLinkTransferQueue()\n                    .setBatchSize(1_000).setPollWait(500);\n        }\n        return sendQueueBuilder;\n    }\n\n\n    public StatServiceBuilder setSendQueueBuilder(QueueBuilder sendQueueBuilder) {\n        this.sendQueueBuilder = sendQueueBuilder;\n        return this;\n    }\n\n    public EndpointServerBuilder getEndpointServerBuilder() {\n\n        if (endpointServerBuilder == null) {\n            endpointServerBuilder = EndpointServerBuilder.endpointServerBuilder();\n        }\n        return endpointServerBuilder;\n    }\n\n    public StatServiceBuilder setEndpointServerBuilder(EndpointServerBuilder endpointServerBuilder) {\n        this.endpointServerBuilder = endpointServerBuilder;\n        return this;\n    }\n\n    public ServiceQueue getServiceQueue() {\n\n        if (serviceQueue == null) {\n            buildServiceQueue();\n        }\n        return serviceQueue;\n    }\n\n    public StatServiceBuilder setServiceQueue(ServiceQueue serviceQueue) {\n        this.serviceQueue = serviceQueue;\n        return this;\n    }\n\n    public ServiceBuilder getServiceBuilder() {\n\n        if (serviceBuilder == null) {\n            serviceBuilder = ServiceBuilder.serviceBuilder();\n            return serviceBuilder;\n        }\n        return serviceBuilder.copy();\n    }\n\n    public StatServiceBuilder setServiceBuilder(ServiceBuilder serviceBuilder) {\n        this.serviceBuilder = serviceBuilder;\n        return this;\n    }\n\n\n    public String getLocalServiceId() {\n        return localServiceId;\n    }\n\n    public StatServiceBuilder setLocalServiceId(String localServiceId) {\n        this.localServiceId = localServiceId;\n        return this;\n    }\n\n    public String getServiceName() {\n        return serviceName;\n    }\n\n    public StatServiceBuilder setServiceName(String serviceName) {\n        this.serviceName = serviceName;\n        return this;\n    }\n\n    private ClientBuilder getClientBuilder() {\n\n        if (clientBuilder == null) {\n            clientBuilder = clientBuilder();\n        }\n\n        return BeanUtils.copy(clientBuilder);\n    }\n\n    public ServiceDiscovery getServiceDiscovery() {\n        return serviceDiscovery;\n    }\n\n    public StatServiceBuilder setServiceDiscovery(ServiceDiscovery serviceDiscovery) {\n        this.serviceDiscovery = serviceDiscovery;\n        return this;\n    }\n\n    public Timer getTimer() {\n        return timer;\n    }\n\n    public StatServiceBuilder setTimer(Timer timer) {\n        this.timer = timer;\n        return this;\n    }\n\n    public StatServiceBuilder addReplicator(StatReplicator replicator) {\n        replicators.add(replicator);\n        return this;\n    }\n\n    public StatRecorder getRecorder() {\n        return recorder;\n    }\n\n    public StatServiceBuilder setRecorder(StatRecorder recorder) {\n        this.recorder = recorder;\n        return this;\n    }\n\n    public StatReplicator getReplicator() {\n        return replicator;\n    }\n\n    public StatServiceBuilder setReplicator(StatReplicator replicator) {\n        this.replicator = replicator;\n        return this;\n    }\n\n    @SuppressWarnings(\"UnusedReturnValue\")\n    public ServiceQueue buildServiceQueue() {\n        ServiceBuilder serviceBuilder = getServiceBuilder()\n                .setRequestQueueBuilder(getSendQueueBuilder())\n                .setServiceObject(getStatServiceImpl())\n                .setCreateCallbackHandler(false);\n\n        serviceQueue = serviceBuilder.build();\n\n        if (serviceDiscovery != null) {\n\n            if (eventManager != null && eventManager != QBit.factory().systemEventManager()) {\n\n                eventManager.joinService(serviceQueue);\n            }\n        }\n        return serviceQueue;\n    }\n\n    public ServiceQueue buildServiceQueueWithCallbackHandler() {\n        ServiceBuilder serviceBuilder = getServiceBuilder()\n                .setRequestQueueBuilder(getSendQueueBuilder())\n                .setServiceObject(getStatServiceImpl())\n                .setCreateCallbackHandler(true);\n\n        serviceQueue = serviceBuilder.build();\n\n        if (serviceDiscovery != null) {\n\n            if (eventManager != null && eventManager != QBit.factory().systemEventManager()) {\n\n                eventManager.joinService(serviceQueue);\n            }\n        }\n        return serviceQueue;\n    }\n\n    public ServiceEndpointServer buildServiceServer() {\n\n\n        final EndpointServerBuilder endpointServerBuilder = getEndpointServerBuilder();\n\n\n        if (serviceDiscovery != null) {\n\n            if (localServiceId == null || \"\".equals(localServiceId.trim())) {\n                localServiceId =\n                        serviceName + \"-\" + ServiceDiscovery.uniqueString(endpointServerBuilder.getPort());\n\n            }\n\n\n            serviceDiscovery.registerWithIdAndTimeToLive(this.getServiceName(), localServiceId,\n                    endpointServerBuilder.getHost(), endpointServerBuilder.getPort(), timeToLiveCheckInterval);\n\n\n        }\n        final ServiceQueue serviceQueue = getServiceQueue();\n        final ServiceEndpointServer serviceEndpointServer = endpointServerBuilder.build();\n        serviceEndpointServer.addServiceObject(this.getServiceName(), serviceQueue.service());\n\n        return serviceEndpointServer;\n    }\n\n\n    public StatServiceImpl getStatServiceImpl() {\n\n        if (statServiceImpl == null) {\n            statServiceImpl = build();\n        }\n        return statServiceImpl;\n    }\n\n    public StatServiceBuilder setStatServiceImpl(StatServiceImpl statServiceImpl) {\n        this.statServiceImpl = statServiceImpl;\n        return this;\n    }\n\n    public StatServiceImpl build() {\n\n\n        final StatReplicator replicator = buildReplicator();\n\n\n        return new StatServiceImpl(this.getRecorder(), replicator, getTimer(), getServiceDiscovery(),\n                getLocalServiceId(), getNumStats(), getTimeToLiveCheckInterval());\n\n    }\n\n\n    private StatReplicator buildReplicator() {\n        final List<StatReplicator> finalReplicators = new ArrayList<>();\n\n\n        if (serviceDiscovery != null) {\n            finalReplicators.add(buildClusteredReplicator());\n        }\n\n\n\n        if (!(this.getReplicator() instanceof NoOpReplicator)) {\n            finalReplicators.add(this.getReplicator());\n        }\n\n\n        if (this.replicators.size() > 0) {\n            finalReplicators.addAll(this.replicators);\n        }\n\n\n\n        return finalReplicators.size() == 0\n                ? new NoOpReplicator()\n                : finalReplicators.size() == 1\n                ? finalReplicators.get(0)\n                : new ReplicatorHub(finalReplicators);\n    }\n\n    public StatReplicatorProvider getStatsReplicatorProvider() {\n\n        if (statReplicatorProvider == null) {\n            statReplicatorProvider = buildStatsReplicatorProvider();\n        }\n\n        return statReplicatorProvider;\n    }\n\n    public StatServiceBuilder setStatReplicatorProvider(StatReplicatorProvider statReplicatorProvider) {\n        this.statReplicatorProvider = statReplicatorProvider;\n        return this;\n    }\n\n    private StatReplicator buildClusteredReplicator() {\n\n        return new ClusteredStatReplicator(getServiceName(), getServiceDiscovery(),\n                getStatsReplicatorProvider(), getLocalServiceId(), getTimer(),\n                getTallyInterval(), getFlushInterval());\n    }\n\n    public StatReplicatorProvider buildStatsReplicatorProvider() {\n        return serviceDefinition -> {\n\n            final ClientBuilder clientBuilder1 = getClientBuilder();\n            final Client client = clientBuilder1.setPort(serviceDefinition.getPort())\n                    .setProtocolBatchSize(1000)\n                    .setHost(serviceDefinition.getHost()).build();\n\n            final StatReplicator proxy = client.createProxy(StatReplicator.class, serviceName);\n\n            client.start();\n\n            return new StatReplicator() {\n\n                private final Client theClient = client;\n\n                @Override\n                protected void finalize() throws Throwable {\n                    super.finalize();\n                    if (theClient != null) {\n                        theClient.stop();\n                    }\n                }\n\n                @Override\n                public void replicateCount(String name, long count, long now) {\n\n                    proxy.replicateCount(name, count, now);\n                }\n\n                @Override\n                public void replicateLevel(String name, long level, long time) {\n                    proxy.replicateLevel(name, level, time);\n                }\n\n                @Override\n                public void replicateTiming(String name, long level, long time) {\n                    proxy.replicateTiming(name, level, time);\n                }\n\n                @Override\n                public void clientProxyFlush() {\n                    proxy.clientProxyFlush();\n                }\n\n                @Override\n                public void stop() {\n                    proxy.stop();\n                    theClient.stop();\n                }\n\n                @Override\n                public void flush() {\n                    proxy.flush();\n                    theClient.flush();\n                }\n\n                public String toString() {\n                    return \"StatServiceReplicator \" + proxy;\n                }\n\n                @Override\n                public int port() {\n                    return proxy.port();\n                }\n\n                @Override\n                public String host() {\n                    return proxy.host();\n                }\n\n                @Override\n                public boolean connected() {\n                    return proxy.connected();\n                }\n\n                @Override\n                public boolean remote() {\n                    return proxy.remote();\n                }\n            };\n        };\n    }\n\n    public EventManager getEventManager() {\n        if (eventManager == null) {\n            eventManager = QBit.factory().systemEventManager();\n        }\n        return eventManager;\n    }\n\n    public StatServiceBuilder setEventManager(EventManager eventManager) {\n        this.eventManager = eventManager;\n        return this;\n    }\n\n    public StatsCollector buildStatsCollector() {\n        return new StatsCollectorBuffer(getServiceQueue().createProxy(StatService.class));\n    }\n\n\n    public StatsCollector buildStatsCollectorWithAutoFlush() {\n        return new StatsCollectorBuffer(getServiceQueue().createProxyWithAutoFlush(StatsCollector.class, 1, TimeUnit.SECONDS));\n    }\n}\n",
        "gt": [
            "'qbit/qbit/vertx/src/main/java/io/advantageous/qbit/vertx/http/VertxHttpClientBuilder.java'",
            "'qbit/qbit/admin/src/main/java/io/advantageous/qbit/metrics/support/StatServiceBuilder.java'",
            "'qbit/qbit/admin/src/test/java/io/advantageous/qbit/metrics/support/Prototype.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.NonNull;\nimport android.support.graphics.drawable.AnimatedVectorDrawableCompat;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.ImageButton;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\nimport com.philliphsu.bottomsheetpickers.date.MonthPickerView.OnMonthClickListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\n\n\nclass PagingDayPickerView extends LinearLayout implements OnDateChangedListener, OnPageChangeListener, OnMonthClickListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n    static final int DAY_PICKER_INDEX = 0;\n    static final int MONTH_PICKER_INDEX = 1;\n\n    static int MONTH_NAVIGATION_BAR_SIZE;\n\n    private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected PagingMonthAdapter mAdapter;\n\n    private DayPickerViewAnimator mMonthAnimator;\n    private ViewPager mViewPager;\n    private MonthPickerView mMonthPickerView;\n    private TextView mMonthYearTitleView;\n    private ImageButton mPreviousButton;\n    private ImageButton mNextButton;\n    private View mTitleContainer;\n\n\n    private AnimatedVectorDrawableCompat mArrowDownDrawable;\n\n    private AnimatedVectorDrawableCompat mArrowUpDrawable;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mCurrentMonthDisplayed;\n\n    private int mCurrentView = DAY_PICKER_INDEX;\n\n    private int mCurrentYearDisplayed;\n\n    private DatePickerController mController;\n\n    private boolean mThemeDark;\n    private int mAccentColor;\n\n    public PagingDayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        this(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark,\n                               int accentColor) {\n        super(context);\n\n        mThemeDark = themeDark;\n        mAccentColor = accentColor;\n        init(context);\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n        mMonthPickerView.setDatePickerController(mController);\n    }\n\n    private void init(Context context) {\n        mHandler = new Handler();\n        setOrientation(VERTICAL);\n        setLayoutParams(new LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        Resources res = getResources();\n        MONTH_NAVIGATION_BAR_SIZE = res.getDimensionPixelOffset(R.dimen.bsp_month_navigation_bar_height)\n                + res.getDimensionPixelOffset(R.dimen.bsp_month_view_top_padding);\n\n        final View view = LayoutInflater.from(context).inflate(R.layout.bsp_day_picker_content, this, true);\n        mMonthAnimator = (DayPickerViewAnimator) findViewById(R.id.bsp_month_animator);\n        mMonthPickerView = (MonthPickerView) findViewById(R.id.bsp_month_picker);\n        mMonthPickerView.setOnMonthClickListener(this);\n        mViewPager = (ViewPager) findViewById(R.id.bsp_viewpager);\n        mViewPager.addOnPageChangeListener(this);\n        mMonthYearTitleView = (TextView) view.findViewById(R.id.bsp_month_year_title);\n        mTitleContainer = view.findViewById(R.id.bsp_month_year_title_container);\n        mTitleContainer.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int newIndex = mCurrentView == DAY_PICKER_INDEX ? MONTH_PICKER_INDEX : DAY_PICKER_INDEX;\n                setupCurrentView(newIndex, true);\n            }\n        });\n        mPreviousButton = (ImageButton) view.findViewById(R.id.bsp_prev);\n        mPreviousButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int previousItem = mViewPager.getCurrentItem() - 1;\n                if (previousItem >= 0) {\n                    mViewPager.setCurrentItem(previousItem, true);\n                }\n            }\n        });\n        mNextButton = (ImageButton) view.findViewById(R.id.bsp_next);\n        mNextButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int nextItem = mViewPager.getCurrentItem() + 1;\n                if (nextItem < mAdapter.getCount()) {\n                    mViewPager.setCurrentItem(nextItem, true);\n                }\n            }\n        });\n\n        mArrowDownDrawable = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_down);\n        mArrowUpDrawable   = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_up);\n        setArrowDrawableOnTitle(mArrowDownDrawable);\n\n\n        if (mThemeDark) {\n            int selectableItemBg = getColor(context, R.color.bsp_selectable_item_background_dark);\n            Utils.setColorControlHighlight(mPreviousButton, selectableItemBg);\n            Utils.setColorControlHighlight(mNextButton, selectableItemBg);\n            Utils.setColorControlHighlight(mTitleContainer, selectableItemBg);\n            int cursor = getColor(context, R.color.bsp_text_color_secondary_dark);\n            Utils.applyTint(mPreviousButton, cursor);\n            Utils.applyTint(mNextButton, cursor);\n        }\n\n\n        int monthYearTitleColor = getColor(context, mThemeDark?\n                R.color.bsp_text_color_primary_dark : R.color.bsp_text_color_primary_light);\n        int dropdownArrowColor = getColor(context, mThemeDark?\n                R.color.bsp_icon_color_active_dark : R.color.bsp_icon_color_active_light);\n\n        mMonthYearTitleView.setTextColor(monthYearTitleColor);\n        mArrowDownDrawable.setTint(dropdownArrowColor);\n        mArrowUpDrawable.setTint(dropdownArrowColor);\n\n        mMonthPickerView.setTheme(context, mThemeDark);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mViewPager.removeOnPageChangeListener(this);\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    void setAccentColor(@ColorInt int color) {\n        mAccentColor = color;\n        mMonthPickerView.setCurrentMonthTextColor(color);\n        mMonthPickerView.setSelectedCirclePaintColor(color);\n    }\n\n    public void onChange() {\n        refreshAdapter();\n        refreshMonthPicker();\n    }\n\n\n    void setupCurrentView(int currentView, boolean animate) {\n        if (currentView == DAY_PICKER_INDEX || currentView == MONTH_PICKER_INDEX) {\n            boolean isDayPicker = currentView == DAY_PICKER_INDEX;\n            setCurrentView(currentView, animate);\n            if (isDayPicker) {\n                setTitle(mAdapter.getPageTitle(mViewPager.getCurrentItem()));\n                toggleArrowsVisibility(getPagerPosition());\n            } else {\n\n\n\n                setTitle(String.valueOf(mCurrentYearDisplayed));\n                toggleArrowsVisibility(false, false);\n            }\n        } else {\n            Log.e(TAG, \"Error restoring current view\");\n        }\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            if (mAccentColor != 0) {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark, mAccentColor);\n            } else {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n            }\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        mViewPager.setAdapter(mAdapter);\n    }\n\n\n    private void refreshMonthPicker() {\n        prepareMonthPickerForDisplay(mSelectedDay.year);\n        mMonthPickerView.invalidate();\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller) {\n        return new PagingMonthAdapter(context, controller);\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark) {\n        return createMonthAdapter(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark,\n                                                 int accentColor) {\n        return new PagingMonthAdapter(context, controller, themeDark, accentColor);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n        final int selectedPosition = getPosition(mSelectedDay);\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = getPosition(day);\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthAndYearDisplayed(mTempDay);\n            if (animate) {\n                mViewPager.setCurrentItem(position, true);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n                return true;\n            } else {\n                postSetSelection(position, setSelected);\n            }\n        } else if (setSelected) {\n            setMonthAndYearDisplayed(mSelectedDay);\n            setSelectedDay(mSelectedDay);\n        }\n        return false;\n    }\n\n\n    private int getPosition(CalendarDay day) {\n        return mAdapter.getPosition(day);\n    }\n\n    public void postSetSelection(final int position, final boolean setSelected) {\n        clearFocus();\n        post(new Runnable() {\n            @Override\n            public void run() {\n                mViewPager.setCurrentItem(position, false);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n            }\n        });\n    }\n\n    void postSetupCurrentView(final int currentView, final boolean animate) {\n        post(new Runnable() {\n            @Override\n            public void run() {\n                setupCurrentView(currentView, animate);\n            }\n        });\n    }\n\n\n    protected void setMonthAndYearDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        mCurrentYearDisplayed = date.year;\n    }\n\n    private void setSelectedDay(CalendarDay day) {\n        mAdapter.setSelectedDay(day);\n    }\n\n    @Override\n    public void onDateChanged() {\n        if (mCurrentView != DAY_PICKER_INDEX) {\n            setCurrentView(DAY_PICKER_INDEX, false);\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getPagerPosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        return true;\n    }\n\n    int getPagerPosition() {\n        return mViewPager.getCurrentItem();\n    }\n\n    int getCurrentView() {\n        return mCurrentView;\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mCurrentView == DAY_PICKER_INDEX) {\n            setTitle(mAdapter.getPageTitle(position));\n            toggleArrowsVisibility(position);\n            final int month = mAdapter.getMonth(position);\n            final int year = mAdapter.getYear(position);\n            if (mCurrentYearDisplayed != year) {\n                mCurrentYearDisplayed = year;\n            }\n            if (mCurrentMonthDisplayed != month) {\n                mCurrentMonthDisplayed = month;\n            }\n        }\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n\n    private void setTitle(CharSequence title) {\n        mMonthYearTitleView.setText(title);\n    }\n\n\n    private void toggleArrowsVisibility(int position) {\n        toggleArrowsVisibility(position > 0, position + 1 < mAdapter.getCount());\n    }\n\n    private void toggleArrowsVisibility(boolean leftVisible, boolean rightVisible) {\n        mPreviousButton.setVisibility(leftVisible ? VISIBLE : INVISIBLE);\n        mNextButton.setVisibility(rightVisible ? VISIBLE : INVISIBLE);\n    }\n\n    private void setArrowDrawableOnTitle(@NonNull Drawable arrow) {\n        if (Utils.checkApiLevel(17)) {\n            mMonthYearTitleView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, arrow, null);\n        } else {\n            mMonthYearTitleView.setCompoundDrawablesWithIntrinsicBounds(null, null, arrow, null);\n        }\n    }\n\n    private void animateArrow(AnimatedVectorDrawableCompat arrow) {\n        setArrowDrawableOnTitle(arrow);\n        arrow.start();\n    }\n\n    private void setCurrentView(final int viewIndex, boolean animate) {\n        switch (viewIndex) {\n            case DAY_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    mMonthAnimator.setDisplayedChild(DAY_PICKER_INDEX, animate);\n                    animateArrow(mArrowUpDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n            case MONTH_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    prepareMonthPickerForDisplay(mCurrentYearDisplayed);\n                    mMonthAnimator.setDisplayedChild(MONTH_PICKER_INDEX, animate);\n                    animateArrow(mArrowDownDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n        }\n    }\n\n    private void prepareMonthPickerForDisplay(int currentYear) {\n        mMonthPickerView.setDisplayParams(mSelectedDay, currentYear);\n    }\n\n    @Override\n    public void onMonthClick(MonthPickerView view, int month, int year) {\n\n\n\n\n\n        setCurrentView(DAY_PICKER_INDEX, true);\n\n\n\n\n\n\n\n\n\n\n        if (month == mCurrentMonthDisplayed) {\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        mController.tryVibrate();\n        mController.onMonthYearSelected(month, year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DayPickerViewPager.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerController.java'"
        ]
    },
    {
        "files": [
            "'org.alloytools.alloy/org.alloytools.alloy.application/src/main/java/edu/mit/csail/sdg/alloy4graph/GraphViewer.java'",
            "'org.alloytools.alloy/org.alloytools.alloy.application/src/main/java/edu/mit/csail/sdg/alloy4graph/DotShape.java'",
            "'org.alloytools.alloy/org.alloytools.alloy.application/src/main/java/edu/mit/csail/sdg/alloy4viz/MagicColor.java'"
        ],
        "content": "'org.alloytools.alloy/org.alloytools.alloy.application/src/main/java/edu/mit/csail/sdg/alloy4graph/GraphViewer.java'\n:\n\npackage edu.mit.csail.sdg.alloy4graph;\n\nimport static java.awt.Color.BLACK;\nimport static java.awt.Color.WHITE;\nimport static java.awt.event.InputEvent.BUTTON1_MASK;\nimport static java.awt.event.InputEvent.BUTTON3_MASK;\nimport static java.awt.event.InputEvent.CTRL_MASK;\n\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.RenderingHints;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseMotionAdapter;\nimport java.awt.geom.AffineTransform;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JMenuItem;\nimport javax.swing.JPanel;\nimport javax.swing.JPopupMenu;\nimport javax.swing.JRadioButton;\nimport javax.swing.JTextField;\nimport javax.swing.JViewport;\nimport javax.swing.border.EmptyBorder;\nimport javax.swing.event.DocumentEvent;\nimport javax.swing.event.DocumentListener;\n\nimport edu.mit.csail.sdg.alloy4.OurDialog;\nimport edu.mit.csail.sdg.alloy4.OurPDFWriter;\nimport edu.mit.csail.sdg.alloy4.OurPNGWriter;\nimport edu.mit.csail.sdg.alloy4.OurUtil;\nimport edu.mit.csail.sdg.alloy4.Util;\n\n\n\npublic final strictfp class GraphViewer extends JPanel {\n\n\n    private static final long serialVersionUID = 0;\n\n\n    private final Graph       graph;\n\n\n    private double            scale            = 1d;\n\n\n    private Object            highlight        = null;\n\n\n    private Object            selected         = null;\n\n\n    private int               dragButton       = 0;\n\n\n    public final JPopupMenu   pop              = new JPopupMenu();\n\n\n    private Object alloyFind(int mouseX, int mouseY) {\n        return graph.find(scale, mouseX, mouseY);\n    }\n\n\n    public Object alloyGetAnnotationAtXY(int mouseX, int mouseY) {\n        Object obj = alloyFind(mouseX, mouseY);\n        if (obj instanceof GraphNode)\n            return ((GraphNode) obj).uuid;\n        if (obj instanceof GraphEdge)\n            return ((GraphEdge) obj).uuid;\n        return null;\n    }\n\n\n    public Object alloyGetSelectedAnnotation() {\n        if (selected instanceof GraphNode)\n            return ((GraphNode) selected).uuid;\n        if (selected instanceof GraphEdge)\n            return ((GraphEdge) selected).uuid;\n        return null;\n    }\n\n\n    public Object alloyGetHighlightedAnnotation() {\n        if (highlight instanceof GraphNode)\n            return ((GraphNode) highlight).uuid;\n        if (highlight instanceof GraphEdge)\n            return ((GraphEdge) highlight).uuid;\n        return null;\n    }\n\n\n    private int oldMouseX = 0, oldMouseY = 0, oldX = 0, oldY = 0;\n\n\n    public void alloyRepaint() {\n        Container c = getParent();\n        while (c != null) {\n            if (c instanceof JViewport)\n                break;\n            else\n                c = c.getParent();\n        }\n        setSize((int) (graph.getTotalWidth() * scale), (int) (graph.getTotalHeight() * scale));\n        if (c != null) {\n            c.invalidate();\n            c.repaint();\n            c.validate();\n        } else {\n            invalidate();\n            repaint();\n            validate();\n        }\n    }\n\n\n    public GraphViewer(JFrame parent, final Graph graph) {\n        OurUtil.make(this, BLACK, WHITE, new EmptyBorder(0, 0, 0, 0));\n        setBorder(null);\n        this.scale = graph.defaultScale;\n        this.graph = graph;\n        graph.layout();\n        final JMenuItem zoomIn = new JMenuItem(\"Zoom In\");\n        final JMenuItem zoomOut = new JMenuItem(\"Zoom Out\");\n        final JMenuItem zoomToFit = new JMenuItem(\"Zoom to Fit\");\n        final JMenuItem print = new JMenuItem(\"Export to PNG or PDF\");\n        pop.add(zoomIn);\n        pop.add(zoomOut);\n        pop.add(zoomToFit);\n        pop.add(print);\n        ActionListener act = new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                Container c = getParent();\n                while (c != null) {\n                    if (c instanceof JViewport)\n                        break;\n                    else\n                        c = c.getParent();\n                }\n                if (e.getSource() == print)\n                    alloySaveAs(parent);\n                if (e.getSource() == zoomIn) {\n                    scale = scale * 1.33d;\n                    if (!(scale < 500d))\n                        scale = 500d;\n                }\n                if (e.getSource() == zoomOut) {\n                    scale = scale / 1.33d;\n                    if (!(scale > 0.1d))\n                        scale = 0.1d;\n                }\n                if (e.getSource() == zoomToFit) {\n                    if (c == null)\n                        return;\n                    int w = c.getWidth() - 15, h = c.getHeight() - 15;\n\n\n\n\n\n                    if (w <= 0 || h <= 0)\n                        return;\n                    double scale1 = ((double) w) / graph.getTotalWidth(),\n                                    scale2 = ((double) h) / graph.getTotalHeight();\n                    if (scale1 < scale2)\n                        scale = scale1;\n                    else\n                        scale = scale2;\n                }\n                alloyRepaint();\n            }\n        };\n        zoomIn.addActionListener(act);\n        zoomOut.addActionListener(act);\n        zoomToFit.addActionListener(act);\n        print.addActionListener(act);\n        addMouseMotionListener(new MouseMotionAdapter() {\n\n            @Override\n            public void mouseMoved(MouseEvent ev) {\n                if (pop.isVisible())\n                    return;\n                Object obj = alloyFind(ev.getX(), ev.getY());\n                if (highlight != obj) {\n                    highlight = obj;\n                    alloyRepaint();\n                }\n            }\n\n            @Override\n            public void mouseDragged(MouseEvent ev) {\n                if (selected instanceof GraphNode && dragButton == 1) {\n                    int newX = (int) (oldX + (ev.getX() - oldMouseX) / scale);\n                    int newY = (int) (oldY + (ev.getY() - oldMouseY) / scale);\n                    GraphNode n = (GraphNode) selected;\n                    if (n.x() != newX || n.y() != newY) {\n                        n.tweak(newX, newY);\n                        alloyRepaint();\n                        scrollRectToVisible(new Rectangle((int) ((newX - graph.getLeft()) * scale) - n.getWidth() / 2 - 5, (int) ((newY - graph.getTop()) * scale) - n.getHeight() / 2 - 5, n.getWidth() + n.getReserved() + 10, n.getHeight() + 10));\n                    }\n                }\n            }\n        });\n        addMouseListener(new MouseAdapter() {\n\n            @Override\n            public void mouseReleased(MouseEvent ev) {\n                Object obj = alloyFind(ev.getX(), ev.getY());\n                graph.recalcBound(true);\n                selected = null;\n                highlight = obj;\n                alloyRepaint();\n            }\n\n            @Override\n            public void mousePressed(MouseEvent ev) {\n                dragButton = 0;\n                int mod = ev.getModifiers();\n                if ((mod & BUTTON3_MASK) != 0) {\n                    selected = alloyFind(ev.getX(), ev.getY());\n                    highlight = null;\n                    alloyRepaint();\n                    pop.show(GraphViewer.this, ev.getX(), ev.getY());\n                } else if ((mod & BUTTON1_MASK) != 0 && (mod & CTRL_MASK) != 0) {\n\n\n\n                    selected = alloyFind(ev.getX(), ev.getY());\n                    highlight = null;\n                    alloyRepaint();\n                    pop.show(GraphViewer.this, ev.getX(), ev.getY());\n                } else if ((mod & BUTTON1_MASK) != 0) {\n                    dragButton = 1;\n                    selected = alloyFind(oldMouseX = ev.getX(), oldMouseY = ev.getY());\n                    highlight = null;\n                    alloyRepaint();\n                    if (selected instanceof GraphNode) {\n                        oldX = ((GraphNode) selected).x();\n                        oldY = ((GraphNode) selected).y();\n                    }\n                }\n            }\n\n            @Override\n            public void mouseExited(MouseEvent ev) {\n                if (highlight != null) {\n                    highlight = null;\n                    alloyRepaint();\n                }\n            }\n        });\n    }\n\n\n    private final Color            badColor  = new Color(255, 200, 200);\n\n\n    private static volatile double oldDPI    = 72;\n\n\n    private boolean                recursive = false;\n\n\n    private int alloyRefresh(int who, double ratio, JTextField w1, JLabel w2, JTextField h1, JLabel h2, JTextField d1, JLabel d2, JLabel msg) {\n        if (recursive)\n            return 0;\n        try {\n            recursive = true;\n            w1.setBackground(WHITE);\n            h1.setBackground(WHITE);\n            d1.setBackground(WHITE);\n            boolean bad = false;\n            double w;\n            try {\n                w = Double.parseDouble(w1.getText());\n            } catch (NumberFormatException ex) {\n                w = 0;\n            }\n            double h;\n            try {\n                h = Double.parseDouble(h1.getText());\n            } catch (NumberFormatException ex) {\n                h = 0;\n            }\n            double d;\n            try {\n                d = Double.parseDouble(d1.getText());\n            } catch (NumberFormatException ex) {\n                d = 0;\n            }\n            if (who == 1) {\n                h = ((int) (w * 100 / ratio)) / 100D;\n                h1.setText(\"\" + h);\n            }\n            if (who == 2) {\n                w = ((int) (h * 100 * ratio)) / 100D;\n                w1.setText(\"\" + w);\n            }\n            if (!(d >= 0.01) || !(d <= 10000)) {\n                bad = true;\n                d1.setBackground(badColor);\n                msg.setText(\"DPI must be between 0.01 and 10000\");\n            }\n            if (!(h >= 0.01) || !(h <= 10000)) {\n                bad = true;\n                h1.setBackground(badColor);\n                msg.setText(\"Height must be between 0.01 and 10000\");\n                if (who == 1)\n                    h1.setText(\"\");\n            }\n            if (!(w >= 0.01) || !(w <= 10000)) {\n                bad = true;\n                w1.setBackground(badColor);\n                msg.setText(\"Width must be between 0.01 and 10000\");\n                if (who == 2)\n                    w1.setText(\"\");\n            }\n            if (bad) {\n                w2.setText(\" inches\");\n                h2.setText(\" inches\");\n                return 0;\n            } else\n                msg.setText(\" \");\n            w2.setText(\" inches (\" + (int) (w * d) + \" pixels)\");\n            h2.setText(\" inches (\" + (int) (h * d) + \" pixels)\");\n            return (int) (w * d);\n        } finally {\n            recursive = false;\n        }\n    }\n\n\n    public void alloySaveAs(JFrame parent) {\n\n\n        final double ratio = ((double) (graph.getTotalWidth())) / graph.getTotalHeight();\n        double dpi, iw = 8.5D, ih = ((int) (iw * 100 / ratio)) / 100D;\n\n\n\n\n\n\n\n\n\n        if (ih > 11D) {\n            ih = 11D;\n            iw = ((int) (ih * 100 * ratio)) / 100D;\n        }\n        synchronized (GraphViewer.class) {\n            dpi = oldDPI;\n        }\n\n        final JLabel msg = OurUtil.label(\" \", Color.RED);\n        final JLabel w = OurUtil.label(\"Width: \" + ((int) (graph.getTotalWidth() * scale)) + \" pixels\");\n        final JLabel h = OurUtil.label(\"Height: \" + ((int) (graph.getTotalHeight() * scale)) + \" pixels\");\n        final JTextField w1 = new JTextField(\"\" + iw);\n        final JLabel w0 = OurUtil.label(\"Width: \"), w2 = OurUtil.label(\"\");\n        final JTextField h1 = new JTextField(\"\" + ih);\n        final JLabel h0 = OurUtil.label(\"Height: \"), h2 = OurUtil.label(\"\");\n        final JTextField d1 = new JTextField(\"\" + (int) dpi);\n        final JLabel d0 = OurUtil.label(\"Resolution: \"), d2 = OurUtil.label(\" dots per inch\");\n        final JTextField dp1 = new JTextField(\"\" + (int) dpi);\n        final JLabel dp0 = OurUtil.label(\"Resolution: \"), dp2 = OurUtil.label(\" dots per inch\");\n        alloyRefresh(0, ratio, w1, w2, h1, h2, d1, d2, msg);\n        Dimension dim = new Dimension(100, 20);\n        w1.setMaximumSize(dim);\n        w1.setPreferredSize(dim);\n        w1.setEnabled(false);\n        h1.setMaximumSize(dim);\n        h1.setPreferredSize(dim);\n        h1.setEnabled(false);\n        d1.setMaximumSize(dim);\n        d1.setPreferredSize(dim);\n        d1.setEnabled(false);\n        dp1.setMaximumSize(dim);\n        dp1.setPreferredSize(dim);\n        dp1.setEnabled(false);\n        w1.getDocument().addDocumentListener(new DocumentListener() {\n\n            @Override\n            public void changedUpdate(DocumentEvent e) {\n                alloyRefresh(1, ratio, w1, w2, h1, h2, d1, d2, msg);\n            }\n\n            @Override\n            public void insertUpdate(DocumentEvent e) {\n                changedUpdate(null);\n            }\n\n            @Override\n            public void removeUpdate(DocumentEvent e) {\n                changedUpdate(null);\n            }\n        });\n        h1.getDocument().addDocumentListener(new DocumentListener() {\n\n            @Override\n            public void changedUpdate(DocumentEvent e) {\n                alloyRefresh(2, ratio, w1, w2, h1, h2, d1, d2, msg);\n            }\n\n            @Override\n            public void insertUpdate(DocumentEvent e) {\n                changedUpdate(null);\n            }\n\n            @Override\n            public void removeUpdate(DocumentEvent e) {\n                changedUpdate(null);\n            }\n        });\n        d1.getDocument().addDocumentListener(new DocumentListener() {\n\n            @Override\n            public void changedUpdate(DocumentEvent e) {\n                alloyRefresh(3, ratio, w1, w2, h1, h2, d1, d2, msg);\n            }\n\n            @Override\n            public void insertUpdate(DocumentEvent e) {\n                changedUpdate(null);\n            }\n\n            @Override\n            public void removeUpdate(DocumentEvent e) {\n                changedUpdate(null);\n            }\n        });\n        final JRadioButton b1 = new JRadioButton(\"As a PNG with the window's current magnification:\", true);\n        final JRadioButton b2 = new JRadioButton(\"As a PNG with a specific width, height, and resolution:\", false);\n        final JRadioButton b3 = new JRadioButton(\"As a PDF with the given resolution:\", false);\n        b1.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                b2.setSelected(false);\n                b3.setSelected(false);\n                if (!b1.isSelected())\n                    b1.setSelected(true);\n                w1.setEnabled(false);\n                h1.setEnabled(false);\n                d1.setEnabled(false);\n                dp1.setEnabled(false);\n                msg.setText(\" \");\n                w1.setBackground(WHITE);\n                h1.setBackground(WHITE);\n                d1.setBackground(WHITE);\n            }\n        });\n        b2.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                b1.setSelected(false);\n                b3.setSelected(false);\n                if (!b2.isSelected())\n                    b2.setSelected(true);\n                w1.setEnabled(true);\n                h1.setEnabled(true);\n                d1.setEnabled(true);\n                dp1.setEnabled(false);\n                msg.setText(\" \");\n                alloyRefresh(1, ratio, w1, w2, h1, h2, d1, d2, msg);\n            }\n        });\n        b3.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                b1.setSelected(false);\n                b2.setSelected(false);\n                if (!b3.isSelected())\n                    b3.setSelected(true);\n                w1.setEnabled(false);\n                h1.setEnabled(false);\n                d1.setEnabled(false);\n                dp1.setEnabled(true);\n                msg.setText(\" \");\n                w1.setBackground(WHITE);\n                h1.setBackground(WHITE);\n                d1.setBackground(WHITE);\n            }\n        });\n\n        double myScale;\n        while (true) {\n            if (!OurDialog.getInput(parent, \"Export as PNG or PDF\", new Object[] {\n                                                                                  b1, OurUtil.makeH(20, w, null), OurUtil.makeH(20, h, null), \" \", b2, OurUtil.makeH(20, w0, w1, w2, null), OurUtil.makeH(20, h0, h1, h2, null), OurUtil.makeH(20, d0, d1, d2, null), OurUtil.makeH(20, msg, null), b3, OurUtil.makeH(20, dp0, dp1, dp2, null)\n            }))\n                return;\n\n            if (b2.isSelected()) {\n                int widthInPixel = alloyRefresh(3, ratio, w1, w2, h1, h2, d1, d2, msg);\n                String err = msg.getText().trim();\n                if (err.length() > 0)\n                    continue;\n                dpi = Double.parseDouble(d1.getText());\n                myScale = ((double) widthInPixel) / graph.getTotalWidth();\n                int heightInPixel = (int) (graph.getTotalHeight() * myScale);\n                if (widthInPixel > 4000 || heightInPixel > 4000)\n                    if (!OurDialog.yesno(parent, \"The image dimension (\" + widthInPixel + \"x\" + heightInPixel + \") is very large. Are you sure?\"))\n                        continue;\n            } else if (b3.isSelected()) {\n                try {\n                    dpi = Double.parseDouble(dp1.getText());\n                } catch (NumberFormatException ex) {\n                    dpi = (-1);\n                }\n                if (dpi < 50 || dpi > 3000) {\n                    OurDialog.alert(parent, \"The DPI must be between 50 and 3000.\");\n                    continue;\n                }\n                myScale = 0;\n            } else {\n                dpi = 72;\n                myScale = scale;\n            }\n            break;\n        }\n\n        File filename;\n        if (b3.isSelected())\n            filename = OurDialog.askFile(parent, false, null, \".pdf\", \"PDF file\");\n        else\n            filename = OurDialog.askFile(parent, false, null, \".png\", \"PNG file\");\n        if (filename == null)\n            return;\n        if (filename.exists() && !OurDialog.askOverwrite(parent, filename.getAbsolutePath()))\n            return;\n\n        try {\n            System.gc();\n\n            if (b3.isSelected())\n                alloySaveAsPDF(filename.getAbsolutePath(), (int) dpi);\n            else\n                alloySaveAsPNG(filename.getAbsolutePath(), myScale, dpi, dpi);\n            synchronized (GraphViewer.class) {\n                oldDPI = dpi;\n            }\n            Util.setCurrentDirectory(filename.getParentFile());\n        } catch (Throwable ex) {\n            OurDialog.alert(parent, \"An error has occurred in writing the output file:\\n\" + ex);\n        }\n    }\n\n\n    public void alloySaveAsPDF(String filename, int dpi) throws IOException {\n        try {\n            double xwidth = dpi * 8L + (dpi / 2L);\n            double xheight = dpi * 11L;\n            double scale1 = (xwidth - dpi) / graph.getTotalWidth();\n\n\n\n\n            double scale2 = (xheight - dpi) / graph.getTotalHeight();\n\n\n\n\n\n\n\n\n            if (scale1 < scale2)\n                scale2 = scale1;\n\n            OurPDFWriter x = new OurPDFWriter(filename, dpi, scale2);\n            graph.draw(new Artist(x), scale2, null, false);\n            x.close();\n        } catch (Throwable ex) {\n            if (ex instanceof IOException)\n                throw (IOException) ex;\n            throw new IOException(\"Failure writing the PDF file to \" + filename + \" (\" + ex + \")\");\n        }\n    }\n\n\n    public void alloySaveAsPNG(String filename, double scale, double dpiX, double dpiY) throws IOException {\n        try {\n            int width = (int) (graph.getTotalWidth() * scale);\n            if (width < 10)\n                width = 10;\n            int height = (int) (graph.getTotalHeight() * scale);\n            if (height < 10)\n                height = 10;\n            BufferedImage bf = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n            Graphics2D gr = (Graphics2D) (bf.getGraphics());\n            gr.setColor(WHITE);\n            gr.fillRect(0, 0, width, height);\n            gr.setColor(BLACK);\n            gr.scale(scale, scale);\n            gr.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n            graph.draw(new Artist(gr), scale, null, false);\n            OurPNGWriter.writePNG(bf, filename, dpiX, dpiY);\n        } catch (Throwable ex) {\n            if (ex instanceof IOException)\n                throw (IOException) ex;\n            throw new IOException(\"Failure writing the PNG file to \" + filename + \" (\" + ex + \")\");\n        }\n    }\n\n\n    public void alloyPopup(Component c, int x, int y) {\n        pop.show(c, x, y);\n    }\n\n\n    @Override\n    public String toString() {\n        return graph.toString();\n    }\n\n\n    @Override\n    public Dimension getPreferredSize() {\n        return new Dimension((int) (graph.getTotalWidth() * scale), (int) (graph.getTotalHeight() * scale));\n    }\n\n\n    public double getScale() {\n        return scale;\n    }\n\n\n    public void setScale(double scale) {\n        this.scale = scale;\n    }\n\n\n    @Override\n    public void paintComponent(final Graphics gr) {\n        super.paintComponent(gr);\n        Graphics2D g2 = (Graphics2D) gr;\n        AffineTransform oldAF = (AffineTransform) (g2.getTransform().clone());\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.scale(scale, scale);\n        Object sel = (selected != null ? selected : highlight);\n        GraphNode c = null;\n        if (sel instanceof GraphNode && ((GraphNode) sel).shape() == null) {\n            c = (GraphNode) sel;\n            sel = c.ins.get(0);\n        }\n        graph.draw(new Artist(g2), scale, sel, true);\n        if (c != null) {\n            gr.setColor(((GraphEdge) sel).color());\n            gr.fillArc(c.x() - 5 - graph.getLeft(), c.y() - 5 - graph.getTop(), 10, 10, 0, 360);\n        }\n        g2.setTransform(oldAF);\n    }\n}\n",
        "gt": [
            "'org.alloytools.alloy/org.alloytools.alloy.application/src/main/java/edu/mit/csail/sdg/alloy4graph/DotShape.java'",
            "'org.alloytools.alloy/org.alloytools.alloy.application/src/main/java/edu/mit/csail/sdg/alloy4viz/MagicColor.java'",
            "'org.alloytools.alloy/org.alloytools.alloy.application/src/main/java/edu/mit/csail/sdg/alloy4graph/GraphViewer.java'"
        ]
    },
    {
        "files": [
            "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'",
            "'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'"
        ],
        "content": "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'\n:\npackage org.intellij.jflex.psi;\n\nimport com.intellij.psi.tree.IElementType;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.lang.ASTNode;\nimport org.intellij.jflex.psi.impl.*;\nimport com.intellij.psi.impl.source.tree.CompositePsiElement;\n\npublic interface JFlexTypes {\n\n  IElementType FLEX_CHAR_RANGE = new JFlexCompositeElementType(\"FLEX_CHAR_RANGE\");\n  IElementType FLEX_CHOICE_EXPRESSION = new JFlexCompositeElementType(\"FLEX_CHOICE_EXPRESSION\");\n  IElementType FLEX_CLASS_EXPRESSION = new JFlexCompositeElementType(\"FLEX_CLASS_EXPRESSION\");\n  IElementType FLEX_DECLARATIONS_SECTION = new JFlexCompositeElementType(\"FLEX_DECLARATIONS_SECTION\");\n  IElementType FLEX_EXPRESSION = new JFlexCompositeElementType(\"FLEX_EXPRESSION\");\n  IElementType FLEX_JAVA_CODE = new JFlexCompositeElementType(\"FLEX_JAVA_CODE\");\n  IElementType FLEX_JAVA_NAME = new JFlexCompositeElementType(\"FLEX_JAVA_NAME\");\n  IElementType FLEX_JAVA_TYPE = new JFlexCompositeElementType(\"FLEX_JAVA_TYPE\");\n  IElementType FLEX_JAVA_TYPE_PARAMETERS = new JFlexCompositeElementType(\"FLEX_JAVA_TYPE_PARAMETERS\");\n  IElementType FLEX_LEXICAL_RULES_SECTION = new JFlexCompositeElementType(\"FLEX_LEXICAL_RULES_SECTION\");\n  IElementType FLEX_LITERAL_EXPRESSION = new JFlexCompositeElementType(\"FLEX_LITERAL_EXPRESSION\");\n  IElementType FLEX_LOOK_AHEAD = new JFlexCompositeElementType(\"FLEX_LOOK_AHEAD\");\n  IElementType FLEX_MACRO_DEFINITION = new JFlexCompositeElementType(\"FLEX_MACRO_DEFINITION\");\n  IElementType FLEX_MACRO_REFERENCE = new JFlexCompositeElementType(\"FLEX_MACRO_REFERENCE\");\n  IElementType FLEX_MACRO_REF_EXPRESSION = new JFlexCompositeElementType(\"FLEX_MACRO_REF_EXPRESSION\");\n  IElementType FLEX_NOT_EXPRESSION = new JFlexCompositeElementType(\"FLEX_NOT_EXPRESSION\");\n  IElementType FLEX_OPTION = new JFlexCompositeElementType(\"FLEX_OPTION\");\n  IElementType FLEX_PAREN_EXPRESSION = new JFlexCompositeElementType(\"FLEX_PAREN_EXPRESSION\");\n  IElementType FLEX_PREDEFINED_CLASS_EXPRESSION = new JFlexCompositeElementType(\"FLEX_PREDEFINED_CLASS_EXPRESSION\");\n  IElementType FLEX_QUANTIFIER_EXPRESSION = new JFlexCompositeElementType(\"FLEX_QUANTIFIER_EXPRESSION\");\n  IElementType FLEX_RULE = new JFlexCompositeElementType(\"FLEX_RULE\");\n  IElementType FLEX_SEQUENCE_EXPRESSION = new JFlexCompositeElementType(\"FLEX_SEQUENCE_EXPRESSION\");\n  IElementType FLEX_STATE_DECLARATION = new JFlexCompositeElementType(\"FLEX_STATE_DECLARATION\");\n  IElementType FLEX_STATE_DEFINITION = new JFlexCompositeElementType(\"FLEX_STATE_DEFINITION\");\n  IElementType FLEX_STATE_LIST = new JFlexCompositeElementType(\"FLEX_STATE_LIST\");\n  IElementType FLEX_STATE_REFERENCE = new JFlexCompositeElementType(\"FLEX_STATE_REFERENCE\");\n  IElementType FLEX_USER_CODE_SECTION = new JFlexCompositeElementType(\"FLEX_USER_CODE_SECTION\");\n  IElementType FLEX_USER_VALUE = new JFlexCompositeElementType(\"FLEX_USER_VALUE\");\n\n  IElementType FLEX_AMPAMP = new JFlexTokenType(\"&&\");\n  IElementType FLEX_ANGLE1 = new JFlexTokenType(\"<\");\n  IElementType FLEX_ANGLE2 = new JFlexTokenType(\">\");\n  IElementType FLEX_BANG = new JFlexTokenType(\"!\");\n  IElementType FLEX_BAR = new JFlexTokenType(\"|\");\n  IElementType FLEX_BARBAR = new JFlexTokenType(\"||\");\n  IElementType FLEX_BLOCK_COMMENT = new JFlexTokenType(\"block_comment\");\n  IElementType FLEX_BRACE1 = new JFlexTokenType(\"{\");\n  IElementType FLEX_BRACE2 = new JFlexTokenType(\"}\");\n  IElementType FLEX_BRACK1 = new JFlexTokenType(\"[\");\n  IElementType FLEX_BRACK2 = new JFlexTokenType(\"]\");\n  IElementType FLEX_CHAR = new JFlexTokenType(\"char\");\n  IElementType FLEX_CHAR_CLASS = new JFlexTokenType(\"char_class\");\n  IElementType FLEX_CHAR_ESC = new JFlexTokenType(\"char_esc\");\n  IElementType FLEX_COMMA = new JFlexTokenType(\",\");\n  IElementType FLEX_DASH = new JFlexTokenType(\"-\");\n  IElementType FLEX_DASHDASH = new JFlexTokenType(\"--\");\n  IElementType FLEX_DOLLAR = new JFlexTokenType(\"$\");\n  IElementType FLEX_DOT = new JFlexTokenType(\".\");\n  IElementType FLEX_EOF = new JFlexTokenType(\"<<EOF>>\");\n  IElementType FLEX_EQ = new JFlexTokenType(\"=\");\n  IElementType FLEX_FSLASH = new JFlexTokenType(\"/\");\n  IElementType FLEX_HAT = new JFlexTokenType(\"^\");\n  IElementType FLEX_ID = new JFlexTokenType(\"id\");\n  IElementType FLEX_LINE_COMMENT = new JFlexTokenType(\"line_comment\");\n  IElementType FLEX_NUMBER = new JFlexTokenType(\"number\");\n  IElementType FLEX_OPT16BIT = new JFlexTokenType(\"%16bit\");\n  IElementType FLEX_OPT_7BIT = new JFlexTokenType(\"%7bit\");\n  IElementType FLEX_OPT_8BIT = new JFlexTokenType(\"%8bit\");\n  IElementType FLEX_OPT_ABSTRACT = new JFlexTokenType(\"%abstract\");\n  IElementType FLEX_OPT_APIPRIVATE = new JFlexTokenType(\"%apiprivate\");\n  IElementType FLEX_OPT_BUFFER = new JFlexTokenType(\"%buffer\");\n  IElementType FLEX_OPT_CASELESS = new JFlexTokenType(\"%caseless\");\n  IElementType FLEX_OPT_CHAR = new JFlexTokenType(\"%char\");\n  IElementType FLEX_OPT_CLASS = new JFlexTokenType(\"%class\");\n  IElementType FLEX_OPT_CODE1 = new JFlexTokenType(\"%{\");\n  IElementType FLEX_OPT_CODE2 = new JFlexTokenType(\"%}\");\n  IElementType FLEX_OPT_COLUMN = new JFlexTokenType(\"%column\");\n  IElementType FLEX_OPT_CTORARG = new JFlexTokenType(\"%ctorarg\");\n  IElementType FLEX_OPT_CUP = new JFlexTokenType(\"%cup\");\n  IElementType FLEX_OPT_CUPDEBUG = new JFlexTokenType(\"%cupdebug\");\n  IElementType FLEX_OPT_CUPSYM = new JFlexTokenType(\"%cupsym\");\n  IElementType FLEX_OPT_DEBUG = new JFlexTokenType(\"%debug\");\n  IElementType FLEX_OPT_EOF1 = new JFlexTokenType(\"%eof{\");\n  IElementType FLEX_OPT_EOF2 = new JFlexTokenType(\"%eof}\");\n  IElementType FLEX_OPT_EOFCLOSE = new JFlexTokenType(\"%eofclose\");\n  IElementType FLEX_OPT_EOFTHROW = new JFlexTokenType(\"%eofthrow\");\n  IElementType FLEX_OPT_EOFTHROW1 = new JFlexTokenType(\"%eofthrow{\");\n  IElementType FLEX_OPT_EOFTHROW2 = new JFlexTokenType(\"%eofthrow}\");\n  IElementType FLEX_OPT_EOFVAL1 = new JFlexTokenType(\"%eofval{\");\n  IElementType FLEX_OPT_EOFVAL2 = new JFlexTokenType(\"%eofval}\");\n  IElementType FLEX_OPT_EXTENDS = new JFlexTokenType(\"%extends\");\n  IElementType FLEX_OPT_FINAL = new JFlexTokenType(\"%final\");\n  IElementType FLEX_OPT_FULL = new JFlexTokenType(\"%full\");\n  IElementType FLEX_OPT_FUNCTION = new JFlexTokenType(\"%function\");\n  IElementType FLEX_OPT_IGNORECASE = new JFlexTokenType(\"%ignorecase\");\n  IElementType FLEX_OPT_IMPLEMENTS = new JFlexTokenType(\"%implements\");\n  IElementType FLEX_OPT_INCLUDE = new JFlexTokenType(\"%include\");\n  IElementType FLEX_OPT_INIT1 = new JFlexTokenType(\"%init{\");\n  IElementType FLEX_OPT_INIT2 = new JFlexTokenType(\"%init}\");\n  IElementType FLEX_OPT_INITTHROW = new JFlexTokenType(\"%initthrow\");\n  IElementType FLEX_OPT_INITTHROW1 = new JFlexTokenType(\"%initthrow{\");\n  IElementType FLEX_OPT_INITTHROW2 = new JFlexTokenType(\"%initthrow}\");\n  IElementType FLEX_OPT_INT = new JFlexTokenType(\"%int\");\n  IElementType FLEX_OPT_INTEGER = new JFlexTokenType(\"%integer\");\n  IElementType FLEX_OPT_INTWRAP = new JFlexTokenType(\"%intwrap\");\n  IElementType FLEX_OPT_LINE = new JFlexTokenType(\"%line\");\n  IElementType FLEX_OPT_NOTUNIX = new JFlexTokenType(\"%notunix\");\n  IElementType FLEX_OPT_PUBLIC = new JFlexTokenType(\"%public\");\n  IElementType FLEX_OPT_SCANERROR = new JFlexTokenType(\"%scanerror\");\n  IElementType FLEX_OPT_STANDALONE = new JFlexTokenType(\"%standalone\");\n  IElementType FLEX_OPT_STATE = new JFlexTokenType(\"%state\");\n  IElementType FLEX_OPT_TYPE = new JFlexTokenType(\"%type\");\n  IElementType FLEX_OPT_UNICODE = new JFlexTokenType(\"%unicode\");\n  IElementType FLEX_OPT_XSTATE = new JFlexTokenType(\"%xstate\");\n  IElementType FLEX_OPT_YYEOF = new JFlexTokenType(\"%yyeof\");\n  IElementType FLEX_OPT_YYLEXTHROW = new JFlexTokenType(\"%yylexthrow\");\n  IElementType FLEX_OPT_YYLEXTHROW1 = new JFlexTokenType(\"%yylexthrow{\");\n  IElementType FLEX_OPT_YYLEXTHROW2 = new JFlexTokenType(\"%yylexthrow}\");\n  IElementType FLEX_PAREN1 = new JFlexTokenType(\"(\");\n  IElementType FLEX_PAREN2 = new JFlexTokenType(\")\");\n  IElementType FLEX_PLUS = new JFlexTokenType(\"+\");\n  IElementType FLEX_QUESTION = new JFlexTokenType(\"?\");\n  IElementType FLEX_RAW = new JFlexTokenType(\"code block\");\n  IElementType FLEX_STAR = new JFlexTokenType(\"*\");\n  IElementType FLEX_STRING = new JFlexTokenType(\"string\");\n  IElementType FLEX_TILDE = new JFlexTokenType(\"~\");\n  IElementType FLEX_TILDETILDE = new JFlexTokenType(\"~~\");\n  IElementType FLEX_TWO_PERCS = new JFlexTokenType(\"%%\");\n  IElementType FLEX_UNCLOSED = new JFlexTokenType(\"unclosed\");\n  IElementType FLEX_VERSION = new JFlexTokenType(\"version\");\n\n  class Factory {\n    public static CompositePsiElement createElement(IElementType type) {\n       if (type == FLEX_CHAR_RANGE) {\n        return new JFlexCharRangeImpl(type);\n      }\n      else if (type == FLEX_CHOICE_EXPRESSION) {\n        return new JFlexChoiceExpressionImpl(type);\n      }\n      else if (type == FLEX_CLASS_EXPRESSION) {\n        return new JFlexClassExpressionImpl(type);\n      }\n      else if (type == FLEX_DECLARATIONS_SECTION) {\n        return new JFlexDeclarationsSectionImpl(type);\n      }\n      else if (type == FLEX_JAVA_CODE) {\n        return new JFlexJavaCodeImpl(type);\n      }\n      else if (type == FLEX_JAVA_NAME) {\n        return new JFlexJavaNameImpl(type);\n      }\n      else if (type == FLEX_JAVA_TYPE) {\n        return new JFlexJavaTypeImpl(type);\n      }\n      else if (type == FLEX_JAVA_TYPE_PARAMETERS) {\n        return new JFlexJavaTypeParametersImpl(type);\n      }\n      else if (type == FLEX_LEXICAL_RULES_SECTION) {\n        return new JFlexLexicalRulesSectionImpl(type);\n      }\n      else if (type == FLEX_LITERAL_EXPRESSION) {\n        return new JFlexLiteralExpressionImpl(type);\n      }\n      else if (type == FLEX_LOOK_AHEAD) {\n        return new JFlexLookAheadImpl(type);\n      }\n      else if (type == FLEX_MACRO_DEFINITION) {\n        return new JFlexMacroDefinitionImpl(type);\n      }\n      else if (type == FLEX_MACRO_REFERENCE) {\n        return new JFlexMacroReferenceImpl(type);\n      }\n      else if (type == FLEX_MACRO_REF_EXPRESSION) {\n        return new JFlexMacroRefExpressionImpl(type);\n      }\n      else if (type == FLEX_NOT_EXPRESSION) {\n        return new JFlexNotExpressionImpl(type);\n      }\n      else if (type == FLEX_OPTION) {\n        return new JFlexOptionImpl(type);\n      }\n      else if (type == FLEX_PAREN_EXPRESSION) {\n        return new JFlexParenExpressionImpl(type);\n      }\n      else if (type == FLEX_PREDEFINED_CLASS_EXPRESSION) {\n        return new JFlexPredefinedClassExpressionImpl(type);\n      }\n      else if (type == FLEX_QUANTIFIER_EXPRESSION) {\n        return new JFlexQuantifierExpressionImpl(type);\n      }\n      else if (type == FLEX_RULE) {\n        return new JFlexRuleImpl(type);\n      }\n      else if (type == FLEX_SEQUENCE_EXPRESSION) {\n        return new JFlexSequenceExpressionImpl(type);\n      }\n      else if (type == FLEX_STATE_DECLARATION) {\n        return new JFlexStateDeclarationImpl(type);\n      }\n      else if (type == FLEX_STATE_DEFINITION) {\n        return new JFlexStateDefinitionImpl(type);\n      }\n      else if (type == FLEX_STATE_LIST) {\n        return new JFlexStateListImpl(type);\n      }\n      else if (type == FLEX_STATE_REFERENCE) {\n        return new JFlexStateReferenceImpl(type);\n      }\n      else if (type == FLEX_USER_CODE_SECTION) {\n        return new JFlexUserCodeSectionImpl(type);\n      }\n      else if (type == FLEX_USER_VALUE) {\n        return new JFlexUserValueImpl(type);\n      }\n      throw new AssertionError(\"Unknown element type: \" + type);\n    }\n  }\n}\n\n'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'\n:\n\npackage org.intellij.jflex.editor;\n\nimport com.intellij.lexer.Lexer;\nimport com.intellij.openapi.editor.DefaultLanguageHighlighterColors;\nimport com.intellij.openapi.editor.HighlighterColors;\nimport com.intellij.openapi.editor.colors.EditorColors;\nimport com.intellij.openapi.editor.colors.TextAttributesKey;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighter;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighterBase;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighterFactory;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.intellij.psi.TokenType;\nimport com.intellij.psi.tree.IElementType;\nimport org.intellij.jflex.parser.JFlexLexer;\nimport org.jetbrains.annotations.NotNull;\n\nimport static com.intellij.openapi.editor.colors.TextAttributesKey.createTextAttributesKey;\nimport static org.intellij.jflex.psi.JFlexTokenSets.CHAR_CLASS_OPERATORS;\nimport static org.intellij.jflex.psi.JFlexTokenSets.PATTERN_OPERATORS;\nimport static org.intellij.jflex.psi.JFlexTypes.*;\n\nfinal class JFlexSyntaxHighlighterFactory extends SyntaxHighlighterFactory {\n  public static final TextAttributesKey ILLEGAL    = createTextAttributesKey(\"FLEX_ILLEGAL\", HighlighterColors.BAD_CHARACTER);\n\n  public static final TextAttributesKey MACRO      = createTextAttributesKey(\"FLEX_MACRO\", DefaultLanguageHighlighterColors.INSTANCE_FIELD);\n  public static final TextAttributesKey STATE      = createTextAttributesKey(\"FLEX_STATE\", DefaultLanguageHighlighterColors.CLASS_NAME);\n  public static final TextAttributesKey CLASS      = createTextAttributesKey(\"FLEX_CLASS\");\n  public static final TextAttributesKey PATTERN_OP = createTextAttributesKey(\"FLEX_PATTERN_OP\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey CLASS_OP   = createTextAttributesKey(\"FLEX_CHAR_CLASS_OP\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey OP_RANGE   = createTextAttributesKey(\"FLEX_OP_RANGE\", DefaultLanguageHighlighterColors.KEYWORD);\n\n  public static final TextAttributesKey COMMENT    = createTextAttributesKey(\"FLEX_COMMENT\", DefaultLanguageHighlighterColors.LINE_COMMENT);\n  public static final TextAttributesKey OPTION     = createTextAttributesKey(\"FLEX_OPTION\", DefaultLanguageHighlighterColors.LABEL);\n  public static final TextAttributesKey RAW_CODE   = createTextAttributesKey(\"FLEX_RAW_CODE\", EditorColors.INJECTED_LANGUAGE_FRAGMENT);\n  public static final TextAttributesKey SECT_DIV   = createTextAttributesKey(\"FLEX_SECTION_DIV\", DefaultLanguageHighlighterColors.LABEL);\n\n  public static final TextAttributesKey STRING     = createTextAttributesKey(\"FLEX_STRING\", DefaultLanguageHighlighterColors.STRING);\n  public static final TextAttributesKey CHAR       = createTextAttributesKey(\"FLEX_CHAR\", DefaultLanguageHighlighterColors.STRING);\n  public static final TextAttributesKey CHAR_ESC   = createTextAttributesKey(\"FLEX_CHAR_ESC\", DefaultLanguageHighlighterColors.VALID_STRING_ESCAPE);\n  public static final TextAttributesKey NUMBER     = createTextAttributesKey(\"FLEX_NUMBER\", DefaultLanguageHighlighterColors.NUMBER);\n\n  public static final TextAttributesKey CLASS_STD  = createTextAttributesKey(\"FLEX_PREDEFINED_CLASS\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey DOT        = createTextAttributesKey(\"FLEX_DOT\", DefaultLanguageHighlighterColors.KEYWORD);\n  public static final TextAttributesKey EOF        = createTextAttributesKey(\"FLEX_SECTION_DIV\", DefaultLanguageHighlighterColors.LABEL);\n  public static final TextAttributesKey LOOKAHEAD  = createTextAttributesKey(\"FLEX_LOOKAHEAD\", DefaultLanguageHighlighterColors.OPERATION_SIGN);\n\n  public static final TextAttributesKey COMMA      = createTextAttributesKey(\"FLEX_COMMA\", DefaultLanguageHighlighterColors.COMMA);\n  public static final TextAttributesKey OP_EQUAL   = createTextAttributesKey(\"FLEX_OP_EQUAL\", DefaultLanguageHighlighterColors.OPERATION_SIGN);\n  public static final TextAttributesKey PARENS     = createTextAttributesKey(\"FLEX_PARENS\", DefaultLanguageHighlighterColors.PARENTHESES);\n  public static final TextAttributesKey BRACES     = createTextAttributesKey(\"FLEX_BRACES\", DefaultLanguageHighlighterColors.BRACES);\n  public static final TextAttributesKey BRACKETS   = createTextAttributesKey(\"FLEX_BRACKETS\", DefaultLanguageHighlighterColors.BRACKETS);\n  public static final TextAttributesKey ANGLES     = createTextAttributesKey(\"FLEX_ANGLES\", DefaultLanguageHighlighterColors.BRACKETS);\n\n\n  @Override\n  public @NotNull SyntaxHighlighter getSyntaxHighlighter(Project project, VirtualFile virtualFile) {\n    return new JFlexSyntaxHighlighter();\n  }\n\n  private static class JFlexSyntaxHighlighter extends SyntaxHighlighterBase {\n    @Override\n    public @NotNull Lexer getHighlightingLexer() {\n      return new JFlexLexer();\n    }\n\n    @Override\n    public @NotNull TextAttributesKey @NotNull [] getTokenHighlights(IElementType o) {\n      if (o == FLEX_LINE_COMMENT || o == FLEX_BLOCK_COMMENT) return pack(COMMENT);\n      if (o == FLEX_RAW) return pack(RAW_CODE);\n      if (o == FLEX_TWO_PERCS) return pack(SECT_DIV);\n      if (o == FLEX_STRING) return pack(STRING);\n      if (o == FLEX_CHAR) return pack(CHAR);\n      if (o == FLEX_CHAR_ESC) return pack(CHAR_ESC);\n      if (o == FLEX_NUMBER || o == FLEX_VERSION) return pack(NUMBER);\n      if (o == FLEX_CHAR_CLASS) return pack(CLASS_STD);\n      if (o == FLEX_EOF) return pack(EOF);\n      if (o == FLEX_FSLASH) return pack(LOOKAHEAD);\n      if (o == FLEX_COMMA) return pack(COMMA);\n      if (o == FLEX_DOT) return pack(DOT);\n      if (o == FLEX_EQ) return pack(OP_EQUAL);\n      if (o == FLEX_DASH) return pack(OP_RANGE);\n      if (o == FLEX_PAREN1 || o == FLEX_PAREN2) return pack(PARENS);\n      if (o == FLEX_BRACE1 || o == FLEX_BRACE2) return pack(BRACES);\n      if (o == FLEX_BRACK1 || o == FLEX_BRACK2) return pack(BRACKETS);\n      if (o == FLEX_ANGLE1 || o == FLEX_ANGLE2) return pack(ANGLES);\n      if (PATTERN_OPERATORS.contains(o)) return pack(PATTERN_OP);\n      if (CHAR_CLASS_OPERATORS.contains(o)) return pack(CLASS_OP);\n      if (o == FLEX_UNCLOSED || o == TokenType.BAD_CHARACTER) return pack(ILLEGAL);\n      if (o.toString().startsWith(\"%\")) return pack(OPTION);\n      return TextAttributesKey.EMPTY_ARRAY;\n    }\n  }\n}\n\n'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'\n:\n\npackage org.intellij.jflex.editor;\n\nimport com.intellij.openapi.editor.colors.TextAttributesKey;\nimport com.intellij.openapi.fileTypes.SyntaxHighlighter;\nimport com.intellij.openapi.options.colors.AttributesDescriptor;\nimport com.intellij.openapi.options.colors.ColorDescriptor;\nimport com.intellij.openapi.options.colors.ColorSettingsPage;\nimport com.intellij.util.containers.ContainerUtil;\nimport org.intellij.grammar.GrammarKitBundle;\nimport org.intellij.jflex.parser.JFlexFileType;\nimport org.jetbrains.annotations.NotNull;\n\nimport javax.swing.*;\nimport java.util.Arrays;\nimport java.util.Map;\n\nimport static org.intellij.jflex.editor.JFlexSyntaxHighlighterFactory.*;\n\n\nfinal class JFlexColorSettingsPage implements ColorSettingsPage {\n  private static final AttributesDescriptor[] ATTRS;\n\n  static {\n    ATTRS = new AttributesDescriptor[]{\n      new AttributesDescriptor(\"Illegal symbol\", ILLEGAL),\n\n      new AttributesDescriptor(\"Macro\", MACRO),\n      new AttributesDescriptor(\"State\", STATE),\n      new AttributesDescriptor(\"Character class\", CLASS),\n      new AttributesDescriptor(\"Pattern operator\", PATTERN_OP),\n      new AttributesDescriptor(\"Character class operator\", CLASS_OP),\n\n      new AttributesDescriptor(\"Comment\", COMMENT),\n      new AttributesDescriptor(\"Lexer option\", OPTION),\n      new AttributesDescriptor(\"Java code\", RAW_CODE),\n      new AttributesDescriptor(\"Section divider\", SECT_DIV),\n\n      new AttributesDescriptor(\"String\", STRING),\n      new AttributesDescriptor(\"Character\", CHAR),\n      new AttributesDescriptor(\"Character escape\", CHAR_ESC),\n      new AttributesDescriptor(\"Number\", NUMBER),\n\n      new AttributesDescriptor(\"Predefined character class\", CLASS_STD),\n      new AttributesDescriptor(\"EOF matcher\", EOF),\n      new AttributesDescriptor(\"Lookahead separator\", LOOKAHEAD),\n\n      new AttributesDescriptor(\"Comma\", COMMA),\n      new AttributesDescriptor(\"Dot\", DOT),\n      new AttributesDescriptor(\"Equal sign\", OP_EQUAL),\n      new AttributesDescriptor(\"Range operator\", OP_RANGE),\n      new AttributesDescriptor(\"Parentheses\", PARENS),\n      new AttributesDescriptor(\"Curly braces\", BRACES),\n      new AttributesDescriptor(\"Square brackets\", BRACKETS),\n      new AttributesDescriptor(\"Angle brackets\", ANGLES),\n    };\n  }\n\n  @Override\n  public @NotNull String getDisplayName() {\n    return GrammarKitBundle.message(\"language.name.jflex\");\n  }\n\n  @Override\n  public Icon getIcon() {\n    return JFlexFileType.INSTANCE.getIcon();\n  }\n\n  @Override\n  public AttributesDescriptor @NotNull [] getAttributeDescriptors() {\n    return ATTRS;\n  }\n\n  @Override\n  public ColorDescriptor @NotNull [] getColorDescriptors() {\n    return ColorDescriptor.EMPTY_ARRAY;\n  }\n\n  @Override\n  public @NotNull SyntaxHighlighter getHighlighter() {\n    return new JFlexSyntaxHighlighterFactory().getSyntaxHighlighter(null, null);\n  }\n\n  @Override\n  public @NotNull String getDemoText() {\n    return \"\"\"\n\n      package sample.lexer;\n\n      %%\n      %public\n      %class _MyLexer\n      %unicode\n      %{\n        private int parenCount;\n      %}\n\n\n      %state <s>BLOCK</s>, <s>QUALIFICATION</s>\n\n\n      <m>WHITESPACE</m>=<c>[ \\\\n\\\\r\\\\t]</c>\n      <m>ESCAPED_CHAR</m>=\\\\\\\\.\n      <m>STRING</m>=\\\\\"(<c>[^\\\\\"\\\\\\\\]</c>|\\\\\\\\.)*\\\\\"\n      <m>ID</m> = [a-z_&&[A-Z]]([:letter:]|[:digit:]|_)*\n      <m>BLOCK_COMMENT</m>=\"\n      <m>NUMBER</m>=<c>[+-]</c>[:digit:]+\n      <m>FLOAT</m>=<m>{NUMBER}</m>(\\\\.[:digit:]){1, 3}\n\n      %%\n      <<s>YYINITIAL</s>, <s>BLOCK</s>> {\n          <m>{WHITESPACE}</m>      { return WHITESPACE; }\n          <m>{STRING}</m>          { return STRING; }\n          \"(\"               { return PAREN1; }\n          \")\"               { return PAREN2; }\n          \".\" / !<<EOF>>    { yybegin(QUALIFICATION); return DOT; }\n          <c>[^]</c>               { return BAD_CHARACTER; }\n      }\n      \"\"\";\n  }\n\n  @Override\n  public Map<String, TextAttributesKey> getAdditionalHighlightingTagToDescriptorMap() {\n    return ContainerUtil.newHashMap(Arrays.asList(\"s\", \"m\", \"c\"), Arrays.asList(STATE, MACRO, CLASS));\n  }\n}",
        "gt": [
            "'Grammar-Kit/gen/org/intellij/jflex/psi/JFlexTypes.java'",
            "'Grammar-Kit/src/org/intellij/jflex/psi/JFlexTokenSets.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexSyntaxHighlighterFactory.java'",
            "'Grammar-Kit/src/org/intellij/jflex/editor/JFlexColorSettingsPage.java'"
        ]
    },
    {
        "files": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestAvroScan.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'"
        ],
        "content": "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.google.common.base.Objects;\nimport com.netflix.iceberg.avro.AvroSchemaUtil;\nimport com.netflix.iceberg.types.Types.IntegerType;\nimport com.netflix.iceberg.types.Types.LongType;\nimport com.netflix.iceberg.types.Types.StructType;\nimport org.apache.avro.generic.IndexedRecord;\nimport org.apache.avro.specific.SpecificData;\n\nimport java.util.Collection;\n\nimport static com.netflix.iceberg.types.Types.NestedField.required;\n\nclass ManifestEntry implements IndexedRecord, SpecificData.SchemaConstructable{\n  enum Status {\n    EXISTING(0),\n    ADDED(1),\n    DELETED(2);\n\n    public static Status[] values = new Status[3];\n    static {\n      for (Status status : Status.values()) {\n        values[status.id] = status;\n      }\n    }\n\n    private final int id;\n\n    Status(int id) {\n      this.id = id;\n    }\n\n    public int id() {\n      return id;\n    }\n\n    public static Status fromId(int id) {\n      return values[id];\n    }\n  }\n\n  private final org.apache.avro.Schema schema;\n  private Status status = Status.EXISTING;\n  private long snapshotId = 0L;\n  private DataFile file = null;\n\n  public ManifestEntry(org.apache.avro.Schema schema) {\n    this.schema = schema;\n  }\n\n  ManifestEntry(StructType partitionType) {\n    this.schema = AvroSchemaUtil.convert(getSchema(partitionType), \"manifest_entry\");\n  }\n\n  private ManifestEntry(ManifestEntry toCopy) {\n    this.schema = toCopy.schema;\n    this.status = toCopy.status;\n    this.snapshotId = toCopy.snapshotId;\n    this.file = toCopy.file().copy();\n  }\n\n  ManifestEntry wrapExisting(long snapshotId, DataFile file) {\n    this.status = Status.EXISTING;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapAppend(long snapshotId, DataFile file) {\n    this.status = Status.ADDED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n  ManifestEntry wrapDelete(long snapshotId, DataFile file) {\n    this.status = Status.DELETED;\n    this.snapshotId = snapshotId;\n    this.file = file;\n    return this;\n  }\n\n\n  public Status status() {\n    return status;\n  }\n\n\n  public long snapshotId() {\n    return snapshotId;\n  }\n\n\n  public DataFile file() {\n    return file;\n  }\n\n  public ManifestEntry copy() {\n    return new ManifestEntry(this);\n  }\n\n  @Override\n  public void put(int i, Object v) {\n    switch (i) {\n      case 0:\n        this.status = Status.fromId((Integer) v);\n        return;\n      case 1:\n        this.snapshotId = (Long) v;\n        return;\n      case 2:\n        this.file = (DataFile) v;\n        return;\n      default:\n\n    }\n  }\n\n  @Override\n  public Object get(int i) {\n    switch (i) {\n      case 0:\n        return status.id();\n      case 1:\n        return snapshotId;\n      case 2:\n        return file;\n      default:\n        throw new UnsupportedOperationException(\"Unknown field ordinal: \" + i);\n    }\n  }\n\n  @Override\n  public org.apache.avro.Schema getSchema() {\n    return schema;\n  }\n\n  static Schema projectSchema(StructType partitionType, Collection<String> columns) {\n    return wrapFileSchema(\n        new Schema(DataFile.getType(partitionType).fields()).select(columns).asStruct());\n  }\n\n  static Schema getSchema(StructType partitionType) {\n    return wrapFileSchema(DataFile.getType(partitionType));\n  }\n\n  private static Schema wrapFileSchema(StructType fileStruct) {\n\n    return new Schema(\n        required(0, \"status\", IntegerType.get()),\n        required(1, \"snapshot_id\", LongType.get()),\n        required(2, \"data_file\", fileStruct));\n  }\n\n  @Override\n  public String toString() {\n    return Objects.toStringHelper(this)\n        .add(\"status\", status)\n        .add(\"snapshot_id\", snapshotId)\n        .add(\"file\", file)\n        .toString();\n  }\n}\n\n'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestAvroScan.java'\n:\n\npackage com.netflix.iceberg.spark.source;\n\nimport com.netflix.iceberg.DataFile;\nimport com.netflix.iceberg.DataFiles;\nimport com.netflix.iceberg.FileFormat;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.Table;\nimport com.netflix.iceberg.avro.Avro;\nimport com.netflix.iceberg.hadoop.HadoopTables;\nimport com.netflix.iceberg.io.FileAppender;\nimport com.netflix.iceberg.spark.data.AvroDataTest;\nimport com.netflix.iceberg.spark.data.RandomData;\nimport com.netflix.iceberg.spark.data.TestHelpers;\nimport org.apache.avro.generic.GenericData.Record;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.spark.sql.Dataset;\nimport org.apache.spark.sql.Row;\nimport org.apache.spark.sql.SparkSession;\nimport org.junit.AfterClass;\nimport org.junit.Assert;\nimport org.junit.BeforeClass;\nimport org.junit.Rule;\nimport org.junit.rules.TemporaryFolder;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.UUID;\n\nimport static com.netflix.iceberg.Files.localOutput;\n\npublic class TestAvroScan extends AvroDataTest {\n  private static final Configuration CONF = new Configuration();\n\n  @Rule\n  public TemporaryFolder temp = new TemporaryFolder();\n\n  private static SparkSession spark = null;\n\n  @BeforeClass\n  public static void startSpark() {\n    TestAvroScan.spark = SparkSession.builder().master(\"local[2]\").getOrCreate();\n  }\n\n  @AfterClass\n  public static void stopSpark() {\n    SparkSession spark = TestAvroScan.spark;\n    TestAvroScan.spark = null;\n    spark.stop();\n  }\n\n  protected void writeAndValidate(Schema schema) throws IOException {\n    File parent = temp.newFolder(\"avro\");\n    File location = new File(parent, \"test\");\n    File dataFolder = new File(location, \"data\");\n    dataFolder.mkdirs();\n\n    File avroFile = new File(dataFolder,\n        FileFormat.AVRO.addExtension(UUID.randomUUID().toString()));\n\n    HadoopTables tables = new HadoopTables(CONF);\n    Table table = tables.create(schema, PartitionSpec.unpartitioned(), location.toString());\n\n\n\n    Schema tableSchema = table.schema();\n\n    List<Record> expected = RandomData.generateList(tableSchema, 100, 1L);\n\n    try (FileAppender<Record> writer = Avro.write(localOutput(avroFile))\n        .schema(tableSchema)\n        .build()) {\n      writer.addAll(expected);\n    }\n\n    DataFile file = DataFiles.builder(PartitionSpec.unpartitioned())\n        .withRecordCount(100)\n        .withFileSizeInBytes(avroFile.length())\n        .withPath(avroFile.toString())\n        .build();\n\n    table.newAppend().appendFile(file).commit();\n\n    Dataset<Row> df = spark.read()\n        .format(\"iceberg\")\n        .load(location.toString());\n\n    List<Row> rows = df.collectAsList();\n    Assert.assertEquals(\"Should contain 100 rows\", 100, rows.size());\n\n    for (int i = 0; i < expected.size(); i += 1) {\n      TestHelpers.assertEqualsSafe(tableSchema.asStruct(), expected.get(i), rows.get(i));\n    }\n  }\n}\n\n'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'\n:\n\npackage com.netflix.iceberg;\n\nimport com.netflix.iceberg.exceptions.CommitFailedException;\nimport com.netflix.iceberg.exceptions.ValidationException;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.mockito.internal.util.collections.Sets;\n\nimport java.io.File;\nimport java.util.Collections;\n\nimport static com.netflix.iceberg.ManifestEntry.Status.ADDED;\nimport static com.netflix.iceberg.ManifestEntry.Status.DELETED;\nimport static com.netflix.iceberg.ManifestEntry.Status.EXISTING;\n\npublic class TestReplaceFiles extends TableTestBase {\n\n  @Test\n  public void testEmptyTable() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    TableMetadata base = readMetadata();\n    Assert.assertNull(\"Should not have a current snapshot\", base.currentSnapshot());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-a.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B))\n            .commit());\n  }\n\n  @Test\n  public void testAddOnly() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        IllegalArgumentException.class,\n        \"Files to add can not be null or empty\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Collections.emptySet())\n            .apply());\n  }\n\n  @Test\n  public void testDeleteOnly() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        IllegalArgumentException.class,\n        \"Files to delete cannot be null or empty\",\n        () -> table.newRewrite()\n            .rewriteFiles(Collections.emptySet(), Sets.newSet(FILE_A))\n            .apply());\n  }\n\n  @Test\n  public void testDeleteWithDuplicateEntriesInManifest() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    long baseSnapshotId = base.currentSnapshot().snapshotId();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    Snapshot pending = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_C))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n    Assert.assertFalse(\"Should not contain manifest from initial write\",\n        pending.manifests().contains(initialManifest));\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_C),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId,pendingId, baseSnapshotId),\n        files(FILE_A, FILE_A, FILE_B),\n        statuses(DELETED, DELETED, EXISTING));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testAddAndDelete() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    long baseSnapshotId = base.currentSnapshot().snapshotId();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n    ManifestFile initialManifest = base.currentSnapshot().manifests().get(0);\n\n    Snapshot pending = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_C))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n    Assert.assertFalse(\"Should not contain manifest from initial write\",\n        pending.manifests().contains(initialManifest));\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_C),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId, baseSnapshotId),\n        files(FILE_A, FILE_B),\n        statuses(DELETED, EXISTING));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testFailure() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.ops().failCommits(5);\n\n    RewriteFiles rewrite = table.newRewrite()\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B));\n    Snapshot pending = rewrite.apply();\n\n    Assert.assertEquals(\"Should produce 2 manifests\", 2, pending.manifests().size());\n    ManifestFile manifest1 = pending.manifests().get(0);\n    ManifestFile manifest2 = pending.manifests().get(1);\n\n    validateManifestEntries(manifest1,\n        ids(pending.snapshotId()), files(FILE_B), statuses(ADDED));\n    validateManifestEntries(manifest2,\n        ids(pending.snapshotId()), files(FILE_A), statuses(DELETED));\n\n    AssertHelpers.assertThrows(\"Should retry 4 times and throw last failure\",\n        CommitFailedException.class, \"Injected failure\", rewrite::commit);\n\n    Assert.assertFalse(\"Should clean up new manifest\", new File(manifest1.path()).exists());\n    Assert.assertFalse(\"Should clean up new manifest\", new File(manifest2.path()).exists());\n\n\n    Assert.assertEquals(\"Only 1 manifest should exist\", 1, listManifestFiles().size());\n  }\n\n  @Test\n  public void testRecovery() {\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    table.ops().failCommits(3);\n\n    RewriteFiles rewrite = table.newRewrite().rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B));\n    Snapshot pending = rewrite.apply();\n\n    Assert.assertEquals(\"Should produce 2 manifests\", 2, pending.manifests().size());\n    ManifestFile manifest1 = pending.manifests().get(0);\n    ManifestFile manifest2 = pending.manifests().get(1);\n\n    validateManifestEntries(manifest1,\n        ids(pending.snapshotId()), files(FILE_B), statuses(ADDED));\n    validateManifestEntries(manifest2,\n        ids(pending.snapshotId()), files(FILE_A), statuses(DELETED));\n\n    rewrite.commit();\n\n    Assert.assertTrue(\"Should reuse the manifest for appends\", new File(manifest1.path()).exists());\n    Assert.assertTrue(\"Should reuse the manifest with deletes\", new File(manifest2.path()).exists());\n\n    TableMetadata metadata = readMetadata();\n    Assert.assertTrue(\"Should commit the manifest for append\",\n        metadata.currentSnapshot().manifests().contains(manifest2));\n\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n\n  @Test\n  public void testDeleteNonExistentFile() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .appendFile(FILE_B)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-c.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_C), Sets.newSet(FILE_D))\n            .commit());\n\n    Assert.assertEquals(\"Only 1 manifests should exist\", 1, listManifestFiles().size());\n  }\n\n  @Test\n  public void testAlreadyDeletedFile() {\n    Assert.assertEquals(\"Table should start empty\", 0, listManifestFiles().size());\n\n    table.newAppend()\n        .appendFile(FILE_A)\n        .commit();\n\n    TableMetadata base = readMetadata();\n    Assert.assertEquals(\"Should create 1 manifest for initial write\",\n        1, base.currentSnapshot().manifests().size());\n\n    RewriteFiles rewrite = table.newRewrite();\n    Snapshot pending = rewrite\n        .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_B))\n        .apply();\n\n    Assert.assertEquals(\"Should contain 2 manifest\",\n        2, pending.manifests().size());\n\n    long pendingId = pending.snapshotId();\n\n    validateManifestEntries(pending.manifests().get(0),\n        ids(pendingId),\n        files(FILE_B),\n        statuses(ADDED));\n\n    validateManifestEntries(pending.manifests().get(1),\n        ids(pendingId, base.currentSnapshot().snapshotId()),\n        files(FILE_A),\n        statuses(DELETED));\n\n    rewrite.commit();\n\n    AssertHelpers.assertThrows(\"Expected an exception\",\n        ValidationException.class,\n        \"Missing required files to delete: /path/to/data-a.parquet\",\n        () -> table.newRewrite()\n            .rewriteFiles(Sets.newSet(FILE_A), Sets.newSet(FILE_D))\n            .commit());\n\n    Assert.assertEquals(\"Only 3 manifests should exist\", 3, listManifestFiles().size());\n  }\n}\n",
        "gt": [
            "'iceberg/core/src/main/java/com/netflix/iceberg/ManifestEntry.java'",
            "'iceberg/core/src/test/java/com/netflix/iceberg/TestReplaceFiles.java'",
            "'iceberg/spark/src/test/java/com/netflix/iceberg/spark/source/TestAvroScan.java'"
        ]
    },
    {
        "files": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkExpressions.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/expressions/InclusiveMetricsEvaluator.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/expressions/ExpressionVisitors.java'"
        ],
        "content": "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkExpressions.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.BoundReference;\nimport com.netflix.iceberg.expressions.Expression.Operation;\nimport com.netflix.iceberg.expressions.ExpressionVisitors;\nimport com.netflix.iceberg.types.Types.TimestampType;\nimport com.netflix.iceberg.util.Pair;\nimport org.apache.spark.sql.Column;\nimport org.apache.spark.sql.catalyst.analysis.UnresolvedAttribute;\nimport org.apache.spark.sql.catalyst.expressions.And;\nimport org.apache.spark.sql.catalyst.expressions.And$;\nimport org.apache.spark.sql.catalyst.expressions.Attribute;\nimport org.apache.spark.sql.catalyst.expressions.AttributeReference;\nimport org.apache.spark.sql.catalyst.expressions.BinaryExpression;\nimport org.apache.spark.sql.catalyst.expressions.Cast;\nimport org.apache.spark.sql.catalyst.expressions.EqualNullSafe;\nimport org.apache.spark.sql.catalyst.expressions.EqualTo;\nimport org.apache.spark.sql.catalyst.expressions.Expression;\nimport org.apache.spark.sql.catalyst.expressions.GreaterThan;\nimport org.apache.spark.sql.catalyst.expressions.GreaterThanOrEqual;\nimport org.apache.spark.sql.catalyst.expressions.In;\nimport org.apache.spark.sql.catalyst.expressions.InSet;\nimport org.apache.spark.sql.catalyst.expressions.IsNotNull;\nimport org.apache.spark.sql.catalyst.expressions.IsNull;\nimport org.apache.spark.sql.catalyst.expressions.LessThan;\nimport org.apache.spark.sql.catalyst.expressions.LessThanOrEqual;\nimport org.apache.spark.sql.catalyst.expressions.Literal;\nimport org.apache.spark.sql.catalyst.expressions.Not;\nimport org.apache.spark.sql.catalyst.expressions.Not$;\nimport org.apache.spark.sql.catalyst.expressions.Or;\nimport org.apache.spark.sql.catalyst.expressions.Or$;\nimport org.apache.spark.sql.catalyst.expressions.ParseToDate;\nimport org.apache.spark.sql.catalyst.expressions.UnaryExpression;\nimport org.apache.spark.sql.catalyst.expressions.Year;\nimport org.apache.spark.sql.functions$;\nimport org.apache.spark.sql.types.DateType$;\nimport org.apache.spark.sql.types.Decimal;\nimport org.apache.spark.unsafe.types.UTF8String;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Function;\n\nimport static com.netflix.iceberg.expressions.ExpressionVisitors.visit;\nimport static com.netflix.iceberg.expressions.Expressions.alwaysFalse;\nimport static com.netflix.iceberg.expressions.Expressions.and;\nimport static com.netflix.iceberg.expressions.Expressions.equal;\nimport static com.netflix.iceberg.expressions.Expressions.not;\nimport static com.netflix.iceberg.expressions.Expressions.or;\nimport static com.netflix.iceberg.expressions.Expressions.predicate;\nimport static scala.collection.JavaConverters.seqAsJavaListConverter;\nimport static scala.collection.JavaConverters.setAsJavaSetConverter;\n\n\npublic class SparkExpressions {\n  private SparkExpressions() {\n  }\n\n  private static final Map<Class<? extends Expression>, Operation> FILTERS = ImmutableMap\n      .<Class<? extends Expression>, Operation>builder()\n      .put(EqualTo.class, Operation.EQ)\n      .put(EqualNullSafe.class, Operation.EQ)\n      .put(GreaterThan.class, Operation.GT)\n      .put(GreaterThanOrEqual.class, Operation.GT_EQ)\n      .put(LessThan.class, Operation.LT)\n      .put(LessThanOrEqual.class, Operation.LT_EQ)\n      .put(In.class, Operation.IN)\n      .put(InSet.class, Operation.IN)\n      .put(IsNull.class, Operation.IS_NULL)\n      .put(IsNotNull.class, Operation.NOT_NULL)\n      .put(And.class, Operation.AND)\n      .put(Or.class, Operation.OR)\n      .put(Not.class, Operation.NOT)\n      .build();\n\n  public static com.netflix.iceberg.expressions.Expression convert(Expression expr) {\n    Class<? extends Expression> exprClass = expr.getClass();\n    Operation op = FILTERS.get(exprClass);\n    if (op != null) {\n      switch (op) {\n        case IS_NULL:\n        case NOT_NULL:\n          UnaryExpression unary = (UnaryExpression) expr;\n          if (unary.child() instanceof Attribute) {\n            Attribute attr = (Attribute) unary.child();\n            return predicate(op, attr.name());\n          }\n          return null;\n        case LT:\n        case LT_EQ:\n        case GT:\n        case GT_EQ:\n        case EQ:\n        case NOT_EQ:\n          BinaryExpression binary = (BinaryExpression) expr;\n          return convert(op, binary.left(), binary.right());\n        case NOT:\n          com.netflix.iceberg.expressions.Expression child = convert(((Not) expr).child());\n          if (child != null) {\n            return not(child);\n          }\n          return null;\n        case AND:\n          And andExpr = (And) expr;\n          com.netflix.iceberg.expressions.Expression andLeft = convert(andExpr.left());\n          com.netflix.iceberg.expressions.Expression andRight = convert(andExpr.right());\n          if (andLeft != null && andRight != null) {\n            return and(convert(andExpr.left()), convert(andExpr.right()));\n          }\n          return null;\n        case OR:\n          Or orExpr = (Or) expr;\n          com.netflix.iceberg.expressions.Expression orLeft = convert(orExpr.left());\n          com.netflix.iceberg.expressions.Expression orRight = convert(orExpr.right());\n          if (orLeft != null && orRight != null) {\n            return or(orLeft, orRight);\n          }\n          return null;\n        case IN:\n          if (expr instanceof In) {\n            In inExpr = (In) expr;\n            List<Object> literals = convertLiterals(seqAsJavaListConverter(inExpr.list()).asJava());\n            if (literals != null) {\n              return convertIn(inExpr.value(), literals);\n            } else {\n\n              return null;\n            }\n          } else if (expr instanceof InSet) {\n            InSet inExpr = (InSet) expr;\n\n            Set<Object> literals = setAsJavaSetConverter(inExpr.hset()).asJava();\n            return convertIn(inExpr.child(), literals);\n          }\n        default:\n      }\n    }\n\n    return null;\n  }\n\n  private enum Transform {\n    IDENTITY,\n    YEAR,\n    DAY,\n  }\n\n  private static final Map<Class<? extends Expression>, Transform> TRANSFORMS = ImmutableMap\n      .<Class<? extends Expression>, Transform>builder()\n      .put(UnresolvedAttribute.class, Transform.IDENTITY)\n      .put(AttributeReference.class, Transform.IDENTITY)\n      .put(Year.class, Transform.YEAR)\n      .put(ParseToDate.class, Transform.DAY)\n      .put(Cast.class, Transform.DAY)\n      .build();\n\n  private static com.netflix.iceberg.expressions.Expression convertIn(Expression expr,\n                                                                      Collection<Object> values) {\n    if (expr instanceof Attribute) {\n      Attribute attr = (Attribute) expr;\n      com.netflix.iceberg.expressions.Expression converted = alwaysFalse();\n      for (Object item : values) {\n        converted = or(converted, equal(attr.name(), item));\n      }\n      return converted;\n    }\n\n    return null;\n  }\n\n  private static List<Object> convertLiterals(List<Expression> values) {\n    List<Object> converted = Lists.newArrayListWithExpectedSize(values.size());\n\n    for (Expression value : values) {\n      if (value instanceof Literal) {\n        Literal lit = (Literal) value;\n        converted.add(valueFromSpark(lit));\n      } else {\n        return null;\n      }\n    }\n\n    return converted;\n  }\n\n  private static com.netflix.iceberg.expressions.Expression convert(Operation op,\n                                                                    Expression left,\n                                                                    Expression right) {\n    Pair<Transform, String> attrPair = null;\n    Operation leftOperation = null;\n    Literal lit = null;\n\n    if (right instanceof Literal) {\n      lit = (Literal) right;\n      attrPair = convertAttr(left);\n      leftOperation = op;\n    } else if (left instanceof Literal) {\n      lit = (Literal) left;\n      attrPair = convertAttr(right);\n      leftOperation = op.flipLR();\n    }\n\n    if (attrPair != null) {\n      switch (attrPair.first()) {\n        case IDENTITY:\n          return predicate(leftOperation, attrPair.second(), valueFromSpark(lit));\n        case YEAR:\n          return filter(leftOperation, attrPair.second(), (int) lit.value(),\n              SparkExpressions::yearToTimestampMicros);\n        case DAY:\n          return filter(leftOperation, attrPair.second(), (int) lit.value(),\n              SparkExpressions::dayToTimestampMicros);\n        default:\n      }\n    }\n\n    return null;\n  }\n\n  private static Object valueFromSpark(Literal lit) {\n    if (lit.value() instanceof UTF8String) {\n      return lit.value().toString();\n    } else if (lit.value() instanceof Decimal) {\n      return ((Decimal) lit.value()).toJavaBigDecimal();\n    }\n    return lit.value();\n  }\n\n  private static Pair<Transform, String> convertAttr(Expression expr) {\n    Transform type = TRANSFORMS.get(expr.getClass());\n    if (type == Transform.IDENTITY) {\n      Attribute attr = (Attribute) expr;\n      return Pair.of(type, attr.name());\n\n    } else if (expr instanceof Cast) {\n      Cast cast = (Cast) expr;\n      if (DateType$.MODULE$.sameType(cast.dataType()) && cast.child() instanceof Attribute) {\n        Attribute attr = (Attribute) cast.child();\n        return Pair.of(Transform.DAY, attr.name());\n      }\n\n    } else if (expr instanceof ParseToDate) {\n      ParseToDate toDate = (ParseToDate) expr;\n      if (toDate.left() instanceof Attribute) {\n        Attribute attr = (Attribute) toDate.left();\n        return Pair.of(Transform.DAY, attr.name());\n      }\n\n    } else if (expr instanceof UnaryExpression) {\n      UnaryExpression func = (UnaryExpression) expr;\n      if (func.child() instanceof Attribute) {\n        Attribute attr = (Attribute) func.child();\n        return Pair.of(type, attr.name());\n      }\n    }\n\n    return null;\n  }\n\n  private static final OffsetDateTime EPOCH = Instant.ofEpochSecond(0).atOffset(ZoneOffset.UTC);\n  private static final LocalDate EPOCH_DAY = EPOCH.toLocalDate();\n\n  private static long yearToTimestampMicros(int year) {\n    return ChronoUnit.MICROS.between(EPOCH,\n        LocalDateTime.of(year, 1, 1, 0, 0).atOffset(ZoneOffset.UTC));\n  }\n\n  private static long dayToTimestampMicros(int daysFromEpoch) {\n    return ChronoUnit.MICROS.between(EPOCH,\n        EPOCH_DAY.plusDays(daysFromEpoch).atStartOfDay().atOffset(ZoneOffset.UTC));\n  }\n\n  private static com.netflix.iceberg.expressions.Literal<Long> tsLiteral(long timestampMicros) {\n    return com.netflix.iceberg.expressions.Literal\n        .of(timestampMicros)\n        .to(TimestampType.withoutZone());\n  }\n\n  private static com.netflix.iceberg.expressions.Expression filter(\n      Operation op, String name, int value, Function<Integer, Long> startTsMicros) {\n    switch (op) {\n      case LT:\n        return predicate(Operation.LT, name, tsLiteral(startTsMicros.apply(value)));\n      case LT_EQ:\n        return predicate(Operation.LT, name, tsLiteral(startTsMicros.apply(value + 1)));\n      case GT:\n        return predicate(Operation.GT_EQ, name, tsLiteral(startTsMicros.apply(value + 1)));\n      case GT_EQ:\n        return predicate(Operation.GT_EQ, name, tsLiteral(startTsMicros.apply(value)));\n      case EQ:\n        return and(\n            predicate(Operation.GT_EQ, name, tsLiteral(startTsMicros.apply(value))),\n            predicate(Operation.LT, name, tsLiteral(startTsMicros.apply(value + 1)))\n        );\n      case NOT_EQ:\n        return or(\n            predicate(Operation.GT_EQ, name, tsLiteral(startTsMicros.apply(value + 1))),\n            predicate(Operation.LT, name, tsLiteral(startTsMicros.apply(value)))\n        );\n      case IN:\n      case NOT_IN:\n      default:\n        throw new IllegalArgumentException(\"Cannot convert operation to year filter: \" + op);\n    }\n  }\n\n  public static Expression convert(com.netflix.iceberg.expressions.Expression filter,\n                                   Schema schema) {\n    return visit(Binder.bind(schema.asStruct(), filter), new ExpressionToSpark(schema));\n  }\n\n  private static class ExpressionToSpark extends ExpressionVisitors.\n      BoundExpressionVisitor<Expression> {\n    private final Schema schema;\n\n    public ExpressionToSpark(Schema schema) {\n      this.schema = schema;\n    }\n\n    @Override\n    public Expression alwaysTrue() {\n      return functions$.MODULE$.lit(true).expr();\n    }\n\n    @Override\n    public Expression alwaysFalse() {\n      return functions$.MODULE$.lit(false).expr();\n    }\n\n    @Override\n    public Expression not(Expression child) {\n      return Not$.MODULE$.apply(child);\n    }\n\n    @Override\n    public Expression and(Expression left, Expression right) {\n      return And$.MODULE$.apply(left, right);\n    }\n\n    @Override\n    public Expression or(Expression left, Expression right) {\n      return Or$.MODULE$.apply(left, right);\n    }\n\n    @Override\n    public <T> Expression isNull(BoundReference<T> ref) {\n      return column(ref).isNull().expr();\n    }\n\n    @Override\n    public <T> Expression notNull(BoundReference<T> ref) {\n      return column(ref).isNotNull().expr();\n    }\n\n    @Override\n    public <T> Expression lt(BoundReference<T> ref,\n                             com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).lt(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression ltEq(BoundReference<T> ref,\n                               com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).leq(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression gt(BoundReference<T> ref,\n                             com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).gt(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression gtEq(BoundReference<T> ref,\n                               com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).geq(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression eq(BoundReference<T> ref,\n                             com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).equalTo(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression notEq(BoundReference<T> ref,\n                                com.netflix.iceberg.expressions.Literal<T> lit) {\n      return column(ref).notEqual(lit.value()).expr();\n    }\n\n    @Override\n    public <T> Expression in(BoundReference<T> ref,\n                             com.netflix.iceberg.expressions.Literal<T> lit) {\n      throw new UnsupportedOperationException(\"Not implemented: in\");\n    }\n\n    @Override\n    public <T> Expression notIn(BoundReference<T> ref,\n                                com.netflix.iceberg.expressions.Literal<T> lit) {\n      throw new UnsupportedOperationException(\"Not implemented: notIn\");\n    }\n\n    private Column column(BoundReference ref) {\n      return functions$.MODULE$.column(schema.findColumnName(ref.fieldId()));\n    }\n  }\n}\n\n'iceberg/api/src/main/java/com/netflix/iceberg/expressions/InclusiveMetricsEvaluator.java'\n:\n\npackage com.netflix.iceberg.expressions;\n\nimport com.google.common.base.Preconditions;\nimport com.netflix.iceberg.DataFile;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.ExpressionVisitors.BoundExpressionVisitor;\nimport com.netflix.iceberg.types.Conversions;\nimport com.netflix.iceberg.types.Types;\nimport com.netflix.iceberg.types.Types.StructType;\nimport java.nio.ByteBuffer;\nimport java.util.Map;\n\nimport static com.netflix.iceberg.expressions.Expressions.rewriteNot;\n\n\npublic class InclusiveMetricsEvaluator {\n  private final Schema schema;\n  private final StructType struct;\n  private final Expression expr;\n  private transient ThreadLocal<MetricsEvalVisitor> visitors = null;\n\n  private MetricsEvalVisitor visitor() {\n    if (visitors == null) {\n      this.visitors = ThreadLocal.withInitial(MetricsEvalVisitor::new);\n    }\n    return visitors.get();\n  }\n\n  public InclusiveMetricsEvaluator(Schema schema, Expression unbound) {\n    this.schema = schema;\n    this.struct = schema.asStruct();\n    this.expr = Binder.bind(struct, rewriteNot(unbound));\n  }\n\n\n  public boolean eval(DataFile file) {\n\n    return visitor().eval(file);\n  }\n\n  private static final boolean ROWS_MIGHT_MATCH = true;\n  private static final boolean ROWS_CANNOT_MATCH = false;\n\n  private class MetricsEvalVisitor extends BoundExpressionVisitor<Boolean> {\n    private Map<Integer, Long> valueCounts = null;\n    private Map<Integer, Long> nullCounts = null;\n    private Map<Integer, ByteBuffer> lowerBounds = null;\n    private Map<Integer, ByteBuffer> upperBounds = null;\n\n    private boolean eval(DataFile file) {\n      if (file.recordCount() <= 0) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      this.valueCounts = file.valueCounts();\n      this.nullCounts = file.nullValueCounts();\n      this.lowerBounds = file.lowerBounds();\n      this.upperBounds = file.upperBounds();\n\n      return ExpressionVisitors.visit(expr, this);\n    }\n\n    @Override\n    public Boolean alwaysTrue() {\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public Boolean alwaysFalse() {\n      return ROWS_CANNOT_MATCH;\n    }\n\n    @Override\n    public Boolean not(Boolean result) {\n      return !result;\n    }\n\n    @Override\n    public Boolean and(Boolean leftResult, Boolean rightResult) {\n      return leftResult && rightResult;\n    }\n\n    @Override\n    public Boolean or(Boolean leftResult, Boolean rightResult) {\n      return leftResult || rightResult;\n    }\n\n    @Override\n    public <T> Boolean isNull(BoundReference<T> ref) {\n\n\n      Integer id = ref.fieldId();\n      Preconditions.checkNotNull(struct.field(id),\n          \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (nullCounts != null && nullCounts.containsKey(id) && nullCounts.get(id) == 0) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean notNull(BoundReference<T> ref) {\n\n\n      Integer id = ref.fieldId();\n      Preconditions.checkNotNull(struct.field(id),\n          \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (valueCounts != null && valueCounts.containsKey(id) &&\n          nullCounts != null && nullCounts.containsKey(id) &&\n          valueCounts.get(id) - nullCounts.get(id) == 0) {\n        return ROWS_CANNOT_MATCH;\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean lt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp >= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean ltEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(field.type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean gt(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp <= 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean gtEq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean eq(BoundReference<T> ref, Literal<T> lit) {\n      Integer id = ref.fieldId();\n      Types.NestedField field = struct.field(id);\n      Preconditions.checkNotNull(field, \"Cannot filter by nested column: %s\", schema.findField(id));\n\n      if (lowerBounds != null && lowerBounds.containsKey(id)) {\n        T lower = Conversions.fromByteBuffer(struct.field(id).type(), lowerBounds.get(id));\n\n        int cmp = lit.comparator().compare(lower, lit.value());\n        if (cmp > 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      if (upperBounds != null && upperBounds.containsKey(id)) {\n        T upper = Conversions.fromByteBuffer(field.type(), upperBounds.get(id));\n\n        int cmp = lit.comparator().compare(upper, lit.value());\n        if (cmp < 0) {\n          return ROWS_CANNOT_MATCH;\n        }\n      }\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean notEq(BoundReference<T> ref, Literal<T> lit) {\n\n\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean in(BoundReference<T> ref, Literal<T> lit) {\n      return ROWS_MIGHT_MATCH;\n    }\n\n    @Override\n    public <T> Boolean notIn(BoundReference<T> ref, Literal<T> lit) {\n      return ROWS_MIGHT_MATCH;\n    }\n  }\n}\n",
        "gt": [
            "'iceberg/api/src/main/java/com/netflix/iceberg/expressions/ExpressionVisitors.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkExpressions.java'",
            "'iceberg/api/src/main/java/com/netflix/iceberg/expressions/InclusiveMetricsEvaluator.java'"
        ]
    },
    {
        "files": [
            "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergStorage.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergPigInputFormat.java'"
        ],
        "content": "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergStorage.java'\n:\n\npackage com.netflix.iceberg.pig;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.Table;\nimport com.netflix.iceberg.expressions.Expressions;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.pig.impl.util.ObjectSerializer;\nimport org.apache.pig.impl.util.UDFContext;\nimport org.mortbay.log.Log;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.netflix.iceberg.Tables;\nimport com.netflix.iceberg.hadoop.HadoopTables;\nimport com.netflix.iceberg.pig.IcebergPigInputFormat.IcebergRecordReader;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.mapreduce.InputFormat;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.RecordReader;\n\nimport org.apache.hadoop.util.ReflectionUtils;\nimport org.apache.pig.Expression;\nimport org.apache.pig.Expression.*;\nimport org.apache.pig.LoadFunc;\nimport org.apache.pig.LoadMetadata;\nimport org.apache.pig.LoadPredicatePushdown;\nimport org.apache.pig.LoadPushDown;\nimport org.apache.pig.ResourceSchema;\nimport org.apache.pig.ResourceStatistics;\nimport org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigSplit;\nimport org.apache.pig.data.Tuple;\nimport org.apache.pig.impl.logicalLayer.FrontendException;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.stream.Collectors;\n\nimport static java.lang.String.format;\nimport static java.util.Arrays.asList;\nimport static com.netflix.iceberg.expressions.Expressions.and;\nimport static com.netflix.iceberg.expressions.Expressions.equal;\nimport static com.netflix.iceberg.expressions.Expressions.greaterThan;\nimport static com.netflix.iceberg.expressions.Expressions.greaterThanOrEqual;\nimport static com.netflix.iceberg.expressions.Expressions.isNull;\nimport static com.netflix.iceberg.expressions.Expressions.lessThan;\nimport static com.netflix.iceberg.expressions.Expressions.lessThanOrEqual;\nimport static com.netflix.iceberg.expressions.Expressions.not;\nimport static com.netflix.iceberg.expressions.Expressions.notEqual;\nimport static com.netflix.iceberg.expressions.Expressions.or;\nimport static com.netflix.iceberg.pig.IcebergPigInputFormat.ICEBERG_FILTER_EXPRESSION;\nimport static com.netflix.iceberg.pig.IcebergPigInputFormat.ICEBERG_PROJECTED_FIELDS;\nimport static com.netflix.iceberg.pig.IcebergPigInputFormat.ICEBERG_SCHEMA;\nimport static org.apache.pig.Expression.OpType.OP_AND;\nimport static org.apache.pig.Expression.OpType.OP_BETWEEN;\nimport static org.apache.pig.Expression.OpType.OP_EQ;\nimport static org.apache.pig.Expression.OpType.OP_GE;\nimport static org.apache.pig.Expression.OpType.OP_GT;\nimport static org.apache.pig.Expression.OpType.OP_IN;\nimport static org.apache.pig.Expression.OpType.OP_LE;\nimport static org.apache.pig.Expression.OpType.OP_LT;\nimport static org.apache.pig.Expression.OpType.OP_NE;\nimport static org.apache.pig.Expression.OpType.OP_NOT;\nimport static org.apache.pig.Expression.OpType.OP_NULL;\nimport static org.apache.pig.Expression.OpType.OP_OR;\n\npublic class IcebergStorage extends LoadFunc implements LoadMetadata, LoadPredicatePushdown, LoadPushDown {\n  private static final Logger LOG = LoggerFactory.getLogger(IcebergStorage.class);\n\n  public static final String PIG_ICEBERG_TABLES_IMPL = \"pig.iceberg.tables.impl\";\n  private static Tables iceberg;\n  private static Map<String, Table> tables = Maps.newConcurrentMap();\n  private static Map<String, String> locations = Maps.newConcurrentMap();\n\n  private String signature;\n\n  private IcebergRecordReader reader;\n\n  @Override\n  public void setLocation(String location, Job job) {\n    LOG.info(format(\"[%s]: setLocation() -> %s \", signature, location));\n\n    locations.put(signature, location);\n\n    Configuration conf = job.getConfiguration();\n\n    copyUDFContextToConfiguration(conf, ICEBERG_SCHEMA);\n    copyUDFContextToConfiguration(conf, ICEBERG_PROJECTED_FIELDS);\n    copyUDFContextToConfiguration(conf, ICEBERG_FILTER_EXPRESSION);\n  }\n\n  @Override\n  public InputFormat getInputFormat() {\n    LOG.info(format(\"[%s]: getInputFormat()\", signature));\n    String location = locations.get(signature);\n\n    return new IcebergPigInputFormat(tables.get(location));\n  }\n\n  @Override\n  public Tuple getNext() throws IOException {\n    if (!reader.nextKeyValue()) {\n      return null;\n    }\n\n    return (Tuple) reader.getCurrentValue();\n  }\n\n  @Override\n  public void prepareToRead(RecordReader reader, PigSplit split) {\n    LOG.info(format(\"[%s]: prepareToRead() -> %s\", signature, split));\n\n    this.reader = (IcebergRecordReader) reader;\n  }\n\n  @Override\n  public ResourceSchema getSchema(String location, Job job) throws IOException {\n    LOG.info(format(\"[%s]: getSchema() -> %s\", signature, location));\n\n    Schema schema = load(location, job).schema();\n    storeInUDFContext(ICEBERG_SCHEMA, schema);\n\n    return SchemaUtil.convert(schema);\n  }\n\n\n  @Override\n  public ResourceStatistics getStatistics(String location, Job job) {\n    LOG.info(format(\"[%s]: getStatistics() -> : %s\", signature, location));\n\n    return null;\n  }\n\n  @Override\n  public String[] getPartitionKeys(String location, Job job) {\n    LOG.info(format(\"[%s]: getPartitionKeys()\", signature));\n    return new String[0];\n  }\n\n  @Override\n  public void setPartitionFilter(Expression partitionFilter) {\n    LOG.info(format(\"[%s]: setPartitionFilter() ->  %s\", signature, partitionFilter));\n  }\n\n  @Override\n  public List<String> getPredicateFields(String location, Job job) throws IOException {\n    LOG.info(format(\"[%s]: getPredicateFields() -> %s\", signature, location));\n    Schema schema = load(location, job).schema();\n\n    List<String> result = Lists.newArrayList();\n\n    for (Types.NestedField nf : schema.columns()) {\n      switch (nf.type().typeId()) {\n        case MAP:\n        case LIST:\n        case STRUCT:\n          continue;\n        default:\n          result.add(nf.name());\n      }\n    }\n\n    return result;\n  }\n\n  @Override\n  public List<Expression.OpType> getSupportedExpressionTypes() {\n    LOG.info(format(\"[%s]: getSupportedExpressionTypes()\", signature));\n    return asList(OP_AND, OP_OR, OP_EQ, OP_NE, OP_NOT, OP_GE, OP_GT, OP_LE, OP_LT, OP_BETWEEN, OP_IN, OP_NULL);\n  }\n\n  @Override\n  public void setPushdownPredicate(Expression predicate) throws IOException {\n    LOG.info(format(\"[%s]: setPushdownPredicate()\", signature));\n    LOG.info(format(\"[%s]: Pig predicate expression: %s\", signature, predicate));\n\n    com.netflix.iceberg.expressions.Expression icebergExpression = convert(predicate);\n\n    LOG.info(format(\"[%s]: Iceberg predicate expression: %s\", signature, icebergExpression));\n\n    storeInUDFContext(ICEBERG_FILTER_EXPRESSION, icebergExpression);\n  }\n\n  private com.netflix.iceberg.expressions.Expression convert(Expression e) throws IOException {\n    OpType op = e.getOpType();\n\n    if (e instanceof BinaryExpression) {\n      Expression lhs = ((BinaryExpression) e).getLhs();\n      Expression rhs = ((BinaryExpression) e).getRhs();\n\n      switch (op) {\n        case OP_AND:\n          return and(convert(lhs), convert(rhs));\n        case OP_OR:\n          return or(convert(lhs), convert(rhs));\n        case OP_BETWEEN:\n          BetweenExpression between = (BetweenExpression) rhs;\n          return and(\n              convert(OP_GE, (Column) lhs, (Const) between.getLower()),\n              convert(OP_LE, (Column) lhs, (Const) between.getUpper())\n          );\n        case OP_IN:\n          return ((InExpression) rhs).getValues().stream()\n              .map((value) -> convert(OP_EQ, (Column) lhs, (Const) value))\n              .reduce(Expressions.alwaysFalse(), (m, v) -> (or(m, v)));\n        default:\n          if (lhs instanceof Column && rhs instanceof Const) {\n            return convert(op, (Column) lhs, (Const) rhs);\n          } else if (lhs instanceof Const && rhs instanceof Column) {\n            throw new FrontendException(\"Invalid expression ordering \" + e);\n          }\n      }\n\n    } else if (e instanceof UnaryExpression) {\n      Expression unary = ((UnaryExpression) e).getExpression();\n\n      switch (op) {\n        case OP_NOT:  return not(convert(unary));\n        case OP_NULL: return isNull(((Column)unary).getName());\n        default:\n          throw new FrontendException(\"Unsupported unary operator\" + op);\n      }\n    }\n\n    throw new FrontendException(\"Failed to pushdown expression \" + e);\n  }\n\n  private com.netflix.iceberg.expressions.Expression convert(OpType op, Column col, Const constant) {\n    String name = col.getName();\n    Object value = constant.getValue();\n\n    switch (op) {\n      case OP_GE: return greaterThanOrEqual(name, value);\n      case OP_GT: return greaterThan(name, value);\n      case OP_LE: return lessThanOrEqual(name, value);\n      case OP_LT: return lessThan(name, value);\n      case OP_EQ: return equal(name, value);\n      case OP_NE: return notEqual(name, value);\n    }\n\n    throw new RuntimeException(format(\"[%s]: Failed to pushdown expression: %s %s %s\", signature, col, op, constant));\n  }\n\n  @Override\n  public List<OperatorSet> getFeatures() {\n    return Collections.singletonList(OperatorSet.PROJECTION);\n  }\n\n  @Override\n  public RequiredFieldResponse pushProjection(RequiredFieldList requiredFieldList) {\n    LOG.info(format(\"[%s]: pushProjection() -> %s\", signature, requiredFieldList));\n\n    try {\n      List<String> projection = requiredFieldList.getFields().stream().map(RequiredField::getAlias).collect(Collectors.toList());\n\n      storeInUDFContext(ICEBERG_PROJECTED_FIELDS, (Serializable) projection);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return new RequiredFieldResponse(true);\n  }\n\n  @Override\n  public void setUDFContextSignature(String signature) {\n    this.signature = signature;\n  }\n\n  private void storeInUDFContext(String key, Serializable value) throws IOException {\n    Properties properties = UDFContext.getUDFContext().getUDFProperties(this.getClass(), new String[]{signature});\n\n    properties.setProperty(key, ObjectSerializer.serialize(value));\n  }\n\n  private void copyUDFContextToConfiguration(Configuration conf, String key) {\n    String value = UDFContext.getUDFContext().getUDFProperties(this.getClass(), new String[]{signature}).getProperty(key);\n\n    if (value != null) {\n      conf.set(key, value);\n    }\n  }\n\n  @Override\n  public String relativeToAbsolutePath(String location, Path curDir) throws IOException {\n    return location;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T extends Serializable> T getFromUDFContext(String key, Class<T> clazz) throws IOException {\n    Properties properties = UDFContext.getUDFContext().getUDFProperties(this.getClass(), new String[]{signature});\n\n    return (T) ObjectSerializer.deserialize(properties.getProperty(key));\n  }\n\n  private Table load(String location, Job job) throws IOException {\n    if(iceberg == null) {\n      Class<?> tablesImpl = job.getConfiguration().getClass(PIG_ICEBERG_TABLES_IMPL, HadoopTables.class);\n      Log.info(\"Initializing iceberg tables implementation: \" + tablesImpl);\n      iceberg = (Tables) ReflectionUtils.newInstance(tablesImpl, job.getConfiguration());\n    }\n\n    Table result = tables.get(location);\n\n    if (result == null) {\n      try {\n        LOG.info(format(\"[%s]: Loading table for location: %s\", signature, location));\n        result = iceberg.load(location);\n        tables.put(location, result);\n      } catch (Exception e) {\n        throw new FrontendException(\"Failed to instantiate tables implementation\", e);\n      }\n    }\n\n    return result;\n  }\n\n}\n\n\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergPigInputFormat.java'",
            "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergStorage.java'"
        ]
    },
    {
        "files": [
            "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergStorage.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergPigInputFormat.java'"
        ],
        "content": "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergStorage.java'\n:\n\npackage com.netflix.iceberg.pig;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.Table;\nimport com.netflix.iceberg.expressions.Expressions;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.pig.impl.util.ObjectSerializer;\nimport org.apache.pig.impl.util.UDFContext;\nimport org.mortbay.log.Log;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.netflix.iceberg.Tables;\nimport com.netflix.iceberg.hadoop.HadoopTables;\nimport com.netflix.iceberg.pig.IcebergPigInputFormat.IcebergRecordReader;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.mapreduce.InputFormat;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.RecordReader;\n\nimport org.apache.hadoop.util.ReflectionUtils;\nimport org.apache.pig.Expression;\nimport org.apache.pig.Expression.*;\nimport org.apache.pig.LoadFunc;\nimport org.apache.pig.LoadMetadata;\nimport org.apache.pig.LoadPredicatePushdown;\nimport org.apache.pig.LoadPushDown;\nimport org.apache.pig.ResourceSchema;\nimport org.apache.pig.ResourceStatistics;\nimport org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.PigSplit;\nimport org.apache.pig.data.Tuple;\nimport org.apache.pig.impl.logicalLayer.FrontendException;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.stream.Collectors;\n\nimport static java.lang.String.format;\nimport static java.util.Arrays.asList;\nimport static com.netflix.iceberg.expressions.Expressions.and;\nimport static com.netflix.iceberg.expressions.Expressions.equal;\nimport static com.netflix.iceberg.expressions.Expressions.greaterThan;\nimport static com.netflix.iceberg.expressions.Expressions.greaterThanOrEqual;\nimport static com.netflix.iceberg.expressions.Expressions.isNull;\nimport static com.netflix.iceberg.expressions.Expressions.lessThan;\nimport static com.netflix.iceberg.expressions.Expressions.lessThanOrEqual;\nimport static com.netflix.iceberg.expressions.Expressions.not;\nimport static com.netflix.iceberg.expressions.Expressions.notEqual;\nimport static com.netflix.iceberg.expressions.Expressions.or;\nimport static com.netflix.iceberg.pig.IcebergPigInputFormat.ICEBERG_FILTER_EXPRESSION;\nimport static com.netflix.iceberg.pig.IcebergPigInputFormat.ICEBERG_PROJECTED_FIELDS;\nimport static com.netflix.iceberg.pig.IcebergPigInputFormat.ICEBERG_SCHEMA;\nimport static org.apache.pig.Expression.OpType.OP_AND;\nimport static org.apache.pig.Expression.OpType.OP_BETWEEN;\nimport static org.apache.pig.Expression.OpType.OP_EQ;\nimport static org.apache.pig.Expression.OpType.OP_GE;\nimport static org.apache.pig.Expression.OpType.OP_GT;\nimport static org.apache.pig.Expression.OpType.OP_IN;\nimport static org.apache.pig.Expression.OpType.OP_LE;\nimport static org.apache.pig.Expression.OpType.OP_LT;\nimport static org.apache.pig.Expression.OpType.OP_NE;\nimport static org.apache.pig.Expression.OpType.OP_NOT;\nimport static org.apache.pig.Expression.OpType.OP_NULL;\nimport static org.apache.pig.Expression.OpType.OP_OR;\n\npublic class IcebergStorage extends LoadFunc implements LoadMetadata, LoadPredicatePushdown, LoadPushDown {\n  private static final Logger LOG = LoggerFactory.getLogger(IcebergStorage.class);\n\n  public static final String PIG_ICEBERG_TABLES_IMPL = \"pig.iceberg.tables.impl\";\n  private static Tables iceberg;\n  private static Map<String, Table> tables = Maps.newConcurrentMap();\n  private static Map<String, String> locations = Maps.newConcurrentMap();\n\n  private String signature;\n\n  private IcebergRecordReader reader;\n\n  @Override\n  public void setLocation(String location, Job job) {\n    LOG.info(format(\"[%s]: setLocation() -> %s \", signature, location));\n\n    locations.put(signature, location);\n\n    Configuration conf = job.getConfiguration();\n\n    copyUDFContextToConfiguration(conf, ICEBERG_SCHEMA);\n    copyUDFContextToConfiguration(conf, ICEBERG_PROJECTED_FIELDS);\n    copyUDFContextToConfiguration(conf, ICEBERG_FILTER_EXPRESSION);\n  }\n\n  @Override\n  public InputFormat getInputFormat() {\n    LOG.info(format(\"[%s]: getInputFormat()\", signature));\n    String location = locations.get(signature);\n\n    return new IcebergPigInputFormat(tables.get(location));\n  }\n\n  @Override\n  public Tuple getNext() throws IOException {\n    if (!reader.nextKeyValue()) {\n      return null;\n    }\n\n    return (Tuple) reader.getCurrentValue();\n  }\n\n  @Override\n  public void prepareToRead(RecordReader reader, PigSplit split) {\n    LOG.info(format(\"[%s]: prepareToRead() -> %s\", signature, split));\n\n    this.reader = (IcebergRecordReader) reader;\n  }\n\n  @Override\n  public ResourceSchema getSchema(String location, Job job) throws IOException {\n    LOG.info(format(\"[%s]: getSchema() -> %s\", signature, location));\n\n    Schema schema = load(location, job).schema();\n    storeInUDFContext(ICEBERG_SCHEMA, schema);\n\n    return SchemaUtil.convert(schema);\n  }\n\n\n  @Override\n  public ResourceStatistics getStatistics(String location, Job job) {\n    LOG.info(format(\"[%s]: getStatistics() -> : %s\", signature, location));\n\n    return null;\n  }\n\n  @Override\n  public String[] getPartitionKeys(String location, Job job) {\n    LOG.info(format(\"[%s]: getPartitionKeys()\", signature));\n    return new String[0];\n  }\n\n  @Override\n  public void setPartitionFilter(Expression partitionFilter) {\n    LOG.info(format(\"[%s]: setPartitionFilter() ->  %s\", signature, partitionFilter));\n  }\n\n  @Override\n  public List<String> getPredicateFields(String location, Job job) throws IOException {\n    LOG.info(format(\"[%s]: getPredicateFields() -> %s\", signature, location));\n    Schema schema = load(location, job).schema();\n\n    List<String> result = Lists.newArrayList();\n\n    for (Types.NestedField nf : schema.columns()) {\n      switch (nf.type().typeId()) {\n        case MAP:\n        case LIST:\n        case STRUCT:\n          continue;\n        default:\n          result.add(nf.name());\n      }\n    }\n\n    return result;\n  }\n\n  @Override\n  public List<Expression.OpType> getSupportedExpressionTypes() {\n    LOG.info(format(\"[%s]: getSupportedExpressionTypes()\", signature));\n    return asList(OP_AND, OP_OR, OP_EQ, OP_NE, OP_NOT, OP_GE, OP_GT, OP_LE, OP_LT, OP_BETWEEN, OP_IN, OP_NULL);\n  }\n\n  @Override\n  public void setPushdownPredicate(Expression predicate) throws IOException {\n    LOG.info(format(\"[%s]: setPushdownPredicate()\", signature));\n    LOG.info(format(\"[%s]: Pig predicate expression: %s\", signature, predicate));\n\n    com.netflix.iceberg.expressions.Expression icebergExpression = convert(predicate);\n\n    LOG.info(format(\"[%s]: Iceberg predicate expression: %s\", signature, icebergExpression));\n\n    storeInUDFContext(ICEBERG_FILTER_EXPRESSION, icebergExpression);\n  }\n\n  private com.netflix.iceberg.expressions.Expression convert(Expression e) throws IOException {\n    OpType op = e.getOpType();\n\n    if (e instanceof BinaryExpression) {\n      Expression lhs = ((BinaryExpression) e).getLhs();\n      Expression rhs = ((BinaryExpression) e).getRhs();\n\n      switch (op) {\n        case OP_AND:\n          return and(convert(lhs), convert(rhs));\n        case OP_OR:\n          return or(convert(lhs), convert(rhs));\n        case OP_BETWEEN:\n          BetweenExpression between = (BetweenExpression) rhs;\n          return and(\n              convert(OP_GE, (Column) lhs, (Const) between.getLower()),\n              convert(OP_LE, (Column) lhs, (Const) between.getUpper())\n          );\n        case OP_IN:\n          return ((InExpression) rhs).getValues().stream()\n              .map((value) -> convert(OP_EQ, (Column) lhs, (Const) value))\n              .reduce(Expressions.alwaysFalse(), (m, v) -> (or(m, v)));\n        default:\n          if (lhs instanceof Column && rhs instanceof Const) {\n            return convert(op, (Column) lhs, (Const) rhs);\n          } else if (lhs instanceof Const && rhs instanceof Column) {\n            throw new FrontendException(\"Invalid expression ordering \" + e);\n          }\n      }\n\n    } else if (e instanceof UnaryExpression) {\n      Expression unary = ((UnaryExpression) e).getExpression();\n\n      switch (op) {\n        case OP_NOT:  return not(convert(unary));\n        case OP_NULL: return isNull(((Column)unary).getName());\n        default:\n          throw new FrontendException(\"Unsupported unary operator\" + op);\n      }\n    }\n\n    throw new FrontendException(\"Failed to pushdown expression \" + e);\n  }\n\n  private com.netflix.iceberg.expressions.Expression convert(OpType op, Column col, Const constant) {\n    String name = col.getName();\n    Object value = constant.getValue();\n\n    switch (op) {\n      case OP_GE: return greaterThanOrEqual(name, value);\n      case OP_GT: return greaterThan(name, value);\n      case OP_LE: return lessThanOrEqual(name, value);\n      case OP_LT: return lessThan(name, value);\n      case OP_EQ: return equal(name, value);\n      case OP_NE: return notEqual(name, value);\n    }\n\n    throw new RuntimeException(format(\"[%s]: Failed to pushdown expression: %s %s %s\", signature, col, op, constant));\n  }\n\n  @Override\n  public List<OperatorSet> getFeatures() {\n    return Collections.singletonList(OperatorSet.PROJECTION);\n  }\n\n  @Override\n  public RequiredFieldResponse pushProjection(RequiredFieldList requiredFieldList) {\n    LOG.info(format(\"[%s]: pushProjection() -> %s\", signature, requiredFieldList));\n\n    try {\n      List<String> projection = requiredFieldList.getFields().stream().map(RequiredField::getAlias).collect(Collectors.toList());\n\n      storeInUDFContext(ICEBERG_PROJECTED_FIELDS, (Serializable) projection);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n\n    return new RequiredFieldResponse(true);\n  }\n\n  @Override\n  public void setUDFContextSignature(String signature) {\n    this.signature = signature;\n  }\n\n  private void storeInUDFContext(String key, Serializable value) throws IOException {\n    Properties properties = UDFContext.getUDFContext().getUDFProperties(this.getClass(), new String[]{signature});\n\n    properties.setProperty(key, ObjectSerializer.serialize(value));\n  }\n\n  private void copyUDFContextToConfiguration(Configuration conf, String key) {\n    String value = UDFContext.getUDFContext().getUDFProperties(this.getClass(), new String[]{signature}).getProperty(key);\n\n    if (value != null) {\n      conf.set(key, value);\n    }\n  }\n\n  @Override\n  public String relativeToAbsolutePath(String location, Path curDir) throws IOException {\n    return location;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T extends Serializable> T getFromUDFContext(String key, Class<T> clazz) throws IOException {\n    Properties properties = UDFContext.getUDFContext().getUDFProperties(this.getClass(), new String[]{signature});\n\n    return (T) ObjectSerializer.deserialize(properties.getProperty(key));\n  }\n\n  private Table load(String location, Job job) throws IOException {\n    if(iceberg == null) {\n      Class<?> tablesImpl = job.getConfiguration().getClass(PIG_ICEBERG_TABLES_IMPL, HadoopTables.class);\n      Log.info(\"Initializing iceberg tables implementation: \" + tablesImpl);\n      iceberg = (Tables) ReflectionUtils.newInstance(tablesImpl, job.getConfiguration());\n    }\n\n    Table result = tables.get(location);\n\n    if (result == null) {\n      try {\n        LOG.info(format(\"[%s]: Loading table for location: %s\", signature, location));\n        result = iceberg.load(location);\n        tables.put(location, result);\n      } catch (Exception e) {\n        throw new FrontendException(\"Failed to instantiate tables implementation\", e);\n      }\n    }\n\n    return result;\n  }\n\n}\n\n\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.collect.Lists;\nimport org.apache.spark.sql.types.ArrayType;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.MapType;\nimport org.apache.spark.sql.types.StructField;\nimport org.apache.spark.sql.types.StructType;\nimport org.apache.spark.sql.types.UserDefinedType;\nimport java.util.List;\n\nclass SparkTypeVisitor<T> {\n  static <T> T visit(DataType type, SparkTypeVisitor<T> visitor) {\n    if (type instanceof StructType) {\n      StructField[] fields = ((StructType) type).fields();\n      List<T> fieldResults = Lists.newArrayListWithExpectedSize(fields.length);\n\n      for (StructField field : fields) {\n        fieldResults.add(visitor.field(\n            field,\n            visit(field.dataType(), visitor)));\n      }\n\n      return visitor.struct((StructType) type, fieldResults);\n\n    } else if (type instanceof MapType) {\n      return visitor.map((MapType) type,\n          visit(((MapType) type).keyType(), visitor),\n          visit(((MapType) type).valueType(), visitor));\n\n    } else if (type instanceof ArrayType) {\n      return visitor.array(\n          (ArrayType) type,\n          visit(((ArrayType) type).elementType(), visitor));\n\n    } else if (type instanceof UserDefinedType){\n      throw new UnsupportedOperationException(\n          \"User-defined types are not supported\");\n\n    } else {\n      return visitor.atomic(type);\n    }\n  }\n\n  public T struct(StructType struct, List<T> fieldResults) {\n    return null;\n  }\n\n  public T field(StructField field, T typeResult) {\n    return null;\n  }\n\n  public T array(ArrayType array, T elementResult) {\n    return null;\n  }\n\n  public T map(MapType map, T keyResult, T valueResult) {\n    return null;\n  }\n\n  public T atomic(DataType atomic) {\n    return null;\n  }\n}\n\n'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'\n:\n\npackage com.netflix.iceberg.spark;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Lists;\nimport com.netflix.iceberg.PartitionSpec;\nimport com.netflix.iceberg.Schema;\nimport com.netflix.iceberg.expressions.Binder;\nimport com.netflix.iceberg.expressions.Expression;\nimport com.netflix.iceberg.types.Type;\nimport com.netflix.iceberg.types.TypeUtil;\nimport com.netflix.iceberg.types.Types;\nimport org.apache.spark.sql.AnalysisException;\nimport org.apache.spark.sql.SparkSession;\nimport org.apache.spark.sql.catalog.Column;\nimport org.apache.spark.sql.types.DataType;\nimport org.apache.spark.sql.types.StructType;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\n\nimport static com.netflix.iceberg.spark.SparkTypeVisitor.visit;\nimport static com.netflix.iceberg.types.TypeUtil.visit;\n\n\npublic class SparkSchemaUtil {\n  private SparkSchemaUtil() {\n  }\n\n\n  public static Schema schemaForTable(SparkSession spark, String name) {\n    StructType sparkType = spark.table(name).schema();\n    Type converted = visit(sparkType,\n        new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static PartitionSpec specForTable(SparkSession spark, String name) throws AnalysisException {\n    List<String> parts = Lists.newArrayList(Splitter.on('.').limit(2).split(name));\n    String db = parts.size() == 1 ? \"default\" : parts.get(0);\n    String table = parts.get(parts.size() == 1 ? 0 : 1);\n\n    return identitySpec(\n        schemaForTable(spark, name),\n        spark.catalog().listColumns(db, table).collectAsList());\n  }\n\n\n  public static StructType convert(Schema schema) {\n    return (StructType) visit(schema, new TypeToSparkType());\n  }\n\n\n  public static DataType convert(Type type) {\n    return visit(type, new TypeToSparkType());\n  }\n\n\n  public static Schema convert(StructType sparkType) {\n    Type converted = visit(sparkType, new SparkTypeToType(sparkType));\n    return new Schema(converted.asNestedType().asStructType().fields());\n  }\n\n\n  public static Type convert(DataType sparkType) {\n    return visit(sparkType, new SparkTypeToType());\n  }\n\n\n  public static Schema convert(Schema baseSchema, StructType sparkType) {\n\n    Types.StructType struct = visit(sparkType, new SparkTypeToType(sparkType)).asStructType();\n\n    Schema schema = TypeUtil.reassignIds(new Schema(struct.fields()), baseSchema);\n\n    return FixupTypes.fixup(schema, baseSchema);\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType) {\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, ImmutableSet.of()))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, List<Expression> filters) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), filters);\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n\n  public static Schema prune(Schema schema, StructType requestedType, Expression filter) {\n    Set<Integer> filterRefs = Binder.boundReferences(schema.asStruct(), Collections.singletonList(filter));\n    return new Schema(visit(schema, new PruneColumnsWithoutReordering(requestedType, filterRefs))\n        .asNestedType()\n        .asStructType()\n        .fields());\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, Collection<Column> columns) {\n    List<String> names = Lists.newArrayList();\n    for (Column column : columns) {\n      if (column.isPartition()) {\n        names.add(column.name());\n      }\n    }\n\n    return identitySpec(schema, names);\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, String... partitionNames) {\n    return identitySpec(schema, Lists.newArrayList(partitionNames));\n  }\n\n  private static PartitionSpec identitySpec(Schema schema, List<String> partitionNames) {\n    if (partitionNames == null || partitionNames.isEmpty()) {\n      return null;\n    }\n\n    PartitionSpec.Builder builder = PartitionSpec.builderFor(schema);\n    for (String partitionName : partitionNames) {\n      builder.identity(partitionName);\n    }\n\n    return builder.build();\n  }\n\n}\n",
        "gt": [
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkTypeVisitor.java'",
            "'iceberg/spark/src/main/java/com/netflix/iceberg/spark/SparkSchemaUtil.java'",
            "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergPigInputFormat.java'",
            "'iceberg/pig/src/main/java/com/netflix/iceberg/pig/IcebergStorage.java'"
        ]
    },
    {
        "files": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'"
        ],
        "content": "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'\n:\n\npackage com.philliphsu.bottomsheetpickers.date;\n\nimport android.annotation.SuppressLint;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.graphics.drawable.Drawable;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.ColorInt;\nimport android.support.annotation.NonNull;\nimport android.support.graphics.drawable.AnimatedVectorDrawableCompat;\nimport android.support.v4.view.ViewPager;\nimport android.support.v4.view.ViewPager.OnPageChangeListener;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.accessibility.AccessibilityEvent;\nimport android.view.accessibility.AccessibilityNodeInfo;\nimport android.widget.ImageButton;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.philliphsu.bottomsheetpickers.R;\nimport com.philliphsu.bottomsheetpickers.Utils;\nimport com.philliphsu.bottomsheetpickers.date.DatePickerDialog.OnDateChangedListener;\nimport com.philliphsu.bottomsheetpickers.date.MonthPickerView.OnMonthClickListener;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Locale;\n\nimport static android.support.v4.content.ContextCompat.getColor;\nimport static android.view.ViewGroup.LayoutParams.MATCH_PARENT;\n\n\nclass PagingDayPickerView extends LinearLayout implements OnDateChangedListener, OnPageChangeListener, OnMonthClickListener {\n\n    private static final String TAG = \"MonthFragment\";\n\n    static final int DAY_PICKER_INDEX = 0;\n    static final int MONTH_PICKER_INDEX = 1;\n\n    static int MONTH_NAVIGATION_BAR_SIZE;\n\n    private static final SimpleDateFormat YEAR_FORMAT = new SimpleDateFormat(\"yyyy\", Locale.getDefault());\n\n    protected Handler mHandler;\n\n\n    protected CalendarDay mSelectedDay = new CalendarDay();\n    protected PagingMonthAdapter mAdapter;\n\n    private DayPickerViewAnimator mMonthAnimator;\n    private ViewPager mViewPager;\n    private MonthPickerView mMonthPickerView;\n    private TextView mMonthYearTitleView;\n    private ImageButton mPreviousButton;\n    private ImageButton mNextButton;\n    private View mTitleContainer;\n\n\n    private AnimatedVectorDrawableCompat mArrowDownDrawable;\n\n    private AnimatedVectorDrawableCompat mArrowUpDrawable;\n\n    protected CalendarDay mTempDay = new CalendarDay();\n\n\n    protected int mCurrentMonthDisplayed;\n\n    private int mCurrentView = DAY_PICKER_INDEX;\n\n    private int mCurrentYearDisplayed;\n\n    private DatePickerController mController;\n\n    private boolean mThemeDark;\n    private int mAccentColor;\n\n    public PagingDayPickerView(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller) {\n        this(context, controller, false);\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark) {\n        this(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingDayPickerView(Context context, DatePickerController controller, boolean themeDark,\n                               int accentColor) {\n        super(context);\n\n        mThemeDark = themeDark;\n        mAccentColor = accentColor;\n        init(context);\n        setController(controller);\n    }\n\n    public void setController(DatePickerController controller) {\n        mController = controller;\n        mController.registerOnDateChangedListener(this);\n        refreshAdapter();\n        onDateChanged();\n        mMonthPickerView.setDatePickerController(mController);\n    }\n\n    private void init(Context context) {\n        mHandler = new Handler();\n        setOrientation(VERTICAL);\n        setLayoutParams(new LayoutParams(MATCH_PARENT, MATCH_PARENT));\n\n        Resources res = getResources();\n        MONTH_NAVIGATION_BAR_SIZE = res.getDimensionPixelOffset(R.dimen.bsp_month_navigation_bar_height)\n                + res.getDimensionPixelOffset(R.dimen.bsp_month_view_top_padding);\n\n        final View view = LayoutInflater.from(context).inflate(R.layout.bsp_day_picker_content, this, true);\n        mMonthAnimator = (DayPickerViewAnimator) findViewById(R.id.bsp_month_animator);\n        mMonthPickerView = (MonthPickerView) findViewById(R.id.bsp_month_picker);\n        mMonthPickerView.setOnMonthClickListener(this);\n        mViewPager = (ViewPager) findViewById(R.id.bsp_viewpager);\n        mViewPager.addOnPageChangeListener(this);\n        mMonthYearTitleView = (TextView) view.findViewById(R.id.bsp_month_year_title);\n        mTitleContainer = view.findViewById(R.id.bsp_month_year_title_container);\n        mTitleContainer.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int newIndex = mCurrentView == DAY_PICKER_INDEX ? MONTH_PICKER_INDEX : DAY_PICKER_INDEX;\n                setupCurrentView(newIndex, true);\n            }\n        });\n        mPreviousButton = (ImageButton) view.findViewById(R.id.bsp_prev);\n        mPreviousButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int previousItem = mViewPager.getCurrentItem() - 1;\n                if (previousItem >= 0) {\n                    mViewPager.setCurrentItem(previousItem, true);\n                }\n            }\n        });\n        mNextButton = (ImageButton) view.findViewById(R.id.bsp_next);\n        mNextButton.setOnClickListener(new OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                int nextItem = mViewPager.getCurrentItem() + 1;\n                if (nextItem < mAdapter.getCount()) {\n                    mViewPager.setCurrentItem(nextItem, true);\n                }\n            }\n        });\n\n        mArrowDownDrawable = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_down);\n        mArrowUpDrawable   = AnimatedVectorDrawableCompat.create(context, R.drawable.bsp_animated_arrow_drop_up);\n        setArrowDrawableOnTitle(mArrowDownDrawable);\n\n\n        if (mThemeDark) {\n            int selectableItemBg = getColor(context, R.color.bsp_selectable_item_background_dark);\n            Utils.setColorControlHighlight(mPreviousButton, selectableItemBg);\n            Utils.setColorControlHighlight(mNextButton, selectableItemBg);\n            Utils.setColorControlHighlight(mTitleContainer, selectableItemBg);\n            int cursor = getColor(context, R.color.bsp_text_color_secondary_dark);\n            Utils.applyTint(mPreviousButton, cursor);\n            Utils.applyTint(mNextButton, cursor);\n        }\n\n\n        int monthYearTitleColor = getColor(context, mThemeDark?\n                R.color.bsp_text_color_primary_dark : R.color.bsp_text_color_primary_light);\n        int dropdownArrowColor = getColor(context, mThemeDark?\n                R.color.bsp_icon_color_active_dark : R.color.bsp_icon_color_active_light);\n\n        mMonthYearTitleView.setTextColor(monthYearTitleColor);\n        mArrowDownDrawable.setTint(dropdownArrowColor);\n        mArrowUpDrawable.setTint(dropdownArrowColor);\n\n        mMonthPickerView.setTheme(context, mThemeDark);\n    }\n\n    @Override\n    protected void onDetachedFromWindow() {\n        super.onDetachedFromWindow();\n        mViewPager.removeOnPageChangeListener(this);\n    }\n\n    void setTheme(Context context, boolean themeDark) {\n        mThemeDark = themeDark;\n    }\n\n    void setAccentColor(@ColorInt int color) {\n        mAccentColor = color;\n        mMonthPickerView.setCurrentMonthTextColor(color);\n        mMonthPickerView.setSelectedCirclePaintColor(color);\n    }\n\n    public void onChange() {\n        refreshAdapter();\n        refreshMonthPicker();\n    }\n\n\n    void setupCurrentView(int currentView, boolean animate) {\n        if (currentView == DAY_PICKER_INDEX || currentView == MONTH_PICKER_INDEX) {\n            boolean isDayPicker = currentView == DAY_PICKER_INDEX;\n            setCurrentView(currentView, animate);\n            if (isDayPicker) {\n                setTitle(mAdapter.getPageTitle(mViewPager.getCurrentItem()));\n                toggleArrowsVisibility(getPagerPosition());\n            } else {\n\n\n\n                setTitle(String.valueOf(mCurrentYearDisplayed));\n                toggleArrowsVisibility(false, false);\n            }\n        } else {\n            Log.e(TAG, \"Error restoring current view\");\n        }\n    }\n\n\n    protected void refreshAdapter() {\n        if (mAdapter == null) {\n            if (mAccentColor != 0) {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark, mAccentColor);\n            } else {\n                mAdapter = createMonthAdapter(getContext(), mController, mThemeDark);\n            }\n        } else {\n            mAdapter.setSelectedDay(mSelectedDay);\n        }\n\n        mViewPager.setAdapter(mAdapter);\n    }\n\n\n    private void refreshMonthPicker() {\n        prepareMonthPickerForDisplay(mSelectedDay.year);\n        mMonthPickerView.invalidate();\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller) {\n        return new PagingMonthAdapter(context, controller);\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark) {\n        return createMonthAdapter(context, controller, themeDark, Utils.getThemeAccentColor(context));\n    }\n\n    public PagingMonthAdapter createMonthAdapter(Context context,\n                                                 DatePickerController controller,\n                                                 boolean themeDark,\n                                                 int accentColor) {\n        return new PagingMonthAdapter(context, controller, themeDark, accentColor);\n    }\n\n\n    public boolean goTo(CalendarDay day, boolean animate, boolean setSelected, boolean forceScroll) {\n        final int selectedPosition = getPosition(mSelectedDay);\n\n\n        if (setSelected) {\n            mSelectedDay.set(day);\n        }\n\n        mTempDay.set(day);\n        final int position = getPosition(day);\n\n        if (Log.isLoggable(TAG, Log.DEBUG)) {\n            Log.d(TAG, \"GoTo position \" + position);\n        }\n\n\n        if (position != selectedPosition || forceScroll) {\n            setMonthAndYearDisplayed(mTempDay);\n            if (animate) {\n                mViewPager.setCurrentItem(position, true);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n                return true;\n            } else {\n                postSetSelection(position, setSelected);\n            }\n        } else if (setSelected) {\n            setMonthAndYearDisplayed(mSelectedDay);\n            setSelectedDay(mSelectedDay);\n        }\n        return false;\n    }\n\n\n    private int getPosition(CalendarDay day) {\n        return mAdapter.getPosition(day);\n    }\n\n    public void postSetSelection(final int position, final boolean setSelected) {\n        clearFocus();\n        post(new Runnable() {\n            @Override\n            public void run() {\n                mViewPager.setCurrentItem(position, false);\n                if (setSelected) {\n                    setSelectedDay(mSelectedDay);\n                }\n            }\n        });\n    }\n\n    void postSetupCurrentView(final int currentView, final boolean animate) {\n        post(new Runnable() {\n            @Override\n            public void run() {\n                setupCurrentView(currentView, animate);\n            }\n        });\n    }\n\n\n    protected void setMonthAndYearDisplayed(CalendarDay date) {\n        mCurrentMonthDisplayed = date.month;\n        mCurrentYearDisplayed = date.year;\n    }\n\n    private void setSelectedDay(CalendarDay day) {\n        mAdapter.setSelectedDay(day);\n    }\n\n    @Override\n    public void onDateChanged() {\n        if (mCurrentView != DAY_PICKER_INDEX) {\n            setCurrentView(DAY_PICKER_INDEX, false);\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        goTo(mController.getSelectedDay(), false, true, true);\n    }\n\n\n    private CalendarDay findAccessibilityFocus() {\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                final CalendarDay focus = ((MonthView) child).getAccessibilityFocus();\n                if (focus != null) {\n                    if (Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN_MR1) {\n\n                        ((MonthView) child).clearAccessibilityFocus();\n                    }\n                    return focus;\n                }\n            }\n        }\n\n        return null;\n    }\n\n\n    private boolean restoreAccessibilityFocus(CalendarDay day) {\n        if (day == null) {\n            return false;\n        }\n\n        final int childCount = getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = getChildAt(i);\n            if (child instanceof MonthView) {\n                if (((MonthView) child).restoreAccessibilityFocus(day)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public void onInitializeAccessibilityEvent(AccessibilityEvent event) {\n        super.onInitializeAccessibilityEvent(event);\n        event.setItemCount(-1);\n   }\n\n    private static String getMonthAndYearString(CalendarDay day) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(day.year, day.month, day.day);\n\n        StringBuffer sbuf = new StringBuffer();\n        sbuf.append(cal.getDisplayName(Calendar.MONTH, Calendar.LONG, Locale.getDefault()));\n        sbuf.append(\" \");\n        sbuf.append(YEAR_FORMAT.format(cal.getTime()));\n        return sbuf.toString();\n    }\n\n\n    @Override\n    public void onInitializeAccessibilityNodeInfo(AccessibilityNodeInfo info) {\n      super.onInitializeAccessibilityNodeInfo(info);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);\n      info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);\n    }\n\n\n    @SuppressLint(\"NewApi\")\n    @Override\n    public boolean performAccessibilityAction(int action, Bundle arguments) {\n        if (action != AccessibilityNodeInfo.ACTION_SCROLL_FORWARD &&\n                action != AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            return super.performAccessibilityAction(action, arguments);\n        }\n\n\n        int firstVisiblePosition = getPagerPosition();\n        int month = firstVisiblePosition % 12;\n        int year = firstVisiblePosition / 12 + mController.getMinYear();\n        CalendarDay day = new CalendarDay(year, month, 1);\n\n\n        if (action == AccessibilityNodeInfo.ACTION_SCROLL_FORWARD) {\n            day.month++;\n            if (day.month == 12) {\n                day.month = 0;\n                day.year++;\n            }\n        } else if (action == AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD) {\n            View firstVisibleView = getChildAt(0);\n\n\n            if (firstVisibleView != null && firstVisibleView.getTop() >= -1) {\n\n\n                day.month--;\n                if (day.month == -1) {\n                    day.month = 11;\n                    day.year--;\n                }\n            }\n        }\n\n\n        Utils.tryAccessibilityAnnounce(this, getMonthAndYearString(day));\n        goTo(day, true, false, true);\n        return true;\n    }\n\n    int getPagerPosition() {\n        return mViewPager.getCurrentItem();\n    }\n\n    int getCurrentView() {\n        return mCurrentView;\n    }\n\n    @Override\n    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {\n\n    }\n\n    @Override\n    public void onPageSelected(int position) {\n        if (mCurrentView == DAY_PICKER_INDEX) {\n            setTitle(mAdapter.getPageTitle(position));\n            toggleArrowsVisibility(position);\n            final int month = mAdapter.getMonth(position);\n            final int year = mAdapter.getYear(position);\n            if (mCurrentYearDisplayed != year) {\n                mCurrentYearDisplayed = year;\n            }\n            if (mCurrentMonthDisplayed != month) {\n                mCurrentMonthDisplayed = month;\n            }\n        }\n    }\n\n    @Override\n    public void onPageScrollStateChanged(int state) {\n\n    }\n\n    private void setTitle(CharSequence title) {\n        mMonthYearTitleView.setText(title);\n    }\n\n\n    private void toggleArrowsVisibility(int position) {\n        toggleArrowsVisibility(position > 0, position + 1 < mAdapter.getCount());\n    }\n\n    private void toggleArrowsVisibility(boolean leftVisible, boolean rightVisible) {\n        mPreviousButton.setVisibility(leftVisible ? VISIBLE : INVISIBLE);\n        mNextButton.setVisibility(rightVisible ? VISIBLE : INVISIBLE);\n    }\n\n    private void setArrowDrawableOnTitle(@NonNull Drawable arrow) {\n        if (Utils.checkApiLevel(17)) {\n            mMonthYearTitleView.setCompoundDrawablesRelativeWithIntrinsicBounds(null, null, arrow, null);\n        } else {\n            mMonthYearTitleView.setCompoundDrawablesWithIntrinsicBounds(null, null, arrow, null);\n        }\n    }\n\n    private void animateArrow(AnimatedVectorDrawableCompat arrow) {\n        setArrowDrawableOnTitle(arrow);\n        arrow.start();\n    }\n\n    private void setCurrentView(final int viewIndex, boolean animate) {\n        switch (viewIndex) {\n            case DAY_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    mMonthAnimator.setDisplayedChild(DAY_PICKER_INDEX, animate);\n                    animateArrow(mArrowUpDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n            case MONTH_PICKER_INDEX:\n                if (mCurrentView != viewIndex) {\n                    prepareMonthPickerForDisplay(mCurrentYearDisplayed);\n                    mMonthAnimator.setDisplayedChild(MONTH_PICKER_INDEX, animate);\n                    animateArrow(mArrowDownDrawable);\n                    mCurrentView = viewIndex;\n                }\n                break;\n        }\n    }\n\n    private void prepareMonthPickerForDisplay(int currentYear) {\n        mMonthPickerView.setDisplayParams(mSelectedDay, currentYear);\n    }\n\n    @Override\n    public void onMonthClick(MonthPickerView view, int month, int year) {\n\n\n\n\n\n        setCurrentView(DAY_PICKER_INDEX, true);\n\n\n\n\n\n\n\n\n\n\n        if (month == mCurrentMonthDisplayed) {\n\n            onPageSelected(mViewPager.getCurrentItem());\n        }\n        mController.tryVibrate();\n        mController.onMonthYearSelected(month, year);\n    }\n}\n",
        "gt": [
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DateFormatHelper.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/DatePickerDialog.java'",
            "'BottomSheetPickers/bottomsheetpickers/src/main/java/com/philliphsu/bottomsheetpickers/date/PagingDayPickerView.java'"
        ]
    },
    {
        "files": [
            "'Grammar-Kit/src/org/intellij/grammar/generator/ExpressionGeneratorHelper.java'",
            "'Grammar-Kit/src/org/intellij/grammar/generator/ExpressionHelper.java'",
            "'Grammar-Kit/src/org/intellij/grammar/generator/RuleGraphHelper.java'"
        ],
        "content": "'Grammar-Kit/src/org/intellij/grammar/generator/ExpressionGeneratorHelper.java'\n:\n\npackage org.intellij.grammar.generator;\n\nimport com.intellij.openapi.util.text.StringUtil;\nimport com.intellij.psi.util.PsiTreeUtil;\nimport com.intellij.util.ArrayUtil;\nimport com.intellij.util.SmartList;\nimport org.intellij.grammar.KnownAttribute;\nimport org.intellij.grammar.psi.BnfExpression;\nimport org.intellij.grammar.psi.BnfRule;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.*;\n\nimport static java.lang.String.format;\nimport static org.intellij.grammar.generator.BnfConstants.PSI_BUILDER_CLASS;\nimport static org.intellij.grammar.generator.ExpressionHelper.OperatorInfo;\nimport static org.intellij.grammar.generator.ExpressionHelper.OperatorType;\nimport static org.intellij.grammar.generator.ParserGeneratorUtil.*;\n\n\npublic class ExpressionGeneratorHelper {\n\n  private static final ConsumeType CONSUME_TYPE_OVERRIDE = ConsumeType.SMART;\n\n  private static @NotNull Map<String, List<OperatorInfo>> buildCallMap(ExpressionHelper.ExpressionInfo info, ParserGenerator g) {\n    Map<String, List<OperatorInfo>> opCalls = new LinkedHashMap<>();\n    for (BnfRule rule : info.priorityMap.keySet()) {\n      OperatorInfo operator = info.operatorMap.get(rule);\n      String opCall = g.generateNodeCall(\n        info.rootRule, operator.operator, getNextName(getFuncName(operator.rule), 0), CONSUME_TYPE_OVERRIDE\n      ).render(g.N);\n      opCalls.computeIfAbsent(opCall, k -> new ArrayList<>(2)).add(operator);\n    }\n    return opCalls;\n  }\n\n  public static void generateExpressionRoot(ExpressionHelper.ExpressionInfo info, ParserGenerator g) {\n    Map<String, List<OperatorInfo>> opCalls = buildCallMap(info, g);\n    Set<String> sortedOpCalls = opCalls.keySet();\n\n    for (String s : info.toString().split(\"\\n\")) {\n      g.out(\"\n    }\n\n\n    String methodName = getFuncName(info.rootRule);\n    String kernelMethodName = getNextName(methodName, 0);\n    String frameName = quote(getRuleDisplayName(info.rootRule, true));\n    String shortPB = g.shorten(PSI_BUILDER_CLASS);\n    String shortMarker = !g.G.generateFQN ? \"Marker\" : PSI_BUILDER_CLASS + \".Marker\";\n    g.out(\"public static boolean %s(%s %s, int %s, int %s) {\", methodName, shortPB, g.N.builder, g.N.level, g.N.priority);\n    g.out(\"if (!recursion_guard_(%s, %s, \\\"%s\\\")) return false;\", g.N.builder, g.N.level, methodName);\n\n    if (frameName != null) {\n      g.out(\"addVariant(%s, %s);\", g.N.builder, frameName);\n    }\n    g.generateFirstCheck(info.rootRule, frameName, true);\n    g.out(\"boolean %s, %s;\", g.N.result, g.N.pinned);\n    g.out(\"%s %s = enter_section_(%s, %s, _NONE_, %s);\", shortMarker, g.N.marker, g.N.builder, g.N.level, frameName);\n\n    boolean first = true;\n    for (String opCall : sortedOpCalls) {\n      List<OperatorInfo> operators = findOperators(opCalls.get(opCall), OperatorType.ATOM, OperatorType.PREFIX);\n      if (operators.isEmpty()) continue;\n      OperatorInfo operator = operators.get(0);\n      if (operators.size() > 1) {\n        g.addWarning(\"only first definition will be used for '\" + operator.operator.getText() + \"': \" + operators);\n      }\n      String nodeCall = g.generateNodeCall(operator.rule, null, operator.rule.getName()).render(g.N);\n      g.out(\"%s%s = %s;\", first ? \"\" : format(\"if (!%s) \", g.N.result), g.N.result, nodeCall);\n      first = false;\n    }\n\n    g.out(\"%s = %s;\", g.N.pinned, g.N.result);\n    g.out(\"%s = %s && %s(%s, %s + 1, %s);\", g.N.result, g.N.result, kernelMethodName, g.N.builder, g.N.level, g.N.priority);\n    g.out(\"exit_section_(%s, %s, %s, null, %s, %s, null);\", g.N.builder, g.N.level, g.N.marker, g.N.result, g.N.pinned);\n    g.out(\"return %s || %s;\", g.N.result, g.N.pinned);\n    g.out(\"}\");\n    g.newLine();\n\n\n    g.out(\"public static boolean %s(%s %s, int %s, int %s) {\", kernelMethodName, shortPB, g.N.builder, g.N.level, g.N.priority);\n    g.out(\"if (!recursion_guard_(%s, %s, \\\"%s\\\")) return false;\", g.N.builder, g.N.level, kernelMethodName);\n    g.out(\"boolean %s = true;\", g.N.result);\n    g.out(\"while (true) {\");\n    g.out(\"%s %s = enter_section_(%s, %s, _LEFT_, null);\", shortMarker, g.N.marker, g.N.builder, g.N.level);\n\n    first = true;\n    for (String opCall : sortedOpCalls) {\n      List<OperatorInfo> operators = findOperators(opCalls.get(opCall), OperatorType.BINARY, OperatorType.N_ARY, OperatorType.POSTFIX);\n      if (operators.isEmpty()) continue;\n      OperatorInfo operator = operators.get(0);\n      if (operators.size() > 1) {\n        g.addWarning(\"only first definition will be used for '\" + operator.operator.getText() + \"': \" + operators);\n      }\n      int priority = info.getPriority(operator.rule);\n      int arg2Priority = operator.arg2 == null ? -1 : info.getPriority(operator.arg2);\n      int argPriority = arg2Priority == -1 ? priority : arg2Priority - 1;\n\n      String substCheck = \"\";\n      if (operator.arg1 != null) {\n        substCheck = format(\" && leftMarkerIs(%s, %s)\", g.N.builder, g.getElementType(operator.arg1));\n      }\n      g.out(\"%sif (%s < %d%s && %s) {\", first ? \"\" : \"else \", g.N.priority, priority, substCheck, opCall);\n      first = false;\n      String elementType = g.getElementType(operator.rule);\n      boolean rightAssociative = getAttribute(operator.rule, KnownAttribute.RIGHT_ASSOCIATIVE);\n      String tailCall = operator.tail == null ? null : g.generateNodeCall(\n        operator.rule, operator.tail, getNextName(getFuncName(operator.rule), 1), ConsumeType.DEFAULT\n      ).render(g.N);\n      if (operator.type == OperatorType.BINARY) {\n        String argCall = format(\"%s(%s, %s, %d)\", methodName, g.N.builder, g.N.level, rightAssociative ? argPriority - 1 : argPriority);\n        g.out(\"%s = %s;\", g.N.result, tailCall == null ? argCall : format(\"report_error_(%s, %s)\", g.N.builder, argCall));\n        if (tailCall != null) g.out(\"%s = %s && %s;\", g.N.result, tailCall, g.N.result);\n      }\n      else if (operator.type == OperatorType.N_ARY) {\n        boolean checkEmpty = info.checkEmpty.contains(operator);\n        if (checkEmpty) {\n          g.out(\"int %s = current_position_(%s);\", g.N.pos, g.N.builder);\n        }\n        g.out(\"while (true) {\");\n        g.out(\"%s = report_error_(%s, %s(%s, %s, %d));\", g.N.result, g.N.builder, methodName, g.N.builder, g.N.level, argPriority);\n        if (tailCall != null) g.out(\"%s = %s && %s;\", g.N.result, tailCall, g.N.result);\n        g.out(\"if (!%s) break;\", opCall);\n        if (checkEmpty) {\n          g.out(\"if (!empty_element_parsed_guard_(%s, \\\"%s\\\", %s)) break;\", g.N.builder, operator.rule.getName(), g.N.pos);\n          g.out(\"%s = current_position_(%s);\", g.N.pos, g.N.builder);\n        }\n        g.out(\"}\");\n      }\n      else if (operator.type == OperatorType.POSTFIX) {\n        g.out(\"%s = true;\", g.N.result);\n      }\n      g.out(\"exit_section_(%s, %s, %s, %s, %s, true, null);\", g.N.builder, g.N.level, g.N.marker, elementType, g.N.result);\n      g.out(\"}\");\n    }\n    if (first) {\n      g.out(\"\n      g.out(\"break;\");\n    }\n    else {\n      g.out(\"else {\");\n      g.out(\"exit_section_(%s, %s, %s, null, false, false, null);\", g.N.builder, g.N.level, g.N.marker);\n      g.out(\"break;\");\n      g.out(\"}\");\n    }\n    g.out(\"}\");\n    g.out(\"return %s;\", g.N.result);\n    g.out(\"}\");\n\n\n    Set<BnfExpression> visited = new HashSet<>();\n    for (String opCall : sortedOpCalls) {\n      for (OperatorInfo operator : opCalls.get(opCall)) {\n        if (operator.type == OperatorType.ATOM) {\n          if (Rule.isExternal(operator.rule)) continue;\n          g.newLine();\n          g.generateNode(operator.rule, operator.rule.getExpression(), getFuncName(operator.rule), visited);\n          continue;\n        }\n        else if (operator.type == OperatorType.PREFIX) {\n          g.newLine();\n          String operatorFuncName = operator.rule.getName();\n          g.out(\"public static boolean %s(%s %s, int %s) {\", operatorFuncName, shortPB, g.N.builder, g.N.level);\n          g.out(\"if (!recursion_guard_(%s, %s, \\\"%s\\\")) return false;\", g.N.builder, g.N.level, operatorFuncName);\n          g.generateFirstCheck(operator.rule, frameName, false);\n          g.out(\"boolean %s, %s;\", g.N.result, g.N.pinned);\n          g.out(\"%s %s = enter_section_(%s, %s, _NONE_, null);\", shortMarker, g.N.marker, g.N.builder, g.N.level);\n\n          String elementType = g.getElementType(operator.rule);\n          String tailCall = operator.tail == null ? null : g.generateNodeCall(\n            operator.rule, operator.tail, getNextName(getFuncName(operator.rule), 1), ConsumeType.DEFAULT\n          ).render(g.N);\n\n          g.out(\"%s = %s;\", g.N.result, opCall);\n          g.out(\"%s = %s;\", g.N.pinned, g.N.result);\n          int priority = info.getPriority(operator.rule);\n          int arg1Priority = operator.arg1 == null ? -1 : info.getPriority(operator.arg1);\n          int argPriority = arg1Priority == -1 ? (priority == info.nextPriority - 1 ? -1 : priority) : arg1Priority - 1;\n          g.out(\"%s = %s && %s(%s, %s, %d);\", g.N.result, g.N.pinned, methodName, g.N.builder, g.N.level, argPriority);\n          if (tailCall != null) {\n            g.out(\"%s = %s && report_error_(%s, %s) && %s;\", g.N.result, g.N.pinned, g.N.builder, tailCall, g.N.result);\n          }\n          String elementTypeRef = StringUtil.isNotEmpty(elementType) ? elementType : \"null\";\n          g.out(\"exit_section_(%s, %s, %s, %s, %s, %s, null);\", g.N.builder, g.N.level, g.N.marker, elementTypeRef,\n                g.N.result, g.N.pinned);\n          g.out(\"return %s || %s;\", g.N.result, g.N.pinned);\n          g.out(\"}\");\n        }\n        g.generateNodeChild(operator.rule, operator.operator, getFuncName(operator.rule), 0, visited);\n        if (operator.tail != null) {\n          g.generateNodeChild(operator.rule, operator.tail, operator.rule.getName(), 1, visited);\n        }\n      }\n    }\n  }\n\n  public static @NotNull List<OperatorInfo> findOperators(Collection<OperatorInfo> list, OperatorType... types) {\n    List<OperatorInfo> result = new SmartList<>();\n    for (OperatorInfo o : list) {\n      if (ArrayUtil.contains(o.type, types)) {\n        result.add(o);\n      }\n    }\n    return result;\n  }\n\n  public static @Nullable ExpressionHelper.ExpressionInfo getInfoForExpressionParsing(ExpressionHelper expressionHelper, BnfRule rule) {\n    ExpressionHelper.ExpressionInfo expressionInfo = expressionHelper.getExpressionInfo(rule);\n    OperatorInfo operatorInfo = expressionInfo == null ? null : expressionInfo.operatorMap.get(rule);\n    if (expressionInfo != null && (operatorInfo == null || operatorInfo.type != OperatorType.ATOM &&\n                                                           operatorInfo.type != OperatorType.PREFIX)) {\n      return expressionInfo;\n    }\n    return null;\n  }\n\n  public static @Nullable ConsumeType fixForcedConsumeType(@NotNull ExpressionHelper expressionHelper,\n                                                           @NotNull BnfRule rule,\n                                                           @Nullable BnfExpression node,\n                                                           @Nullable ConsumeType defValue) {\n    if (defValue != null) return defValue;\n    ExpressionHelper.ExpressionInfo expressionInfo = expressionHelper.getExpressionInfo(rule);\n    OperatorInfo operatorInfo = expressionInfo == null ? null : expressionInfo.operatorMap.get(rule);\n    if (operatorInfo != null) {\n      if (node == null) {\n        return operatorInfo.type == OperatorType.PREFIX || operatorInfo.type == OperatorType.ATOM ?\n               CONSUME_TYPE_OVERRIDE : null;\n      }\n      if (PsiTreeUtil.isAncestor(operatorInfo.operator, node, false)) return CONSUME_TYPE_OVERRIDE;\n      for (BnfExpression o : ExpressionHelper.getOriginalExpressions(operatorInfo.operator)) {\n        if (PsiTreeUtil.isAncestor(o, node, false)) {\n          return CONSUME_TYPE_OVERRIDE;\n        }\n      }\n    }\n    return null;\n  }\n}\n\n'Grammar-Kit/src/org/intellij/grammar/generator/ExpressionHelper.java'\n:\n\npackage org.intellij.grammar.generator;\n\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.util.Conditions;\nimport com.intellij.openapi.util.Key;\nimport com.intellij.openapi.util.text.StringUtil;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.util.CachedValue;\nimport com.intellij.psi.util.CachedValueProvider;\nimport com.intellij.psi.util.CachedValuesManager;\nimport com.intellij.psi.util.PsiTreeUtil;\nimport com.intellij.util.ObjectUtils;\nimport com.intellij.util.PairConsumer;\nimport com.intellij.util.containers.ContainerUtil;\nimport com.intellij.util.containers.JBIterable;\nimport com.intellij.util.containers.JBTreeTraverser;\nimport com.intellij.util.containers.TreeTraversal;\nimport org.intellij.grammar.analysis.BnfFirstNextAnalyzer;\nimport org.intellij.grammar.psi.*;\nimport org.intellij.grammar.psi.impl.BnfElementFactory;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.*;\nimport java.util.function.Consumer;\n\nimport static org.intellij.grammar.generator.ParserGeneratorUtil.*;\nimport static org.intellij.grammar.generator.RuleGraphHelper.Cardinality.OPTIONAL;\n\n\npublic class ExpressionHelper {\n  private final BnfFile myFile;\n  private final RuleGraphHelper myRuleGraph;\n  private final Consumer<String> myWarningConsumer;\n\n  private final Map<BnfRule, ExpressionInfo> myExpressionMap = new HashMap<>();\n  private final Map<BnfRule, BnfRule> myRootRulesMap = new HashMap<>();\n\n  private static final Key<CachedValue<ExpressionHelper>> EXPRESSION_HELPER_KEY = Key.create(\"EXPRESSION_HELPER_KEY\");\n  public static ExpressionHelper getCached(@NotNull BnfFile file) {\n    CachedValue<ExpressionHelper> value = file.getUserData(EXPRESSION_HELPER_KEY);\n    if (value == null) {\n      file.putUserData(EXPRESSION_HELPER_KEY, value = CachedValuesManager.getManager(file.getProject()).createCachedValue(\n        () -> new CachedValueProvider.Result<>(new ExpressionHelper(file, RuleGraphHelper.getCached(file), null), file), false));\n    }\n    return value.getValue();\n  }\n\n\n  public ExpressionHelper(BnfFile file, RuleGraphHelper ruleGraph, @Nullable Consumer<String> warningConsumer) {\n    myFile = file;\n    myRuleGraph = ruleGraph;\n    myWarningConsumer = warningConsumer;\n    buildExpressionRules();\n  }\n\n  public void addWarning(String text) {\n    if (myWarningConsumer == null) return;\n    myWarningConsumer.accept(text);\n  }\n\n  public ExpressionInfo getExpressionInfo(BnfRule rule) {\n    BnfRule root = myRootRulesMap.get(rule);\n    ExpressionInfo info = root == null ? null : myExpressionMap.get(root);\n    if (info == null) return null;\n    if (info.rootRule == rule || Rule.isPrivate(rule)) return info;\n    return info.priorityMap.containsKey(rule) ? info : null;\n  }\n\n  private void buildExpressionRules() {\n    BnfFirstNextAnalyzer analyzer = BnfFirstNextAnalyzer.createAnalyzer(false);\n    for (BnfRule rule : myFile.getRules()) {\n      if (Rule.isPrivate(rule) || Rule.isFake(rule)) continue;\n      if (myRootRulesMap.containsKey(rule)) continue;\n      Map<PsiElement, RuleGraphHelper.Cardinality> contentRules = myRuleGraph.getFor(rule);\n      if (!contentRules.isEmpty()) continue;\n      if (!BnfFirstNextAnalyzer.asStrings(analyzer.calcFirst(rule)).contains(rule.getName())) continue;\n\n      ExpressionInfo expressionInfo = new ExpressionInfo(rule);\n      addToPriorityMap(rule, myRuleGraph.getExtendsRules(rule), expressionInfo);\n      List<BnfRule> rules = topoSort(expressionInfo.priorityMap.keySet(), myRuleGraph);\n      for (BnfRule r : rules) {\n        buildOperatorMap(r, rule, expressionInfo);\n      }\n      if (!expressionInfo.priorityMap.isEmpty()) {\n        myRootRulesMap.put(rule, rule);\n        myExpressionMap.put(rule, expressionInfo);\n      }\n      ops: for (OperatorInfo info : expressionInfo.operatorMap.values()) {\n        Map<PsiElement, RuleGraphHelper.Cardinality> map = myRuleGraph.collectMembers(info.rule, info.operator, new HashSet<>());\n        for (RuleGraphHelper.Cardinality c : map.values()) {\n          if (!c.optional()) continue ops;\n        }\n        expressionInfo.checkEmpty.add(info);\n      }\n    }\n  }\n\n  private void addToPriorityMap(BnfRule rule, Collection<BnfRule> rulesCluster, ExpressionInfo info) {\n    JBTreeTraverser<BnfRule> traverser = new JBTreeTraverser<>(\n      o -> ObjectUtils.notNull(rule == o || Rule.isPrivate(o) ? myRuleGraph.getSubRules(o) : null, Collections.emptyList()));\n    for (TreeTraversal.TracingIt<BnfRule> it = traverser.withRoot(rule).unique().traverse().skip(1).typedIterator(); it.hasNext(); ) {\n      BnfRule subRule = it.next();\n      if (info.priorityMap.containsKey(subRule)) {\n        addWarning(String.format(\"'%s' priority is calculated twice\", subRule.getName()));\n        continue;\n      }\n      BnfRule prev = myRootRulesMap.put(subRule, info.rootRule);\n      if (prev != null) {\n        addWarning(String.format(\"''%s' is in several expression hierarchies: %s and %s\",\n                                 subRule.getName(), prev.getName(), info.rootRule.getName()));\n      }\n      Integer groupPriority = info.privateGroups.get(it.parent());\n      int priority = groupPriority == null ? info.nextPriority++ : groupPriority;\n      if (rulesCluster.contains(subRule)) {\n        if (!Rule.isPrivate(subRule) || !myRuleGraph.getFor(subRule).isEmpty()) {\n          info.priorityMap.put(subRule, priority);\n        }\n      }\n      else if (Rule.isPrivate(subRule)) {\n        info.privateGroups.put(subRule, priority);\n      }\n      else {\n        addWarning(String.format(\"'%s' is not an expression rule nor private priority group\", subRule.getName()));\n      }\n    }\n  }\n\n  private void buildOperatorMap(BnfRule rule, BnfRule rootRule, ExpressionInfo expressionInfo) {\n    Map<PsiElement, RuleGraphHelper.Cardinality> ruleContent = myRuleGraph.getFor(rule);\n    RuleGraphHelper.Cardinality cardinality = ruleContent.get(rootRule);\n    BnfRule rootRuleSubst = rootRule;\n    if (cardinality == null) {\n      Collection<BnfRule> extendsRules = myRuleGraph.getExtendsRules(rootRule);\n      JBIterable<BnfRule> tryOtherRules = JBIterable.from(ruleContent.keySet())\n        .filter(BnfRule.class)\n        .filter(extendsRules::contains)\n        .append(getSuperRules(myFile, rootRule).filter(Conditions.notNull()));\n      for (BnfRule r : tryOtherRules) {\n        cardinality = ruleContent.get(r);\n        if (cardinality == null) continue;\n        rootRuleSubst = r;\n        break;\n      }\n    }\n    if (Rule.isExternal(rule)) {\n      BnfExpression expression = (BnfExpression)ContainerUtil.getFirstItem(ruleContent.keySet());\n      expressionInfo.operatorMap.put(rule, new OperatorInfo(rule, OperatorType.ATOM, expression, null));\n      return;\n    }\n    String rootRuleName = rootRule.getName();\n    List<BnfExpression> childExpressions = getChildExpressions(rule.getExpression());\n    OperatorInfo info;\n    if (cardinality == null) {\n\n      info = new OperatorInfo(rule, OperatorType.ATOM, rule.getExpression(), null);\n    }\n    else if (childExpressions.size() < 2) {\n      addWarning(\"invalid expression definition for \" + rule + \": 2 or more arguments expected\");\n      info = new OperatorInfo(rule, OperatorType.ATOM, rule.getExpression(), null);\n    }\n    else if (cardinality == RuleGraphHelper.Cardinality.REQUIRED) {\n\n      int index = indexOf(rootRuleSubst, 0, childExpressions, expressionInfo);\n      BnfRule arg1 = substRule(childExpressions, index, rootRule);\n      if (index == 0) {\n        info = new OperatorInfo(rule, OperatorType.POSTFIX, combine(childExpressions.subList(1, childExpressions.size())), null, arg1, null);\n      }\n      else if (index == -1) {\n        addWarning(rule +\": \" + rootRuleName + \" reference not found, treating as ATOM\");\n        info = new OperatorInfo(rule, OperatorType.ATOM, rule.getExpression(), null);\n      }\n      else {\n        info = new OperatorInfo(rule, OperatorType.PREFIX, combine(childExpressions.subList(0, index)),\n                                combine(childExpressions.subList(index + 1, childExpressions.size())), arg1, null);\n      }\n    }\n    else if (cardinality == RuleGraphHelper.Cardinality.AT_LEAST_ONE) {\n\n      int index1 = indexOf(rootRuleSubst, 0, childExpressions, expressionInfo);\n      int index2 = indexOf(rootRuleSubst, 1, childExpressions, expressionInfo);\n      if (index1 != 0) {\n        addWarning(rule +\": binary or n-ary expression cannot have prefix, treating as ATOM\");\n        info = new OperatorInfo(rule, OperatorType.ATOM, rule.getExpression(), null);\n      }\n      else if (index2 == 1) {\n        addWarning(rule + \": binary expression needs operator, treating as ATOM\");\n        info = new OperatorInfo(rule, OperatorType.ATOM, rule.getExpression(), null);\n      }\n      else {\n        BnfRule arg1 = substRule(childExpressions, index1, rootRule);\n        if (index2 == -1) {\n          BnfExpression lastExpression = childExpressions.get(1);\n          boolean badNAry = childExpressions.size() != 2 || !(lastExpression instanceof BnfQuantified) ||\n                            !(((BnfQuantified)lastExpression).getQuantifier().getText().equals(\"+\")) ||\n                            !(((BnfQuantified)lastExpression).getExpression() instanceof BnfParenExpression);\n          List<BnfExpression> childExpressions2 = badNAry ? Collections.emptyList() :\n                                                  getChildExpressions(\n                                                    ((BnfParenExpression)((BnfQuantified)lastExpression).getExpression()).getExpression());\n          int index3 = indexOf(rootRuleSubst, 0, childExpressions2, expressionInfo);\n          if (badNAry || index3 == -1) {\n            addWarning(\n                rule + \": '\" + rootRuleName + \" ( <op> \" + rootRuleName + \") +' expected for N-ary operator, treating as POSTFIX\"\n            );\n            info = new OperatorInfo(rule, OperatorType.POSTFIX, combine(childExpressions.subList(1, childExpressions.size())), null,\n                                    arg1, null);\n          }\n          else {\n            BnfRule arg2 = substRule(childExpressions2, index3, rootRule);\n            info = new OperatorInfo(rule, OperatorType.N_ARY, combine(childExpressions2.subList(0, index3)),\n                                    combine(childExpressions2.subList(index3 + 1, childExpressions2.size())), arg1, arg2);\n          }\n        }\n        else {\n          BnfRule arg2 = substRule(childExpressions, index2, rootRule);\n          info = new OperatorInfo(rule, OperatorType.BINARY, combine(childExpressions.subList(index1 + 1, index2)),\n                                  combine(childExpressions.subList(index2 + 1, childExpressions.size())), arg1, arg2);\n        }\n      }\n    }\n    else {\n      addWarning(rule +\": unexpected cardinality \" + cardinality + \" of \" + rootRuleName +\", treating as ATOM\");\n      info = new OperatorInfo(rule, OperatorType.ATOM, rule.getExpression(), null);\n    }\n    expressionInfo.operatorMap.put(rule, info);\n  }\n\n  private @Nullable BnfRule substRule(List<BnfExpression> list, int idx, BnfRule rootRule) {\n    if (idx < 0) return null;\n    BnfRule rule = myFile.getRule(list.get(idx).getText());\n    return rule == rootRule? null : rule;\n  }\n\n  private static final Key<List<BnfExpression>> ORIGINAL_EXPRESSIONS = Key.create(\"ORIGINAL_EXPRESSIONS\");\n  private static BnfExpression combine(List<BnfExpression> list) {\n    if (list.isEmpty()) return null;\n    if (list.size() == 1) return list.get(0);\n    Project project = list.get(0).getProject();\n    String text = StringUtil.join(list, PsiElement::getText, \" \");\n    BnfExpression result = BnfElementFactory.createExpressionFromText(project, text);\n    result.putUserData(ORIGINAL_EXPRESSIONS, list);\n    return result;\n  }\n\n  public static @NotNull List<BnfExpression> getOriginalExpressions(BnfExpression expression) {\n    List<BnfExpression> data = expression.getUserData(ORIGINAL_EXPRESSIONS);\n    return data == null ? Collections.singletonList(expression) : data;\n  }\n\n  public @NotNull RuleGraphHelper.Cardinality fixCardinality(BnfRule rule, PsiElement tree, RuleGraphHelper.Cardinality type) {\n    if (type.optional()) return type;\n\n    ExpressionHelper.ExpressionInfo info = getExpressionInfo(rule);\n    ExpressionHelper.OperatorInfo operatorInfo = info == null ? null : info.operatorMap.get(rule);\n    if (operatorInfo == null || operatorInfo.type == ExpressionHelper.OperatorType.ATOM) return type;\n\n\n    if ((operatorInfo.type == OperatorType.BINARY ||\n         operatorInfo.type == OperatorType.N_ARY ||\n         operatorInfo.type == OperatorType.POSTFIX) &&\n        ObjectUtils.chooseNotNull(operatorInfo.arg1, info.rootRule) == tree ||\n        isRealAncestor(rule, operatorInfo.operator, tree)) {\n\n      return type;\n    }\n    else {\n      return type.and(OPTIONAL);\n    }\n  }\n\n  private boolean isRealAncestor(BnfRule rule, BnfExpression expression, PsiElement target) {\n    List<BnfExpression> list = getOriginalExpressions(expression);\n    if (list.size() == 1 && PsiTreeUtil.isAncestor(list.get(0), target, false)) return true;\n    for (BnfExpression expr : list) {\n      Map<PsiElement, RuleGraphHelper.Cardinality> map = myRuleGraph.collectMembers(rule, expr, new LinkedHashSet<>());\n      if (map.containsKey(target)) return true;\n    }\n    return false;\n  }\n\n  private int indexOf(BnfRule rootRule,\n                      int startIndex,\n                      List<BnfExpression> childExpressions,\n                      ExpressionInfo expressionInfo) {\n    Collection<BnfRule> extendsRules = myRuleGraph.getExtendsRules(rootRule);\n    for (int i = startIndex, childExpressionsSize = childExpressions.size(); i < childExpressionsSize; i++) {\n      BnfRule rule = myFile.getRule(childExpressions.get(i).getText());\n      if (rootRule == rule || extendsRules.contains(rule) || expressionInfo.privateGroups.containsKey(rule)) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  public static class ExpressionInfo {\n    public final BnfRule rootRule;\n    public final Map<BnfRule, Integer> priorityMap = new LinkedHashMap<>();\n    public final Map<BnfRule, OperatorInfo> operatorMap = new LinkedHashMap<>();\n    public final Map<BnfRule, Integer> privateGroups = new HashMap<>();\n    public int nextPriority;\n    public final Set<OperatorInfo> checkEmpty = new HashSet<>();\n\n    public ExpressionInfo(BnfRule rootRule) {\n      this.rootRule = rootRule;\n    }\n\n    @Override\n    public String toString() {\n      StringBuilder sb = new StringBuilder(\"Expression root: \" + rootRule.getName());\n      sb.append(\"\\nOperator priority table:\\n\");\n      return dumpPriorityTable(sb).toString();\n    }\n\n    public StringBuilder dumpPriorityTable(StringBuilder sb) {\n      return dumpPriorityTable(sb, StringBuilder::append);\n    }\n\n    public StringBuilder dumpPriorityTable(StringBuilder sb, PairConsumer<? super StringBuilder, ? super OperatorInfo> printer) {\n      for (int i = 0; i < nextPriority; i++) {\n        sb.append(i).append(\":\");\n        int count = 0;\n        for (BnfRule rule : priorityMap.keySet()) {\n          if (priorityMap.get(rule) == i) {\n            if ((count ++ % 4) == 0 && count > 1) sb.append(\"\\n  \");\n            sb.append(\" \");\n            printer.consume(sb, operatorMap.get(rule));\n          }\n        }\n        sb.append(\"\\n\");\n      }\n      return sb;\n    }\n\n    public int getPriority(BnfRule subRule) {\n      if (subRule == rootRule) return 0;\n      Integer op = priorityMap.get(subRule);\n      if (op != null) return op;\n      Integer group = privateGroups.get(subRule);\n      return group == null ? -1 : group;\n    }\n  }\n\n  public enum OperatorType {ATOM, PREFIX, POSTFIX, BINARY, N_ARY}\n\n  public static class OperatorInfo {\n    public final BnfRule rule;\n    public final OperatorType type;\n    public final BnfExpression operator;\n    public final BnfExpression tail;\n    public final BnfRule arg1;\n    public final BnfRule arg2;\n\n    public OperatorInfo(BnfRule rule, OperatorType type, BnfExpression operator, BnfExpression tail) {\n      this(rule, type, operator, tail, null, null);\n    }\n\n    public OperatorInfo(BnfRule rule, OperatorType type, BnfExpression operator, BnfExpression tail,\n                        @Nullable BnfRule arg1,\n                        @Nullable BnfRule arg2) {\n      if (operator == null) {\n        throw new AssertionError(rule + \": operator must not be null\");\n      }\n      this.rule = rule;\n      this.type = type;\n      this.operator = operator;\n      this.tail = tail;\n      this.arg1 = arg1;\n      this.arg2 = arg2;\n    }\n\n    @Override\n    public String toString() {\n      return type + \"(\" + rule.getName() + \")\";\n    }\n  }\n}\n",
        "gt": [
            "'Grammar-Kit/src/org/intellij/grammar/generator/RuleGraphHelper.java'",
            "'Grammar-Kit/src/org/intellij/grammar/generator/ExpressionHelper.java'",
            "'Grammar-Kit/src/org/intellij/grammar/generator/ExpressionGeneratorHelper.java'"
        ]
    },
    {
        "files": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ApacheThriftTesterUtil.java'"
        ],
        "content": "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'\n:\npackage io.airlift.drift.client.guice;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.reflect.TypeParameter;\nimport com.google.common.reflect.TypeToken;\nimport com.google.inject.Binder;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\nimport com.google.inject.Key;\nimport com.google.inject.Module;\nimport com.google.inject.Provider;\nimport com.google.inject.Provides;\nimport com.google.inject.Scopes;\nimport com.google.inject.Singleton;\nimport com.google.inject.TypeLiteral;\nimport io.airlift.configuration.ConfigDefaults;\nimport io.airlift.drift.client.DriftClient;\nimport io.airlift.drift.client.DriftClientFactory;\nimport io.airlift.drift.client.DriftClientFactoryManager;\nimport io.airlift.drift.client.ExceptionClassifier;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.client.stats.JmxMethodInvocationStatsFactory;\nimport io.airlift.drift.client.stats.MethodInvocationStatsFactory;\nimport io.airlift.drift.client.stats.NullMethodInvocationStatsFactory;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.codec.guice.ThriftCodecModule;\nimport io.airlift.drift.transport.client.DriftClientConfig;\nimport io.airlift.drift.transport.client.MethodInvokerFactory;\nimport org.weakref.jmx.MBeanExporter;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\n\nimport static com.google.inject.multibindings.Multibinder.newSetBinder;\nimport static com.google.inject.multibindings.OptionalBinder.newOptionalBinder;\nimport static io.airlift.configuration.ConfigBinder.configBinder;\nimport static io.airlift.drift.client.ExceptionClassifier.mergeExceptionClassifiers;\nimport static io.airlift.drift.client.guice.DriftClientAnnotationFactory.extractDriftClientBindingAnnotation;\nimport static io.airlift.drift.client.guice.DriftClientAnnotationFactory.getDriftClientAnnotation;\nimport static io.airlift.drift.codec.metadata.ThriftServiceMetadata.getThriftServiceAnnotation;\nimport static java.util.Objects.requireNonNull;\n\npublic class DriftClientBinder\n{\n    public static DriftClientBinder driftClientBinder(Binder binder)\n    {\n        return new DriftClientBinder(binder);\n    }\n\n    private final Binder binder;\n\n    private DriftClientBinder(Binder binder)\n    {\n        this.binder = requireNonNull(binder, \"binder is null\").skipSources(this.getClass());\n        binder.install(new ThriftCodecModule());\n        binder.install(new DriftClientBinderModule());\n    }\n\n    public <T> DriftClientBindingBuilder bindDriftClient(Class<T> clientInterface)\n    {\n        String configPrefix = getServiceName(clientInterface);\n        return bindDriftClient(clientInterface, configPrefix, DefaultClient.class);\n    }\n\n    public <T> DriftClientBindingBuilder bindDriftClient(Class<T> clientInterface, Class<? extends Annotation> annotationType)\n    {\n        String configPrefix = getServiceName(clientInterface);\n        if (annotationType != DefaultClient.class) {\n            configPrefix += \".\" + annotationType.getSimpleName();\n        }\n        return bindDriftClient(clientInterface, configPrefix, annotationType);\n    }\n\n    private <T> DriftClientBindingBuilder bindDriftClient(Class<T> clientInterface, String configPrefix, Class<? extends Annotation> annotation)\n    {\n        Annotation clientAnnotation = getDriftClientAnnotation(clientInterface, annotation);\n\n        configBinder(binder).bindConfig(DriftClientConfig.class, clientAnnotation, configPrefix);\n\n        TypeLiteral<DriftClient<T>> typeLiteral = driftClientTypeLiteral(clientInterface);\n\n        Provider<T> instanceProvider = new DriftClientInstanceProvider<>(clientAnnotation, Key.get(typeLiteral, annotation));\n        Provider<DriftClient<T>> factoryProvider = new DriftClientProvider<>(clientInterface, clientAnnotation);\n\n        binder.bind(Key.get(clientInterface, annotation)).toProvider(instanceProvider).in(Scopes.SINGLETON);\n        binder.bind(Key.get(typeLiteral, annotation)).toProvider(factoryProvider).in(Scopes.SINGLETON);\n\n        if (annotation == DefaultClient.class) {\n            binder.bind(Key.get(clientInterface)).toProvider(instanceProvider).in(Scopes.SINGLETON);\n            binder.bind(Key.get(typeLiteral)).toProvider(factoryProvider).in(Scopes.SINGLETON);\n        }\n\n        return new DriftClientBindingBuilder(binder, clientAnnotation, configPrefix);\n    }\n\n    public <T> void bindClientConfigDefaults(Class<T> clientInterface, ConfigDefaults<DriftClientConfig> configDefaults)\n    {\n        bindClientConfigDefaults(clientInterface, DefaultClient.class, configDefaults);\n    }\n\n    public <T> void bindClientConfigDefaults(Class<T> clientInterface, Class<? extends Annotation> annotationType, ConfigDefaults<DriftClientConfig> configDefaults)\n    {\n        bindConfigDefaults(clientInterface, annotationType, DriftClientConfig.class, configDefaults);\n    }\n\n    public <T, C> void bindConfigDefaults(Class<T> clientInterface, Class<C> configClass, ConfigDefaults<C> configDefaults)\n    {\n        bindConfigDefaults(configClass, DefaultClient.class, configClass, configDefaults);\n    }\n\n    public <T, C> void bindConfigDefaults(Class<T> clientInterface, Class<? extends Annotation> annotationType, Class<C> configClass, ConfigDefaults<C> configDefaults)\n    {\n        configBinder(binder).bindConfigDefaults(configClass, getDriftClientAnnotation(clientInterface, annotationType), configDefaults);\n    }\n\n    private static String getServiceName(Class<?> clientInterface)\n    {\n        requireNonNull(clientInterface, \"clientInterface is null\");\n        String serviceName = getThriftServiceAnnotation(clientInterface).value();\n        if (!serviceName.isEmpty()) {\n            return serviceName;\n        }\n        return clientInterface.getSimpleName();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <T> TypeLiteral<DriftClient<T>> driftClientTypeLiteral(Class<T> clientInterface)\n    {\n        Type javaType = new TypeToken<DriftClient<T>>() {}\n                .where(new TypeParameter<T>() {}, TypeToken.of(clientInterface))\n                .getType();\n        return (TypeLiteral<DriftClient<T>>) TypeLiteral.get(javaType);\n    }\n\n    private static class DriftClientInstanceProvider<T>\n            extends AbstractAnnotatedProvider<T>\n    {\n        private final Key<DriftClient<T>> key;\n\n        public DriftClientInstanceProvider(Annotation annotation, Key<DriftClient<T>> key)\n        {\n            super(annotation);\n            this.key = requireNonNull(key, \"key is null\");\n        }\n\n        @Override\n        protected T get(Injector injector, Annotation annotation)\n        {\n            return injector.getInstance(key).get();\n        }\n    }\n\n    private static class DriftClientProvider<T>\n            extends AbstractAnnotatedProvider<DriftClient<T>>\n    {\n        private static final TypeLiteral<DriftClientFactoryManager<Annotation>> DRIFT_CLIENT_FACTORY_MANAGER_TYPE = new TypeLiteral<DriftClientFactoryManager<Annotation>>() {};\n        private static final TypeLiteral<Set<MethodInvocationFilter>> SET_METHOD_INVOCATION_FILTERS_TYPE = new TypeLiteral<Set<MethodInvocationFilter>>() {};\n        private static final TypeLiteral<Set<ExceptionClassifier>> SET_EXCEPTION_CLASSIFIER_TYPE = new TypeLiteral<Set<ExceptionClassifier>>() {};\n\n        private final Class<T> clientInterface;\n\n        public DriftClientProvider(Class<T> clientInterface, Annotation annotation)\n        {\n            super(annotation);\n            this.clientInterface = requireNonNull(clientInterface, \"clientInterface is null\");\n        }\n\n        @Override\n        protected DriftClient<T> get(Injector injector, Annotation clientAnnotation)\n        {\n            DriftClientConfig config = injector.getInstance(Key.get(DriftClientConfig.class, clientAnnotation));\n            DriftClientFactoryManager<Annotation> driftClientFactoryManager = injector.getInstance(Key.get(DRIFT_CLIENT_FACTORY_MANAGER_TYPE));\n\n            AddressSelector<?> addressSelector = injector.getInstance(Key.get(AddressSelector.class, clientAnnotation));\n\n            ExceptionClassifier exceptionClassifier = mergeExceptionClassifiers(ImmutableList.<ExceptionClassifier>builder()\n                    .addAll(injector.getInstance(Key.get(SET_EXCEPTION_CLASSIFIER_TYPE, clientAnnotation)))\n                    .addAll(injector.getInstance(Key.get(SET_EXCEPTION_CLASSIFIER_TYPE)))\n                    .build());\n\n            List<MethodInvocationFilter> filters = ImmutableList.copyOf(injector.getInstance(Key.get(SET_METHOD_INVOCATION_FILTERS_TYPE, clientAnnotation)));\n\n            DriftClientFactory driftClientFactory = driftClientFactoryManager.createDriftClientFactory(clientAnnotation, addressSelector, exceptionClassifier);\n            return driftClientFactory.createDriftClient(clientInterface, extractDriftClientBindingAnnotation(clientAnnotation), filters, config);\n        }\n    }\n\n    private static class DefaultMethodInvocationStatsFactoryProvider\n            implements Provider<MethodInvocationStatsFactory>\n    {\n        private final Optional<MBeanExporter> mbeanExporter;\n\n        @Inject\n        public DefaultMethodInvocationStatsFactoryProvider(Optional<MBeanExporter> mbeanExporter)\n        {\n            this.mbeanExporter = mbeanExporter;\n        }\n\n        @Override\n        public MethodInvocationStatsFactory get()\n        {\n            return mbeanExporter\n                    .map(JmxMethodInvocationStatsFactory::new)\n                    .map(MethodInvocationStatsFactory.class::cast)\n                    .orElseGet(NullMethodInvocationStatsFactory::new);\n        }\n    }\n\n    private static class DriftClientBinderModule\n            implements Module\n    {\n        @Override\n        public void configure(Binder binder)\n        {\n            newSetBinder(binder, ExceptionClassifier.class);\n            newOptionalBinder(binder, MBeanExporter.class);\n            newOptionalBinder(binder, MethodInvocationStatsFactory.class)\n                    .setDefault()\n                    .toProvider(DefaultMethodInvocationStatsFactoryProvider.class)\n                    .in(Scopes.SINGLETON);\n        }\n\n        @Provides\n        @Singleton\n        private static DriftClientFactoryManager<Annotation> getDriftClientFactory(\n                ThriftCodecManager codecManager,\n                MethodInvokerFactory<Annotation> methodInvokerFactory,\n                MethodInvocationStatsFactory methodInvocationStatsFactory)\n        {\n            return new DriftClientFactoryManager<>(codecManager, methodInvokerFactory, methodInvocationStatsFactory);\n        }\n\n        @Override\n        public boolean equals(Object o)\n        {\n            if (this == o) {\n                return true;\n            }\n            return o != null && getClass() == o.getClass();\n        }\n\n        @Override\n        public int hashCode()\n        {\n            return getClass().hashCode();\n        }\n    }\n}\n\n'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'\n:\npackage io.airlift.drift.integration;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.net.HostAndPort;\nimport com.google.inject.BindingAnnotation;\nimport com.google.inject.Inject;\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\nimport com.google.inject.Scopes;\nimport io.airlift.bootstrap.Bootstrap;\nimport io.airlift.bootstrap.LifeCycleManager;\nimport io.airlift.drift.client.DriftClient;\nimport io.airlift.drift.client.MethodInvocationFilter;\nimport io.airlift.drift.client.address.AddressSelector;\nimport io.airlift.drift.codec.ThriftCodecManager;\nimport io.airlift.drift.integration.scribe.apache.LogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftLogEntry;\nimport io.airlift.drift.integration.scribe.drift.DriftResultCode;\nimport io.airlift.drift.integration.scribe.drift.DriftScribe;\nimport io.airlift.drift.transport.netty.codec.Protocol;\nimport io.airlift.drift.transport.netty.codec.Transport;\nimport io.airlift.jmx.testing.TestingJmxModule;\nimport org.weakref.jmx.guice.MBeanModule;\n\nimport javax.net.ssl.KeyManagerFactory;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManagerFactory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\nimport java.net.URL;\nimport java.security.GeneralSecurityException;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport static io.airlift.drift.client.guice.DriftClientBinder.driftClientBinder;\nimport static io.airlift.drift.client.guice.MethodInvocationFilterBinder.staticFilterBinder;\nimport static io.airlift.security.pem.PemReader.loadKeyStore;\nimport static io.airlift.security.pem.PemReader.loadTrustStore;\nimport static java.lang.annotation.ElementType.FIELD;\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.ElementType.PARAMETER;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertNotSame;\nimport static org.testng.Assert.assertSame;\n\nfinal class ClientTestUtils\n{\n    public static final ThriftCodecManager CODEC_MANAGER = new ThriftCodecManager();\n    public static final List<LogEntry> MESSAGES = ImmutableList.of(\n            new LogEntry(\"hello\", \"world\"),\n            new LogEntry(\"bye\", \"world\"));\n    public static final String HEADER_VALUE = \"header-value\";\n    public static final List<DriftLogEntry> DRIFT_MESSAGES = ImmutableList.copyOf(\n            MESSAGES.stream()\n                    .map(input -> new DriftLogEntry(input.category, input.message))\n                    .collect(Collectors.toList()));\n    public static final DriftResultCode DRIFT_OK = DriftResultCode.OK;\n\n    private ClientTestUtils() {}\n\n    public static int logDriftClientBinder(\n            HostAndPort address,\n            String headerValue,\n            List<DriftLogEntry> entries,\n            Module transportModule,\n            List<MethodInvocationFilter> filters,\n            Transport transport,\n            Protocol protocol,\n            boolean secure)\n    {\n\n        if (!filters.isEmpty()) {\n            return 0;\n        }\n\n        AddressSelector<?> addressSelector = (context, attempted) -> Optional.of(() -> address);\n\n        Bootstrap app = new Bootstrap(\n                new MBeanModule(),\n                new TestingJmxModule(),\n                transportModule,\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> driftClientBinder(binder).bindDriftClient(DriftScribe.class, CustomClient.class)\n                        .withAddressSelector(addressSelector)\n                        .withMethodInvocationFilter(staticFilterBinder(filters)),\n                binder -> binder.bind(ScribeUser.class).in(Scopes.SINGLETON));\n\n        LifeCycleManager lifeCycleManager = null;\n\n        try {\n            app.setRequiredConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"scribe.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.CustomClient.thrift.client.transport\", transport.toString())\n                    .put(\"scribe.thrift.client.protocol\", protocol.toString())\n                    .put(\"scribe.CustomClient.thrift.client.protocol\", protocol.toString())\n                    .build());\n\n\n            app.setOptionalConfigurationProperties(ImmutableMap.<String, String>builder()\n                    .put(\"thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"scribe.CustomClient.thrift.client.ssl.enabled\", String.valueOf(secure))\n                    .put(\"thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .put(\"scribe.CustomClient.thrift.client.ssl.trust-certificate\", getCertificateChainFile().getAbsolutePath())\n                    .build());\n\n            Injector injector = app\n                    .doNotInitializeLogging()\n                    .initialize();\n\n            lifeCycleManager = injector.getInstance(LifeCycleManager.class);\n            DriftScribe scribe = injector.getInstance(DriftScribe.class);\n\n            ScribeUser user = injector.getInstance(ScribeUser.class);\n\n            assertEquals(scribe.log(headerValue, entries), DRIFT_OK);\n\n            assertEquals(user.getClient().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getClientCustom().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactory().get().log(headerValue, entries), DRIFT_OK);\n            assertEquals(user.getFactoryCustom().get().log(headerValue, entries), DRIFT_OK);\n\n            assertSame(scribe, user.getClient());\n            assertNotSame(user.getClient(), user.getClientCustom());\n            assertNotSame(user.getFactory(), user.getFactoryCustom());\n        }\n        catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        finally {\n            if (lifeCycleManager != null) {\n                try {\n                    lifeCycleManager.stop();\n                }\n                catch (Exception ignored) {\n                }\n            }\n        }\n        return 5;\n    }\n\n    public static SSLContext getServerSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n        keyManagerFactory.init(loadKeyStore(getPrivateKeyFile(), getPrivateKeyFile(), Optional.empty()), new char[0]);\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static SSLContext getClientSslContext()\n            throws IOException, GeneralSecurityException\n    {\n        TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n        trustManagerFactory.init(loadTrustStore(getCertificateChainFile()));\n\n        SSLContext sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(null, trustManagerFactory.getTrustManagers(), null);\n        return sslContext;\n    }\n\n    public static File getPrivateKeyFile()\n    {\n        return getResourceFile(\"rsa.key\");\n    }\n\n    public static File getCertificateChainFile()\n    {\n        return getResourceFile(\"rsa.crt\");\n    }\n\n    private static File getResourceFile(String name)\n    {\n        URL resource = TestClientsWithApacheServer.class.getClassLoader().getResource(name);\n        if (resource == null) {\n            throw new IllegalArgumentException(\"Resource not found \" + name);\n        }\n        return new File(resource.getFile());\n    }\n\n    @Target({FIELD, PARAMETER, METHOD})\n    @Retention(RUNTIME)\n    @BindingAnnotation\n    private @interface CustomClient {}\n\n    private static class ScribeUser\n    {\n        @Inject\n        private DriftScribe client;\n\n        @Inject\n        @CustomClient\n        private DriftScribe clientCustom;\n\n        @Inject\n        private DriftClient<DriftScribe> factory;\n\n        @Inject\n        @CustomClient\n        private DriftClient<DriftScribe> factoryCustom;\n\n        public DriftScribe getClient()\n        {\n            return client;\n        }\n\n        public DriftScribe getClientCustom()\n        {\n            return clientCustom;\n        }\n\n        public DriftClient<DriftScribe> getFactory()\n        {\n            return factory;\n        }\n\n        public DriftClient<DriftScribe> getFactoryCustom()\n        {\n            return factoryCustom;\n        }\n    }\n}\n",
        "gt": [
            "'drift/drift-client/src/main/java/io/airlift/drift/client/ExceptionClassifier.java'",
            "'drift/drift-client/src/main/java/io/airlift/drift/client/guice/DriftClientBinder.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ClientTestUtils.java'",
            "'drift/drift-integration-tests/src/test/java/io/airlift/drift/integration/ApacheThriftTesterUtil.java'"
        ]
    },
    {
        "files": [
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'"
        ],
        "content": "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'\n:package com.jnardari.opencv_androidsamples.activities;\n\nimport android.support.v7.app.AppCompatActivity;\nimport java.util.List;\n\nimport org.opencv.android.BaseLoaderCallback;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewFrame;\nimport org.opencv.android.LoaderCallbackInterface;\nimport org.opencv.android.OpenCVLoader;\nimport org.opencv.core.Core;\nimport org.opencv.core.CvType;\nimport org.opencv.core.Mat;\nimport org.opencv.core.MatOfPoint;\nimport org.opencv.core.Rect;\nimport org.opencv.core.Scalar;\nimport org.opencv.core.Size;\nimport org.opencv.android.CameraBridgeViewBase;\nimport org.opencv.android.CameraBridgeViewBase.CvCameraViewListener2;\nimport org.opencv.imgproc.Imgproc;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\nimport android.view.WindowManager;\nimport android.view.View.OnTouchListener;\n\nimport com.jnardari.opencv_androidsamples.R;\nimport com.jnardari.opencv_androidsamples.utils.ColorBlobDetector;\n\npublic class ColorBlobDetectionActivity extends AppCompatActivity implements OnTouchListener, CvCameraViewListener2 {\n    private static final String  TAG              = \"OCVSample::Activity\";\n\n    private boolean              mIsColorSelected = false;\n    private Mat                  mRgba;\n    private Scalar               mBlobColorRgba;\n    private Scalar               mBlobColorHsv;\n    private ColorBlobDetector    mDetector;\n    private Mat                  mSpectrum;\n    private Size                 SPECTRUM_SIZE;\n    private Scalar               CONTOUR_COLOR;\n\n    private CameraBridgeViewBase mOpenCvCameraView;\n\n    private BaseLoaderCallback  mLoaderCallback = new BaseLoaderCallback(this) {\n        @Override\n        public void onManagerConnected(int status) {\n            switch (status) {\n                case LoaderCallbackInterface.SUCCESS:\n                {\n                    Log.i(TAG, \"OpenCV loaded successfully\");\n                    mOpenCvCameraView.enableView();\n                    mOpenCvCameraView.setOnTouchListener(ColorBlobDetectionActivity.this);\n                } break;\n                default:\n                {\n                    super.onManagerConnected(status);\n                } break;\n            }\n        }\n    };\n\n    public ColorBlobDetectionActivity() {\n        Log.i(TAG, \"Instantiated new \" + this.getClass());\n    }\n\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"called onCreate\");\n        super.onCreate(savedInstanceState);\n\n        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);\n\n        setContentView(R.layout.activity_color_blob_detection);\n\n        mOpenCvCameraView = (CameraBridgeViewBase) findViewById(R.id.color_blob_detection_activity_surface_view);\n        mOpenCvCameraView.setCvCameraViewListener(this);\n    }\n\n    @Override\n    public void onPause()\n    {\n        super.onPause();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    @Override\n    public void onResume()\n    {\n        super.onResume();\n        if (!OpenCVLoader.initDebug()) {\n            Log.d(TAG, \"Internal OpenCV library not found. Using OpenCV Manager for initialization\");\n            OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_3_0_0, this, mLoaderCallback);\n        } else {\n            Log.d(TAG, \"OpenCV library found inside package. Using it!\");\n            mLoaderCallback.onManagerConnected(LoaderCallbackInterface.SUCCESS);\n        }\n    }\n\n    public void onDestroy() {\n        super.onDestroy();\n        if (mOpenCvCameraView != null)\n            mOpenCvCameraView.disableView();\n    }\n\n    public void onCameraViewStarted(int width, int height) {\n        mRgba = new Mat(height, width, CvType.CV_8UC4);\n        mDetector = new ColorBlobDetector();\n        mSpectrum = new Mat();\n        mBlobColorRgba = new Scalar(255);\n        mBlobColorHsv = new Scalar(255);\n        SPECTRUM_SIZE = new Size(200, 64);\n        CONTOUR_COLOR = new Scalar(255,0,0,255);\n    }\n\n    public void onCameraViewStopped() {\n        mRgba.release();\n    }\n\n    public boolean onTouch(View v, MotionEvent event) {\n        int cols = mRgba.cols();\n        int rows = mRgba.rows();\n\n        int xOffset = (mOpenCvCameraView.getWidth() - cols) / 2;\n        int yOffset = (mOpenCvCameraView.getHeight() - rows) / 2;\n\n        int x = (int)event.getX() - xOffset;\n        int y = (int)event.getY() - yOffset;\n\n        Log.i(TAG, \"Touch image coordinates: (\" + x + \", \" + y + \")\");\n\n        if ((x < 0) || (y < 0) || (x > cols) || (y > rows)) return false;\n\n        Rect touchedRect = new Rect();\n\n        touchedRect.x = (x>4) ? x-4 : 0;\n        touchedRect.y = (y>4) ? y-4 : 0;\n\n        touchedRect.width = (x+4 < cols) ? x + 4 - touchedRect.x : cols - touchedRect.x;\n        touchedRect.height = (y+4 < rows) ? y + 4 - touchedRect.y : rows - touchedRect.y;\n\n        Mat touchedRegionRgba = mRgba.submat(touchedRect);\n\n        Mat touchedRegionHsv = new Mat();\n        Imgproc.cvtColor(touchedRegionRgba, touchedRegionHsv, Imgproc.COLOR_RGB2HSV_FULL);\n\n\n        mBlobColorHsv = Core.sumElems(touchedRegionHsv);\n        int pointCount = touchedRect.width*touchedRect.height;\n        for (int i = 0; i < mBlobColorHsv.val.length; i++)\n            mBlobColorHsv.val[i] /= pointCount;\n\n        mBlobColorRgba = converScalarHsv2Rgba(mBlobColorHsv);\n\n        Log.i(TAG, \"Touched rgba color: (\" + mBlobColorRgba.val[0] + \", \" + mBlobColorRgba.val[1] +\n                \", \" + mBlobColorRgba.val[2] + \", \" + mBlobColorRgba.val[3] + \")\");\n\n        mDetector.setHsvColor(mBlobColorHsv);\n\n        Imgproc.resize(mDetector.getSpectrum(), mSpectrum, SPECTRUM_SIZE);\n\n        mIsColorSelected = true;\n\n        touchedRegionRgba.release();\n        touchedRegionHsv.release();\n\n        return false;\n    }\n\n    public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n        mRgba = inputFrame.rgba();\n\n        if (mIsColorSelected) {\n            mDetector.process(mRgba);\n            List<MatOfPoint> contours = mDetector.getContours();\n            Log.e(TAG, \"Contours count: \" + contours.size());\n            Imgproc.drawContours(mRgba, contours, -1, CONTOUR_COLOR);\n\n            Mat colorLabel = mRgba.submat(4, 68, 4, 68);\n            colorLabel.setTo(mBlobColorRgba);\n\n            Mat spectrumLabel = mRgba.submat(4, 4 + mSpectrum.rows(), 70, 70 + mSpectrum.cols());\n            mSpectrum.copyTo(spectrumLabel);\n        }\n\n        return mRgba;\n    }\n\n    private Scalar converScalarHsv2Rgba(Scalar hsvColor) {\n        Mat pointMatRgba = new Mat();\n        Mat pointMatHsv = new Mat(1, 1, CvType.CV_8UC3, hsvColor);\n        Imgproc.cvtColor(pointMatHsv, pointMatRgba, Imgproc.COLOR_HSV2RGB_FULL, 4);\n\n        return new Scalar(pointMatRgba.get(0, 0));\n    }\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'\n:\n\n\n\npackage org.opencv.photo;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.opencv.core.Algorithm;\nimport org.opencv.core.Mat;\nimport org.opencv.utils.Converters;\n\n\n\npublic class MergeExposures extends Algorithm {\n\n    protected MergeExposures(long addr) { super(addr); }\n\n\n\n\n\n\n\n    public  void process(List<Mat> src, Mat dst, Mat times, Mat response)\n    {\n        Mat src_mat = Converters.vector_Mat_to_Mat(src);\n        process_0(nativeObj, src_mat.nativeObj, dst.nativeObj, times.nativeObj, response.nativeObj);\n\n        return;\n    }\n\n\n    @Override\n    protected void finalize() throws Throwable {\n        delete(nativeObj);\n    }\n\n\n\n\n    private static native void process_0(long nativeObj, long src_mat_nativeObj, long dst_nativeObj, long times_nativeObj, long response_nativeObj);\n\n\n    private static native void delete(long nativeObj);\n\n}\n\n'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'\n:package org.opencv.android;\n\nimport java.util.List;\n\nimport org.opencv.R;\nimport org.opencv.android.Utils;\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.videoio.Videoio;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.res.TypedArray;\nimport android.graphics.Bitmap;\nimport android.graphics.Canvas;\nimport android.graphics.Rect;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.SurfaceHolder;\nimport android.view.SurfaceView;\n\n\npublic abstract class CameraBridgeViewBase extends SurfaceView implements SurfaceHolder.Callback {\n\n    private static final String TAG = \"CameraBridge\";\n    private static final int MAX_UNSPECIFIED = -1;\n    private static final int STOPPED = 0;\n    private static final int STARTED = 1;\n\n    private int mState = STOPPED;\n    private Bitmap mCacheBitmap;\n    private CvCameraViewListener2 mListener;\n    private boolean mSurfaceExist;\n    private Object mSyncObject = new Object();\n\n    protected int mFrameWidth;\n    protected int mFrameHeight;\n    protected int mMaxHeight;\n    protected int mMaxWidth;\n    protected float mScale = 0;\n    protected int mPreviewFormat = RGBA;\n    protected int mCameraIndex = CAMERA_ID_ANY;\n    protected boolean mEnabled;\n    protected FpsMeter mFpsMeter = null;\n\n    public static final int CAMERA_ID_ANY   = -1;\n    public static final int CAMERA_ID_BACK  = 99;\n    public static final int CAMERA_ID_FRONT = 98;\n    public static final int RGBA = 1;\n    public static final int GRAY = 2;\n\n    public CameraBridgeViewBase(Context context, int cameraId) {\n        super(context);\n        mCameraIndex = cameraId;\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n    }\n\n    public CameraBridgeViewBase(Context context, AttributeSet attrs) {\n        super(context, attrs);\n\n        int count = attrs.getAttributeCount();\n        Log.d(TAG, \"Attr count: \" + Integer.valueOf(count));\n\n        TypedArray styledAttrs = getContext().obtainStyledAttributes(attrs, R.styleable.CameraBridgeViewBase);\n        if (styledAttrs.getBoolean(R.styleable.CameraBridgeViewBase_show_fps, false))\n            enableFpsMeter();\n\n        mCameraIndex = styledAttrs.getInt(R.styleable.CameraBridgeViewBase_camera_id, -1);\n\n        getHolder().addCallback(this);\n        mMaxWidth = MAX_UNSPECIFIED;\n        mMaxHeight = MAX_UNSPECIFIED;\n        styledAttrs.recycle();\n    }\n\n\n    public void setCameraIndex(int cameraIndex) {\n        this.mCameraIndex = cameraIndex;\n    }\n\n    public interface CvCameraViewListener {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(Mat inputFrame);\n    }\n\n    public interface CvCameraViewListener2 {\n\n        public void onCameraViewStarted(int width, int height);\n\n\n        public void onCameraViewStopped();\n\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame);\n    };\n\n    protected class CvCameraViewListenerAdapter implements CvCameraViewListener2  {\n        public CvCameraViewListenerAdapter(CvCameraViewListener oldStypeListener) {\n            mOldStyleListener = oldStypeListener;\n        }\n\n        public void onCameraViewStarted(int width, int height) {\n            mOldStyleListener.onCameraViewStarted(width, height);\n        }\n\n        public void onCameraViewStopped() {\n            mOldStyleListener.onCameraViewStopped();\n        }\n\n        public Mat onCameraFrame(CvCameraViewFrame inputFrame) {\n             Mat result = null;\n             switch (mPreviewFormat) {\n                case RGBA:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.rgba());\n                    break;\n                case GRAY:\n                    result = mOldStyleListener.onCameraFrame(inputFrame.gray());\n                    break;\n                default:\n                    Log.e(TAG, \"Invalid frame format! Only RGBA and Gray Scale are supported!\");\n            };\n\n            return result;\n        }\n\n        public void setFrameFormat(int format) {\n            mPreviewFormat = format;\n        }\n\n        private int mPreviewFormat = RGBA;\n        private CvCameraViewListener mOldStyleListener;\n    };\n\n\n    public interface CvCameraViewFrame {\n\n\n        public Mat rgba();\n\n\n        public Mat gray();\n    };\n\n    public void surfaceChanged(SurfaceHolder arg0, int arg1, int arg2, int arg3) {\n        Log.d(TAG, \"call surfaceChanged event\");\n        synchronized(mSyncObject) {\n            if (!mSurfaceExist) {\n                mSurfaceExist = true;\n                checkCurrentState();\n            } else {\n\n\n                mSurfaceExist = false;\n                checkCurrentState();\n\n                mSurfaceExist = true;\n                checkCurrentState();\n            }\n        }\n    }\n\n    public void surfaceCreated(SurfaceHolder holder) {\n\n    }\n\n    public void surfaceDestroyed(SurfaceHolder holder) {\n        synchronized(mSyncObject) {\n            mSurfaceExist = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableView() {\n        synchronized(mSyncObject) {\n            mEnabled = true;\n            checkCurrentState();\n        }\n    }\n\n\n    public void disableView() {\n        synchronized(mSyncObject) {\n            mEnabled = false;\n            checkCurrentState();\n        }\n    }\n\n\n    public void enableFpsMeter() {\n        if (mFpsMeter == null) {\n            mFpsMeter = new FpsMeter();\n            mFpsMeter.setResolution(mFrameWidth, mFrameHeight);\n        }\n    }\n\n    public void disableFpsMeter() {\n            mFpsMeter = null;\n    }\n\n\n\n    public void setCvCameraViewListener(CvCameraViewListener2 listener) {\n        mListener = listener;\n    }\n\n    public void setCvCameraViewListener(CvCameraViewListener listener) {\n        CvCameraViewListenerAdapter adapter = new CvCameraViewListenerAdapter(listener);\n        adapter.setFrameFormat(mPreviewFormat);\n        mListener = adapter;\n    }\n\n\n    public void setMaxFrameSize(int maxWidth, int maxHeight) {\n        mMaxWidth = maxWidth;\n        mMaxHeight = maxHeight;\n    }\n\n    public void SetCaptureFormat(int format)\n    {\n        mPreviewFormat = format;\n        if (mListener instanceof CvCameraViewListenerAdapter) {\n            CvCameraViewListenerAdapter adapter = (CvCameraViewListenerAdapter) mListener;\n            adapter.setFrameFormat(mPreviewFormat);\n        }\n    }\n\n\n    private void checkCurrentState() {\n        Log.d(TAG, \"call checkCurrentState\");\n        int targetState;\n\n        if (mEnabled && mSurfaceExist && getVisibility() == VISIBLE) {\n            targetState = STARTED;\n        } else {\n            targetState = STOPPED;\n        }\n\n        if (targetState != mState) {\n\n            processExitState(mState);\n            mState = targetState;\n            processEnterState(mState);\n        }\n    }\n\n    private void processEnterState(int state) {\n        Log.d(TAG, \"call processEnterState: \" + state);\n        switch(state) {\n        case STARTED:\n            onEnterStartedState();\n            if (mListener != null) {\n                mListener.onCameraViewStarted(mFrameWidth, mFrameHeight);\n            }\n            break;\n        case STOPPED:\n            onEnterStoppedState();\n            if (mListener != null) {\n                mListener.onCameraViewStopped();\n            }\n            break;\n        };\n    }\n\n    private void processExitState(int state) {\n        Log.d(TAG, \"call processExitState: \" + state);\n        switch(state) {\n        case STARTED:\n            onExitStartedState();\n            break;\n        case STOPPED:\n            onExitStoppedState();\n            break;\n        };\n    }\n\n    private void onEnterStoppedState() {\n\n    }\n\n    private void onExitStoppedState() {\n\n    }\n\n\n\n    private void onEnterStartedState() {\n        Log.d(TAG, \"call onEnterStartedState\");\n\n        if (!connectCamera(getWidth(), getHeight())) {\n            AlertDialog ad = new AlertDialog.Builder(getContext()).create();\n            ad.setCancelable(false);\n            ad.setMessage(\"It seems that you device does not support camera (or it is locked). Application will be closed.\");\n            ad.setButton(DialogInterface.BUTTON_NEUTRAL,  \"OK\", new DialogInterface.OnClickListener() {\n                public void onClick(DialogInterface dialog, int which) {\n                    dialog.dismiss();\n                    ((Activity) getContext()).finish();\n                }\n            });\n            ad.show();\n\n        }\n    }\n\n    private void onExitStartedState() {\n        disconnectCamera();\n        if (mCacheBitmap != null) {\n            mCacheBitmap.recycle();\n        }\n    }\n\n\n    protected void deliverAndDrawFrame(CvCameraViewFrame frame) {\n        Mat modified;\n\n        if (mListener != null) {\n            modified = mListener.onCameraFrame(frame);\n        } else {\n            modified = frame.rgba();\n        }\n\n        boolean bmpValid = true;\n        if (modified != null) {\n            try {\n                Utils.matToBitmap(modified, mCacheBitmap);\n            } catch(Exception e) {\n                Log.e(TAG, \"Mat type: \" + modified);\n                Log.e(TAG, \"Bitmap type: \" + mCacheBitmap.getWidth() + \"*\" + mCacheBitmap.getHeight());\n                Log.e(TAG, \"Utils.matToBitmap() throws an exception: \" + e.getMessage());\n                bmpValid = false;\n            }\n        }\n\n        if (bmpValid && mCacheBitmap != null) {\n            Canvas canvas = getHolder().lockCanvas();\n            if (canvas != null) {\n                canvas.drawColor(0, android.graphics.PorterDuff.Mode.CLEAR);\n                Log.d(TAG, \"mStretch value: \" + mScale);\n\n                if (mScale != 0) {\n                    canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2),\n                         (int)((canvas.getWidth() - mScale*mCacheBitmap.getWidth()) / 2 + mScale*mCacheBitmap.getWidth()),\n                         (int)((canvas.getHeight() - mScale*mCacheBitmap.getHeight()) / 2 + mScale*mCacheBitmap.getHeight())), null);\n                } else {\n                     canvas.drawBitmap(mCacheBitmap, new Rect(0,0,mCacheBitmap.getWidth(), mCacheBitmap.getHeight()),\n                         new Rect((canvas.getWidth() - mCacheBitmap.getWidth()) / 2,\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2,\n                         (canvas.getWidth() - mCacheBitmap.getWidth()) / 2 + mCacheBitmap.getWidth(),\n                         (canvas.getHeight() - mCacheBitmap.getHeight()) / 2 + mCacheBitmap.getHeight()), null);\n                }\n\n                if (mFpsMeter != null) {\n                    mFpsMeter.measure();\n                    mFpsMeter.draw(canvas, 20, 30);\n                }\n                getHolder().unlockCanvasAndPost(canvas);\n            }\n        }\n    }\n\n\n    protected abstract boolean connectCamera(int width, int height);\n\n\n    protected abstract void disconnectCamera();\n\n\n    protected void AllocateCache()\n    {\n        mCacheBitmap = Bitmap.createBitmap(mFrameWidth, mFrameHeight, Bitmap.Config.ARGB_8888);\n    }\n\n    public interface ListItemAccessor {\n        public int getWidth(Object obj);\n        public int getHeight(Object obj);\n    };\n\n\n    protected Size calculateCameraFrameSize(List<?> supportedSizes, ListItemAccessor accessor, int surfaceWidth, int surfaceHeight) {\n        int calcWidth = 0;\n        int calcHeight = 0;\n\n        int maxAllowedWidth = (mMaxWidth != MAX_UNSPECIFIED && mMaxWidth < surfaceWidth)? mMaxWidth : surfaceWidth;\n        int maxAllowedHeight = (mMaxHeight != MAX_UNSPECIFIED && mMaxHeight < surfaceHeight)? mMaxHeight : surfaceHeight;\n\n        for (Object size : supportedSizes) {\n            int width = accessor.getWidth(size);\n            int height = accessor.getHeight(size);\n\n            if (width <= maxAllowedWidth && height <= maxAllowedHeight) {\n                if (width >= calcWidth && height >= calcHeight) {\n                    calcWidth = (int) width;\n                    calcHeight = (int) height;\n                }\n            }\n        }\n\n        return new Size(calcWidth, calcHeight);\n    }\n}\n",
        "gt": [
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/photo/MergeExposures.java'",
            "'OpenCV-AndroidSamples/libraries/opencv/src/org/opencv/android/CameraBridgeViewBase.java'",
            "'OpenCV-AndroidSamples/app/src/main/java/com/jnardari/opencv_androidsamples/activities/ColorBlobDetectionActivity.java'"
        ]
    }
]