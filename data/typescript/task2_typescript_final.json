[
    {
        "files": [
            "'near-social-bridge/examples/dapp-bos-tutorial/src/components/TaskItem.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/components/TodoList.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/App.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/index.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/services/getTasks.ts'"
        ],
        "content": "'near-social-bridge/examples/dapp-bos-tutorial/src/components/TaskItem.tsx'\n:\nimport { Task } from \"../services/getTasks\";\n\ntype Props = {\n  task: Task;\n  completeTaskHandler: (task: Task) => void;\n  removeTaskHandler: (task: Task) => void;\n};\n\nconst TaskItem: React.FC<Props> = ({\n  task,\n  completeTaskHandler,\n  removeTaskHandler,\n}) => {\n  return (\n    <div\n      style={{\n        display: \"flex\",\n        alignItems: \"center\",\n        marginTop: \"8px\",\n      }}\n    >\n      <p\n        style={{\n          margin: \"0 8px 0 0\",\n          opacity: task.finished ? \"0.3\" : \"1\",\n        }}\n      >\n        {task.description}\n      </p>\n      <input\n        style={{\n          marginRight: \"8px\",\n          opacity: task.finished ? \"0.3\" : \"1\",\n        }}\n        type=\"checkbox\"\n        checked={task.finished}\n        onChange={() => completeTaskHandler(task)}\n      />\n      <button onClick={() => removeTaskHandler(task)}>Remove</button>\n    </div>\n  );\n};\n\nexport default TaskItem;\n\n'near-social-bridge/examples/dapp-bos-tutorial/src/components/TodoList.tsx'\n:\nimport { useCallback, useEffect, useState } from 'react'\nimport { useAuth } from 'near-social-bridge/auth'\nimport NewTodoForm from './NewTodoForm'\nimport TaskItem from './TaskItem'\nimport getTasks, { Task } from '../services/getTasks'\nimport storeTasks from '../services/storeTasks'\n\nconst TodoList = () => {\n  const [status, setStatus] = useState<'ready' | 'loading' | 'saving'>('loading')\n  const [taskDescription, setTaskDescription] = useState('')\n  const [tasks, setTasks] = useState<Task[]>([])\n  const auth = useAuth()\n\n\n  useEffect(() => {\n    if (auth.ready) {\n      getTasks(auth.user?.accountId!).then((tasks) => {\n        setTasks(tasks)\n        setStatus('ready')\n      })\n    }\n  }, [auth])\n\n  const persistUpdatedData = useCallback(\n    async (tasksList?: Task[]) => {\n      const updatedTasks = tasksList\n        ? tasksList\n        : [...tasks, { id: Date.now(), description: taskDescription, finished: false }]\n      setStatus('saving')\n\n      const result = await storeTasks(updatedTasks, auth.user?.accountId!)\n      if (!result.error) {\n        setTasks(updatedTasks)\n      }\n      setTaskDescription('')\n      setStatus('ready')\n    },\n    [taskDescription, tasks, auth]\n  )\n\n  const completeTaskHandler = (task: Task) => {\n    const updatedTasks = tasks.map((taskItem) => {\n      if (taskItem.id === task.id) {\n        taskItem.finished = !taskItem.finished\n      }\n      return taskItem\n    })\n\n\n    persistUpdatedData(updatedTasks)\n  }\n\n  const removeTaskHandler = (task: Task) => {\n    const updatedTasks = tasks.filter((taskItem) => taskItem.id !== task.id)\n\n    persistUpdatedData(updatedTasks)\n  }\n\n  return (\n    <div style={{ display: 'flex', justifyContent: 'center', flexDirection: 'column' }}>\n      {tasks.length === 0 && status === 'ready' && <p>No Tasks yet!</p>}\n      {status !== 'ready' ? (\n        <p>{status}...</p>\n      ) : (\n        <>\n          {tasks.map((task) => (\n            <TaskItem\n              key={task.id}\n              task={task}\n              completeTaskHandler={completeTaskHandler}\n              removeTaskHandler={removeTaskHandler}\n            />\n          ))}\n          <br />\n          <NewTodoForm\n            taskDescription={taskDescription}\n            onInputChange={(inputValue) => setTaskDescription(inputValue)}\n            onAddClick={() => persistUpdatedData()}\n          />\n        </>\n      )}\n    </div>\n  )\n}\n\nexport default TodoList\n\n'near-social-bridge/examples/dapp-bos-tutorial/src/App.tsx'\n:import { useAuth } from \"near-social-bridge\";\nimport TodoList from \"./components/TodoList\";\nimport NotLoggedInWarning from \"./components/NotLoggedInWarning\";\n\nfunction App() {\n  const auth = useAuth();\n\n  return (\n    <div className=\"App\">\n      <h3>Web3 - Todo App</h3>\n\n      {auth.user ? <TodoList /> : <NotLoggedInWarning />}\n    </div>\n  );\n}\n\nexport default App;\n\n'near-social-bridge/examples/dapp-bos-tutorial/src/index.tsx'\n:\nimport ReactDOM from 'react-dom/client'\nimport './index.css'\nimport 'near-social-bridge/near-social-bridge.css'\n\nimport App from './App'\nimport { NearSocialBridgeProvider, Spinner } from 'near-social-bridge'\n\nconst root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)\nroot.render(\n  <NearSocialBridgeProvider fallback={<Spinner />}>\n    <App />\n  </NearSocialBridgeProvider>\n)\n\n'near-social-bridge/examples/dapp-bos-tutorial/src/services/getTasks.ts'\n:\nimport { Social } from \"near-social-bridge/api\";\n\nexport interface Task {\n  id: number;\n  finished: boolean;\n  description: string;\n}\n\ntype TasksIndex = {\n  value: Task[];\n}[];\n\n\nconst getTasks = async (accountId: string) => {\n  const response = await Social.index<TasksIndex>(\n    `todo-app-${accountId}`,\n    \"tasks\",\n    {\n      limit: 1,\n      order: \"desc\",\n    }\n  );\n\n  if (Array.isArray(response) && response[0]) {\n    return response[0].value;\n  }\n\n  return [];\n};\n\nexport default getTasks;\n",
        "gt": [
            "'near-social-bridge/examples/dapp-bos-tutorial/src/services/getTasks.ts'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/components/TaskItem.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/components/TodoList.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/App.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'factura-front/src/app/auth/auth.service.ts'",
            "'factura-front/src/app/models/user.model.ts'",
            "'factura-front/src/app/nav/nav.component.ts'",
            "'factura-front/src/app/services/log-user-service.service.ts'",
            "'factura-front/src/app/nav/nav.component.spec.ts'",
            "'factura-front/src/app/models/activityLog.model.ts'"
        ],
        "content": "'factura-front/src/app/auth/auth.service.ts'\n:import { Injectable } from '@angular/core';\nimport { HttpClient, HttpErrorResponse} from '@angular/common/http';\nimport { throwError, BehaviorSubject} from 'rxjs';\nimport { catchError, tap } from 'rxjs/operators';\nimport { Router } from '@angular/router';\nimport { AuthResponse } from '../models/authRes.model';\nimport {HTTP_START} from '../constants';\nimport { ClientService } from '../services/client.service';\nimport { UserService } from '../services/user.service';\nimport { ProductService } from '../services/product.service';\nimport { DevisService } from '../services/devis.service';\nimport { LogUserService} from '../services/log-user-service.service';\n\n@Injectable({providedIn:'root'})\nexport class AuthService{\n    user=new BehaviorSubject<AuthResponse>(null);\n    public error=new BehaviorSubject<string>(null);\n    private tokenExpirationTimer:any;\n    constructor(\n        private http:HttpClient,\n        private router:Router,\n        private clientService:ClientService,\n        private userService:UserService,\n        private productService:ProductService,\n        private devisService:DevisService,\n        private logService:LogUserService\n        ){}\n    private loadAuthUserData(){\n        this.userService.getUsers();\n        this.clientService.getClients();\n        this.productService.getProducts();\n        this.devisService.getDevis();\n        this.logService.getLogsUsers();\n    }\n    logout(){\n        this.user.next(null);\n        localStorage.removeItem('userData'),\n        this.router.navigate(['/']);\n        if(this.tokenExpirationTimer){\n            clearTimeout(this.tokenExpirationTimer);\n        }\n        this.tokenExpirationTimer=null;\n    }\n    autoLogout(expirationDuration:number){\n        console.log(expirationDuration);\n        this.tokenExpirationTimer=setTimeout(()=>{\n            this.logout();\n        },expirationDuration)\n    }\n\n    signIn(email:string,password:string){\n\n        return this.http.post<AuthResponse>(HTTP_START+'auth',\"\",{\n            params:{\n                email:email,\n                password:password\n            }\n        }).pipe(catchError(err=>this.handelError(err)),tap(resData=>{\n            this.handleAuth(\n                resData\n             )\n         }))\n    }\n    private handleAuth(res:AuthResponse){\n        this.user.next(res);\n        this.autoLogout(this.getDurationAuth(new Date(this.user.getValue().expirationDate)));\n        localStorage.setItem('userData',JSON.stringify(res));\n        this.loadAuthUserData();\n    }\n\n    autoLogin(){\n       const userData:AuthResponse= JSON.parse(localStorage.getItem('userData'));\n       if(!userData){\n           return;\n       }\n       const loadedUser=userData;\n       if(loadedUser.jwt){\n          this.user.next(loadedUser);\n            this.autoLogout(this.getDurationAuth(new Date(this.user.getValue().expirationDate)));\n            this.loadAuthUserData();\n       }\n    }\n    private handelError(errorRes:HttpErrorResponse){\n        let error='An unknow error';\n        console.log(errorRes.error.message);\n        if(errorRes.error.message){\n            error=errorRes.error.message;\n        }\n        this.error.next(error);\n        return throwError(error);\n    }\n    private getDurationAuth(expiration:Date){\n        let date=new Date();\n        return  Math.floor(\n            (\n                Date.UTC(\n                    expiration.getFullYear(),\n                    expiration.getMonth(),\n                    expiration.getDate(),\n                    expiration.getHours(),\n                    expiration.getMinutes(),\n                    expiration.getSeconds(),\n                    expiration.getMilliseconds()\n                    )-\n                    Date.UTC(\n                        date.getFullYear(),\n                        date.getMonth(),\n                        date.getDate(),\n                        date.getHours(),\n                        date.getMinutes(),\n                        date.getSeconds(),\n                        date.getMilliseconds()\n                        )\n            ));\n    }\n}\n'factura-front/src/app/models/user.model.ts'\n:export class User{\n    constructor(\n        public id:number,\n        public email:string,\n        public name:string,\n        public phone:string,\n        public role:string,\n        public cin:string,\n        public password:string,\n        public specialty:string,\n        public active:boolean,\n        public avatar:any,\n        public adminUser?:User\n    ){}\n\n}\n'factura-front/src/app/nav/nav.component.ts'\n:import { Component, ElementRef, EventEmitter, OnInit, Output, ViewChild } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { Router } from '@angular/router';\nimport { AuthService } from '../auth/auth.service';\nimport { AuthResponse } from '../models/authRes.model';\n\n@Component({\n  selector: 'navBar',\n  templateUrl: './nav.component.html',\n  styleUrls: ['./nav.component.scss']\n})\nexport class NavComponent implements OnInit {\n  @Output() scroll:EventEmitter<boolean>=new EventEmitter();\n  user:AuthResponse=null;\n  userAvatar:any;\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n  scrollDown(){\n    this.scroll.emit();\n  }\n\n}\n\n'factura-front/src/app/services/log-user-service.service.ts'\n:import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\nimport {HTTP_START} from '../constants';\nimport { ActivityLog } from '../models/activityLog.model';\n@Injectable({\n  providedIn: 'root'\n})\nexport class LogUserService {\n  activityLogs=new BehaviorSubject<ActivityLog[]>([]);\n  constructor(private http:HttpClient) {}\n  public getLogsUsers(){\n    this.http.get<ActivityLog[]>(HTTP_START+'admin/logs').subscribe(res=>{\n      if(res){\n        console.log(res)\n        this.activityLogs.next(res);\n      }\n    })\n  }\n}\n\n'factura-front/src/app/nav/nav.component.spec.ts'\n:import { ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { NavComponent } from './nav.component';\n\ndescribe('NavComponent', () => {\n  let component: NavComponent;\n  let fixture: ComponentFixture<NavComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [ NavComponent ]\n    })\n    .compileComponents();\n  });\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(NavComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n\n'factura-front/src/app/models/activityLog.model.ts'\n:import { User } from './user.model';\n\nexport class ActivityLog{\n    constructor(\n        public id:number,\n        public date:Date,\n        public user:User,\n        public action:string,\n        public detail:string\n    ){}\n}",
        "gt": [
            "'factura-front/src/app/models/user.model.ts'",
            "'factura-front/src/app/models/activityLog.model.ts'",
            "'factura-front/src/app/services/log-user-service.service.ts'",
            "'factura-front/src/app/auth/auth.service.ts'",
            "'factura-front/src/app/nav/nav.component.ts'",
            "'factura-front/src/app/nav/nav.component.spec.ts'"
        ]
    },
    {
        "files": [
            "'koa-crud-backend/src/index.ts'",
            "'koa-crud-backend/src/api/user/userDelete.ts'",
            "'koa-crud-backend/src/app.ts'",
            "'koa-crud-backend/src/api/apiHelpers.ts'"
        ],
        "content": "'koa-crud-backend/src/index.ts'\n:import \"isomorphic-fetch\";\nimport { createServer } from \"http\";\nimport app from \"./app\";\nimport { config } from \"./config\";\nimport { connectDatabase } from \"./mongo\";\n\n(async () => {\n  await connectDatabase();\n\n  const server = createServer(app.callback());\n\n  server.listen(config.PORT, () => {\n    console.log(`server running at http:\n  });\n})();\n\n'koa-crud-backend/src/api/user/userDelete.ts'\n:import { checkObjectId } from \"../apiHelpers\";\nimport User from \"../../modules/user/UserModel\";\nimport { getUserApi } from \"./userGet\";\n\nexport const userDelete = async (ctx) => {\n  const { id } = ctx.params;\n\n  const _id = checkObjectId(id);\n\n  if (!_id) {\n    ctx.status = 400;\n    ctx.body = {\n      message: \"User not found\",\n    };\n    return;\n  }\n\n  const user = await User.findOne({\n    _id,\n    removedAt: null,\n  });\n\n  if (!user) {\n    ctx.status = 400;\n    ctx.body = {\n      message: \"User not found\",\n    };\n    return;\n  }\n\n  try {\n    await User.updateOne(\n      {\n        _id: user._id,\n      },\n      {\n        $set: {\n          removedAt: new Date(),\n        },\n      }\n    );\n\n    const { user: userUpdated, error } = await getUserApi(user._id);\n\n    if (error) {\n      ctx.status = 400;\n      ctx.body = {\n        message: \"Error while deleting user\",\n      };\n      return;\n    }\n\n    ctx.status = 200;\n    ctx.body = {\n      user: userUpdated,\n    };\n  } catch (err) {\n\n    console.log(\"err: \", err);\n\n    ctx.status = 500;\n    ctx.body = {\n      message: \"Unknown error\",\n    };\n  }\n};\n\n'koa-crud-backend/src/app.ts'\n:import Koa from \"koa\";\nimport bodyParser from \"koa-bodyparser\";\nimport logger from \"koa-logger\";\nimport Router from \"koa-router\";\nimport cors from \"koa-cors\";\n\nimport { version } from \"../package.json\";\nimport { userGet } from \"./api/user/userGet\";\nimport { userPost } from \"./api/user/userPost\";\nimport { userGetAll } from \"./api/user/userGetAll\";\nimport { userDelete } from \"./api/user/userDelete\";\n\nimport { authLogin } from \"./api/auth/authLogin\";\n\nimport { auth } from \"./auth/auth\";\nconst app = new Koa();\n\nconst router = new Router();\n\nconst routerAuth = new Router();\nconst routerOpen = new Router();\n\napp.use(logger());\napp.use(cors({ maxAge: 86400 }));\napp.use(bodyParser());\n\n\nrouterOpen.get(\"/api/version\", (ctx) => {\n  ctx.status = 200;\n  ctx.body = {\n    status: \"OK\",\n    version,\n  };\n});\n\n\nrouterOpen.post(\"/api/auth/login\", authLogin);\n\napp.use(routerOpen.routes());\n\n\n\nrouterAuth.use(auth);\n\n\nrouterAuth.post(\"/api/user\", userPost);\nrouterAuth.get(\"/api/user\", userGetAll);\nrouterAuth.get(\"/api/user/:id\", userGet);\nrouterAuth.delete(\"/api/user/:id\", userDelete);\n\napp.use(routerAuth.routes());\n\n\napp.use((ctx) => {\n  ctx.status = 404;\n});\n\nexport default app;\n\n'koa-crud-backend/src/api/apiHelpers.ts'\n:import { Model, Types } from \"mongoose\";\nimport { Context } from \"koa\";\nimport { getObjectId } from \"../../test\";\n\nexport const getSkipAndLimit = (ctx: Context) => {\n  const { skip = 0, limit = 100 } = ctx.query;\n\n  if (skip < 0 || limit < 0) {\n    return {\n      skip: null,\n      limit: null,\n      errors: [\n        {\n          data: { skip, limit },\n          message: \"Pagination values should be positive values\",\n        },\n      ],\n    };\n  }\n\n  const mongoLimit = Math.min(parseInt(limit, 10), 100);\n  const mongoSkip = parseInt(skip, 10);\n\n  return {\n    skip: mongoSkip,\n    limit: mongoLimit,\n    errors: null,\n  };\n};\n\ntype ErrorValidate = {\n  data: {};\n  message: string;\n};\n\ntype PageInfo = {\n  errors?: ErrorValidate[];\n  skip: number;\n  limit: number;\n  totalCount: number;\n  hasPreviousPage: number;\n  hasNextPage: number;\n};\n\nexport const getPageInfo = async (ctx: Context, model: Model): PageInfo => {\n  const { skip, limit, errors } = getSkipAndLimit(ctx);\n\n  if (errors) {\n    return {\n      errors,\n      skip,\n      limit,\n      totalCount: null,\n      hasPreviousPage: null,\n      hasNextPage: null,\n    };\n  }\n\n  const conditionsTotalCount = {\n    removedAt: null,\n  };\n\n  const totalCount = await model.count(conditionsTotalCount);\n\n  const hasPreviousPage = skip > 0;\n  const hasNextPage = skip + limit < totalCount;\n\n  return {\n    skip,\n    limit,\n    totalCount,\n    hasPreviousPage,\n    hasNextPage,\n  };\n};\n\nexport const checkObjectId = (id: string) => {\n  if (!Types.ObjectId.isValid(id)) {\n    return null;\n  }\n\n  return getObjectId(id);\n};\n",
        "gt": [
            "'koa-crud-backend/src/api/apiHelpers.ts'",
            "'koa-crud-backend/src/api/user/userDelete.ts'",
            "'koa-crud-backend/src/app.ts'",
            "'koa-crud-backend/src/index.ts'"
        ]
    },
    {
        "files": [
            "'rules/apps/doc-app/src/app/components/doc-page/doc-page.component.ts'",
            "'rules/apps/doc-app/src/app/app.module.ts'",
            "'rules/apps/doc-app/src/app/app-routing.module.ts'",
            "'rules/apps/doc-app/src/app/components/doc-page/doc-page.module.ts'",
            "'rules/apps/doc-app/src/app/app.routing.ts'"
        ],
        "content": "'rules/apps/doc-app/src/app/components/doc-page/doc-page.component.ts'\n:import {Component} from '@angular/core';\nimport {ActivatedRoute} from '@angular/router';\n\n@Component({\n  selector: 'app-doc-page',\n  template: `\n    <app-markdown [mdFile]=\"mdFile\"></app-markdown>`\n})\nexport class DocPageComponent {\n  mdFile: string = 'assets/docs/getting-started.doc.md';\n\n  constructor(public router: ActivatedRoute) {\n    this.mdFile = router.snapshot.data.path;\n  }\n}\n\n'rules/apps/doc-app/src/app/app.module.ts'\n:import {NgModule} from '@angular/core';\nimport {BrowserModule} from '@angular/platform-browser';\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\nimport {HttpClientModule} from '@angular/common/http';\n\nimport {AppRoutingModule} from './app-routing.module';\nimport {AppComponent} from './app.component';\nimport {HeaderComponent} from './layout/header/header.component';\nimport {FooterComponent} from './layout/footer/footer.component';\nimport {SidebarComponent} from './layout/sidebar/sidebar.component';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatListModule } from '@angular/material/list';\nimport { MatSidenavModule } from '@angular/material/sidenav';\nimport { MatToolbarModule } from '@angular/material/toolbar';\nimport {AsideNavComponent} from './layout/aside-nav/aside-nav.component';\nimport {NgxPageScrollCoreModule} from 'ngx-page-scroll-core';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    SidebarComponent,\n    AsideNavComponent\n  ],\n  imports: [\n    BrowserModule,\n    BrowserAnimationsModule,\n    AppRoutingModule,\n    MatIconModule,\n    MatSidenavModule,\n    MatListModule,\n    HttpClientModule,\n    MatToolbarModule,\n    NgxPageScrollCoreModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n\n'rules/apps/doc-app/src/app/app-routing.module.ts'\n:import { NgModule } from '@angular/core';\nimport { RouterModule } from '@angular/router';\n\nimport { routes } from './app.routing';\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes, { useHash: true, relativeLinkResolution: 'legacy' })],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n\n'rules/apps/doc-app/src/app/components/doc-page/doc-page.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { DocPageRoutingModule } from './doc-page-routing.module';\nimport { DocPageComponent } from './doc-page.component';\nimport { MarkdownModule } from '../../layout/markdown/markdown.module';\n\n@NgModule({\n  declarations: [\n    DocPageComponent\n  ],\n  imports: [\n    CommonModule,\n    DocPageRoutingModule,\n    MarkdownModule\n  ],\n})\nexport class DocPageModule { }\n\n'rules/apps/doc-app/src/app/app.routing.ts'\n:import { Routes } from '@angular/router';\n\nexport const routes: Routes = [\n  {\n    path: 'getting-started',\n    loadChildren: () => import('./components/doc-page/doc-page.module').then(m => m.DocPageModule),\n    data: { title: 'Getting Started' , path: 'assets/docs/getting-started.md'}\n  },\n  {\n    path: 'oss-rules',\n    loadChildren: () => import('./components/doc-page/doc-page.module').then(m => m.DocPageModule),\n    data: { title: 'OSS Rules' , path: 'assets/docs/oss-rules.md'}\n  },\n  {\n    path: 'oss-syntax',\n    loadChildren: () => import('./components/doc-page/doc-page.module').then(m => m.DocPageModule),\n    data: { title: 'OSS Syntax', path: 'assets/docs/oss-syntax.md'}\n  },\n  {\n    path: 'metaui-architecture',\n    loadChildren: () => import('./components/doc-page/doc-page.module').then(m => m.DocPageModule),\n    data: { title: 'MetaUI Architecture' , path: 'assets/docs/metaui-architecture.md'}\n  },\n  {\n    path: '',\n    redirectTo: 'getting-started',\n    pathMatch: 'full',\n  }\n];\n",
        "gt": [
            "'rules/apps/doc-app/src/app/components/doc-page/doc-page.component.ts'",
            "'rules/apps/doc-app/src/app/components/doc-page/doc-page.module.ts'",
            "'rules/apps/doc-app/src/app/app.routing.ts'",
            "'rules/apps/doc-app/src/app/app-routing.module.ts'",
            "'rules/apps/doc-app/src/app/app.module.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/auth/auth.guard.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/api-key/api-key.controller.ts'",
            "'is-even/apps/backend/src/api-key/api-key.module.ts'",
            "'is-even/apps/backend/src/auth/auth.decorator.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ],
        "content": "'is-even/apps/backend/src/auth/auth.guard.ts'\n:import { AuthGuard } from '@nestjs/passport';\n\nexport class JwtAuthGuard extends AuthGuard('jwt') {}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n\n'is-even/apps/backend/src/api-key/api-key.controller.ts'\n:import {\n  Controller,\n  Post,\n  HttpStatus,\n  HttpException,\n  Request,\n  Body,\n  Get,\n  Delete,\n  ParseUUIDPipe,\n  Param,\n  HttpCode,\n} from '@nestjs/common';\nimport { ApiTags, ApiResponse } from '@nestjs/swagger';\n\nimport { RequestWithUser } from '../common/interface/request-with-user.interface';\nimport { Authorised } from '../auth/auth.decorator';\nimport { ApiKeyService } from './api-key.service';\nimport { CreateApiKeyDto } from './dto/create-api-key.dto';\nimport { ApiKeyDto } from './dto/api-key.dto';\nimport { NotFoundApiKeyError } from './error/not-found-api-key.error';\nimport { UnathorizedApiKeyError } from './error/unathorized-api-key.error';\n\n@Controller('api-keys')\nexport class ApiKeyController {\n  constructor(private readonly apiKeyService: ApiKeyService) {}\n\n  @Post('/')\n  @Authorised()\n  @ApiTags('api-keys')\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'API Key has been successfully created',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async createApiKey(\n    @Request() request: RequestWithUser,\n    @Body() createApiKeyDto: CreateApiKeyDto,\n  ): Promise<ApiKeyDto> {\n    try {\n      const user = request.user;\n      const name = createApiKeyDto.name;\n\n      const apiKey = await this.apiKeyService.createApiKey(name, user);\n      return ApiKeyDto.createFromApiKey(apiKey);\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Get('/')\n  @Authorised()\n  @ApiTags('api-keys')\n  @ApiResponse({\n    type: ApiKeyDto,\n    isArray: true,\n    status: HttpStatus.OK,\n    description: 'API Key has been successfully retrieved',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  public async getApiKeys(\n    @Request() request: RequestWithUser,\n  ): Promise<ApiKeyDto[]> {\n    try {\n      const user = request.user;\n      const apiKeys = await this.apiKeyService.readApiKeys(user);\n\n      return apiKeys.map((key) => ApiKeyDto.createFromApiKey(key));\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Delete('/:id')\n  @Authorised()\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @ApiTags('api-keys')\n  @ApiResponse({\n    status: HttpStatus.NO_CONTENT,\n    description: 'API Key has been successfully deleted',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.NOT_FOUND,\n    description: 'API Key not found',\n  })\n  @ApiResponse({\n    status: HttpStatus.FORBIDDEN,\n    description: 'Access forbidden',\n  })\n  public async deleteApiKey(\n    @Param('id', ParseUUIDPipe) id: string,\n    @Request() request: RequestWithUser,\n  ): Promise<void> {\n    try {\n      const user = request.user;\n      return await this.apiKeyService.deleteApiKey(id, user);\n    } catch (error) {\n      if (error instanceof NotFoundApiKeyError) {\n        throw new HttpException('API Key not found', HttpStatus.NOT_FOUND);\n      }\n\n      if (error instanceof UnathorizedApiKeyError) {\n        throw new HttpException('Access forbidden', HttpStatus.FORBIDDEN);\n      }\n\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/api-key/api-key.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { LoggerModule } from '../logger/logger.module';\nimport { ApiKeyController } from './api-key.controller';\nimport { ApiKey } from './api-key.entity';\nimport { ApiKeyService } from './api-key.service';\n\n@Module({\n  controllers: [ApiKeyController],\n  providers: [ApiKeyService],\n  exports: [ApiKeyService],\n  imports: [LoggerModule, TypeOrmModule.forFeature([ApiKey])],\n})\nexport class ApiKeyModule {}\n\n'is-even/apps/backend/src/auth/auth.decorator.ts'\n:import { applyDecorators, UseGuards } from '@nestjs/common';\nimport { JwtAuthGuard } from './auth.guard';\n\nexport function Authorised() {\n  return applyDecorators(UseGuards(JwtAuthGuard));\n}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n",
        "gt": [
            "'is-even/apps/backend/src/auth/auth.guard.ts'",
            "'is-even/apps/backend/src/auth/auth.decorator.ts'",
            "'is-even/apps/backend/src/api-key/api-key.controller.ts'",
            "'is-even/apps/backend/src/api-key/api-key.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'",
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n\n'mean-rsvp-auth0/src/app/core/api.service.ts'\n:import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { AuthService } from './../auth/auth.service';\nimport { throwError as ObservableThrowError, Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { ENV } from './env.config';\nimport { EventModel } from './models/event.model';\nimport { RsvpModel } from './models/rsvp.model';\n\n@Injectable()\nexport class ApiService {\n  constructor(\n    private http: HttpClient,\n    private auth: AuthService\n  ) { }\n\n  private get _authHeader(): string {\n    return `Bearer ${this.auth.accessToken}`;\n  }\n\n\n  getEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events`)\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getAdminEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/admin`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getEventById$(id: string): Observable<EventModel> {\n    return this.http\n      .get<EventModel>(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getRsvpsByEventId$(eventId: string): Observable<RsvpModel[]> {\n    return this.http\n      .get<RsvpModel[]>(`${ENV.BASE_API}event/${eventId}/rsvps`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postEvent$(event: EventModel): Observable<EventModel> {\n    return this.http\n      .post<EventModel>(`${ENV.BASE_API}event/new`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editEvent$(id: string, event: EventModel): Observable<EventModel> {\n    return this.http\n      .put<EventModel>(`${ENV.BASE_API}event/${id}`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  deleteEvent$(id: string): Observable<any> {\n    return this.http\n      .delete(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getUserEvents$(userId: string): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/${userId}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postRsvp$(rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .post<RsvpModel>(`${ENV.BASE_API}rsvp/new`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editRsvp$(id: string, rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .put(`${ENV.BASE_API}rsvp/${id}`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n  private _handleError(err: HttpErrorResponse | any): Observable<any> {\n    const errorMsg = err.message || 'Error: Unable to complete request.';\n    if (err.message && err.message.indexOf('No JWT present') > -1) {\n      this.auth.login();\n    }\n    return ObservableThrowError(errorMsg);\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'\n:import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { AuthService } from './../../../auth/auth.service';\nimport { ApiService } from './../../../core/api.service';\nimport { UtilsService } from './../../../core/utils.service';\nimport { ActivatedRoute } from '@angular/router';\nimport { Subscription } from 'rxjs';\nimport { EventModel } from './../../../core/models/event.model';\n\n@Component({\n  selector: 'app-update-event',\n  templateUrl: './update-event.component.html',\n  styleUrls: ['./update-event.component.scss']\n})\nexport class UpdateEventComponent implements OnInit, OnDestroy {\n  pageTitle = 'Update Event';\n  routeSub: Subscription;\n  eventSub: Subscription;\n  event: EventModel;\n  loading: boolean;\n  submitting: boolean;\n  error: boolean;\n  tabSub: Subscription;\n  tab: string;\n  private _id: string;\n\n  constructor(\n    private route: ActivatedRoute,\n    public auth: AuthService,\n    private api: ApiService,\n    public utils: UtilsService,\n    private title: Title\n  ) { }\n\n  ngOnInit() {\n    this.title.setTitle(this.pageTitle);\n\n\n    this.routeSub = this.route.params\n      .subscribe(params => {\n        this._id = params['id'];\n        this._getEvent();\n      });\n\n\n    this.tabSub = this.route.queryParams\n      .subscribe(queryParams => {\n        this.tab = queryParams['tab'] || 'edit';\n      });\n  }\n\n  private _getEvent() {\n    this.loading = true;\n\n    this.eventSub = this.api\n      .getEventById$(this._id)\n      .subscribe(\n        res => {\n          this.event = res;\n          this.loading = false;\n        },\n        err => {\n          console.error(err);\n          this.loading = false;\n          this.error = true;\n        }\n      );\n  }\n\n  ngOnDestroy() {\n    this.routeSub.unsubscribe();\n    this.tabSub.unsubscribe();\n    this.eventSub.unsubscribe();\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/core/models/event.model.ts'\n:class EventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDatetime: Date,\n    public endDatetime: Date,\n    public viewPublic: boolean,\n    public description?: string,\n    public _id?: string,\n  ) { }\n}\n\nclass FormEventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDate: string,\n    public startTime: string,\n    public endDate: string,\n    public endTime: string,\n    public viewPublic: boolean,\n    public description?: string\n  ) { }\n}\n\nexport { EventModel, FormEventModel };\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'fc-ddd-patterns/src/domain/@shared/event/event-dispatcher.spec.ts'",
            "'fc-ddd-patterns/src/domain/@shared/event/event-handler.interface.ts'",
            "'fc-ddd-patterns/src/domain/@shared/event/event.interface.ts'",
            "'fc-ddd-patterns/src/domain/@shared/event/event-dispatcher.ts'"
        ],
        "content": "'fc-ddd-patterns/src/domain/@shared/event/event-dispatcher.spec.ts'\n:import SendEmailWhenProductIsCreatedHandler from \"../../product/event/handler/send-email-when-product-is-created.handler\";\nimport ProductCreatedEvent from \"../../product/event/product-created.event\";\nimport EventDispatcher from \"./event-dispatcher\";\n\ndescribe(\"Domain events tests\", () => {\n  it(\"should register an event handler\", () => {\n    const eventDispatcher = new EventDispatcher();\n    const eventHandler = new SendEmailWhenProductIsCreatedHandler();\n\n    eventDispatcher.register(\"ProductCreatedEvent\", eventHandler);\n\n    expect(\n      eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"]\n    ).toBeDefined();\n    expect(eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"].length).toBe(\n      1\n    );\n    expect(\n      eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"][0]\n    ).toMatchObject(eventHandler);\n  });\n\n  it(\"should unregister an event handler\", () => {\n    const eventDispatcher = new EventDispatcher();\n    const eventHandler = new SendEmailWhenProductIsCreatedHandler();\n\n    eventDispatcher.register(\"ProductCreatedEvent\", eventHandler);\n\n    expect(\n      eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"][0]\n    ).toMatchObject(eventHandler);\n\n    eventDispatcher.unregister(\"ProductCreatedEvent\", eventHandler);\n\n    expect(\n      eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"]\n    ).toBeDefined();\n    expect(eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"].length).toBe(\n      0\n    );\n  });\n\n  it(\"should unregister all event handlers\", () => {\n    const eventDispatcher = new EventDispatcher();\n    const eventHandler = new SendEmailWhenProductIsCreatedHandler();\n\n    eventDispatcher.register(\"ProductCreatedEvent\", eventHandler);\n\n    expect(\n      eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"][0]\n    ).toMatchObject(eventHandler);\n\n    eventDispatcher.unregisterAll();\n\n    expect(\n      eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"]\n    ).toBeUndefined();\n  });\n\n  it(\"should notify all event handlers\", () => {\n    const eventDispatcher = new EventDispatcher();\n    const eventHandler = new SendEmailWhenProductIsCreatedHandler();\n    const spyEventHandler = jest.spyOn(eventHandler, \"handle\");\n\n    eventDispatcher.register(\"ProductCreatedEvent\", eventHandler);\n\n    expect(\n      eventDispatcher.getEventHandlers[\"ProductCreatedEvent\"][0]\n    ).toMatchObject(eventHandler);\n\n    const productCreatedEvent = new ProductCreatedEvent({\n      name: \"Product 1\",\n      description: \"Product 1 description\",\n      price: 10.0,\n    });\n\n\n    eventDispatcher.notify(productCreatedEvent);\n\n    expect(spyEventHandler).toHaveBeenCalled();\n  });\n});\n\n'fc-ddd-patterns/src/domain/@shared/event/event-handler.interface.ts'\n:import EventInterface from './event.interface';\nexport default interface EventHandlerInterface<T extends EventInterface=EventInterface> {\n    handle(event: T): void;\n}\n'fc-ddd-patterns/src/domain/@shared/event/event.interface.ts'\n:export default interface EventInterface {\n  dataTimeOccurred: Date;\n  eventData: any;\n}\n\n'fc-ddd-patterns/src/domain/@shared/event/event-dispatcher.ts'\n:import EventDispatcherInterface from \"./event-dispatcher.interface\";\nimport EventHandlerInterface from \"./event-handler.interface\";\nimport eventInterface from \"./event.interface\";\n\nexport default class EventDispatcher implements EventDispatcherInterface {\n  private eventHandlers: { [eventName: string]: EventHandlerInterface[] } = {};\n\n  get getEventHandlers(): { [eventName: string]: EventHandlerInterface[] } {\n    return this.eventHandlers;\n  }\n\n  register(eventName: string, eventHandler: EventHandlerInterface): void {\n    if (!this.eventHandlers[eventName]) {\n      this.eventHandlers[eventName] = [];\n    }\n    this.eventHandlers[eventName].push(eventHandler);\n  }\n\n  unregister(eventName: string, eventHandler: EventHandlerInterface): void {\n    if (this.eventHandlers[eventName]) {\n      const index = this.eventHandlers[eventName].indexOf(eventHandler);\n      if (index !== -1) {\n        this.eventHandlers[eventName].splice(index, 1);\n      }\n    }\n  }\n\n  unregisterAll(): void {\n    this.eventHandlers = {};\n  }\n\n  notify(event: eventInterface): void {\n    const eventName = event.constructor.name;\n    if (this.eventHandlers[eventName]) {\n      this.eventHandlers[eventName].forEach((eventHandler) => {\n        eventHandler.handle(event);\n      });\n    }\n  }\n}\n",
        "gt": [
            "'fc-ddd-patterns/src/domain/@shared/event/event.interface.ts'",
            "'fc-ddd-patterns/src/domain/@shared/event/event-handler.interface.ts'",
            "'fc-ddd-patterns/src/domain/@shared/event/event-dispatcher.ts'",
            "'fc-ddd-patterns/src/domain/@shared/event/event-dispatcher.spec.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/order/order.module.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/credit/interface/credit-duration.interface.ts'",
            "'is-even/apps/backend/src/order/order.entity.ts'"
        ],
        "content": "'is-even/apps/backend/src/order/order.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { OrderService } from './order.service';\nimport { OrderController } from './order.controller';\nimport { LoggerModule } from '../logger/logger.module';\nimport { Order } from './order.entity';\nimport { CreditModule } from '../credit/credit.module';\nimport { AppConfigModule } from '../config/config.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [OrderService],\n  controllers: [OrderController],\n  exports: [OrderService],\n  imports: [\n    LoggerModule,\n    CreditModule,\n    AppConfigModule,\n    SentryModule,\n    TypeOrmModule.forFeature([Order]),\n  ],\n})\nexport class OrderModule {}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n\n'is-even/apps/backend/src/credit/interface/credit-duration.interface.ts'\n:export enum CreditDuration {\n  Monthly = 'Monthly',\n}\n\n'is-even/apps/backend/src/order/order.entity.ts'\n:import { Column, ManyToOne, JoinColumn, Entity, OneToOne } from 'typeorm';\n\nimport { User } from '../user/user.entity';\nimport { Credit } from '../credit/credit.entity';\nimport { BaseEditableEntity } from '../common/model/base-editable.entity';\n\nimport { CreditLimit } from '../credit/interface/credit-limit.interface';\nimport { CreditDuration } from '../credit/interface/credit-duration.interface';\nimport { OrderStatus } from './interface/order-status.interface';\n\n@Entity()\nexport class Order extends BaseEditableEntity {\n  @Column({ name: 'price', type: 'int' })\n  public price: number;\n\n  @Column({\n    name: 'status',\n    type: 'enum',\n    enum: OrderStatus,\n    default: OrderStatus.Created,\n  })\n  public status: OrderStatus;\n\n  @Column({\n    name: 'credit_limit_type',\n    type: 'enum',\n    enum: CreditLimit,\n  })\n  public creditLimit: CreditLimit;\n\n  @Column({\n    name: 'credit_duration_type',\n    type: 'enum',\n    enum: CreditDuration,\n  })\n  public creditDuration: CreditDuration;\n\n  @ManyToOne(() => User, { eager: true })\n  @JoinColumn({ name: 'user_id', referencedColumnName: 'id' })\n  public user: User;\n\n  @OneToOne(() => Credit, { eager: true, nullable: true })\n  @JoinColumn({ name: 'credit_id', referencedColumnName: 'id' })\n  public credit?: Credit;\n\n  public belongsTo(userId: string): boolean {\n    return this.user.id === userId;\n  }\n}\n",
        "gt": [
            "'is-even/apps/backend/src/credit/interface/credit-duration.interface.ts'",
            "'is-even/apps/backend/src/order/order.entity.ts'",
            "'is-even/apps/backend/src/order/order.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'angular-16-complete-course/15-angular-authentication/final/src/app/route.module.ts'",
            "'angular-16-complete-course/15-angular-authentication/final/src/app/RouteGuards/authGuard.ts'",
            "'angular-16-complete-course/15-angular-authentication/final/src/app/Services/auth.service.ts'",
            "'angular-16-complete-course/15-angular-authentication/final/src/app/app.module.ts'",
            "'angular-16-complete-course/15-angular-authentication/final/src/main.ts'"
        ],
        "content": "'angular-16-complete-course/15-angular-authentication/final/src/app/route.module.ts'\n:import { NgModule } from '@angular/core';\n\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { DashboardComponent } from './dashboard/dashboard.component';\n\nimport { LoginComponent } from './login/login.component';\n\nimport { HomeComponent } from './home/home.component';\n\nimport { canActivate } from './RouteGuards/authGuard';\n\n\n\nconst routes: Routes = [\n\n    { path: '', component: HomeComponent },\n\n    { path: 'login', component: LoginComponent },\n\n    { path: 'dashboard', component: DashboardComponent, canActivate: [canActivate] },\n\n  ];\n\n\n\n@NgModule({\n\n  imports: [RouterModule.forRoot(routes)],\n\n  exports: [RouterModule],\n\n  providers: []\n\n})\n\nexport class RouteModule { }\n\n\n'angular-16-complete-course/15-angular-authentication/final/src/app/RouteGuards/authGuard.ts'\n:import { inject } from \"@angular/core\";\n\nimport { ActivatedRouteSnapshot, Router, RouterStateSnapshot, UrlTree } from \"@angular/router\";\n\nimport { AuthService } from \"../Services/auth.service\";\n\nimport { map, take } from \"rxjs/operators\";\n\nimport { Observable } from \"rxjs\";\n\n\n\nexport const canActivate = (\n\n    router: ActivatedRouteSnapshot,\n\n    state: RouterStateSnapshot\n\n): boolean | UrlTree |Promise<boolean | UrlTree> | Observable<boolean | UrlTree> => {\n\n    const authService = inject(AuthService);\n\n    const route = inject(Router);\n\n\n\n    return authService.user.pipe(take(1), map((user) => {\n\n        const loggedIn =  user ? true : false;\n\n\n\n        if(loggedIn){\n\n            return true;\n\n        }else {\n\n            return route.createUrlTree(['/login']);\n\n        }\n\n    }))\n\n}\n'angular-16-complete-course/15-angular-authentication/final/src/app/Services/auth.service.ts'\n:import { HttpClient } from \"@angular/common/http\";\n\nimport { Injectable, inject } from \"@angular/core\";\n\nimport { AuthResponse } from \"../Model/AuthResponse\";\n\nimport { BehaviorSubject, Subject, catchError, throwError } from \"rxjs\";\n\nimport { User } from \"../Model/User\";\n\nimport { tap } from 'rxjs/operators';\n\nimport { Router } from \"@angular/router\";\n\n\n\n@Injectable({\n\n    providedIn: 'root'\n\n})\n\nexport class AuthService{\n\n    http: HttpClient = inject(HttpClient);\n\n    user = new BehaviorSubject<User>(null);\n\n    router: Router = inject(Router);\n\n    private tokenExpiretimer: any;\n\n\n\n    signup(email, password){\n\n        const data = {email: email, password: password, returnSecureToken: true};\n\n        return this.http.post<AuthResponse>\n\n            (\n\n                'https:\n\n                data\n\n            ).pipe(catchError(this.handleError), tap((res) => {\n\n                this.handleCreateUser(res)\n\n            }))\n\n    }\n\n\n\n    login(email, password){\n\n        const data = {email: email, password: password, returnSecureToken: true};\n\n        return this.http.post<AuthResponse>(\n\n            'https:\n\n            data\n\n        ).pipe(catchError(this.handleError), tap((res) => {\n\n            this.handleCreateUser(res)\n\n        }))\n\n    }\n\n\n\n    logout(){\n\n        this.user.next(null);\n\n        this.router.navigate(['/login']);\n\n        localStorage.removeItem('user');\n\n\n\n        if(this.tokenExpiretimer){\n\n            clearTimeout(this.tokenExpiretimer);\n\n        }\n\n        this.tokenExpiretimer = null;\n\n    }\n\n\n\n    autoLogin(){\n\n        const user = JSON.parse(localStorage.getItem('user'));\n\n\n\n        if(!user){\n\n            return;\n\n        }\n\n\n\n        const loggedUser = new User(user.email, user.id, user._token, user._expiresIn)\n\n\n\n        if(loggedUser.token){\n\n            this.user.next(loggedUser);\n\n            const timerValue = user._expiresIn.getTime() - new Date().getTime();\n\n            this.autoLogout(timerValue);\n\n        }\n\n    }\n\n\n\n    autoLogout(expireTime: number){\n\n        this.tokenExpiretimer = setTimeout(() => {\n\n            this.logout();\n\n        }, expireTime);\n\n    }\n\n\n\n    private handleCreateUser(res){\n\n        const expiresInTs = new Date().getTime() + +res.expiresIn * 1000;\n\n        const expiresIn = new Date(expiresInTs);\n\n        const user = new User(res.email, res.localId, res.idToken, expiresIn);\n\n        this.user.next(user);\n\n        this.autoLogout(res.expiresIn * 1000);\n\n\n\n        localStorage.setItem('user', JSON.stringify(user));\n\n    }\n\n    private handleError(err){\n\n        let errorMessage = 'An unknown error has occured'\n\n        console.log(err);\n\n        if(!err.error || !err.error.error){\n\n            return throwError(() => errorMessage);\n\n        }\n\n        switch (err.error.error.message){\n\n            case 'EMAIL_EXISTS':\n\n                errorMessage =\"This email already exists.\";\n\n                break;\n\n            case 'OPERATION_NOT_ALLOWED':\n\n                errorMessage = 'This operation is not allowed.';\n\n                break;\n\n            case 'INVALID_LOGIN_CREDENTIALS':\n\n                errorMessage = 'The email ID or Password is not correct.';\n\n                break\n\n        }\n\n        return throwError(() => errorMessage);\n\n    }\n\n}\n'angular-16-complete-course/15-angular-authentication/final/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { FooterComponent } from './footer/footer.component';\nimport { DashboardComponent } from './dashboard/dashboard.component';\nimport { CreateTaskComponent } from './dashboard/create-task/create-task.component';\nimport { FormsModule } from '@angular/forms';\nimport { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { TaskDetailsComponent } from './dashboard/task-details/task-details.component';\nimport { AuthInterceptorService } from './Services/auth-interceptor.service';\nimport { LoggingInterceptorService } from './Services/logging-interceptor.servive';\nimport { RouteModule } from './route.module';\nimport { HomeComponent } from './home/home.component';\nimport { LoginComponent } from './login/login.component';\nimport { LoaderComponent } from './utility/loader/loader.component';\nimport { SnackbarComponent } from './utility/snackbar/snackbar.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    DashboardComponent,\n    CreateTaskComponent,\n    TaskDetailsComponent,\n    HomeComponent,\n    LoginComponent,\n    LoaderComponent,\n    SnackbarComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpClientModule,\n    RouteModule\n  ],\n  providers: [\n    {provide: HTTP_INTERCEPTORS, useClass: AuthInterceptorService, multi: true},\n    {provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptorService, multi: true}\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-16-complete-course/15-angular-authentication/final/src/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n",
        "gt": [
            "'angular-16-complete-course/15-angular-authentication/final/src/app/Services/auth.service.ts'",
            "'angular-16-complete-course/15-angular-authentication/final/src/app/RouteGuards/authGuard.ts'",
            "'angular-16-complete-course/15-angular-authentication/final/src/app/route.module.ts'",
            "'angular-16-complete-course/15-angular-authentication/final/src/app/app.module.ts'",
            "'angular-16-complete-course/15-angular-authentication/final/src/main.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipe-start/recipe-start.component.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/project/src/app/recipes/recipes-routing.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { Routes, RouterModule } from \"@angular/router\";\n\n\n\nimport { AuthGuard } from \"../auth/auth.guard\";\n\nimport { RecipeDetailComponent } from \"./recipe-detail/recipe-detail.component\";\n\nimport { RecipeEditComponent } from \"./recipe-edit/recipe-edit.component\";\n\nimport { RecipeStartComponent } from \"./recipe-start/recipe-start.component\";\n\nimport { RecipesResolverService } from \"./recipes-resolver.service\";\n\nimport { RecipesComponent } from \"./recipes.component\";\n\n\n\nconst routes: Routes = [\n\n  {\n\n    path: '',\n\n    component: RecipesComponent,\n\n    canActivate: [AuthGuard],\n\n    children: [\n\n      { path: '', component: RecipeStartComponent },\n\n      { path: 'new', component: RecipeEditComponent },\n\n      {\n\n        path: ':id',\n\n        component: RecipeDetailComponent,\n\n        resolve: [RecipesResolverService]\n\n      },\n\n      {\n\n        path: ':id/edit',\n\n        component: RecipeEditComponent,\n\n        resolve: [RecipesResolverService]\n\n      }\n\n    ]\n\n  }\n\n];\n\n\n\n@NgModule({\n\n  imports: [RouterModule.forChild(routes)],\n\n  exports: [RouterModule]\n\n})\n\nexport class RecipesRoutingModule {\n\n\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/app/recipes/recipe-start/recipe-start.component.ts'\n:import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-recipe-start',\n  templateUrl: './recipe-start.component.html',\n  styleUrls: ['./recipe-start.component.css']\n})\nexport class RecipeStartComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n\n'angular-the-complete-guide-2023/project/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { CoreModule } from './core.module';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\n\nimport * as fromApp from './store/app.reducer';\nimport { AuthEffects } from './auth/store/auth.effects';\nimport { environment } from 'src/environments/environment';\nimport { RecipeEffects } from './recipes/store/recipe.effects';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    SharedModule,\n    CoreModule,\n    StoreModule.forRoot(fromApp.appReducer),\n    EffectsModule.forRoot([AuthEffects, RecipeEffects]),\n    StoreDevtoolsModule.instrument({\n      logOnly: environment.production\n    }),\n    StoreRouterConnectingModule.forRoot()\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { RouterModule } from \"@angular/router\";\n\nimport { ReactiveFormsModule } from \"@angular/forms\";\n\n\n\nimport { RecipeDetailComponent } from \"./recipe-detail/recipe-detail.component\";\n\nimport { RecipeItemComponent } from \"./recipe-list/recipe-item/recipe-item.component\";\n\nimport { RecipeListComponent } from \"./recipe-list/recipe-list.component\";\n\nimport { RecipeStartComponent } from \"./recipe-start/recipe-start.component\";\n\nimport { RecipesComponent } from \"./recipes.component\";\n\nimport { RecipesRoutingModule } from \"./recipes-routing.module\";\n\nimport { RecipeEditComponent } from \"./recipe-edit/recipe-edit.component\";\n\nimport { SharedModule } from \"../shared/shared.module\";\n\n\n\n@NgModule({\n\n  declarations: [\n\n    RecipesComponent,\n\n    RecipeListComponent,\n\n    RecipeDetailComponent,\n\n    RecipeItemComponent,\n\n    RecipeStartComponent,\n\n    RecipeEditComponent\n\n  ],\n\n  imports: [\n\n    RouterModule,\n\n    ReactiveFormsModule,\n\n    RecipesRoutingModule,\n\n    SharedModule\n\n  ],\n\n  exports: [\n\n    RecipesComponent,\n\n    RecipeListComponent,\n\n    RecipeDetailComponent,\n\n    RecipeItemComponent,\n\n    RecipeStartComponent,\n\n    RecipeEditComponent\n\n  ]\n\n})\n\nexport class RecipesModule {\n\n\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { Routes, RouterModule, PreloadAllModules } from \"@angular/router\";\n\n\n\nconst appRoutes: Routes = [\n\n    { path: '', redirectTo: '/recipes', pathMatch: 'full'},\n\n    { path: 'recipes', loadChildren: () => import('./recipes/recipes.module').then(m => m.RecipesModule) },\n\n    { path: 'shopping-list', loadChildren: () => import('./shopping-list/shopping-list.module').then(m => m.ShoppingListModule) },\n\n    { path: 'auth', loadChildren: () => import('./auth/auth.module').then(m => m.AuthModule) }\n\n];\n\n\n\n@NgModule({\n\n    imports: [RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules })],\n\n    exports: [RouterModule]\n\n})\n\nexport class AppRoutingModule {\n\n\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n",
        "gt": [
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipe-start/recipe-start.component.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'zephyr/packages/common/src/interfaces/zephyr-route.ts'",
            "'zephyr/packages/common/src/interfaces/zephyr-hooks.ts'",
            "'zephyr/packages/common/src/interfaces/zephyr-handler.ts'",
            "'zephyr/packages/common/src/interfaces/zephyr-request.ts'"
        ],
        "content": "'zephyr/packages/common/src/interfaces/zephyr-route.ts'\n:import type { AnyZodObject, ZodObject, ZodTypeAny } from 'zod';\nimport { ZephyrHandler } from './zephyr-handler';\nimport {\n  OnBeforeHandleHook,\n  OnBeforeValidateHook,\n  OnErrorCapturedHook,\n  OnRequestHook,\n  OnResponseHook,\n} from './zephyr-hooks';\nimport { ZephyrBaseRequest } from './zephyr-request';\n\nexport const ROUTE_METHODS = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'] as const;\n\nexport type RouteMethod = typeof ROUTE_METHODS[number];\n\nexport type ZephyrRouteSchema = ZodObject<{\n  params?: AnyZodObject;\n  query?: AnyZodObject;\n  body?: AnyZodObject;\n  response?: ZodTypeAny;\n}>;\n\nexport interface ZephyrRoute<\n  TRequest extends ZephyrBaseRequest = any,\n  TResponse = any,\n> extends ZephyrRouteHooks<TRequest, TResponse> {\n  name?: string;\n  method: RouteMethod;\n  path: string;\n  schema?: ZephyrRouteSchema;\n  handler: ZephyrHandler<TRequest, TResponse>;\n}\n\nexport interface ZephyrRouteHooks<\n  TRequest extends ZephyrBaseRequest,\n  TResponse,\n> {\n  onRequest?: OnRequestHook<TRequest, TResponse>;\n  onBeforeHandle?: OnBeforeHandleHook<TRequest, TResponse>;\n  onBeforeValidate?: OnBeforeValidateHook<TRequest, TResponse>;\n  onResponse?: OnResponseHook<TRequest, TResponse>;\n  onErrorCaptured?: OnErrorCapturedHook<TRequest, TResponse, unknown>;\n}\n\n'zephyr/packages/common/src/interfaces/zephyr-hooks.ts'\n:import { ZephyrHandler, ZephyrHandlerWithError } from './zephyr-handler';\nimport { ZephyrBaseRequest } from './zephyr-request';\nimport { ZephyrRoute } from './zephyr-route';\n\n\nexport type OnReadyHook = () => void | Promise<void>;\nexport type OnRouteHook = (route: ZephyrRoute) => void;\n\n\nexport type OnBeforeHandleHook<\n  TRequest extends ZephyrBaseRequest,\n  TResponse,\n> = ZephyrHandler<TRequest, TResponse>;\n\nexport type OnBeforeValidateHook<\n  TRequest extends ZephyrBaseRequest,\n  TResponse,\n> = ZephyrHandler<TRequest, TResponse>;\n\nexport type OnRequestHook<\n  TRequest extends ZephyrBaseRequest,\n  TResponse,\n> = ZephyrHandler<TRequest, TResponse>;\n\nexport type OnResponseHook<\n  TRequest extends ZephyrBaseRequest,\n  TResponse,\n> = ZephyrHandler<TRequest, TResponse>;\n\nexport type OnErrorCapturedHook<\n  TRequest extends ZephyrBaseRequest = any,\n  TResponse = any,\n  TError = unknown,\n> = ZephyrHandlerWithError<TRequest, TResponse, TError>;\n\n'zephyr/packages/common/src/interfaces/zephyr-handler.ts'\n:import { ZephyrBaseRequest, ZephyrRequest } from './zephyr-request';\nimport { ZephyrResponse } from './zephyr-response';\n\nexport type ZephyrHandler<\n  TRequest extends ZephyrBaseRequest = any,\n  TResponse = any,\n> = (\n  req: ZephyrRequest<TRequest>,\n  res: ZephyrResponse<TResponse>,\n) => TResponse | Promise<TResponse> | undefined | Promise<undefined>;\n\nexport type ZephyrHandlerWithError<\n  TRequest extends ZephyrBaseRequest = any,\n  TResponse = any,\n  TError = unknown,\n> = (\n  req: ZephyrRequest<TRequest, TResponse>,\n  res: ZephyrResponse<TResponse>,\n  err: TError,\n) => TResponse | Promise<TResponse> | undefined | Promise<undefined>;\n\n'zephyr/packages/common/src/interfaces/zephyr-request.ts'\n:import type { Request as ExpressRequest } from 'express';\n\nexport type RequestMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n\nexport interface ZephyrBaseRequest {\n  params?: object;\n  query?: object;\n  body?: object;\n}\n\nexport type ZephyrRequest<\n  T extends ZephyrBaseRequest = any,\n  TResponse = any,\n> = ExpressRequest<T['params'], TResponse, T['body'], T['query']>;\n",
        "gt": [
            "'zephyr/packages/common/src/interfaces/zephyr-request.ts'",
            "'zephyr/packages/common/src/interfaces/zephyr-handler.ts'",
            "'zephyr/packages/common/src/interfaces/zephyr-route.ts'",
            "'zephyr/packages/common/src/interfaces/zephyr-hooks.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/payment/payment.entity.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'"
        ],
        "content": "'is-even/apps/backend/src/payment/payment.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { PaymentService } from './payment.service';\nimport { PaymentController } from './payment.controller';\nimport { Payment } from './payment.entity';\n\nimport { LoggerModule } from '../logger/logger.module';\nimport { StripeModule } from '../stripe/stripe.module';\nimport { OrderModule } from '../order/order.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [PaymentService],\n  controllers: [PaymentController],\n  imports: [\n    LoggerModule,\n    StripeModule,\n    OrderModule,\n    SentryModule,\n    TypeOrmModule.forFeature([Payment]),\n  ],\n  exports: [PaymentService],\n})\nexport class PaymentModule {}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/payment/payment.entity.ts'\n:import { Column, Entity, ManyToOne, JoinColumn } from 'typeorm';\n\nimport { Order } from '../order/order.entity';\nimport { User } from '../user/user.entity';\nimport { BaseReadonlyEntity } from '../common/model/base-readonly.enity';\nimport { PaymentStatus } from './interface/payment-status.interface';\n\n@Entity()\nexport class Payment extends BaseReadonlyEntity {\n  @Column({\n    name: 'session_id',\n    type: 'varchar',\n    length: 128,\n    unique: true,\n  })\n  public sessionId: string;\n\n  @Column({\n    name: 'status',\n    type: 'enum',\n    enum: PaymentStatus,\n    default: PaymentStatus.Pending,\n  })\n  public status: PaymentStatus;\n\n  @ManyToOne(() => User, { eager: true })\n  @JoinColumn({ name: 'user_id', referencedColumnName: 'id' })\n  public user: User;\n\n  @ManyToOne(() => Order, { eager: true })\n  @JoinColumn({ name: 'order_id', referencedColumnName: 'id' })\n  public order: Order;\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n",
        "gt": [
            "'is-even/apps/backend/src/payment/payment.entity.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/project/src/main.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes-routing.module.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { Routes, RouterModule, PreloadAllModules } from \"@angular/router\";\n\n\n\nconst appRoutes: Routes = [\n\n    { path: '', redirectTo: '/recipes', pathMatch: 'full'},\n\n    { path: 'recipes', loadChildren: () => import('./recipes/recipes.module').then(m => m.RecipesModule) },\n\n    { path: 'shopping-list', loadChildren: () => import('./shopping-list/shopping-list.module').then(m => m.ShoppingListModule) },\n\n    { path: 'auth', loadChildren: () => import('./auth/auth.module').then(m => m.AuthModule) }\n\n];\n\n\n\n@NgModule({\n\n    imports: [RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules })],\n\n    exports: [RouterModule]\n\n})\n\nexport class AppRoutingModule {\n\n\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { RouterModule } from \"@angular/router\";\n\nimport { ReactiveFormsModule } from \"@angular/forms\";\n\n\n\nimport { RecipeDetailComponent } from \"./recipe-detail/recipe-detail.component\";\n\nimport { RecipeItemComponent } from \"./recipe-list/recipe-item/recipe-item.component\";\n\nimport { RecipeListComponent } from \"./recipe-list/recipe-list.component\";\n\nimport { RecipeStartComponent } from \"./recipe-start/recipe-start.component\";\n\nimport { RecipesComponent } from \"./recipes.component\";\n\nimport { RecipesRoutingModule } from \"./recipes-routing.module\";\n\nimport { RecipeEditComponent } from \"./recipe-edit/recipe-edit.component\";\n\nimport { SharedModule } from \"../shared/shared.module\";\n\n\n\n@NgModule({\n\n  declarations: [\n\n    RecipesComponent,\n\n    RecipeListComponent,\n\n    RecipeDetailComponent,\n\n    RecipeItemComponent,\n\n    RecipeStartComponent,\n\n    RecipeEditComponent\n\n  ],\n\n  imports: [\n\n    RouterModule,\n\n    ReactiveFormsModule,\n\n    RecipesRoutingModule,\n\n    SharedModule\n\n  ],\n\n  exports: [\n\n    RecipesComponent,\n\n    RecipeListComponent,\n\n    RecipeDetailComponent,\n\n    RecipeItemComponent,\n\n    RecipeStartComponent,\n\n    RecipeEditComponent\n\n  ]\n\n})\n\nexport class RecipesModule {\n\n\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { CoreModule } from './core.module';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\n\nimport * as fromApp from './store/app.reducer';\nimport { AuthEffects } from './auth/store/auth.effects';\nimport { environment } from 'src/environments/environment';\nimport { RecipeEffects } from './recipes/store/recipe.effects';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    SharedModule,\n    CoreModule,\n    StoreModule.forRoot(fromApp.appReducer),\n    EffectsModule.forRoot([AuthEffects, RecipeEffects]),\n    StoreDevtoolsModule.instrument({\n      logOnly: environment.production\n    }),\n    StoreRouterConnectingModule.forRoot()\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-the-complete-guide-2023/project/src/app/recipes/recipes-routing.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { Routes, RouterModule } from \"@angular/router\";\n\n\n\nimport { AuthGuard } from \"../auth/auth.guard\";\n\nimport { RecipeDetailComponent } from \"./recipe-detail/recipe-detail.component\";\n\nimport { RecipeEditComponent } from \"./recipe-edit/recipe-edit.component\";\n\nimport { RecipeStartComponent } from \"./recipe-start/recipe-start.component\";\n\nimport { RecipesResolverService } from \"./recipes-resolver.service\";\n\nimport { RecipesComponent } from \"./recipes.component\";\n\n\n\nconst routes: Routes = [\n\n  {\n\n    path: '',\n\n    component: RecipesComponent,\n\n    canActivate: [AuthGuard],\n\n    children: [\n\n      { path: '', component: RecipeStartComponent },\n\n      { path: 'new', component: RecipeEditComponent },\n\n      {\n\n        path: ':id',\n\n        component: RecipeDetailComponent,\n\n        resolve: [RecipesResolverService]\n\n      },\n\n      {\n\n        path: ':id/edit',\n\n        component: RecipeEditComponent,\n\n        resolve: [RecipesResolverService]\n\n      }\n\n    ]\n\n  }\n\n];\n\n\n\n@NgModule({\n\n  imports: [RouterModule.forChild(routes)],\n\n  exports: [RouterModule]\n\n})\n\nexport class RecipesRoutingModule {\n\n\n\n}\n\n",
        "gt": [
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'",
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n\n'mean-rsvp-auth0/src/app/core/api.service.ts'\n:import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { AuthService } from './../auth/auth.service';\nimport { throwError as ObservableThrowError, Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { ENV } from './env.config';\nimport { EventModel } from './models/event.model';\nimport { RsvpModel } from './models/rsvp.model';\n\n@Injectable()\nexport class ApiService {\n  constructor(\n    private http: HttpClient,\n    private auth: AuthService\n  ) { }\n\n  private get _authHeader(): string {\n    return `Bearer ${this.auth.accessToken}`;\n  }\n\n\n  getEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events`)\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getAdminEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/admin`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getEventById$(id: string): Observable<EventModel> {\n    return this.http\n      .get<EventModel>(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getRsvpsByEventId$(eventId: string): Observable<RsvpModel[]> {\n    return this.http\n      .get<RsvpModel[]>(`${ENV.BASE_API}event/${eventId}/rsvps`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postEvent$(event: EventModel): Observable<EventModel> {\n    return this.http\n      .post<EventModel>(`${ENV.BASE_API}event/new`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editEvent$(id: string, event: EventModel): Observable<EventModel> {\n    return this.http\n      .put<EventModel>(`${ENV.BASE_API}event/${id}`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  deleteEvent$(id: string): Observable<any> {\n    return this.http\n      .delete(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getUserEvents$(userId: string): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/${userId}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postRsvp$(rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .post<RsvpModel>(`${ENV.BASE_API}rsvp/new`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editRsvp$(id: string, rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .put(`${ENV.BASE_API}rsvp/${id}`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n  private _handleError(err: HttpErrorResponse | any): Observable<any> {\n    const errorMsg = err.message || 'Error: Unable to complete request.';\n    if (err.message && err.message.indexOf('No JWT present') > -1) {\n      this.auth.login();\n    }\n    return ObservableThrowError(errorMsg);\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'\n:import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { AuthService } from './../../../auth/auth.service';\nimport { ApiService } from './../../../core/api.service';\nimport { UtilsService } from './../../../core/utils.service';\nimport { ActivatedRoute } from '@angular/router';\nimport { Subscription } from 'rxjs';\nimport { EventModel } from './../../../core/models/event.model';\n\n@Component({\n  selector: 'app-update-event',\n  templateUrl: './update-event.component.html',\n  styleUrls: ['./update-event.component.scss']\n})\nexport class UpdateEventComponent implements OnInit, OnDestroy {\n  pageTitle = 'Update Event';\n  routeSub: Subscription;\n  eventSub: Subscription;\n  event: EventModel;\n  loading: boolean;\n  submitting: boolean;\n  error: boolean;\n  tabSub: Subscription;\n  tab: string;\n  private _id: string;\n\n  constructor(\n    private route: ActivatedRoute,\n    public auth: AuthService,\n    private api: ApiService,\n    public utils: UtilsService,\n    private title: Title\n  ) { }\n\n  ngOnInit() {\n    this.title.setTitle(this.pageTitle);\n\n\n    this.routeSub = this.route.params\n      .subscribe(params => {\n        this._id = params['id'];\n        this._getEvent();\n      });\n\n\n    this.tabSub = this.route.queryParams\n      .subscribe(queryParams => {\n        this.tab = queryParams['tab'] || 'edit';\n      });\n  }\n\n  private _getEvent() {\n    this.loading = true;\n\n    this.eventSub = this.api\n      .getEventById$(this._id)\n      .subscribe(\n        res => {\n          this.event = res;\n          this.loading = false;\n        },\n        err => {\n          console.error(err);\n          this.loading = false;\n          this.error = true;\n        }\n      );\n  }\n\n  ngOnDestroy() {\n    this.routeSub.unsubscribe();\n    this.tabSub.unsubscribe();\n    this.eventSub.unsubscribe();\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/core/models/event.model.ts'\n:class EventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDatetime: Date,\n    public endDatetime: Date,\n    public viewPublic: boolean,\n    public description?: string,\n    public _id?: string,\n  ) { }\n}\n\nclass FormEventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDate: string,\n    public startTime: string,\n    public endDate: string,\n    public endTime: string,\n    public viewPublic: boolean,\n    public description?: string\n  ) { }\n}\n\nexport { EventModel, FormEventModel };\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'stromjs/src/functions/split.ts'",
            "'stromjs/src/functions/baseDefinitions.ts'",
            "'stromjs/src/functions/index.ts'"
        ],
        "content": "'stromjs/src/functions/split.ts'\n:import { Transform, TransformOptions } from \"stream\";\nimport { StringDecoder } from \"string_decoder\";\nimport { WithEncoding } from \"./baseDefinitions\";\n\nexport function split(\n    separator: string | RegExp = \"\\n\",\n    options: WithEncoding & TransformOptions = {\n        encoding: \"utf8\",\n        objectMode: true,\n    },\n): Transform {\n    let buffered = \"\";\n    const decoder = new StringDecoder(options.encoding);\n\n    return new Transform({\n        readableObjectMode: true,\n        transform(chunk: Buffer, encoding, callback) {\n            const asString = decoder.write(chunk);\n            const splitData = asString.split(separator);\n            if (splitData.length > 1) {\n                splitData[0] = buffered.concat(splitData[0]);\n                buffered = \"\";\n            }\n            buffered += splitData[splitData.length - 1];\n            splitData.slice(0, -1).forEach((part: string) => this.push(part));\n            callback();\n        },\n        flush(callback) {\n            callback(undefined, buffered + decoder.end());\n        },\n    });\n}\n\n'stromjs/src/functions/baseDefinitions.ts'\n:export interface WithEncoding {\n    encoding: BufferEncoding;\n}\n\nexport enum SerializationFormats {\n    utf8 = \"utf8\",\n}\n\ntype JsonPrimitive = string | number | object;\nexport type JsonValue = JsonPrimitive | JsonPrimitive[];\n\nexport interface JsonParseOptions {\n    pretty: boolean;\n}\n\n'stromjs/src/functions/index.ts'\n:import { TransformOptions } from \"stream\";\nimport { accumulator, accumulatorBy } from \"./accumulator\";\nimport { batch } from \"./batch\";\nimport { child } from \"./child\";\nimport { collect } from \"./collect\";\nimport { concat } from \"./concat\";\nimport { duplex } from \"./duplex\";\nimport { filter } from \"./filter\";\nimport { flatMap } from \"./flatMap\";\nimport { fromArray } from \"./fromArray\";\nimport { join } from \"./join\";\nimport { last } from \"./last\";\nimport { map } from \"./map\";\nimport { merge } from \"./merge\";\nimport { parallelMap } from \"./parallelMap\";\nimport { parse } from \"./parse\";\nimport { rate } from \"./rate\";\nimport { reduce } from \"./reduce\";\nimport { replace } from \"./replace\";\nimport { split } from \"./split\";\nimport { stringify } from \"./stringify\";\nimport { unbatch } from \"./unbatch\";\nimport { compose } from \"./compose\";\nimport { demux } from \"./demux\";\n\nexport function strom(defaultOptions: TransformOptions = { objectMode: true }) {\n    function withDefaultOptions<T extends any[], R>(\n        n: number,\n        fn: (...args: T) => R,\n    ): (...args: T) => R {\n        return (...args) => {\n            const options = {\n                ...defaultOptions,\n                ...((args[n] || {}) as TransformOptions | {}),\n            };\n            const provided = args.slice(0, n);\n            const nextArgs = [\n                ...provided,\n                ...Array(n - provided.length).fill(undefined),\n                options,\n            ] as T;\n            return fn(...nextArgs) as R;\n        };\n    }\n\n    return {\n\n        fromArray,\n\n\n        map: withDefaultOptions(1, map),\n\n\n        flatMap: withDefaultOptions(1, flatMap),\n\n\n        filter: withDefaultOptions(1, filter),\n\n\n        reduce: withDefaultOptions(2, reduce),\n\n\n        split,\n\n\n        join: withDefaultOptions(1, join),\n\n\n        replace,\n\n\n        parse,\n\n\n        stringify,\n\n\n        collect: withDefaultOptions(0, collect),\n\n\n        concat,\n\n\n        merge,\n\n\n        duplex,\n\n\n        child,\n\n\n        last,\n\n\n        batch: withDefaultOptions(2, batch),\n\n\n        unbatch: withDefaultOptions(0, unbatch),\n\n\n        rate: withDefaultOptions(2, rate),\n\n\n        parallelMap: withDefaultOptions(3, parallelMap),\n\n\n        accumulator: withDefaultOptions(3, accumulator),\n\n\n        accumulatorBy: withDefaultOptions(2, accumulatorBy),\n\n\n        compose: withDefaultOptions(2, compose),\n\n\n        demux: withDefaultOptions(2, demux),\n\n\n        instance: strom,\n    };\n}\n",
        "gt": [
            "'stromjs/src/functions/baseDefinitions.ts'",
            "'stromjs/src/functions/split.ts'",
            "'stromjs/src/functions/index.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/store/recipe.reducer.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/store/recipe.effects.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'\n:import * as fromShoppingList from '../shopping-list/store/shopping-list.reducer';\n\nimport * as fromAuth from '../auth/store/auth.reducer';\n\nimport * as fromRecipes from '../recipes/store/recipe.reducer';\n\nimport { ActionReducerMap } from '@ngrx/store';\n\n\n\nexport interface AppState {\n\n  shoppingList: fromShoppingList.State;\n\n  auth: fromAuth.State;\n\n  recipes: fromRecipes.State;\n\n}\n\n\n\nexport const appReducer: ActionReducerMap<AppState> = {\n\n  shoppingList: fromShoppingList.shoppingListReducer,\n\n  auth: fromAuth.authReducer,\n\n  recipes: fromRecipes.recipeReducer\n\n};\n\n\n'angular-the-complete-guide-2023/project/src/app/recipes/store/recipe.reducer.ts'\n:import { Recipe } from \"../recipe.model\";\n\nimport * as RecipesActions from './recipe.actions';\n\n\n\nexport interface State {\n\n  recipes: Recipe[]\n\n}\n\n\n\nconst initialState: State = {\n\n  recipes: []\n\n};\n\n\n\nexport function recipeReducer(\n\n  state = initialState,\n\n  action: RecipesActions.RecipesActions\n\n) {\n\n  switch (action.type) {\n\n    case RecipesActions.SET_RECIPES:\n\n      return {\n\n        ...state,\n\n        recipes: [...action.payload]\n\n      };\n\n    case RecipesActions.ADD_RECIPE:\n\n      return {\n\n        ...state,\n\n        recipes: [...state.recipes, action.payload]\n\n      };\n\n    case RecipesActions.UPDATE_RECIPE:\n\n      const updatedRecipe = {\n\n        ...state.recipes[action.payload.index],\n\n        ...action.payload.newRecipe\n\n      };\n\n\n\n      const updatedRecipes = [...state.recipes];\n\n      updatedRecipes[action.payload.index] = updatedRecipe;\n\n\n\n      return {\n\n        ...state,\n\n        recipes: updatedRecipes\n\n      };\n\n    case RecipesActions.DELETE_RECIPE:\n\n      return {\n\n        ...state,\n\n        recipes: state.recipes.filter((recipe, index) => {\n\n          return index !== action.payload;\n\n        })\n\n      }\n\n    default:\n\n      return state;\n\n  }\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/app/recipes/store/recipe.effects.ts'\n:import { HttpClient } from \"@angular/common/http\";\n\nimport { Injectable } from \"@angular/core\";\n\nimport { Actions, Effect, ofType } from \"@ngrx/effects\";\n\nimport { Store } from \"@ngrx/store\";\n\nimport { map, switchMap, withLatestFrom } from \"rxjs/operators\";\n\nimport { Recipe } from \"../recipe.model\";\n\n\n\nimport * as RecipesActions from './recipe.actions';\n\nimport * as fromApp from '../../store/app.reducer';\n\n\n\n@Injectable()\n\nexport class RecipeEffects {\n\n\n\n  @Effect()\n\n  fetchRecipes = this.actions$\n\n    .pipe(\n\n      ofType(RecipesActions.FETCH_RECIPES),\n\n      switchMap(fetchAction => {\n\n        return this.http.get<Recipe[]>(\n\n          'https:\n\n        )\n\n      }),\n\n      map(recipes => {\n\n        return recipes.map(recipe => {\n\n          return {\n\n            ...recipe,\n\n            ingredients: recipe.ingredients ? recipe.ingredients : []\n\n          };\n\n        });\n\n      }),\n\n      map(recipes => {\n\n        return new RecipesActions.SetRecipes(recipes);\n\n      })\n\n    );\n\n\n\n  @Effect({ dispatch: false })\n\n  storeRecipes = this.actions$\n\n    .pipe(\n\n      ofType(RecipesActions.STORE_RECIPES),\n\n      withLatestFrom(this.store.select('recipes')),\n\n      switchMap(([actionData, recipesState]) => {\n\n        return this.http.put(\n\n          'https:\n\n          recipesState.recipes\n\n        )\n\n      })\n\n    )\n\n\n\n  constructor(\n\n    private actions$: Actions,\n\n    private http: HttpClient,\n\n    private store: Store<fromApp.AppState>\n\n  ) { }\n\n\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/project/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { CoreModule } from './core.module';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\n\nimport * as fromApp from './store/app.reducer';\nimport { AuthEffects } from './auth/store/auth.effects';\nimport { environment } from 'src/environments/environment';\nimport { RecipeEffects } from './recipes/store/recipe.effects';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    SharedModule,\n    CoreModule,\n    StoreModule.forRoot(fromApp.appReducer),\n    EffectsModule.forRoot([AuthEffects, RecipeEffects]),\n    StoreDevtoolsModule.instrument({\n      logOnly: environment.production\n    }),\n    StoreRouterConnectingModule.forRoot()\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n",
        "gt": [
            "'angular-the-complete-guide-2023/project/src/app/recipes/store/recipe.reducer.ts'",
            "'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/store/recipe.effects.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'predicates/src/typeToPredicate.ts'",
            "'predicates/src/any.ts'",
            "'predicates/test/anyTest.ts'",
            "'predicates/src/weakSet.ts'",
            "'predicates/src/utils/assertPredicates.ts'",
            "'predicates/src/arrayOf.ts'"
        ],
        "content": "'predicates/src/typeToPredicate.ts'\n:import isString from './string';\nimport isBoolean from './boolean';\nimport isNumber from './number';\nimport {Predicate} from './types';\nimport isSymbol from './symbol';\nimport isWeakMap from './weakMap';\nimport isWeakSet from './weakSet';\nimport isRegExp from './regexp';\nimport isObject from './object';\nimport isFunction from './function';\nimport isDate from './date';\nimport isArray from './array';\n\nconst find = require('array-find');\n\nconst mapping: [Function, Predicate][] = [\n    [String, isString],\n    [Boolean, isBoolean],\n    [Number, isNumber],\n    [RegExp, isRegExp],\n    [Object, isObject],\n    [Function, isFunction],\n    [Date, isDate],\n    [Array, isArray]\n];\n\nif (typeof Symbol !== 'undefined') {\n    mapping.push([Symbol, isSymbol]);\n}\n\nif (typeof WeakMap !== 'undefined') {\n    mapping.push([WeakMap, isWeakMap]);\n}\n\nif (typeof WeakSet !== 'undefined') {\n    mapping.push([WeakSet, isWeakSet]);\n}\n\n\nexport function getPredicateForType(type: Function): Predicate {\n    const result = find(mapping, (entry: [Function, Predicate]) => {\n        return entry[0] === type;\n    });\n\n    if (result) {\n        return result[1];\n    }\n}\n'predicates/src/any.ts'\n:import {Predicate} from './types';\nimport assertPredicates from './utils/assertPredicates';\nimport {getDescription, setDescription} from './utils/description';\nimport {getPredicateForType} from './typeToPredicate';\n\n\nexport default function any(...predicates: (Predicate | Function)[]): Predicate {\n    const convertedPredicates = predicates.map((p) => getPredicateForType(p) || <Predicate>p);\n    assertPredicates(convertedPredicates);\n\n    return setDescription(\n        function anyPredicate() {\n            const args = arguments;\n            return convertedPredicates.some(predicate => predicate.apply(this, args));\n        },\n        'a value that satisfies any of predicates: ' + (convertedPredicates.map(getDescription)).join(', ')\n    );\n}\n'predicates/test/anyTest.ts'\n:import any from '../src/any';\nimport {assert} from 'chai';\nimport * as sinon from 'sinon';\nimport {assertDescription, falsePredicate, truePredicate} from \"./common\";\nimport isString from \"../src/string\";\nimport isNumber from \"../src/number\";\n\ndescribe('any', function () {\n\n\n    it('returns a function', function () {\n        assert.isFunction(any(truePredicate, falsePredicate));\n    });\n\n    it('throws error if not every predicate is a function', function () {\n        assert.throws(function () {\n            any(truePredicate, <any>'definitely not a function');\n        });\n    });\n\n    it('throws error if zero or only one predicate provided', function () {\n        assert.throws(function () {\n            any();\n        }, Error, 'need to provide at least two predicates');\n\n        assert.throws(function () {\n            any(truePredicate);\n        }, Error, 'need to provide at least two predicates');\n\n        assert.doesNotThrow(function () {\n            any(truePredicate, falsePredicate);\n        });\n    });\n\n    it('calls predicates in order', function () {\n        const p1 = sinon.stub().returns(false);\n        const p2 = sinon.stub().returns(false);\n        const p3 = sinon.stub().returns(false);\n        const value = 'value';\n\n        any(p1, p2, p3)(value);\n\n        sinon.assert.calledWith(p1, value);\n        sinon.assert.calledWith(p2, value);\n        sinon.assert.calledWith(p3, value);\n\n        assert.ok(p1.calledBefore(p2));\n        assert.ok(p2.calledBefore(p3));\n    });\n\n    it('calls predicates with correct context and arguments', function () {\n        const args = [1, 2, 3, 4];\n        const context = {example: 'context'};\n        const stub = sinon.stub().returns(false);\n        const testPredicate = any(stub, stub, stub, stub);\n\n        assert.isFalse(testPredicate.apply(context, args));\n\n        sinon.assert.callCount(stub, 4);\n        sinon.assert.alwaysCalledOn(stub, context);\n        sinon.assert.calledWith(stub, ...args);\n    });\n\n    it('checks whether at least one predicate has been satisfied', function () {\n        assert.isTrue(any(falsePredicate, truePredicate, falsePredicate)('value'));\n        assert.isFalse(any(falsePredicate, falsePredicate)('value'));\n    });\n\n    it('does not call all predicates if one of them has been satisfied earlier', function () {\n        assert.isTrue(any(truePredicate, function () {\n            throw new Error('Last predicate should not be called');\n        })('value'));\n    });\n\n    it('description', () => {\n        assertDescription(any(isString, isNumber), 'a value that satisfies any of predicates: a string, a number')\n    });\n\n    it('for simple types', () => {\n        const noop = function () {\n        };\n        assert.isTrue(any(String, falsePredicate)('test'));\n        assert.isTrue(any(Boolean, falsePredicate)(false));\n        assert.isTrue(any(RegExp, falsePredicate)(/a/));\n        assert.isTrue(any(Object, falsePredicate)({test: 1}));\n        assert.isTrue(any(Function, falsePredicate)(noop));\n        assert.isTrue(any(Date, falsePredicate)(new Date()));\n        assert.isTrue(any(Array, falsePredicate)([]));\n    })\n});\n\n'predicates/src/weakSet.ts'\n:import {setDescription} from './utils/description';\n\n\nexport default function isWeakSet<T extends object = any>(value: any): value is WeakSet<T> {\n    return typeof WeakSet !== 'undefined' && value instanceof WeakSet;\n}\n\nsetDescription(isWeakSet, 'a WeakSet');\n\n'predicates/src/utils/assertPredicates.ts'\n:import {Predicate} from \"../types\";\nimport isFunction from '../function';\nimport isArrayOf from '../arrayOf';\n\nexport default function assertPredicates(predicates: Predicate[]) {\n    if (!isArrayOf(isFunction, predicates)) {\n        throw new TypeError('Every predicate must be a function');\n    }\n    if (predicates.length < 2) {\n        throw new Error('You need to provide at least two predicates');\n    }\n}\n\n\n'predicates/src/arrayOf.ts'\n:import {Predicate, TypeGuardPredicate} from './types';\n\nimport isArray from './array';\nimport isFunction from './function';\nimport handleCurry from './utils/handleCurry';\nimport {getDescription, setDescription} from './utils/description';\nimport {getPredicateForType} from './typeToPredicate';\n\n\nfunction isArrayOf<T = any>(predicate: Predicate | Function): TypeGuardPredicate<Array<T>>;\nfunction isArrayOf<T = any>(predicate: Predicate | Function, value: any[]): value is Array<T>;\nfunction isArrayOf<T>(predicate: Predicate | Function, value?: any[], ...extraArgs: any[]): boolean | TypeGuardPredicate<Array<T>> {\n    if (!isFunction(predicate)) {\n        throw new TypeError('Predicate must be a function');\n    }\n\n    predicate = getPredicateForType(predicate) || predicate;\n\n    return handleCurry.call(this, arguments,\n        setDescription(function (value: any) {\n                const match = (value: any) => predicate.apply(this, [value].concat(extraArgs));\n                return isArray(value) && value.every(match);\n            },\n            'an array of elements of type: ' + getDescription(<Predicate>predicate)\n        )\n    );\n}\n\nexport default isArrayOf;",
        "gt": [
            "'predicates/src/weakSet.ts'",
            "'predicates/src/typeToPredicate.ts'",
            "'predicates/src/arrayOf.ts'",
            "'predicates/src/utils/assertPredicates.ts'",
            "'predicates/src/any.ts'",
            "'predicates/test/anyTest.ts'"
        ]
    },
    {
        "files": [
            "'angular4-starter/src/app/my-account/my-account.module.ts'",
            "'angular4-starter/src/app/my-account/my-account.component.ts'",
            "'angular4-starter/src/main.ts'",
            "'angular4-starter/src/app/app.module.ts'"
        ],
        "content": "'angular4-starter/src/app/my-account/my-account.module.ts'\n:import { Injectable, NgModule } from '@angular/core';\nimport { Resolve, RouterModule, Routes } from '@angular/router';\nimport { SharedModule } from '../commons/shared.module';\n\nimport { MyAccountComponent } from './my-account.component';\nimport { Observable } from 'rxjs';\nimport { AuthHttp } from 'angular2-jwt';\nimport { Response } from '@angular/http';\nimport { StoreService } from '../components/storage/store.service';\nimport { HttpFallback } from '../components/http/http.fallback.service';\n\n\nexport interface Profile {\n\tname: string;\n\temail: string;\n}\n\n\n@Injectable()\nexport class ProfileResolver implements Resolve<Response> {\n\tconstructor(private authHttp: AuthHttp,\n\t            private store: StoreService,\n\t            private httpFallback: HttpFallback) {\n\t}\n\n\tresolve(): Observable<Response> {\n\t\tlet profile = this.store.get('profile');\n\n\t\treturn this.authHttp.get('/api/profiles/' + profile.id)\n\t\t\t.catch((err) => {\n\t\t\t\tthis.httpFallback.fallback(err);\n\t\t\t\treturn Observable.throw(err);\n\t\t\t});\n\t}\n}\n\nconst routes: Routes = [\n\t{\n\t\tpath: 'my-account',\n\t\tcomponent: MyAccountComponent,\n\t\tresolve: { profile: ProfileResolver }\n\t}\n];\n\n@NgModule({\n\timports: [\n\t\tRouterModule.forChild(routes),\n\t\tSharedModule\n\t],\n\tdeclarations: [\n\t\tMyAccountComponent\n\t],\n\tproviders: [\n\t\tProfileResolver\n\t]\n})\n\nexport class MyAccountModule {}\n\n'angular4-starter/src/app/my-account/my-account.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { HttpFallback } from '../components/http/http.fallback.service';\n\n@Component({\n\tselector: 'my-account',\n\ttemplateUrl: './my-account.component.html',\n\tstyleUrls: [ './my-account.component.scss' ]\n})\n\nexport class MyAccountComponent implements OnInit {\n\tprofile: Observable<any>;\n\n\tconstructor(r: ActivatedRoute, private httpFallback: HttpFallback) {\n\t\tr.data.subscribe((res) => {\n\t\t\tthis.profile = res.profile.json();\n\t\t}, (err) => {\n\t\t\tthis.httpFallback.fallback(err);\n\t\t});\n\t}\n\n\tngOnInit() {\n\t}\n}\n\n'angular4-starter/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app/app.module';\n\nexport function main() {\n    platformBrowserDynamic().bootstrapModule(AppModule);\n}\n\nconst ENV: any = process.env.ENV;\n\nif (ENV && ENV.mode !== 'development') {\n    enableProdMode();\n}\n\nif (document.readyState === 'complete') {\n    main();\n} else {\n    document.addEventListener('DOMContentLoaded', main);\n}\n\n'angular4-starter/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { HttpModule, Http, BrowserXhr } from '@angular/http';\nimport { NgProgressModule, NgProgressBrowserXhr } from 'ngx-progressbar';\nimport { BrowserModule }  from '@angular/platform-browser';\nimport { TranslateStaticLoader, TranslateLoader, TranslateModule } from 'ng2-translate';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { AuthModule } from './components/auth/auth.module';\n\n\nimport { AuthGuard } from './components/auth/auth-guard.service';\nimport { AuthService } from './components/auth/auth.service';\nimport { HttpFallback } from './components/http/http.fallback.service';\nimport { StoreService } from './components/storage/store.service';\n\n\nimport { HomeModule } from './home/home.module';\nimport { LoginModule } from './login/login.module';\nimport { MyAccountModule } from './my-account/my-account.module';\nimport { AboutModule } from './about/about.module';\nimport { UnavailableModule } from './unavailable/unavailable.module';\n\nimport { HeaderComponent } from './commons/header/header.component';\nimport { FooterComponent } from './commons/footer/footer.component';\n\nimport { NgbModule } from '@ng-bootstrap/ng-bootstrap';\nimport { routing } from './app.routing';\nimport { SharedModule } from './commons/shared.module';\n\n@NgModule({\n    imports: [\n        BrowserModule,\n        HttpModule,\n        NgProgressModule,\n        FormsModule,\n\t    NgbModule.forRoot(),\n        TranslateModule.forRoot({\n            provide: TranslateLoader,\n            useFactory: (http: Http) => new TranslateStaticLoader(http, '/public/locales', '.json'),\n            deps: [Http]\n        }),\n        routing,\n        SharedModule,\n        AuthModule,\n\t    HomeModule,\n\t    LoginModule,\n\t    MyAccountModule,\n\t    AboutModule,\n\t    UnavailableModule\n    ],\n    declarations: [\n        AppComponent,\n        HeaderComponent,\n        FooterComponent\n    ],\n    providers: [\n        AuthGuard,\n        AuthService,\n        StoreService,\n        HttpFallback,\n        { provide: BrowserXhr, useClass: NgProgressBrowserXhr }\n    ],\n    bootstrap: [ AppComponent ]\n})\n\nexport class AppModule {}\n",
        "gt": [
            "'angular4-starter/src/app/my-account/my-account.component.ts'",
            "'angular4-starter/src/app/my-account/my-account.module.ts'",
            "'angular4-starter/src/app/app.module.ts'",
            "'angular4-starter/src/main.ts'"
        ]
    },
    {
        "files": [
            "'among-us-stats/src/store/stats/statsSelectors.tsx'",
            "'among-us-stats/src/components/sessions/Sessions.tsx'",
            "'among-us-stats/src/components/sessions/Sessions.test.tsx'"
        ],
        "content": "'among-us-stats/src/store/stats/statsSelectors.tsx'\n:import { RootState } from '../redux';\n\nimport { EnhancedPlayer, Player, Session, SessionPlayer, UUID } from './statsRedux';\nimport { getPlayer } from './statsUtils';\n\nconst createEnhancePlayer = (players: Record<UUID, Player>) => (\n  sessionPlayer: SessionPlayer,\n): EnhancedPlayer | null => {\n  const player = getPlayer(players, sessionPlayer.playerId);\n\n  if (player == null) {\n    return null;\n  }\n\n  return {\n    ...player,\n    ...sessionPlayer,\n  };\n};\n\nexport const getSession = (state: RootState): Session<EnhancedPlayer> => {\n  const enhancePlayer = createEnhancePlayer(state.stats.players);\n\n  return {\n    ...state.stats.session,\n    players: state.stats.session.players.map(enhancePlayer).filter((it): it is Player & SessionPlayer => it != null),\n  };\n};\n\nexport const getPreviousSessions = (state: RootState): Session<EnhancedPlayer>[] => {\n  const enhancePlayer = createEnhancePlayer(state.stats.players);\n\n  return state.stats.previousSessions.map((session) => ({\n    ...session,\n    players: session.players.map(enhancePlayer).filter((it): it is Player & SessionPlayer => it != null),\n  }));\n};\n\nexport const getPlayers = (state: RootState): Player[] =>\n  Object.keys(state.stats.players).map((it) => state.stats.players[it]);\n\n'among-us-stats/src/components/sessions/Sessions.tsx'\n:import React from 'react';\nimport { useSelector } from 'react-redux';\nimport { useHistory } from 'react-router-dom';\nimport Box from '@material-ui/core/Box';\nimport Paper from '@material-ui/core/Paper';\nimport Grid from '@material-ui/core/Grid';\nimport CheckIcon from '@material-ui/icons/Check';\nimport Typography from '@material-ui/core/Typography';\nimport { useDispatch } from 'react-redux';\n\nimport SummaryCard from '../shared/SummaryCard';\nimport { statsSlice } from '../../store/stats/statsRedux';\nimport BreakpointButton from '../shared/BreakpointButton';\nimport { getPreviousSessions } from '../../store/stats/statsSelectors';\nimport { byDate } from '../../utils/dateUtils';\n\nimport DeleteSessionButton from './DeleteSessionButton';\n\nfunction Sessions(): JSX.Element {\n  const dispatch = useDispatch();\n  const previous = useSelector(getPreviousSessions);\n  const history = useHistory();\n\n  const createHandleSwapClick = (sessionId: string) => () => {\n    dispatch(statsSlice.actions.swapSession({ sessionId }));\n    history.push('/');\n  };\n\n  return (\n    <Grid container spacing={3}>\n      {previous.sort(byDate).map((it) => (\n        <Grid key={it.sessionId} item xs={12} md={6}>\n          <Paper>\n            <SummaryCard\n              session={it}\n              extraActions={\n                <>\n                  <BreakpointButton\n                    text=\"Set as active\"\n                    startIcon={<CheckIcon />}\n                    onClick={createHandleSwapClick(it.sessionId)}\n                    label=\"Set this session as active\"\n                    size=\"small\"\n                  />\n                  <DeleteSessionButton session={it} />\n                </>\n              }\n            />\n          </Paper>\n        </Grid>\n      ))}\n      {previous.length === 0 && (\n        <Grid item xs={12}>\n          <Box p={4} display=\"flex\" justifyContent=\"center\">\n            <Box>\n              <Typography variant=\"h5\">No previous sessions found</Typography>\n              <Box m={2} />\n              <Typography variant=\"body1\">\n                Finish your current session and click the {`\"New session\"`} button!\n              </Typography>\n            </Box>\n          </Box>\n        </Grid>\n      )}\n    </Grid>\n  );\n}\n\nexport default Sessions;\n\n'among-us-stats/src/components/sessions/Sessions.test.tsx'\n:import React from 'react';\nimport userEvent from '@testing-library/user-event';\n\nimport { providerRender, screen } from '../../test/testUtils';\nimport { initialStatsState } from '../../store/stats/statsRedux';\nimport { createSessionPlayers, testPlayers } from '../../test/testData';\n\nimport Sessions from './Sessions';\n\ndescribe('Sessions', () => {\n  describe('when clicking \"Set active\" button', () => {\n    it('should set session as active and put current one in previous', () => {\n      const [, store] = providerRender(<Sessions />, {\n        initialState: {\n          stats: {\n            ...initialStatsState,\n            players: testPlayers,\n            session: {\n              ...initialStatsState.session,\n              sessionId: 'originally-current-session',\n              players: createSessionPlayers(testPlayers),\n            },\n            previousSessions: [{ ...initialStatsState.session, sessionId: 'session-to-set-active' }],\n          },\n        },\n      });\n\n      userEvent.click(screen.getByRole('button', { name: 'Set this session as active' }));\n\n      expect(store.getState().stats.session.sessionId).toEqual('session-to-set-active');\n    });\n  });\n\n  describe('when clicking delete button', () => {\n    it('should show confirmation dialog and delete from state', () => {\n      const [, store] = providerRender(<Sessions />, {\n        initialState: {\n          stats: {\n            ...initialStatsState,\n            players: testPlayers,\n            session: {\n              ...initialStatsState.session,\n              players: createSessionPlayers(testPlayers),\n            },\n            previousSessions: [\n              { ...initialStatsState.session, sessionId: 'session-to-delete', name: 'Not very important session' },\n            ],\n          },\n        },\n      });\n\n      userEvent.click(screen.getByRole('button', { name: 'Delete this session' }));\n\n      expect(screen.getByRole('heading', { name: 'Delete session \"Not very important session\"?' })).toBeInTheDocument();\n\n      userEvent.click(screen.getByRole('button', { name: 'Delete' }));\n\n      expect(store.getState().stats.previousSessions).toHaveLength(0);\n    });\n  });\n});\n",
        "gt": [
            "'among-us-stats/src/store/stats/statsSelectors.tsx'",
            "'among-us-stats/src/components/sessions/Sessions.tsx'",
            "'among-us-stats/src/components/sessions/Sessions.test.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/api/webapp/rankings/rankings.module.ts'",
            "'Rankings-Backend/src/api/webapp/rankings/rankings.controller.ts'",
            "'Rankings-Backend/src/api/webapp/index.ts'",
            "'Rankings-Backend/src/api/webapp/api.module.ts'"
        ],
        "content": "'Rankings-Backend/src/api/webapp/rankings/rankings.module.ts'\n:import { Module } from '@nestjs/common';\n\nimport { DatabaseModule } from 'api/webapp/database.module';\nimport { AthleteService } from 'core/athlete/athlete.service';\nimport { RankingsService } from 'core/athlete/rankings.service';\nimport { CategoriesService } from 'core/category/categories.service';\nimport { RankingsController } from './rankings.controller';\n\n@Module({\n  imports: [DatabaseModule],\n  controllers: [RankingsController],\n  providers: [RankingsService, CategoriesService, AthleteService],\n})\nexport class RankingsModule {}\n\n'Rankings-Backend/src/api/webapp/rankings/rankings.controller.ts'\n:import { Body, Controller, Get, Param, Post, UsePipes } from '@nestjs/common';\n\nimport { AthleteService } from 'core/athlete/athlete.service';\nimport { RankingsCategory } from 'core/athlete/interfaces/rankings.interface';\nimport { RankingsService } from 'core/athlete/rankings.service';\nimport { CategoriesService } from 'core/category/categories.service';\nimport { AgeCategory, Discipline, Gender, RankingType } from 'shared/enums';\nimport { YearUtility } from 'shared/enums/enums-utility';\nimport { JoiValidationPipe } from 'shared/pipes/JoiValidation.pipe';\nimport { Utils } from '../../../shared/utils';\nimport { CategoriesDto } from './dto/categories.dto';\nimport { CategoriesResponse } from './dto/categories.response';\nimport { RankingsListDto, rankingsListDtoSchema } from './dto/rankings-list.dto';\nimport { IRankingsListItem, RankingsListResponse } from './dto/rankings-list.response';\n\n@Controller('rankings')\nexport class RankingsController {\n  constructor(\n    private readonly rankingsService: RankingsService,\n    private readonly categoriesService: CategoriesService,\n    private readonly athleteService: AthleteService,\n  ) {}\n  private defaultCategories = [\n    RankingType.TopScore,\n    Discipline.Trickline_Aerial,\n    Gender.Men,\n    YearUtility.AllYears[0],\n    AgeCategory.All,\n  ];\n\n  @Post('categories')\n  public getCategories(@Body() dto: CategoriesDto): CategoriesResponse {\n    let selectedCategories = dto.selectedCategories || [];\n    if (selectedCategories.length < 5) {\n      selectedCategories = this.defaultCategories;\n    }\n    const rankingType = selectedCategories[0];\n    const categories = this.categoriesService.getCategories();\n    if (rankingType === RankingType.TopScore) {\n      categories.year.options[0].label = 'Last 3';\n    }\n    return new CategoriesResponse([\n      categories.rankingType,\n      categories.discipline,\n      categories.gender,\n      categories.year,\n      categories.age,\n    ]);\n  }\n\n  @Post('list')\n  @UsePipes(new JoiValidationPipe(rankingsListDtoSchema))\n  public async getRankingsList(@Body() dto: RankingsListDto): Promise<RankingsListResponse> {\n    let categories = dto.selectedCategories || [];\n    if (categories.length < 5) {\n      categories = this.defaultCategories;\n    }\n    const rankingType = categories[0];\n    const discipline = categories[1];\n    const gender = categories[2];\n    const year = categories[3];\n    const ageCategory = categories[4];\n\n    const category: RankingsCategory = { rankingType, discipline, year, gender, ageCategory };\n    const rankings = await this.rankingsService.queryRankings(20, category, {\n      athleteId: dto.athleteId,\n      after: dto.next,\n      country: dto.country,\n    });\n    const rankingsWithAthletes = await Promise.all(\n      rankings.items.map(async (item, index) => {\n        const athlete = await this.athleteService.getAthlete(item.id);\n        let currentRank: number;\n\n        currentRank = await this.rankingsService.getAthleteRankInCategory({ athleteId: item.id, ...category });\n\n\n        return { athlete, ranking: item, currentRank: currentRank };\n      }),\n    );\n    return new RankingsListResponse(\n      rankingsWithAthletes.map<IRankingsListItem>(obj => {\n        return {\n          id: obj.ranking.id,\n          age: obj.ranking.age,\n          country: obj.ranking.country,\n          name: obj.ranking.name,\n          points: obj.ranking.points.toString(),\n\n          rank: dto.athleteId || dto.country ? obj.currentRank : undefined,\n          thumbnailUrl: obj.athlete.thumbnailUrl || obj.athlete.profileUrl,\n          surname: obj.ranking.surname,\n        };\n      }),\n      rankings.lastKey,\n    );\n  }\n}\n\n'Rankings-Backend/src/api/webapp/index.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { APIGatewayEvent, Callback, Context, Handler } from 'aws-lambda';\n\nimport 'shared';\n\nimport { AllExceptionsFilter } from 'shared/filters/exception.filter';\nimport { waitForLogger } from 'shared/logger';\nimport { AppModule } from './api.module';\n\nimport * as serverless from 'aws-serverless-express';\nimport { eventContext } from 'aws-serverless-express/middleware';\n\nimport { Server } from 'http';\nimport env_variables from 'shared/env_variables';\nlet cachedServer: Server;\n\n\nconst express = require('express')();\n\nasync function bootstrapServer(): Promise<any> {\n  return NestFactory.create(AppModule, express, {\n    bodyParser: true,\n    logger: env_variables.isDev ? undefined : false,\n  })\n    .then(app => {\n      app.use(eventContext());\n      app.useGlobalFilters(new AllExceptionsFilter());\n      app.setGlobalPrefix('api');\n      app.enableCors();\n      return app.init();\n    })\n    .then(() => {\n      return serverless.createServer(express);\n    });\n}\n\nexport const handler: Handler = async (event: APIGatewayEvent, context: Context) => {\n\n  context.succeed = succeedWaitsLogger(context.succeed);\n  if (!cachedServer) {\n    cachedServer = await bootstrapServer();\n  }\n  return serverless.proxy(cachedServer, event, context, 'PROMISE').promise;\n};\n\nfunction succeedWaitsLogger(succeed: Context['succeed']): Context['succeed'] {\n  return (messageObject: any) => {\n    return waitForLogger()\n      .then(() => {\n        succeed(messageObject);\n      })\n      .catch(error => {\n        succeed(messageObject);\n      });\n  };\n}\n\n'Rankings-Backend/src/api/webapp/api.module.ts'\n:import { HelmetMiddleware } from '@nest-middlewares/helmet';\nimport { MethodOverrideMiddleware } from '@nest-middlewares/method-override';\nimport { MorganMiddleware } from '@nest-middlewares/morgan';\nimport { MiddlewareConsumer, Module } from '@nestjs/common';\n\nimport env_variables from 'shared/env_variables';\n\nimport { AthleteModule } from './athlete/athlete.module';\nimport { ContestModule } from './contest/contest.module';\nimport { CountryModule } from './country/country.module';\nimport { NestJSTestController } from './nestjsTest.controller';\nimport { RankingsModule } from './rankings/rankings.module';\n\n@Module({\n  imports: [CountryModule, AthleteModule, ContestModule, RankingsModule],\n  controllers: [NestJSTestController],\n  providers: [],\n  exports: [],\n})\nexport class AppModule {\n  public configure(consumer: MiddlewareConsumer) {\n    MorganMiddleware.configure(env_variables.morganConfig);\n    consumer.apply(MorganMiddleware).forRoutes('*');\n    consumer.apply(MethodOverrideMiddleware).forRoutes('*');\n    consumer.apply(HelmetMiddleware).forRoutes('*');\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/api/webapp/rankings/rankings.controller.ts'",
            "'Rankings-Backend/src/api/webapp/rankings/rankings.module.ts'",
            "'Rankings-Backend/src/api/webapp/api.module.ts'",
            "'Rankings-Backend/src/api/webapp/index.ts'"
        ]
    },
    {
        "files": [
            "'petfinder-js-sdk/tests/api/animalData.test.ts'",
            "'petfinder-js-sdk/src/api/animal.ts'",
            "'petfinder-js-sdk/src/main.ts'"
        ],
        "content": "'petfinder-js-sdk/tests/api/animalData.test.ts'\n:import axios from \"axios\";\nimport MockAdapter from \"axios-mock-adapter\";\n\nimport { AnimalData } from \"../../src/api/animalData\";\nimport { Client } from \"../../src/main\";\n\nit(\"Creates animal data client\", () => {\n    const client = new Client({apiKey: \"foo\", secret: \"bar\"});\n    const animal = new AnimalData(client);\n\n    expect(animal).toBeInstanceOf(AnimalData);\n    expect(client.animalData).toBeInstanceOf(AnimalData);\n});\n\nit(\"Can get animal types\", async () => {\n    const mock = new MockAdapter(axios);\n    const client = new AnimalData(new Client({apiKey: \"foo\", secret: \"bar\", token: \"test\"}));\n\n    mock.onGet(\"/types\").reply(200, {\n        success: true,\n    });\n\n    const response = await client.types();\n    expect(response.data.success).toEqual(true);\n});\n\nit(\"Can get single animal type\", async () => {\n    const mock = new MockAdapter(axios);\n    const client = new AnimalData(new Client({apiKey: \"foo\", secret: \"bar\", token: \"test\"}));\n\n    mock.onGet(\"/types/Dog\").reply(200, {\n        success: true,\n    });\n\n    const response = await client.type(\"Dog\");\n    expect(response.data.success).toEqual(true);\n});\n\nit(\"Can get animal breeds\", async () => {\n    const mock = new MockAdapter(axios);\n    const client = new AnimalData(new Client({apiKey: \"foo\", secret: \"bar\", token: \"test\"}));\n\n    mock.onGet(\"/types/Dog/breeds\").reply(200, {\n        success: true,\n    });\n\n    const response = await client.breeds(\"Dog\");\n    expect(response.data.success).toEqual(true);\n});\n\n'petfinder-js-sdk/src/api/animal.ts'\n:import { AxiosResponse } from \"axios\";\n\nimport { ApiClient } from \"./client\";\n\nexport class Animal extends ApiClient {\n    public async search(params: object = {}): Promise<AxiosResponse> {\n        await this.ensureAuthenticated();\n        return this.http.get(\"/animals\", {\n            params,\n        });\n    }\n\n    public async show(id: number): Promise<AxiosResponse> {\n        await this.ensureAuthenticated();\n        return this.http.get(`/animals/${id}`);\n    }\n}\n\n'petfinder-js-sdk/src/main.ts'\n:import axios, { AxiosError, AxiosInstance, AxiosResponse } from \"axios\";\n\nimport { Animal } from \"./api/animal\";\nimport { AnimalData } from \"./api/animalData\";\nimport { Organization } from \"./api/organization\";\nimport { ProblemDetailsError } from \"./error\";\n\ninterface ClientConfig {\n    apiKey: string;\n    secret: string;\n    token?: string;\n    baseUrl?: string;\n}\n\nexport class Client {\n    public http: AxiosInstance;\n    private config: ClientConfig;\n\n    constructor(config: ClientConfig) {\n        this.config = config;\n        this.http = axios.create({\n            baseURL: config.baseUrl || \"https:\n            headers: {\"x-api-sdk\": \"petfinder-js-sdk/v1.0 (https:\n        });\n\n        this.http.interceptors.response.use((response: AxiosResponse) => {\n            return response;\n        }, (error: AxiosError) => {\n            if (error.response && this.isProblemDetailsResponse(error.response)) {\n                return Promise.reject(new ProblemDetailsError(error.request, error.response));\n            }\n\n            return Promise.reject(error);\n        });\n    }\n\n    get animalData(): AnimalData {\n        return new AnimalData(this);\n    }\n\n    get animal(): Animal {\n        return new Animal(this);\n    }\n\n    get organization(): Organization {\n        return new Organization(this);\n    }\n\n    public async authenticate(token?: string): Promise<void | AxiosResponse> {\n        let response;\n        let accessToken = token || this.config.token;\n\n        if (!accessToken) {\n            response = await this.http.post(\"/oauth2/token\", {\n\n                client_id: this.config.apiKey,\n\n                client_secret: this.config.secret,\n\n                grant_type: \"client_credentials\",\n            });\n            accessToken = response.data.access_token;\n        }\n\n        this.config.token = accessToken;\n        this.http.defaults.headers.common.Authorization = `Bearer ${accessToken}`;\n\n        return response;\n    }\n\n    private isProblemDetailsResponse(response: AxiosResponse): boolean {\n        const headers = response.headers || {};\n        const contentType = headers[\"content-type\"] || \"\";\n        return contentType.includes(\"application/problem+json\");\n    }\n}\n",
        "gt": [
            "'petfinder-js-sdk/src/api/animal.ts'",
            "'petfinder-js-sdk/src/main.ts'",
            "'petfinder-js-sdk/tests/api/animalData.test.ts'"
        ]
    },
    {
        "files": [
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'",
            "'installer-gui/frontend/components/AppContext.ts'"
        ],
        "content": "'installer-gui/frontend/components/App.tsx'\n:import Preact, {Component} from \"preact\";\nimport InstallPage from \"./actions/install\";\nimport UninstallPage from \"./actions/uninstall\";\nimport UpdatePage from \"./actions/update\";\nimport AppContext from \"./AppContext\";\nimport Category from \"./category\";\nimport Install from \"./icons/install\";\nimport Uninstall from \"./icons/uninstall\";\nimport Update from \"./icons/update\";\nimport {Notifications} from \"./notifications\";\nimport TitleBar from \"./titlebar\";\n\nexport default class App extends Component {\n    state = {navigator: {}}\n\n    handleSetPage({element, title}): void {\n        this.setState({\n            navigator: {element, title}\n        });\n    }\n\n    handleReset(): void {\n        this.setState({navigator: {}});\n    }\n\n    renderHome() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Actions</div>\n                <Category title=\"Install\" icon={Install} note=\"Install kernel to an application you choose.\">\n                    <InstallPage />\n                </Category>\n                <Category title=\"Uninstall\" icon={Uninstall} note=\"Uninstall kernel from an application you choose.\">\n                    <UninstallPage />\n                </Category>\n                <Category title=\"Update\" icon={Update} note=\"Update the kernel.asar to the latest release.\">\n                    <UpdatePage />\n                </Category>\n            </div>\n        );\n    }\n\n    render(_, {navigator}) {\n        const context = {\n            currentPage: navigator,\n            setPage: this.handleSetPage.bind(this),\n            reset: this.handleReset.bind(this)\n        };\n\n        return (\n            <AppContext.Provider value={context}>\n                <div id=\"app-mount\">\n                    <TitleBar />\n                    <div class=\"app\">\n                        {navigator.element ? navigator.element : this.renderHome()}\n                    </div>\n                    <Notifications />\n                </div>\n            </AppContext.Provider>\n        );\n    }\n}\n'installer-gui/frontend/index.ts'\n:import {h, render} from \"preact\";\nimport App from \"./components/App\";\nimport Styles from \"./styles\";\nimport {createElement} from \"./util\";\nimport \"./index.scss\";\n\nStyles.inject();\nconst root = createElement(\"div\", {id: \"root\"});\ndocument.body.appendChild(root);\n\nrender(\n    h(App, {}),\n    root\n);\n'installer-gui/frontend/components/AppContext.ts'\n:import {createContext} from \"preact\";\n\nconst AppContext = createContext<{\n    setPage: ({element: any, title: string}) => void;\n    reset: () => void;\n    currentPage: {element: any, title: string}\n}>(null);\n\nexport default AppContext;",
        "gt": [
            "'installer-gui/frontend/components/AppContext.ts'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'"
        ]
    },
    {
        "files": [
            "'ngrx-course-v4/src/app/thread-section/thread-section.component.spec.ts'",
            "'ngrx-course-v4/src/app/shared/mapping/buildThreadParticipantsList.ts'",
            "'ngrx-course-v4/src/app/thread-section/thread-section.component.ts'",
            "'ngrx-course-v4/src/app/store/utils.ts'",
            "'ngrx-course-v4/src/app/store/application-state.ts'",
            "'ngrx-course-v4/src/app/thread-section/stateToThreadSummariesSelector.ts'"
        ],
        "content": "'ngrx-course-v4/src/app/thread-section/thread-section.component.spec.ts'\n:\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\nimport { By } from '@angular/platform-browser';\nimport { DebugElement } from '@angular/core';\n\nimport { ThreadSectionComponent } from './thread-section.component';\n\ndescribe('ThreadSectionComponent', () => {\n  let component: ThreadSectionComponent;\n  let fixture: ComponentFixture<ThreadSectionComponent>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ ThreadSectionComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(ThreadSectionComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n\n'ngrx-course-v4/src/app/shared/mapping/buildThreadParticipantsList.ts'\n:\nimport {ApplicationState} from \"../../store/application-state\";\nimport {Thread} from \"../../../../shared/model/thread\";\nimport * as _ from 'lodash';\n\n\nexport function buildThreadParticipantsList(state:ApplicationState, thread:Thread):string {\n\n    const names = _.keys(thread.participants).map(\n        participantId => state.storeData.participants[participantId].name);\n\n    return _.join(names, \",\");\n}\n'ngrx-course-v4/src/app/thread-section/thread-section.component.ts'\n:import {Component, OnInit} from '@angular/core';\nimport {ThreadsService} from \"../services/threads.service\";\nimport {Store} from \"@ngrx/store\";\nimport {ApplicationState} from \"../store/application-state\";\nimport {UserThreadsLoadedAction, LoadUserThreadsAction, ThreadSelectedAction} from \"../store/actions\";\nimport {Observable} from \"rxjs/Observable\";\nimport {ThreadSummaryVM} from \"./thread-summary.vm\";\nimport {userNameSelector} from \"./userNameSelector\";\nimport {mapStateToUnreadMessagesCounter} from \"./mapStateToUnreadMessagesCounter\";\nimport {stateToThreadSummariesSelector} from \"./stateToThreadSummariesSelector\";\nimport {UiState} from \"../store/ui-state\";\n\nimport * as _ from 'lodash';\n\n@Component({\n    selector: 'thread-section',\n    templateUrl: './thread-section.component.html',\n    styleUrls: ['./thread-section.component.css']\n})\nexport class ThreadSectionComponent {\n\n    userName$: Observable<string>;\n    unreadMessagesCounter$: Observable<number>;\n    threadSummaries$: Observable<ThreadSummaryVM[]>;\n\n    uiState: UiState;\n\n    constructor(private store: Store<ApplicationState>) {\n\n        this.userName$ = store.select(userNameSelector);\n\n        this.unreadMessagesCounter$ = store.map(mapStateToUnreadMessagesCounter);\n\n        this.threadSummaries$ = store.select(stateToThreadSummariesSelector);\n\n        store.select(state => state.uiState).subscribe(uiState => this.uiState =  _.cloneDeep(uiState) );\n\n    }\n\n    onThreadSelected(selectedThreadId:number) {\n        this.store.dispatch(\n            new ThreadSelectedAction({selectedThreadId, currentUserId: this.uiState.userId}));\n    }\n\n}\n\n\n\n\n\n\n\n'ngrx-course-v4/src/app/store/utils.ts'\n:\n\nimport { RouterStateSerializer } from '@ngrx/router-store';\nimport { RouterStateSnapshot, Params } from '@angular/router';\n\n\n\nexport interface RouterStateUrl {\n    url: string;\n    queryParams: Params;\n}\n\nexport class CustomRouterStateSerializer\n    implements RouterStateSerializer<RouterStateUrl> {\n    serialize(routerState: RouterStateSnapshot): RouterStateUrl {\n        const { url } = routerState;\n        const queryParams = routerState.root.queryParams;\n\n        return { url, queryParams };\n    }\n}\n'ngrx-course-v4/src/app/store/application-state.ts'\n:import {UiState, INITIAL_UI_STATE} from \"./ui-state\";\nimport {StoreData, INITIAL_STORE_DATA} from \"./store-data\";\nimport {RouterStateUrl} from \"./utils\";\nimport * as fromRouter from '@ngrx/router-store';\n\n\nexport interface ApplicationState {\n    uiState: UiState,\n    storeData: StoreData,\n    routerReducer: fromRouter.RouterReducerState<RouterStateUrl>;\n}\n\n\nexport const INITIAL_APPLICATION_STATE: ApplicationState = {\n    uiState: INITIAL_UI_STATE,\n    storeData: INITIAL_STORE_DATA,\n    routerReducer: undefined\n};\n'ngrx-course-v4/src/app/thread-section/stateToThreadSummariesSelector.ts'\n:\nimport {ApplicationState} from \"../store/application-state\";\nimport {Thread} from \"../../../shared/model/thread\";\nimport {ThreadSummaryVM} from \"./thread-summary.vm\";\nimport * as _ from 'lodash';\nimport {buildThreadParticipantsList} from \"../shared/mapping/buildThreadParticipantsList\";\n\nconst deepFreeze = require('deep-freeze-strict');\n\nexport function stateToThreadSummariesSelector(state: ApplicationState):ThreadSummaryVM[] {\n\n    const threads = _.values<Thread>(state.storeData.threads);\n\n    return deepFreeze(threads.map(_.partial(mapThreadToThreadSummary, state)));\n}\n\n\nfunction mapThreadToThreadSummary(state:ApplicationState, thread:Thread): ThreadSummaryVM {\n\n    const lastMessageId = _.last(thread.messageIds),\n        lastMessage = state.storeData.messages[lastMessageId];\n\n    return {\n        id: thread.id,\n        participantNames: buildThreadParticipantsList(state, thread),\n        lastMessageText: lastMessage.text,\n        timestamp: lastMessage.timestamp,\n        read: thread.id === state.uiState.currentThreadId || thread.participants[state.uiState.userId] === 0\n    }\n}",
        "gt": [
            "'ngrx-course-v4/src/app/store/utils.ts'",
            "'ngrx-course-v4/src/app/store/application-state.ts'",
            "'ngrx-course-v4/src/app/shared/mapping/buildThreadParticipantsList.ts'",
            "'ngrx-course-v4/src/app/thread-section/stateToThreadSummariesSelector.ts'",
            "'ngrx-course-v4/src/app/thread-section/thread-section.component.ts'",
            "'ngrx-course-v4/src/app/thread-section/thread-section.component.spec.ts'"
        ]
    },
    {
        "files": [
            "'extension/src/pages/panel/components/Nav.tsx'",
            "'extension/src/components/icons/BaseIcon.tsx'",
            "'extension/src/components/Welcome.tsx'",
            "'extension/src/pages/panel/index.tsx'",
            "'extension/src/pages/panel/App.tsx'",
            "'extension/src/components/icons/IconAmazon.tsx'"
        ],
        "content": "'extension/src/pages/panel/components/Nav.tsx'\n:import { useState } from \"react\";\n\nimport alveus from \"../../../assets/alveus.png\";\n\nimport IconInfo from \"../../../components/icons/IconInfo\";\nimport Welcome from \"../../../components/Welcome\";\n\nimport Overlay from \"./Overlay\";\n\nexport default function Nav() {\n  const [showWelcome, setShowWelcome] = useState<boolean>(false);\n\n  return (\n    <nav className=\"bg-alveus-green/85 fixed inset-x-0 top-0 z-10 flex h-12 w-full items-center justify-start gap-3 px-4 shadow-lg backdrop-blur sm:justify-center\">\n      <img className=\"h-8 w-auto\" src={alveus} alt=\"Alveus Logo\" />\n      <h1 className=\"text-lg\">Alveus Ambassadors</h1>\n      <button\n        className=\"group -mr-2 ml-auto rounded-full p-2 sm:absolute sm:right-4 sm:ml-0\"\n        onClick={() => setShowWelcome(true)}\n        title=\"Info\"\n      >\n        <IconInfo\n          size={20}\n          className=\"outline-highlight rounded-full transition-[outline] group-hover:outline\"\n        />\n      </button>\n\n      <Overlay show={showWelcome} onClose={() => setShowWelcome(false)}>\n        <Welcome />\n      </Overlay>\n    </nav>\n  );\n}\n\n'extension/src/components/icons/BaseIcon.tsx'\n:import { type SVGProps, type ReactNode } from \"react\";\n\nexport type IconProps = SVGProps<SVGSVGElement> & {\n  size?: number | string;\n  className?: string;\n  alt?: string;\n};\n\nexport type BaseIconProps = IconProps & {\n  viewBox: string;\n  children: ReactNode | ReactNode[];\n};\n\nexport function BaseIcon({\n  size = 24,\n  alt = \"\",\n  children,\n  ...props\n}: BaseIconProps) {\n  return (\n    <svg\n      role=\"img\"\n      xmlns=\"http:\n      aria-label={alt}\n      width={size}\n      height={size}\n      {...props}\n    >\n      {children}\n    </svg>\n  );\n}\n\n'extension/src/components/Welcome.tsx'\n:import { useMemo } from \"react\";\n\nimport IconGlobe from \"./icons/IconGlobe\";\nimport IconAmazon from \"./icons/IconAmazon\";\nimport IconInstagram from \"./icons/IconInstagram\";\nimport IconTikTok from \"./icons/IconTikTok\";\nimport IconTwitter from \"./icons/IconTwitter\";\nimport IconPlay from \"./icons/IconPlay\";\nimport IconGitHub from \"./icons/IconGitHub\";\n\nimport useChannel from \"../hooks/useChannel\";\n\nimport Card from \"./Card\";\n\nconst socialClass =\n  \"transition-[color,transform] hover:scale-125 focus:scale-125 hover:text-highlight focus:text-highlight\";\n\ninterface WelcomeProps {\n  className?: string;\n}\n\nexport default function Welcome(props: WelcomeProps) {\n  const { className } = props;\n\n  const channel = useChannel();\n  const nonDefault = useMemo(\n    () => !channel || channel.toLowerCase() !== \"alveussanctuary\",\n    [channel],\n  );\n\n  return (\n    <Card className={className} title=\"Welcome to Alveus\">\n      <p className=\"mb-4 mt-2\">\n        Alveus Sanctuary is a 501(c)(3) non-profit organization that functions\n        as a wildlife sanctuary and as a virtual education center. These\n        non-releasable animals are educational ambassadors so viewers can learn\n        from and build a connection to them.\n      </p>\n\n      <ul className=\"mb-2 flex flex-wrap items-center justify-center gap-4\">\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Website\"\n          >\n            <IconGlobe size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Amazon Wishlist\"\n          >\n            <IconAmazon size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Instagram\"\n          >\n            <IconInstagram size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"TikTok\"\n          >\n            <IconTikTok size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Twitter\"\n          >\n            <IconTwitter size={32} />\n          </a>\n        </li>\n        {nonDefault && (\n          <li className={socialClass}>\n            <a\n              href=\"https:\n              rel=\"noreferrer\"\n              target=\"_blank\"\n              title=\"Live\"\n            >\n              <IconPlay size={32} />\n            </a>\n          </li>\n        )}\n      </ul>\n\n      <a\n        className=\"hover:text-highlight focus:text-highlight flex w-fit items-center justify-center gap-1 text-xs transition-colors\"\n        href=\"https:\n        rel=\"noreferrer\"\n        target=\"_blank\"\n      >\n        Contribute on GitHub\n        <IconGitHub size={16} />\n      </a>\n    </Card>\n  );\n}\n\n'extension/src/pages/panel/index.tsx'\n:import { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\nimport { bindTwitchAuth } from \"../../hooks/useTwitchAuth\";\n\nimport App from \"./App\";\n\nimport \"./globals.css\";\n\nbindTwitchAuth();\n\nconst root = createRoot(document.getElementById(\"root\") as HTMLElement);\n\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n\n'extension/src/pages/panel/App.tsx'\n:import Nav from \"./components/Nav\";\nimport Ambassadors from \"./components/Ambassadors\";\n\nfunction App() {\n  return (\n    <div className=\"relative h-full w-full\">\n      <Nav />\n      <Ambassadors />\n    </div>\n  );\n}\n\nexport default App;\n\n'extension/src/components/icons/IconAmazon.tsx'\n:import { BaseIcon, type IconProps } from \"./BaseIcon\";\n\n\nexport default function IconAmazon(props: IconProps) {\n  return (\n    <BaseIcon viewBox=\"0 0 448 512\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M257.2 162.7c-48.7 1.8-169.5 15.5-169.5 117.5 0 109.5 138.3 114 183.5 43.2 6.5 10.2 35.4 37.5 45.3 46.8l56.8-56S341 288.9 341 261.4V114.3C341 89 316.5 32 228.7 32 140.7 32 94 87 94 136.3l73.5 6.8c16.3-49.5 54.2-49.5 54.2-49.5 40.7-.1 35.5 29.8 35.5 69.1zm0 86.8c0 80-84.2 68-84.2 17.2 0-47.2 50.5-56.7 84.2-57.8v40.6zm136 163.5c-7.7 10-70 67-174.5 67S34.2 408.5 9.7 379c-6.8-7.7 1-11.3 5.5-8.3C88.5 415.2 203 488.5 387.7 401c7.5-3.7 13.3 2 5.5 12zm39.8 2.2c-6.5 15.8-16 26.8-21.2 31-5.5 4.5-9.5 2.7-6.5-3.8s19.3-46.5 12.7-55c-6.5-8.3-37-4.3-48-3.2-10.8 1-13 2-14-.3-2.3-5.7 21.7-15.5 37.5-17.5 15.7-1.8 41-.8 46 5.7 3.7 5.1 0 27.1-6.5 43.1z\"\n      />\n    </BaseIcon>\n  );\n}\n",
        "gt": [
            "'extension/src/components/icons/BaseIcon.tsx'",
            "'extension/src/components/icons/IconAmazon.tsx'",
            "'extension/src/components/Welcome.tsx'",
            "'extension/src/pages/panel/components/Nav.tsx'",
            "'extension/src/pages/panel/App.tsx'",
            "'extension/src/pages/panel/index.tsx'"
        ]
    },
    {
        "files": [
            "'ymock/src/components/manageMock/MockForm.tsx'",
            "'ymock/src/components/MSWContext.tsx'",
            "'ymock/src/components/Main.tsx'",
            "'ymock/src/components/manageMock/index.tsx'"
        ],
        "content": "'ymock/src/components/manageMock/MockForm.tsx'\n:import { useContext, useMemo, useState } from \"react\";\nimport { mock } from \"../../lib/mock\";\nimport { MSWContext } from \"../MSWContext\";\nimport { MainParams } from \"../Main\";\nimport { Form } from \"../form/Form\";\nimport { JsonInput } from \"../form/JsonInput\";\nimport { PlainTextInput } from \"../form/PlainTextInput\";\n\nconst responseTypes = [\"json\", \"text\"];\n\ntype ResponseTypes = (typeof responseTypes)[number];\n\nconst renderResponseInput = (type: ResponseTypes) => {\n  switch (type) {\n    case \"text\":\n      return <PlainTextInput />;\n    case \"json\":\n    default:\n      return <JsonInput />;\n  }\n};\n\nexport const MockForm: React.FC<MainParams> = ({ method, path }) => {\n  const { worker } = useContext(MSWContext);\n  const [responseType, setResponseType] = useState<ResponseTypes>(\"json\");\n\n  const setResponse = useMemo(\n    () => mock(worker)(method, path),\n    [worker, method, path]\n  );\n\n  const handleResponseType: React.ChangeEventHandler<HTMLSelectElement> = (e) =>\n    setResponseType(e.target.value);\n\n  return (\n    <Form onSubmit={setResponse()}>\n      <div className=\"input\">\n        <label htmlFor=\"responseType\">Response type</label>\n        <select name=\"responseType\" onChange={handleResponseType}>\n          {responseTypes.map((type) => (\n            <option value={type} key={type}>\n              {type}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"input\">\n        <label>Body</label>\n        {renderResponseInput(responseType)}\n      </div>\n      <button type=\"submit\" className=\"primary\">\n        Set response\n      </button>\n    </Form>\n  );\n};\n\n'ymock/src/components/MSWContext.tsx'\n:import React, { PropsWithChildren } from \"react\";\nimport { RenderFnParams } from \"../types/ymock\";\nimport { SetupWorker } from \"msw/lib/browser\";\n\nexport const MSWContext = React.createContext<RenderFnParams>({\n  worker: null as unknown as SetupWorker,\n  handlers: [],\n});\n\nexport const MSWContextProvider: React.FC<\n  RenderFnParams & PropsWithChildren\n> = ({ worker, handlers, children }) => {\n  return (\n    <MSWContext.Provider value={{ worker, handlers }}>\n      {children}\n    </MSWContext.Provider>\n  );\n};\n\n'ymock/src/components/Main.tsx'\n:import { useParams } from \"react-router-dom\";\nimport { ManageMock } from \"./manageMock/index\";\nimport { Method } from \"../types/method\";\n\nexport type MainParams = {\n  method: Method;\n} & Record<string, string>;\n\nexport const Main: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n\n  return <ManageMock key={`${method}${path}`} />;\n};\n\n'ymock/src/components/manageMock/index.tsx'\n:import { useContext, useEffect, useState } from \"react\";\nimport { useParams } from \"react-router\";\nimport { mock } from \"../../lib/mock\";\nimport { passthroughResponseHandler } from \"../../lib/responseHandlers/passthroughResponseHandler\";\nimport { MSWContext } from \"../MSWContext\";\nimport { MainParams } from \"../Main\";\nimport { Welcome } from \"../Welcome\";\nimport { Checkbox } from \"../form/Checkbox\";\nimport { MockForm } from \"./MockForm\";\n\nexport const ManageMock: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n  const { worker } = useContext(MSWContext);\n  const [passthrough, setPassthrough] = useState(false);\n\n  useEffect(() => {\n    if (passthrough) {\n\n      mock(worker)(method, path)(passthroughResponseHandler)({});\n    }\n  }, [passthrough]);\n\n  if (!method || !path) {\n    console.warn(\"Invalid route: even method and path must be set\");\n    return <Welcome />;\n  }\n\n  return (\n    <div className=\"manage-mock\">\n      <div className=\"title\">Request info</div>\n      <div className=\"request-info\">\n        <div className=\"method\">{method}</div>\n        <div className=\"path\">/{path}</div>\n      </div>\n      <div className=\"configure-form\">\n        <div className=\"input\">\n          <Checkbox\n            name=\"passthrough\"\n            label=\"Passthrough\"\n            defaultChecked={passthrough}\n            onChange={setPassthrough}\n          />\n        </div>\n        {!passthrough && <MockForm {...{ method, path }} />}\n      </div>\n    </div>\n  );\n};\n",
        "gt": [
            "'ymock/src/components/MSWContext.tsx'",
            "'ymock/src/components/manageMock/MockForm.tsx'",
            "'ymock/src/components/manageMock/index.tsx'",
            "'ymock/src/components/Main.tsx'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'",
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n\n'mean-rsvp-auth0/src/app/core/api.service.ts'\n:import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { AuthService } from './../auth/auth.service';\nimport { throwError as ObservableThrowError, Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { ENV } from './env.config';\nimport { EventModel } from './models/event.model';\nimport { RsvpModel } from './models/rsvp.model';\n\n@Injectable()\nexport class ApiService {\n  constructor(\n    private http: HttpClient,\n    private auth: AuthService\n  ) { }\n\n  private get _authHeader(): string {\n    return `Bearer ${this.auth.accessToken}`;\n  }\n\n\n  getEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events`)\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getAdminEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/admin`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getEventById$(id: string): Observable<EventModel> {\n    return this.http\n      .get<EventModel>(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getRsvpsByEventId$(eventId: string): Observable<RsvpModel[]> {\n    return this.http\n      .get<RsvpModel[]>(`${ENV.BASE_API}event/${eventId}/rsvps`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postEvent$(event: EventModel): Observable<EventModel> {\n    return this.http\n      .post<EventModel>(`${ENV.BASE_API}event/new`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editEvent$(id: string, event: EventModel): Observable<EventModel> {\n    return this.http\n      .put<EventModel>(`${ENV.BASE_API}event/${id}`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  deleteEvent$(id: string): Observable<any> {\n    return this.http\n      .delete(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getUserEvents$(userId: string): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/${userId}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postRsvp$(rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .post<RsvpModel>(`${ENV.BASE_API}rsvp/new`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editRsvp$(id: string, rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .put(`${ENV.BASE_API}rsvp/${id}`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n  private _handleError(err: HttpErrorResponse | any): Observable<any> {\n    const errorMsg = err.message || 'Error: Unable to complete request.';\n    if (err.message && err.message.indexOf('No JWT present') > -1) {\n      this.auth.login();\n    }\n    return ObservableThrowError(errorMsg);\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'\n:import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { AuthService } from './../../../auth/auth.service';\nimport { ApiService } from './../../../core/api.service';\nimport { UtilsService } from './../../../core/utils.service';\nimport { ActivatedRoute } from '@angular/router';\nimport { Subscription } from 'rxjs';\nimport { EventModel } from './../../../core/models/event.model';\n\n@Component({\n  selector: 'app-update-event',\n  templateUrl: './update-event.component.html',\n  styleUrls: ['./update-event.component.scss']\n})\nexport class UpdateEventComponent implements OnInit, OnDestroy {\n  pageTitle = 'Update Event';\n  routeSub: Subscription;\n  eventSub: Subscription;\n  event: EventModel;\n  loading: boolean;\n  submitting: boolean;\n  error: boolean;\n  tabSub: Subscription;\n  tab: string;\n  private _id: string;\n\n  constructor(\n    private route: ActivatedRoute,\n    public auth: AuthService,\n    private api: ApiService,\n    public utils: UtilsService,\n    private title: Title\n  ) { }\n\n  ngOnInit() {\n    this.title.setTitle(this.pageTitle);\n\n\n    this.routeSub = this.route.params\n      .subscribe(params => {\n        this._id = params['id'];\n        this._getEvent();\n      });\n\n\n    this.tabSub = this.route.queryParams\n      .subscribe(queryParams => {\n        this.tab = queryParams['tab'] || 'edit';\n      });\n  }\n\n  private _getEvent() {\n    this.loading = true;\n\n    this.eventSub = this.api\n      .getEventById$(this._id)\n      .subscribe(\n        res => {\n          this.event = res;\n          this.loading = false;\n        },\n        err => {\n          console.error(err);\n          this.loading = false;\n          this.error = true;\n        }\n      );\n  }\n\n  ngOnDestroy() {\n    this.routeSub.unsubscribe();\n    this.tabSub.unsubscribe();\n    this.eventSub.unsubscribe();\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/core/models/event.model.ts'\n:class EventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDatetime: Date,\n    public endDatetime: Date,\n    public viewPublic: boolean,\n    public description?: string,\n    public _id?: string,\n  ) { }\n}\n\nclass FormEventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDate: string,\n    public startTime: string,\n    public endDate: string,\n    public endTime: string,\n    public viewPublic: boolean,\n    public description?: string\n  ) { }\n}\n\nexport { EventModel, FormEventModel };\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'near-social-bridge/examples/dapp-bos-tutorial/src/services/getTasks.ts'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/components/TodoList.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/App.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/App.test.tsx'"
        ],
        "content": "'near-social-bridge/examples/dapp-bos-tutorial/src/services/getTasks.ts'\n:\nimport { Social } from \"near-social-bridge/api\";\n\nexport interface Task {\n  id: number;\n  finished: boolean;\n  description: string;\n}\n\ntype TasksIndex = {\n  value: Task[];\n}[];\n\n\nconst getTasks = async (accountId: string) => {\n  const response = await Social.index<TasksIndex>(\n    `todo-app-${accountId}`,\n    \"tasks\",\n    {\n      limit: 1,\n      order: \"desc\",\n    }\n  );\n\n  if (Array.isArray(response) && response[0]) {\n    return response[0].value;\n  }\n\n  return [];\n};\n\nexport default getTasks;\n\n'near-social-bridge/examples/dapp-bos-tutorial/src/components/TodoList.tsx'\n:\nimport { useCallback, useEffect, useState } from 'react'\nimport { useAuth } from 'near-social-bridge/auth'\nimport NewTodoForm from './NewTodoForm'\nimport TaskItem from './TaskItem'\nimport getTasks, { Task } from '../services/getTasks'\nimport storeTasks from '../services/storeTasks'\n\nconst TodoList = () => {\n  const [status, setStatus] = useState<'ready' | 'loading' | 'saving'>('loading')\n  const [taskDescription, setTaskDescription] = useState('')\n  const [tasks, setTasks] = useState<Task[]>([])\n  const auth = useAuth()\n\n\n  useEffect(() => {\n    if (auth.ready) {\n      getTasks(auth.user?.accountId!).then((tasks) => {\n        setTasks(tasks)\n        setStatus('ready')\n      })\n    }\n  }, [auth])\n\n  const persistUpdatedData = useCallback(\n    async (tasksList?: Task[]) => {\n      const updatedTasks = tasksList\n        ? tasksList\n        : [...tasks, { id: Date.now(), description: taskDescription, finished: false }]\n      setStatus('saving')\n\n      const result = await storeTasks(updatedTasks, auth.user?.accountId!)\n      if (!result.error) {\n        setTasks(updatedTasks)\n      }\n      setTaskDescription('')\n      setStatus('ready')\n    },\n    [taskDescription, tasks, auth]\n  )\n\n  const completeTaskHandler = (task: Task) => {\n    const updatedTasks = tasks.map((taskItem) => {\n      if (taskItem.id === task.id) {\n        taskItem.finished = !taskItem.finished\n      }\n      return taskItem\n    })\n\n\n    persistUpdatedData(updatedTasks)\n  }\n\n  const removeTaskHandler = (task: Task) => {\n    const updatedTasks = tasks.filter((taskItem) => taskItem.id !== task.id)\n\n    persistUpdatedData(updatedTasks)\n  }\n\n  return (\n    <div style={{ display: 'flex', justifyContent: 'center', flexDirection: 'column' }}>\n      {tasks.length === 0 && status === 'ready' && <p>No Tasks yet!</p>}\n      {status !== 'ready' ? (\n        <p>{status}...</p>\n      ) : (\n        <>\n          {tasks.map((task) => (\n            <TaskItem\n              key={task.id}\n              task={task}\n              completeTaskHandler={completeTaskHandler}\n              removeTaskHandler={removeTaskHandler}\n            />\n          ))}\n          <br />\n          <NewTodoForm\n            taskDescription={taskDescription}\n            onInputChange={(inputValue) => setTaskDescription(inputValue)}\n            onAddClick={() => persistUpdatedData()}\n          />\n        </>\n      )}\n    </div>\n  )\n}\n\nexport default TodoList\n\n'near-social-bridge/examples/dapp-bos-tutorial/src/App.tsx'\n:import { useAuth } from \"near-social-bridge\";\nimport TodoList from \"./components/TodoList\";\nimport NotLoggedInWarning from \"./components/NotLoggedInWarning\";\n\nfunction App() {\n  const auth = useAuth();\n\n  return (\n    <div className=\"App\">\n      <h3>Web3 - Todo App</h3>\n\n      {auth.user ? <TodoList /> : <NotLoggedInWarning />}\n    </div>\n  );\n}\n\nexport default App;\n\n'near-social-bridge/examples/dapp-bos-tutorial/src/App.test.tsx'\n:import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n",
        "gt": [
            "'near-social-bridge/examples/dapp-bos-tutorial/src/services/getTasks.ts'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/components/TodoList.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/App.tsx'",
            "'near-social-bridge/examples/dapp-bos-tutorial/src/App.test.tsx'"
        ]
    },
    {
        "files": [
            "'nasa-ionic/src/pages/tabs/tabs.ts'",
            "'nasa-ionic/src/app/main.ts'",
            "'nasa-ionic/src/pages/nasa/mars.component.ts'",
            "'nasa-ionic/src/app/app.component.ts'",
            "'nasa-ionic/src/app/app.module.ts'"
        ],
        "content": "'nasa-ionic/src/pages/tabs/tabs.ts'\n:import { Component } from '@angular/core';\n\nimport {ApodComponent} from \"../nasa/apod.component\";\nimport {MarsComponent} from \"../nasa/mars.component\";\n\n@Component({\n  templateUrl: 'tabs.html'\n})\nexport class TabsPage {\n\n  tab1Root = ApodComponent;\n  tab2Root = MarsComponent;\n\n  constructor() {\n\n  }\n}\n\n'nasa-ionic/src/app/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n'nasa-ionic/src/pages/nasa/mars.component.ts'\n:import {Component, OnInit} from '@angular/core';\nimport {NasaService} from '../../services/nasa';\n\n\n@Component({\n  selector: 'mars-component',\n  template: `\n    <ion-header text-center><ion-title>Mars Curiosity Rover</ion-title></ion-header><br/>\n    <ion-content padding>\n      <ion-card padding>\n      <ion-item>\n        <ion-label>Date</ion-label>\n        <ion-datetime displayFormat=\"YYYY-MM-DD\"  (ionChange)=\"getMars(today)\" [(ngModel)]=\"today\"></ion-datetime>\n      </ion-item>\n      </ion-card>\n      <h3 text-center *ngIf=\"mars == 0\">No Photos Found!</h3>\n      <ion-card *ngFor=\"let photo of mars\">\n    <img *ngIf=\"photo\" src=\"{{photo.img_src}}\">\n\n        </ion-card>\n</ion-content>\n`,\n})\n\nexport class MarsComponent implements OnInit {\n  mars: any;\n  today;\n  constructor(private _nasaService: NasaService,){\n    this.mars = 0;\n  }\n  ngOnInit(){\n    this.today = new Date().toISOString().slice(0,10);\n    this.getMars(this.today);\n  }\n\n  getMars(date: string){\n    this._nasaService.getMars(date)\n      .subscribe(data => {this.mars = data;console.log(this.mars);})\n  }\n\n\n\n\n\n}\n\n'nasa-ionic/src/app/app.component.ts'\n:import { Component } from '@angular/core';\nimport { Platform } from 'ionic-angular';\nimport { StatusBar } from '@ionic-native/status-bar';\nimport { SplashScreen } from '@ionic-native/splash-screen';\n\nimport { TabsPage } from '../pages/tabs/tabs';\n\n@Component({\n  templateUrl: 'app.html'\n})\nexport class MyApp {\n  rootPage:any = TabsPage;\n\n  constructor(platform: Platform, statusBar: StatusBar, splashScreen: SplashScreen) {\n    platform.ready().then(() => {\n\n\n      statusBar.styleDefault();\n      splashScreen.hide();\n    });\n  }\n}\n\n'nasa-ionic/src/app/app.module.ts'\n:import { NgModule, ErrorHandler } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { IonicApp, IonicModule, IonicErrorHandler } from 'ionic-angular';\nimport { MyApp } from './app.component';\n\nimport { AboutPage } from '../pages/about/about';\nimport { ContactPage } from '../pages/contact/contact';\nimport { HomePage } from '../pages/home/home';\nimport { TabsPage } from '../pages/tabs/tabs';\nimport { ApodComponent } from '../pages/nasa/apod.component';\nimport {MarsComponent} from '../pages/nasa/mars.component';\nimport { StatusBar } from '@ionic-native/status-bar';\nimport { SplashScreen } from '@ionic-native/splash-screen';\n\nimport {NasaService} from '../services/nasa';\nimport {HttpModule} from \"@angular/http\";\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    TabsPage,\n    ApodComponent,\n    MarsComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpModule,\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    TabsPage,\n    ApodComponent,\n    MarsComponent\n  ],\n  providers: [\n    StatusBar,\n    SplashScreen,\n    {provide: ErrorHandler, useClass: IonicErrorHandler},\n    NasaService\n  ]\n})\nexport class AppModule {}\n",
        "gt": [
            "'nasa-ionic/src/pages/nasa/mars.component.ts'",
            "'nasa-ionic/src/pages/tabs/tabs.ts'",
            "'nasa-ionic/src/app/app.component.ts'",
            "'nasa-ionic/src/app/app.module.ts'",
            "'nasa-ionic/src/app/main.ts'"
        ]
    },
    {
        "files": [
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.actions.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.models.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/booking-data-access.module.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.effects.ts'"
        ],
        "content": "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.actions.ts'\n:import { createAction, props } from '@ngrx/store';\n\nimport { BookingEntity } from './booking.models';\n\nexport const init = createAction('[Booking Page] Init');\n\nexport const loadBookingSuccess = createAction(\n  '[Booking/API] Load Booking Success',\n  props<{ booking: BookingEntity[] }>()\n);\n\nexport const loadBookingFailure = createAction(\n  '[Booking/API] Load Booking Failure',\n  props<{ error: string }>()\n);\n\n'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.models.ts'\n:\nexport interface BookingEntity {\n  id: string | number;\n}\n\n'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/booking-data-access.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport * as fromBooking from './+state/booking.reducer';\nimport { BookingEffects } from './+state/booking.effects';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    StoreModule.forFeature(\n      fromBooking.BOOKING_FEATURE_KEY,\n      fromBooking.reducer\n    ),\n    EffectsModule.forFeature([BookingEffects]),\n  ],\n})\nexport class BookingDataAccessModule {}\n\n'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.effects.ts'\n:import { Injectable } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { fetch } from '@nrwl/angular';\n\nimport * as BookingActions from './booking.actions';\n\n@Injectable()\nexport class BookingEffects {\n  init$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(BookingActions.init),\n      fetch({\n        run: () => {\n\n          return BookingActions.loadBookingSuccess({ booking: [] });\n        },\n\n        onError: (_action, error) => {\n          console.error('Error', error);\n          return BookingActions.loadBookingFailure({ error });\n        },\n      })\n    )\n  );\n\n  constructor(private actions$: Actions) {}\n}\n",
        "gt": [
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.models.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.actions.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.effects.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/booking-data-access.module.ts'"
        ]
    },
    {
        "files": [
            "'angular-16-complete-course/17-dynamic-components/final/src/app/Models/User.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/app/Services/user.service.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/app/app.module.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/app/routing.module.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/app/users/users.component.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/main.ts'"
        ],
        "content": "'angular-16-complete-course/17-dynamic-components/final/src/app/Models/User.ts'\n:export class User{\n\n    id: number;\n\n    name: string;\n\n    gender: string;\n\n    membership: string;\n\n    price: number;\n\n    isActive: boolean;\n\n\n\n    constructor(id: number, name: string, gender: string, membership: string, price: number, isActive: boolean){\n\n        this.id = id;\n\n        this.name = name;\n\n        this.gender = gender;\n\n        this.membership = membership;\n\n        this.price = price;\n\n        this.isActive = isActive\n\n    }\n\n}\n'angular-16-complete-course/17-dynamic-components/final/src/app/Services/user.service.ts'\n:import { Injectable } from \"@angular/core\";\n\nimport { User } from \"../Models/User\";\n\n\n\n@Injectable({\n\n    providedIn: 'root'\n\n})\n\nexport class UserService{\n\n    users: User[] = [\n\n        new User(1, 'John Smith', 'Male', 'Yearly', 999, true),\n\n        new User(2, 'Mark Vought', 'Male', 'Monthly', 199, true),\n\n        new User(3, 'Sarah King', 'Female', 'Quaterly', 399, false),\n\n        new User(4, 'Merry Jane', 'Female', 'Yearly', 999, true),\n\n        new User(5, 'Jonas Fleming', 'Male', 'Monthly', 199, false)\n\n    ]\n\n}\n'angular-16-complete-course/17-dynamic-components/final/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppComponent } from './app.component';\nimport { HomeComponent } from './home/home.component';\nimport { UsersComponent } from './users/users.component';\nimport { ConfirmDeleteComponent } from './users/confirm-delete/confirm-delete.component';\nimport { RoutingModule } from './routing.module';\nimport { ViewContainer } from './viewContainer.directive';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HomeComponent,\n    UsersComponent,\n    ConfirmDeleteComponent,\n    ViewContainer\n  ],\n  imports: [\n    BrowserModule,\n    RoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n  entryComponents: [ConfirmDeleteComponent]\n})\nexport class AppModule { }\n\n'angular-16-complete-course/17-dynamic-components/final/src/app/routing.module.ts'\n:import { NgModule } from '@angular/core';\n\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { HomeComponent } from './home/home.component';\n\nimport { UsersComponent } from './users/users.component';\n\n\n\nconst routes: Routes = [\n\n    {path: '', component: HomeComponent},\n\n    {path: 'Home', component: HomeComponent},\n\n    {path: 'Users', component: UsersComponent}\n\n]\n\n\n\n@NgModule({\n\n    imports: [\n\n      RouterModule.forRoot(routes)\n\n    ],\n\n    exports: [RouterModule]\n\n})\n\n  export class RoutingModule { }\n'angular-16-complete-course/17-dynamic-components/final/src/app/users/users.component.ts'\n:import { Component, OnInit, ComponentFactoryResolver, ViewChild } from '@angular/core';\nimport { User } from '../Models/User';\nimport { UserService } from '../Services/user.service';\nimport { ConfirmDeleteComponent } from './confirm-delete/confirm-delete.component';\nimport { ViewContainer } from '../viewContainer.directive';\n\n@Component({\n  selector: 'app-users',\n  templateUrl: './users.component.html',\n  styleUrls: ['./users.component.css']\n})\nexport class UsersComponent implements OnInit {\n\n  constructor(private userService: UserService, private componentFactoryResolver: ComponentFactoryResolver) {\n\n  }\n\n  users: User[] = [];\n  showConfirmDeleteComponent: boolean = false;\n  userToDelete: User;\n  @ViewChild(ViewContainer, {static: false}) container: ViewContainer;\n\n  onConfirmationObs;\n\n  ngOnInit() {\n    this.users = this.userService.users;\n  }\n\n  OnDeleteClicked(user: User){\n\n    this.userToDelete = user;\n    this.showConfirmDelete(this.userToDelete);\n  }\n\n\n  OnUserDeletionConfirmed(value: boolean){\n    this.showConfirmDeleteComponent = false;\n    if(value){\n\n      let index = this.userService.users.indexOf(this.userToDelete);\n      this.userService.users.splice(index, 1);\n    }\n  }\n\n  showConfirmDelete(user: User){\n\n\n    const confirmDelereComponenetFactory =\n              this.componentFactoryResolver\n              .resolveComponentFactory(ConfirmDeleteComponent);\n\n    const containerViewRef = this.container.viewContainer;\n    containerViewRef.clear();\n\n\n    const componentRef =containerViewRef.createComponent(confirmDelereComponenetFactory);\n    componentRef.instance.usertoDelete = user;\n\n    this.onConfirmationObs = componentRef.instance.OnConfirmation.subscribe((data) => {\n      this.onConfirmationObs.unsubscribe();\n      containerViewRef.clear();\n\n      if(data){\n\n        let index = this.userService.users.indexOf(this.userToDelete);\n        this.userService.users.splice(index, 1);\n      }\n    })\n  }\n}\n\n'angular-16-complete-course/17-dynamic-components/final/src/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n",
        "gt": [
            "'angular-16-complete-course/17-dynamic-components/final/src/app/Models/User.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/app/Services/user.service.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/app/users/users.component.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/app/routing.module.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/app/app.module.ts'",
            "'angular-16-complete-course/17-dynamic-components/final/src/main.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/routing/src/app/auth-service.service.ts'",
            "'angular-the-complete-guide-2023/routing/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/routing/src/main.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/routing/src/app/auth-service.service.ts'\n:import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AuthService {\n\n  loggedIn: boolean = false;\n\n  constructor() { }\n\n  isAuthenticated() {\n    const promise = new Promise(\n      (resolve, reject) => {\n        setTimeout(() => {\n          resolve(this.loggedIn)\n        }, 800);\n      }\n    );\n\n    return promise;\n  }\n\n  login() { this.loggedIn = true; }\n\n  logout() { this.loggedIn = false; }\n\n}\n\n'angular-the-complete-guide-2023/routing/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { HomeComponent } from './home/home.component';\nimport { UsersComponent } from './users/users.component';\nimport { ServersComponent } from './servers/servers.component';\nimport { UserComponent } from './users/user/user.component';\nimport { EditServerComponent } from './servers/edit-server/edit-server.component';\nimport { ServerComponent } from './servers/server/server.component';\nimport { ServersService } from './servers/servers.service';\nimport { PageNotFoundComponent } from './page-not-found/page-not-found.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { AuthService } from './auth-service.service';\nimport { AuthGuard } from './auth-guard.service';\nimport { ErrorPageComponent } from './error-page/error-page.component';\nimport { ServerResolver } from './servers/server/server-resolver.service';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HomeComponent,\n    UsersComponent,\n    ServersComponent,\n    UserComponent,\n    EditServerComponent,\n    ServerComponent,\n    PageNotFoundComponent,\n    ErrorPageComponent,\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    AppRoutingModule\n  ],\n  providers: [ServersService, AuthService, AuthGuard, ServerResolver],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-the-complete-guide-2023/routing/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n",
        "gt": [
            "'angular-the-complete-guide-2023/routing/src/app/auth-service.service.ts'",
            "'angular-the-complete-guide-2023/routing/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/routing/src/main.ts'"
        ]
    },
    {
        "files": [
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.actions.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.models.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.reducer.spec.ts'"
        ],
        "content": "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.actions.ts'\n:import { createAction, props } from '@ngrx/store';\n\nimport { BookingEntity } from './booking.models';\n\nexport const init = createAction('[Booking Page] Init');\n\nexport const loadBookingSuccess = createAction(\n  '[Booking/API] Load Booking Success',\n  props<{ booking: BookingEntity[] }>()\n);\n\nexport const loadBookingFailure = createAction(\n  '[Booking/API] Load Booking Failure',\n  props<{ error: string }>()\n);\n\n'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.models.ts'\n:\nexport interface BookingEntity {\n  id: string | number;\n}\n\n'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.reducer.spec.ts'\n:import * as BookingActions from './booking.actions';\nimport { BookingEntity } from './booking.models';\nimport { initialState, reducer, State } from './booking.reducer';\n\ndescribe('Booking Reducer', () => {\n  const createBookingEntity = (id: string, name = '') =>\n    ({\n      id,\n      name: name || `name-${id}`,\n    } as BookingEntity);\n\n  describe('valid Booking actions', () => {\n    it('loadBookingSuccess should return set the list of known Booking', () => {\n      const booking = [\n        createBookingEntity('PRODUCT-AAA'),\n        createBookingEntity('PRODUCT-zzz'),\n      ];\n      const action = BookingActions.loadBookingSuccess({ booking });\n\n      const result: State = reducer(initialState, action);\n\n      expect(result.loaded).toBe(true);\n      expect(result.ids.length).toBe(2);\n    });\n  });\n\n  describe('unknown action', () => {\n    it('should return the previous state', () => {\n      const action = {};\n\n\n      const result = reducer(initialState, action);\n\n      expect(result).toBe(initialState);\n    });\n  });\n});\n",
        "gt": [
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.models.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.actions.ts'",
            "'nx-nrwl-airlines-angular/libs/booking/data-access/src/lib/+state/booking.reducer.spec.ts'"
        ]
    },
    {
        "files": [
            "'among-us-stats/src/index.tsx'",
            "'among-us-stats/src/components/App.tsx'",
            "'among-us-stats/src/store/common/commonRedux.ts'",
            "'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'"
        ],
        "content": "'among-us-stats/src/index.tsx'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n'among-us-stats/src/components/App.tsx'\n:import React, { Suspense } from 'react';\nimport { CssBaseline, ThemeProvider } from '@material-ui/core';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { Provider } from 'react-redux';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nimport store, { persistor } from '../store/redux';\n\nimport AppBar from './appbar/AppBar';\nimport ActiveSession from './activesession/ActiveSession';\nimport Sessions from './sessions/Sessions';\nimport IntroDialog from './dialogs/IntroDialog';\nimport SettingsDialog from './dialogs/SettingsDialog';\nimport FeedbackDialog from './dialogs/FeedbackDialog';\nimport NotFound from './NotFound';\nimport Analytics from './Analytics';\nimport { theme } from './theme';\nimport ContentWrapper from './ContentWrapper';\nimport ErrorBoundary from './ErrorBoundary';\nimport FullscreenFallback from './shared/FullscreenFallback';\n\nconst LazyPlayersOverview = React.lazy(() => import('./playersoverview/PlayersOverview'));\n\nfunction App(): JSX.Element {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={null} persistor={persistor}>\n        <ThemeProvider theme={theme}>\n          <ErrorBoundary>\n            <Router>\n              <IntroDialog />\n              <SettingsDialog />\n              <FeedbackDialog />\n              <Analytics />\n              <CssBaseline />\n              <AppBar />\n              <ContentWrapper>\n                <Switch>\n                  <Route exact path={['/', '/summary']}>\n                    <ActiveSession />\n                  </Route>\n                  <Route path=\"/sessions\">\n                    <Sessions />\n                  </Route>\n                  <Route path=\"/players\">\n                    <Suspense fallback={<FullscreenFallback />}>\n                      <LazyPlayersOverview />\n                    </Suspense>\n                  </Route>\n                  <Route>\n                    <NotFound />\n                  </Route>\n                </Switch>\n              </ContentWrapper>\n            </Router>\n          </ErrorBoundary>\n        </ThemeProvider>\n      </PersistGate>\n    </Provider>\n  );\n}\n\nexport default App;\n\n'among-us-stats/src/store/common/commonRedux.ts'\n:import { createSlice, PayloadAction } from '@reduxjs/toolkit';\n\nexport const hasBeenShownIntroKey = 'hasBeenShownIntro';\nexport const hasVisitedSettingsKey = 'hasVisitedSettings';\n\nexport type SortPlayersBy = 'Games played' | 'Total win rate' | 'Impostor win rate' | 'Crew win rate' | 'Impostor rate';\n\ninterface CommonState {\n  showHelp: boolean;\n  showSettings: boolean;\n  showFeedback: boolean;\n  sortPlayersBy: SortPlayersBy;\n}\n\nconst initialStatsState: CommonState = {\n  showHelp: !localStorage.getItem(hasBeenShownIntroKey),\n  showSettings: false,\n  showFeedback: false,\n  sortPlayersBy: 'Games played',\n};\n\nexport const commonSlice = createSlice({\n  name: 'common',\n  initialState: initialStatsState,\n  reducers: {\n    toggleShowHelp: (state) => {\n      state.showHelp = !state.showHelp;\n    },\n    toggleFeedback: (state) => {\n      state.showFeedback = !state.showFeedback;\n    },\n    toggleSettings: (state) => {\n      state.showSettings = !state.showSettings;\n    },\n    sortPlayerBy: (state, action: PayloadAction<CommonState['sortPlayersBy']>) => {\n      state.sortPlayersBy = action.payload;\n    },\n  },\n});\n\n'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'\n:import React, { Fragment } from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Typography from '@material-ui/core/Typography';\nimport Box from '@material-ui/core/Box';\nimport Grid from '@material-ui/core/Grid';\nimport { Divider } from '@material-ui/core';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Sort from '@material-ui/icons/Sort';\nimport Menu from '@material-ui/core/Menu';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport { useSelector } from 'react-redux';\nimport { useDispatch } from 'react-redux';\nimport { sortBy, reverse } from 'rambda';\n\nimport useAnchor from '../shared/hooks/useAnchor';\nimport { RootState } from '../../store/redux';\nimport { commonSlice, SortPlayersBy } from '../../store/common/commonRedux';\nimport BreakpointButton from '../shared/BreakpointButton';\n\nimport PlayerOverviewRow from './PlayerOverviewRow';\nimport usePlayersWithTotalStats from './usePlayerWithTotalStats';\n\nconst sortOptions: SortPlayersBy[] = [\n  'Games played',\n  'Total win rate',\n  'Crew win rate',\n  'Impostor win rate',\n  'Impostor rate',\n];\n\nfunction PlayersOverview(): JSX.Element {\n  const dispatch = useDispatch();\n  const [anchorEl, anchorActions] = useAnchor();\n  const sortPlayersBy = useSelector((state: RootState) => state.common.sortPlayersBy);\n  const [playersWithTotalStats, metaStats] = usePlayersWithTotalStats();\n\n  const playersWithTotalStatsSorted = reverse(\n    sortBy((player) => {\n      switch (sortPlayersBy) {\n        case 'Games played':\n          return player.gamesPlayed;\n        case 'Total win rate':\n          return player.totalWinRate;\n        case 'Impostor win rate':\n          return player.totalImpostorWinRate;\n        case 'Crew win rate':\n          return player.totalCrewWinRate;\n        case 'Impostor rate':\n          return player.totalImpostorRate;\n      }\n    })(playersWithTotalStats),\n  );\n\n  return (\n    <Paper>\n      <Toolbar>\n        <Typography variant=\"h5\">Total player stats</Typography>\n        <Box flex=\"1 1 auto\" />\n        <BreakpointButton\n          text={`Sort by: ${sortPlayersBy}`}\n          label={`Sort by: ${sortPlayersBy}`}\n          onClick={anchorActions.handleClick}\n          endIcon={<Sort />}\n        />\n        <Menu\n          id=\"sort-by-menu\"\n          anchorEl={anchorEl}\n          keepMounted\n          open={Boolean(anchorEl)}\n          onClose={anchorActions.handleClose}\n        >\n          {sortOptions.map((it) => (\n            <MenuItem\n              key={it}\n              onClick={() => {\n                dispatch(commonSlice.actions.sortPlayerBy(it));\n                anchorActions.handleClose();\n              }}\n            >\n              {it}\n            </MenuItem>\n          ))}\n        </Menu>\n      </Toolbar>\n      <Box p={3} pt={0}>\n        <Box pb={2}>\n          <Typography variant=\"body1\">\n            A total of{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalPlayers} players\n            </Box>{' '}\n            have played{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalGames} games\n            </Box>{' '}\n            over{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalSessions} sessions\n            </Box>\n            .\n          </Typography>\n        </Box>\n        <Grid container spacing={1}>\n          {playersWithTotalStatsSorted.map((it, index) => (\n            <Fragment key={it.playerId}>\n              <Grid item xs={12}>\n                <PlayerOverviewRow player={it} />\n              </Grid>\n              {index !== playersWithTotalStats.length - 1 && (\n                <Grid item xs={12}>\n                  <Divider />\n                </Grid>\n              )}\n            </Fragment>\n          ))}\n        </Grid>\n      </Box>\n    </Paper>\n  );\n}\n\nexport default PlayersOverview;\n",
        "gt": [
            "'among-us-stats/src/store/common/commonRedux.ts'",
            "'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'",
            "'among-us-stats/src/components/App.tsx'",
            "'among-us-stats/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user/user.component.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/main.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/app/app.module.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user-routing.module.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/app/app-routing.module.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user.module.ts'"
        ],
        "content": "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user/user.component.ts'\n:import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-user',\n  templateUrl: './user.component.html',\n  styleUrls: ['./user.component.css']\n})\nexport class UserComponent {\n\n}\n\n'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user-routing.module.ts'\n:import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { UserComponent } from './user/user.component';\n\nconst routes: Routes = [{\n  path:'',\n  component:UserComponent\n}];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class UserRoutingModule { }\n\n'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/app/app-routing.module.ts'\n:import { authGuard } from './../gards/auth.guard';\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nconst routes: Routes = [\n  {\n    path:'admin',\n    canActivate:[authGuard],\n    loadChildren : ()=> import('../modules/admin/admin.module').then(m=>m.AdminModule)\n  },\n  {\n    path:'user',\n    canActivate:[authGuard],\n    loadChildren : ()=> import('../modules/user/user.module').then(m=>m.UserModule)\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n\n'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { UserRoutingModule } from './user-routing.module';\nimport { UserComponent } from './user/user.component';\n\n\n@NgModule({\n  declarations: [\n    UserComponent\n  ],\n  imports: [\n    CommonModule,\n    UserRoutingModule\n  ]\n})\nexport class UserModule { }\n",
        "gt": [
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user/user.component.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user-routing.module.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/modules/user/user.module.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/app/app-routing.module.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/app/app.module.ts'",
            "'Angular-vault-2.0/click-to-unlock-workspace/projects/advance-routing/src/main.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/new-account/new-account.component.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/accounts.service.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/main.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.module.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/new-account/new-account.component.ts'\n:import { Component } from '@angular/core';\nimport { AccountsService } from '../accounts.service';\nimport { LoggingService } from '../logging.service';\n\n@Component({\n  selector: 'app-new-account',\n  templateUrl: './new-account.component.html',\n  styleUrls: ['./new-account.component.css']\n})\nexport class NewAccountComponent {\n\n  constructor(\n    private loggingService: LoggingService,\n    private accountsService: AccountsService\n  ) {\n    this.accountsService.statusUpdated.subscribe(\n      (status: string) => alert(`New Status: ${status}`)\n    );\n  }\n\n  onCreateAccount(accountName: string, accountStatus: string) {\n    this.accountsService.addAccount(accountName, accountStatus);\n\n  }\n\n}\n\n'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/accounts.service.ts'\n:import { EventEmitter, Injectable } from '@angular/core';\nimport { LoggingService } from './logging.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AccountsService {\n\n  accounts = [\n    {\n      name: 'Master Account',\n      status: 'active'\n    },\n    {\n      name: 'Testaccount',\n      status: 'inactive'\n    },\n    {\n      name: 'Hidden Account',\n      status: 'unknown'\n    }\n  ];\n\n  statusUpdated = new EventEmitter<string>();\n\n  constructor(\n    private loggingService: LoggingService\n  ) { }\n\n  addAccount(name: string, status: string) {\n    this.accounts.push({\n      name: name,\n      status: status\n    });\n    this.loggingService.logStatusChange(status);\n  }\n\n  updateStatus(id: number, status: string) {\n    this.accounts[id].status = status;\n    this.loggingService.logStatusChange(status);\n  }\n\n}\n\n'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n\nimport { AppComponent } from './app.component';\nimport { AccountComponent } from './account/account.component';\nimport { NewAccountComponent } from './new-account/new-account.component';\nimport { AccountsService } from './accounts.service';\nimport { LoggingService } from './logging.service';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    AccountComponent,\n    NewAccountComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n  ],\n  providers: [AccountsService, LoggingService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n",
        "gt": [
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/accounts.service.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/new-account/new-account.component.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/main.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.component.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/main.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/accounts.service.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/logging.service.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { AccountsService } from './accounts.service';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n  accounts: {\n    name: string,\n    status: string\n  }[] = [];\n\n  constructor(\n    private accountsService: AccountsService\n  ) { }\n\n  ngOnInit(): void {\n    this.accounts = this.accountsService.accounts;\n  }\n\n}\n\n'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/accounts.service.ts'\n:import { EventEmitter, Injectable } from '@angular/core';\nimport { LoggingService } from './logging.service';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AccountsService {\n\n  accounts = [\n    {\n      name: 'Master Account',\n      status: 'active'\n    },\n    {\n      name: 'Testaccount',\n      status: 'inactive'\n    },\n    {\n      name: 'Hidden Account',\n      status: 'unknown'\n    }\n  ];\n\n  statusUpdated = new EventEmitter<string>();\n\n  constructor(\n    private loggingService: LoggingService\n  ) { }\n\n  addAccount(name: string, status: string) {\n    this.accounts.push({\n      name: name,\n      status: status\n    });\n    this.loggingService.logStatusChange(status);\n  }\n\n  updateStatus(id: number, status: string) {\n    this.accounts[id].status = status;\n    this.loggingService.logStatusChange(status);\n  }\n\n}\n\n'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\n\nimport { AppComponent } from './app.component';\nimport { AccountComponent } from './account/account.component';\nimport { NewAccountComponent } from './new-account/new-account.component';\nimport { AccountsService } from './accounts.service';\nimport { LoggingService } from './logging.service';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    AccountComponent,\n    NewAccountComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n  ],\n  providers: [AccountsService, LoggingService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/logging.service.ts'\n:import { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class LoggingService {\n\n  constructor() { }\n\n  logStatusChange(status: string) {\n    console.log(`A server status changed, new status: ${status}`);\n  }\n\n}\n",
        "gt": [
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/logging.service.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/accounts.service.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.component.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/services-and-dependency-injection/services/src/main.ts'"
        ]
    },
    {
        "files": [
            "'ng-jda-2017-07-05/apps/store-app-http-start/src/app/product-form/product-form.component.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http-start/src/app/services/products.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http-start/src/main.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http-start/src/app/app.module.ts'"
        ],
        "content": "'ng-jda-2017-07-05/apps/store-app-http-start/src/app/product-form/product-form.component.ts'\n:import { Component, OnInit, ViewChild } from '@angular/core';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { NgForm } from '@angular/forms';\nimport { Observable } from 'rxjs/observable';\n\nimport { Product } from '../models/product';\nimport { LoggingService } from '../services/logging.service';\nimport { ProductsService } from '../services/products.service';\n\n@Component({\n  selector: 'app-product-form',\n  templateUrl: './product-form.component.html',\n  styleUrls: ['./product-form.component.css']\n})\nexport class ProductFormComponent implements OnInit {\n  id: number;\n  product: Product;\n  showMessage: boolean;\n  addNew: boolean;\n\n  constructor(\n    private loggingService: LoggingService,\n    private productsService: ProductsService,\n    private route: ActivatedRoute,\n    private router: Router\n  ) {\n    this.product = new Product();\n    this.showMessage = false;\n  }\n\n  ngOnInit() {\n    this.route.params.subscribe(\n      (params) => {\n        if(params['id'] === 'new') {\n          this.product = new Product();\n          this.addNew = true;\n        } else {\n          this.id = +params.id;\n          this.product = this.productsService.getProduct(this.id);\n\n          if(this.product) {\n            this.addNew = false;\n          }\n          else {\n            this.addNew = true;\n            this.product = new Product();\n          }\n        }\n      }\n    );\n  }\n\n  onSave() {\n    this.product.price = +this.product.price;\n    this.product.isAvailable = this.product.isAvailable ? this.product.isAvailable : false;\n    console.log('product:', this.product);\n\n    if(this.addNew) {\n      this.productsService.addProduct(this.product);\n      this.router.navigate(['/products']);\n    }\n    else {\n      this.productsService.updateProduct(this.id, this.product);\n      this.router.navigate(['/products', this.id]);\n    }\n  }\n\n  onSubmit(pf: NgForm) {\n    console.log('form:', pf);\n    console.log(pf.value);\n  }\n\n  onFocus() {\n    console.log('hi');\n  }\n\n}\n\n'ng-jda-2017-07-05/apps/store-app-http-start/src/app/services/products.service.ts'\n:import { Injectable } from '@angular/core';\nimport { Http, Response } from '@angular/http';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/observable/throw';\n\nimport { Product } from '../models/product';\nimport { LoggingService } from './logging.service';\nimport { StoreAppError } from \"app/errors/store-app-error\";\n\n@Injectable()\nexport class ProductsService {\n    private products: Product[];\n    private apiUrl = 'http:\n\n    constructor(\n        private loggingService: LoggingService,\n        private http: Http\n    ) {\n        this.products = [\n            { id: 1, name: 'Data Structures and Algorithms', description: 'An ideal book for first course on data structures and algorithms, its text ensures a style and content relevant to present-day programming.', isAvailable: true, price: 285 },\n            { id: 2, name: 'Premsons 608 Four Bearing Fidget Spinner', description: 'Perfect toy for fidgeters.', isAvailable: false, price: 160 },\n            { id: 3, name: 'Bahubali', description: 'Raised in a remote tribal village, Shivudu grows up a carefree young man who relentlessly pursues his heart\\'s desire.', isAvailable: true, price: 268 }\n        ];\n    }\n\n    getProductsLocal() {\n        this.loggingService.log('Returning all products.');\n\n        return this.products;\n    }\n\n    getProducts() : Observable<Product[]> {\n        return this.http.get(this.apiUrl)\n            .map( (response: Response) => response.json() )\n            .catch( (error: Response) => {\n\n                return Observable.throw(new StoreAppError(error.json()));\n            });\n    }\n\n    getProduct(id: number) {\n        const product = this.products.find(\n            product => product.id === id\n        );\n\n        this.loggingService.log('Returning a single product for product id: ' + id);\n        return product;\n    }\n\n    addProduct(product: Product) {\n        let newProduct = new Product();\n        newProduct.id = this.generateId();\n        newProduct.name = product.name;\n        newProduct.description = product.description;\n        newProduct.isAvailable = product.isAvailable;\n        newProduct.price = product.price;\n\n        this.products.push(newProduct);\n    }\n\n    private generateId(): number {\n        let id = 1;\n        let lastItemIndex = this.products.length - 1;\n        if(lastItemIndex > -1) {\n            id = this.products[lastItemIndex].id + 1;\n        }\n        return id;\n    }\n\n    updateProduct(id: number, productInfo: Product) {\n        const product = this.getProduct(id);\n\n        if(product) {\n            product.name = productInfo.name;\n            product.description = productInfo.description;\n            product.isAvailable = productInfo.isAvailable;\n            product.price = productInfo.price;\n        }\n    }\n\n    deleteProduct(id: number) {\n        const index = this.products.findIndex(\n            product => product.id === id\n        )\n\n        if(index >= 0) {\n            this.products.splice(index, 1);\n        }\n    }\n}\n\n'ng-jda-2017-07-05/apps/store-app-http-start/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n'ng-jda-2017-07-05/apps/store-app-http-start/src/app/app.module.ts'\n:import { HttpModule } from '@angular/http';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { Routes, RouterModule } from '@angular/router';\n\n\nimport { AppComponent } from './app.component';\n\nimport { HomeComponent } from './home/home.component';\nimport { AppNavComponent } from './app-nav/app-nav.component';\nimport { NotFoundComponent } from './not-found/not-found.component';\n\nimport { ProductsComponent } from './products/products.component';\nimport { ProductDetailComponent } from './product-detail/product-detail.component';\nimport { ProductFormComponent } from './product-form/product-form.component';\nimport { ProductListComponent } from './product-list/product-list.component';\nimport { ProductTableComponent } from './product-table/product-table.component';\n\nimport { CustomersComponent } from './customers/customers.component';\nimport { CustomerFormComponent } from './customer-form/customer-form.component';\n\nimport { CustDirDemoComponent } from './cust-dir-demo/cust-dir-demo.component';\n\n\nimport { ProductsService } from './services/products.service';\nimport { LoggingService } from './services/logging.service';\n\n\nconst appRoutes: Routes = [\n  { path: 'products', component: ProductsComponent, children: [\n    { path: ':id', component: ProductDetailComponent },\n    { path: ':id/edit', component: ProductFormComponent }\n  ] },\n\n  { path: 'customers', component: CustomersComponent },\n\n  { path: 'cust-pipes', component: ProductTableComponent },\n  { path: 'cust-directives', component: CustDirDemoComponent },\n\n  { path: '', component: HomeComponent},\n  { path: '**', component: NotFoundComponent }\n];\n\n@NgModule({\n  declarations: [\n    AppComponent,\n\n    HomeComponent,\n    AppNavComponent,\n    NotFoundComponent,\n\n    ProductsComponent,\n    ProductDetailComponent,\n    ProductFormComponent,\n    ProductListComponent,\n    ProductTableComponent,\n\n    CustomersComponent,\n    CustomerFormComponent,\n\n    CustDirDemoComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    RouterModule.forRoot(appRoutes),\n    HttpModule\n  ],\n  providers: [LoggingService, ProductsService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n",
        "gt": [
            "'ng-jda-2017-07-05/apps/store-app-http-start/src/app/services/products.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http-start/src/app/product-form/product-form.component.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http-start/src/app/app.module.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http-start/src/main.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/api-key/error/unathorized-api-key.error.ts'",
            "'is-even/apps/backend/src/api-key/api-key.service.ts'",
            "'is-even/apps/backend/src/usage/usage.service.spec.ts'"
        ],
        "content": "'is-even/apps/backend/src/api-key/error/unathorized-api-key.error.ts'\n:export class UnathorizedApiKeyError extends Error {\n  constructor() {\n    super(`Unathorized access to an API key.`);\n  }\n}\n\n'is-even/apps/backend/src/api-key/api-key.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport * as crypto from 'crypto';\n\nimport { User } from '../user/user.entity';\nimport { ApiKey } from './api-key.entity';\nimport { LoggerService } from '../logger/logger.service';\n\nimport { CreateApiKeyError } from './error/create-api-key.error';\nimport { ReadApiKeyError } from './error/read-api-key.error';\nimport { DeleteApiKeyError } from './error/delete-api-key.error';\nimport { UnathorizedApiKeyError } from './error/unathorized-api-key.error';\nimport { NotFoundApiKeyError } from './error/not-found-api-key.error';\n\n@Injectable()\nexport class ApiKeyService {\n  constructor(\n    private readonly loggerService: LoggerService,\n    @InjectRepository(ApiKey)\n    private readonly apiKeyRepository: Repository<ApiKey>,\n  ) {\n    this.loggerService.setContext(ApiKeyService.name);\n  }\n\n  public async createApiKey(name: string, user: User): Promise<ApiKey> {\n    try {\n      const apiKey = new ApiKey();\n\n      apiKey.user = user;\n      apiKey.name = name;\n      apiKey.value = this.generateRandomValue(50);\n\n      return await this.apiKeyRepository.save(apiKey);\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to create a new API key. ${error.message}`,\n      );\n      throw new CreateApiKeyError(error);\n    }\n  }\n\n  public async readApiKeys(user: User): Promise<ApiKey[]> {\n    try {\n      return await this.apiKeyRepository.find({\n        where: {\n          user,\n        },\n      });\n    } catch (error) {\n      this.loggerService.error(`Failed to read API keys. ${error.message}`);\n      throw new ReadApiKeyError(error);\n    }\n  }\n\n  public async deleteApiKey(apiKeyId: string, user: User): Promise<void> {\n    let apiKey: ApiKey;\n\n    try {\n      apiKey = await this.findApiKeyById(apiKeyId);\n    } catch (error) {\n      this.loggerService.error(`Failed to read API key. ${error.message}`);\n      throw new DeleteApiKeyError(error);\n    }\n\n    if (!apiKey) {\n      throw new NotFoundApiKeyError();\n    }\n\n    if (!apiKey.belongsTo(user.id)) {\n      throw new UnathorizedApiKeyError();\n    }\n\n    try {\n      await this.apiKeyRepository.delete({ id: apiKeyId });\n    } catch (error) {\n      this.loggerService.error(`Failed to delete API key. ${error.message}`);\n      throw new DeleteApiKeyError(error);\n    }\n  }\n\n  public async useApiKey(apiKeyValue: string): Promise<ApiKey> {\n    try {\n      const apiKey = await this.apiKeyRepository.findOneOrFail({\n        where: {\n          value: apiKeyValue,\n        },\n      });\n\n      apiKey.lastUsed = new Date();\n\n      await this.apiKeyRepository.save(apiKey);\n\n      return apiKey;\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to fetch owner of API key. ${error.message}`,\n      );\n      throw new NotFoundApiKeyError();\n    }\n  }\n\n  private async findApiKeyById(apiKeyId: string): Promise<ApiKey> {\n    return await this.apiKeyRepository.findOne({ id: apiKeyId });\n  }\n\n  private generateRandomValue(length = 50): string {\n    return crypto.randomBytes(length / 2).toString('hex');\n  }\n}\n\n'is-even/apps/backend/src/usage/usage.service.spec.ts'\n:import { Test, TestingModule } from '@nestjs/testing';\n\nimport { ApiKeyService } from '../api-key/api-key.service';\nimport { CreditService } from '../credit/credit.service';\nimport { UsageService } from './usage.service';\n\ndescribe('UsageService', () => {\n  let service: UsageService;\n\n  const apiKeyServiceMock = {};\n  const creditServiceMock = {};\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        UsageService,\n        {\n          provide: ApiKeyService,\n          useValue: apiKeyServiceMock,\n        },\n        {\n          provide: CreditService,\n          useValue: creditServiceMock,\n        },\n      ],\n    }).compile();\n\n    service = module.get<UsageService>(UsageService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n});\n",
        "gt": [
            "'is-even/apps/backend/src/api-key/error/unathorized-api-key.error.ts'",
            "'is-even/apps/backend/src/api-key/api-key.service.ts'",
            "'is-even/apps/backend/src/usage/usage.service.spec.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shared/dropdown.directive.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shared/shared.module.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/project/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { CoreModule } from './core.module';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\n\nimport * as fromApp from './store/app.reducer';\nimport { AuthEffects } from './auth/store/auth.effects';\nimport { environment } from 'src/environments/environment';\nimport { RecipeEffects } from './recipes/store/recipe.effects';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    SharedModule,\n    CoreModule,\n    StoreModule.forRoot(fromApp.appReducer),\n    EffectsModule.forRoot([AuthEffects, RecipeEffects]),\n    StoreDevtoolsModule.instrument({\n      logOnly: environment.production\n    }),\n    StoreRouterConnectingModule.forRoot()\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/project/src/app/shared/dropdown.directive.ts'\n:import { Directive, ElementRef, HostBinding, HostListener } from '@angular/core';\n\n@Directive({\n  selector: '[appDropdown]'\n})\nexport class DropdownDirective {\n\n  @HostBinding('class.open') isOpen: boolean = false;\n\n  @HostListener('document:click', ['$event']) toggleOpen() {\n    this.isOpen = this.elRef.nativeElement.contains(event.target) ? !this.isOpen : false;\n  }\n\n  constructor(\n    private elRef: ElementRef\n  ) { }\n\n}\n\n'angular-the-complete-guide-2023/project/src/app/shared/shared.module.ts'\n:import { CommonModule } from \"@angular/common\";\n\nimport { NgModule } from \"@angular/core\";\n\nimport { AlertComponent } from \"./alert/alert.component\";\n\nimport { DropdownDirective } from \"./dropdown.directive\";\n\nimport { LoadingSpinnerComponent } from \"./loading-spinner/loading-spinner.component\";\n\nimport { PlaceholderDirective } from \"./placeholder.directive\";\n\n\n\n@NgModule({\n\n  declarations: [\n\n    AlertComponent,\n\n    LoadingSpinnerComponent,\n\n    PlaceholderDirective,\n\n    DropdownDirective\n\n  ],\n\n  imports: [\n\n    CommonModule\n\n  ],\n\n  exports: [\n\n    AlertComponent,\n\n    LoadingSpinnerComponent,\n\n    PlaceholderDirective,\n\n    DropdownDirective,\n\n    CommonModule\n\n  ],\n\n  entryComponents: [\n\n    AlertComponent\n\n  ]\n\n})\n\nexport class SharedModule { }\n\n",
        "gt": [
            "'angular-the-complete-guide-2023/project/src/app/shared/dropdown.directive.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shared/shared.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'ng-jda-2017-07-05/apps/store-app/src/app/services/logging.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/main.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/customers/customer-list/customer-list.component.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/app.module.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/services/customers.service.ts'"
        ],
        "content": "'ng-jda-2017-07-05/apps/store-app/src/app/services/logging.service.ts'\n:export class LoggingService {\n    logMessage(message: string) {\n        console.log('[LoggingService.logMessage()]', message);\n    }\n}\n\n'ng-jda-2017-07-05/apps/store-app/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n'ng-jda-2017-07-05/apps/store-app/src/app/customers/customer-list/customer-list.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { Router } from '@angular/router';\n\nimport { Customer } from '../../models/customer';\nimport { CustomersService } from '../../services/customers.service';\nimport { LoggingService } from '../../services/logging.service';\n\n@Component({\n  selector: 'app-customer-list',\n  templateUrl: './customer-list.component.html',\n  styleUrls: ['./customer-list.component.css']\n})\nexport class CustomerListComponent implements OnInit {\n  customers: Customer[];\n\n  constructor(\n    private customersSerivce: CustomersService,\n    private loggingService: LoggingService,\n    private router: Router\n  ) { }\n\n  ngOnInit() {\n    this.customers = this.customersSerivce.getCustomers();\n  }\n\n  onAdd() {\n    this.loggingService.logMessage('Customer List - Add button clicked.')\n    this.router.navigate(['/customers', 'new', 'edit']);\n  }\n}\n\n'ng-jda-2017-07-05/apps/store-app/src/app/app.module.ts'\n:import { ErrorHandler } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { Routes, RouterModule } from '@angular/router';\nimport { HttpModule } from '@angular/http';\n\nimport { AppComponent } from './app.component';\n\n\nimport { HomeComponent } from './home/home.component';\nimport { NotFoundComponent } from './not-found/not-found.component';\nimport { NavComponent } from './nav/nav.component';\n\n\nimport { ProductsComponent } from './products/products.component';\nimport { ProductListComponent } from './products/product-list/product-list.component';\nimport { ProductDetailComponent } from './products/product-detail/product-detail.component';\nimport { ProductFormComponent } from './products/product-form/product-form.component';\n\n\nimport { CustomersComponent } from './customers/customers.component';\nimport { CustomerListComponent } from './customers/customer-list/customer-list.component';\nimport { CustomerDetailComponent } from './customers/customer-detail/customer-detail.component';\nimport { CustomerFormComponent } from './customers/customer-form/customer-form.component';\n\n\nimport { LoggingService } from './services/logging.service';\nimport { ProductsService } from './services/products.service';\nimport { CustomersService } from './services/customers.service';\n\n\nimport { AppErrorHandler } from './errors/app-error-handler';\n\n\nconst appRoutes: Routes = [\n  {\n    path: 'products', component: ProductsComponent, children: [\n      { path: ':id', component: ProductDetailComponent },\n      { path: ':id/edit', component: ProductFormComponent }\n    ]\n  },\n  {\n    path: 'customers', component: CustomersComponent, children: [\n      { path: ':id', component: CustomerDetailComponent },\n      { path: ':id/edit', component: CustomerFormComponent }\n    ]\n  },\n  { path: '', component: HomeComponent },\n  { path: 'not-found', component: NotFoundComponent },\n  { path: '**', redirectTo: 'not-found' }\n];\n\n@NgModule({\n  declarations: [\n    AppComponent,\n\n    HomeComponent,\n    NotFoundComponent,\n    NavComponent,\n\n    ProductsComponent,\n    ProductListComponent,\n    ProductDetailComponent,\n    ProductFormComponent,\n\n    CustomersComponent,\n    CustomerListComponent,\n    CustomerDetailComponent,\n    CustomerFormComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpModule,\n    RouterModule.forRoot(appRoutes)\n  ],\n  providers: [\n    LoggingService,\n    ProductsService,\n    CustomersService,\n    { provide: ErrorHandler, useClass: AppErrorHandler }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'ng-jda-2017-07-05/apps/store-app/src/app/services/customers.service.ts'\n:import { Injectable } from '@angular/core';\n\nimport { Customer } from '../models/customer';\nimport { LoggingService } from './logging.service';\n\n@Injectable()\nexport class CustomersService {\n    private customers: Customer[] = [\n        { id: 1, name: 'John', phone: '9988776655', email: 'john@abc.xyz', city: 'Bengaluru' },\n        { id: 2, name: 'Asif', phone: '1122334455', email: 'asif@abc.xyz', city: 'Chennai' },\n        { id: 3, name: 'Hari', phone: '3355776644', email: 'hari@abc.xyz', city: 'Mumbai' },\n        { id: 4, name: 'Amar', phone: '2244668800', email: 'amar@abc.xyz', city: 'New Delhi' }\n    ];\n\n    constructor(private loggingService: LoggingService) {}\n\n    getCustomers(): Customer[] {\n        return this.customers;\n    }\n\n    getCustomer(id: number): Customer {\n        this.loggingService.logMessage('Get Product, id: ' + id);\n        const customer = this.customers.find(\n            customer => customer.id === id\n        )\n\n        return customer;\n    }\n\n    addCustomer(customer: Customer) {\n        const newCustomer = new Customer();\n        newCustomer.id = this.generateId();\n        newCustomer.name = customer.name;\n        newCustomer.email = customer.email;\n        newCustomer.phone = customer.phone;\n        newCustomer.city = customer.city;\n\n        this.customers.push(newCustomer);\n    }\n\n    private generateId(): number {\n        let id = 1;\n        let lastItemIndex = this.customers.length - 1;\n        if(lastItemIndex > -1) {\n            id = this.customers[lastItemIndex].id + 1;\n        }\n        return id;\n    }\n\n    updateCustomer(id: number, customerInfo: Customer) {\n        const customer = this.getCustomer(id);\n\n        if(customer) {\n            customer.name = customerInfo.name;\n            customer.email = customerInfo.email;\n            customer.phone = customerInfo.phone;\n            customer.city = customerInfo.city;\n        }\n    }\n\n    deletecustomer(id: number) {\n        const index = this.customers.findIndex(\n            customer => customer.id === id\n        )\n\n        if(index >= 0) {\n            this.customers.splice(index, 1);\n        }\n    }\n}\n",
        "gt": [
            "'ng-jda-2017-07-05/apps/store-app/src/app/services/logging.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/services/customers.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/customers/customer-list/customer-list.component.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/app.module.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/main.ts'"
        ]
    },
    {
        "files": [
            "'nestjs-db-postgresql/src/app/user/user.controller.ts'",
            "'nestjs-db-postgresql/src/app/user/user.entity.ts'",
            "'nestjs-db-postgresql/src/app/user.module.ts'",
            "'nestjs-db-postgresql/src/server.ts'",
            "'nestjs-db-postgresql/src/app/app.module.ts'"
        ],
        "content": "'nestjs-db-postgresql/src/app/user/user.controller.ts'\n:import { User } from './user.entity';\nimport { UsersService } from './user.service';\nimport { Controller, Get } from '@nestjs/common';\n\n@Controller()\nexport class UserController {\n\n    constructor(private readonly userService : UsersService){}\n\n    @Get('users')\n    getAllUsers() : Promise<User[]> {\n        return this.userService.getAllUsers();\n    }\n}\n'nestjs-db-postgresql/src/app/user/user.entity.ts'\n:import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn() id: number;\n\n  @Column({length: 500 })\n  name: string;\n\n  @Column('mobile') mobile: string;\n\n  @Column('email') email: string;\n}\n'nestjs-db-postgresql/src/app/user.module.ts'\n:import { TypeOrmModule } from '@nestjs/typeorm';\nimport { UserController } from './user/user.controller';\nimport { Module } from '@nestjs/common';\nimport { UsersService } from './user/user.service';\nimport { User } from './user/user.entity';\n\n@Module({\n    imports: [TypeOrmModule.forFeature([User])],\n    controllers: [UserController],\n    components: [UsersService]\n})\nexport class UsersModule {\n\n    constructor() {\n        console.log('user module get loaded');\n    }\n};\n'nestjs-db-postgresql/src/server.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { ApplicationModule } from './app/app.module';\nimport { INestApplication } from '@nestjs/common/interfaces/nest-application.interface';\n\nconst app: Promise<INestApplication> = NestFactory.create(ApplicationModule);\napp.then(instance =>\n  instance.listen(3000, () =>\n    console.log('Application is listening on port 3000')\n  )\n);\n\n'nestjs-db-postgresql/src/app/app.module.ts'\n:import { UsersModule } from './user.module';\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from \"@nestjs/typeorm\";\nimport { AboutController } from './about/about.controller';\nimport { User } from './user/user.entity';\n\n@Module({\n    imports : [\n        TypeOrmModule.forRoot(),\n        UsersModule\n    ],\n    controllers : [\n        AboutController\n    ]\n})\nexport class ApplicationModule {\n\n    constructor() {\n        console.log('main module got loaded');\n    }\n}",
        "gt": [
            "'nestjs-db-postgresql/src/app/user/user.entity.ts'",
            "'nestjs-db-postgresql/src/app/user/user.controller.ts'",
            "'nestjs-db-postgresql/src/app/user.module.ts'",
            "'nestjs-db-postgresql/src/app/app.module.ts'",
            "'nestjs-db-postgresql/src/server.ts'"
        ]
    },
    {
        "files": [
            "'fc-ddd-patterns/src/domain/checkout/factory/order.factory.ts'",
            "'fc-ddd-patterns/src/domain/checkout/factory/order.factory.spec.ts'",
            "'fc-ddd-patterns/src/domain/checkout/entity/order_item.ts'",
            "'fc-ddd-patterns/src/domain/checkout/entity/order.ts'"
        ],
        "content": "'fc-ddd-patterns/src/domain/checkout/factory/order.factory.ts'\n:import Order from \"../entity/order\";\nimport OrderItem from \"../entity/order_item\";\n\ninterface OrderFactoryProps {\n  id: string;\n  customerId: string;\n  items: {\n    id: string;\n    name: string;\n    productId: string;\n    quantity: number;\n    price: number;\n  }[];\n}\n\nexport default class OrderFactory {\n  public static create(props: OrderFactoryProps): Order {\n    const items = props.items.map((item) => {\n      return new OrderItem(\n        item.id,\n        item.name,\n        item.price,\n        item.productId,\n        item.quantity\n      );\n    });\n\n    return new Order(props.id, props.customerId, items);\n\n  }\n}\n\n'fc-ddd-patterns/src/domain/checkout/factory/order.factory.spec.ts'\n:import { UUID } from \"sequelize/types\";\nimport { v4 as uuid } from \"uuid\";\nimport OrderFactory from \"./order.factory\";\n\ndescribe(\"Order factory unit test\", () => {\n  it(\"should create an order\", () => {\n    const orderProps = {\n      id: uuid(),\n      customerId: uuid(),\n      items: [\n        {\n          id: uuid(),\n          name: \"Product 1\",\n          productId: uuid(),\n          quantity: 1,\n          price: 100,\n        },\n      ],\n    };\n\n    const order = OrderFactory.create(orderProps);\n\n    expect(order.id).toEqual(orderProps.id);\n    expect(order.customerId).toEqual(orderProps.customerId);\n    expect(order.items.length).toBe(1);\n  });\n});\n\n'fc-ddd-patterns/src/domain/checkout/entity/order_item.ts'\n:export default class OrderItem {\n  private _id: string;\n  private _productId: string;\n  private _name: string;\n  private _price: number;\n  private _quantity: number;\n\n  constructor(\n    id: string,\n    name: string,\n    price: number,\n    productId: string,\n    quantity: number\n  ) {\n    this._id = id;\n    this._name = name;\n    this._price = price;\n    this._productId = productId;\n    this._quantity = quantity;\n  }\n\n  get id(): string {\n    return this._id;\n  }\n\n  get name(): string {\n    return this._name;\n  }\n\n  get productId(): string {\n    return this._productId;\n  }\n\n  get quantity(): number {\n    return this._quantity;\n  }\n\n  get price(): number {\n    return this._price;\n  }\n\n  orderItemTotal(): number {\n    return this._price * this._quantity;\n  }\n\n}\n\n'fc-ddd-patterns/src/domain/checkout/entity/order.ts'\n:import OrderItem from \"./order_item\";\nexport default class Order {\n  private _id: string;\n  private _customerId: string;\n  private _items: OrderItem[];\n  private _total: number;\n\n  constructor(id: string, customerId: string, items: OrderItem[]) {\n    this._id = id;\n    this._customerId = customerId;\n    this._items = items;\n    this._total = this.total();\n    this.validate();\n  }\n\n  get id(): string {\n    return this._id;\n  }\n\n  get customerId(): string {\n    return this._customerId;\n  }\n\n  get items(): OrderItem[] {\n    return this._items;\n  }\n\n  validate(): boolean {\n    if (this._id.length === 0) {\n      throw new Error(\"Id is required\");\n    }\n    if (this._customerId.length === 0) {\n      throw new Error(\"CustomerId is required\");\n    }\n    if (this._items.length === 0) {\n      throw new Error(\"Items are required\");\n    }\n\n    if (this._items.some((item) => item.quantity <= 0)) {\n      throw new Error(\"Quantity must be greater than 0\");\n    }\n\n    return true;\n  }\n\n  total(): number {\n    return this._items.reduce((acc, item) => acc + item.orderItemTotal(), 0);\n  }\n}\n",
        "gt": [
            "'fc-ddd-patterns/src/domain/checkout/entity/order_item.ts'",
            "'fc-ddd-patterns/src/domain/checkout/entity/order.ts'",
            "'fc-ddd-patterns/src/domain/checkout/factory/order.factory.ts'",
            "'fc-ddd-patterns/src/domain/checkout/factory/order.factory.spec.ts'"
        ]
    },
    {
        "files": [
            "'event-sourcing-demo-app/backend/src/domain/port/errors/PortError.ts'",
            "'event-sourcing-demo-app/backend/src/presentation/routes/port/delete.ts'",
            "'event-sourcing-demo-app/backend/src/domain/port/errors/PortNotFoundError.ts'",
            "'event-sourcing-demo-app/backend/src/presentation/routes/index.ts'",
            "'event-sourcing-demo-app/backend/src/services/PortService.ts'"
        ],
        "content": "'event-sourcing-demo-app/backend/src/domain/port/errors/PortError.ts'\n:import { DomainError } from '../../domain.error'\n\nexport class PortError extends DomainError {\n\n}\n\n'event-sourcing-demo-app/backend/src/presentation/routes/port/delete.ts'\n:import rescue from 'express-rescue'\nimport { HttpError } from '@expresso/expresso'\nimport { ShipService } from '../../../services/ShipService'\nimport { ShipNotFoundError } from '../../../domain/ship/errors/ShipNotFoundError'\nimport { PortService } from '../../../services/PortService'\n\nexport function factory (service: PortService, shipService: ShipService) {\n  return [\n\n    rescue(async (req, res) => {\n      const port = await service.delete(req.params.portId, req.onBehalfOf)\n\n      for (const shipId of port.dockedShips) {\n        await shipService.depart(shipId, 'Port was deleted', req.onBehalfOf)\n      }\n\n      res.status(204).end()\n    }),\n    (err, _req, _res, next) => {\n      if (err instanceof ShipNotFoundError) return next(new HttpError.NotFound({ message: err.message, code: 'ship_not_found' }))\n\n      next(err)\n    }\n  ]\n}\n\n'event-sourcing-demo-app/backend/src/domain/port/errors/PortNotFoundError.ts'\n:import { PortError } from './PortError'\nimport { format } from 'util'\n\nconst MESSAGE = 'Port with ID \"%s\" was not found'\n\nexport class PortNotFoundError extends PortError {\n  constructor (id: string) {\n    super(format(MESSAGE, id))\n  }\n}\n\n'event-sourcing-demo-app/backend/src/presentation/routes/index.ts'\n:export default {\n  ship: {\n    create: require('./ship/create'),\n    delete: require('./ship/delete'),\n    find: require('./ship/find'),\n    getAll: require('./ship/getAll'),\n    dock: require('./ship/dock'),\n    depart: require('./ship/depart'),\n    getEvents: require('./ship/getEvents')\n  },\n  port: {\n    create: require('./port/create'),\n    delete: require('./port/delete'),\n    find: require('./port/find'),\n    getAll: require('./port/getAll'),\n    getEvents: require('./port/getEvents')\n  }\n}\n\n'event-sourcing-demo-app/backend/src/services/PortService.ts'\n:import { ObjectId } from 'mongodb'\nimport { Port, Ship } from '../domain'\nimport { PortRepository } from '../data/repositories/PortRepository'\nimport { PortNotFoundError } from '../domain/port/errors/PortNotFoundError'\nimport { IPortCreationParams } from '../domain/structures/IPortCreationParams'\n\nexport class PortService {\n  private readonly repository: PortRepository\n\n  constructor (repository: PortRepository) {\n    this.repository = repository\n  }\n\n  async create (params: IPortCreationParams, user: string): Promise<Port> {\n    const port = Port.create(params, user)\n\n    return this.repository.save(port)\n  }\n\n  async undockShip (ship: Ship, reason: string, user: string): Promise<void> {\n    if (!ship.currentPort) return\n\n    const port = await this.repository.findById(ship.currentPort)\n    if (!port) return\n    if (!port.dockedShips.find((dockedShip) => dockedShip.equals(ship.id as ObjectId))) return\n\n    port.undockShip(ship, reason, user)\n\n    await this.repository.save(port)\n  }\n\n  async dockShip (ship: Ship, user: string): Promise<void> {\n    if (!ship.currentPort) return\n\n    const port = await this.repository.findById(ship.currentPort)\n\n    if (!port) throw new PortNotFoundError(ship.currentPort.toHexString())\n    if (port.dockedShips.find((dockedShip) => dockedShip.equals(ship.id as ObjectId))) return\n\n    port.dockShip(ship, user)\n    await this.repository.save(port)\n  }\n\n  async delete (portId: string, user: string): Promise<Port> {\n    const port = await this.repository.findById(portId)\n\n    if (!port) throw new PortNotFoundError(portId)\n\n    port.delete(user)\n\n    return this.repository.save(port)\n  }\n\n  async find (id: ObjectId | string): Promise<Port> {\n    const port = await this.repository.findById(id)\n\n    if (!port) throw new PortNotFoundError(id as string)\n\n    return port\n  }\n\n  async getAll (): Promise<Port[]> {\n    return this.repository.getAll()\n  }\n}\n",
        "gt": [
            "'event-sourcing-demo-app/backend/src/domain/port/errors/PortError.ts'",
            "'event-sourcing-demo-app/backend/src/domain/port/errors/PortNotFoundError.ts'",
            "'event-sourcing-demo-app/backend/src/services/PortService.ts'",
            "'event-sourcing-demo-app/backend/src/presentation/routes/port/delete.ts'",
            "'event-sourcing-demo-app/backend/src/presentation/routes/index.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/project/src/app/auth/auth-interceptor.service.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'",
            "'angular-the-complete-guide-2023/project/src/app/core.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/project/src/app/auth/auth-interceptor.service.ts'\n:import { HttpHandler, HttpInterceptor, HttpParams, HttpRequest } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\nimport { Store } from '@ngrx/store';\nimport { exhaustMap, take, map } from 'rxjs/operators';\nimport { AuthService } from './auth.service';\nimport * as fromApp from '../store/app.reducer';\n\n@Injectable()\nexport class AuthInterceptorService implements HttpInterceptor {\n\n  constructor(\n    private authService: AuthService,\n    private store: Store<fromApp.AppState>\n  ) { }\n\n  intercept(req: HttpRequest<any>, next: HttpHandler) {\n    return this.store.select('auth').pipe(\n      take(1),\n      map(authState => {\n        return authState.user;\n      }),\n      exhaustMap(user => {\n        if (!user) {\n          return next.handle(req);\n        }\n\n        const modifiedReq = req.clone({\n          params: new HttpParams().set('auth', user.token)\n        });\n\n        return next.handle(modifiedReq);\n      }));\n  }\n\n}\n\n'angular-the-complete-guide-2023/project/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { CoreModule } from './core.module';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\n\nimport * as fromApp from './store/app.reducer';\nimport { AuthEffects } from './auth/store/auth.effects';\nimport { environment } from 'src/environments/environment';\nimport { RecipeEffects } from './recipes/store/recipe.effects';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    SharedModule,\n    CoreModule,\n    StoreModule.forRoot(fromApp.appReducer),\n    EffectsModule.forRoot([AuthEffects, RecipeEffects]),\n    StoreDevtoolsModule.instrument({\n      logOnly: environment.production\n    }),\n    StoreRouterConnectingModule.forRoot()\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/project/src/app/core.module.ts'\n:import { HTTP_INTERCEPTORS } from \"@angular/common/http\";\n\nimport { NgModule } from \"@angular/core\";\n\nimport { AuthInterceptorService } from \"./auth/auth-interceptor.service\";\n\n\n\n@NgModule({\n\n  providers: [\n\n    {\n\n      provide: HTTP_INTERCEPTORS,\n\n      useClass: AuthInterceptorService,\n\n      multi: true\n\n    }\n\n  ]\n\n})\n\nexport class CoreModule { }\n\n\n'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'\n:import * as fromShoppingList from '../shopping-list/store/shopping-list.reducer';\n\nimport * as fromAuth from '../auth/store/auth.reducer';\n\nimport * as fromRecipes from '../recipes/store/recipe.reducer';\n\nimport { ActionReducerMap } from '@ngrx/store';\n\n\n\nexport interface AppState {\n\n  shoppingList: fromShoppingList.State;\n\n  auth: fromAuth.State;\n\n  recipes: fromRecipes.State;\n\n}\n\n\n\nexport const appReducer: ActionReducerMap<AppState> = {\n\n  shoppingList: fromShoppingList.shoppingListReducer,\n\n  auth: fromAuth.authReducer,\n\n  recipes: fromRecipes.recipeReducer\n\n};\n\n",
        "gt": [
            "'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'",
            "'angular-the-complete-guide-2023/project/src/app/auth/auth-interceptor.service.ts'",
            "'angular-the-complete-guide-2023/project/src/app/core.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'predicates/src/function.ts'",
            "'predicates/src/instanceOf.ts'",
            "'predicates/test/instanceOfTest.ts'"
        ],
        "content": "'predicates/src/function.ts'\n:import {setDescription} from './utils/description';\n\n\nfunction isFunction(value: any): value is Function {\n    return typeof value === 'function';\n}\n\nsetDescription(isFunction, 'a function');\nexport default isFunction;\n'predicates/src/instanceOf.ts'\n:import {TypeGuardPredicate} from './types';\nimport handleCurry from './utils/handleCurry';\nimport isFunction from './function';\nimport {setDescription} from './utils/description';\n\n\n\nfunction isInstanceOf<T>(clazz: Function): TypeGuardPredicate<T>;\nfunction isInstanceOf<T>(clazz: Function, value: any): value is T;\nfunction isInstanceOf<T>(clazz: Function, value?: any): boolean | TypeGuardPredicate<T> {\n    if (!isFunction(clazz)) {\n        throw new TypeError('Class must be a function');\n    }\n    return handleCurry.call(this, arguments,\n        setDescription(\n            (value: Function) => value instanceof clazz,\n            'an instance of ' + clazz.name\n        )\n    );\n}\n\nexport default isInstanceOf;\n'predicates/test/instanceOfTest.ts'\n:import isInstanceOf from '../src/instanceOf';\nimport {assert} from 'chai';\nimport {assertDescription} from \"./common\";\n\ndescribe('instanceOf', function () {\n    class CLAZZ {\n    }\n\n    it('throws TypeError if class is not a function', function () {\n        const notFunction = 'definitely not a function';\n        assert.throws(function () {\n            isInstanceOf(<any>notFunction);\n        }, TypeError, /must be a function/);\n        assert.throws(function () {\n            isInstanceOf(<any>notFunction)({});\n        }, TypeError, /must be a function/);\n    });\n\n    it('returns another function if only one argument provided', function () {\n        assert.isFunction(isInstanceOf(CLAZZ));\n    });\n\n    it('returns true if value is an instance of given \"class\"', function () {\n        assert.isTrue(isInstanceOf(CLAZZ, new CLAZZ));\n        assert.isTrue(isInstanceOf(CLAZZ)(new CLAZZ));\n        assert.isTrue(isInstanceOf(Array, []));\n        assert.isTrue(isInstanceOf(Array)([]));\n    });\n\n    it('returns false is value is not an instance of given \"class\"', function () {\n        assert.isFalse(isInstanceOf(CLAZZ, {}));\n        assert.isFalse(isInstanceOf(CLAZZ)({}));\n    });\n\n    it('description', () => {\n        assertDescription(isInstanceOf(CLAZZ), 'an instance of CLAZZ');\n    })\n});\n",
        "gt": [
            "'predicates/src/function.ts'",
            "'predicates/src/instanceOf.ts'",
            "'predicates/test/instanceOfTest.ts'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/delete-event/delete-event.component.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/pages/admin/update-event/delete-event/delete-event.component.ts'\n:import { Component, OnDestroy, Input } from '@angular/core';\nimport { EventModel } from './../../../../core/models/event.model';\nimport { Subscription } from 'rxjs';\nimport { ApiService } from './../../../../core/api.service';\nimport { Router } from '@angular/router';\n\n@Component({\n  selector: 'app-delete-event',\n  templateUrl: './delete-event.component.html',\n  styleUrls: ['./delete-event.component.scss']\n})\nexport class DeleteEventComponent implements OnDestroy {\n  @Input() event: EventModel;\n  confirmDelete: string;\n  deleteSub: Subscription;\n  submitting: boolean;\n  error: boolean;\n\n  constructor(\n    private api: ApiService,\n    private router: Router\n  ) { }\n\n  removeEvent() {\n    this.submitting = true;\n\n    this.deleteSub = this.api\n      .deleteEvent$(this.event._id)\n      .subscribe(\n        res => {\n          this.submitting = false;\n          this.error = false;\n          console.log(res.message);\n\n          this.router.navigate(['/admin']);\n        },\n        err => {\n          console.error(err);\n          this.submitting = false;\n          this.error = true;\n        }\n      );\n  }\n\n  ngOnDestroy() {\n    if (this.deleteSub) {\n      this.deleteSub.unsubscribe();\n    }\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/core/api.service.ts'\n:import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { AuthService } from './../auth/auth.service';\nimport { throwError as ObservableThrowError, Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { ENV } from './env.config';\nimport { EventModel } from './models/event.model';\nimport { RsvpModel } from './models/rsvp.model';\n\n@Injectable()\nexport class ApiService {\n  constructor(\n    private http: HttpClient,\n    private auth: AuthService\n  ) { }\n\n  private get _authHeader(): string {\n    return `Bearer ${this.auth.accessToken}`;\n  }\n\n\n  getEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events`)\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getAdminEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/admin`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getEventById$(id: string): Observable<EventModel> {\n    return this.http\n      .get<EventModel>(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getRsvpsByEventId$(eventId: string): Observable<RsvpModel[]> {\n    return this.http\n      .get<RsvpModel[]>(`${ENV.BASE_API}event/${eventId}/rsvps`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postEvent$(event: EventModel): Observable<EventModel> {\n    return this.http\n      .post<EventModel>(`${ENV.BASE_API}event/new`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editEvent$(id: string, event: EventModel): Observable<EventModel> {\n    return this.http\n      .put<EventModel>(`${ENV.BASE_API}event/${id}`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  deleteEvent$(id: string): Observable<any> {\n    return this.http\n      .delete(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getUserEvents$(userId: string): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/${userId}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postRsvp$(rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .post<RsvpModel>(`${ENV.BASE_API}rsvp/new`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editRsvp$(id: string, rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .put(`${ENV.BASE_API}rsvp/${id}`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n  private _handleError(err: HttpErrorResponse | any): Observable<any> {\n    const errorMsg = err.message || 'Error: Unable to complete request.';\n    if (err.message && err.message.indexOf('No JWT present') > -1) {\n      this.auth.login();\n    }\n    return ObservableThrowError(errorMsg);\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/delete-event/delete-event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'stromjs/src/functions/demux.ts'",
            "'stromjs/src/helpers.ts'",
            "'stromjs/src/functions/index.ts'"
        ],
        "content": "'stromjs/src/functions/demux.ts'\n:import { DuplexOptions, Duplex, Transform, Writable } from \"stream\";\n\nimport { isReadable } from \"../helpers\";\n\nexport interface DemuxOptions extends DuplexOptions {\n    remultiplex?: boolean;\n}\n\nexport function demux(\n    pipelineConstructor: (\n        destKey?: string,\n        chunk?: any,\n    ) => Writable | Writable[],\n    demuxBy: string | ((chunk: any) => string),\n    options?: DemuxOptions,\n): Duplex {\n    return new Demux(pipelineConstructor, demuxBy, options);\n}\n\nclass Demux extends Duplex {\n    private streamsByKey: {\n        [key: string]: Writable[];\n    };\n    private demuxer: (chunk: any) => string;\n    private pipelineConstructor: (destKey?: string, chunk?: any) => Writable[];\n    private remultiplex: boolean;\n    private transform: Transform;\n    constructor(\n        pipelineConstructor: (\n            destKey?: string,\n            chunk?: any,\n        ) => Writable | Writable[],\n        demuxBy: string | ((chunk: any) => string),\n        options: DemuxOptions = {},\n    ) {\n        super(options);\n        this.demuxer =\n            typeof demuxBy === \"string\" ? (chunk) => chunk[demuxBy] : demuxBy;\n        this.pipelineConstructor = (destKey: string, chunk?: any) => {\n            const pipeline = pipelineConstructor(destKey, chunk);\n            return Array.isArray(pipeline) ? pipeline : [pipeline];\n        };\n        this.remultiplex =\n            options.remultiplex === undefined ? true : options.remultiplex;\n        this.streamsByKey = {};\n        this.transform = new Transform({\n            ...options,\n            transform: (d, _, cb) => {\n                this.push(d);\n                cb(null);\n            },\n        });\n\n        this.on(\"unpipe\", () => this._flush());\n    }\n\n\n    public _read(_size: number) {}\n\n    public async _write(chunk: any, encoding: any, cb: any) {\n        const destKey = this.demuxer(chunk);\n        if (this.streamsByKey[destKey] === undefined) {\n            const newPipelines = this.pipelineConstructor(destKey, chunk);\n            this.streamsByKey[destKey] = newPipelines;\n\n            newPipelines.forEach((newPipeline) => {\n                if (this.remultiplex && isReadable(newPipeline)) {\n                    newPipeline.pipe(this.transform);\n                } else if (this.remultiplex) {\n                    console.error(\n                        `Pipeline construct for ${destKey} does not implement readable interface`,\n                    );\n                }\n            });\n        }\n        const pipelines = this.streamsByKey[destKey];\n        const pendingDrains: Promise<any>[] = [];\n\n        pipelines.forEach((pipeline) => {\n            if (!pipeline.write(chunk, encoding)) {\n                pendingDrains.push(\n                    new Promise((resolve) => {\n                        pipeline.once(\"drain\", () => {\n                            resolve(null);\n                        });\n                    }),\n                );\n            }\n        });\n        await Promise.all(pendingDrains);\n        cb();\n    }\n\n    public _flush() {\n        const pipelines: Writable[] = Array.prototype.concat.apply(\n            [],\n            Object.values(this.streamsByKey),\n        );\n        const flushPromises: Promise<void>[] = [];\n        pipelines.forEach((pipeline) => {\n            flushPromises.push(\n                new Promise((resolve) => {\n                    pipeline.once(\"end\", () => {\n                        resolve();\n                    });\n                }),\n            );\n        });\n        pipelines.forEach((pipeline) => pipeline.end());\n        Promise.all(flushPromises).then(() => {\n            this.push(null);\n            this.emit(\"end\");\n        });\n    }\n\n    public _destroy(error: any, cb: (error?: any) => void) {\n        const pipelines: Writable[] = [].concat.apply(\n            [],\n            Object.values(this.streamsByKey),\n        );\n        pipelines.forEach((p) => (p as any).destroy());\n        cb(error);\n    }\n}\n\n'stromjs/src/helpers.ts'\n:import { Readable, Stream, Writable } from \"stream\";\n\nexport async function sleep(time: number): Promise<{} | null> {\n    return time > 0\n        ? new Promise((resolve) => setTimeout(resolve, time))\n        : null;\n}\n\nexport function isReadable(stream: Stream): stream is Readable {\n    return (\n        (stream as Readable).pipe !== undefined &&\n        (stream as Readable).readable === true\n    );\n}\n\nexport function isWritable(stream: Stream): stream is Writable {\n    return (\n        (stream as Writable).write !== undefined &&\n        (stream as Writable).writable === true\n    );\n}\n\n'stromjs/src/functions/index.ts'\n:import { TransformOptions } from \"stream\";\nimport { accumulator, accumulatorBy } from \"./accumulator\";\nimport { batch } from \"./batch\";\nimport { child } from \"./child\";\nimport { collect } from \"./collect\";\nimport { concat } from \"./concat\";\nimport { duplex } from \"./duplex\";\nimport { filter } from \"./filter\";\nimport { flatMap } from \"./flatMap\";\nimport { fromArray } from \"./fromArray\";\nimport { join } from \"./join\";\nimport { last } from \"./last\";\nimport { map } from \"./map\";\nimport { merge } from \"./merge\";\nimport { parallelMap } from \"./parallelMap\";\nimport { parse } from \"./parse\";\nimport { rate } from \"./rate\";\nimport { reduce } from \"./reduce\";\nimport { replace } from \"./replace\";\nimport { split } from \"./split\";\nimport { stringify } from \"./stringify\";\nimport { unbatch } from \"./unbatch\";\nimport { compose } from \"./compose\";\nimport { demux } from \"./demux\";\n\nexport function strom(defaultOptions: TransformOptions = { objectMode: true }) {\n    function withDefaultOptions<T extends any[], R>(\n        n: number,\n        fn: (...args: T) => R,\n    ): (...args: T) => R {\n        return (...args) => {\n            const options = {\n                ...defaultOptions,\n                ...((args[n] || {}) as TransformOptions | {}),\n            };\n            const provided = args.slice(0, n);\n            const nextArgs = [\n                ...provided,\n                ...Array(n - provided.length).fill(undefined),\n                options,\n            ] as T;\n            return fn(...nextArgs) as R;\n        };\n    }\n\n    return {\n\n        fromArray,\n\n\n        map: withDefaultOptions(1, map),\n\n\n        flatMap: withDefaultOptions(1, flatMap),\n\n\n        filter: withDefaultOptions(1, filter),\n\n\n        reduce: withDefaultOptions(2, reduce),\n\n\n        split,\n\n\n        join: withDefaultOptions(1, join),\n\n\n        replace,\n\n\n        parse,\n\n\n        stringify,\n\n\n        collect: withDefaultOptions(0, collect),\n\n\n        concat,\n\n\n        merge,\n\n\n        duplex,\n\n\n        child,\n\n\n        last,\n\n\n        batch: withDefaultOptions(2, batch),\n\n\n        unbatch: withDefaultOptions(0, unbatch),\n\n\n        rate: withDefaultOptions(2, rate),\n\n\n        parallelMap: withDefaultOptions(3, parallelMap),\n\n\n        accumulator: withDefaultOptions(3, accumulator),\n\n\n        accumulatorBy: withDefaultOptions(2, accumulatorBy),\n\n\n        compose: withDefaultOptions(2, compose),\n\n\n        demux: withDefaultOptions(2, demux),\n\n\n        instance: strom,\n    };\n}\n",
        "gt": [
            "'stromjs/src/helpers.ts'",
            "'stromjs/src/functions/demux.ts'",
            "'stromjs/src/functions/index.ts'"
        ]
    },
    {
        "files": [
            "'installer-gui/frontend/components/actions/update.tsx'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'"
        ],
        "content": "'installer-gui/frontend/components/actions/update.tsx'\n:import Preact, {Component} from \"preact\";\nimport AppContext from \"../AppContext\";\nimport Terminal from \"../terminal\";\nimport {ipcRenderer as IPC} from \"electron\";\nimport IPCEvents from \"@common/ipcevents\";\nimport FileInput from \"../fileinput\";\nimport Updater from \"../../modules/updater\";\n\nexport default class UpdatePage extends Component<{}, {\n    isBrowsing: boolean;\n    updateDone: boolean;\n    kernelPath: string;\n}> {\n    terminalRef = Preact.createRef();\n\n    state = {\n        isBrowsing: true,\n        updateDone: false,\n        kernelPath: \"\"\n    };\n\n    renderUpdating() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Update Kernel</div>\n                <Terminal ref={this.terminalRef} />\n            </div>\n        );\n    }\n\n    renderBrowser() {\n        return (\n            <FileInput\n                title=\"Kernel path\"\n                name=\"Kernel path\"\n                onChange={([path]) => this.setState({kernelPath: path})}\n                files={[this.state.kernelPath].filter(Boolean)}\n                onRemove={() => {\n                    this.setState({kernelPath: \"\"});\n                }}\n            />\n        );\n    }\n\n    handleUpdate(): void {\n        Updater.update(this.state.kernelPath, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({updateDone: true});\n        });\n    }\n\n    render(_, {isBrowsing, updateDone}) {\n        return (\n            <AppContext.Consumer>\n                {App => (\n                    <div class=\"installing\">\n                        <div class=\"scroller\">\n                            {isBrowsing ? this.renderBrowser() : this.renderUpdating()}\n                            <div class=\"margin-bottom10\" />\n                        </div>\n                        <div class=\"footer\">\n                            <button onClick={() => {\n                                if (isBrowsing) App.reset();\n                                else this.setState({isBrowsing: true});\n                            }}>Back</button>\n                            <button\n                                onClick={() => {\n                                    if (updateDone) return IPC.send(IPCEvents.CLOSE_APP);\n                                    if (!isBrowsing) {\n                                        this.handleUpdate();\n                                    } else {\n                                        this.setState({isBrowsing: false});\n                                    }\n                                }}\n                            >\n                                {isBrowsing ? \"Continue\" : updateDone ? \"Close\" : \"Update\"}\n                            </button>\n                        </div>\n                    </div>\n                )}\n            </AppContext.Consumer>\n        );\n    }\n}\n'installer-gui/frontend/components/App.tsx'\n:import Preact, {Component} from \"preact\";\nimport InstallPage from \"./actions/install\";\nimport UninstallPage from \"./actions/uninstall\";\nimport UpdatePage from \"./actions/update\";\nimport AppContext from \"./AppContext\";\nimport Category from \"./category\";\nimport Install from \"./icons/install\";\nimport Uninstall from \"./icons/uninstall\";\nimport Update from \"./icons/update\";\nimport {Notifications} from \"./notifications\";\nimport TitleBar from \"./titlebar\";\n\nexport default class App extends Component {\n    state = {navigator: {}}\n\n    handleSetPage({element, title}): void {\n        this.setState({\n            navigator: {element, title}\n        });\n    }\n\n    handleReset(): void {\n        this.setState({navigator: {}});\n    }\n\n    renderHome() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Actions</div>\n                <Category title=\"Install\" icon={Install} note=\"Install kernel to an application you choose.\">\n                    <InstallPage />\n                </Category>\n                <Category title=\"Uninstall\" icon={Uninstall} note=\"Uninstall kernel from an application you choose.\">\n                    <UninstallPage />\n                </Category>\n                <Category title=\"Update\" icon={Update} note=\"Update the kernel.asar to the latest release.\">\n                    <UpdatePage />\n                </Category>\n            </div>\n        );\n    }\n\n    render(_, {navigator}) {\n        const context = {\n            currentPage: navigator,\n            setPage: this.handleSetPage.bind(this),\n            reset: this.handleReset.bind(this)\n        };\n\n        return (\n            <AppContext.Provider value={context}>\n                <div id=\"app-mount\">\n                    <TitleBar />\n                    <div class=\"app\">\n                        {navigator.element ? navigator.element : this.renderHome()}\n                    </div>\n                    <Notifications />\n                </div>\n            </AppContext.Provider>\n        );\n    }\n}\n'installer-gui/frontend/index.ts'\n:import {h, render} from \"preact\";\nimport App from \"./components/App\";\nimport Styles from \"./styles\";\nimport {createElement} from \"./util\";\nimport \"./index.scss\";\n\nStyles.inject();\nconst root = createElement(\"div\", {id: \"root\"});\ndocument.body.appendChild(root);\n\nrender(\n    h(App, {}),\n    root\n);",
        "gt": [
            "'installer-gui/frontend/components/actions/update.tsx'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'"
        ]
    },
    {
        "files": [
            "'docs-starter/app/components/content.tsx'",
            "'docs-starter/app/components/rich-text-view.tsx'",
            "'docs-starter/app/components/heading.tsx'"
        ],
        "content": "'docs-starter/app/components/content.tsx'\n:import { useRef } from 'react';\nimport { ClientOnly } from 'remix-utils/client-only';\n\nimport type { GetPageQuery } from '~/generated/schema.server';\nimport { useMarkdownHeadings } from '~/hooks/useMarkdownHeadings';\n\ntype ContentProps = {\n  page: GetPageQuery['page'];\n  disableToc?: boolean;\n};\n\nimport { RichTextView } from './rich-text-view';\nimport { TableOfContents } from './table-of-contents';\n\nexport function Content({ page, disableToc }: ContentProps) {\n  const contentRef = useRef<HTMLDivElement>(null);\n  const { links } = useMarkdownHeadings({\n    content: page?.content?.markdown as string,\n  });\n\n  const hasLinks = links && links?.length > 0;\n\n  return (\n    <div className=\"flex items-start\">\n      <div ref={contentRef} className=\"w-full max-w-[720px] lg:pr-12\">\n        <RichTextView page={page} />\n      </div>\n\n      {hasLinks && !disableToc && (\n        <ClientOnly>\n          {() => (\n            <TableOfContents\n              contentRef={contentRef}\n              links={links}\n              labelText=\"Table of Contents\"\n              className=\"sticky top-32 hidden lg:block\"\n            />\n          )}\n        </ClientOnly>\n      )}\n    </div>\n  );\n}\n\n'docs-starter/app/components/rich-text-view.tsx'\n:import { RichText } from '@graphcms/rich-text-react-renderer';\nimport { EmbedReferences, EmbedProps } from '@graphcms/rich-text-types';\n\nimport type {\n  GetPageQuery,\n  Page,\n  EmbeddedPageFragment,\n} from '~/generated/schema.server';\nimport { Heading } from './heading';\nimport { Link } from './link';\n\ntype PageProps = GetPageQuery['page'];\n\nexport const RichTextView = ({ page }: { page: PageProps }) => {\n  return (\n    <div className=\"prose prose-indigo max-w-none prose-h1:font-light prose-h1:text-indigo-700\">\n      <h1>{page?.title}</h1>\n      <RichText\n        content={page?.content?.json}\n        references={page?.content?.references as EmbedReferences}\n        renderers={{\n          h1: ({ children }) => <Heading as=\"h1\">{children}</Heading>,\n          h2: ({ children }) => <Heading as=\"h2\">{children}</Heading>,\n          h3: ({ children }) => <Heading as=\"h3\">{children}</Heading>,\n          h4: ({ children }) => <Heading as=\"h4\">{children}</Heading>,\n          h5: ({ children }) => <Heading as=\"h5\">{children}</Heading>,\n          h6: ({ children }) => <Heading as=\"h6\">{children}</Heading>,\n          img: ({ height, width, src, title, altText }) => (\n            <img\n              src={src}\n              alt={altText}\n              width={width}\n              height={height}\n              title={title}\n              loading=\"lazy\"\n              className=\"shadow-image\"\n            />\n          ),\n          embed: {\n            Page: ({ slug, title }: EmbedProps<EmbeddedPageFragment>) => (\n              <Link\n                href={`/${slug}`}\n                className=\"flex items-center justify-between rounded border border-gray-200 bg-white p-3 no-underline shadow-image md:p-6\"\n              >\n                <span>{title}</span>\n                <span>&rarr;</span>\n              </Link>\n            ),\n          },\n        }}\n      />\n    </div>\n  );\n};\n\n'docs-starter/app/components/heading.tsx'\n:import { slugify } from '~/utils/slugify';\n\ntype HeadingProps = {\n  as: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n  children: any;\n};\n\nexport function Heading({ as, children }: HeadingProps) {\n  const Component = `${as}` as keyof JSX.IntrinsicElements;\n\n  let title = children?.props?.parent.children;\n\n  if (typeof title === `object`) {\n    const parsedTitle = title.map((child: any) => child?.text);\n\n    title = parsedTitle.join(``);\n  }\n\n  const slug = slugify(title);\n\n  return (\n    <Component\n      id={slug}\n      className=\"group relative whitespace-pre-wrap\"\n      style={{\n        scrollMarginTop: `80px`,\n      }}\n    >\n      {children}\n      <a\n        href={`#${slug}`}\n        aria-label=\"Anchor\"\n        className=\"anchor ml-[10px] text-[length:inherit] text-gray-500 !no-underline opacity-0 transition-opacity duration-100 after:text-gray-500 after:content-['#'] group-hover:opacity-100\"\n      >\n        <span className=\"sr-only\">Anchor</span>\n      </a>\n    </Component>\n  );\n}\n",
        "gt": [
            "'docs-starter/app/components/heading.tsx'",
            "'docs-starter/app/components/rich-text-view.tsx'",
            "'docs-starter/app/components/content.tsx'"
        ]
    },
    {
        "files": [
            "'angular-16-complete-course/16-angular-module/final/src/app/route.module.ts'",
            "'angular-16-complete-course/16-angular-module/final/src/main.ts'",
            "'angular-16-complete-course/16-angular-module/final/src/app/shared.module.ts'",
            "'angular-16-complete-course/16-angular-module/final/src/app/app.module.ts'",
            "'angular-16-complete-course/16-angular-module/final/src/app/dashboard/dashboard.module.ts'"
        ],
        "content": "'angular-16-complete-course/16-angular-module/final/src/app/route.module.ts'\n:import { NgModule } from '@angular/core';\n\nimport { Routes, RouterModule, PreloadAllModules } from '@angular/router';\n\nimport { LoginComponent } from './login/login.component';\n\nimport { HomeComponent } from './home/home.component';\n\n\n\nconst routes: Routes = [\n\n    { path: '', component: HomeComponent },\n\n    { path: 'dashboard', loadChildren: () => import('./dashboard/dashboard.module').then((mod) => mod.DashBoardModule)},\n\n    { path: 'login', loadChildren: () => import('./login/auth.module').then((mod) => mod.AuthModule)}\n\n  ];\n\n\n\n@NgModule({\n\n  imports: [RouterModule.forRoot(routes, { preloadingStrategy: PreloadAllModules})],\n\n  exports: [RouterModule],\n\n  providers: []\n\n})\n\nexport class RouteModule { }\n\n\n'angular-16-complete-course/16-angular-module/final/src/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-16-complete-course/16-angular-module/final/src/app/shared.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { LoaderComponent } from \"./utility/loader/loader.component\";\n\nimport { FormsModule } from \"@angular/forms\";\n\nimport { SnackbarComponent } from \"./utility/snackbar/snackbar.component\";\n\n\n\n@NgModule({\n\n    declarations: [\n\n        LoaderComponent,\n\n        SnackbarComponent\n\n    ],\n\n    exports: [LoaderComponent, FormsModule, SnackbarComponent],\n\n    imports: [FormsModule]\n\n})\n\nexport class SharedModule{\n\n\n\n}\n'angular-16-complete-course/16-angular-module/final/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { FooterComponent } from './footer/footer.component';\nimport { HttpClientModule } from '@angular/common/http';\nimport { RouteModule } from './route.module';\nimport { HomeComponent } from './home/home.component';\nimport { CoreModule } from './core.module';\nimport { CounterService } from './Services/counter.service';\n\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    HomeComponent,\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    RouteModule,\n    CoreModule\n  ],\n  bootstrap: [AppComponent],\n  providers: [CounterService]\n})\nexport class AppModule { }\n\n'angular-16-complete-course/16-angular-module/final/src/app/dashboard/dashboard.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { DashboardComponent } from \"./dashboard.component\";\n\nimport { CreateTaskComponent } from \"./create-task/create-task.component\";\n\nimport { TaskDetailsComponent } from \"./task-details/task-details.component\";\n\nimport { CommonModule } from \"@angular/common\";\n\nimport { SharedModule } from \"../shared.module\";\n\nimport { OverviewComponent } from './overview/overview.component';\n\nimport { RouterModule } from \"@angular/router\";\n\nimport { StatsComponent } from './stats/stats.component';\n\nimport { canActivate } from './../RouteGuards/authGuard';\n\nimport { DashboardRouteModule } from \"./dashboard-route.module\";\n\n\n\n\n\n\n\n@NgModule({\n\n    declarations: [\n\n        DashboardComponent,\n\n        CreateTaskComponent,\n\n        TaskDetailsComponent,\n\n        OverviewComponent,\n\n        StatsComponent,\n\n    ],\n\n    exports: [\n\n\n\n\n\n\n\n        SharedModule,\n\n        DashboardRouteModule\n\n    ],\n\n    imports: [\n\n        CommonModule,\n\n        SharedModule,\n\n        RouterModule\n\n    ]\n\n})\n\nexport class DashBoardModule{\n\n\n\n}",
        "gt": [
            "'angular-16-complete-course/16-angular-module/final/src/app/shared.module.ts'",
            "'angular-16-complete-course/16-angular-module/final/src/app/dashboard/dashboard.module.ts'",
            "'angular-16-complete-course/16-angular-module/final/src/app/route.module.ts'",
            "'angular-16-complete-course/16-angular-module/final/src/app/app.module.ts'",
            "'angular-16-complete-course/16-angular-module/final/src/main.ts'"
        ]
    },
    {
        "files": [
            "'fps/src/scenes/BaseScene.ts'",
            "'fps/src/scenario.ts'",
            "'fps/src/scenes/TitleScene.ts'"
        ],
        "content": "'fps/src/scenes/BaseScene.ts'\n:export default interface BaseScene {\n    playerState: PlayerState;\n    onComplete(cb: () => void): void;\n    start(): void;\n    destroy(): void;\n}\n'fps/src/scenario.ts'\n:import levels from \"./levels\";\nimport AnimationManager from \"./managers/AnimationManager\";\nimport SoundManager from \"./managers/SoundManager\";\nimport TextureManager from \"./managers/TextureManager\";\n\nimport LevelScene from \"./scenes/LevelScene\";\nimport TitleScene from \"./scenes/TitleScene\";\n\ninterface ScenarioProps {\n  container: HTMLElement;\n  soundManager: SoundManager;\n  textureManager: TextureManager;\n  animationManager: AnimationManager;\n}\n\nexport function createScenario({\n  container,\n  soundManager,\n  textureManager,\n  animationManager,\n}: ScenarioProps) {\n  let levelIndex = 0;\n\n  const playerState: PlayerState = {\n    health: 100,\n  };\n\n  const showFinalScene = () => {\n    const scene = new TitleScene(container, playerState, \"Congratulation!\", [\"You survived a zombie invasion\"]);\n    scene.start();\n  };\n\n  const showFailedScene = () => {\n    const scene = new TitleScene(container, playerState, \"You died\");\n    scene.start();\n  };\n\n  const switchToLevelNextScene = (playerState: PlayerState) => {\n    const level = levels[levelIndex];\n\n    if (!level) {\n      showFinalScene();\n      return;\n    }\n\n    levelIndex++;\n\n    const scene = new LevelScene({\n      level,\n      container,\n      soundManager,\n      textureManager,\n      animationManager,\n      playerState,\n    });\n\n    scene.onComplete(() => {\n      if (level.music) {\n        soundManager.pauseBackground();\n      }\n      scene.destroy();\n      switchToLevelNextScene(scene.playerState);\n    });\n\n    scene.onFailed(() => {\n      if (level.music) {\n        soundManager.pauseBackground();\n      }\n      scene.destroy();\n      showFailedScene();\n    });\n\n    scene.start();\n\n    if (level.music) {\n      soundManager.playBackground(level.music);\n    }\n  };\n\n  const startScene = new TitleScene(container, playerState, \"Shoot or run\",\n    [\n      \"Use WASD and mouse to play\",\n      \"Use M to mute\",\n      \"\",\n      \"Press any key to start\"\n    ]);\n\n  startScene.onComplete(() => {\n    startScene.destroy();\n    switchToLevelNextScene(playerState);\n  });\n\n  startScene.start();\n}\n\n'fps/src/scenes/TitleScene.ts'\n:import ContentView from \"src/views/ContentView\";\nimport BaseScene from \"./BaseScene\";\n\nexport default class TitleScene implements BaseScene {\n    public playerState: PlayerState;\n\n    protected readonly view: ContentView;\n    protected readonly container: HTMLElement;\n    protected onCompleteCallback?: () => void;\n\n    constructor(container: HTMLElement, playerState: PlayerState, title: string, subtitle?: string[]) {\n        this.container = container;\n        this.playerState = playerState;\n        this.view = new ContentView(title, subtitle);\n        this.createListeners();\n    }\n\n    onComplete(cb: () => void): void {\n        this.onCompleteCallback = cb;\n    }\n\n    start() {\n        this.container.appendChild(this.view.canvas.element);\n        this.view.render();\n    }\n\n    destroy() {\n        this.destroyListeners()\n        this.view.canvas.element.remove();\n    }\n\n    createListeners() {\n        document.addEventListener('keydown', this.handleDocumentKeydown);\n        document.addEventListener('pointerdown', this.handleDocumentClick);\n    }\n\n    destroyListeners() {\n        document.removeEventListener('keydown', this.handleDocumentKeydown);\n        document.removeEventListener('pointerdown', this.handleDocumentClick);\n    }\n\n    handleDocumentKeydown = () => {\n        if (this.onCompleteCallback) {\n            window.requestAnimationFrame(this.onCompleteCallback);\n        }\n    }\n\n    handleDocumentClick = () => {\n        if (this.onCompleteCallback) {\n            window.requestAnimationFrame(this.onCompleteCallback);\n        }\n    }\n}",
        "gt": [
            "'fps/src/scenes/BaseScene.ts'",
            "'fps/src/scenes/TitleScene.ts'",
            "'fps/src/scenario.ts'"
        ]
    },
    {
        "files": [
            "'calendar-hack/src/ch/ItemTypes.ts'",
            "'calendar-hack/src/components/DayCell.tsx'",
            "'calendar-hack/src/components/WeekCard.tsx'"
        ],
        "content": "'calendar-hack/src/ch/ItemTypes.ts'\n:export const ItemTypes = {\n  DAY: \"DAY\",\n  DOW: \"DOW\",\n  WEEK: \"WEEK\",\n};\n\n'calendar-hack/src/components/DayCell.tsx'\n:import * as React from \"react\";\nimport { useDrop } from \"react-dnd\";\nimport { ItemTypes } from \"../ch/ItemTypes\";\nimport { WorkoutCard } from \"./WorkoutCard\";\nimport { BlankCard } from \"./BlankCard\";\nimport styled from \"styled-components\";\nimport { Overlay } from \"./Overlay\";\nimport { DayDetails, Units } from \"types/app\";\n\ninterface Props {\n  dayDetails: DayDetails | undefined;\n  date: Date;\n  units: Units;\n  swap: (d1: Date, d2: Date) => void;\n  selected: boolean;\n  hovering: boolean;\n}\n\ntype DropTargetProps = {\n  $isOver: boolean;\n  $canDrop: boolean;\n};\n\nconst DropTarget = styled.div<DropTargetProps>`\n  height: 100%;\n  opacity: ${(props) => (props.$isOver ? 0.5 : 1)};\n`;\n\nexport const DayCell = ({\n  dayDetails,\n  date,\n  units,\n  swap,\n  selected,\n  hovering,\n}: Props) => {\n  function canSwap(d1: Date) {\n    return dayDetails !== undefined;\n  }\n\n  const [{ isOver, canDrop }, drop] = useDrop({\n    accept: ItemTypes.DAY,\n    canDrop: () => canSwap(date),\n    drop: (item: { date: Date }) => {\n      swap(date, item.date);\n      return;\n    },\n    collect: (monitor) => ({\n      isOver: monitor.isOver(),\n      canDrop: monitor.canDrop(),\n      droppedItem: monitor.getItem(),\n    }),\n  });\n\n  return (\n    <div\n      style={{\n        position: \"relative\",\n        width: \"100%\",\n        height: \"100%\",\n      }}\n    >\n      <DropTarget $isOver={isOver} $canDrop={canDrop} ref={drop}>\n        {dayDetails && (\n          <WorkoutCard\n            dayDetails={dayDetails}\n            date={date}\n            units={units}\n            swap={swap}\n          />\n        )}\n        {!dayDetails && <BlankCard date={date} />}\n        {isOver && !canDrop && <Overlay color=\"pink\" />}\n        {isOver && canDrop && <Overlay color=\"lightgreen\" />}\n\n        {dayDetails && selected && <Overlay color=\"pink\" />}\n        {dayDetails && !selected && hovering && <Overlay color=\"lightgreen\" />}\n      </DropTarget>\n    </div>\n  );\n};\n\n'calendar-hack/src/components/WeekCard.tsx'\n:import * as React from \"react\";\nimport { RacePlan, key } from \"../ch/dategrid\";\nimport { format } from \"date-fns\";\nimport { DayCell } from \"./DayCell\";\nimport { Week, DayDetails, Units, dayOfWeek } from \"types/app\";\n\ninterface Props {\n  desc: string;\n  week: Week<DayDetails>;\n  units: Units;\n  racePlan: RacePlan;\n  swap: (d1: Date, d2: Date) => void;\n  selectedDow: dayOfWeek | undefined;\n  hoveringDow: dayOfWeek | undefined;\n  selectedWeek: number | undefined;\n  hoveringWeek: number | undefined;\n}\n\nexport const WeekCard = ({\n  week,\n  units,\n  swap,\n  selectedDow,\n  hoveringDow,\n  selectedWeek,\n  hoveringWeek,\n}: Props) => {\n  return (\n    <div>\n      {week.days.map((d, index) => (\n        <div>\n          <DayCell\n            key={key(d.date)}\n            date={d.date}\n            dayDetails={d.event}\n            units={units}\n            swap={swap}\n            selected={\n              selectedDow === format(d.date, \"EEEE\") ||\n              selectedWeek === week.weekNum\n            }\n            hovering={\n              hoveringDow === format(d.date, \"EEEE\") ||\n              hoveringWeek === week.weekNum\n            }\n          />\n        </div>\n      ))}\n    </div>\n  );\n};\n",
        "gt": [
            "'calendar-hack/src/ch/ItemTypes.ts'",
            "'calendar-hack/src/components/DayCell.tsx'",
            "'calendar-hack/src/components/WeekCard.tsx'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-list.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-edit/shopping-edit.component.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { Routes, RouterModule, PreloadAllModules } from \"@angular/router\";\n\n\n\nconst appRoutes: Routes = [\n\n    { path: '', redirectTo: '/recipes', pathMatch: 'full'},\n\n    { path: 'recipes', loadChildren: () => import('./recipes/recipes.module').then(m => m.RecipesModule) },\n\n    { path: 'shopping-list', loadChildren: () => import('./shopping-list/shopping-list.module').then(m => m.ShoppingListModule) },\n\n    { path: 'auth', loadChildren: () => import('./auth/auth.module').then(m => m.AuthModule) }\n\n];\n\n\n\n@NgModule({\n\n    imports: [RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules })],\n\n    exports: [RouterModule]\n\n})\n\nexport class AppRoutingModule {\n\n\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-list.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { FormsModule } from \"@angular/forms\";\n\nimport { RouterModule } from \"@angular/router\";\n\nimport { SharedModule } from \"../shared/shared.module\";\n\n\n\nimport { ShoppingEditComponent } from \"./shopping-edit/shopping-edit.component\";\n\nimport { ShoppingListComponent } from \"./shopping-list.component\";\n\n\n\n@NgModule({\n\n  declarations: [\n\n    ShoppingListComponent,\n\n    ShoppingEditComponent,\n\n  ],\n\n  imports: [\n\n    FormsModule,\n\n    RouterModule.forChild([\n\n      { path: '', component: ShoppingListComponent },\n\n    ]),\n\n    SharedModule\n\n  ],\n\n})\n\nexport class ShoppingListModule { }\n\n\n'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-edit/shopping-edit.component.ts'\n:import { Component, OnDestroy, OnInit, ViewChild } from '@angular/core';\nimport { NgForm } from '@angular/forms';\n\nimport { Subscription } from 'rxjs-compat';\n\nimport { Ingredient } from 'src/app/shared/ingredient.model';\nimport { Store } from '@ngrx/store';\nimport * as ShoppingListActions from '../store/shopping-list.actions';\nimport * as fromApp from '../../store/app.reducer';\n\n@Component({\n  selector: 'app-shopping-edit',\n  templateUrl: './shopping-edit.component.html',\n  styleUrls: ['./shopping-edit.component.css']\n})\nexport class ShoppingEditComponent implements OnInit, OnDestroy {\n\n  @ViewChild('f', { static: false }) shoppingListForm: NgForm;\n  subscription: Subscription;\n  editMode: boolean = false;\n  editedItem: Ingredient;\n\n  constructor(\n    private store: Store<fromApp.AppState>\n  ) { }\n\n  ngOnInit(): void {\n    this.subscription = this.store.select('shoppingList')\n      .subscribe(stateData => {\n        if (stateData.editedIngredientIndex > -1) {\n          this.editMode = true;\n          this.editedItem = stateData.editedIngredient;\n          this.shoppingListForm.setValue({\n            name: this.editedItem.name,\n            amount: this.editedItem.amount\n          });\n        } else {\n          this.editMode = false;\n        }\n      }\n    );\n  }\n\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n    this.store.dispatch(new ShoppingListActions.StopEdit());\n  }\n\n  onClear(): void {\n    this.shoppingListForm.reset();\n    this.editMode = false;\n    this.store.dispatch(new ShoppingListActions.StopEdit());\n  }\n\n  onDelete(): void {\n    this.store.dispatch(new ShoppingListActions.DeleteIngredient());\n    this.onClear();\n  }\n\n  onSubmit(form: NgForm): void {\n    const value = form.value;\n    const newIngredient = new Ingredient(value.name, value.amount);\n\n    if (this.editMode) {\n      this.store.dispatch(new ShoppingListActions.UpdateIngredient(newIngredient));\n    } else {\n      this.store.dispatch(new ShoppingListActions.AddIngredient(newIngredient));\n    }\n\n    this.editMode = false;\n    form.reset();\n  }\n\n}\n\n'angular-the-complete-guide-2023/project/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { CoreModule } from './core.module';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\n\nimport * as fromApp from './store/app.reducer';\nimport { AuthEffects } from './auth/store/auth.effects';\nimport { environment } from 'src/environments/environment';\nimport { RecipeEffects } from './recipes/store/recipe.effects';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    SharedModule,\n    CoreModule,\n    StoreModule.forRoot(fromApp.appReducer),\n    EffectsModule.forRoot([AuthEffects, RecipeEffects]),\n    StoreDevtoolsModule.instrument({\n      logOnly: environment.production\n    }),\n    StoreRouterConnectingModule.forRoot()\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n",
        "gt": [
            "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-edit/shopping-edit.component.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-list.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/check-in-data-access.module.ts'",
            "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.effects.ts'",
            "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.actions.ts'",
            "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.models.ts'"
        ],
        "content": "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/check-in-data-access.module.ts'\n:import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreModule } from '@ngrx/store';\n\nimport { CheckInEffects } from './+state/check-in.effects';\nimport * as fromCheckIn from './+state/check-in.reducer';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    StoreModule.forFeature(\n      fromCheckIn.CHECK_IN_FEATURE_KEY,\n      fromCheckIn.reducer\n    ),\n    EffectsModule.forFeature([CheckInEffects]),\n  ],\n})\nexport class CheckInDataAccessModule {}\n\n'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.effects.ts'\n:import { Injectable } from '@angular/core';\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\nimport { fetch } from '@nrwl/angular';\n\nimport * as CheckInActions from './check-in.actions';\n\n@Injectable()\nexport class CheckInEffects {\n  init$ = createEffect(() =>\n    this.actions$.pipe(\n      ofType(CheckInActions.init),\n      fetch({\n        run: () => {\n\n          return CheckInActions.loadCheckInSuccess({ checkIn: [] });\n        },\n\n        onError: (_action, error) => {\n          console.error('Error', error);\n          return CheckInActions.loadCheckInFailure({ error });\n        },\n      })\n    )\n  );\n\n  constructor(private actions$: Actions) {}\n}\n\n'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.actions.ts'\n:import { createAction, props } from '@ngrx/store';\n\nimport { CheckInEntity } from './check-in.models';\n\nexport const init = createAction('[CheckIn Page] Init');\n\nexport const loadCheckInSuccess = createAction(\n  '[CheckIn/API] Load CheckIn Success',\n  props<{ checkIn: CheckInEntity[] }>()\n);\n\nexport const loadCheckInFailure = createAction(\n  '[CheckIn/API] Load CheckIn Failure',\n  props<{ error: string }>()\n);\n\n'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.models.ts'\n:\nexport interface CheckInEntity {\n  id: string | number;\n}\n",
        "gt": [
            "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.models.ts'",
            "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.actions.ts'",
            "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/+state/check-in.effects.ts'",
            "'nx-nrwl-airlines-angular/libs/check-in/data-access/src/lib/check-in-data-access.module.ts'"
        ]
    },
    {
        "files": [
            "'instaclone/src/pages/login/login.ts'",
            "'instaclone/src/pages/login/login.module.ts'",
            "'instaclone/src/pages/modal-post/modal-post.ts'",
            "'instaclone/src/pages/profile/profile.ts'",
            "'instaclone/src/pages/tabs/tabs.ts'"
        ],
        "content": "'instaclone/src/pages/login/login.ts'\n:import { Component } from '@angular/core';\nimport { IonicPage, AlertController, LoadingController, NavController, NavParams, App } from 'ionic-angular';\nimport { TabsPage } from \"../tabs/tabs\";\n\n\n@IonicPage()\n@Component({\n  selector: 'page-login',\n  templateUrl: 'login.html',\n})\nexport class LoginPage {\n  public loginForm: any;\n\n  constructor(\n    public loadingCtrl: LoadingController,\n    public app: App,\n    public navCtrl: NavController,\n    public navParams: NavParams\n  ) { }\n\n  login() {\n    const loading = this.loadingCtrl.create({\n      duration: 500\n    });\n\n    loading.onDidDismiss(() => {\n      this.navCtrl.setRoot(TabsPage);\n    });\n\n    loading.present();\n\n  }\n\n  goToSignup() {\n\n  }\n\n\n\n\n\n  colors = new Array(\n    [62, 35, 255],\n    [60, 255, 60],\n    [255, 35, 98],\n    [45, 175, 230],\n    [255, 0, 255],\n    [255, 128, 0]);\n\n  step = 0;\n\n\n  colorIndices = [0, 1, 2, 3];\n\n\n  gradientSpeed = 0.00005;\n  gradient = '';\n\n  updateGradient() {\n\n    const c00 = this.colors[this.colorIndices[0]];\n    const c01 = this.colors[this.colorIndices[1]];\n    const c10 = this.colors[this.colorIndices[2]];\n    const c11 = this.colors[this.colorIndices[3]];\n\n    const istep = 1 - this.step;\n    const r1 = Math.round(istep * c00[0] + this.step * c01[0]);\n    const g1 = Math.round(istep * c00[1] + this.step * c01[1]);\n    const b1 = Math.round(istep * c00[2] + this.step * c01[2]);\n    const color1 = 'rgb(' + r1 + ',' + g1 + ',' + b1 + ')';\n\n    const r2 = Math.round(istep * c10[0] + this.step * c11[0]);\n    const g2 = Math.round(istep * c10[1] + this.step * c11[1]);\n    const b2 = Math.round(istep * c10[2] + this.step * c11[2]);\n    const color2 = 'rgb(' + r2 + ',' + g2 + ',' + b2 + ')';\n\n    this.gradient = `-webkit-gradient(linear, left top, right bottom, from(${color1}), to(${color2}))`;\n    this.step += this.gradientSpeed;\n    if (this.step >= 1) {\n      this.step %= 1;\n      this.colorIndices[0] = this.colorIndices[1];\n      this.colorIndices[2] = this.colorIndices[3];\n\n\n\n      this.colorIndices[1] =\n        (this.colorIndices[1] + Math.floor(1 + Math.random() * (this.colors.length - 1)))\n        % this.colors.length;\n\n      this.colorIndices[3] =\n        (this.colorIndices[3] + Math.floor(1 + Math.random() * (this.colors.length - 1)))\n        % this.colors.length;\n\n    }\n\n    setInterval(() => { this.updateGradient(); }, 40);\n  }\n}\n'instaclone/src/pages/login/login.module.ts'\n:import { NgModule } from '@angular/core';\nimport { IonicPageModule } from 'ionic-angular';\nimport { LoginPage } from './login';\n\n@NgModule({\n  declarations: [\n    LoginPage,\n  ],\n  imports: [\n    IonicPageModule.forChild(LoginPage),\n  ],\n  exports: [\n    LoginPage\n  ]\n})\nexport class LoginPageModule {}\n\n'instaclone/src/pages/modal-post/modal-post.ts'\n:import { Component } from '@angular/core';\nimport { ModalController, ViewController, NavParams } from 'ionic-angular';\n\n@Component({\n  selector: 'page-modalpost',\n  templateUrl: 'modal-post.html',\n})\nexport class ModalPost {\n\n  public like_btn = {\n    color: 'black',\n    icon_name: 'heart-outline'\n  };\n\n  public modal_data = {};\n\n  constructor(public viewCtrl: ViewController, public navParams: NavParams, public modalCtrl: ModalController) {\n    this.modal_data = {\n      id: this.navParams.get('user_id'),\n      username: this.navParams.get('username'),\n      profile_img: this.navParams.get('profile_img'),\n      post_img: this.navParams.get('post_img')\n    };\n  }\n\n  ionViewDidLoad() {}\n\n  dismiss() {\n    this.viewCtrl.dismiss();\n  }\n\n  likeButton() {\n    if(this.like_btn.icon_name === 'heart-outline') {\n      this.like_btn.icon_name = 'heart';\n      this.like_btn.color = 'danger';\n    }\n    else {\n      this.like_btn.icon_name = 'heart-outline';\n      this.like_btn.color = 'black';\n    }\n  }\n\n  goUserProfile(userId: number) {\n    console.log(\"User id: \" + userId);\n  }\n\n}\n'instaclone/src/pages/profile/profile.ts'\n:import { Component } from '@angular/core';\nimport { IonicPage, NavController, NavParams, ModalController } from 'ionic-angular';\n\nimport { ModalPost } from '../modal-post/modal-post';\nimport { EditProfile } from '../edit-profile/edit-profile';\nimport { Options } from '../options/options';\nimport { TaggedProfile } from '../tagged-profile/tagged-profile';\nimport { SavedProfile } from '../saved-profile/saved-profile';\n\n@IonicPage()\n@Component({\n  selector: 'page-profile',\n  templateUrl: 'profile.html',\n})\nexport class Profile {\n\n  public profile_segment:string;\n\n\n  public images = [\n    {\n      id: 1,\n      username: 'candelibas',\n      profile_img: 'https:\n      post_img: 'https:\n    },\n    {\n      id: 2,\n      username: 'candelibas',\n      profile_img: 'https:\n      post_img: 'https:\n    },\n    {\n      id: 3,\n      username: 'candelibas',\n      profile_img: 'https:\n      post_img: 'https:\n    },\n    {\n      id: 4,\n      username: 'candelibas',\n      profile_img: 'https:\n      post_img: 'https:\n    },\n    {\n      id: 5,\n      username: 'candelibas',\n      profile_img: 'https:\n      post_img: 'https:\n    },\n    {\n      id: 6,\n      username: 'candelibas',\n      profile_img: 'https:\n      post_img: 'https:\n    }\n  ];\n\n  constructor(public navCtrl: NavController, public navParams: NavParams, public modalCtrl: ModalController) {\n  }\n\n\n  ionViewWillEnter() {\n    this.profile_segment = 'grid';\n  }\n\n  goEditProfile() {\n\n    let modal = this.modalCtrl.create(EditProfile);\n    modal.present();\n  }\n\n  goOptions() {\n    this.navCtrl.push(Options, {});\n  }\n\n  goTaggedProfile() {\n    this.navCtrl.push(TaggedProfile);\n  }\n\n  goSavedProfile() {\n    this.navCtrl.push(SavedProfile);\n  }\n\n\n  pressPhoto(user_id: number, username: string, profile_img: string, post_img: string) {\n    this.presentModal(user_id, username, profile_img, post_img);\n  }\n\n\n  presentModal(user_id: number, username: string, profile_img: string, post_img: string) {\n    let modal = this.modalCtrl.create(ModalPost,\n    {\n      user_id: user_id,\n      username: username,\n      profile_img: profile_img,\n      post_img: post_img\n    },\n    { showBackdrop: true, enableBackdropDismiss: true });\n    modal.present();\n  }\n\n}\n\n'instaclone/src/pages/tabs/tabs.ts'\n:import { Component } from '@angular/core';\n\nimport { Home } from '../home/home';\nimport { Search } from '../search/search';\nimport { Notifications } from '../notifications/notifications';\nimport { Profile } from '../profile/profile';\n\nimport { Camera, CameraOptions } from '@ionic-native/camera';\n\n@Component({\n  templateUrl: 'tabs.html'\n})\nexport class TabsPage {\n\n  tab1Root = Home;\n  tab2Root = Search;\n\n  tab4Root = Notifications;\n  tab5Root = Profile;\n\n  constructor(private camera: Camera) {\n\n  }\n\n  openCamera() {\n    const options: CameraOptions = {\n      quality: 100,\n      destinationType: this.camera.DestinationType.DATA_URL,\n      encodingType: this.camera.EncodingType.JPEG,\n      mediaType: this.camera.MediaType.PICTURE\n    }\n\n    this.camera.getPicture(options).then((imageData) => {\n\n\n      let base64Image = 'data:image/jpeg;base64,' + imageData;\n    }, (err) => {\n\n    });\n  }\n}\n",
        "gt": [
            "'instaclone/src/pages/modal-post/modal-post.ts'",
            "'instaclone/src/pages/profile/profile.ts'",
            "'instaclone/src/pages/tabs/tabs.ts'",
            "'instaclone/src/pages/login/login.ts'",
            "'instaclone/src/pages/login/login.module.ts'"
        ]
    },
    {
        "files": [
            "'angular-reactive-authentication/src/environments/environment.ts'",
            "'angular-reactive-authentication/src/app/app.reducers.ts'",
            "'angular-reactive-authentication/src/app/users/sign-up/sign-up.component.spec.ts'"
        ],
        "content": "'angular-reactive-authentication/src/environments/environment.ts'\n:\n\n\n\n\nexport const environment = {\n  production: false\n};\n\n'angular-reactive-authentication/src/app/app.reducers.ts'\n:\nimport { createSelector } from \"reselect\";\n\n\nimport { ActionReducer, combineReducers } from \"@ngrx/store\";\nimport { compose } from \"@ngrx/core/compose\";\nimport { routerReducer, RouterState } from \"@ngrx/router-store\";\nimport { storeFreeze } from \"ngrx-store-freeze\";\n\n\nimport { environment } from \"../environments/environment\";\n\n\nimport * as users from \"./users/users.reducers\";\n\n\nexport interface State {\n  router: RouterState;\n  users: users.State;\n}\n\n\nconst reducers = {\n  router: routerReducer,\n  users: users.reducer\n};\n\n\nconst developmentReducer: ActionReducer<State> = compose(storeFreeze, combineReducers)(reducers);\n\n\nconst productionReducer: ActionReducer<State> = combineReducers(reducers);\n\n\nexport function reducer(state: any, action: any) {\n  if (environment.production) {\n    return productionReducer(state, action);\n  } else {\n    return developmentReducer(state, action);\n  }\n}\n\n\n\n\nexport const getUsersState = (state: State) => state.users;\n\n\nexport const getAuthenticatedUser = createSelector(getUsersState, users.getAuthenticatedUser);\n\n\nexport const getAuthenticationError = createSelector(getUsersState, users.getAuthenticationError);\n\n\nexport const isAuthenticated = createSelector(getUsersState, users.isAuthenticated);\n\n\nexport const isAuthenticatedLoaded = createSelector(getUsersState, users.isAuthenticatedLoaded);\n\n\nexport const isAuthenticationLoading = createSelector(getUsersState, users.isLoading);\n\n\nexport const getSignOutError = createSelector(getUsersState, users.getSignOutError);\n\n\nexport const getSignUpError = createSelector(getUsersState, users.getSignUpError);\n\n'angular-reactive-authentication/src/app/users/sign-up/sign-up.component.spec.ts'\n:\nimport { DebugElement, CUSTOM_ELEMENTS_SCHEMA } from \"@angular/core\";\nimport { ComponentFixture, TestBed, async } from \"@angular/core/testing\";\nimport { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule } from \"@angular/forms\";\nimport { MaterialModule } from \"@angular/material\";\nimport { ActivatedRoute } from \"@angular/router\";\nimport { By } from \"@angular/platform-browser\";\n\n\nimport { Observable } from \"rxjs/Observable\";\n\n\nimport { Store, StoreModule } from \"@ngrx/store\";\nimport { go } from \"@ngrx/router-store\";\n\n\nimport { reducer } from \"../../app.reducers\";\n\n\nimport { GroupService } from \"../../core/services/group.service\";\nimport { MockGroupService } from \"../../../testing/mock.group.service\";\nimport { USER } from \"../../../testing/mock.user.service\";\n\n\nimport { User } from \"../../models/user\";\n\n\nimport { SignUpComponent } from \"./sign-up.component\";\n\ndescribe(\"Component: Signup\", () => {\n  let component: SignUpComponent;\n  let fixture: ComponentFixture<SignUpComponent>;\n  let page: Page;\n  let user: User = new User();\n\n  beforeEach(() => {\n    user = USER;\n  });\n\n  beforeEach(async(() => {\n\n    TestBed.configureTestingModule({\n      imports: [\n        FormsModule,\n        MaterialModule,\n        ReactiveFormsModule,\n        StoreModule.provideStore(reducer)\n      ],\n      declarations: [\n        SignUpComponent\n      ],\n      providers: [\n        {\n          provide: ActivatedRoute,\n          useValue: {\n            queryParams: Observable.of({})\n          }\n        },\n        { provide: GroupService, useClass: MockGroupService }\n      ],\n      schemas: [\n        CUSTOM_ELEMENTS_SCHEMA\n      ]\n    })\n    .compileComponents();\n\n\n    fixture = TestBed.createComponent(SignUpComponent);\n\n\n    component = fixture.componentInstance;\n  }));\n\n  beforeEach(() => {\n\n    page = new Page(component, fixture);\n    fixture.whenStable().then(() => {\n      page.addPageElements();\n    });\n  });\n\n  it(\"should create a FormGroup comprised of FormControls\", () => {\n    fixture.detectChanges();\n    expect(component.signupForm instanceof FormGroup).toBe(true);\n  });\n\n  it(\"should authenticate\", () => {\n    fixture.detectChanges();\n\n\n    component.signupForm.controls[\"firstName\"].setValue(user.firstName);\n    component.signupForm.controls[\"lastName\"].setValue(user.lastName);\n    component.signupForm.controls[\"email\"].setValue(user.email);\n    component.signupForm.controls[\"password\"].setValue(user.password);\n\n\n    component.submit();\n\n\n    expect(page.navigateSpy.calls.any()).toBe(true, \"Store.dispatch not called\");\n  });\n});\n\n\nclass Page {\n\n  public emailInput: HTMLInputElement;\n  public firstNameInput: HTMLInputElement;\n  public lastNameInput: HTMLInputElement;\n  public navigateSpy: jasmine.Spy;\n  public passwordInput: HTMLInputElement;\n\n  constructor(private component: SignUpComponent, private fixture: ComponentFixture<SignUpComponent>) {\n\n    const injector = fixture.debugElement.injector;\n    const store = injector.get(Store);\n\n\n    this.navigateSpy  = spyOn(store, \"dispatch\");\n  }\n\n  public addPageElements() {\n    const firstNameInputSelector = \"md-input-container input[formcontrolname=\\\"firstName\\\"]\";\n    this.firstNameInput = this.fixture.debugElement.query(By.css(firstNameInputSelector)).nativeElement;\n\n    const lastNameInputSelector = \"md-input-container input[formcontrolname=\\\"lastName\\\"]\";\n    this.lastNameInput = this.fixture.debugElement.query(By.css(lastNameInputSelector)).nativeElement;\n\n    const emailInputSelector = \"md-input-container input[formcontrolname=\\\"email\\\"]\";\n    this.emailInput = this.fixture.debugElement.query(By.css(emailInputSelector)).nativeElement;\n\n    const passwordInputSelector = \"md-input-container input[formcontrolname=\\\"password\\\"]\";\n    this.passwordInput = this.fixture.debugElement.query(By.css(passwordInputSelector)).nativeElement;\n  }\n}\n",
        "gt": [
            "'angular-reactive-authentication/src/environments/environment.ts'",
            "'angular-reactive-authentication/src/app/app.reducers.ts'",
            "'angular-reactive-authentication/src/app/users/sign-up/sign-up.component.spec.ts'"
        ]
    },
    {
        "files": [
            "'stromjs/src/functions/demux.ts'",
            "'stromjs/src/helpers.ts'",
            "'stromjs/src/functions/index.ts'"
        ],
        "content": "'stromjs/src/functions/demux.ts'\n:import { DuplexOptions, Duplex, Transform, Writable } from \"stream\";\n\nimport { isReadable } from \"../helpers\";\n\nexport interface DemuxOptions extends DuplexOptions {\n    remultiplex?: boolean;\n}\n\nexport function demux(\n    pipelineConstructor: (\n        destKey?: string,\n        chunk?: any,\n    ) => Writable | Writable[],\n    demuxBy: string | ((chunk: any) => string),\n    options?: DemuxOptions,\n): Duplex {\n    return new Demux(pipelineConstructor, demuxBy, options);\n}\n\nclass Demux extends Duplex {\n    private streamsByKey: {\n        [key: string]: Writable[];\n    };\n    private demuxer: (chunk: any) => string;\n    private pipelineConstructor: (destKey?: string, chunk?: any) => Writable[];\n    private remultiplex: boolean;\n    private transform: Transform;\n    constructor(\n        pipelineConstructor: (\n            destKey?: string,\n            chunk?: any,\n        ) => Writable | Writable[],\n        demuxBy: string | ((chunk: any) => string),\n        options: DemuxOptions = {},\n    ) {\n        super(options);\n        this.demuxer =\n            typeof demuxBy === \"string\" ? (chunk) => chunk[demuxBy] : demuxBy;\n        this.pipelineConstructor = (destKey: string, chunk?: any) => {\n            const pipeline = pipelineConstructor(destKey, chunk);\n            return Array.isArray(pipeline) ? pipeline : [pipeline];\n        };\n        this.remultiplex =\n            options.remultiplex === undefined ? true : options.remultiplex;\n        this.streamsByKey = {};\n        this.transform = new Transform({\n            ...options,\n            transform: (d, _, cb) => {\n                this.push(d);\n                cb(null);\n            },\n        });\n\n        this.on(\"unpipe\", () => this._flush());\n    }\n\n\n    public _read(_size: number) {}\n\n    public async _write(chunk: any, encoding: any, cb: any) {\n        const destKey = this.demuxer(chunk);\n        if (this.streamsByKey[destKey] === undefined) {\n            const newPipelines = this.pipelineConstructor(destKey, chunk);\n            this.streamsByKey[destKey] = newPipelines;\n\n            newPipelines.forEach((newPipeline) => {\n                if (this.remultiplex && isReadable(newPipeline)) {\n                    newPipeline.pipe(this.transform);\n                } else if (this.remultiplex) {\n                    console.error(\n                        `Pipeline construct for ${destKey} does not implement readable interface`,\n                    );\n                }\n            });\n        }\n        const pipelines = this.streamsByKey[destKey];\n        const pendingDrains: Promise<any>[] = [];\n\n        pipelines.forEach((pipeline) => {\n            if (!pipeline.write(chunk, encoding)) {\n                pendingDrains.push(\n                    new Promise((resolve) => {\n                        pipeline.once(\"drain\", () => {\n                            resolve(null);\n                        });\n                    }),\n                );\n            }\n        });\n        await Promise.all(pendingDrains);\n        cb();\n    }\n\n    public _flush() {\n        const pipelines: Writable[] = Array.prototype.concat.apply(\n            [],\n            Object.values(this.streamsByKey),\n        );\n        const flushPromises: Promise<void>[] = [];\n        pipelines.forEach((pipeline) => {\n            flushPromises.push(\n                new Promise((resolve) => {\n                    pipeline.once(\"end\", () => {\n                        resolve();\n                    });\n                }),\n            );\n        });\n        pipelines.forEach((pipeline) => pipeline.end());\n        Promise.all(flushPromises).then(() => {\n            this.push(null);\n            this.emit(\"end\");\n        });\n    }\n\n    public _destroy(error: any, cb: (error?: any) => void) {\n        const pipelines: Writable[] = [].concat.apply(\n            [],\n            Object.values(this.streamsByKey),\n        );\n        pipelines.forEach((p) => (p as any).destroy());\n        cb(error);\n    }\n}\n\n'stromjs/src/helpers.ts'\n:import { Readable, Stream, Writable } from \"stream\";\n\nexport async function sleep(time: number): Promise<{} | null> {\n    return time > 0\n        ? new Promise((resolve) => setTimeout(resolve, time))\n        : null;\n}\n\nexport function isReadable(stream: Stream): stream is Readable {\n    return (\n        (stream as Readable).pipe !== undefined &&\n        (stream as Readable).readable === true\n    );\n}\n\nexport function isWritable(stream: Stream): stream is Writable {\n    return (\n        (stream as Writable).write !== undefined &&\n        (stream as Writable).writable === true\n    );\n}\n\n'stromjs/src/functions/index.ts'\n:import { TransformOptions } from \"stream\";\nimport { accumulator, accumulatorBy } from \"./accumulator\";\nimport { batch } from \"./batch\";\nimport { child } from \"./child\";\nimport { collect } from \"./collect\";\nimport { concat } from \"./concat\";\nimport { duplex } from \"./duplex\";\nimport { filter } from \"./filter\";\nimport { flatMap } from \"./flatMap\";\nimport { fromArray } from \"./fromArray\";\nimport { join } from \"./join\";\nimport { last } from \"./last\";\nimport { map } from \"./map\";\nimport { merge } from \"./merge\";\nimport { parallelMap } from \"./parallelMap\";\nimport { parse } from \"./parse\";\nimport { rate } from \"./rate\";\nimport { reduce } from \"./reduce\";\nimport { replace } from \"./replace\";\nimport { split } from \"./split\";\nimport { stringify } from \"./stringify\";\nimport { unbatch } from \"./unbatch\";\nimport { compose } from \"./compose\";\nimport { demux } from \"./demux\";\n\nexport function strom(defaultOptions: TransformOptions = { objectMode: true }) {\n    function withDefaultOptions<T extends any[], R>(\n        n: number,\n        fn: (...args: T) => R,\n    ): (...args: T) => R {\n        return (...args) => {\n            const options = {\n                ...defaultOptions,\n                ...((args[n] || {}) as TransformOptions | {}),\n            };\n            const provided = args.slice(0, n);\n            const nextArgs = [\n                ...provided,\n                ...Array(n - provided.length).fill(undefined),\n                options,\n            ] as T;\n            return fn(...nextArgs) as R;\n        };\n    }\n\n    return {\n\n        fromArray,\n\n\n        map: withDefaultOptions(1, map),\n\n\n        flatMap: withDefaultOptions(1, flatMap),\n\n\n        filter: withDefaultOptions(1, filter),\n\n\n        reduce: withDefaultOptions(2, reduce),\n\n\n        split,\n\n\n        join: withDefaultOptions(1, join),\n\n\n        replace,\n\n\n        parse,\n\n\n        stringify,\n\n\n        collect: withDefaultOptions(0, collect),\n\n\n        concat,\n\n\n        merge,\n\n\n        duplex,\n\n\n        child,\n\n\n        last,\n\n\n        batch: withDefaultOptions(2, batch),\n\n\n        unbatch: withDefaultOptions(0, unbatch),\n\n\n        rate: withDefaultOptions(2, rate),\n\n\n        parallelMap: withDefaultOptions(3, parallelMap),\n\n\n        accumulator: withDefaultOptions(3, accumulator),\n\n\n        accumulatorBy: withDefaultOptions(2, accumulatorBy),\n\n\n        compose: withDefaultOptions(2, compose),\n\n\n        demux: withDefaultOptions(2, demux),\n\n\n        instance: strom,\n    };\n}\n",
        "gt": [
            "'stromjs/src/helpers.ts'",
            "'stromjs/src/functions/demux.ts'",
            "'stromjs/src/functions/index.ts'"
        ]
    },
    {
        "files": [
            "'petfinder-js-sdk/tests/api/animalData.test.ts'",
            "'petfinder-js-sdk/src/api/animal.ts'",
            "'petfinder-js-sdk/src/main.ts'"
        ],
        "content": "'petfinder-js-sdk/tests/api/animalData.test.ts'\n:import axios from \"axios\";\nimport MockAdapter from \"axios-mock-adapter\";\n\nimport { AnimalData } from \"../../src/api/animalData\";\nimport { Client } from \"../../src/main\";\n\nit(\"Creates animal data client\", () => {\n    const client = new Client({apiKey: \"foo\", secret: \"bar\"});\n    const animal = new AnimalData(client);\n\n    expect(animal).toBeInstanceOf(AnimalData);\n    expect(client.animalData).toBeInstanceOf(AnimalData);\n});\n\nit(\"Can get animal types\", async () => {\n    const mock = new MockAdapter(axios);\n    const client = new AnimalData(new Client({apiKey: \"foo\", secret: \"bar\", token: \"test\"}));\n\n    mock.onGet(\"/types\").reply(200, {\n        success: true,\n    });\n\n    const response = await client.types();\n    expect(response.data.success).toEqual(true);\n});\n\nit(\"Can get single animal type\", async () => {\n    const mock = new MockAdapter(axios);\n    const client = new AnimalData(new Client({apiKey: \"foo\", secret: \"bar\", token: \"test\"}));\n\n    mock.onGet(\"/types/Dog\").reply(200, {\n        success: true,\n    });\n\n    const response = await client.type(\"Dog\");\n    expect(response.data.success).toEqual(true);\n});\n\nit(\"Can get animal breeds\", async () => {\n    const mock = new MockAdapter(axios);\n    const client = new AnimalData(new Client({apiKey: \"foo\", secret: \"bar\", token: \"test\"}));\n\n    mock.onGet(\"/types/Dog/breeds\").reply(200, {\n        success: true,\n    });\n\n    const response = await client.breeds(\"Dog\");\n    expect(response.data.success).toEqual(true);\n});\n\n'petfinder-js-sdk/src/api/animal.ts'\n:import { AxiosResponse } from \"axios\";\n\nimport { ApiClient } from \"./client\";\n\nexport class Animal extends ApiClient {\n    public async search(params: object = {}): Promise<AxiosResponse> {\n        await this.ensureAuthenticated();\n        return this.http.get(\"/animals\", {\n            params,\n        });\n    }\n\n    public async show(id: number): Promise<AxiosResponse> {\n        await this.ensureAuthenticated();\n        return this.http.get(`/animals/${id}`);\n    }\n}\n\n'petfinder-js-sdk/src/main.ts'\n:import axios, { AxiosError, AxiosInstance, AxiosResponse } from \"axios\";\n\nimport { Animal } from \"./api/animal\";\nimport { AnimalData } from \"./api/animalData\";\nimport { Organization } from \"./api/organization\";\nimport { ProblemDetailsError } from \"./error\";\n\ninterface ClientConfig {\n    apiKey: string;\n    secret: string;\n    token?: string;\n    baseUrl?: string;\n}\n\nexport class Client {\n    public http: AxiosInstance;\n    private config: ClientConfig;\n\n    constructor(config: ClientConfig) {\n        this.config = config;\n        this.http = axios.create({\n            baseURL: config.baseUrl || \"https:\n            headers: {\"x-api-sdk\": \"petfinder-js-sdk/v1.0 (https:\n        });\n\n        this.http.interceptors.response.use((response: AxiosResponse) => {\n            return response;\n        }, (error: AxiosError) => {\n            if (error.response && this.isProblemDetailsResponse(error.response)) {\n                return Promise.reject(new ProblemDetailsError(error.request, error.response));\n            }\n\n            return Promise.reject(error);\n        });\n    }\n\n    get animalData(): AnimalData {\n        return new AnimalData(this);\n    }\n\n    get animal(): Animal {\n        return new Animal(this);\n    }\n\n    get organization(): Organization {\n        return new Organization(this);\n    }\n\n    public async authenticate(token?: string): Promise<void | AxiosResponse> {\n        let response;\n        let accessToken = token || this.config.token;\n\n        if (!accessToken) {\n            response = await this.http.post(\"/oauth2/token\", {\n\n                client_id: this.config.apiKey,\n\n                client_secret: this.config.secret,\n\n                grant_type: \"client_credentials\",\n            });\n            accessToken = response.data.access_token;\n        }\n\n        this.config.token = accessToken;\n        this.http.defaults.headers.common.Authorization = `Bearer ${accessToken}`;\n\n        return response;\n    }\n\n    private isProblemDetailsResponse(response: AxiosResponse): boolean {\n        const headers = response.headers || {};\n        const contentType = headers[\"content-type\"] || \"\";\n        return contentType.includes(\"application/problem+json\");\n    }\n}\n",
        "gt": [
            "'petfinder-js-sdk/src/api/animal.ts'",
            "'petfinder-js-sdk/src/main.ts'",
            "'petfinder-js-sdk/tests/api/animalData.test.ts'"
        ]
    },
    {
        "files": [
            "'healthchecks-with-nestjs-app/apps/api/src/app/health/health.module.ts'",
            "'healthchecks-with-nestjs-app/apps/api/src/app/app.module.ts'",
            "'healthchecks-with-nestjs-app/apps/api/src/main.ts'",
            "'healthchecks-with-nestjs-app/apps/api/src/app/health/health.service.ts'",
            "'healthchecks-with-nestjs-app/apps/api/src/app/health/models/any-other-health.indicator.ts'"
        ],
        "content": "'healthchecks-with-nestjs-app/apps/api/src/app/health/health.module.ts'\n:import { Module } from '@nestjs/common';\nimport { HealthController } from './health.controller';\nimport { HealthService } from './health.service';\nimport { TerminusModule } from '@nestjs/terminus';\nimport { PrometheusModule } from '../prometheus/prometheus.module';\nimport { AnyOtherModuleModule } from '../any-other-module/any-other-module.module';\n\n@Module({\n  imports: [TerminusModule, PrometheusModule, AnyOtherModuleModule],\n  controllers: [HealthController],\n  providers: [HealthService],\n  exports: [HealthService],\n})\nexport class HealthModule {}\n\n'healthchecks-with-nestjs-app/apps/api/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ServeStaticModule } from '@nestjs/serve-static';\nimport { join } from 'path';\nimport { ConfigModule } from '@nestjs/config';\nimport { HealthModule } from './health/health.module';\nimport { PrometheusModule } from './prometheus/prometheus.module';\nimport { AnyOtherModuleModule } from './any-other-module/any-other-module.module';\nimport { MetricsModule } from './metrics/metrics.module';\n\n@Module({\n  imports: [\n    ServeStaticModule.forRoot({\n      rootPath: join(__dirname, '..', '..', '..', 'dist/apps/yuna'),\n    }),\n    ConfigModule.forRoot({ cache: true }),\n    HealthModule,\n    PrometheusModule,\n    AnyOtherModuleModule,\n    MetricsModule,\n  ],\n  controllers: [],\n  providers: [],\n})\nexport class AppModule {}\n\n'healthchecks-with-nestjs-app/apps/api/src/main.ts'\n:\n\nimport { Logger } from '@nestjs/common';\nimport { NestFactory } from '@nestjs/core';\n\nimport { AppModule } from './app/app.module';\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule, {\n    logger: ['log', 'error', 'warn', 'debug', 'verbose']\n  });\n  const globalPrefix = 'api/v1';\n  app.setGlobalPrefix(globalPrefix);\n  const port = process.env.PORT || 3333;\n  await app.listen(port, () => {\n    Logger.log('Listening at http:\n  });\n}\n\nbootstrap();\n\n'healthchecks-with-nestjs-app/apps/api/src/app/health/health.service.ts'\n:import { Injectable, Logger } from '@nestjs/common';\nimport {\n  HealthCheck,\n  HealthCheckResult,\n  HealthCheckService,\n  HttpHealthIndicator,\n} from '@nestjs/terminus';\nimport { PrometheusService } from '../prometheus/prometheus.service';\nimport { AnyOtherService } from '../any-other-module/any-other.service';\nimport { HealthIndicator } from './interfaces/health-indicator.interface';\nimport { NestjsHealthIndicator } from './models/nestjs-health.indicator';\nimport { AnyOtherHealthIndicator } from './models/any-other-health.indicator';\n\n@Injectable()\nexport class HealthService {\n  private readonly listOfThingsToMonitor: HealthIndicator[];\n\n  constructor(\n    private health: HealthCheckService,\n    private http: HttpHealthIndicator,\n    private promClientService: PrometheusService,\n    private anyOtherService: AnyOtherService\n  ) {\n    this.listOfThingsToMonitor = [\n      new NestjsHealthIndicator(\n        this.http,\n        'https:\n        this.promClientService\n      ),\n      new AnyOtherHealthIndicator(this.anyOtherService, this.promClientService),\n    ];\n  }\n\n  @HealthCheck()\n  public async check(): Promise<HealthCheckResult | undefined> {\n    return await this.health.check(\n      this.listOfThingsToMonitor.map(\n        (apiIndicator: HealthIndicator) => async () => {\n          try {\n            return await apiIndicator.isHealthy();\n          } catch (e) {\n            Logger.warn(e);\n            return apiIndicator.reportUnhealthy();\n          }\n        }\n      )\n    );\n  }\n}\n\n'healthchecks-with-nestjs-app/apps/api/src/app/health/models/any-other-health.indicator.ts'\n:import { BaseHealthIndicator } from './base-health.indicator';\nimport { HealthIndicator } from '../interfaces/health-indicator.interface';\nimport { HealthIndicatorResult } from '@nestjs/terminus';\nimport { PrometheusService } from '../../prometheus/prometheus.service';\nimport { AnyOtherService } from '../../any-other-module/any-other.service';\n\nexport class AnyOtherHealthIndicator\n  extends BaseHealthIndicator\n  implements HealthIndicator {\n  public readonly name = 'AnyOtherCustomHealthIndicator';\n  protected readonly help = 'Status of ' + this.name;\n\n  constructor(\n    private service: AnyOtherService,\n    protected promClientService: PrometheusService\n  ) {\n    super();\n\n    this.registerGauges();\n  }\n\n  public async isHealthy(): Promise<HealthIndicatorResult> {\n    const isHealthy = this.service.isConnected;\n    this.updatePrometheusData(isHealthy);\n    return this.getStatus(this.name, isHealthy);\n  }\n}\n",
        "gt": [
            "'healthchecks-with-nestjs-app/apps/api/src/app/health/models/any-other-health.indicator.ts'",
            "'healthchecks-with-nestjs-app/apps/api/src/app/health/health.service.ts'",
            "'healthchecks-with-nestjs-app/apps/api/src/app/health/health.module.ts'",
            "'healthchecks-with-nestjs-app/apps/api/src/app/app.module.ts'",
            "'healthchecks-with-nestjs-app/apps/api/src/main.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/usage/usage.guard.ts'",
            "'is-even/apps/backend/src/usage/track-usage.decorator.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/app/app.controller.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'"
        ],
        "content": "'is-even/apps/backend/src/usage/usage.guard.ts'\n:import {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  Inject,\n  HttpException,\n  HttpStatus,\n} from '@nestjs/common';\n\nimport { UsageService } from './usage.service';\n\nimport { InvalidApiKeyError } from './error/invalid-api-key.error';\nimport { NoActiveCreditError } from './error/no-active-credit.error';\nimport { UsedCreditError } from './error/used-credit.error';\n\n@Injectable()\nexport class UsageGuard implements CanActivate {\n  constructor(\n    @Inject(UsageService) private readonly usageService: UsageService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    try {\n      const request = context.switchToHttp().getRequest();\n      const apiKey = request.query.apiKey;\n\n      await this.usageService.charge(apiKey);\n\n      return true;\n    } catch (error) {\n      if (error instanceof InvalidApiKeyError) {\n        throw new HttpException('Invalid API Key', HttpStatus.BAD_REQUEST);\n      }\n\n      if (error instanceof NoActiveCreditError) {\n        throw new HttpException('No active credit', HttpStatus.BAD_REQUEST);\n      }\n\n      if (error instanceof UsedCreditError) {\n        throw new HttpException('Credit is fully used', HttpStatus.BAD_REQUEST);\n      }\n\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/usage/track-usage.decorator.ts'\n:import { applyDecorators, UseGuards } from '@nestjs/common';\nimport { UsageGuard } from './usage.guard';\n\nexport function TrackUsage() {\n  return applyDecorators(UseGuards(UsageGuard));\n}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/app/app.controller.ts'\n:import { BadRequestException, Controller, Get, Param } from '@nestjs/common';\nimport { ApiTags, ApiOkResponse, ApiBadRequestResponse } from '@nestjs/swagger';\n\nimport { TrackUsage } from '../usage/track-usage.decorator';\nimport { IsEvenDto } from './dto/is-even.dto';\n\n@Controller()\nexport class AppController {\n  @Get()\n  @ApiTags('health')\n  @ApiOkResponse({\n    description: 'Health check',\n  })\n  public check(): string {\n    return 'Ok';\n  }\n\n  @Get('/is-even/:number')\n  @TrackUsage()\n  @ApiTags('is-even')\n  @ApiOkResponse({\n    type: IsEvenDto,\n    description: 'Number parsed',\n  })\n  @ApiBadRequestResponse({\n    description: 'Bad request',\n  })\n  public async analyze(@Param('number') number: number): Promise<IsEvenDto> {\n    if (Number.isNaN(number)) {\n      throw new BadRequestException(`${number} is not a number`);\n    }\n\n    return {\n      isEven: number % 2 === 0,\n    };\n  }\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n",
        "gt": [
            "'is-even/apps/backend/src/usage/usage.guard.ts'",
            "'is-even/apps/backend/src/usage/track-usage.decorator.ts'",
            "'is-even/apps/backend/src/app/app.controller.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'angular-16-complete-course/10-angular-router/final/src/app/Models/course.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/app/contact/contact.component.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/app/Services/authguard.service.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/main.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/app/app.module.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/app/routing.module.ts'"
        ],
        "content": "'angular-16-complete-course/10-angular-router/final/src/app/Models/course.ts'\n:export class Course{\n\n    id: number;\n\n    title: string;\n\n    price: number;\n\n    desc: string;\n\n    image: string;\n\n    rating: number;\n\n    duration: number;\n\n    author: string;\n\n}\n'angular-16-complete-course/10-angular-router/final/src/app/contact/contact.component.ts'\n:import { Component } from '@angular/core';\nimport { IDeactivateComponent } from '../Services/authguard.service';\n\n@Component({\n  selector: 'app-contact',\n  templateUrl: './contact.component.html',\n  styleUrls: ['./contact.component.css']\n})\nexport class ContactComponent implements IDeactivateComponent {\n  firstName: string = '';\n  lastName: string = '';\n  country: string = 'usa';\n  message: string = '';\n\n  isSubmitted: boolean = false;\n\n  OnSubmit(){\n    this.isSubmitted = true;\n  }\n\n  canExit(){\n    console.log('canExit called!')\n    if((this.firstName || this.lastName || this.message) && !this.isSubmitted){\n      return confirm('You have unsaved changes. Do you want to navigate away?')\n    }\n    else{\n      return true;\n    }\n  }\n}\n\n'angular-16-complete-course/10-angular-router/final/src/app/Services/authguard.service.ts'\n:import { Injectable, inject } from '@angular/core';\n\nimport { ActivatedRouteSnapshot, CanActivate, CanActivateChild, CanDeactivate, Resolve, Router, RouterStateSnapshot, UrlTree } from '@angular/router';\n\nimport { Observable } from 'rxjs'\n\nimport { AuthService } from './auth.service';\n\nimport { ContactComponent } from '../contact/contact.component';\n\nimport { Course } from '../Models/course';\n\nimport { CourseService } from './course.service';\n\n\n\nexport interface IDeactivateComponent{\n\n    canExit: () => boolean | Observable<boolean> | Promise<boolean>;\n\n}\n\n\n\n\n\n@Injectable({\n\n    providedIn: 'root'\n\n})\n\nexport class AuthGuardService implements CanActivate, CanActivateChild, CanDeactivate<IDeactivateComponent>, Resolve<Course[]>{\n\n    authService: AuthService = inject(AuthService);\n\n    router: Router = inject(Router);\n\n    courseService: CourseService = inject(CourseService);\n\n\n\n    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot):\n\n        boolean | Observable<boolean> | Promise<boolean>\n\n    {\n\n        if(this.authService.IsAuthenticated()){\n\n            return true;\n\n        }else{\n\n            this.router.navigate(['/Login']);\n\n            return false;\n\n        }\n\n    }\n\n\n\n\n\n    canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean | UrlTree | Observable<boolean | UrlTree> | Promise<boolean | UrlTree> {\n\n        return this.canActivate(childRoute, state);\n\n    }\n\n\n\n    canDeactivate(component: IDeactivateComponent, currentRoute: ActivatedRouteSnapshot,\n\n        currentState: RouterStateSnapshot, nextState: RouterStateSnapshot)\n\n    {\n\n        return component.canExit();\n\n    }\n\n\n\n    resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Course[] | Observable<Course[]> | Promise<Course[]> {\n\n        return this.courseService.getAllcourses();\n\n    }\n\n}\n'angular-16-complete-course/10-angular-router/final/src/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-16-complete-course/10-angular-router/final/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { Routes, RouterModule } from '@angular/router';\nimport { AppComponent } from './app.component';\nimport { ServicesService } from './Services/services.service';\nimport { HomeComponent } from './home/home.component';\nimport { FooterComponent } from './footer/footer.component';\nimport { HeaderComponent } from './header/header.component';\nimport { ContactComponent } from './contact/contact.component';\nimport { AboutComponent } from './about/about.component';\nimport { BannerComponent } from './home/banner/banner.component';\nimport { ServicesComponent } from './home/services/services.component';\nimport { TestimonyComponent } from './home/testimony/testimony.component';\nimport { ContactUsComponent } from './home/contact-us/contact-us.component';\nimport { PopularComponent } from './home/popular/popular.component';\nimport { CourseService } from './Services/course.service';\nimport { CoursesComponent } from './courses/courses.component';\nimport { CourseDetailComponent } from './courses/course-detail/course-detail.component';\nimport { LoginComponent } from './login/login.component';\nimport { NotFoundComponent } from './not-found/not-found.component';\nimport { RoutingModule } from './routing.module';\nimport { CheckoutComponent } from './checkout/checkout.component';\nimport { FormsModule } from '@angular/forms';\n\n\n\n\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HomeComponent,\n    FooterComponent,\n    HeaderComponent,\n    ContactComponent,\n    AboutComponent,\n    BannerComponent,\n    ServicesComponent,\n    TestimonyComponent,\n    ContactUsComponent,\n    PopularComponent,\n    CoursesComponent,\n    CourseDetailComponent,\n    LoginComponent,\n    NotFoundComponent,\n    CheckoutComponent\n  ],\n  imports: [\n    BrowserModule,\n    RoutingModule,\n    FormsModule\n  ],\n  providers: [ServicesService, CourseService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-16-complete-course/10-angular-router/final/src/app/routing.module.ts'\n:import { NgModule } from '@angular/core';\n\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { HomeComponent } from './home/home.component';\n\nimport { ContactComponent } from './contact/contact.component';\n\nimport { AboutComponent } from './about/about.component';\n\nimport { PopularComponent } from './home/popular/popular.component';\n\nimport { CoursesComponent } from './courses/courses.component';\n\nimport { CourseDetailComponent } from './courses/course-detail/course-detail.component';\n\nimport { NotFoundComponent } from './not-found/not-found.component';\n\nimport { LoginComponent } from './login/login.component';\n\nimport { CheckoutComponent } from './checkout/checkout.component';\n\nimport { AuthGuardService } from './Services/authguard.service';\n\nimport { CanActivate, CanActivateChild, resolve } from './auth.guard'\n\n\n\n\n\n\n\nconst routes: Routes = [\n\n\n\n    {path: '', component: HomeComponent},\n\n    {path: 'Home', component: HomeComponent},\n\n    {path: 'About', component: AboutComponent},\n\n    {path: 'Contact', component: ContactComponent, canDeactivate: [(comp: ContactComponent) => {return comp.canExit();}]},\n\n    {path: 'Courses', component: CoursesComponent, resolve: {courses: resolve}},\n\n    {path: 'Courses', canActivateChild: [CanActivateChild], children: [\n\n      {path: 'Course/:id', component: CourseDetailComponent},\n\n      {path: 'Popular', component: PopularComponent},\n\n      {path: 'Checkout', component: CheckoutComponent}\n\n    ]},\n\n    {path: 'Login', component: LoginComponent},\n\n    {path: '**', component: NotFoundComponent},\n\n  ]\n\n\n\n@NgModule({\n\n    imports: [\n\n        RouterModule.forRoot(routes, {enableTracing: true})\n\n    ],\n\n    exports: [RouterModule]\n\n})\n\nexport class RoutingModule{\n\n\n\n}",
        "gt": [
            "'angular-16-complete-course/10-angular-router/final/src/app/Models/course.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/app/Services/authguard.service.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/app/contact/contact.component.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/app/routing.module.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/app/app.module.ts'",
            "'angular-16-complete-course/10-angular-router/final/src/main.ts'"
        ]
    },
    {
        "files": [
            "'Recipe-Book-App-Angular-Project/src/app/recipes/recipe.service.ts'",
            "'Recipe-Book-App-Angular-Project/src/main.ts'",
            "'Recipe-Book-App-Angular-Project/src/app/app.module.ts'",
            "'Recipe-Book-App-Angular-Project/src/app/shopping-list/shopping-list.service.ts'",
            "'Recipe-Book-App-Angular-Project/src/app/core/core.module.ts'"
        ],
        "content": "'Recipe-Book-App-Angular-Project/src/app/recipes/recipe.service.ts'\n:import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\n\nimport { Recipe } from './recipe.model';\nimport { Ingredient } from '../shared/ingredient.model';\nimport { ShoppingListService } from '../shopping-list/shopping-list.service';\n\nconst FRUIT = 'https:\nconst PASTA = 'https:\nconst SOUP = 'https:\nconst BAGUETTE = 'https:\n  'baguette-bread-herb-baguette-frisch-103657.jpeg?cs=srgb&dl=baguette-baked-goods-bread-103657.jpg&fm=jpg';\nconst PIE = 'https:\nconst POPSICLE = 'http:\n\n@Injectable()\nexport class RecipeService {\n  recipesChanged = new Subject<Recipe[]>();\n\n  private recipes: Recipe[] = [\n    new Recipe('Fruit', 'Fruit Salad', FRUIT, [new Ingredient('Apple', 3), new Ingredient('Banans', 4)]),\n    new Recipe('Baguette', 'Italic Bread', BAGUETTE, [new Ingredient('Water', 100), new Ingredient('Italian', 1)]),\n    new Recipe('Pasta', 'With Salad', PASTA, [new Ingredient('Vegetables', 3), new Ingredient('Pasta', 1)]),\n    new Recipe('Soup', 'Tasty & Hot', SOUP, [new Ingredient('Water', 3), new Ingredient('Taste', 1)]),\n    new Recipe('Pie', 'Pretty & Attractive', PIE, [new Ingredient('Power', 10), new Ingredient('Fork', 1)]),\n    new Recipe('Popsicle', 'Cold & Refreshing', POPSICLE, [new Ingredient('Fruits', 5), new Ingredient('Popsicle Steak', 1)])\n  ];\n  constructor(private slService: ShoppingListService) {}\n\n  setRecipes(recipes: Recipe[]) {\n    this.recipes = recipes;\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  getRecipes() {\n    return this.recipes.slice();\n  }\n\n  getRecipe(index: number) {\n    return this.recipes[index];\n  }\n\n  addIngredientsToShoppingList(ingredients: Ingredient[]) {\n    this.slService.addIngredients(ingredients);\n  }\n\n  addRecipe(recipe: Recipe) {\n    this.recipes.push(recipe);\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  updateRecipe(index: number, newRecipe: Recipe) {\n    this.recipes[index] = newRecipe;\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  deleteRecipe(index: number) {\n    this.recipes.splice(index, 1);\n    this.recipesChanged.next(this.recipes.slice());\n  }\n}\n\n'Recipe-Book-App-Angular-Project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));\n\n'Recipe-Book-App-Angular-Project/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { HttpModule } from '@angular/http';\n\nimport { AppComponent } from './app.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { ShoppingListModule } from './shopping-list/shopping-list.module';\nimport { AuthModule } from './auth/auth.module'\nimport { CoreModule } from './core/core.module';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpModule,\n    AppRoutingModule,\n    SharedModule,\n    ShoppingListModule,\n    AuthModule,\n    CoreModule\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'Recipe-Book-App-Angular-Project/src/app/shopping-list/shopping-list.service.ts'\n:import { Ingredient } from '../shared/ingredient.model';\nimport { Subject } from 'rxjs/Subject';\n\nexport class ShoppingListService {\n  ingredientsChanged = new Subject<Ingredient[]>();\n  startedEditing = new Subject<number>();\n  private ingredients: Ingredient[] = [\n    new Ingredient('Apples', 5),\n    new Ingredient('Tomatoes', 10),\n  ];\n\n  getIngredients() {\n    return this.ingredients.slice();\n  }\n\n  getIngredient(index: number) {\n    return this.ingredients[index];\n  }\n\n  addIngredient(ingredient: Ingredient) {\n    this.ingredients.push(ingredient);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  addIngredients(ingredients: Ingredient[]) {\n\n\n\n    this.ingredients.push(...ingredients);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  updateIngredient(index: number, newIngredient: Ingredient) {\n    this.ingredients[index] = newIngredient;\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  deleteIngredient(index: number) {\n    this.ingredients.splice(index, 1);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n}\n\n'Recipe-Book-App-Angular-Project/src/app/core/core.module.ts'\n:import { NgModule } from '@angular/core';\n\nimport { HeaderComponent } from './header/header.component';\nimport { HomeComponent } from './home/home.component';\nimport { SharedModule } from '../shared/shared.module';\nimport { AppRoutingModule } from '../app-routing.module';\nimport { AuthService } from '../auth/auth.service';\nimport { DataStorageService } from '../shared/data-storage.service';\nimport { RecipeService } from '../recipes/recipe.service';\nimport { ShoppingListService } from '../shopping-list/shopping-list.service';\n\n@NgModule({\n  declarations: [\n    HeaderComponent,\n    HomeComponent\n  ],\n  imports: [\n    SharedModule,\n    AppRoutingModule\n  ],\n  exports: [\n    AppRoutingModule,\n    HeaderComponent\n  ],\n  providers: [\n    ShoppingListService,\n    RecipeService,\n    DataStorageService,\n    AuthService\n  ]\n})\nexport class CoreModule {}\n",
        "gt": [
            "'Recipe-Book-App-Angular-Project/src/app/shopping-list/shopping-list.service.ts'",
            "'Recipe-Book-App-Angular-Project/src/app/recipes/recipe.service.ts'",
            "'Recipe-Book-App-Angular-Project/src/app/core/core.module.ts'",
            "'Recipe-Book-App-Angular-Project/src/app/app.module.ts'",
            "'Recipe-Book-App-Angular-Project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'rules/apps/doc-app/src/app/app.routing.ts'",
            "'rules/apps/doc-app/src/app/app.module.ts'",
            "'rules/apps/doc-app/src/app/app-routing.module.ts'",
            "'rules/apps/doc-app/src/app/components/doc-page/doc-page-routing.module.ts'",
            "'rules/apps/doc-app/src/app/components/doc-page/doc-page.module.ts'"
        ],
        "content": "'rules/apps/doc-app/src/app/app.routing.ts'\n:import { Routes } from '@angular/router';\n\nexport const routes: Routes = [\n  {\n    path: 'getting-started',\n    loadChildren: () => import('./components/doc-page/doc-page.module').then(m => m.DocPageModule),\n    data: { title: 'Getting Started' , path: 'assets/docs/getting-started.md'}\n  },\n  {\n    path: 'oss-rules',\n    loadChildren: () => import('./components/doc-page/doc-page.module').then(m => m.DocPageModule),\n    data: { title: 'OSS Rules' , path: 'assets/docs/oss-rules.md'}\n  },\n  {\n    path: 'oss-syntax',\n    loadChildren: () => import('./components/doc-page/doc-page.module').then(m => m.DocPageModule),\n    data: { title: 'OSS Syntax', path: 'assets/docs/oss-syntax.md'}\n  },\n  {\n    path: 'metaui-architecture',\n    loadChildren: () => import('./components/doc-page/doc-page.module').then(m => m.DocPageModule),\n    data: { title: 'MetaUI Architecture' , path: 'assets/docs/metaui-architecture.md'}\n  },\n  {\n    path: '',\n    redirectTo: 'getting-started',\n    pathMatch: 'full',\n  }\n];\n\n'rules/apps/doc-app/src/app/app.module.ts'\n:import {NgModule} from '@angular/core';\nimport {BrowserModule} from '@angular/platform-browser';\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\nimport {HttpClientModule} from '@angular/common/http';\n\nimport {AppRoutingModule} from './app-routing.module';\nimport {AppComponent} from './app.component';\nimport {HeaderComponent} from './layout/header/header.component';\nimport {FooterComponent} from './layout/footer/footer.component';\nimport {SidebarComponent} from './layout/sidebar/sidebar.component';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatListModule } from '@angular/material/list';\nimport { MatSidenavModule } from '@angular/material/sidenav';\nimport { MatToolbarModule } from '@angular/material/toolbar';\nimport {AsideNavComponent} from './layout/aside-nav/aside-nav.component';\nimport {NgxPageScrollCoreModule} from 'ngx-page-scroll-core';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    SidebarComponent,\n    AsideNavComponent\n  ],\n  imports: [\n    BrowserModule,\n    BrowserAnimationsModule,\n    AppRoutingModule,\n    MatIconModule,\n    MatSidenavModule,\n    MatListModule,\n    HttpClientModule,\n    MatToolbarModule,\n    NgxPageScrollCoreModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n\n'rules/apps/doc-app/src/app/app-routing.module.ts'\n:import { NgModule } from '@angular/core';\nimport { RouterModule } from '@angular/router';\n\nimport { routes } from './app.routing';\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes, { useHash: true, relativeLinkResolution: 'legacy' })],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n\n'rules/apps/doc-app/src/app/components/doc-page/doc-page-routing.module.ts'\n:import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { DocPageComponent } from './doc-page.component';\n\nconst routes: Routes = [\n  {\n    path: '',\n    component: DocPageComponent\n  }\n];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class DocPageRoutingModule { }\n\n'rules/apps/doc-app/src/app/components/doc-page/doc-page.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { DocPageRoutingModule } from './doc-page-routing.module';\nimport { DocPageComponent } from './doc-page.component';\nimport { MarkdownModule } from '../../layout/markdown/markdown.module';\n\n@NgModule({\n  declarations: [\n    DocPageComponent\n  ],\n  imports: [\n    CommonModule,\n    DocPageRoutingModule,\n    MarkdownModule\n  ],\n})\nexport class DocPageModule { }\n",
        "gt": [
            "'rules/apps/doc-app/src/app/components/doc-page/doc-page-routing.module.ts'",
            "'rules/apps/doc-app/src/app/components/doc-page/doc-page.module.ts'",
            "'rules/apps/doc-app/src/app/app.routing.ts'",
            "'rules/apps/doc-app/src/app/app-routing.module.ts'",
            "'rules/apps/doc-app/src/app/app.module.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-list.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'",
            "'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-edit/shopping-edit.component.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-list.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { FormsModule } from \"@angular/forms\";\n\nimport { RouterModule } from \"@angular/router\";\n\nimport { SharedModule } from \"../shared/shared.module\";\n\n\n\nimport { ShoppingEditComponent } from \"./shopping-edit/shopping-edit.component\";\n\nimport { ShoppingListComponent } from \"./shopping-list.component\";\n\n\n\n@NgModule({\n\n  declarations: [\n\n    ShoppingListComponent,\n\n    ShoppingEditComponent,\n\n  ],\n\n  imports: [\n\n    FormsModule,\n\n    RouterModule.forChild([\n\n      { path: '', component: ShoppingListComponent },\n\n    ]),\n\n    SharedModule\n\n  ],\n\n})\n\nexport class ShoppingListModule { }\n\n\n'angular-the-complete-guide-2023/project/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { CoreModule } from './core.module';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\n\nimport * as fromApp from './store/app.reducer';\nimport { AuthEffects } from './auth/store/auth.effects';\nimport { environment } from 'src/environments/environment';\nimport { RecipeEffects } from './recipes/store/recipe.effects';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    SharedModule,\n    CoreModule,\n    StoreModule.forRoot(fromApp.appReducer),\n    EffectsModule.forRoot([AuthEffects, RecipeEffects]),\n    StoreDevtoolsModule.instrument({\n      logOnly: environment.production\n    }),\n    StoreRouterConnectingModule.forRoot()\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'\n:import * as fromShoppingList from '../shopping-list/store/shopping-list.reducer';\n\nimport * as fromAuth from '../auth/store/auth.reducer';\n\nimport * as fromRecipes from '../recipes/store/recipe.reducer';\n\nimport { ActionReducerMap } from '@ngrx/store';\n\n\n\nexport interface AppState {\n\n  shoppingList: fromShoppingList.State;\n\n  auth: fromAuth.State;\n\n  recipes: fromRecipes.State;\n\n}\n\n\n\nexport const appReducer: ActionReducerMap<AppState> = {\n\n  shoppingList: fromShoppingList.shoppingListReducer,\n\n  auth: fromAuth.authReducer,\n\n  recipes: fromRecipes.recipeReducer\n\n};\n\n\n'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-edit/shopping-edit.component.ts'\n:import { Component, OnDestroy, OnInit, ViewChild } from '@angular/core';\nimport { NgForm } from '@angular/forms';\n\nimport { Subscription } from 'rxjs-compat';\n\nimport { Ingredient } from 'src/app/shared/ingredient.model';\nimport { Store } from '@ngrx/store';\nimport * as ShoppingListActions from '../store/shopping-list.actions';\nimport * as fromApp from '../../store/app.reducer';\n\n@Component({\n  selector: 'app-shopping-edit',\n  templateUrl: './shopping-edit.component.html',\n  styleUrls: ['./shopping-edit.component.css']\n})\nexport class ShoppingEditComponent implements OnInit, OnDestroy {\n\n  @ViewChild('f', { static: false }) shoppingListForm: NgForm;\n  subscription: Subscription;\n  editMode: boolean = false;\n  editedItem: Ingredient;\n\n  constructor(\n    private store: Store<fromApp.AppState>\n  ) { }\n\n  ngOnInit(): void {\n    this.subscription = this.store.select('shoppingList')\n      .subscribe(stateData => {\n        if (stateData.editedIngredientIndex > -1) {\n          this.editMode = true;\n          this.editedItem = stateData.editedIngredient;\n          this.shoppingListForm.setValue({\n            name: this.editedItem.name,\n            amount: this.editedItem.amount\n          });\n        } else {\n          this.editMode = false;\n        }\n      }\n    );\n  }\n\n  ngOnDestroy(): void {\n    this.subscription.unsubscribe();\n    this.store.dispatch(new ShoppingListActions.StopEdit());\n  }\n\n  onClear(): void {\n    this.shoppingListForm.reset();\n    this.editMode = false;\n    this.store.dispatch(new ShoppingListActions.StopEdit());\n  }\n\n  onDelete(): void {\n    this.store.dispatch(new ShoppingListActions.DeleteIngredient());\n    this.onClear();\n  }\n\n  onSubmit(form: NgForm): void {\n    const value = form.value;\n    const newIngredient = new Ingredient(value.name, value.amount);\n\n    if (this.editMode) {\n      this.store.dispatch(new ShoppingListActions.UpdateIngredient(newIngredient));\n    } else {\n      this.store.dispatch(new ShoppingListActions.AddIngredient(newIngredient));\n    }\n\n    this.editMode = false;\n    form.reset();\n  }\n\n}\n\n'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { Routes, RouterModule, PreloadAllModules } from \"@angular/router\";\n\n\n\nconst appRoutes: Routes = [\n\n    { path: '', redirectTo: '/recipes', pathMatch: 'full'},\n\n    { path: 'recipes', loadChildren: () => import('./recipes/recipes.module').then(m => m.RecipesModule) },\n\n    { path: 'shopping-list', loadChildren: () => import('./shopping-list/shopping-list.module').then(m => m.ShoppingListModule) },\n\n    { path: 'auth', loadChildren: () => import('./auth/auth.module').then(m => m.AuthModule) }\n\n];\n\n\n\n@NgModule({\n\n    imports: [RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules })],\n\n    exports: [RouterModule]\n\n})\n\nexport class AppRoutingModule {\n\n\n\n}\n\n",
        "gt": [
            "'angular-the-complete-guide-2023/project/src/app/store/app.reducer.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-edit/shopping-edit.component.ts'",
            "'angular-the-complete-guide-2023/project/src/app/shopping-list/shopping-list.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'ymock/src/components/Main.tsx'",
            "'ymock/src/components/manageMock/MockForm.tsx'",
            "'ymock/src/lib/mock.ts'",
            "'ymock/src/components/manageMock/index.tsx'",
            "'ymock/src/components/form/Form.tsx'"
        ],
        "content": "'ymock/src/components/Main.tsx'\n:import { useParams } from \"react-router-dom\";\nimport { ManageMock } from \"./manageMock/index\";\nimport { Method } from \"../types/method\";\n\nexport type MainParams = {\n  method: Method;\n} & Record<string, string>;\n\nexport const Main: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n\n  return <ManageMock key={`${method}${path}`} />;\n};\n\n'ymock/src/components/manageMock/MockForm.tsx'\n:import { useContext, useMemo, useState } from \"react\";\nimport { mock } from \"../../lib/mock\";\nimport { MSWContext } from \"../MSWContext\";\nimport { MainParams } from \"../Main\";\nimport { Form } from \"../form/Form\";\nimport { JsonInput } from \"../form/JsonInput\";\nimport { PlainTextInput } from \"../form/PlainTextInput\";\n\nconst responseTypes = [\"json\", \"text\"];\n\ntype ResponseTypes = (typeof responseTypes)[number];\n\nconst renderResponseInput = (type: ResponseTypes) => {\n  switch (type) {\n    case \"text\":\n      return <PlainTextInput />;\n    case \"json\":\n    default:\n      return <JsonInput />;\n  }\n};\n\nexport const MockForm: React.FC<MainParams> = ({ method, path }) => {\n  const { worker } = useContext(MSWContext);\n  const [responseType, setResponseType] = useState<ResponseTypes>(\"json\");\n\n  const setResponse = useMemo(\n    () => mock(worker)(method, path),\n    [worker, method, path]\n  );\n\n  const handleResponseType: React.ChangeEventHandler<HTMLSelectElement> = (e) =>\n    setResponseType(e.target.value);\n\n  return (\n    <Form onSubmit={setResponse()}>\n      <div className=\"input\">\n        <label htmlFor=\"responseType\">Response type</label>\n        <select name=\"responseType\" onChange={handleResponseType}>\n          {responseTypes.map((type) => (\n            <option value={type} key={type}>\n              {type}\n            </option>\n          ))}\n        </select>\n      </div>\n      <div className=\"input\">\n        <label>Body</label>\n        {renderResponseInput(responseType)}\n      </div>\n      <button type=\"submit\" className=\"primary\">\n        Set response\n      </button>\n    </Form>\n  );\n};\n\n'ymock/src/lib/mock.ts'\n:import { http } from \"msw\";\nimport { SetupWorker } from \"msw/lib/browser\";\nimport { FormValues } from \"../components/form/Form\";\nimport { Method } from \"../types/method\";\nimport { ResponseHandler } from \"../types/responseHandler\";\nimport { jsonResponseHandler } from \"./responseHandlers/jsonResponseHandler\";\n\n\nexport const mock = (worker: SetupWorker) => (method: Method = 'get', path: string = '/') => (responseHandler: ResponseHandler = jsonResponseHandler) => (data: FormValues) => {\n  const _method: Method = (method?.toLowerCase() as Method) ?? \"get\";\n\n  const { body } = data;\n\n  worker.use(\n    http[_method](`/${path}`, responseHandler(body))\n  );\n};\n\n'ymock/src/components/manageMock/index.tsx'\n:import { useContext, useEffect, useState } from \"react\";\nimport { useParams } from \"react-router\";\nimport { mock } from \"../../lib/mock\";\nimport { passthroughResponseHandler } from \"../../lib/responseHandlers/passthroughResponseHandler\";\nimport { MSWContext } from \"../MSWContext\";\nimport { MainParams } from \"../Main\";\nimport { Welcome } from \"../Welcome\";\nimport { Checkbox } from \"../form/Checkbox\";\nimport { MockForm } from \"./MockForm\";\n\nexport const ManageMock: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n  const { worker } = useContext(MSWContext);\n  const [passthrough, setPassthrough] = useState(false);\n\n  useEffect(() => {\n    if (passthrough) {\n\n      mock(worker)(method, path)(passthroughResponseHandler)({});\n    }\n  }, [passthrough]);\n\n  if (!method || !path) {\n    console.warn(\"Invalid route: even method and path must be set\");\n    return <Welcome />;\n  }\n\n  return (\n    <div className=\"manage-mock\">\n      <div className=\"title\">Request info</div>\n      <div className=\"request-info\">\n        <div className=\"method\">{method}</div>\n        <div className=\"path\">/{path}</div>\n      </div>\n      <div className=\"configure-form\">\n        <div className=\"input\">\n          <Checkbox\n            name=\"passthrough\"\n            label=\"Passthrough\"\n            defaultChecked={passthrough}\n            onChange={setPassthrough}\n          />\n        </div>\n        {!passthrough && <MockForm {...{ method, path }} />}\n      </div>\n    </div>\n  );\n};\n\n'ymock/src/components/form/Form.tsx'\n:import React, {\n  FormEventHandler,\n  PropsWithChildren,\n  useCallback,\n  useRef,\n} from \"react\";\n\nexport interface FormValues extends Record<string, any> {}\n\ntype Form = {\n  onSubmit: (data: FormValues) => void;\n};\n\nexport const Form: React.FC<Form & PropsWithChildren> = ({\n  children,\n  onSubmit,\n}) => {\n  const formRef = useRef<HTMLFormElement>(null);\n\n  const handleSubmit = useCallback<FormEventHandler<HTMLFormElement>>(\n    (event) => {\n      event.preventDefault();\n      const data: Record<string, any> = {};\n      const formData = new FormData(formRef.current as HTMLFormElement);\n      for (const [key, value] of formData) {\n        data[key] = value;\n      }\n      onSubmit(data);\n    },\n    [onSubmit, formRef]\n  );\n\n  return (\n    <form onSubmit={handleSubmit} ref={formRef}>\n      {children}\n    </form>\n  );\n};\n",
        "gt": [
            "'ymock/src/components/form/Form.tsx'",
            "'ymock/src/lib/mock.ts'",
            "'ymock/src/components/manageMock/MockForm.tsx'",
            "'ymock/src/components/manageMock/index.tsx'",
            "'ymock/src/components/Main.tsx'"
        ]
    },
    {
        "files": [
            "'ng-jda-2017-07-05/apps/store-app-http/src/app/services/products.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http/src/app/product-table/product-table.component.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http/src/app/services/logging.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http/src/main.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http/src/app/app.module.ts'"
        ],
        "content": "'ng-jda-2017-07-05/apps/store-app-http/src/app/services/products.service.ts'\n:import { Injectable, EventEmitter } from '@angular/core';\nimport { Http, Response } from '@angular/http';\n\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/observable/throw';\n\nimport { Product } from '../models/product';\nimport { LoggingService } from './logging.service';\nimport { StoreAppError } from '../errors/store-app-error';\n\n@Injectable()\nexport class ProductsService {\n    private apiUrl: string = 'http:\n\n    productAdded = new EventEmitter<Product>();\n    productUpdated = new EventEmitter<Product>();\n    productDeleted = new EventEmitter<number>();\n\n    constructor(\n        private loggingService: LoggingService,\n        private http: Http\n    ) {}\n\n    getProducts(): Observable<Product[]> {\n        return this.http.get(this.apiUrl)\n            .map(this.handleSuccess)\n            .catch(this.handleError);\n    }\n\n    getProduct(id: number): Observable<Product> {\n        return this.http.get(this.apiUrl + '/' + id)\n            .map(this.handleSuccess)\n            .catch(this.handleError);\n    }\n\n    addProduct(product: Product): Observable<Product> {\n        return this.http.post(this.apiUrl, product)\n            .map(\n                (response: Response) => {\n                    let newProduct = response.json();\n                    this.productAdded.emit(newProduct);\n                    return newProduct;\n                }\n            )\n            .catch(this.handleError);\n    }\n\n    updateProduct(id: number, productInfo: Product): Observable<Product> {\n        return this.http.patch(this.apiUrl + '/' + id, productInfo)\n            .map(\n                (response: Response) => {\n                    let updatedProduct = response.json();\n                    this.productUpdated.emit(updatedProduct);\n                    return updatedProduct;\n                }\n            )\n            .catch(this.handleError);\n    }\n\n    deleteProduct(id: number): Observable<Product> {\n        return this.http.delete(this.apiUrl + '/' + id)\n            .map(\n                (response: Response) => {\n                    this.productDeleted.emit(id);\n                    return response.json();\n                }\n            )\n            .catch(this.handleError);\n    }\n\n    private handleSuccess(response: Response) {\n        return response.json();\n    }\n\n    private handleError(error: Response) {\n        let appError = new StoreAppError(error);\n        return Observable.throw(appError);\n    }\n}\n\n'ng-jda-2017-07-05/apps/store-app-http/src/app/product-table/product-table.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\n\nimport { Product } from '../models/product';\nimport { ProductsService } from '../services/products.service';\nimport { StoreAppError } from '../errors/store-app-error';\n\n@Component({\n  selector: 'app-product-table',\n  templateUrl: './product-table.component.html',\n  styleUrls: ['./product-table.component.css']\n})\nexport class ProductTableComponent implements OnInit {\n  products: Product[] = [];\n  filterName = '';\n\n  constructor(private service: ProductsService) { }\n\n  ngOnInit() {\n    this.service.getProducts()\n      .subscribe(\n        (products: Product[]) => this.products = products,\n        (error: StoreAppError) => console.log(error)\n      );\n  }\n}\n\n'ng-jda-2017-07-05/apps/store-app-http/src/app/services/logging.service.ts'\n:export class LoggingService {\n    log(message: any) {\n        console.log('[LoggingService.log()] ->', message);\n    }\n}\n\n'ng-jda-2017-07-05/apps/store-app-http/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n'ng-jda-2017-07-05/apps/store-app-http/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { Routes, RouterModule } from '@angular/router';\nimport { HttpModule } from '@angular/http';\n\n\nimport { AppComponent } from './app.component';\nimport { ProductsComponent } from './products/products.component';\nimport { ProductListComponent } from './product-list/product-list.component';\nimport { ProductDetailComponent } from './product-detail/product-detail.component';\nimport { ProductFormComponent } from './product-form/product-form.component';\nimport { ProductTableComponent } from './product-table/product-table.component';\nimport { CustomerFormComponent } from './customer-form/customer-form.component';\nimport { NotFoundComponent } from './not-found/not-found.component';\n\n\nimport { LoggingService } from './services/logging.service';\nimport { ProductsService } from './services/products.service';\nimport { HomeComponent } from './home/home.component';\nimport { CustomersComponent } from './customers/customers.component';\nimport { AppNavComponent } from './app-nav/app-nav.component';\n\n\nimport { ShortenPipe } from './common/shorten.pipe';\nimport { FilterPipe } from './common/filter.pipe';\nimport { CustDirDemoComponent } from './cust-dir-demo/cust-dir-demo.component';\n\n\nimport { BasicHighlightDirective } from './directives/basic-highlight.directive';\nimport { BetterHighlightDirective } from './directives/better-highlight.directive';\nimport { ReactiveHighlight1Directive } from './directives/reactive-highlight-1.directive';\nimport { ReactiveHighlight2Directive } from './directives/reactive-highlight-2.directive';\nimport { ReactiveHighlight3Directive } from './directives/reactive-highlight-3.directive';\n\n\nconst appRoutes: Routes = [\n  { path: 'products', component: ProductsComponent, children: [\n    { path: ':id', component: ProductDetailComponent },\n    { path: ':id/edit', component: ProductFormComponent }\n  ] },\n  { path: 'customers', component: CustomersComponent },\n  { path: 'cust-pipes', component: ProductTableComponent },\n  { path: 'cust-directives', component: CustDirDemoComponent },\n  { path: '', component: HomeComponent},\n  { path: '**', component: NotFoundComponent }\n];\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    ProductsComponent,\n    ProductFormComponent,\n    ProductDetailComponent,\n    ProductListComponent,\n    NotFoundComponent,\n    HomeComponent,\n    CustomersComponent,\n    AppNavComponent,\n    CustomerFormComponent,\n    ProductTableComponent,\n    ShortenPipe,\n    FilterPipe,\n    CustDirDemoComponent,\n    BasicHighlightDirective,\n    BetterHighlightDirective,\n    ReactiveHighlight1Directive,\n    ReactiveHighlight2Directive,\n    ReactiveHighlight3Directive\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    ReactiveFormsModule,\n    HttpModule,\n    RouterModule.forRoot(appRoutes)\n  ],\n  providers: [LoggingService, ProductsService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n",
        "gt": [
            "'ng-jda-2017-07-05/apps/store-app-http/src/app/services/logging.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http/src/app/services/products.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http/src/app/product-table/product-table.component.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http/src/app/app.module.ts'",
            "'ng-jda-2017-07-05/apps/store-app-http/src/main.ts'"
        ]
    },
    {
        "files": [
            "'angular-the-complete-guide-2023/project/src/main.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipe-detail/recipe-detail.component.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipe.model.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'"
        ],
        "content": "'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { Routes, RouterModule, PreloadAllModules } from \"@angular/router\";\n\n\n\nconst appRoutes: Routes = [\n\n    { path: '', redirectTo: '/recipes', pathMatch: 'full'},\n\n    { path: 'recipes', loadChildren: () => import('./recipes/recipes.module').then(m => m.RecipesModule) },\n\n    { path: 'shopping-list', loadChildren: () => import('./shopping-list/shopping-list.module').then(m => m.ShoppingListModule) },\n\n    { path: 'auth', loadChildren: () => import('./auth/auth.module').then(m => m.AuthModule) }\n\n];\n\n\n\n@NgModule({\n\n    imports: [RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules })],\n\n    exports: [RouterModule]\n\n})\n\nexport class AppRoutingModule {\n\n\n\n}\n\n\n'angular-the-complete-guide-2023/project/src/app/recipes/recipe-detail/recipe-detail.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { Recipe } from '../recipe.model';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { map, switchMap } from 'rxjs/operators';\n\nimport { Store } from '@ngrx/store';\nimport * as fromApp from '../../store/app.reducer';\nimport * as RecipeActions from '../store/recipe.actions';\nimport * as ShoppingListActions from '../../shopping-list/store/shopping-list.actions';\n\n\n@Component({\n  selector: 'app-recipe-detail',\n  templateUrl: './recipe-detail.component.html',\n  styleUrls: ['./recipe-detail.component.css']\n})\nexport class RecipeDetailComponent implements OnInit {\n\n  recipe: Recipe;\n  id: number;\n\n  constructor(\n    private activatedRoute: ActivatedRoute,\n    private router: Router,\n    private store: Store<fromApp.AppState>\n  ) { }\n\n  ngOnInit(): void {\n    this.activatedRoute.params\n      .pipe(\n        map(params => {\n          return +params['id'];\n        }),\n        switchMap(id => {\n          this.id = id;\n          return this.store.select('recipes');\n        }),\n        map(recipesState => {\n          return recipesState.recipes.find((recipe, index) => {\n            return index === this.id;\n          });\n        })\n      ).subscribe(recipe => {\n        this.recipe = recipe;\n      });\n  }\n\n  onAddToShoppingList() {\n    this.store.dispatch(new ShoppingListActions.AddIngredients(this.recipe.ingredients));\n  }\n\n  onEditRecipe() {\n    this.router.navigate(['edit'], { relativeTo: this.activatedRoute });\n  }\n\n  onDeleteRecipe() {\n    this.store.dispatch(new RecipeActions.DeleteRecipe(this.id));\n    this.router.navigate(['/recipes']);\n  }\n\n}\n\n'angular-the-complete-guide-2023/project/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { AppRoutingModule } from './app-routing.module';\nimport { SharedModule } from './shared/shared.module';\nimport { CoreModule } from './core.module';\n\nimport { StoreModule } from '@ngrx/store';\nimport { EffectsModule } from '@ngrx/effects';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { StoreRouterConnectingModule } from '@ngrx/router-store';\n\nimport * as fromApp from './store/app.reducer';\nimport { AuthEffects } from './auth/store/auth.effects';\nimport { environment } from 'src/environments/environment';\nimport { RecipeEffects } from './recipes/store/recipe.effects';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    AppRoutingModule,\n    SharedModule,\n    CoreModule,\n    StoreModule.forRoot(fromApp.appReducer),\n    EffectsModule.forRoot([AuthEffects, RecipeEffects]),\n    StoreDevtoolsModule.instrument({\n      logOnly: environment.production\n    }),\n    StoreRouterConnectingModule.forRoot()\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-the-complete-guide-2023/project/src/app/recipes/recipe.model.ts'\n:import { Ingredient } from \"../shared/ingredient.model\";\n\n\n\nexport class Recipe {\n\n    public name: string;\n\n    public description: string;\n\n    public imagePath: string;\n\n    public ingredients: Ingredient[];\n\n\n\n    constructor(name: string, description: string, imagePath: string, ingredients: Ingredient[]) {\n\n        this.name = name;\n\n        this.description = description;\n\n        this.imagePath = imagePath;\n\n        this.ingredients = ingredients;\n\n    }\n\n}\n'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'\n:import { NgModule } from \"@angular/core\";\n\nimport { RouterModule } from \"@angular/router\";\n\nimport { ReactiveFormsModule } from \"@angular/forms\";\n\n\n\nimport { RecipeDetailComponent } from \"./recipe-detail/recipe-detail.component\";\n\nimport { RecipeItemComponent } from \"./recipe-list/recipe-item/recipe-item.component\";\n\nimport { RecipeListComponent } from \"./recipe-list/recipe-list.component\";\n\nimport { RecipeStartComponent } from \"./recipe-start/recipe-start.component\";\n\nimport { RecipesComponent } from \"./recipes.component\";\n\nimport { RecipesRoutingModule } from \"./recipes-routing.module\";\n\nimport { RecipeEditComponent } from \"./recipe-edit/recipe-edit.component\";\n\nimport { SharedModule } from \"../shared/shared.module\";\n\n\n\n@NgModule({\n\n  declarations: [\n\n    RecipesComponent,\n\n    RecipeListComponent,\n\n    RecipeDetailComponent,\n\n    RecipeItemComponent,\n\n    RecipeStartComponent,\n\n    RecipeEditComponent\n\n  ],\n\n  imports: [\n\n    RouterModule,\n\n    ReactiveFormsModule,\n\n    RecipesRoutingModule,\n\n    SharedModule\n\n  ],\n\n  exports: [\n\n    RecipesComponent,\n\n    RecipeListComponent,\n\n    RecipeDetailComponent,\n\n    RecipeItemComponent,\n\n    RecipeStartComponent,\n\n    RecipeEditComponent\n\n  ]\n\n})\n\nexport class RecipesModule {\n\n\n\n}\n\n",
        "gt": [
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipe.model.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipe-detail/recipe-detail.component.ts'",
            "'angular-the-complete-guide-2023/project/src/app/recipes/recipes.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app-routing.module.ts'",
            "'angular-the-complete-guide-2023/project/src/app/app.module.ts'",
            "'angular-the-complete-guide-2023/project/src/main.ts'"
        ]
    },
    {
        "files": [
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/utils/dom.ts'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'"
        ],
        "content": "'extension/src/pages/overlay/components/overlay/Overlay.tsx'\n:import {\n  useEffect,\n  useRef,\n  useCallback,\n  useState,\n  useMemo,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\nimport Welcome from \"../../../../components/Welcome\";\nimport IconWelcome from \"../../../../components/icons/IconWelcome\";\nimport IconAmbassadors from \"../../../../components/icons/IconAmbassadors\";\nimport IconSettings from \"../../../../components/icons/IconSettings\";\n\nimport {\n  isAmbassadorKey,\n  type AmbassadorKey,\n} from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\nimport { visibleUnderCursor } from \"../../../../utils/dom\";\n\nimport useChatCommand from \"../../../../hooks/useChatCommand\";\n\nimport useSettings from \"../../hooks/useSettings\";\nimport useSleeping from \"../../hooks/useSleeping\";\n\nimport AmbassadorsOverlay from \"./Ambassadors\";\nimport SettingsOverlay from \"./Settings\";\n\nimport Buttons from \"../Buttons\";\n\n\nconst commandTimeout = 10_000;\n\nconst overlayOptions = [\n  {\n    key: \"welcome\",\n    type: \"primary\",\n    icon: IconWelcome,\n    title: \"Welcome to Alveus\",\n    component: (props: OverlayOptionProps) => (\n      <Welcome\n        className={classes(\"absolute left-0 top-0 mx-4 my-6\", props.className)}\n      />\n    ),\n  },\n  {\n    key: \"ambassadors\",\n    type: \"primary\",\n    icon: IconAmbassadors,\n    title: \"Explore our Ambassadors\",\n    component: AmbassadorsOverlay,\n  },\n  {\n    key: \"settings\",\n    type: \"secondary\",\n    icon: IconSettings,\n    title: \"Extension Settings\",\n    component: SettingsOverlay,\n  },\n] as const;\n\nexport const isValidOverlayKey = (key: string) =>\n  key === \"\" || overlayOptions.some((option) => option.key === key);\n\nexport type OverlayKey = (typeof overlayOptions)[number][\"key\"] | \"\";\n\ntype ActiveAmbassadorState = {\n  key?: AmbassadorKey;\n  isCommand?: boolean;\n};\n\nexport interface OverlayOptionProps {\n  context: {\n    activeAmbassador: ActiveAmbassadorState;\n    setActiveAmbassador: Dispatch<SetStateAction<ActiveAmbassadorState>>;\n  };\n  className?: string;\n}\n\nconst hiddenClass =\n  \"invisible opacity-0 -translate-x-10 motion-reduce:translate-x-0\";\n\nexport default function Overlay() {\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n  const [activeAmbassador, setActiveAmbassador] =\n    useState<ActiveAmbassadorState>({});\n  const [visibleOption, setVisibleOption] = useState<OverlayKey>(\n    settings.openedMenu.value,\n  );\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const awakingRef = useRef(false);\n\n\n  useEffect(() => {\n    settings.openedMenu.change(visibleOption);\n  }, [visibleOption]);\n\n\n  useEffect(() => {\n    setVisibleOption(settings.openedMenu.value);\n  }, [settings.openedMenu.value]);\n\n\n  useChatCommand(\n    useCallback(\n      (command: string) => {\n        if (!settings.disableChatPopup.value) {\n          if (isAmbassadorKey(command))\n            setActiveAmbassador({ key: command, isCommand: true });\n          else if (command !== \"welcome\") return;\n\n\n          setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n\n          if (timeoutRef.current) clearTimeout(timeoutRef.current);\n          timeoutRef.current = setTimeout(() => {\n            setVisibleOption(\"\");\n            setActiveAmbassador({});\n          }, commandTimeout);\n\n\n          awakingRef.current = true;\n          wake(commandTimeout);\n        }\n      },\n      [settings.disableChatPopup.value, wake],\n    ),\n  );\n\n\n  useEffect(\n    () => () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    },\n    [],\n  );\n\n\n\n  useEffect(() => {\n    const callback = () => {\n      if (awakingRef.current) awakingRef.current = false;\n      else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    };\n    addSleepListener(\"wake\", callback);\n    return () => removeSleepListener(\"wake\", callback);\n  }, [addSleepListener, removeSleepListener]);\n\n\n  const bodyClick = useCallback((e: MouseEvent) => {\n    if (!visibleUnderCursor(e)) {\n      setVisibleOption(\"\");\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"click\", bodyClick, true);\n    return () => document.body.removeEventListener(\"click\", bodyClick, true);\n  }, [bodyClick]);\n\n\n  const bodyDblClick = useCallback((e: MouseEvent) => {\n    if (visibleUnderCursor(e)) {\n      e.stopPropagation();\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n    return () =>\n      document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n  }, [bodyDblClick]);\n\n\n  const context = useMemo<OverlayOptionProps[\"context\"]>(\n    () => ({\n      activeAmbassador,\n      setActiveAmbassador,\n    }),\n    [activeAmbassador],\n  );\n\n  return (\n    <div\n      className={classes(\n        \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          ) &&\n          hiddenClass,\n      )}\n    >\n      <Buttons\n        options={overlayOptions}\n        onClick={setVisibleOption}\n        active={visibleOption}\n      />\n      <div className=\"relative h-full w-full\">\n        {overlayOptions.map((option) => (\n          <option.component\n            key={option.key}\n            context={context}\n            className={classes(\n              \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n              visibleOption !== option.key && hiddenClass,\n            )}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n'extension/src/utils/dom.ts'\n:\nexport function visibleUnderCursor(e: MouseEvent) {\n\n  const elements = document.elementsFromPoint(e.clientX, e.clientY);\n\n\n  for (const element of elements) {\n    if (element === document.body) break;\n\n\n    if (element instanceof HTMLElement && element.dataset.transparentClicks)\n      return element;\n\n    const style = getComputedStyle(element);\n    if (\n      style.backgroundImage !== \"none\" ||\n      style.backgroundColor !== \"rgba(0, 0, 0, 0)\"\n    ) {\n      return element;\n    }\n  }\n\n  return null;\n}\n\n\nexport function mutableDOMRect(rect: DOMRect) {\n  const mutable = DOMRect.fromRect(rect);\n  const props = {\n    x: rect.x,\n    y: rect.y,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    width: rect.width,\n    height: rect.height,\n  };\n  Object.entries(props).forEach(([key, value]) => {\n    Object.defineProperty(mutable, key, {\n      writable: true,\n      value,\n    });\n  });\n  return mutable as typeof rect & typeof props;\n}\n\n'extension/src/pages/overlay/components/overlay/Settings.tsx'\n:import { typeSafeObjectEntries } from \"../../../../utils/helpers\";\nimport { classes } from \"../../../../utils/classes\";\n\nimport useSettings from \"../../hooks/useSettings\";\n\nimport Card from \"../../../../components/Card\";\nimport Toggle from \"../Toggle\";\n\nimport type { OverlayOptionProps } from \"./Overlay\";\n\nexport default function Settings(props: OverlayOptionProps) {\n  const { className } = props;\n  const settings = useSettings();\n\n  return (\n    <Card\n      className={classes(\"absolute left-0 top-0 mx-4 my-6\", className)}\n      title=\"Extension Settings\"\n    >\n      <ul className=\"flex flex-col gap-4\">\n        {typeSafeObjectEntries(settings).map(([key, setting]) => {\n          if (!setting.configurable) return null;\n\n          return (\n            <li key={key} className=\"flex items-center\">\n              {setting.type === \"boolean\" && (\n                <Toggle\n                  label={setting.title}\n                  value={setting.value as boolean}\n                  onChange={setting.change as (value: boolean) => void}\n                />\n              )}\n            </li>\n          );\n        })}\n      </ul>\n    </Card>\n  );\n}\n",
        "gt": [
            "'extension/src/utils/dom.ts'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'",
            "'mean-rsvp-auth0/src/app/core/models/rsvp.model.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/core/core.module.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n\n'mean-rsvp-auth0/src/app/core/models/rsvp.model.ts'\n:export class RsvpModel {\n  constructor(\n    public userId: string,\n    public name: string,\n    public eventId: string,\n    public attending: boolean,\n    public guests?: number,\n    public comments?: string,\n    public _id?: string,\n  ) { }\n}\n\n'mean-rsvp-auth0/src/app/core/api.service.ts'\n:import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { AuthService } from './../auth/auth.service';\nimport { throwError as ObservableThrowError, Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { ENV } from './env.config';\nimport { EventModel } from './models/event.model';\nimport { RsvpModel } from './models/rsvp.model';\n\n@Injectable()\nexport class ApiService {\n  constructor(\n    private http: HttpClient,\n    private auth: AuthService\n  ) { }\n\n  private get _authHeader(): string {\n    return `Bearer ${this.auth.accessToken}`;\n  }\n\n\n  getEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events`)\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getAdminEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/admin`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getEventById$(id: string): Observable<EventModel> {\n    return this.http\n      .get<EventModel>(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getRsvpsByEventId$(eventId: string): Observable<RsvpModel[]> {\n    return this.http\n      .get<RsvpModel[]>(`${ENV.BASE_API}event/${eventId}/rsvps`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postEvent$(event: EventModel): Observable<EventModel> {\n    return this.http\n      .post<EventModel>(`${ENV.BASE_API}event/new`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editEvent$(id: string, event: EventModel): Observable<EventModel> {\n    return this.http\n      .put<EventModel>(`${ENV.BASE_API}event/${id}`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  deleteEvent$(id: string): Observable<any> {\n    return this.http\n      .delete(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getUserEvents$(userId: string): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/${userId}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postRsvp$(rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .post<RsvpModel>(`${ENV.BASE_API}rsvp/new`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editRsvp$(id: string, rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .put(`${ENV.BASE_API}rsvp/${id}`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n  private _handleError(err: HttpErrorResponse | any): Observable<any> {\n    const errorMsg = err.message || 'Error: Unable to complete request.';\n    if (err.message && err.message.indexOf('No JWT present') > -1) {\n      this.auth.login();\n    }\n    return ObservableThrowError(errorMsg);\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/core/core.module.ts'\n:import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { CommonModule } from '@angular/common';\nimport { HttpClientModule } from '@angular/common/http';\nimport { RouterModule } from '@angular/router';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { DatePipe } from '@angular/common';\nimport { ApiService } from './api.service';\nimport { UtilsService } from './utils.service';\nimport { FilterSortService } from './filter-sort.service';\nimport { SubmittingComponent } from './forms/submitting.component';\nimport { LoadingComponent } from './loading.component';\nimport { HeaderComponent } from './../header/header.component';\nimport { FooterComponent } from './../footer/footer.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    HttpClientModule,\n    RouterModule,\n    FormsModule,\n    ReactiveFormsModule\n  ],\n  declarations: [\n    HeaderComponent,\n    FooterComponent,\n    LoadingComponent,\n    SubmittingComponent\n  ],\n  exports: [\n    HttpClientModule,\n    RouterModule,\n    FormsModule,\n    ReactiveFormsModule,\n    HeaderComponent,\n    FooterComponent,\n    LoadingComponent,\n    SubmittingComponent\n  ]\n})\nexport class CoreModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: CoreModule,\n      providers: [\n        Title,\n        DatePipe,\n        ApiService,\n        UtilsService,\n        FilterSortService\n      ]\n    };\n  }\n}\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/models/rsvp.model.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/core/core.module.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'angular-16-complete-course/17-dynamic-components/start/src/app/routing.module.ts'",
            "'angular-16-complete-course/17-dynamic-components/start/src/app/Services/user.service.ts'",
            "'angular-16-complete-course/17-dynamic-components/start/src/main.ts'",
            "'angular-16-complete-course/17-dynamic-components/start/src/app/users/users.component.ts'",
            "'angular-16-complete-course/17-dynamic-components/start/src/app/app.module.ts'"
        ],
        "content": "'angular-16-complete-course/17-dynamic-components/start/src/app/routing.module.ts'\n:import { NgModule } from '@angular/core';\n\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { HomeComponent } from './home/home.component';\n\nimport { UsersComponent } from './users/users.component';\n\n\n\nconst routes: Routes = [\n\n    {path: '', component: HomeComponent},\n\n    {path: 'Home', component: HomeComponent},\n\n    {path: 'Users', component: UsersComponent}\n\n]\n\n\n\n@NgModule({\n\n    imports: [\n\n      RouterModule.forRoot(routes)\n\n    ],\n\n    exports: [RouterModule]\n\n})\n\n  export class RoutingModule { }\n'angular-16-complete-course/17-dynamic-components/start/src/app/Services/user.service.ts'\n:import { Injectable } from \"@angular/core\";\n\nimport { User } from \"../Models/User\";\n\n\n\n@Injectable({\n\n    providedIn: 'root'\n\n})\n\nexport class UserService{\n\n    users: User[] = [\n\n        new User(1, 'John Smith', 'Male', 'Yearly', 999, true),\n\n        new User(2, 'Mark Vought', 'Male', 'Monthly', 199, true),\n\n        new User(3, 'Sarah King', 'Female', 'Quaterly', 399, false),\n\n        new User(4, 'Merry Jane', 'Female', 'Yearly', 999, true),\n\n        new User(5, 'Jonas Fleming', 'Male', 'Monthly', 199, false)\n\n    ]\n\n}\n'angular-16-complete-course/17-dynamic-components/start/src/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-16-complete-course/17-dynamic-components/start/src/app/users/users.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { User } from '../Models/User';\nimport { UserService } from '../Services/user.service';\n\n@Component({\n  selector: 'app-users',\n  templateUrl: './users.component.html',\n  styleUrls: ['./users.component.css']\n})\nexport class UsersComponent implements OnInit {\n\n  constructor(private userService: UserService) {\n\n  }\n\n  users: User[] = [];\n\n  ngOnInit() {\n    this.users = this.userService.users;\n  }\n}\n\n'angular-16-complete-course/17-dynamic-components/start/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppComponent } from './app.component';\nimport { HomeComponent } from './home/home.component';\nimport { UsersComponent } from './users/users.component';\nimport { ConfirmDeleteComponent } from './users/confirm-delete/confirm-delete.component';\nimport { RoutingModule } from './routing.module';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HomeComponent,\n    UsersComponent,\n    ConfirmDeleteComponent\n  ],\n  imports: [\n    BrowserModule,\n    RoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule { }\n",
        "gt": [
            "'angular-16-complete-course/17-dynamic-components/start/src/app/Services/user.service.ts'",
            "'angular-16-complete-course/17-dynamic-components/start/src/app/users/users.component.ts'",
            "'angular-16-complete-course/17-dynamic-components/start/src/app/routing.module.ts'",
            "'angular-16-complete-course/17-dynamic-components/start/src/app/app.module.ts'",
            "'angular-16-complete-course/17-dynamic-components/start/src/main.ts'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/pages/event/event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/event/event.module.ts'",
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/pages/event/event.component.ts'\n:import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { AuthService } from './../../auth/auth.service';\nimport { ApiService } from './../../core/api.service';\nimport { UtilsService } from './../../core/utils.service';\nimport { ActivatedRoute } from '@angular/router';\nimport { Subscription } from 'rxjs';\nimport { EventModel } from './../../core/models/event.model';\n\n@Component({\n  selector: 'app-event',\n  templateUrl: './event.component.html',\n  styleUrls: ['./event.component.scss']\n})\nexport class EventComponent implements OnInit, OnDestroy {\n  pageTitle: string;\n  id: string;\n  loggedInSub: Subscription;\n  routeSub: Subscription;\n  tabSub: Subscription;\n  eventSub: Subscription;\n  event: EventModel;\n  loading: boolean;\n  error: boolean;\n  tab: string;\n  eventPast: boolean;\n\n  constructor(\n    private route: ActivatedRoute,\n    public auth: AuthService,\n    private api: ApiService,\n    public utils: UtilsService,\n    private title: Title\n  ) { }\n\n  ngOnInit() {\n    this.loggedInSub = this.auth.loggedIn$.subscribe(\n      loggedIn => {\n        this.loading = true;\n        if (loggedIn) {\n          this._routeSubs();\n        }\n      }\n    );\n  }\n\n  private _routeSubs() {\n\n    this.routeSub = this.route.params\n      .subscribe(params => {\n        this.id = params['id'];\n        this._getEvent();\n      });\n\n\n    this.tabSub = this.route.queryParams\n      .subscribe(queryParams => {\n        this.tab = queryParams['tab'] || 'details';\n      });\n  }\n\n  private _getEvent() {\n\n    this.eventSub = this.api\n      .getEventById$(this.id)\n      .subscribe(\n        res => {\n          this.event = res;\n          this._setPageTitle(this.event.title);\n          this.loading = false;\n          this.eventPast = this.utils.eventPast(this.event.endDatetime);\n        },\n        err => {\n          console.error(err);\n          this.loading = false;\n          this.error = true;\n          this._setPageTitle('Event Details');\n        }\n      );\n  }\n\n  private _setPageTitle(title: string) {\n    this.pageTitle = title;\n    this.title.setTitle(title);\n  }\n\n  ngOnDestroy() {\n    this.routeSub.unsubscribe();\n    this.tabSub.unsubscribe();\n    this.eventSub.unsubscribe();\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/event/event.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { EVENT_ROUTES } from './event.routes';\nimport { EventComponent } from './event.component';\nimport { EventDetailComponent } from './event-detail/event-detail.component';\nimport { RsvpComponent } from './rsvp/rsvp.component';\nimport { RsvpFormComponent } from './rsvp/rsvp-form/rsvp-form.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(EVENT_ROUTES)\n  ],\n  declarations: [\n    EventComponent,\n    EventDetailComponent,\n    RsvpComponent,\n    RsvpFormComponent\n  ]\n})\nexport class EventModule { }\n\n'mean-rsvp-auth0/src/app/core/models/event.model.ts'\n:class EventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDatetime: Date,\n    public endDatetime: Date,\n    public viewPublic: boolean,\n    public description?: string,\n    public _id?: string,\n  ) { }\n}\n\nclass FormEventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDate: string,\n    public startTime: string,\n    public endDate: string,\n    public endTime: string,\n    public viewPublic: boolean,\n    public description?: string\n  ) { }\n}\n\nexport { EventModel, FormEventModel };\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'",
            "'mean-rsvp-auth0/src/app/pages/event/event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/event/event.module.ts'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'",
            "'mean-rsvp-auth0/src/app/core/env.config.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.routes.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n\n'mean-rsvp-auth0/src/app/core/env.config.ts'\n:const _isDev = window.location.port.indexOf('4200') > -1;\nconst getHost = () => {\n  const protocol = window.location.protocol;\n  const host = window.location.host;\n  return `${protocol}\n};\nconst apiURI = _isDev ? 'http:\n\nexport const ENV = {\n  BASE_URI: getHost(),\n  BASE_API: apiURI\n};\n\n'mean-rsvp-auth0/src/app/core/api.service.ts'\n:import { Injectable } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { AuthService } from './../auth/auth.service';\nimport { throwError as ObservableThrowError, Observable } from 'rxjs';\nimport { catchError } from 'rxjs/operators';\nimport { ENV } from './env.config';\nimport { EventModel } from './models/event.model';\nimport { RsvpModel } from './models/rsvp.model';\n\n@Injectable()\nexport class ApiService {\n  constructor(\n    private http: HttpClient,\n    private auth: AuthService\n  ) { }\n\n  private get _authHeader(): string {\n    return `Bearer ${this.auth.accessToken}`;\n  }\n\n\n  getEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events`)\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getAdminEvents$(): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/admin`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getEventById$(id: string): Observable<EventModel> {\n    return this.http\n      .get<EventModel>(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getRsvpsByEventId$(eventId: string): Observable<RsvpModel[]> {\n    return this.http\n      .get<RsvpModel[]>(`${ENV.BASE_API}event/${eventId}/rsvps`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postEvent$(event: EventModel): Observable<EventModel> {\n    return this.http\n      .post<EventModel>(`${ENV.BASE_API}event/new`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editEvent$(id: string, event: EventModel): Observable<EventModel> {\n    return this.http\n      .put<EventModel>(`${ENV.BASE_API}event/${id}`, event, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  deleteEvent$(id: string): Observable<any> {\n    return this.http\n      .delete(`${ENV.BASE_API}event/${id}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  getUserEvents$(userId: string): Observable<EventModel[]> {\n    return this.http\n      .get<EventModel[]>(`${ENV.BASE_API}events/${userId}`, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  postRsvp$(rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .post<RsvpModel>(`${ENV.BASE_API}rsvp/new`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n\n  editRsvp$(id: string, rsvp: RsvpModel): Observable<RsvpModel> {\n    return this.http\n      .put(`${ENV.BASE_API}rsvp/${id}`, rsvp, {\n        headers: new HttpHeaders().set('Authorization', this._authHeader)\n      })\n      .pipe(\n        catchError((error) => this._handleError(error))\n      );\n  }\n\n  private _handleError(err: HttpErrorResponse | any): Observable<any> {\n    const errorMsg = err.message || 'Error: Unable to complete request.';\n    if (err.message && err.message.indexOf('No JWT present') > -1) {\n      this.auth.login();\n    }\n    return ObservableThrowError(errorMsg);\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'\n:import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { AuthService } from './../../../auth/auth.service';\nimport { ApiService } from './../../../core/api.service';\nimport { UtilsService } from './../../../core/utils.service';\nimport { ActivatedRoute } from '@angular/router';\nimport { Subscription } from 'rxjs';\nimport { EventModel } from './../../../core/models/event.model';\n\n@Component({\n  selector: 'app-update-event',\n  templateUrl: './update-event.component.html',\n  styleUrls: ['./update-event.component.scss']\n})\nexport class UpdateEventComponent implements OnInit, OnDestroy {\n  pageTitle = 'Update Event';\n  routeSub: Subscription;\n  eventSub: Subscription;\n  event: EventModel;\n  loading: boolean;\n  submitting: boolean;\n  error: boolean;\n  tabSub: Subscription;\n  tab: string;\n  private _id: string;\n\n  constructor(\n    private route: ActivatedRoute,\n    public auth: AuthService,\n    private api: ApiService,\n    public utils: UtilsService,\n    private title: Title\n  ) { }\n\n  ngOnInit() {\n    this.title.setTitle(this.pageTitle);\n\n\n    this.routeSub = this.route.params\n      .subscribe(params => {\n        this._id = params['id'];\n        this._getEvent();\n      });\n\n\n    this.tabSub = this.route.queryParams\n      .subscribe(queryParams => {\n        this.tab = queryParams['tab'] || 'edit';\n      });\n  }\n\n  private _getEvent() {\n    this.loading = true;\n\n    this.eventSub = this.api\n      .getEventById$(this._id)\n      .subscribe(\n        res => {\n          this.event = res;\n          this.loading = false;\n        },\n        err => {\n          console.error(err);\n          this.loading = false;\n          this.error = true;\n        }\n      );\n  }\n\n  ngOnDestroy() {\n    this.routeSub.unsubscribe();\n    this.tabSub.unsubscribe();\n    this.eventSub.unsubscribe();\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/admin.routes.ts'\n:import { Routes } from '@angular/router';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\n\nexport const ADMIN_ROUTES: Routes = [\n  {\n    path: '',\n    component: AdminComponent,\n  },\n  {\n    path: 'event/new',\n    component: CreateEventComponent\n  },\n  {\n    path: 'event/update/:id',\n    component: UpdateEventComponent\n  }\n];\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/env.config.ts'",
            "'mean-rsvp-auth0/src/app/core/api.service.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/update-event/update-event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.routes.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/pages/admin/create-event/create-event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.routes.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/pages/admin/create-event/create-event.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\n\n@Component({\n  selector: 'app-create-event',\n  templateUrl: './create-event.component.html',\n  styleUrls: ['./create-event.component.scss']\n})\nexport class CreateEventComponent implements OnInit {\n  pageTitle = 'Create Event';\n\n  constructor(private title: Title) { }\n\n  ngOnInit() {\n    this.title.setTitle(this.pageTitle);\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/admin.routes.ts'\n:import { Routes } from '@angular/router';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\n\nexport const ADMIN_ROUTES: Routes = [\n  {\n    path: '',\n    component: AdminComponent,\n  },\n  {\n    path: 'event/new',\n    component: CreateEventComponent\n  },\n  {\n    path: 'event/update/:id',\n    component: UpdateEventComponent\n  }\n];\n\n'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/pages/admin/create-event/create-event.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.routes.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'extension/src/pages/panel/components/Nav.tsx'",
            "'extension/src/components/icons/BaseIcon.tsx'",
            "'extension/src/components/Welcome.tsx'",
            "'extension/src/pages/panel/index.tsx'",
            "'extension/src/pages/panel/App.tsx'",
            "'extension/src/components/icons/IconAmazon.tsx'"
        ],
        "content": "'extension/src/pages/panel/components/Nav.tsx'\n:import { useState } from \"react\";\n\nimport alveus from \"../../../assets/alveus.png\";\n\nimport IconInfo from \"../../../components/icons/IconInfo\";\nimport Welcome from \"../../../components/Welcome\";\n\nimport Overlay from \"./Overlay\";\n\nexport default function Nav() {\n  const [showWelcome, setShowWelcome] = useState<boolean>(false);\n\n  return (\n    <nav className=\"bg-alveus-green/85 fixed inset-x-0 top-0 z-10 flex h-12 w-full items-center justify-start gap-3 px-4 shadow-lg backdrop-blur sm:justify-center\">\n      <img className=\"h-8 w-auto\" src={alveus} alt=\"Alveus Logo\" />\n      <h1 className=\"text-lg\">Alveus Ambassadors</h1>\n      <button\n        className=\"group -mr-2 ml-auto rounded-full p-2 sm:absolute sm:right-4 sm:ml-0\"\n        onClick={() => setShowWelcome(true)}\n        title=\"Info\"\n      >\n        <IconInfo\n          size={20}\n          className=\"outline-highlight rounded-full transition-[outline] group-hover:outline\"\n        />\n      </button>\n\n      <Overlay show={showWelcome} onClose={() => setShowWelcome(false)}>\n        <Welcome />\n      </Overlay>\n    </nav>\n  );\n}\n\n'extension/src/components/icons/BaseIcon.tsx'\n:import { type SVGProps, type ReactNode } from \"react\";\n\nexport type IconProps = SVGProps<SVGSVGElement> & {\n  size?: number | string;\n  className?: string;\n  alt?: string;\n};\n\nexport type BaseIconProps = IconProps & {\n  viewBox: string;\n  children: ReactNode | ReactNode[];\n};\n\nexport function BaseIcon({\n  size = 24,\n  alt = \"\",\n  children,\n  ...props\n}: BaseIconProps) {\n  return (\n    <svg\n      role=\"img\"\n      xmlns=\"http:\n      aria-label={alt}\n      width={size}\n      height={size}\n      {...props}\n    >\n      {children}\n    </svg>\n  );\n}\n\n'extension/src/components/Welcome.tsx'\n:import { useMemo } from \"react\";\n\nimport IconGlobe from \"./icons/IconGlobe\";\nimport IconAmazon from \"./icons/IconAmazon\";\nimport IconInstagram from \"./icons/IconInstagram\";\nimport IconTikTok from \"./icons/IconTikTok\";\nimport IconTwitter from \"./icons/IconTwitter\";\nimport IconPlay from \"./icons/IconPlay\";\nimport IconGitHub from \"./icons/IconGitHub\";\n\nimport useChannel from \"../hooks/useChannel\";\n\nimport Card from \"./Card\";\n\nconst socialClass =\n  \"transition-[color,transform] hover:scale-125 focus:scale-125 hover:text-highlight focus:text-highlight\";\n\ninterface WelcomeProps {\n  className?: string;\n}\n\nexport default function Welcome(props: WelcomeProps) {\n  const { className } = props;\n\n  const channel = useChannel();\n  const nonDefault = useMemo(\n    () => !channel || channel.toLowerCase() !== \"alveussanctuary\",\n    [channel],\n  );\n\n  return (\n    <Card className={className} title=\"Welcome to Alveus\">\n      <p className=\"mb-4 mt-2\">\n        Alveus Sanctuary is a 501(c)(3) non-profit organization that functions\n        as a wildlife sanctuary and as a virtual education center. These\n        non-releasable animals are educational ambassadors so viewers can learn\n        from and build a connection to them.\n      </p>\n\n      <ul className=\"mb-2 flex flex-wrap items-center justify-center gap-4\">\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Website\"\n          >\n            <IconGlobe size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Amazon Wishlist\"\n          >\n            <IconAmazon size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Instagram\"\n          >\n            <IconInstagram size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"TikTok\"\n          >\n            <IconTikTok size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Twitter\"\n          >\n            <IconTwitter size={32} />\n          </a>\n        </li>\n        {nonDefault && (\n          <li className={socialClass}>\n            <a\n              href=\"https:\n              rel=\"noreferrer\"\n              target=\"_blank\"\n              title=\"Live\"\n            >\n              <IconPlay size={32} />\n            </a>\n          </li>\n        )}\n      </ul>\n\n      <a\n        className=\"hover:text-highlight focus:text-highlight flex w-fit items-center justify-center gap-1 text-xs transition-colors\"\n        href=\"https:\n        rel=\"noreferrer\"\n        target=\"_blank\"\n      >\n        Contribute on GitHub\n        <IconGitHub size={16} />\n      </a>\n    </Card>\n  );\n}\n\n'extension/src/pages/panel/index.tsx'\n:import { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\nimport { bindTwitchAuth } from \"../../hooks/useTwitchAuth\";\n\nimport App from \"./App\";\n\nimport \"./globals.css\";\n\nbindTwitchAuth();\n\nconst root = createRoot(document.getElementById(\"root\") as HTMLElement);\n\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>,\n);\n\n'extension/src/pages/panel/App.tsx'\n:import Nav from \"./components/Nav\";\nimport Ambassadors from \"./components/Ambassadors\";\n\nfunction App() {\n  return (\n    <div className=\"relative h-full w-full\">\n      <Nav />\n      <Ambassadors />\n    </div>\n  );\n}\n\nexport default App;\n\n'extension/src/components/icons/IconAmazon.tsx'\n:import { BaseIcon, type IconProps } from \"./BaseIcon\";\n\n\nexport default function IconAmazon(props: IconProps) {\n  return (\n    <BaseIcon viewBox=\"0 0 448 512\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M257.2 162.7c-48.7 1.8-169.5 15.5-169.5 117.5 0 109.5 138.3 114 183.5 43.2 6.5 10.2 35.4 37.5 45.3 46.8l56.8-56S341 288.9 341 261.4V114.3C341 89 316.5 32 228.7 32 140.7 32 94 87 94 136.3l73.5 6.8c16.3-49.5 54.2-49.5 54.2-49.5 40.7-.1 35.5 29.8 35.5 69.1zm0 86.8c0 80-84.2 68-84.2 17.2 0-47.2 50.5-56.7 84.2-57.8v40.6zm136 163.5c-7.7 10-70 67-174.5 67S34.2 408.5 9.7 379c-6.8-7.7 1-11.3 5.5-8.3C88.5 415.2 203 488.5 387.7 401c7.5-3.7 13.3 2 5.5 12zm39.8 2.2c-6.5 15.8-16 26.8-21.2 31-5.5 4.5-9.5 2.7-6.5-3.8s19.3-46.5 12.7-55c-6.5-8.3-37-4.3-48-3.2-10.8 1-13 2-14-.3-2.3-5.7 21.7-15.5 37.5-17.5 15.7-1.8 41-.8 46 5.7 3.7 5.1 0 27.1-6.5 43.1z\"\n      />\n    </BaseIcon>\n  );\n}\n",
        "gt": [
            "'extension/src/components/icons/BaseIcon.tsx'",
            "'extension/src/components/icons/IconAmazon.tsx'",
            "'extension/src/components/Welcome.tsx'",
            "'extension/src/pages/panel/components/Nav.tsx'",
            "'extension/src/pages/panel/App.tsx'",
            "'extension/src/pages/panel/index.tsx'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/usage/track-usage.decorator.ts'",
            "'is-even/apps/backend/src/usage/usage.guard.ts'",
            "'is-even/apps/backend/src/usage/error/no-active-credit.error.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/app/app.controller.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'"
        ],
        "content": "'is-even/apps/backend/src/usage/track-usage.decorator.ts'\n:import { applyDecorators, UseGuards } from '@nestjs/common';\nimport { UsageGuard } from './usage.guard';\n\nexport function TrackUsage() {\n  return applyDecorators(UseGuards(UsageGuard));\n}\n\n'is-even/apps/backend/src/usage/usage.guard.ts'\n:import {\n  Injectable,\n  CanActivate,\n  ExecutionContext,\n  Inject,\n  HttpException,\n  HttpStatus,\n} from '@nestjs/common';\n\nimport { UsageService } from './usage.service';\n\nimport { InvalidApiKeyError } from './error/invalid-api-key.error';\nimport { NoActiveCreditError } from './error/no-active-credit.error';\nimport { UsedCreditError } from './error/used-credit.error';\n\n@Injectable()\nexport class UsageGuard implements CanActivate {\n  constructor(\n    @Inject(UsageService) private readonly usageService: UsageService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    try {\n      const request = context.switchToHttp().getRequest();\n      const apiKey = request.query.apiKey;\n\n      await this.usageService.charge(apiKey);\n\n      return true;\n    } catch (error) {\n      if (error instanceof InvalidApiKeyError) {\n        throw new HttpException('Invalid API Key', HttpStatus.BAD_REQUEST);\n      }\n\n      if (error instanceof NoActiveCreditError) {\n        throw new HttpException('No active credit', HttpStatus.BAD_REQUEST);\n      }\n\n      if (error instanceof UsedCreditError) {\n        throw new HttpException('Credit is fully used', HttpStatus.BAD_REQUEST);\n      }\n\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/usage/error/no-active-credit.error.ts'\n:export class NoActiveCreditError extends Error {\n  constructor(error) {\n    super(`No active credit available. ${error.message}`);\n  }\n}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/app/app.controller.ts'\n:import { BadRequestException, Controller, Get, Param } from '@nestjs/common';\nimport { ApiTags, ApiOkResponse, ApiBadRequestResponse } from '@nestjs/swagger';\n\nimport { TrackUsage } from '../usage/track-usage.decorator';\nimport { IsEvenDto } from './dto/is-even.dto';\n\n@Controller()\nexport class AppController {\n  @Get()\n  @ApiTags('health')\n  @ApiOkResponse({\n    description: 'Health check',\n  })\n  public check(): string {\n    return 'Ok';\n  }\n\n  @Get('/is-even/:number')\n  @TrackUsage()\n  @ApiTags('is-even')\n  @ApiOkResponse({\n    type: IsEvenDto,\n    description: 'Number parsed',\n  })\n  @ApiBadRequestResponse({\n    description: 'Bad request',\n  })\n  public async analyze(@Param('number') number: number): Promise<IsEvenDto> {\n    if (Number.isNaN(number)) {\n      throw new BadRequestException(`${number} is not a number`);\n    }\n\n    return {\n      isEven: number % 2 === 0,\n    };\n  }\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n",
        "gt": [
            "'is-even/apps/backend/src/usage/error/no-active-credit.error.ts'",
            "'is-even/apps/backend/src/usage/usage.guard.ts'",
            "'is-even/apps/backend/src/usage/track-usage.decorator.ts'",
            "'is-even/apps/backend/src/app/app.controller.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'Source-Engine-VSCode-Extension/src/language/ShaderParamCompletionItemProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/language/KvFormatter.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangKv.ts'",
            "'Source-Engine-VSCode-Extension/src/main.ts'"
        ],
        "content": "'Source-Engine-VSCode-Extension/src/language/ShaderParamCompletionItemProvider.ts'\n:import vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\nimport { shaderParams, internalTextures } from \"@sourcelib/vmt\";\nimport { KvPair } from \"../Kv\";\nimport { ShaderParam } from \"@sourcelib/vmt\";\nimport { getParentDocumentDirectory } from \"@sourcelib/fs\";\nimport { listFilesSync } from \"list-files-in-dir\";\nimport fs from \"fs\";\nimport path from \"path\";\n\n\nexport class ShaderParamCompletionItemProvider implements vscode.CompletionItemProvider {\n\n    public provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, cancellationToken: vscode.CancellationToken): vscode.CompletionList {\n\n        const kvDoc = KvDocument.from(document);\n        if (kvDoc == null)\n            return new vscode.CompletionList();\n        const kv = kvDoc.getKeyValueAt(position.line);\n\n        if (kv == null)\n            return new vscode.CompletionList();\n\n\n        if (kv.key.range.contains(position)) {\n            const suggestions = shaderParams.filter(p => p.name.includes(kv.key.content));\n            const completions = suggestions.map(s => {\n                const completion = new vscode.CompletionItem(s.name);\n                completion.insertText = s.name.substring(1);\n                if (s.description != null) {\n                    completion.documentation = new vscode.MarkdownString(s.description);\n                }\n\n                if (s.defaultCompletion != null) {\n                    completion.insertText += \" \" + s.defaultCompletion.toString();\n                } else if (s.type === \"string\" || s.type === \"texture\") {\n                    completion.insertText = new vscode.SnippetString(completion.insertText + \" \\\"${1}\\\"\");\n                }\n\n                if (s.type === \"texture\") {\n                    completion.command = { command: \"editor.action.triggerSuggest\", title: \"Re-trigger completions\" };\n                }\n\n                return completion;\n            });\n\n            return new vscode.CompletionList(completions);\n        }\n\n\n        if (kv.value.range.contains(position)) {\n            const param = shaderParams.find(p => p.name == kv.key.content);\n\n            const completions = new vscode.CompletionList();\n\n            if (param == null)\n                return new vscode.CompletionList();\n\n\n            this.completeDefault(completions, document, kv, param);\n            this.completeTexturePath(completions, document, kv, param);\n\n\n            return completions;\n\n        }\n\n        return new vscode.CompletionList();\n\n    }\n\n    completeDefault(completions: vscode.CompletionList, document: vscode.TextDocument, kv: KvPair, param: ShaderParam): void {\n        if (param.defaultCompletion == null)\n            return;\n        const completion = new vscode.CompletionItem(param.defaultCompletion.toString());\n        completion.detail = \"Default Completion\";\n        completion.kind = vscode.CompletionItemKind.Value;\n        completions.items.push(completion);\n    }\n\n    completeTexturePath(completions: vscode.CompletionList, document: vscode.TextDocument, kv: KvPair, param: ShaderParam): void {\n        if (param.type !== \"texture\" && document.uri.scheme !== \"file\")\n            return;\n\n        internalTextures.forEach(rt => {\n            const completion = new vscode.CompletionItem(rt);\n            completion.detail = \"Internal engine texture\";\n            completion.kind = vscode.CompletionItemKind.Keyword;\n            completions.items.push(completion);\n        });\n\n        const materialRoot = getParentDocumentDirectory(document.uri.fsPath, \"materials\");\n        if (materialRoot == null)\n            return;\n\n\n        if (fs.existsSync(path.join(materialRoot, kv.value + \".vtf\"))) {\n            return;\n        }\n\n        let cursorStartDir: string;\n        if (kv.value.content.endsWith(\"\\\\\") || kv.value.content.endsWith(\"/\")) {\n            cursorStartDir = kv.value.content;\n        } else {\n            cursorStartDir = path.dirname(kv.value.content);\n        }\n        const startDir = path.join(materialRoot, cursorStartDir);\n\n        if (!fs.existsSync(startDir))\n            return;\n\n        const textureFiles = listFilesSync(startDir, \"vtf\");\n        textureFiles.forEach(t => {\n            let filePath = t.substring(startDir.length);\n            if (filePath.startsWith(\"\\\\\") || filePath.startsWith(\"/\")) {\n                filePath = filePath.slice(1);\n            }\n            const filePathWithoutExtension = filePath.substring(0, filePath.length - 4).replace(\"\\\\\", \"/\");\n\n            const completion = new vscode.CompletionItem(filePathWithoutExtension);\n            completion.insertText = filePathWithoutExtension;\n            completion.detail = \"Texture Path\";\n            completion.kind = vscode.CompletionItemKind.File;\n            completion.preselect = true;\n            completions.items.push(completion);\n        });\n\n    }\n}\n\n'Source-Engine-VSCode-Extension/src/language/KvFormatter.ts'\n:\n\n\n'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'\n:\n\n\n\n\nimport * as shared from \"./Shared\";\nimport vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\n\nimport { ShaderParamCompletionItemProvider } from \"./ShaderParamCompletionItemProvider\";\nimport { ShaderParamHoverProvider } from \"./ShaderParamHoverProvider\";\nimport { ShaderParamColorsProvider } from \"./ShaderParamColorsProvider\";\nimport { VmtSemanticTokenProvider } from \"./VmtSemanticTokenProvider\";\n\n\nexport const selectorAll: ReadonlyArray<vscode.DocumentFilter> = [shared.filterVmtSaved, shared.filterVmtUnsaved];\n\nexport function init(context: vscode.ExtensionContext): void {\n\n    const vmtSemantics = vscode.languages.registerDocumentSemanticTokensProvider(selectorAll, new VmtSemanticTokenProvider(), KvDocument.tokenLegend);\n    const vmtCompletion = vscode.languages.registerCompletionItemProvider(selectorAll, new ShaderParamCompletionItemProvider(), \"$\", \"%\");\n    const vmtHover = vscode.languages.registerHoverProvider(selectorAll, new ShaderParamHoverProvider());\n    const vmtColors = vscode.languages.registerColorProvider(selectorAll, new ShaderParamColorsProvider());\n\n\n    context.subscriptions.push(vmtSemantics, vmtCompletion, vmtHover, vmtColors);\n}\n\n\n'Source-Engine-VSCode-Extension/src/language/LangKv.ts'\n:\n\n\n\n\n\n\nimport * as shared from \"./Shared\";\nimport * as vscode from \"vscode\";\nimport { KvTokensProviderBase } from \"./KvTokensProviderBase\";\n\nimport { KvSemanticProcessor, KvSemanticProcessorParams } from \"./KvSemanticProcessor\";\nimport KvDocument from \"./KvDocument\";\nimport { matrixRegExp } from \"@sourcelib/vmt\";\n\nexport const selectorAll: ReadonlyArray<vscode.DocumentFilter> = [ shared.filterKvSaved,\n    shared.filterKvUnsaved,\n    shared.filterSoundscriptSaved,\n    shared.filterSoundscriptUnsaved ];\n\nexport function init(context: vscode.ExtensionContext): void {\n    const kvTokenProvider = new KeyvalueSemanticTokensProvider();\n    const kvSemantics = vscode.languages.registerDocumentSemanticTokensProvider(selectorAll, kvTokenProvider, kvTokenProvider.legend);\n\n\n    context.subscriptions.push(kvSemantics, kvTokenProvider.diagnosticCollection);\n}\n\nexport class KeyvalueSemanticTokensProvider extends KvTokensProviderBase {\n\n    protected keyProcessors: KvSemanticProcessor[] = [];\n    protected valueProcessors: KvSemanticProcessor[] =\n    [\n        { regex: /^-?\\d+(\\.\\d+)?$/, processor: this.processValueNumber },\n        { regex: matrixRegExp, processor: this.processValueArray }\n    ];\n\n    constructor() {\n        super(KvDocument.tokenLegend, vscode.languages.createDiagnosticCollection(\"keyvalue\"));\n    }\n\n    processValueNumber(params: KvSemanticProcessorParams): boolean {\n        params.tokensBuilder.push(params.kvPiece.range, \"number\", []);\n        return true;\n    }\n\n    processValueArray(params: KvSemanticProcessorParams): boolean {\n\n        params.tokensBuilder.push(new vscode.Range(params.kvPiece.range.start, params.kvPiece.range.start.translate(0, 1)), \"operator\", []);\n        params.tokensBuilder.push(new vscode.Range(params.kvPiece.range.end.translate(0, -1), params.kvPiece.range.end), \"operator\", []);\n\n        params.tokensBuilder.push(new vscode.Range(params.kvPiece.range.start.translate(0, 1), params.kvPiece.range.end.translate(0, -1)), \"number\", []);\n        return true;\n    }\n\n}\n\n'Source-Engine-VSCode-Extension/src/main.ts'\n:\n\n\n\n\nimport * as vscode from \"vscode\";\nimport * as vmt from \"./language/LangVmt\";\nimport * as captions from \"./language/LangCaptions\";\nimport * as keyvalue from \"./language/LangKv\";\nimport * as captionsCompile from \"./compiler/captions-compile\";\nimport * as modelCompile from \"./compiler/model-compile\";\nimport * as performance from \"./performance\";\nimport * as kvDetect from \"./KvFileDetection\";\n\nimport * as packageJson from \"../package.json\";\n\nexport let output: vscode.OutputChannel;\nexport let debugOutput: vscode.OutputChannel;\nexport let config: vscode.WorkspaceConfiguration;\n\nexport function deactivate(): void {}\nexport function activate(context: vscode.ExtensionContext): void {\n\n    output = vscode.window.createOutputChannel(\"Source Engine Support\");\n    debugOutput = vscode.window.createOutputChannel(\"Source Engine Support Debug\");\n    context.subscriptions.push(output, debugOutput);\n\n    updateConfig();\n    const configChangeEvent = vscode.workspace.onDidChangeConfiguration(updateConfig);\n    context.subscriptions.push(configChangeEvent);\n\n    kvDetect.init(context);\n\n    keyvalue.init(context);\n    vmt.init(context);\n    captions.init(context);\n\n    captionsCompile.init(context);\n    modelCompile.init(context);\n\n    output.appendLine(`Started Source Engine Support v${packageJson.version}`);\n\n    performance.init(context);\n}\n\n\nconst updateConfig = () => config = vscode.workspace.getConfiguration(\"sourceEngine\");\n",
        "gt": [
            "'Source-Engine-VSCode-Extension/src/language/ShaderParamCompletionItemProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'",
            "'Source-Engine-VSCode-Extension/src/main.ts'",
            "'Source-Engine-VSCode-Extension/src/language/KvFormatter.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangKv.ts'"
        ]
    },
    {
        "files": [
            "'Approvals.NodeJS/lib/Approvals.ts'",
            "'Approvals.NodeJS/bin/index.ts'",
            "'Approvals.NodeJS/lib/Writers/BinaryWriter.ts'"
        ],
        "content": "'Approvals.NodeJS/lib/Approvals.ts'\n:\n\n\n\nimport callsite from \"callsite\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport * as cfg from \"./config\";\nimport { BinaryWriter } from \"./Writers/BinaryWriter\";\nimport { FileApprover } from \"./FileApprover\";\nimport { FinalMessages } from \"./FinalMessages\";\nimport { ManualNamer } from \"./ManualNamer\";\nimport { Namer } from \"./Core/Namer\";\nimport { ReporterFactory, ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { Scrubber, Scrubbers } from \"./Scrubbers/Scrubbers\";\nimport { StringWriter } from \"./StringWriter\";\nimport { Writer } from \"./Core/Writer\";\nimport { postRunCleanup } from \"./postRunCleanup\";\nimport { stringifyKeysInOrder } from \"./AUtils\";\n\n\n\nimport { MochaNamer } from \"./Providers/Mocha/MochaNamer\";\n\nimport { beforeEachVerifierBase } from \"./Providers/BeforeEachVerifierBase\";\n\n\nexport { Scrubbers as scrubbers };\n\nif (typeof beforeEach === \"function\") {\n  beforeEach(function (): void {\n    if (!this) {\n      return;\n    }\n    this.verify = function () {\n      throw new Error(\"You must call either .mocha()\");\n    };\n  });\n}\n\n\nconst listOfApprovedFiles: string[] = [];\nprocess.on(\"approvalFileApproved\", function (fileName): void {\n  if (listOfApprovedFiles.indexOf(fileName) === -1) {\n    listOfApprovedFiles.push(fileName);\n  }\n});\n\nprocess.on(\"exit\", function (): void {\n  const options = cfg.currentConfig();\n  postRunCleanup(options, listOfApprovedFiles);\n  const finalMessages = FinalMessages.getMessages();\n  if (finalMessages.length) {\n    console.log(\"******************************\");\n    console.log(\"* Approvals Report: WARNING!\");\n    finalMessages.forEach((message: string) => {\n      console.log(`*  - ${message}`);\n    });\n    console.log(\"******************************\");\n  }\n});\n\n\nexport function configure(overrideOptions: cfg.Config): typeof module.exports {\n  cfg.configure(overrideOptions);\n  return module.exports;\n}\n\n\nexport function getConfig(overrideOptions?: cfg.Config): cfg.Config {\n  return cfg.getConfig(overrideOptions);\n}\n\n\n\nexport function mocha(optionalBaseDir?: string): typeof module.exports {\n\n  if (!optionalBaseDir) {\n      let fileName = callsite()[1].getFileName();\n      if (fileName.startsWith(\"file:\n          fileName = fileURLToPath(fileName);\n      }\n      optionalBaseDir = path.dirname(fileName);\n  }\n  beforeEachVerifierBase(\n    MochaNamer,\n    \"require('Approvals').mocha();\",\n    optionalBaseDir,\n  );\n\n  return module.exports;\n}\n\nfunction jasmineExport(): void {\n  throw new Error(\n    \"Aww shucks.\\n\\nApprovals support of Jasmine has been completely yanked out (don't shoot). \\n\\n Jasmine has grown quite complicated (behind our back) and we haven't had enough time to figure out a solid integration pattern... for now it's support has been removed.\\n\\n Check out the docs for manual usage of approval tests to work around the missing Jasmine integration (it should be a straightforward change for you, really).\\n\\n We'll consider bringing it back if we can get someone with interest in submitting a pull request that can bring it back...\",\n  );\n}\n\n\n\nexport const reporters: { MultiReporter: any } = {\n\n  MultiReporter: require(\"./Reporting/Reporters/multiReporter\").default,\n};\n\n\nfunction verifyAndScrub(\n  dirName: string,\n  testName: string,\n  data: BinaryWriter | string,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  scrubber = scrubber || Scrubbers.noScrubber;\n\n\n  if (Array.isArray(optionsOverride)) {\n    optionsOverride = {\n      reporters: optionsOverride,\n    };\n    const stringReporters = JSON.stringify(optionsOverride.reporters);\n    console.error(\n      'For the last arg of the approvals.verify(...) function, if you passed in an array of reporters, something like [\"opendiff\",\"nodediff\"], this has been deprecated and replaced by passing in a config object. Please re-evaluate if you can remove this parameter alltogether and use individual user configs in ~/.approvalConfig, if not then replace this: ' +\n        stringReporters +\n        \" with this { reporters: \" +\n        stringReporters +\n        \"}.\",\n    );\n  }\n\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const namer = new ManualNamer(dirName, testName);\n\n  let writer: Writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data as string);\n\n    writer = new StringWriter(newOptions, data as string);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}\n\n\nexport function verify(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride?: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n\nexport function verifyAsJSON(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride: any,\n) {\n  return verifyAsJSONAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n\n\nexport function verifyAsJSONAndScrub(\n  dirName: string,\n  testName: string,\n  data: any,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    stringifyKeysInOrder(data),\n    scrubber,\n    optionsOverride,\n  );\n}\n\n\n\nexport function verifyWithControl(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory?: ReporterLoader | null,\n  optionsOverride?: Partial<cfg.Config>,\n) {\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const loader =\n    (reporterFactory as ReporterLoader) ||\n    function () {\n      return [ReporterFactory.loadReporter(newOptions.reporters)];\n    };\n\n  FileApprover.verify(namer, writer, loader, newOptions);\n}\n\n'Approvals.NodeJS/bin/index.ts'\n:#!/usr/bin/env ts-node\nimport es from \"event-stream\";\nimport * as autils from \"../lib/AUtils\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport marked from \"marked\";\nimport TerminalRenderer from \"marked-terminal\";\nimport minimist from \"minimist\";\nimport { configure, verify } from \"../lib/Approvals\";\nimport { redText } from \"../lib/Utilities/ConsoleUtils\";\n\nconst verbose = process.argv.includes(\"--verbose\");\nconst printHelp = process.argv.includes(\"--help\");\n\nfunction printHelpMessage() {\n  if (verbose) {\n    console.log(\"printing help...\");\n  }\n\n  const helpFile = fs.readFileSync(path.join(__dirname, \"help.md\"), \"utf8\");\n  marked.setOptions({\n    renderer: new TerminalRenderer(),\n  });\n  let output = marked.parse(helpFile) as string;\n\n  output = output.replace(/&nbsp;/g, \" \");\n  console.log(output);\n}\n\nfunction errAndExit(msg: string): void {\n  printHelpMessage();\n  console.log(redText(msg));\n  process.exit(1);\n}\n\nif (printHelp) {\n  printHelpMessage();\n  process.exit();\n}\n\nif (verbose) {\n  console.log(\"process.argv: \", process.argv);\n}\n\nconst argv = minimist(process.argv.slice(2), {\n  alias: {\n    reporters: [\"r\"],\n  },\n  boolean: [\"verbose\"],\n});\n\nif (verbose) {\n  console.log(\"parsed args: \", argv);\n}\n\nlet reporters = argv.reporter as string | string[];\nif (typeof reporters === \"string\") {\n  reporters = [reporters];\n}\n\nconst testname = argv._[0];\nif (!testname) {\n  errAndExit(\n    'Missing parameter: supply a test name ex: echo \"hello\" | approvals myFirstTest. This will become the file name myFirstTest.approved.txt in the current directory',\n  );\n}\n\nconst outdir = argv.outdir || process.cwd();\nif (!fs.existsSync(outdir)) {\n  errAndExit(\"Directory not found: \" + outdir);\n}\n\nconst errorOnStaleApprovedFiles = argv.errorOnStaleApprovedFiles === \"true\";\n\nif (verbose) {\n  console.log(\"outdir: \", outdir);\n  console.log(\"errorOnStaleApprovedFiles: \", errorOnStaleApprovedFiles);\n  console.log(\"testname: \", testname);\n  console.log(\n    \"reporters: \",\n    reporters ||\n      \"undefined (but will fallback to approvals preconfigure defaults)\",\n  );\n}\n\nconst opts: any = {};\nif (reporters) {\n  opts.reporters = reporters;\n}\nopts.errorOnStaleApprovedFiles = errorOnStaleApprovedFiles;\n\nif (verbose) {\n  console.log(\"approval opts: \", opts);\n}\n\nopts.forceApproveAll =\n  autils.hasCommandLineArgument(\"--forceapproveall\") ||\n  autils.hasCommandLineArgument(\"-f\");\n\nprocess.stdin.pipe(\n  es.mapSync((data: Buffer) => {\n    const dataToVerify = data.toString();\n    configure(opts);\n    verify(outdir, testname, dataToVerify);\n  }),\n);\n\n'Approvals.NodeJS/lib/Writers/BinaryWriter.ts'\n:import * as fs from \"fs\";\nimport * as path from \"path\";\nimport mkdirp from \"mkdirp\";\nimport fileType from \"file-type\";\n\ninterface Config {\n\n  [key: string]: any;\n}\n\nexport class BinaryWriter {\n  private config: Config;\n  private outputData: Buffer;\n  private _ext?: string;\n\n  constructor(config: Config, outputData: Buffer) {\n    this.config = config;\n    this.outputData = outputData;\n  }\n\n  getFileExtension(): string {\n    if (!this._ext) {\n      const fileTypeDiscovered = fileType(this.outputData);\n      this._ext = fileTypeDiscovered?.ext || \"blob\";\n    }\n    return this._ext;\n  }\n\n  write(filePath: string): void {\n    const dir = path.dirname(path.normalize(filePath));\n    if (!fs.existsSync(dir)) {\n      mkdirp.sync(dir);\n    }\n\n    fs.writeFileSync(filePath, this.outputData);\n  }\n}\n",
        "gt": [
            "'Approvals.NodeJS/lib/Writers/BinaryWriter.ts'",
            "'Approvals.NodeJS/lib/Approvals.ts'",
            "'Approvals.NodeJS/bin/index.ts'"
        ]
    },
    {
        "files": [
            "'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/main.ts'",
            "'Source-Engine-VSCode-Extension/src/language/ShaderParamHoverProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'"
        ],
        "content": "'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'\n:import vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\nimport { KvTokensProviderBase } from \"./KvTokensProviderBase\";\nimport { getColorMatches, ColorMatchParenthesisType, getMatrixMatches } from \"@sourcelib/vmt\";\nimport { getParentDocumentDirectory } from \"@sourcelib/fs\";\nimport { Token, isFloatValue, isScalarValue } from \"@sourcelib/kv\";\nimport { shaderParams, internalTextures } from \"@sourcelib/vmt\";\nimport { KvSemanticProcessor, KvSemanticProcessorParams } from \"./KvSemanticProcessor\";\nimport { KvPair } from \"../Kv\";\nimport * as main from \"../main\";\nimport fs from \"fs\";\nimport path from \"path\";\n\n\nexport class VmtSemanticTokenProvider extends KvTokensProviderBase {\n\n    protected keyProcessors: KvSemanticProcessor[] = [\n        { regex: /\\$\\w+/, processor: this.processKeyShader },\n        { regex: /%\\w+/, processor: this.processKeyCompile }\n    ];\n\n    protected valueProcessors: KvSemanticProcessor[] = [\n        { regex: /.*/, processor: this.processValue }\n    ];\n\n    constructor() {\n        super(KvDocument.tokenLegend, vscode.languages.createDiagnosticCollection(\"vmt\"));\n    }\n\n    processKeyShader(params: KvSemanticProcessorParams): boolean {\n        params.tokensBuilder.push(params.wholeRange, \"parameter\");\n        return true;\n    }\n\n    processKeyCompile(params: KvSemanticProcessorParams): boolean {\n        params.tokensBuilder.push(params.wholeRange, \"parameter\", [\"readonly\"]);\n        return true;\n    }\n\n    processValue(params: KvSemanticProcessorParams): boolean {\n\n\n        if (!params.kvPiece.range.isSingleLine)\n            return false;\n\n\n        const kv = params.kvDocument.getKeyValueAt(params.kvPiece.range.start.line);\n        if (kv == null)\n            return false;\n        const param = shaderParams.find(p => p.name === kv.key.content);\n        if (param == null) {\n            this.processValueString(kv, params.wholeRange, params.tokensBuilder, params.kvDocument);\n            return false;\n        }\n        if (param.type == null || param.type == \"unknown\")\n            return false;\n\n\n        switch (param.type) {\n        case \"bool\": this.processValueBool(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"int\": this.processValueInt(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"float\": this.processValueFloat(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"scalar\": this.processValueScalar(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"texture\": this.processValueTexture(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"color\": this.processValueColor(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"matrix\": this.processValueMatrix(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"env_cubemap\": this.processValueCubemap(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n\n        case \"string\":\n        default: this.processValueString(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        }\n        return true;\n    }\n\n    processValueBool(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (kv.value.content.match(/^[01]$/)) {\n            tokensBuilder.push(range, \"boolean\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a boolean (0 or 1).\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueInt(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (kv.value.content.match(/^\\d+$/)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting an integer.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueFloat(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (isFloatValue(kv.value.content)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a float.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueScalar(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (isScalarValue(kv.value.content)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a scalar. (0-1)\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueString(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        tokensBuilder.push(range, \"string\");\n    }\n\n    processValueTexture(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n        if (internalTextures.includes(kv.value.content)) {\n            tokensBuilder.push(range, \"keyword\");\n            return;\n        }\n        const validationEnabled = main.config.get<boolean>(\"vmt.validateTexturePaths\");\n        if(validationEnabled) {\n            const materialDir = getParentDocumentDirectory(kvDoc.document.uri.fsPath, \"materials\");\n            if (materialDir != null) {\n                const materialPath: string = path.join(materialDir, kv.value.content + \".vtf\");\n                if (!fs.existsSync(materialPath)) {\n                    this.diagnostics.push(new vscode.Diagnostic(range, \"Texture not found on disk\", vscode.DiagnosticSeverity.Warning));\n                }\n            }\n        }\n\n        tokensBuilder.push(range, \"string\");\n    }\n\n    processValueMatrix(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n\n        const matrixMatches = getMatrixMatches(kv.value.content);\n        if (!matrixMatches.validFormat) {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Invalid matrix format.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueColor(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n\n        const colorMatches = getColorMatches(kv.value.content);\n        if (!colorMatches.validFormat) {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Invalid color value. Format: [0 0.25 1] or {0 200 49}\", vscode.DiagnosticSeverity.Warning));\n            return;\n        }\n        if (colorMatches.valuesOutOfBounds) {\n            if (colorMatches.parenthesisType === ColorMatchParenthesisType.Brackets) {\n                this.diagnostics.push(new vscode.Diagnostic(range, \"Color values out of bounds. Must be between 0 and 1\", vscode.DiagnosticSeverity.Warning));\n            } else if (colorMatches.parenthesisType === ColorMatchParenthesisType.Braces) {\n                this.diagnostics.push(new vscode.Diagnostic(range, \"Color values out of bounds. Must be between 0 and 255\", vscode.DiagnosticSeverity.Warning));\n            }\n        }\n    }\n\n    processValueCubemap(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n        if (kv.value.content === \"env_cubemap\") {\n            tokensBuilder.push(range, \"keyword\");\n        } else {\n            tokensBuilder.push(range, \"string\");\n        }\n\n    }\n\n    protected override disallowDuplicate(scopedKey: string, depth: number, token: Token): boolean {\n        return depth === 1;\n    }\n}\n\n'Source-Engine-VSCode-Extension/src/main.ts'\n:\n\n\n\n\nimport * as vscode from \"vscode\";\nimport * as vmt from \"./language/LangVmt\";\nimport * as captions from \"./language/LangCaptions\";\nimport * as keyvalue from \"./language/LangKv\";\nimport * as captionsCompile from \"./compiler/captions-compile\";\nimport * as modelCompile from \"./compiler/model-compile\";\nimport * as performance from \"./performance\";\nimport * as kvDetect from \"./KvFileDetection\";\n\nimport * as packageJson from \"../package.json\";\n\nexport let output: vscode.OutputChannel;\nexport let debugOutput: vscode.OutputChannel;\nexport let config: vscode.WorkspaceConfiguration;\n\nexport function deactivate(): void {}\nexport function activate(context: vscode.ExtensionContext): void {\n\n    output = vscode.window.createOutputChannel(\"Source Engine Support\");\n    debugOutput = vscode.window.createOutputChannel(\"Source Engine Support Debug\");\n    context.subscriptions.push(output, debugOutput);\n\n    updateConfig();\n    const configChangeEvent = vscode.workspace.onDidChangeConfiguration(updateConfig);\n    context.subscriptions.push(configChangeEvent);\n\n    kvDetect.init(context);\n\n    keyvalue.init(context);\n    vmt.init(context);\n    captions.init(context);\n\n    captionsCompile.init(context);\n    modelCompile.init(context);\n\n    output.appendLine(`Started Source Engine Support v${packageJson.version}`);\n\n    performance.init(context);\n}\n\n\nconst updateConfig = () => config = vscode.workspace.getConfiguration(\"sourceEngine\");\n\n'Source-Engine-VSCode-Extension/src/language/ShaderParamHoverProvider.ts'\n:import vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\nimport { shaderParams } from \"@sourcelib/vmt\";\n\n\nexport class ShaderParamHoverProvider implements vscode.HoverProvider {\n\n    provideHover(document: vscode.TextDocument, position: vscode.Position, token: vscode.CancellationToken): vscode.Hover | null {\n\n        const kvDoc = KvDocument.from(document);\n        if (kvDoc == null)\n            return null;\n        const kv = kvDoc.getKeyValueAt(position.line);\n\n        if (kv == null)\n            return null;\n\n        const param = shaderParams.find(p => p.name == kv.key.content);\n        if (param == null)\n            return null;\n        const name = param.name;\n        const defaultCompletion = param.defaultCompletion;\n        const description = param.description;\n        const uri = param.wikiUri;\n\n        if (kv.key.range.contains(position) && kv.key.content !== \"\") {\n            let hoverText = `(Shader Parameter) **${name}** [${param.type}] ${defaultCompletion != null ? (\"- Default: \" + defaultCompletion) : \"\"}`;\n            if (description != null)\n                hoverText += `\\n\\n${description}`;\n            if (uri != null)\n                hoverText += `\\n\\n[Wiki](${uri})`;\n\n            return new vscode.Hover(hoverText, kv.key.range);\n        }\n\n        if (kv.value.range.contains(position) && kv.value.content !== \"\") {\n            if (param.type === \"env_cubemap\" && kv.value.content === \"env_cubemap\") {\n                return new vscode.Hover(\"Internal Texture, Samples the environment cubemap.\");\n            }\n        }\n\n\n        return null;\n    }\n\n}\n\n'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'\n:\n\n\n\n\nimport * as shared from \"./Shared\";\nimport vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\n\nimport { ShaderParamCompletionItemProvider } from \"./ShaderParamCompletionItemProvider\";\nimport { ShaderParamHoverProvider } from \"./ShaderParamHoverProvider\";\nimport { ShaderParamColorsProvider } from \"./ShaderParamColorsProvider\";\nimport { VmtSemanticTokenProvider } from \"./VmtSemanticTokenProvider\";\n\n\nexport const selectorAll: ReadonlyArray<vscode.DocumentFilter> = [shared.filterVmtSaved, shared.filterVmtUnsaved];\n\nexport function init(context: vscode.ExtensionContext): void {\n\n    const vmtSemantics = vscode.languages.registerDocumentSemanticTokensProvider(selectorAll, new VmtSemanticTokenProvider(), KvDocument.tokenLegend);\n    const vmtCompletion = vscode.languages.registerCompletionItemProvider(selectorAll, new ShaderParamCompletionItemProvider(), \"$\", \"%\");\n    const vmtHover = vscode.languages.registerHoverProvider(selectorAll, new ShaderParamHoverProvider());\n    const vmtColors = vscode.languages.registerColorProvider(selectorAll, new ShaderParamColorsProvider());\n\n\n    context.subscriptions.push(vmtSemantics, vmtCompletion, vmtHover, vmtColors);\n}\n\n",
        "gt": [
            "'Source-Engine-VSCode-Extension/src/language/ShaderParamHoverProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'",
            "'Source-Engine-VSCode-Extension/src/main.ts'",
            "'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'"
        ]
    },
    {
        "files": [
            "'meditations/src/habits/containers/HabitsRoot.tsx'",
            "'meditations/src/index.tsx'",
            "'meditations/src/habits/main.tsx'"
        ],
        "content": "'meditations/src/habits/containers/HabitsRoot.tsx'\n:import * as React from \"react\";\nimport HTML5Backend from \"react-dnd-html5-backend\";\nimport moment from \"moment\";\n\nimport * as common from \"../../common\";\nimport { MOUNT_NEXT_DAY_TIME } from \"../../common/constants\";\nimport { HabitsState, Scope } from \"../state\";\nimport { CommonUI } from \"../../common/components/CommonUI\";\nimport { Spinner } from \"../../common/components/Spinner\";\n\nimport { HabitsControlBar } from \"../components/HabitsControlBar\";\nimport { TimeScope } from \"../components/TimeScope\";\nimport { ProjectScope } from \"../components/ProjectScope\";\nimport { ProjectList } from \"../components/ProjectList\";\nimport { DndProvider } from \"react-dnd\";\n\nexport const HabitsRoot = common.connect()(\n  class extends React.Component<HabitsState> {\n\n    renderTimeScope(s?: Scope, i?: number) {\n      if (s) {\n\n        return (\n          <TimeScope\n            currentProject={this.props.currentProject}\n            key={i}\n            currentDate={this.props.currentDate}\n            scope={s}\n            filter={this.props.filter}\n            lastModifiedTask={this.props.lastModifiedTask}\n            mostRecentDay={i !== undefined && i === 0 ? true : false}\n          />\n        );\n      }\n      return <Spinner />;\n    }\n\n\n    renderProjects() {\n      if (this.props.currentProject === 0) {\n        return (\n          <ProjectList\n            hiddenProjects={this.props.hiddenProjects}\n            pinnedProjects={this.props.pinnedProjects}\n            unpinnedProjects={this.props.unpinnedProjects}\n            projectStatsDays={this.props.projectStatsDays}\n          />\n        );\n      }\n\n      if (\n        this.props.project &&\n        this.props.currentProject === this.props.project.Scope\n      ) {\n        return (\n          <ProjectScope\n            currentDate={this.props.currentDate}\n            scope={this.props.project}\n            projectStatsDays={this.props.projectStatsDays}\n          />\n        );\n      }\n\n\n      return <Spinner />;\n    }\n\n    renderDays() {\n      let { days } = this.props;\n\n      const today = moment();\n\n      if (\n        this.props.currentDate.month() === today.month() &&\n        this.props.currentDate.year() === today.year()\n      ) {\n\n\n\n\n\n        days = days.filter(\n          (d, i) =>\n            i === days.length ||\n\n            d.Date.date() <= today.date() ||\n            (d.Date.date() === today.date() + 1 &&\n              today.hour() > 24 - MOUNT_NEXT_DAY_TIME)\n        );\n      }\n\n      return days.map((d, i) => this.renderTimeScope(d, i));\n    }\n\n    render() {\n      return (\n        <div id=\"habits-root-sub\">\n          <DndProvider backend={HTML5Backend}>\n            <CommonUI {...this.props}>\n              <HabitsControlBar {...this.props} />\n              <div className=\"d-flex flex-column flex-md-row\">\n                <div id=\"scope-days\" className=\"scope-column mr-md-1\">\n                  {this.props.days ? this.renderDays() : <Spinner />}\n                </div>\n                <div id=\"scope-month\" className=\"scope-column mr-md-1\">\n                  {this.renderTimeScope(this.props.month)}\n                </div>\n                <div id=\"scope-year\" className=\"scope-column mr-md-1\">\n                  {this.renderTimeScope(this.props.year)}\n                </div>\n                <div id=\"scope-projects\" className=\"scope-column\">\n                  {this.props.pinnedProjects ? (\n                    this.renderProjects()\n                  ) : (\n                    <Spinner />\n                  )}\n                </div>\n              </div>\n            </CommonUI>\n          </DndProvider>\n        </div>\n      );\n    }\n  }\n);\n\n'meditations/src/index.tsx'\n:\n\nimport { main as habitsMain } from './habits/main';\nimport { main as journalMain } from './journal/main';\n\n\n\nimport './style/shared.css';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const { pathname } = window.location;\n  if (pathname === '/habits') {\n    habitsMain();\n  } else if (pathname === '/journal') {\n    journalMain();\n  } else if (pathname === '/') {\n\n    location.href = '/habits';\n  } else {\n    console.error('path not found');\n  }\n});\n\n'meditations/src/habits/main.tsx'\n:\n\nimport * as React from \"react\";\nimport moment from \"moment\";\nimport route from \"riot-route\";\nimport { reverse, rangeRight } from \"lodash\";\n\nimport * as common from \"../common\";\n\nimport {\n  ScopeType,\n  Project,\n  Task,\n  store,\n  dispatch,\n  HabitsState,\n  dispatchProjectListUpdate\n} from \"./state\";\nimport { HabitsRoot } from \"./containers/HabitsRoot\";\n\n\nexport const routeForView = (\n  date: moment.Moment | \"current\",\n  project?: number\n) => {\n\n  return `view/${\n    date === \"current\" ? date : date.format(common.MONTH_FORMAT)\n    }/${project ? project : 0}`;\n};\n\n\nexport const urlForView = (\n  date: moment.Moment | \"current\",\n  project?: number\n) => {\n  return `#${routeForView(date, project)}`;\n};\n\nexport const dispatchProjectUpdate = (id: number, days: number) => {\n  dispatch(dispatch => {\n    common.get(`/habits/project/${id}/${days}`, (response: Project) => {\n      dispatch({\n        type: \"UPDATE_PROJECT\",\n        project: response\n      });\n    });\n  });\n};\n\n\nexport const main = () => {\n\n  common.installRouter(\n    \"/habits#\",\n    `view/${moment().format(common.MONTH_FORMAT)}/0`,\n    {\n      no_action: () => {\n        route(routeForView(moment(), 0));\n      },\n      habits: () => { },\n      view: (datestr: string, scopestr: string) => {\n        const state = store.getState() as HabitsState;\n        const project = parseInt(scopestr, 10);\n\n\n\n\n        if (datestr === \"current\") {\n          route(routeForView(state.currentDate, project), \"?\", true);\n        }\n\n        if (state === undefined) return;\n        const date =\n          datestr === \"current\"\n            ? state.currentDate\n            : moment(datestr, common.MONTH_FORMAT);\n\n\n\n\n\n\n        if (state === undefined) return;\n        const prevDate = state.currentDate;\n        const prevProject = state.currentProject;\n\n        let timeChanged: \"NO_CHANGE\" | \"CHANGE_YEAR\" | \"CHANGE_MONTH\" =\n          \"NO_CHANGE\";\n\n        if (state.mounted === false) {\n\n          timeChanged = \"CHANGE_YEAR\";\n        } else if (\n          date.format(common.DAY_FORMAT) !== prevDate.format(common.DAY_FORMAT)\n        ) {\n\n          timeChanged = \"CHANGE_MONTH\";\n          if (date.year() !== prevDate.year()) {\n            timeChanged = \"CHANGE_YEAR\";\n          }\n        }\n\n        const projectChanged = prevProject !== project;\n\n        common.setTitle(\"Habits\", `${date.format(\"MMMM YYYY\")}`);\n        dispatch({ date, type: \"CHANGE_ROUTE\", currentProject: project });\n\n\n        if (timeChanged === \"CHANGE_YEAR\" || timeChanged === \"CHANGE_MONTH\") {\n          dispatch(dispatch => {\n            const qs = `/habits/in-month-and-days?date=${date.format(\n              common.DAY_FORMAT\n            )}`;\n            common.get(qs, (response: { Days: Task[]; Month: Task[] }) => {\n\n              const array = rangeRight(date.daysInMonth()).map((_, i) => ({\n                Date: moment(date)\n                  .clone()\n                  .date(i + 1)\n                  .format(common.DAY_FORMAT),\n                Tasks: [] as Task[]\n              }));\n\n              response.Days.forEach(t => {\n                common.processModel(t);\n                array[t.Date.date() - 1].Tasks.push(t);\n              });\n\n              response.Month.forEach(common.processModel);\n\n              dispatch({\n                date,\n                type: \"MOUNT_DAYS_AND_SCOPE\",\n                days: reverse(array),\n                scope: ScopeType.MONTH,\n                tasks: response.Month\n              });\n            });\n          });\n        }\n\n        if (timeChanged === \"CHANGE_YEAR\") {\n          dispatch(dispatch => {\n            common.get(\n              `/habits/in-year?date=${date.format(common.DAY_FORMAT)}`,\n              (tasks: Task[]) => {\n                tasks.forEach(common.processModel);\n                dispatch({\n                  date,\n                  tasks,\n                  type: \"MOUNT_SCOPE\",\n                  scope: ScopeType.YEAR\n                });\n              }\n            );\n          });\n        }\n\n\n        if (!state.pinnedProjects) {\n          dispatchProjectListUpdate(state.projectStatsDays);\n        }\n\n\n        if (projectChanged) {\n          dispatch(dispatch => {\n            common.get(\n              `/habits/in-project/${project}`,\n              (response: {\n                scope: { Name: string; ID: number };\n                tasks: Task[];\n              }) => {\n                response.tasks.forEach(common.processModel);\n                dispatch({\n                  date,\n                  type: \"MOUNT_SCOPE\",\n                  name: response.scope.Name,\n                  scope: response.scope.ID,\n                  tasks: response.tasks\n                });\n              }\n            );\n          });\n        }\n      }\n    }\n  );\n\n\n  type HabitMessage =\n    | {\n      Type: \"UPDATE_TASKS_AND_PROJECT\";\n      Datum: {\n        Tasks: Task[];\n        ProjectID?: number;\n      };\n    }\n    | {\n      Type: \"UPDATE_SCOPE\";\n      Datum: {\n        Date: string;\n        Scope: number;\n        Tasks: Task[];\n        Name: string;\n      };\n    }\n    | {\n      Type: \"GET_PROJECT_LIST\";\n      Datum: {\n        Pinned: Project[];\n        Unpinned: Project[];\n      };\n    }\n    | {\n      Type: \"GET_PROJECT\";\n      Datum: Project;\n    };\n\n  common.makeSocket(\"habits/sync\", (msg: HabitMessage) => {\n    console.log(\"Received WebSocket message\", msg);\n    switch (msg.Type) {\n      case \"UPDATE_TASKS_AND_PROJECT\":\n        msg.Datum.Tasks.forEach(common.processModel);\n\n        dispatch({\n          type: \"UPDATE_TASKS\",\n          tasks: msg.Datum.Tasks\n        });\n\n        if (msg.Datum.ProjectID) {\n          dispatchProjectUpdate(\n            msg.Datum.ProjectID,\n            store.getState().projectStatsDays\n          );\n        }\n        break;\n\n      case \"UPDATE_SCOPE\":\n        msg.Datum.Tasks.forEach(common.processModel);\n        dispatch({\n          type: \"MOUNT_SCOPE\",\n          date: moment(msg.Datum.Date, common.DAY_FORMAT),\n          scope: msg.Datum.Scope,\n          tasks: msg.Datum.Tasks,\n          name: msg.Datum.Name\n        });\n        break;\n\n      case \"GET_PROJECT\":\n        dispatchProjectUpdate(msg.Datum.ID, store.getState().projectStatsDays);\n        break;\n\n      case \"GET_PROJECT_LIST\":\n        dispatchProjectListUpdate(store.getState().projectStatsDays);\n        break;\n    }\n  });\n\n\n  common.render(\"root\", store, React.createElement(HabitsRoot));\n};\n",
        "gt": [
            "'meditations/src/habits/containers/HabitsRoot.tsx'",
            "'meditations/src/habits/main.tsx'",
            "'meditations/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'react-signature-pad-wrapper/example/Layout.tsx'",
            "'react-signature-pad-wrapper/src/SignaturePad.tsx'",
            "'react-signature-pad-wrapper/example/app.tsx'"
        ],
        "content": "'react-signature-pad-wrapper/example/Layout.tsx'\n:import * as React from 'react';\n\nimport SignaturePad from '../src/SignaturePad';\n\n\nclass Layout extends React.PureComponent {\n\n    private signaturePadRef = React.createRef<SignaturePad>();\n\n\n    handleClear(): void {\n        const signaturePad = this.signaturePadRef.current;\n\n        if (signaturePad) {\n            signaturePad.instance.clear();\n        }\n    }\n\n\n    handleSave(): void {\n        const signaturePad = this.signaturePadRef.current;\n\n        if (!signaturePad) {\n            return;\n        }\n\n        if (signaturePad.isEmpty()) {\n            alert('Please provide a signature first.');\n        } else {\n            window.open(signaturePad.toDataURL());\n        }\n    }\n\n\n    renderTitle(): React.ReactNode {\n        return (\n            <div className=\"columns\">\n                <div className=\"column\">\n                    <h1 className=\"title\">React-Signature-Pad-Wrapper</h1>\n                    <h2 className=\"subtitle\">responsive example</h2>\n                </div>\n            </div>\n        );\n    }\n\n\n    renderSignaturePad(): React.ReactNode {\n        return (\n            <div className=\"columns\">\n                <div className=\"column is-10-tablet is-offset-1-tablet is-8-desktop is-offset-2-desktop\">\n                    <div className=\"card\">\n                        <div className=\"card-content\">\n                            <div className=\"content\">\n                                <SignaturePad redrawOnResize ref={this.signaturePadRef} />\n                            </div>\n                        </div>\n                        <footer className=\"card-footer\">\n                            <a className=\"card-footer-item\" onClick={this.handleClear.bind(this)}>\n                                Clear\n                            </a>\n                            <p className=\"card-footer-item\">\n                                <span>sign above</span>\n                            </p>\n                            <a className=\"card-footer-item\" onClick={this.handleSave.bind(this)}>\n                                Save\n                            </a>\n                        </footer>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n\n\n    render(): React.ReactNode {\n        return (\n            <section className=\"section\">\n                <div className=\"container\">\n                    {this.renderTitle()}\n                    {this.renderSignaturePad()}\n                </div>\n            </section>\n        );\n    }\n}\n\nexport default Layout;\n\n'react-signature-pad-wrapper/src/SignaturePad.tsx'\n:import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport SigPad, { type Options, type PointGroup, type ToSVGOptions } from 'signature_pad';\nimport { debounce } from 'throttle-debounce';\n\ntype Props = {\n    width?: number;\n    height?: number;\n    options?: Options;\n    canvasProps?: { [key: string]: string | { [key: string]: string } };\n} & DefaultProps;\n\ntype DefaultProps = {\n    redrawOnResize: boolean;\n    debounceInterval: number;\n};\n\ntype State = {\n    canvasWidth: number;\n    canvasHeight: number;\n};\n\n\nclass SignaturePad extends React.PureComponent<Props, State> {\n    static displayName = 'react-signature-pad-wrapper';\n\n    static propTypes = {\n        width: PropTypes.number,\n        height: PropTypes.number,\n        options: PropTypes.object,\n        canvasProps: PropTypes.object,\n        redrawOnResize: PropTypes.bool.isRequired,\n        debounceInterval: PropTypes.number.isRequired,\n    };\n\n    static defaultProps: DefaultProps = {\n        redrawOnResize: false,\n        debounceInterval: 150,\n    };\n\n    private canvasRef = React.createRef<HTMLCanvasElement>();\n\n    private signaturePad!: SigPad;\n\n    private callResizeHandler!: debounce<() => void>;\n\n\n    constructor(props: Props) {\n        super(props);\n\n        this.state = { canvasWidth: 0, canvasHeight: 0 };\n\n        this.callResizeHandler = debounce<() => void>(this.props.debounceInterval, this.handleResize.bind(this));\n    }\n\n\n    componentDidMount(): void {\n        const canvas = this.canvasRef.current;\n\n        if (canvas) {\n            if (!this.props.width || !this.props.height) {\n                canvas.style.width = '100%';\n                window.addEventListener('resize', this.callResizeHandler);\n            }\n\n            this.signaturePad = new SigPad(canvas, this.props.options);\n\n            this.scaleCanvas(canvas);\n        }\n    }\n\n\n    componentWillUnmount(): void {\n        if (!this.props.width || !this.props.height) {\n            window.removeEventListener('resize', this.callResizeHandler);\n        }\n\n        this.signaturePad.off();\n    }\n\n\n    get instance(): SigPad {\n        return this.signaturePad;\n    }\n\n\n    get canvas(): React.RefObject<HTMLCanvasElement> {\n        return this.canvasRef;\n    }\n\n\n    set dotSize(dotSize: number) {\n        this.signaturePad.dotSize = dotSize;\n    }\n\n\n    get dotSize(): number {\n        return this.signaturePad.dotSize;\n    }\n\n\n    set minWidth(minWidth: number) {\n        this.signaturePad.minWidth = minWidth;\n    }\n\n\n    get minWidth(): number {\n        return this.signaturePad.minWidth;\n    }\n\n\n    set maxWidth(maxWidth: number) {\n        this.signaturePad.maxWidth = maxWidth;\n    }\n\n\n    get maxWidth(): number {\n        return this.signaturePad.maxWidth;\n    }\n\n\n    set throttle(throttle: number) {\n        this.signaturePad.throttle = throttle;\n    }\n\n\n    get throttle(): number {\n        return this.signaturePad.throttle;\n    }\n\n\n    set backgroundColor(color: string) {\n        this.signaturePad.backgroundColor = color;\n    }\n\n\n    get backgroundColor(): string {\n        return this.signaturePad.backgroundColor;\n    }\n\n\n    set penColor(color: string) {\n        this.signaturePad.penColor = color;\n    }\n\n\n    get penColor(): string {\n        return this.signaturePad.penColor;\n    }\n\n\n    set velocityFilterWeight(weight: number) {\n        this.signaturePad.velocityFilterWeight = weight;\n    }\n\n\n    get velocityFilterWeight(): number {\n        return this.signaturePad.velocityFilterWeight;\n    }\n\n\n    isEmpty(): boolean {\n        return this.signaturePad.isEmpty();\n    }\n\n\n    clear(): void {\n        this.signaturePad.clear();\n    }\n\n\n    fromDataURL(\n        dataUrl: string,\n        options: Partial<{ ratio: number; width: number; height: number; xOffset: number; yOffset: number }> = {},\n    ): void {\n        this.signaturePad.fromDataURL(dataUrl, options);\n    }\n\n\n    toDataURL(type?: string, encoderOptions?: number): string {\n        return this.signaturePad.toDataURL(type, encoderOptions);\n    }\n\n\n    toSVG(svgOptions?: ToSVGOptions): string {\n        return this.signaturePad.toSVG(svgOptions);\n    }\n\n\n    fromData(data: PointGroup[]): void {\n        this.signaturePad.fromData(data);\n    }\n\n\n    toData(): PointGroup[] {\n        return this.signaturePad.toData();\n    }\n\n\n    off(): void {\n        this.signaturePad.off();\n    }\n\n\n    on(): void {\n        this.signaturePad.on();\n    }\n\n\n    handleResize(): void {\n        const canvas = this.canvasRef.current;\n\n        if (canvas) {\n            this.scaleCanvas(canvas);\n        }\n    }\n\n\n    scaleCanvas(canvas: HTMLCanvasElement): void {\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const width = (this.props.width || canvas.offsetWidth) * ratio;\n        const height = (this.props.height || canvas.offsetHeight) * ratio;\n\n\n        const { canvasWidth, canvasHeight } = this.state;\n\n        if (width === canvasWidth && height === canvasHeight) return;\n\n        let data;\n\n        if (this.props.redrawOnResize && this.signaturePad && !this.signaturePad.isEmpty()) {\n            data = this.signaturePad.toDataURL();\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        this.setState({ canvasWidth: width, canvasHeight: height });\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx) {\n            ctx.scale(ratio, ratio);\n        }\n\n        if (data) {\n            this.signaturePad.fromDataURL(data);\n        } else if (this.signaturePad) {\n            this.signaturePad.clear();\n        }\n    }\n\n\n    render(): React.ReactNode {\n        const { canvasProps } = this.props;\n\n        return <canvas data-testid=\"canvas-element\" ref={this.canvasRef} {...canvasProps} />;\n    }\n}\n\nexport default SignaturePad;\n\n'react-signature-pad-wrapper/example/app.tsx'\n:import * as React from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport Layout from './Layout';\n\nconst element = document.getElementById('root');\n\nif (element) {\n    createRoot(element).render(<Layout />);\n}\n",
        "gt": [
            "'react-signature-pad-wrapper/src/SignaturePad.tsx'",
            "'react-signature-pad-wrapper/example/Layout.tsx'",
            "'react-signature-pad-wrapper/example/app.tsx'"
        ]
    },
    {
        "files": [
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/components/actions/uninstall.tsx'",
            "'installer-gui/frontend/components/actions/suggested.tsx'",
            "'installer-gui/frontend/index.ts'"
        ],
        "content": "'installer-gui/frontend/components/App.tsx'\n:import Preact, {Component} from \"preact\";\nimport InstallPage from \"./actions/install\";\nimport UninstallPage from \"./actions/uninstall\";\nimport UpdatePage from \"./actions/update\";\nimport AppContext from \"./AppContext\";\nimport Category from \"./category\";\nimport Install from \"./icons/install\";\nimport Uninstall from \"./icons/uninstall\";\nimport Update from \"./icons/update\";\nimport {Notifications} from \"./notifications\";\nimport TitleBar from \"./titlebar\";\n\nexport default class App extends Component {\n    state = {navigator: {}}\n\n    handleSetPage({element, title}): void {\n        this.setState({\n            navigator: {element, title}\n        });\n    }\n\n    handleReset(): void {\n        this.setState({navigator: {}});\n    }\n\n    renderHome() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Actions</div>\n                <Category title=\"Install\" icon={Install} note=\"Install kernel to an application you choose.\">\n                    <InstallPage />\n                </Category>\n                <Category title=\"Uninstall\" icon={Uninstall} note=\"Uninstall kernel from an application you choose.\">\n                    <UninstallPage />\n                </Category>\n                <Category title=\"Update\" icon={Update} note=\"Update the kernel.asar to the latest release.\">\n                    <UpdatePage />\n                </Category>\n            </div>\n        );\n    }\n\n    render(_, {navigator}) {\n        const context = {\n            currentPage: navigator,\n            setPage: this.handleSetPage.bind(this),\n            reset: this.handleReset.bind(this)\n        };\n\n        return (\n            <AppContext.Provider value={context}>\n                <div id=\"app-mount\">\n                    <TitleBar />\n                    <div class=\"app\">\n                        {navigator.element ? navigator.element : this.renderHome()}\n                    </div>\n                    <Notifications />\n                </div>\n            </AppContext.Provider>\n        );\n    }\n}\n'installer-gui/frontend/components/actions/uninstall.tsx'\n:import Preact, {Component} from \"preact\";\nimport AppContext from \"../AppContext\";\nimport FileInput from \"../fileinput\";\nimport \"./install.scss\";\nimport SuggestedApplications from \"./suggested\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport NotificationsStore from \"../notifications\";\nimport Terminal from \"../terminal\";\nimport {ipcRenderer as IPC} from \"electron\";\nimport IPCEvents from \"@common/ipcevents\";\nimport Uninstaller from \"../../modules/uninstaller\";\n\nexport default class UninstallPage extends Component<{}, {\n    files: string[],\n    isBrowsing: boolean,\n    kernelPath: string,\n    uninstallDone: boolean;\n}> {\n    fileInputRef = Preact.createRef();\n    terminalRef = Preact.createRef<Terminal>();\n\n    state = {\n        files: [],\n        isBrowsing: true,\n        kernelPath: \"\",\n        uninstallDone: false\n    };\n\n    handleChange = (files: string[]): void => {\n        for (let i = 0; i < files.length; i++) {\n            if (this.state.files.includes(files[i])) {\n                files.splice(i, 1);\n                continue;\n            }\n\n            const location = path.resolve(files[i], \"resources\");\n            if (!fs.existsSync(location)) {\n                files.splice(i, 1);\n                NotificationsStore.showNotification(\"An invalid directory was given!\");\n            }\n        }\n\n        this.setState({\n            files: this.state.files.concat(files)\n        });\n    }\n\n    handleKernelPath = () => {}\n\n    get canInstall() {\n        return this.state.files.length > 0;\n    }\n\n    renderBrowser() {\n        return (\n            <>\n                <FileInput\n                    title=\"Applications to uninstall kernel from\"\n                    name=\"Uninstall paths\"\n                    files={this.state.files}\n                    onChange={(files) => this.handleChange(files)}\n                    onRemove={(path) => {\n                        this.setState(prev => {\n                            prev.files.splice(prev.files.indexOf(path), 1);\n                            return {...prev, files: prev.files};\n                        });\n                    }}\n                />\n                <SuggestedApplications\n                    onSelect={app => {\n                        this.handleChange([app]);\n                    }}\n                    files={this.state.files}\n                />\n            </>\n        );\n    }\n\n    renderInstalling() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Uninstall Kernel</div>\n                <Terminal ref={this.terminalRef} />\n            </div>\n        );\n    }\n\n    handleInstall() {\n        Uninstaller.uninstall(this.state.files, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({uninstallDone: true});\n        });\n    }\n\n    render(_, {isBrowsing, uninstallDone}) {\n        return (\n            <AppContext.Consumer>\n                {App => (\n                    <div class=\"installing\">\n                        <div class=\"scroller\">\n                            {isBrowsing ? this.renderBrowser() : this.renderInstalling()}\n                            <div class=\"margin-bottom10\" />\n                        </div>\n                        <div class=\"footer\">\n                            <button onClick={() => {\n                                if (isBrowsing) App.reset();\n                                else this.setState({isBrowsing: true});\n                            }}>Back</button>\n                            <button\n                                disabled={!this.canInstall}\n                                onClick={() => {\n                                    if (!this.canInstall) return;\n\n                                    if (uninstallDone) return IPC.send(IPCEvents.CLOSE_APP);\n                                    if (!isBrowsing) {\n                                        this.handleInstall();\n                                    } else {\n                                        this.setState({isBrowsing: false});\n                                    }\n                                }}\n                            >\n                                {isBrowsing ? \"Continue\" : uninstallDone ? \"Close\" : \"Uninstall\"}\n                            </button>\n                        </div>\n                    </div>\n                )}\n            </AppContext.Consumer>\n        );\n    }\n}\n'installer-gui/frontend/components/actions/suggested.tsx'\n:import Preact, {Component} from \"preact\";\n\nimport path from \"path\";\n\nimport fs from \"fs\";\n\nimport Add from \"../icons/add\";\n\nimport \"./suggested.scss\";\n\n\n\nconst validateDirectory = (path: string) => fs.existsSync(path) && fs.statSync(path).isDirectory();\n\nconst capitalize = (str: string) => str[0].toUpperCase() + str.slice(1);\n\nconst sum = (...numbers) => numbers.reduce((full, num) => full += Number(num));\n\nconst extractVersion = (str: string) => sum(...str.slice(\"app-\".length).split(\".\"));\n\n\n\nconst AppData = process.env.LOCALAPPDATA ?? path.join(process.env.USERPROFILE ?? \"/\", \"AppData\", \"Local\");\n\nconst ProgramData = process.env.ProgramData ?? path.join(\"C:\", \"ProgramData\");\n\n\n\nconst makeDiscordPath = (type: \"canary\" | \"stable\" | \"ptb\" | \"development\") => ({\n\n    id: type === \"stable\" ? \"Discord\" : `Discord${capitalize(type)}`,\n\n    name: `Discord ${type === \"stable\" ? \"\" : type === \"ptb\" ? \"PTB\" : capitalize(type)}`,\n\n    get icon() {\n\n        if (this._icon) return this._icon;\n\n        let location = path.resolve(AppData, this.id, \"app.ico\");\n\n        if (!fs.existsSync(location)) location = path.resolve(ProgramData, this.id, \"app.ico\");\n\n        if (!fs.existsSync(location)) return \"\";\n\n        return this._icon = (\"data:image/x-icon;base64,\" + fs.readFileSync(location).toString(\"base64\"));\n\n    },\n\n    get path() {\n\n        if (this._path) return this._path;\n\n\n\n        let location = path.resolve(AppData ?? \"\", this.id);\n\n\n\n        if (!validateDirectory(location)) location = path.resolve(ProgramData, this.id);\n\n        if (!validateDirectory(location)) return \"\";\n\n\n\n        const appFolder = fs.readdirSync(location, \"utf8\")\n\n            .filter(e => e.startsWith(\"app-\") && validateDirectory(path.resolve(location, e)))\n\n            .sort((a, b) => extractVersion(b) - extractVersion(a))[0];\n\n\n\n        if (!appFolder) return null;\n\n\n\n        return this._path = path.resolve(location, appFolder);\n\n    }\n\n});\n\n\n\nconst knownApplications = {\n\n    Discord: makeDiscordPath(\"stable\"),\n\n    DiscordPTB: makeDiscordPath(\"ptb\"),\n\n    DiscordCanary: makeDiscordPath(\"canary\"),\n\n    DiscordDevelopment: makeDiscordPath(\"development\")\n\n};\n\n\n\nexport default class SuggestedApplications extends Component<{onSelect(app: string): void, files: string[]}> {\n\n    renderApplication = (app: typeof knownApplications[keyof typeof knownApplications]) => {\n\n        if (!app.path) return null;\n\n\n\n        return (\n\n            <div class={`application${this.props.files.includes(app.path) ? \" disabled\" : \"\"}`} key={app.name}>\n\n                <img src={app.icon} class=\"app-icon\" />\n\n                <div class=\"app-container\">\n\n                    <div class=\"app-name\">{app.name}</div>\n\n                    <div class=\"app-path\">{app.path}</div>\n\n                </div>\n\n                <button class=\"inline app-add\" onClick={this.props.onSelect.bind(null, app.path)}>\n\n                    <Add />\n\n                </button>\n\n            </div>\n\n        );\n\n    }\n\n\n\n    render() {\n\n        return (\n\n            <div class=\"form\">\n\n                <div class=\"form-title\">Suggested Appplications</div>\n\n                {Object.values(knownApplications).map(this.renderApplication)}\n\n            </div>\n\n        )\n\n    }\n\n}\n'installer-gui/frontend/index.ts'\n:import {h, render} from \"preact\";\nimport App from \"./components/App\";\nimport Styles from \"./styles\";\nimport {createElement} from \"./util\";\nimport \"./index.scss\";\n\nStyles.inject();\nconst root = createElement(\"div\", {id: \"root\"});\ndocument.body.appendChild(root);\n\nrender(\n    h(App, {}),\n    root\n);",
        "gt": [
            "'installer-gui/frontend/components/actions/suggested.tsx'",
            "'installer-gui/frontend/components/actions/uninstall.tsx'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'"
        ]
    },
    {
        "files": [
            "'extension/src/hooks/useChatCommand.ts'",
            "'extension/src/pages/overlay/App.tsx'",
            "'extension/src/hooks/useChannel.ts'",
            "'extension/src/pages/overlay/hooks/useSettings.tsx'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/index.tsx'"
        ],
        "content": "'extension/src/hooks/useChatCommand.ts'\n:import { useCallback, useEffect, useMemo } from \"react\";\nimport tmi, { ChatUserstate } from \"tmi.js\";\n\nimport { type AmbassadorKey, useAmbassadors } from \"./useAmbassadors\";\n\nimport useChannel from \"./useChannel\";\n\nconst parseCsvEnv = (env: string | undefined): string[] =>\n  env?.split(\",\").map((str) => str.toLowerCase()) ?? [];\n\nconst testChannelNames = parseCsvEnv(process.env.REACT_APP_TEST_CHANNEL_NAMES);\nconst defaultChannelNames = parseCsvEnv(\n  process.env.REACT_APP_DEFAULT_CHANNEL_NAMES,\n);\nconst extraChannelNames = parseCsvEnv(\n  process.env.REACT_APP_EXTRA_CHANNEL_NAMES,\n);\nconst privilegedUsers = parseCsvEnv(\n  process.env.REACT_APP_CHAT_COMMANDS_PRIVILEGED_USERS,\n);\n\nexport default function useChatCommand(callback: (command: string) => void) {\n  const channel = useChannel();\n  const channelNames = useMemo(\n    () =>\n      Array.from(\n        new Set(\n          [\n\n            ...testChannelNames,\n\n\n            ...(channel ? [channel] : defaultChannelNames),\n\n\n\n            ...(channel && !defaultChannelNames.includes(channel)\n              ? extraChannelNames\n              : []),\n          ].map((name) => name.toLowerCase()),\n        ),\n      ),\n    [channel],\n  );\n\n  const ambassadors = useAmbassadors();\n  const commandsMap = useMemo(() => {\n    const commands = new Map<string, AmbassadorKey | \"welcome\">();\n    ambassadors.forEach(([key, ambassador]) => {\n      ambassador.commands.forEach((command) => {\n        commands.set(command.toLowerCase(), key);\n      });\n    });\n    commands.set(\"welcome\", \"welcome\");\n    return commands;\n  }, [ambassadors]);\n\n  const messageHandler = useCallback(\n    (\n      id: number,\n      channel: string,\n      tags: ChatUserstate,\n      msg: string,\n      self: boolean,\n    ) => {\n\n      if (\n        !tags.mod &&\n        !tags.badges?.broadcaster &&\n        !privilegedUsers.includes(tags.username?.toLowerCase() ?? \"\")\n      )\n        return;\n\n      if (self || !msg.trim().startsWith(\"!\")) return;\n\n      const commandName = msg.trim().toLowerCase().slice(1);\n      const command = commandsMap.get(commandName);\n      console.log(\n        `*Twitch extension received command: ${commandName} (${command})*`,\n        id,\n      );\n      if (command) callback(command);\n    },\n    [commandsMap, callback],\n  );\n\n  useEffect(() => {\n    const id = Date.now();\n    console.log(\"*Twitch extension is connecting to chat*\", id);\n\n\n    const client = new tmi.Client({\n      connection: {\n        secure: true,\n        reconnect: true,\n      },\n      channels: channelNames.map((name) => `#${name}`),\n    });\n\n\n    client.on(\"message\", (...args) => messageHandler(id, ...args));\n\n\n    let closing = false;\n    client.on(\"connected\", () => {\n\n      if (closing) {\n        client\n          .disconnect()\n          .then(() =>\n            console.log(\n              \"*Twitch extension disconnected from chat (after connecting)*\",\n              id,\n            ),\n          );\n        return;\n      }\n\n      console.log(\n        `*Twitch extension is connected to chat: ${channelNames.join(\", \")}*`,\n        id,\n      );\n    });\n\n\n    client.connect();\n\n\n    return () => {\n      closing = true;\n      client\n        .disconnect()\n        .then(() =>\n          console.log(\"*Twitch extension disconnected from chat*\", id),\n        );\n    };\n  }, [channelNames, messageHandler]);\n}\n\n'extension/src/pages/overlay/App.tsx'\n:import { useEffect, useCallback } from \"react\";\n\nimport { classes } from \"../../utils/classes\";\n\nimport useHiddenCursor from \"./hooks/useHiddenCursor\";\nimport useSettings from \"./hooks/useSettings\";\nimport useSleeping from \"./hooks/useSleeping\";\n\nimport Overlay from \"./components/overlay/Overlay\";\n\n\nconst timeout = 5_000;\n\nexport default function App() {\n\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    sleep,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n\n  const interacted = useCallback(() => wake(timeout), [wake]);\n\n\n  const [, showCursor] = useHiddenCursor();\n\n\n  useEffect(() => {\n    addSleepListener(\"wake\", showCursor);\n    return () => removeSleepListener(\"wake\", showCursor);\n  }, [addSleepListener, removeSleepListener, showCursor]);\n\n  return (\n    <div\n      className={classes(\n        \"relative mx-4 h-full w-full transition-opacity\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          )\n          ? \"opacity-0 [&_*]:pointer-events-none\"\n          : \"opacity-100\",\n      )}\n      onMouseEnter={interacted}\n      onMouseMove={interacted}\n      onWheel={interacted}\n      onTouchMove={interacted}\n      onKeyDown={interacted}\n      onMouseLeave={sleep}\n    >\n      <Overlay />\n    </div>\n  );\n}\n\n'extension/src/hooks/useChannel.ts'\n:import { useEffect, useState } from \"react\";\n\nimport { fetchCurrentChannelInfo } from \"../utils/twitchApi\";\n\nimport useTwitchAuth from \"./useTwitchAuth\";\n\nexport default () => {\n  const auth = useTwitchAuth();\n  const [channelName, setChannelName] = useState<string>();\n\n  useEffect(() => {\n    if (!auth) return;\n\n    fetchCurrentChannelInfo(auth)\n      .then((newChannelInfo) => {\n        if (typeof newChannelInfo?.broadcaster_login === \"string\") {\n          setChannelName(newChannelInfo.broadcaster_login.toLowerCase());\n        }\n      })\n      .catch((e) => {\n        console.error(\"Failed to fetch channel info\", e);\n        return undefined;\n      });\n  }, [auth]);\n\n  return channelName;\n};\n\n'extension/src/pages/overlay/hooks/useSettings.tsx'\n:import {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n  type ReactNode,\n} from \"react\";\n\nimport {\n  typeSafeObjectEntries,\n  typeSafeObjectFromEntries,\n} from \"../../../utils/helpers\";\nimport { OverlayKey, isValidOverlayKey } from \"../components/overlay/Overlay\";\n\nconst settings = {\n  disableChatPopup: {\n    title: \"Prevent Mod-triggered Card Popups\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: true,\n  },\n  disableOverlayHiding: {\n    title: \"(DEV) Prevent app hiding automatically\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: process.env.NODE_ENV === \"development\",\n  },\n  openedMenu: {\n    title: \"Menu that was last opened\",\n    type: \"string\",\n    process: (value: any): OverlayKey => {\n      return isValidOverlayKey(value) ? value : \"ambassadors\";\n    },\n    configurable: false,\n  },\n};\n\ntype SettingsKey = keyof typeof settings;\n\ntype StoredSettings = {\n  [key in SettingsKey]: ReturnType<(typeof settings)[key][\"process\"]>;\n};\n\nexport type Settings = {\n  [key in SettingsKey]: (typeof settings)[key] & {\n    value: StoredSettings[key];\n    change: (value: StoredSettings[key]) => void;\n  };\n};\n\nconst context = createContext<Settings | undefined>(undefined);\n\nexport const SettingsProvider = ({ children }: { children: ReactNode }) => {\n  const [stored, setStored] = useState<StoredSettings>(() => {\n\n    const storage = JSON.parse(localStorage.getItem(\"settings\") || \"{}\");\n    return typeSafeObjectEntries(settings).reduce(\n      (acc, [key, value]) => ({ ...acc, [key]: value.process(storage[key]) }),\n      {} as StoredSettings,\n    );\n  });\n\n\n  useEffect(() => {\n    localStorage.setItem(\"settings\", JSON.stringify(stored));\n  }, [stored]);\n\n\n  const change = useCallback(\n    <Key extends SettingsKey>(key: Key, value: StoredSettings[Key]) => {\n      setStored((current) => ({ ...current, [key]: value }));\n    },\n    [],\n  );\n\n\n  const obj = useMemo<Settings>(\n    () =>\n      typeSafeObjectFromEntries(\n        typeSafeObjectEntries(settings).map(([key, value]) => [\n          key,\n          {\n            ...value,\n            value: stored[key],\n            change: (value: any) => change(key, value),\n          },\n        ]),\n      ) as Settings,\n    [stored, change],\n  );\n\n  return <context.Provider value={obj}>{children}</context.Provider>;\n};\n\nconst useSettings = () => {\n  const ctx = useContext(context);\n  if (!ctx)\n    throw new Error(\"useSettings must be used within a SettingsProvider\");\n  return ctx;\n};\n\nexport default useSettings;\n\n'extension/src/pages/overlay/components/overlay/Overlay.tsx'\n:import {\n  useEffect,\n  useRef,\n  useCallback,\n  useState,\n  useMemo,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\nimport Welcome from \"../../../../components/Welcome\";\nimport IconWelcome from \"../../../../components/icons/IconWelcome\";\nimport IconAmbassadors from \"../../../../components/icons/IconAmbassadors\";\nimport IconSettings from \"../../../../components/icons/IconSettings\";\n\nimport {\n  isAmbassadorKey,\n  type AmbassadorKey,\n} from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\nimport { visibleUnderCursor } from \"../../../../utils/dom\";\n\nimport useChatCommand from \"../../../../hooks/useChatCommand\";\n\nimport useSettings from \"../../hooks/useSettings\";\nimport useSleeping from \"../../hooks/useSleeping\";\n\nimport AmbassadorsOverlay from \"./Ambassadors\";\nimport SettingsOverlay from \"./Settings\";\n\nimport Buttons from \"../Buttons\";\n\n\nconst commandTimeout = 10_000;\n\nconst overlayOptions = [\n  {\n    key: \"welcome\",\n    type: \"primary\",\n    icon: IconWelcome,\n    title: \"Welcome to Alveus\",\n    component: (props: OverlayOptionProps) => (\n      <Welcome\n        className={classes(\"absolute left-0 top-0 mx-4 my-6\", props.className)}\n      />\n    ),\n  },\n  {\n    key: \"ambassadors\",\n    type: \"primary\",\n    icon: IconAmbassadors,\n    title: \"Explore our Ambassadors\",\n    component: AmbassadorsOverlay,\n  },\n  {\n    key: \"settings\",\n    type: \"secondary\",\n    icon: IconSettings,\n    title: \"Extension Settings\",\n    component: SettingsOverlay,\n  },\n] as const;\n\nexport const isValidOverlayKey = (key: string) =>\n  key === \"\" || overlayOptions.some((option) => option.key === key);\n\nexport type OverlayKey = (typeof overlayOptions)[number][\"key\"] | \"\";\n\ntype ActiveAmbassadorState = {\n  key?: AmbassadorKey;\n  isCommand?: boolean;\n};\n\nexport interface OverlayOptionProps {\n  context: {\n    activeAmbassador: ActiveAmbassadorState;\n    setActiveAmbassador: Dispatch<SetStateAction<ActiveAmbassadorState>>;\n  };\n  className?: string;\n}\n\nconst hiddenClass =\n  \"invisible opacity-0 -translate-x-10 motion-reduce:translate-x-0\";\n\nexport default function Overlay() {\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n  const [activeAmbassador, setActiveAmbassador] =\n    useState<ActiveAmbassadorState>({});\n  const [visibleOption, setVisibleOption] = useState<OverlayKey>(\n    settings.openedMenu.value,\n  );\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const awakingRef = useRef(false);\n\n\n  useEffect(() => {\n    settings.openedMenu.change(visibleOption);\n  }, [visibleOption]);\n\n\n  useEffect(() => {\n    setVisibleOption(settings.openedMenu.value);\n  }, [settings.openedMenu.value]);\n\n\n  useChatCommand(\n    useCallback(\n      (command: string) => {\n        if (!settings.disableChatPopup.value) {\n          if (isAmbassadorKey(command))\n            setActiveAmbassador({ key: command, isCommand: true });\n          else if (command !== \"welcome\") return;\n\n\n          setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n\n          if (timeoutRef.current) clearTimeout(timeoutRef.current);\n          timeoutRef.current = setTimeout(() => {\n            setVisibleOption(\"\");\n            setActiveAmbassador({});\n          }, commandTimeout);\n\n\n          awakingRef.current = true;\n          wake(commandTimeout);\n        }\n      },\n      [settings.disableChatPopup.value, wake],\n    ),\n  );\n\n\n  useEffect(\n    () => () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    },\n    [],\n  );\n\n\n\n  useEffect(() => {\n    const callback = () => {\n      if (awakingRef.current) awakingRef.current = false;\n      else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    };\n    addSleepListener(\"wake\", callback);\n    return () => removeSleepListener(\"wake\", callback);\n  }, [addSleepListener, removeSleepListener]);\n\n\n  const bodyClick = useCallback((e: MouseEvent) => {\n    if (!visibleUnderCursor(e)) {\n      setVisibleOption(\"\");\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"click\", bodyClick, true);\n    return () => document.body.removeEventListener(\"click\", bodyClick, true);\n  }, [bodyClick]);\n\n\n  const bodyDblClick = useCallback((e: MouseEvent) => {\n    if (visibleUnderCursor(e)) {\n      e.stopPropagation();\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n    return () =>\n      document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n  }, [bodyDblClick]);\n\n\n  const context = useMemo<OverlayOptionProps[\"context\"]>(\n    () => ({\n      activeAmbassador,\n      setActiveAmbassador,\n    }),\n    [activeAmbassador],\n  );\n\n  return (\n    <div\n      className={classes(\n        \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          ) &&\n          hiddenClass,\n      )}\n    >\n      <Buttons\n        options={overlayOptions}\n        onClick={setVisibleOption}\n        active={visibleOption}\n      />\n      <div className=\"relative h-full w-full\">\n        {overlayOptions.map((option) => (\n          <option.component\n            key={option.key}\n            context={context}\n            className={classes(\n              \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n              visibleOption !== option.key && hiddenClass,\n            )}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n'extension/src/pages/overlay/index.tsx'\n:import { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\n\nimport { bindTwitchAuth } from \"../../hooks/useTwitchAuth\";\n\nimport App from \"./App\";\nimport { SettingsProvider } from \"./hooks/useSettings\";\nimport { SleepingProvider } from \"./hooks/useSleeping\";\n\nimport \"./globals.css\";\n\nbindTwitchAuth();\n\nconst root = createRoot(document.getElementById(\"root\") as HTMLElement);\n\nroot.render(\n  <StrictMode>\n    <SettingsProvider>\n      <SleepingProvider>\n        <App />\n      </SleepingProvider>\n    </SettingsProvider>\n  </StrictMode>,\n);\n",
        "gt": [
            "'extension/src/hooks/useChannel.ts'",
            "'extension/src/hooks/useChatCommand.ts'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/hooks/useSettings.tsx'",
            "'extension/src/pages/overlay/App.tsx'",
            "'extension/src/pages/overlay/index.tsx'"
        ]
    },
    {
        "files": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeProperty.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/DeclareExportAllDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/getPropertyKey.ts'"
        ],
        "content": "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeProperty.ts'\n:import * as t from '@babel/types';\nimport { convertFlowType } from './convertFlowType';\nimport { baseNodeProps } from '../utils/baseNodeProps';\nimport { getPropertyKey } from './getPropertyKey';\n\nexport function convertObjectTypeProperty(property: t.ObjectTypeProperty) {\n  let tsType;\n  if (!t.isNullableTypeAnnotation(property.value)) {\n    tsType = convertFlowType(property.value);\n  } else {\n    let tsValueT = convertFlowType(property.value.typeAnnotation);\n    if (t.isTSFunctionType(tsValueT)) {\n      tsValueT = t.tsParenthesizedType(tsValueT);\n    }\n    if (property.optional) {\n\n      tsType = t.tsUnionType([tsValueT, t.tsNullKeyword()]);\n    } else {\n\n      tsType = t.tsUnionType([\n        tsValueT,\n        t.tsUndefinedKeyword(),\n        t.tsNullKeyword(),\n      ]);\n    }\n  }\n\n  const { key, isComputed } = getPropertyKey(property);\n\n  if (property.method) {\n    if (!t.isTSFunctionType(tsType)) {\n      throw new Error('incorrect method declaration');\n    }\n    const tsMethod = t.tsMethodSignature(\n      key,\n      tsType.typeParameters,\n      tsType.parameters,\n      tsType.typeAnnotation\n    );\n\n    tsMethod.optional = property.optional;\n    tsMethod.computed = isComputed;\n    return tsMethod;\n  } else {\n    const tsPropSignature = t.tsPropertySignature(\n      key,\n      t.tsTypeAnnotation({ ...tsType, ...baseNodeProps(property.value) })\n    );\n    tsPropSignature.optional = property.optional;\n    tsPropSignature.readonly =\n      property.variance && property.variance.kind === 'plus';\n    tsPropSignature.computed = isComputed;\n    return tsPropSignature;\n  }\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'\n:import * as t from '@babel/types';\n\nimport { convertTypeParameterDeclaration } from './convertTypeParameterDeclaration';\nimport { convertObjectTypeProperty } from './convertObjectTypeProperty';\nimport { baseNodeProps } from '../utils/baseNodeProps';\nimport { convertObjectTypeCallProperty } from './convertObjectTypeCallProperty';\nimport { convertObjectTypeIndexer } from './convertObjectTypeIndexer';\nimport { convertObjectTypeInternalSlot } from './convertObjectTypeInternalSlot';\nimport { convertInterfaceExtends } from './convertInterfaceExtends';\n\nexport function convertInterfaceDeclaration(\n  node: t.InterfaceDeclaration | t.DeclareInterface\n) {\n  let typeParameters = null;\n  if (node.typeParameters) {\n    typeParameters = {\n      ...convertTypeParameterDeclaration(node.typeParameters),\n      ...baseNodeProps(node.typeParameters),\n    };\n  }\n  const extendsCombined = node.extends;\n  let _extends = undefined;\n\n  if (extendsCombined && extendsCombined.length > 0) {\n    _extends = extendsCombined.map(v => ({\n      ...convertInterfaceExtends(v),\n      ...baseNodeProps(v),\n    }));\n  }\n\n  const bodyElements = [];\n\n  for (const property of node.body.properties) {\n    if (t.isObjectTypeProperty(property)) {\n      bodyElements.push({\n        ...convertObjectTypeProperty(property),\n        ...baseNodeProps(property),\n      });\n    }\n  }\n  if (node.body.callProperties) {\n    bodyElements.push(\n      ...node.body.callProperties.map(v => ({\n        ...convertObjectTypeCallProperty(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  if (node.body.indexers) {\n    bodyElements.push(\n      ...node.body.indexers.map(v => ({\n        ...convertObjectTypeIndexer(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  if (node.body.internalSlots) {\n    bodyElements.push(\n      ...node.body.internalSlots.map(v => ({\n        ...convertObjectTypeInternalSlot(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  const body = {\n    ...t.tsInterfaceBody(bodyElements),\n    ...baseNodeProps(node.body),\n  };\n\n  return t.tsInterfaceDeclaration(node.id, typeParameters, _extends, body);\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/DeclareExportAllDeclaration.ts'\n:import { NodePath } from '@babel/traverse';\nimport * as t from '@babel/types';\n\nimport { convertFlowType } from '../converters/convertFlowType';\nimport { convertDeclareVariable } from '../converters/convertDeclareVariable';\nimport { convertDeclareFunction } from '../converters/convertDeclareFunction';\nimport { convertDeclareTypeAlias } from '../converters/convertDeclareTypeAlias';\nimport { convertDeclareClass } from '../converters/convertDeclareClass';\nimport { replaceWith } from '../utils/replaceWith';\nimport { convertInterfaceDeclaration } from '../converters/convertInterfaceDeclaration';\n\nexport function DeclareExportAllDeclaration(\n  path: NodePath<t.DeclareExportAllDeclaration>\n) {\n  const node = path.node;\n  const replacement = t.exportAllDeclaration(node.source);\n  replacement.exportKind = node.exportKind;\n  path.replaceWith(replacement);\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'\n:import { BabelFile, PluginObj, Visitor } from '@babel/core';\nimport * as t from '@babel/types';\nimport { codeFrameColumns } from '@babel/code-frame';\nimport { ImportDeclaration } from './visitors/ImportDeclaration';\nimport { OpaqueType } from './visitors/OpaqueType';\nimport { TypeAnnotation } from './visitors/TypeAnnotation';\nimport { TypeCastExpression } from './visitors/TypeCastExpression';\nimport { TypeParameterDeclaration } from './visitors/TypeParameterDeclaration';\nimport { ClassDeclaration } from './visitors/ClassDeclaration';\nimport { DeclareClass } from './visitors/DeclareClass';\nimport { InterfaceDeclaration } from './visitors/InterfaceDeclaration';\nimport { DeclareFunction } from './visitors/DeclareFunction';\nimport { Program } from './visitors/Program';\nimport { TypeAlias } from './visitors/TypeAlias';\nimport { FunctionDeclaration } from './visitors/FunctionDeclaration';\nimport { CallExpression } from './visitors/CallExpression';\nimport { DeclareVariable } from './visitors/DeclareVariable';\nimport { DeclareTypeAlias } from './visitors/DeclareTypeAlias';\nimport { DeclareInterface } from './visitors/DeclareInterface';\nimport { DeclareOpaqueType } from './visitors/DeclareOpaqueType';\nimport { DeclareModuleExports } from './visitors/DeclareModuleExports';\nimport { DeclareModule } from './visitors/DeclareModule';\nimport { DeclareExportDeclaration } from './visitors/DeclareExportDeclaration';\nimport { NewExpression } from './visitors/NewExpression';\nimport { ArrowFunctionExpression } from './visitors/ArrowFunctionExpression';\nimport { PluginOptions, PluginPass } from './types';\nimport { TSModuleDeclaration } from './visitors/TSModuleDeclaration';\nimport { ExportAllDeclaration } from './visitors/ExportAllDeclaration';\nimport { ObjectMethod } from './visitors/ObjectMethod';\nimport { DeclareExportAllDeclaration } from './visitors/DeclareExportAllDeclaration';\nimport { Pattern } from './visitors/Pattern';\nimport { ForOfStatement } from './visitors/ForOfStatement';\nimport { EnumDeclaration } from './visitors/EnumDeclaration';\n\nconst visitor: Visitor<PluginPass> = {\n  Program,\n  TypeAnnotation,\n  TypeAlias,\n  TypeParameterDeclaration,\n  ImportDeclaration,\n  TypeCastExpression,\n  OpaqueType,\n  DeclareClass,\n  ClassDeclaration,\n  ClassExpression: ClassDeclaration,\n  ExportAllDeclaration,\n  InterfaceDeclaration,\n  DeclareFunction,\n  FunctionDeclaration,\n  CallExpression,\n  OptionalCallExpression: CallExpression,\n  DeclareVariable,\n  DeclareTypeAlias,\n  DeclareInterface,\n  DeclareOpaqueType,\n  DeclareModuleExports,\n  DeclareModule,\n  DeclareExportDeclaration,\n  DeclareExportAllDeclaration,\n  NewExpression,\n  ArrowFunctionExpression,\n  TSModuleDeclaration,\n  ObjectMethod,\n  TemplateElement(path: any) {\n\n\n\n    path.node.original = null;\n  },\n  Pattern,\n  ForOfStatement,\n  EnumDeclaration,\n};\n\nexport default (_babel: any, opts: PluginOptions = {} as PluginOptions) => {\n  if (typeof opts.isJSX === 'undefined') {\n    opts.isJSX = true;\n  }\n  if (typeof opts.legacyImports === 'undefined') {\n    opts.legacyImports = true;\n  }\n  return {\n    name: 'babel-plugin-flow-to-typescript',\n    visitor,\n\n    manipulateOptions(_babel: any, parserOpts) {\n      parserOpts.plugins.push(['flow', { enums: true }]);\n      if (opts.isJSX) {\n        parserOpts.plugins.push('jsx');\n      }\n      parserOpts.plugins.push('classProperties');\n      parserOpts.plugins.push('objectRestSpread');\n      parserOpts.plugins.push('optionalChaining');\n      parserOpts.plugins.push('nullishCoalescingOperator');\n      parserOpts.plugins.push(['decorators', { decoratorsBeforeExport: true }]);\n      parserOpts.plugins.push('dynamicImport');\n      parserOpts.allowReturnOutsideFunction = true;\n    },\n    pre(this: PluginPass, file: BabelFile) {\n      const logger = this.opts.logger || {\n        error: console.error.bind(console),\n        warn: console.log.bind(console),\n        log: console.log.bind(console),\n      };\n      const oldMessages = new Set<string>();\n      function createLogger(log: (message: string) => void) {\n        return (node: t.Node, message: string) => {\n          const loc = node && node.loc;\n\n          const highlightCode: boolean = file.opts.highlightCode ?? true;\n\n          let msg = message;\n          if (loc) {\n            msg +=\n              '\\n' +\n              codeFrameColumns(\n                file.code,\n                {\n                  start: {\n                    line: loc.start.line,\n                    column: loc.start.column + 1,\n                  },\n                  end:\n                    loc.end && loc.start.line === loc.end.line\n                      ? {\n                          line: loc.end.line,\n                          column: loc.end.column + 1,\n                        }\n                      : undefined,\n                },\n                { highlightCode }\n              );\n          }\n          if (!oldMessages.has(msg)) {\n            log(msg);\n            oldMessages.add(msg);\n          }\n        };\n      }\n      this.set('logger', {\n        error: createLogger(logger.error),\n        warn: createLogger(logger.warn),\n        log: createLogger(logger.log),\n      });\n    },\n  } as PluginObj<PluginPass>;\n};\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/getPropertyKey.ts'\n:import * as t from '@babel/types';\nimport { baseNodeProps } from '../utils/baseNodeProps';\n\nexport function getPropertyKey(property: t.ObjectTypeProperty) {\n  let key: t.Expression = property.key;\n  let isComputed = false;\n  if (t.isIdentifier(property.key)) {\n    if (property.key.name === '@@iterator') {\n      isComputed = true;\n      key = {\n        ...t.memberExpression(t.identifier('Symbol'), t.identifier('iterator')),\n        ...baseNodeProps(property.key),\n      };\n    }\n    if (property.key.name === '@@asyncIterator') {\n      isComputed = true;\n      key = {\n        ...t.memberExpression(\n          t.identifier('Symbol'),\n          t.identifier('asyncIterator')\n        ),\n        ...baseNodeProps(property.key),\n      };\n    }\n  }\n  return { key, isComputed };\n}\n",
        "gt": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/getPropertyKey.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeProperty.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/DeclareExportAllDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/user/user.service.ts'",
            "'is-even/apps/backend/src/user/error/read-user.error.ts'",
            "'is-even/apps/backend/src/user/user.module.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/user/user.controller.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'"
        ],
        "content": "'is-even/apps/backend/src/user/user.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\n\nimport { User } from './user.entity';\nimport { UserWithAuth } from './interface/user-with-auth.interface';\n\nimport { LoggerService } from '../logger/logger.service';\nimport { CognitoService } from '../cognito/cognito.service';\nimport { SentryService } from '../sentry/sentry.service';\n\nimport { CreateUserError } from './error/create-user.error';\nimport { LoginUserError } from './error/login-user.error';\nimport { ReadUserError } from './error/read-user.error';\nimport { LogoutUserError } from './error/logout-user.error';\nimport { CognitoCreateUserError } from '../cognito/error/cognito-create-user.error';\n\n@Injectable()\nexport class UserService {\n  constructor(\n    private readonly loggerService: LoggerService,\n    private readonly cognitoService: CognitoService,\n    private readonly sentryService: SentryService,\n    @InjectRepository(User) private readonly usersRepository: Repository<User>,\n  ) {\n    this.loggerService.setContext(UserService.name);\n  }\n\n  public async createUser(\n    firstName: string,\n    lastName: string,\n    email: string,\n    password: string,\n  ): Promise<User> {\n    try {\n      const user = new User();\n\n      user.firstName = firstName;\n      user.lastName = lastName;\n      user.email = email;\n\n      const authId = await this.cognitoService.createUser(user.email, password);\n\n      user.authId = authId;\n\n      return await this.usersRepository.save(user);\n    } catch (error) {\n      this.loggerService.error(`Failed to create a new user. ${error.message}`);\n\n      this.sentryService.instance.withScope((scope) => {\n        scope.setTag('where', 'userService.createUser');\n        this.sentryService.instance.captureException(error);\n      });\n\n      if (error instanceof CognitoCreateUserError) {\n        throw error;\n      }\n\n      throw new CreateUserError(error);\n    }\n  }\n\n  public async loginWithCredentials(\n    email: string,\n    password: string,\n  ): Promise<UserWithAuth> {\n    try {\n      const auth = await this.cognitoService.login(email, password);\n      const user = await this.findUserByEmail(email);\n\n      return {\n        user,\n        auth,\n      };\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to login user with credentials. ${error.message}`,\n      );\n      throw new LoginUserError(error);\n    }\n  }\n\n  public async loginWithToken(refreshToken): Promise<UserWithAuth> {\n    try {\n      const auth = await this.cognitoService.refreshToken(refreshToken);\n      const userAuthId = this.cognitoService.getTokenAuthId(auth.accessToken);\n      const user = await this.findUserByAuthId(userAuthId);\n\n      return {\n        user,\n        auth,\n      };\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to login user with token. ${error.message}`,\n      );\n      throw new LoginUserError(error);\n    }\n  }\n\n  public async logoutUser(email: string): Promise<void> {\n    try {\n      await this.cognitoService.logout(email);\n    } catch (error) {\n      this.loggerService.error(`Failed to logout user. ${error.message}`);\n      throw new LogoutUserError(error);\n    }\n  }\n\n  public async findUserByEmail(email: string): Promise<User> {\n    try {\n      return await this.usersRepository.findOneOrFail({\n        where: {\n          email,\n        },\n      });\n    } catch (error) {\n      this.loggerService.error(`Failed to read user data. ${error.message}`);\n      throw new ReadUserError(error);\n    }\n  }\n\n  public async findUserByAuthId(authId: string): Promise<User> {\n    try {\n      return await this.usersRepository.findOneOrFail({\n        where: {\n          authId,\n        },\n      });\n    } catch (error) {\n      this.loggerService.error(`Failed to read user data. ${error.message}`);\n      throw new ReadUserError(error);\n    }\n  }\n}\n\n'is-even/apps/backend/src/user/error/read-user.error.ts'\n:export class ReadUserError extends Error {\n  constructor(error: Error) {\n    super(`Failed to read user data. ${error.message}`);\n  }\n}\n\n'is-even/apps/backend/src/user/user.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { User } from './user.entity';\nimport { UserService } from './user.service';\nimport { UserController } from './user.controller';\n\nimport { CognitoModule } from '../cognito/cognito.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [UserService],\n  exports: [UserService],\n  controllers: [UserController],\n  imports: [\n    TypeOrmModule.forFeature([User]),\n    CognitoModule,\n    LoggerModule,\n    SentryModule,\n  ],\n})\nexport class UserModule {}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/user/user.controller.ts'\n:import {\n  Controller,\n  Post,\n  HttpStatus,\n  HttpException,\n  Body,\n  Get,\n  Req,\n  BadRequestException,\n  HttpCode,\n} from '@nestjs/common';\nimport { ApiResponse, ApiTags } from '@nestjs/swagger';\n\nimport { CognitoCreateUserError } from '../cognito/error/cognito-create-user.error';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { LoginUserDto } from './dto/login-user.dto';\nimport { UserWithAuth } from './interface/user-with-auth.interface';\nimport { User } from './user.entity';\nimport { UserService } from './user.service';\nimport { Authorised } from '../auth/auth.decorator';\nimport { RequestWithUser } from '../common/interface/request-with-user.interface';\nimport { LoginUserError } from './error/login-user.error';\nimport { RefreshUserTokenDto } from './dto/refresh-user-token.dto';\n\n@Controller('users')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Post('/register')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'User has been successfully created',\n  })\n  @ApiResponse({\n    status: HttpStatus.SERVICE_UNAVAILABLE,\n    description: 'Third party service error',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async createUser(@Body() createUserDto: CreateUserDto): Promise<User> {\n    const { firstName, lastName, email, password } = createUserDto;\n    try {\n      return await this.userService.createUser(\n        firstName,\n        lastName,\n        email,\n        password,\n      );\n    } catch (error) {\n      if (error instanceof CognitoCreateUserError) {\n        throw new HttpException(\n          'Service temporary unavailable',\n          HttpStatus.SERVICE_UNAVAILABLE,\n        );\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Post('login')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'User has been successfully logged in',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async loginUser(\n    @Body() loginUserDto: LoginUserDto,\n  ): Promise<UserWithAuth> {\n    const { email, password } = loginUserDto;\n    try {\n      return await this.userService.loginWithCredentials(email, password);\n    } catch (error) {\n      if (error instanceof LoginUserError) {\n        throw new BadRequestException('Invalid email or password');\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Post('refresh')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Token has been successfully refreshed',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async refreshUserToken(\n    @Body() refreshUserTokenDto: RefreshUserTokenDto,\n  ): Promise<UserWithAuth> {\n    const { refreshToken } = refreshUserTokenDto;\n    try {\n      return await this.userService.loginWithToken(refreshToken);\n    } catch (error) {\n      if (error instanceof LoginUserError) {\n        throw new BadRequestException('Invalid token');\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @Post('logout')\n  @Authorised()\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.NO_CONTENT,\n    description: 'User has been successfully logout',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  public async logoutUser(@Req() request: RequestWithUser): Promise<void> {\n    const user = request.user;\n\n    try {\n      return await this.userService.logoutUser(user.email);\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Get('me')\n  @Authorised()\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'User data has been successfully retrieved',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  public async me(@Req() request: RequestWithUser): Promise<User> {\n    try {\n      return request.user;\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n",
        "gt": [
            "'is-even/apps/backend/src/user/error/read-user.error.ts'",
            "'is-even/apps/backend/src/user/user.service.ts'",
            "'is-even/apps/backend/src/user/user.controller.ts'",
            "'is-even/apps/backend/src/user/user.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/redis/redis.repo.ts'",
            "'Rankings-Backend/src/core/database/redis/redis.module.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.interface.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/redis/redis.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { IHandyRedis } from 'handy-redis';\nimport { Discipline } from 'shared/enums';\nimport { Utils } from 'shared/utils';\nimport { DDBAthleteDetailItem } from '../dynamodb/athlete/details/athlete.details.interface';\nimport { DDBAthleteRankingsItemPrimaryKey } from '../dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBContestItem } from '../dynamodb/contests/contest.interface';\nimport { RedisConfig } from './redis.config';\n\n@Injectable()\nexport class RedisRepository {\n  protected keyNamePrefix = 'ISA-Rankings';\n  protected seperator = ':';\n\n\n  protected get redis(): IHandyRedis {\n    return this.redisConfig.redisClient;\n  }\n\n  constructor(public readonly redisConfig: RedisConfig) {}\n\n  public async getAthleteDetail(athleteId: string) {\n    const key = this.redisKeyOfAthleteDetails(athleteId);\n    const get = this.redis.get(key).then(d => JSON.parse(d) as DDBAthleteDetailItem);\n    return Utils.omitReject(get);\n  }\n\n  public async setAthleteDetail(item: DDBAthleteDetailItem) {\n    if (!item) {\n      return;\n    }\n    const key = this.redisKeyOfAthleteDetails(item.athleteId);\n    const set = this.redis.set(key, JSON.stringify(item));\n    return Utils.omitReject(set);\n  }\n\n  public async clearAthleteDetail(athleteId: string) {\n    const key = this.redisKeyOfAthleteDetails(athleteId);\n    const del = this.redis.del(key);\n    return Utils.omitReject(del);\n  }\n\n  public async getContest(contestId: string, discipline: Discipline) {\n    const key = this.redisKeyOfContest(contestId, discipline);\n    const get = this.redis.get(key).then(d => JSON.parse(d) as DDBContestItem);\n    return Utils.omitReject(get);\n  }\n\n  public async setContest(item: DDBContestItem) {\n    if (!item) {\n      return;\n    }\n    const key = this.redisKeyOfContest(item.contestId, item.discipline);\n    const set = this.redis.set(key, JSON.stringify(item));\n    return Utils.omitReject(set);\n  }\n\n  public async clearContest(contestId: string, discipline: Discipline) {\n    const key = this.redisKeyOfContest(contestId, discipline);\n    const del = this.redis.del(key);\n    return Utils.omitReject(del);\n  }\n\n  public async updatePointsOfAthleteInRankingCategory(pk: DDBAthleteRankingsItemPrimaryKey, points: number) {\n    const key = this.redisKeyOfRankingCategory(pk);\n    const zadd = this.redis.zadd(key, [points, pk.athleteId]);\n    return Utils.omitReject(zadd);\n  }\n\n  public async getPlaceOfAthleteInRankingCategory(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const key = this.redisKeyOfRankingCategory(pk);\n    const zrevrank = this.redis.zrevrank(key, pk.athleteId);\n    return Utils.omitReject(zrevrank);\n  }\n\n  public async getTopScoreRankingsCronJobOffset() {\n    const key = this.redisKeyOfTopScoreRankingsOffset();\n    const get = this.redis.get(key);\n    return Utils.omitReject(get);\n  }\n\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    const key = this.redisKeyOfTopScoreRankingsOffset();\n    const get = this.redis.set(key, offset.toString());\n    return Utils.omitReject(get);\n  }\n\n  protected redisKeyOfRankingCategory(pk: DDBAthleteRankingsItemPrimaryKey): string {\n    return this.concatWithKeynamePrefix(\n      'Rankings',\n      pk.rankingType.toString(),\n      pk.year.toString(),\n      pk.discipline.toString(),\n      pk.gender.toString(),\n      pk.ageCategory.toString(),\n    );\n  }\n\n  protected redisKeyOfAthleteDetails(athleteId: string): string {\n    return this.concatWithKeynamePrefix('AthleteDetails', athleteId);\n  }\n\n  protected redisKeyOfContest(contesId: string, discipline: Discipline): string {\n    return this.concatWithKeynamePrefix('Contest', contesId, discipline.toString());\n  }\n\n  protected redisKeyOfTopScoreRankingsOffset(): string {\n    return this.concatWithKeynamePrefix('TopScoreRankingsOffset');\n  }\n  protected concatWithKeynamePrefix(keySpace: string, ...params: string[]): string {\n    const finalKey = this.keyNamePrefix + this.seperator + keySpace;\n    return this.concat(finalKey, ...params);\n  }\n\n  protected concat(keySpace: string, ...params: string[]): string {\n    return Utils.concatParams(keySpace, ...params);\n  }\n}\n\n'Rankings-Backend/src/core/database/redis/redis.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { ClientOpts } from 'redis';\nimport { RedisConfig } from './redis.config';\nimport { RedisRepository } from './redis.repo';\n\n@Module({\n  imports: [],\n  providers: [RedisRepository],\n  exports: [RedisRepository],\n})\nexport class RedisRepositoryModule {\n  public static withConfig(opts: ClientOpts): DynamicModule {\n    const redisConfig = {\n      provide: RedisConfig,\n      useFactory: () => {\n        return new RedisConfig(opts);\n      },\n    };\n    return {\n      module: RedisRepositoryModule,\n      providers: [redisConfig],\n      exports: [redisConfig],\n    };\n  }\n  public static forTest(opts: ClientOpts): ModuleMetadata {\n    const redisConfig = {\n      provide: RedisConfig,\n      useFactory: () => {\n        return new RedisConfig(opts);\n      },\n    };\n    return {\n      providers: [redisConfig],\n      exports: [redisConfig],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/contests/contest.interface.ts'\n:import { ContestGender, ContestType, Discipline } from 'shared/enums';\nimport { DDBTableKeyAttrs } from '../interfaces/table.interface';\n\nexport type KeyAttrs = DDBTableKeyAttrs;\n\ninterface Attrs {\n  readonly name: string;\n  readonly normalizedName: string;\n  readonly city: string;\n  readonly country: string;\n  readonly prize: number;\n  readonly category: ContestType;\n  readonly gender: ContestGender;\n  readonly profileUrl: string;\n  readonly thumbnailUrl: string;\n  readonly infoUrl: string;\n  readonly createdAt: number;\n}\n\ninterface NonKeyAttrs extends Attrs {}\n\nexport type AllAttrs = KeyAttrs & NonKeyAttrs;\n\nexport interface DDBContestItem extends Attrs {\n  readonly contestId: string;\n  readonly discipline: Discipline;\n  readonly date: string;\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.interface.ts'",
            "'Rankings-Backend/src/core/database/redis/redis.repo.ts'",
            "'Rankings-Backend/src/core/database/redis/redis.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/api/admin/submit/contest/submit-contest.service.ts'",
            "'Rankings-Backend/src/api/admin/submit/contest/submit-contest.module.ts'",
            "'Rankings-Backend/src/api/admin/submit/contest/submit-contest.controller.ts'",
            "'Rankings-Backend/src/api/admin/submit/contest/dto/submit-contest.dto.ts'",
            "'Rankings-Backend/src/api/admin/api.module.ts'",
            "'Rankings-Backend/src/api/admin/index.ts'"
        ],
        "content": "'Rankings-Backend/src/api/admin/submit/contest/submit-contest.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { Contest } from 'core/contest/entity/contest';\nimport { DatabaseService } from 'core/database/database.service';\nimport { Discipline } from 'shared/enums';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { SubmitContestDto } from './dto/submit-contest.dto';\n\n@Injectable()\nexport class SubmitContestService {\n  constructor(private readonly db: DatabaseService) {}\n  public async createContest(dto: SubmitContestDto) {\n    const contestDate = new Date(dto.date);\n    const id = IdGenerator.generateContestId();\n    const contest = new Contest({\n      ...dto,\n      id: id,\n      date: contestDate,\n    });\n    await this.db.putContest(contest);\n    return { id: contest.id, discipline: contest.discipline };\n  }\n\n  public async modifyContest(dto: SubmitContestDto) {\n    const contestDate = new Date(dto.date);\n    const contest = new Contest({\n      ...dto,\n      date: contestDate,\n    });\n    await this.db.putContest(contest);\n    return { id: contest.id, discipline: contest.discipline };\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.db.updateContestProfileUrl(contestId, discipline, url);\n  }\n}\n\n'Rankings-Backend/src/api/admin/submit/contest/submit-contest.module.ts'\n:import { Module } from '@nestjs/common';\nimport { DatabaseModule } from 'api/admin/database.module';\nimport { SubmitContestController } from './submit-contest.controller';\nimport { SubmitContestService } from './submit-contest.service';\n\n@Module({\n  imports: [DatabaseModule],\n  controllers: [SubmitContestController],\n  providers: [SubmitContestService],\n})\nexport class SubmitContestModule {}\n\n'Rankings-Backend/src/api/admin/submit/contest/submit-contest.controller.ts'\n:import { Body, Controller, Post, Put, UseGuards, UsePipes } from '@nestjs/common';\nimport { Roles } from 'shared/decorators/roles.decorator';\nimport { AuthenticationRole, Discipline } from 'shared/enums';\nimport { RolesGuard } from 'shared/guards/roles.guard';\nimport { logger } from 'shared/logger';\nimport { JoiValidationPipe } from 'shared/pipes/JoiValidation.pipe';\nimport {\n  BatchSubmitContestDto,\n  batchSubmitContestDtoSchema,\n  SubmitContestDto,\n  submitContestDtoSchema,\n} from './dto/submit-contest.dto';\nimport { SubmitContestResponse } from './dto/submit-contest.response';\nimport { SubmitContestPictureDto, submitContestPictureDtoSchema } from './dto/submit-picture.dto';\nimport { SubmitContestService } from './submit-contest.service';\n\n@Controller('submit/contest')\nexport class SubmitContestController {\n  constructor(private readonly service: SubmitContestService) {}\n\n  @Post()\n\n\n  @UsePipes(new JoiValidationPipe(submitContestDtoSchema))\n  public async submitContest(@Body() dto: SubmitContestDto) {\n    logger.info('Submit Contest', { data: dto });\n    let rsp: { id: string; discipline: Discipline };\n    if (dto.id) {\n      rsp = await this.service.modifyContest(dto);\n    } else {\n      rsp = await this.service.createContest(dto);\n    }\n    const response = new SubmitContestResponse(rsp.id, rsp.discipline);\n    return response;\n  }\n\n  @Post('batch')\n  @UsePipes(new JoiValidationPipe(batchSubmitContestDtoSchema))\n  public async batchSubmitAthlete(@Body() dto: BatchSubmitContestDto) {\n    for (const contest of dto.data) {\n      await this.submitContest(contest);\n    }\n  }\n\n  @Post('picture')\n\n\n  @UsePipes(new JoiValidationPipe(submitContestPictureDtoSchema))\n  public async submitAthletePicture(@Body() dto: SubmitContestPictureDto) {\n    await this.service.updateContestProfileUrl(dto.id, dto.discipline, dto.url);\n  }\n}\n\n'Rankings-Backend/src/api/admin/submit/contest/dto/submit-contest.dto.ts'\n:import * as Joi from 'joi';\nimport { ContestGenderUtility, ContestTypeUtility, DisciplineUtility } from 'shared/enums/enums-utility';\nimport { APIErrors } from 'shared/exceptions/api.exceptions';\n\nexport class SubmitContestDto {\n  public readonly id: string;\n  public readonly name: string;\n  public readonly date: string;\n  public readonly city: string;\n  public readonly country: string;\n  public readonly discipline: number;\n  public readonly contestType: number;\n  public readonly contestGender: number;\n  public readonly prize: number;\n  public readonly profileUrl: string;\n  public readonly thumbnailUrl: string;\n  public readonly infoUrl: string;\n}\n\n\nexport class BatchSubmitContestDto {\n  public readonly data: SubmitContestDto[];\n}\n\nexport const submitContestDtoSchema = Joi.object().keys({\n  id: Joi.string()\n    .allow('')\n    .optional()\n    .error(new APIErrors.JoiValidationError('Unknown id')),\n  name: Joi.string()\n    .required()\n    .error(new APIErrors.JoiValidationError('Unknown name')),\n  date: Joi.string()\n    .isoDate()\n    .error(new APIErrors.JoiValidationError('Invalid date')),\n  city: Joi.string()\n    .required()\n    .error(new APIErrors.JoiValidationError('Unknown city')),\n  country: Joi.string()\n    .lowercase()\n    .required()\n    .error(new APIErrors.JoiValidationError('Unknown country')),\n  discipline: Joi.number()\n    .required()\n    .valid(DisciplineUtility.CompetitionDisciplines)\n    .error(new APIErrors.JoiValidationError('Invalid discipline')),\n  contestType: Joi.number()\n    .required()\n    .valid(ContestTypeUtility.ContestTypes)\n    .error(new APIErrors.JoiValidationError('Invalid category')),\n  contestGender: Joi.number()\n    .required()\n    .valid(ContestGenderUtility.ContestGenders)\n    .error(new APIErrors.JoiValidationError('Invalid gender')),\n  prize: Joi.number()\n    .required()\n    .allow(0)\n    .error(new APIErrors.JoiValidationError('Unknown prize')),\n  profileUrl: Joi.string()\n    .allow('')\n    .optional()\n    .uri()\n    .error(new APIErrors.JoiValidationError('Unknown profileUrl')),\n  thumbnailUrl: Joi.string()\n    .allow('')\n    .optional()\n    .uri()\n    .error(new APIErrors.JoiValidationError('Unknown thumbnailUrl')),\n  infoUrl: Joi.string()\n    .allow('')\n    .optional()\n\n    .error(new APIErrors.JoiValidationError('Unknown infoUrl')),\n});\n\nexport const batchSubmitContestDtoSchema = Joi.object().keys({\n  data: Joi.array().items(submitContestDtoSchema),\n});\n\n'Rankings-Backend/src/api/admin/api.module.ts'\n:import { HelmetMiddleware } from '@nest-middlewares/helmet';\nimport { MethodOverrideMiddleware } from '@nest-middlewares/method-override';\nimport { MorganMiddleware } from '@nest-middlewares/morgan';\nimport { MiddlewareConsumer, Module } from '@nestjs/common';\n\nimport env_variables from 'shared/env_variables';\nimport { AthleteModule } from './athlete/athlete.module';\nimport { ContestModule } from './contest/contest.module';\nimport { ResultsModule } from './results/results.module';\nimport { SubmitAthleteModule } from './submit/athlete/submit-athlete.module';\nimport { SubmitContestModule } from './submit/contest/submit-contest.module';\nimport { SubmitContestResultsModule } from './submit/results/submit-contest-result.module';\n\n@Module({\n  imports: [\n    SubmitContestModule,\n    SubmitAthleteModule,\n    SubmitContestResultsModule,\n    ContestModule,\n    AthleteModule,\n    ResultsModule,\n  ],\n  providers: [],\n  exports: [],\n})\nexport class AppModule {\n  public configure(consumer: MiddlewareConsumer) {\n    MorganMiddleware.configure(env_variables.morganConfig);\n    consumer.apply(MorganMiddleware).forRoutes('*');\n    consumer.apply(MethodOverrideMiddleware).forRoutes('*');\n    consumer.apply(HelmetMiddleware).forRoutes('*');\n  }\n}\n\n'Rankings-Backend/src/api/admin/index.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { APIGatewayEvent, Callback, Context, Handler } from 'aws-lambda';\n\nimport 'shared';\n\nimport { AllExceptionsFilter } from 'shared/filters/exception.filter';\nimport { waitForLogger } from 'shared/logger';\nimport { AppModule } from './api.module';\n\nimport * as serverless from 'aws-serverless-express';\nimport { eventContext } from 'aws-serverless-express/middleware';\n\nimport { Server } from 'http';\nimport env_variables from 'shared/env_variables';\nlet cachedServer: Server;\n\n\nconst express = require('express')();\n\nasync function bootstrapServer(): Promise<any> {\n  return NestFactory.create(AppModule, express, {\n    bodyParser: true,\n    logger: env_variables.isDev ? undefined : false,\n  })\n    .then(app => {\n      app.use(eventContext());\n      app.useGlobalFilters(new AllExceptionsFilter());\n      app.setGlobalPrefix('admin/api');\n      app.enableCors();\n      return app.init();\n    })\n    .then(() => {\n      return serverless.createServer(express);\n    });\n}\n\nexport const handler: Handler = async (event: APIGatewayEvent, context: Context) => {\n\n  context.succeed = succeedWaitsLogger(context.succeed);\n  if (!cachedServer) {\n    cachedServer = await bootstrapServer();\n  }\n  return serverless.proxy(cachedServer, event, context, 'PROMISE').promise;\n};\n\nfunction succeedWaitsLogger(succeed: Context['succeed']): Context['succeed'] {\n  return (messageObject: any) => {\n    return waitForLogger()\n      .then(() => {\n        succeed(messageObject);\n      })\n      .catch(error => {\n        succeed(messageObject);\n      });\n  };\n}\n",
        "gt": [
            "'Rankings-Backend/src/api/admin/submit/contest/dto/submit-contest.dto.ts'",
            "'Rankings-Backend/src/api/admin/submit/contest/submit-contest.service.ts'",
            "'Rankings-Backend/src/api/admin/submit/contest/submit-contest.controller.ts'",
            "'Rankings-Backend/src/api/admin/submit/contest/submit-contest.module.ts'",
            "'Rankings-Backend/src/api/admin/api.module.ts'",
            "'Rankings-Backend/src/api/admin/index.ts'"
        ]
    },
    {
        "files": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeAnnotation.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceExtends.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeCallProperty.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertFlowType.ts'"
        ],
        "content": "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeAnnotation.ts'\n:import * as t from '@babel/types';\nimport { convertObjectTypeCallProperty } from './convertObjectTypeCallProperty';\nimport { convertObjectTypeIndexer } from './convertObjectTypeIndexer';\nimport { convertObjectTypeInternalSlot } from './convertObjectTypeInternalSlot';\nimport { baseNodeProps } from '../utils/baseNodeProps';\nimport { convertObjectTypeProperty } from './convertObjectTypeProperty';\nimport { convertFlowType } from './convertFlowType';\n\nexport function convertObjectTypeAnnotation(\n  node: t.ObjectTypeAnnotation\n): t.TSType {\n  const members: t.TSTypeElement[] = [];\n  const spreads: t.TSType[] = [];\n\n  if (\n    (!node.properties || node.properties.length === 0) &&\n    (!node.callProperties || node.callProperties.length === 0) &&\n    (!node.internalSlots || node.internalSlots.length === 0) &&\n    node.indexers &&\n    node.indexers.length === 1 &&\n    !t.isNumberTypeAnnotation(node.indexers[0].key) &&\n    !t.isStringTypeAnnotation(node.indexers[0].key)\n  ) {\n\n\n    return t.tsMappedType(\n      t.tsTypeParameter(\n        convertFlowType(node.indexers[0].key),\n        null,\n        node.indexers[0].id?.name || 'k'\n      ),\n      convertFlowType(node.indexers[0].value)\n    );\n  }\n\n  if (node.properties) {\n    for (const property of node.properties) {\n      if (t.isObjectTypeProperty(property)) {\n        members.push({\n          ...convertObjectTypeProperty(property),\n          ...baseNodeProps(property),\n        });\n      }\n\n      if (t.isObjectTypeSpreadProperty(property)) {\n\n        spreads.push(convertFlowType(property.argument));\n      }\n    }\n  }\n\n  if (node.indexers) {\n    members.push(...node.indexers.map(convertObjectTypeIndexer));\n  }\n\n  if (node.callProperties) {\n    members.push(...node.callProperties.map(convertObjectTypeCallProperty));\n  }\n\n  if (node.internalSlots) {\n    members.push(...node.internalSlots.map(convertObjectTypeInternalSlot));\n  }\n\n\n\n  let ret: t.TSType = t.tsTypeLiteral(members);\n\n  if (spreads.length > 0) {\n    if (ret.members.length > 0) {\n      spreads.unshift(ret);\n    }\n    ret = t.tsIntersectionType(spreads);\n  }\n\n  return ret;\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceExtends.ts'\n:import * as t from '@babel/types';\n\nimport { convertFlowType } from './convertFlowType';\nimport { baseNodeProps } from '../utils/baseNodeProps';\nimport { convertFlowIdentifier } from './convertFlowIdentifier';\n\nexport function convertInterfaceExtends(\n  node: t.InterfaceExtends | t.ClassImplements\n) {\n  const typeParameters = node.typeParameters;\n  const typeParameterParams = typeParameters ? typeParameters.params : [];\n  const parameters = t.tsTypeParameterInstantiation(\n    typeParameterParams.map(item => ({\n      ...convertFlowType(item),\n      ...baseNodeProps(item),\n    }))\n  );\n\n  return t.tsExpressionWithTypeArguments(\n    convertFlowIdentifier(node.id),\n    typeParameterParams.length ? parameters : null\n  );\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeCallProperty.ts'\n:import * as t from '@babel/types';\nimport { convertFunctionTypeAnnotation } from './convertFunctionTypeAnnotation';\n\nexport function convertObjectTypeCallProperty(\n  callProperty: t.ObjectTypeCallProperty\n) {\n  if (t.isFunctionTypeAnnotation(callProperty.value)) {\n    const { typeParams, parameters, returnType } =\n      convertFunctionTypeAnnotation(callProperty.value);\n\n    return t.tsCallSignatureDeclaration(typeParams, parameters, returnType);\n  } else {\n    throw new Error('ObjectCallTypeProperty case not implemented');\n  }\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertFlowType.ts'\n:import * as t from '@babel/types';\nimport { warnOnlyOnce } from '../utils/warnOnlyOnce';\nimport { convertFlowIdentifier } from './convertFlowIdentifier';\nimport { convertFunctionTypeAnnotation } from './convertFunctionTypeAnnotation';\nimport { baseNodeProps } from '../utils/baseNodeProps';\nimport { convertObjectTypeAnnotation } from './convertObjectTypeAnnotation';\nimport { convertInterfaceExtends } from './convertInterfaceExtends';\n\nexport function convertFlowType(node: t.FlowType): t.TSType {\n  if (t.isAnyTypeAnnotation(node)) {\n    return t.tsAnyKeyword();\n  }\n\n  if (t.isArrayTypeAnnotation(node)) {\n    const elementType = {\n      ...convertFlowType(node.elementType),\n      ...baseNodeProps(node.elementType),\n    };\n    return t.tsArrayType(\n      t.isTSUnionType(elementType) ||\n        t.isTSIntersectionType(elementType) ||\n        t.isTSFunctionType(elementType)\n        ? t.tsParenthesizedType(elementType)\n        : elementType\n    );\n  }\n\n  if (t.isBooleanTypeAnnotation(node)) {\n    return t.tsBooleanKeyword();\n  }\n\n  if (t.isBooleanLiteralTypeAnnotation(node)) {\n    return t.tsLiteralType(t.booleanLiteral(node.value));\n  }\n\n  if (t.isEmptyTypeAnnotation(node)) {\n    return t.tsNeverKeyword();\n  }\n\n  if (t.isExistsTypeAnnotation(node)) {\n    warnOnlyOnce(\n      'Existential type (*) in Flow is converted to \"any\" in TypeScript, and this conversion loses some type information.'\n    );\n    return t.tsAnyKeyword();\n  }\n\n  if (t.isGenericTypeAnnotation(node)) {\n    const typeParameters = node.typeParameters;\n    let tsTypeParameters: t.TSTypeParameterInstantiation | null = null;\n    if (typeParameters) {\n      const tsParams = typeParameters.params.map(p => ({\n        ...convertFlowType(p),\n        ...baseNodeProps(p),\n      }));\n      tsTypeParameters = t.tsTypeParameterInstantiation(tsParams);\n    }\n\n    const id = node.id;\n    if (t.isIdentifier(id) && id.name === '$Keys') {\n\n      const ret = t.tsTypeOperator(tsTypeParameters!.params[0]);\n      ret.operator = 'keyof';\n      return ret;\n    } else if (t.isIdentifier(id) && id.name === '$Values') {\n\n      const tsType = tsTypeParameters!.params[0];\n      const tsKey = t.tsTypeOperator(tsType);\n      tsKey.operator = 'keyof';\n      return t.tsIndexedAccessType(tsType, tsKey);\n    } else if (t.isIdentifier(id) && id.name === '$ReadOnly') {\n\n      return t.tsTypeReference(t.identifier('Readonly'), tsTypeParameters);\n    } else if (t.isIdentifier(id) && id.name === '$ReadOnlyArray') {\n\n      return t.tsTypeReference(t.identifier('ReadonlyArray'), tsTypeParameters);\n    } else if (t.isIdentifier(id) && id.name === '$Exact') {\n      warnOnlyOnce(\n        \"Exact object type annotation in Flow is ignored. In TypeScript, it's always regarded as exact type\"\n      );\n      return tsTypeParameters!.params[0];\n    } else if (\n      t.isIdentifier(id) &&\n      (id.name === '$Diff' || id.name === '$Rest')\n    ) {\n\n      const [tsX, tsY] = tsTypeParameters!.params;\n\n      let tsKeyofY: t.TSTypeOperator | t.TSUnionType = t.tsTypeOperator(tsY);\n      tsKeyofY.operator = 'keyof';\n      if (t.isTSTypeLiteral(tsY)) {\n        const keys: string[] = [];\n        let doable = true;\n        tsY.members.forEach(m => {\n          if (t.isTSPropertySignature(m) || t.isTSMethodSignature(m)) {\n            if (t.isIdentifier(m.key)) {\n              keys.push(m.key.name);\n            } else if (t.isStringLiteral(m.key)) {\n              keys.push(m.key.value);\n            } else {\n              doable = false;\n            }\n          } else if (t.isTSIndexSignature(m)) {\n            doable = false;\n          }\n        });\n        if (doable) {\n          tsKeyofY = t.tsUnionType(\n            keys.map(p => t.tsLiteralType(t.stringLiteral(p)))\n          );\n        }\n      }\n      return t.tsTypeReference(\n        t.identifier('Omit'),\n        t.tsTypeParameterInstantiation([tsX, tsKeyofY])\n      );\n    } else if (t.isIdentifier(id) && id.name === '$PropertyType') {\n\n\n      const [tsT, tsK] = tsTypeParameters!.params;\n      if (\n        t.isTSImportType(tsT) &&\n        t.isTSLiteralType(tsK) &&\n        t.isStringLiteral(tsK.literal)\n      ) {\n        tsT.qualifier = t.identifier(tsK.literal.value);\n        return tsT;\n      } else return t.tsIndexedAccessType(tsT, tsK);\n    } else if (t.isIdentifier(id) && id.name === '$ElementType') {\n      const [tsT, tsK] = tsTypeParameters!.params;\n      return t.tsIndexedAccessType(tsT, tsK);\n    } else if (t.isIdentifier(id) && id.name === '$Shape') {\n      return t.tsTypeReference(t.identifier('Partial'), tsTypeParameters);\n    } else if (t.isIdentifier(id) && id.name === '$NonMaybeType') {\n      return t.tsTypeReference(t.identifier('NonNullable'), tsTypeParameters);\n    } else if (t.isIdentifier(id) && id.name === '$ReadOnlySet') {\n      return t.tsTypeReference(t.identifier('ReadonlySet'), tsTypeParameters);\n    } else if (t.isIdentifier(id) && id.name === '$ReadOnlyMap') {\n      return t.tsTypeReference(t.identifier('ReadonlyMap'), tsTypeParameters);\n    } else if (t.isIdentifier(id) && id.name === '$Exports') {\n\n      if (\n        tsTypeParameters &&\n        tsTypeParameters.params.length === 1 &&\n        t.isTSLiteralType(tsTypeParameters.params[0]) &&\n        t.isStringLiteral(tsTypeParameters.params[0].literal)\n      ) {\n        return t.tsImportType(tsTypeParameters.params[0].literal, null);\n      } else {\n        return t.tsTypeReference(\n          convertFlowIdentifier(id),\n          tsTypeParameters && tsTypeParameters.params.length\n            ? tsTypeParameters\n            : null\n        );\n      }\n    } else if (t.isIdentifier(id) && id.name === 'Class') {\n\n      return t.tsTypeLiteral([\n        t.tsConstructSignatureDeclaration(\n          null,\n          [\n            {\n              ...t.restElement(t.identifier('args')),\n              typeAnnotation: t.tsTypeAnnotation(t.tsAnyKeyword()),\n            },\n          ],\n          tsTypeParameters !== null\n            ? t.tsTypeAnnotation(tsTypeParameters!.params[0])\n            : t.tsTypeAnnotation(t.tsAnyKeyword())\n        ),\n      ]);\n    } else if (t.isIdentifier(id) && id.name === '$FlowFixMe') {\n      return t.tsTypeReference(t.identifier('any'), tsTypeParameters);\n    } else if (t.isIdentifier(id) && id.name === 'Object') {\n\n      return t.tsAnyKeyword();\n    } else if (t.isQualifiedTypeIdentifier(id) || t.isIdentifier(id)) {\n      return t.tsTypeReference(\n        convertFlowIdentifier(id),\n        tsTypeParameters && tsTypeParameters.params.length\n          ? tsTypeParameters\n          : null\n      );\n    }\n\n  }\n\n  if (t.isIntersectionTypeAnnotation(node)) {\n    const flowTypes = node.types;\n    return t.tsIntersectionType(\n      flowTypes.map(v => {\n        let tsType = convertFlowType(v);\n        if (t.isTSFunctionType(tsType)) {\n          tsType = t.tsParenthesizedType(tsType);\n        }\n        return { ...tsType, ...baseNodeProps(v) };\n      })\n    );\n  }\n\n  if (t.isMixedTypeAnnotation(node)) {\n    return t.tsUnknownKeyword();\n  }\n\n  if (t.isNullableTypeAnnotation(node)) {\n    let tsType = convertFlowType(node.typeAnnotation);\n    if (t.isTSFunctionType(tsType)) {\n      tsType = t.tsParenthesizedType(tsType);\n    }\n\n\n\n    if (t.isTSAnyKeyword(tsType)) return tsType;\n    return t.tsUnionType([tsType, t.tsUndefinedKeyword(), t.tsNullKeyword()]);\n  }\n\n  if (t.isNullLiteralTypeAnnotation(node)) {\n    return t.tsNullKeyword();\n  }\n\n  if (t.isNumberLiteralTypeAnnotation(node)) {\n    return t.tsLiteralType(t.numericLiteral(node.value));\n  }\n\n  if (t.isNumberTypeAnnotation(node)) {\n    return t.tsNumberKeyword();\n  }\n\n  if (t.isObjectTypeAnnotation(node)) {\n    return convertObjectTypeAnnotation(node);\n  }\n\n  if (t.isStringLiteralTypeAnnotation(node)) {\n    return t.tsLiteralType(t.stringLiteral(node.value!));\n  }\n\n  if (t.isStringTypeAnnotation(node)) {\n    return t.tsStringKeyword();\n  }\n\n  if (t.isThisTypeAnnotation(node)) {\n    return t.tsThisType();\n  }\n\n  if (t.isTypeofTypeAnnotation(node)) {\n    const typeOp = t.tsTypeOperator(convertFlowType(node.argument));\n    typeOp.operator = 'typeof';\n    return typeOp;\n  }\n\n  if (t.isUnionTypeAnnotation(node)) {\n    const flowTypes = node.types;\n    return t.tsUnionType(\n      flowTypes.map(v => {\n        let tsType = convertFlowType(v);\n        if (t.isTSFunctionType(tsType)) {\n          tsType = t.tsParenthesizedType(tsType);\n        }\n        return { ...tsType, ...baseNodeProps(v) };\n      })\n    );\n  }\n\n  if (t.isVoidTypeAnnotation(node)) {\n    return t.tsVoidKeyword();\n  }\n\n  if (t.isFunctionTypeAnnotation(node)) {\n    const { typeParams, parameters, returnType } =\n      convertFunctionTypeAnnotation(node);\n    return t.tsFunctionType(typeParams, parameters, returnType);\n  }\n\n  if (t.isTupleTypeAnnotation(node)) {\n    const flowTypes = node.types;\n    return t.tsTupleType(flowTypes.map(convertFlowType));\n  }\n\n  if (t.isSymbolTypeAnnotation(node)) {\n    return t.tsSymbolKeyword();\n  }\n\n  if (t.isIdentifier(node)) {\n    console.warn(\n      `unexpected identifier with name \"${\n        (node as any).name\n      }\" used as type annotation. This is bug in babel parser. Using it as type name`\n    );\n    if ((node as any).name === 'function') {\n      (node as any).name = 'Function';\n    }\n    return convertFlowType(t.genericTypeAnnotation(node));\n  }\n\n  if (t.isInterfaceTypeAnnotation(node)) {\n    const objectType = convertObjectTypeAnnotation(node.body);\n    if (!node.extends || node.extends.length === 0) {\n      return objectType;\n    } else {\n      return t.tsIntersectionType([\n        objectType,\n        ...node.extends.map(v => {\n          let tsType: any = convertInterfaceExtends(v);\n          if (t.isTSFunctionType(tsType)) {\n            tsType = t.tsParenthesizedType(tsType);\n          }\n          return { ...tsType, ...baseNodeProps(v) };\n        }),\n      ]);\n    }\n  }\n\n  if (t.isIndexedAccessType(node)) {\n    return {\n      ...t.tsIndexedAccessType(\n        convertFlowType(node.objectType),\n        convertFlowType(node.indexType)\n      ),\n      ...baseNodeProps(node),\n    };\n  }\n  throw new Error(`Unsupported flow type FlowType(type=${node.type})`);\n}\n",
        "gt": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeCallProperty.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeAnnotation.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertFlowType.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceExtends.ts'"
        ]
    },
    {
        "files": [
            "'angular-16-complete-course/15-angular-authentication/start/src/app/dashboard/dashboard.component.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/app/app.module.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/main.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/app/route.module.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/app/Services/Logging.Service.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/app/Services/task.service.ts'"
        ],
        "content": "'angular-16-complete-course/15-angular-authentication/start/src/app/dashboard/dashboard.component.ts'\n:import { Component, OnInit, inject } from '@angular/core';\nimport { Task } from '../Model/Task';\nimport { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';\nimport { TaskService } from '../Services/task.service';\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-dashboard',\n  templateUrl: './dashboard.component.html',\n  styleUrls: ['./dashboard.component.css']\n})\nexport class DashboardComponent implements OnInit{\n  showCreateTaskForm: boolean = false;\n  showTaskDetails: boolean = false;\n  http: HttpClient = inject(HttpClient)\n  allTasks: Task[] = [];\n  taskService: TaskService = inject(TaskService);\n  currentTaskId: string = '';\n  isLoading: boolean = false;\n\n  currentTask: Task | null = null;\n\n  errorMessage: string | null = null;\n\n  editMode: boolean = false;\n  selectedTask: Task;\n\n  errorSub: Subscription\n\n  ngOnInit(){\n    this.fetchAllTasks();\n    this.errorSub = this.taskService.errorSubject.subscribe({next: (httpError) => {\n      this.setErrorMessage(httpError);\n    }})\n  }\n\n  ngOnDestroy(){\n    this.errorSub.unsubscribe();\n  }\n\n  OpenCreateTaskForm(){\n    this.showCreateTaskForm = true;\n    this.editMode = false;\n    this.selectedTask = {title: '', desc: '', assignedTo: '', createdAt: '', priority: '', status: ''}\n  }\n\n  showCurrentTaskDetails(id: string | undefined){\n    this.showTaskDetails = true;\n    this.taskService.getTaskDetails(id).subscribe({next: (data: Task) => {\n      this.currentTask = data;\n    }});\n  }\n\n  CloseTaskDetails(){\n    this.showTaskDetails = false;\n  }\n\n  CloseCreateTaskForm(){\n    this.showCreateTaskForm = false;\n  }\n\n  CreateOrUpdateTask(data: Task){\n    if(!this.editMode)\n      this.taskService.CreateTask(data);\n    else\n      this.taskService.UpdateTask(this.currentTaskId, data);\n  }\n\n\n\n  FetchAllTaskClicked(){\n    this.fetchAllTasks()\n  }\n\n  private fetchAllTasks(){\n    this.isLoading = true;\n    this.taskService.GetAlltasks().subscribe({next: (tasks) => {\n      this.allTasks = tasks;\n      this.isLoading = false;\n    }, error: (error) => {\n      this.setErrorMessage(error);\n      this.isLoading = false;\n    }})\n  }\n\n  private setErrorMessage(err: HttpErrorResponse){\n    if(err.error.error === 'Permission denied'){\n      this.errorMessage = 'You do not have permisssion to perform this action';\n    }\n    else{\n      this.errorMessage = err.message;\n    }\n\n    setTimeout(() => {\n      this.errorMessage = null;\n    }, 3000);\n  }\n\n  DeleteTask(id: string | undefined){\n    this.taskService.DeleteTask(id);\n  }\n\n  DeleteAllTask(){\n    this.taskService.DeleteAllTasks();\n  }\n\n  OnEditTaskClicked(id: string | undefined){\n    this.currentTaskId = id;\n\n\n    this.showCreateTaskForm = true;\n    this.editMode = true;\n\n    this.selectedTask = this.allTasks.find((task) => {return task.id === id})\n  }\n}\n\n'angular-16-complete-course/15-angular-authentication/start/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { FooterComponent } from './footer/footer.component';\nimport { DashboardComponent } from './dashboard/dashboard.component';\nimport { CreateTaskComponent } from './dashboard/create-task/create-task.component';\nimport { FormsModule } from '@angular/forms';\nimport { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { TaskDetailsComponent } from './dashboard/task-details/task-details.component';\nimport { AuthInterceptorService } from './Services/auth-interceptor.service';\nimport { LoggingInterceptorService } from './Services/logging-interceptor.servive';\nimport { RouteModule } from './route.module';\nimport { HomeComponent } from './home/home.component';\nimport { LoginComponent } from './login/login.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    DashboardComponent,\n    CreateTaskComponent,\n    TaskDetailsComponent,\n    HomeComponent,\n    LoginComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpClientModule,\n    RouteModule\n  ],\n  providers: [\n    {provide: HTTP_INTERCEPTORS, useClass: AuthInterceptorService, multi: true},\n    {provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptorService, multi: true}\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-16-complete-course/15-angular-authentication/start/src/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n'angular-16-complete-course/15-angular-authentication/start/src/app/route.module.ts'\n:import { NgModule } from '@angular/core';\n\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { DashboardComponent } from './dashboard/dashboard.component';\n\nimport { LoginComponent } from './login/login.component';\n\nimport { HomeComponent } from './home/home.component';\n\n\n\nconst routes: Routes = [\n\n    { path: '', component: HomeComponent },\n\n    { path: 'login', component: LoginComponent },\n\n    { path: 'dashboard', component: DashboardComponent },\n\n  ];\n\n\n\n@NgModule({\n\n  imports: [RouterModule.forRoot(routes)],\n\n  exports: [RouterModule],\n\n  providers: []\n\n})\n\nexport class RouteModule { }\n\n\n'angular-16-complete-course/15-angular-authentication/start/src/app/Services/Logging.Service.ts'\n:import { Injectable, inject } from '@angular/core';\n\nimport { HttpClient } from '@angular/common/http';\n\n\n\n@Injectable({\n\n    providedIn: 'root'\n\n})\n\nexport class LoggingService{\n\n    http: HttpClient = inject(HttpClient);\n\n    logError(data: {statusCode: number, errorMessage: string, datetime: Date}){\n\n        this.http.post('https:\n\n        .subscribe();\n\n    }\n\n\n\n    fetcherrors(){\n\n        this.http.get('https:\n\n        .subscribe((data) => {\n\n            console.log(data);\n\n        })\n\n    }\n\n}\n'angular-16-complete-course/15-angular-authentication/start/src/app/Services/task.service.ts'\n:import { Injectable, inject } from \"@angular/core\";\n\nimport { HttpClient, HttpHeaders, HttpErrorResponse, HttpParams, HttpEventType } from '@angular/common/http';\n\nimport { Task } from \"../Model/Task\";\n\nimport { map, catchError, tap } from 'rxjs/operators';\n\nimport { Subject, throwError } from 'rxjs';\n\nimport { LoggingService } from \"./Logging.Service\";\n\n\n\n@Injectable({\n\n    providedIn: 'root'\n\n})\n\nexport class TaskService{\n\n    http: HttpClient = inject(HttpClient);\n\n    loggingService: LoggingService = inject(LoggingService);\n\n    errorSubject = new Subject<HttpErrorResponse>();\n\n\n\n    CreateTask(task: Task){\n\n        const headers = new HttpHeaders({'my-header': 'hello-world'})\n\n        this.http.post<{name: string}>(\n\n            'https:\n\n            task, {headers: headers}\n\n            )\n\n            .pipe(catchError((err) => {\n\n\n\n                const errorObj = {statusCode: err.status, errorMessage: err.message, datetime: new Date()}\n\n                this.loggingService.logError(errorObj);\n\n                return throwError(() => err);\n\n            }))\n\n            .subscribe({error: (err) => {\n\n                this.errorSubject.next(err);\n\n            }});\n\n    }\n\n\n\n    DeleteTask(id: string | undefined){\n\n        this.http.delete('https:\n\n        .pipe(catchError((err) => {\n\n\n\n            const errorObj = {statusCode: err.status, errorMessage: err.message, datetime: new Date()}\n\n            this.loggingService.logError(errorObj);\n\n            return throwError(() => err);\n\n        }))\n\n        .subscribe({error: (err) => {\n\n            this.errorSubject.next(err);\n\n        }});\n\n    }\n\n\n\n    DeleteAllTasks(){\n\n        this.http.delete('https:\n\n        .pipe(tap((event) => {\n\n            console.log(event);\n\n            if(event.type === HttpEventType.Sent){\n\n\n\n            }\n\n        }), catchError((err) => {\n\n\n\n            const errorObj = {statusCode: err.status, errorMessage: err.message, datetime: new Date()}\n\n            this.loggingService.logError(errorObj);\n\n            return throwError(() => err);\n\n        }))\n\n        .subscribe({error: (err) => {\n\n            this.errorSubject.next(err);\n\n        }})\n\n    }\n\n\n\n    GetAlltasks(){\n\n        let headers = new HttpHeaders();\n\n        headers = headers.append('content-type', 'application/json');\n\n        headers = headers.append('content-type', 'text/html')\n\n\n\n        let queryParams = new HttpParams();\n\n        queryParams = queryParams.set('page', 2);\n\n        queryParams = queryParams.set('item', 10)\n\n\n\n        return this.http.get<{[key: string]: Task}>(\n\n            'https:\n\n            ,{headers: headers, params: queryParams, observe: 'body'}\n\n            ).pipe(map((response) => {\n\n\n\n                 let tasks = [];\n\n                 console.log(response);\n\n                 for(let key in response){\n\n                   if(response.hasOwnProperty(key)){\n\n                     tasks.push({...response[key], id: key});\n\n                   }\n\n                 }\n\n\n\n                 return tasks;\n\n            }), catchError((err) => {\n\n\n\n                const errorObj = {statusCode: err.status, errorMessage: err.message, datetime: new Date()}\n\n                this.loggingService.logError(errorObj);\n\n                return throwError(() => err);\n\n            }))\n\n    }\n\n\n\n    UpdateTask(id: string | undefined, data: Task){\n\n        this.http.put('https:\n\n        .pipe(catchError((err) => {\n\n\n\n            const errorObj = {statusCode: err.status, errorMessage: err.message, datetime: new Date()}\n\n            this.loggingService.logError(errorObj);\n\n            return throwError(() => err);\n\n        }))\n\n        .subscribe({error: (err) => {\n\n            this.errorSubject.next(err);\n\n        }});\n\n    }\n\n\n\n    getTaskDetails(id: string | undefined){\n\n        return this.http.get('https:\n\n        .pipe(map((response) => {\n\n            console.log(response)\n\n            let task = {};\n\n            task = {...response, id: id}\n\n            return task;\n\n        }))\n\n    }\n\n}",
        "gt": [
            "'angular-16-complete-course/15-angular-authentication/start/src/app/Services/Logging.Service.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/app/Services/task.service.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/app/dashboard/dashboard.component.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/app/route.module.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/app/app.module.ts'",
            "'angular-16-complete-course/15-angular-authentication/start/src/main.ts'"
        ]
    },
    {
        "files": [
            "'Lumina/src/Components/Systems/CreateEmptySystem.tsx'",
            "'Lumina/src/Components/Systems/NodeSystem.tsx'",
            "'Lumina/src/Components/SizeConfig.ts'",
            "'Lumina/src/Components/Systems/CreateBurstSystem.ts'"
        ],
        "content": "'Lumina/src/Components/Systems/CreateEmptySystem.tsx'\n:import React from \"@rbxts/react\";\nimport { NodeSystem as NodeSystemAPI } from \"API/NodeSystem\";\nimport { GetCanvasData } from \"Services/CanvasService\";\nimport { AddSystem } from \"Services/NodeSystemService\";\nimport NodeSystem from \"./NodeSystem\";\n\nexport function CreateEmptySystem(position?: Vector2) {\n    return AddSystem(\n        new NodeSystemAPI(),\n        \"Empty System\",\n        (systemData) => (\n            <NodeSystem\n                key={`system_${systemData.id}`}\n                anchorPoint={systemData.anchorPoint}\n                canvasPosition={GetCanvasData().Position}\n                systemId={systemData.id}\n                systemAPI={systemData.system}\n                systemDestroyEvent={systemData.onDestroy}\n            />\n        ),\n        position,\n    );\n}\n\n'Lumina/src/Components/Systems/NodeSystem.tsx'\n:import React, { useEffect, useMemo, useRef, useState } from \"@rbxts/react\";\nimport { RunService } from \"@rbxts/services\";\nimport type { FastEvent, FastEventConnection } from \"API/Bindables/FastEvent\";\nimport { NodeGroups } from \"API/NodeGroup\";\nimport type { NodeSystem as NodeSystemAPI } from \"API/NodeSystem\";\nimport { TextInput } from \"Components/Basic/TextInput\";\nimport { GetSelectedSystemId, SetSelectSystemId, selectedSystemIdChanged } from \"Services/SelectionService\";\nimport { StyleColors } from \"Style\";\nimport { GetMousePosition, GetMousePositionOnCanvas } from \"Windows/MainWindow\";\nimport { GetZoomScale, ZoomScaleChanged } from \"ZoomScale\";\nimport {\n    GetSystemById,\n    type NodeSystemCollectioEntry,\n    type NodeSystemData,\n    RemoveNodeSystem,\n    UpdateSystemData,\n} from \"../../Services/NodeSystemService\";\nimport Div from \"../Div\";\nimport { SYSTEM_BORDER_THICKNESS, SYSTEM_HEADER_HEIGHT, SYSTEM_LIST_PADDING, SYSTEM_PADDING, SYSTEM_WIDTH } from \"../SizeConfig\";\nimport NodeGroup from \"./NodeGroup\";\n\nconst SYSTEM_SELECT_TIME = 0.1;\n\ninterface Props {\n    anchorPoint: Vector2;\n    canvasPosition: UDim2;\n    systemId: number;\n    systemAPI: NodeSystemAPI;\n    systemDestroyEvent: FastEvent<[NodeSystemData]>;\n}\n\nfunction NodeSystem({ anchorPoint, canvasPosition, systemId, systemAPI, systemDestroyEvent }: Props) {\n    const [_, setForceRender] = useState(0);\n    const [zoomScale, setZoomScale] = useState(GetZoomScale());\n\n    const mouseOffsetRef = useRef(new Vector2(0, 0));\n    const selectingSystemTimeRef = useRef(0);\n    const selectedSystemIdChangedConnectionRef = useRef<FastEventConnection>();\n\n    const onMouseButton1Down = (element: TextButton) => {\n        const mousePosition = GetMousePosition();\n        mouseOffsetRef.current = element.AbsolutePosition.sub(mousePosition);\n\n        selectingSystemTimeRef.current = os.clock();\n\n        RunService.BindToRenderStep(\"MoveSystem\", Enum.RenderPriority.Input.Value, () => {\n            const mousePosition = GetMousePositionOnCanvas();\n            const newAnchorPoint = mousePosition.add(mouseOffsetRef.current).div(zoomScale);\n\n            if (anchorPoint !== newAnchorPoint) {\n                UpdateSystemData(systemId, (systemData) => {\n                    systemData.anchorPoint = newAnchorPoint;\n                    return systemData;\n                });\n            }\n        });\n    };\n\n    const onMouseButton1Up = () => {\n        RunService.UnbindFromRenderStep(\"MoveSystem\");\n\n        if (os.clock() - selectingSystemTimeRef.current > SYSTEM_SELECT_TIME) return;\n\n        SetSelectSystemId(systemId);\n        setForceRender((prev) => prev + 1);\n\n        if (selectedSystemIdChangedConnectionRef.current !== undefined) return;\n\n        selectedSystemIdChangedConnectionRef.current = selectedSystemIdChanged.Connect((newSystemId) => {\n            if (newSystemId !== systemId) {\n                setForceRender((prev) => prev + 1);\n                (selectedSystemIdChangedConnectionRef.current as FastEventConnection).Disconnect();\n                selectedSystemIdChangedConnectionRef.current = undefined;\n            }\n        });\n    };\n\n    const onMouseButton2Down = () => {\n        RemoveNodeSystem(systemId);\n    };\n\n    const getPosition = () => {\n        const offsetFromCenter = anchorPoint.mul(zoomScale).add(new Vector2(SYSTEM_WIDTH * 0.5 * zoomScale, 0));\n        const canvasPositionVec2 = new Vector2(canvasPosition.X.Offset, canvasPosition.Y.Offset);\n        const position = canvasPositionVec2.add(offsetFromCenter);\n        return UDim2.fromOffset(position.X, position.Y);\n    };\n\n    const getSystemName = () => {\n        const data = GetSystemById(systemId) as NodeSystemCollectioEntry;\n        return data.data.systemName;\n    };\n\n    const updateSystemName = (name: string) => {\n        if (name === \"\") return \"\";\n\n        UpdateSystemData(systemId, (systemData) => {\n            systemData.systemName = name;\n            return systemData;\n        });\n    };\n\n    const updateSystemNameLostFocus = (name: string) => {\n        if (name === \"\") return getSystemName();\n\n        UpdateSystemData(systemId, (systemData) => {\n            systemData.systemName = name;\n            return systemData;\n        });\n    };\n\n    useEffect(() => {\n        const connection = ZoomScaleChanged.Connect((newScale) => {\n            setZoomScale(newScale);\n        });\n\n        return () => {\n            connection.Disconnect();\n        };\n    }, []);\n\n    return (\n        <textbutton\n            Size={UDim2.fromOffset(SYSTEM_WIDTH * zoomScale, 0)}\n            AutomaticSize={\"Y\"}\n            AnchorPoint={new Vector2(0.5, 0)}\n            Position={getPosition()}\n            BackgroundTransparency={1}\n            Text={\"\"}\n            Active={true}\n            Event={{\n                InputBegan: (element, inputObject) => {\n                    if (inputObject.UserInputType === Enum.UserInputType.MouseButton1) {\n                        onMouseButton1Down(element);\n                    } else if (inputObject.UserInputType === Enum.UserInputType.MouseButton2) {\n                        onMouseButton2Down();\n                    }\n                },\n                InputEnded: (_, inputObject) => {\n                    if (inputObject.UserInputType === Enum.UserInputType.MouseButton1) {\n                        onMouseButton1Up();\n                    }\n                },\n            }}\n        >\n            <Div>\n                <uipadding\n                    PaddingLeft={new UDim(0, SYSTEM_BORDER_THICKNESS * zoomScale)}\n                    PaddingRight={new UDim(0, SYSTEM_BORDER_THICKNESS * zoomScale)}\n                    PaddingTop={new UDim(0, SYSTEM_BORDER_THICKNESS * zoomScale)}\n                    PaddingBottom={new UDim(0, SYSTEM_BORDER_THICKNESS * zoomScale)}\n                />\n                {GetSelectedSystemId() === systemId && (\n                    <>\n                        <uicorner CornerRadius={new UDim(0, 5 * zoomScale)} />\n                        <uistroke Thickness={math.clamp(3 * zoomScale, 1, math.huge)} Color={StyleColors.Selection} />\n                    </>\n                )}\n\n                <Div>\n                    <uistroke\n                        Color={StyleColors.FullWhite}\n                        Thickness={math.clamp(SYSTEM_BORDER_THICKNESS * zoomScale, 0.5, math.huge)}\n                        Transparency={0.75}\n                    >\n                        <uigradient\n                            Color={\n                                new ColorSequence([\n                                    new ColorSequenceKeypoint(0, StyleColors.SpawnGroup),\n                                    new ColorSequenceKeypoint(1, StyleColors.EndGroup),\n                                ])\n                            }\n                            Rotation={90}\n                        />\n                    </uistroke>\n                    <uicorner CornerRadius={new UDim(0, 5 * zoomScale)} />\n                    <uipadding\n                        PaddingBottom={new UDim(0, SYSTEM_PADDING * zoomScale)}\n                        PaddingLeft={new UDim(0, SYSTEM_PADDING * zoomScale)}\n                        PaddingRight={new UDim(0, SYSTEM_PADDING * zoomScale)}\n                        PaddingTop={new UDim(0, SYSTEM_PADDING * zoomScale)}\n                    />\n                    <uilistlayout Padding={new UDim(0, 1 + SYSTEM_LIST_PADDING * zoomScale)} HorizontalAlignment={\"Center\"} />\n\n                    {useMemo(\n                        () => (\n                            <TextInput\n                                Size={new UDim2(1, 0, 0, SYSTEM_HEADER_HEIGHT)}\n                                HideBackground={true}\n                                Text={getSystemName()}\n                                TextSize={20}\n                                TextColor={StyleColors.White}\n                                TextChanged={updateSystemName}\n                                LostFocus={updateSystemNameLostFocus}\n                            />\n                        ),\n                        [zoomScale],\n                    )}\n\n                    <NodeGroup\n                        SystemId={systemId}\n                        SystemAPI={systemAPI}\n                        SystemDestroyEvent={systemDestroyEvent}\n                        NodeGroup={NodeGroups.Spawn}\n                        GradientStart={StyleColors.SpawnGroup}\n                        GradientEnd={StyleColors.InitializeGroup}\n                    />\n                    <NodeGroup\n                        SystemId={systemId}\n                        SystemAPI={systemAPI}\n                        SystemDestroyEvent={systemDestroyEvent}\n                        NodeGroup={NodeGroups.Initialize}\n                        GradientStart={StyleColors.InitializeGroup}\n                        GradientEnd={StyleColors.UpdateGroup}\n                    />\n                    <NodeGroup\n                        SystemId={systemId}\n                        SystemAPI={systemAPI}\n                        SystemDestroyEvent={systemDestroyEvent}\n                        NodeGroup={NodeGroups.Update}\n                        GradientStart={StyleColors.UpdateGroup}\n                        GradientEnd={StyleColors.RenderGroup}\n                    />\n                    <NodeGroup\n                        SystemId={systemId}\n                        SystemAPI={systemAPI}\n                        SystemDestroyEvent={systemDestroyEvent}\n                        NodeGroup={NodeGroups.Render}\n                        GradientStart={StyleColors.RenderGroup}\n                        GradientEnd={StyleColors.EndGroup}\n                    />\n                </Div>\n            </Div>\n        </textbutton>\n    );\n}\n\nexport default React.memo(NodeSystem);\n\n'Lumina/src/Components/SizeConfig.ts'\n:export const SYSTEM_WIDTH = 300;\nexport const SYSTEM_PADDING = 10;\nexport const SYSTEM_HEADER_HEIGHT = 22;\nexport const SYSTEM_LIST_PADDING = 10;\nexport const SYSTEM_BORDER_THICKNESS = 3;\n\nexport const GROUP_HEADER_HEIGHT = 20;\nexport const GROUP_BORDER_THICKNESS = 2;\nexport const GROUP_PADDING = 6;\nexport const GROUP_LIST_PADDING = 5;\n\nexport const NODE_WIDTH = 250;\n\n'Lumina/src/Components/Systems/CreateBurstSystem.ts'\n:import { NodeGroups } from \"API/NodeGroup\";\nimport { CalculationType1 } from \"API/Nodes/FieldStates\";\nimport type { SetLifetime } from \"API/Nodes/Initialize/SetLifetime\";\nimport type { Position } from \"API/Nodes/Mixed/Position\";\nimport type { Velocity } from \"API/Nodes/Mixed/Velocity\";\nimport { CreatePosition } from \"Components/Nodes/Initialize/Position\";\nimport { CreateSetLifetime } from \"Components/Nodes/Initialize/SetLifetime\";\nimport { CreateVelocity } from \"Components/Nodes/Mixed/Velocity\";\nimport { CreatePlaneParticle } from \"Components/Nodes/Render/PlaneParticle\";\nimport { CreateBurstSpawn } from \"Components/Nodes/Spawn/BurstSpawn\";\nimport { CreateEmptySystem } from \"./CreateEmptySystem\";\n\nexport function CreateBurstSystem() {\n    const system = CreateEmptySystem();\n    const systemData = system.data;\n    systemData.systemName = \"Burst System\";\n\n    systemData.finishedBindingGroups.Connect(() => {\n        const burstSpawn = CreateBurstSpawn();\n        burstSpawn.elementLoaded.Connect(() => {\n            (systemData.addToNodeGroup[NodeGroups.Spawn] as (id: number) => void)(burstSpawn.data.node.id);\n        });\n\n        const setLifetimeRandom = CreateSetLifetime();\n        (setLifetimeRandom.data.node as SetLifetime).nodeFields.calculationType.SetState(CalculationType1.Random);\n        (setLifetimeRandom.data.node as SetLifetime).nodeFields.range.SetVector2(0.4, 0.8);\n        setLifetimeRandom.elementLoaded.Connect(() => {\n            (systemData.addToNodeGroup[NodeGroups.Initialize] as (id: number) => void)(setLifetimeRandom.data.node.id);\n        });\n\n        const position = CreatePosition();\n        (position.data.node as Position).nodeFields.position.SetY(5);\n        position.elementLoaded.Connect(() => {\n            (systemData.addToNodeGroup[NodeGroups.Initialize] as (id: number) => void)(position.data.node.id);\n        });\n\n        const velocity = CreateVelocity();\n        (velocity.data.node as Velocity).nodeFields.calculationType.SetState(CalculationType1.Random);\n        (velocity.data.node as Velocity).nodeFields.rangeX.SetVector2(-5, 5);\n        (velocity.data.node as Velocity).nodeFields.rangeY.SetVector2(-5, 5);\n        (velocity.data.node as Velocity).nodeFields.rangeZ.SetVector2(-5, 5);\n        velocity.elementLoaded.Connect(() => {\n            (systemData.addToNodeGroup[NodeGroups.Initialize] as (id: number) => void)(velocity.data.node.id);\n        });\n\n        const particlePlane = CreatePlaneParticle();\n        particlePlane.elementLoaded.Connect(() => {\n            (systemData.addToNodeGroup[NodeGroups.Render] as (id: number) => void)(particlePlane.data.node.id);\n        });\n    });\n\n    return system;\n}\n",
        "gt": [
            "'Lumina/src/Components/SizeConfig.ts'",
            "'Lumina/src/Components/Systems/NodeSystem.tsx'",
            "'Lumina/src/Components/Systems/CreateEmptySystem.tsx'",
            "'Lumina/src/Components/Systems/CreateBurstSystem.ts'"
        ]
    },
    {
        "files": [
            "'installer-gui/frontend/components/icons/close.tsx'",
            "'installer-gui/frontend/components/fileinput.tsx'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'",
            "'installer-gui/frontend/components/actions/update.tsx'"
        ],
        "content": "'installer-gui/frontend/components/icons/close.tsx'\n:import Preact from \"preact\";\n\nexport default function Close(props: any) {\n    return (\n        <svg fill=\"currentColor\" xmlns=\"http:\n            <path d=\"M 4.7070312 3.2929688 L 3.2929688 4.7070312 L 10.585938 12 L 3.2929688 19.292969 L 4.7070312 20.707031 L 12 13.414062 L 19.292969 20.707031 L 20.707031 19.292969 L 13.414062 12 L 20.707031 4.7070312 L 19.292969 3.2929688 L 12 10.585938 L 4.7070312 3.2929688 z\" />\n        </svg>\n    );\n}\n'installer-gui/frontend/components/fileinput.tsx'\n:import Preact, {Component} from \"preact\";\nimport \"./fileinput.scss\";\nimport {ipcRenderer as IPC} from \"electron\";\nimport IPCEvents from \"@common/ipcevents\";\nimport CaretRight from \"./icons/caret_right\";\nimport CaretDown from \"./icons/caret_down\";\nimport fs from \"fs\";\nimport Close from \"./icons/close\";\n\nclass FileBrowser {\n    static async openPath(title: string): Promise<string[]> {\n        const result = await IPC.invoke(IPCEvents.BROWSE_PATHS, {\n            title: title,\n            properties: [\"openDirectory\", \"multiSelections\"]\n        });\n        return result.filePaths;\n    }\n}\n\nexport default class FileInput extends Component<{\n    onChange: (paths: string[]) => void;\n    title: string;\n    name: string;\n    files: string[];\n    onRemove(path: string): void;\n}, {\n    expanded: boolean;\n}> {\n    state = {files: [], expanded: true};\n\n    handleBrowse = (event: MouseEvent): void => {\n        event.preventDefault();\n        event.stopPropagation();\n        FileBrowser.openPath(this.props.title).then((paths) => {\n            const files = [...new Set(this.props.files.concat(paths))];\n            this.props.onChange(files);\n        });\n    }\n\n    renderFile = (path: string, index: number) => {\n        return (\n            <div class=\"file\" key={path}>\n                <div class=\"filename\">{path}</div>\n                <button class=\"inline\" onClick={() => this.props.onRemove(path)}>\n                    <Close width=\"16\" height=\"16\" />\n                </button>\n            </div>\n        );\n    }\n\n    handleExpandChange = (): void => {\n        if (!this.props.files.length) return;\n\n        this.setState(prev => ({expanded: !prev.expanded}));\n    }\n\n    render({name, title, files}, {expanded}) {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">{title}</div>\n                <div class=\"file-picker\">\n                    <div class=\"header\">\n                        <div class=\"name\">{name}</div>\n                        <button\n                            class=\"browse-file\"\n                            onClick={this.handleBrowse}\n                        >Browse</button>\n                        <button class=\"inline expandButton\" onClick={this.handleExpandChange} disabled={!files.length}>\n                            {(files.length && expanded) ? <CaretDown /> : <CaretRight />}\n                        </button>\n                    </div>\n                    {expanded && files.map(this.renderFile)}\n                </div>\n            </div>\n        );\n    }\n}\n'installer-gui/frontend/components/App.tsx'\n:import Preact, {Component} from \"preact\";\nimport InstallPage from \"./actions/install\";\nimport UninstallPage from \"./actions/uninstall\";\nimport UpdatePage from \"./actions/update\";\nimport AppContext from \"./AppContext\";\nimport Category from \"./category\";\nimport Install from \"./icons/install\";\nimport Uninstall from \"./icons/uninstall\";\nimport Update from \"./icons/update\";\nimport {Notifications} from \"./notifications\";\nimport TitleBar from \"./titlebar\";\n\nexport default class App extends Component {\n    state = {navigator: {}}\n\n    handleSetPage({element, title}): void {\n        this.setState({\n            navigator: {element, title}\n        });\n    }\n\n    handleReset(): void {\n        this.setState({navigator: {}});\n    }\n\n    renderHome() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Actions</div>\n                <Category title=\"Install\" icon={Install} note=\"Install kernel to an application you choose.\">\n                    <InstallPage />\n                </Category>\n                <Category title=\"Uninstall\" icon={Uninstall} note=\"Uninstall kernel from an application you choose.\">\n                    <UninstallPage />\n                </Category>\n                <Category title=\"Update\" icon={Update} note=\"Update the kernel.asar to the latest release.\">\n                    <UpdatePage />\n                </Category>\n            </div>\n        );\n    }\n\n    render(_, {navigator}) {\n        const context = {\n            currentPage: navigator,\n            setPage: this.handleSetPage.bind(this),\n            reset: this.handleReset.bind(this)\n        };\n\n        return (\n            <AppContext.Provider value={context}>\n                <div id=\"app-mount\">\n                    <TitleBar />\n                    <div class=\"app\">\n                        {navigator.element ? navigator.element : this.renderHome()}\n                    </div>\n                    <Notifications />\n                </div>\n            </AppContext.Provider>\n        );\n    }\n}\n'installer-gui/frontend/index.ts'\n:import {h, render} from \"preact\";\nimport App from \"./components/App\";\nimport Styles from \"./styles\";\nimport {createElement} from \"./util\";\nimport \"./index.scss\";\n\nStyles.inject();\nconst root = createElement(\"div\", {id: \"root\"});\ndocument.body.appendChild(root);\n\nrender(\n    h(App, {}),\n    root\n);\n'installer-gui/frontend/components/actions/update.tsx'\n:import Preact, {Component} from \"preact\";\nimport AppContext from \"../AppContext\";\nimport Terminal from \"../terminal\";\nimport {ipcRenderer as IPC} from \"electron\";\nimport IPCEvents from \"@common/ipcevents\";\nimport FileInput from \"../fileinput\";\nimport Updater from \"../../modules/updater\";\n\nexport default class UpdatePage extends Component<{}, {\n    isBrowsing: boolean;\n    updateDone: boolean;\n    kernelPath: string;\n}> {\n    terminalRef = Preact.createRef();\n\n    state = {\n        isBrowsing: true,\n        updateDone: false,\n        kernelPath: \"\"\n    };\n\n    renderUpdating() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Update Kernel</div>\n                <Terminal ref={this.terminalRef} />\n            </div>\n        );\n    }\n\n    renderBrowser() {\n        return (\n            <FileInput\n                title=\"Kernel path\"\n                name=\"Kernel path\"\n                onChange={([path]) => this.setState({kernelPath: path})}\n                files={[this.state.kernelPath].filter(Boolean)}\n                onRemove={() => {\n                    this.setState({kernelPath: \"\"});\n                }}\n            />\n        );\n    }\n\n    handleUpdate(): void {\n        Updater.update(this.state.kernelPath, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({updateDone: true});\n        });\n    }\n\n    render(_, {isBrowsing, updateDone}) {\n        return (\n            <AppContext.Consumer>\n                {App => (\n                    <div class=\"installing\">\n                        <div class=\"scroller\">\n                            {isBrowsing ? this.renderBrowser() : this.renderUpdating()}\n                            <div class=\"margin-bottom10\" />\n                        </div>\n                        <div class=\"footer\">\n                            <button onClick={() => {\n                                if (isBrowsing) App.reset();\n                                else this.setState({isBrowsing: true});\n                            }}>Back</button>\n                            <button\n                                onClick={() => {\n                                    if (updateDone) return IPC.send(IPCEvents.CLOSE_APP);\n                                    if (!isBrowsing) {\n                                        this.handleUpdate();\n                                    } else {\n                                        this.setState({isBrowsing: false});\n                                    }\n                                }}\n                            >\n                                {isBrowsing ? \"Continue\" : updateDone ? \"Close\" : \"Update\"}\n                            </button>\n                        </div>\n                    </div>\n                )}\n            </AppContext.Consumer>\n        );\n    }\n}",
        "gt": [
            "'installer-gui/frontend/components/icons/close.tsx'",
            "'installer-gui/frontend/components/fileinput.tsx'",
            "'installer-gui/frontend/components/actions/update.tsx'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'"
        ]
    },
    {
        "files": [
            "'lemmy-fennec/Screens/Profile/OwnComments.tsx'",
            "'lemmy-fennec/Screens/User/UserScreen.tsx'",
            "'lemmy-fennec/components/Pagination.tsx'",
            "'lemmy-fennec/App.tsx'"
        ],
        "content": "'lemmy-fennec/Screens/Profile/OwnComments.tsx'\n:import React from \"react\";\nimport { FlatList, Share, StyleSheet, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { CommentView } from \"lemmy-js-client\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport { commonColors, commonStyles } from \"../../commonStyles\";\nimport Pagination from \"../../components/Pagination\";\n\nimport MiniComment from \"../../components/TinyComment\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { preferences } from \"../../store/preferences\";\n\n\n\nfunction OwnComments({ navigation }) {\n  const { colors } = useTheme();\n  const comments = apiClient.profileStore.userProfile?.comments ?? [];\n\n  const refresh = () => {\n    apiClient.profileStore.setProfilePage(1);\n    void apiClient.profileStore.getProfile({\n      person_id: apiClient.profileStore.userProfile.person_view.person.id,\n      limit: 30,\n    });\n  };\n\n  const getPost = (comment: CommentView) => {\n    navigation.navigate(\"Post\", {\n      post: comment.post.id,\n      openComment: 0,\n      parentId: comment.comment.path.split(\".\")[1],\n    });\n  };\n\n  const nextPage = () => {\n    apiClient.profileStore.setProfilePage(\n      apiClient.profileStore.profilePage + 1\n    );\n    void apiClient.profileStore.getProfile({\n      person_id: apiClient.profileStore.userProfile.person_view.person.id,\n      limit: 30,\n    });\n  };\n  const prevPage = () => {\n    if (apiClient.profileStore.profilePage === 1) return;\n    apiClient.profileStore.setProfilePage(\n      apiClient.profileStore.profilePage - 1\n    );\n    void apiClient.profileStore.getProfile({\n      person_id: apiClient.profileStore.userProfile.person_view.person.id,\n      limit: 30,\n    });\n  };\n\n  const renderItem = ({ item }) => <OwnComment item={item} getPost={getPost} />;\n  return (\n    <View style={{ flex: 1 }}>\n      <FlatList\n        data={comments}\n        onRefresh={refresh}\n        style={styles.container}\n        refreshing={apiClient.profileStore.isLoading}\n        ItemSeparatorComponent={() => (\n          <View\n            style={{ height: 1, width: \"100%\", backgroundColor: colors.border }}\n          />\n        )}\n        ListEmptyComponent={\n          <View style={styles.container}>\n            <Text style={styles.empty}>Nothing is here for now...</Text>\n          </View>\n        }\n        keyExtractor={(item) => item.comment.id.toString()}\n        renderItem={renderItem}\n      />\n      <Pagination\n        page={apiClient.profileStore.profilePage}\n        nextPage={nextPage}\n        prevPage={prevPage}\n        itemsLength={comments?.length ?? 0}\n      />\n    </View>\n  );\n}\n\nfunction OwnComment({\n  item,\n  getPost,\n}: {\n  item: CommentView;\n  getPost: (comment: CommentView) => void;\n}) {\n  return (\n    <View>\n      <MiniComment\n        published={item.comment.published}\n        author={\"\"}\n        isSelf\n        communityPic={item.community.icon}\n        community={item.community.name}\n        title={item.post.name}\n        content={item.comment.content}\n      />\n      <View\n        style={{\n          ...commonStyles.iconsRow,\n          flexDirection: preferences.leftHanded ? \"row-reverse\" : \"row\",\n        }}\n      >\n        <View style={{ flex: 1 }} />\n        <TouchableOpacity simple onPressCb={() => getPost(item)}>\n          <Icon name={\"corner-down-right\"} size={24} />\n        </TouchableOpacity>\n        <TouchableOpacity\n          simple\n          onPressCb={() =>\n            Share.share({\n              url: item.comment.ap_id,\n              message: item.comment.ap_id,\n            })\n          }\n        >\n          <Icon\n            name={\"share-2\"}\n            accessibilityLabel={\"share comment button\"}\n            size={24}\n          />\n        </TouchableOpacity>\n        <View style={styles.row}>\n          <Icon\n            name={\"arrow-up\"}\n            color={preferences.voteColors.upvote}\n            size={24}\n          />\n          <Text customColor={preferences.voteColors.upvote}>\n            {item.counts.upvotes}\n          </Text>\n        </View>\n        <View style={styles.row}>\n          <Icon\n            name={\"arrow-down\"}\n            color={preferences.voteColors.downvote}\n            size={24}\n          />\n          <Text customColor={preferences.voteColors.downvote}>\n            {item.counts.downvotes}\n          </Text>\n        </View>\n      </View>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    paddingHorizontal: 12,\n    paddingVertical: 4,\n  },\n  comment: {\n    paddingVertical: 8,\n  },\n  empty: {\n    fontSize: 16,\n  },\n  row: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 6,\n  },\n  topRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 6,\n  },\n});\n\nexport default observer(OwnComments);\n\n'lemmy-fennec/Screens/User/UserScreen.tsx'\n:import React from \"react\";\nimport { ActivityIndicator, View } from \"react-native\";\n\nimport { createMaterialTopTabNavigator } from \"@react-navigation/material-top-tabs\";\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { apiClient } from \"../../store/apiClient\";\nimport OwnComments from \"../Profile/OwnComments\";\nimport OwnPosts from \"../Profile/OwnPosts\";\nimport User from \"./User\";\n\nconst Tab = createMaterialTopTabNavigator();\n\nfunction UserScreen({\n  route,\n  navigation,\n}: NativeStackScreenProps<any, \"User\">) {\n  const loadedProfile = apiClient.profileStore.userProfile;\n  const person = loadedProfile?.person_view?.person;\n\n  React.useEffect(() => {\n    const title =\n      apiClient.profileStore.isLoading || !person\n        ? \"Loading User...\"\n        : `@${person.name}`;\n    navigation.setOptions({\n      title: title,\n    });\n  }, [person, navigation, apiClient.profileStore.isLoading]);\n\n  React.useEffect(() => {\n    const paramsPresent = route.params?.personId || route.params?.username;\n    if (paramsPresent) {\n      void apiClient.profileStore.getProfile({\n        person_id: route.params.personId,\n        username: route.params.username,\n      });\n    }\n  }, [route.params?.personId, route.params?.username]);\n\n  if (!person || apiClient.profileStore.isLoading) {\n    return (\n      <View style={{ padding: 24 }}>\n        <ActivityIndicator />\n      </View>\n    );\n  }\n  return (\n    <Tab.Navigator initialRouteName={\"ForeignUser\"}>\n      <Tab.Screen\n        options={{\n          tabBarLabel: \"Profile\",\n        }}\n        name={\"ForeignUser\"}\n        component={User}\n      />\n      <Tab.Screen\n        options={{\n          tabBarLabel: \"Comments\",\n        }}\n        name={\"ForeignUserComments\"}\n        component={OwnComments}\n      />\n      <Tab.Screen\n        options={{\n          tabBarLabel: \"Posts\",\n        }}\n        name={\"ForeignUserPosts\"}\n        component={OwnPosts}\n      />\n    </Tab.Navigator>\n  );\n}\n\nexport default observer(UserScreen);\n\n'lemmy-fennec/components/Pagination.tsx'\n:import React from \"react\";\nimport { StyleSheet, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\n\nimport { Text, TouchableOpacity } from \"../ThemedComponents\";\n\ninterface Props {\n  prevPage: () => void;\n  nextPage: () => void;\n  itemsLength: number;\n  page: number;\n  isLoading?: boolean;\n}\n\nfunction Pagination({\n  prevPage,\n  nextPage,\n  itemsLength,\n  page,\n  isLoading,\n}: Props) {\n  const { colors } = useTheme();\n  return (\n    <View style={styles.paddedRow}>\n      {page > 1 && !isLoading ? (\n        <TouchableOpacity onPressCb={prevPage}>\n          <Text>Previous page</Text>\n        </TouchableOpacity>\n      ) : (\n        <TouchableOpacity\n          style={{ backgroundColor: colors.card }}\n          onPressCb={() => null}\n        >\n          <Text>Previous page</Text>\n        </TouchableOpacity>\n      )}\n      {itemsLength > 0 && !isLoading ? (\n        <TouchableOpacity onPressCb={nextPage}>\n          <Text>Next page</Text>\n        </TouchableOpacity>\n      ) : (\n        <TouchableOpacity\n          style={{ backgroundColor: colors.card }}\n          onPressCb={() => null}\n        >\n          <Text>Next page</Text>\n        </TouchableOpacity>\n      )}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  row: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 6,\n  },\n  paddedRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 8,\n    paddingVertical: 6,\n    paddingHorizontal: 8,\n  },\n});\n\nexport default Pagination;\n\n'lemmy-fennec/App.tsx'\n:import React from \"react\";\nimport { StatusBar, useColorScheme } from \"react-native\";\n\nimport { ActionSheetProvider } from \"@expo/react-native-action-sheet\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\n\nimport AddAccount from \"./Screens/AddAccount\";\nimport BlocksScreen from \"./Screens/Blocks/BlocksScreen\";\nimport CommentWrite from \"./Screens/CommentWrite/CommentWrite\";\nimport CommunityScreen from \"./Screens/Community/CommunityScreen\";\nimport DebugScreen from \"./Screens/DebugScreen\";\nimport HomeScreen from \"./Screens/HomeScreen\";\nimport LoginScreen from \"./Screens/LoginScreen\";\nimport PostScreen from \"./Screens/Post/PostScreen\";\nimport PostWrite from \"./Screens/PostWrite\";\nimport Behavior from \"./Screens/Settings/Behavior\";\nimport Looks from \"./Screens/Settings/Looks\";\nimport ProfileSettings from \"./Screens/Settings/ProfileSettings\";\nimport SettingsScreen from \"./Screens/SettingsScreen\";\nimport MessageWrite from \"./Screens/Unreads/MessageWrite\";\nimport UserScreen from \"./Screens/User/UserScreen\";\nimport { Icon } from \"./ThemedComponents\";\nimport { AppAmoledTheme, AppDarkTheme, AppTheme } from \"./commonStyles\";\nimport Prompt from \"./components/Prompt\";\nimport { ReportMode, apiClient } from \"./store/apiClient\";\nimport { Theme, preferences } from \"./store/preferences\";\n\nconst Stack = createNativeStackNavigator();\n\nconst App = observer(() => {\n  const scheme = useColorScheme();\n\n  const systemTheme = scheme === \"dark\" ? AppDarkTheme : AppTheme;\n  const isLightStatusBar =\n    preferences.theme === Theme.System\n      ? scheme !== \"dark\"\n      : preferences.theme === Theme.Light;\n\n  const schemeMap = {\n    [Theme.System]: systemTheme,\n    [Theme.Light]: AppTheme,\n    [Theme.Dark]: AppDarkTheme,\n    [Theme.Amoled]: AppAmoledTheme,\n  };\n\n  const sendReport = (text: string) => {\n    if (apiClient.reportMode === ReportMode.Post) {\n      apiClient.api\n        .createPostReport({\n          post_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    } else {\n      apiClient.api\n        .createCommentReport({\n          comment_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    }\n  };\n\n  const closeReport = () => {\n    apiClient.setShowPrompt(false);\n  };\n\n  const reportMode = apiClient.reportMode;\n  const promptActions =\n    reportMode !== ReportMode.Off\n      ? {\n          onCancel: closeReport,\n          onConfirm: sendReport,\n        }\n      : apiClient.promptActions;\n  return (\n    <SafeAreaProvider style={{ flex: 1 }}>\n      {}\n      <StatusBar\n        barStyle={isLightStatusBar ? \"dark-content\" : \"light-content\"}\n        backgroundColor={schemeMap[preferences.theme].colors.card}\n      />\n      <ActionSheetProvider>\n        <NavigationContainer theme={schemeMap[preferences.theme]}>\n          <Stack.Navigator initialRouteName={\"Home\"}>\n            <Stack.Screen\n              name=\"Home\"\n              component={HomeScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              name=\"Post\"\n              component={PostScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Comment\" }}\n              name={\"CommentWrite\"}\n              component={CommentWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Post\" }}\n              name={\"PostWrite\"}\n              component={PostWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"Message\" }}\n              name={\"MessageWrite\"}\n              component={MessageWrite}\n            />\n            <Stack.Screen\n              options={{\n                headerRight: () => <Icon name={\"arrow-up\"} size={24} />,\n              }}\n              name=\"Community\"\n              component={CommunityScreen}\n            />\n            <Stack.Screen name=\"Login\" component={LoginScreen} />\n            <Stack.Screen\n              options={{ headerTitle: \"Add Account\" }}\n              name={\"AddAccount\"}\n              component={AddAccount}\n            />\n            <Stack.Screen name=\"User\" component={UserScreen} />\n            <Stack.Screen name=\"Settings\" component={SettingsScreen} />\n            <Stack.Screen name=\"Debug\" component={DebugScreen} />\n            <Stack.Screen name=\"Blocks\" component={BlocksScreen} />\n            <Stack.Screen name=\"Looks\" component={Looks} />\n            <Stack.Screen name=\"Behavior\" component={Behavior} />\n            <Stack.Screen name=\"ProfileSettings\" component={ProfileSettings} />\n          </Stack.Navigator>\n          {apiClient.showPrompt ? (\n            <Prompt\n              text={`Describe whats wrong with this ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              title={`Report ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              reportMode={reportMode}\n              placeholder={\"Type a reason here\"}\n              onSubmit={promptActions.onConfirm}\n              onCancel={promptActions.onCancel}\n            />\n          ) : null}\n        </NavigationContainer>\n      </ActionSheetProvider>\n    </SafeAreaProvider>\n  );\n});\n\nexport default App;\n",
        "gt": [
            "'lemmy-fennec/components/Pagination.tsx'",
            "'lemmy-fennec/Screens/Profile/OwnComments.tsx'",
            "'lemmy-fennec/Screens/User/UserScreen.tsx'",
            "'lemmy-fennec/App.tsx'"
        ]
    },
    {
        "files": [
            "'Source-Engine-VSCode-Extension/src/main.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'",
            "'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/performance.ts'"
        ],
        "content": "'Source-Engine-VSCode-Extension/src/main.ts'\n:\n\n\n\n\nimport * as vscode from \"vscode\";\nimport * as vmt from \"./language/LangVmt\";\nimport * as captions from \"./language/LangCaptions\";\nimport * as keyvalue from \"./language/LangKv\";\nimport * as captionsCompile from \"./compiler/captions-compile\";\nimport * as modelCompile from \"./compiler/model-compile\";\nimport * as performance from \"./performance\";\nimport * as kvDetect from \"./KvFileDetection\";\n\nimport * as packageJson from \"../package.json\";\n\nexport let output: vscode.OutputChannel;\nexport let debugOutput: vscode.OutputChannel;\nexport let config: vscode.WorkspaceConfiguration;\n\nexport function deactivate(): void {}\nexport function activate(context: vscode.ExtensionContext): void {\n\n    output = vscode.window.createOutputChannel(\"Source Engine Support\");\n    debugOutput = vscode.window.createOutputChannel(\"Source Engine Support Debug\");\n    context.subscriptions.push(output, debugOutput);\n\n    updateConfig();\n    const configChangeEvent = vscode.workspace.onDidChangeConfiguration(updateConfig);\n    context.subscriptions.push(configChangeEvent);\n\n    kvDetect.init(context);\n\n    keyvalue.init(context);\n    vmt.init(context);\n    captions.init(context);\n\n    captionsCompile.init(context);\n    modelCompile.init(context);\n\n    output.appendLine(`Started Source Engine Support v${packageJson.version}`);\n\n    performance.init(context);\n}\n\n\nconst updateConfig = () => config = vscode.workspace.getConfiguration(\"sourceEngine\");\n\n'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'\n:\n\n\n\n\nimport * as shared from \"./Shared\";\nimport vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\n\nimport { ShaderParamCompletionItemProvider } from \"./ShaderParamCompletionItemProvider\";\nimport { ShaderParamHoverProvider } from \"./ShaderParamHoverProvider\";\nimport { ShaderParamColorsProvider } from \"./ShaderParamColorsProvider\";\nimport { VmtSemanticTokenProvider } from \"./VmtSemanticTokenProvider\";\n\n\nexport const selectorAll: ReadonlyArray<vscode.DocumentFilter> = [shared.filterVmtSaved, shared.filterVmtUnsaved];\n\nexport function init(context: vscode.ExtensionContext): void {\n\n    const vmtSemantics = vscode.languages.registerDocumentSemanticTokensProvider(selectorAll, new VmtSemanticTokenProvider(), KvDocument.tokenLegend);\n    const vmtCompletion = vscode.languages.registerCompletionItemProvider(selectorAll, new ShaderParamCompletionItemProvider(), \"$\", \"%\");\n    const vmtHover = vscode.languages.registerHoverProvider(selectorAll, new ShaderParamHoverProvider());\n    const vmtColors = vscode.languages.registerColorProvider(selectorAll, new ShaderParamColorsProvider());\n\n\n    context.subscriptions.push(vmtSemantics, vmtCompletion, vmtHover, vmtColors);\n}\n\n\n'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'\n:import vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\nimport { KvTokensProviderBase } from \"./KvTokensProviderBase\";\nimport { getColorMatches, ColorMatchParenthesisType, getMatrixMatches } from \"@sourcelib/vmt\";\nimport { getParentDocumentDirectory } from \"@sourcelib/fs\";\nimport { Token, isFloatValue, isScalarValue } from \"@sourcelib/kv\";\nimport { shaderParams, internalTextures } from \"@sourcelib/vmt\";\nimport { KvSemanticProcessor, KvSemanticProcessorParams } from \"./KvSemanticProcessor\";\nimport { KvPair } from \"../Kv\";\nimport * as main from \"../main\";\nimport fs from \"fs\";\nimport path from \"path\";\n\n\nexport class VmtSemanticTokenProvider extends KvTokensProviderBase {\n\n    protected keyProcessors: KvSemanticProcessor[] = [\n        { regex: /\\$\\w+/, processor: this.processKeyShader },\n        { regex: /%\\w+/, processor: this.processKeyCompile }\n    ];\n\n    protected valueProcessors: KvSemanticProcessor[] = [\n        { regex: /.*/, processor: this.processValue }\n    ];\n\n    constructor() {\n        super(KvDocument.tokenLegend, vscode.languages.createDiagnosticCollection(\"vmt\"));\n    }\n\n    processKeyShader(params: KvSemanticProcessorParams): boolean {\n        params.tokensBuilder.push(params.wholeRange, \"parameter\");\n        return true;\n    }\n\n    processKeyCompile(params: KvSemanticProcessorParams): boolean {\n        params.tokensBuilder.push(params.wholeRange, \"parameter\", [\"readonly\"]);\n        return true;\n    }\n\n    processValue(params: KvSemanticProcessorParams): boolean {\n\n\n        if (!params.kvPiece.range.isSingleLine)\n            return false;\n\n\n        const kv = params.kvDocument.getKeyValueAt(params.kvPiece.range.start.line);\n        if (kv == null)\n            return false;\n        const param = shaderParams.find(p => p.name === kv.key.content);\n        if (param == null) {\n            this.processValueString(kv, params.wholeRange, params.tokensBuilder, params.kvDocument);\n            return false;\n        }\n        if (param.type == null || param.type == \"unknown\")\n            return false;\n\n\n        switch (param.type) {\n        case \"bool\": this.processValueBool(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"int\": this.processValueInt(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"float\": this.processValueFloat(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"scalar\": this.processValueScalar(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"texture\": this.processValueTexture(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"color\": this.processValueColor(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"matrix\": this.processValueMatrix(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"env_cubemap\": this.processValueCubemap(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n\n        case \"string\":\n        default: this.processValueString(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        }\n        return true;\n    }\n\n    processValueBool(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (kv.value.content.match(/^[01]$/)) {\n            tokensBuilder.push(range, \"boolean\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a boolean (0 or 1).\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueInt(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (kv.value.content.match(/^\\d+$/)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting an integer.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueFloat(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (isFloatValue(kv.value.content)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a float.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueScalar(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (isScalarValue(kv.value.content)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a scalar. (0-1)\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueString(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        tokensBuilder.push(range, \"string\");\n    }\n\n    processValueTexture(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n        if (internalTextures.includes(kv.value.content)) {\n            tokensBuilder.push(range, \"keyword\");\n            return;\n        }\n        const validationEnabled = main.config.get<boolean>(\"vmt.validateTexturePaths\");\n        if(validationEnabled) {\n            const materialDir = getParentDocumentDirectory(kvDoc.document.uri.fsPath, \"materials\");\n            if (materialDir != null) {\n                const materialPath: string = path.join(materialDir, kv.value.content + \".vtf\");\n                if (!fs.existsSync(materialPath)) {\n                    this.diagnostics.push(new vscode.Diagnostic(range, \"Texture not found on disk\", vscode.DiagnosticSeverity.Warning));\n                }\n            }\n        }\n\n        tokensBuilder.push(range, \"string\");\n    }\n\n    processValueMatrix(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n\n        const matrixMatches = getMatrixMatches(kv.value.content);\n        if (!matrixMatches.validFormat) {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Invalid matrix format.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueColor(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n\n        const colorMatches = getColorMatches(kv.value.content);\n        if (!colorMatches.validFormat) {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Invalid color value. Format: [0 0.25 1] or {0 200 49}\", vscode.DiagnosticSeverity.Warning));\n            return;\n        }\n        if (colorMatches.valuesOutOfBounds) {\n            if (colorMatches.parenthesisType === ColorMatchParenthesisType.Brackets) {\n                this.diagnostics.push(new vscode.Diagnostic(range, \"Color values out of bounds. Must be between 0 and 1\", vscode.DiagnosticSeverity.Warning));\n            } else if (colorMatches.parenthesisType === ColorMatchParenthesisType.Braces) {\n                this.diagnostics.push(new vscode.Diagnostic(range, \"Color values out of bounds. Must be between 0 and 255\", vscode.DiagnosticSeverity.Warning));\n            }\n        }\n    }\n\n    processValueCubemap(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n        if (kv.value.content === \"env_cubemap\") {\n            tokensBuilder.push(range, \"keyword\");\n        } else {\n            tokensBuilder.push(range, \"string\");\n        }\n\n    }\n\n    protected override disallowDuplicate(scopedKey: string, depth: number, token: Token): boolean {\n        return depth === 1;\n    }\n}\n\n'Source-Engine-VSCode-Extension/src/performance.ts'\n:import { PerformanceObserver } from \"perf_hooks\";\nimport { ExtensionContext } from \"vscode\";\nimport * as main from \"./main\";\n\nconst performanceObserver = new PerformanceObserver((list) => {\n    const entry = list.getEntries()[0];\n    if(main.config.get<boolean>(\"performance.log\")) {\n        main.debugOutput.appendLine(`${entry.name}: ${entry.duration}ms`);\n    }\n});\n\nexport function init(context: ExtensionContext): void {\n    performanceObserver.observe({ entryTypes: [\"function\"] });\n}",
        "gt": [
            "'Source-Engine-VSCode-Extension/src/performance.ts'",
            "'Source-Engine-VSCode-Extension/src/main.ts'",
            "'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/order/error/fulfilled-order.error.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/payment/payment.controller.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/order/order.service.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'"
        ],
        "content": "'is-even/apps/backend/src/order/error/fulfilled-order.error.ts'\n:export class FulfilledOrderError extends Error {\n  constructor() {\n    super(`Order is already fulfilled.`);\n  }\n}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/payment/payment.controller.ts'\n:import {\n  Controller,\n  HttpException,\n  HttpStatus,\n  Post,\n  Body,\n  Request,\n  HttpCode,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOkResponse,\n  ApiCreatedResponse,\n  ApiUnauthorizedResponse,\n  ApiForbiddenResponse,\n  ApiNotFoundResponse,\n  ApiInternalServerErrorResponse,\n} from '@nestjs/swagger';\n\nimport { OrderService } from '../order/order.service';\nimport { StripeService } from '../stripe/stripe.service';\nimport { PaymentService } from './payment.service';\nimport { LoggerService } from '../logger/logger.service';\nimport { SentryService } from '../sentry/sentry.service';\n\nimport { RegisterPaymentDto } from './dto/register-payment.dto';\n\nimport { Authorised } from '../auth/auth.decorator';\nimport { PaymentSession } from './interface/payment-session.interface';\nimport { RequestWithUser } from '../common/interface/request-with-user.interface';\n\nimport { UnathorizedOrderError } from '../order/error/unathorized-order.error';\nimport { ReadOrderError } from '../order/error/read-order.error';\n\nimport { sessionEventMapper } from './mapper/session-event.mapper';\nimport { RequestWithRawBody } from 'src/common/middlewere/webhook-raw-body.middlewere';\nimport { PaymentStatus } from './interface/payment-status.interface';\n\n@ApiTags('payments')\n@Controller('payments')\nexport class PaymentController {\n  constructor(\n    private readonly stripeService: StripeService,\n    private readonly orderService: OrderService,\n    private readonly paymentService: PaymentService,\n    private readonly loggerService: LoggerService,\n    private readonly sentryService: SentryService,\n  ) {}\n\n  @Post('/register')\n  @Authorised()\n  @ApiCreatedResponse({ description: 'Payment registered' })\n  @ApiUnauthorizedResponse({ description: 'Unathorized' })\n  @ApiForbiddenResponse({ description: 'Access forbidden' })\n  @ApiNotFoundResponse({ description: 'Not found' })\n  @ApiInternalServerErrorResponse({ description: 'Internal server error' })\n  public async registerPayment(\n    @Body() registerPaymentDto: RegisterPaymentDto,\n    @Request() request: RequestWithUser,\n  ): Promise<PaymentSession> {\n    try {\n      this.loggerService.log(\n        `Registering payment for order: ${registerPaymentDto.orderId}`,\n      );\n\n      const user = request.user;\n      const { orderId } = registerPaymentDto;\n\n      const order = await this.orderService.getOrderById(orderId);\n\n      this.orderService.checkOrderOwner(order, user);\n      this.orderService.checkOrderFulfillment(order);\n\n      const session = await this.paymentService.registerPayment(order);\n\n      await this.paymentService.createPayment(session.id, order);\n\n      return session;\n    } catch (error) {\n      this.loggerService.error(`Failed to register payment: ${error.message}`);\n\n      if (error instanceof ReadOrderError) {\n        throw new HttpException('Not found', HttpStatus.NOT_FOUND);\n      }\n      if (error instanceof UnathorizedOrderError) {\n        throw new HttpException('Access forbidden', HttpStatus.FORBIDDEN);\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Post('/verify')\n  @HttpCode(200)\n  @ApiOkResponse({ description: 'Payment verified' })\n  @ApiInternalServerErrorResponse({ description: 'Internal server error' })\n  public async verifyPayment(\n    @Request() request: RequestWithUser & RequestWithRawBody,\n  ): Promise<void> {\n    try {\n      const signature = request.headers['stripe-signature'];\n\n      const stripeEvent = await this.stripeService.constructEvent(\n        request.rawBody,\n        signature,\n      );\n      const event = sessionEventMapper(stripeEvent);\n\n      switch (event.type) {\n        case 'checkout.session.completed': {\n          const session = event.data as PaymentSession;\n          const payment = await this.paymentService.getPaymentBySessionId(\n            session.id,\n          );\n\n          await this.paymentService.updatePaymentStatus(\n            payment,\n            PaymentStatus.Successful,\n          );\n          await this.orderService.fulfillOrder(payment.order);\n        }\n\n        default:\n          break;\n      }\n    } catch (error) {\n      this.loggerService.error(`Failed to verify payment: ${error.message}`);\n\n      this.sentryService.instance.withScope((scope) => {\n        scope.setTag('where', 'paymentController.verifyPayment');\n        this.sentryService.instance.captureException(error);\n      });\n\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/payment/payment.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { PaymentService } from './payment.service';\nimport { PaymentController } from './payment.controller';\nimport { Payment } from './payment.entity';\n\nimport { LoggerModule } from '../logger/logger.module';\nimport { StripeModule } from '../stripe/stripe.module';\nimport { OrderModule } from '../order/order.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [PaymentService],\n  controllers: [PaymentController],\n  imports: [\n    LoggerModule,\n    StripeModule,\n    OrderModule,\n    SentryModule,\n    TypeOrmModule.forFeature([Payment]),\n  ],\n  exports: [PaymentService],\n})\nexport class PaymentModule {}\n\n'is-even/apps/backend/src/order/order.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\n\nimport { CreditDuration } from '../credit/interface/credit-duration.interface';\nimport { CreditLimit } from '../credit/interface/credit-limit.interface';\nimport { OrderStatus } from './interface/order-status.interface';\n\nimport { LoggerService } from '../logger/logger.service';\nimport { CreditService } from '../credit/credit.service';\nimport { AppConfigService } from '../config/config.service';\nimport { SentryService } from '../sentry/sentry.service';\n\nimport { Order } from './order.entity';\nimport { User } from '../user/user.entity';\nimport { Credit } from '../credit/credit.entity';\n\nimport { UnathorizedOrderError } from './error/unathorized-order.error';\nimport { CreateOrderError } from './error/create-order.error';\nimport { ReadOrderError } from './error/read-order.error';\nimport { UpdateOrderError } from './error/update-order.error';\nimport { InvalidOrderStatusError } from './error/invalid-order-status.error';\nimport { FulfilledOrderError } from './error/fulfilled-order.error';\n\n@Injectable()\nexport class OrderService {\n  constructor(\n    private readonly loggerService: LoggerService,\n    @InjectRepository(Order)\n    private readonly orderRepository: Repository<Order>,\n    private readonly creditService: CreditService,\n    private readonly configService: AppConfigService,\n    private readonly sentryService: SentryService,\n  ) {\n    this.loggerService.setContext(OrderService.name);\n  }\n\n  public async createOrder(\n    creditLimit: CreditLimit,\n    creditDuration: CreditDuration,\n    user: User,\n  ): Promise<Order> {\n    try {\n      await this.checkOrderCreateConditions(user);\n\n      const price = this.calculateOrderPrice(creditLimit);\n\n      const order = new Order();\n\n      order.status = OrderStatus.Created;\n      order.creditDuration = creditDuration;\n      order.creditLimit = creditLimit;\n      order.price = price;\n      order.user = user;\n\n      return await this.orderRepository.save(order);\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to create a new order. ${error.message}`,\n      );\n\n      this.sentryService.instance.withScope((scope) => {\n        scope.setTag('where', 'orderService.createOrder');\n        scope.setExtra('creditLimit', creditLimit);\n        scope.setExtra('creditDuration', creditDuration);\n        this.sentryService.instance.captureException(error);\n      });\n\n      throw new CreateOrderError(error);\n    }\n  }\n\n  public async getOrders(user: User): Promise<Order[]> {\n    try {\n      return await this.orderRepository.find({\n        where: {\n          user,\n        },\n      });\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to read a orders for a user. ${error.message}`,\n      );\n      throw new ReadOrderError(error);\n    }\n  }\n\n  public async getOrderById(id: string): Promise<Order> {\n    try {\n      return await this.orderRepository.findOneOrFail({\n        where: {\n          id,\n        },\n      });\n    } catch (error) {\n      this.loggerService.error(`Failed to read a order. ${error.message}`);\n      throw new ReadOrderError(error);\n    }\n  }\n\n  public async updateOrderStatus(\n    order: Order,\n    status: OrderStatus,\n  ): Promise<Order> {\n    if (order.status === status) {\n      this.loggerService.error(\n        `Cannot update order status with the exact same value`,\n      );\n      throw new InvalidOrderStatusError(\n        `Cannot update order status with the exact same value`,\n      );\n    }\n\n    if (\n      status === OrderStatus.Created &&\n      order.status !== OrderStatus.Created\n    ) {\n      this.loggerService.error(\n        `Cannot change the order's status to Created again`,\n      );\n      throw new InvalidOrderStatusError(\n        `Cannot change the order's status to Created again`,\n      );\n    }\n\n    order.status = status;\n\n    try {\n      return await this.orderRepository.save(order);\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to update order status. ${error.message}`,\n      );\n      throw new UpdateOrderError(error);\n    }\n  }\n\n  public async fulfillOrder(order: Order): Promise<Order> {\n    try {\n      this.loggerService.log(`Fulfilling order: ${order.id}`);\n\n      const { creditLimit, creditDuration } = order;\n\n      const credit = await this.creditService.createCredit(\n        creditLimit,\n        creditDuration,\n        order.user,\n      );\n\n      order.credit = credit;\n      order.status = OrderStatus.Fulfilled;\n\n      return await this.orderRepository.save(order);\n    } catch (error) {\n      this.loggerService.error('Failed to fulfill and save order.');\n      throw new UpdateOrderError(error);\n    }\n  }\n\n  public checkOrderOwner(order: Order, user: User): void {\n    if (!order.belongsTo(user.id)) {\n      this.loggerService.error(`Order does not belong to the user.`);\n      throw new UnathorizedOrderError();\n    }\n  }\n\n  public checkOrderFulfillment(order: Order): void {\n    if (order.status === OrderStatus.Fulfilled) {\n      this.loggerService.error('Order is already fulfilled');\n      throw new FulfilledOrderError();\n    }\n  }\n\n  private async checkOrderCreateConditions(user: User): Promise<void> {\n    let credit: Credit;\n\n    try {\n      credit = await this.creditService.getActiveCredit(user);\n    } catch {}\n\n    if (credit) {\n      throw new Error('User has active credit');\n    }\n  }\n\n  private calculateOrderPrice(limit: CreditLimit): number {\n    const creditsConfig = this.configService.pricesConfig;\n\n    switch (limit) {\n      case CreditLimit.Free:\n        return creditsConfig.Free;\n      case CreditLimit.Standard:\n        return creditsConfig.Standard;\n      default:\n        throw new Error(`Cannot calculate price for limit type ${limit}`);\n    }\n  }\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n",
        "gt": [
            "'is-even/apps/backend/src/order/error/fulfilled-order.error.ts'",
            "'is-even/apps/backend/src/order/order.service.ts'",
            "'is-even/apps/backend/src/payment/payment.controller.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'ngrx-example/src/app/_people/services/people-selectors.service.ts'",
            "'ngrx-example/src/app/_people/routes/people.detail.route/people.detail.route.ts'",
            "'ngrx-example/src/app/_people/routes/people.routes.ts'",
            "'ngrx-example/src/main.browser.ts'",
            "'ngrx-example/src/app/services/utils.service.ts'",
            "'ngrx-example/src/app/routes/routes.ts'"
        ],
        "content": "'ngrx-example/src/app/_people/services/people-selectors.service.ts'\n:import { ISelector } from '../../interfaces/ISelector';\nimport { IEntities } from '../../interfaces/IEntities';\nimport { IState } from '../../interfaces/IState';\nimport { IPeople } from '../interfaces/IPeople';\nimport { IPerson } from '../interfaces/IPerson';\n\nimport { recursiveReduce } from '../../services/utils.service';\n\nexport const getPeople$ = (): ISelector<IState, IPeople>  => {\n  return state$ => state$\n    .map((res: IState) => res.people)\n    .distinctUntilChanged();\n};\n\nexport const getEntities$ = (): ISelector<IState, Object>  => {\n  return state$ => state$\n    .map((res: IState) => res.entities)\n    .map((res: IEntities) => res.people);\n};\n\nexport const getList$ = (): ISelector<IState, Array<any>> => {\n  return state$ => state$\n    .let(getPeople$())\n    .combineLatest(\n      state$.let(getEntities$()),\n      (people, entities) => {\n        if (people.result && people.result.length) {\n        return people.result\n          .reduce((arr, id) => {\n            arr.push(entities[id]);\n\n            return arr;\n          }, [])\n\n          .sort((a, b) => {\n            if (a[people.sort] < b[people.sort]) {\n              return -1;\n            } else if (a[people.sort] > b[people.sort]) {\n              return 1;\n            } else {\n              return 0;\n            }\n          });\n        } else {\n          return [];\n        }\n      }\n    )\n};\n\nexport const getOne$ = (id): ISelector<IState, IPerson> => {\n  return state$ => state$\n    .let(getEntities$())\n    .map(peopleEnt => {\n      if (peopleEnt[id]) {\n        return peopleEnt[id];\n      }\n\n      return {};\n    });\n};\n'ngrx-example/src/app/_people/routes/people.detail.route/people.detail.route.ts'\n:import {\n  Component,\n  OnInit,\n  OnDestroy\n} from 'angular2/core';\n\n\nimport { Observable } from 'rxjs/Observable';\nimport { Subscription } from 'rxjs/Subscription';\nimport { RouteParams } from '@ngrx/router';\nimport { Store } from '@ngrx/store';\n\n\nimport { IPerson } from '../../interfaces/IPerson';\n\n\nimport { one } from '../../services/people-actions.service';\n\n\nimport { getOne$ } from '../../services/people-selectors.service';\n\n\nimport { PersonDetailComponent } from '../../components/person-detail.component/person-detail.component';\n\n@Component({\n  selector: 'people-detail-route',\n  directives: [ PersonDetailComponent ],\n  template: require('./people.detail.route.html')\n})\nexport class PeopleDetailRoute implements OnInit, OnDestroy {\n  public person$: Observable<IPerson> = this._params.pluck('id')\n    .mergeMap(id => this._store.let(getOne$(id)))\n\n\n  public queryIdSetAction$ = this._params.pluck('id').map(one());\n\n\n  private _subscription: Subscription;\n\n  constructor(\n    private _store: Store<any>,\n    private _params: RouteParams) {}\n\n  ngOnInit() {\n    this._subscription = Observable\n      .merge(\n        this.queryIdSetAction$\n      )\n      .subscribe(this._store);\n  }\n\n  ngOnDestroy() {\n    this._subscription.unsubscribe();\n  }\n}\n\n'ngrx-example/src/app/_people/routes/people.routes.ts'\n:import { Routes } from '@ngrx/router';\n\nimport { PeopleRoute } from './people.route/people.route';\nimport { PeopleListRoute } from './people.list.route/people.list.route';\nimport { PeopleDetailRoute } from './people.detail.route/people.detail.route';\nimport { PeopleEditRoute } from './people.edit.route/people.edit.route';\n\nexport const peopleRoutes: Routes = [\n  {\n    path: '/people',\n    component: PeopleRoute,\n    indexRoute: {\n      component: PeopleListRoute\n    },\n    children: [\n      {\n        path: ':id',\n        component: PeopleDetailRoute\n      },\n      {\n        path: ':id/edit',\n        component: PeopleEditRoute\n      }\n    ]\n  }\n];\n\n'ngrx-example/src/main.browser.ts'\n:\nimport { bootstrap } from 'angular2/platform/browser';\n\nimport { DIRECTIVES, PIPES, PROVIDERS } from './platform/browser';\nimport { ENV_PROVIDERS } from './platform/environment';\n\n\nimport { AppComponent, APP_PROVIDERS } from './app';\n\n\nimport { APP_ROUTES_PROVIDER } from './app/routes/routes';\n\n\nimport { APP_REDUCERS_PROVIDER } from './app/reducers/reducers';\n\n\nimport { APP_COMPONENTS_PROVIDERS } from './app/components/components';\nimport { APP_CONTAINERS_PROVIDERS } from './app/containers/containers';\n\n\nimport { APP_SERVICES } from './app/services/services';\n\n\nexport function main(initialHmrState?: any): Promise<any> {\n\n  return bootstrap(AppComponent, [\n    ...ENV_PROVIDERS,\n    ...PROVIDERS,\n    ...DIRECTIVES,\n    ...PIPES,\n    ...APP_PROVIDERS,\n    APP_ROUTES_PROVIDER,\n    APP_REDUCERS_PROVIDER,\n    APP_COMPONENTS_PROVIDERS,\n    APP_CONTAINERS_PROVIDERS,\n    APP_SERVICES\n  ])\n  .catch(err => console.error(err));\n\n}\n\n\nif ('development' === ENV && HMR === true) {\n\n  let ngHmr = require('angular2-hmr');\n  ngHmr.hotModuleReplacement(main, module);\n} else {\n\n  document.addEventListener('DOMContentLoaded', () => main());\n}\n\n'ngrx-example/src/app/services/utils.service.ts'\n:import { Saga } from 'store-saga';\n\nvar flattenDeep = require('lodash/flattenDeep');\nvar uniq = require('lodash/uniq');\n\nimport { SET_ERROR } from '../reducers/errors.reducer';\n\nexport function recursiveReduce(\n  source: Array<number>,\n  entities: Object,\n  by: string,\n  entryLevel?: number): Array<any> {\n\n  return source.reduce((arr, id) => {\n    var ent = Object.assign({}, entities[id]);\n\n    if (ent.level === entryLevel || !entryLevel) {\n      if (ent[by] && ent[by].length) {\n        ent[by] = recursiveReduce(ent[by], entities, by);\n      }\n      arr.push(ent);\n    }\n\n    return arr;\n\n  }, []);\n\n}\n\nexport const getSingleEntityObject = (\n  name: string,\n  id: number,\n  payload: Object) => {\n\n  var data = { entities: {} };\n  data.entities[name] = {};\n  data.entities[name][id] = payload;\n\n  return data;\n};\n\nexport const getUncachedEntities = (\n  source: Array<any>,\n  key: string,\n  from: Object): Array<any> => {\n\n  let ids = uniq(flattenDeep(source.map(res => res[key])));\n\n  return ids.reduce((arr, id) => {\n    if (!from[id]) {\n      arr.push(id);\n    }\n    return arr;\n  }, []);\n};\n\nexport const getUrlWithIds = (\n  url: string,\n  ids?: Array<number>) => {\n\n  var append = ids ? `?ids=${ids.join(',')}` : '';\n  return `/${url + append}`;\n};\n\n\nexport const shouldLoad = (entity: string, key: string): Saga<any> => {\n  return saga$ => saga$.filter(saga$ => {\n    return !saga$.state.entities[entity][saga$.action[key]];\n  });\n};\n\nexport function generateErrorPayload(payload, type: string) {\n  var r = {\n    type: SET_ERROR,\n    payload: {\n      errors: [],\n      key: type\n    }\n  };\n\n  if (payload.message) {\n    r.payload.errors.push({\n      text: payload.message,\n      main: true\n    });\n  }\n\n  if (payload.errors && payload.errors.length) {\n\n    if (typeof payload.errors === 'string') {\n      r.payload.errors.push({\n        text: payload.errors\n      });\n    } else {\n      payload.errors.forEach(item => {\n        r.payload.errors.push({\n          text: item\n        });\n      });\n    }\n\n\n  }\n\n  return r;\n};\n\nexport function generateResponse(payload, successType: string, errorType: string, cb?) {\n  var r = {};\n  if (payload.status < 400 || !payload.status) {\n    var asJson = payload.text() ? payload.json() : null;\n\n    r = Object.assign({}, r, {\n      type: successType,\n      payload: cb ? cb.call(this, asJson) : null\n    });\n\n  } else {\n    var payloadAsJson = payload.json();\n\n    r = Object.assign({}, r, generateErrorPayload(payloadAsJson, errorType));\n  }\n\n  return r;\n}\n\n'ngrx-example/src/app/routes/routes.ts'\n:import { provideRouter, Routes, createGuard } from '@ngrx/router';\n\nimport { FofRoute } from './fof.route/fof.route';\n\nimport { homeRoutes } from '../_home/routes/home.routes';\nimport { peopleRoutes } from '../_people/routes/people.routes';\nimport { authRoutes } from '../_auth/routes/auth.routes';\nimport { catsRoutes } from '../_cats/routes/cats.routes';\n\nconst routes: Routes = [\n  ...homeRoutes,\n  ...peopleRoutes,\n  ...authRoutes,\n  ...catsRoutes,\n  {\n    path: '/**',\n    component: FofRoute\n  }\n];\n\nexport const APP_ROUTES_PROVIDER = provideRouter(routes);\n",
        "gt": [
            "'ngrx-example/src/app/services/utils.service.ts'",
            "'ngrx-example/src/app/_people/services/people-selectors.service.ts'",
            "'ngrx-example/src/app/_people/routes/people.detail.route/people.detail.route.ts'",
            "'ngrx-example/src/app/_people/routes/people.routes.ts'",
            "'ngrx-example/src/app/routes/routes.ts'",
            "'ngrx-example/src/main.browser.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/order/order.module.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/order/dto/order.dto.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/order/order.controller.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'"
        ],
        "content": "'is-even/apps/backend/src/order/order.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { OrderService } from './order.service';\nimport { OrderController } from './order.controller';\nimport { LoggerModule } from '../logger/logger.module';\nimport { Order } from './order.entity';\nimport { CreditModule } from '../credit/credit.module';\nimport { AppConfigModule } from '../config/config.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [OrderService],\n  controllers: [OrderController],\n  exports: [OrderService],\n  imports: [\n    LoggerModule,\n    CreditModule,\n    AppConfigModule,\n    SentryModule,\n    TypeOrmModule.forFeature([Order]),\n  ],\n})\nexport class OrderModule {}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/order/dto/order.dto.ts'\n:import { IsUUID, IsDate, IsInt, IsEnum, IsString } from 'class-validator';\nimport { ApiProperty } from '@nestjs/swagger';\n\nimport { Order } from '../order.entity';\nimport { CreditLimit } from '../../credit/interface/credit-limit.interface';\nimport { CreditDuration } from '../../credit/interface/credit-duration.interface';\nimport { OrderStatus } from '../interface/order-status.interface';\n\nexport class OrderDto {\n  @ApiProperty()\n  @IsUUID()\n  id: string;\n\n  @ApiProperty()\n  @IsDate()\n  createdAt: Date;\n\n  @ApiProperty()\n  @IsDate()\n  updatedAt: Date;\n\n  @ApiProperty()\n  @IsEnum(CreditLimit)\n  creditLimit: CreditLimit;\n\n  @ApiProperty()\n  @IsEnum(CreditDuration)\n  creditDuration: CreditDuration;\n\n  @ApiProperty()\n  @IsString()\n  creditId: string;\n\n  @ApiProperty()\n  @IsInt()\n  public price: number;\n\n  @ApiProperty()\n  @IsEnum(OrderStatus)\n  public status: OrderStatus;\n\n  public static createDtoFromEntity(order: Order): OrderDto {\n    const dto = new OrderDto();\n\n    dto.id = order.id;\n    dto.price = order.price;\n    dto.status = order.status;\n    dto.createdAt = order.createdAt;\n    dto.updatedAt = order.updatedAt;\n    dto.creditId = order.credit?.id;\n    dto.creditLimit = order.creditLimit;\n    dto.creditDuration = order.creditDuration;\n\n    return dto;\n  }\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n\n'is-even/apps/backend/src/order/order.controller.ts'\n:import {\n  Controller,\n  Post,\n  HttpStatus,\n  HttpException,\n  Request,\n  Body,\n  Get,\n  Param,\n  ParseUUIDPipe,\n  Patch,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOkResponse,\n  ApiUnauthorizedResponse,\n  ApiCreatedResponse,\n  ApiNotFoundResponse,\n  ApiInternalServerErrorResponse,\n} from '@nestjs/swagger';\n\nimport { OrderService } from './order.service';\n\nimport { Authorised } from '../auth/auth.decorator';\nimport { RequestWithUser } from '../common/interface/request-with-user.interface';\n\nimport { CreateOrderDto } from './dto/create-order.dto';\nimport { OrderDto } from './dto/order.dto';\n\nimport { ReadOrderError } from './error/read-order.error';\nimport { UnathorizedOrderError } from './error/unathorized-order.error';\nimport { OrderStatus } from './interface/order-status.interface';\nimport { CreditLimit } from '../credit/interface/credit-limit.interface';\n\n@ApiTags('orders')\n@Controller('orders')\nexport class OrderController {\n  constructor(private readonly orderService: OrderService) {}\n\n  @Post('/')\n  @Authorised()\n  @ApiCreatedResponse({ type: OrderDto })\n  @ApiUnauthorizedResponse()\n  @ApiInternalServerErrorResponse()\n  public async createOrder(\n    @Request() request: RequestWithUser,\n    @Body() createOrderDto: CreateOrderDto,\n  ): Promise<OrderDto> {\n    try {\n      const user = request.user;\n      const { creditDuration, creditLimit } = createOrderDto;\n\n      const order = await this.orderService.createOrder(\n        creditLimit,\n        creditDuration,\n        user,\n      );\n\n      if (creditLimit === CreditLimit.Free) {\n        const fullfiledOrder = await this.orderService.fulfillOrder(order);\n        return OrderDto.createDtoFromEntity(fullfiledOrder);\n      }\n\n      return OrderDto.createDtoFromEntity(order);\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Get('/')\n  @Authorised()\n  @ApiOkResponse({ type: OrderDto, isArray: true })\n  @ApiUnauthorizedResponse()\n  @ApiInternalServerErrorResponse()\n  public async getOrders(\n    @Request() request: RequestWithUser,\n  ): Promise<OrderDto[]> {\n    try {\n      const user = request.user;\n\n      const orders = await this.orderService.getOrders(user);\n\n      return orders.map(OrderDto.createDtoFromEntity);\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Patch('/:id')\n  @Authorised()\n  @ApiCreatedResponse()\n  @ApiNotFoundResponse()\n  @ApiUnauthorizedResponse()\n  @ApiInternalServerErrorResponse()\n  public async cancelOrder(\n    @Request() request: RequestWithUser,\n    @Param('id', ParseUUIDPipe) orderId: string,\n  ): Promise<void> {\n    try {\n      const user = request.user;\n      const order = await this.orderService.getOrderById(orderId);\n\n      this.orderService.checkOrderOwner(order, user);\n      this.orderService.checkOrderFulfillment(order);\n\n      await this.orderService.updateOrderStatus(order, OrderStatus.Cancelled);\n    } catch (error) {\n      if (error instanceof UnathorizedOrderError) {\n        throw new HttpException('Access forbidden', HttpStatus.FORBIDDEN);\n      }\n      if (error instanceof ReadOrderError) {\n        throw new HttpException('Not found', HttpStatus.NOT_FOUND);\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/payment/payment.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { PaymentService } from './payment.service';\nimport { PaymentController } from './payment.controller';\nimport { Payment } from './payment.entity';\n\nimport { LoggerModule } from '../logger/logger.module';\nimport { StripeModule } from '../stripe/stripe.module';\nimport { OrderModule } from '../order/order.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [PaymentService],\n  controllers: [PaymentController],\n  imports: [\n    LoggerModule,\n    StripeModule,\n    OrderModule,\n    SentryModule,\n    TypeOrmModule.forFeature([Payment]),\n  ],\n  exports: [PaymentService],\n})\nexport class PaymentModule {}\n",
        "gt": [
            "'is-even/apps/backend/src/order/dto/order.dto.ts'",
            "'is-even/apps/backend/src/order/order.controller.ts'",
            "'is-even/apps/backend/src/order/order.module.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'extension/src/utils/dom.ts'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/components/overlay/Ambassadors.tsx'"
        ],
        "content": "'extension/src/utils/dom.ts'\n:\nexport function visibleUnderCursor(e: MouseEvent) {\n\n  const elements = document.elementsFromPoint(e.clientX, e.clientY);\n\n\n  for (const element of elements) {\n    if (element === document.body) break;\n\n\n    if (element instanceof HTMLElement && element.dataset.transparentClicks)\n      return element;\n\n    const style = getComputedStyle(element);\n    if (\n      style.backgroundImage !== \"none\" ||\n      style.backgroundColor !== \"rgba(0, 0, 0, 0)\"\n    ) {\n      return element;\n    }\n  }\n\n  return null;\n}\n\n\nexport function mutableDOMRect(rect: DOMRect) {\n  const mutable = DOMRect.fromRect(rect);\n  const props = {\n    x: rect.x,\n    y: rect.y,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    width: rect.width,\n    height: rect.height,\n  };\n  Object.entries(props).forEach(([key, value]) => {\n    Object.defineProperty(mutable, key, {\n      writable: true,\n      value,\n    });\n  });\n  return mutable as typeof rect & typeof props;\n}\n\n'extension/src/pages/overlay/components/overlay/Overlay.tsx'\n:import {\n  useEffect,\n  useRef,\n  useCallback,\n  useState,\n  useMemo,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\nimport Welcome from \"../../../../components/Welcome\";\nimport IconWelcome from \"../../../../components/icons/IconWelcome\";\nimport IconAmbassadors from \"../../../../components/icons/IconAmbassadors\";\nimport IconSettings from \"../../../../components/icons/IconSettings\";\n\nimport {\n  isAmbassadorKey,\n  type AmbassadorKey,\n} from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\nimport { visibleUnderCursor } from \"../../../../utils/dom\";\n\nimport useChatCommand from \"../../../../hooks/useChatCommand\";\n\nimport useSettings from \"../../hooks/useSettings\";\nimport useSleeping from \"../../hooks/useSleeping\";\n\nimport AmbassadorsOverlay from \"./Ambassadors\";\nimport SettingsOverlay from \"./Settings\";\n\nimport Buttons from \"../Buttons\";\n\n\nconst commandTimeout = 10_000;\n\nconst overlayOptions = [\n  {\n    key: \"welcome\",\n    type: \"primary\",\n    icon: IconWelcome,\n    title: \"Welcome to Alveus\",\n    component: (props: OverlayOptionProps) => (\n      <Welcome\n        className={classes(\"absolute left-0 top-0 mx-4 my-6\", props.className)}\n      />\n    ),\n  },\n  {\n    key: \"ambassadors\",\n    type: \"primary\",\n    icon: IconAmbassadors,\n    title: \"Explore our Ambassadors\",\n    component: AmbassadorsOverlay,\n  },\n  {\n    key: \"settings\",\n    type: \"secondary\",\n    icon: IconSettings,\n    title: \"Extension Settings\",\n    component: SettingsOverlay,\n  },\n] as const;\n\nexport const isValidOverlayKey = (key: string) =>\n  key === \"\" || overlayOptions.some((option) => option.key === key);\n\nexport type OverlayKey = (typeof overlayOptions)[number][\"key\"] | \"\";\n\ntype ActiveAmbassadorState = {\n  key?: AmbassadorKey;\n  isCommand?: boolean;\n};\n\nexport interface OverlayOptionProps {\n  context: {\n    activeAmbassador: ActiveAmbassadorState;\n    setActiveAmbassador: Dispatch<SetStateAction<ActiveAmbassadorState>>;\n  };\n  className?: string;\n}\n\nconst hiddenClass =\n  \"invisible opacity-0 -translate-x-10 motion-reduce:translate-x-0\";\n\nexport default function Overlay() {\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n  const [activeAmbassador, setActiveAmbassador] =\n    useState<ActiveAmbassadorState>({});\n  const [visibleOption, setVisibleOption] = useState<OverlayKey>(\n    settings.openedMenu.value,\n  );\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const awakingRef = useRef(false);\n\n\n  useEffect(() => {\n    settings.openedMenu.change(visibleOption);\n  }, [visibleOption]);\n\n\n  useEffect(() => {\n    setVisibleOption(settings.openedMenu.value);\n  }, [settings.openedMenu.value]);\n\n\n  useChatCommand(\n    useCallback(\n      (command: string) => {\n        if (!settings.disableChatPopup.value) {\n          if (isAmbassadorKey(command))\n            setActiveAmbassador({ key: command, isCommand: true });\n          else if (command !== \"welcome\") return;\n\n\n          setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n\n          if (timeoutRef.current) clearTimeout(timeoutRef.current);\n          timeoutRef.current = setTimeout(() => {\n            setVisibleOption(\"\");\n            setActiveAmbassador({});\n          }, commandTimeout);\n\n\n          awakingRef.current = true;\n          wake(commandTimeout);\n        }\n      },\n      [settings.disableChatPopup.value, wake],\n    ),\n  );\n\n\n  useEffect(\n    () => () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    },\n    [],\n  );\n\n\n\n  useEffect(() => {\n    const callback = () => {\n      if (awakingRef.current) awakingRef.current = false;\n      else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    };\n    addSleepListener(\"wake\", callback);\n    return () => removeSleepListener(\"wake\", callback);\n  }, [addSleepListener, removeSleepListener]);\n\n\n  const bodyClick = useCallback((e: MouseEvent) => {\n    if (!visibleUnderCursor(e)) {\n      setVisibleOption(\"\");\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"click\", bodyClick, true);\n    return () => document.body.removeEventListener(\"click\", bodyClick, true);\n  }, [bodyClick]);\n\n\n  const bodyDblClick = useCallback((e: MouseEvent) => {\n    if (visibleUnderCursor(e)) {\n      e.stopPropagation();\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n    return () =>\n      document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n  }, [bodyDblClick]);\n\n\n  const context = useMemo<OverlayOptionProps[\"context\"]>(\n    () => ({\n      activeAmbassador,\n      setActiveAmbassador,\n    }),\n    [activeAmbassador],\n  );\n\n  return (\n    <div\n      className={classes(\n        \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          ) &&\n          hiddenClass,\n      )}\n    >\n      <Buttons\n        options={overlayOptions}\n        onClick={setVisibleOption}\n        active={visibleOption}\n      />\n      <div className=\"relative h-full w-full\">\n        {overlayOptions.map((option) => (\n          <option.component\n            key={option.key}\n            context={context}\n            className={classes(\n              \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n              visibleOption !== option.key && hiddenClass,\n            )}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n'extension/src/pages/overlay/components/overlay/Ambassadors.tsx'\n:import { useRef, useEffect, useCallback, type MouseEvent } from \"react\";\nimport { Transition } from \"@headlessui/react\";\n\nimport AmbassadorCard from \"../../../../components/AmbassadorCard\";\nimport AmbassadorButton from \"../../../../components/AmbassadorButton\";\n\nimport { useAmbassadors } from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\n\nimport type { OverlayOptionProps } from \"./Overlay\";\n\nimport IconChevron from \"../../../../components/icons/IconChevron\";\n\nconst arrowClass =\n  \"absolute border-0 cursor-pointer text-alveus-green w-full h-[var(--list-fade-padding)] z-20 transition-opacity group pt-[var(--twitch-vertical-padding)] pb-4 box-content\";\nconst arrowSvgClass =\n  \"mx-auto drop-shadow-lg overflow-visible transition-transform group-hover:scale-125 group-focus:scale-125\";\nconst arrowPathClass =\n  \"[&_path]:stroke-alveus-tan [&_path]:stroke-[0.25rem] [&_path]:[paint-order:stroke] [&_path]:transition-[stroke] [&_path]:group-hover:stroke-highlight [&_path]:group-hover:stroke-[0.375rem] [&_path]:group-focus:stroke-highlight [&_path]:group-focus:stroke-[0.375rem]\";\nconst hiddenClass = \"opacity-0 pointer-events-none\";\n\nexport default function Ambassadors(props: OverlayOptionProps) {\n  const {\n    context: { activeAmbassador, setActiveAmbassador },\n    className,\n  } = props;\n\n  const ambassadors = useAmbassadors();\n\n  const upArrowRef = useRef<HTMLButtonElement>(null);\n  const ambassadorList = useRef<HTMLDivElement>(null);\n  const downArrowRef = useRef<HTMLButtonElement>(null);\n\n\n  useEffect(() => {\n    if (\n      !ambassadorList.current ||\n      !activeAmbassador.key ||\n      !activeAmbassador.isCommand\n    )\n      return;\n\n    const offset = 200;\n    const anchorElement = ambassadorList.current.querySelector(\n      `#${activeAmbassador.key}`,\n    );\n    if (anchorElement instanceof HTMLButtonElement)\n      ambassadorList.current.scrollTo({\n        top: Math.max(0, anchorElement.offsetTop - offset),\n        behavior: \"smooth\",\n      });\n  }, [activeAmbassador]);\n\n\n  const ambassadorListScroll = useCallback(\n    (event: MouseEvent, direction: number) => {\n      if (ambassadorList.current) {\n        event.stopPropagation();\n\n        ambassadorList.current.scroll({\n          top: ambassadorList.current.scrollTop - direction,\n          left: 0,\n          behavior: \"smooth\",\n        });\n      }\n    },\n    [],\n  );\n\n\n  const handleArrowVisibility = useCallback(() => {\n    if (ambassadorList.current) {\n      if (ambassadorList.current.scrollTop === 0)\n        upArrowRef.current?.classList.add(...hiddenClass.split(\" \"));\n      else if (\n        ambassadorList.current.scrollTop +\n          ambassadorList.current.clientHeight ===\n        ambassadorList.current.scrollHeight\n      )\n        downArrowRef.current?.classList.add(...hiddenClass.split(\" \"));\n      else {\n        upArrowRef.current?.classList.remove(...hiddenClass.split(\" \"));\n        downArrowRef.current?.classList.remove(...hiddenClass.split(\" \"));\n      }\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    handleArrowVisibility();\n  }, [handleArrowVisibility]);\n\n  return (\n    <div\n      className={classes(\n        \"grid-cols-2-auto absolute left-0 top-0 z-0 grid h-full grid-rows-1\",\n        className,\n      )}\n    >\n      <div className=\"relative z-10 flex flex-col items-center\">\n        <div\n          ref={ambassadorList}\n          className=\"list-fade scrollbar-none -my-[var(--twitch-vertical-padding)] flex w-40 flex-col items-center gap-4 overflow-scroll px-4 py-[calc(var(--twitch-vertical-padding)+var(--list-fade-padding))]\"\n          onScroll={handleArrowVisibility}\n        >\n          {ambassadors.map(([key]) => (\n            <AmbassadorButton\n              key={key}\n              ambassador={key}\n              onClick={() => {\n                setActiveAmbassador((prev) =>\n                  prev.key === key ? {} : { key },\n                );\n              }}\n              className={classes(\n                \"w-full\",\n                activeAmbassador.key === key && \"outline-highlight outline\",\n              )}\n            />\n          ))}\n        </div>\n\n        <button\n          ref={upArrowRef}\n          className={classes(\n            arrowClass,\n            \"-top-[var(--twitch-vertical-padding)]\",\n            hiddenClass,\n          )}\n          onClick={(e) => ambassadorListScroll(e, 250)}\n          title=\"Scroll up\"\n          type=\"button\"\n          data-transparent-clicks\n        >\n          <IconChevron className={classes(arrowSvgClass, arrowPathClass)} />\n        </button>\n\n        <button\n          ref={downArrowRef}\n          className={classes(\n            arrowClass,\n            \"-bottom-[var(--twitch-vertical-padding)] rotate-180\",\n          )}\n          onClick={(e) => ambassadorListScroll(e, -250)}\n          title=\"Scroll down\"\n          type=\"button\"\n          data-transparent-clicks\n        >\n          <IconChevron className={classes(arrowSvgClass, arrowPathClass)} />\n        </button>\n      </div>\n\n      {ambassadors.map(([key]) => (\n        <Transition show={activeAmbassador.key === key} key={key}>\n          <AmbassadorCard\n            key={key}\n            ambassador={key}\n            onClose={() => setActiveAmbassador({})}\n            className=\"z-0 col-start-2 row-start-1 origin-[center_left] self-center transition-[opacity,transform] will-change-[opacity,transform] data-[closed]:-translate-x-10 data-[closed]:opacity-0 data-[closed]:motion-reduce:translate-x-0\"\n          />\n        </Transition>\n      ))}\n    </div>\n  );\n}\n",
        "gt": [
            "'extension/src/utils/dom.ts'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/components/overlay/Ambassadors.tsx'"
        ]
    },
    {
        "files": [
            "'near-social-bridge/src/navigation/types.ts'",
            "'near-social-bridge/src/navigation/contexts/NavigationProvider.tsx'",
            "'near-social-bridge/src/navigation/createStackNavigator.tsx'",
            "'near-social-bridge/src/navigation/index.ts'"
        ],
        "content": "'near-social-bridge/src/navigation/types.ts'\n:\nexport type HistoryProps = [keyof ParamListBase, {} | undefined]\n\nexport interface NavigationProps<S extends ParamListBase> {\n\n  push<RouteName extends keyof S>(\n    ...args: undefined extends S[RouteName]\n      ? [screen: RouteName] | [screen: RouteName, params: S[RouteName]]\n      : [screen: RouteName, params: S[RouteName]]\n  ): void\n\n\n  goBack: () => void\n\n\n  replace<RouteName extends keyof S>(\n    ...args: undefined extends S[RouteName]\n      ? [screen: RouteName] | [screen: RouteName, params: S[RouteName]]\n      : [screen: RouteName, params: S[RouteName]]\n  ): void\n\n\n  location: HistoryProps | []\n\n\n  history: HistoryProps[]\n\n\n  ready: boolean\n}\n\n\nexport declare type Route<RouteName> = Readonly<{\n\n  key?: string\n\n  name: RouteName\n\n  component: React.ComponentType<any>\n\n  pathParams?: string\n}>\n\n\nexport declare type ScreenRoute<RouteName, Params extends object | undefined = object | undefined> = Readonly<{\n\n  key?: string\n\n  name: RouteName\n\n  params: Params\n\n  path: string\n\n  pathParams?: string\n}>\n\nexport declare type ParamListBase = Record<string, object | undefined>\n\ndeclare type Keyof<T extends {}> = Extract<keyof T, string>\n\nexport type IFrameStackNavigationProp<ParamListBase> = {\n\n  push<RouteName extends keyof ParamListBase>(\n    ...args: undefined extends ParamListBase[RouteName]\n      ? [screen: RouteName] | [screen: RouteName, params: ParamListBase[RouteName]]\n      : [screen: RouteName, params: ParamListBase[RouteName]]\n  ): void\n\n\n  goBack: () => void\n\n\n  location: HistoryProps | []\n\n\n  history: HistoryProps[]\n}\n\nexport declare type RouteProp<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList = Keyof<ParamList>\n> = Route<Extract<RouteName, string>>\n\n\nexport declare type ScreenRouteProp<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList = Keyof<ParamList>\n> = ScreenRoute<Extract<RouteName, string>, ParamList[RouteName]>\n\nexport declare type IFrameStackScreenProps<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList = string\n> = {\n  navigation: IFrameStackNavigationProp<ParamList>\n  route: ScreenRouteProp<ParamList, RouteName>\n}\n\nexport declare type NavigatorProps<RouteName> = {\n  children: React.ReactNode\n\n  defaultRoute?: RouteName\n}\n\n'near-social-bridge/src/navigation/contexts/NavigationProvider.tsx'\n:'use client'\n\nimport getPathParams from '../../utils/getPathParams'\nimport React, { createContext, useCallback, useEffect, useState } from 'react'\nimport { HistoryProps, NavigationProps, ParamListBase } from '../types'\nimport { Storage } from '../../api'\n\nconst NAVIGATION_PROPS_KEY = 'NAVIGATION_PROPS'\n\nconst defaultValue: NavigationProps<ParamListBase> = {\n  push: () => {\n    throw new Error('push must be defined!')\n  },\n  goBack: () => {\n    throw new Error('goBack must be defined!')\n  },\n  replace: () => {\n    throw new Error('replace must be defined!')\n  },\n  location: [],\n  history: [],\n  ready: false,\n}\n\nexport const NavigationContext = createContext(defaultValue)\n\ntype NavigationProviderProps = {\n  children: React.ReactNode\n}\n\n\nexport let initialRoute: string | undefined = undefined\n\nconst NavigationProvider: React.FC<NavigationProviderProps> = ({ children }) => {\n\n  if (!initialRoute) {\n    initialRoute = getPathParams()[0]\n  }\n\n\n  const [history, setHistory] = useState<HistoryProps[]>([])\n  const [ready, setReady] = useState(false)\n\n\n  useEffect(() => {\n    Storage.get<string>(NAVIGATION_PROPS_KEY).then((storedHistory) => {\n      setHistory(storedHistory ? JSON.parse(storedHistory) : [])\n      setReady(true)\n    })\n  }, [])\n\n\n  useEffect(() => {\n    const handler = () => {\n      const currentRoute = getPathParams()[0]\n\n\n      const penultimateHistoryPath = history.at(-2)?.[0] || ''\n      if (penultimateHistoryPath.toLowerCase() === currentRoute) {\n        const updatedHistory = [...history.slice(0, history.length - 1)]\n        setHistory(updatedHistory)\n      }\n    }\n\n    window.addEventListener('hashchange', handler)\n\n    return () => {\n      window.removeEventListener('hashchange', handler)\n    }\n  }, [history])\n\n  const push = useCallback(\n    (screen: keyof ParamListBase, params?: {}) => {\n\n      if (history.at(-1)?.[0] !== screen && ready) {\n        const updatedHistory = [...history]\n        updatedHistory.push([screen, params])\n        setHistory(updatedHistory)\n        Storage.set(NAVIGATION_PROPS_KEY, JSON.stringify(updatedHistory))\n      }\n    },\n    [history, ready]\n  )\n\n  const replace = useCallback((screen: keyof ParamListBase, params?: {}) => {\n    setHistory([[screen, params]])\n    Storage.set(NAVIGATION_PROPS_KEY, JSON.stringify([[screen, params]]))\n  }, [])\n\n  const goBack = useCallback(() => {\n    const updatedHistory = [...history.slice(0, history.length - 1)]\n\n    if (updatedHistory && updatedHistory.length > 0) {\n      setHistory(updatedHistory)\n      Storage.set(NAVIGATION_PROPS_KEY, JSON.stringify(updatedHistory))\n    }\n  }, [history])\n\n  return (\n    <NavigationContext.Provider\n      value={{ push, goBack, replace, location: history.at(-1) as HistoryProps, history, ready }}\n    >\n      {children}\n    </NavigationContext.Provider>\n  )\n}\n\nexport default NavigationProvider\n\n'near-social-bridge/src/navigation/createStackNavigator.tsx'\n:import React, { useCallback, useEffect, useState } from 'react'\nimport {\n  onConnectObservable,\n  ConnectionPayload,\n  getConnectionPayload,\n  getConnectionStatus,\n} from '../services/bridge-service'\nimport getHostname from '../utils/getHostname'\nimport getPathParams from '../utils/getPathParams'\nimport NavigationProvider, { initialRoute } from './contexts/NavigationProvider'\nimport useNavigation from './hooks/useNavigation'\nimport { NavigatorProps, ParamListBase, Route } from './types'\nimport { useAuth } from '../auth'\nimport { syncContentHeight } from './syncContentHeight'\nimport isBrowser from '../utils/isBrowser'\n\n\nconst createStackNavigator = function <T extends ParamListBase>(fallback?: React.ReactNode) {\n\n  const Navigator: React.FC<NavigatorProps<keyof T>> = ({ children, defaultRoute }) => {\n    const auth = useAuth()\n    const [isReady, setIsReady] = useState(false)\n    const navigation = useNavigation()\n    const [screens, setScreens] = useState<any[]>()\n\n    const getScreens = useCallback(() => {\n\n      const mainChildren = children as any\n      let finalChildren: any\n\n\n      if (mainChildren.props?.children?.length) {\n        finalChildren = mainChildren.props?.children\n\n      } else if (mainChildren.props?.children?.props?.name) {\n        finalChildren = [mainChildren.props?.children]\n\n      } else if (mainChildren.length) {\n        finalChildren = mainChildren\n\n      } else if (mainChildren.props?.name) {\n        finalChildren = [mainChildren]\n      }\n\n      if (!finalChildren) {\n        throw new Error('You have to provide at least one Screen!')\n      }\n\n      return finalChildren\n    }, [children])\n\n\n    const [currentScreen, setCurrentScreen] = useState<any>(getScreens()[0])\n\n    useEffect(() => {\n\n      const screensList = getScreens()\n\n      setScreens(screensList)\n    }, [getScreens])\n\n    const [blockFindScreen, setBlockFindScreen] = useState(false)\n    const findScreenAndPopulateProps = useCallback(\n      (route?: string) => {\n        if (blockFindScreen) return\n        if (!screens) return\n\n        const pathParams = route ? route.split('/') : []\n        const routeParams = pathParams.slice(2)\n\n\n        const params: any = {}\n\n\n        const urlPath = pathParams[1]\n        const foundScreen = screens.find((screen: any) => screen.props.name.toLowerCase() === urlPath)\n\n        if (foundScreen) {\n          if (foundScreen.props.pathParams) {\n\n            const foundScreenParamsKeys: [] = foundScreen.props.pathParams.split('/:').slice(1)\n\n            foundScreenParamsKeys.forEach((key, index) => {\n              params[key] = routeParams[index] || undefined\n            })\n          }\n\n\n          defaultRoute ? navigation.replace(defaultRoute as string) : navigation.push(foundScreen.props.name)\n        } else {\n\n          const firstChildName = screens[0].props.name\n          defaultRoute ? navigation.replace(defaultRoute as string) : navigation.push(firstChildName)\n        }\n        setBlockFindScreen(!!route && navigation.ready)\n      },\n      [screens, blockFindScreen, defaultRoute]\n    )\n\n    useEffect(() => {\n\n      const route = getConnectionPayload().initialPath || `/${initialRoute}` || undefined\n      findScreenAndPopulateProps(route)\n    }, [findScreenAndPopulateProps])\n\n    useEffect(() => {\n\n\n      const handler = (connectionPayload: ConnectionPayload) => {\n        const route = connectionPayload.initialPath\n        findScreenAndPopulateProps(route)\n        setIsReady(true)\n      }\n\n      if (getConnectionStatus() === 'connected') {\n        setIsReady(true)\n      }\n\n      onConnectObservable.subscribe(handler)\n\n\n      if (getHostname() === 'localhost') {\n        handler({ initialPath: `/${initialRoute}` })\n      }\n\n      return () => {\n        onConnectObservable.unsubscribe(handler)\n      }\n    }, [findScreenAndPopulateProps])\n\n\n    useEffect(() => {\n      if (currentScreen && isReady) {\n\n        syncContentHeight()\n      }\n    }, [currentScreen, isReady])\n\n\n    useEffect(() => {\n      if (!screen) return\n\n      const _currentScreen = screens?.find((screen: any) => screen.props.name === navigation.location?.[0]) || null\n      if (!currentScreen && _currentScreen) {\n        setCurrentScreen(_currentScreen)\n      }\n\n      if (currentScreen?.props?.name !== _currentScreen?.props?.name) {\n        setCurrentScreen(_currentScreen)\n      }\n    }, [navigation.location, screens, currentScreen])\n\n\n    useEffect(() => {\n      const handler = (event: HashChangeEvent) => {\n        if (!screen) return\n\n        const currentRoute = getPathParams(event.newURL)[0]\n\n        const _currentScreen = screens?.find((screen: any) => screen.props.name.toLowerCase() === currentRoute) || null\n        if (_currentScreen) {\n          setCurrentScreen(_currentScreen)\n        }\n      }\n\n      window.addEventListener('hashchange', handler)\n\n      return () => {\n        window.removeEventListener('hashchange', handler)\n      }\n    }, [screens])\n\n\n    if (fallback && !navigation.ready) {\n      return <>{fallback}</>\n    }\n\n\n    if (fallback && !auth.user) {\n      if (!isReady || !auth.ready) return <>{fallback}</>\n    }\n\n    return <>{currentScreen}</>\n  }\n\n\n  const WrappedNavigator: React.FC<NavigatorProps<keyof T>> = ({ children, defaultRoute }) => {\n    return (\n      <NavigationProvider>\n        <Navigator defaultRoute={defaultRoute}>{children}</Navigator>\n      </NavigationProvider>\n    )\n  }\n\n\n  const Screen: React.FC<Route<keyof T>> = ({ key, name, component, pathParams }) => {\n    const navigation = useNavigation()\n\n\n    const params = navigation?.location && navigation?.location[1] ? navigation.location[1] : undefined\n\n    const Component = component\n\n\n    let path: string | null = null\n    if (isBrowser()) {\n      const url = new URL(window.location.href)\n      path = url.searchParams.get('r')\n    }\n\n    return (\n      <div id=\"nsb-navigation-screen\">\n        <Component\n          {...{\n            navigation,\n            route: {\n              key,\n              name,\n              params: params ? { ...params } : {},\n              path,\n              pathParams,\n            },\n          }}\n        />\n      </div>\n    )\n  }\n\n  return {\n    Navigator: WrappedNavigator,\n    Screen,\n  }\n}\n\nexport default createStackNavigator\n\n'near-social-bridge/src/navigation/index.ts'\n:import NavigationProvider from './contexts/NavigationProvider'\nimport useNavigation from './hooks/useNavigation'\nimport createStackNavigator from './createStackNavigator'\nimport { IFrameStackScreenProps } from './types'\n\nexport { NavigationProvider, useNavigation, createStackNavigator, IFrameStackScreenProps }\n",
        "gt": [
            "'near-social-bridge/src/navigation/types.ts'",
            "'near-social-bridge/src/navigation/contexts/NavigationProvider.tsx'",
            "'near-social-bridge/src/navigation/createStackNavigator.tsx'",
            "'near-social-bridge/src/navigation/index.ts'"
        ]
    },
    {
        "files": [
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item.directive.spec.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item.directive.ts'"
        ],
        "content": "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item.directive.spec.ts'\n:import { PrintItemDirective } from './print-item.directive';\nimport { TestBed } from '@angular/core/testing';\nimport { NgxPrinterService } from '../public_api';\n\ndescribe('PrintItemDirective', () => {\n  beforeEach(() => TestBed.configureTestingModule({}));\n\n  it('should create an instance PrintItemDirective', () => {\n    const service = TestBed.get(NgxPrinterService);\n    const directive = new PrintItemDirective(null, service);\n    expect(directive).toBeTruthy();\n  });\n\n});\n\n'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'\n:import { Helpers } from \"./helper\";\nimport { ngxPrintMarkerPosition } from \"./ngx-print-marker-position.enum\";\nimport { PrintItem } from \"./print-item\";\nimport {\n  ComponentFactoryResolver,\n  EnvironmentInjector,\n  Injectable,\n  Injector,\n  Optional,\n  TemplateRef,\n  Type,\n  createComponent,\n} from \"@angular/core\";\nimport { NgxPrinterComponent } from \"./ngx-printer.component\";\nimport { BehaviorSubject } from \"rxjs\";\nimport { PrintServiceConfig } from \"./print-service-config\";\n\nexport type Content<T> = string | HTMLElement | TemplateRef<T> | Type<T>;\n\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class NgxPrinterService {\n  private printWindowOpen = new BehaviorSubject<boolean>(false);\n\n\n  private _printItems = new BehaviorSubject<PrintItem[]>([]);\n  $printItems = this._printItems.asObservable();\n\n  private openNgxPrinter: HTMLElement;\n\n\n  timeToWaitRender = 200;\n\n\n  renderClass = \"default\";\n\n\n  printOpenWindow = true;\n\n\n  appRootName = \"app-root\";\n\n\n  printPreviewOnly = false;\n\n  appRoot: HTMLElement;\n  appRootDislaySetting = \"\";\n\n  $printWindowOpen = this.printWindowOpen.asObservable();\n  eventadded = [];\n  markerPosition: ngxPrintMarkerPosition;\n\n  constructor(\n    @Optional() config: PrintServiceConfig,\n    private envInjector: EnvironmentInjector,\n  ) {\n    this.setRootConfigOptions(config);\n  }\n\n\n  private setRootConfigOptions(config: PrintServiceConfig): void {\n    if (config) {\n      config.timeToWaitRender &&\n        (this.timeToWaitRender = config.timeToWaitRender);\n\n      config.renderClass && (this.renderClass = config.renderClass);\n\n      config.appRootName && (this.appRootName = config.appRootName);\n\n      config.markerPosition && (this.markerPosition = config.markerPosition);\n\n      if (config.hasOwnProperty(\"printPreviewOnly\")) {\n        this.printPreviewOnly = config.printPreviewOnly;\n      }\n\n      if (config.hasOwnProperty(\"printOpenWindow\")) {\n        this.printOpenWindow = config.printOpenWindow;\n      }\n    }\n  }\n\n\n  public printDiv(divID: string): void {\n    const divToPrint = document.getElementById(divID);\n\n    if (divToPrint) {\n      this.print(divToPrint, this.printOpenWindow);\n    } else {\n      console.log(`div with id ${divID} not found..`);\n    }\n  }\n\n\n  public printByClassName(className: string): void {\n    const elementToPrint = document.getElementsByClassName(className);\n\n    if (elementToPrint && elementToPrint.length > 0) {\n      this.print(<HTMLScriptElement>elementToPrint[0], this.printOpenWindow);\n    } else {\n      console.log(\"element with id ${className} not found..\");\n    }\n  }\n\n\n  public printAngular(contentToPrint: any, context?: any): void {\n    const nativeEl = this.createComponent(contentToPrint, null, context);\n\n    this.print(nativeEl.nativeElement, this.printOpenWindow);\n  }\n\n\n  public printImg(imgSrc: string): void {\n    const compRef = this.createComponent(null, imgSrc);\n    const openNewWindow = this.printOpenWindow;\n\n    compRef.instance.completed.subscribe((val) => {\n      compRef.hostView.detectChanges();\n      console.log(\"completed:\", val);\n      this.print(compRef.location.nativeElement, openNewWindow);\n    });\n  }\n\n\n  public printHTMLElement(nativeElement: HTMLElement): void {\n    this.print(nativeElement, this.printOpenWindow);\n  }\n\n\n  private createComponent(\n    contentToRender: any,\n    imgSrc?: string,\n    context?: any\n  ): any {\n\n    let componentRef: any;\n\n    if (contentToRender) {\n      if (context === undefined) {\n        context = null;\n      }\n      const ngContent = this.resolveNgContent(contentToRender, context);\n\n      componentRef = createComponent(NgxPrinterComponent, {\n        environmentInjector: this.envInjector,\n        projectableNodes: ngContent\n      });\n\n    } else {\n      componentRef = createComponent(NgxPrinterComponent, {\n        environmentInjector: this.envInjector,\n      });\n    }\n\n    componentRef.instance.renderClass = this.renderClass;\n\n    if (imgSrc) {\n      componentRef.instance.imgSrc = imgSrc;\n      return componentRef;\n    }\n\n    componentRef.hostView.detectChanges();\n    return componentRef.location;\n  }\n\n\n  private print(printContent: any, printOpenWindow: boolean): void {\n    if (printOpenWindow === true) {\n      const printContentClone = document.importNode(printContent, true);\n\n      this.hideBeforePrint(printContentClone);\n      this.printInNewWindow(printContentClone);\n    }\n    if (printOpenWindow === false) {\n      const printContentClone = document.importNode(printContent, true);\n      this.hideBeforePrint(printContentClone);\n      const nativeEl = this.createComponent(printContentClone).nativeElement;\n      this.openNgxPrinter = nativeEl;\n      document.body.appendChild(this.openNgxPrinter);\n\n      this.getAppRoot();\n\n      this.appRoot && (this.appRoot.style.display = \"none\");\n\n      this.printCurrentWindow();\n    }\n  }\n\n\n  private printInNewWindow(divToPrint: HTMLElement): void {\n    const printWindow = window.open(\"\", \"PRINT\");\n    const title = document.title;\n\n    printWindow.document.write(\n      \"<HTML><HEAD><TITLE>\" + title + \"</TITLE></HEAD><BODY></BODY></HTML>\"\n    );\n\n\n    const printWindowDoc = printWindow.document;\n    Helpers.copyCss(printWindowDoc);\n\n    printWindowDoc.body.style.margin = \"0 0\";\n    printWindowDoc.body.appendChild(divToPrint);\n    printWindow.document.close();\n\n    setTimeout(\n      () => this.printTabWindow(printWindow, printWindowDoc),\n      this.timeToWaitRender\n    );\n  }\n\n\n  private printTabWindow(printWindow: Window, printWindowDoc: Document): void {\n    if (this.printPreviewOnly) {\n      return;\n    }\n    this.registerPrintEvent(printWindow, true);\n    this.printWindowOpen.next(true);\n    printWindow.focus();\n    if (printWindowDoc.execCommand(\"print\") === false) {\n      printWindow.print();\n    }\n  }\n\n\n  public printCurrentWindow(): void {\n    if (this.printPreviewOnly) {\n      return;\n    }\n    this.registerPrintEvent(window, false);\n    setTimeout(() => {\n      this.printWindowOpen.next(true);\n      if (document.execCommand(\"print\") === false) {\n        window.print();\n      }\n    }, this.timeToWaitRender);\n  }\n\n\n  private registerPrintEvent(\n    printWindow: Window,\n    printWithOpenInNewWindow: boolean\n  ) {\n    const that = this;\n    printWindow.focus();\n\n    if (that.eventadded[printWindow.name]) {\n      return;\n    }\n\n\n\n\n    printWindow.addEventListener('beforeprint', () => {});\n\n    printWindow.addEventListener('afterprint', () => {\n      this.eventadded[printWindow.name] = true;\n      console.log('afterprint');\n\n      if (printWithOpenInNewWindow) {\n        that.eventadded[printWindow.name] = false;\n      }\n      that.cleanUp(printWindow, printWithOpenInNewWindow);\n      that.printWindowOpen.next(false);\n    });\n  }\n\n\n  private cleanUp(printWindow: Window, printOpenWindow: boolean): void {\n    if (printOpenWindow === true) {\n      console.log(\"close print window\");\n      printWindow.close();\n      setTimeout(() => {\n        printWindow.close();\n      }, 20);\n    }\n    if (printOpenWindow === false) {\n      if (!this.openNgxPrinter) {\n        return;\n      }\n      if (document.body.getElementsByTagName(\"ngx-printer\").length === 0) {\n        return;\n      }\n\n      if (this.appRoot) {\n        if (this.appRootDislaySetting !== \"\") {\n          this.appRoot.style.display = this.appRootDislaySetting;\n        } else {\n          this.appRoot.style.display = \"\";\n        }\n      }\n\n      document.body.removeChild(this.openNgxPrinter);\n      this.openNgxPrinter = null;\n    }\n  }\n\n\n  private hideBeforePrint(parentDiv: HTMLElement): void {\n    const childrenOfDiv = parentDiv.querySelectorAll(\".no_print_indicator\");\n\n    for (let i = 0; i < childrenOfDiv.length; i++) {\n      const child = childrenOfDiv[i] as HTMLElement;\n      child.style.display = \"none\";\n    }\n  }\n\n\n  private getAppRoot(): void {\n    const appRoot = document.body.getElementsByTagName(this.appRootName);\n    if (appRoot.length === 0) {\n      return null;\n    } else {\n      this.appRoot = <HTMLElement>appRoot[0];\n      this.appRootDislaySetting = this.appRoot.style.display;\n    }\n  }\n\n\n  public addPrintItem(newPrintItem: PrintItem): void {\n    const tmpItems = this._printItems.getValue();\n\n    tmpItems.push(newPrintItem);\n    this._printItems.next(tmpItems);\n  }\n\n\n  public removePrintItem(idOfItemToRemove: string): void {\n    const tmpItems = this._printItems.getValue();\n    const newIitems = tmpItems.filter((item) => item.id !== idOfItemToRemove);\n\n    this._printItems.next(newIitems);\n  }\n\n\n  public getPrintItem(idOfItemToRemove: string): PrintItem {\n    const tmpItems = this._printItems.getValue();\n    const foundItem = tmpItems.find((item) => item.id === idOfItemToRemove);\n\n    return foundItem;\n  }\n\n\n  public printPrintItem(printItemToPrint: PrintItem): void {\n    this.printHTMLElement(printItemToPrint.nativeElement);\n  }\n\n\n  public printPrintItems(\n    printItemsToPrint: PrintItem[],\n    className?: string\n  ): void {\n    const newDiv = <HTMLDivElement>document.createElement(\"div\");\n\n    if (className) {\n      newDiv.classList.add(className);\n    } else {\n      newDiv.style.display = \"flex\";\n      newDiv.style.flexDirection = \"column\";\n    }\n\n    printItemsToPrint.forEach((element) => {\n      newDiv.appendChild(element.nativeElement.cloneNode(true));\n    });\n\n    this.printHTMLElement(newDiv);\n  }\n\n\n  private resolveNgContent<T>(content: Content<T>, context: any): any {\n    if (typeof content === \"string\") {\n      const element = document.createTextNode(content);\n\n      return [[element]];\n    }\n\n    if (content instanceof TemplateRef) {\n      const viewRef = content.createEmbeddedView(context);\n\n      viewRef.detectChanges();\n\n      return [viewRef.rootNodes];\n    }\n\n    if (content instanceof HTMLElement) {\n      return [[content]];\n    }\n\n\n\n    let componentRef =  createComponent(content, {\n      environmentInjector: this.envInjector,\n    });\n\n\n    componentRef.changeDetectorRef.detectChanges();\n\n    return [[componentRef.location.nativeElement]];\n  }\n}\n\n'ngx-printer-demo/projects/ngx-printer/src/lib/print-item.directive.ts'\n:import { Directive, ElementRef, OnInit, OnDestroy, Input } from '@angular/core';\nimport { NgxPrinterService } from './ngx-printer.service';\nimport { PrintItem } from './print-item';\n\n\n@Directive({\n  selector: '[ngxPrintItem]'\n})\nexport class PrintItemDirective implements OnInit, OnDestroy {\n\n\n  @Input()\n  printName: string;\n\n  constructor(private el: ElementRef, private printerService: NgxPrinterService) {\n  }\n\n  ngOnInit() {\n    if (this.el.nativeElement.id) {\n      const tmpPrintItem = new PrintItem();\n      tmpPrintItem.id = this.el.nativeElement.id;\n      tmpPrintItem.nativeElement = this.el.nativeElement;\n\n      this.printerService.addPrintItem(tmpPrintItem);\n    }\n  }\n\n  ngOnDestroy() {\n    if (this.el.nativeElement.id) {\n      this.printerService.removePrintItem( this.el.nativeElement.id);\n    }\n  }\n\n}\n",
        "gt": [
            "'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item.directive.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item.directive.spec.ts'"
        ]
    },
    {
        "files": [
            "'bchain_business_card/frontend/src/pages/_app.tsx'",
            "'bchain_business_card/frontend/src/components/Nav.tsx'",
            "'bchain_business_card/frontend/src/context/NearProvider.tsx'"
        ],
        "content": "'bchain_business_card/frontend/src/pages/_app.tsx'\n:import \"windi.css\";\nimport \"../styles/globals.css\";\nimport Head from \"next/head\";\nimport { NearProvider } from \"../context/NearProvider\";\nimport { Nav } from \"../components/Nav\";\nimport TransactionProvider from \"../context/TransactionProvider\";\n\nfunction MyApp({ Component, pageProps }) {\n  return (\n    <>\n      <Head>\n        <title>Business Card</title>\n        <meta name=\"description\" content=\"expose yourself\" charSet=\"UTF-8\" />\n        <link rel=\"icon\" href=\"../public/favicon.ico\" />\n      </Head>\n      <NearProvider>\n        <TransactionProvider>\n          <Nav>\n            <Component {...pageProps} />\n          </Nav>\n        </TransactionProvider>\n      </NearProvider>\n    </>\n  );\n}\n\nexport default MyApp;\n\n'bchain_business_card/frontend/src/components/Nav.tsx'\n:import React, { Fragment, useContext, useEffect, useState } from \"react\";\nimport ErrorIcon from \"../public/error-notification.svg\";\nimport NearLogo from \"../public/near-logo.svg\";\nimport SearchIcon from \"../public/search-icon.svg\";\nimport { useNear, NearContext } from \"../context/NearProvider\";\nimport Image from \"next/image\";\nimport ErrorBox from \"./ErrorBox\";\nimport { useErrors } from \"../context/TransactionProvider\";\nimport Link from \"next/link\";\nimport { useRouter } from \"next/router\";\nimport { createContext } from \"react\";\n\ninterface NavContext {\n  setShowSearchBox?: any;\n}\nconst NavContext = createContext<NavContext>({});\nexport function useNavContext() {\n  return useContext(NavContext);\n}\n\nexport const Nav = ({ children }) => {\n  let { wallet, contract } = useNear();\n  let { errorList } = useErrors();\n  let [showErrorBox, setShowErrorBox] = useState(true);\n  let [showSearchBox, setShowSearchBox] = useState(false);\n  let [searchValue, setSearchValue] = useState(\"\");\n  const router = useRouter();\n\n  useEffect(() => {}, [wallet]);\n\n  function signIn() {\n    wallet.requestSignIn({\n      contractId: process.env.NEXT_PUBLIC_CONTRACT_NAME,\n\n\n      methodNames: [],\n    });\n  }\n\n  function signOut() {\n    wallet.signOut();\n    window.location.replace(window.location.origin + window.location.pathname);\n  }\n  const ctx = { setShowSearchBox };\n  return (\n    <NavContext.Provider value={ctx}>\n      {\n        <div className=\"flex flex-col\">\n          <nav\n            id=\"navbar\"\n            className=\"grid grid-cols-3\n            items-center gap-1\n            w-full max-h-[55px] h-full\n            shadow-lg col-auto\"\n          >\n            <section\n              id=\"Left\"\n              className=\"flex flex-row self-center min-h-max h-full\"\n            >\n              <NearLogo className=\"min-w-max\" height={50} width={50} />\n              <Link href=\"/\">\n                <h1\n                  onClick={() => setShowSearchBox(false)}\n                  className=\"flex pt-1.5 text-3xl font-extrabold min-w-max font-mono hover:cursor-pointer\"\n                >\n                  {\"Block Cards\"}\n                </h1>\n              </Link>\n              <div\n                className=\" flex w-full h-full\n            flex justify-center flex-col pr-[30px]\"\n              >\n                <SearchIcon\n                  className=\"self-end hover:cursor-pointer \"\n                  height={30}\n                  width={30}\n                  onClick={() => setShowSearchBox((prev) => !prev)}\n                />\n              </div>\n            </section>\n\n            <section id=\"Center\" className=\"max-h-[50px] grid grid-row-2\">\n              {contract?.contractId ? (\n                <>\n                  <span\n                    className=\"self-start justify-self-center\n                max-w-35  font-semibold text-sm font-mono\"\n                  >\n                    {wallet?.getAccountId() ? (\n                      <>\n                        Connected to: <span className=\"text-md\">&#x1F91D;</span>{\" \"}\n                      </>\n                    ) : (\n                      <>\n                        Connect to?<span className=\"text-md\"> &#x1F914;</span>\n                      </>\n                    )}\n                  </span>\n                  <a\n                    target=\"_blank\"\n                    className=\"justify-self-center hover:(underline)\"\n                    href={`https:\n                  >{`${contract.contractId}`}</a>\n                </>\n              ) : (\n                <></>\n              )}\n            </section>\n\n            <section\n              id=\"Right\"\n              className=\"max-h-[50px] h-full pl-[65px] pr-[30px] w-full\n              flex justify-between items-center text-xl\n              \"\n            >\n              <div\n                className=\"hover:cursor-pointer\n              h-[44px] w-[82px]\n\n              flex flex-col items-center justify-center\"\n                onClick={() => setShowErrorBox((prev) => !prev)}\n              >\n                <ErrorIcon\n                  stroke={errorList?.length > 0 ? \"#a80c19\" : \"#6B7280\"}\n                  height={25}\n                  width={25}\n                />\n                {errorList?.length > 0 && (\n                  <p className=\"text-xs w-max\">\n                    Click to {showErrorBox ? \"Hide\" : \"Show\"}\n                  </p>\n                )}\n              </div>\n\n              {wallet?.getAccountId() ? (\n                <button\n                  className=\"flex items-center justify-center\n                font-thin text-white\n                bg-black\n                border-solid rounded-lg border-black border-[2px]\n                h-[30px] w-[90px] pb-[2px]\n                hover:(border-danger  text-danger font-semibold bg-light-600)\"\n                  onClick={signOut}\n                >\n                  Sign Out\n                </button>\n              ) : (\n                <button\n                  className=\"flex items-center justify-center\n                font-thin text-white\n                bg-black\n                border-solid rounded-lg border-black border-[2px]\n                h-[30px] w-[90px] pb-[2px]\n                hover:(border-near-blue text-near-blue font-semibold bg-light-600)\"\n                  onClick={signIn}\n                >\n                  Sign in\n                </button>\n              )}\n            </section>\n          </nav>\n          <aside\n            id=\"error-container\"\n            className=\"absolute self-end mt-[75px] mr-[15px]\"\n          >\n            {errorList && showErrorBox && <ErrorBox></ErrorBox>}\n          </aside>\n          <aside\n            id=\"search-bar-container\"\n            className=\"absolute self-start mt-[65px] ml-[35px]\n          \"\n          >\n            {showSearchBox && (\n              <>\n                <div\n                  id=\"input-button-container\"\n                  className=\"focus:(border-near-blue border-2)\n                shadow-xl\n                w-max h-max\n                flex grid-cols-2\n                \"\n                >\n                  <input\n                    placeholder=\"search for an account\"\n                    className={`rounded-lg w-min border-2 border-gray-400\n                      focus:(border-near-blue)\n                      ${\n                        errorList?.length > 0\n                          ? \" focus:border-danger\"\n                          : \"border-near-blue\"\n                      } rounded-r-[0px] h-[35px] pl-[10px]  outline-none `}\n                    onChange={(e) => {\n                      setSearchValue(e.target.value);\n                    }}\n                    onKeyPress={(e) => {\n                      if (e.key === \"Enter\") {\n                        if (searchValue != \"\") {\n                          router.push(`/${searchValue}`);\n                        }\n                      }\n                      if (e.key === \"Escape\") {\n                        setShowSearchBox(false);\n                      }\n                      console.log(e.code);\n                    }}\n                  />\n                  <button\n                    className=\"flex items-center justify-center\n                   text-black\n                  bg-gray-400\n                  border-solid rounded-lg  rounded-l-[0px]\n                  h-[35px] w-max pb-[2px] pl-[8px] pr-[8px]\n                  hover:(border-black text-black bg-gray-500)\"\n                    onClick={() => router.push(`/${searchValue}`)}\n                  >\n                    Enter\n                  </button>\n                </div>\n              </>\n            )}\n          </aside>\n        </div>\n      }\n      {children}\n    </NavContext.Provider>\n  );\n};\n\n'bchain_business_card/frontend/src/context/NearProvider.tsx'\n:\nimport { useState, useEffect, useContext, createContext, Context } from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {\n  keyStores,\n  connect,\n  WalletConnection,\n  Near,\n  Contract,\n  utils,\n} from \"near-api-js\";\n\ninterface NearContext {\n  near: Near;\n  wallet: WalletConnection;\n  contract?: Contract;\n  currentUserId?: String;\n  viewFunction?: (functionName: any, args: {}) => Promise<any>;\n  callFunction?: (\n    functionName: any,\n    args: {},\n    deposit?: string\n  ) => Promise<any>;\n}\n\nexport const NearContext = createContext<NearContext>({\n  near: null,\n  wallet: null,\n  contract: null,\n});\nexport const viewMethods = [\"get_card\"];\nexport const changeMethods = [\n  \"set_website\",\n  \"add_blockchain\",\n  \"vouch\",\n  \"refute\",\n  \"create_new_card\",\n];\n\nexport function NearProvider({ children }) {\n  const [near, setNear] = useState(undefined);\n  const [wallet, setWallet] = useState(undefined);\n  const [contract, setContract] = useState<Contract>(undefined);\n  const [currentUserId, setCurrentUserId] = useState(undefined);\n\n  useEffect(() => {\n    (async function init() {\n      const config = {\n        networkId: process.env.NEXT_PUBLIC_NEAR_ENV,\n        keyStore: new keyStores.BrowserLocalStorageKeyStore(),\n        nodeUrl: process.env.NEXT_PUBLIC_RPC_URL,\n        walletUrl: process.env.NEXT_PUBLIC_WALLET_URL,\n        helperUrl: process.env.NEXT_PUBLIC_HELPER_URL,\n        explorerUrl: process.env.NEXT_PUBLIC_EXPLORER_URL,\n        headers: {},\n      };\n      const near_connection = await connect(config);\n      console.log(`fetching wallet...`);\n      const wallet_connection = new WalletConnection(\n        near_connection,\n        process.env.NEXT_PUBLIC_CONTRACT_LOCALSTORAGE_PREFIX\n      );\n      if (wallet_connection) {\n        console.log(\"wallet found\", wallet_connection);\n      }\n\n      if (typeof window !== \"undefined\") {\n        const contract = new Contract(\n          wallet_connection.account(),\n          process.env.NEXT_PUBLIC_CONTRACT_NAME!,\n          {\n            viewMethods: viewMethods,\n            changeMethods: changeMethods,\n          }\n        );\n        setContract(contract);\n      }\n\n      ReactDOM.unstable_batchedUpdates(() => {\n        setNear(near_connection);\n        setWallet(wallet_connection);\n        setCurrentUserId(wallet_connection.getAccountId());\n      });\n    })();\n  }, []);\n\n  const context = {\n    near,\n    wallet,\n    contract,\n    currentUserId,\n  };\n\n  return (\n    <>\n      <NearContext.Provider value={context}>{children}</NearContext.Provider>\n    </>\n  );\n}\nexport function useNear() {\n  return useContext(NearContext);\n}\n",
        "gt": [
            "'bchain_business_card/frontend/src/context/NearProvider.tsx'",
            "'bchain_business_card/frontend/src/components/Nav.tsx'",
            "'bchain_business_card/frontend/src/pages/_app.tsx'"
        ]
    },
    {
        "files": [
            "'installer-gui/frontend/components/actions/install.tsx'",
            "'installer-gui/frontend/modules/installer.ts'",
            "'installer-gui/frontend/index.ts'",
            "'installer-gui/frontend/components/App.tsx'"
        ],
        "content": "'installer-gui/frontend/components/actions/install.tsx'\n:import Preact, {Component, toChildArray} from \"preact\";\nimport AppContext from \"../AppContext\";\nimport FileInput from \"../fileinput\";\nimport \"./install.scss\";\nimport SuggestedApplications from \"./suggested\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport NotificationsStore from \"../notifications\";\nimport SwitchItem from \"../switchitem\";\nimport Terminal from \"../terminal\";\nimport Installer from \"../../modules/installer\";\nimport {ipcRenderer as IPC} from \"electron\";\nimport IPCEvents from \"@common/ipcevents\";\n\nexport default class InstallPage extends Component<{}, {\n    files: string[],\n    isBrowsing: boolean,\n    kernelPath: string,\n    shouldDownloadKernel: boolean;\n    shouldCreatePackages: boolean;\n    installationDone: boolean;\n}> {\n    fileInputRef = Preact.createRef();\n    terminalRef = Preact.createRef<Terminal>();\n\n    state = {\n        files: [],\n        isBrowsing: true,\n        kernelPath: \"\",\n        shouldDownloadKernel: true,\n        shouldCreatePackages: true,\n        installationDone: false\n    };\n\n    handleChange = (files: string[]): void => {\n        for (let i = 0; i < files.length; i++) {\n            if (this.state.files.includes(files[i])) {\n                files.splice(i, 1);\n                continue;\n            }\n\n            const location = path.resolve(files[i], \"resources\");\n            if (!fs.existsSync(location)) {\n                files.splice(i, 1);\n                NotificationsStore.showNotification(\"An invalid directory was given!\");\n            }\n        }\n\n        this.setState({\n            files: this.state.files.concat(files)\n        });\n    }\n\n    handleKernelPath = () => {}\n\n    get canInstall() {\n        return this.state.files.length > 0 && this.state.kernelPath !== \"\";\n    }\n\n    renderBrowser() {\n        return (\n            <>\n                <FileInput\n                    title=\"Applications to install kernel to\"\n                    name=\"Install paths\"\n                    files={this.state.files}\n                    onChange={(files) => this.handleChange(files)}\n                    onRemove={(path) => {\n                        this.setState(prev => {\n                            prev.files.splice(prev.files.indexOf(path), 1);\n                            return {...prev, files: prev.files};\n                        });\n                    }}\n                />\n                <FileInput\n                    title=\"Kernel path\"\n                    name=\"Kernel path\"\n                    onChange={([path]) => this.setState({kernelPath: path})}\n                    files={[this.state.kernelPath].filter(Boolean)}\n                    onRemove={() => {\n                        this.setState({kernelPath: \"\"});\n                    }}\n                />\n                <SuggestedApplications\n                    onSelect={app => {\n                        this.handleChange([app]);\n                    }}\n                    files={this.state.files}\n                />\n            </>\n        );\n    }\n\n    renderInstalling() {\n        return (\n            <>\n                <SwitchItem\n                    title=\"Download kernel.asar\"\n                    value={this.state.shouldDownloadKernel}\n                    onChange={value => {\n                        this.setState({shouldDownloadKernel: value});\n                    }}\n                />\n                <SwitchItem\n                    title=\"Create packages folder\"\n                    value={this.state.shouldCreatePackages}\n                    onChange={value => {\n                        this.setState({shouldCreatePackages: value});\n                    }}\n                />\n                <Terminal ref={this.terminalRef} />\n            </>\n        );\n    }\n\n    handleInstall() {\n        Installer.install(this.state.files, {\n            downloadASAR: this.state.shouldDownloadKernel,\n            kernelPath: this.state.kernelPath,\n            makePackagesFolder: this.state.shouldCreatePackages,\n        }, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({installationDone: true});\n        });\n    }\n\n    render(_, {isBrowsing, installationDone}) {\n        return (\n            <AppContext.Consumer>\n                {App => (\n                    <div class=\"installing\">\n                        <div class=\"scroller\">\n                            {isBrowsing ? this.renderBrowser() : this.renderInstalling()}\n                            <div class=\"margin-bottom10\" />\n                        </div>\n                        <div class=\"footer\">\n                            <button onClick={() => {\n                                if (isBrowsing) App.reset();\n                                else this.setState({isBrowsing: true});\n                            }}>Back</button>\n                            <button\n                                disabled={!this.canInstall}\n                                onClick={() => {\n                                    if (!this.canInstall) return;\n\n                                    if (installationDone) return IPC.send(IPCEvents.CLOSE_APP);\n                                    if (!isBrowsing) {\n                                        this.handleInstall();\n                                    } else {\n                                        this.setState({isBrowsing: false});\n                                    }\n                                }}\n                            >\n                                {isBrowsing ? \"Continue\" : installationDone ? \"Close\" : \"Install\"}\n                            </button>\n                        </div>\n                    </div>\n                )}\n            </AppContext.Consumer>\n        );\n    }\n}\n'installer-gui/frontend/modules/installer.ts'\n:\n'installer-gui/frontend/index.ts'\n:import {h, render} from \"preact\";\nimport App from \"./components/App\";\nimport Styles from \"./styles\";\nimport {createElement} from \"./util\";\nimport \"./index.scss\";\n\nStyles.inject();\nconst root = createElement(\"div\", {id: \"root\"});\ndocument.body.appendChild(root);\n\nrender(\n    h(App, {}),\n    root\n);\n'installer-gui/frontend/components/App.tsx'\n:import Preact, {Component} from \"preact\";\nimport InstallPage from \"./actions/install\";\nimport UninstallPage from \"./actions/uninstall\";\nimport UpdatePage from \"./actions/update\";\nimport AppContext from \"./AppContext\";\nimport Category from \"./category\";\nimport Install from \"./icons/install\";\nimport Uninstall from \"./icons/uninstall\";\nimport Update from \"./icons/update\";\nimport {Notifications} from \"./notifications\";\nimport TitleBar from \"./titlebar\";\n\nexport default class App extends Component {\n    state = {navigator: {}}\n\n    handleSetPage({element, title}): void {\n        this.setState({\n            navigator: {element, title}\n        });\n    }\n\n    handleReset(): void {\n        this.setState({navigator: {}});\n    }\n\n    renderHome() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Actions</div>\n                <Category title=\"Install\" icon={Install} note=\"Install kernel to an application you choose.\">\n                    <InstallPage />\n                </Category>\n                <Category title=\"Uninstall\" icon={Uninstall} note=\"Uninstall kernel from an application you choose.\">\n                    <UninstallPage />\n                </Category>\n                <Category title=\"Update\" icon={Update} note=\"Update the kernel.asar to the latest release.\">\n                    <UpdatePage />\n                </Category>\n            </div>\n        );\n    }\n\n    render(_, {navigator}) {\n        const context = {\n            currentPage: navigator,\n            setPage: this.handleSetPage.bind(this),\n            reset: this.handleReset.bind(this)\n        };\n\n        return (\n            <AppContext.Provider value={context}>\n                <div id=\"app-mount\">\n                    <TitleBar />\n                    <div class=\"app\">\n                        {navigator.element ? navigator.element : this.renderHome()}\n                    </div>\n                    <Notifications />\n                </div>\n            </AppContext.Provider>\n        );\n    }\n}",
        "gt": [
            "'installer-gui/frontend/modules/installer.ts'",
            "'installer-gui/frontend/components/actions/install.tsx'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'"
        ]
    },
    {
        "files": [
            "'ng-jda-2017-07-05/apps/store-app/src/app/services/logging.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/products/product-list/product-list.component.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/app.module.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/main.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/services/products.service.ts'"
        ],
        "content": "'ng-jda-2017-07-05/apps/store-app/src/app/services/logging.service.ts'\n:export class LoggingService {\n    logMessage(message: string) {\n        console.log('[LoggingService.logMessage()]', message);\n    }\n}\n\n'ng-jda-2017-07-05/apps/store-app/src/app/products/product-list/product-list.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { Router } from '@angular/router';\n\nimport { Product } from '../../models/product';\nimport { ProductsService } from '../../services/products.service';\nimport { LoggingService } from '../../services/logging.service';\n\n@Component({\n  selector: 'app-product-list',\n  templateUrl: './product-list.component.html',\n  styleUrls: ['./product-list.component.css']\n})\nexport class ProductListComponent implements OnInit {\n  products: Product[];\n\n  constructor(\n    private productsService: ProductsService,\n    private loggingService: LoggingService,\n    private router: Router\n  ) {\n    this.products = [];\n  }\n\n  ngOnInit() {\n    this.productsService.productAdded.subscribe(\n      (newProduct) => {\n        this.products.push(newProduct);\n      }\n    );\n    this.productsService.productUpdated.subscribe(\n      (updatedProduct) => {\n        this.updateProduct(updatedProduct);\n      }\n    );\n    this.productsService.productDeleted.subscribe(\n      (id) => {\n        this.deleteProduct(id);\n      }\n    );\n\n    this.getProducts();\n  }\n\n  private updateProduct(updatedProduct: Product) {\n    const product = this.products.find(\n        product => product.id === updatedProduct.id\n    );\n\n    if(product) {\n        product.name = updatedProduct.name;\n        product.description = updatedProduct.description;\n        product.isAvailable = updatedProduct.isAvailable;\n        product.price = updatedProduct.price;\n    }\n  }\n\n  private deleteProduct(id: number) {\n    const index = this.products.findIndex(\n      product => product.id === id\n    )\n\n    if(index >= 0) {\n      this.products.splice(index, 1);\n    }\n  }\n\n  private getProducts() {\n\n\n    this.productsService.getProducts()\n      .subscribe(\n        (products: Product[]) => {\n          this.products = products;\n          console.log('Products retrieved successfully.', products);\n        }\n      );\n  }\n\n  onAdd() {\n    this.loggingService.logMessage('Product List - Add button clicked.');\n    this.router.navigate(['/products', 'new', 'edit']);\n  }\n}\n\n'ng-jda-2017-07-05/apps/store-app/src/app/app.module.ts'\n:import { ErrorHandler } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { Routes, RouterModule } from '@angular/router';\nimport { HttpModule } from '@angular/http';\n\nimport { AppComponent } from './app.component';\n\n\nimport { HomeComponent } from './home/home.component';\nimport { NotFoundComponent } from './not-found/not-found.component';\nimport { NavComponent } from './nav/nav.component';\n\n\nimport { ProductsComponent } from './products/products.component';\nimport { ProductListComponent } from './products/product-list/product-list.component';\nimport { ProductDetailComponent } from './products/product-detail/product-detail.component';\nimport { ProductFormComponent } from './products/product-form/product-form.component';\n\n\nimport { CustomersComponent } from './customers/customers.component';\nimport { CustomerListComponent } from './customers/customer-list/customer-list.component';\nimport { CustomerDetailComponent } from './customers/customer-detail/customer-detail.component';\nimport { CustomerFormComponent } from './customers/customer-form/customer-form.component';\n\n\nimport { LoggingService } from './services/logging.service';\nimport { ProductsService } from './services/products.service';\nimport { CustomersService } from './services/customers.service';\n\n\nimport { AppErrorHandler } from './errors/app-error-handler';\n\n\nconst appRoutes: Routes = [\n  {\n    path: 'products', component: ProductsComponent, children: [\n      { path: ':id', component: ProductDetailComponent },\n      { path: ':id/edit', component: ProductFormComponent }\n    ]\n  },\n  {\n    path: 'customers', component: CustomersComponent, children: [\n      { path: ':id', component: CustomerDetailComponent },\n      { path: ':id/edit', component: CustomerFormComponent }\n    ]\n  },\n  { path: '', component: HomeComponent },\n  { path: 'not-found', component: NotFoundComponent },\n  { path: '**', redirectTo: 'not-found' }\n];\n\n@NgModule({\n  declarations: [\n    AppComponent,\n\n    HomeComponent,\n    NotFoundComponent,\n    NavComponent,\n\n    ProductsComponent,\n    ProductListComponent,\n    ProductDetailComponent,\n    ProductFormComponent,\n\n    CustomersComponent,\n    CustomerListComponent,\n    CustomerDetailComponent,\n    CustomerFormComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpModule,\n    RouterModule.forRoot(appRoutes)\n  ],\n  providers: [\n    LoggingService,\n    ProductsService,\n    CustomersService,\n    { provide: ErrorHandler, useClass: AppErrorHandler }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'ng-jda-2017-07-05/apps/store-app/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n'ng-jda-2017-07-05/apps/store-app/src/app/services/products.service.ts'\n:import { Injectable, EventEmitter } from '@angular/core';\nimport { Http, Response } from '@angular/http';\nimport { Observable } from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/observable/throw';\n\nimport { Product } from '../models/product';\nimport { LoggingService } from './logging.service';\nimport { AppError } from '../errors/app-error';\nimport { NotFoundError } from '../errors/not-found-error';\nimport { BadInputError } from '../errors/bad-input-error';\n\n@Injectable()\nexport class ProductsService {\n    productAdded = new EventEmitter<Product>();\n    productUpdated = new EventEmitter<Product>();\n    productDeleted = new EventEmitter<number>();\n\n    private apiUrl = 'http:\n\n    private products: Product[] = [\n        { id: 1, name: 'Data Structures and Algorithms', description: 'An ideal book for first course on data structures and algorithms, its text ensures a style and content relevant to present-day programming.', isAvailable: true, price: 285 },\n        { id: 2, name: 'Premsons 608 Four Bearing Fidget Spinner', description: 'Perfect toy for fidgeters.', isAvailable: false, price: 160 },\n        { id: 3, name: 'Bahubali', description: 'Raised in a remote tribal village, Shivudu grows up a carefree young man who relentlessly pursues his heart\\'s desire.', isAvailable: true, price: 268 }\n    ];\n\n    constructor(\n        private loggingService: LoggingService,\n        private http: Http\n    ) {}\n\n    getProductsLocal(): Product[] {\n        return this.products;\n    }\n\n    getProductLocal(id: number): Product {\n        this.loggingService.logMessage('Get Product, id: ' + id);\n\n        const product = this.products.find(\n            product => product.id === id\n        )\n        return product;\n    }\n\n    addProductLocal(product: Product) {\n        const newProduct = new Product();\n        newProduct.id = this.generateId();\n        newProduct.name = product.name;\n        newProduct.description = product.description;\n        newProduct.isAvailable = product.isAvailable;\n        newProduct.price = product.price;\n\n        this.products.push(newProduct);\n    }\n\n    private generateId(): number {\n        let id = 1;\n        let lastItemIndex = this.products.length - 1;\n        if(lastItemIndex > -1) {\n            id = this.products[lastItemIndex].id + 1;\n        }\n        return id;\n    }\n\n    updateProductLocal(id: number, productInfo: Product) {\n        const product = this.getProductLocal(id);\n\n        if(product) {\n            product.name = productInfo.name;\n            product.description = productInfo.description;\n            product.isAvailable = productInfo.isAvailable;\n            product.price = productInfo.price;\n        }\n    }\n\n    deleteProductLocal(id: number) {\n        const index = this.products.findIndex(\n            product => product.id === id\n        )\n\n        if(index >= 0) {\n            this.products.splice(index, 1);\n        }\n    }\n\n    getProducts(): Observable<Product[]> {\n        return this.http.get(this.apiUrl)\n            .map((response: Response) => response.json())\n            .catch(this.handleError);\n    }\n\n    getProduct(id: number): Observable<Product> {\n        return this.http.get(this.apiUrl + '/' + id)\n            .map((response: Response) => response.json())\n            .catch(this.handleError);\n    }\n\n    addProduct(newProduct: Product): Observable<Product> {\n        return this.http.post(this.apiUrl, newProduct)\n            .map(\n                (response: Response) => {\n                    console.log(response);\n                    let p = response.json();\n                    this.productAdded.emit(p);\n                    return p;\n                }\n            )\n            .catch(this.handleError);\n    }\n\n    updateProduct(id: number, product: Product): Observable<Product> {\n        return this.http.patch(this.apiUrl + '/' + id, product)\n            .map(\n                (response: Response) => {\n                    let p = response.json();\n                    this.productUpdated.emit(p);\n                    return p;\n                }\n            )\n            .catch(this.handleError);\n    }\n\n    deleteProduct(id: number): Observable<Product> {\n        return this.http.delete(this.apiUrl + '/' + id)\n            .map(\n                (response: Response) => {\n                    this.productDeleted.emit(id);\n                    return response.json();\n                }\n            )\n            .catch(this.handleError);\n    }\n\n    private handleError(error: Response) {\n        if(error.status === 400) {\n            return Observable.throw(new BadInputError());\n        }\n\n        if(error.status === 404) {\n            return Observable.throw(new NotFoundError());\n        }\n\n        return Observable.throw(new AppError(error));\n    }\n}\n",
        "gt": [
            "'ng-jda-2017-07-05/apps/store-app/src/app/services/logging.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/services/products.service.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/products/product-list/product-list.component.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/app/app.module.ts'",
            "'ng-jda-2017-07-05/apps/store-app/src/main.ts'"
        ]
    },
    {
        "files": [
            "'ngx-printer-demo/projects/ngx-printer/src/lib/helper.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.spec.ts'"
        ],
        "content": "'ngx-printer-demo/projects/ngx-printer/src/lib/helper.ts'\n:\nexport class Helpers {\n\n\n   public static copyCss(printWindowDoc: Document) {\n\n    const links = document.querySelectorAll('link');\n    const styles = document.querySelectorAll('style');\n    const base = document.querySelector('base');\n\n    const targetHead = printWindowDoc.getElementsByTagName('head')[0];\n\n    if (base) {\n      targetHead.appendChild(document.importNode(base, true));\n    }\n\n    links.forEach(link => {\n      targetHead.appendChild(document.importNode(link, true));\n    });\n\n    styles.forEach(style => {\n      targetHead.appendChild(document.importNode(style, true));\n    });\n  }\n\n}\n\n\n'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'\n:import { Helpers } from \"./helper\";\nimport { ngxPrintMarkerPosition } from \"./ngx-print-marker-position.enum\";\nimport { PrintItem } from \"./print-item\";\nimport {\n  ComponentFactoryResolver,\n  EnvironmentInjector,\n  Injectable,\n  Injector,\n  Optional,\n  TemplateRef,\n  Type,\n  createComponent,\n} from \"@angular/core\";\nimport { NgxPrinterComponent } from \"./ngx-printer.component\";\nimport { BehaviorSubject } from \"rxjs\";\nimport { PrintServiceConfig } from \"./print-service-config\";\n\nexport type Content<T> = string | HTMLElement | TemplateRef<T> | Type<T>;\n\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class NgxPrinterService {\n  private printWindowOpen = new BehaviorSubject<boolean>(false);\n\n\n  private _printItems = new BehaviorSubject<PrintItem[]>([]);\n  $printItems = this._printItems.asObservable();\n\n  private openNgxPrinter: HTMLElement;\n\n\n  timeToWaitRender = 200;\n\n\n  renderClass = \"default\";\n\n\n  printOpenWindow = true;\n\n\n  appRootName = \"app-root\";\n\n\n  printPreviewOnly = false;\n\n  appRoot: HTMLElement;\n  appRootDislaySetting = \"\";\n\n  $printWindowOpen = this.printWindowOpen.asObservable();\n  eventadded = [];\n  markerPosition: ngxPrintMarkerPosition;\n\n  constructor(\n    @Optional() config: PrintServiceConfig,\n    private envInjector: EnvironmentInjector,\n  ) {\n    this.setRootConfigOptions(config);\n  }\n\n\n  private setRootConfigOptions(config: PrintServiceConfig): void {\n    if (config) {\n      config.timeToWaitRender &&\n        (this.timeToWaitRender = config.timeToWaitRender);\n\n      config.renderClass && (this.renderClass = config.renderClass);\n\n      config.appRootName && (this.appRootName = config.appRootName);\n\n      config.markerPosition && (this.markerPosition = config.markerPosition);\n\n      if (config.hasOwnProperty(\"printPreviewOnly\")) {\n        this.printPreviewOnly = config.printPreviewOnly;\n      }\n\n      if (config.hasOwnProperty(\"printOpenWindow\")) {\n        this.printOpenWindow = config.printOpenWindow;\n      }\n    }\n  }\n\n\n  public printDiv(divID: string): void {\n    const divToPrint = document.getElementById(divID);\n\n    if (divToPrint) {\n      this.print(divToPrint, this.printOpenWindow);\n    } else {\n      console.log(`div with id ${divID} not found..`);\n    }\n  }\n\n\n  public printByClassName(className: string): void {\n    const elementToPrint = document.getElementsByClassName(className);\n\n    if (elementToPrint && elementToPrint.length > 0) {\n      this.print(<HTMLScriptElement>elementToPrint[0], this.printOpenWindow);\n    } else {\n      console.log(\"element with id ${className} not found..\");\n    }\n  }\n\n\n  public printAngular(contentToPrint: any, context?: any): void {\n    const nativeEl = this.createComponent(contentToPrint, null, context);\n\n    this.print(nativeEl.nativeElement, this.printOpenWindow);\n  }\n\n\n  public printImg(imgSrc: string): void {\n    const compRef = this.createComponent(null, imgSrc);\n    const openNewWindow = this.printOpenWindow;\n\n    compRef.instance.completed.subscribe((val) => {\n      compRef.hostView.detectChanges();\n      console.log(\"completed:\", val);\n      this.print(compRef.location.nativeElement, openNewWindow);\n    });\n  }\n\n\n  public printHTMLElement(nativeElement: HTMLElement): void {\n    this.print(nativeElement, this.printOpenWindow);\n  }\n\n\n  private createComponent(\n    contentToRender: any,\n    imgSrc?: string,\n    context?: any\n  ): any {\n\n    let componentRef: any;\n\n    if (contentToRender) {\n      if (context === undefined) {\n        context = null;\n      }\n      const ngContent = this.resolveNgContent(contentToRender, context);\n\n      componentRef = createComponent(NgxPrinterComponent, {\n        environmentInjector: this.envInjector,\n        projectableNodes: ngContent\n      });\n\n    } else {\n      componentRef = createComponent(NgxPrinterComponent, {\n        environmentInjector: this.envInjector,\n      });\n    }\n\n    componentRef.instance.renderClass = this.renderClass;\n\n    if (imgSrc) {\n      componentRef.instance.imgSrc = imgSrc;\n      return componentRef;\n    }\n\n    componentRef.hostView.detectChanges();\n    return componentRef.location;\n  }\n\n\n  private print(printContent: any, printOpenWindow: boolean): void {\n    if (printOpenWindow === true) {\n      const printContentClone = document.importNode(printContent, true);\n\n      this.hideBeforePrint(printContentClone);\n      this.printInNewWindow(printContentClone);\n    }\n    if (printOpenWindow === false) {\n      const printContentClone = document.importNode(printContent, true);\n      this.hideBeforePrint(printContentClone);\n      const nativeEl = this.createComponent(printContentClone).nativeElement;\n      this.openNgxPrinter = nativeEl;\n      document.body.appendChild(this.openNgxPrinter);\n\n      this.getAppRoot();\n\n      this.appRoot && (this.appRoot.style.display = \"none\");\n\n      this.printCurrentWindow();\n    }\n  }\n\n\n  private printInNewWindow(divToPrint: HTMLElement): void {\n    const printWindow = window.open(\"\", \"PRINT\");\n    const title = document.title;\n\n    printWindow.document.write(\n      \"<HTML><HEAD><TITLE>\" + title + \"</TITLE></HEAD><BODY></BODY></HTML>\"\n    );\n\n\n    const printWindowDoc = printWindow.document;\n    Helpers.copyCss(printWindowDoc);\n\n    printWindowDoc.body.style.margin = \"0 0\";\n    printWindowDoc.body.appendChild(divToPrint);\n    printWindow.document.close();\n\n    setTimeout(\n      () => this.printTabWindow(printWindow, printWindowDoc),\n      this.timeToWaitRender\n    );\n  }\n\n\n  private printTabWindow(printWindow: Window, printWindowDoc: Document): void {\n    if (this.printPreviewOnly) {\n      return;\n    }\n    this.registerPrintEvent(printWindow, true);\n    this.printWindowOpen.next(true);\n    printWindow.focus();\n    if (printWindowDoc.execCommand(\"print\") === false) {\n      printWindow.print();\n    }\n  }\n\n\n  public printCurrentWindow(): void {\n    if (this.printPreviewOnly) {\n      return;\n    }\n    this.registerPrintEvent(window, false);\n    setTimeout(() => {\n      this.printWindowOpen.next(true);\n      if (document.execCommand(\"print\") === false) {\n        window.print();\n      }\n    }, this.timeToWaitRender);\n  }\n\n\n  private registerPrintEvent(\n    printWindow: Window,\n    printWithOpenInNewWindow: boolean\n  ) {\n    const that = this;\n    printWindow.focus();\n\n    if (that.eventadded[printWindow.name]) {\n      return;\n    }\n\n\n\n\n    printWindow.addEventListener('beforeprint', () => {});\n\n    printWindow.addEventListener('afterprint', () => {\n      this.eventadded[printWindow.name] = true;\n      console.log('afterprint');\n\n      if (printWithOpenInNewWindow) {\n        that.eventadded[printWindow.name] = false;\n      }\n      that.cleanUp(printWindow, printWithOpenInNewWindow);\n      that.printWindowOpen.next(false);\n    });\n  }\n\n\n  private cleanUp(printWindow: Window, printOpenWindow: boolean): void {\n    if (printOpenWindow === true) {\n      console.log(\"close print window\");\n      printWindow.close();\n      setTimeout(() => {\n        printWindow.close();\n      }, 20);\n    }\n    if (printOpenWindow === false) {\n      if (!this.openNgxPrinter) {\n        return;\n      }\n      if (document.body.getElementsByTagName(\"ngx-printer\").length === 0) {\n        return;\n      }\n\n      if (this.appRoot) {\n        if (this.appRootDislaySetting !== \"\") {\n          this.appRoot.style.display = this.appRootDislaySetting;\n        } else {\n          this.appRoot.style.display = \"\";\n        }\n      }\n\n      document.body.removeChild(this.openNgxPrinter);\n      this.openNgxPrinter = null;\n    }\n  }\n\n\n  private hideBeforePrint(parentDiv: HTMLElement): void {\n    const childrenOfDiv = parentDiv.querySelectorAll(\".no_print_indicator\");\n\n    for (let i = 0; i < childrenOfDiv.length; i++) {\n      const child = childrenOfDiv[i] as HTMLElement;\n      child.style.display = \"none\";\n    }\n  }\n\n\n  private getAppRoot(): void {\n    const appRoot = document.body.getElementsByTagName(this.appRootName);\n    if (appRoot.length === 0) {\n      return null;\n    } else {\n      this.appRoot = <HTMLElement>appRoot[0];\n      this.appRootDislaySetting = this.appRoot.style.display;\n    }\n  }\n\n\n  public addPrintItem(newPrintItem: PrintItem): void {\n    const tmpItems = this._printItems.getValue();\n\n    tmpItems.push(newPrintItem);\n    this._printItems.next(tmpItems);\n  }\n\n\n  public removePrintItem(idOfItemToRemove: string): void {\n    const tmpItems = this._printItems.getValue();\n    const newIitems = tmpItems.filter((item) => item.id !== idOfItemToRemove);\n\n    this._printItems.next(newIitems);\n  }\n\n\n  public getPrintItem(idOfItemToRemove: string): PrintItem {\n    const tmpItems = this._printItems.getValue();\n    const foundItem = tmpItems.find((item) => item.id === idOfItemToRemove);\n\n    return foundItem;\n  }\n\n\n  public printPrintItem(printItemToPrint: PrintItem): void {\n    this.printHTMLElement(printItemToPrint.nativeElement);\n  }\n\n\n  public printPrintItems(\n    printItemsToPrint: PrintItem[],\n    className?: string\n  ): void {\n    const newDiv = <HTMLDivElement>document.createElement(\"div\");\n\n    if (className) {\n      newDiv.classList.add(className);\n    } else {\n      newDiv.style.display = \"flex\";\n      newDiv.style.flexDirection = \"column\";\n    }\n\n    printItemsToPrint.forEach((element) => {\n      newDiv.appendChild(element.nativeElement.cloneNode(true));\n    });\n\n    this.printHTMLElement(newDiv);\n  }\n\n\n  private resolveNgContent<T>(content: Content<T>, context: any): any {\n    if (typeof content === \"string\") {\n      const element = document.createTextNode(content);\n\n      return [[element]];\n    }\n\n    if (content instanceof TemplateRef) {\n      const viewRef = content.createEmbeddedView(context);\n\n      viewRef.detectChanges();\n\n      return [viewRef.rootNodes];\n    }\n\n    if (content instanceof HTMLElement) {\n      return [[content]];\n    }\n\n\n\n    let componentRef =  createComponent(content, {\n      environmentInjector: this.envInjector,\n    });\n\n\n    componentRef.changeDetectorRef.detectChanges();\n\n    return [[componentRef.location.nativeElement]];\n  }\n}\n\n'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.spec.ts'\n:import { PrintItemMarkerDirective } from './print-item-marker.directive';\nimport { NgxPrinterService } from './ngx-printer.service';\nimport { TestBed } from '@angular/core/testing';\n\ndescribe('PrintItemMarkerDirective', () => {\n  it('should create an instance', () => {\n    const service = TestBed.get(NgxPrinterService);\n    const directive = new PrintItemMarkerDirective(null, null, service);\n    expect(directive).toBeTruthy();\n  });\n});\n",
        "gt": [
            "'ngx-printer-demo/projects/ngx-printer/src/lib/helper.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.spec.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/auth/auth.module.ts'",
            "'is-even/apps/backend/src/user/user.module.ts'",
            "'is-even/apps/backend/src/user/dto/login-user.dto.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/user/user.controller.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'"
        ],
        "content": "'is-even/apps/backend/src/auth/auth.module.ts'\n:import { Module } from '@nestjs/common';\nimport { PassportModule } from '@nestjs/passport';\n\nimport { UserModule } from '../user/user.module';\nimport { AppConfigModule } from '../config/config.module';\nimport { JwtStrategy } from './jwt.strategy';\nimport { LoggerModule } from '../logger/logger.module';\n\n@Module({\n  providers: [JwtStrategy],\n  imports: [\n    UserModule,\n    LoggerModule,\n    AppConfigModule,\n    PassportModule.register({ defaultStrategy: 'jwt' }),\n  ],\n})\nexport class AuthModule {}\n\n'is-even/apps/backend/src/user/user.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { User } from './user.entity';\nimport { UserService } from './user.service';\nimport { UserController } from './user.controller';\n\nimport { CognitoModule } from '../cognito/cognito.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [UserService],\n  exports: [UserService],\n  controllers: [UserController],\n  imports: [\n    TypeOrmModule.forFeature([User]),\n    CognitoModule,\n    LoggerModule,\n    SentryModule,\n  ],\n})\nexport class UserModule {}\n\n'is-even/apps/backend/src/user/dto/login-user.dto.ts'\n:import { IsEmail, IsNotEmpty, IsString } from 'class-validator';\nimport { ApiProperty } from '@nestjs/swagger';\n\nexport class LoginUserDto {\n  @ApiProperty()\n  @IsEmail()\n  @IsNotEmpty()\n  email: string;\n\n  @ApiProperty()\n  @IsString()\n  @IsNotEmpty()\n  password: string;\n}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/user/user.controller.ts'\n:import {\n  Controller,\n  Post,\n  HttpStatus,\n  HttpException,\n  Body,\n  Get,\n  Req,\n  BadRequestException,\n  HttpCode,\n} from '@nestjs/common';\nimport { ApiResponse, ApiTags } from '@nestjs/swagger';\n\nimport { CognitoCreateUserError } from '../cognito/error/cognito-create-user.error';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { LoginUserDto } from './dto/login-user.dto';\nimport { UserWithAuth } from './interface/user-with-auth.interface';\nimport { User } from './user.entity';\nimport { UserService } from './user.service';\nimport { Authorised } from '../auth/auth.decorator';\nimport { RequestWithUser } from '../common/interface/request-with-user.interface';\nimport { LoginUserError } from './error/login-user.error';\nimport { RefreshUserTokenDto } from './dto/refresh-user-token.dto';\n\n@Controller('users')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Post('/register')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'User has been successfully created',\n  })\n  @ApiResponse({\n    status: HttpStatus.SERVICE_UNAVAILABLE,\n    description: 'Third party service error',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async createUser(@Body() createUserDto: CreateUserDto): Promise<User> {\n    const { firstName, lastName, email, password } = createUserDto;\n    try {\n      return await this.userService.createUser(\n        firstName,\n        lastName,\n        email,\n        password,\n      );\n    } catch (error) {\n      if (error instanceof CognitoCreateUserError) {\n        throw new HttpException(\n          'Service temporary unavailable',\n          HttpStatus.SERVICE_UNAVAILABLE,\n        );\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Post('login')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'User has been successfully logged in',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async loginUser(\n    @Body() loginUserDto: LoginUserDto,\n  ): Promise<UserWithAuth> {\n    const { email, password } = loginUserDto;\n    try {\n      return await this.userService.loginWithCredentials(email, password);\n    } catch (error) {\n      if (error instanceof LoginUserError) {\n        throw new BadRequestException('Invalid email or password');\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Post('refresh')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Token has been successfully refreshed',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async refreshUserToken(\n    @Body() refreshUserTokenDto: RefreshUserTokenDto,\n  ): Promise<UserWithAuth> {\n    const { refreshToken } = refreshUserTokenDto;\n    try {\n      return await this.userService.loginWithToken(refreshToken);\n    } catch (error) {\n      if (error instanceof LoginUserError) {\n        throw new BadRequestException('Invalid token');\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @Post('logout')\n  @Authorised()\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.NO_CONTENT,\n    description: 'User has been successfully logout',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  public async logoutUser(@Req() request: RequestWithUser): Promise<void> {\n    const user = request.user;\n\n    try {\n      return await this.userService.logoutUser(user.email);\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Get('me')\n  @Authorised()\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'User data has been successfully retrieved',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  public async me(@Req() request: RequestWithUser): Promise<User> {\n    try {\n      return request.user;\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n",
        "gt": [
            "'is-even/apps/backend/src/user/dto/login-user.dto.ts'",
            "'is-even/apps/backend/src/user/user.controller.ts'",
            "'is-even/apps/backend/src/user/user.module.ts'",
            "'is-even/apps/backend/src/auth/auth.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'",
            "'extension/src/pages/overlay/components/Buttons.tsx'",
            "'extension/src/pages/overlay/hooks/useSettings.tsx'"
        ],
        "content": "'extension/src/pages/overlay/components/overlay/Overlay.tsx'\n:import {\n  useEffect,\n  useRef,\n  useCallback,\n  useState,\n  useMemo,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\nimport Welcome from \"../../../../components/Welcome\";\nimport IconWelcome from \"../../../../components/icons/IconWelcome\";\nimport IconAmbassadors from \"../../../../components/icons/IconAmbassadors\";\nimport IconSettings from \"../../../../components/icons/IconSettings\";\n\nimport {\n  isAmbassadorKey,\n  type AmbassadorKey,\n} from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\nimport { visibleUnderCursor } from \"../../../../utils/dom\";\n\nimport useChatCommand from \"../../../../hooks/useChatCommand\";\n\nimport useSettings from \"../../hooks/useSettings\";\nimport useSleeping from \"../../hooks/useSleeping\";\n\nimport AmbassadorsOverlay from \"./Ambassadors\";\nimport SettingsOverlay from \"./Settings\";\n\nimport Buttons from \"../Buttons\";\n\n\nconst commandTimeout = 10_000;\n\nconst overlayOptions = [\n  {\n    key: \"welcome\",\n    type: \"primary\",\n    icon: IconWelcome,\n    title: \"Welcome to Alveus\",\n    component: (props: OverlayOptionProps) => (\n      <Welcome\n        className={classes(\"absolute left-0 top-0 mx-4 my-6\", props.className)}\n      />\n    ),\n  },\n  {\n    key: \"ambassadors\",\n    type: \"primary\",\n    icon: IconAmbassadors,\n    title: \"Explore our Ambassadors\",\n    component: AmbassadorsOverlay,\n  },\n  {\n    key: \"settings\",\n    type: \"secondary\",\n    icon: IconSettings,\n    title: \"Extension Settings\",\n    component: SettingsOverlay,\n  },\n] as const;\n\nexport const isValidOverlayKey = (key: string) =>\n  key === \"\" || overlayOptions.some((option) => option.key === key);\n\nexport type OverlayKey = (typeof overlayOptions)[number][\"key\"] | \"\";\n\ntype ActiveAmbassadorState = {\n  key?: AmbassadorKey;\n  isCommand?: boolean;\n};\n\nexport interface OverlayOptionProps {\n  context: {\n    activeAmbassador: ActiveAmbassadorState;\n    setActiveAmbassador: Dispatch<SetStateAction<ActiveAmbassadorState>>;\n  };\n  className?: string;\n}\n\nconst hiddenClass =\n  \"invisible opacity-0 -translate-x-10 motion-reduce:translate-x-0\";\n\nexport default function Overlay() {\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n  const [activeAmbassador, setActiveAmbassador] =\n    useState<ActiveAmbassadorState>({});\n  const [visibleOption, setVisibleOption] = useState<OverlayKey>(\n    settings.openedMenu.value,\n  );\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const awakingRef = useRef(false);\n\n\n  useEffect(() => {\n    settings.openedMenu.change(visibleOption);\n  }, [visibleOption]);\n\n\n  useEffect(() => {\n    setVisibleOption(settings.openedMenu.value);\n  }, [settings.openedMenu.value]);\n\n\n  useChatCommand(\n    useCallback(\n      (command: string) => {\n        if (!settings.disableChatPopup.value) {\n          if (isAmbassadorKey(command))\n            setActiveAmbassador({ key: command, isCommand: true });\n          else if (command !== \"welcome\") return;\n\n\n          setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n\n          if (timeoutRef.current) clearTimeout(timeoutRef.current);\n          timeoutRef.current = setTimeout(() => {\n            setVisibleOption(\"\");\n            setActiveAmbassador({});\n          }, commandTimeout);\n\n\n          awakingRef.current = true;\n          wake(commandTimeout);\n        }\n      },\n      [settings.disableChatPopup.value, wake],\n    ),\n  );\n\n\n  useEffect(\n    () => () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    },\n    [],\n  );\n\n\n\n  useEffect(() => {\n    const callback = () => {\n      if (awakingRef.current) awakingRef.current = false;\n      else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    };\n    addSleepListener(\"wake\", callback);\n    return () => removeSleepListener(\"wake\", callback);\n  }, [addSleepListener, removeSleepListener]);\n\n\n  const bodyClick = useCallback((e: MouseEvent) => {\n    if (!visibleUnderCursor(e)) {\n      setVisibleOption(\"\");\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"click\", bodyClick, true);\n    return () => document.body.removeEventListener(\"click\", bodyClick, true);\n  }, [bodyClick]);\n\n\n  const bodyDblClick = useCallback((e: MouseEvent) => {\n    if (visibleUnderCursor(e)) {\n      e.stopPropagation();\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n    return () =>\n      document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n  }, [bodyDblClick]);\n\n\n  const context = useMemo<OverlayOptionProps[\"context\"]>(\n    () => ({\n      activeAmbassador,\n      setActiveAmbassador,\n    }),\n    [activeAmbassador],\n  );\n\n  return (\n    <div\n      className={classes(\n        \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          ) &&\n          hiddenClass,\n      )}\n    >\n      <Buttons\n        options={overlayOptions}\n        onClick={setVisibleOption}\n        active={visibleOption}\n      />\n      <div className=\"relative h-full w-full\">\n        {overlayOptions.map((option) => (\n          <option.component\n            key={option.key}\n            context={context}\n            className={classes(\n              \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n              visibleOption !== option.key && hiddenClass,\n            )}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n'extension/src/pages/overlay/components/overlay/Settings.tsx'\n:import { typeSafeObjectEntries } from \"../../../../utils/helpers\";\nimport { classes } from \"../../../../utils/classes\";\n\nimport useSettings from \"../../hooks/useSettings\";\n\nimport Card from \"../../../../components/Card\";\nimport Toggle from \"../Toggle\";\n\nimport type { OverlayOptionProps } from \"./Overlay\";\n\nexport default function Settings(props: OverlayOptionProps) {\n  const { className } = props;\n  const settings = useSettings();\n\n  return (\n    <Card\n      className={classes(\"absolute left-0 top-0 mx-4 my-6\", className)}\n      title=\"Extension Settings\"\n    >\n      <ul className=\"flex flex-col gap-4\">\n        {typeSafeObjectEntries(settings).map(([key, setting]) => {\n          if (!setting.configurable) return null;\n\n          return (\n            <li key={key} className=\"flex items-center\">\n              {setting.type === \"boolean\" && (\n                <Toggle\n                  label={setting.title}\n                  value={setting.value as boolean}\n                  onChange={setting.change as (value: boolean) => void}\n                />\n              )}\n            </li>\n          );\n        })}\n      </ul>\n    </Card>\n  );\n}\n\n'extension/src/pages/overlay/components/Buttons.tsx'\n:import { useMemo } from \"react\";\n\nimport Tooltip from \"../../../components/Tooltip\";\n\nimport { classes } from \"../../../utils/classes\";\n\ntype ButtonsOptions = Readonly<\n  {\n    key: string;\n    type: \"primary\" | \"secondary\";\n    icon: (props: { size: number; className?: string }) => JSX.Element;\n    title: string;\n  }[]\n>;\n\ninterface ButtonsProps<T extends ButtonsOptions> {\n  options: T;\n  onClick: (key: T[number][\"key\"] | \"\") => void;\n  active?: string;\n}\n\nexport default function Buttons<T extends ButtonsOptions = ButtonsOptions>(\n  props: ButtonsProps<T>,\n) {\n  const { options, onClick, active } = props;\n\n\n  const optionsWithOnClick = useMemo(\n    () =>\n      options\n        .map((option) => ({\n          ...option,\n          onClick: () => onClick(active === option.key ? \"\" : option.key),\n          active: active === option.key,\n        }))\n        .sort((a, b) => {\n          if (a.type === b.type) return 0;\n          return a.type === \"primary\" ? -1 : 1;\n        }),\n    [options, onClick, active],\n  );\n\n  return (\n    <div className=\"z-10 mt-12 flex flex-col gap-4\">\n      {optionsWithOnClick.map((option, idx) => (\n        <Tooltip key={option.key} text={option.title}>\n          <button\n            onClick={option.onClick}\n            className={classes(\n              \"bg-alveus-green outline-highlight flex cursor-pointer items-center justify-center rounded-lg p-2 shadow transition-[outline,filter] hover:outline hover:brightness-125 focus:outline\",\n              option.type === \"primary\" ? \"h-16 w-16\" : \"h-12 w-12\",\n              option.active && \"outline\",\n\n              idx > 0 &&\n                optionsWithOnClick[idx - 1].type !== option.type &&\n                \"mt-auto\",\n            )}\n          >\n            <option.icon\n              size={option.type === \"primary\" ? 48 : 32}\n              className=\"h-full w-full\"\n            />\n          </button>\n        </Tooltip>\n      ))}\n    </div>\n  );\n}\n\n'extension/src/pages/overlay/hooks/useSettings.tsx'\n:import {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n  type ReactNode,\n} from \"react\";\n\nimport {\n  typeSafeObjectEntries,\n  typeSafeObjectFromEntries,\n} from \"../../../utils/helpers\";\nimport { OverlayKey, isValidOverlayKey } from \"../components/overlay/Overlay\";\n\nconst settings = {\n  disableChatPopup: {\n    title: \"Prevent Mod-triggered Card Popups\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: true,\n  },\n  disableOverlayHiding: {\n    title: \"(DEV) Prevent app hiding automatically\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: process.env.NODE_ENV === \"development\",\n  },\n  openedMenu: {\n    title: \"Menu that was last opened\",\n    type: \"string\",\n    process: (value: any): OverlayKey => {\n      return isValidOverlayKey(value) ? value : \"ambassadors\";\n    },\n    configurable: false,\n  },\n};\n\ntype SettingsKey = keyof typeof settings;\n\ntype StoredSettings = {\n  [key in SettingsKey]: ReturnType<(typeof settings)[key][\"process\"]>;\n};\n\nexport type Settings = {\n  [key in SettingsKey]: (typeof settings)[key] & {\n    value: StoredSettings[key];\n    change: (value: StoredSettings[key]) => void;\n  };\n};\n\nconst context = createContext<Settings | undefined>(undefined);\n\nexport const SettingsProvider = ({ children }: { children: ReactNode }) => {\n  const [stored, setStored] = useState<StoredSettings>(() => {\n\n    const storage = JSON.parse(localStorage.getItem(\"settings\") || \"{}\");\n    return typeSafeObjectEntries(settings).reduce(\n      (acc, [key, value]) => ({ ...acc, [key]: value.process(storage[key]) }),\n      {} as StoredSettings,\n    );\n  });\n\n\n  useEffect(() => {\n    localStorage.setItem(\"settings\", JSON.stringify(stored));\n  }, [stored]);\n\n\n  const change = useCallback(\n    <Key extends SettingsKey>(key: Key, value: StoredSettings[Key]) => {\n      setStored((current) => ({ ...current, [key]: value }));\n    },\n    [],\n  );\n\n\n  const obj = useMemo<Settings>(\n    () =>\n      typeSafeObjectFromEntries(\n        typeSafeObjectEntries(settings).map(([key, value]) => [\n          key,\n          {\n            ...value,\n            value: stored[key],\n            change: (value: any) => change(key, value),\n          },\n        ]),\n      ) as Settings,\n    [stored, change],\n  );\n\n  return <context.Provider value={obj}>{children}</context.Provider>;\n};\n\nconst useSettings = () => {\n  const ctx = useContext(context);\n  if (!ctx)\n    throw new Error(\"useSettings must be used within a SettingsProvider\");\n  return ctx;\n};\n\nexport default useSettings;\n",
        "gt": [
            "'extension/src/pages/overlay/components/Buttons.tsx'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/hooks/useSettings.tsx'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/order/order.module.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/order/order.controller.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/order/dto/create-order.dto.ts'"
        ],
        "content": "'is-even/apps/backend/src/order/order.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { OrderService } from './order.service';\nimport { OrderController } from './order.controller';\nimport { LoggerModule } from '../logger/logger.module';\nimport { Order } from './order.entity';\nimport { CreditModule } from '../credit/credit.module';\nimport { AppConfigModule } from '../config/config.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [OrderService],\n  controllers: [OrderController],\n  exports: [OrderService],\n  imports: [\n    LoggerModule,\n    CreditModule,\n    AppConfigModule,\n    SentryModule,\n    TypeOrmModule.forFeature([Order]),\n  ],\n})\nexport class OrderModule {}\n\n'is-even/apps/backend/src/payment/payment.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { PaymentService } from './payment.service';\nimport { PaymentController } from './payment.controller';\nimport { Payment } from './payment.entity';\n\nimport { LoggerModule } from '../logger/logger.module';\nimport { StripeModule } from '../stripe/stripe.module';\nimport { OrderModule } from '../order/order.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [PaymentService],\n  controllers: [PaymentController],\n  imports: [\n    LoggerModule,\n    StripeModule,\n    OrderModule,\n    SentryModule,\n    TypeOrmModule.forFeature([Payment]),\n  ],\n  exports: [PaymentService],\n})\nexport class PaymentModule {}\n\n'is-even/apps/backend/src/order/order.controller.ts'\n:import {\n  Controller,\n  Post,\n  HttpStatus,\n  HttpException,\n  Request,\n  Body,\n  Get,\n  Param,\n  ParseUUIDPipe,\n  Patch,\n} from '@nestjs/common';\nimport {\n  ApiTags,\n  ApiOkResponse,\n  ApiUnauthorizedResponse,\n  ApiCreatedResponse,\n  ApiNotFoundResponse,\n  ApiInternalServerErrorResponse,\n} from '@nestjs/swagger';\n\nimport { OrderService } from './order.service';\n\nimport { Authorised } from '../auth/auth.decorator';\nimport { RequestWithUser } from '../common/interface/request-with-user.interface';\n\nimport { CreateOrderDto } from './dto/create-order.dto';\nimport { OrderDto } from './dto/order.dto';\n\nimport { ReadOrderError } from './error/read-order.error';\nimport { UnathorizedOrderError } from './error/unathorized-order.error';\nimport { OrderStatus } from './interface/order-status.interface';\nimport { CreditLimit } from '../credit/interface/credit-limit.interface';\n\n@ApiTags('orders')\n@Controller('orders')\nexport class OrderController {\n  constructor(private readonly orderService: OrderService) {}\n\n  @Post('/')\n  @Authorised()\n  @ApiCreatedResponse({ type: OrderDto })\n  @ApiUnauthorizedResponse()\n  @ApiInternalServerErrorResponse()\n  public async createOrder(\n    @Request() request: RequestWithUser,\n    @Body() createOrderDto: CreateOrderDto,\n  ): Promise<OrderDto> {\n    try {\n      const user = request.user;\n      const { creditDuration, creditLimit } = createOrderDto;\n\n      const order = await this.orderService.createOrder(\n        creditLimit,\n        creditDuration,\n        user,\n      );\n\n      if (creditLimit === CreditLimit.Free) {\n        const fullfiledOrder = await this.orderService.fulfillOrder(order);\n        return OrderDto.createDtoFromEntity(fullfiledOrder);\n      }\n\n      return OrderDto.createDtoFromEntity(order);\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Get('/')\n  @Authorised()\n  @ApiOkResponse({ type: OrderDto, isArray: true })\n  @ApiUnauthorizedResponse()\n  @ApiInternalServerErrorResponse()\n  public async getOrders(\n    @Request() request: RequestWithUser,\n  ): Promise<OrderDto[]> {\n    try {\n      const user = request.user;\n\n      const orders = await this.orderService.getOrders(user);\n\n      return orders.map(OrderDto.createDtoFromEntity);\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Patch('/:id')\n  @Authorised()\n  @ApiCreatedResponse()\n  @ApiNotFoundResponse()\n  @ApiUnauthorizedResponse()\n  @ApiInternalServerErrorResponse()\n  public async cancelOrder(\n    @Request() request: RequestWithUser,\n    @Param('id', ParseUUIDPipe) orderId: string,\n  ): Promise<void> {\n    try {\n      const user = request.user;\n      const order = await this.orderService.getOrderById(orderId);\n\n      this.orderService.checkOrderOwner(order, user);\n      this.orderService.checkOrderFulfillment(order);\n\n      await this.orderService.updateOrderStatus(order, OrderStatus.Cancelled);\n    } catch (error) {\n      if (error instanceof UnathorizedOrderError) {\n        throw new HttpException('Access forbidden', HttpStatus.FORBIDDEN);\n      }\n      if (error instanceof ReadOrderError) {\n        throw new HttpException('Not found', HttpStatus.NOT_FOUND);\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/order/dto/create-order.dto.ts'\n:import { ApiProperty } from '@nestjs/swagger';\nimport { IsEnum } from 'class-validator';\n\nimport { CreditDuration } from '../../credit/interface/credit-duration.interface';\nimport { CreditLimit } from '../../credit/interface/credit-limit.interface';\n\nexport class CreateOrderDto {\n  @ApiProperty()\n  @IsEnum(CreditLimit)\n  creditLimit: CreditLimit;\n\n  @ApiProperty()\n  @IsEnum(CreditDuration)\n  creditDuration: CreditDuration;\n}\n",
        "gt": [
            "'is-even/apps/backend/src/order/dto/create-order.dto.ts'",
            "'is-even/apps/backend/src/order/order.controller.ts'",
            "'is-even/apps/backend/src/order/order.module.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'hydrated-ws/src/router/RoutedWebSocket.spec.ts'",
            "'hydrated-ws/src/Shell.ts'",
            "'hydrated-ws/src/router/RoutedWebSocket.ts'"
        ],
        "content": "'hydrated-ws/src/router/RoutedWebSocket.spec.ts'\n:\n\nimport WebSocket from \"../polyfill/WebSocket\";\n\nimport { expect } from \"chai\";\nimport { IRouterConnector } from \"./IRouterConnector\";\nimport { RoutedWebSocket } from \"./RoutedWebSocket\";\nimport { Router } from \"./Router\";\n\ndescribe(\"RoutedWebSocket\", () => {\n        it(\"should be connecting\",  () => {\n            const ws = new RoutedWebSocket(null, null);\n            expect (ws.readyState).to.equal(WebSocket.CONNECTING);\n        });\n        it(\"should send a message\",  (done) => {\n            const ws = new RoutedWebSocket((data: any) => {\n                expect(data).to.equal(\"test\");\n                done();\n            }, null);\n            ws.send(\"test\");\n        });\n        it(\"should close\",  (done) => {\n            const ws = new RoutedWebSocket(null, (code: any, reason: any) => {\n                expect(code).to.equal(1000);\n                expect(reason).to.equal(void 0);\n                done();\n            });\n            ws.close();\n        });\n        it(\"should close ans send code + reason\",  (done) => {\n            const ws = new RoutedWebSocket(null, (code: any, reason: any) => {\n                expect(code).to.equal(2000);\n                expect(reason).to.equal(\"test\");\n                done();\n            });\n            ws.close(2000, \"test\");\n        });\n\n        it(\"should return empty properties\",  () => {\n            const ws = new RoutedWebSocket(null, null);\n            expect(ws.url).to.equal(\"\");\n            expect(ws.bufferedAmount).to.equal(0);\n            expect(ws.extensions).to.equal(\"\");\n            expect(ws.protocol).to.equal(\"\");\n        });\n\n});\n\n'hydrated-ws/src/Shell.ts'\n:import {computedFrom} from \"./computedFrom\";\nimport IHydratedWebSocketEventMap from \"./IHydratedWebSocketEventMap\";\nimport { Dict } from \"./polyfill/Dict\";\nimport WebSocket from \"./polyfill/WebSocket\";\n\nexport abstract class Shell implements WebSocket {\n\n\n    @computedFrom(\"_onclose\")\n    public get onclose(): (ev: CloseEvent) => any {\n        return this._onclose;\n    }\n\n    public set onclose(f: (ev: CloseEvent) => any) {\n        this._onclose = f;\n    }\n\n\n    @computedFrom(\"_onerror\")\n    public get onerror(): (ev: Event) => any {\n        return this._onerror;\n    }\n\n    public set onerror(f: (ev: Event) => any) {\n        this._onerror = f;\n    }\n\n\n    @computedFrom(\"_onmessage\")\n    public get onmessage(): (ev: MessageEvent) => any {\n        return this.getOnmessage();\n    }\n\n    public set onmessage(f: (ev: MessageEvent) => any) {\n        this.setOnmessage(f);\n    }\n\n\n    @computedFrom(\"_onopen\")\n    public get onopen(): (ev: Event) => any {\n        return this._onopen;\n    }\n\n    public set onopen(f: (ev: Event) => any) {\n        this._onopen = f;\n    }\n\n\n    @computedFrom(\"ws.readyState\")\n    public get readyState(): number {\n        return this.getReadyState();\n    }\n\n\n    @computedFrom(\"ws.url\")\n    public get url(): string {\n        return this.ws.url;\n    }\n\n\n    @computedFrom(\"ws.bufferedAmount\")\n    public get bufferedAmount(): number {\n        return this.ws.bufferedAmount;\n    }\n\n\n    @computedFrom(\"ws.extensions\")\n    public get extensions(): string {\n        return this.ws.extensions;\n    }\n\n    @computedFrom(\"ws.protocol\")\n    public get protocol(): string {\n        return this.ws.protocol;\n    }\n\n\n    public readonly CONNECTING = WebSocket.CONNECTING;\n\n    public readonly OPEN = WebSocket.OPEN;\n\n    public readonly CLOSING = WebSocket.CLOSING;\n\n    public readonly CLOSED = WebSocket.CLOSED;\n\n\n    public binaryType: \"blob\" | \"arraybuffer\";\n\n    protected closing: boolean = false;\n    protected ws: WebSocket;\n    protected _readyState: number = WebSocket.CONNECTING;\n    protected listeners: Dict<keyof IHydratedWebSocketEventMap,\n        Array<{\n            listener: (this: WebSocket,\n                       ev: IHydratedWebSocketEventMap[keyof IHydratedWebSocketEventMap]) => any,\n            useCapture?: boolean,\n        }>> = new Dict();\n\n    private readonly forwardListener: (evt: Event) => boolean;\n    private _onerror: (ev: Event) => any;\n    private _onmessage: (ev: MessageEvent) => any;\n    private _onopen: (ev: Event) => any;\n    private _onclose: (ev: CloseEvent) => any;\n\n    constructor(ws?: WebSocket) {\n        if (!this.dispatchEvent) {\n            throw new TypeError(\"Failed to construct. Please use the 'new' operator\");\n        }\n        this.forwardListener = this.dispatchEvent.bind(this);\n        if (ws) {\n            this.ws = ws;\n            this.forwardEvents();\n        }\n    }\n\n\n    public close(code: number = 1000, reason?: string) {\n        this.ws.close(code, reason);\n    }\n\n\n    public send(data: string | ArrayBuffer | Blob | ArrayBufferView): void {\n        if (this.ws.readyState !== WebSocket.OPEN) {\n            const err = new Error(\n                `WebSocket is not open ws is ${this.ws.readyState}, local is ${this.readyState}`,\n            );\n            throw err;\n        }\n        this.ws.send(data);\n    }\n\n\n    public addEventListener<K extends keyof IHydratedWebSocketEventMap>(type: K,\n                                                                        listener: (this: WebSocket,\n                                                                                   ev: IHydratedWebSocketEventMap[K])\n                                                                                  => any,\n                                                                        useCapture?: boolean): void {\n        let listeners = this.listeners.get(type);\n        if (!listeners) {\n            listeners = [];\n            this.listeners.set(type, listeners);\n        }\n        listeners.push({ listener, useCapture });\n    }\n\n\n    public removeEventListener<K extends keyof IHydratedWebSocketEventMap>(type: K,\n                                                                           listener: (this: WebSocket,\n                                                                                      ev: IHydratedWebSocketEventMap[K])\n                                                                                     => any,\n                                                                           useCapture?: boolean): void {\n        const listeners = this.listeners.get(type);\n        if (listeners) {\n            this.listeners.set(\n                type,\n                listeners.filter((l) => l.listener !== listener || l.useCapture !== useCapture),\n            );\n        }\n    }\n\n\n    public dispatchEvent(evt: Event): boolean {\n        const method = this[`_on${evt.type}`];\n        if (typeof method === \"function\") {\n            method.call(this, evt);\n        }\n        return (this.listeners.get(evt.type as keyof IHydratedWebSocketEventMap) || [])\n            .some(({ listener }) => listener.call(this, evt) === false) === void 0;\n    }\n\n    protected getOnmessage(): (ev: MessageEvent) => any {\n        return this._onmessage;\n    }\n\n    protected setOnmessage(f: (ev: MessageEvent) => any) {\n        this._onmessage = f;\n    }\n\n    protected forwardEvents<K extends keyof IHydratedWebSocketEventMap>(list?: K[]) {\n        (list || [\"close\", \"message\", \"open\"] as K[]).forEach((event: K): void =>\n            this.ws.addEventListener(event, this.forwardListener),\n        );\n    }\n\n    protected stopForwardingEvents() {\n        this.ws.removeEventListener(\"close\", this.forwardListener);\n        this.ws.removeEventListener(\"message\", this.forwardListener);\n        this.ws.removeEventListener(\"open\", this.forwardListener);\n    }\n\n    protected getReadyState(): number {\n        return this.ws.readyState;\n    }\n\n}\n\n'hydrated-ws/src/router/RoutedWebSocket.ts'\n:import {computedFrom} from \"../computedFrom\";\nimport IHydratedWebSocketEventMap from \"../IHydratedWebSocketEventMap\";\nimport CloseEvent from \"../polyfill/CloseEvent\";\nimport Event from \"../polyfill/Event\";\nimport WebSocket from \"../polyfill/WebSocket\";\nimport {Shell} from \"../Shell\";\n\nexport class RoutedWebSocket extends Shell {\n\n    public set onmessage(f: (ev: MessageEvent) => any) {\n        super.setOnmessage(f);\n        this.checkSubscriptions();\n    }\n\n    public get onmessage(): (ev: MessageEvent) => any {\n        return super.getOnmessage();\n    }\n\n    public get url(): string {\n        return \"\";\n    }\n\n    public get bufferedAmount(): number {\n        return 0;\n    }\n\n    public get extensions(): string {\n        return \"\";\n    }\n\n    public get protocol(): string {\n        return \"\";\n    }\n\n\n    public readonly CONNECTING = WebSocket.CONNECTING;\n\n    public readonly OPEN = WebSocket.OPEN;\n\n    public readonly CLOSING = WebSocket.CLOSING;\n\n    public readonly CLOSED = WebSocket.CLOSED;\n\n    private virtualReadyState: number = null;\n    private subscribed: boolean = false;\n\n    constructor(\n        private readonly routerSend: (data: string | ArrayBuffer | Blob | ArrayBufferView) => void,\n        private readonly routerClose: (code: number, reason: string) => void,\n        private readonly onMessageSubscribe?: (ws: RoutedWebSocket) => void,\n        private readonly onMessageUnsubscribe?: (ws: RoutedWebSocket) => void,\n    ) {\n        super();\n    }\n\n    public setReadyState(state: number) {\n        if (this.virtualReadyState === state) {\n            return;\n        }\n        this.virtualReadyState = state;\n        switch (state) {\n            case this.OPEN:\n                this.dispatchEvent(new Event(\"open\"));\n                break;\n            case this.CLOSED:\n                this.dispatchEvent(new CloseEvent(\"close\"));\n                break;\n            default:\n                break;\n        }\n    }\n\n    public addEventListener<K extends keyof IHydratedWebSocketEventMap>(type: K,\n                                                                        listener: (this: WebSocket,\n                                                                                   ev: IHydratedWebSocketEventMap[K])\n                                                                            => any,\n                                                                        useCapture?: boolean): void {\n        super.addEventListener(type, listener, useCapture);\n        this.checkSubscriptions();\n    }\n\n    public removeEventListener<K extends keyof IHydratedWebSocketEventMap>(type: K,\n                                                                           listener: (this: WebSocket,\n                                                                                      ev: IHydratedWebSocketEventMap[K])\n                                                                               => any,\n                                                                           useCapture?: boolean): void {\n        super.removeEventListener(type, listener, useCapture);\n        this.checkSubscriptions();\n    }\n\n    public emitMessage(event: MessageEvent) {\n        this.dispatchEvent(event);\n    }\n\n    public send(data: string | ArrayBuffer | Blob | ArrayBufferView): void {\n        this.routerSend(data);\n    }\n\n    public close(code: number = 1000, reason?: string) {\n        this.virtualReadyState = this.CLOSED;\n        this.routerClose(code, reason);\n    }\n\n    protected getReadyState(): number {\n        return this.virtualReadyState === null ? WebSocket.CONNECTING : this.virtualReadyState;\n    }\n\n    private checkSubscriptions() {\n        if (this.onmessage || (this.listeners.has(\"message\") && this.listeners.get(\"message\").length)) {\n            if (!this.subscribed) {\n                this.subscribed = true;\n                if (this.onMessageSubscribe) {\n                    this.onMessageSubscribe(this);\n                }\n            }\n\n        } else {\n            if (this.subscribed) {\n                this.subscribed = false;\n                if (this.onMessageUnsubscribe) {\n                    this.onMessageUnsubscribe(this);\n                }\n            }\n        }\n    }\n}\n",
        "gt": [
            "'hydrated-ws/src/Shell.ts'",
            "'hydrated-ws/src/router/RoutedWebSocket.ts'",
            "'hydrated-ws/src/router/RoutedWebSocket.spec.ts'"
        ]
    },
    {
        "files": [
            "'vscode.clipboard-manager/src/completion.ts'",
            "'vscode.clipboard-manager/src/extension.ts'",
            "'vscode.clipboard-manager/src/manager.ts'"
        ],
        "content": "'vscode.clipboard-manager/src/completion.ts'\n:import * as vscode from \"vscode\";\nimport { commandList } from \"./commads/common\";\nimport { ClipboardManager } from \"./manager\";\nimport { leftPad } from \"./util\";\n\nexport class ClipboardCompletion implements vscode.CompletionItemProvider {\n  constructor(protected manager: ClipboardManager) {}\n\n  public provideCompletionItems(\n    document: vscode.TextDocument,\n    _position: vscode.Position,\n    _token: vscode.CancellationToken,\n    _context: vscode.CompletionContext\n  ): vscode.ProviderResult<vscode.CompletionItem[] | vscode.CompletionList> {\n    const config = vscode.workspace.getConfiguration(\n      \"clipboard-manager\",\n      document.uri\n    );\n\n    const enabled = config.get<boolean>(\"snippet.enabled\", true);\n\n    if (!enabled) {\n      return null;\n    }\n\n    const prefix = config.get<string>(\"snippet.prefix\", \"clip\");\n    const maxSnippets = config.get<number>(\"snippet.max\", 10);\n\n    const clips =\n      maxSnippets > 0\n        ? this.manager.clips.slice(0, maxSnippets)\n        : this.manager.clips;\n\n    const maxLength = `${clips.length}`.length;\n\n    const completions: vscode.CompletionItem[] = clips.map((clip, index) => {\n\n      const indexNumber = leftPad(index + 1, maxLength, \"0\");\n\n      const c: vscode.CompletionItem = {\n        label: `${prefix}${indexNumber}`,\n        detail: `Clipboard ${indexNumber}`,\n        insertText: clip.value,\n        kind: vscode.CompletionItemKind.Text,\n        filterText: `${prefix}${indexNumber} ${clip.value}`,\n      };\n\n\n      c.documentation = new vscode.MarkdownString();\n      c.documentation.appendCodeblock(clip.value, clip.language);\n\n      if (clip.createdAt) {\n        const date = new Date(clip.createdAt);\n        c.detail += \" - \" + date.toLocaleString();\n      }\n\n      c.command = {\n        command: commandList.setClipboardValue,\n        title: \"Paste\",\n        tooltip: \"Paste\",\n        arguments: [clip.value],\n      };\n\n      return c;\n    });\n\n    return completions;\n  }\n}\n\n'vscode.clipboard-manager/src/extension.ts'\n:\"use strict\";\nimport * as vscode from \"vscode\";\nimport { defaultClipboard } from \"./clipboard\";\nimport { ApiGetMonitor } from \"./commads/apiGetMonitor\";\nimport { ClearClipboardHistory } from \"./commads/clearClipboardHistory\";\nimport { HistoryTreeDoubleClickCommand } from \"./commads/historyTreeDoubleClick\";\nimport { PickAndPasteCommand } from \"./commads/pickAndPaste\";\nimport { RemoveClipboardHistory } from \"./commads/removeClipboardHistory\";\nimport { SetClipboardValueCommand } from \"./commads/setClipboardValue\";\nimport { ShowClipboardInFile } from \"./commads/showClipboardInFile\";\nimport { ClipboardCompletion } from \"./completion\";\nimport { ClipboardManager } from \"./manager\";\nimport { Monitor } from \"./monitor\";\nimport { ClipboardTreeDataProvider } from \"./tree/history\";\nimport { CopyToHistoryCommand } from \"./commads/copyToHistory\";\n\nlet manager: ClipboardManager;\n\n\nexport async function activate(context: vscode.ExtensionContext) {\n  const disposable: vscode.Disposable[] = [];\n\n\n  try {\n    await defaultClipboard.readText();\n  } catch (error: any) {\n    console.log(error);\n\n    setTimeout(() => {\n      if (error.message) {\n        vscode.window.showErrorMessage(error.message);\n      } else {\n        vscode.window.showErrorMessage(\n          \"Failed to read value from clipboard, check the console log\"\n        );\n      }\n    }, 2000);\n\n    defaultClipboard.dispose();\n    return;\n  }\n\n\n  disposable.push(defaultClipboard);\n\n  const monitor = new Monitor(defaultClipboard);\n  disposable.push(monitor);\n\n  manager = new ClipboardManager(context, monitor);\n  disposable.push(manager);\n\n\n  disposable.push(new ApiGetMonitor(monitor));\n\n\n  disposable.push(new PickAndPasteCommand(manager));\n  disposable.push(new HistoryTreeDoubleClickCommand(manager));\n  disposable.push(new SetClipboardValueCommand(manager));\n  disposable.push(new RemoveClipboardHistory(manager));\n  disposable.push(new ShowClipboardInFile(manager));\n  disposable.push(new ClearClipboardHistory(manager));\n  disposable.push(new CopyToHistoryCommand(monitor));\n\n  const completion = new ClipboardCompletion(manager);\n\n\n\n  disposable.push(\n    vscode.languages.registerCompletionItemProvider(\n      {\n        scheme: \"file\",\n      },\n      completion\n    )\n  );\n\n\n  disposable.push(\n    vscode.languages.registerCompletionItemProvider(\n      {\n        scheme: \"untitled\",\n      },\n      completion\n    )\n  );\n\n  const clipboardTreeDataProvider = new ClipboardTreeDataProvider(manager);\n  disposable.push(clipboardTreeDataProvider);\n\n  disposable.push(\n    vscode.window.registerTreeDataProvider(\n      \"clipboardHistory\",\n      clipboardTreeDataProvider\n    )\n  );\n\n  const updateConfig = () => {\n    const config = vscode.workspace.getConfiguration(\"clipboard-manager\");\n    monitor.checkInterval = config.get(\"checkInterval\", 500);\n    monitor.onlyWindowFocused = config.get(\"onlyWindowFocused\", true);\n    monitor.maxClipboardSize = config.get(\"maxClipboardSize\", 1000000);\n  };\n  updateConfig();\n\n  disposable.push(\n    vscode.workspace.onDidChangeConfiguration(\n      e => e.affectsConfiguration(\"clipboard-manager\") && updateConfig()\n    )\n  );\n\n  context.subscriptions.push(...disposable);\n\n  return {\n    completion,\n    manager,\n  };\n}\n\n\nexport function deactivate() {\n  if (manager) {\n    manager.saveClips();\n  }\n}\n\n'vscode.clipboard-manager/src/manager.ts'\n:import * as fs from \"fs\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport * as vscode from \"vscode\";\nimport { IClipboardTextChange, Monitor } from \"./monitor\";\n\nexport interface IClipboardItem {\n  value: string;\n  createdAt: number;\n  lastUse?: number;\n  copyCount: number;\n  useCount: number;\n  language?: string;\n  createdLocation?: vscode.Location;\n}\n\nexport class ClipboardManager implements vscode.Disposable {\n  protected _disposable: vscode.Disposable[] = [];\n\n  protected _clips: IClipboardItem[] = [];\n  get clips() {\n    return this._clips;\n  }\n\n  protected lastUpdate: number = 0;\n\n\n\n\n\n  private _onDidClipListChange = new vscode.EventEmitter<void>();\n  public readonly onDidChangeClipList = this._onDidClipListChange.event;\n\n  constructor(\n    protected context: vscode.ExtensionContext,\n    protected _monitor: Monitor\n  ) {\n    this._monitor.onDidChangeText(this.updateClipList, this, this._disposable);\n\n    this.loadClips();\n\n    vscode.window.onDidChangeWindowState(\n      state => {\n        if (state.focused) {\n          this.checkClipsUpdate();\n        }\n      },\n      this,\n      this._disposable\n    );\n\n    vscode.workspace.onDidChangeConfiguration(\n      e => e.affectsConfiguration(\"clipboard-manager\") && this.saveClips()\n    );\n  }\n\n  protected updateClipList(change: IClipboardTextChange) {\n    this.checkClipsUpdate();\n\n    const config = vscode.workspace.getConfiguration(\"clipboard-manager\");\n    const maxClips = config.get(\"maxClips\", 100);\n    const avoidDuplicates = config.get(\"avoidDuplicates\", true);\n\n    let item: IClipboardItem = {\n      value: change.value,\n      createdAt: change.timestamp,\n      copyCount: 1,\n      useCount: 0,\n      language: change.language,\n      createdLocation: change.location,\n    };\n\n    if (avoidDuplicates) {\n      const index = this._clips.findIndex(c => c.value === change.value);\n\n\n      if (index >= 0) {\n        this._clips[index].copyCount++;\n        item = this._clips[index];\n        this._clips = this._clips.filter(c => c.value !== change.value);\n      }\n    }\n\n\n    this._clips.unshift(item);\n\n\n    if (maxClips > 0) {\n      this._clips = this._clips.slice(0, maxClips);\n    }\n\n    this._onDidClipListChange.fire();\n\n    this.saveClips();\n  }\n\n  public async setClipboardValue(value: string) {\n    this.checkClipsUpdate();\n\n    const config = vscode.workspace.getConfiguration(\"clipboard-manager\");\n    const moveToTop = config.get(\"moveToTop\", true);\n\n    const index = this._clips.findIndex(c => c.value === value);\n\n    if (index >= 0) {\n      this._clips[index].useCount++;\n\n      if (moveToTop) {\n        const clips = this.clips.splice(index, 1);\n        this._clips.unshift(...clips);\n        this._onDidClipListChange.fire();\n        this.saveClips();\n      }\n    }\n\n    return await this._monitor.clipboard.writeText(value);\n  }\n\n  public removeClipboardValue(value: string) {\n    this.checkClipsUpdate();\n\n    const prevLength = this._clips.length;\n\n    this._clips = this._clips.filter(c => c.value !== value);\n    this._onDidClipListChange.fire();\n    this.saveClips();\n\n    return prevLength !== this._clips.length;\n  }\n\n  public clearAll() {\n    this.checkClipsUpdate();\n\n    this._clips = [];\n    this._onDidClipListChange.fire();\n    this.saveClips();\n\n    return true;\n  }\n\n\n  protected getStoreFile() {\n    let folder = os.tmpdir();\n\n    if (this.context.storagePath) {\n      const parts = this.context.storagePath.split(\n        /[\\\\/]workspaceStorage[\\\\/]/\n      );\n      folder = parts[0];\n    }\n\n    const filePath = path.join(folder, \"clipboard.history.json\");\n\n    const config = vscode.workspace.getConfiguration(\"clipboard-manager\");\n    const saveTo = config.get<string | null | boolean>(\"saveTo\");\n\n    if (typeof saveTo === \"string\") {\n      return saveTo;\n    }\n\n    if (saveTo === false) {\n      return false;\n    }\n\n    return filePath;\n  }\n\n  protected jsonReplacer(key: string, value: any) {\n    if (key === \"createdLocation\" && value) {\n      value = {\n        range: {\n          start: value.range.start,\n          end: value.range.end,\n        },\n        uri: value.uri.toString(),\n      };\n    } else if (value instanceof vscode.Uri) {\n      value = value.toString();\n    }\n\n    return value;\n  }\n\n  public saveClips() {\n    const file = this.getStoreFile();\n    if (!file) {\n      return;\n    }\n\n    let json = \"[]\";\n    try {\n      json = JSON.stringify(\n        {\n          version: 2,\n          clips: this._clips,\n        },\n        this.jsonReplacer,\n        2\n      );\n    } catch (error) {\n      console.error(error);\n      return;\n    }\n\n    try {\n      fs.writeFileSync(file, json);\n      this.lastUpdate = fs.statSync(file).mtimeMs;\n    } catch (error: any) {\n      switch (error.code) {\n        case \"EPERM\":\n          vscode.window.showErrorMessage(\n            `Not permitted to save clipboards on \"${file}\"`\n          );\n          break;\n        case \"EISDIR\":\n          vscode.window.showErrorMessage(\n            `Failed to save clipboards on \"${file}\", because the path is a directory`\n          );\n          break;\n        default:\n          console.error(error);\n      }\n    }\n  }\n\n\n  public checkClipsUpdate() {\n    const file = this.getStoreFile();\n\n    if (!file) {\n      return;\n    }\n\n    if (!fs.existsSync(file)) {\n      return;\n    }\n\n    const stat = fs.statSync(file);\n\n    if (this.lastUpdate < stat.mtimeMs) {\n      this.lastUpdate = stat.mtimeMs;\n      this.loadClips();\n    }\n  }\n\n  public loadClips() {\n    let json;\n\n    const file = this.getStoreFile();\n\n    if (file && fs.existsSync(file)) {\n      try {\n        json = fs.readFileSync(file);\n        this.lastUpdate = fs.statSync(file).mtimeMs;\n      } catch (error) {\n\n      }\n    } else {\n\n      json = this.context.globalState.get<any>(\"clips\");\n    }\n\n    if (!json) {\n      return;\n    }\n\n    let stored: any = {};\n\n    try {\n      stored = JSON.parse(json);\n    } catch (error) {\n      console.log(error);\n      return;\n    }\n\n    if (!stored.version || !stored.clips) {\n      return;\n    }\n\n    let clips = stored.clips as any[];\n\n    if (stored.version === 1) {\n      clips = clips.map(c => {\n        c.createdAt = c.timestamp;\n        c.copyCount = 1;\n        c.useCount = 0;\n        c.createdLocation = c.location;\n        return c;\n      });\n      stored.version = 2;\n    }\n\n    this._clips = clips.map(c => {\n      const clip: IClipboardItem = {\n        value: c.value,\n        createdAt: c.createdAt,\n        copyCount: c.copyCount,\n        useCount: c.copyCount,\n        language: c.language,\n      };\n\n      if (c.createdLocation) {\n        const uri = vscode.Uri.parse(c.createdLocation.uri);\n        const range = new vscode.Range(\n          c.createdLocation.range.start.line,\n          c.createdLocation.range.start.character,\n          c.createdLocation.range.end.line,\n          c.createdLocation.range.end.character\n        );\n        clip.createdLocation = new vscode.Location(uri, range);\n      }\n\n      return clip;\n    });\n\n    this._onDidClipListChange.fire();\n  }\n\n  public dispose() {\n    this._disposable.forEach(d => d.dispose());\n  }\n}\n",
        "gt": [
            "'vscode.clipboard-manager/src/manager.ts'",
            "'vscode.clipboard-manager/src/completion.ts'",
            "'vscode.clipboard-manager/src/extension.ts'"
        ]
    },
    {
        "files": [
            "'lemmy-fennec/Screens/User/User.tsx'",
            "'lemmy-fennec/App.tsx'",
            "'lemmy-fennec/Screens/User/UserScreen.tsx'"
        ],
        "content": "'lemmy-fennec/Screens/User/User.tsx'\n:import React from \"react\";\nimport { Image, StyleSheet, View } from \"react-native\";\n\nimport { useNavigation } from \"@react-navigation/native\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { makeDateString } from \"../../utils/utils\";\nimport Bio from \"../Profile/Bio\";\nimport Counters from \"../Profile/Counters\";\nimport UserRow from \"../Profile/UserRow\";\n\nfunction User() {\n  const navigation = useNavigation();\n  const loadedProfile = apiClient.profileStore.userProfile;\n  const profile = loadedProfile?.person_view;\n  const isBlocked =\n    apiClient.profileStore.blockedPeople.findIndex(\n      (p) => p.target.id === profile.person.id\n    ) !== -1;\n\n  const onMessagePress = () => {\n\n    navigation.navigate(\"MessageWrite\", {\n      isFromLocalUser: true,\n      toLocalUser: false,\n      item: {\n        private_message: {\n          content: \"New message...\",\n        },\n        recipient: {\n          name: profile?.person?.name,\n        },\n      },\n      messageDate: makeDateString(new Date().getTime()),\n      recipient: profile?.person?.id,\n      messageId: null,\n      newMessage: true,\n    });\n  };\n\n  const onBlock = () => {\n    void apiClient.profileStore.blockPerson(profile.person.id, !isBlocked);\n  };\n\n  const hasBanner = Boolean(profile?.person?.banner);\n\n  return (\n    <View style={styles.container}>\n      {hasBanner ? (\n        <Image\n          resizeMode={\"cover\"}\n          source={{ uri: profile.person.banner }}\n          style={{\n            width: \"100%\",\n            height: 120,\n          }}\n        />\n      ) : null}\n      <UserRow hasBanner={hasBanner} person={profile.person} />\n      <Bio profile={profile} />\n      <Counters profile={profile} />\n      {apiClient.loginDetails.jwt ? (\n        <>\n          <TouchableOpacity onPressCb={onMessagePress}>\n            <Text>Message User</Text>\n          </TouchableOpacity>\n          <TouchableOpacity\n            feedback\n            style={{ backgroundColor: \"red\" }}\n            onPressCb={onBlock}\n          >\n            <Text>{isBlocked ? \"Unblock User\" : \"Block User\"}</Text>\n          </TouchableOpacity>\n        </>\n      ) : null}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: 12,\n    gap: 12,\n  },\n  row: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 8,\n  },\n});\n\nexport default observer(User);\n\n'lemmy-fennec/App.tsx'\n:import React from \"react\";\nimport { StatusBar, useColorScheme } from \"react-native\";\n\nimport { ActionSheetProvider } from \"@expo/react-native-action-sheet\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\n\nimport AddAccount from \"./Screens/AddAccount\";\nimport BlocksScreen from \"./Screens/Blocks/BlocksScreen\";\nimport CommentWrite from \"./Screens/CommentWrite/CommentWrite\";\nimport CommunityScreen from \"./Screens/Community/CommunityScreen\";\nimport DebugScreen from \"./Screens/DebugScreen\";\nimport HomeScreen from \"./Screens/HomeScreen\";\nimport LoginScreen from \"./Screens/LoginScreen\";\nimport PostScreen from \"./Screens/Post/PostScreen\";\nimport PostWrite from \"./Screens/PostWrite\";\nimport Behavior from \"./Screens/Settings/Behavior\";\nimport Looks from \"./Screens/Settings/Looks\";\nimport ProfileSettings from \"./Screens/Settings/ProfileSettings\";\nimport SettingsScreen from \"./Screens/SettingsScreen\";\nimport MessageWrite from \"./Screens/Unreads/MessageWrite\";\nimport UserScreen from \"./Screens/User/UserScreen\";\nimport { Icon } from \"./ThemedComponents\";\nimport { AppAmoledTheme, AppDarkTheme, AppTheme } from \"./commonStyles\";\nimport Prompt from \"./components/Prompt\";\nimport { ReportMode, apiClient } from \"./store/apiClient\";\nimport { Theme, preferences } from \"./store/preferences\";\n\nconst Stack = createNativeStackNavigator();\n\nconst App = observer(() => {\n  const scheme = useColorScheme();\n\n  const systemTheme = scheme === \"dark\" ? AppDarkTheme : AppTheme;\n  const isLightStatusBar =\n    preferences.theme === Theme.System\n      ? scheme !== \"dark\"\n      : preferences.theme === Theme.Light;\n\n  const schemeMap = {\n    [Theme.System]: systemTheme,\n    [Theme.Light]: AppTheme,\n    [Theme.Dark]: AppDarkTheme,\n    [Theme.Amoled]: AppAmoledTheme,\n  };\n\n  const sendReport = (text: string) => {\n    if (apiClient.reportMode === ReportMode.Post) {\n      apiClient.api\n        .createPostReport({\n          post_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    } else {\n      apiClient.api\n        .createCommentReport({\n          comment_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    }\n  };\n\n  const closeReport = () => {\n    apiClient.setShowPrompt(false);\n  };\n\n  const reportMode = apiClient.reportMode;\n  const promptActions =\n    reportMode !== ReportMode.Off\n      ? {\n          onCancel: closeReport,\n          onConfirm: sendReport,\n        }\n      : apiClient.promptActions;\n  return (\n    <SafeAreaProvider style={{ flex: 1 }}>\n      {}\n      <StatusBar\n        barStyle={isLightStatusBar ? \"dark-content\" : \"light-content\"}\n        backgroundColor={schemeMap[preferences.theme].colors.card}\n      />\n      <ActionSheetProvider>\n        <NavigationContainer theme={schemeMap[preferences.theme]}>\n          <Stack.Navigator initialRouteName={\"Home\"}>\n            <Stack.Screen\n              name=\"Home\"\n              component={HomeScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              name=\"Post\"\n              component={PostScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Comment\" }}\n              name={\"CommentWrite\"}\n              component={CommentWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Post\" }}\n              name={\"PostWrite\"}\n              component={PostWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"Message\" }}\n              name={\"MessageWrite\"}\n              component={MessageWrite}\n            />\n            <Stack.Screen\n              options={{\n                headerRight: () => <Icon name={\"arrow-up\"} size={24} />,\n              }}\n              name=\"Community\"\n              component={CommunityScreen}\n            />\n            <Stack.Screen name=\"Login\" component={LoginScreen} />\n            <Stack.Screen\n              options={{ headerTitle: \"Add Account\" }}\n              name={\"AddAccount\"}\n              component={AddAccount}\n            />\n            <Stack.Screen name=\"User\" component={UserScreen} />\n            <Stack.Screen name=\"Settings\" component={SettingsScreen} />\n            <Stack.Screen name=\"Debug\" component={DebugScreen} />\n            <Stack.Screen name=\"Blocks\" component={BlocksScreen} />\n            <Stack.Screen name=\"Looks\" component={Looks} />\n            <Stack.Screen name=\"Behavior\" component={Behavior} />\n            <Stack.Screen name=\"ProfileSettings\" component={ProfileSettings} />\n          </Stack.Navigator>\n          {apiClient.showPrompt ? (\n            <Prompt\n              text={`Describe whats wrong with this ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              title={`Report ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              reportMode={reportMode}\n              placeholder={\"Type a reason here\"}\n              onSubmit={promptActions.onConfirm}\n              onCancel={promptActions.onCancel}\n            />\n          ) : null}\n        </NavigationContainer>\n      </ActionSheetProvider>\n    </SafeAreaProvider>\n  );\n});\n\nexport default App;\n\n'lemmy-fennec/Screens/User/UserScreen.tsx'\n:import React from \"react\";\nimport { ActivityIndicator, View } from \"react-native\";\n\nimport { createMaterialTopTabNavigator } from \"@react-navigation/material-top-tabs\";\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { apiClient } from \"../../store/apiClient\";\nimport OwnComments from \"../Profile/OwnComments\";\nimport OwnPosts from \"../Profile/OwnPosts\";\nimport User from \"./User\";\n\nconst Tab = createMaterialTopTabNavigator();\n\nfunction UserScreen({\n  route,\n  navigation,\n}: NativeStackScreenProps<any, \"User\">) {\n  const loadedProfile = apiClient.profileStore.userProfile;\n  const person = loadedProfile?.person_view?.person;\n\n  React.useEffect(() => {\n    const title =\n      apiClient.profileStore.isLoading || !person\n        ? \"Loading User...\"\n        : `@${person.name}`;\n    navigation.setOptions({\n      title: title,\n    });\n  }, [person, navigation, apiClient.profileStore.isLoading]);\n\n  React.useEffect(() => {\n    const paramsPresent = route.params?.personId || route.params?.username;\n    if (paramsPresent) {\n      void apiClient.profileStore.getProfile({\n        person_id: route.params.personId,\n        username: route.params.username,\n      });\n    }\n  }, [route.params?.personId, route.params?.username]);\n\n  if (!person || apiClient.profileStore.isLoading) {\n    return (\n      <View style={{ padding: 24 }}>\n        <ActivityIndicator />\n      </View>\n    );\n  }\n  return (\n    <Tab.Navigator initialRouteName={\"ForeignUser\"}>\n      <Tab.Screen\n        options={{\n          tabBarLabel: \"Profile\",\n        }}\n        name={\"ForeignUser\"}\n        component={User}\n      />\n      <Tab.Screen\n        options={{\n          tabBarLabel: \"Comments\",\n        }}\n        name={\"ForeignUserComments\"}\n        component={OwnComments}\n      />\n      <Tab.Screen\n        options={{\n          tabBarLabel: \"Posts\",\n        }}\n        name={\"ForeignUserPosts\"}\n        component={OwnPosts}\n      />\n    </Tab.Navigator>\n  );\n}\n\nexport default observer(UserScreen);\n",
        "gt": [
            "'lemmy-fennec/Screens/User/User.tsx'",
            "'lemmy-fennec/Screens/User/UserScreen.tsx'",
            "'lemmy-fennec/App.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { DDBRepository, GlobalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteDetailItem, KeyAttrs } from './athlete.details.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteDetailsRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteDetailItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async isExists(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      ProjectionExpression: this.transformer.attrName('PK'),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return true;\n        }\n        return false;\n      })\n      .catch(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository isExists', err, params);\n        return false;\n      });\n  }\n\n  public async get(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async batchGet(athleteIds: string[]) {\n    const params: DocumentClient.BatchGetItemInput = {\n      RequestItems: {\n        [this._tableName]: {\n          Keys: athleteIds.map(id => {\n            return this.transformer.primaryKey(id);\n          }),\n        },\n      },\n    };\n    return this.client\n      .batchGet(params)\n      .promise()\n      .then(data => {\n        return data.Responses[this._tableName].map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository batchGet', params));\n  }\n\n  public async put(athlete: DDBAthleteDetailItem) {\n    const params = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(athlete),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository Put', params));\n  }\n\n  public async delete(id: string) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(id),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository delete', params));\n  }\n\n  public async updateProfileUrl(athleteId: string, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository updateUrl', params));\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi and begins_with(#gsi_sk, :value) ',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        '#gsi_sk': this.transformer.attrName('GSI_SK'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ':value': this.transformer.itemToAttrsTransformer.GSI_SK(name),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return items;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletesByName', params));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: { fullName?: string };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(opts.after);\n\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletes', params));\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        name: this.transformer.attrsToItemTransformer.normalizedName(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createGSIExclusiveStartKey(after?: { athleteId: string; name: string }) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && after.name) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.name),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { fullName?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.fullName) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedFullName, :fullName)`;\n      filterExpAttrNames['#normalizedFullName'] = this.transformer.attrName('normalizedFullname');\n      filterExpAttrValues[':fullName'] = filter.fullName;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/entity.transformer.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport * as moment from 'moment';\nimport { Utils } from 'shared/utils';\nimport { DDBAthleteDetailItem } from '../athlete.details.interface';\n\n@Injectable()\nexport class EntityTransformer {\n  constructor() {}\n\n  public toDBItem(athlete: AthleteDetail): DDBAthleteDetailItem {\n    return {\n      athleteId: athlete.id,\n      birthdate: athlete.birthdate && athlete.birthdate.toISODate(),\n      country: athlete.country,\n      createdAt: athlete.createdAt || moment().unix(),\n      gender: athlete.gender,\n      name: athlete.name,\n      normalizedName: Utils.normalizeString(athlete.name),\n      normalizedFullname: `${Utils.normalizeString(athlete.name)} ${Utils.normalizeString(athlete.surname)}`,\n      profileUrl: athlete.profileUrl || undefined,\n      thumbnailUrl: athlete.thumbnailUrl || undefined,\n      surname: athlete.surname,\n      city: athlete.city || undefined,\n      email: athlete.email,\n      infoUrl: athlete.infoUrl || undefined,\n    };\n  }\n\n  public fromDBItem(athlete: DDBAthleteDetailItem): AthleteDetail {\n    if (!athlete) {\n      return null;\n    }\n    return new AthleteDetail({\n      id: athlete.athleteId,\n      birthdate: athlete.birthdate && new Date(athlete.birthdate),\n      country: athlete.country,\n      createdAt: athlete.createdAt,\n      gender: athlete.gender,\n      name: athlete.name,\n      profileUrl: athlete.profileUrl || '',\n      thumbnailUrl: athlete.thumbnailUrl || '',\n      surname: athlete.surname,\n      city: athlete.city || '',\n      email: athlete.email,\n      infoUrl: athlete.infoUrl || '',\n    });\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { repositoryFactory } from '../../utils/utils';\nimport { DDBAthleteDetailsRepository } from './athlete.details.repo';\n\n@Module({\n  imports: [],\n  providers: [],\n  exports: [],\n})\nexport class DDBAthleteDetailsRepoModule {\n  public static withConfig(dynamodbService: IDynamoDBService): DynamicModule {\n    const repo = repositoryFactory(\n      DDBAthleteDetailsRepository,\n      dynamodbService,\n    );\n    return {\n      module: DDBAthleteDetailsRepoModule,\n      providers: [repo],\n      exports: [repo],\n    };\n  }\n  public static forTest(dynamodbService: IDynamoDBService): ModuleMetadata {\n    const repo = repositoryFactory(\n      DDBAthleteDetailsRepository,\n      dynamodbService,\n    );\n    return {\n      providers: [repo],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/user/user.controller.spec.ts'",
            "'is-even/apps/backend/src/user/user.controller.ts'",
            "'is-even/apps/backend/src/user/user.service.ts'"
        ],
        "content": "'is-even/apps/backend/src/user/user.controller.spec.ts'\n:import { Test, TestingModule } from '@nestjs/testing';\nimport { UserController } from './user.controller';\nimport { UserService } from './user.service';\n\ndescribe('UserController', () => {\n  let controller: UserController;\n\n  const userServiceMock = {\n    createUser: jest.fn(),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      controllers: [UserController],\n      providers: [\n        {\n          provide: UserService,\n          useValue: userServiceMock,\n        },\n      ],\n    }).compile();\n\n    controller = module.get<UserController>(UserController);\n  });\n\n  it('should be defined', () => {\n    expect(controller).toBeDefined();\n  });\n});\n\n'is-even/apps/backend/src/user/user.controller.ts'\n:import {\n  Controller,\n  Post,\n  HttpStatus,\n  HttpException,\n  Body,\n  Get,\n  Req,\n  BadRequestException,\n  HttpCode,\n} from '@nestjs/common';\nimport { ApiResponse, ApiTags } from '@nestjs/swagger';\n\nimport { CognitoCreateUserError } from '../cognito/error/cognito-create-user.error';\nimport { CreateUserDto } from './dto/create-user.dto';\nimport { LoginUserDto } from './dto/login-user.dto';\nimport { UserWithAuth } from './interface/user-with-auth.interface';\nimport { User } from './user.entity';\nimport { UserService } from './user.service';\nimport { Authorised } from '../auth/auth.decorator';\nimport { RequestWithUser } from '../common/interface/request-with-user.interface';\nimport { LoginUserError } from './error/login-user.error';\nimport { RefreshUserTokenDto } from './dto/refresh-user-token.dto';\n\n@Controller('users')\nexport class UserController {\n  constructor(private readonly userService: UserService) {}\n\n  @Post('/register')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.CREATED,\n    description: 'User has been successfully created',\n  })\n  @ApiResponse({\n    status: HttpStatus.SERVICE_UNAVAILABLE,\n    description: 'Third party service error',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async createUser(@Body() createUserDto: CreateUserDto): Promise<User> {\n    const { firstName, lastName, email, password } = createUserDto;\n    try {\n      return await this.userService.createUser(\n        firstName,\n        lastName,\n        email,\n        password,\n      );\n    } catch (error) {\n      if (error instanceof CognitoCreateUserError) {\n        throw new HttpException(\n          'Service temporary unavailable',\n          HttpStatus.SERVICE_UNAVAILABLE,\n        );\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Post('login')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'User has been successfully logged in',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async loginUser(\n    @Body() loginUserDto: LoginUserDto,\n  ): Promise<UserWithAuth> {\n    const { email, password } = loginUserDto;\n    try {\n      return await this.userService.loginWithCredentials(email, password);\n    } catch (error) {\n      if (error instanceof LoginUserError) {\n        throw new BadRequestException('Invalid email or password');\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Post('refresh')\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'Token has been successfully refreshed',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  @ApiResponse({\n    status: HttpStatus.BAD_REQUEST,\n    description: 'Bad request',\n  })\n  public async refreshUserToken(\n    @Body() refreshUserTokenDto: RefreshUserTokenDto,\n  ): Promise<UserWithAuth> {\n    const { refreshToken } = refreshUserTokenDto;\n    try {\n      return await this.userService.loginWithToken(refreshToken);\n    } catch (error) {\n      if (error instanceof LoginUserError) {\n        throw new BadRequestException('Invalid token');\n      }\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @HttpCode(HttpStatus.NO_CONTENT)\n  @Post('logout')\n  @Authorised()\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.NO_CONTENT,\n    description: 'User has been successfully logout',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  public async logoutUser(@Req() request: RequestWithUser): Promise<void> {\n    const user = request.user;\n\n    try {\n      return await this.userService.logoutUser(user.email);\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n\n  @Get('me')\n  @Authorised()\n  @ApiTags('users')\n  @ApiResponse({\n    status: HttpStatus.OK,\n    description: 'User data has been successfully retrieved',\n  })\n  @ApiResponse({\n    status: HttpStatus.INTERNAL_SERVER_ERROR,\n    description: 'Internal server error',\n  })\n  public async me(@Req() request: RequestWithUser): Promise<User> {\n    try {\n      return request.user;\n    } catch (error) {\n      throw new HttpException(\n        'Internal server error',\n        HttpStatus.INTERNAL_SERVER_ERROR,\n      );\n    }\n  }\n}\n\n'is-even/apps/backend/src/user/user.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\n\nimport { User } from './user.entity';\nimport { UserWithAuth } from './interface/user-with-auth.interface';\n\nimport { LoggerService } from '../logger/logger.service';\nimport { CognitoService } from '../cognito/cognito.service';\nimport { SentryService } from '../sentry/sentry.service';\n\nimport { CreateUserError } from './error/create-user.error';\nimport { LoginUserError } from './error/login-user.error';\nimport { ReadUserError } from './error/read-user.error';\nimport { LogoutUserError } from './error/logout-user.error';\nimport { CognitoCreateUserError } from '../cognito/error/cognito-create-user.error';\n\n@Injectable()\nexport class UserService {\n  constructor(\n    private readonly loggerService: LoggerService,\n    private readonly cognitoService: CognitoService,\n    private readonly sentryService: SentryService,\n    @InjectRepository(User) private readonly usersRepository: Repository<User>,\n  ) {\n    this.loggerService.setContext(UserService.name);\n  }\n\n  public async createUser(\n    firstName: string,\n    lastName: string,\n    email: string,\n    password: string,\n  ): Promise<User> {\n    try {\n      const user = new User();\n\n      user.firstName = firstName;\n      user.lastName = lastName;\n      user.email = email;\n\n      const authId = await this.cognitoService.createUser(user.email, password);\n\n      user.authId = authId;\n\n      return await this.usersRepository.save(user);\n    } catch (error) {\n      this.loggerService.error(`Failed to create a new user. ${error.message}`);\n\n      this.sentryService.instance.withScope((scope) => {\n        scope.setTag('where', 'userService.createUser');\n        this.sentryService.instance.captureException(error);\n      });\n\n      if (error instanceof CognitoCreateUserError) {\n        throw error;\n      }\n\n      throw new CreateUserError(error);\n    }\n  }\n\n  public async loginWithCredentials(\n    email: string,\n    password: string,\n  ): Promise<UserWithAuth> {\n    try {\n      const auth = await this.cognitoService.login(email, password);\n      const user = await this.findUserByEmail(email);\n\n      return {\n        user,\n        auth,\n      };\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to login user with credentials. ${error.message}`,\n      );\n      throw new LoginUserError(error);\n    }\n  }\n\n  public async loginWithToken(refreshToken): Promise<UserWithAuth> {\n    try {\n      const auth = await this.cognitoService.refreshToken(refreshToken);\n      const userAuthId = this.cognitoService.getTokenAuthId(auth.accessToken);\n      const user = await this.findUserByAuthId(userAuthId);\n\n      return {\n        user,\n        auth,\n      };\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to login user with token. ${error.message}`,\n      );\n      throw new LoginUserError(error);\n    }\n  }\n\n  public async logoutUser(email: string): Promise<void> {\n    try {\n      await this.cognitoService.logout(email);\n    } catch (error) {\n      this.loggerService.error(`Failed to logout user. ${error.message}`);\n      throw new LogoutUserError(error);\n    }\n  }\n\n  public async findUserByEmail(email: string): Promise<User> {\n    try {\n      return await this.usersRepository.findOneOrFail({\n        where: {\n          email,\n        },\n      });\n    } catch (error) {\n      this.loggerService.error(`Failed to read user data. ${error.message}`);\n      throw new ReadUserError(error);\n    }\n  }\n\n  public async findUserByAuthId(authId: string): Promise<User> {\n    try {\n      return await this.usersRepository.findOneOrFail({\n        where: {\n          authId,\n        },\n      });\n    } catch (error) {\n      this.loggerService.error(`Failed to read user data. ${error.message}`);\n      throw new ReadUserError(error);\n    }\n  }\n}\n",
        "gt": [
            "'is-even/apps/backend/src/user/user.service.ts'",
            "'is-even/apps/backend/src/user/user.controller.ts'",
            "'is-even/apps/backend/src/user/user.controller.spec.ts'"
        ]
    },
    {
        "files": [
            "'hydrated-ws/src/waterfall/IWaterfallOptions.ts'",
            "'hydrated-ws/src/polyfill/isNode.ts'",
            "'hydrated-ws/src/waterfall/Waterfall.ts'",
            "'hydrated-ws/src/polyfill/CustomEvent.ts'"
        ],
        "content": "'hydrated-ws/src/waterfall/IWaterfallOptions.ts'\n:import {Waterfall} from \"./Waterfall\";\n\nexport interface IWaterfallOptions {\n\n    connectionTimeout?: number;\n\n\n    emitClose?: boolean;\n\n\n    retryPolicy?: (attempt: number, ws: Waterfall) => number;\n\n\n    factory?: (url: string, protocols?: string | string[]) => WebSocket;\n}\n\n'hydrated-ws/src/polyfill/isNode.ts'\n:declare var global: any;\n\nlet isNode: boolean;\ntry {\n    isNode = Object.prototype.toString.call(global.process) === \"[object process]\";\n} catch {\n    isNode = false;\n}\n\nexport default isNode;\n\n'hydrated-ws/src/waterfall/Waterfall.ts'\n:import {computedFrom} from \"../computedFrom\";\nimport CloseEvent from \"../polyfill/CloseEvent\";\nimport CustomEvent from \"../polyfill/CustomEvent\";\nimport WebSocket from \"../polyfill/WebSocket\";\nimport { Shell } from \"../Shell\";\nimport { exponentialTruncatedBackoff } from \"./exponentialTruncatedBackoff\";\nimport { IWaterfallOptions } from \"./IWaterfallOptions\";\n\n\n\nexport const REGEXP_URL = /^wss?:(?:\\/\\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD])*@)?(?:\\[(?:(?:(?:[0-9a-f]{1,4}:){6}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|::(?:[0-9a-f]{1,4}:){5}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4}:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:]+)\\]|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}|(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=@\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD])*)(?::[0-9]*)?(?:\\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:@\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD]))*)*|\\/(?:(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:@\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD]))+)(?:\\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:@\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD]))*)*)?|(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:@\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD]))+)(?:\\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:@\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD]))*)*|(?!(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:@\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD])))(?:\\?(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:@\\/\\?\\xA0-\\uD7FF\\uE000-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E\\uDB80-\\uDBBE\\uDBC0-\\uDBFE][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDC00-\\uDFFD])*)?(?:\\#(?:%[0-9a-f][0-9a-f]|[-a-z0-9\\._~!\\$&'\\(\\)\\*\\+,;=:@\\/\\?\\xA0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]|[\\uD800-\\uD83E\\uD840-\\uD87E\\uD880-\\uD8BE\\uD8C0-\\uD8FE\\uD900-\\uD93E\\uD940-\\uD97E\\uD980-\\uD9BE\\uD9C0-\\uD9FE\\uDA00-\\uDA3E\\uDA40-\\uDA7E\\uDA80-\\uDABE\\uDAC0-\\uDAFE\\uDB00-\\uDB3E\\uDB44-\\uDB7E][\\uDC00-\\uDFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F][\\uDC00-\\uDFFD])*)?$/i;\n\nexport type UrlGenerator = ((attempt: number, ws: Waterfall) => string) | ((attempt: number, ws: Waterfall) => Promise<string>);\n\nexport class Waterfall extends Shell {\n\n    private timeout: any;\n    private connectionTimeout: number = 5000;\n    private emitClose: boolean = false;\n    private retryPolicy: (attempt: number, ws: Waterfall) => number = exponentialTruncatedBackoff();\n    private _urlGenerator: UrlGenerator;\n    private _url: string;\n    private attempts: number = -1;\n\n\n    public constructor(\n        url: string | UrlGenerator,\n        private protocols?: string | string[],\n        private options?: IWaterfallOptions) {\n        super();\n        if (!url) {\n            throw new TypeError(\"Invalid url\");\n        }\n        this.urlGenerator = url;\n        if (options) {\n            this.connectionTimeout = options.connectionTimeout || this.connectionTimeout;\n            this.emitClose = options.emitClose || this.emitClose;\n            this.retryPolicy = options.retryPolicy || this.retryPolicy;\n        }\n        this.reconnect();\n    }\n\n\n    @computedFrom(\"_url\")\n    public get url(): string {\n        return this._url;\n    }\n\n\n    public set url(value: string) {\n        this.urlGenerator = value;\n        if (this._url !== value) {\n            this._url = value;\n            if (this.ws) {\n                this.ws.close(1000);\n            }\n        }\n    }\n\n\n    public reset() {\n        if (this.ws) {\n            this.ws.close(1000);\n        }\n    }\n\n\n    @computedFrom(\"_readyState\")\n    public get readyState(): number {\n        return this._readyState;\n    }\n\n\n    @computedFrom(\"ws.bufferedAmount\")\n    public get bufferedAmount(): number {\n        return this.ws.bufferedAmount;\n    }\n\n\n    @computedFrom(\"ws.extensions\")\n    public get extensions(): string {\n\n        return typeof (this.ws.extensions) === \"string\" ? this.ws.extensions : \"\";\n    }\n\n    @computedFrom(\"ws.protocol\")\n    public get protocol(): string {\n        return this.ws.protocol;\n    }\n\n\n    public close(code: number = 1000, reason?: string) {\n        if (this.closing) {\n            return;\n        }\n        this.closing = true;\n        clearTimeout(this.timeout);\n        if ( this.ws) {\n        this.ws.close(  code, reason);\n        }\n    }\n\n    private set urlGenerator(value: string | UrlGenerator) {\n        if (typeof value === \"string\") {\n            if (!value.match(REGEXP_URL)) {\n                throw new TypeError(\"Invalid url\");\n            }\n            this._urlGenerator = () => value;\n        } else {\n            this._urlGenerator = value;\n        }\n    }\n\n    private webSocketFactory(): WebSocket {\n        return this.options && this.options.factory\n            ? this.options.factory(this.url, this.protocols || [])\n            : new WebSocket(this.url, this.protocols || []);\n\n    }\n\n    private onOpenWebSocket(evt: Event) {\n        this.attempts = -1;\n        clearTimeout(this.timeout);\n        this._readyState = WebSocket.OPEN;\n        this.dispatchEvent(evt);\n    }\n\n    private reconnect(timeout?: number) {\n        this._readyState = WebSocket.CONNECTING;\n        this.dispatchEvent(new CustomEvent(\"connecting\", { detail: timeout }));\n        if (timeout !== void 0) {\n            setTimeout(() => this.open(), timeout);\n        } else {\n            this.open();\n        }\n    }\n\n    private onCloseWebSocket(evt: CloseEvent) {\n        clearTimeout(this.timeout);\n        if (this.closing) {\n            this._readyState = WebSocket.CLOSED;\n            this.dispatchEvent(evt);\n            return;\n        }\n        const timeout = this.retryPolicy(this.attempts + 1, this);\n        if (timeout === null) {\n            this._readyState = WebSocket.CLOSED;\n            this.dispatchEvent(evt);\n        } else if (this.emitClose) {\n            this._readyState = WebSocket.CLOSED;\n            this.dispatchEvent(evt);\n            this.reconnect(timeout);\n        } else {\n            this.reconnect(timeout);\n        }\n    }\n\n    private unbindWebSocket() {\n        if (this.ws) {\n            this.ws.onopen = null;\n            this.ws.onclose = null;\n            this.ws.onmessage = null;\n            this.ws.onerror = null;\n        }\n    }\n\n    private bindWebSocket() {\n        this.ws.onopen = this.onOpenWebSocket.bind(this);\n        this.ws.onclose = this.onCloseWebSocket.bind(this);\n        this.ws.onmessage = this.dispatchEvent.bind(this);\n        this.ws.onerror = this.dispatchEvent.bind(this);\n    }\n\n    private forceClose(silent: boolean = false): void {\n        try {\n            if (silent) {\n                this.unbindWebSocket();\n            }\n            this.ws.close();\n        } catch {\n\n        }\n    }\n\n    private failed(): void {\n        clearTimeout(this.timeout);\n        this.forceClose(true);\n        const timeout = this.retryPolicy(this.attempts + 1, this);\n        if (timeout === null) {\n            this._readyState = WebSocket.CLOSED;\n            this.dispatchEvent(new CloseEvent(\"close\", { code: 4000, reason: \"Connect timeout\" }));\n        } else {\n            setTimeout(() => this.open(), timeout);\n        }\n    }\n\n    private setupWebSocketTimeout(): void {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => {\n            this.failed();\n        }, this.connectionTimeout);\n    }\n\n    private open() {\n        if (this.closing) {\n            return;\n        }\n\n        const doOpen = (url: string) => {\n            this._url = url;\n            this.forceClose(true);\n            try {\n                this.ws = this.webSocketFactory();\n                (this.ws as any).binaryType = this.binaryType || this.ws.binaryType;\n                this.setupWebSocketTimeout();\n                this.bindWebSocket();\n            } catch (e) {\n                this.failed();\n            }\n        };\n\n        this.attempts++;\n        const urlOrPromise: any = this._urlGenerator(this.attempts, this);\n        urlOrPromise.then ? urlOrPromise.then(doOpen).catch(() => this.failed()) : doOpen(urlOrPromise);\n    }\n\n}\n\n'hydrated-ws/src/polyfill/CustomEvent.ts'\n:import Event from \"./Event\";\nimport isNode from \"./isNode\";\n\nclass CustomEventPolyfill<T> extends Event implements CustomEvent<T> {\n\n    public readonly detail: T;\n\n    constructor(type: string, eventInitDict?: CustomEventInit<T>) {\n        super(type);\n        eventInitDict = eventInitDict || {};\n        this.detail = eventInitDict.detail;\n    }\n\n    public initCustomEvent(typeArg: string,\n                           canBubbleArg: boolean,\n                           cancelableArg: boolean,\n                           detailArg: T): void {\n        throw new Error(\"initCustomEvent is deprecated\");\n    }\n\n}\n\nexport default (isNode ? CustomEventPolyfill : CustomEvent) as\n    new(type: string, eventInitDict?: CustomEventInit) => CustomEvent;\n",
        "gt": [
            "'hydrated-ws/src/polyfill/isNode.ts'",
            "'hydrated-ws/src/polyfill/CustomEvent.ts'",
            "'hydrated-ws/src/waterfall/Waterfall.ts'",
            "'hydrated-ws/src/waterfall/IWaterfallOptions.ts'"
        ]
    },
    {
        "files": [
            "'among-us-stats/src/components/playersoverview/PlayerOverviewRow.tsx'",
            "'among-us-stats/src/index.tsx'",
            "'among-us-stats/src/components/App.tsx'",
            "'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'"
        ],
        "content": "'among-us-stats/src/components/playersoverview/PlayerOverviewRow.tsx'\n:import Grid from '@material-ui/core/Grid';\nimport React from 'react';\nimport Avatar from '@material-ui/core/Avatar';\nimport Box from '@material-ui/core/Box';\nimport Typography from '@material-ui/core/Typography';\nimport InsertEmoticonIcon from '@material-ui/icons/InsertEmoticon';\nimport { makeStyles } from '@material-ui/core/styles';\n\nimport { percentIt } from '../../utils/mathUtils';\nimport ImpostorIcon from '../shared/icons/ImpostorIcon';\nimport CrewAvatar from '../shared/avatar/CrewAvatar';\n\nimport { PlayerStats } from './usePlayerWithTotalStats';\n\nconst useStyles = makeStyles((theme) => ({\n  winnerIcon: {\n    backgroundColor: theme.palette.primary.main,\n    flexGrow: 1,\n  },\n  impostorRateAvatar: {\n    backgroundColor: theme.palette.background.paper,\n  },\n}));\n\ninterface Props {\n  player: PlayerStats;\n}\n\nfunction PlayerOverviewRow({ player }: Props): JSX.Element {\n  const classes = useStyles();\n  return (\n    <Grid container spacing={1}>\n      <Grid item md=\"auto\" sm={12} xs={12}>\n        <Box display=\"flex\" alignItems=\"center\">\n          <Box p={1}>\n            <Avatar>{player.name.slice(0, 2).toUpperCase()}</Avatar>\n          </Box>\n          <Box display=\"flex\" flexDirection=\"column\">\n            <Typography variant=\"body1\">{player.name}</Typography>\n            <Typography variant=\"caption\">{player.gamesPlayed} games played</Typography>\n          </Box>\n        </Box>\n      </Grid>\n      <StatItem\n        icon={\n          <Avatar className={classes.winnerIcon}>\n            <InsertEmoticonIcon fontSize=\"large\" />\n          </Avatar>\n        }\n        title=\"Total win rate\"\n        text={percentIt(player.totalWinRate)}\n      />\n      <StatItem\n        icon={<CrewAvatar type=\"impostor\" />}\n        title=\"Impostor win rate\"\n        text={percentIt(player.totalImpostorWinRate)}\n      />\n      <StatItem\n        icon={<CrewAvatar type=\"crew\" />}\n        title=\"CrewAvatar win rate\"\n        text={percentIt(player.totalCrewWinRate)}\n      />\n      <StatItem\n        icon={\n          <Avatar className={classes.impostorRateAvatar}>\n            <ImpostorIcon color=\"secondary\" fontSize=\"large\" />\n          </Avatar>\n        }\n        title=\"Games as impostor\"\n        text={percentIt(player.totalImpostorRate)}\n      />\n    </Grid>\n  );\n}\n\ninterface StatItemProps {\n  icon: JSX.Element;\n  title: string;\n  text: string;\n}\n\nfunction StatItem({ icon, title, text }: StatItemProps) {\n  return (\n    <Grid item md=\"auto\" sm={6} xs={12}>\n      <Box display=\"flex\" alignItems=\"center\">\n        <Box p={1}>{icon}</Box>\n        <Box display=\"flex\" flexDirection=\"column\">\n          <Typography variant=\"subtitle2\">{title}</Typography>\n          <Typography variant=\"body1\">{text}</Typography>\n        </Box>\n      </Box>\n    </Grid>\n  );\n}\n\nexport default PlayerOverviewRow;\n\n'among-us-stats/src/index.tsx'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n'among-us-stats/src/components/App.tsx'\n:import React, { Suspense } from 'react';\nimport { CssBaseline, ThemeProvider } from '@material-ui/core';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { Provider } from 'react-redux';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nimport store, { persistor } from '../store/redux';\n\nimport AppBar from './appbar/AppBar';\nimport ActiveSession from './activesession/ActiveSession';\nimport Sessions from './sessions/Sessions';\nimport IntroDialog from './dialogs/IntroDialog';\nimport SettingsDialog from './dialogs/SettingsDialog';\nimport FeedbackDialog from './dialogs/FeedbackDialog';\nimport NotFound from './NotFound';\nimport Analytics from './Analytics';\nimport { theme } from './theme';\nimport ContentWrapper from './ContentWrapper';\nimport ErrorBoundary from './ErrorBoundary';\nimport FullscreenFallback from './shared/FullscreenFallback';\n\nconst LazyPlayersOverview = React.lazy(() => import('./playersoverview/PlayersOverview'));\n\nfunction App(): JSX.Element {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={null} persistor={persistor}>\n        <ThemeProvider theme={theme}>\n          <ErrorBoundary>\n            <Router>\n              <IntroDialog />\n              <SettingsDialog />\n              <FeedbackDialog />\n              <Analytics />\n              <CssBaseline />\n              <AppBar />\n              <ContentWrapper>\n                <Switch>\n                  <Route exact path={['/', '/summary']}>\n                    <ActiveSession />\n                  </Route>\n                  <Route path=\"/sessions\">\n                    <Sessions />\n                  </Route>\n                  <Route path=\"/players\">\n                    <Suspense fallback={<FullscreenFallback />}>\n                      <LazyPlayersOverview />\n                    </Suspense>\n                  </Route>\n                  <Route>\n                    <NotFound />\n                  </Route>\n                </Switch>\n              </ContentWrapper>\n            </Router>\n          </ErrorBoundary>\n        </ThemeProvider>\n      </PersistGate>\n    </Provider>\n  );\n}\n\nexport default App;\n\n'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'\n:import React, { Fragment } from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Typography from '@material-ui/core/Typography';\nimport Box from '@material-ui/core/Box';\nimport Grid from '@material-ui/core/Grid';\nimport { Divider } from '@material-ui/core';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Sort from '@material-ui/icons/Sort';\nimport Menu from '@material-ui/core/Menu';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport { useSelector } from 'react-redux';\nimport { useDispatch } from 'react-redux';\nimport { sortBy, reverse } from 'rambda';\n\nimport useAnchor from '../shared/hooks/useAnchor';\nimport { RootState } from '../../store/redux';\nimport { commonSlice, SortPlayersBy } from '../../store/common/commonRedux';\nimport BreakpointButton from '../shared/BreakpointButton';\n\nimport PlayerOverviewRow from './PlayerOverviewRow';\nimport usePlayersWithTotalStats from './usePlayerWithTotalStats';\n\nconst sortOptions: SortPlayersBy[] = [\n  'Games played',\n  'Total win rate',\n  'Crew win rate',\n  'Impostor win rate',\n  'Impostor rate',\n];\n\nfunction PlayersOverview(): JSX.Element {\n  const dispatch = useDispatch();\n  const [anchorEl, anchorActions] = useAnchor();\n  const sortPlayersBy = useSelector((state: RootState) => state.common.sortPlayersBy);\n  const [playersWithTotalStats, metaStats] = usePlayersWithTotalStats();\n\n  const playersWithTotalStatsSorted = reverse(\n    sortBy((player) => {\n      switch (sortPlayersBy) {\n        case 'Games played':\n          return player.gamesPlayed;\n        case 'Total win rate':\n          return player.totalWinRate;\n        case 'Impostor win rate':\n          return player.totalImpostorWinRate;\n        case 'Crew win rate':\n          return player.totalCrewWinRate;\n        case 'Impostor rate':\n          return player.totalImpostorRate;\n      }\n    })(playersWithTotalStats),\n  );\n\n  return (\n    <Paper>\n      <Toolbar>\n        <Typography variant=\"h5\">Total player stats</Typography>\n        <Box flex=\"1 1 auto\" />\n        <BreakpointButton\n          text={`Sort by: ${sortPlayersBy}`}\n          label={`Sort by: ${sortPlayersBy}`}\n          onClick={anchorActions.handleClick}\n          endIcon={<Sort />}\n        />\n        <Menu\n          id=\"sort-by-menu\"\n          anchorEl={anchorEl}\n          keepMounted\n          open={Boolean(anchorEl)}\n          onClose={anchorActions.handleClose}\n        >\n          {sortOptions.map((it) => (\n            <MenuItem\n              key={it}\n              onClick={() => {\n                dispatch(commonSlice.actions.sortPlayerBy(it));\n                anchorActions.handleClose();\n              }}\n            >\n              {it}\n            </MenuItem>\n          ))}\n        </Menu>\n      </Toolbar>\n      <Box p={3} pt={0}>\n        <Box pb={2}>\n          <Typography variant=\"body1\">\n            A total of{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalPlayers} players\n            </Box>{' '}\n            have played{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalGames} games\n            </Box>{' '}\n            over{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalSessions} sessions\n            </Box>\n            .\n          </Typography>\n        </Box>\n        <Grid container spacing={1}>\n          {playersWithTotalStatsSorted.map((it, index) => (\n            <Fragment key={it.playerId}>\n              <Grid item xs={12}>\n                <PlayerOverviewRow player={it} />\n              </Grid>\n              {index !== playersWithTotalStats.length - 1 && (\n                <Grid item xs={12}>\n                  <Divider />\n                </Grid>\n              )}\n            </Fragment>\n          ))}\n        </Grid>\n      </Box>\n    </Paper>\n  );\n}\n\nexport default PlayersOverview;\n",
        "gt": [
            "'among-us-stats/src/components/playersoverview/PlayerOverviewRow.tsx'",
            "'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'",
            "'among-us-stats/src/components/App.tsx'",
            "'among-us-stats/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'calendar-hack/src/defy/components/Radios.tsx'",
            "'calendar-hack/src/App.tsx'",
            "'calendar-hack/src/defy/components/UnitsButtons.tsx'",
            "'calendar-hack/src/index.tsx'"
        ],
        "content": "'calendar-hack/src/defy/components/Radios.tsx'\n:import React from \"react\";\nimport styled from \"styled-components\";\n\nconst Mark = styled.div`\n  position: relative;\n  border-radius: 50%;\n  width: 2.2em;\n  height: 2.2em;\n  z-index: 10;\n  color: ${(props) => props.theme.colors.buttonTxt};\n  margin: 0 0.1em;\n\n  &:hover {\n    cursor: pointer;\n  }\n  &::after {\n\n\n    content: \"\";\n    width: 1.9em;\n    height: 1.9em;\n    border-radius: 50%;\n    background-color: ${(props) => props.theme.colors.buttonBg};\n    opacity: 1;\n    position: absolute;\n    margin: auto;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n  }\n`;\n\nconst RadioLabel = styled.div`\n  font-size: 1em;\n  font-weight: 900;\n  z-index: 12;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n`;\n\nconst Input = styled.input`\n  position: absolute;\n  visibility: hidden;\n  display: none;\n  &:checked + ${Mark} {\n    background-color: ${(props) => props.theme.colors.buttonSelectedBorder};\n    &:hover {\n      cursor: not-allowed;\n    }\n    &:after {\n\n      margin: auto;\n      opacity: 1;\n      background-color: ${(props) => props.theme.colors.buttonBg};\n    }\n  }\n  &:not(:checked) + ${Mark} {\n    background-color: ${(props) => props.theme.colors.buttonBg};\n  }\n`;\n\ninterface Props {\n  id: string;\n  name: string;\n  value: string;\n  labelTxt: string;\n  changeCb: (event: React.FormEvent<HTMLInputElement>) => void;\n  currentValue: string;\n}\n\nexport const Radio = ({\n  id,\n  name,\n  value,\n  labelTxt,\n  changeCb,\n  currentValue,\n}: Props) => {\n  return (\n    <label htmlFor={id}>\n      <Input\n        id={id}\n        name={name}\n        type=\"radio\"\n        value={value}\n        checked={value === currentValue}\n        onChange={changeCb}\n      />\n      <Mark>\n        <RadioLabel>{labelTxt}</RadioLabel>\n      </Mark>\n    </label>\n  );\n};\n\n'calendar-hack/src/App.tsx'\n:import React, { useState } from \"react\";\nimport { repo } from \"./ch/planrepo\";\nimport { endOfWeek, addWeeks, isAfter } from \"date-fns\";\nimport { RacePlan } from \"./ch/dategrid\";\nimport { build, swap, swapDow } from \"./ch/planbuilder\";\nimport { CalendarGrid } from \"./components/CalendarGrid\";\nimport { ThemeProvider } from \"styled-components\";\nimport { toIcal, download } from \"./ch/icalservice\";\nimport UnitsButtons from \"./defy/components/UnitsButtons\";\nimport PlanAndDate from \"./components/PlanAndDate\";\nimport Toolbar from \"./defy/components/Toolbar\";\nimport styled from \"styled-components\";\nimport DownloadButton from \"./components/DownloadButton\";\nimport UndoButton from \"./components/UndoButton\";\nimport history from \"./defy/history\";\nimport {\n  useQueryParams,\n  StringParam,\n  DateParam,\n  NumberParam,\n} from \"use-query-params\";\nimport { PlanDetailsCard } from \"./components/PlanDetailsCard\";\nimport { WeekStartsOn, WeekStartsOnValues } from \"./ch/datecalc\";\nimport WeekStartsOnPicker from \"./components/WeekStartsOnPicker\";\nimport { useMountEffect } from \"./ch/hooks\";\nimport { Units, PlanSummary, dayOfWeek } from \"types/app\";\nimport { getLocaleUnits } from \"./ch/localize\";\n\nconst theme = {\n  colors: {\n    bodyBg: \"#B8E2E6\",\n    title: \"#424242\",\n    buttonBg: \"#E3F7F8\",\n    buttonIcons: \"#E3F7F8\",\n    buttonTxt: \"#424242\",\n    buttonSelectedBorder: \"#FF6FDF\",\n    dowHeaderBg: \"#C2C5EB\",\n    weekSummaryBg: \"#C2C5EB\",\n    workoutCardBg: \"#E3F7F8\",\n    workoutCardBlankBg: \"#e9ecef\",\n    datelineBg: \"#B391D2\",\n    datelineBlankBg: \"#beafd2\",\n    datelineTxt: \"#424242\",\n    planDescriptionBg: \"#E3F7F8\",\n    planDescriptionTxt: \"#424242\",\n  },\n  fonts: [\"sans-serif\", \"Roboto\"],\n  fontSizes: {\n    small: \"1em\",\n    medium: \"2em\",\n    large: \"3em\",\n  },\n  screenSizes: {\n    sm: \"576px\",\n    md: \"768px\",\n    lg: \"992px\",\n    xl: \"1200px\",\n  },\n};\n\nconst MainUI = styled.div`\n  margin-top: 2em;\n`;\n\nconst SecondToolbar = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-wrap: wrap;\n  margin: 1em 0 5px 0;\n  color: ${(props) => props.theme.colors.controlsTitle};\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    flex-direction: column;\n  }\n`;\nconst UnitsDiv = styled.div`\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    margin-top: 0.5em;\n  }\n`;\n\nconst App = () => {\n  const [{ u, p, d, s }, setq] = useQueryParams({\n    u: StringParam,\n    p: StringParam,\n    d: DateParam,\n    s: NumberParam,\n  });\n  const [selectedUnits, setSelectedUnits] = useState<Units>(\n    u === \"mi\" || u === \"km\" ? u : getLocaleUnits()\n  );\n  var [selectedPlan, setSelectedPlan] = useState(repo.find(p || \"\"));\n  var [racePlan, setRacePlan] = useState<RacePlan | undefined>(undefined);\n  var [undoHistory, setUndoHistory] = useState([] as RacePlan[]);\n  var [weekStartsOn, setWeekStartsOn] = useState<WeekStartsOn>(\n    s === 0 || s === 1 || s === 6 ? s : WeekStartsOnValues.Monday\n  );\n  var [planEndDate, setPlanEndDate] = useState(\n    d && isAfter(d, new Date())\n      ? d\n      : addWeeks(endOfWeek(new Date(), { weekStartsOn: weekStartsOn }), 20)\n  );\n\n  useMountEffect(() => {\n    initialLoad(selectedPlan, planEndDate, selectedUnits, weekStartsOn);\n  });\n\n  const [, forceUpdate] = React.useReducer((x) => x + 1, 0);\n  React.useEffect(() => {\n\n    history.listen(() => {\n      forceUpdate();\n    });\n  }, []);\n\n  const getParams = (\n    units: Units,\n    plan: PlanSummary,\n    date: Date,\n    weekStartsOn: WeekStartsOn\n  ) => {\n    return {\n      u: units,\n      p: plan[0],\n      d: date,\n      s: weekStartsOn,\n    };\n  };\n\n  const initialLoad = async (\n    plan: PlanSummary,\n    endDate: Date,\n    units: Units,\n    weekStartsOn: WeekStartsOn\n  ) => {\n    const racePlan = build(await repo.fetch(plan), endDate, weekStartsOn);\n    setRacePlan(racePlan);\n    setUndoHistory([...undoHistory, racePlan]);\n    setq(getParams(units, plan, endDate, weekStartsOn));\n  };\n\n  const onSelectedPlanChange = async (plan: PlanSummary) => {\n    const racePlan = build(await repo.fetch(plan), planEndDate, weekStartsOn);\n    setSelectedPlan(plan);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, plan, planEndDate, weekStartsOn));\n  };\n\n  const onSelectedEndDateChange = async (date: Date) => {\n    const racePlan = build(await repo.fetch(selectedPlan), date, weekStartsOn);\n    setPlanEndDate(date);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, selectedPlan, date, weekStartsOn));\n  };\n\n  const onSelectedUnitsChanged = (u: Units) => {\n    setSelectedUnits(u);\n    setq(getParams(u, selectedPlan, planEndDate, weekStartsOn));\n  };\n\n  const onWeekStartsOnChanged = async (v: WeekStartsOn) => {\n    const racePlan = build(await repo.fetch(selectedPlan), planEndDate, v);\n    setWeekStartsOn(v);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, selectedPlan, planEndDate, v));\n  };\n\n  function swapDates(d1: Date, d2: Date): void {\n    if (racePlan) {\n      const newRacePlan = swap(racePlan, d1, d2);\n      setRacePlan(newRacePlan);\n      setUndoHistory([...undoHistory, newRacePlan]);\n    }\n  }\n\n  function doSwapDow(dow1: dayOfWeek, dow2: dayOfWeek) {\n    if (racePlan) {\n      const newRacePlan = swapDow(racePlan, dow1, dow2);\n      setRacePlan(newRacePlan);\n      setUndoHistory([...undoHistory, newRacePlan]);\n    }\n  }\n\n  function downloadHandler() {\n    if (racePlan) {\n      const iCalEventsStr = toIcal(racePlan, selectedUnits);\n      if (iCalEventsStr) {\n        download(iCalEventsStr, \"plan\", \"ics\");\n      }\n    }\n  }\n\n  function undoHandler() {\n    if (undoHistory?.length >= 0) {\n      undoHistory.pop();\n    }\n    setRacePlan(undoHistory[undoHistory.length - 1]);\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <Toolbar downloadHandler={downloadHandler} />\n      <PlanAndDate\n        units={selectedUnits}\n        availablePlans={repo.available}\n        selectedPlan={selectedPlan}\n        selectedDate={planEndDate}\n        dateChangeHandler={onSelectedEndDateChange}\n        selectedPlanChangeHandler={onSelectedPlanChange}\n        unitsChangeHandler={onSelectedUnitsChanged}\n        downloadHandler={downloadHandler}\n        weekStartsOn={weekStartsOn}\n      />\n      <SecondToolbar>\n        <UnitsDiv>\n          <UnitsButtons\n            units={selectedUnits}\n            unitsChangeHandler={onSelectedUnitsChanged}\n          />\n        </UnitsDiv>\n      </SecondToolbar>\n      <SecondToolbar>\n        <DownloadButton downloadHandler={downloadHandler} />\n        <UndoButton\n          disabled={undoHistory.length <= 1}\n          undoHandler={undoHandler}\n        />\n      </SecondToolbar>\n      <PlanDetailsCard racePlan={racePlan} />\n      <SecondToolbar>\n        <WeekStartsOnPicker\n          weekStartsOn={weekStartsOn}\n          changeHandler={onWeekStartsOnChanged}\n        />\n      </SecondToolbar>\n      <MainUI>\n        {racePlan && (\n          <CalendarGrid\n            racePlan={racePlan}\n            units={selectedUnits}\n            weekStartsOn={weekStartsOn}\n            swapDates={swapDates}\n            swapDow={doSwapDow}\n          />\n        )}\n      </MainUI>\n    </ThemeProvider>\n  );\n};\n\nexport default App;\n\n'calendar-hack/src/defy/components/UnitsButtons.tsx'\n:import React from \"react\";\nimport styled from \"styled-components\";\nimport { IconContext } from \"react-icons\";\nimport { useContext } from \"react\";\nimport { ThemeContext } from \"styled-components\";\nimport { Radio } from \"./Radios\";\nimport { Units } from \"types/app\";\n\ninterface Props {\n  units: Units;\n  unitsChangeHandler: (u: Units) => void;\n}\n\nconst Root = styled.div`\n  display: flex;\n  justify-content: center;\n  font-size: 18px;\n`;\n\nconst UnitsButtons = ({ units, unitsChangeHandler }: Props) => {\n  const themeContext = useContext(ThemeContext);\n\n  const changeCb = (event: React.FormEvent<HTMLInputElement>) => {\n    const newSelection = \"mi\" === event.currentTarget.value ? \"mi\" : \"km\";\n    unitsChangeHandler(newSelection);\n  };\n\n  return (\n    <IconContext.Provider value={{ color: themeContext?.colors.buttonIcons }}>\n      <Root>\n        <Radio\n          id=\"radio-mi\"\n          name=\"radio-units\"\n          value=\"mi\"\n          labelTxt=\"Mi\"\n          changeCb={changeCb}\n          currentValue={units}\n        />\n        <Radio\n          id=\"radio-km\"\n          name=\"radio-units\"\n          value=\"km\"\n          labelTxt=\"Km\"\n          changeCb={changeCb}\n          currentValue={units}\n        />\n      </Root>\n    </IconContext.Provider>\n  );\n};\n\nexport default UnitsButtons;\n\n'calendar-hack/src/index.tsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { DndProvider } from 'react-dnd-multi-backend'\nimport { HTML5toTouch } from 'rdndmb-html5-to-touch'\nimport { QueryParamProvider } from \"use-query-params\";\nimport { WindowHistoryAdapter } from \"use-query-params/adapters/window\";\nimport \"./css/reset.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <DndProvider options={HTML5toTouch}>\n      <QueryParamProvider adapter={WindowHistoryAdapter}>\n        <App />\n      </QueryParamProvider>\n    </DndProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n\n\n\nserviceWorker.unregister();\n",
        "gt": [
            "'calendar-hack/src/defy/components/Radios.tsx'",
            "'calendar-hack/src/defy/components/UnitsButtons.tsx'",
            "'calendar-hack/src/App.tsx'",
            "'calendar-hack/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'meditations/src/journal/main.tsx'",
            "'meditations/src/index.tsx'",
            "'meditations/src/common/components/FormFactorProvider.tsx'",
            "'meditations/src/common/components/CommonUI.tsx'",
            "'meditations/src/journal/containers/JournalRoot.tsx'"
        ],
        "content": "'meditations/src/journal/main.tsx'\n:import * as React from \"react\";\nimport route from \"riot-route\";\nimport * as Scroll from \"react-scroll\";\n\nimport moment from \"moment\";\nimport * as common from \"../common\";\n\nimport { JournalRoot } from \"./containers/JournalRoot\";\nimport { SidebarState } from \"./components/Sidebar\";\nimport { store, dispatch, Entry } from \"./state\";\n\nexport const main = () => {\n\n\n  common.installRouter(\n    \"/journal#\",\n    `view/${moment().format(common.MONTH_FORMAT)}`,\n    {\n      no_action: () => route(`view/${moment().format(common.MONTH_FORMAT)}`),\n      journal: () => null,\n\n      view: (datestr: string, entryScrollId?: string) => {\n        const date = moment(datestr, common.MONTH_FORMAT);\n\n        if (entryScrollId && !isNaN(parseInt(entryScrollId, 10))) {\n          Scroll.scroller.scrollTo(`entry-${entryScrollId}`, {\n            smooth: true,\n            duration: 500\n          });\n        }\n\n        common.setTitle(\"Notes\", `${date.format(\"MMMM YYYY\")}`);\n\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/date?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_MONTH\" });\n            }\n          );\n        });\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/date?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_MONTH\" });\n            }\n          );\n        });\n      },\n\n      search: (text: string) => {\n        common.setTitle(\"Notes\", `Search: ${text}`);\n\n        common.post(`/journal/search?string=${text}`);\n      },\n\n      viewdays: (datestr: string) => {\n        const date = moment(datestr, common.DAY_FORMAT);\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/by-day?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_DAYS\" });\n            }\n          );\n        });\n      },\n\n      tag: (tagname: string) => {\n        common.setTitle(\"Notes\", `Tag #${tagname}`);\n        dispatch(dispatch => {\n          common.get(`/journal/entries/tag/${tagname}`, (entries: Entry[]) => {\n            entries.forEach(common.processModel);\n            dispatch({ entries, type: \"VIEW_TAG\", tag: tagname });\n          });\n        });\n      },\n\n      name: (name: string) => {\n        common.setTitle(\"Notes\", `${name}`);\n        dispatch(dispatch => {\n          common.get(`/journal/entries/name/${name}`, (entry: Entry) => {\n            common.processModel(entry);\n            dispatch({ entry, type: \"VIEW_NAMED_ENTRY\" });\n          });\n        });\n      }\n    }\n  );\n\n\n  type JournalMessage =\n    | {\n      Type: \"UPDATE_ENTRY\";\n      Datum: Entry;\n    }\n    | {\n      Type: \"DELETE_ENTRY\";\n      Datum: number;\n    }\n    | {\n      Type: \"CREATE_ENTRY\";\n      Datum: Entry;\n    }\n    | {\n      Type: \"SIDEBAR\";\n      Datum: SidebarState;\n    }\n    | {\n      Type: \"SEARCH\";\n      Datum: {\n        String: string;\n        Entries: Entry[];\n      };\n    };\n\n  common.makeSocket(\n    \"journal/sync\",\n    (msg: JournalMessage) => {\n      switch (msg.Type) {\n        case \"UPDATE_ENTRY\":\n          common.processModel(msg.Datum);\n          dispatch({ type: \"UPDATE_ENTRY\", entry: msg.Datum });\n          break;\n        case \"DELETE_ENTRY\":\n          dispatch({ type: \"DELETE_ENTRY\", ID: msg.Datum });\n          break;\n        case \"CREATE_ENTRY\":\n          common.processModel(msg.Datum);\n\n\n          dispatch({ type: \"CREATE_ENTRY\", entry: msg.Datum });\n          break;\n        case \"SIDEBAR\":\n          dispatch({ type: \"MOUNT_SIDEBAR\", sidebar: msg.Datum });\n          break;\n        case \"SEARCH\":\n          msg.Datum.Entries.forEach(common.processModel);\n          dispatch({\n            type: \"SEARCH\",\n            string: msg.Datum.String,\n            entries: msg.Datum.Entries\n          });\n          break;\n      }\n    },\n    () => {\n\n\n      common.render(\"root\", store, React.createElement(JournalRoot));\n\n\n      common.post(\"/journal/sidebar\");\n    }\n  );\n};\n\n'meditations/src/index.tsx'\n:\n\nimport { main as habitsMain } from './habits/main';\nimport { main as journalMain } from './journal/main';\n\n\n\nimport './style/shared.css';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const { pathname } = window.location;\n  if (pathname === '/habits') {\n    habitsMain();\n  } else if (pathname === '/journal') {\n    journalMain();\n  } else if (pathname === '/') {\n\n    location.href = '/habits';\n  } else {\n    console.error('path not found');\n  }\n});\n\n'meditations/src/common/components/FormFactorProvider.tsx'\n:import * as React from \"react\";\nimport { MOBILE_WIDTH } from \"../constants\";\n\ninterface FormFactorProviderState {\n  mobile: boolean;\n}\n\nexport class FormFactorManager extends React.Component<\n  {},\n  FormFactorProviderState\n> {\n  state = {\n    mobile: false\n  };\n\n  handleScreenResize = () => {\n    this.setState({\n      mobile: window.innerWidth <= MOBILE_WIDTH\n    });\n  };\n\n  componentDidMount() {\n    this.handleScreenResize();\n    window.onresize = this.handleScreenResize;\n  }\n\n  render() {\n    return (\n      <formFactorContext.Provider value={this.state}>\n        {this.props.children}\n      </formFactorContext.Provider>\n    );\n  }\n}\n\nexport const formFactorContext = React.createContext(\n  (undefined as any) as FormFactorProviderState\n);\n\n'meditations/src/common/components/CommonUI.tsx'\n:import * as React from \"react\";\nimport { CommonState } from \"..\";\nimport { ModalProvider } from \"../modal\";\nimport { FormFactorManager } from \"./FormFactorProvider\";\n\nconst IntroMessage = () => {\n  return (\n    <>\n      <p>\n        <strong>Welcome to meditations!</strong>\n      </p>\n\n      <p>\n        Meditations is a daily task manager based on the principles of habit\n        formation.\n      </p>\n\n      <p>\n        If you'd like to read more about meditations and how to use it, the best\n        place to start is its README:\n      </p>\n      <p>\n        <a href=\"https:\n          https:\n        </a>\n      </p>\n\n      <p>\n        If you'd like to learn more about its creator or need a similar\n        application developed, visit{\" \"}\n        <a href=\"https:\n      </p>\n\n      <p>Enjoy.</p>\n    </>\n  );\n};\n\n\nexport class CommonUI extends React.Component<CommonState> {\n  reconnect = () => {\n    this.props.socketReconnect();\n  };\n\n  renderPopups() {\n    if (!this.props.notifications && !this.props.socketClosed) {\n      return <></>;\n    }\n\n    return (\n      <div id=\"notifications\" className=\"bg-gray border border-gray-dark p-2\">\n        <h3>\n          Notifications\n          {this.props.notifications && (\n            <span className=\"float-right Label Label--gray-darker\">\n              {this.props.notifications.length}\n            </span>\n          )}\n        </h3>\n\n        {this.props.socketClosed && (\n          <div>\n            <div className=\"notification flash flash-error mb-2\">\n              <p>WebSocket connection failed!</p>\n              <button className=\"btn btn-primary\" onClick={this.reconnect}>\n                Attempt reconnection\n              </button>\n            </div>\n          </div>\n        )}\n\n        {this.props.notifications && (\n          <button\n            className=\"btn btn-block mb-2\"\n            onClick={this.props.dismissNotifications}\n          >\n            Dismiss all notifications\n          </button>\n        )}\n\n        {this.props.notifications &&\n          this.props.notifications.map((n, i) => {\n            return (\n              <div\n                key={i}\n                className={`notification flash\n              flash-with-icon mb-2 ${n.error ? \"flash-danger\" : \"\"}`}\n              >\n                {n.message === \"INTRO\" ? (\n                  <IntroMessage />\n                ) : (\n                    <pre style={{ whiteSpace: \"pre-wrap\" }}>{n.message}</pre>\n                  )}\n              </div>\n            );\n          })}\n      </div>\n    );\n  }\n\n  render() {\n    return (\n      <>\n        {this.renderPopups()}\n        <FormFactorManager>\n          <ModalProvider socketClosed={this.props.socketClosed}>\n            {this.props.children}\n          </ModalProvider>\n        </FormFactorManager>\n      </>\n    );\n  }\n}\n\n'meditations/src/journal/containers/JournalRoot.tsx'\n:import * as React from \"react\";\nimport moment from \"moment\";\n\nimport * as common from \"../../common\";\nimport { CommonUI } from \"../../common/components/CommonUI\";\n\nimport { JournalState, Entry } from \"../state\";\nimport { JournalSidebar } from \"../components/Sidebar\";\n\nimport { BrowseChrono } from \"../components/BrowseChrono\";\nimport { BrowseTag } from \"../components/BrowseTag\";\nimport { CEntry } from \"../components/CEntry\";\nimport { JournalNavigation } from \"./JournalNavigation\";\n\nconst ViewEntry = (props: { entry: Entry | null }) => {\n  return props.entry ? (\n    <CEntry editableID={`entry-${props.entry.ID}`} context={true} entry={props.entry} />\n  ) : (\n    <p>Entry deleted</p>\n  );\n};\n\nexport const JournalRoot = common.connect()(\n  class extends React.Component<JournalState, {}> {\n    render() {\n      return (\n        <CommonUI {...this.props}>\n          <div className=\"d-flex flex-column flex-md-row mr-md-1\">\n            <div id=\"journal-sidebar\" className=\"mb-1\">\n              {React.createElement(JournalSidebar)}\n            </div>\n\n            <div id=\"journal-main\" className=\"ml-md-1\">\n              {React.createElement(JournalNavigation)}\n              {(this.props.route === \"VIEW_MONTH\" ||\n                this.props.route === \"VIEW_DAYS\" ||\n                this.props.searchResults) && (\n                  <BrowseChrono\n                    searchString={this.props.searchString}\n                    daysView={this.props.route === \"VIEW_DAYS\"}\n                    date={\n                      this.props.route === \"VIEW_MONTH\" ||\n                        this.props.route === \"VIEW_DAYS\"\n                        ? this.props.date\n                        : moment()\n                    }\n                    entries={this.props.entries}\n                  />\n                )}\n              {this.props.route === \"VIEW_TAG\" && (\n                <BrowseTag\n                  tagName={this.props.tag}\n                  entries={this.props.entries}\n                />\n              )}\n              {this.props.route === \"VIEW_NAMED_ENTRY\" && (\n                <ViewEntry\n                  entry={\n                    this.props.entries.length === 0\n                      ? null\n                      : this.props.entries[0]\n                  }\n                />\n              )}\n              {this.props.route === \"VIEW_SEARCH\" && (\n                <span>Search not implemented yet</span>\n              )}\n            </div>\n          </div>\n        </CommonUI>\n      );\n    }\n  }\n);\n",
        "gt": [
            "'meditations/src/common/components/FormFactorProvider.tsx'",
            "'meditations/src/common/components/CommonUI.tsx'",
            "'meditations/src/journal/containers/JournalRoot.tsx'",
            "'meditations/src/journal/main.tsx'",
            "'meditations/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'cxml/src/builder/BuilderConfig.ts'",
            "'cxml/src/schema/Group.ts'",
            "'cxml/src/builder/Builder.ts'",
            "'cxml/src/schema/Element.ts'",
            "'cxml/src/builder/RuleSet.ts'"
        ],
        "content": "'cxml/src/builder/BuilderConfig.ts'\n:import { Namespace } from '../Namespace';\nimport { ParserConfig, ParserOptions } from '../parser/ParserConfig';\nimport { SimpleSchema, SimpleSchemaSpecTbl } from '../schema/SimpleSchema';\nimport { RuleSet } from './RuleSet';\nimport { Builder } from './Builder';\n\nexport class BuilderConfig {\n\n\tconstructor(parserConfig: ParserConfig, schemaSpec: SimpleSchemaSpecTbl) {\n\t\tthis.options = parserConfig.options;\n\n\t\tfor(let prefix of Object.keys(schemaSpec)) {\n\t\t\tconst [ defaultPrefix, nsUri, spec ] = schemaSpec[prefix];\n\t\t\tconst ns = new Namespace(defaultPrefix, nsUri);\n\n\t\t\tif(spec['document']) {\n\t\t\t\tthis.ruleSetTbl[nsUri] = new RuleSet(new SimpleSchema(parserConfig, ns, spec));\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateBuilder(nsUri: string) {\n\t\treturn(new Builder(this, nsUri));\n\t}\n\n\toptions: ParserOptions;\n\truleSetTbl: { [uri: string]: RuleSet } = {};\n\n}\n\n'cxml/src/schema/Group.ts'\n:import { SimpleElementSpec, ElementSpec } from './Element';\n\nexport const enum GroupKind {\n\tgroup,\n\tall,\n\tchoice,\n\tsequence\n}\n\nexport class Group {\n\n\tconstructor( public kind: GroupKind ) {}\n\n\taddElement(spec: SimpleElementSpec | ElementSpec) {\n\t\tthis.list.push(spec);\n\t\tif(spec.meta) this.tbl[spec.meta.token.id!] = spec;\n\t}\n\n\n\tlist: (SimpleElementSpec | ElementSpec)[] = []\n\n\ttbl: { [id: number]: SimpleElementSpec | ElementSpec } = {};\n\n}\n\n'cxml/src/builder/Builder.ts'\n:import { Namespace } from '../Namespace';\nimport { TokenChunk } from '../parser/TokenChunk';\nimport { Token, TokenBuffer, TokenKind, OpenToken, CloseToken, StringToken } from '../parser/Token';\nimport { ParserConfig, ParserOptions } from '../parser/ParserConfig';\nimport { Parser } from '../parser/Parser';\nimport { SimpleSchema, SimpleSchemaSpecTbl } from '../schema/SimpleSchema';\nimport { RuleSet, Rule, RuleMember } from './RuleSet';\n\nimport { ComplexType } from '../schema/ComplexType';\nimport { ElementInstance, ElementSpec, ElementMeta, ElementConstructor } from '../schema/Element';\nimport { ElementToken } from '../parser/Token';\nimport { BuilderConfig } from './BuilderConfig';\n\nconst enum State {\n\tELEMENT = 0,\n\tPROCESSING,\n\tTEXT,\n\tCOMMENT\n}\n\nexport class Builder {\n\n\tconstructor(private config: BuilderConfig, public nsUri: string) {\n\t\tconst ruleSet = this.config.ruleSetTbl[nsUri];\n\n\t\tif(!ruleSet) throw(new Error('Unknown XML namespace ' + nsUri));\n\n\t\tthis.rule = ruleSet.rootRule;\n\t}\n\n\tgetUnknownProto(token: ElementToken) {\n\t\tlet elementSpec: ElementSpec | undefined = this.unknownType.elements && this.unknownType.elements.group!.tbl[token.id!] as ElementSpec;\n\n\t\tif(!elementSpec) {\n\t\t\telementSpec = new ElementSpec(0, Infinity);\n\t\t\tconst elementMeta = new ElementMeta(token);\n\n\t\t\telementMeta.type = new ComplexType();\n\t\t\telementSpec.meta = elementMeta;\n\n\t\t\tthis.unknownType.addAll(elementSpec);\n\t\t}\n\n\t\treturn(elementSpec.meta!.createProto());\n\t}\n\n\twrite(chunk: TokenChunk) {\n\t\tif(!chunk) return;\n\n\t\tconst parseUnknown = this.config.options.parseUnknown;\n\t\tlet unknownDepth = this.unknownDepth;\n\t\tlet state = this.state;\n\t\tlet item = this.item;\n\t\tlet rule = this.rule;\n\t\tlet member = this.member;\n\t\tlet target = this.target;\n\t\tlet stackPos = this.stackPos;\n\n\t\tconst ruleStack = this.ruleStack;\n\t\tconst itemStack = this.itemStack;\n\n\t\tconst buffer = chunk.buffer;\n\t\tlet token: typeof buffer[0];\n\t\tlet dataType: string;\n\t\tlet kind: number;\n\t\tlet id: number;\n\t\tlet name: string;\n\n\t\tlet itemNext: any;\n\t\tlet ruleNext: Rule | undefined;\n\n\t\tlet lastNum = chunk.length - 1;\n\t\tlet tokenNum = -1;\n\n\t\twhile(tokenNum < lastNum) {\n\n\t\t\ttoken = buffer[++tokenNum];\n\t\t\tdataType = typeof(token);\n\n\t\t\tif(unknownDepth) {\n\t\t\t\tif(dataType == 'object') {\n\t\t\t\t\tkind = (token as Token).kind;\n\n\t\t\t\t\tif(kind == TokenKind.open) ++unknownDepth;\n\t\t\t\t\telse if(kind == TokenKind.close) --unknownDepth;\n\t\t\t\t}\n\t\t\t} else if(dataType == 'object') {\n\t\t\t\tkind = (token as Token).kind;\n\n\t\t\t\tswitch(kind) {\n\t\t\t\t\tcase TokenKind.open:\n\n\t\t\t\t\t\tid = (token as OpenToken).id!;\n\t\t\t\t\t\tname = (token as OpenToken).name;\n\t\t\t\t\t\tmember = rule && rule.elements[id];\n\n\t\t\t\t\t\tif(member) {\n\t\t\t\t\t\t\truleNext = member.rule;\n\n\t\t\t\t\t\t\tif(ruleNext == Rule.string) {\n\n\n\t\t\t\t\t\t\t\ttarget = name;\n\t\t\t\t\t\t\t\titemNext = item;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\titemNext = new ruleNext.XMLType();\n\t\t\t\t\t\t\t\tif(member.max > 1) {\n\t\t\t\t\t\t\t\t\tif(!item.hasOwnProperty(name)) item[name] = [];\n\t\t\t\t\t\t\t\t\titem[name].push(itemNext);\n\t\t\t\t\t\t\t\t} else item[name] = itemNext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(!parseUnknown) {\n\t\t\t\t\t\t\t++unknownDepth;\n\n\t\t\t\t\t\t\tstate = State.TEXT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\truleNext = void 0;\n\t\t\t\t\t\t\titemNext = new (this.getUnknownProto(token as OpenToken))();\n\n\t\t\t\t\t\t\tif(!item.hasOwnProperty(name)) item[name] = itemNext;\n\t\t\t\t\t\t\telse if(item[name] instanceof Array) item[name].push(itemNext);\n\t\t\t\t\t\t\telse item[name] = [item[name], itemNext];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titemStack[stackPos] = item;\n\t\t\t\t\t\truleStack[stackPos++] = rule;\n\t\t\t\t\t\titem = itemNext;\n\t\t\t\t\t\trule = ruleNext;\n\n\t\t\t\t\t\tstate = State.ELEMENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TokenKind.close:\n\n\t\t\t\t\t\titem = itemStack[--stackPos];\n\t\t\t\t\t\trule = ruleStack[stackPos];\n\n\n\t\t\t\t\tcase TokenKind.emitted:\n\n\t\t\t\t\t\tif(rule != Rule.string) target = '$';\n\n\t\t\t\t\t\tstate = State.TEXT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TokenKind.string:\n\n\t\t\t\t\t\tid = (token as StringToken).id!;\n\t\t\t\t\t\tmember = rule && rule.attributes[id];\n\t\t\t\t\t\tif(member || parseUnknown) {\n\t\t\t\t\t\t\ttarget = (token as StringToken).name;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget = void 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TokenKind.comment:\n\n\t\t\t\t\t\tstate = State.COMMENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch(state) {\n\t\t\t\t\tcase State.TEXT:\n\t\t\t\t\tcase State.ELEMENT:\n\n\t\t\t\t\t\tif(target) {\n\t\t\t\t\t\t\titem[target] = (member && member.max > 1) ? (token + '').split(/ +/) : token;\n\t\t\t\t\t\t\ttarget = void 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.unknownDepth = unknownDepth;\n\t\tthis.state = state;\n\t\tthis.item = item;\n\t\tthis.rule = rule;\n\t\tthis.member = member;\n\t\tthis.target = target;\n\t\tthis.stackPos = stackPos;\n\n\t\tchunk.free();\n\n\t\treturn(this.document);\n\t}\n\n\tdocument: any = {};\n\tprivate item = this.document;\n\tprivate rule?: Rule;\n\tprivate member?: RuleMember;\n\tprivate target?: string;\n\n\tprivate unknownType = new ComplexType();\n\tprivate unknownDepth = 0;\n\n\tprivate stackPos = 0;\n\tprivate ruleStack: (Rule | undefined)[] = [];\n\tprivate itemStack: any[] = [];\n\n\tprivate state = State.TEXT;\n\n}\n\n'cxml/src/schema/Element.ts'\n:import { ElementToken } from '../parser/Token';\n\nimport { ComplexType, ElementTypeConstructor } from './ComplexType';\nimport { Group } from './Group';\nimport { MemberSpec, MemberMeta, SimpleType, SimpleValue } from './Member';\n\nexport class SimpleElementSpec extends MemberSpec {\n\n\n\tmeta: SimpleElementMeta;\n\n}\n\n\n\nexport class ElementSpec extends MemberSpec {\n\n\n\tmeta?: ElementMeta;\n\n\tgroup?: Group;\n\n}\n\n\n\nexport class SimpleElementMeta extends MemberMeta {\n\n\n\tsubstitutes?: SimpleElementMeta;\n\n\n\ttoken: ElementToken;\n\n\ttype: SimpleType;\n\n}\n\n\n\nexport class ElementMeta<ElementClass extends ElementInstance = ElementInstance> extends MemberMeta {\n\n\tcreateProto() {\n\t\tif(!this.XMLType) {\n\t\t\tconst BaseType: ElementTypeConstructor = this.type.createProto<ElementClass>();\n\n\t\t\tthis.XMLType = class XMLType extends BaseType implements ElementInstance {\n\t\t\t\t_: ElementMeta<this>;\n\t\t\t} as ElementConstructor<ElementClass>;\n\n\t\t\tObject.defineProperty(this.XMLType.prototype, 'constructor', {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: true\n\t\t\t});\n\n\t\t\tObject.defineProperty(this.XMLType.prototype, '_', {\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: this,\n\t\t\t\twritable: true\n\t\t\t});\n\t\t}\n\n\t\treturn(this.XMLType);\n\t}\n\n\tXMLType?: ElementConstructor<ElementClass>;\n\n\n\tplaceholder?: ElementClass;\n\n\n\tsubstitutes?: ElementMeta;\n\n\n\ttoken: ElementToken;\n\n\ttype: ComplexType;\n\n}\n\n\n\nexport class ElementBase {}\n\n\n\nexport interface ElementInstance extends ElementBase {\n\n\n\t_: ElementMeta<this>;\n\n\n\t$?: SimpleValue;\n\n}\n\nexport interface ElementConstructor<ElementClass extends ElementInstance = ElementInstance> {\n\tnew(): ElementClass;\n};\n\n'cxml/src/builder/RuleSet.ts'\n:import { SimpleSchema } from '../schema/SimpleSchema';\nimport { ComplexType } from '../schema/ComplexType';\nimport { MemberSpec } from '../schema/Member';\nimport { ElementInstance, ElementMeta, ElementConstructor } from '../schema/Element';\n\nexport class Rule {\n\n\taddElement(member: RuleMember) {\n\t\tthis.elements[member.id] = member;\n\t}\n\n\taddAttribute(member: RuleMember) {\n\t\tthis.attributes[member.id] = member;\n\t}\n\n\telements: { [id: number]: RuleMember } = {};\n\tattributes: { [id: number]: RuleMember } = {};\n\n\tstatic string = new Rule();\n\n\tXMLType: ElementConstructor;\n\n}\n\nexport class RuleMember {\n\n\tconstructor(public rule: Rule, public spec: MemberSpec) {\n\t\tthis.id = spec.meta!.token.id!;\n\t\tthis.min = spec.min;\n\t\tthis.max = spec.max;\n\t}\n\n\tid: number;\n\tmin: number;\n\tmax: number;\n\n}\n\nfunction link<Type>(parent: Type) {\n\tfunction Result() {}\n\tResult.prototype = parent;\n\treturn(new (Result as any)());\n}\n\nexport interface RuleStack {\n\tmeta?: ElementMeta;\n\trule?: Rule;\n\tparent?: RuleStack;\n}\n\nexport class RuleSet {\n\n\tcreateRule(type: ComplexType, meta?: ElementMeta, parent?: RuleStack) {\n\t\tconst rule = new Rule();\n\t\tlet childRule: Rule | undefined;\n\t\tlet proto: { [key: string]: any } = {};\n\n\t\tif(meta) {\n\t\t\trule.XMLType = meta.createProto();\n\t\t\tproto = rule.XMLType.prototype;\n\t\t}\n\n\t\tif(type.elements && type.elements.group) {\n\t\t\tfor(let childSpec of type.elements.group.list) {\n\t\t\t\tconst memberMeta = childSpec.meta;\n\n\t\t\t\tif(memberMeta) {\n\t\t\t\t\tif(memberMeta instanceof ElementMeta) {\n\t\t\t\t\t\tchildRule = void 0;\n\n\t\t\t\t\t\tfor(let item = parent; item; item = item.parent) {\n\t\t\t\t\t\t\tif(item.meta == memberMeta) {\n\n\n\n\t\t\t\t\t\t\t\tchildRule = item.rule;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(!childRule) {\n\t\t\t\t\t\t\tchildRule = this.createRule(memberMeta.type, memberMeta, { meta, rule, parent });\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tlet fakeMeta = link(memberMeta);\n\t\t\t\t\t\tfakeMeta.exists = false;\n\n\t\t\t\t\t\tlet placeholder: ElementInstance | ElementInstance[] | null = new childRule.XMLType();\n\t\t\t\t\t\tplaceholder._ = fakeMeta;\n\t\t\t\t\t\tmemberMeta.placeholder = placeholder;\n\n\t\t\t\t\t\tif(childSpec.max > 1) {\n\n\t\t\t\t\t\t\tplaceholder = childSpec.min > 0 ? [ placeholder ] : [];\n\t\t\t\t\t\t} else if(childSpec.min < 1) {\n\t\t\t\t\t\t\tplaceholder = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(placeholder) {\n\t\t\t\t\t\t\tObject.defineProperty(proto, memberMeta.token.name, {\n\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\tenumerable: false,\n\t\t\t\t\t\t\t\tvalue: placeholder,\n\t\t\t\t\t\t\t\twritable: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else childRule = Rule.string;\n\n\t\t\t\t\trule.addElement(new RuleMember(childRule, childSpec));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(type.attributes) {\n\t\t\tfor(let attributeSpec of type.attributes.list) {\n\t\t\t\tconst memberMeta = attributeSpec.meta;\n\n\t\t\t\tif(memberMeta) {\n\n\n\t\t\t\t\tchildRule = Rule.string;\n\n\t\t\t\t\trule.addAttribute(new RuleMember(childRule, attributeSpec));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn(rule);\n\t}\n\n\tconstructor(public schema: SimpleSchema) {\n\t\tthis.rootRule = this.createRule(schema.document);\n\t}\n\n\trootRule: Rule;\n\n}\n",
        "gt": [
            "'cxml/src/schema/Group.ts'",
            "'cxml/src/schema/Element.ts'",
            "'cxml/src/builder/RuleSet.ts'",
            "'cxml/src/builder/BuilderConfig.ts'",
            "'cxml/src/builder/Builder.ts'"
        ]
    },
    {
        "files": [
            "'calendar-hack/src/components/PlanAndDate.tsx'",
            "'calendar-hack/src/index.tsx'",
            "'calendar-hack/src/ch/datecalc.ts'",
            "'calendar-hack/src/App.tsx'"
        ],
        "content": "'calendar-hack/src/components/PlanAndDate.tsx'\n:import React from \"react\";\nimport styled from \"styled-components\";\nimport { DateControl } from \"./DateControl\";\nimport PlanPicker from \"./PlanPicker\";\nimport { Units, PlanSummary } from \"types/app\";\nimport { WeekStartsOn } from \"../ch/datecalc\";\n\ninterface Props {\n  units: Units;\n  availablePlans: PlanSummary[];\n  selectedPlan: PlanSummary;\n  selectedDate: Date;\n  dateChangeHandler: (d: Date) => void;\n  selectedPlanChangeHandler: (p: PlanSummary) => void;\n  unitsChangeHandler: (u: Units) => void;\n  downloadHandler: () => void;\n  weekStartsOn: WeekStartsOn;\n}\n\nconst Title = styled.h3`\n  display: inline;\n  margin: 0 0.4em;\n  color: ${(props) => props.theme.colors.buttonBg};\n`;\n\nconst Root = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-wrap: wrap;\n  margin: 1em 0 5px 0;\n  color: ${(props) => props.theme.colors.controlsTitle};\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    flex-direction: column;\n  }\n`;\n\nconst PlanAndDate = ({\n  selectedPlan,\n  selectedPlanChangeHandler,\n  availablePlans,\n  selectedDate,\n  dateChangeHandler,\n  weekStartsOn,\n}: Props) => {\n  return (\n    <Root>\n      <PlanPicker\n        availablePlans={availablePlans}\n        selectedPlan={selectedPlan}\n        planChangeHandler={selectedPlanChangeHandler}\n      />\n      <Title>ending on</Title>\n      <DateControl\n        selectedDate={selectedDate}\n        onDateChanged={dateChangeHandler}\n        weekStartsOn={weekStartsOn}\n      />\n    </Root>\n  );\n};\n\nexport default PlanAndDate;\n\n'calendar-hack/src/index.tsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { DndProvider } from 'react-dnd-multi-backend'\nimport { HTML5toTouch } from 'rdndmb-html5-to-touch'\nimport { QueryParamProvider } from \"use-query-params\";\nimport { WindowHistoryAdapter } from \"use-query-params/adapters/window\";\nimport \"./css/reset.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <DndProvider options={HTML5toTouch}>\n      <QueryParamProvider adapter={WindowHistoryAdapter}>\n        <App />\n      </QueryParamProvider>\n    </DndProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n\n\n\nserviceWorker.unregister();\n\n'calendar-hack/src/ch/datecalc.ts'\n:import {\n  subDays,\n  startOfWeek,\n  endOfWeek,\n  startOfDay,\n  differenceInCalendarDays,\n} from \"date-fns\";\n\nimport { dayOfWeek, PlanDates } from \"types/app\";\n\nexport const WeekStartsOnValues = {\n  Sunday: 0,\n  Monday: 1,\n  Saturday: 6,\n} as const;\n\nexport type WeekStartsOn =\n  (typeof WeekStartsOnValues)[keyof typeof WeekStartsOnValues];\n\n\nexport function calcPlanDates(\n  numWeeksInPlan: number,\n  planEndsOn: Date,\n  weekStartsOn: WeekStartsOn\n): PlanDates {\n  const daysInPlan = numWeeksInPlan * 7;\n  const planStartsOn = subDays(planEndsOn, daysInPlan - 1);\n  const end = startOfDay(endOfWeek(planEndsOn, { weekStartsOn: weekStartsOn }));\n  const start = startOfDay(\n    startOfWeek(planStartsOn, { weekStartsOn: weekStartsOn })\n  );\n  const totalDays = 1 + differenceInCalendarDays(end, start);\n  if (0 !== totalDays % 7) {\n    throw new Error(\"total days %7 !==0: \" + totalDays);\n  }\n  const weekCount = totalDays / 7;\n  let result = {\n    start: start,\n    planStartDate: planStartsOn,\n    planEndDate: planEndsOn,\n    end: end,\n    weekCount: weekCount,\n  };\n  return result;\n}\n\nexport function getDaysHeader(weekStartsOn: WeekStartsOn): dayOfWeek[] {\n  if (weekStartsOn === WeekStartsOnValues.Monday) {\n    return [\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n      \"Sunday\",\n    ];\n  }\n  if (weekStartsOn === WeekStartsOnValues.Sunday) {\n    return [\n      \"Sunday\",\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n      \"Saturday\",\n    ];\n  } else {\n    return [\n      \"Saturday\",\n      \"Sunday\",\n      \"Monday\",\n      \"Tuesday\",\n      \"Wednesday\",\n      \"Thursday\",\n      \"Friday\",\n    ];\n  }\n}\n\n'calendar-hack/src/App.tsx'\n:import React, { useState } from \"react\";\nimport { repo } from \"./ch/planrepo\";\nimport { endOfWeek, addWeeks, isAfter } from \"date-fns\";\nimport { RacePlan } from \"./ch/dategrid\";\nimport { build, swap, swapDow } from \"./ch/planbuilder\";\nimport { CalendarGrid } from \"./components/CalendarGrid\";\nimport { ThemeProvider } from \"styled-components\";\nimport { toIcal, download } from \"./ch/icalservice\";\nimport UnitsButtons from \"./defy/components/UnitsButtons\";\nimport PlanAndDate from \"./components/PlanAndDate\";\nimport Toolbar from \"./defy/components/Toolbar\";\nimport styled from \"styled-components\";\nimport DownloadButton from \"./components/DownloadButton\";\nimport UndoButton from \"./components/UndoButton\";\nimport history from \"./defy/history\";\nimport {\n  useQueryParams,\n  StringParam,\n  DateParam,\n  NumberParam,\n} from \"use-query-params\";\nimport { PlanDetailsCard } from \"./components/PlanDetailsCard\";\nimport { WeekStartsOn, WeekStartsOnValues } from \"./ch/datecalc\";\nimport WeekStartsOnPicker from \"./components/WeekStartsOnPicker\";\nimport { useMountEffect } from \"./ch/hooks\";\nimport { Units, PlanSummary, dayOfWeek } from \"types/app\";\nimport { getLocaleUnits } from \"./ch/localize\";\n\nconst theme = {\n  colors: {\n    bodyBg: \"#B8E2E6\",\n    title: \"#424242\",\n    buttonBg: \"#E3F7F8\",\n    buttonIcons: \"#E3F7F8\",\n    buttonTxt: \"#424242\",\n    buttonSelectedBorder: \"#FF6FDF\",\n    dowHeaderBg: \"#C2C5EB\",\n    weekSummaryBg: \"#C2C5EB\",\n    workoutCardBg: \"#E3F7F8\",\n    workoutCardBlankBg: \"#e9ecef\",\n    datelineBg: \"#B391D2\",\n    datelineBlankBg: \"#beafd2\",\n    datelineTxt: \"#424242\",\n    planDescriptionBg: \"#E3F7F8\",\n    planDescriptionTxt: \"#424242\",\n  },\n  fonts: [\"sans-serif\", \"Roboto\"],\n  fontSizes: {\n    small: \"1em\",\n    medium: \"2em\",\n    large: \"3em\",\n  },\n  screenSizes: {\n    sm: \"576px\",\n    md: \"768px\",\n    lg: \"992px\",\n    xl: \"1200px\",\n  },\n};\n\nconst MainUI = styled.div`\n  margin-top: 2em;\n`;\n\nconst SecondToolbar = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-wrap: wrap;\n  margin: 1em 0 5px 0;\n  color: ${(props) => props.theme.colors.controlsTitle};\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    flex-direction: column;\n  }\n`;\nconst UnitsDiv = styled.div`\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    margin-top: 0.5em;\n  }\n`;\n\nconst App = () => {\n  const [{ u, p, d, s }, setq] = useQueryParams({\n    u: StringParam,\n    p: StringParam,\n    d: DateParam,\n    s: NumberParam,\n  });\n  const [selectedUnits, setSelectedUnits] = useState<Units>(\n    u === \"mi\" || u === \"km\" ? u : getLocaleUnits()\n  );\n  var [selectedPlan, setSelectedPlan] = useState(repo.find(p || \"\"));\n  var [racePlan, setRacePlan] = useState<RacePlan | undefined>(undefined);\n  var [undoHistory, setUndoHistory] = useState([] as RacePlan[]);\n  var [weekStartsOn, setWeekStartsOn] = useState<WeekStartsOn>(\n    s === 0 || s === 1 || s === 6 ? s : WeekStartsOnValues.Monday\n  );\n  var [planEndDate, setPlanEndDate] = useState(\n    d && isAfter(d, new Date())\n      ? d\n      : addWeeks(endOfWeek(new Date(), { weekStartsOn: weekStartsOn }), 20)\n  );\n\n  useMountEffect(() => {\n    initialLoad(selectedPlan, planEndDate, selectedUnits, weekStartsOn);\n  });\n\n  const [, forceUpdate] = React.useReducer((x) => x + 1, 0);\n  React.useEffect(() => {\n\n    history.listen(() => {\n      forceUpdate();\n    });\n  }, []);\n\n  const getParams = (\n    units: Units,\n    plan: PlanSummary,\n    date: Date,\n    weekStartsOn: WeekStartsOn\n  ) => {\n    return {\n      u: units,\n      p: plan[0],\n      d: date,\n      s: weekStartsOn,\n    };\n  };\n\n  const initialLoad = async (\n    plan: PlanSummary,\n    endDate: Date,\n    units: Units,\n    weekStartsOn: WeekStartsOn\n  ) => {\n    const racePlan = build(await repo.fetch(plan), endDate, weekStartsOn);\n    setRacePlan(racePlan);\n    setUndoHistory([...undoHistory, racePlan]);\n    setq(getParams(units, plan, endDate, weekStartsOn));\n  };\n\n  const onSelectedPlanChange = async (plan: PlanSummary) => {\n    const racePlan = build(await repo.fetch(plan), planEndDate, weekStartsOn);\n    setSelectedPlan(plan);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, plan, planEndDate, weekStartsOn));\n  };\n\n  const onSelectedEndDateChange = async (date: Date) => {\n    const racePlan = build(await repo.fetch(selectedPlan), date, weekStartsOn);\n    setPlanEndDate(date);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, selectedPlan, date, weekStartsOn));\n  };\n\n  const onSelectedUnitsChanged = (u: Units) => {\n    setSelectedUnits(u);\n    setq(getParams(u, selectedPlan, planEndDate, weekStartsOn));\n  };\n\n  const onWeekStartsOnChanged = async (v: WeekStartsOn) => {\n    const racePlan = build(await repo.fetch(selectedPlan), planEndDate, v);\n    setWeekStartsOn(v);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, selectedPlan, planEndDate, v));\n  };\n\n  function swapDates(d1: Date, d2: Date): void {\n    if (racePlan) {\n      const newRacePlan = swap(racePlan, d1, d2);\n      setRacePlan(newRacePlan);\n      setUndoHistory([...undoHistory, newRacePlan]);\n    }\n  }\n\n  function doSwapDow(dow1: dayOfWeek, dow2: dayOfWeek) {\n    if (racePlan) {\n      const newRacePlan = swapDow(racePlan, dow1, dow2);\n      setRacePlan(newRacePlan);\n      setUndoHistory([...undoHistory, newRacePlan]);\n    }\n  }\n\n  function downloadHandler() {\n    if (racePlan) {\n      const iCalEventsStr = toIcal(racePlan, selectedUnits);\n      if (iCalEventsStr) {\n        download(iCalEventsStr, \"plan\", \"ics\");\n      }\n    }\n  }\n\n  function undoHandler() {\n    if (undoHistory?.length >= 0) {\n      undoHistory.pop();\n    }\n    setRacePlan(undoHistory[undoHistory.length - 1]);\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <Toolbar downloadHandler={downloadHandler} />\n      <PlanAndDate\n        units={selectedUnits}\n        availablePlans={repo.available}\n        selectedPlan={selectedPlan}\n        selectedDate={planEndDate}\n        dateChangeHandler={onSelectedEndDateChange}\n        selectedPlanChangeHandler={onSelectedPlanChange}\n        unitsChangeHandler={onSelectedUnitsChanged}\n        downloadHandler={downloadHandler}\n        weekStartsOn={weekStartsOn}\n      />\n      <SecondToolbar>\n        <UnitsDiv>\n          <UnitsButtons\n            units={selectedUnits}\n            unitsChangeHandler={onSelectedUnitsChanged}\n          />\n        </UnitsDiv>\n      </SecondToolbar>\n      <SecondToolbar>\n        <DownloadButton downloadHandler={downloadHandler} />\n        <UndoButton\n          disabled={undoHistory.length <= 1}\n          undoHandler={undoHandler}\n        />\n      </SecondToolbar>\n      <PlanDetailsCard racePlan={racePlan} />\n      <SecondToolbar>\n        <WeekStartsOnPicker\n          weekStartsOn={weekStartsOn}\n          changeHandler={onWeekStartsOnChanged}\n        />\n      </SecondToolbar>\n      <MainUI>\n        {racePlan && (\n          <CalendarGrid\n            racePlan={racePlan}\n            units={selectedUnits}\n            weekStartsOn={weekStartsOn}\n            swapDates={swapDates}\n            swapDow={doSwapDow}\n          />\n        )}\n      </MainUI>\n    </ThemeProvider>\n  );\n};\n\nexport default App;\n",
        "gt": [
            "'calendar-hack/src/ch/datecalc.ts'",
            "'calendar-hack/src/components/PlanAndDate.tsx'",
            "'calendar-hack/src/App.tsx'",
            "'calendar-hack/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'extension/src/pages/overlay/components/Buttons.tsx'",
            "'extension/src/components/Tooltip.tsx'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'"
        ],
        "content": "'extension/src/pages/overlay/components/Buttons.tsx'\n:import { useMemo } from \"react\";\n\nimport Tooltip from \"../../../components/Tooltip\";\n\nimport { classes } from \"../../../utils/classes\";\n\ntype ButtonsOptions = Readonly<\n  {\n    key: string;\n    type: \"primary\" | \"secondary\";\n    icon: (props: { size: number; className?: string }) => JSX.Element;\n    title: string;\n  }[]\n>;\n\ninterface ButtonsProps<T extends ButtonsOptions> {\n  options: T;\n  onClick: (key: T[number][\"key\"] | \"\") => void;\n  active?: string;\n}\n\nexport default function Buttons<T extends ButtonsOptions = ButtonsOptions>(\n  props: ButtonsProps<T>,\n) {\n  const { options, onClick, active } = props;\n\n\n  const optionsWithOnClick = useMemo(\n    () =>\n      options\n        .map((option) => ({\n          ...option,\n          onClick: () => onClick(active === option.key ? \"\" : option.key),\n          active: active === option.key,\n        }))\n        .sort((a, b) => {\n          if (a.type === b.type) return 0;\n          return a.type === \"primary\" ? -1 : 1;\n        }),\n    [options, onClick, active],\n  );\n\n  return (\n    <div className=\"z-10 mt-12 flex flex-col gap-4\">\n      {optionsWithOnClick.map((option, idx) => (\n        <Tooltip key={option.key} text={option.title}>\n          <button\n            onClick={option.onClick}\n            className={classes(\n              \"bg-alveus-green outline-highlight flex cursor-pointer items-center justify-center rounded-lg p-2 shadow transition-[outline,filter] hover:outline hover:brightness-125 focus:outline\",\n              option.type === \"primary\" ? \"h-16 w-16\" : \"h-12 w-12\",\n              option.active && \"outline\",\n\n              idx > 0 &&\n                optionsWithOnClick[idx - 1].type !== option.type &&\n                \"mt-auto\",\n            )}\n          >\n            <option.icon\n              size={option.type === \"primary\" ? 48 : 32}\n              className=\"h-full w-full\"\n            />\n          </button>\n        </Tooltip>\n      ))}\n    </div>\n  );\n}\n\n'extension/src/components/Tooltip.tsx'\n:import {\n  useCallback,\n  useRef,\n  useState,\n  type MouseEvent,\n  useMemo,\n  useId,\n  type FocusEvent,\n  Children,\n  isValidElement,\n  cloneElement,\n} from \"react\";\n\nimport { classes } from \"../utils/classes\";\nimport { mutableDOMRect } from \"../utils/dom\";\n\ninterface TooltipProps {\n  text: string;\n  children: React.ReactNode;\n  fontSize?: string;\n  maxWidth?: string;\n}\n\nconst Tooltip = (props: TooltipProps) => {\n  const { text, children, fontSize, maxWidth } = props;\n\n  const id = useId();\n  const tooltipRef = useRef<HTMLDivElement>(null);\n  const [show, setShow] = useState(false);\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n  const [above, setAbove] = useState(false);\n  const [triangleMargin, setTriangleMargin] = useState<string>();\n\n\n  const handleEnter = useCallback(\n    (e: MouseEvent<HTMLElement> | FocusEvent<HTMLElement>) => {\n      if (!tooltipRef.current) return;\n\n      const target = e.currentTarget as HTMLElement;\n      const rect = mutableDOMRect(target.getBoundingClientRect());\n\n      const offsetRect = target.offsetParent?.getBoundingClientRect();\n      if (offsetRect) {\n        rect.top -= offsetRect.top;\n        rect.bottom -= offsetRect.top;\n        rect.left -= offsetRect.left;\n        rect.right -= offsetRect.left;\n      }\n\n      const tooltipRect = tooltipRef.current.getBoundingClientRect();\n\n      if (rect.right + tooltipRect.width > window.innerWidth) {\n\n        setAbove(true);\n        setPosition({\n          top: rect.top - rect.height / 2 - tooltipRect.height,\n          left: window.innerWidth / 2 - tooltipRect.width / 2,\n        });\n\n        setTriangleMargin(`0 ${window.innerWidth / 2 - rect.right + 5}px 0 0`);\n      } else {\n\n        setAbove(false);\n        setPosition({\n          top: rect.top + rect.height / 2 - tooltipRect.height / 2,\n          left: rect.right + 10,\n        });\n\n        setTriangleMargin(\"-5px 0 0\");\n      }\n      setShow(true);\n    },\n    [],\n  );\n\n\n  const style = useMemo(\n    () => ({\n      opacity: show ? 1 : 0,\n      top: position.top,\n      left: position.left,\n      maxWidth,\n      fontSize,\n    }),\n    [show, position, maxWidth, fontSize],\n  );\n\n\n  const childrenWithProps = useMemo(\n    () =>\n      Children.map(children, (child) => {\n        if (!isValidElement(child)) return child;\n\n        return cloneElement(child as React.ReactElement, {\n          onMouseEnter: handleEnter,\n          onFocus: handleEnter,\n          onMouseLeave: () => setShow(false),\n          onBlur: () => setShow(false),\n          \"aria-describedby\": id,\n        });\n      }),\n    [children, handleEnter, id],\n  );\n\n  return (\n    <>\n      {childrenWithProps}\n      <div\n        className=\"pointer-events-none fixed z-10 w-max rounded-lg bg-black/50 p-2 shadow-lg backdrop-blur transition-opacity\"\n        ref={tooltipRef}\n        style={style}\n        id={id}\n        role=\"tooltip\"\n      >\n        <div\n          className={classes(\n            \"absolute border-[5px] border-solid border-transparent\",\n            above\n              ? \"right-1/2 top-full border-t-black/50\"\n              : \"right-full top-1/2 border-r-black/50\",\n          )}\n          style={{ margin: triangleMargin }}\n        />\n        {text}\n      </div>\n    </>\n  );\n};\n\nexport default Tooltip;\n\n'extension/src/pages/overlay/components/overlay/Settings.tsx'\n:import { typeSafeObjectEntries } from \"../../../../utils/helpers\";\nimport { classes } from \"../../../../utils/classes\";\n\nimport useSettings from \"../../hooks/useSettings\";\n\nimport Card from \"../../../../components/Card\";\nimport Toggle from \"../Toggle\";\n\nimport type { OverlayOptionProps } from \"./Overlay\";\n\nexport default function Settings(props: OverlayOptionProps) {\n  const { className } = props;\n  const settings = useSettings();\n\n  return (\n    <Card\n      className={classes(\"absolute left-0 top-0 mx-4 my-6\", className)}\n      title=\"Extension Settings\"\n    >\n      <ul className=\"flex flex-col gap-4\">\n        {typeSafeObjectEntries(settings).map(([key, setting]) => {\n          if (!setting.configurable) return null;\n\n          return (\n            <li key={key} className=\"flex items-center\">\n              {setting.type === \"boolean\" && (\n                <Toggle\n                  label={setting.title}\n                  value={setting.value as boolean}\n                  onChange={setting.change as (value: boolean) => void}\n                />\n              )}\n            </li>\n          );\n        })}\n      </ul>\n    </Card>\n  );\n}\n\n'extension/src/pages/overlay/components/overlay/Overlay.tsx'\n:import {\n  useEffect,\n  useRef,\n  useCallback,\n  useState,\n  useMemo,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\nimport Welcome from \"../../../../components/Welcome\";\nimport IconWelcome from \"../../../../components/icons/IconWelcome\";\nimport IconAmbassadors from \"../../../../components/icons/IconAmbassadors\";\nimport IconSettings from \"../../../../components/icons/IconSettings\";\n\nimport {\n  isAmbassadorKey,\n  type AmbassadorKey,\n} from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\nimport { visibleUnderCursor } from \"../../../../utils/dom\";\n\nimport useChatCommand from \"../../../../hooks/useChatCommand\";\n\nimport useSettings from \"../../hooks/useSettings\";\nimport useSleeping from \"../../hooks/useSleeping\";\n\nimport AmbassadorsOverlay from \"./Ambassadors\";\nimport SettingsOverlay from \"./Settings\";\n\nimport Buttons from \"../Buttons\";\n\n\nconst commandTimeout = 10_000;\n\nconst overlayOptions = [\n  {\n    key: \"welcome\",\n    type: \"primary\",\n    icon: IconWelcome,\n    title: \"Welcome to Alveus\",\n    component: (props: OverlayOptionProps) => (\n      <Welcome\n        className={classes(\"absolute left-0 top-0 mx-4 my-6\", props.className)}\n      />\n    ),\n  },\n  {\n    key: \"ambassadors\",\n    type: \"primary\",\n    icon: IconAmbassadors,\n    title: \"Explore our Ambassadors\",\n    component: AmbassadorsOverlay,\n  },\n  {\n    key: \"settings\",\n    type: \"secondary\",\n    icon: IconSettings,\n    title: \"Extension Settings\",\n    component: SettingsOverlay,\n  },\n] as const;\n\nexport const isValidOverlayKey = (key: string) =>\n  key === \"\" || overlayOptions.some((option) => option.key === key);\n\nexport type OverlayKey = (typeof overlayOptions)[number][\"key\"] | \"\";\n\ntype ActiveAmbassadorState = {\n  key?: AmbassadorKey;\n  isCommand?: boolean;\n};\n\nexport interface OverlayOptionProps {\n  context: {\n    activeAmbassador: ActiveAmbassadorState;\n    setActiveAmbassador: Dispatch<SetStateAction<ActiveAmbassadorState>>;\n  };\n  className?: string;\n}\n\nconst hiddenClass =\n  \"invisible opacity-0 -translate-x-10 motion-reduce:translate-x-0\";\n\nexport default function Overlay() {\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n  const [activeAmbassador, setActiveAmbassador] =\n    useState<ActiveAmbassadorState>({});\n  const [visibleOption, setVisibleOption] = useState<OverlayKey>(\n    settings.openedMenu.value,\n  );\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const awakingRef = useRef(false);\n\n\n  useEffect(() => {\n    settings.openedMenu.change(visibleOption);\n  }, [visibleOption]);\n\n\n  useEffect(() => {\n    setVisibleOption(settings.openedMenu.value);\n  }, [settings.openedMenu.value]);\n\n\n  useChatCommand(\n    useCallback(\n      (command: string) => {\n        if (!settings.disableChatPopup.value) {\n          if (isAmbassadorKey(command))\n            setActiveAmbassador({ key: command, isCommand: true });\n          else if (command !== \"welcome\") return;\n\n\n          setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n\n          if (timeoutRef.current) clearTimeout(timeoutRef.current);\n          timeoutRef.current = setTimeout(() => {\n            setVisibleOption(\"\");\n            setActiveAmbassador({});\n          }, commandTimeout);\n\n\n          awakingRef.current = true;\n          wake(commandTimeout);\n        }\n      },\n      [settings.disableChatPopup.value, wake],\n    ),\n  );\n\n\n  useEffect(\n    () => () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    },\n    [],\n  );\n\n\n\n  useEffect(() => {\n    const callback = () => {\n      if (awakingRef.current) awakingRef.current = false;\n      else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    };\n    addSleepListener(\"wake\", callback);\n    return () => removeSleepListener(\"wake\", callback);\n  }, [addSleepListener, removeSleepListener]);\n\n\n  const bodyClick = useCallback((e: MouseEvent) => {\n    if (!visibleUnderCursor(e)) {\n      setVisibleOption(\"\");\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"click\", bodyClick, true);\n    return () => document.body.removeEventListener(\"click\", bodyClick, true);\n  }, [bodyClick]);\n\n\n  const bodyDblClick = useCallback((e: MouseEvent) => {\n    if (visibleUnderCursor(e)) {\n      e.stopPropagation();\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n    return () =>\n      document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n  }, [bodyDblClick]);\n\n\n  const context = useMemo<OverlayOptionProps[\"context\"]>(\n    () => ({\n      activeAmbassador,\n      setActiveAmbassador,\n    }),\n    [activeAmbassador],\n  );\n\n  return (\n    <div\n      className={classes(\n        \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          ) &&\n          hiddenClass,\n      )}\n    >\n      <Buttons\n        options={overlayOptions}\n        onClick={setVisibleOption}\n        active={visibleOption}\n      />\n      <div className=\"relative h-full w-full\">\n        {overlayOptions.map((option) => (\n          <option.component\n            key={option.key}\n            context={context}\n            className={classes(\n              \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n              visibleOption !== option.key && hiddenClass,\n            )}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n",
        "gt": [
            "'extension/src/components/Tooltip.tsx'",
            "'extension/src/pages/overlay/components/Buttons.tsx'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'"
        ]
    },
    {
        "files": [
            "'alienworlds-api/src/handlers/tracehandler.ts'",
            "'alienworlds-api/src/include/statsdisplay.ts'",
            "'alienworlds-api/src/filler.ts'"
        ],
        "content": "'alienworlds-api/src/handlers/tracehandler.ts'\n:import { StatsDisplay } from '../include/statsdisplay';\nconst { Api, JsonRpc, Serialize } = require('eosjs');\n\n\nexport class TraceHandler {\n  config: any;\n  eos_rpc: typeof JsonRpc;\n  eos_api: typeof Api;\n  abis: Array<any>;\n  current_abi: String;\n  amq: any;\n  stats: StatsDisplay;\n  filtered_actions: Array<string>;\n  abi_update_action = 'eosio::setabi';\n\n  constructor({ config, amq, stats }) {\n    this.config = config;\n    this.amq = amq;\n    this.stats = stats;\n\n    const fetch = require('node-fetch');\n    this.eos_rpc = new JsonRpc(config.endpoints[0], { fetch });\n    this.eos_api = new Api({\n      rpc: this.eos_rpc,\n      signatureProvider: null,\n      textDecoder: new TextDecoder(),\n      textEncoder: new TextEncoder(),\n    });\n\n    this.filtered_actions = [\n      `${this.config.notify_contract}::logmine`,\n      `${this.config.mining_contract}::logmine`,\n      `${this.config.mining_contract}::logrand`,\n      `${this.config.atomicassets.contract}::logtransfer`,\n      `${this.config.atomicassets.contract}::logburn`,\n      `${this.config.atomicassets.contract}::logmint`,\n      this.abi_update_action,\n    ];\n  }\n\n  int32ToBuffer(num) {\n    const arr = Buffer.alloc(4);\n    arr.writeUInt32BE(num, 0);\n    return arr;\n  }\n\n  handleTrace(block_num, block_timestamp, trace) {\n    const [api_message, trx] = trace;\n\n    if (api_message === 'transaction_trace_v0') {\n      this.stats.add('txs');\n      for (const action of trx.action_traces) {\n        this.handleAction(block_num, block_timestamp, trx, action);\n      }\n    }\n  }\n\n  serialize(block_num, block_timestamp, trx, trace) {\n    const sb_action = new Serialize.SerialBuffer({\n      textEncoder: new TextEncoder(),\n      textDecoder: new TextDecoder(),\n    });\n\n    sb_action.pushName(trace.act.account);\n    sb_action.pushName(trace.act.name);\n    sb_action.pushBytes(trace.act.data);\n\n    const block_buffer = Buffer.allocUnsafe(8);\n    block_buffer.writeBigInt64BE(BigInt(block_num), 0);\n    const timestamp_buffer = this.int32ToBuffer(\n      block_timestamp.getTime() / 1000\n    );\n    const trx_id_buffer = Buffer.from(trx.id, 'hex');\n    const recv_buffer = Buffer.allocUnsafe(8);\n    recv_buffer.writeBigInt64BE(BigInt(trace.receipt[1].recv_sequence), 0);\n    const global_buffer = Buffer.allocUnsafe(8);\n    global_buffer.writeBigInt64BE(BigInt(trace.receipt[1].global_sequence), 0);\n\n    const action_buffer = Buffer.from(sb_action.array);\n\n\n    return Buffer.concat([\n      block_buffer,\n      timestamp_buffer,\n      trx_id_buffer,\n      recv_buffer,\n      global_buffer,\n      action_buffer,\n    ]);\n  }\n\n  setabiConcernsUs(trace) {\n    const account = trace.act.data.account;\n    return account && this.config.abi_fetch_contracts.includes(account);\n  }\n\n  handleAction(block_num, block_timestamp, trx, action) {\n    const [api_message, trace] = action;\n\n    if (\n      api_message === 'action_trace_v0' ||\n      api_message === 'action_trace_v1'\n    ) {\n      this.stats.add('actions');\n\n\n      if (trace.receiver !== trace.act.account) return;\n\n      const action_name = `${trace.receiver}::${trace.act.name}`;\n\n      if (!this.filtered_actions.includes(action_name)) return;\n\n      if (\n        action_name === this.abi_update_action &&\n        !this.setabiConcernsUs(trace)\n      )\n        return;\n\n      const buffers = this.serialize(block_num, block_timestamp, trx, trace);\n      this.amq.send('action', buffers);\n      this.stats.add(trace.act.name);\n    }\n  }\n\n  async processTrace(block_num, traces, block_timestamp) {\n    this.stats.add('blocks');\n    for (const trace of traces) {\n      this.handleTrace(block_num, block_timestamp, trace);\n    }\n  }\n}\n\n'alienworlds-api/src/include/statsdisplay.ts'\n:export class StatsDisplay {\n  interval: number;\n  buckets: object;\n\n  constructor(interval = 5) {\n    this.interval = interval;\n    setInterval(() => {\n      this.display();\n    }, this.interval * 1000);\n    this.buckets = {};\n  }\n\n  add(name, count = 1) {\n    if (typeof this.buckets[name] === 'undefined') {\n      this.buckets[name] = 0;\n    }\n    this.buckets[name] += count;\n  }\n\n  display() {\n    const items = [];\n    for (let name in this.buckets) {\n      const rate = (this.buckets[name] / this.interval).toFixed(2);\n      items.push(`${name} : ${rate}/s`);\n      this.buckets[name] = 0;\n    }\n    const str = `[${process.pid}] ` + items.join(' | ') || 'No data';\n    console.log(str);\n  }\n}\n\n'alienworlds-api/src/filler.ts'\n:\n\nconst newrelic = require('newrelic');\nconst StateReceiver = require('@eosdacio/eosio-statereceiver');\nimport { Amq } from './connections/amq';\nimport { connectMongo } from './connections/mongo';\nimport { StatsDisplay } from './include/statsdisplay';\nimport { TraceHandler } from './handlers/tracehandler';\n\nimport { program } from 'commander';\nimport fetch from 'node-fetch';\n\nclass AlienAPIFiller {\n  state_receiver: typeof StateReceiver;\n  config: any;\n  options: any;\n  mongo: any;\n  stats: any;\n  amq: any;\n\n  constructor(\n    config: any,\n    options: any,\n    amq: Amq,\n    mongo: unknown,\n    stats: StatsDisplay\n  ) {\n    console.log(`Constructing...`, config, options);\n\n    this.config = config;\n    this.options = options;\n    this.mongo = mongo;\n    this.stats = stats;\n    this.amq = amq;\n  }\n\n  async start() {\n    let startBlock = this.config.start_block;\n    let endBlock = 0xffffffff;\n\n    console.log('New Relic App Name: [' + process.env.NEW_RELIC_APP_NAME + ']');\n\n    if (this.options.startBlock === -1) {\n      console.log(`Finding start block from DB`);\n\n\n      const col = this.mongo.collection('mines');\n      const res = await col.findOne({}, { limit: 1, sort: { block_num: -1 } });\n\n      if (res && res.block_num) {\n        startBlock = res.block_num;\n      }\n    } else {\n      startBlock = this.options.startBlock;\n    }\n    if (this.options.endBlock !== endBlock) {\n      endBlock = this.options.endBlock;\n    }\n    console.log(`Starting from ${startBlock}, ending at ${endBlock}`);\n\n    if (this.options.replay) {\n      console.log(\n        `Kicking off parallel replay, make sure you start a filler instance after this replay is complete`\n      );\n      let lib: number;\n      if (endBlock === 0xffffffff) {\n        lib = await this.fetchLastIrreversableBlockNum();\n      }\n\n      await this.replay(startBlock, lib);\n      if (this.options.continueWithFiller) {\n        console.log(\n          'Prepare the startBlock and endBlock to continue a filler after the replay has been scheduled instead of exiting the process.'\n        );\n        startBlock = lib;\n        endBlock === 0xffffffff;\n      } else {\n        process.exit(0);\n      }\n    }\n\n    const statereceiver_config = {\n      eos: {\n        wsEndpoint: this.config.ship_endpoints[0],\n        chainId: this.config.chain_id,\n        endpoint: this.config.endpoints[0],\n      },\n    };\n\n\n    const trace_handler = new TraceHandler({\n      config: this.config,\n      amq: this.amq,\n      stats: this.stats,\n    });\n\n\n    this.state_receiver = new StateReceiver({\n      startBlock,\n      endBlock,\n      mode: 0,\n      config: statereceiver_config,\n    });\n    this.state_receiver.registerTraceHandler(trace_handler);\n\n    this.state_receiver.start();\n  }\n\n  async replay(startBlock: number, endBlock: number) {\n\n\n    const chunk_size = 10000;\n    let from = startBlock;\n    let to = from + chunk_size;\n    let break_now = false;\n    let number_jobs = 0;\n\n    const send_promises = [];\n\n    while (true) {\n\n\n\n      process.stdout.write('.');\n\n      const from_buffer = Buffer.allocUnsafe(8);\n      from_buffer.writeBigInt64BE(BigInt(from), 0);\n\n      const to_buffer = Buffer.allocUnsafe(8);\n      to_buffer.writeBigInt64BE(BigInt(to), 0);\n\n      send_promises.push(\n        this.amq.send('aw_block_range', Buffer.concat([from_buffer, to_buffer]))\n      );\n      number_jobs++;\n\n      if (to === endBlock) {\n        break_now = true;\n      }\n\n      from += chunk_size;\n      to += chunk_size;\n\n      if (to > endBlock) {\n        to = endBlock;\n      }\n\n      if (from > to) {\n        break_now = true;\n      }\n\n      if (break_now) {\n        break;\n      }\n    }\n\n    console.log(`Added ${number_jobs} jobs`);\n\n    await Promise.all(send_promises);\n  }\n\n  private async fetchLastIrreversableBlockNum() {\n    console.log(\n      `Fetching lib from ${this.config.endpoints[0]}/v1/chain/get_info`\n    );\n    const info_res = await fetch(\n      `${this.config.endpoints[0]}/v1/chain/get_info`\n    );\n    const json = await info_res.json();\n    const lib: number = json.last_irreversible_block_num;\n    return lib;\n  }\n}\n\nconst commanderParseInt = (value: string, _: any) => {\n\n  const parsedValue = parseInt(value, 10);\n  if (isNaN(parsedValue)) {\n    throw new Error('Not a number.');\n  }\n  return parsedValue;\n};\n\n(async () => {\n  const config = require(`./config`);\n\n  const stats = new StatsDisplay();\n\n  const amq = new Amq(config.amq);\n  await amq.init();\n\n  const mongo = await connectMongo(config.mongo);\n\n  program\n    .version('0.1', '-v, --version')\n    .option(\n      '-s, --start-block <start-block>',\n      'Start at this block',\n      commanderParseInt,\n      -1\n    )\n    .option(\n      '-t, --test <block>',\n      'Test mode, specify a single block to pull and process',\n      commanderParseInt,\n      0\n    )\n    .option(\n      '-e, --end-block <end-block>',\n      'End block (exclusive)',\n      commanderParseInt,\n      4294967295\n    )\n    .option(\n      '-r, --replay',\n      'Force replay (ignore head block).  This option will populate a blockrange queue (must specify start block too)',\n      false\n    )\n    .option(\n      '-c, --continue-with-filler',\n      'used with --replay.  This option will set a serial filler to continure after the batch',\n      false\n    )\n    .parse(process.argv);\n\n  const options = program.opts();\n\n\n  const api = new AlienAPIFiller(config, options, amq, mongo, stats);\n  await api.start();\n})();\n",
        "gt": [
            "'alienworlds-api/src/include/statsdisplay.ts'",
            "'alienworlds-api/src/handlers/tracehandler.ts'",
            "'alienworlds-api/src/filler.ts'"
        ]
    },
    {
        "files": [
            "'ionicstart-snapaday/src/app/home/ui/photo-list/photo-list.component.ts'",
            "'ionicstart-snapaday/src/app/home/home.component.ts'",
            "'ionicstart-snapaday/src/app/home/home.component.spec.ts'"
        ],
        "content": "'ionicstart-snapaday/src/app/home/ui/photo-list/photo-list.component.ts'\n:import { CommonModule } from '@angular/common';\nimport {\n  ChangeDetectionStrategy,\n  Component,\n  EventEmitter,\n  Input,\n  NgModule,\n  Output,\n} from '@angular/core';\nimport { IonicModule } from '@ionic/angular';\nimport { Photo } from '../../../shared/interfaces/photo';\nimport { DaysAgoPipeModule } from '../days-ago/days-ago.pipe';\n\n@Component({\n  selector: 'app-photo-list',\n  template: `\n    <ion-list data-test=\"photo-list\" lines=\"none\">\n      <ion-item-sliding *ngFor=\"let photo of photos; trackBy: trackByFn\">\n        <ion-item data-test=\"photo\">\n          <img [src]=\"photo.safeResourceUrl\" />\n          <ion-badge data-test=\"days-ago-label\" slot=\"end\" color=\"light\">\n            {{ photo.dateTaken | daysAgo }}\n          </ion-badge>\n        </ion-item>\n        <ion-item-options side=\"end\">\n          <ion-item-option\n            data-test=\"delete-photo-button\"\n            (click)=\"delete.emit(photo.name)\"\n            color=\"danger\"\n          >\n            <ion-icon name=\"trash\" slot=\"icon-only\"></ion-icon>\n          </ion-item-option>\n        </ion-item-options>\n      </ion-item-sliding>\n    </ion-list>\n  `,\n  styles: [\n    `\n      ion-list {\n        padding: 0;\n      }\n\n      ion-item-sliding {\n        margin-bottom: 2px;\n      }\n\n      ion-item {\n        --inner-padding-end: 0px;\n        --padding-start: 0px;\n\n        img {\n          width: 100%;\n          height: auto;\n        }\n      }\n\n      ion-badge {\n        position: absolute;\n        right: 10px;\n        top: 10px;\n      }\n    `,\n  ],\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class PhotoListComponent {\n  @Input() photos!: Photo[];\n  @Output() delete = new EventEmitter<string>();\n\n  constructor() {}\n\n  trackByFn(index: number, photo: Photo) {\n    return photo.name;\n  }\n}\n\n@NgModule({\n  imports: [CommonModule, IonicModule, DaysAgoPipeModule],\n  declarations: [PhotoListComponent],\n  exports: [PhotoListComponent],\n})\nexport class PhotoListComponentModule {}\n\n'ionicstart-snapaday/src/app/home/home.component.ts'\n:import { CommonModule } from '@angular/common';\nimport { ChangeDetectionStrategy, Component, NgModule } from '@angular/core';\nimport { DomSanitizer } from '@angular/platform-browser';\nimport { RouterModule } from '@angular/router';\nimport { IonicModule, IonRouterOutlet } from '@ionic/angular';\nimport { BehaviorSubject, combineLatest } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { SlideshowComponentModule } from '../slideshow/slideshow.component';\nimport { PhotoService } from './data-access/photo/photo.service';\nimport { PhotoListComponentModule } from './ui/photo-list/photo-list.component';\n\n@Component({\n  selector: 'app-home',\n  template: `\n    <ng-container *ngIf=\"vm$ | async as vm\">\n      <ion-header>\n        <ion-toolbar color=\"danger\">\n          <ion-title>Snapaday</ion-title>\n          <ion-buttons slot=\"end\">\n            <ion-button\n              [disabled]=\"vm.hasTakenPhotoToday === true\"\n              (click)=\"photoService.takePhoto()\"\n              data-test=\"take-photo-button\"\n            >\n              <ion-icon name=\"camera-outline\" slot=\"icon-only\"></ion-icon>\n            </ion-button>\n            <ion-button\n              data-test=\"slideshow-button\"\n              (click)=\"modalIsOpen$.next(true)\"\n            >\n              <ion-icon name=\"play\" slot=\"icon-only\"></ion-icon>\n            </ion-button>\n          </ion-buttons>\n        </ion-toolbar>\n      </ion-header>\n      <ion-content>\n        <app-photo-list\n          [photos]=\"vm.photos\"\n          (delete)=\"photoService.deletePhoto($event)\"\n        ></app-photo-list>\n        <ion-modal\n          [isOpen]=\"vm.modalIsOpen\"\n          [canDismiss]=\"true\"\n          [presentingElement]=\"routerOutlet.nativeEl\"\n          (ionModalDidDismiss)=\"modalIsOpen$.next(false)\"\n        >\n          <ng-template>\n            <app-slideshow [photos]=\"vm.photos\"></app-slideshow>\n          </ng-template>\n        </ion-modal>\n      </ion-content>\n    </ng-container>\n  `,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n})\nexport class HomeComponent {\n  photos$ = this.photoService.photos$.pipe(\n    map((photos) =>\n      photos.map((photo) => ({\n        ...photo,\n        safeResourceUrl: this.sanitizer.bypassSecurityTrustResourceUrl(\n          photo.path\n        ),\n      }))\n    )\n  );\n\n  modalIsOpen$ = new BehaviorSubject(false);\n\n  vm$ = combineLatest([\n    this.photos$,\n    this.modalIsOpen$,\n    this.photoService.hasTakenPhotoToday$,\n  ]).pipe(\n    map(([photos, modalIsOpen, hasTakenPhotoToday]) => ({\n      photos,\n      modalIsOpen,\n      hasTakenPhotoToday,\n    }))\n  );\n\n  constructor(\n    protected photoService: PhotoService,\n    private sanitizer: DomSanitizer,\n    public routerOutlet: IonRouterOutlet\n  ) {}\n}\n\n@NgModule({\n  imports: [\n    CommonModule,\n    IonicModule,\n    PhotoListComponentModule,\n    SlideshowComponentModule,\n    RouterModule.forChild([\n      {\n        path: '',\n        component: HomeComponent,\n      },\n    ]),\n  ],\n  declarations: [HomeComponent],\n})\nexport class HomeModule {}\n\n'ionicstart-snapaday/src/app/home/home.component.spec.ts'\n:import { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing';\nimport { By, DomSanitizer } from '@angular/platform-browser';\nimport { IonicModule, IonRouterOutlet } from '@ionic/angular';\nimport { subscribeSpyTo } from '@hirez_io/observer-spy';\nimport { PhotoService } from './data-access/photo/photo.service';\nimport { HomeComponent } from './home.component';\nimport { BehaviorSubject, of } from 'rxjs';\nimport { MockPhotoListComponent } from './ui/photo-list/photo-list.component.spec';\n\ndescribe('HomeComponent', () => {\n  let component: HomeComponent;\n  let fixture: ComponentFixture<HomeComponent>;\n  let mockHasTakenPhotoToday: BehaviorSubject<boolean>;\n\n  const testPhoto = {\n    name: 'test',\n    path: 'path',\n    dateTaken: new Date(),\n  };\n\n  const testPhotos = [testPhoto, testPhoto, testPhoto];\n\n  beforeEach(waitForAsync(() => {\n    mockHasTakenPhotoToday = new BehaviorSubject(false);\n\n    TestBed.configureTestingModule({\n      declarations: [HomeComponent, MockPhotoListComponent],\n      imports: [IonicModule.forRoot()],\n      providers: [\n        {\n          provide: IonRouterOutlet,\n          useValue: {},\n        },\n        {\n          provide: PhotoService,\n          useValue: {\n            takePhoto: jest.fn(),\n            photos$: of(testPhotos),\n            hasTakenPhotoToday$: mockHasTakenPhotoToday,\n            deletePhoto: jest.fn(),\n          },\n        },\n        {\n          provide: DomSanitizer,\n          useValue: {\n            bypassSecurityTrustResourceUrl: jest\n              .fn()\n              .mockReturnValue('bypass-path'),\n          },\n        },\n      ],\n    }).compileComponents();\n\n    fixture = TestBed.createComponent(HomeComponent);\n    component = fixture.componentInstance;\n\n    fixture.detectChanges();\n  }));\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should disable the take photo button if a photo has already been taken', () => {\n    mockHasTakenPhotoToday.next(true);\n    fixture.detectChanges();\n    const takePhotoButton = fixture.debugElement.query(\n      By.css('[data-test=\"take-photo-button\"]')\n    );\n    expect(takePhotoButton.componentInstance.disabled).toBeTruthy();\n  });\n\n  it('should call the takePhoto method in the photo service when take photo button clicked', () => {\n    const photoService = fixture.debugElement.injector.get(PhotoService);\n\n    const takePhotoButton = fixture.debugElement.query(\n      By.css('[data-test=\"take-photo-button\"]')\n    );\n\n    takePhotoButton.nativeElement.click();\n\n    expect(photoService.takePhoto).toHaveBeenCalled();\n  });\n\n  it('should call the deletePhoto method in the photo service when the delete event emits', () => {\n    const photoService = fixture.debugElement.injector.get(PhotoService);\n    const photoList = fixture.debugElement.query(By.css('app-photo-list'));\n\n    photoList.triggerEventHandler('delete', 'testName');\n\n    expect(photoService.deletePhoto).toHaveBeenCalledWith('testName');\n  });\n\n  describe('photos$', () => {\n    it('should modify photo paths to use bypassSecurityTrustResourceUrl', () => {\n      const observerSpy = subscribeSpyTo(component.photos$);\n      expect(observerSpy.getLastValue()?.[0].safeResourceUrl).toEqual(\n        'bypass-path'\n      );\n    });\n  });\n});\n",
        "gt": [
            "'ionicstart-snapaday/src/app/home/ui/photo-list/photo-list.component.ts'",
            "'ionicstart-snapaday/src/app/home/home.component.ts'",
            "'ionicstart-snapaday/src/app/home/home.component.spec.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/auth/auth.module.ts'",
            "'is-even/apps/backend/src/cognito/cognito.module.ts'",
            "'is-even/apps/backend/src/user/user.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/cognito/cognito.service.ts'"
        ],
        "content": "'is-even/apps/backend/src/auth/auth.module.ts'\n:import { Module } from '@nestjs/common';\nimport { PassportModule } from '@nestjs/passport';\n\nimport { UserModule } from '../user/user.module';\nimport { AppConfigModule } from '../config/config.module';\nimport { JwtStrategy } from './jwt.strategy';\nimport { LoggerModule } from '../logger/logger.module';\n\n@Module({\n  providers: [JwtStrategy],\n  imports: [\n    UserModule,\n    LoggerModule,\n    AppConfigModule,\n    PassportModule.register({ defaultStrategy: 'jwt' }),\n  ],\n})\nexport class AuthModule {}\n\n'is-even/apps/backend/src/cognito/cognito.module.ts'\n:import { Module } from '@nestjs/common';\n\nimport { AppConfigModule } from '../config/config.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { CognitoService } from './cognito.service';\n\n@Module({\n  providers: [CognitoService],\n  exports: [CognitoService],\n  imports: [LoggerModule, AppConfigModule],\n})\nexport class CognitoModule {}\n\n'is-even/apps/backend/src/user/user.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { User } from './user.entity';\nimport { UserService } from './user.service';\nimport { UserController } from './user.controller';\n\nimport { CognitoModule } from '../cognito/cognito.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [UserService],\n  exports: [UserService],\n  controllers: [UserController],\n  imports: [\n    TypeOrmModule.forFeature([User]),\n    CognitoModule,\n    LoggerModule,\n    SentryModule,\n  ],\n})\nexport class UserModule {}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/cognito/cognito.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\nimport { InjectAwsService } from 'nest-aws-sdk';\nimport jwtDecode from 'jwt-decode';\n\nimport { LoggerService } from '../logger/logger.service';\nimport { AppConfigService } from '../config/config.service';\nimport { CognitoCreateUserError } from './error/cognito-create-user.error';\nimport { CognitoUserIdMissingError } from './error/cognito-user-id-missing.error';\nimport { CognitoLoginUserError } from './error/cognito-login-user.error';\nimport { TokenResponse } from './interface/auth-response.interface';\nimport { CognitoLogoutUserError } from './error/cognito-logout-user.error';\n\n@Injectable()\nexport class CognitoService {\n  private readonly userPoolId: string;\n  private readonly clientId: string;\n\n  constructor(\n    private readonly loggerService: LoggerService,\n    private readonly configService: AppConfigService,\n    @InjectAwsService(CognitoIdentityServiceProvider)\n    private readonly cognitoService: CognitoIdentityServiceProvider,\n  ) {\n    this.userPoolId = this.configService.awsConfig.cognito_userPoolId;\n    this.clientId = this.configService.awsConfig.cognito_clientId;\n  }\n\n\n  public async createUser(email: string, password: string): Promise<string> {\n    try {\n      const response = await this.cognitoService\n        .adminCreateUser({\n          UserPoolId: this.userPoolId,\n          Username: email,\n        })\n        .promise();\n\n      try {\n        await this.cognitoService\n          .adminSetUserPassword({\n            UserPoolId: this.userPoolId,\n            Username: email,\n            Password: password,\n            Permanent: true,\n          })\n          .promise();\n      } catch (error) {\n        await this.deleteUser(email);\n        throw error;\n      }\n\n      return this.getUserId(response.User);\n    } catch (error) {\n      this.loggerService.error(`Failed to create a new user. ${error.message}`);\n      throw new CognitoCreateUserError(error);\n    }\n  }\n\n\n  public async login(email: string, password: string): Promise<TokenResponse> {\n    try {\n      const response = await this.cognitoService\n        .adminInitiateAuth({\n          ClientId: this.clientId,\n          AuthFlow: 'ADMIN_USER_PASSWORD_AUTH',\n          UserPoolId: this.userPoolId,\n          AuthParameters: {\n            USERNAME: email,\n            PASSWORD: password,\n          },\n        })\n        .promise();\n\n      if (\n        !response.AuthenticationResult.AccessToken ||\n        !response.AuthenticationResult.RefreshToken\n      ) {\n        throw new Error('AccessToken or RefreshToken is missing');\n      }\n\n      const accessToken = response.AuthenticationResult.AccessToken;\n      const refreshToken = response.AuthenticationResult.RefreshToken;\n      const expiration = this.getTokenExpiration(accessToken);\n\n      return {\n        accessToken,\n        refreshToken,\n        expiration,\n      };\n    } catch (error) {\n      this.loggerService.error(`Failed to login user: ${error.message}`);\n      throw new CognitoLoginUserError(error);\n    }\n  }\n\n  public async deleteUser(email: string): Promise<void> {\n    try {\n      await this.cognitoService\n        .adminDeleteUser({\n          Username: email,\n          UserPoolId: this.userPoolId,\n        })\n        .promise();\n    } catch (error) {\n      this.loggerService.error(`Failed to delete user: ${error.message}`);\n      throw error;\n    }\n  }\n\n  public async refreshToken(token: string): Promise<TokenResponse> {\n    try {\n      const response = await this.cognitoService\n        .adminInitiateAuth({\n          ClientId: this.clientId,\n          UserPoolId: this.userPoolId,\n          AuthFlow: 'REFRESH_TOKEN_AUTH',\n          AuthParameters: { REFRESH_TOKEN: token },\n        })\n        .promise();\n\n      if (!response.AuthenticationResult.AccessToken) {\n        throw new Error('AccessToken is missing');\n      }\n\n      const refreshToken = token;\n      const accessToken = response.AuthenticationResult.AccessToken;\n      const expiration = this.getTokenExpiration(accessToken);\n\n      return {\n        accessToken,\n        refreshToken,\n        expiration,\n      };\n    } catch (error) {\n      this.loggerService.error(`Failed to refresh token: ${error.message}`);\n      throw new CognitoLoginUserError(error);\n    }\n  }\n\n  public async logout(email: string): Promise<void> {\n    try {\n      await this.cognitoService\n        .adminUserGlobalSignOut({\n          Username: email,\n          UserPoolId: this.userPoolId,\n        })\n        .promise();\n    } catch (error) {\n      this.loggerService.error(`Failed to logout user: ${error.message}`);\n      throw new CognitoLogoutUserError(error);\n    }\n  }\n\n  public getTokenAuthId(accessToken: string): string {\n\n\n    return jwtDecode(accessToken).sub;\n  }\n\n  private getUserId(user: CognitoIdentityServiceProvider.UserType): string {\n    const userId = user.Attributes.find((attr) => attr.Name === 'sub').Value;\n\n    if (!userId) {\n      this.loggerService.error('User ID is missing but cannot be undefined');\n      throw new CognitoUserIdMissingError();\n    }\n\n    return userId;\n  }\n\n  private getTokenExpiration(accessToken: string): number {\n\n\n    return jwtDecode(accessToken).exp;\n  }\n}\n",
        "gt": [
            "'is-even/apps/backend/src/cognito/cognito.service.ts'",
            "'is-even/apps/backend/src/cognito/cognito.module.ts'",
            "'is-even/apps/backend/src/user/user.module.ts'",
            "'is-even/apps/backend/src/auth/auth.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/core/forms/date-range.validator.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/event-form/event-form.component.ts'",
            "'mean-rsvp-auth0/src/app/core/forms/formUtils.factory.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/core/forms/date-range.validator.ts'\n:import { AbstractControl } from '@angular/forms';\nimport { stringsToDate } from './formUtils.factory';\n\nexport function dateRangeValidator(c: AbstractControl): {[key: string]: any} {\n\n  const startDateC = c.get('startDate');\n  const startTimeC = c.get('startTime');\n  const endDateC = c.get('endDate');\n  const endTimeC = c.get('endTime');\n\n  const invalidObj = { 'dateRange': true };\n\n\n\n  if (startDateC.valid && endDateC.valid) {\n    const checkStartTime = startTimeC.invalid ? '12:00 AM' : startTimeC.value;\n    const checkEndTime = endTimeC.invalid ? '11:59 PM' : endTimeC.value;\n    const startDatetime = stringsToDate(startDateC.value, checkStartTime);\n    const endDatetime = stringsToDate(endDateC.value, checkEndTime);\n\n    if (endDatetime >= startDatetime) {\n      return null;\n    } else {\n      return invalidObj;\n    }\n  }\n  return null;\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n\n'mean-rsvp-auth0/src/app/pages/admin/event-form/event-form.component.ts'\n:import { Component, OnInit, OnDestroy, Input } from '@angular/core';\nimport { FormGroup, FormBuilder, Validators, AbstractControl } from '@angular/forms';\nimport { Router } from '@angular/router';\nimport { Subscription } from 'rxjs';\nimport { ApiService } from './../../../core/api.service';\nimport { EventModel, FormEventModel } from './../../../core/models/event.model';\nimport { DatePipe } from '@angular/common';\nimport { dateValidator } from './../../../core/forms/date.validator';\nimport { dateRangeValidator } from './../../../core/forms/date-range.validator';\nimport { DATE_REGEX, TIME_REGEX, stringsToDate } from './../../../core/forms/formUtils.factory';\nimport { EventFormService } from './event-form.service';\n\n@Component({\n  selector: 'app-event-form',\n  templateUrl: './event-form.component.html',\n  styleUrls: ['./event-form.component.scss'],\n  providers: [ EventFormService ]\n})\nexport class EventFormComponent implements OnInit, OnDestroy {\n  @Input() event: EventModel;\n  isEdit: boolean;\n\n  eventForm: FormGroup;\n  datesGroup: AbstractControl;\n\n  formEvent: FormEventModel;\n\n  formErrors: any;\n  formChangeSub: Subscription;\n\n  submitEventObj: EventModel;\n  submitEventSub: Subscription;\n  error: boolean;\n  submitting: boolean;\n  submitBtnText: string;\n\n  constructor(\n    private fb: FormBuilder,\n    private api: ApiService,\n    private datePipe: DatePipe,\n    public ef: EventFormService,\n    private router: Router\n  ) { }\n\n  ngOnInit() {\n    this.formErrors = this.ef.formErrors;\n    this.isEdit = !!this.event;\n    this.submitBtnText = this.isEdit ? 'Update Event' : 'Create Event';\n\n    this.formEvent = this._setFormEvent();\n\n    this._buildForm();\n  }\n\n  private _setFormEvent() {\n    if (!this.isEdit) {\n\n\n      return new FormEventModel(null, null, null, null, null, null, null);\n    } else {\n\n\n\n\n\n\n      const _shortDate = 'M/d/yyyy';\n      return new FormEventModel(\n        this.event.title,\n        this.event.location,\n        this.datePipe.transform(this.event.startDatetime, _shortDate),\n        this.datePipe.transform(this.event.startDatetime, 'shortTime'),\n        this.datePipe.transform(this.event.endDatetime, _shortDate),\n        this.datePipe.transform(this.event.endDatetime, 'shortTime'),\n        this.event.viewPublic,\n        this.event.description\n      );\n    }\n  }\n\n  private _buildForm() {\n    this.eventForm = this.fb.group({\n      title: [this.formEvent.title, [\n        Validators.required,\n        Validators.minLength(this.ef.textMin),\n        Validators.maxLength(this.ef.titleMax)\n      ]],\n      location: [this.formEvent.location, [\n        Validators.required,\n        Validators.minLength(this.ef.textMin),\n        Validators.maxLength(this.ef.locMax)\n      ]],\n      viewPublic: [this.formEvent.viewPublic,\n        Validators.required\n      ],\n      description: [this.formEvent.description,\n        Validators.maxLength(this.ef.descMax)\n      ],\n      datesGroup: this.fb.group({\n        startDate: [this.formEvent.startDate, [\n          Validators.required,\n          Validators.maxLength(this.ef.dateMax),\n          Validators.pattern(DATE_REGEX),\n          dateValidator()\n        ]],\n        startTime: [this.formEvent.startTime, [\n          Validators.required,\n          Validators.maxLength(this.ef.timeMax),\n          Validators.pattern(TIME_REGEX)\n        ]],\n        endDate: [this.formEvent.endDate, [\n          Validators.required,\n          Validators.maxLength(this.ef.dateMax),\n          Validators.pattern(DATE_REGEX),\n          dateValidator()\n        ]],\n        endTime: [this.formEvent.endTime, [\n          Validators.required,\n          Validators.maxLength(this.ef.timeMax),\n          Validators.pattern(TIME_REGEX)\n        ]]\n      }, { validator: dateRangeValidator })\n    });\n\n    this.datesGroup = this.eventForm.get('datesGroup');\n\n\n    this.formChangeSub = this.eventForm\n      .valueChanges\n      .subscribe(data => this._onValueChanged());\n\n\n\n\n    if (this.isEdit) {\n      const _markDirty = group => {\n        for (const i in group.controls) {\n          if (group.controls.hasOwnProperty(i)) {\n            group.controls[i].markAsDirty();\n          }\n        }\n      };\n      _markDirty(this.eventForm);\n      _markDirty(this.datesGroup);\n    }\n\n    this._onValueChanged();\n  }\n\n  private _onValueChanged() {\n    if (!this.eventForm) { return; }\n    const _setErrMsgs = (control: AbstractControl, errorsObj: any, field: string) => {\n      if (control && control.dirty && control.invalid) {\n        const messages = this.ef.validationMessages[field];\n        for (const key in control.errors) {\n          if (control.errors.hasOwnProperty(key)) {\n            errorsObj[field] += messages[key] + '<br>';\n          }\n        }\n      }\n    };\n\n\n    for (const field in this.formErrors) {\n      if (this.formErrors.hasOwnProperty(field)) {\n        if (field !== 'datesGroup') {\n\n\n          this.formErrors[field] = '';\n          _setErrMsgs(this.eventForm.get(field), this.formErrors, field);\n        } else {\n\n          const datesGroupErrors = this.formErrors['datesGroup'];\n          for (const dateField in datesGroupErrors) {\n            if (datesGroupErrors.hasOwnProperty(dateField)) {\n\n              datesGroupErrors[dateField] = '';\n              _setErrMsgs(this.datesGroup.get(dateField), datesGroupErrors, dateField);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  private _getSubmitObj() {\n    const startDate = this.datesGroup.get('startDate').value;\n    const startTime = this.datesGroup.get('startTime').value;\n    const endDate = this.datesGroup.get('endDate').value;\n    const endTime = this.datesGroup.get('endTime').value;\n\n\n    return new EventModel(\n      this.eventForm.get('title').value,\n      this.eventForm.get('location').value,\n      stringsToDate(startDate, startTime),\n      stringsToDate(endDate, endTime),\n      this.eventForm.get('viewPublic').value,\n      this.eventForm.get('description').value,\n      this.event ? this.event._id : null\n    );\n  }\n\n  onSubmit() {\n    this.submitting = true;\n    this.submitEventObj = this._getSubmitObj();\n\n    if (!this.isEdit) {\n      this.submitEventSub = this.api\n        .postEvent$(this.submitEventObj)\n        .subscribe(\n          data => this._handleSubmitSuccess(data),\n          err => this._handleSubmitError(err)\n        );\n    } else {\n      this.submitEventSub = this.api\n        .editEvent$(this.event._id, this.submitEventObj)\n        .subscribe(\n          data => this._handleSubmitSuccess(data),\n          err => this._handleSubmitError(err)\n        );\n    }\n  }\n\n  private _handleSubmitSuccess(res) {\n    this.error = false;\n    this.submitting = false;\n\n    this.router.navigate(['/event', res._id]);\n  }\n\n  private _handleSubmitError(err) {\n    console.error(err);\n    this.submitting = false;\n    this.error = true;\n  }\n\n  resetForm() {\n    this.eventForm.reset();\n  }\n\n  ngOnDestroy() {\n    if (this.submitEventSub) {\n      this.submitEventSub.unsubscribe();\n    }\n    this.formChangeSub.unsubscribe();\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/core/forms/formUtils.factory.ts'\n:\n\nconst GUESTS_REGEX = new RegExp(/^[0-9]$/);\n\n\nconst DATE_REGEX = new RegExp(/^(\\d{2}|\\d)\\/(\\d{2}|\\d)\\/\\d{4}$/);\n\n\nconst TIME_REGEX = new RegExp(/^((1[0-2]|0?[1-9]):([0-5][0-9]) ([AaPp][Mm]))$/);\n\n\n\n\nfunction stringsToDate(dateStr: string, timeStr: string) {\n  if (!DATE_REGEX.test(dateStr) || !TIME_REGEX.test(timeStr)) {\n    console.error('Cannot convert date/time to Date object.');\n    return;\n  }\n  const date = new Date(dateStr);\n  const timeArr = timeStr.split(/[\\s:]+/);\n  let hour = parseInt(timeArr[0], 10);\n  const min = parseInt(timeArr[1], 10);\n  const pm = timeArr[2].toLowerCase() === 'pm';\n\n  if (!pm && hour === 12) {\n    hour = 0;\n  }\n  if (pm && hour < 12) {\n    hour += 12;\n  }\n  date.setHours(hour);\n  date.setMinutes(min);\n  return date;\n}\n\nexport { GUESTS_REGEX, DATE_REGEX, TIME_REGEX, stringsToDate };\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/forms/formUtils.factory.ts'",
            "'mean-rsvp-auth0/src/app/core/forms/date-range.validator.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/event-form/event-form.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.service.ts'",
            "'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.module.ts'",
            "'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.controller.ts'",
            "'Rankings-Backend/src/api/admin/index.ts'",
            "'Rankings-Backend/src/api/admin/submit/athlete/dto/submit-athlete.dto.ts'",
            "'Rankings-Backend/src/api/admin/api.module.ts'"
        ],
        "content": "'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { RankingsService } from 'core/athlete/rankings.service';\nimport { DatabaseService } from 'core/database/database.service';\nimport { APIErrors } from 'shared/exceptions/api.exceptions';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { SubmitAthleteDto } from './dto/submit-athlete.dto';\n\n@Injectable()\nexport class SubmitAthleteService {\n  constructor(private readonly db: DatabaseService, private readonly rankingsService: RankingsService) {}\n  public async createAthlete(dto: SubmitAthleteDto) {\n    await this.checkDuplicate(dto.name, dto.surname, dto.email);\n    const id = await this.generateValidAthleteId(dto.name, dto.surname);\n    const athleteDetail = new AthleteDetail({\n      ...dto,\n      id: id,\n      birthdate: dto.birthdate ? new Date(dto.birthdate) : undefined,\n    });\n    await this.db.putAthlete(athleteDetail);\n    return id;\n  }\n\n  public async modifyAthlete(dto: SubmitAthleteDto) {\n    const current = await this.db.getAthleteDetails(dto.id);\n    const athleteDetail = new AthleteDetail({\n      ...dto,\n      birthdate: dto.birthdate ? new Date(dto.birthdate) : undefined,\n    });\n    await this.db.putAthlete(athleteDetail);\n    if (this.shouldRefreshRankings(current, athleteDetail)) {\n      await this.rankingsService.refreshAllRankingsOfAthlete(dto.id);\n    }\n    return dto.id;\n  }\n\n  private shouldRefreshRankings(oldAthlete: AthleteDetail, modifiedAthlete: AthleteDetail) {\n    if (oldAthlete.gender !== modifiedAthlete.gender) {\n      return true;\n    }\n    if (oldAthlete.country !== modifiedAthlete.country) {\n      return true;\n    }\n    if (oldAthlete.name !== modifiedAthlete.name) {\n      return true;\n    }\n    if (oldAthlete.surname !== modifiedAthlete.surname) {\n      return true;\n    }\n    if (oldAthlete.birthdate !== modifiedAthlete.birthdate) {\n      return true;\n    }\n    return false;\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.db.updateAthleteProfileUrl(athleteId, url);\n  }\n\n  private async checkDuplicate(name: string, surname: string, email: string) {\n    const id = IdGenerator.generateAthleteId(name, surname);\n    const athlete = await this.db.getAthleteDetails(id);\n    if (athlete) {\n      if (athlete.email === email) {\n        throw new APIErrors.DuplicateAthleteError(email);\n      }\n    }\n  }\n  private async generateValidAthleteId(name: string, surname: string) {\n    let id = IdGenerator.generateAthleteId(name, surname);\n    let exists = await this.db.isAthleteExists(id);\n    let suffix = 1;\n    while (exists) {\n      if (suffix > 10) {\n        throw new Error('Cannot create athlete id. Name + Surname appears more than 10 times');\n      }\n      id = IdGenerator.generateAthleteId(name, surname, suffix.toString());\n      exists = await this.db.isAthleteExists(id);\n      suffix++;\n    }\n    return id;\n  }\n}\n\n'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.module.ts'\n:import { Module } from '@nestjs/common';\nimport { DatabaseModule } from 'api/admin/database.module';\nimport { AthleteService } from 'core/athlete/athlete.service';\nimport { RankingsService } from 'core/athlete/rankings.service';\nimport { SubmitAthleteController } from './submit-athlete.controller';\nimport { SubmitAthleteService } from './submit-athlete.service';\n\n@Module({\n  imports: [DatabaseModule],\n  controllers: [SubmitAthleteController],\n  providers: [SubmitAthleteService, AthleteService, RankingsService],\n})\nexport class SubmitAthleteModule {}\n\n'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.controller.ts'\n:import { Body, Controller, Post, Put, UsePipes } from '@nestjs/common';\nimport { Roles } from 'shared/decorators/roles.decorator';\nimport { AuthenticationRole } from 'shared/enums';\nimport { RolesGuard } from 'shared/guards/roles.guard';\nimport { logger } from 'shared/logger';\nimport { JoiValidationPipe } from 'shared/pipes/JoiValidation.pipe';\nimport {\n  BatchSubmitAthleteDto,\n  batchSubmitAthleteDtoSchema,\n  SubmitAthleteDto,\n  submitAthleteDtoSchema,\n} from './dto/submit-athlete.dto';\nimport { SubmitAthleteResponse } from './dto/submit-athlete.response';\nimport { SubmitAthletePictureDto, submitAthletePictureDtoSchema } from './dto/submit-picture.dto';\nimport { SubmitAthleteService } from './submit-athlete.service';\n\n@Controller('submit/athlete')\nexport class SubmitAthleteController {\n  constructor(private readonly service: SubmitAthleteService) {}\n\n  @Post()\n\n\n  @UsePipes(new JoiValidationPipe(submitAthleteDtoSchema))\n  public async submitAthlete(@Body() dto: SubmitAthleteDto) {\n    logger.info('Submit Athlete', { data: dto });\n    let id: string;\n    if (dto.id) {\n      id = await this.service.modifyAthlete(dto);\n    } else {\n      id = await this.service.createAthlete(dto);\n    }\n    const response = new SubmitAthleteResponse(id);\n    return response;\n  }\n\n  @Post('batch')\n  @UsePipes(new JoiValidationPipe(batchSubmitAthleteDtoSchema))\n  public async batchSubmitAthlete(@Body() dto: BatchSubmitAthleteDto) {\n    for (const athlete of dto.data) {\n      await this.submitAthlete(athlete);\n    }\n  }\n\n  @Post('picture')\n\n\n  @UsePipes(new JoiValidationPipe(submitAthletePictureDtoSchema))\n  public async submitAthletePicture(@Body() dto: SubmitAthletePictureDto) {\n    await this.service.updateAthleteProfileUrl(dto.id, dto.url);\n  }\n}\n\n'Rankings-Backend/src/api/admin/index.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { APIGatewayEvent, Callback, Context, Handler } from 'aws-lambda';\n\nimport 'shared';\n\nimport { AllExceptionsFilter } from 'shared/filters/exception.filter';\nimport { waitForLogger } from 'shared/logger';\nimport { AppModule } from './api.module';\n\nimport * as serverless from 'aws-serverless-express';\nimport { eventContext } from 'aws-serverless-express/middleware';\n\nimport { Server } from 'http';\nimport env_variables from 'shared/env_variables';\nlet cachedServer: Server;\n\n\nconst express = require('express')();\n\nasync function bootstrapServer(): Promise<any> {\n  return NestFactory.create(AppModule, express, {\n    bodyParser: true,\n    logger: env_variables.isDev ? undefined : false,\n  })\n    .then(app => {\n      app.use(eventContext());\n      app.useGlobalFilters(new AllExceptionsFilter());\n      app.setGlobalPrefix('admin/api');\n      app.enableCors();\n      return app.init();\n    })\n    .then(() => {\n      return serverless.createServer(express);\n    });\n}\n\nexport const handler: Handler = async (event: APIGatewayEvent, context: Context) => {\n\n  context.succeed = succeedWaitsLogger(context.succeed);\n  if (!cachedServer) {\n    cachedServer = await bootstrapServer();\n  }\n  return serverless.proxy(cachedServer, event, context, 'PROMISE').promise;\n};\n\nfunction succeedWaitsLogger(succeed: Context['succeed']): Context['succeed'] {\n  return (messageObject: any) => {\n    return waitForLogger()\n      .then(() => {\n        succeed(messageObject);\n      })\n      .catch(error => {\n        succeed(messageObject);\n      });\n  };\n}\n\n'Rankings-Backend/src/api/admin/submit/athlete/dto/submit-athlete.dto.ts'\n:import * as Joi from 'joi';\n\nimport { Gender } from 'shared/enums';\nimport { GenderUtility } from 'shared/enums/enums-utility';\nimport { APIErrors } from 'shared/exceptions/api.exceptions';\n\nexport class SubmitAthleteDto {\n  public readonly id: string;\n  public readonly name: string;\n  public readonly surname: string;\n  public readonly profileUrl: string;\n  public readonly thumbnailUrl: string;\n  public readonly country: string;\n  public readonly gender: Gender;\n  public readonly birthdate?: string;\n  public readonly email: string;\n  public readonly city: string;\n  public readonly infoUrl: string;\n}\n\n\nexport class BatchSubmitAthleteDto {\n  public readonly data: SubmitAthleteDto[];\n}\n\nexport const submitAthleteDtoSchema = Joi.object().keys({\n  id: Joi.string()\n    .allow('')\n    .optional()\n    .error(new APIErrors.JoiValidationError('Unknown id')),\n  name: Joi.string()\n    .required()\n    .error(new APIErrors.JoiValidationError('Unknown name')),\n  surname: Joi.string()\n    .required()\n    .error(new APIErrors.JoiValidationError('Unknown surname')),\n  profileUrl: Joi.string()\n    .allow('')\n    .optional()\n    .uri()\n    .error(new APIErrors.JoiValidationError('Unknown profileUrl')),\n  thumbnailUrl: Joi.string()\n    .allow('')\n    .optional()\n    .uri()\n    .error(new APIErrors.JoiValidationError('Unknown thumbnailUrl')),\n  country: Joi.string()\n    .lowercase()\n    .required()\n    .error(new APIErrors.JoiValidationError('Unknown country')),\n  gender: Joi.number()\n    .required()\n    .valid(GenderUtility.ValidGenders)\n    .error(new APIErrors.JoiValidationError('Invalid gender')),\n  birthdate: Joi.string()\n    .allow('')\n    .isoDate()\n    .error(new APIErrors.JoiValidationError('Invalid birthdate')),\n  email: Joi.string()\n    .email()\n    .required()\n    .error(new APIErrors.JoiValidationError('Unknown email')),\n  city: Joi.string()\n    .optional()\n    .allow('')\n    .error(new APIErrors.JoiValidationError('Unknown city')),\n  infoUrl: Joi.string()\n    .allow('')\n    .optional()\n\n    .error(new APIErrors.JoiValidationError('Unknown infoUrl')),\n});\n\nexport const batchSubmitAthleteDtoSchema = Joi.object().keys({\n  data: Joi.array().items(submitAthleteDtoSchema),\n});\n\n'Rankings-Backend/src/api/admin/api.module.ts'\n:import { HelmetMiddleware } from '@nest-middlewares/helmet';\nimport { MethodOverrideMiddleware } from '@nest-middlewares/method-override';\nimport { MorganMiddleware } from '@nest-middlewares/morgan';\nimport { MiddlewareConsumer, Module } from '@nestjs/common';\n\nimport env_variables from 'shared/env_variables';\nimport { AthleteModule } from './athlete/athlete.module';\nimport { ContestModule } from './contest/contest.module';\nimport { ResultsModule } from './results/results.module';\nimport { SubmitAthleteModule } from './submit/athlete/submit-athlete.module';\nimport { SubmitContestModule } from './submit/contest/submit-contest.module';\nimport { SubmitContestResultsModule } from './submit/results/submit-contest-result.module';\n\n@Module({\n  imports: [\n    SubmitContestModule,\n    SubmitAthleteModule,\n    SubmitContestResultsModule,\n    ContestModule,\n    AthleteModule,\n    ResultsModule,\n  ],\n  providers: [],\n  exports: [],\n})\nexport class AppModule {\n  public configure(consumer: MiddlewareConsumer) {\n    MorganMiddleware.configure(env_variables.morganConfig);\n    consumer.apply(MorganMiddleware).forRoutes('*');\n    consumer.apply(MethodOverrideMiddleware).forRoutes('*');\n    consumer.apply(HelmetMiddleware).forRoutes('*');\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/api/admin/submit/athlete/dto/submit-athlete.dto.ts'",
            "'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.service.ts'",
            "'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.controller.ts'",
            "'Rankings-Backend/src/api/admin/submit/athlete/submit-athlete.module.ts'",
            "'Rankings-Backend/src/api/admin/api.module.ts'",
            "'Rankings-Backend/src/api/admin/index.ts'"
        ]
    },
    {
        "files": [
            "'foodie/server/src/config/passport.ts'",
            "'foodie/server/src/server.ts'",
            "'foodie/server/src/app.ts'"
        ],
        "content": "'foodie/server/src/config/passport.ts'\n:import User, { IUser } from '@/schemas/UserSchema';\nimport FacebookStrategy from 'passport-facebook';\nimport GitHubStrategy from 'passport-github';\nimport GoogleStrategy from 'passport-google-oauth2';\nimport LocalStrategy from 'passport-local';\n\n\nexport default function (passport) {\n    passport.serializeUser(function (user: IUser, done: any) {\n        done(null, user._id);\n        console.log('SERIALIZE', user)\n    });\n\n\n    passport.deserializeUser(function (id: string, done: any) {\n        User.findById(id, function (err, user) {\n            if (err) {\n                console.log('ERR', err)\n                return done(err);\n            }\n            done(err, user);\n        });\n    });\n\n    passport.use('local-register', new LocalStrategy.Strategy({\n\n        usernameField: 'email',\n        passwordField: 'password',\n        passReqToCallback: true\n    }, (req, email, password, done) => {\n        User.findOne({ email })\n            .then((user) => {\n                if (user) {\n                    return done(null, false, { message: 'Email already has been already used by other user.' });\n                } else {\n                    const newUser = new User({ email, password, username: req.body.username });\n\n                    newUser.save(function (err) {\n                        if (err) {\n                            return done(err);\n                        }\n                        return done(null, newUser);\n                    });\n                }\n            })\n            .catch((e) => {\n                return done(e);\n            })\n    })\n    );\n\n    passport.use(\n        'local-login',\n        new LocalStrategy.Strategy({\n            usernameField: 'username',\n            passwordField: 'password',\n            passReqToCallback: true\n        }, async (req, username, password, done) => {\n            try {\n                const user = await User.findOne({ username });\n\n                if (user) {\n                    user.passwordMatch(password, function (err, match) {\n                        if (err) {\n                            return done(err);\n                        }\n                        if (match) {\n                            return done(null, user);\n                        } else {\n                            return done(null, false, {\n                                message: 'Incorrect credentials.'\n                            });\n                        }\n                    });\n                } else {\n                    return done(null, false, { message: 'Incorrect credentials.' });\n                }\n            } catch (err) {\n                return done(err);\n            }\n        })\n    );\n\n    passport.use(\n        'facebook-auth',\n        new FacebookStrategy.Strategy({\n            clientID: process.env.FACEBOOK_CLIENT_ID,\n            clientSecret: process.env.FACEBOOK_CLIENT_SECRET,\n            callbackURL: `/api/v1/auth/facebook/callback`,\n            profileFields: ['id', 'profileUrl', 'email', 'displayName', 'name', 'gender', 'picture.type(large)']\n        }, async (accessToken, refreshToken, profile, done) => {\n            try {\n                const fbProfile = profile._json;\n                const user = await User.findOne({ provider_id: fbProfile.id });\n\n                if (user) {\n                    return done(null, user);\n                } else {\n                    const randomString = Math.random().toString(36).substring(2);\n\n                    const newUser = new User({\n                        username: fbProfile.email.split('@')[0],\n                        email: fbProfile.email,\n                        password: randomString,\n                        firstname: fbProfile.first_name,\n                        lastname: fbProfile.last_name,\n                        profilePicture: {\n                            url: fbProfile.picture ? fbProfile.picture.data.url : ''\n                        },\n                        provider_id: fbProfile.id,\n                        provider: 'facebook',\n                        provider_access_token: accessToken,\n                        provider_refresh_token: refreshToken\n                    });\n\n                    newUser.save(function (err) {\n                        if (err) {\n                            done(null, false, err);\n                        } else {\n                            console.log('SUCCESSFULL CREATED', newUser);\n                            done(null, newUser);\n                        }\n                    });\n                }\n            } catch (err) {\n                console.log(err);\n                return done(err);\n            }\n        }\n        )\n    );\n\n    passport.use(\n        'github-auth',\n        new GitHubStrategy.Strategy({\n            clientID: process.env.GITHUB_CLIENT_ID,\n            clientSecret: process.env.GITHUB_CLIENT_SECRET,\n            callbackURL: `/api/v1/auth/github/callback`,\n            scope: 'user:email'\n        }, async (accessToken, refreshToken, profile, done) => {\n            try {\n                const githubProfile: any = profile._json;\n                const user = await User.findOne({ provider_id: githubProfile.id });\n\n                if (user) {\n                    return done(null, user);\n                } else {\n                    const randomString = Math.random().toString(36).substring(2);\n\n                    const newUser = new User({\n                        username: githubProfile.login,\n                        email: githubProfile.email,\n                        password: randomString,\n                        firstname: githubProfile.name.split(' ')[0],\n                        lastname: githubProfile.name.split(' ')[1],\n                        profilePicture: {\n                            url: githubProfile.avatar_url\n                        },\n                        provider_id: githubProfile.id,\n                        provider: 'github',\n                        'info.bio': githubProfile.bio,\n                        provider_access_token: accessToken,\n                        provider_refresh_token: refreshToken\n                    });\n\n                    newUser.save(function (err) {\n                        if (err) {\n                            console.log(err)\n                            done(null, false, err);\n                        } else {\n                            console.log('SUCCESSFULL CREATED', newUser);\n                            done(null, newUser);\n                        }\n                    });\n                }\n            } catch (err) {\n                console.log(err);\n                return done(err);\n            }\n        }\n        )\n    );\n\n    passport.use(\n        'google-auth',\n        new GoogleStrategy.Strategy(\n            {\n                clientID: process.env.GOOGLE_CLIENT_ID,\n                clientSecret: process.env.GOOGLE_CLIENT_SECRET,\n                callbackURL: `/api/v1/auth/google/callback`\n            },\n            async (accessToken, refreshToken, profile, done) => {\n                try {\n                    console.log(profile)\n                    const user = await User.findOne({ provider_id: profile.id });\n\n                    console.log(profile)\n\n                    if (user) {\n                        return done(null, user);\n                    } else {\n                        const randomString = Math.random().toString(36).substring(2);\n                        const randomNumber = Math.floor(Math.random() * 100);\n                        const photo = profile.picture ? { url: profile.picture } : {};\n\n                        const newUser = new User({\n                            username: `${profile.given_name}_${profile.family_name}${randomNumber}`,\n                            email: profile.email,\n                            password: randomString,\n                            firstname: profile.given_name,\n                            lastname: profile.family_name,\n                            profilePicture: photo,\n                            provider_id: profile.id,\n                            provider: 'google',\n                            provider_access_token: accessToken,\n                            provider_refresh_token: refreshToken\n                        });\n\n                        newUser.save(function (err) {\n                            if (err) {\n                                done(null, false, err);\n                            } else {\n                                console.log('SUCCESSFULL CREATED', newUser);\n                                done(null, newUser);\n                            }\n                        });\n                    }\n                } catch (err) {\n                    console.log(err);\n                    return done(err);\n                }\n            }\n        )\n    )\n\n};\n\n'foodie/server/src/server.ts'\n:import Express from './app';\n\nconst express = new Express();\nexpress.listen();\nexpress.onError();\nexpress.onListening();\n'foodie/server/src/app.ts'\n:import cors from 'cors';\nimport csurf from 'csurf';\nimport createDebug from 'debug';\nimport express from 'express';\nimport session, { SessionOptions } from 'express-session';\nimport helmet from 'helmet';\nimport hpp from 'hpp';\nimport http, { Server } from 'http';\nimport createError from 'http-errors';\nimport logger from 'morgan';\nimport passport from 'passport';\nimport config from './config/config';\nimport initializePassport from './config/passport';\nimport initializeSocket from './config/socket';\nimport initializeDB from './db/db';\nimport errorHandler from './middlewares/error.middleware';\nimport routers from './routes/createRouter';\n\nconst debug = createDebug('server:server');\n\nconsole.log(config);\n\nclass Express {\n  public app: express.Application;\n  public server: Server;\n\n  constructor() {\n    this.app = express();\n    this.server = http.createServer(this.app);\n    initializeDB();\n    this.initializeMiddlewares();\n    initializeSocket(this.app, this.server);\n    initializePassport(passport);\n  }\n\n  private initializeMiddlewares() {\n    this.app.disable('x-powered-by');\n    this.app.use(express.json());\n    this.app.use(express.urlencoded({ extended: true }));\n    this.app.use(cors(config.cors));\n    this.app.set('trust proxy', 1);\n    this.app.use(logger('dev'));\n    this.app.use(helmet());\n    this.app.use(hpp());\n\n    this.app.use(session(config.session as SessionOptions));\n    this.app.use(passport.initialize());\n    this.app.use(passport.session());\n    this.app.use('/api', routers);\n\n\n    this.app.use(function (req, res, next) {\n      next(createError(404));\n    });\n\n\n    this.app.use(csurf());\n    this.app.use(errorHandler);\n  }\n\n  public onError() {\n    this.server.on('error', (error: NodeJS.ErrnoException) => {\n      if (error.syscall !== 'listen') {\n        throw error;\n      }\n\n      const bind = typeof config.server.port === 'string'\n        ? 'Pipe ' + config.server.port\n        : 'Port ' + config.server.port;\n\n\n      switch (error.code) {\n        case 'EACCES':\n          console.error(bind + ' requires elevated privileges');\n          process.exit(1);\n        case 'EADDRINUSE':\n          console.error(bind + ' is already in use');\n          process.exit(1);\n        default:\n          throw error;\n      }\n    })\n  }\n\n  public onListening() {\n    this.server.on('listening', () => {\n      const addr = this.server.address();\n      const bind = typeof addr === 'string'\n        ? 'pipe ' + addr\n        : 'port ' + addr.port;\n\n      debug('Listening on ' + bind);\n    })\n  }\n\n  public listen() {\n    this.server.listen(config.server.port, () => {\n      console.log(`# Application is listening on port ${config.server.port} #`)\n    })\n  }\n}\n\nexport default Express;",
        "gt": [
            "'foodie/server/src/config/passport.ts'",
            "'foodie/server/src/app.ts'",
            "'foodie/server/src/server.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { repositoryFactory } from '../../utils/utils';\nimport { DDBAthleteContestsRepository } from './athlete.contests.repo';\n\n@Module({\n  imports: [],\n  providers: [],\n  exports: [],\n})\nexport class DDBAthleteContestsRepoModule {\n  public static withConfig(dynamodbService: IDynamoDBService): DynamicModule {\n    const repo = repositoryFactory(\n      DDBAthleteContestsRepository,\n      dynamodbService,\n    );\n    return {\n      module: DDBAthleteContestsRepoModule,\n      providers: [repo],\n      exports: [repo],\n    };\n  }\n  public static forTest(dynamodbService: IDynamoDBService): ModuleMetadata {\n    const repo = repositoryFactory(\n      DDBAthleteContestsRepository,\n      dynamodbService,\n    );\n    return {\n      providers: [repo],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { DDBRepository, GlobalSecondaryIndexName, LocalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey, LSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteContestItem, KeyAttrs } from './athlete.contests.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nimport { Utils } from 'shared/utils';\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteContestsRepository extends DDBRepository {\n  protected _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async put(contest: DDBAthleteContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Put', params));\n  }\n\n  public async delete(athleteId: string, contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId, discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Delete', params));\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(athleteId, opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const startDate = opts.betweenDates ? opts.betweenDates.start.toISODate() : '';\n    const endDate = (opts.betweenDates && !Utils.isNil(opts.betweenDates.end)\n      ? opts.betweenDates.end\n      : Utils.DateNow().toDate()\n    ).toISODate();\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and #lsi BETWEEN :startDate AND :endDate',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(athleteId),\n        ':startDate': this.transformer.itemToAttrsTransformer.LSI(startDate),\n        ':endDate': this.transformer.itemToAttrsTransformer.LSI(endDate),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryAthleteContestsByDate', params));\n  }\n\n  public async queryContestAthletes(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(contestId, discipline, after);\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryContestAthletes', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        points: this.transformer.attrsToItemTransformer.points(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(\n    athleteId: string,\n    after?: {\n      contestId: string;\n      discipline: Discipline;\n      date: string;\n    },\n  ): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createGSIExclusiveStartKey(\n    contestId: string,\n    discipline: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && !Utils.isNil(after.points)) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.points),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[] }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'\n:import { DocumentClient } from 'aws-sdk/clients/dynamodb';\n\nexport interface DDBTableKeyAttrs {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly LSI: string;\n  readonly GSI_SK: string;\n}\n\nexport interface LSILastEvaluatedKey {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly LSI: string;\n}\n\nexport interface GSILastEvaluatedKey {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly GSI_SK: string;\n}\n\nexport type NumberSet = DocumentClient.DynamoDbSet;\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'cxml/src/builder/RuleSet.ts'",
            "'cxml/src/builder/Builder.ts'",
            "'cxml/src/builder/BuilderConfig.ts'"
        ],
        "content": "'cxml/src/builder/RuleSet.ts'\n:import { SimpleSchema } from '../schema/SimpleSchema';\nimport { ComplexType } from '../schema/ComplexType';\nimport { MemberSpec } from '../schema/Member';\nimport { ElementInstance, ElementMeta, ElementConstructor } from '../schema/Element';\n\nexport class Rule {\n\n\taddElement(member: RuleMember) {\n\t\tthis.elements[member.id] = member;\n\t}\n\n\taddAttribute(member: RuleMember) {\n\t\tthis.attributes[member.id] = member;\n\t}\n\n\telements: { [id: number]: RuleMember } = {};\n\tattributes: { [id: number]: RuleMember } = {};\n\n\tstatic string = new Rule();\n\n\tXMLType: ElementConstructor;\n\n}\n\nexport class RuleMember {\n\n\tconstructor(public rule: Rule, public spec: MemberSpec) {\n\t\tthis.id = spec.meta!.token.id!;\n\t\tthis.min = spec.min;\n\t\tthis.max = spec.max;\n\t}\n\n\tid: number;\n\tmin: number;\n\tmax: number;\n\n}\n\nfunction link<Type>(parent: Type) {\n\tfunction Result() {}\n\tResult.prototype = parent;\n\treturn(new (Result as any)());\n}\n\nexport interface RuleStack {\n\tmeta?: ElementMeta;\n\trule?: Rule;\n\tparent?: RuleStack;\n}\n\nexport class RuleSet {\n\n\tcreateRule(type: ComplexType, meta?: ElementMeta, parent?: RuleStack) {\n\t\tconst rule = new Rule();\n\t\tlet childRule: Rule | undefined;\n\t\tlet proto: { [key: string]: any } = {};\n\n\t\tif(meta) {\n\t\t\trule.XMLType = meta.createProto();\n\t\t\tproto = rule.XMLType.prototype;\n\t\t}\n\n\t\tif(type.elements && type.elements.group) {\n\t\t\tfor(let childSpec of type.elements.group.list) {\n\t\t\t\tconst memberMeta = childSpec.meta;\n\n\t\t\t\tif(memberMeta) {\n\t\t\t\t\tif(memberMeta instanceof ElementMeta) {\n\t\t\t\t\t\tchildRule = void 0;\n\n\t\t\t\t\t\tfor(let item = parent; item; item = item.parent) {\n\t\t\t\t\t\t\tif(item.meta == memberMeta) {\n\n\n\n\t\t\t\t\t\t\t\tchildRule = item.rule;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(!childRule) {\n\t\t\t\t\t\t\tchildRule = this.createRule(memberMeta.type, memberMeta, { meta, rule, parent });\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\tlet fakeMeta = link(memberMeta);\n\t\t\t\t\t\tfakeMeta.exists = false;\n\n\t\t\t\t\t\tlet placeholder: ElementInstance | ElementInstance[] | null = new childRule.XMLType();\n\t\t\t\t\t\tplaceholder._ = fakeMeta;\n\t\t\t\t\t\tmemberMeta.placeholder = placeholder;\n\n\t\t\t\t\t\tif(childSpec.max > 1) {\n\n\t\t\t\t\t\t\tplaceholder = childSpec.min > 0 ? [ placeholder ] : [];\n\t\t\t\t\t\t} else if(childSpec.min < 1) {\n\t\t\t\t\t\t\tplaceholder = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(placeholder) {\n\t\t\t\t\t\t\tObject.defineProperty(proto, memberMeta.token.name, {\n\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\tenumerable: false,\n\t\t\t\t\t\t\t\tvalue: placeholder,\n\t\t\t\t\t\t\t\twritable: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else childRule = Rule.string;\n\n\t\t\t\t\trule.addElement(new RuleMember(childRule, childSpec));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(type.attributes) {\n\t\t\tfor(let attributeSpec of type.attributes.list) {\n\t\t\t\tconst memberMeta = attributeSpec.meta;\n\n\t\t\t\tif(memberMeta) {\n\n\n\t\t\t\t\tchildRule = Rule.string;\n\n\t\t\t\t\trule.addAttribute(new RuleMember(childRule, attributeSpec));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn(rule);\n\t}\n\n\tconstructor(public schema: SimpleSchema) {\n\t\tthis.rootRule = this.createRule(schema.document);\n\t}\n\n\trootRule: Rule;\n\n}\n\n'cxml/src/builder/Builder.ts'\n:import { Namespace } from '../Namespace';\nimport { TokenChunk } from '../parser/TokenChunk';\nimport { Token, TokenBuffer, TokenKind, OpenToken, CloseToken, StringToken } from '../parser/Token';\nimport { ParserConfig, ParserOptions } from '../parser/ParserConfig';\nimport { Parser } from '../parser/Parser';\nimport { SimpleSchema, SimpleSchemaSpecTbl } from '../schema/SimpleSchema';\nimport { RuleSet, Rule, RuleMember } from './RuleSet';\n\nimport { ComplexType } from '../schema/ComplexType';\nimport { ElementInstance, ElementSpec, ElementMeta, ElementConstructor } from '../schema/Element';\nimport { ElementToken } from '../parser/Token';\nimport { BuilderConfig } from './BuilderConfig';\n\nconst enum State {\n\tELEMENT = 0,\n\tPROCESSING,\n\tTEXT,\n\tCOMMENT\n}\n\nexport class Builder {\n\n\tconstructor(private config: BuilderConfig, public nsUri: string) {\n\t\tconst ruleSet = this.config.ruleSetTbl[nsUri];\n\n\t\tif(!ruleSet) throw(new Error('Unknown XML namespace ' + nsUri));\n\n\t\tthis.rule = ruleSet.rootRule;\n\t}\n\n\tgetUnknownProto(token: ElementToken) {\n\t\tlet elementSpec: ElementSpec | undefined = this.unknownType.elements && this.unknownType.elements.group!.tbl[token.id!] as ElementSpec;\n\n\t\tif(!elementSpec) {\n\t\t\telementSpec = new ElementSpec(0, Infinity);\n\t\t\tconst elementMeta = new ElementMeta(token);\n\n\t\t\telementMeta.type = new ComplexType();\n\t\t\telementSpec.meta = elementMeta;\n\n\t\t\tthis.unknownType.addAll(elementSpec);\n\t\t}\n\n\t\treturn(elementSpec.meta!.createProto());\n\t}\n\n\twrite(chunk: TokenChunk) {\n\t\tif(!chunk) return;\n\n\t\tconst parseUnknown = this.config.options.parseUnknown;\n\t\tlet unknownDepth = this.unknownDepth;\n\t\tlet state = this.state;\n\t\tlet item = this.item;\n\t\tlet rule = this.rule;\n\t\tlet member = this.member;\n\t\tlet target = this.target;\n\t\tlet stackPos = this.stackPos;\n\n\t\tconst ruleStack = this.ruleStack;\n\t\tconst itemStack = this.itemStack;\n\n\t\tconst buffer = chunk.buffer;\n\t\tlet token: typeof buffer[0];\n\t\tlet dataType: string;\n\t\tlet kind: number;\n\t\tlet id: number;\n\t\tlet name: string;\n\n\t\tlet itemNext: any;\n\t\tlet ruleNext: Rule | undefined;\n\n\t\tlet lastNum = chunk.length - 1;\n\t\tlet tokenNum = -1;\n\n\t\twhile(tokenNum < lastNum) {\n\n\t\t\ttoken = buffer[++tokenNum];\n\t\t\tdataType = typeof(token);\n\n\t\t\tif(unknownDepth) {\n\t\t\t\tif(dataType == 'object') {\n\t\t\t\t\tkind = (token as Token).kind;\n\n\t\t\t\t\tif(kind == TokenKind.open) ++unknownDepth;\n\t\t\t\t\telse if(kind == TokenKind.close) --unknownDepth;\n\t\t\t\t}\n\t\t\t} else if(dataType == 'object') {\n\t\t\t\tkind = (token as Token).kind;\n\n\t\t\t\tswitch(kind) {\n\t\t\t\t\tcase TokenKind.open:\n\n\t\t\t\t\t\tid = (token as OpenToken).id!;\n\t\t\t\t\t\tname = (token as OpenToken).name;\n\t\t\t\t\t\tmember = rule && rule.elements[id];\n\n\t\t\t\t\t\tif(member) {\n\t\t\t\t\t\t\truleNext = member.rule;\n\n\t\t\t\t\t\t\tif(ruleNext == Rule.string) {\n\n\n\t\t\t\t\t\t\t\ttarget = name;\n\t\t\t\t\t\t\t\titemNext = item;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\titemNext = new ruleNext.XMLType();\n\t\t\t\t\t\t\t\tif(member.max > 1) {\n\t\t\t\t\t\t\t\t\tif(!item.hasOwnProperty(name)) item[name] = [];\n\t\t\t\t\t\t\t\t\titem[name].push(itemNext);\n\t\t\t\t\t\t\t\t} else item[name] = itemNext;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(!parseUnknown) {\n\t\t\t\t\t\t\t++unknownDepth;\n\n\t\t\t\t\t\t\tstate = State.TEXT;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\truleNext = void 0;\n\t\t\t\t\t\t\titemNext = new (this.getUnknownProto(token as OpenToken))();\n\n\t\t\t\t\t\t\tif(!item.hasOwnProperty(name)) item[name] = itemNext;\n\t\t\t\t\t\t\telse if(item[name] instanceof Array) item[name].push(itemNext);\n\t\t\t\t\t\t\telse item[name] = [item[name], itemNext];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\titemStack[stackPos] = item;\n\t\t\t\t\t\truleStack[stackPos++] = rule;\n\t\t\t\t\t\titem = itemNext;\n\t\t\t\t\t\trule = ruleNext;\n\n\t\t\t\t\t\tstate = State.ELEMENT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TokenKind.close:\n\n\t\t\t\t\t\titem = itemStack[--stackPos];\n\t\t\t\t\t\trule = ruleStack[stackPos];\n\n\n\t\t\t\t\tcase TokenKind.emitted:\n\n\t\t\t\t\t\tif(rule != Rule.string) target = '$';\n\n\t\t\t\t\t\tstate = State.TEXT;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TokenKind.string:\n\n\t\t\t\t\t\tid = (token as StringToken).id!;\n\t\t\t\t\t\tmember = rule && rule.attributes[id];\n\t\t\t\t\t\tif(member || parseUnknown) {\n\t\t\t\t\t\t\ttarget = (token as StringToken).name;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget = void 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase TokenKind.comment:\n\n\t\t\t\t\t\tstate = State.COMMENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tswitch(state) {\n\t\t\t\t\tcase State.TEXT:\n\t\t\t\t\tcase State.ELEMENT:\n\n\t\t\t\t\t\tif(target) {\n\t\t\t\t\t\t\titem[target] = (member && member.max > 1) ? (token + '').split(/ +/) : token;\n\t\t\t\t\t\t\ttarget = void 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.unknownDepth = unknownDepth;\n\t\tthis.state = state;\n\t\tthis.item = item;\n\t\tthis.rule = rule;\n\t\tthis.member = member;\n\t\tthis.target = target;\n\t\tthis.stackPos = stackPos;\n\n\t\tchunk.free();\n\n\t\treturn(this.document);\n\t}\n\n\tdocument: any = {};\n\tprivate item = this.document;\n\tprivate rule?: Rule;\n\tprivate member?: RuleMember;\n\tprivate target?: string;\n\n\tprivate unknownType = new ComplexType();\n\tprivate unknownDepth = 0;\n\n\tprivate stackPos = 0;\n\tprivate ruleStack: (Rule | undefined)[] = [];\n\tprivate itemStack: any[] = [];\n\n\tprivate state = State.TEXT;\n\n}\n\n'cxml/src/builder/BuilderConfig.ts'\n:import { Namespace } from '../Namespace';\nimport { ParserConfig, ParserOptions } from '../parser/ParserConfig';\nimport { SimpleSchema, SimpleSchemaSpecTbl } from '../schema/SimpleSchema';\nimport { RuleSet } from './RuleSet';\nimport { Builder } from './Builder';\n\nexport class BuilderConfig {\n\n\tconstructor(parserConfig: ParserConfig, schemaSpec: SimpleSchemaSpecTbl) {\n\t\tthis.options = parserConfig.options;\n\n\t\tfor(let prefix of Object.keys(schemaSpec)) {\n\t\t\tconst [ defaultPrefix, nsUri, spec ] = schemaSpec[prefix];\n\t\t\tconst ns = new Namespace(defaultPrefix, nsUri);\n\n\t\t\tif(spec['document']) {\n\t\t\t\tthis.ruleSetTbl[nsUri] = new RuleSet(new SimpleSchema(parserConfig, ns, spec));\n\t\t\t}\n\t\t}\n\t}\n\n\tcreateBuilder(nsUri: string) {\n\t\treturn(new Builder(this, nsUri));\n\t}\n\n\toptions: ParserOptions;\n\truleSetTbl: { [uri: string]: RuleSet } = {};\n\n}\n",
        "gt": [
            "'cxml/src/builder/RuleSet.ts'",
            "'cxml/src/builder/Builder.ts'",
            "'cxml/src/builder/BuilderConfig.ts'"
        ]
    },
    {
        "files": [
            "'among-us-stats/src/index.tsx'",
            "'among-us-stats/src/components/playersoverview/PlayerOverviewRow.tsx'",
            "'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'",
            "'among-us-stats/src/components/App.tsx'",
            "'among-us-stats/src/components/playersoverview/usePlayerWithTotalStats.ts'"
        ],
        "content": "'among-us-stats/src/index.tsx'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n'among-us-stats/src/components/playersoverview/PlayerOverviewRow.tsx'\n:import Grid from '@material-ui/core/Grid';\nimport React from 'react';\nimport Avatar from '@material-ui/core/Avatar';\nimport Box from '@material-ui/core/Box';\nimport Typography from '@material-ui/core/Typography';\nimport InsertEmoticonIcon from '@material-ui/icons/InsertEmoticon';\nimport { makeStyles } from '@material-ui/core/styles';\n\nimport { percentIt } from '../../utils/mathUtils';\nimport ImpostorIcon from '../shared/icons/ImpostorIcon';\nimport CrewAvatar from '../shared/avatar/CrewAvatar';\n\nimport { PlayerStats } from './usePlayerWithTotalStats';\n\nconst useStyles = makeStyles((theme) => ({\n  winnerIcon: {\n    backgroundColor: theme.palette.primary.main,\n    flexGrow: 1,\n  },\n  impostorRateAvatar: {\n    backgroundColor: theme.palette.background.paper,\n  },\n}));\n\ninterface Props {\n  player: PlayerStats;\n}\n\nfunction PlayerOverviewRow({ player }: Props): JSX.Element {\n  const classes = useStyles();\n  return (\n    <Grid container spacing={1}>\n      <Grid item md=\"auto\" sm={12} xs={12}>\n        <Box display=\"flex\" alignItems=\"center\">\n          <Box p={1}>\n            <Avatar>{player.name.slice(0, 2).toUpperCase()}</Avatar>\n          </Box>\n          <Box display=\"flex\" flexDirection=\"column\">\n            <Typography variant=\"body1\">{player.name}</Typography>\n            <Typography variant=\"caption\">{player.gamesPlayed} games played</Typography>\n          </Box>\n        </Box>\n      </Grid>\n      <StatItem\n        icon={\n          <Avatar className={classes.winnerIcon}>\n            <InsertEmoticonIcon fontSize=\"large\" />\n          </Avatar>\n        }\n        title=\"Total win rate\"\n        text={percentIt(player.totalWinRate)}\n      />\n      <StatItem\n        icon={<CrewAvatar type=\"impostor\" />}\n        title=\"Impostor win rate\"\n        text={percentIt(player.totalImpostorWinRate)}\n      />\n      <StatItem\n        icon={<CrewAvatar type=\"crew\" />}\n        title=\"CrewAvatar win rate\"\n        text={percentIt(player.totalCrewWinRate)}\n      />\n      <StatItem\n        icon={\n          <Avatar className={classes.impostorRateAvatar}>\n            <ImpostorIcon color=\"secondary\" fontSize=\"large\" />\n          </Avatar>\n        }\n        title=\"Games as impostor\"\n        text={percentIt(player.totalImpostorRate)}\n      />\n    </Grid>\n  );\n}\n\ninterface StatItemProps {\n  icon: JSX.Element;\n  title: string;\n  text: string;\n}\n\nfunction StatItem({ icon, title, text }: StatItemProps) {\n  return (\n    <Grid item md=\"auto\" sm={6} xs={12}>\n      <Box display=\"flex\" alignItems=\"center\">\n        <Box p={1}>{icon}</Box>\n        <Box display=\"flex\" flexDirection=\"column\">\n          <Typography variant=\"subtitle2\">{title}</Typography>\n          <Typography variant=\"body1\">{text}</Typography>\n        </Box>\n      </Box>\n    </Grid>\n  );\n}\n\nexport default PlayerOverviewRow;\n\n'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'\n:import React, { Fragment } from 'react';\nimport Paper from '@material-ui/core/Paper';\nimport Typography from '@material-ui/core/Typography';\nimport Box from '@material-ui/core/Box';\nimport Grid from '@material-ui/core/Grid';\nimport { Divider } from '@material-ui/core';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Sort from '@material-ui/icons/Sort';\nimport Menu from '@material-ui/core/Menu';\nimport MenuItem from '@material-ui/core/MenuItem';\nimport { useSelector } from 'react-redux';\nimport { useDispatch } from 'react-redux';\nimport { sortBy, reverse } from 'rambda';\n\nimport useAnchor from '../shared/hooks/useAnchor';\nimport { RootState } from '../../store/redux';\nimport { commonSlice, SortPlayersBy } from '../../store/common/commonRedux';\nimport BreakpointButton from '../shared/BreakpointButton';\n\nimport PlayerOverviewRow from './PlayerOverviewRow';\nimport usePlayersWithTotalStats from './usePlayerWithTotalStats';\n\nconst sortOptions: SortPlayersBy[] = [\n  'Games played',\n  'Total win rate',\n  'Crew win rate',\n  'Impostor win rate',\n  'Impostor rate',\n];\n\nfunction PlayersOverview(): JSX.Element {\n  const dispatch = useDispatch();\n  const [anchorEl, anchorActions] = useAnchor();\n  const sortPlayersBy = useSelector((state: RootState) => state.common.sortPlayersBy);\n  const [playersWithTotalStats, metaStats] = usePlayersWithTotalStats();\n\n  const playersWithTotalStatsSorted = reverse(\n    sortBy((player) => {\n      switch (sortPlayersBy) {\n        case 'Games played':\n          return player.gamesPlayed;\n        case 'Total win rate':\n          return player.totalWinRate;\n        case 'Impostor win rate':\n          return player.totalImpostorWinRate;\n        case 'Crew win rate':\n          return player.totalCrewWinRate;\n        case 'Impostor rate':\n          return player.totalImpostorRate;\n      }\n    })(playersWithTotalStats),\n  );\n\n  return (\n    <Paper>\n      <Toolbar>\n        <Typography variant=\"h5\">Total player stats</Typography>\n        <Box flex=\"1 1 auto\" />\n        <BreakpointButton\n          text={`Sort by: ${sortPlayersBy}`}\n          label={`Sort by: ${sortPlayersBy}`}\n          onClick={anchorActions.handleClick}\n          endIcon={<Sort />}\n        />\n        <Menu\n          id=\"sort-by-menu\"\n          anchorEl={anchorEl}\n          keepMounted\n          open={Boolean(anchorEl)}\n          onClose={anchorActions.handleClose}\n        >\n          {sortOptions.map((it) => (\n            <MenuItem\n              key={it}\n              onClick={() => {\n                dispatch(commonSlice.actions.sortPlayerBy(it));\n                anchorActions.handleClose();\n              }}\n            >\n              {it}\n            </MenuItem>\n          ))}\n        </Menu>\n      </Toolbar>\n      <Box p={3} pt={0}>\n        <Box pb={2}>\n          <Typography variant=\"body1\">\n            A total of{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalPlayers} players\n            </Box>{' '}\n            have played{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalGames} games\n            </Box>{' '}\n            over{' '}\n            <Box component=\"span\" fontWeight=\"bold\">\n              {metaStats.totalSessions} sessions\n            </Box>\n            .\n          </Typography>\n        </Box>\n        <Grid container spacing={1}>\n          {playersWithTotalStatsSorted.map((it, index) => (\n            <Fragment key={it.playerId}>\n              <Grid item xs={12}>\n                <PlayerOverviewRow player={it} />\n              </Grid>\n              {index !== playersWithTotalStats.length - 1 && (\n                <Grid item xs={12}>\n                  <Divider />\n                </Grid>\n              )}\n            </Fragment>\n          ))}\n        </Grid>\n      </Box>\n    </Paper>\n  );\n}\n\nexport default PlayersOverview;\n\n'among-us-stats/src/components/App.tsx'\n:import React, { Suspense } from 'react';\nimport { CssBaseline, ThemeProvider } from '@material-ui/core';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { Provider } from 'react-redux';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nimport store, { persistor } from '../store/redux';\n\nimport AppBar from './appbar/AppBar';\nimport ActiveSession from './activesession/ActiveSession';\nimport Sessions from './sessions/Sessions';\nimport IntroDialog from './dialogs/IntroDialog';\nimport SettingsDialog from './dialogs/SettingsDialog';\nimport FeedbackDialog from './dialogs/FeedbackDialog';\nimport NotFound from './NotFound';\nimport Analytics from './Analytics';\nimport { theme } from './theme';\nimport ContentWrapper from './ContentWrapper';\nimport ErrorBoundary from './ErrorBoundary';\nimport FullscreenFallback from './shared/FullscreenFallback';\n\nconst LazyPlayersOverview = React.lazy(() => import('./playersoverview/PlayersOverview'));\n\nfunction App(): JSX.Element {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={null} persistor={persistor}>\n        <ThemeProvider theme={theme}>\n          <ErrorBoundary>\n            <Router>\n              <IntroDialog />\n              <SettingsDialog />\n              <FeedbackDialog />\n              <Analytics />\n              <CssBaseline />\n              <AppBar />\n              <ContentWrapper>\n                <Switch>\n                  <Route exact path={['/', '/summary']}>\n                    <ActiveSession />\n                  </Route>\n                  <Route path=\"/sessions\">\n                    <Sessions />\n                  </Route>\n                  <Route path=\"/players\">\n                    <Suspense fallback={<FullscreenFallback />}>\n                      <LazyPlayersOverview />\n                    </Suspense>\n                  </Route>\n                  <Route>\n                    <NotFound />\n                  </Route>\n                </Switch>\n              </ContentWrapper>\n            </Router>\n          </ErrorBoundary>\n        </ThemeProvider>\n      </PersistGate>\n    </Provider>\n  );\n}\n\nexport default App;\n\n'among-us-stats/src/components/playersoverview/usePlayerWithTotalStats.ts'\n:import { useSelector } from 'react-redux';\nimport { map } from 'rambda';\nimport { useMemo } from 'react';\n\nimport { RootState } from '../../store/redux';\nimport { Game, Player, Session, UUID } from '../../store/stats/statsRedux';\nimport { getWinnersPerGame, WinnersPerGameTuple } from '../../store/stats/statsUtils';\n\nexport interface PlayerStats extends Player {\n  gamesPlayed: number;\n  totalImpostorRate: number;\n  totalWinRate: number;\n  totalImpostorWinRate: number;\n  totalCrewWinRate: number;\n}\n\ninterface MetaStats {\n  totalGames: number;\n  totalPlayers: number;\n  totalSessions: number;\n}\n\nfunction usePlayersWithTotalStats(): [PlayerStats[], MetaStats] {\n  const statsState = useSelector((state: RootState) => state.stats);\n\n  return useMemo(() => {\n    const allSessions: Session[] = [statsState.session, ...statsState.previousSessions].filter(\n      (it) => it.players.length !== 0,\n    );\n    const allGames: Game[] = allSessions.flatMap((session) => session.games);\n    const allImpostors: UUID[] = allGames.flatMap((game) => game.impostors);\n    const winnersPerGame: WinnersPerGameTuple[] = getWinnersPerGame(allGames);\n    const gameCountPerPlayer: Record<UUID, number> = map(\n      (player) => allGames.filter((game) => game.players.includes(player.playerId)).length,\n      statsState.players,\n    );\n\n    return [\n      Object.keys(statsState.players).map((playerId) => {\n        const playerGameCount = gameCountPerPlayer[playerId];\n        const playerImpostorCount = allImpostors.filter((it) => it === playerId).length;\n        return {\n          playerId,\n          name: statsState.players[playerId].name,\n          gamesPlayed: playerGameCount,\n          totalImpostorRate: playerImpostorCount / playerGameCount,\n          totalWinRate: winnersPerGame.filter(([winners]) => winners.includes(playerId)).length / playerGameCount,\n          totalImpostorWinRate:\n            playerImpostorCount > 0\n              ? winnersPerGame.filter(([winners, wonByImpostors]) => wonByImpostors && winners.includes(playerId))\n                  .length / playerImpostorCount\n              : -1,\n          totalCrewWinRate:\n            playerGameCount - playerImpostorCount > 0\n              ? winnersPerGame.filter(([winners, wonByImpostors]) => !wonByImpostors && winners.includes(playerId))\n                  .length /\n                (playerGameCount - playerImpostorCount)\n              : -1,\n        };\n      }),\n      {\n        totalGames: allGames.length,\n        totalPlayers: Object.keys(statsState.players).length,\n        totalSessions: allSessions.length,\n      },\n    ];\n  }, [statsState]);\n}\n\nexport default usePlayersWithTotalStats;\n",
        "gt": [
            "'among-us-stats/src/components/playersoverview/usePlayerWithTotalStats.ts'",
            "'among-us-stats/src/components/playersoverview/PlayerOverviewRow.tsx'",
            "'among-us-stats/src/components/playersoverview/PlayersOverview.tsx'",
            "'among-us-stats/src/components/App.tsx'",
            "'among-us-stats/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'ngrx-example/src/app/_people/routes/people.list.route/people.list.route.ts'",
            "'ngrx-example/src/app/_people/services/people-selectors.service.ts'",
            "'ngrx-example/src/main.browser.ts'",
            "'ngrx-example/src/app/_people/routes/people.routes.ts'",
            "'ngrx-example/src/app/routes/routes.ts'",
            "'ngrx-example/src/app/services/utils.service.ts'"
        ],
        "content": "'ngrx-example/src/app/_people/routes/people.list.route/people.list.route.ts'\n:import {\n  Component,\n  OnInit,\n  OnDestroy\n} from 'angular2/core';\n\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { Store } from '@ngrx/store';\n\n\nimport { list, add } from '../../services/people-actions.service';\n\n\nimport { getList$ } from '../../services/people-selectors.service';\n\n\nimport {\n  PeopleListComponent\n} from '../../components/people-list.component/people-list.component';\n\n\nimport {\n  PersonFormComponent\n} from '../../components/person-form.component/person-form.component';\n\n@Component({\n  selector: 'people-list-route',\n  directives: [\n    PeopleListComponent,\n    PersonFormComponent\n  ],\n  template: require('./people.list.route.html'),\n  styles: [ require('./people.list.route.scss') ]\n})\nexport class PeopleListRoute implements OnInit, OnDestroy {\n\n  public people$: Observable<Array<any>> = this._store.let(getList$())\n\n\n  public onInit$ = new Subject<any>();\n  public onAdd$ = new Subject<any>();\n\n\n  public initAction$ = this.onInit$.map(list());\n  public addAction$ = this.onAdd$.map(add());\n\n  constructor(private _store: Store<any>) {}\n\n\n  private _subscription: Subscription;\n\n  ngOnInit() {\n    this._subscription = Observable\n      .merge(\n        this.initAction$,\n        this.addAction$\n      )\n      .subscribe(this._store);\n\n    this.onInit$.next(null);\n  }\n\n  ngOnDestroy() {\n    this._subscription.unsubscribe();\n  }\n\n}\n\n'ngrx-example/src/app/_people/services/people-selectors.service.ts'\n:import { ISelector } from '../../interfaces/ISelector';\nimport { IEntities } from '../../interfaces/IEntities';\nimport { IState } from '../../interfaces/IState';\nimport { IPeople } from '../interfaces/IPeople';\nimport { IPerson } from '../interfaces/IPerson';\n\nimport { recursiveReduce } from '../../services/utils.service';\n\nexport const getPeople$ = (): ISelector<IState, IPeople>  => {\n  return state$ => state$\n    .map((res: IState) => res.people)\n    .distinctUntilChanged();\n};\n\nexport const getEntities$ = (): ISelector<IState, Object>  => {\n  return state$ => state$\n    .map((res: IState) => res.entities)\n    .map((res: IEntities) => res.people);\n};\n\nexport const getList$ = (): ISelector<IState, Array<any>> => {\n  return state$ => state$\n    .let(getPeople$())\n    .combineLatest(\n      state$.let(getEntities$()),\n      (people, entities) => {\n        if (people.result && people.result.length) {\n        return people.result\n          .reduce((arr, id) => {\n            arr.push(entities[id]);\n\n            return arr;\n          }, [])\n\n          .sort((a, b) => {\n            if (a[people.sort] < b[people.sort]) {\n              return -1;\n            } else if (a[people.sort] > b[people.sort]) {\n              return 1;\n            } else {\n              return 0;\n            }\n          });\n        } else {\n          return [];\n        }\n      }\n    )\n};\n\nexport const getOne$ = (id): ISelector<IState, IPerson> => {\n  return state$ => state$\n    .let(getEntities$())\n    .map(peopleEnt => {\n      if (peopleEnt[id]) {\n        return peopleEnt[id];\n      }\n\n      return {};\n    });\n};\n'ngrx-example/src/main.browser.ts'\n:\nimport { bootstrap } from 'angular2/platform/browser';\n\nimport { DIRECTIVES, PIPES, PROVIDERS } from './platform/browser';\nimport { ENV_PROVIDERS } from './platform/environment';\n\n\nimport { AppComponent, APP_PROVIDERS } from './app';\n\n\nimport { APP_ROUTES_PROVIDER } from './app/routes/routes';\n\n\nimport { APP_REDUCERS_PROVIDER } from './app/reducers/reducers';\n\n\nimport { APP_COMPONENTS_PROVIDERS } from './app/components/components';\nimport { APP_CONTAINERS_PROVIDERS } from './app/containers/containers';\n\n\nimport { APP_SERVICES } from './app/services/services';\n\n\nexport function main(initialHmrState?: any): Promise<any> {\n\n  return bootstrap(AppComponent, [\n    ...ENV_PROVIDERS,\n    ...PROVIDERS,\n    ...DIRECTIVES,\n    ...PIPES,\n    ...APP_PROVIDERS,\n    APP_ROUTES_PROVIDER,\n    APP_REDUCERS_PROVIDER,\n    APP_COMPONENTS_PROVIDERS,\n    APP_CONTAINERS_PROVIDERS,\n    APP_SERVICES\n  ])\n  .catch(err => console.error(err));\n\n}\n\n\nif ('development' === ENV && HMR === true) {\n\n  let ngHmr = require('angular2-hmr');\n  ngHmr.hotModuleReplacement(main, module);\n} else {\n\n  document.addEventListener('DOMContentLoaded', () => main());\n}\n\n'ngrx-example/src/app/_people/routes/people.routes.ts'\n:import { Routes } from '@ngrx/router';\n\nimport { PeopleRoute } from './people.route/people.route';\nimport { PeopleListRoute } from './people.list.route/people.list.route';\nimport { PeopleDetailRoute } from './people.detail.route/people.detail.route';\nimport { PeopleEditRoute } from './people.edit.route/people.edit.route';\n\nexport const peopleRoutes: Routes = [\n  {\n    path: '/people',\n    component: PeopleRoute,\n    indexRoute: {\n      component: PeopleListRoute\n    },\n    children: [\n      {\n        path: ':id',\n        component: PeopleDetailRoute\n      },\n      {\n        path: ':id/edit',\n        component: PeopleEditRoute\n      }\n    ]\n  }\n];\n\n'ngrx-example/src/app/routes/routes.ts'\n:import { provideRouter, Routes, createGuard } from '@ngrx/router';\n\nimport { FofRoute } from './fof.route/fof.route';\n\nimport { homeRoutes } from '../_home/routes/home.routes';\nimport { peopleRoutes } from '../_people/routes/people.routes';\nimport { authRoutes } from '../_auth/routes/auth.routes';\nimport { catsRoutes } from '../_cats/routes/cats.routes';\n\nconst routes: Routes = [\n  ...homeRoutes,\n  ...peopleRoutes,\n  ...authRoutes,\n  ...catsRoutes,\n  {\n    path: '/**',\n    component: FofRoute\n  }\n];\n\nexport const APP_ROUTES_PROVIDER = provideRouter(routes);\n\n'ngrx-example/src/app/services/utils.service.ts'\n:import { Saga } from 'store-saga';\n\nvar flattenDeep = require('lodash/flattenDeep');\nvar uniq = require('lodash/uniq');\n\nimport { SET_ERROR } from '../reducers/errors.reducer';\n\nexport function recursiveReduce(\n  source: Array<number>,\n  entities: Object,\n  by: string,\n  entryLevel?: number): Array<any> {\n\n  return source.reduce((arr, id) => {\n    var ent = Object.assign({}, entities[id]);\n\n    if (ent.level === entryLevel || !entryLevel) {\n      if (ent[by] && ent[by].length) {\n        ent[by] = recursiveReduce(ent[by], entities, by);\n      }\n      arr.push(ent);\n    }\n\n    return arr;\n\n  }, []);\n\n}\n\nexport const getSingleEntityObject = (\n  name: string,\n  id: number,\n  payload: Object) => {\n\n  var data = { entities: {} };\n  data.entities[name] = {};\n  data.entities[name][id] = payload;\n\n  return data;\n};\n\nexport const getUncachedEntities = (\n  source: Array<any>,\n  key: string,\n  from: Object): Array<any> => {\n\n  let ids = uniq(flattenDeep(source.map(res => res[key])));\n\n  return ids.reduce((arr, id) => {\n    if (!from[id]) {\n      arr.push(id);\n    }\n    return arr;\n  }, []);\n};\n\nexport const getUrlWithIds = (\n  url: string,\n  ids?: Array<number>) => {\n\n  var append = ids ? `?ids=${ids.join(',')}` : '';\n  return `/${url + append}`;\n};\n\n\nexport const shouldLoad = (entity: string, key: string): Saga<any> => {\n  return saga$ => saga$.filter(saga$ => {\n    return !saga$.state.entities[entity][saga$.action[key]];\n  });\n};\n\nexport function generateErrorPayload(payload, type: string) {\n  var r = {\n    type: SET_ERROR,\n    payload: {\n      errors: [],\n      key: type\n    }\n  };\n\n  if (payload.message) {\n    r.payload.errors.push({\n      text: payload.message,\n      main: true\n    });\n  }\n\n  if (payload.errors && payload.errors.length) {\n\n    if (typeof payload.errors === 'string') {\n      r.payload.errors.push({\n        text: payload.errors\n      });\n    } else {\n      payload.errors.forEach(item => {\n        r.payload.errors.push({\n          text: item\n        });\n      });\n    }\n\n\n  }\n\n  return r;\n};\n\nexport function generateResponse(payload, successType: string, errorType: string, cb?) {\n  var r = {};\n  if (payload.status < 400 || !payload.status) {\n    var asJson = payload.text() ? payload.json() : null;\n\n    r = Object.assign({}, r, {\n      type: successType,\n      payload: cb ? cb.call(this, asJson) : null\n    });\n\n  } else {\n    var payloadAsJson = payload.json();\n\n    r = Object.assign({}, r, generateErrorPayload(payloadAsJson, errorType));\n  }\n\n  return r;\n}\n",
        "gt": [
            "'ngrx-example/src/app/services/utils.service.ts'",
            "'ngrx-example/src/app/_people/services/people-selectors.service.ts'",
            "'ngrx-example/src/app/_people/routes/people.list.route/people.list.route.ts'",
            "'ngrx-example/src/app/_people/routes/people.routes.ts'",
            "'ngrx-example/src/app/routes/routes.ts'",
            "'ngrx-example/src/main.browser.ts'"
        ]
    },
    {
        "files": [
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/event-form/event-form.component.ts'"
        ],
        "content": "'mean-rsvp-auth0/src/app/core/models/event.model.ts'\n:class EventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDatetime: Date,\n    public endDatetime: Date,\n    public viewPublic: boolean,\n    public description?: string,\n    public _id?: string,\n  ) { }\n}\n\nclass FormEventModel {\n  constructor(\n    public title: string,\n    public location: string,\n    public startDate: string,\n    public startTime: string,\n    public endDate: string,\n    public endTime: string,\n    public viewPublic: boolean,\n    public description?: string\n  ) { }\n}\n\nexport { EventModel, FormEventModel };\n\n'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n\n'mean-rsvp-auth0/src/app/pages/admin/event-form/event-form.component.ts'\n:import { Component, OnInit, OnDestroy, Input } from '@angular/core';\nimport { FormGroup, FormBuilder, Validators, AbstractControl } from '@angular/forms';\nimport { Router } from '@angular/router';\nimport { Subscription } from 'rxjs';\nimport { ApiService } from './../../../core/api.service';\nimport { EventModel, FormEventModel } from './../../../core/models/event.model';\nimport { DatePipe } from '@angular/common';\nimport { dateValidator } from './../../../core/forms/date.validator';\nimport { dateRangeValidator } from './../../../core/forms/date-range.validator';\nimport { DATE_REGEX, TIME_REGEX, stringsToDate } from './../../../core/forms/formUtils.factory';\nimport { EventFormService } from './event-form.service';\n\n@Component({\n  selector: 'app-event-form',\n  templateUrl: './event-form.component.html',\n  styleUrls: ['./event-form.component.scss'],\n  providers: [ EventFormService ]\n})\nexport class EventFormComponent implements OnInit, OnDestroy {\n  @Input() event: EventModel;\n  isEdit: boolean;\n\n  eventForm: FormGroup;\n  datesGroup: AbstractControl;\n\n  formEvent: FormEventModel;\n\n  formErrors: any;\n  formChangeSub: Subscription;\n\n  submitEventObj: EventModel;\n  submitEventSub: Subscription;\n  error: boolean;\n  submitting: boolean;\n  submitBtnText: string;\n\n  constructor(\n    private fb: FormBuilder,\n    private api: ApiService,\n    private datePipe: DatePipe,\n    public ef: EventFormService,\n    private router: Router\n  ) { }\n\n  ngOnInit() {\n    this.formErrors = this.ef.formErrors;\n    this.isEdit = !!this.event;\n    this.submitBtnText = this.isEdit ? 'Update Event' : 'Create Event';\n\n    this.formEvent = this._setFormEvent();\n\n    this._buildForm();\n  }\n\n  private _setFormEvent() {\n    if (!this.isEdit) {\n\n\n      return new FormEventModel(null, null, null, null, null, null, null);\n    } else {\n\n\n\n\n\n\n      const _shortDate = 'M/d/yyyy';\n      return new FormEventModel(\n        this.event.title,\n        this.event.location,\n        this.datePipe.transform(this.event.startDatetime, _shortDate),\n        this.datePipe.transform(this.event.startDatetime, 'shortTime'),\n        this.datePipe.transform(this.event.endDatetime, _shortDate),\n        this.datePipe.transform(this.event.endDatetime, 'shortTime'),\n        this.event.viewPublic,\n        this.event.description\n      );\n    }\n  }\n\n  private _buildForm() {\n    this.eventForm = this.fb.group({\n      title: [this.formEvent.title, [\n        Validators.required,\n        Validators.minLength(this.ef.textMin),\n        Validators.maxLength(this.ef.titleMax)\n      ]],\n      location: [this.formEvent.location, [\n        Validators.required,\n        Validators.minLength(this.ef.textMin),\n        Validators.maxLength(this.ef.locMax)\n      ]],\n      viewPublic: [this.formEvent.viewPublic,\n        Validators.required\n      ],\n      description: [this.formEvent.description,\n        Validators.maxLength(this.ef.descMax)\n      ],\n      datesGroup: this.fb.group({\n        startDate: [this.formEvent.startDate, [\n          Validators.required,\n          Validators.maxLength(this.ef.dateMax),\n          Validators.pattern(DATE_REGEX),\n          dateValidator()\n        ]],\n        startTime: [this.formEvent.startTime, [\n          Validators.required,\n          Validators.maxLength(this.ef.timeMax),\n          Validators.pattern(TIME_REGEX)\n        ]],\n        endDate: [this.formEvent.endDate, [\n          Validators.required,\n          Validators.maxLength(this.ef.dateMax),\n          Validators.pattern(DATE_REGEX),\n          dateValidator()\n        ]],\n        endTime: [this.formEvent.endTime, [\n          Validators.required,\n          Validators.maxLength(this.ef.timeMax),\n          Validators.pattern(TIME_REGEX)\n        ]]\n      }, { validator: dateRangeValidator })\n    });\n\n    this.datesGroup = this.eventForm.get('datesGroup');\n\n\n    this.formChangeSub = this.eventForm\n      .valueChanges\n      .subscribe(data => this._onValueChanged());\n\n\n\n\n    if (this.isEdit) {\n      const _markDirty = group => {\n        for (const i in group.controls) {\n          if (group.controls.hasOwnProperty(i)) {\n            group.controls[i].markAsDirty();\n          }\n        }\n      };\n      _markDirty(this.eventForm);\n      _markDirty(this.datesGroup);\n    }\n\n    this._onValueChanged();\n  }\n\n  private _onValueChanged() {\n    if (!this.eventForm) { return; }\n    const _setErrMsgs = (control: AbstractControl, errorsObj: any, field: string) => {\n      if (control && control.dirty && control.invalid) {\n        const messages = this.ef.validationMessages[field];\n        for (const key in control.errors) {\n          if (control.errors.hasOwnProperty(key)) {\n            errorsObj[field] += messages[key] + '<br>';\n          }\n        }\n      }\n    };\n\n\n    for (const field in this.formErrors) {\n      if (this.formErrors.hasOwnProperty(field)) {\n        if (field !== 'datesGroup') {\n\n\n          this.formErrors[field] = '';\n          _setErrMsgs(this.eventForm.get(field), this.formErrors, field);\n        } else {\n\n          const datesGroupErrors = this.formErrors['datesGroup'];\n          for (const dateField in datesGroupErrors) {\n            if (datesGroupErrors.hasOwnProperty(dateField)) {\n\n              datesGroupErrors[dateField] = '';\n              _setErrMsgs(this.datesGroup.get(dateField), datesGroupErrors, dateField);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  private _getSubmitObj() {\n    const startDate = this.datesGroup.get('startDate').value;\n    const startTime = this.datesGroup.get('startTime').value;\n    const endDate = this.datesGroup.get('endDate').value;\n    const endTime = this.datesGroup.get('endTime').value;\n\n\n    return new EventModel(\n      this.eventForm.get('title').value,\n      this.eventForm.get('location').value,\n      stringsToDate(startDate, startTime),\n      stringsToDate(endDate, endTime),\n      this.eventForm.get('viewPublic').value,\n      this.eventForm.get('description').value,\n      this.event ? this.event._id : null\n    );\n  }\n\n  onSubmit() {\n    this.submitting = true;\n    this.submitEventObj = this._getSubmitObj();\n\n    if (!this.isEdit) {\n      this.submitEventSub = this.api\n        .postEvent$(this.submitEventObj)\n        .subscribe(\n          data => this._handleSubmitSuccess(data),\n          err => this._handleSubmitError(err)\n        );\n    } else {\n      this.submitEventSub = this.api\n        .editEvent$(this.event._id, this.submitEventObj)\n        .subscribe(\n          data => this._handleSubmitSuccess(data),\n          err => this._handleSubmitError(err)\n        );\n    }\n  }\n\n  private _handleSubmitSuccess(res) {\n    this.error = false;\n    this.submitting = false;\n\n    this.router.navigate(['/event', res._id]);\n  }\n\n  private _handleSubmitError(err) {\n    console.error(err);\n    this.submitting = false;\n    this.error = true;\n  }\n\n  resetForm() {\n    this.eventForm.reset();\n  }\n\n  ngOnDestroy() {\n    if (this.submitEventSub) {\n      this.submitEventSub.unsubscribe();\n    }\n    this.formChangeSub.unsubscribe();\n  }\n\n}\n",
        "gt": [
            "'mean-rsvp-auth0/src/app/core/models/event.model.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/event-form/event-form.component.ts'",
            "'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'"
        ]
    },
    {
        "files": [
            "'is-even/apps/backend/src/common/model/base-readonly.enity.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/payment/payment.service.ts'",
            "'is-even/apps/backend/src/payment/payment.entity.ts'"
        ],
        "content": "'is-even/apps/backend/src/common/model/base-readonly.enity.ts'\n:import { CreateDateColumn, PrimaryGeneratedColumn } from 'typeorm';\n\nexport abstract class BaseReadonlyEntity {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @CreateDateColumn()\n  createdAt: Date;\n}\n\n'is-even/apps/backend/src/app/app.module.ts'\n:import { Module } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { AwsSdkModule } from 'nest-aws-sdk';\nimport { CognitoIdentityServiceProvider } from 'aws-sdk';\n\nimport { AppController } from './app.controller';\nimport { AppConfigService } from '../config/config.service';\nimport { AppConfigModule } from '../config/config.module';\nimport { UserModule } from '../user/user.module';\nimport { LoggerModule } from '../logger/logger.module';\nimport { AuthModule } from '../auth/auth.module';\nimport { ApiKeyModule } from '../api-key/api-key.module';\nimport { CreditModule } from '../credit/credit.module';\nimport { UsageModule } from '../usage/usage.module';\nimport { OrderModule } from '../order/order.module';\nimport { PaymentModule } from '../payment/payment.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    TypeOrmModule.forRootAsync({\n      inject: [AppConfigService],\n      imports: [AppConfigModule],\n      useFactory: async (configService: AppConfigService) => {\n        return configService.databaseConfig;\n      },\n    }),\n    AwsSdkModule.forRootAsync({\n      defaultServiceOptions: {\n        useFactory: (configService: AppConfigService) => {\n          return {\n            region: configService.awsConfig.region,\n          };\n        },\n        inject: [AppConfigService],\n        imports: [AppConfigModule],\n      },\n      services: [CognitoIdentityServiceProvider],\n    }),\n    AppConfigModule,\n    LoggerModule,\n    UserModule,\n    AuthModule,\n    ApiKeyModule,\n    CreditModule,\n    UsageModule,\n    OrderModule,\n    PaymentModule,\n    SentryModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {}\n\n'is-even/apps/backend/src/main.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';\nimport { ValidationPipe } from '@nestjs/common';\nimport { NestExpressApplication } from '@nestjs/platform-express';\nimport * as helmet from 'helmet';\nimport * as rateLimit from 'express-rate-limit';\n\nimport { AppModule } from './app/app.module';\nimport { AppConfigService } from './config/config.service';\nimport { webhookRawBodyMiddleware } from './common/middlewere/webhook-raw-body.middlewere';\n\nasync function bootstrap() {\n  const app = await NestFactory.create<NestExpressApplication>(AppModule);\n\n  app.use(helmet());\n\n  app.useGlobalPipes(new ValidationPipe({ transform: true }));\n  app.use(webhookRawBodyMiddleware());\n\n  const config = app.get(AppConfigService);\n\n  if (config.appConfig.cors) {\n    app.enableCors();\n  }\n  if (config.appConfig.behindProxy) {\n    app.set('trust proxy', 1);\n  }\n\n  app.use(\n    rateLimit({\n      windowMs: config.rateLimitConfig.ttlMs,\n      max: config.rateLimitConfig.maxRequests,\n    }),\n  );\n\n  if (config.swaggerConfig.enabled) {\n    const swaggerParams = new DocumentBuilder()\n      .setTitle(config.swaggerConfig.title)\n      .setDescription(config.swaggerConfig.description)\n      .setVersion(config.swaggerConfig.version)\n      .build();\n\n    const document = SwaggerModule.createDocument(app, swaggerParams);\n    SwaggerModule.setup('docs', app, document);\n  }\n\n  await app.listen(process.env.PORT || 3000);\n}\nbootstrap();\n\n'is-even/apps/backend/src/payment/payment.module.ts'\n:import { Module } from '@nestjs/common';\nimport { TypeOrmModule } from '@nestjs/typeorm';\n\nimport { PaymentService } from './payment.service';\nimport { PaymentController } from './payment.controller';\nimport { Payment } from './payment.entity';\n\nimport { LoggerModule } from '../logger/logger.module';\nimport { StripeModule } from '../stripe/stripe.module';\nimport { OrderModule } from '../order/order.module';\nimport { SentryModule } from '../sentry/sentry.module';\n\n@Module({\n  providers: [PaymentService],\n  controllers: [PaymentController],\n  imports: [\n    LoggerModule,\n    StripeModule,\n    OrderModule,\n    SentryModule,\n    TypeOrmModule.forFeature([Payment]),\n  ],\n  exports: [PaymentService],\n})\nexport class PaymentModule {}\n\n'is-even/apps/backend/src/payment/payment.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\n\nimport { LoggerService } from '../logger/logger.service';\nimport { StripeService } from '../stripe/stripe.service';\nimport { SentryService } from '../sentry/sentry.service';\n\nimport { Payment } from './payment.entity';\nimport { Order } from '../order/order.entity';\n\nimport { PaymentSession } from './interface/payment-session.interface';\nimport { SessionEvent } from './interface/session-event.interface';\nimport { sessionEventMapper } from './mapper/session-event.mapper';\n\nimport { RegisterPaymentError } from './error/register-payment.error';\nimport { ConstructPaymentEventError } from './error/construct-payment-event.error';\nimport { CreatePaymentError } from './error/create-payment.error';\nimport { PaymentStatus } from './interface/payment-status.interface';\nimport { InvalidPaymentStatusError } from './error/invalid-payment-status.error';\nimport { UpdatePaymentError } from './error/update-payment.error';\n\n@Injectable()\nexport class PaymentService {\n  constructor(\n    private readonly loggerService: LoggerService,\n    @InjectRepository(Payment)\n    private readonly paymentRepository: Repository<Payment>,\n    private readonly stripeService: StripeService,\n    private readonly sentryService: SentryService,\n  ) {\n    this.loggerService.setContext(PaymentService.name);\n  }\n\n  public async registerPayment(order: Order): Promise<PaymentSession> {\n    try {\n      const price = order.price;\n\n      const session = await this.stripeService.createSession([\n        {\n          quantity: 1,\n          price_data: {\n            currency: 'eur',\n            unit_amount: price,\n            product_data: {\n              name: `is-even_${order.creditDuration}_${order.creditLimit}`,\n            },\n          },\n        },\n      ]);\n\n      return { url: session.url, id: session.id };\n    } catch (error) {\n      this.loggerService.error(`Failed to register payment. ${error.message}`);\n\n      this.sentryService.instance.withScope((scope) => {\n        scope.setTag('where', 'paymentService.registerPayment');\n        scope.setExtra('order.id', order.id);\n        this.sentryService.instance.captureException(error);\n      });\n\n      throw new RegisterPaymentError(error);\n    }\n  }\n\n  public async constructSessionEvent(\n    payload: string,\n    signature: string,\n  ): Promise<SessionEvent> {\n    try {\n      const stripeEvent = await this.stripeService.constructEvent(\n        payload,\n        signature,\n      );\n      return sessionEventMapper(stripeEvent);\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to construct session event. ${error.message}`,\n      );\n\n      this.sentryService.instance.withScope((scope) => {\n        scope.setTag('where', 'paymentService.constructSessionEvent');\n        this.sentryService.instance.captureException(error);\n      });\n\n      throw new ConstructPaymentEventError(error);\n    }\n  }\n\n  public async createPayment(\n    sessionId: string,\n    order: Order,\n  ): Promise<Payment> {\n    try {\n      const payment = new Payment();\n\n      payment.order = order;\n      payment.user = order.user;\n      payment.sessionId = sessionId;\n\n      return await this.paymentRepository.save(payment);\n    } catch (error) {\n      this.loggerService.error(`Failed to create payment. ${error.message}`);\n      throw new CreatePaymentError(error);\n    }\n  }\n\n  public async getPaymentBySessionId(sessionId: string): Promise<Payment> {\n    try {\n      return await this.paymentRepository.findOneOrFail({\n        where: {\n          sessionId,\n        },\n      });\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to get payment by sessionId ${sessionId}. ${error.message}`,\n      );\n      throw error;\n    }\n  }\n\n  public async updatePaymentStatus(\n    payment: Payment,\n    status: PaymentStatus,\n  ): Promise<Payment> {\n    this.loggerService.log(\n      `Updating payment: ${payment.id} with status: ${status}`,\n    );\n\n    if (payment.status === status) {\n      this.loggerService.error(\n        `Cannot update payment status with the exact same value`,\n      );\n      throw new InvalidPaymentStatusError(\n        `Cannot update payment status with the exact same value`,\n      );\n    }\n\n    if (payment.status === PaymentStatus.Successful) {\n      this.loggerService.error(\n        `Cannot change the status of successfull payment's`,\n      );\n      throw new InvalidPaymentStatusError(\n        `Cannot change the status of successfull payment's`,\n      );\n    }\n\n    try {\n      payment.status = status;\n      return await this.paymentRepository.save(payment);\n    } catch (error) {\n      this.loggerService.error(\n        `Failed to update payment status. ${error.message}`,\n      );\n      throw new UpdatePaymentError(error.message);\n    }\n  }\n}\n\n'is-even/apps/backend/src/payment/payment.entity.ts'\n:import { Column, Entity, ManyToOne, JoinColumn } from 'typeorm';\n\nimport { Order } from '../order/order.entity';\nimport { User } from '../user/user.entity';\nimport { BaseReadonlyEntity } from '../common/model/base-readonly.enity';\nimport { PaymentStatus } from './interface/payment-status.interface';\n\n@Entity()\nexport class Payment extends BaseReadonlyEntity {\n  @Column({\n    name: 'session_id',\n    type: 'varchar',\n    length: 128,\n    unique: true,\n  })\n  public sessionId: string;\n\n  @Column({\n    name: 'status',\n    type: 'enum',\n    enum: PaymentStatus,\n    default: PaymentStatus.Pending,\n  })\n  public status: PaymentStatus;\n\n  @ManyToOne(() => User, { eager: true })\n  @JoinColumn({ name: 'user_id', referencedColumnName: 'id' })\n  public user: User;\n\n  @ManyToOne(() => Order, { eager: true })\n  @JoinColumn({ name: 'order_id', referencedColumnName: 'id' })\n  public order: Order;\n}\n",
        "gt": [
            "'is-even/apps/backend/src/common/model/base-readonly.enity.ts'",
            "'is-even/apps/backend/src/payment/payment.entity.ts'",
            "'is-even/apps/backend/src/payment/payment.service.ts'",
            "'is-even/apps/backend/src/payment/payment.module.ts'",
            "'is-even/apps/backend/src/app/app.module.ts'",
            "'is-even/apps/backend/src/main.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/api/admin/submit/results/dto/submit-contest-result.dto.ts'",
            "'Rankings-Backend/src/api/admin/index.ts'",
            "'Rankings-Backend/src/api/admin/api.module.ts'",
            "'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.service.ts'",
            "'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.controller.ts'",
            "'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.module.ts'"
        ],
        "content": "'Rankings-Backend/src/api/admin/submit/results/dto/submit-contest-result.dto.ts'\n:import * as Joi from 'joi';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { APIErrors } from 'shared/exceptions/api.exceptions';\n\nexport interface ContestResult {\n  readonly contestId: string;\n  readonly discipline: number;\n  readonly places: { athleteId: string; place: number; points?: number }[];\n}\n\nexport class SubmitContestResultDto implements ContestResult {\n  public readonly places: { athleteId: string; place: number; points?: number }[];\n  public readonly contestId: string;\n  public readonly discipline: Discipline;\n}\n\nexport const submitContestResultDtoSchema = Joi.object().keys({\n  contestId: Joi.string()\n    .required()\n    .error(new APIErrors.JoiValidationError('Unknown contestId')),\n  discipline: Joi.number()\n    .required()\n    .valid(DisciplineUtility.CompetitionDisciplines)\n    .error(new APIErrors.JoiValidationError('Invalid discipline')),\n  places: Joi.array()\n    .min(2)\n    .required()\n    .items(\n      Joi.object()\n        .keys({\n          athleteId: Joi.string()\n            .required()\n            .error(new APIErrors.JoiValidationError('Unknown athleteId')),\n          place: Joi.number()\n            .required()\n            .error(new APIErrors.JoiValidationError('Unknown place')),\n          points: Joi.number()\n            .optional()\n            .allow(null, '')\n            .error(new APIErrors.JoiValidationError('Unknown points')),\n        })\n        .required(),\n    )\n    .error(new APIErrors.JoiValidationError('Invalid Results')),\n});\n\n'Rankings-Backend/src/api/admin/index.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { APIGatewayEvent, Callback, Context, Handler } from 'aws-lambda';\n\nimport 'shared';\n\nimport { AllExceptionsFilter } from 'shared/filters/exception.filter';\nimport { waitForLogger } from 'shared/logger';\nimport { AppModule } from './api.module';\n\nimport * as serverless from 'aws-serverless-express';\nimport { eventContext } from 'aws-serverless-express/middleware';\n\nimport { Server } from 'http';\nimport env_variables from 'shared/env_variables';\nlet cachedServer: Server;\n\n\nconst express = require('express')();\n\nasync function bootstrapServer(): Promise<any> {\n  return NestFactory.create(AppModule, express, {\n    bodyParser: true,\n    logger: env_variables.isDev ? undefined : false,\n  })\n    .then(app => {\n      app.use(eventContext());\n      app.useGlobalFilters(new AllExceptionsFilter());\n      app.setGlobalPrefix('admin/api');\n      app.enableCors();\n      return app.init();\n    })\n    .then(() => {\n      return serverless.createServer(express);\n    });\n}\n\nexport const handler: Handler = async (event: APIGatewayEvent, context: Context) => {\n\n  context.succeed = succeedWaitsLogger(context.succeed);\n  if (!cachedServer) {\n    cachedServer = await bootstrapServer();\n  }\n  return serverless.proxy(cachedServer, event, context, 'PROMISE').promise;\n};\n\nfunction succeedWaitsLogger(succeed: Context['succeed']): Context['succeed'] {\n  return (messageObject: any) => {\n    return waitForLogger()\n      .then(() => {\n        succeed(messageObject);\n      })\n      .catch(error => {\n        succeed(messageObject);\n      });\n  };\n}\n\n'Rankings-Backend/src/api/admin/api.module.ts'\n:import { HelmetMiddleware } from '@nest-middlewares/helmet';\nimport { MethodOverrideMiddleware } from '@nest-middlewares/method-override';\nimport { MorganMiddleware } from '@nest-middlewares/morgan';\nimport { MiddlewareConsumer, Module } from '@nestjs/common';\n\nimport env_variables from 'shared/env_variables';\nimport { AthleteModule } from './athlete/athlete.module';\nimport { ContestModule } from './contest/contest.module';\nimport { ResultsModule } from './results/results.module';\nimport { SubmitAthleteModule } from './submit/athlete/submit-athlete.module';\nimport { SubmitContestModule } from './submit/contest/submit-contest.module';\nimport { SubmitContestResultsModule } from './submit/results/submit-contest-result.module';\n\n@Module({\n  imports: [\n    SubmitContestModule,\n    SubmitAthleteModule,\n    SubmitContestResultsModule,\n    ContestModule,\n    AthleteModule,\n    ResultsModule,\n  ],\n  providers: [],\n  exports: [],\n})\nexport class AppModule {\n  public configure(consumer: MiddlewareConsumer) {\n    MorganMiddleware.configure(env_variables.morganConfig);\n    consumer.apply(MorganMiddleware).forRoutes('*');\n    consumer.apply(MethodOverrideMiddleware).forRoutes('*');\n    consumer.apply(HelmetMiddleware).forRoutes('*');\n  }\n}\n\n'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.service.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport {\n  AthletePointsDictionary,\n  ContestPointsCalculatorService,\n  DetailedContestResult,\n} from 'core/contest/points-calculator.service';\nimport { DatabaseService } from 'core/database/database.service';\nimport { ContestType } from 'shared/enums';\nimport { APIErrors } from 'shared/exceptions/api.exceptions';\nimport { SubmitContestResultDto } from './dto/submit-contest-result.dto';\n\n@Injectable()\nexport class SubmitContestResultService {\n  constructor(\n    private readonly db: DatabaseService,\n    private readonly pointsCalculator: ContestPointsCalculatorService,\n  ) {}\n\n  public async submitContestResult(dto: SubmitContestResultDto) {\n    const contest = await this.findContest(dto);\n\n    const athletes = await this.findAthletes(dto);\n\n    const athletePointsDict = this.calculatePoints(dto, contest.contestType);\n    const failures = await this.putResultsIntoDB(contest, dto, athletePointsDict);\n    if (failures.length > 0) {\n      throw new APIErrors.OperationFailedError(\n        'Some athlete results failed when writing to database',\n        JSON.stringify(failures),\n      );\n    }\n  }\n\n  private async putResultsIntoDB(\n    contest: Contest,\n    contestResults: SubmitContestResultDto,\n    athletePointsDict: AthletePointsDictionary,\n  ) {\n    const dbFailedAthleteResults: AthleteContestResult[] = [];\n    for (const athlete of contestResults.places) {\n      const { points, place } = athletePointsDict[athlete.athleteId];\n      const athleteResult = new AthleteContestResult({\n        contestId: contest.id,\n        athleteId: athlete.athleteId,\n        place: place,\n        points: points,\n        contestDate: contest.date,\n        contestDiscipline: contest.discipline,\n      });\n      await this.db\n        .putContestResult(athleteResult)\n        .then(data => data)\n        .catch(err => {\n          dbFailedAthleteResults.push(athleteResult);\n        });\n    }\n    return dbFailedAthleteResults;\n  }\n\n  private calculatePoints(contestScores: SubmitContestResultDto, category: ContestType) {\n    const contestResults: DetailedContestResult = {\n      contestId: contestScores.contestId,\n      discipline: contestScores.discipline,\n      places: contestScores.places,\n      category: category,\n    };\n    const athletePointsDict = this.pointsCalculator.calculatePoints(contestResults);\n    return athletePointsDict;\n  }\n\n  private async findContest(dto: SubmitContestResultDto) {\n    const contest = await this.db.getContest(dto.contestId, dto.discipline);\n    if (!contest) {\n      throw new APIErrors.ContestNotFoundError(dto.contestId, dto.discipline);\n    }\n    return contest;\n  }\n\n  private async findAthletes(dto: SubmitContestResultDto) {\n    const athleteIds = dto.places.map(athlete => {\n      return athlete.athleteId;\n    });\n    const notFoundAthletes: string[] = [];\n    const athletes = await Promise.all(\n      athleteIds.map(async id => {\n        const athlete = await this.db.getAthleteDetails(id);\n        if (!athlete) {\n          notFoundAthletes.push(id);\n        }\n        return athlete;\n      }),\n    );\n    if (notFoundAthletes.length > 0) {\n      throw new APIErrors.AthleteNotFoundError(notFoundAthletes);\n    }\n    return athletes;\n  }\n}\n\n'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.controller.ts'\n:import { Body, Controller, Post, UseGuards, UsePipes } from '@nestjs/common';\nimport { Roles } from 'shared/decorators/roles.decorator';\nimport { AuthenticationRole } from 'shared/enums';\nimport { RolesGuard } from 'shared/guards/roles.guard';\nimport { logger } from 'shared/logger';\nimport { JoiValidationPipe } from 'shared/pipes/JoiValidation.pipe';\nimport { SubmitContestResultDto, submitContestResultDtoSchema } from './dto/submit-contest-result.dto';\nimport { SubmitContestResultService } from './submit-contest-result.service';\n\n@Controller('submit/contest/results')\nexport class SubmitContestResultController {\n  constructor(private readonly service: SubmitContestResultService) {}\n\n  @Post()\n\n\n  @UsePipes(new JoiValidationPipe(submitContestResultDtoSchema))\n  public async submitContestResults(@Body() dto: SubmitContestResultDto) {\n    logger.info('Submit Results', { data: dto });\n    return await this.service.submitContestResult(dto);\n  }\n}\n\n'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.module.ts'\n:import { Module } from '@nestjs/common';\nimport { DatabaseModule } from 'api/admin/database.module';\nimport { ContestPointsCalculatorService } from 'core/contest/points-calculator.service';\nimport { SubmitContestResultController } from './submit-contest-result.controller';\nimport { SubmitContestResultService } from './submit-contest-result.service';\n\n@Module({\n  imports: [DatabaseModule],\n  controllers: [SubmitContestResultController],\n  providers: [SubmitContestResultService, ContestPointsCalculatorService],\n})\nexport class SubmitContestResultsModule {}\n",
        "gt": [
            "'Rankings-Backend/src/api/admin/submit/results/dto/submit-contest-result.dto.ts'",
            "'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.service.ts'",
            "'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.controller.ts'",
            "'Rankings-Backend/src/api/admin/submit/results/submit-contest-result.module.ts'",
            "'Rankings-Backend/src/api/admin/api.module.ts'",
            "'Rankings-Backend/src/api/admin/index.ts'"
        ]
    },
    {
        "files": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeInternalSlot.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/DeclareInterface.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertFunctionTypeAnnotation.ts'"
        ],
        "content": "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeInternalSlot.ts'\n:import * as t from '@babel/types';\nimport { convertFlowType } from './convertFlowType';\nimport { convertFunctionTypeAnnotation } from './convertFunctionTypeAnnotation';\nimport { baseNodeProps } from '../utils/baseNodeProps';\n\nexport function convertObjectTypeInternalSlot(\n  property: t.ObjectTypeInternalSlot\n) {\n  if (property.method) {\n    if (!t.isFunctionTypeAnnotation(property.value)) {\n      throw new Error('FunctionTypeAnnotation expected');\n    }\n    const { typeParams, parameters, returnType } =\n      convertFunctionTypeAnnotation(property.value);\n    const methodSignature = t.tsMethodSignature(\n      property.id,\n      typeParams,\n      parameters,\n      returnType\n    );\n\n    methodSignature.computed = true;\n    methodSignature.optional = property.optional;\n    return methodSignature;\n  } else {\n    const tsPropSignature = t.tsPropertySignature(\n      property.id,\n      t.tsTypeAnnotation({\n        ...convertFlowType(property.value),\n        ...baseNodeProps(property.value),\n      })\n    );\n    tsPropSignature.optional = property.optional;\n    tsPropSignature.computed = true;\n\n    return tsPropSignature;\n  }\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'\n:import * as t from '@babel/types';\n\nimport { convertTypeParameterDeclaration } from './convertTypeParameterDeclaration';\nimport { convertObjectTypeProperty } from './convertObjectTypeProperty';\nimport { baseNodeProps } from '../utils/baseNodeProps';\nimport { convertObjectTypeCallProperty } from './convertObjectTypeCallProperty';\nimport { convertObjectTypeIndexer } from './convertObjectTypeIndexer';\nimport { convertObjectTypeInternalSlot } from './convertObjectTypeInternalSlot';\nimport { convertInterfaceExtends } from './convertInterfaceExtends';\n\nexport function convertInterfaceDeclaration(\n  node: t.InterfaceDeclaration | t.DeclareInterface\n) {\n  let typeParameters = null;\n  if (node.typeParameters) {\n    typeParameters = {\n      ...convertTypeParameterDeclaration(node.typeParameters),\n      ...baseNodeProps(node.typeParameters),\n    };\n  }\n  const extendsCombined = node.extends;\n  let _extends = undefined;\n\n  if (extendsCombined && extendsCombined.length > 0) {\n    _extends = extendsCombined.map(v => ({\n      ...convertInterfaceExtends(v),\n      ...baseNodeProps(v),\n    }));\n  }\n\n  const bodyElements = [];\n\n  for (const property of node.body.properties) {\n    if (t.isObjectTypeProperty(property)) {\n      bodyElements.push({\n        ...convertObjectTypeProperty(property),\n        ...baseNodeProps(property),\n      });\n    }\n  }\n  if (node.body.callProperties) {\n    bodyElements.push(\n      ...node.body.callProperties.map(v => ({\n        ...convertObjectTypeCallProperty(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  if (node.body.indexers) {\n    bodyElements.push(\n      ...node.body.indexers.map(v => ({\n        ...convertObjectTypeIndexer(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  if (node.body.internalSlots) {\n    bodyElements.push(\n      ...node.body.internalSlots.map(v => ({\n        ...convertObjectTypeInternalSlot(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  const body = {\n    ...t.tsInterfaceBody(bodyElements),\n    ...baseNodeProps(node.body),\n  };\n\n  return t.tsInterfaceDeclaration(node.id, typeParameters, _extends, body);\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'\n:import { BabelFile, PluginObj, Visitor } from '@babel/core';\nimport * as t from '@babel/types';\nimport { codeFrameColumns } from '@babel/code-frame';\nimport { ImportDeclaration } from './visitors/ImportDeclaration';\nimport { OpaqueType } from './visitors/OpaqueType';\nimport { TypeAnnotation } from './visitors/TypeAnnotation';\nimport { TypeCastExpression } from './visitors/TypeCastExpression';\nimport { TypeParameterDeclaration } from './visitors/TypeParameterDeclaration';\nimport { ClassDeclaration } from './visitors/ClassDeclaration';\nimport { DeclareClass } from './visitors/DeclareClass';\nimport { InterfaceDeclaration } from './visitors/InterfaceDeclaration';\nimport { DeclareFunction } from './visitors/DeclareFunction';\nimport { Program } from './visitors/Program';\nimport { TypeAlias } from './visitors/TypeAlias';\nimport { FunctionDeclaration } from './visitors/FunctionDeclaration';\nimport { CallExpression } from './visitors/CallExpression';\nimport { DeclareVariable } from './visitors/DeclareVariable';\nimport { DeclareTypeAlias } from './visitors/DeclareTypeAlias';\nimport { DeclareInterface } from './visitors/DeclareInterface';\nimport { DeclareOpaqueType } from './visitors/DeclareOpaqueType';\nimport { DeclareModuleExports } from './visitors/DeclareModuleExports';\nimport { DeclareModule } from './visitors/DeclareModule';\nimport { DeclareExportDeclaration } from './visitors/DeclareExportDeclaration';\nimport { NewExpression } from './visitors/NewExpression';\nimport { ArrowFunctionExpression } from './visitors/ArrowFunctionExpression';\nimport { PluginOptions, PluginPass } from './types';\nimport { TSModuleDeclaration } from './visitors/TSModuleDeclaration';\nimport { ExportAllDeclaration } from './visitors/ExportAllDeclaration';\nimport { ObjectMethod } from './visitors/ObjectMethod';\nimport { DeclareExportAllDeclaration } from './visitors/DeclareExportAllDeclaration';\nimport { Pattern } from './visitors/Pattern';\nimport { ForOfStatement } from './visitors/ForOfStatement';\nimport { EnumDeclaration } from './visitors/EnumDeclaration';\n\nconst visitor: Visitor<PluginPass> = {\n  Program,\n  TypeAnnotation,\n  TypeAlias,\n  TypeParameterDeclaration,\n  ImportDeclaration,\n  TypeCastExpression,\n  OpaqueType,\n  DeclareClass,\n  ClassDeclaration,\n  ClassExpression: ClassDeclaration,\n  ExportAllDeclaration,\n  InterfaceDeclaration,\n  DeclareFunction,\n  FunctionDeclaration,\n  CallExpression,\n  OptionalCallExpression: CallExpression,\n  DeclareVariable,\n  DeclareTypeAlias,\n  DeclareInterface,\n  DeclareOpaqueType,\n  DeclareModuleExports,\n  DeclareModule,\n  DeclareExportDeclaration,\n  DeclareExportAllDeclaration,\n  NewExpression,\n  ArrowFunctionExpression,\n  TSModuleDeclaration,\n  ObjectMethod,\n  TemplateElement(path: any) {\n\n\n\n    path.node.original = null;\n  },\n  Pattern,\n  ForOfStatement,\n  EnumDeclaration,\n};\n\nexport default (_babel: any, opts: PluginOptions = {} as PluginOptions) => {\n  if (typeof opts.isJSX === 'undefined') {\n    opts.isJSX = true;\n  }\n  if (typeof opts.legacyImports === 'undefined') {\n    opts.legacyImports = true;\n  }\n  return {\n    name: 'babel-plugin-flow-to-typescript',\n    visitor,\n\n    manipulateOptions(_babel: any, parserOpts) {\n      parserOpts.plugins.push(['flow', { enums: true }]);\n      if (opts.isJSX) {\n        parserOpts.plugins.push('jsx');\n      }\n      parserOpts.plugins.push('classProperties');\n      parserOpts.plugins.push('objectRestSpread');\n      parserOpts.plugins.push('optionalChaining');\n      parserOpts.plugins.push('nullishCoalescingOperator');\n      parserOpts.plugins.push(['decorators', { decoratorsBeforeExport: true }]);\n      parserOpts.plugins.push('dynamicImport');\n      parserOpts.allowReturnOutsideFunction = true;\n    },\n    pre(this: PluginPass, file: BabelFile) {\n      const logger = this.opts.logger || {\n        error: console.error.bind(console),\n        warn: console.log.bind(console),\n        log: console.log.bind(console),\n      };\n      const oldMessages = new Set<string>();\n      function createLogger(log: (message: string) => void) {\n        return (node: t.Node, message: string) => {\n          const loc = node && node.loc;\n\n          const highlightCode: boolean = file.opts.highlightCode ?? true;\n\n          let msg = message;\n          if (loc) {\n            msg +=\n              '\\n' +\n              codeFrameColumns(\n                file.code,\n                {\n                  start: {\n                    line: loc.start.line,\n                    column: loc.start.column + 1,\n                  },\n                  end:\n                    loc.end && loc.start.line === loc.end.line\n                      ? {\n                          line: loc.end.line,\n                          column: loc.end.column + 1,\n                        }\n                      : undefined,\n                },\n                { highlightCode }\n              );\n          }\n          if (!oldMessages.has(msg)) {\n            log(msg);\n            oldMessages.add(msg);\n          }\n        };\n      }\n      this.set('logger', {\n        error: createLogger(logger.error),\n        warn: createLogger(logger.warn),\n        log: createLogger(logger.log),\n      });\n    },\n  } as PluginObj<PluginPass>;\n};\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/DeclareInterface.ts'\n:import * as t from '@babel/types';\nimport { NodePath } from '@babel/traverse';\nimport { convertInterfaceDeclaration } from '../converters/convertInterfaceDeclaration';\nimport { replaceWith } from '../utils/replaceWith';\nimport { PluginPass } from '../types';\n\nexport function DeclareInterface(\n  path: NodePath<t.DeclareInterface>,\n  state: PluginPass\n) {\n  const node = path.node;\n  const replacement = convertInterfaceDeclaration(node);\n  replacement.declare = !state.get('isModuleDeclaration');\n  replaceWith(path, replacement);\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertFunctionTypeAnnotation.ts'\n:import * as t from '@babel/types';\nimport { generateFreeIdentifier } from '../utils/generateFreeIdentifier';\nimport { convertFlowType } from './convertFlowType';\nimport { convertTypeParameterDeclaration } from './convertTypeParameterDeclaration';\nimport { baseNodeProps } from '../utils/baseNodeProps';\n\nexport function convertFunctionTypeAnnotation(node: t.FunctionTypeAnnotation) {\n  let typeParams = undefined;\n\n  if (node.typeParameters) {\n    typeParams = {\n      ...convertTypeParameterDeclaration(node.typeParameters),\n      ...baseNodeProps(node.typeParameters),\n    };\n  }\n\n  const parameters = [];\n  let returnType = null;\n\n\n  if (node.params) {\n    const paramNames = node.params\n      .map(_ => _.name)\n      .filter(<T>(_: null | undefined | T): _ is T => !!_)\n      .map(_ => _.name);\n\n    let hasRequiredAfter = false;\n    for (let i = node.params.length - 1; i >= 0; i--) {\n      const param = node.params[i];\n      let name = param.name && param.name.name;\n\n\n      if (name == null) {\n        name = generateFreeIdentifier(paramNames);\n        paramNames.push(name);\n      }\n\n      const id = t.identifier(name);\n      id.optional = param.optional;\n      if (param.typeAnnotation) {\n        let typeAnnotation: t.TSType;\n        if (t.isNullableTypeAnnotation(param.typeAnnotation)) {\n          if (!hasRequiredAfter) {\n            id.optional = true;\n          }\n          if (id.optional) {\n            let tsType = convertFlowType(param.typeAnnotation.typeAnnotation);\n            if (t.isTSFunctionType(tsType)) {\n              tsType = t.tsParenthesizedType(tsType);\n            }\n            typeAnnotation = t.tsUnionType([tsType, t.tsNullKeyword()]);\n          } else {\n            typeAnnotation = convertFlowType(param.typeAnnotation);\n            hasRequiredAfter = true;\n          }\n        } else {\n          typeAnnotation = convertFlowType(param.typeAnnotation);\n          hasRequiredAfter = true;\n        }\n        id.typeAnnotation = {\n          ...t.tsTypeAnnotation(typeAnnotation),\n          ...baseNodeProps(param.typeAnnotation),\n        };\n      }\n\n      parameters.unshift({ ...id, ...baseNodeProps(param) });\n    }\n  }\n\n\n  if (node.rest) {\n    if (node.rest.name) {\n      const id = t.restElement(node.rest.name);\n      id.typeAnnotation = t.tsTypeAnnotation(\n        convertFlowType(node.rest.typeAnnotation)\n      );\n      parameters.push({ ...id, ...baseNodeProps(node.rest) });\n    }\n  }\n\n\n  if (node.returnType) {\n    returnType = t.tsTypeAnnotation({\n      ...convertFlowType(node.returnType),\n      ...baseNodeProps(node.returnType),\n    });\n  }\n  return { typeParams, parameters, returnType };\n}\n",
        "gt": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertFunctionTypeAnnotation.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertObjectTypeInternalSlot.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/DeclareInterface.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/transformers/entity.transformer.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { DDBRepository, LocalSecondaryIndexName } from '../dynamodb.repo';\nimport { LSILastEvaluatedKey } from '../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../utils/utils';\nimport { AllAttrs, DDBContestItem, KeyAttrs } from './contest.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBContestRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async get(contestId: string, discipline: Discipline) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBContestRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async put(contest: DDBContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBContestRepository Put', params));\n  }\n  public async delete(contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBContestRepository Delete', params));\n  }\n\n  public async updateProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBContestRepository updateUrl', params));\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: !opts.descending,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and begins_with(#lsi, :sortKeyPrefix) ',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(),\n        ':sortKeyPrefix': this.transformer.itemToAttrsTransformer.LSI((opts.year || '').toString()),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBContestRepository query', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(after?: {\n    contestId: string;\n    discipline: Discipline;\n    date: string;\n  }): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date && after.discipline) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[]; name?: string; id?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    if (filter.name) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedName, :queryString)`;\n      filterExpAttrNames['#normalizedName'] = this.transformer.attrName('normalizedName');\n      filterExpAttrValues[':queryString'] = filter.name;\n    }\n    if (filter.id) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#sk_gsi, :id)`;\n      filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n      filterExpAttrValues[':id'] = filter.id;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/contests/contest.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { repositoryFactory } from '../utils/utils';\nimport { DDBContestRepository } from './contest.repo';\n\n@Module({\n  imports: [],\n  providers: [],\n  exports: [],\n})\nexport class DDBContestRepoModule {\n  public static withConfig(dynamodbService: IDynamoDBService): DynamicModule {\n    const repo = repositoryFactory(\n      DDBContestRepository,\n      dynamodbService,\n    );\n    return {\n      module: DDBContestRepoModule,\n      providers: [repo],\n      exports: [repo],\n    };\n  }\n  public static forTest(dynamodbService: IDynamoDBService): ModuleMetadata {\n    const repo = repositoryFactory(\n      DDBContestRepository,\n      dynamodbService,\n    );\n    return {\n      providers: [repo],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/dynamodb/contests/transformers/entity.transformer.ts'\n:import { Contest } from 'core/contest/entity/contest';\nimport * as moment from 'moment';\nimport { Utils } from 'shared/utils';\nimport { DDBContestItem } from '../contest.interface';\n\nexport class EntityTransformer {\n  constructor() {}\n\n  public toDBItem(contest: Contest): DDBContestItem {\n    return {\n      contestId: contest.id,\n      category: contest.contestType,\n      gender: contest.contestGender,\n      city: contest.city,\n      country: contest.country,\n      createdAt: contest.createdAt || moment().unix(),\n      date: contest.date.toISODate(),\n      discipline: contest.discipline,\n      name: contest.name,\n      normalizedName: Utils.normalizeString(contest.name),\n      prize: contest.prize,\n      profileUrl: contest.profileUrl || undefined,\n      thumbnailUrl: contest.thumbnailUrl || undefined,\n      infoUrl: contest.infoUrl || undefined,\n    };\n  }\n\n  public fromDBItem(contest: DDBContestItem): Contest {\n    if (!contest) {\n      return null;\n    }\n    return new Contest({\n      id: contest.contestId,\n      city: contest.city,\n      country: contest.country,\n      createdAt: contest.createdAt,\n      date: new Date(contest.date),\n      contestType: contest.category,\n      contestGender: contest.gender,\n      discipline: contest.discipline,\n      name: contest.name,\n      prize: contest.prize,\n      profileUrl: contest.profileUrl || '',\n      thumbnailUrl: contest.thumbnailUrl || '',\n      infoUrl: contest.infoUrl || '',\n    });\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/contests/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'nody-greeter/src/main/bridge/bridge_objects.ts'",
            "'nody-greeter/src/main/utils/acpi.ts'",
            "'nody-greeter/src/main/utils/battery.ts'",
            "'nody-greeter/src/main/logger.ts'"
        ],
        "content": "'nody-greeter/src/main/bridge/bridge_objects.ts'\n:import {\n  LightDMBattery,\n  LightDMLanguage,\n  LightDMLayout,\n  LightDMSession,\n  LightDMUser,\n} from \"common/ldm_interfaces\";\n\nimport { LightDM } from \"node-gtk\";\nimport { BatteryController } from \"../utils/battery\";\n\nfunction sessionToObject(\n  session: LightDM.LightDMSession\n): LightDMSession | null {\n  if (!session) return null;\n  return {\n    comment: session.getComment(),\n    key: session.getKey(),\n    name: session.getName(),\n    type: session.getSessionType(),\n  };\n}\n\nfunction userToObject(user: LightDM.LightDMUser): LightDMUser | null {\n  if (!user) return null;\n  return {\n    background: user.getBackground(),\n    display_name: user.getDisplayName(),\n    home_directory: user.getHomeDirectory(),\n    image: user.getImage(),\n    language: user.getLanguage(),\n    layout: user.getLayout(),\n    layouts: user.getLayouts(),\n    logged_in: user.getLoggedIn(),\n    session: user.getSession(),\n    username: user.getName(),\n  };\n}\n\nfunction languageToObject(\n  lang: LightDM.LightDMLanguage\n): LightDMLanguage | null {\n  if (!lang) return null;\n  return {\n    code: lang.getCode(),\n    name: lang.getName(),\n    territory: lang.getTerritory(),\n  };\n}\n\nfunction layoutToObject(layout: LightDM.LightDMLayout): LightDMLayout | null {\n  if (!layout) return null;\n  return {\n    description: layout.getDescription(),\n    name: layout.getName(),\n    short_description: layout.getShortDescription(),\n  };\n}\n\nfunction batteryToObject(battery: BatteryController): LightDMBattery | null {\n  if (!battery) return null;\n  if (battery._batteries.length == 0) return null;\n  return {\n    name: battery.name,\n    level: battery.level,\n    status: battery.status,\n    ac_status: battery.acStatus,\n    capacity: battery.capacity,\n    time: battery.time,\n    watt: battery.watt,\n  };\n}\n\nexport {\n  sessionToObject,\n  batteryToObject,\n  languageToObject,\n  layoutToObject,\n  userToObject,\n};\n\n'nody-greeter/src/main/utils/acpi.ts'\n:import * as child_process from \"child_process\";\nimport { logger } from \"../logger\";\n\ntype Callback = (data: string) => void;\n\nclass ACPIController {\n  public constructor() {\n    if (this.checkAcpi()) this.listen();\n    else logger.error(\"ACPI: acpi_listen does not exists\");\n  }\n\n  protected tries = 0;\n  protected callbacks: Callback[] = [];\n\n  public connect(cb: Callback): void {\n    this.callbacks.push(cb);\n  }\n  public disconnect(cb: Callback): void {\n    const ind = this.callbacks.findIndex((c) => {\n      return c === cb;\n    });\n    if (ind == -1) return;\n    this.callbacks.splice(ind, 1);\n  }\n\n  private checkAcpi(): boolean {\n    const res = child_process.spawnSync(\"which\", [\"acpi_listen\"], {\n      encoding: \"utf-8\",\n    });\n    if (res.status == 0) return true;\n    else return false;\n  }\n\n  private listen(): void {\n    const acpi = child_process.spawn(\"acpi_listen\");\n    acpi.on(\"error\", (err) => {\n      logger.error(\"ACPI: \" + err.message);\n    });\n    acpi.on(\"close\", () => {\n      if (this.tries < 5) {\n        this.tries++;\n        logger.debug(\"Restarting acpi_listen\");\n        return this.listen();\n      }\n    });\n\n    acpi.stdout.addListener(\"data\", (d: Buffer) => {\n      const data = d.toString().trim();\n      this.callbacks.forEach((cb) => {\n        if (cb !== undefined) cb(data);\n      });\n    });\n  }\n}\n\nconst ACPI = new ACPIController();\n\nexport { ACPI };\n\n'nody-greeter/src/main/utils/battery.ts'\n:import * as path from \"path\";\nimport * as fs from \"fs\";\n\nimport { globalNodyConfig } from \"../config\";\nimport { ACPI } from \"./acpi\";\n\ninterface Battery {\n  name: string;\n  status: string;\n  perc: number;\n  capacity: number;\n}\n\nlet runningUpdate = false;\n\nclass BatteryController {\n  public _batteries: Battery[] = [];\n  public PS_PATH = \"/sys/class/power_supply/\";\n  private _ac = \"AC0\";\n  private _perc = -1;\n  private _status = \"N/A\";\n  private _acStatus = false;\n  private _capacity = 0;\n  private _time = \"\";\n  private _watt = 0;\n\n  public constructor() {\n    if (globalNodyConfig.config.features.battery == true) this._init();\n  }\n\n  private _init(): void {\n    if (this._batteries.length == 0) {\n      scandirLine(this.PS_PATH, (lines) => this._updateBatteries(lines));\n    }\n    this.acpiListen();\n    this.fullUpdate();\n  }\n\n\n  private _updateBatteries(line: string): void {\n    const match = line.match(/BAT\\w+/);\n    if (match) {\n      this._batteries.push({\n        name: match[0],\n        status: \"N/A\",\n        perc: 0,\n        capacity: 0,\n      });\n    } else {\n      const ac = line.match(/A\\w+/);\n      this._ac = ac ? ac[0] : this._ac;\n    }\n  }\n  public get name(): string {\n    return this._batteries[0].name;\n  }\n  public get level(): number {\n    return this._perc;\n  }\n  public get status(): string {\n    return this._status;\n  }\n  public get acStatus(): boolean {\n    return this._acStatus;\n  }\n  public get capacity(): number {\n    return this._capacity;\n  }\n  public get time(): string {\n    return this._time;\n  }\n  public get watt(): number {\n    return this._watt;\n  }\n\n  public acpiListen(): void {\n    ACPI.connect((data) => {\n      if (data.match(/battery|ac_adapter/)) {\n        this.fullUpdate();\n      }\n    });\n  }\n\n\n  public async fullUpdate(): Promise<void> {\n    if (runningUpdate) return;\n    runningUpdate = true;\n\n    let sumRateCurrent = 0;\n    let sumRatePower = 0;\n    let sumRateEnergy = 0;\n    let sumEnergyNow = 0;\n    let sumEnergyFull = 0;\n    let sumChargeFull = 0;\n    let sumChargeDesign = 0;\n\n    async function readData(...p: string[]): Promise<string> {\n      return readFirstLine(path.join(...p));\n    }\n\n    for (let i = 0; i < this._batteries.length; i++) {\n      const battery = this._batteries[i];\n      const batPath = this.PS_PATH + battery.name;\n      const present = await readFirstLine(path.join(batPath, \"present\"));\n\n      if (parseInt(present) == 1) {\n        const rateCurrent = parseInt(await readData(batPath, \"current_now\"));\n        const rateVoltage = parseInt(await readData(batPath, \"voltage_now\"));\n        const ratePower = parseInt(await readData(batPath, \"power_now\"));\n        const chargeFull = parseInt(await readData(batPath, \"charge_full\"));\n        const chargeDesign = parseInt(\n          await readData(batPath, \"charge_full_design\")\n        );\n\n        const energyNow = parseInt(\n          (await readData(batPath, \"energy_now\")) ||\n            (await readData(batPath, \"charge_now\"))\n        );\n        const energyFull =\n          parseInt(await readData(batPath, \"energy_full\")) || chargeFull;\n        const energyPercentage =\n          parseInt(await readData(batPath, \"capacity\")) ||\n          Math.floor((energyNow / energyFull) * 100);\n        this._batteries[i].status =\n          (await readData(batPath, \"status\")) || \"N/A\";\n        this._batteries[i].perc = energyPercentage || this._batteries[i].perc;\n\n        if (!chargeDesign || chargeDesign == 0) {\n          this._batteries[i].capacity = 0;\n        } else {\n          this._batteries[i].capacity = Math.floor(\n            (chargeFull / chargeDesign) * 100\n          );\n        }\n        sumRateCurrent += rateCurrent || 0;\n        sumRatePower += ratePower || 0;\n        sumRateEnergy +=\n          ratePower || ((rateVoltage || 0) * (rateCurrent || 0)) / 1e6;\n        sumEnergyNow += energyNow || 0;\n        sumEnergyFull += energyFull || 0;\n        sumChargeFull += chargeFull || 0;\n        sumChargeDesign += chargeDesign || 0;\n      }\n    }\n    this._capacity = Math.floor(\n      Math.min(100, (sumChargeFull / sumChargeDesign) * 100)\n    );\n    this._status =\n      this._batteries.length > 0 ? this._batteries[0].status : \"N/A\";\n\n    for (let i = 0; i < this._batteries.length; i++) {\n      const battery = this._batteries[i];\n      if (battery.status == \"Discharging\" || battery.status == \"Charging\") {\n        this._status = battery.status;\n      }\n    }\n    this._acStatus = Boolean(\n      parseInt(await readData(this.PS_PATH, this._ac, \"online\"))\n    );\n\n    let rateTime: number;\n    let rateTimeMagnitude: number;\n\n    if (this._status != \"N/A\") {\n      if (\n        this._status != \"Full\" &&\n        sumRatePower == 0 &&\n        this._acStatus == true\n      ) {\n        this._perc = Math.floor(\n          Math.min(100, (sumEnergyNow / sumEnergyFull) * 100 + 0.5)\n        );\n        this._time = \"00:00\";\n        this._watt = 0;\n      } else if (this._status != \"Full\") {\n        rateTime = 0;\n        if (sumRatePower > 0 || sumRateCurrent > 0) {\n          const div = (sumRatePower > 0 && sumRatePower) || sumRateCurrent;\n          if (this._status == \"Charging\")\n            rateTime = (sumEnergyFull - sumEnergyNow) / div;\n          else rateTime = sumEnergyNow / div;\n          if (0 < rateTime && rateTime < 0.01) {\n            rateTimeMagnitude = Math.abs(Math.floor(Math.log10(rateTime)));\n            rateTime = (rateTime * 10) ^ (rateTimeMagnitude - 2);\n          }\n          const hours = Math.floor(rateTime);\n          const minutes = Math.floor((rateTime - hours) * 60);\n          this._perc = Math.floor(\n            Math.min(100, (sumEnergyNow / sumEnergyFull) * 100 + 0.5)\n          );\n          this._time = `${hours.toString().padStart(2, \"0\")}:${minutes\n            .toString()\n            .padStart(2, \"0\")}`;\n          this._watt = sumRateEnergy / 1e6;\n        }\n      } else if (this._status == \"Full\") {\n        this._perc = 100;\n        this._time = \"00:00\";\n        this._watt = 0;\n      }\n    }\n    this._perc = this._perc == null ? 0 : this._perc;\n\n    if (global.lightdmGreeter)\n      global.lightdmGreeter._emitSignal(\"battery_update\");\n\n    runningUpdate = false;\n  }\n}\n\n\nfunction scandirLine(dir: string, callback: (lines: string) => void): void {\n  const lines = fs.readdirSync(dir, { encoding: \"utf8\" });\n  lines.forEach((l) => callback(l));\n}\n\n\nfunction readFirstLine(filePath: string): Promise<string> {\n  return new Promise((resolve) => {\n    const rs = fs.createReadStream(filePath, { encoding: \"utf8\" });\n    let val = \"\";\n    let ind = 0;\n    let pos = 0;\n    rs.on(\"data\", (data) => {\n      ind = data.indexOf(\"\\n\");\n      val += data;\n      if (ind == -1) {\n        pos += data.length;\n      } else {\n        pos += ind;\n        rs.close();\n      }\n    })\n      .on(\"close\", () =>\n        resolve(val.slice((val.charCodeAt(0) === 0xfeff && 1) || 0, pos))\n      )\n      .on(\"error\", () => resolve(\"\"));\n  });\n}\n\nexport { BatteryController };\n\n'nody-greeter/src/main/logger.ts'\n:import winston from \"winston\";\nimport * as path from \"path\";\n\nObject.defineProperty(global, \"__stack\", {\n  get: function () {\n    const orig = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack): NodeJS.CallSite[] {\n      return stack;\n    };\n    const err = new Error();\n\n    const stack: NodeJS.CallSite[] = err.stack as unknown as NodeJS.CallSite[];\n    Error.prepareStackTrace = orig;\n    return stack;\n  },\n});\n\nObject.defineProperty(global, \"__line\", {\n  get: function () {\n    const stack: NodeJS.CallSite[] = __stack;\n    if (stack[3]) return stack[3].getLineNumber();\n    return stack[2].getLineNumber();\n  },\n});\nObject.defineProperty(global, \"__source\", {\n  get: function (): string {\n    const stack: NodeJS.CallSite[] = __stack;\n    if (stack[3]) return stack[3].getFileName() || \"\";\n    return stack[2].getFileName() || \"\";\n  },\n});\n\ndeclare global {\n  const __line: number;\n  const __stack: NodeJS.CallSite[];\n  const __source: string;\n}\n\nconst myFormat = winston.format.printf(\n  ({ level, message, source, line, timestamp }) => {\n    return `${timestamp} [ ${level.toLocaleUpperCase()} ] ${source} ${line}: ${message}`;\n  }\n);\n\nconst winstonLogger = winston.createLogger({\n  level: \"debug\",\n  format: winston.format.combine(\n    winston.format.timestamp({ format: \"YYYY-MM-DD HH:mm:ss\" }),\n    myFormat\n  ),\n  defaultMeta: { service: \"user-service\" },\n  transports: [\n    new winston.transports.Console({\n      stderrLevels: [\"debug\", \"warn\", \"error\"],\n    }),\n  ],\n  exitOnError: false,\n});\n\nclass Logger {\n  private winstonLogger: winston.Logger;\n  public constructor() {\n    this.winstonLogger = winstonLogger;\n  }\n\n  public debug(message: string): void {\n    this.winstonLogger.log({\n      level: \"debug\",\n      message: message,\n      line: __line,\n      source: path.basename(__source),\n    });\n  }\n  public warn(message: string): void {\n    this.winstonLogger.log({\n      level: \"warn\",\n      message: message,\n      line: __line,\n      source: path.basename(__source),\n    });\n  }\n  public error(message: string): void {\n    this.winstonLogger.log({\n      level: \"error\",\n      message: message,\n      line: __line,\n      source: path.basename(__source),\n    });\n  }\n  public log({\n    level,\n    message,\n    line,\n    source,\n  }: {\n    level: string;\n    message: string;\n    line: number;\n    source: string;\n  }): void {\n    this.winstonLogger.log({\n      level: level,\n      message: message,\n      line: line,\n      source: source,\n    });\n  }\n}\n\nconst logger = new Logger();\n\nexport { logger };\n",
        "gt": [
            "'nody-greeter/src/main/logger.ts'",
            "'nody-greeter/src/main/utils/acpi.ts'",
            "'nody-greeter/src/main/utils/battery.ts'",
            "'nody-greeter/src/main/bridge/bridge_objects.ts'"
        ]
    },
    {
        "files": [
            "'extension/src/components/icons/IconAmazon.tsx'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/components/Welcome.tsx'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'"
        ],
        "content": "'extension/src/components/icons/IconAmazon.tsx'\n:import { BaseIcon, type IconProps } from \"./BaseIcon\";\n\n\nexport default function IconAmazon(props: IconProps) {\n  return (\n    <BaseIcon viewBox=\"0 0 448 512\" {...props}>\n      <path\n        fill=\"currentColor\"\n        d=\"M257.2 162.7c-48.7 1.8-169.5 15.5-169.5 117.5 0 109.5 138.3 114 183.5 43.2 6.5 10.2 35.4 37.5 45.3 46.8l56.8-56S341 288.9 341 261.4V114.3C341 89 316.5 32 228.7 32 140.7 32 94 87 94 136.3l73.5 6.8c16.3-49.5 54.2-49.5 54.2-49.5 40.7-.1 35.5 29.8 35.5 69.1zm0 86.8c0 80-84.2 68-84.2 17.2 0-47.2 50.5-56.7 84.2-57.8v40.6zm136 163.5c-7.7 10-70 67-174.5 67S34.2 408.5 9.7 379c-6.8-7.7 1-11.3 5.5-8.3C88.5 415.2 203 488.5 387.7 401c7.5-3.7 13.3 2 5.5 12zm39.8 2.2c-6.5 15.8-16 26.8-21.2 31-5.5 4.5-9.5 2.7-6.5-3.8s19.3-46.5 12.7-55c-6.5-8.3-37-4.3-48-3.2-10.8 1-13 2-14-.3-2.3-5.7 21.7-15.5 37.5-17.5 15.7-1.8 41-.8 46 5.7 3.7 5.1 0 27.1-6.5 43.1z\"\n      />\n    </BaseIcon>\n  );\n}\n\n'extension/src/pages/overlay/components/overlay/Overlay.tsx'\n:import {\n  useEffect,\n  useRef,\n  useCallback,\n  useState,\n  useMemo,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\nimport Welcome from \"../../../../components/Welcome\";\nimport IconWelcome from \"../../../../components/icons/IconWelcome\";\nimport IconAmbassadors from \"../../../../components/icons/IconAmbassadors\";\nimport IconSettings from \"../../../../components/icons/IconSettings\";\n\nimport {\n  isAmbassadorKey,\n  type AmbassadorKey,\n} from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\nimport { visibleUnderCursor } from \"../../../../utils/dom\";\n\nimport useChatCommand from \"../../../../hooks/useChatCommand\";\n\nimport useSettings from \"../../hooks/useSettings\";\nimport useSleeping from \"../../hooks/useSleeping\";\n\nimport AmbassadorsOverlay from \"./Ambassadors\";\nimport SettingsOverlay from \"./Settings\";\n\nimport Buttons from \"../Buttons\";\n\n\nconst commandTimeout = 10_000;\n\nconst overlayOptions = [\n  {\n    key: \"welcome\",\n    type: \"primary\",\n    icon: IconWelcome,\n    title: \"Welcome to Alveus\",\n    component: (props: OverlayOptionProps) => (\n      <Welcome\n        className={classes(\"absolute left-0 top-0 mx-4 my-6\", props.className)}\n      />\n    ),\n  },\n  {\n    key: \"ambassadors\",\n    type: \"primary\",\n    icon: IconAmbassadors,\n    title: \"Explore our Ambassadors\",\n    component: AmbassadorsOverlay,\n  },\n  {\n    key: \"settings\",\n    type: \"secondary\",\n    icon: IconSettings,\n    title: \"Extension Settings\",\n    component: SettingsOverlay,\n  },\n] as const;\n\nexport const isValidOverlayKey = (key: string) =>\n  key === \"\" || overlayOptions.some((option) => option.key === key);\n\nexport type OverlayKey = (typeof overlayOptions)[number][\"key\"] | \"\";\n\ntype ActiveAmbassadorState = {\n  key?: AmbassadorKey;\n  isCommand?: boolean;\n};\n\nexport interface OverlayOptionProps {\n  context: {\n    activeAmbassador: ActiveAmbassadorState;\n    setActiveAmbassador: Dispatch<SetStateAction<ActiveAmbassadorState>>;\n  };\n  className?: string;\n}\n\nconst hiddenClass =\n  \"invisible opacity-0 -translate-x-10 motion-reduce:translate-x-0\";\n\nexport default function Overlay() {\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n  const [activeAmbassador, setActiveAmbassador] =\n    useState<ActiveAmbassadorState>({});\n  const [visibleOption, setVisibleOption] = useState<OverlayKey>(\n    settings.openedMenu.value,\n  );\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const awakingRef = useRef(false);\n\n\n  useEffect(() => {\n    settings.openedMenu.change(visibleOption);\n  }, [visibleOption]);\n\n\n  useEffect(() => {\n    setVisibleOption(settings.openedMenu.value);\n  }, [settings.openedMenu.value]);\n\n\n  useChatCommand(\n    useCallback(\n      (command: string) => {\n        if (!settings.disableChatPopup.value) {\n          if (isAmbassadorKey(command))\n            setActiveAmbassador({ key: command, isCommand: true });\n          else if (command !== \"welcome\") return;\n\n\n          setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n\n          if (timeoutRef.current) clearTimeout(timeoutRef.current);\n          timeoutRef.current = setTimeout(() => {\n            setVisibleOption(\"\");\n            setActiveAmbassador({});\n          }, commandTimeout);\n\n\n          awakingRef.current = true;\n          wake(commandTimeout);\n        }\n      },\n      [settings.disableChatPopup.value, wake],\n    ),\n  );\n\n\n  useEffect(\n    () => () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    },\n    [],\n  );\n\n\n\n  useEffect(() => {\n    const callback = () => {\n      if (awakingRef.current) awakingRef.current = false;\n      else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    };\n    addSleepListener(\"wake\", callback);\n    return () => removeSleepListener(\"wake\", callback);\n  }, [addSleepListener, removeSleepListener]);\n\n\n  const bodyClick = useCallback((e: MouseEvent) => {\n    if (!visibleUnderCursor(e)) {\n      setVisibleOption(\"\");\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"click\", bodyClick, true);\n    return () => document.body.removeEventListener(\"click\", bodyClick, true);\n  }, [bodyClick]);\n\n\n  const bodyDblClick = useCallback((e: MouseEvent) => {\n    if (visibleUnderCursor(e)) {\n      e.stopPropagation();\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n    return () =>\n      document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n  }, [bodyDblClick]);\n\n\n  const context = useMemo<OverlayOptionProps[\"context\"]>(\n    () => ({\n      activeAmbassador,\n      setActiveAmbassador,\n    }),\n    [activeAmbassador],\n  );\n\n  return (\n    <div\n      className={classes(\n        \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          ) &&\n          hiddenClass,\n      )}\n    >\n      <Buttons\n        options={overlayOptions}\n        onClick={setVisibleOption}\n        active={visibleOption}\n      />\n      <div className=\"relative h-full w-full\">\n        {overlayOptions.map((option) => (\n          <option.component\n            key={option.key}\n            context={context}\n            className={classes(\n              \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n              visibleOption !== option.key && hiddenClass,\n            )}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n'extension/src/components/Welcome.tsx'\n:import { useMemo } from \"react\";\n\nimport IconGlobe from \"./icons/IconGlobe\";\nimport IconAmazon from \"./icons/IconAmazon\";\nimport IconInstagram from \"./icons/IconInstagram\";\nimport IconTikTok from \"./icons/IconTikTok\";\nimport IconTwitter from \"./icons/IconTwitter\";\nimport IconPlay from \"./icons/IconPlay\";\nimport IconGitHub from \"./icons/IconGitHub\";\n\nimport useChannel from \"../hooks/useChannel\";\n\nimport Card from \"./Card\";\n\nconst socialClass =\n  \"transition-[color,transform] hover:scale-125 focus:scale-125 hover:text-highlight focus:text-highlight\";\n\ninterface WelcomeProps {\n  className?: string;\n}\n\nexport default function Welcome(props: WelcomeProps) {\n  const { className } = props;\n\n  const channel = useChannel();\n  const nonDefault = useMemo(\n    () => !channel || channel.toLowerCase() !== \"alveussanctuary\",\n    [channel],\n  );\n\n  return (\n    <Card className={className} title=\"Welcome to Alveus\">\n      <p className=\"mb-4 mt-2\">\n        Alveus Sanctuary is a 501(c)(3) non-profit organization that functions\n        as a wildlife sanctuary and as a virtual education center. These\n        non-releasable animals are educational ambassadors so viewers can learn\n        from and build a connection to them.\n      </p>\n\n      <ul className=\"mb-2 flex flex-wrap items-center justify-center gap-4\">\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Website\"\n          >\n            <IconGlobe size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Amazon Wishlist\"\n          >\n            <IconAmazon size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Instagram\"\n          >\n            <IconInstagram size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"TikTok\"\n          >\n            <IconTikTok size={32} />\n          </a>\n        </li>\n        <li className={socialClass}>\n          <a\n            href=\"https:\n            rel=\"noreferrer\"\n            target=\"_blank\"\n            title=\"Twitter\"\n          >\n            <IconTwitter size={32} />\n          </a>\n        </li>\n        {nonDefault && (\n          <li className={socialClass}>\n            <a\n              href=\"https:\n              rel=\"noreferrer\"\n              target=\"_blank\"\n              title=\"Live\"\n            >\n              <IconPlay size={32} />\n            </a>\n          </li>\n        )}\n      </ul>\n\n      <a\n        className=\"hover:text-highlight focus:text-highlight flex w-fit items-center justify-center gap-1 text-xs transition-colors\"\n        href=\"https:\n        rel=\"noreferrer\"\n        target=\"_blank\"\n      >\n        Contribute on GitHub\n        <IconGitHub size={16} />\n      </a>\n    </Card>\n  );\n}\n\n'extension/src/pages/overlay/components/overlay/Settings.tsx'\n:import { typeSafeObjectEntries } from \"../../../../utils/helpers\";\nimport { classes } from \"../../../../utils/classes\";\n\nimport useSettings from \"../../hooks/useSettings\";\n\nimport Card from \"../../../../components/Card\";\nimport Toggle from \"../Toggle\";\n\nimport type { OverlayOptionProps } from \"./Overlay\";\n\nexport default function Settings(props: OverlayOptionProps) {\n  const { className } = props;\n  const settings = useSettings();\n\n  return (\n    <Card\n      className={classes(\"absolute left-0 top-0 mx-4 my-6\", className)}\n      title=\"Extension Settings\"\n    >\n      <ul className=\"flex flex-col gap-4\">\n        {typeSafeObjectEntries(settings).map(([key, setting]) => {\n          if (!setting.configurable) return null;\n\n          return (\n            <li key={key} className=\"flex items-center\">\n              {setting.type === \"boolean\" && (\n                <Toggle\n                  label={setting.title}\n                  value={setting.value as boolean}\n                  onChange={setting.change as (value: boolean) => void}\n                />\n              )}\n            </li>\n          );\n        })}\n      </ul>\n    </Card>\n  );\n}\n",
        "gt": [
            "'extension/src/components/icons/IconAmazon.tsx'",
            "'extension/src/components/Welcome.tsx'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/dynamodb.repo.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/dynamodb.repo.ts'\n:import { DynamoDB } from 'aws-sdk';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\n\nexport const LocalSecondaryIndexName = 'PK-LSI-index';\nexport const GlobalSecondaryIndexName = 'GSI-GSI_SK-index';\n\nexport abstract class DDBRepository {\n  protected client: DocumentClient;\n  protected db: DynamoDB;\n\n  protected abstract _tableName;\n\n  constructor(dynamodbService: IDynamoDBService) {\n    this.client = dynamodbService.DynamoDocumentClient;\n    this.db = dynamodbService.DynamoDB;\n  }\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { DDBRepository, LocalSecondaryIndexName } from '../dynamodb.repo';\nimport { LSILastEvaluatedKey } from '../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../utils/utils';\nimport { AllAttrs, DDBContestItem, KeyAttrs } from './contest.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBContestRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async get(contestId: string, discipline: Discipline) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBContestRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async put(contest: DDBContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBContestRepository Put', params));\n  }\n  public async delete(contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBContestRepository Delete', params));\n  }\n\n  public async updateProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBContestRepository updateUrl', params));\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: !opts.descending,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and begins_with(#lsi, :sortKeyPrefix) ',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(),\n        ':sortKeyPrefix': this.transformer.itemToAttrsTransformer.LSI((opts.year || '').toString()),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBContestRepository query', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(after?: {\n    contestId: string;\n    discipline: Discipline;\n    date: string;\n  }): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date && after.discipline) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[]; name?: string; id?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    if (filter.name) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedName, :queryString)`;\n      filterExpAttrNames['#normalizedName'] = this.transformer.attrName('normalizedName');\n      filterExpAttrValues[':queryString'] = filter.name;\n    }\n    if (filter.id) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#sk_gsi, :id)`;\n      filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n      filterExpAttrValues[':id'] = filter.id;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/contests/contest.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { repositoryFactory } from '../utils/utils';\nimport { DDBContestRepository } from './contest.repo';\n\n@Module({\n  imports: [],\n  providers: [],\n  exports: [],\n})\nexport class DDBContestRepoModule {\n  public static withConfig(dynamodbService: IDynamoDBService): DynamicModule {\n    const repo = repositoryFactory(\n      DDBContestRepository,\n      dynamodbService,\n    );\n    return {\n      module: DDBContestRepoModule,\n      providers: [repo],\n      exports: [repo],\n    };\n  }\n  public static forTest(dynamodbService: IDynamoDBService): ModuleMetadata {\n    const repo = repositoryFactory(\n      DDBContestRepository,\n      dynamodbService,\n    );\n    return {\n      providers: [repo],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/dynamodb.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'Approvals.NodeJS/lib/Providers/Mocha/MochaApprovals.ts'",
            "'Approvals.NodeJS/lib/Approvals.ts'",
            "'Approvals.NodeJS/lib/config.ts'",
            "'Approvals.NodeJS/lib/Providers/BeforeEachVerifierBase.ts'",
            "'Approvals.NodeJS/lib/Reporting/ReportLaunchingCircuitBreaker.ts'"
        ],
        "content": "'Approvals.NodeJS/lib/Providers/Mocha/MochaApprovals.ts'\n:import { printArray, printJson } from \"../../Utilities/Printers\";\n\nimport { Options } from \"../../Core/Options\";\nimport { MochaNamer } from \"./MochaNamer\";\nimport mocha from \"mocha\";\n\nimport StringWriter from \"../../StringWriter\";\n\nimport * as approvals from \"../../Approvals\";\n\nlet mochaTest: any = null;\n\nexport function it2(label: string, test: () => void): void {\n  mocha.it(label, function () {\n    mochaTest = this;\n    console.log(\"Mocha Test: \", mochaTest.test.name);\n    test();\n  });\n}\n\nexport function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  approvals.verifyWithControl(namer, writer, null, config);\n}\n\nexport function verifyAsJson(data: any, options?: Options): void {\n  const text = printJson(data);\n  options = options || new Options();\n  options = options.forFile().withFileExtention(\".json\");\n  verify(text, options);\n}\n\nexport function verifyAll<T>(\n  header: string,\n  list: T[],\n  formatter?: (element: T) => string,\n  options?: Options,\n): void {\n  const text = printArray(header, list, formatter);\n  verify(text, options);\n}\n\n'Approvals.NodeJS/lib/Approvals.ts'\n:\n\n\n\nimport callsite from \"callsite\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport * as cfg from \"./config\";\nimport { BinaryWriter } from \"./Writers/BinaryWriter\";\nimport { FileApprover } from \"./FileApprover\";\nimport { FinalMessages } from \"./FinalMessages\";\nimport { ManualNamer } from \"./ManualNamer\";\nimport { Namer } from \"./Core/Namer\";\nimport { ReporterFactory, ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { Scrubber, Scrubbers } from \"./Scrubbers/Scrubbers\";\nimport { StringWriter } from \"./StringWriter\";\nimport { Writer } from \"./Core/Writer\";\nimport { postRunCleanup } from \"./postRunCleanup\";\nimport { stringifyKeysInOrder } from \"./AUtils\";\n\n\n\nimport { MochaNamer } from \"./Providers/Mocha/MochaNamer\";\n\nimport { beforeEachVerifierBase } from \"./Providers/BeforeEachVerifierBase\";\n\n\nexport { Scrubbers as scrubbers };\n\nif (typeof beforeEach === \"function\") {\n  beforeEach(function (): void {\n    if (!this) {\n      return;\n    }\n    this.verify = function () {\n      throw new Error(\"You must call either .mocha()\");\n    };\n  });\n}\n\n\nconst listOfApprovedFiles: string[] = [];\nprocess.on(\"approvalFileApproved\", function (fileName): void {\n  if (listOfApprovedFiles.indexOf(fileName) === -1) {\n    listOfApprovedFiles.push(fileName);\n  }\n});\n\nprocess.on(\"exit\", function (): void {\n  const options = cfg.currentConfig();\n  postRunCleanup(options, listOfApprovedFiles);\n  const finalMessages = FinalMessages.getMessages();\n  if (finalMessages.length) {\n    console.log(\"******************************\");\n    console.log(\"* Approvals Report: WARNING!\");\n    finalMessages.forEach((message: string) => {\n      console.log(`*  - ${message}`);\n    });\n    console.log(\"******************************\");\n  }\n});\n\n\nexport function configure(overrideOptions: cfg.Config): typeof module.exports {\n  cfg.configure(overrideOptions);\n  return module.exports;\n}\n\n\nexport function getConfig(overrideOptions?: cfg.Config): cfg.Config {\n  return cfg.getConfig(overrideOptions);\n}\n\n\n\nexport function mocha(optionalBaseDir?: string): typeof module.exports {\n\n  if (!optionalBaseDir) {\n      let fileName = callsite()[1].getFileName();\n      if (fileName.startsWith(\"file:\n          fileName = fileURLToPath(fileName);\n      }\n      optionalBaseDir = path.dirname(fileName);\n  }\n  beforeEachVerifierBase(\n    MochaNamer,\n    \"require('Approvals').mocha();\",\n    optionalBaseDir,\n  );\n\n  return module.exports;\n}\n\nfunction jasmineExport(): void {\n  throw new Error(\n    \"Aww shucks.\\n\\nApprovals support of Jasmine has been completely yanked out (don't shoot). \\n\\n Jasmine has grown quite complicated (behind our back) and we haven't had enough time to figure out a solid integration pattern... for now it's support has been removed.\\n\\n Check out the docs for manual usage of approval tests to work around the missing Jasmine integration (it should be a straightforward change for you, really).\\n\\n We'll consider bringing it back if we can get someone with interest in submitting a pull request that can bring it back...\",\n  );\n}\n\n\n\nexport const reporters: { MultiReporter: any } = {\n\n  MultiReporter: require(\"./Reporting/Reporters/multiReporter\").default,\n};\n\n\nfunction verifyAndScrub(\n  dirName: string,\n  testName: string,\n  data: BinaryWriter | string,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  scrubber = scrubber || Scrubbers.noScrubber;\n\n\n  if (Array.isArray(optionsOverride)) {\n    optionsOverride = {\n      reporters: optionsOverride,\n    };\n    const stringReporters = JSON.stringify(optionsOverride.reporters);\n    console.error(\n      'For the last arg of the approvals.verify(...) function, if you passed in an array of reporters, something like [\"opendiff\",\"nodediff\"], this has been deprecated and replaced by passing in a config object. Please re-evaluate if you can remove this parameter alltogether and use individual user configs in ~/.approvalConfig, if not then replace this: ' +\n        stringReporters +\n        \" with this { reporters: \" +\n        stringReporters +\n        \"}.\",\n    );\n  }\n\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const namer = new ManualNamer(dirName, testName);\n\n  let writer: Writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data as string);\n\n    writer = new StringWriter(newOptions, data as string);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}\n\n\nexport function verify(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride?: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n\nexport function verifyAsJSON(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride: any,\n) {\n  return verifyAsJSONAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n\n\nexport function verifyAsJSONAndScrub(\n  dirName: string,\n  testName: string,\n  data: any,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    stringifyKeysInOrder(data),\n    scrubber,\n    optionsOverride,\n  );\n}\n\n\n\nexport function verifyWithControl(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory?: ReporterLoader | null,\n  optionsOverride?: Partial<cfg.Config>,\n) {\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const loader =\n    (reporterFactory as ReporterLoader) ||\n    function () {\n      return [ReporterFactory.loadReporter(newOptions.reporters)];\n    };\n\n  FileApprover.verify(namer, writer, loader, newOptions);\n}\n\n'Approvals.NodeJS/lib/config.ts'\n:import * as os from \"os\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as _ from \"lodash\";\nimport * as yaml from \"js-yaml\";\nimport { ReportLaunchingCircuitBreaker } from \"./Reporting/ReportLaunchingCircuitBreaker\";\nimport { Reporter } from \"./Core/Reporter\";\n\nexport interface Config {\n  reporters: (string | Reporter)[];\n  normalizeLineEndingsTo: boolean | string;\n  failOnLineEndingDifferences: boolean;\n  appendEOL: boolean;\n  EOL: string;\n  errorOnStaleApprovedFiles: boolean;\n  shouldIgnoreStaleApprovedFile: (fileName?: string) => boolean;\n  stripBOM: boolean;\n  forceApproveAll: boolean;\n  blockUntilReporterExits: boolean;\n  maxLaunches: number;\n  cmdOptionOverrides?: any;\n  cmdArgs?: string[];\n}\n\n\nexport const defaultConfig: Config = {\n  reporters: [\n    \"BeyondCompare\",\n    \"diffmerge\",\n    \"p4merge\",\n    \"tortoisemerge\",\n    \"nodediff\",\n    \"opendiff\",\n    \"gitdiff\",\n  ],\n  normalizeLineEndingsTo: false,\n  failOnLineEndingDifferences: false,\n  appendEOL: true,\n  EOL: os.EOL,\n  errorOnStaleApprovedFiles: true,\n  shouldIgnoreStaleApprovedFile: () => false,\n  stripBOM: false,\n  forceApproveAll: false,\n  blockUntilReporterExits: false,\n  maxLaunches: 10,\n};\n\n\nexport function getHomeApprovalConfig(): Config | null {\n  const homeConfigPath = path.join(os.homedir(), \".approvalsConfig\");\n  if (fs.existsSync(homeConfigPath)) {\n    const configFileData = fs.readFileSync(homeConfigPath).toString();\n    try {\n      return yaml.load(configFileData) as Config;\n    } catch (ex) {\n      throw new Error(\"Error parsing \" + homeConfigPath + \". \" + ex);\n    }\n  }\n  return null;\n}\n\nlet currentConfigObj: Config;\n\nexport function getConfig(configOverrides?: Partial<Config>): Config {\n  const homeConfig = getHomeApprovalConfig() || {};\n  const resultConfig = _.defaults(\n    configOverrides || {},\n    currentConfigObj || {},\n    homeConfig,\n    defaultConfig,\n  );\n  return resultConfig as Config;\n}\n\nexport function configure(overrideOptions?: Partial<Config>): Config {\n  currentConfigObj = getConfig(overrideOptions);\n  processConfig(currentConfigObj);\n  return currentConfigObj;\n}\n\nexport function currentConfig(): Config {\n  return currentConfigObj;\n}\n\nexport function reset(): void {\n  currentConfigObj = _.defaults({}, getHomeApprovalConfig(), defaultConfig);\n}\n\ncurrentConfigObj = getConfig();\n\nfunction processConfig(config: Config): void {\n  if (config.maxLaunches) {\n    ReportLaunchingCircuitBreaker.setMaxLaunch(config.maxLaunches);\n  }\n}\n\n'Approvals.NodeJS/lib/Providers/BeforeEachVerifierBase.ts'\n:import * as _ from \"lodash\";\nimport * as fs from \"fs\";\nimport * as cfg from \"../config\";\nimport { StringWriter } from \"../StringWriter\";\nimport { FileApprover } from \"../FileApprover\";\nimport { ReporterFactory } from \"../Reporting/ReporterFactory\";\nimport * as aUtils from \"../AUtils\";\n\nimport { MochaNamer } from \"./Mocha/MochaNamer\";\n\nfunction beforeEachLoaderFunction(\n  Namer: typeof MochaNamer,\n  dirName: string,\n  that: any,\n): void {\n\n  that.approvals = { getCurrentReporters };\n  that.verify = verify;\n  that.verifyAsJSON = verifyAsJSON;\n\n  function getCurrentReporters(options?: any) {\n    options = options || cfg.currentConfig();\n    const reporterCandidates = ReporterFactory.loadAllReporters(\n      options.reporters,\n    );\n    return reporterCandidates;\n  }\n  function verify(data: any, overrideOptions?: any) {\n\n    const context = this as Mocha.Context;\n    const namer = new Namer(context, dirName);\n\n    const newOptions = _.defaults(overrideOptions || {}, cfg.currentConfig());\n\n    const reporterFactory = function () {\n      return { getCurrentReporters }.getCurrentReporters(newOptions);\n    };\n\n    const writer = new StringWriter(newOptions, data);\n    FileApprover.verify(namer, writer, reporterFactory);\n  }\n\n  function verifyAsJSON(data: any, overrideOptions?: any) {\n\n    this.verify(aUtils.stringifyKeysInOrder(data), overrideOptions);\n  }\n}\n\nexport function beforeEachVerifierBase(\n  Namer: typeof MochaNamer,\n  usageSample: string,\n  dirName: string,\n): void {\n  if (!fs.existsSync(dirName)) {\n    fs.mkdirSync(dirName);\n  }\n\n\n  const stats = fs.lstatSync(dirName);\n  if (!stats.isDirectory()) {\n    throw new Error(\n      `Invalid directory [${dirName}]. Try using the following syntax. > ${usageSample}`,\n    );\n  }\n  beforeEach(function () {\n    return beforeEachLoaderFunction(Namer, dirName, this);\n  });\n}\n\n'Approvals.NodeJS/lib/Reporting/ReportLaunchingCircuitBreaker.ts'\n:import { FinalMessages } from \"../FinalMessages\";\nimport NodeDiffReporter from \"./Reporters/nodediffReporter\";\n\nlet maxLaunch = 10;\nlet currentCount = 0;\nlet reroutedCount = 0;\n\nexport class ReportLaunchingCircuitBreaker {\n  static setMaxLaunch(value: number): void {\n    maxLaunch = value;\n  }\n\n  static get currentCount(): number {\n    return currentCount;\n  }\n\n  static notifyLaunched(): void {\n    currentCount++;\n  }\n\n  static isLimitExceeded(): boolean {\n    return maxLaunch <= currentCount;\n  }\n\n  static check(approved: string, received: string, options: any): boolean {\n    if (this.isLimitExceeded()) {\n      reroutedCount++;\n      FinalMessages.addKeyMessage(\n        \"maxLaunches\",\n        `config.maxLaunches (${maxLaunch}) exceeded: ${reroutedCount} diff(s) shown in console above...`,\n      );\n      new NodeDiffReporter().report(approved, received, options);\n      return true;\n    }\n    this.notifyLaunched();\n    return false;\n  }\n}\n\nexport default ReportLaunchingCircuitBreaker;\n",
        "gt": [
            "'Approvals.NodeJS/lib/Reporting/ReportLaunchingCircuitBreaker.ts'",
            "'Approvals.NodeJS/lib/config.ts'",
            "'Approvals.NodeJS/lib/Providers/BeforeEachVerifierBase.ts'",
            "'Approvals.NodeJS/lib/Approvals.ts'",
            "'Approvals.NodeJS/lib/Providers/Mocha/MochaApprovals.ts'"
        ]
    },
    {
        "files": [
            "'hydrated-ws/src/pipe/Pipe.ts'",
            "'hydrated-ws/src/polyfill/MessageEvent.ts'",
            "'hydrated-ws/src/pipe/Pipe.spec.ts'"
        ],
        "content": "'hydrated-ws/src/pipe/Pipe.ts'\n:import CloseEvent from \"../polyfill/CloseEvent\";\nimport Event from \"../polyfill/Event\";\nimport MessageEvent from \"../polyfill/MessageEvent\";\nimport WebSocket from \"../polyfill/WebSocket\";\nimport { Shell } from \"../Shell\";\n\n\n\nexport class Pipe extends Shell {\n\n    private static repeatString(str: string, count: number): string {\n        let res = \"\";\n        for (let i = count; i > 0; i--) {\n            res += str;\n        }\n        return res;\n    }\n\n    private readonly channel: string;\n    private pipeReadyState: number = null;\n\n\n    constructor(ws: WebSocket, channel: string, private readonly prefixLength: number = 4) {\n        super();\n\n        if (typeof (channel) !== \"string\" || !channel.length || channel.length > this.prefixLength) {\n            throw new Error(`Channel should be a string between 1 and ${this.prefixLength} characters`);\n        }\n        this.channel = `${Pipe.repeatString(\" \", this.prefixLength)}${channel}`.slice(this.prefixLength * -1);\n        this.ws = ws;\n        this.forwardEvents();\n    }\n\n\n    public close(code: number = 1000, reason?: string) {\n        if (this.pipeReadyState) {\n            return;\n        }\n        this.stopForwardingEvents();\n        this.pipeReadyState = this.CLOSING;\n        setTimeout(() => {\n            this.pipeReadyState = this.CLOSED;\n            this.dispatchEvent(new CloseEvent(\"close\", { code, reason, wasClean: true }));\n        }, 0);\n    }\n\n\n    public send(data: string) {\n        if (this.pipeReadyState) {\n            return;\n        }\n        if (typeof (data) !== \"string\") {\n            throw new Error(`Pipe only support sending string, you passed a type ${typeof (data)}`);\n        }\n        super.send(this.channel + data);\n    }\n\n\n    public dispatchEvent(evt: Event): any {\n        if (evt.type === \"message\") {\n            const e: MessageEvent = evt as any;\n            if (typeof (e.data) === \"string\" && this.channel === e.data.substr(0, this.prefixLength)) {\n                super.dispatchEvent(new MessageEvent(\"message\", {\n                    data: e.data.substr(this.prefixLength),\n                    origin: e.origin,\n                    ports: e.ports as any,\n                    source: e.source,\n                }));\n                return false;\n            }\n        } else {\n            super.dispatchEvent(evt);\n        }\n    }\n\n    protected getReadyState() {\n        return this.pipeReadyState || super.getReadyState();\n    }\n}\n\n'hydrated-ws/src/polyfill/MessageEvent.ts'\n:import Event from \"./Event\";\nimport isNode from \"./isNode\";\n\nclass MessageEventPolyfill extends Event implements MessageEvent {\n\n    public readonly data: any;\n    public readonly origin: string;\n    public readonly ports: any;\n    public readonly source: Window;\n    public readonly lastEventId: string;\n\n    constructor(type: string, eventInitDict?: MessageEventInit) {\n        super(type);\n        eventInitDict = eventInitDict || {};\n        this.data = eventInitDict.data;\n    }\n\n    public initMessageEvent(typeArg: string,\n                            canBubbleArg: boolean,\n                            cancelableArg: boolean,\n                            dataArg: any,\n                            originArg: string,\n                            lastEventIdArg: string,\n                            sourceArg: Window): void {\n        throw new Error(\"initMessageEvent is deprecated\");\n    }\n\n}\n\nexport default (isNode ? MessageEventPolyfill : MessageEvent) as\n    new(type: string, eventInitDict?: MessageEventInit) => MessageEvent;\n\n'hydrated-ws/src/pipe/Pipe.spec.ts'\n:import {expect} from \"chai\";\nimport WebSocket from \"../polyfill/WebSocket\";\nimport {expectEventually, rnd, sleep, supervisor, TIMEOUT_FACTOR} from \"../wrench.spec\";\nimport {Pipe} from \"./Pipe\";\n\ndescribe(\"Pipe\", () => {\n    let ws: WebSocket;\n    let testCase: string;\n\n    before(async () => {\n        await expectEventually(() => supervisor.ws.readyState === WebSocket.OPEN,\n            \"The supervisor failed to connect\");\n    });\n    beforeEach((done) => {\n        testCase = rnd();\n        ws = new WebSocket(`ws:\n        ws.onopen = () => done();\n    });\n\n    afterEach(async () => {\n        if (ws) {\n            ws.close();\n        }\n    });\n\n    describe(\"constructor\", () => {\n        it(\"should throw an error if the channel parameter is invalid\", () => {\n            [\"\", 6, NaN, [], {}, \"XXXXX\"].forEach((channel) => {\n                expect(() => new Pipe(ws, channel as any)).to.throw();\n            });\n        });\n        it(\"should support a prefix length\", () => {\n            [\"a\", \"aaaaaaaaaa\"].forEach((channel) => {\n                expect(() => new Pipe(ws, channel as any, 10)).to.not.throw();\n            });\n            [\"aaaaaaaaaaa\"].forEach((channel) => {\n                expect(() => new Pipe(ws, channel as any, 10)).to.throw();\n            });\n        });\n    });\n\n    describe(\"close\", () => {\n        it(\"should dispatch a close event\", (done) => {\n            const mp = new Pipe(ws, \"a\");\n            mp.addEventListener(\"close\", () => {\n                done();\n            });\n            mp.close();\n\n        });\n\n        it(\"should dispatch a single close event if closed twice\", (done) => {\n            const mp = new Pipe(ws, \"a\");\n            let events = 0;\n            mp.addEventListener(\"close\", () => {\n                events ++;\n            });\n            mp.close();\n            mp.close();\n            setTimeout(() => {\n                expect(events).to.equal(1);\n                done();\n            }, 5);\n\n        });\n        it(\"should stop listening to the message\", async () => {\n            const mp = new Pipe(ws, \"a\");\n            let received = false;\n            mp.addEventListener(\"message\", (e: MessageEvent) => {\n                received = true;\n            });\n            mp.close();\n\n            ws.send(\"   aping\");\n            await sleep(TIMEOUT_FACTOR * 100);\n            return expect(received).to.be.false;\n        });\n        it(\"should not throw an error on send\", async () => {\n            const mp = new Pipe(ws, \"a\");\n            mp.close();\n            expect(() => mp.send(\"\")).to.not.throw();\n            await sleep(TIMEOUT_FACTOR * 50);\n            const logs = await supervisor.logs(testCase);\n            expect(logs.map((l) => l[1])).to.deep.equal([\"connect\"]);\n        });\n        it(\"should have a correct readyState\", async () => {\n            const mp = new Pipe(ws, \"a\");\n            expect(mp.readyState).to.equal(mp.OPEN);\n            mp.close();\n            expect(mp.readyState).to.equal(mp.CLOSING);\n            await sleep(TIMEOUT_FACTOR * 1);\n            expect(mp.readyState).to.equal(mp.CLOSED);\n        });\n    });\n\n    describe(\"send\", () => {\n        it(\"should prefix messages with the channel\", async () => {\n            const mp = new Pipe(ws, \"a\");\n            mp.send(\"data\");\n            await sleep(TIMEOUT_FACTOR * 50);\n            const logs = await supervisor.logs(testCase);\n            expect(logs.map((l) => l[1])).to.deep.equal([\"connect\", \"   adata\"]);\n        });\n        it(\"should refuse a non string message\", async () => {\n            const mp = new Pipe(ws, \"a\");\n            [6, NaN, [], {}].forEach((message) => {\n                expect(() => mp.send(message as any)).to.throw();\n            });\n        });\n    });\n\n    describe(\"receive\", () => {\n        it(\"filter the messages\", async () => {\n            const mpA = new Pipe(ws, \"a\");\n            const mpB = new Pipe(ws, \"b\");\n            const messagesA = [];\n            const messagesB = [];\n            mpA.addEventListener(\"message\", (e: MessageEvent) => {\n                expect(e.data).to.equal(\"pong\");\n                messagesA.push(e.data);\n            });\n            mpB.addEventListener(\"message\", (e: MessageEvent) => {\n                expect(e.data).to.equal(\"pong\");\n                messagesB.push(e.data);\n            });\n\n            mpA.send(\"ping\");\n            mpB.send(\"ping\");\n            mpB.send(\"ping\");\n\n            await sleep(2000);\n            expect(messagesA.length).to.equal(1);\n            expect(messagesB.length).to.equal(2);\n\n        });\n    });\n});\n",
        "gt": [
            "'hydrated-ws/src/polyfill/MessageEvent.ts'",
            "'hydrated-ws/src/pipe/Pipe.ts'",
            "'hydrated-ws/src/pipe/Pipe.spec.ts'"
        ]
    },
    {
        "files": [
            "'Approvals.NodeJS/lib/Providers/BeforeEachVerifierBase.ts'",
            "'Approvals.NodeJS/bin/index.ts'",
            "'Approvals.NodeJS/lib/Approvals.ts'",
            "'Approvals.NodeJS/lib/config.ts'",
            "'Approvals.NodeJS/lib/Reporting/ReportLaunchingCircuitBreaker.ts'"
        ],
        "content": "'Approvals.NodeJS/lib/Providers/BeforeEachVerifierBase.ts'\n:import * as _ from \"lodash\";\nimport * as fs from \"fs\";\nimport * as cfg from \"../config\";\nimport { StringWriter } from \"../StringWriter\";\nimport { FileApprover } from \"../FileApprover\";\nimport { ReporterFactory } from \"../Reporting/ReporterFactory\";\nimport * as aUtils from \"../AUtils\";\n\nimport { MochaNamer } from \"./Mocha/MochaNamer\";\n\nfunction beforeEachLoaderFunction(\n  Namer: typeof MochaNamer,\n  dirName: string,\n  that: any,\n): void {\n\n  that.approvals = { getCurrentReporters };\n  that.verify = verify;\n  that.verifyAsJSON = verifyAsJSON;\n\n  function getCurrentReporters(options?: any) {\n    options = options || cfg.currentConfig();\n    const reporterCandidates = ReporterFactory.loadAllReporters(\n      options.reporters,\n    );\n    return reporterCandidates;\n  }\n  function verify(data: any, overrideOptions?: any) {\n\n    const context = this as Mocha.Context;\n    const namer = new Namer(context, dirName);\n\n    const newOptions = _.defaults(overrideOptions || {}, cfg.currentConfig());\n\n    const reporterFactory = function () {\n      return { getCurrentReporters }.getCurrentReporters(newOptions);\n    };\n\n    const writer = new StringWriter(newOptions, data);\n    FileApprover.verify(namer, writer, reporterFactory);\n  }\n\n  function verifyAsJSON(data: any, overrideOptions?: any) {\n\n    this.verify(aUtils.stringifyKeysInOrder(data), overrideOptions);\n  }\n}\n\nexport function beforeEachVerifierBase(\n  Namer: typeof MochaNamer,\n  usageSample: string,\n  dirName: string,\n): void {\n  if (!fs.existsSync(dirName)) {\n    fs.mkdirSync(dirName);\n  }\n\n\n  const stats = fs.lstatSync(dirName);\n  if (!stats.isDirectory()) {\n    throw new Error(\n      `Invalid directory [${dirName}]. Try using the following syntax. > ${usageSample}`,\n    );\n  }\n  beforeEach(function () {\n    return beforeEachLoaderFunction(Namer, dirName, this);\n  });\n}\n\n'Approvals.NodeJS/bin/index.ts'\n:#!/usr/bin/env ts-node\nimport es from \"event-stream\";\nimport * as autils from \"../lib/AUtils\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport marked from \"marked\";\nimport TerminalRenderer from \"marked-terminal\";\nimport minimist from \"minimist\";\nimport { configure, verify } from \"../lib/Approvals\";\nimport { redText } from \"../lib/Utilities/ConsoleUtils\";\n\nconst verbose = process.argv.includes(\"--verbose\");\nconst printHelp = process.argv.includes(\"--help\");\n\nfunction printHelpMessage() {\n  if (verbose) {\n    console.log(\"printing help...\");\n  }\n\n  const helpFile = fs.readFileSync(path.join(__dirname, \"help.md\"), \"utf8\");\n  marked.setOptions({\n    renderer: new TerminalRenderer(),\n  });\n  let output = marked.parse(helpFile) as string;\n\n  output = output.replace(/&nbsp;/g, \" \");\n  console.log(output);\n}\n\nfunction errAndExit(msg: string): void {\n  printHelpMessage();\n  console.log(redText(msg));\n  process.exit(1);\n}\n\nif (printHelp) {\n  printHelpMessage();\n  process.exit();\n}\n\nif (verbose) {\n  console.log(\"process.argv: \", process.argv);\n}\n\nconst argv = minimist(process.argv.slice(2), {\n  alias: {\n    reporters: [\"r\"],\n  },\n  boolean: [\"verbose\"],\n});\n\nif (verbose) {\n  console.log(\"parsed args: \", argv);\n}\n\nlet reporters = argv.reporter as string | string[];\nif (typeof reporters === \"string\") {\n  reporters = [reporters];\n}\n\nconst testname = argv._[0];\nif (!testname) {\n  errAndExit(\n    'Missing parameter: supply a test name ex: echo \"hello\" | approvals myFirstTest. This will become the file name myFirstTest.approved.txt in the current directory',\n  );\n}\n\nconst outdir = argv.outdir || process.cwd();\nif (!fs.existsSync(outdir)) {\n  errAndExit(\"Directory not found: \" + outdir);\n}\n\nconst errorOnStaleApprovedFiles = argv.errorOnStaleApprovedFiles === \"true\";\n\nif (verbose) {\n  console.log(\"outdir: \", outdir);\n  console.log(\"errorOnStaleApprovedFiles: \", errorOnStaleApprovedFiles);\n  console.log(\"testname: \", testname);\n  console.log(\n    \"reporters: \",\n    reporters ||\n      \"undefined (but will fallback to approvals preconfigure defaults)\",\n  );\n}\n\nconst opts: any = {};\nif (reporters) {\n  opts.reporters = reporters;\n}\nopts.errorOnStaleApprovedFiles = errorOnStaleApprovedFiles;\n\nif (verbose) {\n  console.log(\"approval opts: \", opts);\n}\n\nopts.forceApproveAll =\n  autils.hasCommandLineArgument(\"--forceapproveall\") ||\n  autils.hasCommandLineArgument(\"-f\");\n\nprocess.stdin.pipe(\n  es.mapSync((data: Buffer) => {\n    const dataToVerify = data.toString();\n    configure(opts);\n    verify(outdir, testname, dataToVerify);\n  }),\n);\n\n'Approvals.NodeJS/lib/Approvals.ts'\n:\n\n\n\nimport callsite from \"callsite\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport * as cfg from \"./config\";\nimport { BinaryWriter } from \"./Writers/BinaryWriter\";\nimport { FileApprover } from \"./FileApprover\";\nimport { FinalMessages } from \"./FinalMessages\";\nimport { ManualNamer } from \"./ManualNamer\";\nimport { Namer } from \"./Core/Namer\";\nimport { ReporterFactory, ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { Scrubber, Scrubbers } from \"./Scrubbers/Scrubbers\";\nimport { StringWriter } from \"./StringWriter\";\nimport { Writer } from \"./Core/Writer\";\nimport { postRunCleanup } from \"./postRunCleanup\";\nimport { stringifyKeysInOrder } from \"./AUtils\";\n\n\n\nimport { MochaNamer } from \"./Providers/Mocha/MochaNamer\";\n\nimport { beforeEachVerifierBase } from \"./Providers/BeforeEachVerifierBase\";\n\n\nexport { Scrubbers as scrubbers };\n\nif (typeof beforeEach === \"function\") {\n  beforeEach(function (): void {\n    if (!this) {\n      return;\n    }\n    this.verify = function () {\n      throw new Error(\"You must call either .mocha()\");\n    };\n  });\n}\n\n\nconst listOfApprovedFiles: string[] = [];\nprocess.on(\"approvalFileApproved\", function (fileName): void {\n  if (listOfApprovedFiles.indexOf(fileName) === -1) {\n    listOfApprovedFiles.push(fileName);\n  }\n});\n\nprocess.on(\"exit\", function (): void {\n  const options = cfg.currentConfig();\n  postRunCleanup(options, listOfApprovedFiles);\n  const finalMessages = FinalMessages.getMessages();\n  if (finalMessages.length) {\n    console.log(\"******************************\");\n    console.log(\"* Approvals Report: WARNING!\");\n    finalMessages.forEach((message: string) => {\n      console.log(`*  - ${message}`);\n    });\n    console.log(\"******************************\");\n  }\n});\n\n\nexport function configure(overrideOptions: cfg.Config): typeof module.exports {\n  cfg.configure(overrideOptions);\n  return module.exports;\n}\n\n\nexport function getConfig(overrideOptions?: cfg.Config): cfg.Config {\n  return cfg.getConfig(overrideOptions);\n}\n\n\n\nexport function mocha(optionalBaseDir?: string): typeof module.exports {\n\n  if (!optionalBaseDir) {\n      let fileName = callsite()[1].getFileName();\n      if (fileName.startsWith(\"file:\n          fileName = fileURLToPath(fileName);\n      }\n      optionalBaseDir = path.dirname(fileName);\n  }\n  beforeEachVerifierBase(\n    MochaNamer,\n    \"require('Approvals').mocha();\",\n    optionalBaseDir,\n  );\n\n  return module.exports;\n}\n\nfunction jasmineExport(): void {\n  throw new Error(\n    \"Aww shucks.\\n\\nApprovals support of Jasmine has been completely yanked out (don't shoot). \\n\\n Jasmine has grown quite complicated (behind our back) and we haven't had enough time to figure out a solid integration pattern... for now it's support has been removed.\\n\\n Check out the docs for manual usage of approval tests to work around the missing Jasmine integration (it should be a straightforward change for you, really).\\n\\n We'll consider bringing it back if we can get someone with interest in submitting a pull request that can bring it back...\",\n  );\n}\n\n\n\nexport const reporters: { MultiReporter: any } = {\n\n  MultiReporter: require(\"./Reporting/Reporters/multiReporter\").default,\n};\n\n\nfunction verifyAndScrub(\n  dirName: string,\n  testName: string,\n  data: BinaryWriter | string,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  scrubber = scrubber || Scrubbers.noScrubber;\n\n\n  if (Array.isArray(optionsOverride)) {\n    optionsOverride = {\n      reporters: optionsOverride,\n    };\n    const stringReporters = JSON.stringify(optionsOverride.reporters);\n    console.error(\n      'For the last arg of the approvals.verify(...) function, if you passed in an array of reporters, something like [\"opendiff\",\"nodediff\"], this has been deprecated and replaced by passing in a config object. Please re-evaluate if you can remove this parameter alltogether and use individual user configs in ~/.approvalConfig, if not then replace this: ' +\n        stringReporters +\n        \" with this { reporters: \" +\n        stringReporters +\n        \"}.\",\n    );\n  }\n\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const namer = new ManualNamer(dirName, testName);\n\n  let writer: Writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data as string);\n\n    writer = new StringWriter(newOptions, data as string);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}\n\n\nexport function verify(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride?: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n\nexport function verifyAsJSON(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride: any,\n) {\n  return verifyAsJSONAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n\n\nexport function verifyAsJSONAndScrub(\n  dirName: string,\n  testName: string,\n  data: any,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    stringifyKeysInOrder(data),\n    scrubber,\n    optionsOverride,\n  );\n}\n\n\n\nexport function verifyWithControl(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory?: ReporterLoader | null,\n  optionsOverride?: Partial<cfg.Config>,\n) {\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const loader =\n    (reporterFactory as ReporterLoader) ||\n    function () {\n      return [ReporterFactory.loadReporter(newOptions.reporters)];\n    };\n\n  FileApprover.verify(namer, writer, loader, newOptions);\n}\n\n'Approvals.NodeJS/lib/config.ts'\n:import * as os from \"os\";\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as _ from \"lodash\";\nimport * as yaml from \"js-yaml\";\nimport { ReportLaunchingCircuitBreaker } from \"./Reporting/ReportLaunchingCircuitBreaker\";\nimport { Reporter } from \"./Core/Reporter\";\n\nexport interface Config {\n  reporters: (string | Reporter)[];\n  normalizeLineEndingsTo: boolean | string;\n  failOnLineEndingDifferences: boolean;\n  appendEOL: boolean;\n  EOL: string;\n  errorOnStaleApprovedFiles: boolean;\n  shouldIgnoreStaleApprovedFile: (fileName?: string) => boolean;\n  stripBOM: boolean;\n  forceApproveAll: boolean;\n  blockUntilReporterExits: boolean;\n  maxLaunches: number;\n  cmdOptionOverrides?: any;\n  cmdArgs?: string[];\n}\n\n\nexport const defaultConfig: Config = {\n  reporters: [\n    \"BeyondCompare\",\n    \"diffmerge\",\n    \"p4merge\",\n    \"tortoisemerge\",\n    \"nodediff\",\n    \"opendiff\",\n    \"gitdiff\",\n  ],\n  normalizeLineEndingsTo: false,\n  failOnLineEndingDifferences: false,\n  appendEOL: true,\n  EOL: os.EOL,\n  errorOnStaleApprovedFiles: true,\n  shouldIgnoreStaleApprovedFile: () => false,\n  stripBOM: false,\n  forceApproveAll: false,\n  blockUntilReporterExits: false,\n  maxLaunches: 10,\n};\n\n\nexport function getHomeApprovalConfig(): Config | null {\n  const homeConfigPath = path.join(os.homedir(), \".approvalsConfig\");\n  if (fs.existsSync(homeConfigPath)) {\n    const configFileData = fs.readFileSync(homeConfigPath).toString();\n    try {\n      return yaml.load(configFileData) as Config;\n    } catch (ex) {\n      throw new Error(\"Error parsing \" + homeConfigPath + \". \" + ex);\n    }\n  }\n  return null;\n}\n\nlet currentConfigObj: Config;\n\nexport function getConfig(configOverrides?: Partial<Config>): Config {\n  const homeConfig = getHomeApprovalConfig() || {};\n  const resultConfig = _.defaults(\n    configOverrides || {},\n    currentConfigObj || {},\n    homeConfig,\n    defaultConfig,\n  );\n  return resultConfig as Config;\n}\n\nexport function configure(overrideOptions?: Partial<Config>): Config {\n  currentConfigObj = getConfig(overrideOptions);\n  processConfig(currentConfigObj);\n  return currentConfigObj;\n}\n\nexport function currentConfig(): Config {\n  return currentConfigObj;\n}\n\nexport function reset(): void {\n  currentConfigObj = _.defaults({}, getHomeApprovalConfig(), defaultConfig);\n}\n\ncurrentConfigObj = getConfig();\n\nfunction processConfig(config: Config): void {\n  if (config.maxLaunches) {\n    ReportLaunchingCircuitBreaker.setMaxLaunch(config.maxLaunches);\n  }\n}\n\n'Approvals.NodeJS/lib/Reporting/ReportLaunchingCircuitBreaker.ts'\n:import { FinalMessages } from \"../FinalMessages\";\nimport NodeDiffReporter from \"./Reporters/nodediffReporter\";\n\nlet maxLaunch = 10;\nlet currentCount = 0;\nlet reroutedCount = 0;\n\nexport class ReportLaunchingCircuitBreaker {\n  static setMaxLaunch(value: number): void {\n    maxLaunch = value;\n  }\n\n  static get currentCount(): number {\n    return currentCount;\n  }\n\n  static notifyLaunched(): void {\n    currentCount++;\n  }\n\n  static isLimitExceeded(): boolean {\n    return maxLaunch <= currentCount;\n  }\n\n  static check(approved: string, received: string, options: any): boolean {\n    if (this.isLimitExceeded()) {\n      reroutedCount++;\n      FinalMessages.addKeyMessage(\n        \"maxLaunches\",\n        `config.maxLaunches (${maxLaunch}) exceeded: ${reroutedCount} diff(s) shown in console above...`,\n      );\n      new NodeDiffReporter().report(approved, received, options);\n      return true;\n    }\n    this.notifyLaunched();\n    return false;\n  }\n}\n\nexport default ReportLaunchingCircuitBreaker;\n",
        "gt": [
            "'Approvals.NodeJS/lib/Reporting/ReportLaunchingCircuitBreaker.ts'",
            "'Approvals.NodeJS/lib/config.ts'",
            "'Approvals.NodeJS/lib/Providers/BeforeEachVerifierBase.ts'",
            "'Approvals.NodeJS/lib/Approvals.ts'",
            "'Approvals.NodeJS/bin/index.ts'"
        ]
    },
    {
        "files": [
            "'installer-gui/frontend/components/actions/install.tsx'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/components/notifications.tsx'",
            "'installer-gui/frontend/index.ts'"
        ],
        "content": "'installer-gui/frontend/components/actions/install.tsx'\n:import Preact, {Component, toChildArray} from \"preact\";\nimport AppContext from \"../AppContext\";\nimport FileInput from \"../fileinput\";\nimport \"./install.scss\";\nimport SuggestedApplications from \"./suggested\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport NotificationsStore from \"../notifications\";\nimport SwitchItem from \"../switchitem\";\nimport Terminal from \"../terminal\";\nimport Installer from \"../../modules/installer\";\nimport {ipcRenderer as IPC} from \"electron\";\nimport IPCEvents from \"@common/ipcevents\";\n\nexport default class InstallPage extends Component<{}, {\n    files: string[],\n    isBrowsing: boolean,\n    kernelPath: string,\n    shouldDownloadKernel: boolean;\n    shouldCreatePackages: boolean;\n    installationDone: boolean;\n}> {\n    fileInputRef = Preact.createRef();\n    terminalRef = Preact.createRef<Terminal>();\n\n    state = {\n        files: [],\n        isBrowsing: true,\n        kernelPath: \"\",\n        shouldDownloadKernel: true,\n        shouldCreatePackages: true,\n        installationDone: false\n    };\n\n    handleChange = (files: string[]): void => {\n        for (let i = 0; i < files.length; i++) {\n            if (this.state.files.includes(files[i])) {\n                files.splice(i, 1);\n                continue;\n            }\n\n            const location = path.resolve(files[i], \"resources\");\n            if (!fs.existsSync(location)) {\n                files.splice(i, 1);\n                NotificationsStore.showNotification(\"An invalid directory was given!\");\n            }\n        }\n\n        this.setState({\n            files: this.state.files.concat(files)\n        });\n    }\n\n    handleKernelPath = () => {}\n\n    get canInstall() {\n        return this.state.files.length > 0 && this.state.kernelPath !== \"\";\n    }\n\n    renderBrowser() {\n        return (\n            <>\n                <FileInput\n                    title=\"Applications to install kernel to\"\n                    name=\"Install paths\"\n                    files={this.state.files}\n                    onChange={(files) => this.handleChange(files)}\n                    onRemove={(path) => {\n                        this.setState(prev => {\n                            prev.files.splice(prev.files.indexOf(path), 1);\n                            return {...prev, files: prev.files};\n                        });\n                    }}\n                />\n                <FileInput\n                    title=\"Kernel path\"\n                    name=\"Kernel path\"\n                    onChange={([path]) => this.setState({kernelPath: path})}\n                    files={[this.state.kernelPath].filter(Boolean)}\n                    onRemove={() => {\n                        this.setState({kernelPath: \"\"});\n                    }}\n                />\n                <SuggestedApplications\n                    onSelect={app => {\n                        this.handleChange([app]);\n                    }}\n                    files={this.state.files}\n                />\n            </>\n        );\n    }\n\n    renderInstalling() {\n        return (\n            <>\n                <SwitchItem\n                    title=\"Download kernel.asar\"\n                    value={this.state.shouldDownloadKernel}\n                    onChange={value => {\n                        this.setState({shouldDownloadKernel: value});\n                    }}\n                />\n                <SwitchItem\n                    title=\"Create packages folder\"\n                    value={this.state.shouldCreatePackages}\n                    onChange={value => {\n                        this.setState({shouldCreatePackages: value});\n                    }}\n                />\n                <Terminal ref={this.terminalRef} />\n            </>\n        );\n    }\n\n    handleInstall() {\n        Installer.install(this.state.files, {\n            downloadASAR: this.state.shouldDownloadKernel,\n            kernelPath: this.state.kernelPath,\n            makePackagesFolder: this.state.shouldCreatePackages,\n        }, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({installationDone: true});\n        });\n    }\n\n    render(_, {isBrowsing, installationDone}) {\n        return (\n            <AppContext.Consumer>\n                {App => (\n                    <div class=\"installing\">\n                        <div class=\"scroller\">\n                            {isBrowsing ? this.renderBrowser() : this.renderInstalling()}\n                            <div class=\"margin-bottom10\" />\n                        </div>\n                        <div class=\"footer\">\n                            <button onClick={() => {\n                                if (isBrowsing) App.reset();\n                                else this.setState({isBrowsing: true});\n                            }}>Back</button>\n                            <button\n                                disabled={!this.canInstall}\n                                onClick={() => {\n                                    if (!this.canInstall) return;\n\n                                    if (installationDone) return IPC.send(IPCEvents.CLOSE_APP);\n                                    if (!isBrowsing) {\n                                        this.handleInstall();\n                                    } else {\n                                        this.setState({isBrowsing: false});\n                                    }\n                                }}\n                            >\n                                {isBrowsing ? \"Continue\" : installationDone ? \"Close\" : \"Install\"}\n                            </button>\n                        </div>\n                    </div>\n                )}\n            </AppContext.Consumer>\n        );\n    }\n}\n'installer-gui/frontend/components/App.tsx'\n:import Preact, {Component} from \"preact\";\nimport InstallPage from \"./actions/install\";\nimport UninstallPage from \"./actions/uninstall\";\nimport UpdatePage from \"./actions/update\";\nimport AppContext from \"./AppContext\";\nimport Category from \"./category\";\nimport Install from \"./icons/install\";\nimport Uninstall from \"./icons/uninstall\";\nimport Update from \"./icons/update\";\nimport {Notifications} from \"./notifications\";\nimport TitleBar from \"./titlebar\";\n\nexport default class App extends Component {\n    state = {navigator: {}}\n\n    handleSetPage({element, title}): void {\n        this.setState({\n            navigator: {element, title}\n        });\n    }\n\n    handleReset(): void {\n        this.setState({navigator: {}});\n    }\n\n    renderHome() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Actions</div>\n                <Category title=\"Install\" icon={Install} note=\"Install kernel to an application you choose.\">\n                    <InstallPage />\n                </Category>\n                <Category title=\"Uninstall\" icon={Uninstall} note=\"Uninstall kernel from an application you choose.\">\n                    <UninstallPage />\n                </Category>\n                <Category title=\"Update\" icon={Update} note=\"Update the kernel.asar to the latest release.\">\n                    <UpdatePage />\n                </Category>\n            </div>\n        );\n    }\n\n    render(_, {navigator}) {\n        const context = {\n            currentPage: navigator,\n            setPage: this.handleSetPage.bind(this),\n            reset: this.handleReset.bind(this)\n        };\n\n        return (\n            <AppContext.Provider value={context}>\n                <div id=\"app-mount\">\n                    <TitleBar />\n                    <div class=\"app\">\n                        {navigator.element ? navigator.element : this.renderHome()}\n                    </div>\n                    <Notifications />\n                </div>\n            </AppContext.Provider>\n        );\n    }\n}\n'installer-gui/frontend/components/notifications.tsx'\n:import Store from \"../modules/store\";\nimport Preact, {Component} from \"preact\";\nimport Close from \"./icons/close\";\nimport \"./notifications.scss\";\n\nexport type StoreNotification = {content: string, id: string};\n\nconst NotificationsStore = new class NotificationsStore extends Store {\n    notifications: StoreNotification[] = [];\n\n    closeNotification(id: string) {\n        const index = this.notifications.findIndex(n => n.id === id);\n        if (index < 0) return false;\n\n        this.notifications.splice(index, 1);\n        this.emitChange();\n    }\n\n    showNotification(content: string) {\n        this.notifications.push({content, id: Math.random().toString(36).slice(0, 8)});\n        this.emitChange();\n    }\n}\n\nexport class Notification extends Component<{content: string, id: string}> {\n    state = {closing: false};\n\n    timeout: NodeJS.Timeout;\n\n    handleClose = () => {\n        this.setState({closing: true}, () => {\n            setTimeout(() => {\n                NotificationsStore.closeNotification(this.props.id);\n            }, 400);\n        });\n    }\n\n    componentDidMount() {this.startTimeout();}\n\n    startTimeout() {\n        this.timeout = setTimeout(() => {\n            this.handleClose();\n        }, 5000);\n    }\n\n    onMouseEnter = () => {\n        clearTimeout(this.timeout);\n    }\n\n    onMouseLeave = () => {\n        this.startTimeout();\n    }\n\n    render({content}, {closing}) {\n        return (\n            <div\n                class={`notification${closing ? \" closing\" : \"\"}`}\n                onMouseEnter={this.onMouseEnter}\n                onMouseLeave={this.onMouseLeave}\n            >\n                <div class=\"content\">{content}</div>\n                <div class=\"close-button\" onClick={this.handleClose}>\n                    <Close width=\"16\" height=\"16\" />\n                </div>\n            </div>\n        );\n    }\n}\n\nexport class Notifications extends Component {\n    componentDidMount(): void {\n        NotificationsStore.addListener(this.handleUpdate);\n    }\n\n    componentWillUnmount(): void {\n        NotificationsStore.removeListener(this.handleUpdate);\n    }\n\n    handleUpdate = (): void => {this.forceUpdate();}\n\n    renderNotifications() {\n        return NotificationsStore.notifications.map(notification => (\n            <Notification key={notification.id} {...notification} />\n        ));\n    }\n\n    render() {\n        return (\n            <div class=\"notifications\">\n                {this.renderNotifications()}\n            </div>\n        );\n    }\n}\n\nexport default NotificationsStore;\n'installer-gui/frontend/index.ts'\n:import {h, render} from \"preact\";\nimport App from \"./components/App\";\nimport Styles from \"./styles\";\nimport {createElement} from \"./util\";\nimport \"./index.scss\";\n\nStyles.inject();\nconst root = createElement(\"div\", {id: \"root\"});\ndocument.body.appendChild(root);\n\nrender(\n    h(App, {}),\n    root\n);",
        "gt": [
            "'installer-gui/frontend/components/notifications.tsx'",
            "'installer-gui/frontend/components/actions/install.tsx'",
            "'installer-gui/frontend/components/App.tsx'",
            "'installer-gui/frontend/index.ts'"
        ]
    },
    {
        "files": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameter.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/InterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameterDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'"
        ],
        "content": "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'\n:import * as t from '@babel/types';\n\nimport { convertTypeParameterDeclaration } from './convertTypeParameterDeclaration';\nimport { convertObjectTypeProperty } from './convertObjectTypeProperty';\nimport { baseNodeProps } from '../utils/baseNodeProps';\nimport { convertObjectTypeCallProperty } from './convertObjectTypeCallProperty';\nimport { convertObjectTypeIndexer } from './convertObjectTypeIndexer';\nimport { convertObjectTypeInternalSlot } from './convertObjectTypeInternalSlot';\nimport { convertInterfaceExtends } from './convertInterfaceExtends';\n\nexport function convertInterfaceDeclaration(\n  node: t.InterfaceDeclaration | t.DeclareInterface\n) {\n  let typeParameters = null;\n  if (node.typeParameters) {\n    typeParameters = {\n      ...convertTypeParameterDeclaration(node.typeParameters),\n      ...baseNodeProps(node.typeParameters),\n    };\n  }\n  const extendsCombined = node.extends;\n  let _extends = undefined;\n\n  if (extendsCombined && extendsCombined.length > 0) {\n    _extends = extendsCombined.map(v => ({\n      ...convertInterfaceExtends(v),\n      ...baseNodeProps(v),\n    }));\n  }\n\n  const bodyElements = [];\n\n  for (const property of node.body.properties) {\n    if (t.isObjectTypeProperty(property)) {\n      bodyElements.push({\n        ...convertObjectTypeProperty(property),\n        ...baseNodeProps(property),\n      });\n    }\n  }\n  if (node.body.callProperties) {\n    bodyElements.push(\n      ...node.body.callProperties.map(v => ({\n        ...convertObjectTypeCallProperty(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  if (node.body.indexers) {\n    bodyElements.push(\n      ...node.body.indexers.map(v => ({\n        ...convertObjectTypeIndexer(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  if (node.body.internalSlots) {\n    bodyElements.push(\n      ...node.body.internalSlots.map(v => ({\n        ...convertObjectTypeInternalSlot(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  const body = {\n    ...t.tsInterfaceBody(bodyElements),\n    ...baseNodeProps(node.body),\n  };\n\n  return t.tsInterfaceDeclaration(node.id, typeParameters, _extends, body);\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameter.ts'\n:import * as t from '@babel/types';\nimport { convertFlowType } from './convertFlowType';\nimport { baseNodeProps } from '../utils/baseNodeProps';\n\nexport function convertTypeParameter(node: t.TypeParameter): t.TSTypeParameter {\n  return t.tsTypeParameter(\n    node.bound && {\n      ...baseNodeProps(node.bound.typeAnnotation),\n      ...convertFlowType(node.bound.typeAnnotation),\n    },\n    node.default && {\n      ...baseNodeProps(node.default),\n      ...convertFlowType(node.default),\n    },\n    node.name!\n  );\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/InterfaceDeclaration.ts'\n:import * as t from '@babel/types';\nimport { NodePath } from '@babel/traverse';\n\nimport { convertInterfaceDeclaration } from '../converters/convertInterfaceDeclaration';\nimport { replaceWith } from '../utils/replaceWith';\n\nexport function InterfaceDeclaration(path: NodePath<t.InterfaceDeclaration>) {\n  replaceWith(path, convertInterfaceDeclaration(path.node));\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameterDeclaration.ts'\n:import * as t from '@babel/types';\nimport { convertTypeParameter } from './convertTypeParameter';\nimport { baseNodeProps } from '../utils/baseNodeProps';\n\nexport function convertTypeParameterDeclaration(\n  node: t.TypeParameterDeclaration\n): t.TSTypeParameterDeclaration {\n  const params = node.params.map(p => ({\n    ...baseNodeProps(p),\n    ...convertTypeParameter(p),\n  }));\n\n  return t.tsTypeParameterDeclaration(params);\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'\n:import { BabelFile, PluginObj, Visitor } from '@babel/core';\nimport * as t from '@babel/types';\nimport { codeFrameColumns } from '@babel/code-frame';\nimport { ImportDeclaration } from './visitors/ImportDeclaration';\nimport { OpaqueType } from './visitors/OpaqueType';\nimport { TypeAnnotation } from './visitors/TypeAnnotation';\nimport { TypeCastExpression } from './visitors/TypeCastExpression';\nimport { TypeParameterDeclaration } from './visitors/TypeParameterDeclaration';\nimport { ClassDeclaration } from './visitors/ClassDeclaration';\nimport { DeclareClass } from './visitors/DeclareClass';\nimport { InterfaceDeclaration } from './visitors/InterfaceDeclaration';\nimport { DeclareFunction } from './visitors/DeclareFunction';\nimport { Program } from './visitors/Program';\nimport { TypeAlias } from './visitors/TypeAlias';\nimport { FunctionDeclaration } from './visitors/FunctionDeclaration';\nimport { CallExpression } from './visitors/CallExpression';\nimport { DeclareVariable } from './visitors/DeclareVariable';\nimport { DeclareTypeAlias } from './visitors/DeclareTypeAlias';\nimport { DeclareInterface } from './visitors/DeclareInterface';\nimport { DeclareOpaqueType } from './visitors/DeclareOpaqueType';\nimport { DeclareModuleExports } from './visitors/DeclareModuleExports';\nimport { DeclareModule } from './visitors/DeclareModule';\nimport { DeclareExportDeclaration } from './visitors/DeclareExportDeclaration';\nimport { NewExpression } from './visitors/NewExpression';\nimport { ArrowFunctionExpression } from './visitors/ArrowFunctionExpression';\nimport { PluginOptions, PluginPass } from './types';\nimport { TSModuleDeclaration } from './visitors/TSModuleDeclaration';\nimport { ExportAllDeclaration } from './visitors/ExportAllDeclaration';\nimport { ObjectMethod } from './visitors/ObjectMethod';\nimport { DeclareExportAllDeclaration } from './visitors/DeclareExportAllDeclaration';\nimport { Pattern } from './visitors/Pattern';\nimport { ForOfStatement } from './visitors/ForOfStatement';\nimport { EnumDeclaration } from './visitors/EnumDeclaration';\n\nconst visitor: Visitor<PluginPass> = {\n  Program,\n  TypeAnnotation,\n  TypeAlias,\n  TypeParameterDeclaration,\n  ImportDeclaration,\n  TypeCastExpression,\n  OpaqueType,\n  DeclareClass,\n  ClassDeclaration,\n  ClassExpression: ClassDeclaration,\n  ExportAllDeclaration,\n  InterfaceDeclaration,\n  DeclareFunction,\n  FunctionDeclaration,\n  CallExpression,\n  OptionalCallExpression: CallExpression,\n  DeclareVariable,\n  DeclareTypeAlias,\n  DeclareInterface,\n  DeclareOpaqueType,\n  DeclareModuleExports,\n  DeclareModule,\n  DeclareExportDeclaration,\n  DeclareExportAllDeclaration,\n  NewExpression,\n  ArrowFunctionExpression,\n  TSModuleDeclaration,\n  ObjectMethod,\n  TemplateElement(path: any) {\n\n\n\n    path.node.original = null;\n  },\n  Pattern,\n  ForOfStatement,\n  EnumDeclaration,\n};\n\nexport default (_babel: any, opts: PluginOptions = {} as PluginOptions) => {\n  if (typeof opts.isJSX === 'undefined') {\n    opts.isJSX = true;\n  }\n  if (typeof opts.legacyImports === 'undefined') {\n    opts.legacyImports = true;\n  }\n  return {\n    name: 'babel-plugin-flow-to-typescript',\n    visitor,\n\n    manipulateOptions(_babel: any, parserOpts) {\n      parserOpts.plugins.push(['flow', { enums: true }]);\n      if (opts.isJSX) {\n        parserOpts.plugins.push('jsx');\n      }\n      parserOpts.plugins.push('classProperties');\n      parserOpts.plugins.push('objectRestSpread');\n      parserOpts.plugins.push('optionalChaining');\n      parserOpts.plugins.push('nullishCoalescingOperator');\n      parserOpts.plugins.push(['decorators', { decoratorsBeforeExport: true }]);\n      parserOpts.plugins.push('dynamicImport');\n      parserOpts.allowReturnOutsideFunction = true;\n    },\n    pre(this: PluginPass, file: BabelFile) {\n      const logger = this.opts.logger || {\n        error: console.error.bind(console),\n        warn: console.log.bind(console),\n        log: console.log.bind(console),\n      };\n      const oldMessages = new Set<string>();\n      function createLogger(log: (message: string) => void) {\n        return (node: t.Node, message: string) => {\n          const loc = node && node.loc;\n\n          const highlightCode: boolean = file.opts.highlightCode ?? true;\n\n          let msg = message;\n          if (loc) {\n            msg +=\n              '\\n' +\n              codeFrameColumns(\n                file.code,\n                {\n                  start: {\n                    line: loc.start.line,\n                    column: loc.start.column + 1,\n                  },\n                  end:\n                    loc.end && loc.start.line === loc.end.line\n                      ? {\n                          line: loc.end.line,\n                          column: loc.end.column + 1,\n                        }\n                      : undefined,\n                },\n                { highlightCode }\n              );\n          }\n          if (!oldMessages.has(msg)) {\n            log(msg);\n            oldMessages.add(msg);\n          }\n        };\n      }\n      this.set('logger', {\n        error: createLogger(logger.error),\n        warn: createLogger(logger.warn),\n        log: createLogger(logger.log),\n      });\n    },\n  } as PluginObj<PluginPass>;\n};\n",
        "gt": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameter.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameterDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/InterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'"
        ]
    },
    {
        "files": [
            "'among-us-stats/src/index.tsx'",
            "'among-us-stats/src/store/redux.ts'",
            "'among-us-stats/src/components/dialogs/SettingsDialog.tsx'",
            "'among-us-stats/src/components/App.tsx'",
            "'among-us-stats/src/store/gaMiddleware.ts'"
        ],
        "content": "'among-us-stats/src/index.tsx'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n\n'among-us-stats/src/store/redux.ts'\n:import { configureStore, getDefaultMiddleware } from '@reduxjs/toolkit';\nimport { persistStore, persistReducer, FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER } from 'redux-persist';\nimport storage from 'redux-persist/lib/storage';\nimport { PersistConfig } from 'redux-persist/es/types';\n\nimport rootReducer from './reducers';\nimport migrations from './migrations/migrations';\nimport gaMiddleware from './gaMiddleware';\n\nexport type RootState = ReturnType<typeof rootReducer>;\n\nconst persistConfig: PersistConfig<RootState> = {\n  key: 'root',\n  version: 7,\n  storage,\n  migrate: migrations,\n  blacklist: ['common'],\n};\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\nconst store = configureStore({\n  reducer: persistedReducer,\n  middleware: getDefaultMiddleware({\n    serializableCheck: {\n      ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n    },\n  }).concat(gaMiddleware),\n});\n\nconst persistor = persistStore(store);\n\nexport { persistor };\n\nexport default store;\n\n'among-us-stats/src/components/dialogs/SettingsDialog.tsx'\n:import React, { useEffect, useState } from 'react';\nimport { useDispatch, useSelector } from 'react-redux';\nimport DialogTitle from '@material-ui/core/DialogTitle';\nimport DialogContent from '@material-ui/core/DialogContent/DialogContent';\nimport DialogContentText from '@material-ui/core/DialogContentText';\nimport DialogActions from '@material-ui/core/DialogActions';\nimport Accordion from '@material-ui/core/Accordion';\nimport AccordionSummary from '@material-ui/core/AccordionSummary';\nimport AccordionDetails from '@material-ui/core/AccordionDetails';\nimport { Button, Typography } from '@material-ui/core';\nimport Dialog from '@material-ui/core/Dialog';\nimport TextField from '@material-ui/core/TextField/TextField';\nimport Box from '@material-ui/core/Box';\nimport { Check, Close, ExpandMore } from '@material-ui/icons';\nimport GA from 'react-ga';\nimport Badge from '@material-ui/core/Badge';\n\nimport { commonSlice, hasVisitedSettingsKey } from '../../store/common/commonRedux';\nimport { RootState } from '../../store/redux';\nimport { settingsSlice } from '../../store/settings/settingsRedux';\nimport DiscordIcon from '../shared/icons/DiscordIcon';\n\nfunction SettingsDialog(): JSX.Element | null {\n  const dispatch = useDispatch();\n  const shouldShow = useSelector((state: RootState) => state.common.showSettings);\n  const settings = useSelector((state: RootState) => state.settings);\n  const [testResult, setTestResult] = useState<'untested' | 'good' | 'bad'>('untested');\n\n  useEffect(() => {\n    if (shouldShow) {\n      localStorage.setItem(hasVisitedSettingsKey, 'true');\n      GA.event({ category: 'View', action: 'settingsDialog' });\n    }\n  }, [shouldShow]);\n\n  const handleClose = () => {\n    dispatch(commonSlice.actions.toggleSettings());\n  };\n\n  if (!shouldShow) {\n    return null;\n  }\n\n  const testUrl = async () => {\n    const formData = new FormData();\n    formData.append(\n      'payload_json',\n      JSON.stringify({\n        content: 'If you see this message you have set up the integration correctly! :ballot_box_with_check: ',\n      }),\n    );\n\n    try {\n      const result = await fetch(settings.discordShareWebhook ?? '', {\n        method: 'POST',\n        body: formData,\n      });\n\n      if (result.status < 299) {\n        GA.event({ category: 'Social', action: 'testDiscordWebhook', label: 'hook-good' });\n        setTestResult('good');\n      } else {\n        GA.event({ category: 'Social', action: 'testDiscordWebhook', label: 'hook-bad-response' });\n        setTestResult('bad');\n      }\n    } catch (e) {\n      console.error(e);\n      GA.event({ category: 'Social', action: 'testDiscordWebhook', label: 'hook-bad-request' });\n      setTestResult('bad');\n    }\n  };\n\n  return (\n    <Dialog\n      open\n      onClose={() => {\n        dispatch(commonSlice.actions.toggleSettings());\n        setTestResult('untested');\n      }}\n    >\n      <DialogTitle>Settings</DialogTitle>\n      <DialogContent>\n        <Box display=\"flex\" alignItems=\"center\">\n          <Badge variant=\"dot\" color=\"secondary\" invisible={!!localStorage.getItem(hasVisitedSettingsKey)}>\n            <DiscordIcon />\n          </Badge>\n\n          <Box pl={1}>\n            <Typography variant=\"h6\">New feature: Discord integration</Typography>\n          </Box>\n        </Box>\n        <DialogContentText>\n          If you configure a Discord webhook URL you will be able to share the score directly from the summary card.\n        </DialogContentText>\n        <Box pt={1} pb={1}>\n          <Accordion>\n            <AccordionSummary expandIcon={<ExpandMore />} aria-controls=\"panel1a-content\" id=\"panel1a-header\">\n              <Typography>How do I get a webhook URL?</Typography>\n            </AccordionSummary>\n            <AccordionDetails>\n              <ol>\n                <li>Open the Discord channel you want to use</li>\n                <li>From the channel menu, select Edit channel.</li>\n                <li>Click on Webhooks menu item.</li>\n                <li>Click the Create Webhook button and fill in the name of the bot that will post the messages.</li>\n                <li>Note the URL from the WEBHOOK URL field.</li>\n                <li>Click the Save button.</li>\n                <li>Paste the URL into the field in this settings dialog</li>\n              </ol>\n            </AccordionDetails>\n          </Accordion>\n        </Box>\n        <Box pt={1}>\n          <TextField\n            id=\"discord-share-webhook\"\n            label=\"Discord Webhook URL\"\n            variant=\"outlined\"\n            defaultValue={settings.discordShareWebhook}\n            fullWidth\n            onFocus={() => {\n              setTestResult('untested');\n            }}\n            onBlur={(event) => {\n              dispatch(settingsSlice.actions.setDiscordShareWebhook(event.target.value || null));\n              setTestResult('untested');\n            }}\n          />\n        </Box>\n        <Box pt={1} display=\"flex\" justifyContent=\"flex-end\">\n          <Button\n            color=\"primary\"\n            disabled={!settings.discordShareWebhook}\n            endIcon={testResult === 'good' ? <Check /> : testResult === 'bad' ? <Close color=\"error\" /> : null}\n            onClick={testUrl}\n          >\n            Test URL\n          </Button>\n        </Box>\n        <DialogContentText>\n          {testResult === 'good'\n            ? 'Seems good! Did you see a message in the Discord channel?'\n            : testResult === 'bad'\n            ? \"Something isn't set up right\"\n            : null}\n        </DialogContentText>\n      </DialogContent>\n      <DialogActions>\n        <Button onClick={handleClose}>Done</Button>\n      </DialogActions>\n    </Dialog>\n  );\n}\n\nexport default SettingsDialog;\n\n'among-us-stats/src/components/App.tsx'\n:import React, { Suspense } from 'react';\nimport { CssBaseline, ThemeProvider } from '@material-ui/core';\nimport { PersistGate } from 'redux-persist/integration/react';\nimport { Provider } from 'react-redux';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\n\nimport store, { persistor } from '../store/redux';\n\nimport AppBar from './appbar/AppBar';\nimport ActiveSession from './activesession/ActiveSession';\nimport Sessions from './sessions/Sessions';\nimport IntroDialog from './dialogs/IntroDialog';\nimport SettingsDialog from './dialogs/SettingsDialog';\nimport FeedbackDialog from './dialogs/FeedbackDialog';\nimport NotFound from './NotFound';\nimport Analytics from './Analytics';\nimport { theme } from './theme';\nimport ContentWrapper from './ContentWrapper';\nimport ErrorBoundary from './ErrorBoundary';\nimport FullscreenFallback from './shared/FullscreenFallback';\n\nconst LazyPlayersOverview = React.lazy(() => import('./playersoverview/PlayersOverview'));\n\nfunction App(): JSX.Element {\n  return (\n    <Provider store={store}>\n      <PersistGate loading={null} persistor={persistor}>\n        <ThemeProvider theme={theme}>\n          <ErrorBoundary>\n            <Router>\n              <IntroDialog />\n              <SettingsDialog />\n              <FeedbackDialog />\n              <Analytics />\n              <CssBaseline />\n              <AppBar />\n              <ContentWrapper>\n                <Switch>\n                  <Route exact path={['/', '/summary']}>\n                    <ActiveSession />\n                  </Route>\n                  <Route path=\"/sessions\">\n                    <Sessions />\n                  </Route>\n                  <Route path=\"/players\">\n                    <Suspense fallback={<FullscreenFallback />}>\n                      <LazyPlayersOverview />\n                    </Suspense>\n                  </Route>\n                  <Route>\n                    <NotFound />\n                  </Route>\n                </Switch>\n              </ContentWrapper>\n            </Router>\n          </ErrorBoundary>\n        </ThemeProvider>\n      </PersistGate>\n    </Provider>\n  );\n}\n\nexport default App;\n\n'among-us-stats/src/store/gaMiddleware.ts'\n:import GA from 'react-ga';\nimport { Middleware, PayloadAction } from '@reduxjs/toolkit';\n\nimport { reportError } from '../utils/reportError';\n\nimport { statsSlice } from './stats/statsRedux';\n\nexport const gaMiddleware: Middleware = () => (next) => (action) => {\n  const [part, actionName] = action.type.split('/');\n\n  if (part === 'stats') {\n    GA.event({ category: part, action: actionName, label: getLabelFromActionPayload(action) });\n  }\n\n  if (part === 'settings') {\n    GA.event({ category: part, action: actionName });\n  }\n\n  try {\n    next(action);\n  } catch (e) {\n    GA.exception({\n      description: `Redux: ${e.message}`,\n      fatal: false,\n    });\n    reportError('redux', e);\n    throw e;\n  }\n};\n\nfunction getLabelFromActionPayload({ type, payload }: PayloadAction<unknown>): string | undefined {\n  switch (type) {\n    case statsSlice.actions.finishGame.toString():\n      const finishGamePayload = payload as Parameters<typeof statsSlice.actions.finishGame>['0'];\n\n      return finishGamePayload.winner ?? 'null';\n    case statsSlice.actions.newPlayers.toString():\n      const newPlayersPayload = payload as Parameters<typeof statsSlice.actions.newPlayers>['0'];\n\n      return `new:${newPlayersPayload.newPlayerNames.length},existing${newPlayersPayload.existingPlayers.length}`;\n    default:\n      return undefined;\n  }\n}\n\nexport default gaMiddleware;\n",
        "gt": [
            "'among-us-stats/src/store/gaMiddleware.ts'",
            "'among-us-stats/src/store/redux.ts'",
            "'among-us-stats/src/components/dialogs/SettingsDialog.tsx'",
            "'among-us-stats/src/components/App.tsx'",
            "'among-us-stats/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'vscode.clipboard-manager/src/manager.ts'",
            "'vscode.clipboard-manager/src/test/common.ts'",
            "'vscode.clipboard-manager/src/test/completion.test.ts'",
            "'vscode.clipboard-manager/src/completion.ts'"
        ],
        "content": "'vscode.clipboard-manager/src/manager.ts'\n:import * as fs from \"fs\";\nimport * as os from \"os\";\nimport * as path from \"path\";\nimport * as vscode from \"vscode\";\nimport { IClipboardTextChange, Monitor } from \"./monitor\";\n\nexport interface IClipboardItem {\n  value: string;\n  createdAt: number;\n  lastUse?: number;\n  copyCount: number;\n  useCount: number;\n  language?: string;\n  createdLocation?: vscode.Location;\n}\n\nexport class ClipboardManager implements vscode.Disposable {\n  protected _disposable: vscode.Disposable[] = [];\n\n  protected _clips: IClipboardItem[] = [];\n  get clips() {\n    return this._clips;\n  }\n\n  protected lastUpdate: number = 0;\n\n\n\n\n\n  private _onDidClipListChange = new vscode.EventEmitter<void>();\n  public readonly onDidChangeClipList = this._onDidClipListChange.event;\n\n  constructor(\n    protected context: vscode.ExtensionContext,\n    protected _monitor: Monitor\n  ) {\n    this._monitor.onDidChangeText(this.updateClipList, this, this._disposable);\n\n    this.loadClips();\n\n    vscode.window.onDidChangeWindowState(\n      state => {\n        if (state.focused) {\n          this.checkClipsUpdate();\n        }\n      },\n      this,\n      this._disposable\n    );\n\n    vscode.workspace.onDidChangeConfiguration(\n      e => e.affectsConfiguration(\"clipboard-manager\") && this.saveClips()\n    );\n  }\n\n  protected updateClipList(change: IClipboardTextChange) {\n    this.checkClipsUpdate();\n\n    const config = vscode.workspace.getConfiguration(\"clipboard-manager\");\n    const maxClips = config.get(\"maxClips\", 100);\n    const avoidDuplicates = config.get(\"avoidDuplicates\", true);\n\n    let item: IClipboardItem = {\n      value: change.value,\n      createdAt: change.timestamp,\n      copyCount: 1,\n      useCount: 0,\n      language: change.language,\n      createdLocation: change.location,\n    };\n\n    if (avoidDuplicates) {\n      const index = this._clips.findIndex(c => c.value === change.value);\n\n\n      if (index >= 0) {\n        this._clips[index].copyCount++;\n        item = this._clips[index];\n        this._clips = this._clips.filter(c => c.value !== change.value);\n      }\n    }\n\n\n    this._clips.unshift(item);\n\n\n    if (maxClips > 0) {\n      this._clips = this._clips.slice(0, maxClips);\n    }\n\n    this._onDidClipListChange.fire();\n\n    this.saveClips();\n  }\n\n  public async setClipboardValue(value: string) {\n    this.checkClipsUpdate();\n\n    const config = vscode.workspace.getConfiguration(\"clipboard-manager\");\n    const moveToTop = config.get(\"moveToTop\", true);\n\n    const index = this._clips.findIndex(c => c.value === value);\n\n    if (index >= 0) {\n      this._clips[index].useCount++;\n\n      if (moveToTop) {\n        const clips = this.clips.splice(index, 1);\n        this._clips.unshift(...clips);\n        this._onDidClipListChange.fire();\n        this.saveClips();\n      }\n    }\n\n    return await this._monitor.clipboard.writeText(value);\n  }\n\n  public removeClipboardValue(value: string) {\n    this.checkClipsUpdate();\n\n    const prevLength = this._clips.length;\n\n    this._clips = this._clips.filter(c => c.value !== value);\n    this._onDidClipListChange.fire();\n    this.saveClips();\n\n    return prevLength !== this._clips.length;\n  }\n\n  public clearAll() {\n    this.checkClipsUpdate();\n\n    this._clips = [];\n    this._onDidClipListChange.fire();\n    this.saveClips();\n\n    return true;\n  }\n\n\n  protected getStoreFile() {\n    let folder = os.tmpdir();\n\n    if (this.context.storagePath) {\n      const parts = this.context.storagePath.split(\n        /[\\\\/]workspaceStorage[\\\\/]/\n      );\n      folder = parts[0];\n    }\n\n    const filePath = path.join(folder, \"clipboard.history.json\");\n\n    const config = vscode.workspace.getConfiguration(\"clipboard-manager\");\n    const saveTo = config.get<string | null | boolean>(\"saveTo\");\n\n    if (typeof saveTo === \"string\") {\n      return saveTo;\n    }\n\n    if (saveTo === false) {\n      return false;\n    }\n\n    return filePath;\n  }\n\n  protected jsonReplacer(key: string, value: any) {\n    if (key === \"createdLocation\" && value) {\n      value = {\n        range: {\n          start: value.range.start,\n          end: value.range.end,\n        },\n        uri: value.uri.toString(),\n      };\n    } else if (value instanceof vscode.Uri) {\n      value = value.toString();\n    }\n\n    return value;\n  }\n\n  public saveClips() {\n    const file = this.getStoreFile();\n    if (!file) {\n      return;\n    }\n\n    let json = \"[]\";\n    try {\n      json = JSON.stringify(\n        {\n          version: 2,\n          clips: this._clips,\n        },\n        this.jsonReplacer,\n        2\n      );\n    } catch (error) {\n      console.error(error);\n      return;\n    }\n\n    try {\n      fs.writeFileSync(file, json);\n      this.lastUpdate = fs.statSync(file).mtimeMs;\n    } catch (error: any) {\n      switch (error.code) {\n        case \"EPERM\":\n          vscode.window.showErrorMessage(\n            `Not permitted to save clipboards on \"${file}\"`\n          );\n          break;\n        case \"EISDIR\":\n          vscode.window.showErrorMessage(\n            `Failed to save clipboards on \"${file}\", because the path is a directory`\n          );\n          break;\n        default:\n          console.error(error);\n      }\n    }\n  }\n\n\n  public checkClipsUpdate() {\n    const file = this.getStoreFile();\n\n    if (!file) {\n      return;\n    }\n\n    if (!fs.existsSync(file)) {\n      return;\n    }\n\n    const stat = fs.statSync(file);\n\n    if (this.lastUpdate < stat.mtimeMs) {\n      this.lastUpdate = stat.mtimeMs;\n      this.loadClips();\n    }\n  }\n\n  public loadClips() {\n    let json;\n\n    const file = this.getStoreFile();\n\n    if (file && fs.existsSync(file)) {\n      try {\n        json = fs.readFileSync(file);\n        this.lastUpdate = fs.statSync(file).mtimeMs;\n      } catch (error) {\n\n      }\n    } else {\n\n      json = this.context.globalState.get<any>(\"clips\");\n    }\n\n    if (!json) {\n      return;\n    }\n\n    let stored: any = {};\n\n    try {\n      stored = JSON.parse(json);\n    } catch (error) {\n      console.log(error);\n      return;\n    }\n\n    if (!stored.version || !stored.clips) {\n      return;\n    }\n\n    let clips = stored.clips as any[];\n\n    if (stored.version === 1) {\n      clips = clips.map(c => {\n        c.createdAt = c.timestamp;\n        c.copyCount = 1;\n        c.useCount = 0;\n        c.createdLocation = c.location;\n        return c;\n      });\n      stored.version = 2;\n    }\n\n    this._clips = clips.map(c => {\n      const clip: IClipboardItem = {\n        value: c.value,\n        createdAt: c.createdAt,\n        copyCount: c.copyCount,\n        useCount: c.copyCount,\n        language: c.language,\n      };\n\n      if (c.createdLocation) {\n        const uri = vscode.Uri.parse(c.createdLocation.uri);\n        const range = new vscode.Range(\n          c.createdLocation.range.start.line,\n          c.createdLocation.range.start.character,\n          c.createdLocation.range.end.line,\n          c.createdLocation.range.end.character\n        );\n        clip.createdLocation = new vscode.Location(uri, range);\n      }\n\n      return clip;\n    });\n\n    this._onDidClipListChange.fire();\n  }\n\n  public dispose() {\n    this._disposable.forEach(d => d.dispose());\n  }\n}\n\n'vscode.clipboard-manager/src/test/common.ts'\n:import * as vscode from \"vscode\";\nimport { ClipboardCompletion } from \"../completion\";\nimport { ClipboardManager } from \"../manager\";\n\n\nconst pkg = require(\"../../package.json\");\n\nconst EXTENSION_ID = `${pkg.publisher}.${pkg.name}`;\n\ninterface ExtensionAPI {\n  completion: ClipboardCompletion;\n  manager: ClipboardManager;\n}\n\nexport function getExtension() {\n  return vscode.extensions.getExtension<ExtensionAPI>(EXTENSION_ID);\n}\n\nexport async function activateExtension() {\n  const ext = getExtension();\n\n  if (!ext) {\n    return false;\n  }\n\n  if (!ext.isActive) {\n    await ext.activate();\n  }\n\n  return ext.isActive;\n}\n\nexport async function showSidebar() {\n  try {\n    await vscode.commands.executeCommand(\n      \"workbench.view.extension.clipboard-manager\"\n    );\n\n  } catch (error) {}\n}\n\n'vscode.clipboard-manager/src/test/completion.test.ts'\n:import * as assert from \"assert\";\nimport * as sinon from \"sinon\";\nimport * as vscode from \"vscode\";\nimport {\n  BaseClipboard,\n  defaultClipboard,\n  getNewDefaultInstance,\n} from \"../clipboard\";\nimport { commandList } from \"../commads/common\";\nimport { Monitor } from \"../monitor\";\nimport { sleep } from \"../util\";\nimport * as common from \"./common\";\n\nsuiteSetup(async function () {\n  if (!(await common.activateExtension())) {\n    this.skip();\n  }\n});\n\n\nsuite(\"Completion Tests\", function () {\n  let sandbox: sinon.SinonSandbox;\n\n  let externalClipboard: BaseClipboard;\n  let monitor: Monitor;\n\n  setup(async function () {\n    sandbox = sinon.createSandbox();\n\n    externalClipboard = getNewDefaultInstance();\n\n    monitor = (await vscode.commands.executeCommand(\n      commandList.apiGetMonitor\n    )) as Monitor;\n\n    monitor.checkInterval = 300;\n    monitor.onlyWindowFocused = false;\n\n\n    await defaultClipboard.writeText(\"Initial Value\");\n\n\n    common.showSidebar();\n\n\n    common.getExtension()?.exports.manager.clearAll();\n    await sleep(500);\n  });\n\n  teardown(function () {\n    externalClipboard.dispose();\n\n    sandbox.restore();\n  });\n\n  test(\"Completion List\", async function () {\n    const completion = common.getExtension()?.exports.completion;\n\n    if (!completion) {\n      return this.skip();\n    }\n\n    this.timeout(60000);\n\n    const provideCompletionItemsSpy = sandbox.spy(\n      completion,\n      \"provideCompletionItems\"\n    );\n\n    await externalClipboard.writeText(\"alpha\");\n    await sleep(monitor.checkInterval + 300);\n    await externalClipboard.writeText(\"beta\");\n    await sleep(monitor.checkInterval + 300);\n    await externalClipboard.writeText(\"gamma\");\n    await sleep(monitor.checkInterval + 300);\n\n    const document = await vscode.workspace.openTextDocument({\n      content:\n        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\\nclip\",\n    });\n\n    const editor = await vscode.window.showTextDocument(document);\n\n    editor.selections = [new vscode.Selection(1, 4, 1, 4)];\n\n    await vscode.commands.executeCommand(\"editor.action.triggerSuggest\");\n    await sleep(500);\n    assert.ok(provideCompletionItemsSpy.called);\n\n    await vscode.commands.executeCommand(\"selectNextSuggestion\");\n    await sleep(500);\n\n    await vscode.commands.executeCommand(\"selectPrevSuggestion\");\n    await sleep(500);\n\n    await vscode.commands.executeCommand(\"acceptSelectedSuggestion\");\n    await sleep(500);\n\n    assert.ok(!editor.document.getText().includes(\"clip\"));\n    assert.ok(editor.document.getText().includes(\"gamma\"));\n\n    await vscode.commands.executeCommand(\"workbench.action.closeActiveEditor\");\n  });\n});\n\n'vscode.clipboard-manager/src/completion.ts'\n:import * as vscode from \"vscode\";\nimport { commandList } from \"./commads/common\";\nimport { ClipboardManager } from \"./manager\";\nimport { leftPad } from \"./util\";\n\nexport class ClipboardCompletion implements vscode.CompletionItemProvider {\n  constructor(protected manager: ClipboardManager) {}\n\n  public provideCompletionItems(\n    document: vscode.TextDocument,\n    _position: vscode.Position,\n    _token: vscode.CancellationToken,\n    _context: vscode.CompletionContext\n  ): vscode.ProviderResult<vscode.CompletionItem[] | vscode.CompletionList> {\n    const config = vscode.workspace.getConfiguration(\n      \"clipboard-manager\",\n      document.uri\n    );\n\n    const enabled = config.get<boolean>(\"snippet.enabled\", true);\n\n    if (!enabled) {\n      return null;\n    }\n\n    const prefix = config.get<string>(\"snippet.prefix\", \"clip\");\n    const maxSnippets = config.get<number>(\"snippet.max\", 10);\n\n    const clips =\n      maxSnippets > 0\n        ? this.manager.clips.slice(0, maxSnippets)\n        : this.manager.clips;\n\n    const maxLength = `${clips.length}`.length;\n\n    const completions: vscode.CompletionItem[] = clips.map((clip, index) => {\n\n      const indexNumber = leftPad(index + 1, maxLength, \"0\");\n\n      const c: vscode.CompletionItem = {\n        label: `${prefix}${indexNumber}`,\n        detail: `Clipboard ${indexNumber}`,\n        insertText: clip.value,\n        kind: vscode.CompletionItemKind.Text,\n        filterText: `${prefix}${indexNumber} ${clip.value}`,\n      };\n\n\n      c.documentation = new vscode.MarkdownString();\n      c.documentation.appendCodeblock(clip.value, clip.language);\n\n      if (clip.createdAt) {\n        const date = new Date(clip.createdAt);\n        c.detail += \" - \" + date.toLocaleString();\n      }\n\n      c.command = {\n        command: commandList.setClipboardValue,\n        title: \"Paste\",\n        tooltip: \"Paste\",\n        arguments: [clip.value],\n      };\n\n      return c;\n    });\n\n    return completions;\n  }\n}\n",
        "gt": [
            "'vscode.clipboard-manager/src/manager.ts'",
            "'vscode.clipboard-manager/src/completion.ts'",
            "'vscode.clipboard-manager/src/test/common.ts'",
            "'vscode.clipboard-manager/src/test/completion.test.ts'"
        ]
    },
    {
        "files": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameter.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/InterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameterDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'"
        ],
        "content": "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'\n:import * as t from '@babel/types';\n\nimport { convertTypeParameterDeclaration } from './convertTypeParameterDeclaration';\nimport { convertObjectTypeProperty } from './convertObjectTypeProperty';\nimport { baseNodeProps } from '../utils/baseNodeProps';\nimport { convertObjectTypeCallProperty } from './convertObjectTypeCallProperty';\nimport { convertObjectTypeIndexer } from './convertObjectTypeIndexer';\nimport { convertObjectTypeInternalSlot } from './convertObjectTypeInternalSlot';\nimport { convertInterfaceExtends } from './convertInterfaceExtends';\n\nexport function convertInterfaceDeclaration(\n  node: t.InterfaceDeclaration | t.DeclareInterface\n) {\n  let typeParameters = null;\n  if (node.typeParameters) {\n    typeParameters = {\n      ...convertTypeParameterDeclaration(node.typeParameters),\n      ...baseNodeProps(node.typeParameters),\n    };\n  }\n  const extendsCombined = node.extends;\n  let _extends = undefined;\n\n  if (extendsCombined && extendsCombined.length > 0) {\n    _extends = extendsCombined.map(v => ({\n      ...convertInterfaceExtends(v),\n      ...baseNodeProps(v),\n    }));\n  }\n\n  const bodyElements = [];\n\n  for (const property of node.body.properties) {\n    if (t.isObjectTypeProperty(property)) {\n      bodyElements.push({\n        ...convertObjectTypeProperty(property),\n        ...baseNodeProps(property),\n      });\n    }\n  }\n  if (node.body.callProperties) {\n    bodyElements.push(\n      ...node.body.callProperties.map(v => ({\n        ...convertObjectTypeCallProperty(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  if (node.body.indexers) {\n    bodyElements.push(\n      ...node.body.indexers.map(v => ({\n        ...convertObjectTypeIndexer(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  if (node.body.internalSlots) {\n    bodyElements.push(\n      ...node.body.internalSlots.map(v => ({\n        ...convertObjectTypeInternalSlot(v),\n        ...baseNodeProps(v),\n      }))\n    );\n  }\n  const body = {\n    ...t.tsInterfaceBody(bodyElements),\n    ...baseNodeProps(node.body),\n  };\n\n  return t.tsInterfaceDeclaration(node.id, typeParameters, _extends, body);\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameter.ts'\n:import * as t from '@babel/types';\nimport { convertFlowType } from './convertFlowType';\nimport { baseNodeProps } from '../utils/baseNodeProps';\n\nexport function convertTypeParameter(node: t.TypeParameter): t.TSTypeParameter {\n  return t.tsTypeParameter(\n    node.bound && {\n      ...baseNodeProps(node.bound.typeAnnotation),\n      ...convertFlowType(node.bound.typeAnnotation),\n    },\n    node.default && {\n      ...baseNodeProps(node.default),\n      ...convertFlowType(node.default),\n    },\n    node.name!\n  );\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/InterfaceDeclaration.ts'\n:import * as t from '@babel/types';\nimport { NodePath } from '@babel/traverse';\n\nimport { convertInterfaceDeclaration } from '../converters/convertInterfaceDeclaration';\nimport { replaceWith } from '../utils/replaceWith';\n\nexport function InterfaceDeclaration(path: NodePath<t.InterfaceDeclaration>) {\n  replaceWith(path, convertInterfaceDeclaration(path.node));\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameterDeclaration.ts'\n:import * as t from '@babel/types';\nimport { convertTypeParameter } from './convertTypeParameter';\nimport { baseNodeProps } from '../utils/baseNodeProps';\n\nexport function convertTypeParameterDeclaration(\n  node: t.TypeParameterDeclaration\n): t.TSTypeParameterDeclaration {\n  const params = node.params.map(p => ({\n    ...baseNodeProps(p),\n    ...convertTypeParameter(p),\n  }));\n\n  return t.tsTypeParameterDeclaration(params);\n}\n\n'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'\n:import { BabelFile, PluginObj, Visitor } from '@babel/core';\nimport * as t from '@babel/types';\nimport { codeFrameColumns } from '@babel/code-frame';\nimport { ImportDeclaration } from './visitors/ImportDeclaration';\nimport { OpaqueType } from './visitors/OpaqueType';\nimport { TypeAnnotation } from './visitors/TypeAnnotation';\nimport { TypeCastExpression } from './visitors/TypeCastExpression';\nimport { TypeParameterDeclaration } from './visitors/TypeParameterDeclaration';\nimport { ClassDeclaration } from './visitors/ClassDeclaration';\nimport { DeclareClass } from './visitors/DeclareClass';\nimport { InterfaceDeclaration } from './visitors/InterfaceDeclaration';\nimport { DeclareFunction } from './visitors/DeclareFunction';\nimport { Program } from './visitors/Program';\nimport { TypeAlias } from './visitors/TypeAlias';\nimport { FunctionDeclaration } from './visitors/FunctionDeclaration';\nimport { CallExpression } from './visitors/CallExpression';\nimport { DeclareVariable } from './visitors/DeclareVariable';\nimport { DeclareTypeAlias } from './visitors/DeclareTypeAlias';\nimport { DeclareInterface } from './visitors/DeclareInterface';\nimport { DeclareOpaqueType } from './visitors/DeclareOpaqueType';\nimport { DeclareModuleExports } from './visitors/DeclareModuleExports';\nimport { DeclareModule } from './visitors/DeclareModule';\nimport { DeclareExportDeclaration } from './visitors/DeclareExportDeclaration';\nimport { NewExpression } from './visitors/NewExpression';\nimport { ArrowFunctionExpression } from './visitors/ArrowFunctionExpression';\nimport { PluginOptions, PluginPass } from './types';\nimport { TSModuleDeclaration } from './visitors/TSModuleDeclaration';\nimport { ExportAllDeclaration } from './visitors/ExportAllDeclaration';\nimport { ObjectMethod } from './visitors/ObjectMethod';\nimport { DeclareExportAllDeclaration } from './visitors/DeclareExportAllDeclaration';\nimport { Pattern } from './visitors/Pattern';\nimport { ForOfStatement } from './visitors/ForOfStatement';\nimport { EnumDeclaration } from './visitors/EnumDeclaration';\n\nconst visitor: Visitor<PluginPass> = {\n  Program,\n  TypeAnnotation,\n  TypeAlias,\n  TypeParameterDeclaration,\n  ImportDeclaration,\n  TypeCastExpression,\n  OpaqueType,\n  DeclareClass,\n  ClassDeclaration,\n  ClassExpression: ClassDeclaration,\n  ExportAllDeclaration,\n  InterfaceDeclaration,\n  DeclareFunction,\n  FunctionDeclaration,\n  CallExpression,\n  OptionalCallExpression: CallExpression,\n  DeclareVariable,\n  DeclareTypeAlias,\n  DeclareInterface,\n  DeclareOpaqueType,\n  DeclareModuleExports,\n  DeclareModule,\n  DeclareExportDeclaration,\n  DeclareExportAllDeclaration,\n  NewExpression,\n  ArrowFunctionExpression,\n  TSModuleDeclaration,\n  ObjectMethod,\n  TemplateElement(path: any) {\n\n\n\n    path.node.original = null;\n  },\n  Pattern,\n  ForOfStatement,\n  EnumDeclaration,\n};\n\nexport default (_babel: any, opts: PluginOptions = {} as PluginOptions) => {\n  if (typeof opts.isJSX === 'undefined') {\n    opts.isJSX = true;\n  }\n  if (typeof opts.legacyImports === 'undefined') {\n    opts.legacyImports = true;\n  }\n  return {\n    name: 'babel-plugin-flow-to-typescript',\n    visitor,\n\n    manipulateOptions(_babel: any, parserOpts) {\n      parserOpts.plugins.push(['flow', { enums: true }]);\n      if (opts.isJSX) {\n        parserOpts.plugins.push('jsx');\n      }\n      parserOpts.plugins.push('classProperties');\n      parserOpts.plugins.push('objectRestSpread');\n      parserOpts.plugins.push('optionalChaining');\n      parserOpts.plugins.push('nullishCoalescingOperator');\n      parserOpts.plugins.push(['decorators', { decoratorsBeforeExport: true }]);\n      parserOpts.plugins.push('dynamicImport');\n      parserOpts.allowReturnOutsideFunction = true;\n    },\n    pre(this: PluginPass, file: BabelFile) {\n      const logger = this.opts.logger || {\n        error: console.error.bind(console),\n        warn: console.log.bind(console),\n        log: console.log.bind(console),\n      };\n      const oldMessages = new Set<string>();\n      function createLogger(log: (message: string) => void) {\n        return (node: t.Node, message: string) => {\n          const loc = node && node.loc;\n\n          const highlightCode: boolean = file.opts.highlightCode ?? true;\n\n          let msg = message;\n          if (loc) {\n            msg +=\n              '\\n' +\n              codeFrameColumns(\n                file.code,\n                {\n                  start: {\n                    line: loc.start.line,\n                    column: loc.start.column + 1,\n                  },\n                  end:\n                    loc.end && loc.start.line === loc.end.line\n                      ? {\n                          line: loc.end.line,\n                          column: loc.end.column + 1,\n                        }\n                      : undefined,\n                },\n                { highlightCode }\n              );\n          }\n          if (!oldMessages.has(msg)) {\n            log(msg);\n            oldMessages.add(msg);\n          }\n        };\n      }\n      this.set('logger', {\n        error: createLogger(logger.error),\n        warn: createLogger(logger.warn),\n        log: createLogger(logger.log),\n      });\n    },\n  } as PluginObj<PluginPass>;\n};\n",
        "gt": [
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameter.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertTypeParameterDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/converters/convertInterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/visitors/InterfaceDeclaration.ts'",
            "'flowts/packages/babel-plugin-flow-to-typescript/src/index.ts'"
        ]
    },
    {
        "files": [
            "'Source-Engine-VSCode-Extension/src/language/KvDocument.ts'",
            "'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/main.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'",
            "'Source-Engine-VSCode-Extension/src/language/ShaderParamCompletionItemProvider.ts'"
        ],
        "content": "'Source-Engine-VSCode-Extension/src/language/KvDocument.ts'\n:import * as vscode from \"vscode\";\nimport { KvPair, KvPiece } from \"../Kv\";\nimport { tokenize, TokenList, Token, TokenType } from \"@sourcelib/kv\";\nimport { KvTokensProviderBase } from \"./KvTokensProviderBase\";\n\nexport default class KvDocument {\n\n    protected _document: vscode.TextDocument;\n    protected _tokens: TokenList;\n\n    public get document(): vscode.TextDocument {\n        return this._document;\n    }\n\n    public get tokens(): TokenList {\n        return this._tokens;\n    }\n\n    public static from(document: vscode.TextDocument): KvDocument {\n        return new KvDocument(document, tokenize(document.getText()));\n    }\n\n    public static tokenLegend = new vscode.SemanticTokensLegend([\n        \"struct\",\n        \"comment\",\n        \"variable\",\n        \"string\",\n        \"number\",\n        \"operator\",\n        \"macro\",\n        \"boolean\",\n        \"keyword\",\n        \"parameter\"\n    ], [\n        \"declaration\",\n        \"readonly\"\n    ]);\n\n    private constructor(document: vscode.TextDocument, tks: TokenList) {\n        this._document = document;\n        this._tokens = tks;\n    }\n\n    public getKeyValueAt(lineNumber: number): KvPair | null {\n\n        const line = this._document.lineAt(lineNumber);\n        if (line.isEmptyOrWhitespace)\n            return null;\n        const tokens = this.tokens.getAllOnLine(lineNumber);\n\n\n        if (tokens.length == 0)\n            return null;\n\n        let keyPiece: KvPiece | null = null;\n        const valuePieces: KvPiece[] = [];\n        for (const token of tokens) {\n            switch (token.type) {\n            case TokenType.Key:\n                keyPiece = this.getUnquotedToken(token); break;\n            case TokenType.Value:\n                valuePieces.push(this.getUnquotedToken(token)); break;\n            }\n        }\n\n        if (keyPiece == null)\n            return null;\n\n        return new KvPair(keyPiece, valuePieces);\n    }\n\n    public getTokenRange(token: Token): vscode.Range {\n        const start = new vscode.Position(token.line, token.range.getStart());\n        const end = new vscode.Position(token.line, token.range.getEnd());\n        return new vscode.Range(start, end);\n    }\n\n    private getUnquotedToken(token: Token): KvPiece {\n        const range = this.getTokenRange(token);\n        return KvTokensProviderBase.unquoteToken(token, range);\n    }\n\n}\n\n'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'\n:import vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\nimport { KvTokensProviderBase } from \"./KvTokensProviderBase\";\nimport { getColorMatches, ColorMatchParenthesisType, getMatrixMatches } from \"@sourcelib/vmt\";\nimport { getParentDocumentDirectory } from \"@sourcelib/fs\";\nimport { Token, isFloatValue, isScalarValue } from \"@sourcelib/kv\";\nimport { shaderParams, internalTextures } from \"@sourcelib/vmt\";\nimport { KvSemanticProcessor, KvSemanticProcessorParams } from \"./KvSemanticProcessor\";\nimport { KvPair } from \"../Kv\";\nimport * as main from \"../main\";\nimport fs from \"fs\";\nimport path from \"path\";\n\n\nexport class VmtSemanticTokenProvider extends KvTokensProviderBase {\n\n    protected keyProcessors: KvSemanticProcessor[] = [\n        { regex: /\\$\\w+/, processor: this.processKeyShader },\n        { regex: /%\\w+/, processor: this.processKeyCompile }\n    ];\n\n    protected valueProcessors: KvSemanticProcessor[] = [\n        { regex: /.*/, processor: this.processValue }\n    ];\n\n    constructor() {\n        super(KvDocument.tokenLegend, vscode.languages.createDiagnosticCollection(\"vmt\"));\n    }\n\n    processKeyShader(params: KvSemanticProcessorParams): boolean {\n        params.tokensBuilder.push(params.wholeRange, \"parameter\");\n        return true;\n    }\n\n    processKeyCompile(params: KvSemanticProcessorParams): boolean {\n        params.tokensBuilder.push(params.wholeRange, \"parameter\", [\"readonly\"]);\n        return true;\n    }\n\n    processValue(params: KvSemanticProcessorParams): boolean {\n\n\n        if (!params.kvPiece.range.isSingleLine)\n            return false;\n\n\n        const kv = params.kvDocument.getKeyValueAt(params.kvPiece.range.start.line);\n        if (kv == null)\n            return false;\n        const param = shaderParams.find(p => p.name === kv.key.content);\n        if (param == null) {\n            this.processValueString(kv, params.wholeRange, params.tokensBuilder, params.kvDocument);\n            return false;\n        }\n        if (param.type == null || param.type == \"unknown\")\n            return false;\n\n\n        switch (param.type) {\n        case \"bool\": this.processValueBool(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"int\": this.processValueInt(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"float\": this.processValueFloat(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"scalar\": this.processValueScalar(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"texture\": this.processValueTexture(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"color\": this.processValueColor(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"matrix\": this.processValueMatrix(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        case \"env_cubemap\": this.processValueCubemap(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n\n        case \"string\":\n        default: this.processValueString(kv, params.wholeRange, params.tokensBuilder, params.kvDocument); break;\n        }\n        return true;\n    }\n\n    processValueBool(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (kv.value.content.match(/^[01]$/)) {\n            tokensBuilder.push(range, \"boolean\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a boolean (0 or 1).\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueInt(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (kv.value.content.match(/^\\d+$/)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting an integer.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueFloat(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (isFloatValue(kv.value.content)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a float.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueScalar(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        if (isScalarValue(kv.value.content)) {\n            tokensBuilder.push(range, \"number\");\n        } else {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Unexpected shader parameter value type. Expecting a scalar. (0-1)\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueString(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n        tokensBuilder.push(range, \"string\");\n    }\n\n    processValueTexture(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n        if (internalTextures.includes(kv.value.content)) {\n            tokensBuilder.push(range, \"keyword\");\n            return;\n        }\n        const validationEnabled = main.config.get<boolean>(\"vmt.validateTexturePaths\");\n        if(validationEnabled) {\n            const materialDir = getParentDocumentDirectory(kvDoc.document.uri.fsPath, \"materials\");\n            if (materialDir != null) {\n                const materialPath: string = path.join(materialDir, kv.value.content + \".vtf\");\n                if (!fs.existsSync(materialPath)) {\n                    this.diagnostics.push(new vscode.Diagnostic(range, \"Texture not found on disk\", vscode.DiagnosticSeverity.Warning));\n                }\n            }\n        }\n\n        tokensBuilder.push(range, \"string\");\n    }\n\n    processValueMatrix(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n\n        const matrixMatches = getMatrixMatches(kv.value.content);\n        if (!matrixMatches.validFormat) {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Invalid matrix format.\", vscode.DiagnosticSeverity.Warning));\n        }\n    }\n\n    processValueColor(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n\n        const colorMatches = getColorMatches(kv.value.content);\n        if (!colorMatches.validFormat) {\n            this.diagnostics.push(new vscode.Diagnostic(range, \"Invalid color value. Format: [0 0.25 1] or {0 200 49}\", vscode.DiagnosticSeverity.Warning));\n            return;\n        }\n        if (colorMatches.valuesOutOfBounds) {\n            if (colorMatches.parenthesisType === ColorMatchParenthesisType.Brackets) {\n                this.diagnostics.push(new vscode.Diagnostic(range, \"Color values out of bounds. Must be between 0 and 1\", vscode.DiagnosticSeverity.Warning));\n            } else if (colorMatches.parenthesisType === ColorMatchParenthesisType.Braces) {\n                this.diagnostics.push(new vscode.Diagnostic(range, \"Color values out of bounds. Must be between 0 and 255\", vscode.DiagnosticSeverity.Warning));\n            }\n        }\n    }\n\n    processValueCubemap(kv: KvPair, range: vscode.Range, tokensBuilder: vscode.SemanticTokensBuilder, kvDoc: KvDocument): void {\n\n        if (kv.value.content === \"env_cubemap\") {\n            tokensBuilder.push(range, \"keyword\");\n        } else {\n            tokensBuilder.push(range, \"string\");\n        }\n\n    }\n\n    protected override disallowDuplicate(scopedKey: string, depth: number, token: Token): boolean {\n        return depth === 1;\n    }\n}\n\n'Source-Engine-VSCode-Extension/src/main.ts'\n:\n\n\n\n\nimport * as vscode from \"vscode\";\nimport * as vmt from \"./language/LangVmt\";\nimport * as captions from \"./language/LangCaptions\";\nimport * as keyvalue from \"./language/LangKv\";\nimport * as captionsCompile from \"./compiler/captions-compile\";\nimport * as modelCompile from \"./compiler/model-compile\";\nimport * as performance from \"./performance\";\nimport * as kvDetect from \"./KvFileDetection\";\n\nimport * as packageJson from \"../package.json\";\n\nexport let output: vscode.OutputChannel;\nexport let debugOutput: vscode.OutputChannel;\nexport let config: vscode.WorkspaceConfiguration;\n\nexport function deactivate(): void {}\nexport function activate(context: vscode.ExtensionContext): void {\n\n    output = vscode.window.createOutputChannel(\"Source Engine Support\");\n    debugOutput = vscode.window.createOutputChannel(\"Source Engine Support Debug\");\n    context.subscriptions.push(output, debugOutput);\n\n    updateConfig();\n    const configChangeEvent = vscode.workspace.onDidChangeConfiguration(updateConfig);\n    context.subscriptions.push(configChangeEvent);\n\n    kvDetect.init(context);\n\n    keyvalue.init(context);\n    vmt.init(context);\n    captions.init(context);\n\n    captionsCompile.init(context);\n    modelCompile.init(context);\n\n    output.appendLine(`Started Source Engine Support v${packageJson.version}`);\n\n    performance.init(context);\n}\n\n\nconst updateConfig = () => config = vscode.workspace.getConfiguration(\"sourceEngine\");\n\n'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'\n:\n\n\n\n\nimport * as shared from \"./Shared\";\nimport vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\n\nimport { ShaderParamCompletionItemProvider } from \"./ShaderParamCompletionItemProvider\";\nimport { ShaderParamHoverProvider } from \"./ShaderParamHoverProvider\";\nimport { ShaderParamColorsProvider } from \"./ShaderParamColorsProvider\";\nimport { VmtSemanticTokenProvider } from \"./VmtSemanticTokenProvider\";\n\n\nexport const selectorAll: ReadonlyArray<vscode.DocumentFilter> = [shared.filterVmtSaved, shared.filterVmtUnsaved];\n\nexport function init(context: vscode.ExtensionContext): void {\n\n    const vmtSemantics = vscode.languages.registerDocumentSemanticTokensProvider(selectorAll, new VmtSemanticTokenProvider(), KvDocument.tokenLegend);\n    const vmtCompletion = vscode.languages.registerCompletionItemProvider(selectorAll, new ShaderParamCompletionItemProvider(), \"$\", \"%\");\n    const vmtHover = vscode.languages.registerHoverProvider(selectorAll, new ShaderParamHoverProvider());\n    const vmtColors = vscode.languages.registerColorProvider(selectorAll, new ShaderParamColorsProvider());\n\n\n    context.subscriptions.push(vmtSemantics, vmtCompletion, vmtHover, vmtColors);\n}\n\n\n'Source-Engine-VSCode-Extension/src/language/ShaderParamCompletionItemProvider.ts'\n:import vscode from \"vscode\";\nimport KvDocument from \"./KvDocument\";\nimport { shaderParams, internalTextures } from \"@sourcelib/vmt\";\nimport { KvPair } from \"../Kv\";\nimport { ShaderParam } from \"@sourcelib/vmt\";\nimport { getParentDocumentDirectory } from \"@sourcelib/fs\";\nimport { listFilesSync } from \"list-files-in-dir\";\nimport fs from \"fs\";\nimport path from \"path\";\n\n\nexport class ShaderParamCompletionItemProvider implements vscode.CompletionItemProvider {\n\n    public provideCompletionItems(document: vscode.TextDocument, position: vscode.Position, cancellationToken: vscode.CancellationToken): vscode.CompletionList {\n\n        const kvDoc = KvDocument.from(document);\n        if (kvDoc == null)\n            return new vscode.CompletionList();\n        const kv = kvDoc.getKeyValueAt(position.line);\n\n        if (kv == null)\n            return new vscode.CompletionList();\n\n\n        if (kv.key.range.contains(position)) {\n            const suggestions = shaderParams.filter(p => p.name.includes(kv.key.content));\n            const completions = suggestions.map(s => {\n                const completion = new vscode.CompletionItem(s.name);\n                completion.insertText = s.name.substring(1);\n                if (s.description != null) {\n                    completion.documentation = new vscode.MarkdownString(s.description);\n                }\n\n                if (s.defaultCompletion != null) {\n                    completion.insertText += \" \" + s.defaultCompletion.toString();\n                } else if (s.type === \"string\" || s.type === \"texture\") {\n                    completion.insertText = new vscode.SnippetString(completion.insertText + \" \\\"${1}\\\"\");\n                }\n\n                if (s.type === \"texture\") {\n                    completion.command = { command: \"editor.action.triggerSuggest\", title: \"Re-trigger completions\" };\n                }\n\n                return completion;\n            });\n\n            return new vscode.CompletionList(completions);\n        }\n\n\n        if (kv.value.range.contains(position)) {\n            const param = shaderParams.find(p => p.name == kv.key.content);\n\n            const completions = new vscode.CompletionList();\n\n            if (param == null)\n                return new vscode.CompletionList();\n\n\n            this.completeDefault(completions, document, kv, param);\n            this.completeTexturePath(completions, document, kv, param);\n\n\n            return completions;\n\n        }\n\n        return new vscode.CompletionList();\n\n    }\n\n    completeDefault(completions: vscode.CompletionList, document: vscode.TextDocument, kv: KvPair, param: ShaderParam): void {\n        if (param.defaultCompletion == null)\n            return;\n        const completion = new vscode.CompletionItem(param.defaultCompletion.toString());\n        completion.detail = \"Default Completion\";\n        completion.kind = vscode.CompletionItemKind.Value;\n        completions.items.push(completion);\n    }\n\n    completeTexturePath(completions: vscode.CompletionList, document: vscode.TextDocument, kv: KvPair, param: ShaderParam): void {\n        if (param.type !== \"texture\" && document.uri.scheme !== \"file\")\n            return;\n\n        internalTextures.forEach(rt => {\n            const completion = new vscode.CompletionItem(rt);\n            completion.detail = \"Internal engine texture\";\n            completion.kind = vscode.CompletionItemKind.Keyword;\n            completions.items.push(completion);\n        });\n\n        const materialRoot = getParentDocumentDirectory(document.uri.fsPath, \"materials\");\n        if (materialRoot == null)\n            return;\n\n\n        if (fs.existsSync(path.join(materialRoot, kv.value + \".vtf\"))) {\n            return;\n        }\n\n        let cursorStartDir: string;\n        if (kv.value.content.endsWith(\"\\\\\") || kv.value.content.endsWith(\"/\")) {\n            cursorStartDir = kv.value.content;\n        } else {\n            cursorStartDir = path.dirname(kv.value.content);\n        }\n        const startDir = path.join(materialRoot, cursorStartDir);\n\n        if (!fs.existsSync(startDir))\n            return;\n\n        const textureFiles = listFilesSync(startDir, \"vtf\");\n        textureFiles.forEach(t => {\n            let filePath = t.substring(startDir.length);\n            if (filePath.startsWith(\"\\\\\") || filePath.startsWith(\"/\")) {\n                filePath = filePath.slice(1);\n            }\n            const filePathWithoutExtension = filePath.substring(0, filePath.length - 4).replace(\"\\\\\", \"/\");\n\n            const completion = new vscode.CompletionItem(filePathWithoutExtension);\n            completion.insertText = filePathWithoutExtension;\n            completion.detail = \"Texture Path\";\n            completion.kind = vscode.CompletionItemKind.File;\n            completion.preselect = true;\n            completions.items.push(completion);\n        });\n\n    }\n}\n",
        "gt": [
            "'Source-Engine-VSCode-Extension/src/language/KvDocument.ts'",
            "'Source-Engine-VSCode-Extension/src/language/ShaderParamCompletionItemProvider.ts'",
            "'Source-Engine-VSCode-Extension/src/language/LangVmt.ts'",
            "'Source-Engine-VSCode-Extension/src/main.ts'",
            "'Source-Engine-VSCode-Extension/src/language/VmtSemanticTokenProvider.ts'"
        ]
    },
    {
        "files": [
            "'plantae/packages/plantae/src/ky/createKyHooks.ts'",
            "'plantae/packages/plantae/src/ky/createKyHooks.spec.ts'",
            "'plantae/packages/plantae/src/createMiddleware.ts'",
            "'plantae/packages/plantae/src/types.ts'"
        ],
        "content": "'plantae/packages/plantae/src/ky/createKyHooks.ts'\n:import type ky from \"ky\";\n\nimport createMiddleware from \"../createMiddleware\";\nimport type { Plugin } from \"../types\";\n\ntype KyHooks = NonNullable<Parameters<(typeof ky)[\"extend\"]>[0][\"hooks\"]>;\n\nconst createKyHooks = ({\n  client,\n  plugins,\n}: {\n  client: typeof ky;\n  plugins?: Plugin[];\n}): KyHooks => {\n  if (!plugins) {\n    return {};\n  }\n\n  const { requestMiddleware, responseMiddleware } = createMiddleware<\n    Request,\n    Response\n  >({\n    convertToAdapterRequest: (req) => req,\n    convertToAdapterResponse: (res) => res,\n    extendClientRequest: (_, req) => req as Request,\n    extendClientResponse: (_, res) => res as Response,\n    cloneClientRequest: (req) => req.clone(),\n    plugins,\n    retry: client,\n  });\n\n  return {\n    beforeRequest: [requestMiddleware],\n    afterResponse: [\n      async (req, _, res) => {\n        return responseMiddleware(res, req);\n      },\n    ],\n  };\n};\n\nexport default createKyHooks;\n\n'plantae/packages/plantae/src/ky/createKyHooks.spec.ts'\n:import Ky from \"ky\";\nimport { http } from \"msw\";\nimport { describe, expect, it } from \"vitest\";\n\nimport { base, baseURL, Status } from \"../test/utils\";\nimport { server } from \"../test/worker\";\nimport createKyHooks from \"./createKyHooks\";\n\ndescribe(\"createKyHooks\", () => {\n  it(\"can modify request body\", async () => {\n    server.use(\n      http.post(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(\n            (await request.text()) === \"modified\" ? Status.OK : Status.BAD\n          )\n      )\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-request-body\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                body: \"modified\",\n                method: \"POST\",\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.post(\"\");\n\n    expect(await res.text()).toBe(Status.OK);\n  });\n\n  it(\"can modify request headers\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(\n            request.headers.get(\"x-custom-header\") === \"modified\"\n              ? Status.OK\n              : Status.BAD\n          )\n      )\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-request-headers\",\n          hooks: {\n            beforeRequest: (req) => {\n              req.headers.set(\"x-custom-header\", \"modified\");\n              return req;\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\");\n\n    expect(await res.text()).toBe(Status.OK);\n  });\n\n  it(\"can modify existing request header\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(\n            request.headers.get(\"x-custom-header\") === \"modified\"\n              ? Status.OK\n              : Status.BAD\n          )\n      )\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-request-headers\",\n          hooks: {\n            beforeRequest: (req) => {\n              req.headers.set(\"x-custom-header\", \"modified\");\n              return req;\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\", {\n      headers: {\n        \"x-custom-header\": \"original\",\n      },\n    });\n\n    expect(await res.text()).toBe(Status.OK);\n  });\n\n  it(\"can modify request method\", async () => {\n    server.use(http.post(base(\"/\"), () => new Response(Status.OK)));\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-request-method\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                method: \"POST\",\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\");\n\n    expect(await res.text()).toBe(Status.OK);\n  });\n\n  it(\"can modify request url\", async () => {\n    server.use(http.get(base(\"/modified\"), () => new Response(Status.OK)));\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-request-url\",\n          hooks: {\n            beforeRequest: () => {\n              return new Request(base(\"/modified\"));\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\");\n\n    expect(await res.text()).toBe(Status.OK);\n  });\n\n  it(\"can add request signal\", async () => {\n    server.use(\n      http.get(base(\"/delay\"), async () => {\n        await new Promise((resolve) => setTimeout(resolve, 5000));\n\n        return new Response();\n      })\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-add-request-signal\",\n          hooks: {\n            beforeRequest: () => {\n              const abortController = new AbortController();\n\n              setTimeout(() => {\n                abortController.abort();\n              }, 100);\n\n              return new Request(base(\"/delay\"), {\n                signal: abortController.signal,\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    await expect(ky.get(\"\")).rejects.toThrow();\n  });\n\n  it(\"can modify request credentials\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(request.credentials === \"omit\" ? Status.OK : Status.BAD)\n      )\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-request-credentials\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                credentials: \"omit\",\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\", {\n      credentials: \"include\",\n    });\n\n    expect(await res.text()).toBe(Status.OK);\n  });\n\n  it(\"can modify request cache\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(request.cache === \"no-cache\" ? Status.OK : Status.BAD)\n      )\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-request-cache\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                cache: \"no-cache\",\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\", {\n      cache: \"force-cache\",\n    });\n\n    expect(await res.text()).toBe(Status.OK);\n  });\n\n  it(\"can modify response body\", async () => {\n    server.use(http.post(base(\"/\"), () => new Response()));\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-response-body\",\n          hooks: {\n            afterResponse: (res) => new Response(\"modified\", res),\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.post(\"\");\n\n    expect(await res.text()).toBe(\"modified\");\n  });\n\n  it(\"can modify response headers\", async () => {\n    server.use(http.get(base(\"/\"), () => new Response()));\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-response-headers\",\n          hooks: {\n            afterResponse: (res) => {\n              const headers = new Headers(res.headers);\n\n              headers.set(\"x-custom-header\", \"modified\");\n\n              return new Response(res.body, {\n                headers,\n                status: res.status,\n                statusText: res.statusText,\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\");\n\n    expect(res.headers.get(\"x-custom-header\")).toBe(\"modified\");\n  });\n\n  it(\"can modify existing response header\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        () =>\n          new Response(undefined, {\n            headers: {\n              \"x-custom-header\": \"original\",\n            },\n          })\n      )\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-response-headers\",\n          hooks: {\n            afterResponse: (res) => {\n              const headers = new Headers(res.headers);\n\n              headers.set(\"x-custom-header\", \"modified\");\n\n              return new Response(res.body, {\n                headers,\n                status: res.status,\n                statusText: res.statusText,\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\");\n\n    expect(res.headers.get(\"x-custom-header\")).toBe(\"modified\");\n  });\n\n  it(\"can modify response status\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async () =>\n          new Response(null, {\n            status: 201,\n          })\n      )\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-response-status\",\n          hooks: {\n            afterResponse: (res) =>\n              new Response(res.body, {\n                headers: res.headers,\n                statusText: res.statusText,\n                status: 201,\n              }),\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\");\n\n    expect(res.status).toBe(201);\n  });\n\n  it(\"can modify response status text\", async () => {\n    server.use(http.get(base(\"/\"), async () => new Response()));\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-modify-status-text\",\n          hooks: {\n            afterResponse: (res) =>\n              new Response(res.body, {\n                headers: res.headers,\n                status: res.status,\n                statusText: \"modified\",\n              }),\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"\");\n\n    expect(res.statusText).toBe(\"modified\");\n  });\n\n  it(\"can retry request\", async () => {\n    server.use(\n      http.get(base(\"/error\"), async () => {\n        return new Response(null, {\n          status: 500,\n        });\n      }),\n      http.get(base(\"/retry\"), () => new Response(\"retried\"))\n    );\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-retry-request\",\n          hooks: {\n            afterResponse: async (res, req, retry) => {\n              if (!res.ok) {\n                const newReq = new Request(base(\"/retry\"), req);\n\n                return retry(newReq);\n              }\n              return res;\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    const res = await ky.get(\"error\");\n\n    expect(await res.text()).toBe(\"retried\");\n  });\n\n  it(\"should pass unused request to afterResponse hook\", async () => {\n    server.use(http.post(base(\"/\"), () => new Response()));\n\n    const hooks = createKyHooks({\n      client: Ky,\n      plugins: [\n        {\n          name: \"plugin-clone-request\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                method: \"POST\",\n                body: \"modified\",\n              });\n            },\n            afterResponse: (_, req, retry) => {\n              expect(req.bodyUsed).toBe(false);\n\n              return retry(req);\n            },\n          },\n        },\n      ],\n    });\n\n    const ky = Ky.create({\n      prefixUrl: baseURL,\n      hooks,\n    });\n\n    await ky.get(\"\");\n\n    expect.assertions(1);\n  });\n});\n\n'plantae/packages/plantae/src/createMiddleware.ts'\n:import type { AdapterRequest, AdapterResponse, Plugin } from \"./types\";\n\ntype ConvertToAdapterRequest<T> = (request: T) => AdapterRequest;\ntype ExtendClientRequest<T> = (\n  clientRequest: T,\n  adapterRequest: AdapterRequest\n) => T | Promise<T>;\n\ntype ConvertToAdapterResponse<T> = (response: T) => AdapterResponse;\ntype ExtendClientResponse<T> = (\n  clientResponse: T,\n  adapterResponse: AdapterResponse\n) => T | Promise<T>;\n\ntype Retryer<T, U> = (clientRequest: T) => Promise<U>;\n\n\nexport function createRequestMiddleware<T>({\n  plugins,\n  convertToAdapterRequest,\n  extendClientRequest,\n}: {\n  plugins: Plugin[];\n  convertToAdapterRequest: ConvertToAdapterRequest<T>;\n  extendClientRequest: ExtendClientRequest<T>;\n}) {\n  return async (clientRequest: T) => {\n    let adapterRequest = convertToAdapterRequest(clientRequest);\n\n    for (const plugin of plugins) {\n      if (plugin.hooks?.beforeRequest) {\n        adapterRequest = await plugin.hooks.beforeRequest(adapterRequest);\n      }\n    }\n\n    return extendClientRequest(clientRequest, adapterRequest);\n  };\n}\n\n\nexport function createResponseMiddleware<T, U>({\n  plugins,\n  convertToAdapterRequest,\n  extendClientRequest,\n  convertToAdapterResponse,\n  extendClientResponse,\n  cloneClientRequest,\n  retry,\n}: {\n  plugins: Plugin[];\n  convertToAdapterRequest: ConvertToAdapterRequest<T>;\n  extendClientRequest: ExtendClientRequest<T>;\n  convertToAdapterResponse: ConvertToAdapterResponse<U>;\n  extendClientResponse: ExtendClientResponse<U>;\n  cloneClientRequest?: (req: T) => T;\n  retry: Retryer<T, U>;\n}) {\n  return async (clientResponse: U, clientRequest: T) => {\n    let adapterResponse: AdapterResponse =\n      convertToAdapterResponse(clientResponse);\n\n    for (const plugin of plugins) {\n      if (plugin.hooks?.afterResponse) {\n        adapterResponse = await plugin.hooks.afterResponse(\n          adapterResponse,\n          convertToAdapterRequest(clientRequest),\n\n          async (adapterRequest) => {\n            const extendedClientRequest = await extendClientRequest(\n              clientRequest,\n              adapterRequest\n            );\n            const clonedClientRequest = cloneClientRequest\n              ? cloneClientRequest(extendedClientRequest)\n              : extendedClientRequest;\n\n            clientResponse = await retry(extendedClientRequest);\n\n            clientRequest = clonedClientRequest;\n\n            return convertToAdapterResponse(clientResponse);\n          }\n        );\n      }\n    }\n\n    return extendClientResponse(clientResponse, adapterResponse);\n  };\n}\n\nexport default function createMiddleware<Req, Res>({\n  convertToAdapterRequest,\n  extendClientRequest,\n  convertToAdapterResponse,\n  extendClientResponse,\n  cloneClientRequest,\n  plugins,\n  retry,\n}: {\n  plugins: Plugin[];\n  convertToAdapterRequest: ConvertToAdapterRequest<Req>;\n  extendClientRequest: ExtendClientRequest<Req>;\n  convertToAdapterResponse: ConvertToAdapterResponse<Res>;\n  extendClientResponse: ExtendClientResponse<Res>;\n  cloneClientRequest?: (req: Req) => Req;\n  retry: Retryer<Req, Res>;\n}) {\n  return {\n    requestMiddleware: createRequestMiddleware({\n      plugins,\n      convertToAdapterRequest,\n      extendClientRequest,\n    }),\n    responseMiddleware: createResponseMiddleware({\n      plugins,\n      convertToAdapterRequest,\n      extendClientRequest,\n      convertToAdapterResponse,\n      extendClientResponse,\n      cloneClientRequest,\n      retry,\n    }),\n  };\n}\n\n'plantae/packages/plantae/src/types.ts'\n:export type Plugin<Context = {}> = {\n  name: string;\n  hooks?: {\n    beforeRequest?: (\n      request: AdapterRequest\n    ) => Promise<AdapterRequest> | AdapterRequest;\n    afterResponse?: (\n      response: AdapterResponse,\n      request: AdapterRequest,\n      retry: (request: AdapterRequest) => Promise<AdapterResponse>\n    ) => Promise<AdapterResponse> | AdapterResponse;\n  };\n  context?: Context;\n};\n\nexport type AdapterRequest = Request;\n\nexport type AdapterResponse = Response;\n",
        "gt": [
            "'plantae/packages/plantae/src/types.ts'",
            "'plantae/packages/plantae/src/createMiddleware.ts'",
            "'plantae/packages/plantae/src/ky/createKyHooks.ts'",
            "'plantae/packages/plantae/src/ky/createKyHooks.spec.ts'"
        ]
    },
    {
        "files": [
            "'react-3d-editor/src/components/common/Markers.tsx'",
            "'react-3d-editor/src/components/common/ColorPicker.tsx'",
            "'react-3d-editor/src/components/common/CreateMarkerForm.tsx'",
            "'react-3d-editor/src/components/common/MarkerPicker.tsx'",
            "'react-3d-editor/src/components/common/CreateMarker.tsx'"
        ],
        "content": "'react-3d-editor/src/components/common/Markers.tsx'\n:import React, { Component } from 'react';\nimport { Spin, Input, Button, Row, Col, Card } from 'antd';\nimport Icon from 'polestar-icons';\nimport warning from 'warning';\n\nimport Scrollbar from './Scrollbar';\nimport AddEmpty from './AddEmpty';\nimport CreateMarker from './CreateMarker';\nimport { MarkerDatabase } from '../../database';\nimport { UtilTools } from '../../tools';\n\nexport interface IMarker {\n\tid?: string;\n\tname?: string;\n\ttitle?: string;\n\tthumbnail: string;\n\tpattern: Blob;\n\tpatternRatio: number;\n\timageSize: number;\n\tborderColor: string;\n}\n\nexport interface MarkersProps {\n\tonClick?: (value?: IMarker) => void;\n\tvisible?: boolean;\n}\n\ninterface IState {\n\tmarkers: IMarker[];\n\tsearchMarker: string;\n\tloading: boolean;\n\tadding: boolean;\n}\n\nclass Markers extends Component<MarkersProps, IState> {\n\tstate: IState = {\n\t\tmarkers: [],\n\t\tsearchMarker: '',\n\t\tloading: false,\n\t\tadding: false,\n\t};\n\n\tcomponentDidMount() {\n\t\tthis.getMarkers();\n\t}\n\n\tcomponentDidUpdate(prevProps: MarkersProps) {\n\t\tif (this.props.visible && this.props.visible !== prevProps.visible) {\n\t\t\tthis.getMarkers();\n\t\t}\n\t}\n\n\n\tprivate getMarkers = () => {\n\t\tthis.setState({\n\t\t\tloading: true,\n\t\t});\n\t\tMarkerDatabase.allDocs()\n\t\t\t.then(response => {\n\t\t\t\tconst markers = response.rows.map(row => {\n\t\t\t\t\tconst { doc } = row;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: doc._id,\n\t\t\t\t\t\tname: doc.name,\n\t\t\t\t\t\ttitle: doc.title,\n\t\t\t\t\t\tthumbnail: doc.thumbnail,\n\t\t\t\t\t\tpattern: doc._attachments.pattern.data,\n\t\t\t\t\t\tpatternRatio: doc.patternRatio,\n\t\t\t\t\t\timageSize: doc.imageSize,\n\t\t\t\t\t\tborderColor: doc.borderColor,\n\t\t\t\t\t} as IMarker;\n\t\t\t\t});\n\t\t\t\tthis.setState({\n\t\t\t\t\tmarkers,\n\t\t\t\t\tloading: false,\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\twarning(true, error);\n\t\t\t\tthis.setState({\n\t\t\t\t\tloading: false,\n\t\t\t\t});\n\t\t\t});\n\t};\n\n\n\tprivate handleAddMarkerVisible = () => {\n\t\tthis.setState(prevState => {\n\t\t\treturn {\n\t\t\t\tadding: !prevState.adding,\n\t\t\t};\n\t\t});\n\t};\n\n\n\tprivate handleSearchMarker = (searchMarker: string) => {\n\t\tthis.setState({\n\t\t\tsearchMarker,\n\t\t});\n\t};\n\n\n\tprivate handleSelectMarker = (marker: IMarker) => {\n\t\tconst { onClick } = this.props;\n\t\tif (onClick) {\n\t\t\tonClick(marker);\n\t\t}\n\t};\n\n\n\tprivate handleAppendMarker = async (marker: IMarker) => {\n\t\tthis.setState({\n\t\t\tloading: true,\n\t\t});\n\t\ttry {\n\t\t\tawait MarkerDatabase.save({\n\t\t\t\t_id: marker.id,\n\t\t\t\tname: marker.name,\n\t\t\t\ttitle: marker.title,\n\t\t\t\t_attachments: {\n\t\t\t\t\tpattern: {\n\t\t\t\t\t\tcontent_type: marker.pattern.type,\n\t\t\t\t\t\tdata: marker.pattern,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tpatternRatio: marker.patternRatio,\n\t\t\t\timageSize: marker.imageSize,\n\t\t\t\tthumbnail: marker.thumbnail,\n\t\t\t\tborderColor: marker.borderColor,\n\t\t\t});\n\t\t\tthis.getMarkers();\n\t\t} catch (error) {\n\t\t\tthis.setState({\n\t\t\t\tloading: false,\n\t\t\t});\n\t\t\tconsole.error(error.toString());\n\t\t}\n\t};\n\n\n\tprivate renderCardActions = (marker: IMarker) => {\n\t\treturn [\n\t\t\t<Icon\n\t\t\t\tkey=\"download\"\n\t\t\t\tname=\"download\"\n\t\t\t\tonClick={e => {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tUtilTools.saveBlob(marker.pattern, marker.name);\n\t\t\t\t}}\n\t\t\t/>,\n\t\t\t<Icon\n\t\t\t\tkey=\"image\"\n\t\t\t\tname=\"image\"\n\t\t\t\tonClick={e => {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tUtilTools.saveBlob(UtilTools.dataURLToBlob(marker.thumbnail), `${marker.title}.png`);\n\t\t\t\t}}\n\t\t\t/>,\n\t\t\t<Icon\n\t\t\t\tkey=\"delete\"\n\t\t\t\tname=\"trash\"\n\t\t\t\tonClick={e => {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tMarkerDatabase.delete(marker.id).then(() => {\n\t\t\t\t\t\tthis.getMarkers();\n\t\t\t\t\t});\n\t\t\t\t}}\n\t\t\t/>,\n\t\t];\n\t};\n\n\n\tprivate renderCardItems = (markers: IMarker[], searchMarker: string) => {\n\t\treturn (\n\t\t\t<Scrollbar>\n\t\t\t\t<Row gutter={16} style={{ margin: 0 }}>\n\t\t\t\t\t{markers\n\t\t\t\t\t\t.filter(marker => marker.name.includes(searchMarker.toLowerCase()))\n\t\t\t\t\t\t.map(marker => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Col\n\t\t\t\t\t\t\t\t\tkey={marker.id}\n\t\t\t\t\t\t\t\t\tmd={24}\n\t\t\t\t\t\t\t\t\tlg={12}\n\t\t\t\t\t\t\t\t\txl={6}\n\t\t\t\t\t\t\t\t\tonClick={() => this.handleSelectMarker(marker)}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<Card\n\t\t\t\t\t\t\t\t\t\thoverable={true}\n\n\n\t\t\t\t\t\t\t\t\t\tcover={<img src={marker.thumbnail} />}\n\t\t\t\t\t\t\t\t\t\tactions={this.renderCardActions(marker)}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Card.Meta title={marker.name} />\n\t\t\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t\t\t</Col>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t</Row>\n\t\t\t</Scrollbar>\n\t\t);\n\t};\n\n\n\tprivate renderSearch = () => {\n\t\treturn (\n\t\t\t<div style={{ flex: 1, padding: '0 16px 0 0' }}>\n\t\t\t\t<Input\n\t\t\t\t\tallowClear={true}\n\t\t\t\t\tplaceholder=\"Search for Marker...\"\n\t\t\t\t\tonChange={e => this.handleSearchMarker(e.target.value)}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t};\n\n\n\tprivate renderActions = () => {\n\t\treturn (\n\t\t\t<Button type=\"primary\" onClick={this.handleAddMarkerVisible}>\n\t\t\t\t<Icon name=\"plus\" />\n\t\t\t</Button>\n\t\t);\n\t};\n\n\trender() {\n\t\tconst { loading, markers, searchMarker, adding } = this.state;\n\t\treturn (\n\t\t\t<Spin spinning={loading}>\n\t\t\t\t<div style={{ display: 'flex', height: '100%' }}>\n\t\t\t\t\t{markers.length ? (\n\t\t\t\t\t\t<div style={{ display: 'flex', height: '100%', flexDirection: 'column', flex: 1 }}>\n\t\t\t\t\t\t\t<div style={{ display: 'flex', padding: '0 8px 16px 8px' }}>\n\t\t\t\t\t\t\t\t{this.renderSearch()}\n\t\t\t\t\t\t\t\t{this.renderActions()}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div style={{ flex: 1 }}>{this.renderCardItems(markers, searchMarker)}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<AddEmpty onClick={this.handleAddMarkerVisible}>\n\t\t\t\t\t\t\t<Icon name=\"plus\" style={{ marginRight: 4 }} />\n\t\t\t\t\t\t\t{'New Marker'}\n\t\t\t\t\t\t</AddEmpty>\n\t\t\t\t\t)}\n\t\t\t\t\t<CreateMarker\n\t\t\t\t\t\tvisible={adding}\n\t\t\t\t\t\tonSave={this.handleAppendMarker}\n\t\t\t\t\t\tonCancel={this.handleAddMarkerVisible}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</Spin>\n\t\t);\n\t}\n}\n\nexport default Markers;\n\n'react-3d-editor/src/components/common/ColorPicker.tsx'\n:import React, { Component } from 'react';\nimport { Popover, Button } from 'antd';\nimport { SketchPicker, Color } from 'react-color';\n\ninterface IProps {\n    onChange?: (color: Color) => void;\n    value?: any;\n    disabled?: boolean;\n}\n\nclass ColorPicker extends Component<IProps> {\n    handlers = {\n        onChange: (color: any) => {\n            const { onChange } = this.props;\n            this.setState({\n                color: `rgba(${color.rgb.r},${color.rgb.g},${color.rgb.b},${color.rgb.a})`,\n            }, () => {\n                onChange(`rgba(${color.rgb.r},${color.rgb.g},${color.rgb.b},${color.rgb.a})`);\n            });\n        },\n    }\n\n    state = {\n        color: this.props.value || 'rgba(255, 255, 255, 1)',\n    }\n\n    UNSAFE_componentWillReceiveProps(nextProps: IProps) {\n        this.setState({\n            color: nextProps.value || this.state.color,\n        });\n    }\n\n    render() {\n        const { color } = this.state;\n        const { onChange } = this.handlers;\n        return (\n            <Popover\n                trigger=\"click\"\n                placement=\"bottom\"\n                style={{ zIndex: 9999 }}\n                overlayStyle={{ zIndex: 9999 }}\n                content={<SketchPicker disableAlpha={true} color={color} onChange={onChange} />}\n            >\n                <div style={{ display: 'flex', flex: 1, alignItems: 'center', cursor: 'pointer' }}>\n                    <Button style={{ background: color }} shape=\"circle\" />\n                    <span style={{ marginLeft: 16 }}>{color}</span>\n                </div>\n            </Popover>\n        );\n    }\n}\n\nexport default ColorPicker;\n\n'react-3d-editor/src/components/common/CreateMarkerForm.tsx'\n:import React, { Component } from 'react';\nimport { Form, Slider, Input } from 'antd';\nimport { FormComponentProps } from 'antd/lib/form';\nimport ColorPicker from './ColorPicker';\n\ninterface IProps extends FormComponentProps {\n    onChange?: (values: any) => void;\n}\n\nclass CreateMarkerForm extends Component<IProps> {\n    render() {\n        const { form } = this.props;\n        return (\n            <Form colon={false}>\n                <Form.Item label={'Name'}>\n                    {\n                        form.getFieldDecorator('name', {\n                            initialValue: 'pattern-marker',\n                        })(<Input />)\n                    }\n                </Form.Item>\n                <Form.Item label={'Pattern Ratio'}>\n                    {\n                        form.getFieldDecorator('patternRatio', {\n                            initialValue: 0.75,\n                        })(<Slider disabled={true} step={0.01} min={0.10} max={0.90} />)\n                    }\n                </Form.Item>\n                <Form.Item label={'Image Size'}>\n                    {\n                        form.getFieldDecorator('imageSize', {\n                            initialValue: 512,\n                        })(<Slider disabled={true} min={150} max={2500} />)\n                    }\n                </Form.Item>\n                <Form.Item label={'Border Color'}>\n                    {\n                        form.getFieldDecorator('borderColor', {\n                            initialValue: '#000',\n                        })(<ColorPicker disabled={true} />)\n                    }\n                </Form.Item>\n            </Form>\n        );\n    }\n}\n\nexport default Form.create<IProps>({\n    onValuesChange: (props: IProps, changedValues, allValues) => {\n        const { onChange } = props;\n        if (onChange) {\n            onChange(allValues);\n        }\n    },\n})(CreateMarkerForm);\n\n'react-3d-editor/src/components/common/MarkerPicker.tsx'\n:import React, { Component } from 'react';\nimport { Modal, Icon } from 'antd';\nimport { Entity } from 'aframe';\nimport debounce from 'lodash/debounce';\nimport { DataSourceItemType } from 'antd/lib/auto-complete';\nimport { FormComponentProps } from 'antd/lib/form';\n\nimport AutoComplete from './AutoComplete';\nimport Markers, { IMarker } from './Markers';\nimport { AssetTools, EventTools } from '../../tools';\n\ninterface IProps extends FormComponentProps {\n\tschema: any;\n\tentity?: Entity;\n\tdata?: any;\n\tcomponentName?: string;\n\tschemaKey?: string;\n\tonChange?: (value?: any) => void;\n\tprefixUrl?: boolean;\n\tbaseUrl?: boolean;\n}\n\ninterface IState {\n\tvisible: boolean;\n\tvalue: string;\n\tassets: DataSourceItemType[];\n}\n\nclass MarkerPicker extends Component<IProps, IState> {\n\tstate: IState = {\n\t\tvalue: this.props.data,\n\t\tvisible: false,\n\t\tassets: [],\n\t};\n\n\tcomponentDidMount() {\n\t\tthis.setAssets();\n\t\tEventTools.on('assetcreate', () => {\n\t\t\tthis.setAssets();\n\t\t});\n\t\tEventTools.on('assetremove', () => {\n\t\t\tthis.setAssets();\n\t\t});\n\t}\n\n\tUNSAFE_componentWillReceiveProps(nextProps: IProps) {\n\t\tif (nextProps.entity.id !== this.props.entity.id) {\n\t\t\tthis.setState({\n\t\t\t\tvalue: nextProps.data,\n\t\t\t});\n\t\t}\n\t}\n\n\n\tprivate setAssets = (): void => {\n\t\tconst { schemaKey, componentName } = this.props;\n\t\tthis.setState({\n\t\t\tassets: AssetTools.buildAssets(AFRAME.INSPECTOR.sceneEl, ['a-mixin', 'img', 'video', 'audio'])\n\t\t\t\t.filter(asset => {\n\t\t\t\t\tif (asset.type === 'a-asset-item' && schemaKey === 'patternUrl') {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t})\n\t\t\t\t.map(asset => {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: asset.key.toString(),\n\t\t\t\t\t\ttext: asset.title.toString(),\n\t\t\t\t\t};\n\t\t\t\t}),\n\t\t});\n\t};\n\n\n\tprivate handleClickMarker = (marker: IMarker) => {\n\t\tconst { onChange } = this.props;\n\t\tif (onChange) {\n\t\t\tconst value = window.URL.createObjectURL(marker.pattern);\n\t\t\tthis.setState({\n\t\t\t\tvalue,\n\t\t\t\tvisible: false,\n\t\t\t});\n\t\t\tonChange(value);\n\t\t}\n\t};\n\n\n\tprivate handleModalVisible = () => {\n\t\tthis.setState((prevState: IState) => {\n\t\t\treturn {\n\t\t\t\tvisible: !prevState.visible,\n\t\t\t};\n\t\t});\n\t};\n\n\n\tprivate debouncedChangeSrc = debounce((value: any) => {\n\t\tconst { onChange } = this.props;\n\t\tif (onChange) {\n\t\t\tonChange(value);\n\t\t}\n\t}, 200);\n\n\n\tprivate handleSelectSrc = (value: any) => {\n\t\tconst assetItem = document.getElementById(value);\n\t\tif (assetItem) {\n\t\t\tconst src = assetItem.getAttribute('src');\n\t\t\tthis.setState({\n\t\t\t\tvalue: src,\n\t\t\t});\n\t\t\tthis.debouncedChangeSrc(src);\n\t\t}\n\t};\n\n\n\tprivate handleChangeSrc = (value: any) => {\n\t\tthis.debouncedChangeSrc(value);\n\t\tthis.setState({\n\t\t\tvalue,\n\t\t});\n\t};\n\n\trender() {\n\t\tconst { entity, schemaKey, componentName } = this.props;\n\t\tconst { visible, value, assets } = this.state;\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<AutoComplete\n\t\t\t\t\tonChange={this.handleChangeSrc}\n\t\t\t\t\tonSelect={this.handleSelectSrc}\n\t\t\t\t\tvalue={value.length > 100 ? value.substring(0, 100).concat('...') : value}\n\t\t\t\t\tdataSource={(entity.object3D || entity.tagName.toLowerCase() === 'a-asset-item') && assets}\n\t\t\t\t\tfilterOption={(inputValue, option: any) =>\n\t\t\t\t\t\toption.props.children.toUpperCase().indexOf(inputValue.toUpperCase()) !== -1\n\t\t\t\t\t}\n\t\t\t\t\taddonAfter={<Icon type=\"shop\" onClick={this.handleModalVisible} />}\n\t\t\t\t/>\n\t\t\t\t<Modal\n\t\t\t\t\tclassName=\"editor-item-modal\"\n\t\t\t\t\tvisible={visible}\n\t\t\t\t\tonCancel={this.handleModalVisible}\n\t\t\t\t\tfooter={null}\n\t\t\t\t\ttitle={'Markers'}\n\t\t\t\t\twidth=\"75%\"\n\t\t\t\t\tstyle={{ height: '75%' }}\n\t\t\t\t>\n\t\t\t\t\t<Markers onClick={this.handleClickMarker} />\n\t\t\t\t</Modal>\n\t\t\t</>\n\t\t);\n\t}\n}\n\nexport default MarkerPicker;\n\n'react-3d-editor/src/components/common/CreateMarker.tsx'\n:import React, { Component } from 'react';\nimport { Icon, Button, Radio } from 'antd';\nimport uuid from 'uuid';\nimport QRCode from 'qrcode';\nimport debounce from 'lodash/debounce';\nimport warning from 'warning';\n\nimport AutoComplete from './AutoComplete';\nimport CreateMarkerForm from './CreateMarkerForm';\nimport ARPatternFile from '../../lib/ARPatternFile';\nimport InputScript from './InputScript';\n\nexport interface CreateMarkerProps {\n    onSave?: (marker: any) => void;\n    onCancel?: () => void;\n    visible?: boolean;\n}\n\ninterface IState {\n    imageURL: string;\n    innerImageURL: string;\n    markerType: string;\n}\n\nclass CreateMarker extends Component<CreateMarkerProps, IState> {\n    formRef: any;\n\n    state: IState = {\n        imageURL: '',\n        innerImageURL: '',\n        markerType: 'image',\n    }\n\n    private debouncedChangeImageURL = debounce((value: string) => {\n        const { form } = this.formRef.props;\n        form.validateFields((err: any, values: any) => {\n            if (err) {\n                return;\n            }\n            this.handleChangeForm(values);\n        });\n    }, 200)\n\n\n    private handleClear = () => {\n        const { form } = this.formRef.props;\n        form.resetFields();\n        this.setState({\n            imageURL: '',\n            innerImageURL: '',\n        });\n    }\n\n\n    private handleChooseImage = () => {\n        const input = document.createElement('input');\n        input.setAttribute('type', 'file');\n        input.setAttribute('accept', 'image\n    private handleChangeImageURL = (innerImageURL: any) => {\n        const { markerType } = this.state;\n        if (markerType === 'qrcode') {\n            QRCode.toDataURL(innerImageURL, { margin: 0, width: 512 }).then(url => {\n                this.setState({\n                    innerImageURL: url,\n                });\n                this.debouncedChangeImageURL(url);\n            }).catch(error => {\n                warning(true, error);\n            });\n        } else {\n            this.debouncedChangeImageURL(innerImageURL);\n            this.setState({\n                innerImageURL,\n            });\n        }\n    }\n\n\n    private handleSave = () => {\n        const { form } = this.formRef.props;\n        const { onSave } = this.props;\n        form.validateFields((err: any, values: any) => {\n            if (err) {\n                return;\n            }\n            const { innerImageURL, imageURL } = this.state;\n            if (!innerImageURL.length) {\n                return;\n            }\n            if (onSave) {\n                ARPatternFile.encodeImageURL(innerImageURL, patternFileString => {\n                    onSave({\n                        ...values,\n                        id: uuid(),\n                        name: `${values.name}.patt`,\n                        title: values.name,\n                        thumbnail: imageURL,\n                        pattern: new Blob([patternFileString], { type: 'text/plain' }),\n                    });\n                });\n            }\n        });\n    }\n\n\n    private handleChangeForm = (values: any) => {\n        const { innerImageURL } = this.state;\n        const { patternRatio, imageSize, borderColor } = values;\n        ARPatternFile.buildFullMarker(innerImageURL, patternRatio, imageSize, borderColor, (imageURL: string) => {\n            this.setState({\n                imageURL,\n            });\n        });\n    }\n\n    render() {\n        const { onCancel, visible } = this.props;\n        const { imageURL, markerType } = this.state;\n        return (\n            <div style={{ overflowX: 'hidden', width: visible ? 360 : 0, transition: 'width 0.3s', borderLeft: visible ? '1px solid rgba(0, 0, 0, 0.1)' : 0 }}>\n                <div className=\"editor-picker\">\n                    <div className=\"editor-picker-form\">\n                        <Radio.Group onChange={e => { this.setState({ markerType: e.target.value }); }} value={markerType} style={{ marginBottom: 8 }}>\n                            <Radio.Button style={{ width: '50%', textAlign: 'center' }} value=\"image\">{'Image'}</Radio.Button>\n                            <Radio.Button style={{ width: '50%', textAlign: 'center' }} value=\"qrcode\">{'QR Code'}</Radio.Button>\n                        </Radio.Group>\n                        {\n                            markerType === 'image' ? (\n                                <AutoComplete\n                                    onChange={this.handleChangeImageURL}\n                                    value={imageURL.length > 100 ? imageURL.substring(0, 100).concat('...') : imageURL}\n                                    addonAfter={<Icon type=\"shop\" onClick={this.handleChooseImage} />}\n                                />\n                            ) : (\n                                <InputScript onChange={value => { this.handleChangeImageURL(value); }} />\n                            )\n                        }\n                    </div>\n                    <div className=\"editor-picker-preview\">\n                        <div className=\"editor-picker-container\">\n                            <img src={imageURL} alt=\"\" />\n                        </div>\n                    </div>\n                    <div className=\"editor-picker-actions\">\n                        <CreateMarkerForm wrappedComponentRef={(form: any) => this.formRef = form} onChange={this.handleChangeForm} />\n                        <div style={{ display: 'flex', justifyContent: 'center' }}>\n                            <Button style={{ marginRight: 8 }} onClick={this.handleClear}>{'Clear'}</Button>\n                            <Button style={{ marginRight: 8 }} onClick={onCancel}>{'Cancel'}</Button>\n                            <Button style={{ marginLeft: 8 }} type=\"primary\" onClick={this.handleSave}>{'Save'}</Button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default CreateMarker;\n",
        "gt": [
            "'react-3d-editor/src/components/common/ColorPicker.tsx'",
            "'react-3d-editor/src/components/common/CreateMarkerForm.tsx'",
            "'react-3d-editor/src/components/common/CreateMarker.tsx'",
            "'react-3d-editor/src/components/common/Markers.tsx'",
            "'react-3d-editor/src/components/common/MarkerPicker.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.interface.ts'\n:import { AgeCategory, Discipline, Gender, RankingType, Year } from 'shared/enums';\nimport { DDBTableKeyAttrs } from '../../interfaces/table.interface';\n\ntype KeyAttrs = DDBTableKeyAttrs;\n\ninterface Attrs {\n  readonly name: string;\n  readonly birthdate: string;\n  readonly surname: string;\n  readonly country: string;\n  readonly normalizedName: string;\n  readonly lastUpdatedAt?: number;\n}\n\ninterface NonKeyAttrs extends Attrs {}\nexport type AllAttrs = KeyAttrs & NonKeyAttrs;\n\nexport interface DDBAthleteRankingsItem extends Attrs {\n  readonly athleteId: string;\n  readonly rankingType: RankingType;\n  readonly discipline: Discipline;\n  readonly ageCategory: AgeCategory;\n  readonly gender: Gender;\n  readonly year: number;\n  readonly points: number;\n}\n\nexport interface DDBRankingsItemPrimaryKey {\n  readonly rankingType: RankingType;\n  readonly discipline: Discipline;\n  readonly ageCategory: AgeCategory;\n  readonly gender: Gender;\n  readonly year: Year;\n}\n\nexport interface DDBAthleteRankingsItemPrimaryKey extends DDBRankingsItemPrimaryKey {\n  readonly athleteId: string;\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/transformers/entity.transformer.ts'\n:import { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport * as moment from 'moment';\nimport { AgeCategory } from 'shared/enums';\nimport { Utils } from 'shared/utils';\nimport { DDBAthleteRankingsItem } from '../athlete.rankings.interface';\n\nexport class EntityTransformer {\n  constructor() {}\n\n  public toDBItem(athleteRanking: AthleteRanking): DDBAthleteRankingsItem {\n    return {\n      ageCategory: athleteRanking.ageCategory,\n      athleteId: athleteRanking.id,\n      country: athleteRanking.country,\n      lastUpdatedAt: athleteRanking.lastUpdatedAt || moment().unix(),\n      birthdate: athleteRanking.birthdate && athleteRanking.birthdate.toISODate(),\n      gender: athleteRanking.gender,\n      name: athleteRanking.name,\n      normalizedName: Utils.normalizeString(athleteRanking.name),\n      surname: athleteRanking.surname,\n      discipline: athleteRanking.discipline,\n      points: athleteRanking.points,\n      year: athleteRanking.year,\n      rankingType: athleteRanking.rankingType,\n    };\n  }\n\n  public fromDBItem(dbItem: DDBAthleteRankingsItem): AthleteRanking {\n    if (!dbItem) {\n      return null;\n    }\n    return new AthleteRanking({\n      ageCategory: dbItem.ageCategory || AgeCategory.All,\n      id: dbItem.athleteId,\n      country: dbItem.country,\n      lastUpdatedAt: dbItem.lastUpdatedAt,\n      gender: dbItem.gender,\n      name: dbItem.name,\n      surname: dbItem.surname,\n      discipline: dbItem.discipline,\n      points: dbItem.points,\n      year: dbItem.year,\n      birthdate: dbItem.birthdate && new Date(dbItem.birthdate),\n      rankingType: dbItem.rankingType,\n    });\n  }\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport * as moment from 'moment';\n\nimport { Utils } from 'shared/utils';\nimport { DDBRepository, GlobalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../../utils/utils';\nimport {\n  AllAttrs,\n  DDBAthleteRankingsItem,\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './athlete.rankings.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformers';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\n@Injectable()\nexport class DDBAthleteRankingsRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  private readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public async get(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(pk.athleteId, pk.rankingType, pk.year, pk.discipline, pk.gender, pk.ageCategory),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBAthleteRankingsRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async put(item: DDBAthleteRankingsItem) {\n    const params = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(item),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository Put', params));\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      KeyConditionExpression: '#pk = :pk and begins_with(#sk_gsi, :sortKeyPrefix) ',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(athleteId),\n        ':sortKeyPrefix': this.transformer.itemToAttrsTransformer.SK_GSI(\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n        ),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository getAllAthleteRankings', params));\n  }\n  public async deleteAthleteRankings(athleteId: string) {\n    const allRankings = await this.getAllAthleteRankings(athleteId);\n    const promises = [];\n\n    for (const ranking of allRankings.items) {\n      const params: AWS.DynamoDB.DocumentClient.DeleteItemInput = {\n        TableName: this._tableName,\n        Key: this.transformer.primaryKey(\n          athleteId,\n          ranking.rankingType,\n          ranking.year,\n          ranking.discipline,\n          ranking.gender,\n          ranking.ageCategory,\n        ),\n      };\n      promises.push(\n        this.client\n          .delete(params)\n          .promise()\n          .then(data => {})\n          .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository delete', params)),\n      );\n    }\n    await Promise.all(promises);\n  }\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const params: AWS.DynamoDB.DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(pk.athleteId, pk.rankingType, pk.year, pk.discipline, pk.gender, pk.ageCategory),\n    };\n    await this.client\n      .delete(params)\n      .promise()\n      .then(data => {})\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository deleteAthleteRankingsItem', params));\n  }\n\n  public async queryRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(category, opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi ',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(\n          category.rankingType,\n          category.year,\n          category.discipline,\n          category.gender,\n          category.ageCategory,\n        ),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository queryRankings', params));\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        points: this.transformer.attrsToItemTransformer.points(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createGSIExclusiveStartKey(\n    category: DDBRankingsItemPrimaryKey,\n    after?: { athleteId: string; points: number },\n  ) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && !Utils.isNil(after.points)) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(\n          category.rankingType,\n          category.year,\n          category.discipline,\n          category.gender,\n          category.ageCategory,\n        ),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.points),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter: { country?: string; id?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.country) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#country, :country)`;\n      filterExpAttrNames['#country'] = this.transformer.attrName('country');\n      filterExpAttrValues[':country'] = filter.country;\n    }\n    if (filter.id) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#pk, :id)`;\n      filterExpAttrNames['#pk'] = this.transformer.attrName('PK');\n      filterExpAttrValues[':id'] = filter.id;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { DDBRepository, GlobalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteDetailItem, KeyAttrs } from './athlete.details.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteDetailsRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteDetailItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async isExists(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      ProjectionExpression: this.transformer.attrName('PK'),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return true;\n        }\n        return false;\n      })\n      .catch(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository isExists', err, params);\n        return false;\n      });\n  }\n\n  public async get(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async batchGet(athleteIds: string[]) {\n    const params: DocumentClient.BatchGetItemInput = {\n      RequestItems: {\n        [this._tableName]: {\n          Keys: athleteIds.map(id => {\n            return this.transformer.primaryKey(id);\n          }),\n        },\n      },\n    };\n    return this.client\n      .batchGet(params)\n      .promise()\n      .then(data => {\n        return data.Responses[this._tableName].map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository batchGet', params));\n  }\n\n  public async put(athlete: DDBAthleteDetailItem) {\n    const params = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(athlete),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository Put', params));\n  }\n\n  public async delete(id: string) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(id),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository delete', params));\n  }\n\n  public async updateProfileUrl(athleteId: string, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository updateUrl', params));\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi and begins_with(#gsi_sk, :value) ',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        '#gsi_sk': this.transformer.attrName('GSI_SK'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ':value': this.transformer.itemToAttrsTransformer.GSI_SK(name),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return items;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletesByName', params));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: { fullName?: string };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(opts.after);\n\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletes', params));\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        name: this.transformer.attrsToItemTransformer.normalizedName(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createGSIExclusiveStartKey(after?: { athleteId: string; name: string }) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && after.name) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.name),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { fullName?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.fullName) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedFullName, :fullName)`;\n      filterExpAttrNames['#normalizedFullName'] = this.transformer.attrName('normalizedFullname');\n      filterExpAttrValues[':fullName'] = filter.fullName;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/attributes.transformer.ts'\n:import { DDBOverloadedTableTransformer } from '../../../dynamodb.table.transformers';\nimport { buildCompositeKey, destructCompositeKey } from '../../../utils/utils';\nimport { AllAttrs, DDBAthleteDetailItem } from '../athlete.details.interface';\n\n\nexport class AttrsTransformer extends DDBOverloadedTableTransformer<\n  AllAttrs,\n  DDBAthleteDetailItem\n> {\n  constructor() {\n    super();\n  }\n\n  public prefixes = {\n    PK: 'Athlete',\n    SK_GSI: 'AthleteDetails',\n    LSI: '',\n    GSI_SK: ''\n  };\n\n  public attrsToItemTransformer = {\n    athleteId: (pk: string) => destructCompositeKey(pk, 1),\n    normalizedName: (gsi_sk: string) => gsi_sk,\n  };\n\n  public itemToAttrsTransformer = {\n    PK: (id: string) => buildCompositeKey(this.prefixes.PK, id),\n    SK_GSI: () => this.prefixes.SK_GSI,\n    LSI: () => undefined,\n    GSI_SK: (name: string) => name,\n  };\n\n  public transformAttrsToItem(dynamodbItem: AllAttrs): DDBAthleteDetailItem {\n    const { PK, SK_GSI, LSI, GSI_SK, ...rest } = dynamodbItem;\n    return {\n      athleteId: this.attrsToItemTransformer.athleteId(PK),\n      normalizedName: GSI_SK,\n      ...rest,\n    };\n  }\n\n  public transformItemToAttrs(item: DDBAthleteDetailItem): AllAttrs {\n    const { athleteId, normalizedName, ...rest } = item;\n    return {\n      PK: this.itemToAttrsTransformer.PK(item.athleteId),\n      SK_GSI: this.itemToAttrsTransformer.SK_GSI(),\n      LSI: this.itemToAttrsTransformer.LSI(),\n      GSI_SK: this.itemToAttrsTransformer.GSI_SK(normalizedName),\n      ...rest,\n    };\n  }\n\n  public primaryKey(athleteId: string) {\n    return {\n      [this.attrName('PK')]: this.itemToAttrsTransformer.PK(athleteId),\n      [this.attrName('SK_GSI')]: this.itemToAttrsTransformer.SK_GSI(),\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'\n:import { DocumentClient } from 'aws-sdk/clients/dynamodb';\n\nexport type AttrsTransformer<T> = {\n  [P in keyof T]: ((...params: string[]) => string)\n};\nexport type AttrsTransformerOptional<T> = {\n  [P in keyof T]?: ((...params: any[]) => any)\n};\nexport type ItemTransformerOptional<T> = {\n  [P in keyof T]?: ((...params: any[]) => any)\n};\n\nexport abstract class DDBOverloadedTableTransformer<\n  TAllAttrs,\n  TTransformedItem\n> {\n  protected abstract attrsToItemTransformer: ItemTransformerOptional<\n    TTransformedItem\n  >;\n  protected abstract itemToAttrsTransformer: AttrsTransformerOptional<\n    TAllAttrs\n  >;\n\n  protected abstract transformAttrsToItem(\n    dynamodbItem: TAllAttrs,\n  ): TTransformedItem;\n\n  protected abstract transformItemToAttrs(\n    item: TTransformedItem,\n    client?: DocumentClient,\n  ): TAllAttrs;\n\n  protected attrNameTyped<T>(attr: keyof T): string {\n    return this.identity(attr);\n  }\n\n  public attrName(attr: keyof TAllAttrs): string {\n    return this.identity(attr);\n  }\n\n  protected identity(x) {\n    return x;\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'calendar-hack/src/ch/dategrid.ts'",
            "'calendar-hack/src/App.tsx'",
            "'calendar-hack/src/components/CalendarGrid.tsx'",
            "'calendar-hack/src/index.tsx'"
        ],
        "content": "'calendar-hack/src/ch/dategrid.ts'\n:import {\n  format,\n  isWithinInterval,\n  eachDayOfInterval,\n  differenceInWeeks,\n  isBefore,\n  isAfter,\n  addDays,\n  addWeeks,\n  startOfWeek,\n  startOfDay,\n  endOfWeek,\n  isMonday,\n  isTuesday,\n  isWednesday,\n  isThursday,\n  isFriday,\n  isSaturday,\n  isSunday,\n} from \"date-fns\";\nimport { WeekStartsOn, WeekStartsOnValues } from \"./datecalc\";\nimport {\n  PlanDates,\n  RaceType,\n  DayDetails,\n  Units,\n  Day,\n  Week,\n  dayOfWeek,\n} from \"types/app\";\n\nexport const key = (d: Date) => format(d, \"yyyy/MM/dd\");\n\n\n\nexport interface RacePlan {\n  planDates: PlanDates;\n  raceType: RaceType;\n  dateGrid: DateGrid<DayDetails>;\n  sourceUnits: Units;\n  description: string;\n  sourceUrl: string;\n}\n\n\n\n\n\n\n\n\n\nexport class DateGrid<T> {\n  private _events: Map<string, T> = new Map();\n\n  private _min: Date | undefined = undefined;\n  private _max: Date | undefined = undefined;\n  private _first: Date | undefined = undefined;\n  private _last: Date | undefined = undefined;\n  private _weekCount: number = 0;\n  private _weekStartsOn: WeekStartsOn = WeekStartsOnValues.Monday;\n\n  constructor(events: Map<Date, T>, weekStartsOn: WeekStartsOn) {\n    this._weekStartsOn = weekStartsOn;\n    events?.forEach((v, k) => {\n      this.setEvent(k, v);\n    });\n  }\n\n  get min(): Date | undefined {\n    return this._min;\n  }\n\n  get max(): Date | undefined {\n    return this._max;\n  }\n\n  get first(): Date | undefined {\n    return this._first;\n  }\n\n  get last(): Date | undefined {\n    return this._last;\n  }\n\n  get weekCount(): number {\n    return this._weekCount;\n  }\n\n  get days(): Day<T>[] {\n    if (!this.first || !this.last) return [];\n    const dates = eachDayOfInterval({ start: this.first, end: this.last });\n    const res = dates.map((d) => {\n      return { date: d, event: this.getEvent(d) };\n    });\n    return res;\n  }\n\n  get weeks(): Week<T>[] {\n    const weeks = [];\n    const allDays = this.days;\n    for (let i = 0; i < this.weekCount; i++) {\n      const daysSlice = allDays.slice(i * 7, i * 7 + 7);\n      weeks.push({ weekNum: i, dist: 0.0, desc: `Week ${i}`, days: daysSlice });\n    }\n    return weeks;\n  }\n\n  clone(): DateGrid<T> {\n    const res = new DateGrid<T>(new Map(), this._weekStartsOn);\n    res._events = new Map<string, T>(this._events);\n    res._min = this._min;\n    res._max = this._max;\n    res._first = this._first;\n    res._last = this._last;\n    res._weekCount = this._weekCount;\n    return res;\n  }\n\n  setEvent(date: Date, event: T | undefined) {\n    const k = key(date);\n    if (event) {\n      this._events.set(k, event);\n\n      if (!this._max || isAfter(date, this._max)) this._max = date;\n      this._last = startOfDay(\n        endOfWeek(this._max, { weekStartsOn: this._weekStartsOn })\n      );\n      if (!this._min || isBefore(date, this._min)) this._min = date;\n      this._first = startOfWeek(this._min, {\n        weekStartsOn: this._weekStartsOn,\n      });\n      this._weekCount = differenceInWeeks(\n        startOfDay(addDays(this._last, 1)),\n        this._first\n      );\n    } else {\n      this._events.delete(k);\n    }\n  }\n\n  getEvent(date: Date): T | undefined {\n    this.validate(date);\n    const k = key(date);\n    const r = this._events.get(k);\n    return r;\n  }\n\n  private validate(d: Date) {\n    if (!this.first || !this.last) return;\n    if (!isWithinInterval(d, { start: this.first, end: this.last }))\n      throw new Error(\n        `\"date ${key(d)} is not within interval (${key(this.first)},${key(\n          this.last\n        )})`\n      );\n  }\n\n  swap(d1: Date, d2: Date) {\n    const e1 = this.getEvent(d1);\n    const e2 = this.getEvent(d2);\n    if (e1 && e2) {\n\n      const temp = e1;\n      this.setEvent(d1, e2);\n      this.setEvent(d2, temp);\n    }\n  }\n\n  swapDow(dow1: dayOfWeek, dow2: dayOfWeek) {\n    if (dow1 === dow2) return;\n\n    const firstSelection = this.selectAll(dow1);\n    const secondSelection = this.selectAll(dow2);\n    if (firstSelection.length !== secondSelection.length) {\n      throw new Error(`selection lengths do not match`);\n    }\n\n    for (let i = 0; i < firstSelection.length; i++) {\n      this.swap(firstSelection[i], secondSelection[i]);\n    }\n  }\n\n  selectWeek(weekNum: number) {\n    if (!this.first || !this.last) return [];\n    const d1 = addWeeks(this.first, weekNum);\n    const d2 = addDays(d1, 6);\n    return eachDayOfInterval({ start: d1, end: d2 });\n  }\n\n  selectAll(dow: dayOfWeek) {\n    if (!this.first || !this.last) return [];\n    const dates = eachDayOfInterval({ start: this.first, end: this.last });\n    switch (dow) {\n      case \"Monday\":\n        return dates.filter((d) => isMonday(d));\n      case \"Tuesday\":\n        return dates.filter((d) => isTuesday(d));\n      case \"Wednesday\":\n        return dates.filter((d) => isWednesday(d));\n      case \"Thursday\":\n        return dates.filter((d) => isThursday(d));\n      case \"Friday\":\n        return dates.filter((d) => isFriday(d));\n      case \"Saturday\":\n        return dates.filter((d) => isSaturday(d));\n      case \"Sunday\":\n        return dates.filter((d) => isSunday(d));\n      default:\n        throw new Error(`unhandled day of week ${dow}`);\n    }\n  }\n\n  swapWeeks(w1: number, w2: number) {\n    if (w1 === w2) return;\n    if (!this.first || !this.last) return;\n    const datesW1 = this.selectWeek(w1);\n    const datesW2 = this.selectWeek(w2);\n    for (let i = 0; i < datesW1.length; i++) {\n      this.swap(datesW1[i], datesW2[i]);\n    }\n  }\n}\n\n'calendar-hack/src/App.tsx'\n:import React, { useState } from \"react\";\nimport { repo } from \"./ch/planrepo\";\nimport { endOfWeek, addWeeks, isAfter } from \"date-fns\";\nimport { RacePlan } from \"./ch/dategrid\";\nimport { build, swap, swapDow } from \"./ch/planbuilder\";\nimport { CalendarGrid } from \"./components/CalendarGrid\";\nimport { ThemeProvider } from \"styled-components\";\nimport { toIcal, download } from \"./ch/icalservice\";\nimport UnitsButtons from \"./defy/components/UnitsButtons\";\nimport PlanAndDate from \"./components/PlanAndDate\";\nimport Toolbar from \"./defy/components/Toolbar\";\nimport styled from \"styled-components\";\nimport DownloadButton from \"./components/DownloadButton\";\nimport UndoButton from \"./components/UndoButton\";\nimport history from \"./defy/history\";\nimport {\n  useQueryParams,\n  StringParam,\n  DateParam,\n  NumberParam,\n} from \"use-query-params\";\nimport { PlanDetailsCard } from \"./components/PlanDetailsCard\";\nimport { WeekStartsOn, WeekStartsOnValues } from \"./ch/datecalc\";\nimport WeekStartsOnPicker from \"./components/WeekStartsOnPicker\";\nimport { useMountEffect } from \"./ch/hooks\";\nimport { Units, PlanSummary, dayOfWeek } from \"types/app\";\nimport { getLocaleUnits } from \"./ch/localize\";\n\nconst theme = {\n  colors: {\n    bodyBg: \"#B8E2E6\",\n    title: \"#424242\",\n    buttonBg: \"#E3F7F8\",\n    buttonIcons: \"#E3F7F8\",\n    buttonTxt: \"#424242\",\n    buttonSelectedBorder: \"#FF6FDF\",\n    dowHeaderBg: \"#C2C5EB\",\n    weekSummaryBg: \"#C2C5EB\",\n    workoutCardBg: \"#E3F7F8\",\n    workoutCardBlankBg: \"#e9ecef\",\n    datelineBg: \"#B391D2\",\n    datelineBlankBg: \"#beafd2\",\n    datelineTxt: \"#424242\",\n    planDescriptionBg: \"#E3F7F8\",\n    planDescriptionTxt: \"#424242\",\n  },\n  fonts: [\"sans-serif\", \"Roboto\"],\n  fontSizes: {\n    small: \"1em\",\n    medium: \"2em\",\n    large: \"3em\",\n  },\n  screenSizes: {\n    sm: \"576px\",\n    md: \"768px\",\n    lg: \"992px\",\n    xl: \"1200px\",\n  },\n};\n\nconst MainUI = styled.div`\n  margin-top: 2em;\n`;\n\nconst SecondToolbar = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-wrap: wrap;\n  margin: 1em 0 5px 0;\n  color: ${(props) => props.theme.colors.controlsTitle};\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    flex-direction: column;\n  }\n`;\nconst UnitsDiv = styled.div`\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    margin-top: 0.5em;\n  }\n`;\n\nconst App = () => {\n  const [{ u, p, d, s }, setq] = useQueryParams({\n    u: StringParam,\n    p: StringParam,\n    d: DateParam,\n    s: NumberParam,\n  });\n  const [selectedUnits, setSelectedUnits] = useState<Units>(\n    u === \"mi\" || u === \"km\" ? u : getLocaleUnits()\n  );\n  var [selectedPlan, setSelectedPlan] = useState(repo.find(p || \"\"));\n  var [racePlan, setRacePlan] = useState<RacePlan | undefined>(undefined);\n  var [undoHistory, setUndoHistory] = useState([] as RacePlan[]);\n  var [weekStartsOn, setWeekStartsOn] = useState<WeekStartsOn>(\n    s === 0 || s === 1 || s === 6 ? s : WeekStartsOnValues.Monday\n  );\n  var [planEndDate, setPlanEndDate] = useState(\n    d && isAfter(d, new Date())\n      ? d\n      : addWeeks(endOfWeek(new Date(), { weekStartsOn: weekStartsOn }), 20)\n  );\n\n  useMountEffect(() => {\n    initialLoad(selectedPlan, planEndDate, selectedUnits, weekStartsOn);\n  });\n\n  const [, forceUpdate] = React.useReducer((x) => x + 1, 0);\n  React.useEffect(() => {\n\n    history.listen(() => {\n      forceUpdate();\n    });\n  }, []);\n\n  const getParams = (\n    units: Units,\n    plan: PlanSummary,\n    date: Date,\n    weekStartsOn: WeekStartsOn\n  ) => {\n    return {\n      u: units,\n      p: plan[0],\n      d: date,\n      s: weekStartsOn,\n    };\n  };\n\n  const initialLoad = async (\n    plan: PlanSummary,\n    endDate: Date,\n    units: Units,\n    weekStartsOn: WeekStartsOn\n  ) => {\n    const racePlan = build(await repo.fetch(plan), endDate, weekStartsOn);\n    setRacePlan(racePlan);\n    setUndoHistory([...undoHistory, racePlan]);\n    setq(getParams(units, plan, endDate, weekStartsOn));\n  };\n\n  const onSelectedPlanChange = async (plan: PlanSummary) => {\n    const racePlan = build(await repo.fetch(plan), planEndDate, weekStartsOn);\n    setSelectedPlan(plan);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, plan, planEndDate, weekStartsOn));\n  };\n\n  const onSelectedEndDateChange = async (date: Date) => {\n    const racePlan = build(await repo.fetch(selectedPlan), date, weekStartsOn);\n    setPlanEndDate(date);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, selectedPlan, date, weekStartsOn));\n  };\n\n  const onSelectedUnitsChanged = (u: Units) => {\n    setSelectedUnits(u);\n    setq(getParams(u, selectedPlan, planEndDate, weekStartsOn));\n  };\n\n  const onWeekStartsOnChanged = async (v: WeekStartsOn) => {\n    const racePlan = build(await repo.fetch(selectedPlan), planEndDate, v);\n    setWeekStartsOn(v);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, selectedPlan, planEndDate, v));\n  };\n\n  function swapDates(d1: Date, d2: Date): void {\n    if (racePlan) {\n      const newRacePlan = swap(racePlan, d1, d2);\n      setRacePlan(newRacePlan);\n      setUndoHistory([...undoHistory, newRacePlan]);\n    }\n  }\n\n  function doSwapDow(dow1: dayOfWeek, dow2: dayOfWeek) {\n    if (racePlan) {\n      const newRacePlan = swapDow(racePlan, dow1, dow2);\n      setRacePlan(newRacePlan);\n      setUndoHistory([...undoHistory, newRacePlan]);\n    }\n  }\n\n  function downloadHandler() {\n    if (racePlan) {\n      const iCalEventsStr = toIcal(racePlan, selectedUnits);\n      if (iCalEventsStr) {\n        download(iCalEventsStr, \"plan\", \"ics\");\n      }\n    }\n  }\n\n  function undoHandler() {\n    if (undoHistory?.length >= 0) {\n      undoHistory.pop();\n    }\n    setRacePlan(undoHistory[undoHistory.length - 1]);\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <Toolbar downloadHandler={downloadHandler} />\n      <PlanAndDate\n        units={selectedUnits}\n        availablePlans={repo.available}\n        selectedPlan={selectedPlan}\n        selectedDate={planEndDate}\n        dateChangeHandler={onSelectedEndDateChange}\n        selectedPlanChangeHandler={onSelectedPlanChange}\n        unitsChangeHandler={onSelectedUnitsChanged}\n        downloadHandler={downloadHandler}\n        weekStartsOn={weekStartsOn}\n      />\n      <SecondToolbar>\n        <UnitsDiv>\n          <UnitsButtons\n            units={selectedUnits}\n            unitsChangeHandler={onSelectedUnitsChanged}\n          />\n        </UnitsDiv>\n      </SecondToolbar>\n      <SecondToolbar>\n        <DownloadButton downloadHandler={downloadHandler} />\n        <UndoButton\n          disabled={undoHistory.length <= 1}\n          undoHandler={undoHandler}\n        />\n      </SecondToolbar>\n      <PlanDetailsCard racePlan={racePlan} />\n      <SecondToolbar>\n        <WeekStartsOnPicker\n          weekStartsOn={weekStartsOn}\n          changeHandler={onWeekStartsOnChanged}\n        />\n      </SecondToolbar>\n      <MainUI>\n        {racePlan && (\n          <CalendarGrid\n            racePlan={racePlan}\n            units={selectedUnits}\n            weekStartsOn={weekStartsOn}\n            swapDates={swapDates}\n            swapDow={doSwapDow}\n          />\n        )}\n      </MainUI>\n    </ThemeProvider>\n  );\n};\n\nexport default App;\n\n'calendar-hack/src/components/CalendarGrid.tsx'\n:import * as React from \"react\";\nimport { RacePlan, key } from \"../ch/dategrid\";\nimport { DayCell } from \"./DayCell\";\nimport { WeekSummary } from \"./WeekSummary\";\nimport { DayOfWeekHeader } from \"./DayOfWeekHeader\";\nimport styled from \"styled-components\";\nimport { format } from \"date-fns\";\nimport { getDaysHeader, WeekStartsOn } from \"../ch/datecalc\";\nimport { Units, dayOfWeek, Week, DayDetails } from \"types/app\";\n\ninterface Props {\n  racePlan: RacePlan;\n  units: Units;\n  weekStartsOn: WeekStartsOn;\n  swapDates: (d1: Date, d2: Date) => void;\n  swapDow: (dow1: dayOfWeek, dow2: dayOfWeek) => void;\n}\n\nconst Root = styled.div`\n  display: grid;\n  grid-template-columns: repeat(1, 1fr);\n  grid-template-rows: auto;\n  row-gap: 0.5em;\n`;\n\nconst WeekRow = styled.div`\n  display: grid;\n  @media (min-width: ${(props) => props.theme.screenSizes.lg}) {\n    grid-template-columns: 0.75fr repeat(7, 1fr);\n  }\n  column-gap: 0.5em;\n`;\n\nconst Blank = styled.div``;\n\nfunction calcWeeklyDistance(w: Week<DayDetails>): number {\n  return w.days\n    .map((d) => d.event)\n    .reduce((a, e) => {\n      return !e || !e.dist ? a : a + e.dist;\n    }, 0);\n}\n\nfunction findMaxDistance(weeks: Week<DayDetails>[]): number {\n  let currMax = 0.0;\n  for (var i = 0; i < weeks.length; i++) {\n    let d = calcWeeklyDistance(weeks[i]);\n    if (d > currMax) {\n      currMax = d;\n    }\n  }\n  return currMax;\n}\n\nexport const CalendarGrid = ({\n  racePlan,\n  units,\n  weekStartsOn,\n  swapDates,\n  swapDow,\n}: Props) => {\n  const [selectedDow, setSelectedDow] = React.useState<dayOfWeek | undefined>(\n    undefined\n  );\n  const [hoveringDow, setHoveringDow] = React.useState<dayOfWeek | undefined>(\n    undefined\n  );\n  const maxDistance = findMaxDistance(racePlan.dateGrid.weeks);\n\n  function getWeek(w: Week<DayDetails>) {\n    return (\n      <WeekRow key={`wr:${w.weekNum}`}>\n        <WeekSummary\n          key={`ws:${w.weekNum}`}\n          desc={w.desc}\n          week={w}\n          units={units}\n          racePlan={racePlan}\n          isFirstWeek={w.weekNum === 0}\n          isLastWeek={w.weekNum === racePlan.dateGrid.weekCount - 1}\n          isHighestMileage={\n            maxDistance > 0 && calcWeeklyDistance(w) === maxDistance\n          }\n        ></WeekSummary>\n        {w.days.map((d, index) => (\n          <DayCell\n            key={key(d.date)}\n            date={d.date}\n            units={units}\n            swap={swapDates}\n            dayDetails={d.event}\n            selected={selectedDow === format(d.date, \"EEEE\")}\n            hovering={hoveringDow === format(d.date, \"EEEE\")}\n          />\n        ))}\n      </WeekRow>\n    );\n  }\n\n  function getHeader() {\n    return (\n      <WeekRow>\n        <Blank key={\"blank-left\"} />\n        {getDaysHeader(weekStartsOn).map((dow, index) => (\n          <DayOfWeekHeader\n            key={dow}\n            dow={dow as dayOfWeek}\n            swapDow={swapDow}\n            setSelectedDow={setSelectedDow}\n            setHoveringDow={setHoveringDow}\n          />\n        ))}\n      </WeekRow>\n    );\n  }\n\n  return (\n    <Root>\n      {getHeader()}\n      {racePlan.dateGrid.weeks.map((w, index) => getWeek(w))}\n    </Root>\n  );\n};\n\n'calendar-hack/src/index.tsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { DndProvider } from 'react-dnd-multi-backend'\nimport { HTML5toTouch } from 'rdndmb-html5-to-touch'\nimport { QueryParamProvider } from \"use-query-params\";\nimport { WindowHistoryAdapter } from \"use-query-params/adapters/window\";\nimport \"./css/reset.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <DndProvider options={HTML5toTouch}>\n      <QueryParamProvider adapter={WindowHistoryAdapter}>\n        <App />\n      </QueryParamProvider>\n    </DndProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n\n\n\nserviceWorker.unregister();\n",
        "gt": [
            "'calendar-hack/src/ch/dategrid.ts'",
            "'calendar-hack/src/components/CalendarGrid.tsx'",
            "'calendar-hack/src/App.tsx'",
            "'calendar-hack/src/index.tsx'"
        ]
    },
    {
        "files": [
            "'react-3d-editor/src/components/asset/Assets.tsx'",
            "'react-3d-editor/src/components/common/CreateMarker.tsx'",
            "'react-3d-editor/src/components/common/CreateMarkerForm.tsx'",
            "'react-3d-editor/src/components/common/Markers.tsx'"
        ],
        "content": "'react-3d-editor/src/components/asset/Assets.tsx'\n:import React, { Component } from 'react';\nimport Icon from 'polestar-icons';\nimport { Entity } from 'aframe';\nimport { Modal, Tree, Row, Col, Card, Tabs, Input } from 'antd';\nimport { AntTreeNodeSelectedEvent } from 'antd/lib/tree';\nimport { AntTreeNodeDropEvent } from 'antd/lib/tree/Tree';\n\nimport { SidebarContainer, Scrollbar, Empty, AddEmpty, Textures, Markers } from '../common';\nimport { EventTools, AssetTools } from '../../tools';\nimport { IScene } from '../../tools/InspectorTools';\nimport { assetPrimitives, getIcon } from '../../constants';\nimport { ITexture } from '../common/Textures';\nimport { IMarker } from '../common/Markers';\nimport { IEntity, IDetailEntity } from '../../models/entity';\nimport { IPrimitive } from '../../models/primitive';\n\ninterface IState {\n\tassets: IEntity[];\n\tvisible: boolean;\n\tselectedKeys: string[];\n\tspinning: boolean;\n\tsearchPrimitives?: string;\n\tsearchMarkers?: string;\n}\n\nclass Assets extends Component<{}, IState> {\n\tstate: IState = {\n\t\tassets: [],\n\t\tvisible: false,\n\t\tselectedKeys: [],\n\t\tspinning: true,\n\t\tsearchPrimitives: '',\n\t\tsearchMarkers: '',\n\t};\n\n\tcomponentDidMount() {\n\t\tEventTools.on('sceneloaded', (scene: IScene) => {\n\t\t\tconst assets = AssetTools.buildAssets(scene);\n\t\t\tthis.setState({\n\t\t\t\tassets,\n\t\t\t\tspinning: false,\n\t\t\t});\n\t\t});\n\t\tEventTools.on('assetcreate', () => {\n\t\t\tconst assets = AssetTools.buildAssets(AFRAME.INSPECTOR.sceneEl);\n\t\t\tthis.setState({\n\t\t\t\tassets,\n\t\t\t});\n\t\t});\n\t\tEventTools.on('assetselect', (asset: Entity) => {\n\t\t\tif (asset) {\n\t\t\t\tthis.setState({\n\t\t\t\t\tselectedKeys: [asset.id],\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.setState({\n\t\t\t\t\tselectedKeys: [],\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t\tEventTools.on('assetremove', () => {\n\t\t\tconst assets = AssetTools.buildAssets(AFRAME.INSPECTOR.sceneEl);\n\t\t\tthis.setState({\n\t\t\t\tassets,\n\t\t\t});\n\t\t});\n\t\tEventTools.on('entityselect', (entity: Entity) => {\n\t\t\tif (entity) {\n\t\t\t\tthis.setState({\n\t\t\t\t\tselectedKeys: [],\n\t\t\t\t});\n\t\t\t\tEventTools.emit('assetselect');\n\t\t\t}\n\t\t});\n\t\tEventTools.on('entityupdate', (detail: IDetailEntity) => {\n\t\t\tif (!detail.entity.object3D && detail.component === 'name') {\n\t\t\t\tdetail.entity.title = detail.value;\n\t\t\t\tconst assets = AssetTools.buildAssets(AFRAME.INSPECTOR.sceneEl);\n\t\t\t\tthis.setState({\n\t\t\t\t\tassets,\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\n\tprivate handleModalVisible = () => {\n\t\tthis.setState((prevState: IState) => {\n\t\t\treturn {\n\t\t\t\tvisible: !prevState.visible,\n\t\t\t};\n\t\t});\n\t};\n\n\n\tprivate handleAddAsset = (item: IPrimitive) => {\n\t\tthis.handleModalVisible();\n\t\tAssetTools.createAsset(item);\n\t};\n\n\n\tprivate handleSelectAsset = (selectedKeys: string[], e: AntTreeNodeSelectedEvent) => {\n\t\tthis.setState(\n\t\t\t{\n\t\t\t\tselectedKeys,\n\t\t\t},\n\t\t\t() => {\n\t\t\t\tif (selectedKeys.length) {\n\t\t\t\t\tAssetTools.selectAsset(e.node.props.dataRef.entity);\n\t\t\t\t\tEventTools.emit('entityselect');\n\t\t\t\t} else {\n\t\t\t\t\tAssetTools.selectAsset();\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t};\n\n\n\tprivate handleDeleteAsset = () => {\n\t\tif (AFRAME.INSPECTOR.selectedAsset) {\n\t\t\tModal.confirm({\n\t\t\t\ttitle: 'Delete asset',\n\t\t\t\tcontent: 'Are you sure want to delete this asset?',\n\t\t\t\tonOk: () => {\n\t\t\t\t\tAssetTools.removeSelectedAsset();\n\t\t\t\t},\n\t\t\t});\n\t\t}\n\t};\n\n\n\tprivate handleSearchPrimitives = (searchPrimitives: string) => {\n\t\tthis.setState({\n\t\t\tsearchPrimitives,\n\t\t});\n\t};\n\n\n\tprivate handleClickTexture = (texture: ITexture) => {\n\t\tconst asset: IPrimitive = {\n\t\t\tkey: '',\n\t\t\ttype: '',\n\t\t\ttitle: texture.name,\n\t\t\tattributes: [\n\t\t\t\t{\n\t\t\t\t\tattribute: 'src',\n\t\t\t\t\tdefault: texture.url,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tattribute: 'crossorigin',\n\t\t\t\t\tdefault: 'anonymous',\n\t\t\t\t},\n\t\t\t],\n\t\t};\n\t\tif (texture.type.includes('image')) {\n\t\t\tObject.assign(asset, {\n\t\t\t\tkey: 'img',\n\t\t\t\ttype: 'img',\n\t\t\t\ticon: getIcon('img'),\n\t\t\t});\n\t\t} else if (texture.type.includes('video')) {\n\t\t\tObject.assign(asset, {\n\t\t\t\tkey: 'video',\n\t\t\t\ttype: 'video',\n\t\t\t\ticon: getIcon('video'),\n\t\t\t});\n\t\t} else if (texture.type.includes('audio')) {\n\t\t\tObject.assign(asset, {\n\t\t\t\tkey: 'audio',\n\t\t\t\ttype: 'audio',\n\t\t\t\ticon: getIcon('audio'),\n\t\t\t});\n\t\t} else {\n\t\t\tObject.assign(asset, {\n\t\t\t\tkey: 'a-asset-item',\n\t\t\t\ttype: 'a-asset-item',\n\t\t\t\ticon: getIcon('a-asset-item'),\n\t\t\t});\n\t\t}\n\t\tthis.handleAddAsset(asset);\n\t};\n\n\n\tprivate handleDropAsset = (options: AntTreeNodeDropEvent) => {\n\t\tconst { dragNode, node } = options;\n\t\tconst source = dragNode.props.dataRef.entity as Entity;\n\t\tconst dest = node.props.dataRef.entity as Entity;\n\t\tconst dropPos = node.props.pos.split('-');\n\t\tconst dropPosition = options.dropPosition - Number(dropPos[dropPos.length - 1]);\n\t\tif (dropPosition < 0) {\n\t\t\tconst parent = dest.parentElement;\n\t\t\tparent.insertBefore(source, dest);\n\t\t\tconst assets = AssetTools.buildAssets(AFRAME.INSPECTOR.sceneEl);\n\t\t\tthis.setState({\n\t\t\t\tassets,\n\t\t\t});\n\t\t}\n\t};\n\n\n\tprivate handleClickMarker = (marker: IMarker) => {\n\t\tthis.handleAddAsset({\n\t\t\ttitle: marker.name,\n\t\t\tkey: 'a-asset-item',\n\t\t\ttype: 'a-asset-item',\n\t\t\ticon: getIcon('a-asset-item'),\n\t\t\tattributes: [\n\t\t\t\t{\n\t\t\t\t\tattribute: 'src',\n\t\t\t\t\tdefault: window.URL.createObjectURL(marker.pattern),\n\t\t\t\t},\n\t\t\t],\n\t\t});\n\t};\n\n\n\tprivate renderTreeNode = (item: IEntity) => {\n\t\treturn (\n\t\t\t<Tree.TreeNode\n\t\t\t\tkey={item.key.toString()}\n\t\t\t\ttitle={item.title}\n\t\t\t\ticon={<Icon name={item.icon} />}\n\t\t\t\tdataRef={item}\n\t\t\t/>\n\t\t);\n\t};\n\n\n\tprivate renderCardItems = (items: IPrimitive[], searchText: string) => {\n\t\treturn (\n\t\t\t<Scrollbar>\n\t\t\t\t{items.length ? (\n\t\t\t\t\t<Row gutter={16} style={{ margin: 0 }}>\n\t\t\t\t\t\t{items\n\t\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t\titem =>\n\t\t\t\t\t\t\t\t\titem.title.includes(searchText.toLowerCase()) ||\n\t\t\t\t\t\t\t\t\titem.description.includes(searchText.toLowerCase()),\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t.map(item => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<Col\n\t\t\t\t\t\t\t\t\t\tkey={item.key}\n\t\t\t\t\t\t\t\t\t\tmd={24}\n\t\t\t\t\t\t\t\t\t\tlg={12}\n\t\t\t\t\t\t\t\t\t\txl={6}\n\t\t\t\t\t\t\t\t\t\tonClick={() => this.handleAddAsset(item)}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Card\n\t\t\t\t\t\t\t\t\t\t\thoverable={true}\n\t\t\t\t\t\t\t\t\t\t\ttitle={item.title}\n\t\t\t\t\t\t\t\t\t\t\textra={\n\t\t\t\t\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\t\t\t\t\tclassName=\"editor-item-help-icon\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tonClick={e => e.stopPropagation()}\n\t\t\t\t\t\t\t\t\t\t\t\t\ttarget=\"_blank\"\n\t\t\t\t\t\t\t\t\t\t\t\t\thref={item.url}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Icon name=\"question-circle-o\" />\n\t\t\t\t\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstyle={{ marginBottom: 16 }}\n\t\t\t\t\t\t\t\t\t\t\tbodyStyle={{ padding: 12, height: 120 }}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<div className=\"editor-item-card-desc\">{item.description}</div>\n\t\t\t\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t\t\t\t</Col>\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t</Row>\n\t\t\t\t) : (\n\t\t\t\t\t<Empty />\n\t\t\t\t)}\n\t\t\t</Scrollbar>\n\t\t);\n\t};\n\n\n\tprivate renderSearch = (callback: (value: string) => void) => {\n\t\treturn (\n\t\t\t<div style={{ flex: 1 }}>\n\t\t\t\t<Input allowClear={true} placeholder=\"Search for Asset...\" onChange={e => callback(e.target.value)} />\n\t\t\t</div>\n\t\t);\n\t};\n\n\trender() {\n\t\tconst { assets, visible, spinning, selectedKeys, searchPrimitives } = this.state;\n\t\treturn (\n\t\t\t<SidebarContainer\n\t\t\t\ttitleStyle={{ border: 0 }}\n\t\t\t\ttitle={\n\t\t\t\t\t<>\n\t\t\t\t\t\t<div style={{ flex: 1 }}>{'Assets'}</div>\n\t\t\t\t\t\t<div>\n\t\t\t\t\t\t\t<Icon\n\t\t\t\t\t\t\t\tclassName=\"editor-icon\"\n\t\t\t\t\t\t\t\tstyle={{ fontSize: '1.25rem', marginRight: 8 }}\n\t\t\t\t\t\t\t\tname=\"plus\"\n\t\t\t\t\t\t\t\tonClick={this.handleModalVisible}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t<Icon\n\t\t\t\t\t\t\t\tclassName=\"editor-icon\"\n\t\t\t\t\t\t\t\tstyle={{ fontSize: '1.25rem' }}\n\t\t\t\t\t\t\t\tname=\"trash\"\n\t\t\t\t\t\t\t\tonClick={this.handleDeleteAsset}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</>\n\t\t\t\t}\n\t\t\t\tspinning={spinning}\n\t\t\t>\n\t\t\t\t{assets.length ? (\n\t\t\t\t\t<Tree\n\t\t\t\t\t\tshowIcon={true}\n\t\t\t\t\t\tonSelect={this.handleSelectAsset}\n\t\t\t\t\t\tselectedKeys={selectedKeys}\n\t\t\t\t\t\tdraggable={true}\n\t\t\t\t\t\tonDrop={this.handleDropAsset}\n\t\t\t\t\t>\n\t\t\t\t\t\t{assets.map(asset => this.renderTreeNode(asset))}\n\t\t\t\t\t</Tree>\n\t\t\t\t) : (\n\t\t\t\t\t<AddEmpty onClick={this.handleModalVisible} />\n\t\t\t\t)}\n\t\t\t\t<Modal\n\t\t\t\t\tclassName=\"editor-item-modal\"\n\t\t\t\t\ttitle={'Add Assets'}\n\t\t\t\t\tvisible={visible}\n\t\t\t\t\tonCancel={this.handleModalVisible}\n\t\t\t\t\tfooter={null}\n\t\t\t\t\twidth=\"75%\"\n\t\t\t\t\tstyle={{ height: '75%' }}\n\t\t\t\t>\n\t\t\t\t\t<Tabs tabPosition=\"left\">\n\t\t\t\t\t\t<Tabs.TabPane key=\"primitives\" tab=\"Primitives\">\n\t\t\t\t\t\t\t<div style={{ display: 'flex', height: '100%', flexDirection: 'column' }}>\n\t\t\t\t\t\t\t\t<div style={{ display: 'flex', padding: '0 8px 16px 8px' }}>\n\t\t\t\t\t\t\t\t\t{this.renderSearch(this.handleSearchPrimitives)}\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div style={{ flex: 1 }}>{this.renderCardItems(assetPrimitives, searchPrimitives)}</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</Tabs.TabPane>\n\t\t\t\t\t\t<Tabs.TabPane key=\"textures\" tab=\"Textures\">\n\t\t\t\t\t\t\t<Textures visible={visible} onClick={this.handleClickTexture} />\n\t\t\t\t\t\t</Tabs.TabPane>\n\t\t\t\t\t\t<Tabs.TabPane key=\"markers\" tab=\"Markers\">\n\t\t\t\t\t\t\t<Markers onClick={this.handleClickMarker} />\n\t\t\t\t\t\t</Tabs.TabPane>\n\t\t\t\t\t</Tabs>\n\t\t\t\t</Modal>\n\t\t\t</SidebarContainer>\n\t\t);\n\t}\n}\n\nexport default Assets;\n\n'react-3d-editor/src/components/common/CreateMarker.tsx'\n:import React, { Component } from 'react';\nimport { Icon, Button, Radio } from 'antd';\nimport uuid from 'uuid';\nimport QRCode from 'qrcode';\nimport debounce from 'lodash/debounce';\nimport warning from 'warning';\n\nimport AutoComplete from './AutoComplete';\nimport CreateMarkerForm from './CreateMarkerForm';\nimport ARPatternFile from '../../lib/ARPatternFile';\nimport InputScript from './InputScript';\n\nexport interface CreateMarkerProps {\n    onSave?: (marker: any) => void;\n    onCancel?: () => void;\n    visible?: boolean;\n}\n\ninterface IState {\n    imageURL: string;\n    innerImageURL: string;\n    markerType: string;\n}\n\nclass CreateMarker extends Component<CreateMarkerProps, IState> {\n    formRef: any;\n\n    state: IState = {\n        imageURL: '',\n        innerImageURL: '',\n        markerType: 'image',\n    }\n\n    private debouncedChangeImageURL = debounce((value: string) => {\n        const { form } = this.formRef.props;\n        form.validateFields((err: any, values: any) => {\n            if (err) {\n                return;\n            }\n            this.handleChangeForm(values);\n        });\n    }, 200)\n\n\n    private handleClear = () => {\n        const { form } = this.formRef.props;\n        form.resetFields();\n        this.setState({\n            imageURL: '',\n            innerImageURL: '',\n        });\n    }\n\n\n    private handleChooseImage = () => {\n        const input = document.createElement('input');\n        input.setAttribute('type', 'file');\n        input.setAttribute('accept', 'image\n    private handleChangeImageURL = (innerImageURL: any) => {\n        const { markerType } = this.state;\n        if (markerType === 'qrcode') {\n            QRCode.toDataURL(innerImageURL, { margin: 0, width: 512 }).then(url => {\n                this.setState({\n                    innerImageURL: url,\n                });\n                this.debouncedChangeImageURL(url);\n            }).catch(error => {\n                warning(true, error);\n            });\n        } else {\n            this.debouncedChangeImageURL(innerImageURL);\n            this.setState({\n                innerImageURL,\n            });\n        }\n    }\n\n\n    private handleSave = () => {\n        const { form } = this.formRef.props;\n        const { onSave } = this.props;\n        form.validateFields((err: any, values: any) => {\n            if (err) {\n                return;\n            }\n            const { innerImageURL, imageURL } = this.state;\n            if (!innerImageURL.length) {\n                return;\n            }\n            if (onSave) {\n                ARPatternFile.encodeImageURL(innerImageURL, patternFileString => {\n                    onSave({\n                        ...values,\n                        id: uuid(),\n                        name: `${values.name}.patt`,\n                        title: values.name,\n                        thumbnail: imageURL,\n                        pattern: new Blob([patternFileString], { type: 'text/plain' }),\n                    });\n                });\n            }\n        });\n    }\n\n\n    private handleChangeForm = (values: any) => {\n        const { innerImageURL } = this.state;\n        const { patternRatio, imageSize, borderColor } = values;\n        ARPatternFile.buildFullMarker(innerImageURL, patternRatio, imageSize, borderColor, (imageURL: string) => {\n            this.setState({\n                imageURL,\n            });\n        });\n    }\n\n    render() {\n        const { onCancel, visible } = this.props;\n        const { imageURL, markerType } = this.state;\n        return (\n            <div style={{ overflowX: 'hidden', width: visible ? 360 : 0, transition: 'width 0.3s', borderLeft: visible ? '1px solid rgba(0, 0, 0, 0.1)' : 0 }}>\n                <div className=\"editor-picker\">\n                    <div className=\"editor-picker-form\">\n                        <Radio.Group onChange={e => { this.setState({ markerType: e.target.value }); }} value={markerType} style={{ marginBottom: 8 }}>\n                            <Radio.Button style={{ width: '50%', textAlign: 'center' }} value=\"image\">{'Image'}</Radio.Button>\n                            <Radio.Button style={{ width: '50%', textAlign: 'center' }} value=\"qrcode\">{'QR Code'}</Radio.Button>\n                        </Radio.Group>\n                        {\n                            markerType === 'image' ? (\n                                <AutoComplete\n                                    onChange={this.handleChangeImageURL}\n                                    value={imageURL.length > 100 ? imageURL.substring(0, 100).concat('...') : imageURL}\n                                    addonAfter={<Icon type=\"shop\" onClick={this.handleChooseImage} />}\n                                />\n                            ) : (\n                                <InputScript onChange={value => { this.handleChangeImageURL(value); }} />\n                            )\n                        }\n                    </div>\n                    <div className=\"editor-picker-preview\">\n                        <div className=\"editor-picker-container\">\n                            <img src={imageURL} alt=\"\" />\n                        </div>\n                    </div>\n                    <div className=\"editor-picker-actions\">\n                        <CreateMarkerForm wrappedComponentRef={(form: any) => this.formRef = form} onChange={this.handleChangeForm} />\n                        <div style={{ display: 'flex', justifyContent: 'center' }}>\n                            <Button style={{ marginRight: 8 }} onClick={this.handleClear}>{'Clear'}</Button>\n                            <Button style={{ marginRight: 8 }} onClick={onCancel}>{'Cancel'}</Button>\n                            <Button style={{ marginLeft: 8 }} type=\"primary\" onClick={this.handleSave}>{'Save'}</Button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default CreateMarker;\n\n'react-3d-editor/src/components/common/CreateMarkerForm.tsx'\n:import React, { Component } from 'react';\nimport { Form, Slider, Input } from 'antd';\nimport { FormComponentProps } from 'antd/lib/form';\nimport ColorPicker from './ColorPicker';\n\ninterface IProps extends FormComponentProps {\n    onChange?: (values: any) => void;\n}\n\nclass CreateMarkerForm extends Component<IProps> {\n    render() {\n        const { form } = this.props;\n        return (\n            <Form colon={false}>\n                <Form.Item label={'Name'}>\n                    {\n                        form.getFieldDecorator('name', {\n                            initialValue: 'pattern-marker',\n                        })(<Input />)\n                    }\n                </Form.Item>\n                <Form.Item label={'Pattern Ratio'}>\n                    {\n                        form.getFieldDecorator('patternRatio', {\n                            initialValue: 0.75,\n                        })(<Slider disabled={true} step={0.01} min={0.10} max={0.90} />)\n                    }\n                </Form.Item>\n                <Form.Item label={'Image Size'}>\n                    {\n                        form.getFieldDecorator('imageSize', {\n                            initialValue: 512,\n                        })(<Slider disabled={true} min={150} max={2500} />)\n                    }\n                </Form.Item>\n                <Form.Item label={'Border Color'}>\n                    {\n                        form.getFieldDecorator('borderColor', {\n                            initialValue: '#000',\n                        })(<ColorPicker disabled={true} />)\n                    }\n                </Form.Item>\n            </Form>\n        );\n    }\n}\n\nexport default Form.create<IProps>({\n    onValuesChange: (props: IProps, changedValues, allValues) => {\n        const { onChange } = props;\n        if (onChange) {\n            onChange(allValues);\n        }\n    },\n})(CreateMarkerForm);\n\n'react-3d-editor/src/components/common/Markers.tsx'\n:import React, { Component } from 'react';\nimport { Spin, Input, Button, Row, Col, Card } from 'antd';\nimport Icon from 'polestar-icons';\nimport warning from 'warning';\n\nimport Scrollbar from './Scrollbar';\nimport AddEmpty from './AddEmpty';\nimport CreateMarker from './CreateMarker';\nimport { MarkerDatabase } from '../../database';\nimport { UtilTools } from '../../tools';\n\nexport interface IMarker {\n\tid?: string;\n\tname?: string;\n\ttitle?: string;\n\tthumbnail: string;\n\tpattern: Blob;\n\tpatternRatio: number;\n\timageSize: number;\n\tborderColor: string;\n}\n\nexport interface MarkersProps {\n\tonClick?: (value?: IMarker) => void;\n\tvisible?: boolean;\n}\n\ninterface IState {\n\tmarkers: IMarker[];\n\tsearchMarker: string;\n\tloading: boolean;\n\tadding: boolean;\n}\n\nclass Markers extends Component<MarkersProps, IState> {\n\tstate: IState = {\n\t\tmarkers: [],\n\t\tsearchMarker: '',\n\t\tloading: false,\n\t\tadding: false,\n\t};\n\n\tcomponentDidMount() {\n\t\tthis.getMarkers();\n\t}\n\n\tcomponentDidUpdate(prevProps: MarkersProps) {\n\t\tif (this.props.visible && this.props.visible !== prevProps.visible) {\n\t\t\tthis.getMarkers();\n\t\t}\n\t}\n\n\n\tprivate getMarkers = () => {\n\t\tthis.setState({\n\t\t\tloading: true,\n\t\t});\n\t\tMarkerDatabase.allDocs()\n\t\t\t.then(response => {\n\t\t\t\tconst markers = response.rows.map(row => {\n\t\t\t\t\tconst { doc } = row;\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: doc._id,\n\t\t\t\t\t\tname: doc.name,\n\t\t\t\t\t\ttitle: doc.title,\n\t\t\t\t\t\tthumbnail: doc.thumbnail,\n\t\t\t\t\t\tpattern: doc._attachments.pattern.data,\n\t\t\t\t\t\tpatternRatio: doc.patternRatio,\n\t\t\t\t\t\timageSize: doc.imageSize,\n\t\t\t\t\t\tborderColor: doc.borderColor,\n\t\t\t\t\t} as IMarker;\n\t\t\t\t});\n\t\t\t\tthis.setState({\n\t\t\t\t\tmarkers,\n\t\t\t\t\tloading: false,\n\t\t\t\t});\n\t\t\t})\n\t\t\t.catch(error => {\n\t\t\t\twarning(true, error);\n\t\t\t\tthis.setState({\n\t\t\t\t\tloading: false,\n\t\t\t\t});\n\t\t\t});\n\t};\n\n\n\tprivate handleAddMarkerVisible = () => {\n\t\tthis.setState(prevState => {\n\t\t\treturn {\n\t\t\t\tadding: !prevState.adding,\n\t\t\t};\n\t\t});\n\t};\n\n\n\tprivate handleSearchMarker = (searchMarker: string) => {\n\t\tthis.setState({\n\t\t\tsearchMarker,\n\t\t});\n\t};\n\n\n\tprivate handleSelectMarker = (marker: IMarker) => {\n\t\tconst { onClick } = this.props;\n\t\tif (onClick) {\n\t\t\tonClick(marker);\n\t\t}\n\t};\n\n\n\tprivate handleAppendMarker = async (marker: IMarker) => {\n\t\tthis.setState({\n\t\t\tloading: true,\n\t\t});\n\t\ttry {\n\t\t\tawait MarkerDatabase.save({\n\t\t\t\t_id: marker.id,\n\t\t\t\tname: marker.name,\n\t\t\t\ttitle: marker.title,\n\t\t\t\t_attachments: {\n\t\t\t\t\tpattern: {\n\t\t\t\t\t\tcontent_type: marker.pattern.type,\n\t\t\t\t\t\tdata: marker.pattern,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tpatternRatio: marker.patternRatio,\n\t\t\t\timageSize: marker.imageSize,\n\t\t\t\tthumbnail: marker.thumbnail,\n\t\t\t\tborderColor: marker.borderColor,\n\t\t\t});\n\t\t\tthis.getMarkers();\n\t\t} catch (error) {\n\t\t\tthis.setState({\n\t\t\t\tloading: false,\n\t\t\t});\n\t\t\tconsole.error(error.toString());\n\t\t}\n\t};\n\n\n\tprivate renderCardActions = (marker: IMarker) => {\n\t\treturn [\n\t\t\t<Icon\n\t\t\t\tkey=\"download\"\n\t\t\t\tname=\"download\"\n\t\t\t\tonClick={e => {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tUtilTools.saveBlob(marker.pattern, marker.name);\n\t\t\t\t}}\n\t\t\t/>,\n\t\t\t<Icon\n\t\t\t\tkey=\"image\"\n\t\t\t\tname=\"image\"\n\t\t\t\tonClick={e => {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tUtilTools.saveBlob(UtilTools.dataURLToBlob(marker.thumbnail), `${marker.title}.png`);\n\t\t\t\t}}\n\t\t\t/>,\n\t\t\t<Icon\n\t\t\t\tkey=\"delete\"\n\t\t\t\tname=\"trash\"\n\t\t\t\tonClick={e => {\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\tMarkerDatabase.delete(marker.id).then(() => {\n\t\t\t\t\t\tthis.getMarkers();\n\t\t\t\t\t});\n\t\t\t\t}}\n\t\t\t/>,\n\t\t];\n\t};\n\n\n\tprivate renderCardItems = (markers: IMarker[], searchMarker: string) => {\n\t\treturn (\n\t\t\t<Scrollbar>\n\t\t\t\t<Row gutter={16} style={{ margin: 0 }}>\n\t\t\t\t\t{markers\n\t\t\t\t\t\t.filter(marker => marker.name.includes(searchMarker.toLowerCase()))\n\t\t\t\t\t\t.map(marker => {\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<Col\n\t\t\t\t\t\t\t\t\tkey={marker.id}\n\t\t\t\t\t\t\t\t\tmd={24}\n\t\t\t\t\t\t\t\t\tlg={12}\n\t\t\t\t\t\t\t\t\txl={6}\n\t\t\t\t\t\t\t\t\tonClick={() => this.handleSelectMarker(marker)}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<Card\n\t\t\t\t\t\t\t\t\t\thoverable={true}\n\n\n\t\t\t\t\t\t\t\t\t\tcover={<img src={marker.thumbnail} />}\n\t\t\t\t\t\t\t\t\t\tactions={this.renderCardActions(marker)}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Card.Meta title={marker.name} />\n\t\t\t\t\t\t\t\t\t</Card>\n\t\t\t\t\t\t\t\t</Col>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\t\t\t\t</Row>\n\t\t\t</Scrollbar>\n\t\t);\n\t};\n\n\n\tprivate renderSearch = () => {\n\t\treturn (\n\t\t\t<div style={{ flex: 1, padding: '0 16px 0 0' }}>\n\t\t\t\t<Input\n\t\t\t\t\tallowClear={true}\n\t\t\t\t\tplaceholder=\"Search for Marker...\"\n\t\t\t\t\tonChange={e => this.handleSearchMarker(e.target.value)}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t);\n\t};\n\n\n\tprivate renderActions = () => {\n\t\treturn (\n\t\t\t<Button type=\"primary\" onClick={this.handleAddMarkerVisible}>\n\t\t\t\t<Icon name=\"plus\" />\n\t\t\t</Button>\n\t\t);\n\t};\n\n\trender() {\n\t\tconst { loading, markers, searchMarker, adding } = this.state;\n\t\treturn (\n\t\t\t<Spin spinning={loading}>\n\t\t\t\t<div style={{ display: 'flex', height: '100%' }}>\n\t\t\t\t\t{markers.length ? (\n\t\t\t\t\t\t<div style={{ display: 'flex', height: '100%', flexDirection: 'column', flex: 1 }}>\n\t\t\t\t\t\t\t<div style={{ display: 'flex', padding: '0 8px 16px 8px' }}>\n\t\t\t\t\t\t\t\t{this.renderSearch()}\n\t\t\t\t\t\t\t\t{this.renderActions()}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div style={{ flex: 1 }}>{this.renderCardItems(markers, searchMarker)}</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t) : (\n\t\t\t\t\t\t<AddEmpty onClick={this.handleAddMarkerVisible}>\n\t\t\t\t\t\t\t<Icon name=\"plus\" style={{ marginRight: 4 }} />\n\t\t\t\t\t\t\t{'New Marker'}\n\t\t\t\t\t\t</AddEmpty>\n\t\t\t\t\t)}\n\t\t\t\t\t<CreateMarker\n\t\t\t\t\t\tvisible={adding}\n\t\t\t\t\t\tonSave={this.handleAppendMarker}\n\t\t\t\t\t\tonCancel={this.handleAddMarkerVisible}\n\t\t\t\t\t/>\n\t\t\t\t</div>\n\t\t\t</Spin>\n\t\t);\n\t}\n}\n\nexport default Markers;\n",
        "gt": [
            "'react-3d-editor/src/components/common/CreateMarkerForm.tsx'",
            "'react-3d-editor/src/components/common/CreateMarker.tsx'",
            "'react-3d-editor/src/components/common/Markers.tsx'",
            "'react-3d-editor/src/components/asset/Assets.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'\n:import { Discipline } from 'shared/enums';\nimport { DDBTableKeyAttrs } from '../../interfaces/table.interface';\n\nexport type KeyAttrs = DDBTableKeyAttrs;\n\ninterface Attrs {\n  readonly place: number;\n  readonly createdAt: number;\n}\n\ninterface NonKeyAttrs extends Attrs {}\nexport type AllAttrs = KeyAttrs & NonKeyAttrs;\n\nexport interface DDBAthleteContestItem extends Attrs {\n  readonly athleteId: string;\n  readonly contestId: string;\n  readonly discipline: Discipline;\n  readonly date: string;\n  readonly points: number;\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { DDBRepository, GlobalSecondaryIndexName, LocalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey, LSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteContestItem, KeyAttrs } from './athlete.contests.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nimport { Utils } from 'shared/utils';\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteContestsRepository extends DDBRepository {\n  protected _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async put(contest: DDBAthleteContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Put', params));\n  }\n\n  public async delete(athleteId: string, contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId, discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Delete', params));\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(athleteId, opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const startDate = opts.betweenDates ? opts.betweenDates.start.toISODate() : '';\n    const endDate = (opts.betweenDates && !Utils.isNil(opts.betweenDates.end)\n      ? opts.betweenDates.end\n      : Utils.DateNow().toDate()\n    ).toISODate();\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and #lsi BETWEEN :startDate AND :endDate',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(athleteId),\n        ':startDate': this.transformer.itemToAttrsTransformer.LSI(startDate),\n        ':endDate': this.transformer.itemToAttrsTransformer.LSI(endDate),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryAthleteContestsByDate', params));\n  }\n\n  public async queryContestAthletes(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(contestId, discipline, after);\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryContestAthletes', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        points: this.transformer.attrsToItemTransformer.points(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(\n    athleteId: string,\n    after?: {\n      contestId: string;\n      discipline: Discipline;\n      date: string;\n    },\n  ): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createGSIExclusiveStartKey(\n    contestId: string,\n    discipline: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && !Utils.isNil(after.points)) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.points),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[] }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'\n:import { DocumentClient } from 'aws-sdk/clients/dynamodb';\n\nexport interface DDBTableKeyAttrs {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly LSI: string;\n  readonly GSI_SK: string;\n}\n\nexport interface LSILastEvaluatedKey {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly LSI: string;\n}\n\nexport interface GSILastEvaluatedKey {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly GSI_SK: string;\n}\n\nexport type NumberSet = DocumentClient.DynamoDbSet;\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'lemmy-fennec/components/Post/PostTitle.tsx'",
            "'lemmy-fennec/Screens/Search/ListComponents.tsx'",
            "'lemmy-fennec/App.tsx'",
            "'lemmy-fennec/Screens/Post/PostScreen.tsx'",
            "'lemmy-fennec/components/Post/ExpandedPost.tsx'"
        ],
        "content": "'lemmy-fennec/components/Post/PostTitle.tsx'\n:import React from \"react\";\nimport { Image, StyleSheet, View } from \"react-native\";\n\nimport { PostView } from \"lemmy-js-client\";\n\nimport { hostname } from \"../../Screens/Search/ListComponents\";\nimport { Text, TouchableOpacity } from \"../../ThemedComponents\";\n\ninterface Props {\n  post: PostView;\n  getCommunity: () => void;\n  getAuthor: () => void;\n  customReadColor?: string;\n  dateStr: string;\n}\n\nfunction PostTitle({\n  post,\n  getCommunity,\n  getAuthor,\n  customReadColor,\n  dateStr,\n}: Props) {\n  const isLocal = post.community.local;\n  const communityName = isLocal\n    ? `c/${post.community.name}`\n    : `c/${post.community.name}@${hostname(post.community.actor_id)}`;\n\n  const safeCommunityName =\n    communityName.length > 50\n      ? communityName.slice(0, 50) + \"...\"\n      : communityName;\n\n  const authorDisplayName = `u/${\n    post.creator.display_name || post.creator.name\n  }`;\n  const safeAuthorName =\n    authorDisplayName.length > 50\n      ? authorDisplayName.slice(0, 50) + \"...\"\n      : authorDisplayName;\n\n  return (\n    <View style={styles.topRow}>\n      <View style={styles.communityIconContainer}>\n        <TouchableOpacity simple onPressCb={getCommunity}>\n          <Image\n            source={{ uri: post.community.icon }}\n            style={styles.communityIcon}\n            accessibilityLabel={\"Icon for community: \" + post.community.name}\n          />\n        </TouchableOpacity>\n      </View>\n      <View>\n        <TouchableOpacity simple onPressCb={getCommunity}>\n          <Text\n            lines={1}\n            customColor={customReadColor}\n            style={styles.communityName}\n          >\n            {safeCommunityName}\n          </Text>\n        </TouchableOpacity>\n        <TouchableOpacity simple onPressCb={getAuthor}>\n          <Text customColor={customReadColor} style={styles.authorName}>\n            {safeAuthorName}\n          </Text>\n        </TouchableOpacity>\n      </View>\n      <Text style={styles.date} customColor={customReadColor}>\n        {dateStr}\n      </Text>\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: 8,\n    borderBottomWidth: 1,\n  },\n  topRow: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 6,\n  },\n  communityIconContainer: {\n    backgroundColor: \"#f6f6f6\",\n    borderRadius: 28,\n    width: 28,\n    height: 28,\n  },\n  communityIcon: { width: 28, height: 28, borderRadius: 28 },\n  authorName: {\n    fontSize: 13,\n    fontWeight: \"500\",\n    color: \"orange\",\n    marginTop: 2,\n  },\n  date: {\n    alignSelf: \"flex-start\",\n    marginLeft: \"auto\",\n  },\n  communityName: {\n    fontSize: 13,\n    fontWeight: \"500\",\n    color: \"violet\",\n  },\n  smolText: { fontSize: 12 },\n});\n\nexport default PostTitle;\n\n'lemmy-fennec/Screens/Search/ListComponents.tsx'\n:import React from \"react\";\nimport { Dimensions, Image, StyleSheet, View } from \"react-native\";\n\nimport {\n  CommunityView,\n  Community as ICommunity,\n  PersonView,\n  PostView,\n} from \"lemmy-js-client\";\n\nimport { Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { makeDateString } from \"../../utils/utils\";\n\nexport function hostname(url: string): string {\n  const matches = url.match(/^https?:\\/\\/([^\\/?#]+)(?:[\\/?#]|$)/i);\n\n  return matches ? matches[1] : \"\";\n}\n\nfunction isCommunityView(\n  item: ICommunity | CommunityView\n): item is CommunityView {\n  return (item as CommunityView).community !== undefined;\n}\n\nexport function Community({\n  sublemmy,\n  navigation,\n}: {\n  sublemmy: CommunityView | ICommunity;\n  navigation: any;\n}) {\n  const isView = isCommunityView(sublemmy);\n\n  let commonItemInterface: ICommunity = isView\n    ?\n      sublemmy.community\n    : sublemmy;\n  const getCommunity = () => {\n    apiClient.postStore.setCommunityPosts([]);\n    apiClient.communityStore.setCommunity(null);\n    navigation.navigate(\"Community\", { id: commonItemInterface.id });\n  };\n\n  const name = commonItemInterface.local\n    ? commonItemInterface.name\n    : `${commonItemInterface.name}@${hostname(commonItemInterface.actor_id)}`;\n\n  return (\n    <TouchableOpacity simple onPressCb={getCommunity}>\n      <View style={styles.community}>\n        {commonItemInterface.icon ? (\n          <Image\n            source={{ uri: commonItemInterface.icon }}\n            style={styles.communityIcon}\n          />\n        ) : (\n          <View style={styles.communityIcon} />\n        )}\n        <View>\n          <Text style={styles.communityName}>{name}</Text>\n          {isView ? (\n            <Text>\n              {(sublemmy as unknown as CommunityView).counts?.subscribers}\n              {\" subscribers\"}\n            </Text>\n          ) : null}\n        </View>\n      </View>\n    </TouchableOpacity>\n  );\n}\n\nexport function User({\n  user,\n  navigation,\n}: {\n  user: PersonView;\n  navigation: any;\n}) {\n  return (\n    <TouchableOpacity\n      simple\n      onPressCb={() =>\n        navigation.navigate(\"User\", { personId: user.person.id })\n      }\n    >\n      <View style={styles.community}>\n        {user.person.avatar ? (\n          <Image\n            source={{ uri: user.person.avatar }}\n            style={styles.communityIcon}\n          />\n        ) : null}\n        <Text style={{ color: \"orange\" }}>{user.person.name}</Text>\n        <Text>{user.counts.post_score + user.counts.comment_score} score</Text>\n        <Text>{user.counts.comment_count} comments</Text>\n      </View>\n    </TouchableOpacity>\n  );\n}\n\nexport function Post({\n  post,\n  navigation,\n}: {\n  post: PostView;\n  navigation: any;\n}) {\n  return (\n    <TouchableOpacity\n      simple\n      onPressCb={() => navigation.navigate(\"Post\", { post: post.post.id })}\n    >\n      <View style={styles.community}>\n        {post.post.thumbnail_url ? (\n          <Image\n            source={{ uri: post.post.thumbnail_url }}\n            style={styles.postIcon}\n          />\n        ) : null}\n        <View style={{ flexDirection: \"column\", gap: 6 }}>\n          <Text style={{ fontWeight: \"500\", fontSize: 16 }}>\n            {post.post.name}\n          </Text>\n          <View style={{ flexDirection: \"row\", gap: 6 }}>\n            <Text style={{ color: \"orange\" }}>{post.creator.name}</Text>\n            <Text style={{ color: \"violet\" }}>in {post.community.name}</Text>\n            <Text>{makeDateString(post.post.published)}</Text>\n          </View>\n        </View>\n      </View>\n    </TouchableOpacity>\n  );\n}\n\nconst styles = StyleSheet.create({\n  communityIcon: {\n    width: 28,\n    height: 28,\n    borderRadius: 28,\n    backgroundColor: \"#cecece\",\n  },\n  communityName: {\n    color: \"violet\",\n    fontSize: 16,\n    maxWidth: Dimensions.get(\"window\").width - 75,\n    flexWrap: \"wrap\",\n  },\n  postIcon: { width: 72, height: 72 },\n  community: {\n    flexDirection: \"row\",\n    alignItems: \"center\",\n    gap: 8,\n    padding: 4,\n    width: \"100%\",\n    flex: 1,\n  },\n});\n\n'lemmy-fennec/App.tsx'\n:import React from \"react\";\nimport { StatusBar, useColorScheme } from \"react-native\";\n\nimport { ActionSheetProvider } from \"@expo/react-native-action-sheet\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\n\nimport AddAccount from \"./Screens/AddAccount\";\nimport BlocksScreen from \"./Screens/Blocks/BlocksScreen\";\nimport CommentWrite from \"./Screens/CommentWrite/CommentWrite\";\nimport CommunityScreen from \"./Screens/Community/CommunityScreen\";\nimport DebugScreen from \"./Screens/DebugScreen\";\nimport HomeScreen from \"./Screens/HomeScreen\";\nimport LoginScreen from \"./Screens/LoginScreen\";\nimport PostScreen from \"./Screens/Post/PostScreen\";\nimport PostWrite from \"./Screens/PostWrite\";\nimport Behavior from \"./Screens/Settings/Behavior\";\nimport Looks from \"./Screens/Settings/Looks\";\nimport ProfileSettings from \"./Screens/Settings/ProfileSettings\";\nimport SettingsScreen from \"./Screens/SettingsScreen\";\nimport MessageWrite from \"./Screens/Unreads/MessageWrite\";\nimport UserScreen from \"./Screens/User/UserScreen\";\nimport { Icon } from \"./ThemedComponents\";\nimport { AppAmoledTheme, AppDarkTheme, AppTheme } from \"./commonStyles\";\nimport Prompt from \"./components/Prompt\";\nimport { ReportMode, apiClient } from \"./store/apiClient\";\nimport { Theme, preferences } from \"./store/preferences\";\n\nconst Stack = createNativeStackNavigator();\n\nconst App = observer(() => {\n  const scheme = useColorScheme();\n\n  const systemTheme = scheme === \"dark\" ? AppDarkTheme : AppTheme;\n  const isLightStatusBar =\n    preferences.theme === Theme.System\n      ? scheme !== \"dark\"\n      : preferences.theme === Theme.Light;\n\n  const schemeMap = {\n    [Theme.System]: systemTheme,\n    [Theme.Light]: AppTheme,\n    [Theme.Dark]: AppDarkTheme,\n    [Theme.Amoled]: AppAmoledTheme,\n  };\n\n  const sendReport = (text: string) => {\n    if (apiClient.reportMode === ReportMode.Post) {\n      apiClient.api\n        .createPostReport({\n          post_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    } else {\n      apiClient.api\n        .createCommentReport({\n          comment_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    }\n  };\n\n  const closeReport = () => {\n    apiClient.setShowPrompt(false);\n  };\n\n  const reportMode = apiClient.reportMode;\n  const promptActions =\n    reportMode !== ReportMode.Off\n      ? {\n          onCancel: closeReport,\n          onConfirm: sendReport,\n        }\n      : apiClient.promptActions;\n  return (\n    <SafeAreaProvider style={{ flex: 1 }}>\n      {}\n      <StatusBar\n        barStyle={isLightStatusBar ? \"dark-content\" : \"light-content\"}\n        backgroundColor={schemeMap[preferences.theme].colors.card}\n      />\n      <ActionSheetProvider>\n        <NavigationContainer theme={schemeMap[preferences.theme]}>\n          <Stack.Navigator initialRouteName={\"Home\"}>\n            <Stack.Screen\n              name=\"Home\"\n              component={HomeScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              name=\"Post\"\n              component={PostScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Comment\" }}\n              name={\"CommentWrite\"}\n              component={CommentWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Post\" }}\n              name={\"PostWrite\"}\n              component={PostWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"Message\" }}\n              name={\"MessageWrite\"}\n              component={MessageWrite}\n            />\n            <Stack.Screen\n              options={{\n                headerRight: () => <Icon name={\"arrow-up\"} size={24} />,\n              }}\n              name=\"Community\"\n              component={CommunityScreen}\n            />\n            <Stack.Screen name=\"Login\" component={LoginScreen} />\n            <Stack.Screen\n              options={{ headerTitle: \"Add Account\" }}\n              name={\"AddAccount\"}\n              component={AddAccount}\n            />\n            <Stack.Screen name=\"User\" component={UserScreen} />\n            <Stack.Screen name=\"Settings\" component={SettingsScreen} />\n            <Stack.Screen name=\"Debug\" component={DebugScreen} />\n            <Stack.Screen name=\"Blocks\" component={BlocksScreen} />\n            <Stack.Screen name=\"Looks\" component={Looks} />\n            <Stack.Screen name=\"Behavior\" component={Behavior} />\n            <Stack.Screen name=\"ProfileSettings\" component={ProfileSettings} />\n          </Stack.Navigator>\n          {apiClient.showPrompt ? (\n            <Prompt\n              text={`Describe whats wrong with this ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              title={`Report ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              reportMode={reportMode}\n              placeholder={\"Type a reason here\"}\n              onSubmit={promptActions.onConfirm}\n              onCancel={promptActions.onCancel}\n            />\n          ) : null}\n        </NavigationContainer>\n      </ActionSheetProvider>\n    </SafeAreaProvider>\n  );\n});\n\nexport default App;\n\n'lemmy-fennec/Screens/Post/PostScreen.tsx'\n:import React from \"react\";\nimport { ActivityIndicator, Animated, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, TouchableOpacity } from \"../../ThemedComponents\";\nimport DynamicHeader from \"../../components/DynamicHeader\";\nimport ExpandedPost from \"../../components/Post/ExpandedPost\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { preferences } from \"../../store/preferences\";\nimport CommentFlatList from \"./CommentsFlatlist\";\nimport CommentsFloatingMenu from \"./CommentsFloatingMenu\";\n\nlet lastOffset = 0;\n\nfunction PostScreen({\n  navigation,\n  route,\n}: NativeStackScreenProps<any, \"Feed\">) {\n  const scrollOffsetY = React.useRef(new Animated.Value(0)).current;\n\n  const [showFab, setShowFab] = React.useState(true);\n  const post = apiClient.postStore.singlePost;\n  const openComment = route.params.openComment;\n  const parentId = route.params.parentId;\n  const { colors } = useTheme();\n\n  const refreshAll = () => {\n    void apiClient.postStore.getSinglePost(route.params.post);\n    void apiClient.commentsStore.getComments(post.post.id, parentId);\n  };\n\n  React.useEffect(() => {\n    if (route.params.post) {\n      void apiClient.postStore.getSinglePost(route.params.post);\n    }\n    return () => {\n      apiClient.postStore.setSinglePost(null);\n    };\n  }, [route.params.post]);\n\n  React.useEffect(() => {\n    if (post) {\n      if (\n        post.counts.comments > 0\n\n      ) {\n        apiClient.commentsStore.setPage(1);\n        void apiClient.commentsStore.getComments(\n          post.post.id,\n          parentId,\n          Boolean(parentId)\n        );\n      }\n    }\n  }, [post]);\n\n  React.useEffect(() => {\n    return () => {\n      apiClient.commentsStore.setPage(1);\n      apiClient.commentsStore.setComments([]);\n    };\n  }, []);\n\n  const onScroll = React.useCallback(\n    (e: any) => {\n      if (preferences.disableDynamicHeaders) return;\n      const currentScrollY = e.nativeEvent.contentOffset.y;\n      const deltaY = currentScrollY - lastOffset;\n      const isGoingDown = currentScrollY > lastOffset;\n\n      if (isGoingDown) {\n\n        scrollOffsetY.setValue(Math.min(scrollOffsetY._value + deltaY, 56));\n      } else {\n\n        scrollOffsetY.setValue(Math.max(scrollOffsetY._value + deltaY, 0));\n      }\n\n      if (showFab !== !isGoingDown) setShowFab(!isGoingDown);\n\n      lastOffset = currentScrollY;\n    },\n    [showFab, scrollOffsetY, preferences.disableDynamicHeaders]\n  );\n\n  if (!post) return <ActivityIndicator />;\n\n  const getAuthor = (id: number) => {\n    navigation.navigate(\"User\", { personId: id });\n  };\n\n  const openCommenting = () => {\n    navigation.navigate(\"CommentWrite\");\n  };\n\n  const onEndReached = () => {\n\n    return console.log(\"endreached\", apiClient.commentsStore.comments.length);\n\n\n\n\n\n\n\n\n\n\n\n  };\n\n  const showAllButton = Boolean(parentId);\n  return (\n    <View style={{ flex: 1 }}>\n      <DynamicHeader\n        animHeaderValue={scrollOffsetY}\n        title={post.post.name || \"Post\"}\n        leftAction={\n          <TouchableOpacity\n            style={{ marginLeft: 16 }}\n            simple\n            onPressCb={() => navigation.goBack()}\n          >\n            <Icon name={\"arrow-left\"} color={colors.text} size={24} />\n          </TouchableOpacity>\n        }\n      />\n\n      <CommentFlatList\n        getAuthor={getAuthor}\n        header={\n          <ExpandedPost\n            post={post}\n            navigation={navigation}\n            showAllButton={showAllButton}\n          />\n        }\n        refreshing={apiClient.commentsStore.isLoading}\n        comments={apiClient.commentsStore.commentTree}\n        colors={colors}\n        onRefresh={refreshAll}\n        onEndReached={onEndReached}\n        openComment={openComment}\n        openCommenting={openCommenting}\n        navigation={navigation}\n        onScroll={onScroll}\n        scrollEventThrottle={8}\n        level={1}\n        footer={<View style={{ height: 112, width: \"100%\" }} />}\n      />\n      {showFab ? (\n        <CommentsFloatingMenu isLoading={apiClient.commentsStore.isLoading} />\n      ) : null}\n    </View>\n  );\n}\n\nexport default observer(PostScreen);\n\n'lemmy-fennec/components/Post/ExpandedPost.tsx'\n:import React from \"react\";\nimport { StyleSheet, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { PostView } from \"lemmy-js-client\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport Embed from \"../../components/Post/Embed\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { makeDateString } from \"../../utils/utils\";\nimport MdRenderer from \"../MdRenderer\";\nimport Media from \"./Media\";\nimport PostBadges from \"./PostBadges\";\nimport PostIconRow from \"./PostIconRow\";\nimport PostTitle from \"./PostTitle\";\n\n\n\n\n\n\nfunction Post({\n  post,\n  navigation,\n  useCommunity,\n  showAllButton,\n}: {\n  post: PostView;\n  useCommunity?: boolean;\n  showAllButton?: boolean;\n  navigation?: NativeStackScreenProps<any, \"Feed\">[\"navigation\"];\n}) {\n  const { colors } = useTheme();\n\n\n  const isNsfw = post.post.nsfw || post.community.nsfw;\n  const isPic = post.post.url\n    ? /\\.(jpeg|jpg|gif|png|webp)$/.test(post.post.url)\n    : false;\n\n\n  const maxLines = undefined;\n  const safeDescription = post.post.body ? post.post.body : \"\";\n  const dateStr = makeDateString(post.post.published);\n\n  const markRead = () => {\n    if (apiClient.loginDetails?.jwt) {\n      void apiClient.postStore.markPostRead(\n        {\n          post_ids: [post.post.id],\n          read: true,\n        },\n        useCommunity\n      );\n    }\n  };\n  React.useEffect(() => {\n    markRead();\n  }, []);\n\n  const getCommunity = () => {\n    apiClient.postStore.setCommunityPosts([]);\n    apiClient.communityStore.setCommunity(null);\n    navigation.navigate(\"Community\", { id: post.community.id });\n  };\n\n  const getAuthor = () => {\n    navigation.navigate(\"User\", { personId: post.creator.id });\n  };\n\n  const customReadColor = post.read ? \"#ababab\" : colors.text;\n\n  const openCommenting = () => {\n    if (post.post.locked) return;\n    apiClient.commentsStore.setReplyTo({\n      postId: post.post.id,\n      parent_id: undefined,\n      title: post.post.name,\n      community: post.community.name,\n      published: post.post.published,\n      author: post.creator.name,\n      content: post.post.body || post.post.url,\n      language_id: post.post.language_id,\n    });\n    navigation.navigate(\"CommentWrite\");\n  };\n\n  return (\n    <>\n      <View style={{ ...styles.container, borderColor: colors.border }}>\n        <PostTitle\n          post={post}\n          getCommunity={getCommunity}\n          getAuthor={getAuthor}\n          dateStr={dateStr}\n        />\n\n        <Text\n          customColor={customReadColor}\n          lines={maxLines}\n          style={styles.postName}\n        >\n          {post.post.name}\n        </Text>\n\n        <PostBadges isNsfw={isNsfw} post={post} />\n        <View>\n          {isPic ? (\n            <Media url={post.post.url} name={post.post.name} isNsfw={isNsfw} />\n          ) : null}\n          {post.post.url || post.post.embed_title ? (\n            <Embed\n              embed_title={post.post.embed_title}\n              embed_description={post.post.embed_description}\n              url={post.post.url}\n            />\n          ) : null}\n          <MdRenderer value={safeDescription} />\n        </View>\n        <PostIconRow\n          post={post}\n          markRead={markRead}\n          getComments={openCommenting}\n          useCommunity={useCommunity}\n        />\n      </View>\n      {showAllButton ? (\n        <TouchableOpacity\n          onPressCb={() => {\n            navigation.setParams({ post: post.post.id, parentId: undefined });\n            void apiClient.commentsStore.getComments(post.post.id);\n          }}\n          simple\n        >\n          <Text\n            style={{\n              padding: 8,\n              color: colors.primary,\n              backgroundColor: colors.card,\n              fontSize: 16,\n            }}\n          >\n            Show all {post.counts.comments} comments\n          </Text>\n        </TouchableOpacity>\n      ) : null}\n    </>\n  );\n}\n\n\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: 8,\n    borderBottomWidth: 1,\n    marginTop: 56,\n  },\n  previewButton: {\n    width: \"100%\",\n    alignItems: \"center\",\n    padding: 12,\n  },\n  postName: {\n    fontSize: 17,\n    fontWeight: \"500\",\n    flex: 1,\n    marginTop: 4,\n    marginBottom: 8,\n  },\n  postImg: { width: \"100%\", height: 340 },\n});\n\nexport default observer(Post);\n",
        "gt": [
            "'lemmy-fennec/Screens/Search/ListComponents.tsx'",
            "'lemmy-fennec/components/Post/PostTitle.tsx'",
            "'lemmy-fennec/components/Post/ExpandedPost.tsx'",
            "'lemmy-fennec/Screens/Post/PostScreen.tsx'",
            "'lemmy-fennec/App.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'\n:import { DocumentClient } from 'aws-sdk/clients/dynamodb';\n\nexport interface DDBTableKeyAttrs {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly LSI: string;\n  readonly GSI_SK: string;\n}\n\nexport interface LSILastEvaluatedKey {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly LSI: string;\n}\n\nexport interface GSILastEvaluatedKey {\n  readonly PK: string;\n  readonly SK_GSI: string;\n  readonly GSI_SK: string;\n}\n\nexport type NumberSet = DocumentClient.DynamoDbSet;\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'\n:import { Discipline } from 'shared/enums';\nimport { DDBTableKeyAttrs } from '../../interfaces/table.interface';\n\nexport type KeyAttrs = DDBTableKeyAttrs;\n\ninterface Attrs {\n  readonly place: number;\n  readonly createdAt: number;\n}\n\ninterface NonKeyAttrs extends Attrs {}\nexport type AllAttrs = KeyAttrs & NonKeyAttrs;\n\nexport interface DDBAthleteContestItem extends Attrs {\n  readonly athleteId: string;\n  readonly contestId: string;\n  readonly discipline: Discipline;\n  readonly date: string;\n  readonly points: number;\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/entity.transformer.ts'\n:import { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport * as moment from 'moment';\nimport { DDBAthleteContestItem } from '../athlete.contests.interface';\n\nexport class EntityTransformer {\n  constructor() {}\n\n  public toDBItem(contestResult: AthleteContestResult): DDBAthleteContestItem {\n    return {\n      contestId: contestResult.contestId,\n      athleteId: contestResult.athleteId,\n      date: contestResult.contestDate.toISODate(),\n      discipline: contestResult.contestDiscipline,\n      points: contestResult.points,\n      place: contestResult.place,\n      createdAt: contestResult.createdAt || moment().unix(),\n    };\n  }\n\n  public fromDBItem(dbItem: DDBAthleteContestItem): AthleteContestResult {\n    if (!dbItem) {\n      return null;\n    }\n    return new AthleteContestResult({\n      contestDate: new Date(dbItem.date),\n      contestDiscipline: dbItem.discipline,\n      contestId: dbItem.contestId,\n      createdAt: dbItem.createdAt,\n      athleteId: dbItem.athleteId,\n      place: dbItem.place,\n      points: dbItem.points,\n    });\n  }\n}\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { DDBRepository, GlobalSecondaryIndexName, LocalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey, LSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteContestItem, KeyAttrs } from './athlete.contests.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nimport { Utils } from 'shared/utils';\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteContestsRepository extends DDBRepository {\n  protected _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async put(contest: DDBAthleteContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Put', params));\n  }\n\n  public async delete(athleteId: string, contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId, discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Delete', params));\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(athleteId, opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const startDate = opts.betweenDates ? opts.betweenDates.start.toISODate() : '';\n    const endDate = (opts.betweenDates && !Utils.isNil(opts.betweenDates.end)\n      ? opts.betweenDates.end\n      : Utils.DateNow().toDate()\n    ).toISODate();\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and #lsi BETWEEN :startDate AND :endDate',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(athleteId),\n        ':startDate': this.transformer.itemToAttrsTransformer.LSI(startDate),\n        ':endDate': this.transformer.itemToAttrsTransformer.LSI(endDate),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryAthleteContestsByDate', params));\n  }\n\n  public async queryContestAthletes(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(contestId, discipline, after);\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryContestAthletes', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        points: this.transformer.attrsToItemTransformer.points(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(\n    athleteId: string,\n    after?: {\n      contestId: string;\n      discipline: Discipline;\n      date: string;\n    },\n  ): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createGSIExclusiveStartKey(\n    contestId: string,\n    discipline: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && !Utils.isNil(after.points)) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.points),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[] }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/interfaces/table.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'Lumina/src/Components/Windows/Ramps/ColorRamp.tsx'",
            "'Lumina/src/Components/Windows/Pickers.tsx/ColorPicker.tsx'",
            "'Lumina/src/Main.server.ts'",
            "'Lumina/src/Components/Windows/Pickers.tsx/PickerCursor.tsx'"
        ],
        "content": "'Lumina/src/Components/Windows/Ramps/ColorRamp.tsx'\n:import React, { StrictMode, useEffect, useRef, useState } from \"@rbxts/react\";\nimport { createRoot } from \"@rbxts/react-roblox\";\nimport { Event } from \"API/Bindables/Event\";\nimport type { ColorPoint, ColorRampField } from \"API/Fields/ColorRampField\";\nimport { RoundDecimal } from \"API/Lib\";\nimport { BasicTextLabel } from \"Components/Basic/BasicTextLabel\";\nimport { NumberInput } from \"Components/Basic/NumberInput\";\nimport Div from \"Components/Div\";\nimport { StyleColors } from \"Style\";\nimport { GetWindow, Windows } from \"Windows/WindowSevice\";\nimport { LoadColorPickerAPI } from \"../Pickers.tsx/ColorPicker\";\nimport ColorRampPoint from \"./ColorRampPoint\";\n\nconst DOUBLE_CLICK_TIME = 0.25;\n\nexport function InitializeColorRamp() {\n    const window = GetWindow(Windows.ColorRamp);\n    const root = createRoot(window);\n    root.render(\n        <StrictMode>\n            <ColorRamp />\n        </StrictMode>,\n    );\n}\n\nlet loadedRampAPI: ColorRampField;\nconst loadedRampChanged = new Event();\n\nconst placeholderGradient = new ColorSequence([\n    new ColorSequenceKeypoint(0, Color3.fromRGB(0, 0, 0)),\n    new ColorSequenceKeypoint(1, Color3.fromRGB(255, 255, 255)),\n]);\n\nexport function LoadColorRampAPI(ramp: ColorRampField) {\n    loadedRampAPI = ramp;\n    loadedRampChanged.Fire();\n}\n\nfunction ColorRamp() {\n    const [forceRender, setForceRender] = useState(0);\n\n    const rampAPIRef = useRef<ColorRampField>();\n    const colorPickerWindowRef = useRef(GetWindow(Windows.ColorPicker));\n    const selectedPointRef = useRef<ColorPoint | undefined>();\n    const lastClickTime = useRef(0);\n\n    const onClick = () => {\n        if (rampAPIRef.current === undefined) return;\n\n        if (os.clock() - lastClickTime.current < DOUBLE_CLICK_TIME) {\n            if (rampAPIRef.current.CountPoints() >= 20) {\n                warn(\"Max amount of color gradient points reached\");\n                return;\n            }\n\n            const window = GetWindow(Windows.ColorRamp);\n            const mousePosition = window.GetRelativeMousePosition();\n\n            const percentX = (mousePosition.X - window.AbsoluteSize.X * 0.1) / (window.AbsoluteSize.X * 0.8);\n            const newPoint = rampAPIRef.current.AddPoint(RoundDecimal(percentX, 0.01), new Vector3(0, 0, 1));\n            selectedPointRef.current = newPoint;\n\n            setForceRender((prev) => prev + 1);\n            return;\n        }\n\n        lastClickTime.current = os.clock();\n    };\n\n    const selectPoint = (point: ColorPoint) => {\n        selectedPointRef.current = point;\n        setForceRender((prev) => prev + 1);\n    };\n\n    const updatePointTime = (id: number, time: number) => {\n        if (rampAPIRef.current === undefined) return;\n\n        let validatedTime = time;\n        if (validatedTime > 1) {\n            validatedTime = 1;\n        }\n\n        rampAPIRef.current.UpdatePointTime(id, validatedTime);\n        setForceRender((prev) => prev + 1);\n\n        return time;\n    };\n\n    const removePoint = (id: number) => {\n        if (rampAPIRef.current === undefined) return;\n\n        rampAPIRef.current.RemovePoint(id);\n        setForceRender((prev) => prev + 1);\n    };\n\n    const openColorPicker = () => {\n        if (selectedPointRef.current === undefined) return;\n\n        LoadColorPickerAPI(selectedPointRef.current.color);\n        colorPickerWindowRef.current.Enabled = true;\n    };\n\n    useEffect(() => {\n        const connection = loadedRampChanged.Connect(() => {\n            if (loadedRampAPI !== undefined) {\n                rampAPIRef.current = loadedRampAPI;\n                selectedPointRef.current = undefined;\n                setForceRender((prev) => prev + 1);\n            }\n        });\n\n        return () => connection.Disconnect();\n    }, []);\n\n    useEffect(() => {\n        const connections: RBXScriptConnection[] = [];\n        let changedConnection: RBXScriptConnection;\n\n        if (rampAPIRef.current !== undefined) {\n            changedConnection = rampAPIRef.current.FieldChanged.Connect(() => {\n                for (const connection of connections) connection.Disconnect();\n                setForceRender((prev) => prev + 1);\n            });\n\n            for (const point of rampAPIRef.current.GetAllPoints()) {\n                const connection = point.color.FieldChanged.Connect(() => {\n                    setForceRender((prev) => prev + 1);\n                });\n\n                connections.push(connection);\n            }\n        }\n\n        return () => {\n            for (const connection of connections) connection.Disconnect();\n\n            if (changedConnection !== undefined) {\n                changedConnection.Disconnect();\n            }\n        };\n    }, [rampAPIRef.current, forceRender]);\n\n    return (\n        <Div BackgroundColor={StyleColors.Background}>\n            <Div\n                AnchorPoint={new Vector2(0.5, 0)}\n                Position={UDim2.fromScale(0.5, 0.2)}\n                Size={UDim2.fromScale(0.8, 0.3)}\n                BackgroundColor={StyleColors.FullWhite}\n                onMouseButton1Down={onClick}\n            >\n                <uigradient Color={rampAPIRef.current === undefined ? placeholderGradient : rampAPIRef.current.GetGradient()} />\n\n                {rampAPIRef.current?.GetAllPoints().map((point, _) => {\n                    return (\n                        <ColorRampPoint\n                            key={`point_${point.id}`}\n                            Point={point}\n                            SetSelectedPoint={selectPoint}\n                            UpdateTime={point.canEditTime ? updatePointTime : undefined}\n                            RemovePoint={point.canEditTime ? removePoint : undefined}\n                        />\n                    );\n                })}\n            </Div>\n            <Div Position={UDim2.fromScale(0, 0.7)} Size={UDim2.fromScale(1, 0.3)} BackgroundColor={StyleColors.Primary}>\n                <uilistlayout FillDirection={Enum.FillDirection.Horizontal} Padding={new UDim(0, 10)} />\n\n                <Div Size={UDim2.fromScale(0.5, 1)}>\n                    <uilistlayout\n                        FillDirection={Enum.FillDirection.Horizontal}\n                        VerticalAlignment={\"Center\"}\n                        HorizontalAlignment={\"Center\"}\n                        Padding={new UDim(0, 10)}\n                    />\n\n                    <BasicTextLabel Size={new UDim2(0.4, 0, 0, 20)} Text={\"Time:\"} TextXAlignment={\"Right\"} IsAffectedByZoom={false} />\n                    {selectedPointRef.current !== undefined ? (\n                        <NumberInput\n                            Size={new UDim2(0.4, 0, 0, 20)}\n                            Text={tostring(selectedPointRef.current.time)}\n                            Disabled={!selectedPointRef.current.canEditTime}\n                            NumberChanged={(number) => updatePointTime((selectedPointRef.current as ColorPoint).id, number)}\n                            IsAffectedByZoom={false}\n                        />\n                    ) : (\n                        <NumberInput Size={new UDim2(0.4, 0, 0, 20)} Disabled={true} IsAffectedByZoom={false} />\n                    )}\n                </Div>\n                <Div Size={UDim2.fromScale(0.5, 1)}>\n                    {selectedPointRef.current && (\n                        <Div\n                            AnchorPoint={new Vector2(0.5, 0.5)}\n                            Position={UDim2.fromScale(0.5, 0.5)}\n                            Size={UDim2.fromScale(0.8, 0.5)}\n                            BackgroundColor={(selectedPointRef.current as ColorPoint).color.GetColor()}\n                            onMouseButton1Down={openColorPicker}\n                        />\n                    )}\n                </Div>\n            </Div>\n        </Div>\n    );\n}\n\n'Lumina/src/Components/Windows/Pickers.tsx/ColorPicker.tsx'\n:import React, { StrictMode, useEffect, useRef, useState } from \"@rbxts/react\";\nimport { createRoot } from \"@rbxts/react-roblox\";\nimport { RunService } from \"@rbxts/services\";\nimport { Event } from \"API/Bindables/Event\";\nimport type { ColorField } from \"API/Fields/ColorField\";\nimport { BasicTextLabel } from \"Components/Basic/BasicTextLabel\";\nimport { NumberInput } from \"Components/Basic/NumberInput\";\nimport { TextInput } from \"Components/Basic/TextInput\";\nimport Div from \"Components/Div\";\nimport { StyleColors } from \"Style\";\nimport { GetWindow, Windows } from \"Windows/WindowSevice\";\nimport PickerCursor from \"./PickerCursor\";\n\n\n\n\nexport function InitializeColorPicker() {\n    const window = GetWindow(Windows.ColorPicker);\n    const root = createRoot(window);\n    root.render(\n        <StrictMode>\n            <ColorPicker />\n        </StrictMode>,\n    );\n}\n\nconst blackGradient = new ColorSequence([\n    new ColorSequenceKeypoint(0, Color3.fromRGB(0, 0, 0)),\n    new ColorSequenceKeypoint(1, Color3.fromRGB(0, 0, 0)),\n]);\n\nconst hueRangeGradient = new ColorSequence([\n    new ColorSequenceKeypoint(0, Color3.fromRGB(255, 0, 0)),\n    new ColorSequenceKeypoint(1 / 6, Color3.fromRGB(255, 255, 0)),\n    new ColorSequenceKeypoint(2 / 6, Color3.fromRGB(0, 255, 0)),\n    new ColorSequenceKeypoint(3 / 6, Color3.fromRGB(0, 255, 255)),\n    new ColorSequenceKeypoint(4 / 6, Color3.fromRGB(0, 0, 255)),\n    new ColorSequenceKeypoint(5 / 6, Color3.fromRGB(255, 0, 255)),\n    new ColorSequenceKeypoint(1, Color3.fromRGB(255, 0, 0)),\n]);\n\nconst transparency = new NumberSequence([new NumberSequenceKeypoint(0, 0), new NumberSequenceKeypoint(1, 1)]);\n\nlet loadedColorPickerAPI: ColorField;\nconst colorPickerAPILoaded = new Event();\n\nexport function LoadColorPickerAPI(colorPicker: ColorField) {\n    loadedColorPickerAPI = colorPicker;\n    colorPickerAPILoaded.Fire();\n}\n\nfunction ColorPicker() {\n    const [forceRender, setForceRender] = useState(0);\n\n    const window = useRef<DockWidgetPluginGui>();\n    const pickerAPIRef = useRef<ColorField>();\n    const isDraggingCursor1Ref = useRef(false);\n    const isDraggingCursor2Ref = useRef(false);\n\n    const getRGB = () => {\n        if (pickerAPIRef.current === undefined) return { R: 0, G: 0, B: 0 };\n\n        const color = pickerAPIRef.current.GetColor();\n        return { R: math.round(color.R * 255), G: math.round(color.G * 255), B: math.round(color.B * 255) };\n    };\n\n    const getHex = () => {\n        if (pickerAPIRef.current === undefined) return \"FFFFFF\";\n\n        const color = pickerAPIRef.current.GetColor();\n        const roundedColor = Color3.fromRGB(math.round(color.R * 255), math.round(color.G * 255), math.round(color.B * 255));\n\n        return roundedColor.ToHex();\n    };\n\n    const getCursor1Position = () => {\n        if (pickerAPIRef.current === undefined || window.current === undefined) return UDim2.fromOffset(0, 0);\n        if (window.current.AbsoluteSize === Vector2.zero) return UDim2.fromOffset(0, 0);\n\n        const marginRight = 4;\n        const maxX = window.current.AbsoluteSize.X * 0.8 - marginRight;\n        const x = math.clamp(pickerAPIRef.current.saturation * maxX, 0, maxX);\n\n        const marginBottom = 4;\n        const maxY = window.current.AbsoluteSize.Y * 0.55 - marginBottom;\n        const y = math.clamp((1 - pickerAPIRef.current.value) * maxY, 0, maxY);\n\n        return UDim2.fromOffset(x - 4, y - 4);\n    };\n\n    const onCursor1Down = () => {\n        isDraggingCursor1Ref.current = true;\n\n        RunService.BindToRenderStep(\"ColorPickerCursor1\", Enum.RenderPriority.Input.Value, () => {\n            if (pickerAPIRef.current === undefined || window.current === undefined) return;\n\n            const mousePosition = window.current.GetRelativeMousePosition();\n\n            const marginLeft = 1;\n            const marginRight = 4;\n\n            const minX = window.current.AbsoluteSize.X * 0.1 + marginLeft;\n            const maxX = window.current.AbsoluteSize.X * 0.8 - marginRight;\n            const x = math.clamp(mousePosition.X - minX, 0, maxX);\n\n            const marginTop = 1;\n            const marginBottom = 4;\n\n            const minY = window.current.AbsoluteSize.Y * 0.05 + marginTop;\n            const maxY = window.current.AbsoluteSize.Y * 0.55 - marginBottom;\n            const y = math.clamp(mousePosition.Y - minY, 0, maxY);\n\n            pickerAPIRef.current.SetSaturation(math.clamp(x / maxX, 0, 1));\n            pickerAPIRef.current.SetValue(math.clamp(1 - y / maxY, 0, 1));\n        });\n    };\n\n    const onCursor1Up = () => {\n        isDraggingCursor1Ref.current = false;\n        RunService.UnbindFromRenderStep(\"ColorPickerCursor1\");\n    };\n\n    const getCursor2Position = () => {\n        if (pickerAPIRef.current === undefined || window.current === undefined) return UDim2.fromOffset(0, 0);\n        if (window.current.AbsoluteSize === Vector2.zero) return UDim2.fromOffset(0, 0);\n\n        const marginRight = 4;\n        const maxX = window.current.AbsoluteSize.X * 0.8 - marginRight;\n        const x = math.clamp(pickerAPIRef.current.hue * maxX, 0, maxX);\n\n        return new UDim2(0, x - 4, 0.5, 0);\n    };\n\n    const onCursor2Down = () => {\n        isDraggingCursor2Ref.current = true;\n\n        RunService.BindToRenderStep(\"ColorPickerCursor2\", Enum.RenderPriority.Input.Value, () => {\n            if (pickerAPIRef.current === undefined || window.current === undefined) return;\n\n            const mousePosition = window.current.GetRelativeMousePosition();\n\n            const marginLeft = 1;\n            const marginRight = 4;\n\n            const minX = window.current.AbsoluteSize.X * 0.1 + marginLeft;\n            const maxX = window.current.AbsoluteSize.X * 0.8 - marginRight;\n            const x = math.clamp(mousePosition.X - minX, 0, maxX);\n\n            const hue = math.clamp(x / maxX, 0, 1);\n            pickerAPIRef.current.SetHue(hue);\n        });\n    };\n\n    const onCursor2Up = () => {\n        isDraggingCursor2Ref.current = false;\n        RunService.UnbindFromRenderStep(\"ColorPickerCursor2\");\n    };\n\n    const rChanged = (number: number) => {\n        if (isDraggingCursor1Ref.current || isDraggingCursor2Ref.current || pickerAPIRef.current === undefined) return;\n\n        let r = number;\n\n        if (r > 255) {\n            r = 255;\n        }\n\n        const oldColor = pickerAPIRef.current.GetColor();\n        const newColor = Color3.fromRGB(r, math.round(oldColor.G * 255), math.round(oldColor.B * 255));\n        const hsv = newColor.ToHSV();\n\n        pickerAPIRef.current.SetHSV(hsv[0], hsv[1], hsv[2]);\n        return r;\n    };\n\n    const gChanged = (number: number) => {\n        if (isDraggingCursor1Ref.current || isDraggingCursor2Ref.current || pickerAPIRef.current === undefined) return;\n\n        let g = number;\n\n        if (g > 255) {\n            g = 255;\n        }\n\n        const oldColor = pickerAPIRef.current.GetColor();\n        const newColor = Color3.fromRGB(math.round(oldColor.R * 255), g, math.round(oldColor.B * 255));\n        const hsv = newColor.ToHSV();\n\n        pickerAPIRef.current.SetHSV(hsv[0], hsv[1], hsv[2]);\n        return g;\n    };\n\n    const bChanged = (number: number) => {\n        if (isDraggingCursor1Ref.current || isDraggingCursor2Ref.current || pickerAPIRef.current === undefined) return;\n\n        let b = number;\n\n        if (b > 255) {\n            b = 255;\n        }\n\n        const oldColor = pickerAPIRef.current.GetColor();\n        const newColor = Color3.fromRGB(math.round(oldColor.R * 255), math.round(oldColor.G * 255), b);\n        const hsv = newColor.ToHSV();\n\n        pickerAPIRef.current.SetHSV(hsv[0], hsv[1], hsv[2]);\n        return b;\n    };\n\n    const hexChanged = (text: string) => {\n        if (isDraggingCursor1Ref.current || isDraggingCursor2Ref.current || pickerAPIRef.current === undefined) return;\n\n        let hex = text;\n\n        if (hex.size() > 6) {\n            hex = hex.sub(1, 6);\n        }\n\n        if (hex.size() < 6) {\n            return hex;\n        }\n\n        let validatedHex = \"\";\n\n        for (let i = 1; i <= 6; i++) {\n            const char = hex.sub(i, i);\n\n            if (tonumber(char, 16) === undefined) {\n                validatedHex += \"F\";\n            } else {\n                validatedHex += char;\n            }\n        }\n\n        const newColor = Color3.fromHex(validatedHex);\n        const hsv = newColor.ToHSV();\n\n        pickerAPIRef.current.SetHSV(hsv[0], hsv[1], hsv[2]);\n\n        if (validatedHex.upper() !== getHex().upper()) {\n            warn(\"Hex Color Mistranslated\");\n        }\n\n        return validatedHex.upper();\n    };\n\n    const hexLostFocus = () => {\n        return getHex().upper();\n    };\n\n    useEffect(() => {\n        const loadedConnection = colorPickerAPILoaded.Connect(() => {\n            if (loadedColorPickerAPI !== undefined) {\n                pickerAPIRef.current = loadedColorPickerAPI;\n                setForceRender((prev) => prev + 1);\n            }\n        });\n\n        window.current = GetWindow(Windows.ColorPicker);\n        const resizeConnection = window.current.GetPropertyChangedSignal(\"AbsoluteSize\").Connect(() => {\n            setForceRender((prev) => prev + 1);\n        });\n\n        return () => {\n            loadedConnection.Disconnect();\n            resizeConnection.Disconnect();\n        };\n    }, []);\n\n    useEffect(() => {\n        if (pickerAPIRef.current === undefined) return;\n\n        const valuesChangedConnection = pickerAPIRef.current.FieldChanged.Connect(() => {\n            setForceRender((prev) => prev + 1);\n        });\n\n        return () => valuesChangedConnection.Disconnect();\n    }, [pickerAPIRef.current, forceRender]);\n\n    return (\n        <Div BackgroundColor={StyleColors.Background}>\n            {}\n            <Div\n                AnchorPoint={new Vector2(0.5, 0)}\n                Size={UDim2.fromScale(0.8, 0.55)}\n                Position={UDim2.fromScale(0.5, 0.05)}\n                BackgroundColor={Color3.fromHex(\"#FFFFFF\")}\n                onMouseButton1Down={onCursor1Down}\n                onMouseButton1Up={onCursor1Up}\n            >\n                <uicorner CornerRadius={new UDim(0, 6)} />\n\n                <Div BackgroundColor={StyleColors.FullWhite}>\n                    <uicorner CornerRadius={new UDim(0, 6)} />\n                    <uigradient\n                        Color={\n                            pickerAPIRef.current === undefined\n                                ? blackGradient\n                                : new ColorSequence([\n                                      new ColorSequenceKeypoint(0, Color3.fromHSV(pickerAPIRef.current.hue, 1, 1)),\n                                      new ColorSequenceKeypoint(1, Color3.fromHSV(pickerAPIRef.current.hue, 1, 1)),\n                                  ])\n                        }\n                        Transparency={transparency}\n                        Rotation={180}\n                    />\n                    <uistroke Color={StyleColors.Background} Thickness={1} />\n                </Div>\n                <Div BackgroundColor={StyleColors.FullWhite}>\n                    <uicorner CornerRadius={new UDim(0, 6)} />\n                    <uigradient Color={blackGradient} Transparency={transparency} Rotation={-90} />\n                    <uistroke Color={StyleColors.Background} Thickness={1} />\n                </Div>\n                <Div>\n                    <uipadding\n                        PaddingTop={new UDim(0, 6)}\n                        PaddingBottom={new UDim(0, 6)}\n                        PaddingLeft={new UDim(0, 6)}\n                        PaddingRight={new UDim(0, 6)}\n                    />\n\n                    <PickerCursor Position={getCursor1Position()} />\n                </Div>\n            </Div>\n            {}\n            <Div\n                AnchorPoint={new Vector2(0.5, 0.5)}\n                Position={UDim2.fromScale(0.5, 0.67)}\n                Size={new UDim2(0.8, 0, 0, 10)}\n                BackgroundColor={Color3.fromHex(\"#FFFFFF\")}\n                onMouseButton1Down={onCursor2Down}\n                onMouseButton1Up={onCursor2Up}\n            >\n                <uicorner CornerRadius={new UDim(0, 6)} />\n                <uigradient Color={hueRangeGradient} />\n                <uipadding PaddingLeft={new UDim(0, 6)} PaddingRight={new UDim(0, 6)} />\n\n                <PickerCursor Position={getCursor2Position()} />\n            </Div>\n            {}\n            <Div\n                AnchorPoint={new Vector2(0.5, 0)}\n                Position={UDim2.fromScale(0.5, 0.75)}\n                Size={UDim2.fromScale(1, 0.25)}\n                BackgroundColor={StyleColors.Primary}\n            >\n                <uipadding\n                    PaddingLeft={new UDim(0.05, 10)}\n                    PaddingRight={new UDim(0.05, 10)}\n                    PaddingTop={new UDim(0.05, 10)}\n                    PaddingBottom={new UDim(0.05, 10)}\n                />\n                <uilistlayout FillDirection={\"Horizontal\"} Padding={new UDim(0, 10)} />\n\n                <Div Size={UDim2.fromScale(0.8, 1)}>\n                    <uilistlayout FillDirection={\"Vertical\"} Padding={new UDim(0, 10)} />\n\n                    <Div Size={new UDim2(1, 0, 0.5, -5)}>\n                        <uilistlayout FillDirection={\"Horizontal\"} Padding={new UDim(0.05, 0)} />\n\n                        <Div Size={UDim2.fromScale(0.3, 1)}>\n                            <BasicTextLabel Size={UDim2.fromScale(0.2, 1)} Text={\"R: \"} IsAffectedByZoom={false} />\n                            <NumberInput\n                                Position={UDim2.fromScale(0.25, 0)}\n                                Size={UDim2.fromScale(0.75, 1)}\n                                Text={() => tostring(getRGB().R)}\n                                NumberChanged={rChanged}\n                                IsAffectedByZoom={false}\n                            />\n                        </Div>\n                        <Div Size={UDim2.fromScale(0.3, 1)}>\n                            <BasicTextLabel Size={UDim2.fromScale(0.2, 1)} Text={\"G: \"} IsAffectedByZoom={false} />\n                            <NumberInput\n                                Position={UDim2.fromScale(0.25, 0)}\n                                Size={UDim2.fromScale(0.75, 1)}\n                                Text={() => tostring(getRGB().G)}\n                                NumberChanged={gChanged}\n                                IsAffectedByZoom={false}\n                            />\n                        </Div>\n                        <Div Size={UDim2.fromScale(0.3, 1)}>\n                            <BasicTextLabel Size={UDim2.fromScale(0.2, 1)} Text={\"B: \"} IsAffectedByZoom={false} />\n                            <NumberInput\n                                Position={UDim2.fromScale(0.25, 0)}\n                                Size={UDim2.fromScale(0.75, 1)}\n                                Text={() => tostring(getRGB().B)}\n                                NumberChanged={bChanged}\n                                IsAffectedByZoom={false}\n                            />\n                        </Div>\n                    </Div>\n                    <Div Position={UDim2.fromScale(0.2, 0)} Size={new UDim2(0.6, 0, 0.5, -5)}>\n                        <BasicTextLabel Size={UDim2.fromScale(0.2, 1)} Text={\"Hex: \"} IsAffectedByZoom={false} />\n                        <TextInput\n                            Position={UDim2.fromScale(0.25, 0)}\n                            Size={UDim2.fromScale(0.75, 1)}\n                            Text={() => getHex().upper()}\n                            TextChanged={hexChanged}\n                            LostFocus={hexLostFocus}\n                            IsAffectedByZoom={false}\n                        />\n                    </Div>\n                </Div>\n                <Div\n                    Size={new UDim2(0.2, -10, 1, 0)}\n                    BackgroundColor={pickerAPIRef.current === undefined ? StyleColors.FullWhite : pickerAPIRef.current.GetColor()}\n                />\n            </Div>\n        </Div>\n    );\n}\n\n'Lumina/src/Main.server.ts'\n:import CheckForUpdates from \"UpdateChecker/CheckForUpdates\";\nimport { GetWindow, InitializeWindows, Windows } from \"Windows/WindowSevice\";\nInitializeWindows(plugin);\nCheckForUpdates(plugin);\n\nimport { InitializeLineGraph } from \"Components/Windows/Line/LineGraph\";\nimport { InitializeColorPicker } from \"Components/Windows/Pickers.tsx/ColorPicker\";\nimport { InitializeColorRamp } from \"Components/Windows/Ramps/ColorRamp\";\nimport { InitUI } from \"UIHandler\";\n\nconst toolbar = plugin.CreateToolbar(\"Lumina 0.2.1\");\n\n\n\n\n\n\n\nconst mainButton = toolbar.CreateButton(\"Lumina\", \"Opens VFX Graph\", \"rbxassetid:\n\nconst window = GetWindow(Windows.Lumina);\nwindow.ZIndexBehavior = Enum.ZIndexBehavior.Sibling;\n\nmainButton.Click.Connect(() => {\n    window.Enabled = !window.Enabled;\n});\n\nInitUI();\n\nInitializeLineGraph();\nInitializeColorPicker();\nInitializeColorRamp();\n\n'Lumina/src/Components/Windows/Pickers.tsx/PickerCursor.tsx'\n:import React from \"@rbxts/react\";\nimport Div from \"Components/Div\";\nimport { StyleColors } from \"Style\";\n\ninterface Props {\n    Position: UDim2;\n}\n\nexport default function PickerCursor({ Position }: Props) {\n    return (\n        <Div AnchorPoint={new Vector2(0.5, 0.5)} Position={Position} Size={UDim2.fromOffset(6, 6)}>\n            <Div>\n                <uicorner CornerRadius={new UDim(1, 0)} />\n                <uistroke Color={StyleColors.FullWhite} Thickness={3} />\n            </Div>\n        </Div>\n    );\n}\n",
        "gt": [
            "'Lumina/src/Components/Windows/Pickers.tsx/PickerCursor.tsx'",
            "'Lumina/src/Components/Windows/Pickers.tsx/ColorPicker.tsx'",
            "'Lumina/src/Components/Windows/Ramps/ColorRamp.tsx'",
            "'Lumina/src/Main.server.ts'"
        ]
    },
    {
        "files": [
            "'confetti-cannon/src/UpdatableValue.tsx'",
            "'confetti-cannon/src/components/useConfettiCannon.tsx'",
            "'confetti-cannon/src/createConfetti.ts'"
        ],
        "content": "'confetti-cannon/src/UpdatableValue.tsx'\n:export abstract class UpdatableValue {\n  value: number;\n\n  constructor(value: number) {\n    this.value = value;\n  }\n\n  abstract update(deltaTime: number): void;\n  abstract previewUpdate(deltaTime: number): number;\n}\n\nexport class UpdatableVector2Value {\n  _x: UpdatableValue;\n  _y: UpdatableValue;\n\n  constructor(x: UpdatableValue, y: UpdatableValue) {\n    this._x = x;\n    this._y = y;\n  }\n\n  update(deltaTime: number) {\n    this._x.update(deltaTime);\n    this._y.update(deltaTime);\n  }\n\n  previewUpdate(deltaTime: number) {\n    return {\n      x: this._x.previewUpdate(deltaTime),\n      y: this._y.previewUpdate(deltaTime),\n    };\n  }\n\n  get x() {\n    return this._x.value;\n  }\n\n  set x(x: number) {\n    this._x.value = x;\n  }\n\n  get y() {\n    return this._y.value;\n  }\n\n  set y(y: number) {\n    this._y.value = y;\n  }\n}\n\nexport class UpdatableVector3Value extends UpdatableVector2Value {\n  _z: UpdatableValue;\n\n  constructor(x: UpdatableValue, y: UpdatableValue, z: UpdatableValue) {\n    super(x, y);\n    this._z = z;\n  }\n\n  update(deltaTime: number) {\n    super.update(deltaTime);\n    this._z.update(deltaTime);\n  }\n\n  previewUpdate(deltaTime: number) {\n    const superUpdate = super.previewUpdate(deltaTime);\n    return {\n      ...superUpdate,\n      z: this._z.previewUpdate(deltaTime),\n    };\n  }\n\n  get z() {\n    return this._z.value;\n  }\n\n  set z(z: number) {\n    this._z.value = z;\n  }\n}\n\n'confetti-cannon/src/components/useConfettiCannon.tsx'\n:import * as React from \"react\";\nimport Confetti from \"../Confetti\";\nimport { SpriteProp } from \"../Types\";\nimport { CreateConfettiArgs } from \"../createConfetti\";\nimport { ConfettiCanvasHandle } from \"./ConfettiCanvas\";\nimport { SpriteCanvasHandle } from \"./SpriteCanvas\";\n\nexport interface CreateConfettiRequestedOptions {\n  sprite?: SpriteProp;\n  color?: string;\n}\n\nexport interface ConfettiCannon {\n  createConfetti: (\n    createConfettiArgs: CreateConfettiArgs,\n    createConfettiRequestedOptions?: CreateConfettiRequestedOptions\n  ) => Confetti | undefined;\n  createMultipleConfetti: (\n    createConfettiArgs: CreateConfettiArgs,\n    numberToFire: number,\n    createConfettiRequestedOptions?: CreateConfettiRequestedOptions\n  ) => Confetti[];\n  addConfetti: (confetti: Confetti) => void;\n  deleteConfetti: (id: string) => void;\n  clearConfetti: () => void;\n  isReady: boolean;\n}\n\nexport default function useConfettiCannon(\n  confettiCanvas: ConfettiCanvasHandle | null,\n  spriteCanvas: SpriteCanvasHandle | null\n): ConfettiCannon {\n  const [isReady, setIsReady] = React.useState(spriteCanvas?.isReady ?? false);\n\n  React.useEffect(() => {\n    const listenerId = spriteCanvas?.addReadyListener(setIsReady);\n\n    return () => {\n      if (listenerId != null) {\n        spriteCanvas?.removeReadyListener(listenerId);\n      }\n    };\n  }, [spriteCanvas]);\n\n  const createConfetti = React.useCallback(\n    (\n      createConfettiArgs: CreateConfettiArgs,\n      { sprite, color }: CreateConfettiRequestedOptions = {}\n    ) => {\n      const spriteData = spriteCanvas?.getCreateData();\n      const spriteCanvasRef = spriteCanvas?.getCanvas();\n\n      if (\n        spriteCanvasRef == null ||\n        spriteData == null ||\n        spriteData.sprites.length === 0\n      ) {\n        return;\n      }\n\n      return confettiCanvas?.createConfetti(\n        createConfettiArgs,\n        spriteCanvasRef,\n        spriteData,\n        sprite,\n        color\n      );\n    },\n    [confettiCanvas, spriteCanvas]\n  );\n  const createMultipleConfetti = React.useCallback(\n    (\n      createConfettiArgs: CreateConfettiArgs,\n      numConfetti: number,\n      createConfettiRequestedOptions?: CreateConfettiRequestedOptions\n    ) => {\n      const createdConfetti: Confetti[] = [];\n\n      for (let i = 0; i < numConfetti; i++) {\n        const confetti = createConfetti(\n          createConfettiArgs,\n          createConfettiRequestedOptions\n        );\n        if (confetti) {\n          createdConfetti.push(confetti);\n        }\n      }\n\n      return createdConfetti;\n    },\n    [createConfetti]\n  );\n\n  const addConfetti = React.useCallback(\n    (confetti: Confetti) => {\n      const spriteCanvasRef = spriteCanvas?.getCanvas();\n      if (spriteCanvasRef != null) {\n        confettiCanvas?.addConfetti(confetti, spriteCanvasRef);\n      }\n    },\n    [confettiCanvas, spriteCanvas]\n  );\n\n  const deleteConfetti = React.useCallback(\n    (id: string) => {\n      confettiCanvas?.deleteConfetti(id);\n    },\n    [confettiCanvas]\n  );\n\n  const clearConfetti = React.useCallback(\n    () => confettiCanvas?.clearConfetti(),\n    [confettiCanvas]\n  );\n\n  return React.useMemo(\n    () => ({\n      createConfetti,\n      createMultipleConfetti,\n      addConfetti,\n      clearConfetti,\n      deleteConfetti,\n      isReady: isReady && spriteCanvas != null && confettiCanvas != null,\n    }),\n    [\n      addConfetti,\n      clearConfetti,\n      confettiCanvas,\n      createConfetti,\n      createMultipleConfetti,\n      deleteConfetti,\n      isReady,\n      spriteCanvas,\n    ]\n  );\n}\n\n'confetti-cannon/src/createConfetti.ts'\n:import Confetti from \"./Confetti\";\nimport { CREATE_CONFETTI_DEFAULTS } from \"./Constants\";\nimport { SPRITE_SPACING } from \"./ConstantsInternal\";\nimport {\n  SpriteProp,\n  Vector2,\n  Vector2Template,\n  Vector3,\n  Vector3Template,\n} from \"./Types\";\nimport { UpdatableVector2Value, UpdatableVector3Value } from \"./UpdatableValue\";\nimport {\n  LinearUpdatableValue,\n  OscillatingUpdatableValue,\n  StaticUpdatableValue,\n} from \"./UpdatableValueImplementations\";\nimport { Sprite, SpriteCanvasData } from \"./components/SpriteCanvas\";\nimport { EasingFunction } from \"./easing\";\n\ninterface StaticConfigConstant<T> {\n  type: \"static\";\n  value: T;\n}\n\ninterface StaticConfigRandom<T> {\n  type: \"static-random\";\n  minValue: T;\n  maxValue: T;\n}\n\ntype StaticConfig<T> = StaticConfigConstant<T> | StaticConfigRandom<T>;\n\ninterface LinearConfigConstant<T> {\n  type: \"linear\";\n  value: T;\n  addValue: T;\n}\n\ninterface LinearConfigRandom<T> {\n  type: \"linear-random\";\n  minValue: T;\n  maxValue: T;\n  minAddValue: T;\n  maxAddValue: T;\n}\n\ntype LinearConfig<T> = LinearConfigConstant<T> | LinearConfigRandom<T>;\n\ntype Direction = 1 | -1;\ntype DirectionVector2 = { x: Direction; y: Direction };\ntype DirectionVector3 = DirectionVector2 & { z: Direction };\n\ninterface OscillatingConfigConstant<T, TDirection> {\n  type: \"oscillating\";\n  value: T;\n  start: T;\n  final: T;\n  duration: T;\n  direction: TDirection;\n  easingFunction: EasingFunction;\n}\n\ninterface OscillatingConfigRandom<T, TDirection> {\n  type: \"oscillating-random\";\n  minValue: T;\n  maxValue: T;\n  minStart: T;\n  maxStart: T;\n  minFinal: T;\n  maxFinal: T;\n  minDuration: T;\n  maxDuration: T;\n  minDirection: TDirection;\n  maxDirection: TDirection;\n  easingFunctions: EasingFunction[];\n}\n\ntype OscillatingConfig<T, TDirection> =\n  | OscillatingConfigConstant<T, TDirection>\n  | OscillatingConfigRandom<T, TDirection>;\n\ntype Config<T, TDirection> =\n  | StaticConfig<T>\n  | LinearConfig<T>\n  | OscillatingConfig<T, TDirection>;\n\ntype ConfigNumber = Config<number, Direction>;\ntype ConfigVector2 = Config<Vector2, DirectionVector2>;\ntype ConfigVector3 = Config<Vector3, DirectionVector3>;\n\ntype ConfigNumberInput = ConfigNumber;\ntype ConfigVector2Input = ConfigVector2 | ConfigNumber;\ntype ConfigVector3Input = ConfigVector3 | ConfigNumber;\n\nexport interface CreateConfettiArgsFull {\n  id?: string;\n  position: ConfigVector2;\n  velocity: ConfigVector2;\n  rotation: ConfigVector3;\n  dragCoefficient: ConfigVector2;\n  airResistanceArea?: ConfigVector2Input;\n  size: ConfigNumber;\n  opacity: ConfigNumber;\n}\n\nexport type CreateConfettiArgs = {\n  id?: string;\n  position: ConfigVector2Input;\n  velocity?: ConfigVector2Input;\n  rotation?: ConfigVector3Input;\n  dragCoefficient?: ConfigVector2Input;\n  airResistanceArea?: ConfigVector2Input;\n  size: ConfigVector2Input;\n  opacity?: ConfigNumberInput;\n};\n\ntype CreateConfettiArgsFullInput = Required<CreateConfettiArgs>;\n\ntype ConfigNumberAnnotated = ConfigNumberInput & {\n  valueType: \"number\";\n};\ntype ConfigVector2Annotated = ConfigVector2Input & {\n  valueType: \"Vector2\";\n};\ntype ConfigVector3Annotated = ConfigVector3Input & {\n  valueType: \"Vector3\";\n};\n\nfunction getRandomValue(min: number, max: number) {\n  if (min === max) {\n    return min;\n  }\n  return Math.random() * (max - min + 1) + min;\n}\n\nfunction getRandomFromList<T>(list: T[]): [T, number] {\n  const index = Math.floor(getRandomValue(0, list.length - 1));\n  const value = list[index];\n  return [value, index];\n}\n\nfunction getRandomDirection(min: Direction, max: Direction): Direction {\n  return getRandomFromList([min, max])[0];\n}\n\nfunction getVector2<T extends number>(input: Vector2Template<T> | T) {\n  if (typeof input === \"number\") {\n    return { x: input, y: input };\n  }\n  return input;\n}\n\nfunction getVector3<T extends number>(input: Vector3Template<T> | T) {\n  if (typeof input === \"number\") {\n    return { x: input, y: input, z: input };\n  }\n  return input;\n}\n\nfunction getValueNumberAnnotated(config: ConfigNumberAnnotated) {\n  switch (config.type) {\n    case \"static\":\n      return new StaticUpdatableValue(config.value);\n    case \"static-random\":\n      return new StaticUpdatableValue(\n        getRandomValue(config.minValue, config.maxValue)\n      );\n    case \"linear\":\n      return new LinearUpdatableValue(config.value, config.addValue);\n    case \"linear-random\":\n      return new LinearUpdatableValue(\n        getRandomValue(config.minValue, config.maxValue),\n        getRandomValue(config.minAddValue, config.maxAddValue)\n      );\n    case \"oscillating\":\n      return new OscillatingUpdatableValue(\n        config.value,\n        config.start,\n        config.final,\n        config.duration,\n        config.direction,\n        config.easingFunction\n      );\n    case \"oscillating-random\":\n      return new OscillatingUpdatableValue(\n        getRandomValue(config.minValue, config.maxValue),\n        getRandomValue(config.minStart, config.maxStart),\n        getRandomValue(config.minFinal, config.maxFinal),\n        getRandomValue(config.minDuration, config.maxDuration),\n        getRandomDirection(config.minDirection, config.maxDirection),\n        getRandomFromList(config.easingFunctions)[0]\n      );\n  }\n}\n\nfunction getValueVector2Annotated(config: ConfigVector2Annotated) {\n  switch (config.type) {\n    case \"static\": {\n      const value = getVector2(config.value);\n      return new UpdatableVector2Value(\n        new StaticUpdatableValue(value.x),\n        new StaticUpdatableValue(value.y)\n      );\n    }\n    case \"static-random\": {\n      const minValue = getVector2(config.minValue);\n      const maxValue = getVector2(config.maxValue);\n      return new UpdatableVector2Value(\n        new StaticUpdatableValue(getRandomValue(minValue.x, maxValue.x)),\n        new StaticUpdatableValue(getRandomValue(minValue.y, maxValue.y))\n      );\n    }\n    case \"linear\": {\n      const value = getVector2(config.value);\n      const addValue = getVector2(config.addValue);\n      return new UpdatableVector2Value(\n        new LinearUpdatableValue(value.x, addValue.x),\n        new LinearUpdatableValue(value.y, addValue.y)\n      );\n    }\n    case \"linear-random\": {\n      const minValue = getVector2(config.minValue);\n      const maxValue = getVector2(config.maxValue);\n      const minAddValue = getVector2(config.minAddValue);\n      const maxAddValue = getVector2(config.maxAddValue);\n      return new UpdatableVector2Value(\n        new LinearUpdatableValue(\n          getRandomValue(minValue.x, maxValue.x),\n          getRandomValue(minAddValue.x, maxAddValue.x)\n        ),\n        new LinearUpdatableValue(\n          getRandomValue(minValue.y, maxValue.y),\n          getRandomValue(minAddValue.x, maxAddValue.x)\n        )\n      );\n    }\n    case \"oscillating\": {\n      const value = getVector2(config.value);\n      const start = getVector2(config.start);\n      const final = getVector2(config.final);\n      const duration = getVector2(config.duration);\n      const direction = getVector2(config.direction);\n      return new UpdatableVector2Value(\n        new OscillatingUpdatableValue(\n          value.x,\n          start.x,\n          final.x,\n          duration.x,\n          direction.x,\n          config.easingFunction\n        ),\n        new OscillatingUpdatableValue(\n          value.y,\n          start.y,\n          final.y,\n          duration.x,\n          direction.y,\n          config.easingFunction\n        )\n      );\n    }\n    case \"oscillating-random\": {\n      const minValue = getVector2(config.minValue);\n      const maxValue = getVector2(config.maxValue);\n      const minStart = getVector2(config.minStart);\n      const maxStart = getVector2(config.maxStart);\n      const minFinal = getVector2(config.minFinal);\n      const maxFinal = getVector2(config.maxFinal);\n      const minDuration = getVector2(config.minDuration);\n      const maxDuration = getVector2(config.maxDuration);\n      const minDirection = getVector2(config.minDirection);\n      const maxDirection = getVector2(config.maxDirection);\n      return new UpdatableVector2Value(\n        new OscillatingUpdatableValue(\n          getRandomValue(minValue.x, maxValue.x),\n          getRandomValue(minStart.x, maxStart.x),\n          getRandomValue(minFinal.x, maxFinal.x),\n          getRandomValue(minDuration.x, maxDuration.x),\n          getRandomDirection(minDirection.x, maxDirection.x),\n          getRandomFromList(config.easingFunctions)[0]\n        ),\n        new OscillatingUpdatableValue(\n          getRandomValue(minValue.y, maxValue.y),\n          getRandomValue(minStart.y, maxStart.y),\n          getRandomValue(minFinal.y, maxFinal.y),\n          getRandomValue(minDuration.y, maxDuration.y),\n          getRandomDirection(minDirection.y, maxDirection.y),\n          getRandomFromList(config.easingFunctions)[0]\n        )\n      );\n    }\n  }\n}\n\nfunction getValueVector3Annotated(config: ConfigVector3Annotated) {\n  switch (config.type) {\n    case \"static\": {\n      const value = getVector3(config.value);\n      return new UpdatableVector3Value(\n        new StaticUpdatableValue(value.x),\n        new StaticUpdatableValue(value.y),\n        new StaticUpdatableValue(value.z)\n      );\n    }\n    case \"static-random\": {\n      const minValue = getVector3(config.minValue);\n      const maxValue = getVector3(config.maxValue);\n      return new UpdatableVector3Value(\n        new StaticUpdatableValue(getRandomValue(minValue.x, maxValue.x)),\n        new StaticUpdatableValue(getRandomValue(minValue.y, maxValue.y)),\n        new StaticUpdatableValue(getRandomValue(minValue.z, maxValue.z))\n      );\n    }\n    case \"linear\": {\n      const value = getVector3(config.value);\n      const addValue = getVector3(config.addValue);\n      return new UpdatableVector3Value(\n        new LinearUpdatableValue(value.x, addValue.x),\n        new LinearUpdatableValue(value.y, addValue.y),\n        new LinearUpdatableValue(value.z, addValue.z)\n      );\n    }\n    case \"linear-random\": {\n      const minValue = getVector3(config.minValue);\n      const maxValue = getVector3(config.maxValue);\n      const minAddValue = getVector3(config.minAddValue);\n      const maxAddValue = getVector3(config.maxAddValue);\n      return new UpdatableVector3Value(\n        new LinearUpdatableValue(\n          getRandomValue(minValue.x, maxValue.x),\n          getRandomValue(minAddValue.x, maxAddValue.x)\n        ),\n        new LinearUpdatableValue(\n          getRandomValue(minValue.y, maxValue.y),\n          getRandomValue(minAddValue.y, maxAddValue.y)\n        ),\n        new LinearUpdatableValue(\n          getRandomValue(minValue.z, maxValue.z),\n          getRandomValue(minAddValue.z, maxAddValue.z)\n        )\n      );\n    }\n    case \"oscillating\": {\n      const value = getVector3(config.value);\n      const start = getVector3(config.start);\n      const final = getVector3(config.final);\n      const duration = getVector3(config.duration);\n      const direction = getVector3(config.direction);\n      return new UpdatableVector3Value(\n        new OscillatingUpdatableValue(\n          value.x,\n          start.x,\n          final.x,\n          duration.x,\n          direction.x,\n          config.easingFunction\n        ),\n        new OscillatingUpdatableValue(\n          value.y,\n          start.y,\n          final.y,\n          duration.z,\n          direction.y,\n          config.easingFunction\n        ),\n        new OscillatingUpdatableValue(\n          value.z,\n          start.z,\n          final.z,\n          duration.z,\n          direction.z,\n          config.easingFunction\n        )\n      );\n    }\n    case \"oscillating-random\": {\n      const minValue = getVector3(config.minValue);\n      const maxValue = getVector3(config.maxValue);\n      const minStart = getVector3(config.minStart);\n      const maxStart = getVector3(config.maxStart);\n      const minFinal = getVector3(config.minFinal);\n      const maxFinal = getVector3(config.maxFinal);\n      const minDuration = getVector3(config.minDuration);\n      const maxDuration = getVector3(config.maxDuration);\n      const minDirection = getVector3(config.minDirection);\n      const maxDirection = getVector3(config.maxDirection);\n      return new UpdatableVector3Value(\n        new OscillatingUpdatableValue(\n          getRandomValue(minValue.x, maxValue.x),\n          getRandomValue(minStart.x, maxStart.x),\n          getRandomValue(minFinal.x, maxFinal.x),\n          getRandomValue(minDuration.x, maxDuration.x),\n          getRandomDirection(minDirection.x, maxDirection.x),\n          getRandomFromList(config.easingFunctions)[0]\n        ),\n        new OscillatingUpdatableValue(\n          getRandomValue(minValue.y, maxValue.y),\n          getRandomValue(minStart.y, maxStart.y),\n          getRandomValue(minFinal.y, maxFinal.y),\n          getRandomValue(minDuration.y, maxDuration.y),\n          getRandomDirection(minDirection.y, maxDirection.y),\n          getRandomFromList(config.easingFunctions)[0]\n        ),\n        new OscillatingUpdatableValue(\n          getRandomValue(minValue.z, maxValue.z),\n          getRandomValue(minStart.z, maxStart.z),\n          getRandomValue(minFinal.z, maxFinal.z),\n          getRandomValue(minDuration.z, maxDuration.z),\n          getRandomDirection(minDirection.z, maxDirection.z),\n          getRandomFromList(config.easingFunctions)[0]\n        )\n      );\n    }\n  }\n}\n\nfunction provideDefaults(\n  args: CreateConfettiArgs,\n  id: string\n): CreateConfettiArgsFullInput {\n  return {\n    id,\n    ...CREATE_CONFETTI_DEFAULTS,\n    ...args,\n  };\n}\n\nfunction shouldColorizeSprite(sprite: SpriteProp) {\n  if (typeof sprite === \"string\") {\n    return true;\n  }\n  return sprite.colorize;\n}\n\nfunction spriteEquals(spriteA: Sprite, spriteB: SpriteProp) {\n  if (typeof spriteB === \"string\") {\n    return spriteA.src === spriteB && spriteA.colorize;\n  }\n  return spriteA.src === spriteB.src && spriteA.colorize === spriteB.colorize;\n}\n\nfunction getSpriteWithIndex(\n  requestedSprite: SpriteProp | undefined,\n  spriteCanvasData: SpriteCanvasData\n): [SpriteProp, number] {\n  if (requestedSprite != null) {\n    const index = spriteCanvasData.sprites.findIndex((sprite) =>\n      spriteEquals(sprite, requestedSprite)\n    );\n    if (index !== -1) {\n      return [requestedSprite, index];\n    }\n  }\n  return getRandomFromList(spriteCanvasData.sprites);\n}\n\nfunction getColorIndex(\n  sprite: SpriteProp,\n  requestedColor: string | undefined | null,\n  spriteCanvasData: SpriteCanvasData\n) {\n  if (!shouldColorizeSprite(sprite)) {\n    return 0;\n  }\n  const index =\n    requestedColor != null\n      ? spriteCanvasData.colors.findIndex((color) => color === requestedColor)\n      : -1;\n  return index !== -1\n    ? index\n    : Math.floor(getRandomValue(0, spriteCanvasData.colors.length - 1));\n}\n\nexport function getUpdatableValueNumber(config: ConfigNumber) {\n  return getValueNumberAnnotated({ ...config, valueType: \"number\" });\n}\n\nexport function getUpdatableValueVector2(config: ConfigVector2Input) {\n  return getValueVector2Annotated({ ...config, valueType: \"Vector2\" });\n}\n\nexport function getUpdatableValueVector3(config: ConfigVector3Input) {\n  return getValueVector3Annotated({ ...config, valueType: \"Vector3\" });\n}\n\nexport default function createConfetti(\n  id: string,\n  rawArgs: CreateConfettiArgs,\n  spriteCanvasData: SpriteCanvasData,\n  requestedSprite?: SpriteProp,\n  requestedColor?: string | null\n) {\n  const args = provideDefaults(rawArgs, id);\n\n  const size = getUpdatableValueVector2(args.size);\n\n  const [sprite, spriteIndex] = getSpriteWithIndex(\n    requestedSprite,\n    spriteCanvasData\n  );\n  const colorIndex = getColorIndex(\n    requestedSprite ?? sprite,\n    requestedColor,\n    spriteCanvasData\n  );\n\n  return new Confetti({\n    id,\n    position: getUpdatableValueVector2(args.position),\n    velocity: getUpdatableValueVector2(args.velocity),\n    rotation: getUpdatableValueVector3(args.rotation),\n    dragCoefficient: getUpdatableValueVector2(args.dragCoefficient),\n    size,\n    opacity: getUpdatableValueNumber(args.opacity),\n    airResistanceArea: getUpdatableValueVector2(args.airResistanceArea),\n    spriteX:\n      colorIndex * spriteCanvasData.spriteWidth + colorIndex * SPRITE_SPACING,\n    spriteY:\n      spriteIndex * spriteCanvasData.spriteHeight +\n      spriteIndex * SPRITE_SPACING,\n    spriteWidth: spriteCanvasData.spriteWidth,\n    spriteHeight: spriteCanvasData.spriteHeight,\n  });\n}\n",
        "gt": [
            "'confetti-cannon/src/UpdatableValue.tsx'",
            "'confetti-cannon/src/createConfetti.ts'",
            "'confetti-cannon/src/components/useConfettiCannon.tsx'"
        ]
    },
    {
        "files": [
            "'lemmy-fennec/components/Post/ImageViewer.tsx'",
            "'lemmy-fennec/components/Post/TinyPost.tsx'",
            "'lemmy-fennec/App.tsx'",
            "'lemmy-fennec/Screens/Feed/FeedScreen.tsx'",
            "'lemmy-fennec/components/Post/Media.tsx'",
            "'lemmy-fennec/Screens/HomeScreen.tsx'"
        ],
        "content": "'lemmy-fennec/components/Post/ImageViewer.tsx'\n:import React from \"react\";\nimport { StyleSheet, ToastAndroid, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { setImageAsync } from \"expo-clipboard\";\nimport { documentDirectory, downloadAsync } from \"expo-file-system\";\nimport {\n  addAssetsToAlbumAsync,\n  createAlbumAsync,\n  createAssetAsync,\n  getAlbumAsync,\n  usePermissions,\n} from \"expo-media-library\";\nimport ImageView from \"react-native-image-viewing\";\n\nimport { Icon, Text, TouchableOpacity } from \"../../ThemedComponents\";\n\ninterface Props {\n  url: string;\n  name: string;\n  visible: boolean;\n  setIsVisible: React.Dispatch<React.SetStateAction<boolean>>;\n  shareImage: () => void;\n}\n\nfunction ImageViewer({ url, name, visible, setIsVisible, shareImage }: Props) {\n  const [permissionResponse, askForPermission] = usePermissions({\n    writeOnly: true,\n  });\n  const { colors } = useTheme();\n  const safeName = name.length > 45 ? name.slice(0, 40) + \"...\" : name;\n\n  const handleDownload = async () => {\n    let fileUri = documentDirectory + `${safeName.replace(\" \", \"-\")}.jpg`;\n    try {\n      const res = await downloadAsync(url, fileUri);\n      await saveFile(res.uri);\n      ToastAndroid.showWithGravity(\n        \"Image saved\",\n        ToastAndroid.SHORT,\n        ToastAndroid.CENTER\n      );\n    } catch (err) {\n      ToastAndroid.showWithGravity(\n        \"Couldn't save image\",\n        ToastAndroid.SHORT,\n        ToastAndroid.CENTER\n      );\n      console.log(\"FS Err: \", err);\n    }\n  };\n\n  const copyImage = () => {\n    fetch(url)\n      .then((r) => r.blob())\n      .then((blob) => {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n        reader.onloadend = () => {\n          const base64data = reader.result.toString().split(\",\")[1];\n          setImageAsync(base64data.toString()).catch((err) =>\n            console.log(\"Copy err: \", err)\n          );\n        };\n      });\n  };\n\n  const saveFile = async (fileUri) => {\n    const shouldAsk =\n      permissionResponse?.granted === false &&\n      permissionResponse?.canAskAgain === true;\n    const saveToAlbum = async () => {\n      try {\n        const asset = await createAssetAsync(fileUri);\n        const album = await getAlbumAsync(\"Arctius\");\n        if (album === null) {\n          await createAlbumAsync(\"Arctius\", asset, false);\n        } else {\n          await addAssetsToAlbumAsync([asset], album, false);\n        }\n      } catch (err) {\n        console.log(\"Save err: \", err);\n      }\n    };\n    if (shouldAsk) {\n      askForPermission().then(async (res) => {\n        if (res.status === \"granted\") {\n          void saveToAlbum();\n        } else if (res.status === \"denied\") {\n          alert(\"please allow permissions to download\");\n        }\n      });\n    } else {\n      void saveToAlbum();\n    }\n  };\n  return (\n    <ImageView\n      images={[{ uri: url }]}\n      imageIndex={0}\n      visible={visible}\n      onRequestClose={() => setIsVisible(false)}\n      FooterComponent={() => (\n        <View style={{ ...styles.imgHeader, backgroundColor: colors.card }}>\n          <Text lines={1} style={{ fontSize: 14 }}>\n            {safeName}\n          </Text>\n          <View style={{ flexDirection: \"row\", gap: 16 }}>\n            <TouchableOpacity onPressCb={shareImage} simple>\n              <Icon\n                name={\"share-2\"}\n                accessibilityLabel={\"share post button\"}\n                size={24}\n              />\n            </TouchableOpacity>\n            <TouchableOpacity simple onPressCb={copyImage}>\n              <Icon\n                name={\"copy\"}\n                accessibilityLabel={\"copy post button\"}\n                size={24}\n              />\n            </TouchableOpacity>\n            <TouchableOpacity onPressCb={handleDownload} simple>\n              <Icon\n                name={\"download\"}\n                accessibilityLabel={\"download post button\"}\n                size={24}\n              />\n            </TouchableOpacity>\n          </View>\n        </View>\n      )}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  imgHeader: {\n    padding: 12,\n    alignItems: \"center\",\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    gap: 16,\n  },\n});\n\nexport default ImageViewer;\n\n'lemmy-fennec/components/Post/TinyPost.tsx'\n:\nimport React from \"react\";\nimport { Dimensions, Image, Share, StyleSheet, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { PostView } from \"lemmy-js-client\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { makeDateString } from \"../../utils/utils\";\nimport Media from \"./Media\";\nimport PostIconRow from \"./PostIconRow\";\nimport PostTitle from \"./PostTitle\";\n\nfunction TinyPost({\n  post,\n  navigation,\n  useCommunity,\n}: {\n  post: PostView;\n  useCommunity?: boolean;\n  navigation?: NativeStackScreenProps<any, \"Feed\">[\"navigation\"];\n}) {\n  const { colors } = useTheme();\n\n  const isNsfw = post.post.nsfw || post.community.nsfw;\n  const isPic = post.post.url\n    ? /\\.(jpeg|jpg|gif|png|webp)$/.test(post.post.url)\n    : false;\n  const dateStr = makeDateString(post.post.published);\n\n  const markRead = () => {\n    if (apiClient.loginDetails?.jwt) {\n      void apiClient.postStore.markPostRead(\n        {\n          post_ids: [post.post.id],\n          read: true,\n        },\n        useCommunity\n      );\n    }\n  };\n\n  const getCommunity = () => {\n    apiClient.postStore.setCommunityPosts([]);\n    apiClient.communityStore.setCommunity(null);\n    navigation.navigate(\"Community\", { id: post.community.id });\n  };\n\n  const getAuthor = () => {\n    navigation.navigate(\"User\", { personId: post.creator.id });\n  };\n\n  const getComments = () => {\n    apiClient.postStore.setSinglePost(post);\n    navigation.navigate(\"Post\", { post: post.post.id, openComment: 0 });\n  };\n\n  const customReadColor = post.read ? \"#ababab\" : colors.text;\n\n  return (\n    <View style={{ ...styles.container, borderColor: colors.border }}>\n      <PostTitle\n        post={post}\n        dateStr={dateStr}\n        getAuthor={getAuthor}\n        getCommunity={getCommunity}\n      />\n      <View style={styles.row}>\n        <TouchableOpacity\n          simple\n          onPressCb={() => {\n            apiClient.postStore.setSinglePost(post);\n            navigation.navigate(\"Post\", { post: post.post.id });\n          }}\n        >\n          {isPic ? (\n            <Media\n              url={post.post.url}\n              name={post.post.name}\n              isNsfw={isNsfw}\n              small\n            />\n          ) : (\n            <View style={{ ...styles.imageLike, backgroundColor: colors.card }}>\n              <Icon\n                name={\n                  post.post.url || post.post.embed_title ? \"link\" : \"align-left\"\n                }\n                size={54}\n              />\n            </View>\n          )}\n        </TouchableOpacity>\n        <View style={{ flex: 1, justifyContent: \"space-between\" }}>\n          <TouchableOpacity\n            simple\n            style={{ flex: 1, gap: 4 }}\n            onPressCb={() => {\n              apiClient.postStore.setSinglePost(post);\n              navigation.navigate(\"Post\", { post: post.post.id });\n            }}\n          >\n            <Text\n              customColor={customReadColor}\n              lines={2}\n              style={styles.postName}\n            >\n              {post.post.name}\n            </Text>\n          </TouchableOpacity>\n          <View style={{ flexDirection: \"row\", gap: 4, flex: 1 }}>\n            {isNsfw ? <Text style={{ color: \"red\" }}>NSFW</Text> : null}\n            <Text lines={1} style={styles.text}>\n              {post.post.body}\n            </Text>\n          </View>\n        </View>\n      </View>\n      <PostIconRow\n        post={post}\n        useCommunity={useCommunity}\n        markRead={markRead}\n        getComments={getComments}\n      />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: 8,\n    borderBottomWidth: 1,\n    width: Dimensions.get(\"window\").width,\n  },\n  postName: {\n    fontSize: 17,\n    fontWeight: \"500\",\n    marginTop: 4,\n    marginBottom: 8,\n  },\n  postImg: { width: 80, height: 80, borderRadius: 8 },\n  imageLike: {\n    width: 80,\n    height: 80,\n    borderRadius: 8,\n    justifyContent: \"center\",\n    alignItems: \"center\",\n  },\n  row: {\n    paddingVertical: 8,\n    flexDirection: \"row\",\n    alignItems: \"flex-start\",\n    gap: 16,\n  },\n  text: {\n    opacity: 0.8,\n  },\n});\n\nexport default observer(TinyPost);\n\n'lemmy-fennec/App.tsx'\n:import React from \"react\";\nimport { StatusBar, useColorScheme } from \"react-native\";\n\nimport { ActionSheetProvider } from \"@expo/react-native-action-sheet\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\n\nimport AddAccount from \"./Screens/AddAccount\";\nimport BlocksScreen from \"./Screens/Blocks/BlocksScreen\";\nimport CommentWrite from \"./Screens/CommentWrite/CommentWrite\";\nimport CommunityScreen from \"./Screens/Community/CommunityScreen\";\nimport DebugScreen from \"./Screens/DebugScreen\";\nimport HomeScreen from \"./Screens/HomeScreen\";\nimport LoginScreen from \"./Screens/LoginScreen\";\nimport PostScreen from \"./Screens/Post/PostScreen\";\nimport PostWrite from \"./Screens/PostWrite\";\nimport Behavior from \"./Screens/Settings/Behavior\";\nimport Looks from \"./Screens/Settings/Looks\";\nimport ProfileSettings from \"./Screens/Settings/ProfileSettings\";\nimport SettingsScreen from \"./Screens/SettingsScreen\";\nimport MessageWrite from \"./Screens/Unreads/MessageWrite\";\nimport UserScreen from \"./Screens/User/UserScreen\";\nimport { Icon } from \"./ThemedComponents\";\nimport { AppAmoledTheme, AppDarkTheme, AppTheme } from \"./commonStyles\";\nimport Prompt from \"./components/Prompt\";\nimport { ReportMode, apiClient } from \"./store/apiClient\";\nimport { Theme, preferences } from \"./store/preferences\";\n\nconst Stack = createNativeStackNavigator();\n\nconst App = observer(() => {\n  const scheme = useColorScheme();\n\n  const systemTheme = scheme === \"dark\" ? AppDarkTheme : AppTheme;\n  const isLightStatusBar =\n    preferences.theme === Theme.System\n      ? scheme !== \"dark\"\n      : preferences.theme === Theme.Light;\n\n  const schemeMap = {\n    [Theme.System]: systemTheme,\n    [Theme.Light]: AppTheme,\n    [Theme.Dark]: AppDarkTheme,\n    [Theme.Amoled]: AppAmoledTheme,\n  };\n\n  const sendReport = (text: string) => {\n    if (apiClient.reportMode === ReportMode.Post) {\n      apiClient.api\n        .createPostReport({\n          post_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    } else {\n      apiClient.api\n        .createCommentReport({\n          comment_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    }\n  };\n\n  const closeReport = () => {\n    apiClient.setShowPrompt(false);\n  };\n\n  const reportMode = apiClient.reportMode;\n  const promptActions =\n    reportMode !== ReportMode.Off\n      ? {\n          onCancel: closeReport,\n          onConfirm: sendReport,\n        }\n      : apiClient.promptActions;\n  return (\n    <SafeAreaProvider style={{ flex: 1 }}>\n      {}\n      <StatusBar\n        barStyle={isLightStatusBar ? \"dark-content\" : \"light-content\"}\n        backgroundColor={schemeMap[preferences.theme].colors.card}\n      />\n      <ActionSheetProvider>\n        <NavigationContainer theme={schemeMap[preferences.theme]}>\n          <Stack.Navigator initialRouteName={\"Home\"}>\n            <Stack.Screen\n              name=\"Home\"\n              component={HomeScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              name=\"Post\"\n              component={PostScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Comment\" }}\n              name={\"CommentWrite\"}\n              component={CommentWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Post\" }}\n              name={\"PostWrite\"}\n              component={PostWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"Message\" }}\n              name={\"MessageWrite\"}\n              component={MessageWrite}\n            />\n            <Stack.Screen\n              options={{\n                headerRight: () => <Icon name={\"arrow-up\"} size={24} />,\n              }}\n              name=\"Community\"\n              component={CommunityScreen}\n            />\n            <Stack.Screen name=\"Login\" component={LoginScreen} />\n            <Stack.Screen\n              options={{ headerTitle: \"Add Account\" }}\n              name={\"AddAccount\"}\n              component={AddAccount}\n            />\n            <Stack.Screen name=\"User\" component={UserScreen} />\n            <Stack.Screen name=\"Settings\" component={SettingsScreen} />\n            <Stack.Screen name=\"Debug\" component={DebugScreen} />\n            <Stack.Screen name=\"Blocks\" component={BlocksScreen} />\n            <Stack.Screen name=\"Looks\" component={Looks} />\n            <Stack.Screen name=\"Behavior\" component={Behavior} />\n            <Stack.Screen name=\"ProfileSettings\" component={ProfileSettings} />\n          </Stack.Navigator>\n          {apiClient.showPrompt ? (\n            <Prompt\n              text={`Describe whats wrong with this ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              title={`Report ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              reportMode={reportMode}\n              placeholder={\"Type a reason here\"}\n              onSubmit={promptActions.onConfirm}\n              onCancel={promptActions.onCancel}\n            />\n          ) : null}\n        </NavigationContainer>\n      </ActionSheetProvider>\n    </SafeAreaProvider>\n  );\n});\n\nexport default App;\n\n'lemmy-fennec/Screens/Feed/FeedScreen.tsx'\n:import React from \"react\";\nimport { Animated, FlatList, View } from \"react-native\";\n\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { PostView } from \"lemmy-js-client\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, TouchableOpacity } from \"../../ThemedComponents\";\nimport { commonStyles } from \"../../commonStyles\";\nimport DynamicHeader from \"../../components/DynamicHeader\";\nimport Pagination from \"../../components/Pagination\";\nimport FeedPost from \"../../components/Post/FeedPost\";\nimport TinyPost from \"../../components/Post/TinyPost\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { preferences } from \"../../store/preferences\";\nimport FloatingMenu from \"./FloatingMenu\";\n\nlet lastOffset = 0;\n\nfunction Feed({ navigation }: NativeStackScreenProps<any, \"Feed\">) {\n  const scrollOffsetY = React.useRef(new Animated.Value(0)).current;\n\n  const [showFab, setShowFab] = React.useState(true);\n  const isFocused = navigation.isFocused();\n  const listRef = React.useRef<FlatList<PostView>>(null);\n  const title = React.useMemo(() => {\n    return `Feed | ${apiClient.postStore.filters.type_ ?? \"\"} | ${\n      apiClient.postStore.filters.sort.replace(/([a-z])([A-Z])/g, \"$1 $2\") ?? \"\"\n    }`;\n  }, [apiClient.postStore.filters.type_, apiClient.postStore.filters.sort]);\n\n  React.useEffect(() => {\n    const getPosts = () => {\n      if (apiClient.api && apiClient.postStore.posts.length === 0) {\n        void apiClient.postStore.getPosts();\n      }\n    };\n\n    const unsubscribe = navigation.addListener(\"focus\", () => {\n      getPosts();\n    });\n\n    getPosts();\n    return unsubscribe;\n  }, [apiClient.api, navigation, isFocused]);\n\n  const renderPost = React.useCallback(\n    ({ item }) => {\n      return preferences.compactPostLayout ? (\n        <TinyPost post={item} navigation={navigation} />\n      ) : (\n        <FeedPost post={item} navigation={navigation} />\n      );\n    },\n    [preferences.compactPostLayout]\n  );\n  const extractor = React.useCallback(\n    (p: Record<string, any>) => p.post.id.toString(),\n    []\n  );\n  const onEndReached = React.useCallback(() => {\n    if (apiClient.postStore.posts.length === 0) return;\n    void apiClient.postStore.nextPage();\n  }, [apiClient.postStore.posts.length]);\n  const onRefresh = React.useCallback(() => {\n    apiClient.postStore.setPage(1);\n    void apiClient.postStore.getPosts();\n  }, []);\n\n\n  const onPostScroll = React.useRef(({ changed }) => {\n    if (changed.length > 0 && apiClient.loginDetails?.jwt) {\n      changed.forEach((item: Record<string, any>) => {\n        if (!item.isViewable && preferences.getReadOnScroll()) {\n          void apiClient.postStore.markPostRead({\n            post_ids: [item.item.post.id],\n            read: true,\n          });\n        }\n      });\n    }\n  }).current;\n\n  const nextPage = React.useCallback(() => {\n    if (apiClient.postStore.posts.length === 0) return;\n    listRef.current.scrollToOffset({ animated: true, offset: 0 });\n    void apiClient.postStore.changePage(apiClient.postStore.page + 1);\n  }, []);\n  const prevPage = React.useCallback(() => {\n    if (apiClient.postStore.posts.length === 0) return;\n    listRef.current.scrollToOffset({ animated: true, offset: 0 });\n    void apiClient.postStore.changePage(apiClient.postStore.page - 1);\n  }, []);\n\n\n  const onScroll = React.useCallback(\n    (e: any) => {\n      if (preferences.disableDynamicHeaders) return;\n      const currentScrollY = e.nativeEvent.contentOffset.y;\n      const deltaY = currentScrollY - lastOffset;\n      const isGoingDown = currentScrollY > lastOffset;\n\n      if (isGoingDown) {\n\n        scrollOffsetY.setValue(Math.min(scrollOffsetY._value + deltaY, 56));\n      } else {\n\n        scrollOffsetY.setValue(Math.max(scrollOffsetY._value + deltaY, 0));\n      }\n\n      if (showFab !== !isGoingDown) setShowFab(!isGoingDown);\n\n      lastOffset = currentScrollY;\n    },\n    [showFab, scrollOffsetY, preferences.disableDynamicHeaders]\n  );\n\n  React.useEffect(() => {\n    if (preferences.disableDynamicHeaders) {\n      scrollOffsetY.setValue(0);\n      setShowFab(true);\n    }\n  }, [preferences.disableDynamicHeaders]);\n\n  return (\n    <View style={commonStyles.container} key={apiClient.postStore.feedKey}>\n      <DynamicHeader\n        animHeaderValue={scrollOffsetY}\n        title={title}\n        rightAction={\n          <TouchableOpacity\n            style={{ marginRight: 10 }}\n            simple\n            onPressCb={() =>\n              listRef.current?.scrollToOffset({ animated: true, offset: 0 })\n            }\n          >\n            <Icon name={\"arrow-up\"} size={24} />\n          </TouchableOpacity>\n        }\n      />\n\n      <FlatList\n        ref={listRef}\n        style={{ flex: 1 }}\n        renderItem={renderPost}\n        data={apiClient.postStore.posts}\n        onRefresh={onRefresh}\n        windowSize={10}\n        initialNumToRender={10}\n        maxToRenderPerBatch={10}\n        onScroll={onScroll}\n        scrollEventThrottle={8}\n        onEndReached={preferences.paginatedFeed ? undefined : onEndReached}\n        refreshing={apiClient.postStore.isLoading}\n        onEndReachedThreshold={preferences.paginatedFeed ? undefined : 1}\n        keyExtractor={extractor}\n        onViewableItemsChanged={onPostScroll}\n        ListHeaderComponent={<View style={{ height: 56, width: \"100%\" }} />}\n        ListFooterComponent={\n          preferences.paginatedFeed ? (\n            <Pagination\n              prevPage={prevPage}\n              nextPage={nextPage}\n              isLoading={apiClient.postStore.isLoading}\n              page={apiClient.postStore.page}\n              itemsLength={apiClient.postStore.posts.length}\n            />\n          ) : undefined\n        }\n      />\n      {showFab ? <FloatingMenu /> : null}\n    </View>\n  );\n}\n\nexport default observer(Feed);\n\n'lemmy-fennec/components/Post/Media.tsx'\n:import React from \"react\";\nimport { Image, Share, StyleSheet, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport { preferences } from \"../../store/preferences\";\nimport ImageViewer from \"./ImageViewer\";\n\ninterface Props {\n  url: string;\n  name: string;\n  isNsfw: boolean;\n  small?: boolean;\n}\n\nfunction Media({ url, name, isNsfw, small }: Props) {\n  const [visible, setIsVisible] = React.useState(false);\n  const { colors } = useTheme();\n  const shareImage = () => {\n    void Share.share({\n      url: url,\n      message: url,\n      title: \"Share post image\",\n    });\n  };\n\n  const imgStyle = React.useMemo(() => {\n    return small ? styles.postSmallImg : styles.postImg;\n  }, [small]);\n  const containerStyle = React.useMemo(() => {\n    return small ? styles.noImageSmall : styles.noImage;\n  }, [small]);\n\n  return (\n    <>\n      <ImageViewer\n        url={url}\n        name={name}\n        visible={visible}\n        setIsVisible={setIsVisible}\n        shareImage={shareImage}\n      />\n      <TouchableOpacity onPressCb={() => setIsVisible(true)} simple>\n        {preferences.lowTrafficMode ? (\n          <View style={{ ...containerStyle, backgroundColor: colors.card }}>\n            <Icon name={\"image\"} size={32} />\n            {!small ? (\n              <>\n                <Text style={styles.text}>Low data mode enabled</Text>\n                <Text style={styles.text}>Tap to view image</Text>\n              </>\n            ) : null}\n          </View>\n        ) : (\n          <Image\n            source={{ uri: url }}\n            style={imgStyle}\n            progressiveRenderingEnabled\n            resizeMode={\"contain\"}\n            alt={\"Image for post\" + name}\n            accessibilityLabel={\"Image for post\" + name}\n            blurRadius={isNsfw && !preferences.unblurNsfw ? 55 : 0}\n          />\n        )}\n      </TouchableOpacity>\n    </>\n  );\n}\n\nconst styles = StyleSheet.create({\n  postImg: { width: \"100%\", height: 340 },\n  noImage: {\n    width: \"100%\",\n    height: 340,\n    flexDirection: \"column\",\n    gap: 8,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  noImageSmall: {\n    width: 80,\n    height: 80,\n    borderRadius: 8,\n    flexDirection: \"column\",\n    gap: 8,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  text: {\n    fontSize: 16,\n    opacity: 0.8,\n  },\n  postSmallImg: { width: 80, height: 80, borderRadius: 8 },\n});\n\nexport default observer(Media);\n\n'lemmy-fennec/Screens/HomeScreen.tsx'\n:import React from \"react\";\n\nimport { Feather } from \"@expo/vector-icons\";\nimport { createBottomTabNavigator } from \"@react-navigation/bottom-tabs\";\nimport { getFocusedRouteNameFromRoute } from \"@react-navigation/native\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon } from \"../ThemedComponents\";\nimport { apiClient } from \"../store/apiClient\";\nimport Feed from \"./Feed/FeedScreen\";\nimport FollowsScreen from \"./Follows/FollowsScreen\";\nimport Profile from \"./Profile/ProfileScreen\";\nimport Search from \"./Search/SearchScreen\";\nimport Unreads from \"./Unreads/Unreads\";\n\nconst Tab = createBottomTabNavigator();\n\nfunction HomeScreen() {\n  const jwt = apiClient.loginDetails?.jwt;\n  const isLoggedIn = apiClient.isLoggedIn;\n  React.useEffect(() => {\n    if (jwt) {\n      void apiClient.mentionsStore.fetchUnreads();\n    }\n  }, [jwt]);\n  const unreadCount = apiClient.mentionsStore.unreadsCount;\n  const displayedUnreads = unreadCount > 99 ? \"99+\" : unreadCount;\n\n  return (\n    <Tab.Navigator\n      screenOptions={({ route }) => ({\n        tabBarIcon: ({ color, size }) => {\n          switch (route.name) {\n            case \"Feed\":\n              return <Feather name={\"align-left\"} size={size} color={color} />;\n            case \"Profile\":\n              return <Feather name={\"user\"} size={size} color={color} />;\n            case \"Search\":\n              return <Feather name={\"search\"} size={size} color={color} />;\n            case \"Followed Communities\":\n              return <Feather name={\"star\"} size={size} color={color} />;\n            case \"Unreads\":\n              return <Feather name={\"mail\"} size={size} color={color} />;\n            default:\n              return <Feather name={\"heart\"} size={size} color={color} />;\n          }\n        },\n        tabBarShowLabel: false,\n        tabBarAccessibilityLabel: `Tab bar route - ${route.name}`,\n      })}\n      initialRouteName={\"Feed\"}\n    >\n      <Tab.Screen\n        name=\"Feed\"\n        component={Feed}\n        options={{\n          headerShown: false,\n        }}\n      />\n      {isLoggedIn ? (\n        <>\n          <Tab.Screen name={\"Saved\"} component={FollowsScreen} />\n          <Tab.Screen\n            name={\"Unreads\"}\n            component={Unreads}\n            options={{\n              tabBarBadge: unreadCount > 0 ? displayedUnreads : undefined,\n            }}\n          />\n        </>\n      ) : null}\n      <Tab.Screen name={\"Search\"} component={Search} />\n      <Tab.Screen name=\"Profile\" component={Profile} />\n    </Tab.Navigator>\n  );\n}\n\nexport default observer(HomeScreen);\n",
        "gt": [
            "'lemmy-fennec/components/Post/ImageViewer.tsx'",
            "'lemmy-fennec/components/Post/Media.tsx'",
            "'lemmy-fennec/components/Post/TinyPost.tsx'",
            "'lemmy-fennec/Screens/Feed/FeedScreen.tsx'",
            "'lemmy-fennec/Screens/HomeScreen.tsx'",
            "'lemmy-fennec/App.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/attributes.transformer.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { DDBRepository, GlobalSecondaryIndexName, LocalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey, LSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteContestItem, KeyAttrs } from './athlete.contests.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nimport { Utils } from 'shared/utils';\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteContestsRepository extends DDBRepository {\n  protected _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async put(contest: DDBAthleteContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Put', params));\n  }\n\n  public async delete(athleteId: string, contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId, discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Delete', params));\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(athleteId, opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const startDate = opts.betweenDates ? opts.betweenDates.start.toISODate() : '';\n    const endDate = (opts.betweenDates && !Utils.isNil(opts.betweenDates.end)\n      ? opts.betweenDates.end\n      : Utils.DateNow().toDate()\n    ).toISODate();\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and #lsi BETWEEN :startDate AND :endDate',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(athleteId),\n        ':startDate': this.transformer.itemToAttrsTransformer.LSI(startDate),\n        ':endDate': this.transformer.itemToAttrsTransformer.LSI(endDate),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryAthleteContestsByDate', params));\n  }\n\n  public async queryContestAthletes(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(contestId, discipline, after);\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryContestAthletes', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        points: this.transformer.attrsToItemTransformer.points(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(\n    athleteId: string,\n    after?: {\n      contestId: string;\n      discipline: Discipline;\n      date: string;\n    },\n  ): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createGSIExclusiveStartKey(\n    contestId: string,\n    discipline: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && !Utils.isNil(after.points)) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.points),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[] }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/attributes.transformer.ts'\n:import { Injectable } from '@nestjs/common';\nimport { DDBOverloadedTableTransformer } from 'core/database/dynamodb/dynamodb.table.transformers';\nimport { Discipline } from 'shared/enums';\nimport { Utils } from 'shared/utils';\nimport {\n  buildCompositeKey,\n  decodeStringToPoint,\n  destructCompositeKey,\n  encodePointToString,\n} from '../../../utils/utils';\nimport { AllAttrs, DDBAthleteContestItem, KeyAttrs } from '../athlete.contests.interface';\n\n\n@Injectable()\nexport class AttrsTransformer extends DDBOverloadedTableTransformer<AllAttrs, DDBAthleteContestItem> {\n  constructor() {\n    super();\n  }\n  public prefixes: KeyAttrs = {\n    PK: 'Athlete',\n    SK_GSI: 'Contest',\n    LSI: 'Contest',\n    GSI_SK: '',\n  };\n\n  public attrsToItemTransformer = {\n    athleteId: (pk: string) => destructCompositeKey(pk, 1),\n    contestId: (sk_gsi: string) => destructCompositeKey(sk_gsi, 2),\n    discipline: (sk_gsi: string) => parseInt(destructCompositeKey(sk_gsi, 1), 10),\n    date: (lsi: string) => destructCompositeKey(lsi, 1),\n    points: (gsi_sk: string) => decodeStringToPoint(gsi_sk),\n  };\n\n  public itemToAttrsTransformer = {\n    PK: (id: string) => buildCompositeKey(this.prefixes.PK, id),\n    SK_GSI: (discipline: Discipline, contestId: string) =>\n      buildCompositeKey(this.prefixes.SK_GSI, !Utils.isNil(discipline) && discipline.toString(), contestId),\n    LSI: (date: string) => buildCompositeKey(this.prefixes.LSI, date),\n    GSI_SK: (points: number) => encodePointToString(points),\n  };\n\n  public transformAttrsToItem(dynamodbItem: AllAttrs): DDBAthleteContestItem {\n    const { PK, SK_GSI, LSI, GSI_SK, ...rest } = dynamodbItem;\n    return {\n      athleteId: this.attrsToItemTransformer.athleteId(PK),\n      contestId: this.attrsToItemTransformer.contestId(SK_GSI),\n      discipline: this.attrsToItemTransformer.discipline(SK_GSI),\n      date: this.attrsToItemTransformer.date(LSI),\n      points: this.attrsToItemTransformer.points(GSI_SK),\n      ...rest,\n    };\n  }\n\n  public transformItemToAttrs(item: DDBAthleteContestItem): AllAttrs {\n    const { athleteId, contestId, date, points, discipline, ...rest } = item;\n\n    return {\n      PK: this.itemToAttrsTransformer.PK(athleteId),\n      SK_GSI: this.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n      LSI: this.itemToAttrsTransformer.LSI(date),\n      GSI_SK: this.itemToAttrsTransformer.GSI_SK(points),\n      ...rest,\n    };\n  }\n\n  public primaryKey(athleteId: string, discipline: Discipline, contestId: string) {\n    return {\n      [this.attrName('PK')]: this.itemToAttrsTransformer.PK(athleteId),\n      [this.attrName('SK_GSI')]: this.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n    };\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.interface.ts'\n:import { AgeCategory, Gender } from 'shared/enums';\nimport { DDBTableKeyAttrs } from '../../interfaces/table.interface';\n\nexport type KeyAttrs = DDBTableKeyAttrs;\n\ninterface Attrs {\n  readonly name: string;\n  readonly surname: string;\n  readonly normalizedFullname: string;\n  readonly birthdate: string;\n  readonly gender: Gender;\n  readonly country: string;\n  readonly profileUrl: string;\n  readonly thumbnailUrl: string;\n  readonly createdAt: number;\n  readonly email: string;\n  readonly city: string;\n  readonly infoUrl: string;\n}\ninterface NonKeyAttrs extends Attrs {}\n\nexport type AllAttrs = KeyAttrs & NonKeyAttrs;\n\nexport interface DDBAthleteDetailItem extends Attrs {\n  readonly athleteId: string;\n  readonly normalizedName: string;\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { DDBRepository, GlobalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteDetailItem, KeyAttrs } from './athlete.details.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteDetailsRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteDetailItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async isExists(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      ProjectionExpression: this.transformer.attrName('PK'),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return true;\n        }\n        return false;\n      })\n      .catch(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository isExists', err, params);\n        return false;\n      });\n  }\n\n  public async get(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async batchGet(athleteIds: string[]) {\n    const params: DocumentClient.BatchGetItemInput = {\n      RequestItems: {\n        [this._tableName]: {\n          Keys: athleteIds.map(id => {\n            return this.transformer.primaryKey(id);\n          }),\n        },\n      },\n    };\n    return this.client\n      .batchGet(params)\n      .promise()\n      .then(data => {\n        return data.Responses[this._tableName].map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository batchGet', params));\n  }\n\n  public async put(athlete: DDBAthleteDetailItem) {\n    const params = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(athlete),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository Put', params));\n  }\n\n  public async delete(id: string) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(id),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository delete', params));\n  }\n\n  public async updateProfileUrl(athleteId: string, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository updateUrl', params));\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi and begins_with(#gsi_sk, :value) ',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        '#gsi_sk': this.transformer.attrName('GSI_SK'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ':value': this.transformer.itemToAttrsTransformer.GSI_SK(name),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return items;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletesByName', params));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: { fullName?: string };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(opts.after);\n\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletes', params));\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        name: this.transformer.attrsToItemTransformer.normalizedName(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createGSIExclusiveStartKey(after?: { athleteId: string; name: string }) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && after.name) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.name),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { fullName?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.fullName) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedFullName, :fullName)`;\n      filterExpAttrNames['#normalizedFullName'] = this.transformer.attrName('normalizedFullname');\n      filterExpAttrValues[':fullName'] = filter.fullName;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/entity.transformer.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport * as moment from 'moment';\nimport { Utils } from 'shared/utils';\nimport { DDBAthleteDetailItem } from '../athlete.details.interface';\n\n@Injectable()\nexport class EntityTransformer {\n  constructor() {}\n\n  public toDBItem(athlete: AthleteDetail): DDBAthleteDetailItem {\n    return {\n      athleteId: athlete.id,\n      birthdate: athlete.birthdate && athlete.birthdate.toISODate(),\n      country: athlete.country,\n      createdAt: athlete.createdAt || moment().unix(),\n      gender: athlete.gender,\n      name: athlete.name,\n      normalizedName: Utils.normalizeString(athlete.name),\n      normalizedFullname: `${Utils.normalizeString(athlete.name)} ${Utils.normalizeString(athlete.surname)}`,\n      profileUrl: athlete.profileUrl || undefined,\n      thumbnailUrl: athlete.thumbnailUrl || undefined,\n      surname: athlete.surname,\n      city: athlete.city || undefined,\n      email: athlete.email,\n      infoUrl: athlete.infoUrl || undefined,\n    };\n  }\n\n  public fromDBItem(athlete: DDBAthleteDetailItem): AthleteDetail {\n    if (!athlete) {\n      return null;\n    }\n    return new AthleteDetail({\n      id: athlete.athleteId,\n      birthdate: athlete.birthdate && new Date(athlete.birthdate),\n      country: athlete.country,\n      createdAt: athlete.createdAt,\n      gender: athlete.gender,\n      name: athlete.name,\n      profileUrl: athlete.profileUrl || '',\n      thumbnailUrl: athlete.thumbnailUrl || '',\n      surname: athlete.surname,\n      city: athlete.city || '',\n      email: athlete.email,\n      infoUrl: athlete.infoUrl || '',\n    });\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/entity.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/tests/grid.spec.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/pointer.utils.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/grid.utils.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/passive-listeners.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts'"
        ],
        "content": "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/tests/grid.spec.ts'\n:import { ktdGetGridLayoutDiff } from '../grid.utils';\n\ndescribe('Grid utils', () => {\n\n    describe('ktdGetGridLayoutDiff', () => {\n        it('should calculate resize grid diff', () => {\n            const a = [\n                {x: 1, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 2, id: '3'}\n            ];\n            const b = [\n                {x: 1, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 3, id: '3'}\n            ];\n            expect(ktdGetGridLayoutDiff(a, b)).toEqual({3: {change: 'resize'}});\n        });\n\n        it('should calculate move items grid diff', () => {\n            const a = [\n                {x: 1, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 2, id: '3'}\n            ];\n            const b = [\n                {x: 2, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'}\n\n            ];\n            expect(ktdGetGridLayoutDiff(a, b)).toEqual({2: {change: 'move'}});\n        });\n\n        it('should calculate resize and move changes on the grid', () => {\n            const a = [\n                {x: 1, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 2, id: '3'}\n            ];\n            const b = [\n                {x: 1, y: 2, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 3, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 2, id: '3'}\n            ];\n            expect(ktdGetGridLayoutDiff(a, b)).toEqual({2: {change: 'move'}, 1: {change: 'resize'}});\n        });\n    });\n\n});\n\n'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/pointer.utils.ts'\n:import { fromEvent, iif, merge, Observable } from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport { ktdNormalizePassiveListenerOptions } from './passive-listeners';\n\n\nconst passiveEventListenerOptions = ktdNormalizePassiveListenerOptions({passive: true});\n\n\nconst activeEventListenerOptions = ktdNormalizePassiveListenerOptions({passive: false});\n\nlet isMobile: boolean | null = null;\n\nexport function ktdIsMobileOrTablet(): boolean {\n\n    if (isMobile != null) {\n        return isMobile;\n    }\n\n\n    const isMobileDevice = /Android|webOS|BlackBerry|Windows Phone|iPad|iPhone|iPod/i.test(navigator.userAgent);\n\n\n    const isIOSMobileDevice = /iPad|iPhone|iPod/.test(navigator.platform) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);\n\n    isMobile = isMobileDevice || isIOSMobileDevice;\n\n    return isMobile;\n}\n\nexport function ktdIsMouseEvent(event: any): event is MouseEvent {\n    return (event as MouseEvent).clientX != null;\n}\n\nexport function ktdIsTouchEvent(event: any): event is TouchEvent {\n    return (event as TouchEvent).touches != null && (event as TouchEvent).touches.length != null;\n}\n\nexport function ktdPointerClientX(event: MouseEvent | TouchEvent): number {\n    return ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX;\n}\n\nexport function ktdPointerClientY(event: MouseEvent | TouchEvent): number {\n    return ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY;\n}\n\nexport function ktdPointerClient(event: MouseEvent | TouchEvent): {clientX: number, clientY: number} {\n    return  {\n        clientX: ktdIsMouseEvent(event) ? event.clientX : event.touches[0].clientX,\n        clientY: ktdIsMouseEvent(event) ? event.clientY : event.touches[0].clientY\n    };\n}\n\n\nexport function ktdMouseOrTouchDown(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        fromEvent<TouchEvent>(element, 'touchstart', passiveEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber)\n        ),\n        fromEvent<MouseEvent>(element, 'mousedown', activeEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((mouseEvent: MouseEvent) => {\n\n                return mouseEvent.button === 0;\n            })\n        )\n    );\n}\n\n\nexport function ktdMouseOrTouchMove(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        fromEvent<TouchEvent>(element, 'touchmove', activeEventListenerOptions as AddEventListenerOptions).pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber),\n        ),\n        fromEvent<MouseEvent>(element, 'mousemove', activeEventListenerOptions as AddEventListenerOptions)\n    );\n}\n\nexport function ktdTouchEnd(element, touchNumber = 1): Observable<TouchEvent> {\n    return merge(\n        fromEvent<TouchEvent>(element, 'touchend').pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)\n        ),\n        fromEvent<TouchEvent>(element, 'touchcancel').pipe(\n            filter((touchEvent) => touchEvent.touches.length === touchNumber - 1)\n        )\n    );\n}\n\n\nexport function ktdMouseOrTouchEnd(element, touchNumber = 1): Observable<MouseEvent | TouchEvent> {\n    return iif(\n        () => ktdIsMobileOrTablet(),\n        ktdTouchEnd(element, touchNumber),\n        fromEvent<MouseEvent>(element, 'mouseup'),\n    );\n}\n\n'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/grid.utils.ts'\n:import { compact, CompactType, getFirstCollision, Layout, LayoutItem, moveElement } from './react-grid-layout.utils';\nimport { KtdDraggingData, KtdGridCfg, KtdGridCompactType, KtdGridItemRect, KtdGridLayout, KtdGridLayoutItem } from '../grid.definitions';\nimport { ktdPointerClientX, ktdPointerClientY } from './pointer.utils';\nimport { KtdDictionary } from '../../types';\nimport { KtdGridItemComponent } from '../grid-item/grid-item.component';\n\n\nexport function ktdTrackById(index: number, item: {id: string}) {\n    return item.id;\n}\n\n\nexport function ktdGridCompact(layout: KtdGridLayout, compactType: KtdGridCompactType, cols: number): KtdGridLayout {\n    return compact(layout, compactType, cols)\n\n        .map(item => ({ id: item.id, x: item.x, y: item.y, w: item.w, h: item.h, minW: item.minW, minH: item.minH, maxW: item.maxW, maxH: item.maxH }));\n}\n\nfunction screenXPosToGridValue(screenXPos: number, cols: number, width: number): number {\n    return Math.round((screenXPos * cols) / width);\n}\n\nfunction screenYPosToGridValue(screenYPos: number, rowHeight: number, height: number): number {\n    return Math.round(screenYPos / rowHeight);\n}\n\n\nexport function ktdGetGridLayoutDiff(gridLayoutA: KtdGridLayoutItem[], gridLayoutB: KtdGridLayoutItem[]): KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> {\n    const diff: KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> = {};\n\n    gridLayoutA.forEach(itemA => {\n        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\n        if (itemB != null) {\n            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\n            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\n            const change: 'move' | 'resize' | 'moveresize' | null = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\n            if (change) {\n                diff[itemB.id] = {change};\n            }\n        }\n    });\n    return diff;\n}\n\n\nexport function ktdGridItemDragging(gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n\n    const gridItemId = gridItem.id;\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n    const offsetX = clientStartX - dragElemClientRect.left;\n    const offsetY = clientStartY - dragElemClientRect.top;\n\n\n    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\n    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;\n\n\n    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\n    const gridRelYPos = clientY - gridElementTopPosition - offsetY;\n\n\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width),\n        y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height)\n    };\n\n\n    layoutItem.x = Math.max(0, layoutItem.x);\n    layoutItem.y = Math.max(0, layoutItem.y);\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.x = Math.max(0, config.cols - layoutItem.w);\n    }\n\n\n    const layoutItems: LayoutItem[] = config.layout;\n    const draggedLayoutItem: LayoutItem = layoutItems.find(item => item.id === gridItemId)!;\n\n    let newLayoutItems: LayoutItem[] = moveElement(\n        layoutItems,\n        draggedLayoutItem,\n        layoutItem.x,\n        layoutItem.y,\n        true,\n        config.preventCollision,\n        compactionType,\n        config.cols\n    );\n\n    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\n\n    return {\n        layout: newLayoutItems,\n        draggedItemPos: {\n            top: gridRelYPos,\n            left: gridRelXPos,\n            width: dragElemClientRect.width,\n            height: dragElemClientRect.height,\n        }\n    };\n}\n\n\nexport function ktdGridItemResizing(gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n    const gridItemId = gridItem.id;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n\n    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\n    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\n    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);\n\n\n\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width),\n        h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height)\n    };\n\n    layoutItem.w = limitNumberWithinRange(layoutItem.w, gridItem.minW ?? layoutItem.minW, gridItem.maxW ?? layoutItem.maxW);\n    layoutItem.h = limitNumberWithinRange(layoutItem.h, gridItem.minH ?? layoutItem.minH, gridItem.maxH ?? layoutItem.maxH);\n\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.w = Math.max(1, config.cols - layoutItem.x);\n    }\n\n    if (config.preventCollision) {\n        const maxW = layoutItem.w;\n        const maxH = layoutItem.h;\n\n        let colliding = hasCollision(config.layout, layoutItem);\n        let shrunkDimension: 'w' | 'h' | undefined;\n\n        while (colliding) {\n            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\n            layoutItem[shrunkDimension]--;\n            colliding = hasCollision(config.layout, layoutItem);\n        }\n\n        if (shrunkDimension === 'w') {\n            layoutItem.h = maxH;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.h--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n        if (shrunkDimension === 'h') {\n            layoutItem.w = maxW;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.w--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n\n    }\n\n    const newLayoutItems: LayoutItem[] = config.layout.map((item) => {\n        return item.id === gridItemId ? layoutItem : item;\n    });\n\n    return {\n        layout: compact(newLayoutItems, compactionType, config.cols),\n        draggedItemPos: {\n            top: dragElemClientRect.top - gridElemClientRect.top,\n            left: dragElemClientRect.left - gridElemClientRect.left,\n            width,\n            height,\n        }\n    };\n}\n\nfunction hasCollision(layout: Layout, layoutItem: LayoutItem): boolean {\n    return !!getFirstCollision(layout, layoutItem);\n}\n\nfunction getDimensionToShrink(layoutItem, lastShrunk): 'w' | 'h' {\n    if (layoutItem.h <= 1) {\n        return 'w';\n    }\n    if (layoutItem.w <= 1) {\n        return 'h';\n    }\n\n    return lastShrunk === 'w' ? 'h' : 'w';\n}\n\n\nfunction limitNumberWithinRange(num: number, min: number = 1, max: number = Infinity) {\n    return Math.min(Math.max(num, min < 1 ? 1 : min), max);\n}\n\n'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/passive-listeners.ts'\n:\nlet supportsPassiveEvents: boolean;\n\n\nexport function ktdSupportsPassiveEventListeners(): boolean {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null!, Object.defineProperty({}, 'passive', {\n                get: () => supportsPassiveEvents = true\n            }));\n        } finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n\n    return supportsPassiveEvents;\n}\n\n\nexport function ktdNormalizePassiveListenerOptions(options: AddEventListenerOptions):\n    AddEventListenerOptions | boolean {\n    return ktdSupportsPassiveEventListeners() ? options : !!options.capture;\n}\n\n'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts'\n:import {\n    AfterContentInit, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, Inject, Input, NgZone, OnDestroy, OnInit, QueryList, Renderer2,\n    ViewChild\n} from '@angular/core';\nimport { BehaviorSubject, iif, merge, NEVER, Observable, Subject, Subscription } from 'rxjs';\nimport { exhaustMap, filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';\nimport { ktdMouseOrTouchDown, ktdMouseOrTouchEnd, ktdPointerClient } from '../utils/pointer.utils';\nimport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KtdGridItemRenderDataTokenType } from '../grid.definitions';\nimport { KTD_GRID_DRAG_HANDLE, KtdGridDragHandle } from '../directives/drag-handle';\nimport { KTD_GRID_RESIZE_HANDLE, KtdGridResizeHandle } from '../directives/resize-handle';\nimport { KtdGridService } from '../grid.service';\nimport { ktdOutsideZone } from '../utils/operators';\nimport { BooleanInput, coerceBooleanProperty } from '../coercion/boolean-property';\nimport { coerceNumberProperty, NumberInput } from '../coercion/number-property';\n\n@Component({\n    selector: 'ktd-grid-item',\n    templateUrl: './grid-item.component.html',\n    styleUrls: ['./grid-item.component.scss'],\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class KtdGridItemComponent implements OnInit, OnDestroy, AfterContentInit {\n\n    @ContentChildren(KTD_GRID_DRAG_HANDLE, {descendants: true}) _dragHandles: QueryList<KtdGridDragHandle>;\n    @ContentChildren(KTD_GRID_RESIZE_HANDLE, {descendants: true}) _resizeHandles: QueryList<KtdGridResizeHandle>;\n    @ViewChild('resizeElem', {static: true, read: ElementRef}) resizeElem: ElementRef;\n\n\n    @Input() minW?: number;\n    @Input() minH?: number;\n    @Input() maxW?: number;\n    @Input() maxH?: number;\n\n\n    @Input() transition: string = 'transform 500ms ease, width 500ms ease, height 500ms ease';\n\n    dragStart$: Observable<MouseEvent | TouchEvent>;\n    resizeStart$: Observable<MouseEvent | TouchEvent>;\n\n\n    @Input()\n    get id(): string {\n        return this._id;\n    }\n\n    set id(val: string) {\n        this._id = val;\n    }\n\n    private _id: string;\n\n\n    @Input()\n    get dragStartThreshold(): number { return this._dragStartThreshold; }\n\n    set dragStartThreshold(val: number) {\n        this._dragStartThreshold = coerceNumberProperty(val);\n    }\n\n    private _dragStartThreshold: number = 0;\n\n\n\n    @Input()\n    get draggable(): boolean {\n        return this._draggable;\n    }\n\n    set draggable(val: boolean) {\n        this._draggable = coerceBooleanProperty(val);\n        this._draggable$.next(this._draggable);\n    }\n\n    private _draggable: boolean = true;\n    private _draggable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._draggable);\n\n\n    @Input()\n    get resizable(): boolean {\n        return this._resizable;\n    }\n\n    set resizable(val: boolean) {\n        this._resizable = coerceBooleanProperty(val);\n        this._resizable$.next(this._resizable);\n    }\n\n    private _resizable: boolean = true;\n    private _resizable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._resizable);\n\n    private dragStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n    private resizeStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n\n    private subscriptions: Subscription[] = [];\n\n    constructor(public elementRef: ElementRef,\n                private gridService: KtdGridService,\n                private renderer: Renderer2,\n                private ngZone: NgZone,\n                @Inject(GRID_ITEM_GET_RENDER_DATA_TOKEN) private getItemRenderData: KtdGridItemRenderDataTokenType) {\n        this.dragStart$ = this.dragStartSubject.asObservable();\n        this.resizeStart$ = this.resizeStartSubject.asObservable();\n    }\n\n    ngOnInit() {\n        const gridItemRenderData = this.getItemRenderData(this.id)!;\n        this.setStyles(gridItemRenderData);\n    }\n\n    ngAfterContentInit() {\n        this.subscriptions.push(\n            this._dragStart$().subscribe(this.dragStartSubject),\n            this._resizeStart$().subscribe(this.resizeStartSubject),\n        );\n    }\n\n    ngOnDestroy() {\n        this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    setStyles({top, left, width, height}: { top: string, left: string, width?: string, height?: string }) {\n\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\n        if (width != null) { this.renderer.setStyle(this.elementRef.nativeElement, 'width', width); }\n        if (height != null) {this.renderer.setStyle(this.elementRef.nativeElement, 'height', height); }\n    }\n\n    private _dragStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._draggable$.pipe(\n            switchMap((draggable) => {\n                if (!draggable) {\n                    return NEVER;\n                } else {\n                    return this._dragHandles.changes.pipe(\n                        startWith(this._dragHandles),\n                        switchMap((dragHandles: QueryList<KtdGridDragHandle>) => {\n                            return iif(\n                                () => dragHandles.length > 0,\n                                merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))),\n                                ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)\n                            ).pipe(\n                                exhaustMap((startEvent) => {\n\n\n\n\n\n\n                                    if (startEvent.target && (startEvent.target as HTMLElement).draggable && startEvent.type === 'mousedown') {\n                                        startEvent.preventDefault();\n                                    }\n\n                                    const startPointer = ktdPointerClient(startEvent);\n                                    return this.gridService.mouseOrTouchMove$(document).pipe(\n                                        takeUntil(ktdMouseOrTouchEnd(document, 1)),\n                                        ktdOutsideZone(this.ngZone),\n                                        filter((moveEvent) => {\n                                            moveEvent.preventDefault();\n                                            const movePointer = ktdPointerClient(moveEvent);\n                                            const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\n                                            const distanceY = Math.abs(startPointer.clientY - movePointer.clientY);\n\n                                            return distanceX + distanceY >= this.dragStartThreshold;\n                                        }),\n                                        take(1),\n\n                                        map(() => startEvent)\n                                    );\n                                })\n                            );\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n    private _resizeStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._resizable$.pipe(\n            switchMap((resizable) => {\n                if (!resizable) {\n\n                    this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                    return NEVER;\n                } else {\n                    return this._resizeHandles.changes.pipe(\n                        startWith(this._resizeHandles),\n                        switchMap((resizeHandles: QueryList<KtdGridResizeHandle>) => {\n                            if (resizeHandles.length > 0) {\n\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                                return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\n                            } else {\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\n                                return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\n                            }\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n\n    static ngAcceptInputType_minW: NumberInput;\n    static ngAcceptInputType_minH: NumberInput;\n    static ngAcceptInputType_maxW: NumberInput;\n    static ngAcceptInputType_maxH: NumberInput;\n    static ngAcceptInputType_draggable: BooleanInput;\n    static ngAcceptInputType_resizable: BooleanInput;\n    static ngAcceptInputType_dragStartThreshold: NumberInput;\n\n}\n",
        "gt": [
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/passive-listeners.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/pointer.utils.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/grid.utils.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/tests/grid.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/shared/utils.ts'",
            "'Rankings-Backend/src/shared/constants.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/shared/env_variables.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/shared/utils.ts'\n:import latinize = require('latinize');\nimport { isNil as _isNil } from 'lodash';\nimport * as moment from 'moment';\n\nimport { Constants } from './constants';\nimport env_variables from './env_variables';\nimport { logger } from './logger';\n\n\nexport namespace Utils {\n  export function concatParams(base: string, ...params: string[]) {\n    let str = base;\n    for (const param of params) {\n      if (param !== undefined && param !== null && param.length > 0) {\n        str = str + ':' + param;\n      } else {\n        break;\n      }\n    }\n    return str;\n  }\n\n  export function DateNow() {\n    return moment().utc();\n  }\n\n  export function unixToDate(unix: number): moment.Moment {\n    return moment.unix(unix);\n  }\n\n  export function dateToMoment(date: Date): moment.Moment {\n    if (date) {\n      return moment(date);\n    }\n    return null;\n  }\n\n  export function normalizeString(str: string) {\n    if (!str) {\n      return str;\n    }\n    return latinize(str).toLowerCase();\n  }\n\n  export async function omitReject<T>(promise: Promise<T>) {\n    return promise.then<T>(d => d).catch<null>(err => {\n      logger.debug('OmitReject Error', { err: JSON.stringify(err) });\n      return null;\n    });\n  }\n\n  export function isRequestAuthenticated(request: Express.Request) {\n    if (env_variables.isDev) {\n      return true;\n    }\n    return isNil(request.cognitoClaims);\n  }\n\n  export function isNil(...value: any) {\n    return value.every((e: any) => _isNil(e));\n  }\n\n  export function isSomeNil(...value: any) {\n    return value.some((e: any) => _isNil(e));\n  }\n  export function logThrowError(errorDesc: string, params: any) {\n    return err => {\n      logError(errorDesc, err, params);\n      throw err;\n    };\n  }\n\n  export function logError(errorDesc: string, err: any, params: any) {\n    let errMessage;\n    if (!err.requestId) {\n\n      errMessage = err.message;\n    }\n    logger.error(`Error: ${errorDesc}`, {\n      data: {\n        params: params,\n        error: errMessage || err,\n      },\n    });\n  }\n}\n\n'Rankings-Backend/src/shared/constants.ts'\n:import { ContestType } from './enums';\nimport env_variables from './env_variables';\n\n\nexport namespace Constants {\n  export const BaseYear = 2017;\n  export const TopScoreContestCount = 2;\n  export const TopScoreYearRange = 3;\n\n  export function ContestTypeTopPoints(category: ContestType): number {\n    switch (category) {\n      case ContestType.WorldChampionship:\n        return 2000;\n      case ContestType.WorldCup:\n        return 1500;\n      case ContestType.Masters:\n        return 900;\n      case ContestType.GrandSlam:\n        return 600;\n      case ContestType.Open:\n        return 300;\n      case ContestType.Challenge:\n        return 150;\n      default:\n        throw new Error('Contest Category Top Points not found: ' + category);\n    }\n  }\n\n  export function ContestScoringRange(category: ContestType): number {\n    switch (category) {\n      case ContestType.WorldChampionship:\n        return 18;\n      case ContestType.WorldCup:\n        return 16;\n      case ContestType.Masters:\n        return 14;\n      case ContestType.GrandSlam:\n        return 12;\n      case ContestType.Open:\n        return 10;\n      case ContestType.Challenge:\n        return 8;\n      default:\n        throw new Error('Contest Scoring Range not found: ' + category);\n    }\n  }\n\n  export function ContestTypeMinParticipantsLimit(category: ContestType): number {\n    if (env_variables.isDev) {\n      return 2;\n    }\n    switch (category) {\n      case ContestType.WorldChampionship:\n        return 11;\n      case ContestType.WorldCup:\n        return 9;\n      case ContestType.Masters:\n        return 7;\n      case ContestType.GrandSlam:\n        return 5;\n      case ContestType.Open:\n        return 3;\n      case ContestType.Challenge:\n        return 3;\n      default:\n        throw new Error('Contest Category Participant Limit not found: ' + category);\n    }\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/shared/env_variables.ts'\n:class EnvironmentVariables {\n  public env = process.env.NODE_ENV || process.env.ENVIRONMENT || 'production';\n\n  get isDev(): boolean {\n    return !this.isProd;\n  }\n  get isProd(): boolean {\n    return this.env === 'production' || this.env === 'Prod';\n  }\n\n  get LoggerDebugLevel(): string {\n    return process.env.LoggerDebugLevel || 'debug';\n  }\n\n  get IS_OFFLINE(): boolean {\n    return process.env.IS_OFFLINE === 'true' || process.env.ENVIRONMENT === 'Local';\n  }\n\n  get morganConfig(): string {\n    return process.env.NODE_ENV === 'production' ? 'tiny' : 'combined';\n  }\n\n  get redis_host(): string {\n    return process.env.REDISHOST;\n  }\n\n  get redis_port(): string {\n    return process.env.REDISPORT;\n  }\n\n  get redis_password(): string {\n    return process.env.REDISPASSWORD;\n  }\n\n  get disable_streams(): boolean {\n    return process.env.DISABLE_STREAMS === 'true';\n  }\n  get disable_cronjob(): boolean {\n    return process.env.DISABLE_CRONJOB === 'true';\n  }\n}\n\nexport default new EnvironmentVariables();\n",
        "gt": [
            "'Rankings-Backend/src/shared/env_variables.ts'",
            "'Rankings-Backend/src/shared/constants.ts'",
            "'Rankings-Backend/src/shared/utils.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'lemmy-fennec/Screens/Community/CommunityFeed.tsx'",
            "'lemmy-fennec/App.tsx'",
            "'lemmy-fennec/Screens/Feed/FloatingMenu.tsx'",
            "'lemmy-fennec/Screens/Community/CommunityScreen.tsx'"
        ],
        "content": "'lemmy-fennec/Screens/Community/CommunityFeed.tsx'\n:import React from \"react\";\nimport { FlatList, StyleSheet, View } from \"react-native\";\n\nimport { PostView } from \"lemmy-js-client\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport { commonStyles } from \"../../commonStyles\";\nimport FeedPost from \"../../components/Post/FeedPost\";\nimport TinyPost from \"../../components/Post/TinyPost\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { preferences } from \"../../store/preferences\";\nimport FloatingMenu from \"../Feed/FloatingMenu\";\n\nfunction CommunityFeed({ navigation }: { navigation: any }) {\n  const { community } = apiClient.communityStore;\n  const listRef = React.useRef<FlatList<PostView>>(null);\n\n  React.useEffect(() => {\n    if (navigation && listRef.current) {\n      const scrollUp = () =>\n        listRef.current.scrollToOffset({ animated: true, offset: 0 });\n\n      navigation.getParent().setOptions({\n        headerRight: () => (\n          <TouchableOpacity\n            style={{ marginRight: 10 }}\n            simple\n            onPressCb={scrollUp}\n          >\n            <Icon name={\"arrow-up\"} size={24} />\n          </TouchableOpacity>\n        ),\n      });\n    }\n  }, [navigation, listRef.current]);\n\n  const renderPost = React.useCallback(\n    ({ item }) => {\n      return preferences.compactPostLayout ? (\n\n        <TinyPost post={item} navigation={navigation} useCommunity />\n      ) : (\n\n        <FeedPost post={item} navigation={navigation} useCommunity />\n      );\n    },\n    [preferences.compactPostLayout]\n  );\n  const extractor = React.useCallback((p) => p.post.id.toString(), []);\n  const onEndReached = React.useCallback(() => {\n    if (apiClient.postStore.posts.length === 0) return;\n    void apiClient.postStore.nextPage(community.community.id);\n  }, [community]);\n  const onRefresh = React.useCallback(() => {\n    apiClient.postStore.setCommPage(1);\n    void apiClient.postStore.getPosts(community.community.id);\n  }, [community]);\n\n  const onPostScroll = React.useRef(({ changed }) => {\n    if (changed.length > 0 && apiClient.loginDetails?.jwt) {\n      changed.forEach((item) => {\n        if (!item.isViewable && preferences.getReadOnScroll()) {\n          void apiClient.postStore.markPostRead({\n            post_ids: [item.item.post.id],\n            read: true,\n          });\n        }\n      });\n    }\n  }).current;\n\n  const createPost = () => {\n    navigation.navigate(\"PostWrite\", {\n      communityName: community.community.name,\n      communityId: community.community.id,\n    });\n  };\n\n\n  return (\n    <View style={commonStyles.container} key={apiClient.postStore.feedKey}>\n      <FlatList\n        ref={listRef}\n        ListEmptyComponent={\n          <View style={ownStyles.emptyContainer}>\n            <Text style={ownStyles.empty}>No posts here so far...</Text>\n          </View>\n        }\n        style={{ flex: 1, width: \"100%\" }}\n        renderItem={renderPost}\n        data={apiClient.postStore.communityPosts}\n        onRefresh={onRefresh}\n        onEndReached={onEndReached}\n        refreshing={apiClient.postStore.isLoading}\n        onEndReachedThreshold={0.5}\n        keyExtractor={extractor}\n        fadingEdgeLength={1}\n        onViewableItemsChanged={onPostScroll}\n      />\n      <FloatingMenu\n        useCommunity\n        additional={\n          !community?.community.posting_restricted_to_mods &&\n          apiClient.loginDetails?.jwt ? (\n            <TouchableOpacity simple onPressCb={createPost}>\n              <Text style={{ fontWeight: \"500\" }}>New Post</Text>\n            </TouchableOpacity>\n          ) : null\n        }\n      />\n    </View>\n  );\n}\n\nconst ownStyles = StyleSheet.create({\n  emptyContainer: {\n    padding: 12,\n    flex: 1,\n  },\n  empty: {\n    fontSize: 16,\n  },\n});\n\nexport default observer(CommunityFeed);\n\n'lemmy-fennec/App.tsx'\n:import React from \"react\";\nimport { StatusBar, useColorScheme } from \"react-native\";\n\nimport { ActionSheetProvider } from \"@expo/react-native-action-sheet\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\n\nimport AddAccount from \"./Screens/AddAccount\";\nimport BlocksScreen from \"./Screens/Blocks/BlocksScreen\";\nimport CommentWrite from \"./Screens/CommentWrite/CommentWrite\";\nimport CommunityScreen from \"./Screens/Community/CommunityScreen\";\nimport DebugScreen from \"./Screens/DebugScreen\";\nimport HomeScreen from \"./Screens/HomeScreen\";\nimport LoginScreen from \"./Screens/LoginScreen\";\nimport PostScreen from \"./Screens/Post/PostScreen\";\nimport PostWrite from \"./Screens/PostWrite\";\nimport Behavior from \"./Screens/Settings/Behavior\";\nimport Looks from \"./Screens/Settings/Looks\";\nimport ProfileSettings from \"./Screens/Settings/ProfileSettings\";\nimport SettingsScreen from \"./Screens/SettingsScreen\";\nimport MessageWrite from \"./Screens/Unreads/MessageWrite\";\nimport UserScreen from \"./Screens/User/UserScreen\";\nimport { Icon } from \"./ThemedComponents\";\nimport { AppAmoledTheme, AppDarkTheme, AppTheme } from \"./commonStyles\";\nimport Prompt from \"./components/Prompt\";\nimport { ReportMode, apiClient } from \"./store/apiClient\";\nimport { Theme, preferences } from \"./store/preferences\";\n\nconst Stack = createNativeStackNavigator();\n\nconst App = observer(() => {\n  const scheme = useColorScheme();\n\n  const systemTheme = scheme === \"dark\" ? AppDarkTheme : AppTheme;\n  const isLightStatusBar =\n    preferences.theme === Theme.System\n      ? scheme !== \"dark\"\n      : preferences.theme === Theme.Light;\n\n  const schemeMap = {\n    [Theme.System]: systemTheme,\n    [Theme.Light]: AppTheme,\n    [Theme.Dark]: AppDarkTheme,\n    [Theme.Amoled]: AppAmoledTheme,\n  };\n\n  const sendReport = (text: string) => {\n    if (apiClient.reportMode === ReportMode.Post) {\n      apiClient.api\n        .createPostReport({\n          post_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    } else {\n      apiClient.api\n        .createCommentReport({\n          comment_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    }\n  };\n\n  const closeReport = () => {\n    apiClient.setShowPrompt(false);\n  };\n\n  const reportMode = apiClient.reportMode;\n  const promptActions =\n    reportMode !== ReportMode.Off\n      ? {\n          onCancel: closeReport,\n          onConfirm: sendReport,\n        }\n      : apiClient.promptActions;\n  return (\n    <SafeAreaProvider style={{ flex: 1 }}>\n      {}\n      <StatusBar\n        barStyle={isLightStatusBar ? \"dark-content\" : \"light-content\"}\n        backgroundColor={schemeMap[preferences.theme].colors.card}\n      />\n      <ActionSheetProvider>\n        <NavigationContainer theme={schemeMap[preferences.theme]}>\n          <Stack.Navigator initialRouteName={\"Home\"}>\n            <Stack.Screen\n              name=\"Home\"\n              component={HomeScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              name=\"Post\"\n              component={PostScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Comment\" }}\n              name={\"CommentWrite\"}\n              component={CommentWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Post\" }}\n              name={\"PostWrite\"}\n              component={PostWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"Message\" }}\n              name={\"MessageWrite\"}\n              component={MessageWrite}\n            />\n            <Stack.Screen\n              options={{\n                headerRight: () => <Icon name={\"arrow-up\"} size={24} />,\n              }}\n              name=\"Community\"\n              component={CommunityScreen}\n            />\n            <Stack.Screen name=\"Login\" component={LoginScreen} />\n            <Stack.Screen\n              options={{ headerTitle: \"Add Account\" }}\n              name={\"AddAccount\"}\n              component={AddAccount}\n            />\n            <Stack.Screen name=\"User\" component={UserScreen} />\n            <Stack.Screen name=\"Settings\" component={SettingsScreen} />\n            <Stack.Screen name=\"Debug\" component={DebugScreen} />\n            <Stack.Screen name=\"Blocks\" component={BlocksScreen} />\n            <Stack.Screen name=\"Looks\" component={Looks} />\n            <Stack.Screen name=\"Behavior\" component={Behavior} />\n            <Stack.Screen name=\"ProfileSettings\" component={ProfileSettings} />\n          </Stack.Navigator>\n          {apiClient.showPrompt ? (\n            <Prompt\n              text={`Describe whats wrong with this ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              title={`Report ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              reportMode={reportMode}\n              placeholder={\"Type a reason here\"}\n              onSubmit={promptActions.onConfirm}\n              onCancel={promptActions.onCancel}\n            />\n          ) : null}\n        </NavigationContainer>\n      </ActionSheetProvider>\n    </SafeAreaProvider>\n  );\n});\n\nexport default App;\n\n'lemmy-fennec/Screens/Feed/FloatingMenu.tsx'\n:import React from \"react\";\nimport { StyleSheet, TouchableOpacity, View } from \"react-native\";\n\nimport { Theme, useTheme } from \"@react-navigation/native\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, Text } from \"../../ThemedComponents\";\nimport { commonStyles } from \"../../commonStyles\";\nimport FAB from \"../../components/FAB\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { ListingTypeMap, SortTypeMap } from \"../../store/postStore\";\n\nfunction splitCamelCase(str: string) {\n  return str.replace(/([a-z])([A-Z])/g, \"$1 $2\");\n}\n\nconst sortTypes = Object.values(SortTypeMap).map((type) => ({\n  label: splitCamelCase(type),\n  value: type,\n}));\nconst listingTypes = Object.values(ListingTypeMap).map((type) => ({\n  label: splitCamelCase(type),\n  value: type,\n}));\n\nfunction FloatingMenu({\n  useCommunity,\n  additional,\n}: {\n  useCommunity?: boolean;\n  additional?: React.ReactNode;\n}) {\n  const { colors } = useTheme();\n  const [isSortOpen, setIsSortOpen] = React.useState(false);\n  const [isListingOpen, setIsListingOpen] = React.useState(false);\n  const [isOpen, setIsOpen] = React.useState(false);\n\n  const switchToSort = () => {\n    setIsSortOpen(true);\n    setIsListingOpen(false);\n    setIsOpen(false);\n  };\n  const switchToListing = () => {\n    setIsListingOpen(true);\n    setIsSortOpen(false);\n    setIsOpen(false);\n  };\n  const openMenu = () => {\n    setIsOpen(true);\n    setIsSortOpen(false);\n    setIsListingOpen(false);\n  };\n  const closeAll = () => {\n    setIsOpen(false);\n    setIsSortOpen(false);\n    setIsListingOpen(false);\n  };\n\n\n  const hideRead = () => {\n    if (useCommunity) {\n      const newPosts = apiClient.postStore.communityPosts.filter(\n        (post) => post.read === false\n      );\n      apiClient.postStore.setCommunityPosts(newPosts);\n    } else {\n      const newPosts = apiClient.postStore.posts.filter(\n        (post) => post.read === false\n      );\n      apiClient.postStore.setPosts(newPosts);\n    }\n  };\n\n  const refresh = () => {\n    if (useCommunity) {\n      const id = apiClient.communityStore.community.community.id;\n      apiClient.postStore.getPosts(id).then(() => {\n        apiClient.postStore.bumpFeedKey();\n      });\n    } else {\n      apiClient.postStore.getPosts().then(() => {\n        apiClient.postStore.bumpFeedKey();\n      });\n    }\n  };\n\n  return (\n    <FAB>\n      {isSortOpen ? (\n        <SortMenu\n          useCommunity={useCommunity}\n          colors={colors}\n          closeSelf={closeAll}\n        />\n      ) : null}\n      {isListingOpen ? (\n        <ListingMenu colors={colors} closeSelf={closeAll} />\n      ) : null}\n      {isOpen ? (\n        <View style={{ ...commonStyles.fabMenu, backgroundColor: colors.card }}>\n          <TouchableOpacity onPress={switchToSort}>\n            <Text style={styles.bold}>Change sorting type</Text>\n          </TouchableOpacity>\n          {useCommunity ? null : (\n            <TouchableOpacity onPress={switchToListing}>\n              <Text style={styles.bold}>Change feed type</Text>\n            </TouchableOpacity>\n          )}\n          <TouchableOpacity onPress={hideRead}>\n            <Text style={styles.bold}>Hide Read</Text>\n          </TouchableOpacity>\n          <TouchableOpacity onPress={refresh}>\n            <Text style={styles.bold}>Refresh</Text>\n          </TouchableOpacity>\n          {additional}\n        </View>\n      ) : null}\n      <TouchableOpacity onPress={() => (isOpen ? closeAll() : openMenu())}>\n        <View\n          style={{ ...commonStyles.fabButton, backgroundColor: colors.card }}\n        >\n          <Icon name={isOpen ? \"x\" : \"menu\"} size={24} />\n        </View>\n      </TouchableOpacity>\n    </FAB>\n  );\n}\n\nfunction SortMenu({\n  colors,\n  closeSelf,\n  useCommunity,\n}: {\n  useCommunity?: boolean;\n  colors: Theme[\"colors\"];\n  closeSelf: () => void;\n}) {\n  const setSorting = (sort: (typeof SortTypeMap)[keyof typeof SortTypeMap]) => {\n    void apiClient.postStore.setFilters({ sort: sort });\n    if (useCommunity) {\n      const id = apiClient.communityStore.community.community.id;\n      void apiClient.postStore.getPosts(id);\n    } else {\n      void apiClient.postStore.getPosts();\n    }\n    closeSelf();\n  };\n\n  return (\n    <View style={{ ...commonStyles.fabMenu, backgroundColor: colors.card }}>\n      {sortTypes.map((type) => (\n        <TouchableOpacity\n          key={type.value}\n          onPress={() => setSorting(type.value)}\n        >\n          <Text style={{ fontWeight: \"500\" }}>{type.label}</Text>\n        </TouchableOpacity>\n      ))}\n    </View>\n  );\n}\n\nfunction ListingMenu({\n  colors,\n  closeSelf,\n}: {\n  colors: Theme[\"colors\"];\n  closeSelf: () => void;\n}) {\n  const setListing = (\n    listing: (typeof ListingTypeMap)[keyof typeof ListingTypeMap]\n  ) => {\n    void apiClient.postStore.setFilters({ type_: listing });\n    void apiClient.postStore.getPosts();\n    closeSelf();\n  };\n  return (\n    <View style={{ ...commonStyles.fabMenu, backgroundColor: colors.card }}>\n      {listingTypes.map((type) => (\n        <TouchableOpacity\n          key={type.value}\n          onPress={() => setListing(type.value)}\n        >\n          <Text style={{ fontWeight: \"500\" }}>{type.label}</Text>\n        </TouchableOpacity>\n      ))}\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  bold: {\n    fontWeight: \"500\",\n  },\n});\n\nexport default observer(FloatingMenu);\n\n'lemmy-fennec/Screens/Community/CommunityScreen.tsx'\n:import React from \"react\";\nimport { ActivityIndicator } from \"react-native\";\n\nimport { createMaterialTopTabNavigator } from \"@react-navigation/material-top-tabs\";\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { apiClient } from \"../../store/apiClient\";\nimport { communityStore } from \"../../store/communityStore\";\nimport CommunityFeed from \"./CommunityFeed\";\nimport CommunityInfos from \"./CommunityInfos\";\n\nconst Tab = createMaterialTopTabNavigator();\n\nfunction CommunityScreen({\n  navigation,\n  route,\n}: NativeStackScreenProps<any, \"Community\">) {\n  const commId = route.params.id;\n  const name = route.params.name;\n  const { community } = apiClient.communityStore;\n\n  const fetchedName = community?.community.name;\n  const fetchedId = community?.community.id;\n\n  React.useEffect(() => {\n    const nameWithoutInst =\n      name && name.includes(\"@\") ? name.split(\"@\")[0] : name;\n    const getData = () => {\n      if (\n        (fetchedId === commId || fetchedName === nameWithoutInst) &&\n        apiClient.postStore.communityPosts.length > 0\n      ) {\n        return;\n      } else {\n        if (commId || name) {\n          apiClient.postStore.setCommPage(1);\n          void apiClient.postStore.getPosts(commId, name);\n          void apiClient.communityStore.getCommunity(commId, name);\n        }\n      }\n    };\n\n    const unsubscribe = navigation.addListener(\"focus\", () => {\n      getData();\n    });\n    getData();\n\n    return unsubscribe;\n  }, [\n    commId,\n    name,\n    apiClient.postStore.communityPosts.length,\n    fetchedName,\n    fetchedId,\n  ]);\n\n  React.useEffect(() => {\n    if (communityStore.community !== null && apiClient.postStore) {\n      navigation.setOptions({\n        title: `${communityStore.community.community.title} | ${apiClient.postStore.filters.sort}`,\n      });\n    }\n  }, [navigation, apiClient.postStore, communityStore.community]);\n\n  if (apiClient.communityStore.isLoading || !community)\n    return <ActivityIndicator />;\n\n  return (\n    <Tab.Navigator initialRouteName={\"CommunityFeed\"}>\n      <Tab.Screen\n        options={{\n          tabBarLabel: \"Posts\",\n        }}\n        name={\"CommunityFeed\"}\n        component={CommunityFeed}\n      />\n      <Tab.Screen\n        options={{\n          tabBarLabel: \"About\",\n        }}\n        name={\"CommunityInfos\"}\n        component={CommunityInfos}\n      />\n    </Tab.Navigator>\n  );\n}\n\nexport default observer(CommunityScreen);\n",
        "gt": [
            "'lemmy-fennec/Screens/Feed/FloatingMenu.tsx'",
            "'lemmy-fennec/Screens/Community/CommunityFeed.tsx'",
            "'lemmy-fennec/Screens/Community/CommunityScreen.tsx'",
            "'lemmy-fennec/App.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { DDBRepository, LocalSecondaryIndexName } from '../dynamodb.repo';\nimport { LSILastEvaluatedKey } from '../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../utils/utils';\nimport { AllAttrs, DDBContestItem, KeyAttrs } from './contest.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBContestRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async get(contestId: string, discipline: Discipline) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBContestRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async put(contest: DDBContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBContestRepository Put', params));\n  }\n  public async delete(contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBContestRepository Delete', params));\n  }\n\n  public async updateProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBContestRepository updateUrl', params));\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: !opts.descending,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and begins_with(#lsi, :sortKeyPrefix) ',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(),\n        ':sortKeyPrefix': this.transformer.itemToAttrsTransformer.LSI((opts.year || '').toString()),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBContestRepository query', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(after?: {\n    contestId: string;\n    discipline: Discipline;\n    date: string;\n  }): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date && after.discipline) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[]; name?: string; id?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    if (filter.name) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedName, :queryString)`;\n      filterExpAttrNames['#normalizedName'] = this.transformer.attrName('normalizedName');\n      filterExpAttrValues[':queryString'] = filter.name;\n    }\n    if (filter.id) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#sk_gsi, :id)`;\n      filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n      filterExpAttrValues[':id'] = filter.id;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'\n:import { DocumentClient } from 'aws-sdk/clients/dynamodb';\n\nexport type AttrsTransformer<T> = {\n  [P in keyof T]: ((...params: string[]) => string)\n};\nexport type AttrsTransformerOptional<T> = {\n  [P in keyof T]?: ((...params: any[]) => any)\n};\nexport type ItemTransformerOptional<T> = {\n  [P in keyof T]?: ((...params: any[]) => any)\n};\n\nexport abstract class DDBOverloadedTableTransformer<\n  TAllAttrs,\n  TTransformedItem\n> {\n  protected abstract attrsToItemTransformer: ItemTransformerOptional<\n    TTransformedItem\n  >;\n  protected abstract itemToAttrsTransformer: AttrsTransformerOptional<\n    TAllAttrs\n  >;\n\n  protected abstract transformAttrsToItem(\n    dynamodbItem: TAllAttrs,\n  ): TTransformedItem;\n\n  protected abstract transformItemToAttrs(\n    item: TTransformedItem,\n    client?: DocumentClient,\n  ): TAllAttrs;\n\n  protected attrNameTyped<T>(attr: keyof T): string {\n    return this.identity(attr);\n  }\n\n  public attrName(attr: keyof TAllAttrs): string {\n    return this.identity(attr);\n  }\n\n  protected identity(x) {\n    return x;\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/contests/transformers/attributes.transformer.ts'\n:import { Discipline } from 'shared/enums';\nimport { Utils } from 'shared/utils';\nimport { DDBOverloadedTableTransformer } from '../../dynamodb.table.transformers';\nimport { buildCompositeKey, destructCompositeKey } from '../../utils/utils';\nimport { AllAttrs, DDBContestItem } from '../contest.interface';\n\n\nexport class AttrsTransformer extends DDBOverloadedTableTransformer<AllAttrs, DDBContestItem> {\n  constructor() {\n    super();\n  }\n\n  public prefixes = {\n    PK: 'Contests',\n    SK_GSI: 'Contest',\n    LSI: 'Contest',\n    GSI_SK: '',\n  };\n\n  public attrsToItemTransformer = {\n    contestId: (sk_gsi: string) => destructCompositeKey(sk_gsi, 2),\n    discipline: (sk_gsi: string) => parseInt(destructCompositeKey(sk_gsi, 1), 10),\n    date: (lsi: string) => destructCompositeKey(lsi, 1),\n  };\n\n  public itemToAttrsTransformer = {\n    PK: () => this.prefixes.PK,\n    SK_GSI: (discipline: Discipline, contestId: string) =>\n      buildCompositeKey(\n        this.prefixes.SK_GSI,\n        !Utils.isNil(discipline) && discipline.toString(),\n        contestId,\n      ),\n    LSI: (date: string) =>\n      buildCompositeKey(\n        this.prefixes.LSI,\n        date,\n      ),\n    GSI_SK: () => undefined,\n  };\n\n  public transformAttrsToItem(dynamodbItem: AllAttrs): DDBContestItem {\n    const { PK, SK_GSI, LSI, GSI_SK, ...rest } = dynamodbItem;\n    return {\n      contestId: this.attrsToItemTransformer.contestId(SK_GSI),\n      discipline: this.attrsToItemTransformer.discipline(SK_GSI),\n      date: this.attrsToItemTransformer.date(LSI),\n      ...rest,\n    };\n  }\n\n  public transformItemToAttrs(item: DDBContestItem): AllAttrs {\n    const { contestId, discipline, date, ...rest } = item;\n    return {\n      PK: this.itemToAttrsTransformer.PK(),\n      SK_GSI: this.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n      LSI: this.itemToAttrsTransformer.LSI(date),\n      GSI_SK: this.itemToAttrsTransformer.GSI_SK(),\n      ...rest,\n    };\n  }\n\n  public primaryKey(discipline: Discipline, contestId: string) {\n    return {\n      [this.attrName('PK')]: this.itemToAttrsTransformer.PK(),\n      [this.attrName('SK_GSI')]: this.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'lemmy-fennec/components/Post/ExpandedPost.tsx'",
            "'lemmy-fennec/App.tsx'",
            "'lemmy-fennec/components/Post/ImageViewer.tsx'",
            "'lemmy-fennec/components/Post/Media.tsx'",
            "'lemmy-fennec/Screens/Post/PostScreen.tsx'"
        ],
        "content": "'lemmy-fennec/components/Post/ExpandedPost.tsx'\n:import React from \"react\";\nimport { StyleSheet, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { PostView } from \"lemmy-js-client\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport Embed from \"../../components/Post/Embed\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { makeDateString } from \"../../utils/utils\";\nimport MdRenderer from \"../MdRenderer\";\nimport Media from \"./Media\";\nimport PostBadges from \"./PostBadges\";\nimport PostIconRow from \"./PostIconRow\";\nimport PostTitle from \"./PostTitle\";\n\n\n\n\n\n\nfunction Post({\n  post,\n  navigation,\n  useCommunity,\n  showAllButton,\n}: {\n  post: PostView;\n  useCommunity?: boolean;\n  showAllButton?: boolean;\n  navigation?: NativeStackScreenProps<any, \"Feed\">[\"navigation\"];\n}) {\n  const { colors } = useTheme();\n\n\n  const isNsfw = post.post.nsfw || post.community.nsfw;\n  const isPic = post.post.url\n    ? /\\.(jpeg|jpg|gif|png|webp)$/.test(post.post.url)\n    : false;\n\n\n  const maxLines = undefined;\n  const safeDescription = post.post.body ? post.post.body : \"\";\n  const dateStr = makeDateString(post.post.published);\n\n  const markRead = () => {\n    if (apiClient.loginDetails?.jwt) {\n      void apiClient.postStore.markPostRead(\n        {\n          post_ids: [post.post.id],\n          read: true,\n        },\n        useCommunity\n      );\n    }\n  };\n  React.useEffect(() => {\n    markRead();\n  }, []);\n\n  const getCommunity = () => {\n    apiClient.postStore.setCommunityPosts([]);\n    apiClient.communityStore.setCommunity(null);\n    navigation.navigate(\"Community\", { id: post.community.id });\n  };\n\n  const getAuthor = () => {\n    navigation.navigate(\"User\", { personId: post.creator.id });\n  };\n\n  const customReadColor = post.read ? \"#ababab\" : colors.text;\n\n  const openCommenting = () => {\n    if (post.post.locked) return;\n    apiClient.commentsStore.setReplyTo({\n      postId: post.post.id,\n      parent_id: undefined,\n      title: post.post.name,\n      community: post.community.name,\n      published: post.post.published,\n      author: post.creator.name,\n      content: post.post.body || post.post.url,\n      language_id: post.post.language_id,\n    });\n    navigation.navigate(\"CommentWrite\");\n  };\n\n  return (\n    <>\n      <View style={{ ...styles.container, borderColor: colors.border }}>\n        <PostTitle\n          post={post}\n          getCommunity={getCommunity}\n          getAuthor={getAuthor}\n          dateStr={dateStr}\n        />\n\n        <Text\n          customColor={customReadColor}\n          lines={maxLines}\n          style={styles.postName}\n        >\n          {post.post.name}\n        </Text>\n\n        <PostBadges isNsfw={isNsfw} post={post} />\n        <View>\n          {isPic ? (\n            <Media url={post.post.url} name={post.post.name} isNsfw={isNsfw} />\n          ) : null}\n          {post.post.url || post.post.embed_title ? (\n            <Embed\n              embed_title={post.post.embed_title}\n              embed_description={post.post.embed_description}\n              url={post.post.url}\n            />\n          ) : null}\n          <MdRenderer value={safeDescription} />\n        </View>\n        <PostIconRow\n          post={post}\n          markRead={markRead}\n          getComments={openCommenting}\n          useCommunity={useCommunity}\n        />\n      </View>\n      {showAllButton ? (\n        <TouchableOpacity\n          onPressCb={() => {\n            navigation.setParams({ post: post.post.id, parentId: undefined });\n            void apiClient.commentsStore.getComments(post.post.id);\n          }}\n          simple\n        >\n          <Text\n            style={{\n              padding: 8,\n              color: colors.primary,\n              backgroundColor: colors.card,\n              fontSize: 16,\n            }}\n          >\n            Show all {post.counts.comments} comments\n          </Text>\n        </TouchableOpacity>\n      ) : null}\n    </>\n  );\n}\n\n\n\nconst styles = StyleSheet.create({\n  container: {\n    padding: 8,\n    borderBottomWidth: 1,\n    marginTop: 56,\n  },\n  previewButton: {\n    width: \"100%\",\n    alignItems: \"center\",\n    padding: 12,\n  },\n  postName: {\n    fontSize: 17,\n    fontWeight: \"500\",\n    flex: 1,\n    marginTop: 4,\n    marginBottom: 8,\n  },\n  postImg: { width: \"100%\", height: 340 },\n});\n\nexport default observer(Post);\n\n'lemmy-fennec/App.tsx'\n:import React from \"react\";\nimport { StatusBar, useColorScheme } from \"react-native\";\n\nimport { ActionSheetProvider } from \"@expo/react-native-action-sheet\";\nimport { NavigationContainer } from \"@react-navigation/native\";\nimport { createNativeStackNavigator } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\nimport { SafeAreaProvider } from \"react-native-safe-area-context\";\n\nimport AddAccount from \"./Screens/AddAccount\";\nimport BlocksScreen from \"./Screens/Blocks/BlocksScreen\";\nimport CommentWrite from \"./Screens/CommentWrite/CommentWrite\";\nimport CommunityScreen from \"./Screens/Community/CommunityScreen\";\nimport DebugScreen from \"./Screens/DebugScreen\";\nimport HomeScreen from \"./Screens/HomeScreen\";\nimport LoginScreen from \"./Screens/LoginScreen\";\nimport PostScreen from \"./Screens/Post/PostScreen\";\nimport PostWrite from \"./Screens/PostWrite\";\nimport Behavior from \"./Screens/Settings/Behavior\";\nimport Looks from \"./Screens/Settings/Looks\";\nimport ProfileSettings from \"./Screens/Settings/ProfileSettings\";\nimport SettingsScreen from \"./Screens/SettingsScreen\";\nimport MessageWrite from \"./Screens/Unreads/MessageWrite\";\nimport UserScreen from \"./Screens/User/UserScreen\";\nimport { Icon } from \"./ThemedComponents\";\nimport { AppAmoledTheme, AppDarkTheme, AppTheme } from \"./commonStyles\";\nimport Prompt from \"./components/Prompt\";\nimport { ReportMode, apiClient } from \"./store/apiClient\";\nimport { Theme, preferences } from \"./store/preferences\";\n\nconst Stack = createNativeStackNavigator();\n\nconst App = observer(() => {\n  const scheme = useColorScheme();\n\n  const systemTheme = scheme === \"dark\" ? AppDarkTheme : AppTheme;\n  const isLightStatusBar =\n    preferences.theme === Theme.System\n      ? scheme !== \"dark\"\n      : preferences.theme === Theme.Light;\n\n  const schemeMap = {\n    [Theme.System]: systemTheme,\n    [Theme.Light]: AppTheme,\n    [Theme.Dark]: AppDarkTheme,\n    [Theme.Amoled]: AppAmoledTheme,\n  };\n\n  const sendReport = (text: string) => {\n    if (apiClient.reportMode === ReportMode.Post) {\n      apiClient.api\n        .createPostReport({\n          post_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    } else {\n      apiClient.api\n        .createCommentReport({\n          comment_id: apiClient.reportedItemId,\n          reason: text,\n        })\n        .then(() => {\n          closeReport();\n        });\n    }\n  };\n\n  const closeReport = () => {\n    apiClient.setShowPrompt(false);\n  };\n\n  const reportMode = apiClient.reportMode;\n  const promptActions =\n    reportMode !== ReportMode.Off\n      ? {\n          onCancel: closeReport,\n          onConfirm: sendReport,\n        }\n      : apiClient.promptActions;\n  return (\n    <SafeAreaProvider style={{ flex: 1 }}>\n      {}\n      <StatusBar\n        barStyle={isLightStatusBar ? \"dark-content\" : \"light-content\"}\n        backgroundColor={schemeMap[preferences.theme].colors.card}\n      />\n      <ActionSheetProvider>\n        <NavigationContainer theme={schemeMap[preferences.theme]}>\n          <Stack.Navigator initialRouteName={\"Home\"}>\n            <Stack.Screen\n              name=\"Home\"\n              component={HomeScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              name=\"Post\"\n              component={PostScreen}\n              options={{ headerShown: false }}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Comment\" }}\n              name={\"CommentWrite\"}\n              component={CommentWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"New Post\" }}\n              name={\"PostWrite\"}\n              component={PostWrite}\n            />\n            <Stack.Screen\n              options={{ headerTitle: \"Message\" }}\n              name={\"MessageWrite\"}\n              component={MessageWrite}\n            />\n            <Stack.Screen\n              options={{\n                headerRight: () => <Icon name={\"arrow-up\"} size={24} />,\n              }}\n              name=\"Community\"\n              component={CommunityScreen}\n            />\n            <Stack.Screen name=\"Login\" component={LoginScreen} />\n            <Stack.Screen\n              options={{ headerTitle: \"Add Account\" }}\n              name={\"AddAccount\"}\n              component={AddAccount}\n            />\n            <Stack.Screen name=\"User\" component={UserScreen} />\n            <Stack.Screen name=\"Settings\" component={SettingsScreen} />\n            <Stack.Screen name=\"Debug\" component={DebugScreen} />\n            <Stack.Screen name=\"Blocks\" component={BlocksScreen} />\n            <Stack.Screen name=\"Looks\" component={Looks} />\n            <Stack.Screen name=\"Behavior\" component={Behavior} />\n            <Stack.Screen name=\"ProfileSettings\" component={ProfileSettings} />\n          </Stack.Navigator>\n          {apiClient.showPrompt ? (\n            <Prompt\n              text={`Describe whats wrong with this ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              title={`Report ${\n                reportMode === ReportMode.Post ? \"post\" : \"comment\"\n              }`}\n              reportMode={reportMode}\n              placeholder={\"Type a reason here\"}\n              onSubmit={promptActions.onConfirm}\n              onCancel={promptActions.onCancel}\n            />\n          ) : null}\n        </NavigationContainer>\n      </ActionSheetProvider>\n    </SafeAreaProvider>\n  );\n});\n\nexport default App;\n\n'lemmy-fennec/components/Post/ImageViewer.tsx'\n:import React from \"react\";\nimport { StyleSheet, ToastAndroid, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { setImageAsync } from \"expo-clipboard\";\nimport { documentDirectory, downloadAsync } from \"expo-file-system\";\nimport {\n  addAssetsToAlbumAsync,\n  createAlbumAsync,\n  createAssetAsync,\n  getAlbumAsync,\n  usePermissions,\n} from \"expo-media-library\";\nimport ImageView from \"react-native-image-viewing\";\n\nimport { Icon, Text, TouchableOpacity } from \"../../ThemedComponents\";\n\ninterface Props {\n  url: string;\n  name: string;\n  visible: boolean;\n  setIsVisible: React.Dispatch<React.SetStateAction<boolean>>;\n  shareImage: () => void;\n}\n\nfunction ImageViewer({ url, name, visible, setIsVisible, shareImage }: Props) {\n  const [permissionResponse, askForPermission] = usePermissions({\n    writeOnly: true,\n  });\n  const { colors } = useTheme();\n  const safeName = name.length > 45 ? name.slice(0, 40) + \"...\" : name;\n\n  const handleDownload = async () => {\n    let fileUri = documentDirectory + `${safeName.replace(\" \", \"-\")}.jpg`;\n    try {\n      const res = await downloadAsync(url, fileUri);\n      await saveFile(res.uri);\n      ToastAndroid.showWithGravity(\n        \"Image saved\",\n        ToastAndroid.SHORT,\n        ToastAndroid.CENTER\n      );\n    } catch (err) {\n      ToastAndroid.showWithGravity(\n        \"Couldn't save image\",\n        ToastAndroid.SHORT,\n        ToastAndroid.CENTER\n      );\n      console.log(\"FS Err: \", err);\n    }\n  };\n\n  const copyImage = () => {\n    fetch(url)\n      .then((r) => r.blob())\n      .then((blob) => {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n        reader.onloadend = () => {\n          const base64data = reader.result.toString().split(\",\")[1];\n          setImageAsync(base64data.toString()).catch((err) =>\n            console.log(\"Copy err: \", err)\n          );\n        };\n      });\n  };\n\n  const saveFile = async (fileUri) => {\n    const shouldAsk =\n      permissionResponse?.granted === false &&\n      permissionResponse?.canAskAgain === true;\n    const saveToAlbum = async () => {\n      try {\n        const asset = await createAssetAsync(fileUri);\n        const album = await getAlbumAsync(\"Arctius\");\n        if (album === null) {\n          await createAlbumAsync(\"Arctius\", asset, false);\n        } else {\n          await addAssetsToAlbumAsync([asset], album, false);\n        }\n      } catch (err) {\n        console.log(\"Save err: \", err);\n      }\n    };\n    if (shouldAsk) {\n      askForPermission().then(async (res) => {\n        if (res.status === \"granted\") {\n          void saveToAlbum();\n        } else if (res.status === \"denied\") {\n          alert(\"please allow permissions to download\");\n        }\n      });\n    } else {\n      void saveToAlbum();\n    }\n  };\n  return (\n    <ImageView\n      images={[{ uri: url }]}\n      imageIndex={0}\n      visible={visible}\n      onRequestClose={() => setIsVisible(false)}\n      FooterComponent={() => (\n        <View style={{ ...styles.imgHeader, backgroundColor: colors.card }}>\n          <Text lines={1} style={{ fontSize: 14 }}>\n            {safeName}\n          </Text>\n          <View style={{ flexDirection: \"row\", gap: 16 }}>\n            <TouchableOpacity onPressCb={shareImage} simple>\n              <Icon\n                name={\"share-2\"}\n                accessibilityLabel={\"share post button\"}\n                size={24}\n              />\n            </TouchableOpacity>\n            <TouchableOpacity simple onPressCb={copyImage}>\n              <Icon\n                name={\"copy\"}\n                accessibilityLabel={\"copy post button\"}\n                size={24}\n              />\n            </TouchableOpacity>\n            <TouchableOpacity onPressCb={handleDownload} simple>\n              <Icon\n                name={\"download\"}\n                accessibilityLabel={\"download post button\"}\n                size={24}\n              />\n            </TouchableOpacity>\n          </View>\n        </View>\n      )}\n    />\n  );\n}\n\nconst styles = StyleSheet.create({\n  imgHeader: {\n    padding: 12,\n    alignItems: \"center\",\n    flexDirection: \"row\",\n    justifyContent: \"space-between\",\n    gap: 16,\n  },\n});\n\nexport default ImageViewer;\n\n'lemmy-fennec/components/Post/Media.tsx'\n:import React from \"react\";\nimport { Image, Share, StyleSheet, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, Text, TouchableOpacity } from \"../../ThemedComponents\";\nimport { preferences } from \"../../store/preferences\";\nimport ImageViewer from \"./ImageViewer\";\n\ninterface Props {\n  url: string;\n  name: string;\n  isNsfw: boolean;\n  small?: boolean;\n}\n\nfunction Media({ url, name, isNsfw, small }: Props) {\n  const [visible, setIsVisible] = React.useState(false);\n  const { colors } = useTheme();\n  const shareImage = () => {\n    void Share.share({\n      url: url,\n      message: url,\n      title: \"Share post image\",\n    });\n  };\n\n  const imgStyle = React.useMemo(() => {\n    return small ? styles.postSmallImg : styles.postImg;\n  }, [small]);\n  const containerStyle = React.useMemo(() => {\n    return small ? styles.noImageSmall : styles.noImage;\n  }, [small]);\n\n  return (\n    <>\n      <ImageViewer\n        url={url}\n        name={name}\n        visible={visible}\n        setIsVisible={setIsVisible}\n        shareImage={shareImage}\n      />\n      <TouchableOpacity onPressCb={() => setIsVisible(true)} simple>\n        {preferences.lowTrafficMode ? (\n          <View style={{ ...containerStyle, backgroundColor: colors.card }}>\n            <Icon name={\"image\"} size={32} />\n            {!small ? (\n              <>\n                <Text style={styles.text}>Low data mode enabled</Text>\n                <Text style={styles.text}>Tap to view image</Text>\n              </>\n            ) : null}\n          </View>\n        ) : (\n          <Image\n            source={{ uri: url }}\n            style={imgStyle}\n            progressiveRenderingEnabled\n            resizeMode={\"contain\"}\n            alt={\"Image for post\" + name}\n            accessibilityLabel={\"Image for post\" + name}\n            blurRadius={isNsfw && !preferences.unblurNsfw ? 55 : 0}\n          />\n        )}\n      </TouchableOpacity>\n    </>\n  );\n}\n\nconst styles = StyleSheet.create({\n  postImg: { width: \"100%\", height: 340 },\n  noImage: {\n    width: \"100%\",\n    height: 340,\n    flexDirection: \"column\",\n    gap: 8,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  noImageSmall: {\n    width: 80,\n    height: 80,\n    borderRadius: 8,\n    flexDirection: \"column\",\n    gap: 8,\n    alignItems: \"center\",\n    justifyContent: \"center\",\n  },\n  text: {\n    fontSize: 16,\n    opacity: 0.8,\n  },\n  postSmallImg: { width: 80, height: 80, borderRadius: 8 },\n});\n\nexport default observer(Media);\n\n'lemmy-fennec/Screens/Post/PostScreen.tsx'\n:import React from \"react\";\nimport { ActivityIndicator, Animated, View } from \"react-native\";\n\nimport { useTheme } from \"@react-navigation/native\";\nimport { NativeStackScreenProps } from \"@react-navigation/native-stack\";\nimport { observer } from \"mobx-react-lite\";\n\nimport { Icon, TouchableOpacity } from \"../../ThemedComponents\";\nimport DynamicHeader from \"../../components/DynamicHeader\";\nimport ExpandedPost from \"../../components/Post/ExpandedPost\";\nimport { apiClient } from \"../../store/apiClient\";\nimport { preferences } from \"../../store/preferences\";\nimport CommentFlatList from \"./CommentsFlatlist\";\nimport CommentsFloatingMenu from \"./CommentsFloatingMenu\";\n\nlet lastOffset = 0;\n\nfunction PostScreen({\n  navigation,\n  route,\n}: NativeStackScreenProps<any, \"Feed\">) {\n  const scrollOffsetY = React.useRef(new Animated.Value(0)).current;\n\n  const [showFab, setShowFab] = React.useState(true);\n  const post = apiClient.postStore.singlePost;\n  const openComment = route.params.openComment;\n  const parentId = route.params.parentId;\n  const { colors } = useTheme();\n\n  const refreshAll = () => {\n    void apiClient.postStore.getSinglePost(route.params.post);\n    void apiClient.commentsStore.getComments(post.post.id, parentId);\n  };\n\n  React.useEffect(() => {\n    if (route.params.post) {\n      void apiClient.postStore.getSinglePost(route.params.post);\n    }\n    return () => {\n      apiClient.postStore.setSinglePost(null);\n    };\n  }, [route.params.post]);\n\n  React.useEffect(() => {\n    if (post) {\n      if (\n        post.counts.comments > 0\n\n      ) {\n        apiClient.commentsStore.setPage(1);\n        void apiClient.commentsStore.getComments(\n          post.post.id,\n          parentId,\n          Boolean(parentId)\n        );\n      }\n    }\n  }, [post]);\n\n  React.useEffect(() => {\n    return () => {\n      apiClient.commentsStore.setPage(1);\n      apiClient.commentsStore.setComments([]);\n    };\n  }, []);\n\n  const onScroll = React.useCallback(\n    (e: any) => {\n      if (preferences.disableDynamicHeaders) return;\n      const currentScrollY = e.nativeEvent.contentOffset.y;\n      const deltaY = currentScrollY - lastOffset;\n      const isGoingDown = currentScrollY > lastOffset;\n\n      if (isGoingDown) {\n\n        scrollOffsetY.setValue(Math.min(scrollOffsetY._value + deltaY, 56));\n      } else {\n\n        scrollOffsetY.setValue(Math.max(scrollOffsetY._value + deltaY, 0));\n      }\n\n      if (showFab !== !isGoingDown) setShowFab(!isGoingDown);\n\n      lastOffset = currentScrollY;\n    },\n    [showFab, scrollOffsetY, preferences.disableDynamicHeaders]\n  );\n\n  if (!post) return <ActivityIndicator />;\n\n  const getAuthor = (id: number) => {\n    navigation.navigate(\"User\", { personId: id });\n  };\n\n  const openCommenting = () => {\n    navigation.navigate(\"CommentWrite\");\n  };\n\n  const onEndReached = () => {\n\n    return console.log(\"endreached\", apiClient.commentsStore.comments.length);\n\n\n\n\n\n\n\n\n\n\n\n  };\n\n  const showAllButton = Boolean(parentId);\n  return (\n    <View style={{ flex: 1 }}>\n      <DynamicHeader\n        animHeaderValue={scrollOffsetY}\n        title={post.post.name || \"Post\"}\n        leftAction={\n          <TouchableOpacity\n            style={{ marginLeft: 16 }}\n            simple\n            onPressCb={() => navigation.goBack()}\n          >\n            <Icon name={\"arrow-left\"} color={colors.text} size={24} />\n          </TouchableOpacity>\n        }\n      />\n\n      <CommentFlatList\n        getAuthor={getAuthor}\n        header={\n          <ExpandedPost\n            post={post}\n            navigation={navigation}\n            showAllButton={showAllButton}\n          />\n        }\n        refreshing={apiClient.commentsStore.isLoading}\n        comments={apiClient.commentsStore.commentTree}\n        colors={colors}\n        onRefresh={refreshAll}\n        onEndReached={onEndReached}\n        openComment={openComment}\n        openCommenting={openCommenting}\n        navigation={navigation}\n        onScroll={onScroll}\n        scrollEventThrottle={8}\n        level={1}\n        footer={<View style={{ height: 112, width: \"100%\" }} />}\n      />\n      {showFab ? (\n        <CommentsFloatingMenu isLoading={apiClient.commentsStore.isLoading} />\n      ) : null}\n    </View>\n  );\n}\n\nexport default observer(PostScreen);\n",
        "gt": [
            "'lemmy-fennec/components/Post/ImageViewer.tsx'",
            "'lemmy-fennec/components/Post/Media.tsx'",
            "'lemmy-fennec/components/Post/ExpandedPost.tsx'",
            "'lemmy-fennec/Screens/Post/PostScreen.tsx'",
            "'lemmy-fennec/App.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/shared/utils.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/shared/constants.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/shared/utils.ts'\n:import latinize = require('latinize');\nimport { isNil as _isNil } from 'lodash';\nimport * as moment from 'moment';\n\nimport { Constants } from './constants';\nimport env_variables from './env_variables';\nimport { logger } from './logger';\n\n\nexport namespace Utils {\n  export function concatParams(base: string, ...params: string[]) {\n    let str = base;\n    for (const param of params) {\n      if (param !== undefined && param !== null && param.length > 0) {\n        str = str + ':' + param;\n      } else {\n        break;\n      }\n    }\n    return str;\n  }\n\n  export function DateNow() {\n    return moment().utc();\n  }\n\n  export function unixToDate(unix: number): moment.Moment {\n    return moment.unix(unix);\n  }\n\n  export function dateToMoment(date: Date): moment.Moment {\n    if (date) {\n      return moment(date);\n    }\n    return null;\n  }\n\n  export function normalizeString(str: string) {\n    if (!str) {\n      return str;\n    }\n    return latinize(str).toLowerCase();\n  }\n\n  export async function omitReject<T>(promise: Promise<T>) {\n    return promise.then<T>(d => d).catch<null>(err => {\n      logger.debug('OmitReject Error', { err: JSON.stringify(err) });\n      return null;\n    });\n  }\n\n  export function isRequestAuthenticated(request: Express.Request) {\n    if (env_variables.isDev) {\n      return true;\n    }\n    return isNil(request.cognitoClaims);\n  }\n\n  export function isNil(...value: any) {\n    return value.every((e: any) => _isNil(e));\n  }\n\n  export function isSomeNil(...value: any) {\n    return value.some((e: any) => _isNil(e));\n  }\n  export function logThrowError(errorDesc: string, params: any) {\n    return err => {\n      logError(errorDesc, err, params);\n      throw err;\n    };\n  }\n\n  export function logError(errorDesc: string, err: any, params: any) {\n    let errMessage;\n    if (!err.requestId) {\n\n      errMessage = err.message;\n    }\n    logger.error(`Error: ${errorDesc}`, {\n      data: {\n        params: params,\n        error: errMessage || err,\n      },\n    });\n  }\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/shared/constants.ts'\n:import { ContestType } from './enums';\nimport env_variables from './env_variables';\n\n\nexport namespace Constants {\n  export const BaseYear = 2017;\n  export const TopScoreContestCount = 2;\n  export const TopScoreYearRange = 3;\n\n  export function ContestTypeTopPoints(category: ContestType): number {\n    switch (category) {\n      case ContestType.WorldChampionship:\n        return 2000;\n      case ContestType.WorldCup:\n        return 1500;\n      case ContestType.Masters:\n        return 900;\n      case ContestType.GrandSlam:\n        return 600;\n      case ContestType.Open:\n        return 300;\n      case ContestType.Challenge:\n        return 150;\n      default:\n        throw new Error('Contest Category Top Points not found: ' + category);\n    }\n  }\n\n  export function ContestScoringRange(category: ContestType): number {\n    switch (category) {\n      case ContestType.WorldChampionship:\n        return 18;\n      case ContestType.WorldCup:\n        return 16;\n      case ContestType.Masters:\n        return 14;\n      case ContestType.GrandSlam:\n        return 12;\n      case ContestType.Open:\n        return 10;\n      case ContestType.Challenge:\n        return 8;\n      default:\n        throw new Error('Contest Scoring Range not found: ' + category);\n    }\n  }\n\n  export function ContestTypeMinParticipantsLimit(category: ContestType): number {\n    if (env_variables.isDev) {\n      return 2;\n    }\n    switch (category) {\n      case ContestType.WorldChampionship:\n        return 11;\n      case ContestType.WorldCup:\n        return 9;\n      case ContestType.Masters:\n        return 7;\n      case ContestType.GrandSlam:\n        return 5;\n      case ContestType.Open:\n        return 3;\n      case ContestType.Challenge:\n        return 3;\n      default:\n        throw new Error('Contest Category Participant Limit not found: ' + category);\n    }\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/shared/constants.ts'",
            "'Rankings-Backend/src/shared/utils.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'meditations/src/habits/containers/HabitsRoot.tsx'",
            "'meditations/src/habits/components/ProjectScope.tsx'",
            "'meditations/src/habits/main.tsx'",
            "'meditations/src/habits/components/HabitsControlBar.tsx'"
        ],
        "content": "'meditations/src/habits/containers/HabitsRoot.tsx'\n:import * as React from \"react\";\nimport HTML5Backend from \"react-dnd-html5-backend\";\nimport moment from \"moment\";\n\nimport * as common from \"../../common\";\nimport { MOUNT_NEXT_DAY_TIME } from \"../../common/constants\";\nimport { HabitsState, Scope } from \"../state\";\nimport { CommonUI } from \"../../common/components/CommonUI\";\nimport { Spinner } from \"../../common/components/Spinner\";\n\nimport { HabitsControlBar } from \"../components/HabitsControlBar\";\nimport { TimeScope } from \"../components/TimeScope\";\nimport { ProjectScope } from \"../components/ProjectScope\";\nimport { ProjectList } from \"../components/ProjectList\";\nimport { DndProvider } from \"react-dnd\";\n\nexport const HabitsRoot = common.connect()(\n  class extends React.Component<HabitsState> {\n\n    renderTimeScope(s?: Scope, i?: number) {\n      if (s) {\n\n        return (\n          <TimeScope\n            currentProject={this.props.currentProject}\n            key={i}\n            currentDate={this.props.currentDate}\n            scope={s}\n            filter={this.props.filter}\n            lastModifiedTask={this.props.lastModifiedTask}\n            mostRecentDay={i !== undefined && i === 0 ? true : false}\n          />\n        );\n      }\n      return <Spinner />;\n    }\n\n\n    renderProjects() {\n      if (this.props.currentProject === 0) {\n        return (\n          <ProjectList\n            hiddenProjects={this.props.hiddenProjects}\n            pinnedProjects={this.props.pinnedProjects}\n            unpinnedProjects={this.props.unpinnedProjects}\n            projectStatsDays={this.props.projectStatsDays}\n          />\n        );\n      }\n\n      if (\n        this.props.project &&\n        this.props.currentProject === this.props.project.Scope\n      ) {\n        return (\n          <ProjectScope\n            currentDate={this.props.currentDate}\n            scope={this.props.project}\n            projectStatsDays={this.props.projectStatsDays}\n          />\n        );\n      }\n\n\n      return <Spinner />;\n    }\n\n    renderDays() {\n      let { days } = this.props;\n\n      const today = moment();\n\n      if (\n        this.props.currentDate.month() === today.month() &&\n        this.props.currentDate.year() === today.year()\n      ) {\n\n\n\n\n\n        days = days.filter(\n          (d, i) =>\n            i === days.length ||\n\n            d.Date.date() <= today.date() ||\n            (d.Date.date() === today.date() + 1 &&\n              today.hour() > 24 - MOUNT_NEXT_DAY_TIME)\n        );\n      }\n\n      return days.map((d, i) => this.renderTimeScope(d, i));\n    }\n\n    render() {\n      return (\n        <div id=\"habits-root-sub\">\n          <DndProvider backend={HTML5Backend}>\n            <CommonUI {...this.props}>\n              <HabitsControlBar {...this.props} />\n              <div className=\"d-flex flex-column flex-md-row\">\n                <div id=\"scope-days\" className=\"scope-column mr-md-1\">\n                  {this.props.days ? this.renderDays() : <Spinner />}\n                </div>\n                <div id=\"scope-month\" className=\"scope-column mr-md-1\">\n                  {this.renderTimeScope(this.props.month)}\n                </div>\n                <div id=\"scope-year\" className=\"scope-column mr-md-1\">\n                  {this.renderTimeScope(this.props.year)}\n                </div>\n                <div id=\"scope-projects\" className=\"scope-column\">\n                  {this.props.pinnedProjects ? (\n                    this.renderProjects()\n                  ) : (\n                    <Spinner />\n                  )}\n                </div>\n              </div>\n            </CommonUI>\n          </DndProvider>\n        </div>\n      );\n    }\n  }\n);\n\n'meditations/src/habits/components/ProjectScope.tsx'\n:import * as React from \"react\";\nimport moment from \"moment\";\nimport { ModalProvider, modalContext } from \"../../common/modal\";\n\nimport { TaskNew } from \"../api\";\nimport * as common from \"../../common\";\nimport { Scope } from \"../state\";\nimport { createCTask } from \"./Task\";\nimport { OcticonButton } from \"../../common/components/OcticonButton\";\nimport { OcticonPlus } from \"../../common/octicons\";\n\nexport interface ProjectScopeProps {\n  currentDate: moment.Moment;\n  scope: Scope;\n  projectStatsDays: number;\n}\n\n\nexport class ProjectScope extends React.PureComponent<ProjectScopeProps> {\n  changeProject(e: React.SyntheticEvent<HTMLSelectElement>) {\n    e.persist();\n    const projectID = parseInt(e.currentTarget.value, 10);\n\n    if (isNaN(projectID)) return;\n\n    route(\n      `view/${this.props.currentDate.format(common.MONTH_FORMAT)}/${projectID}`\n    );\n  }\n\n  addTask = (modal: ModalProvider) => {\n    return modal.openModalPrompt(\"Enter task name\", \"New task\", Name => {\n      if (Name) {\n        TaskNew({\n          Name,\n          Date: this.props.scope.Date,\n          Scope: this.props.scope.Scope\n        });\n      }\n    });\n  };\n\n  render() {\n    const tasks = this.props.scope.Tasks.map(t => createCTask(t));\n\n    return (\n      <section className=\"scope bg-gray\">\n        <div className=\"scope-header d-flex flex-row flex-justify-between p-1 \">\n          <h3 className=\"scope-title border-bottom \">\n            <span>\n              <a\n                href={`#view/${this.props.currentDate.format(\n                  common.MONTH_FORMAT\n                )}/0`}\n              >\n                Projects\n              </a>\n            </span>\n            <span> &gt; {this.props.scope.Name}</span>\n          </h3>\n\n          <modalContext.Consumer>\n            {modal => (\n              <OcticonButton\n                className=\"flex-self-center\"\n                icon={OcticonPlus}\n                tooltip=\"New task\"\n                onClick={this.addTask(modal)}\n              />\n            )}\n          </modalContext.Consumer>\n        </div>\n\n        {tasks}\n      </section>\n    );\n  }\n}\n\n'meditations/src/habits/main.tsx'\n:\n\nimport * as React from \"react\";\nimport moment from \"moment\";\nimport route from \"riot-route\";\nimport { reverse, rangeRight } from \"lodash\";\n\nimport * as common from \"../common\";\n\nimport {\n  ScopeType,\n  Project,\n  Task,\n  store,\n  dispatch,\n  HabitsState,\n  dispatchProjectListUpdate\n} from \"./state\";\nimport { HabitsRoot } from \"./containers/HabitsRoot\";\n\n\nexport const routeForView = (\n  date: moment.Moment | \"current\",\n  project?: number\n) => {\n\n  return `view/${\n    date === \"current\" ? date : date.format(common.MONTH_FORMAT)\n    }/${project ? project : 0}`;\n};\n\n\nexport const urlForView = (\n  date: moment.Moment | \"current\",\n  project?: number\n) => {\n  return `#${routeForView(date, project)}`;\n};\n\nexport const dispatchProjectUpdate = (id: number, days: number) => {\n  dispatch(dispatch => {\n    common.get(`/habits/project/${id}/${days}`, (response: Project) => {\n      dispatch({\n        type: \"UPDATE_PROJECT\",\n        project: response\n      });\n    });\n  });\n};\n\n\nexport const main = () => {\n\n  common.installRouter(\n    \"/habits#\",\n    `view/${moment().format(common.MONTH_FORMAT)}/0`,\n    {\n      no_action: () => {\n        route(routeForView(moment(), 0));\n      },\n      habits: () => { },\n      view: (datestr: string, scopestr: string) => {\n        const state = store.getState() as HabitsState;\n        const project = parseInt(scopestr, 10);\n\n\n\n\n        if (datestr === \"current\") {\n          route(routeForView(state.currentDate, project), \"?\", true);\n        }\n\n        if (state === undefined) return;\n        const date =\n          datestr === \"current\"\n            ? state.currentDate\n            : moment(datestr, common.MONTH_FORMAT);\n\n\n\n\n\n\n        if (state === undefined) return;\n        const prevDate = state.currentDate;\n        const prevProject = state.currentProject;\n\n        let timeChanged: \"NO_CHANGE\" | \"CHANGE_YEAR\" | \"CHANGE_MONTH\" =\n          \"NO_CHANGE\";\n\n        if (state.mounted === false) {\n\n          timeChanged = \"CHANGE_YEAR\";\n        } else if (\n          date.format(common.DAY_FORMAT) !== prevDate.format(common.DAY_FORMAT)\n        ) {\n\n          timeChanged = \"CHANGE_MONTH\";\n          if (date.year() !== prevDate.year()) {\n            timeChanged = \"CHANGE_YEAR\";\n          }\n        }\n\n        const projectChanged = prevProject !== project;\n\n        common.setTitle(\"Habits\", `${date.format(\"MMMM YYYY\")}`);\n        dispatch({ date, type: \"CHANGE_ROUTE\", currentProject: project });\n\n\n        if (timeChanged === \"CHANGE_YEAR\" || timeChanged === \"CHANGE_MONTH\") {\n          dispatch(dispatch => {\n            const qs = `/habits/in-month-and-days?date=${date.format(\n              common.DAY_FORMAT\n            )}`;\n            common.get(qs, (response: { Days: Task[]; Month: Task[] }) => {\n\n              const array = rangeRight(date.daysInMonth()).map((_, i) => ({\n                Date: moment(date)\n                  .clone()\n                  .date(i + 1)\n                  .format(common.DAY_FORMAT),\n                Tasks: [] as Task[]\n              }));\n\n              response.Days.forEach(t => {\n                common.processModel(t);\n                array[t.Date.date() - 1].Tasks.push(t);\n              });\n\n              response.Month.forEach(common.processModel);\n\n              dispatch({\n                date,\n                type: \"MOUNT_DAYS_AND_SCOPE\",\n                days: reverse(array),\n                scope: ScopeType.MONTH,\n                tasks: response.Month\n              });\n            });\n          });\n        }\n\n        if (timeChanged === \"CHANGE_YEAR\") {\n          dispatch(dispatch => {\n            common.get(\n              `/habits/in-year?date=${date.format(common.DAY_FORMAT)}`,\n              (tasks: Task[]) => {\n                tasks.forEach(common.processModel);\n                dispatch({\n                  date,\n                  tasks,\n                  type: \"MOUNT_SCOPE\",\n                  scope: ScopeType.YEAR\n                });\n              }\n            );\n          });\n        }\n\n\n        if (!state.pinnedProjects) {\n          dispatchProjectListUpdate(state.projectStatsDays);\n        }\n\n\n        if (projectChanged) {\n          dispatch(dispatch => {\n            common.get(\n              `/habits/in-project/${project}`,\n              (response: {\n                scope: { Name: string; ID: number };\n                tasks: Task[];\n              }) => {\n                response.tasks.forEach(common.processModel);\n                dispatch({\n                  date,\n                  type: \"MOUNT_SCOPE\",\n                  name: response.scope.Name,\n                  scope: response.scope.ID,\n                  tasks: response.tasks\n                });\n              }\n            );\n          });\n        }\n      }\n    }\n  );\n\n\n  type HabitMessage =\n    | {\n      Type: \"UPDATE_TASKS_AND_PROJECT\";\n      Datum: {\n        Tasks: Task[];\n        ProjectID?: number;\n      };\n    }\n    | {\n      Type: \"UPDATE_SCOPE\";\n      Datum: {\n        Date: string;\n        Scope: number;\n        Tasks: Task[];\n        Name: string;\n      };\n    }\n    | {\n      Type: \"GET_PROJECT_LIST\";\n      Datum: {\n        Pinned: Project[];\n        Unpinned: Project[];\n      };\n    }\n    | {\n      Type: \"GET_PROJECT\";\n      Datum: Project;\n    };\n\n  common.makeSocket(\"habits/sync\", (msg: HabitMessage) => {\n    console.log(\"Received WebSocket message\", msg);\n    switch (msg.Type) {\n      case \"UPDATE_TASKS_AND_PROJECT\":\n        msg.Datum.Tasks.forEach(common.processModel);\n\n        dispatch({\n          type: \"UPDATE_TASKS\",\n          tasks: msg.Datum.Tasks\n        });\n\n        if (msg.Datum.ProjectID) {\n          dispatchProjectUpdate(\n            msg.Datum.ProjectID,\n            store.getState().projectStatsDays\n          );\n        }\n        break;\n\n      case \"UPDATE_SCOPE\":\n        msg.Datum.Tasks.forEach(common.processModel);\n        dispatch({\n          type: \"MOUNT_SCOPE\",\n          date: moment(msg.Datum.Date, common.DAY_FORMAT),\n          scope: msg.Datum.Scope,\n          tasks: msg.Datum.Tasks,\n          name: msg.Datum.Name\n        });\n        break;\n\n      case \"GET_PROJECT\":\n        dispatchProjectUpdate(msg.Datum.ID, store.getState().projectStatsDays);\n        break;\n\n      case \"GET_PROJECT_LIST\":\n        dispatchProjectListUpdate(store.getState().projectStatsDays);\n        break;\n    }\n  });\n\n\n  common.render(\"root\", store, React.createElement(HabitsRoot));\n};\n\n'meditations/src/habits/components/HabitsControlBar.tsx'\n:import * as React from \"react\";\nimport moment from \"moment\";\nimport * as Mousetrap from \"mousetrap\";\n\nimport { routeForView } from \"../main\";\nimport { dispatch, HabitsState } from \"../state\";\nimport DatePicker from \"react-datepicker\";\n\nimport * as common from \"../../common\";\nimport { KEYSEQ_FILTER_FOCUS } from \"../../common/constants\";\nimport { TimeNavigator } from \"../../common/components/TimeNavigator\";\n\n\nexport class HabitsControlBar extends React.PureComponent<HabitsState> {\n  filterByNameElement!: HTMLInputElement | null;\n\n  componentDidMount() {\n    Mousetrap.bind(KEYSEQ_FILTER_FOCUS, () => {\n      if (this.filterByNameElement) {\n        this.filterByNameElement.focus();\n      }\n      return false;\n    });\n  }\n\n  componentWillUnmount() {\n    Mousetrap.unbind(KEYSEQ_FILTER_FOCUS);\n  }\n\n\n  navigatorRoute = (\n    method: \"add\" | \"subtract\" | \"reset\",\n    unit?: \"month\" | \"year\" | \"day\"\n  ) => {\n    if (method === \"reset\") {\n      return routeForView(moment(), this.props.currentProject);\n    } else if (unit) {\n\n      const ndate = this.props.currentDate.clone()[method](1, unit);\n      return routeForView(ndate, this.props.currentProject);\n    }\n  };\n\n  navigate = (method: \"add\" | \"subtract\", unit: \"month\" | \"year\") => {\n    const ndate = this.props.currentDate.clone()[method](1, unit);\n    route(routeForView(ndate, this.props.currentProject));\n  };\n\n  filterByName = (e: React.ChangeEvent<HTMLInputElement>) => {\n    dispatch({ name: e.target.value, type: \"FILTER_BY_NAME\" });\n  };\n\n  filterByDate(end: boolean, date: moment.Moment | null) {\n    if (date) {\n      dispatch({ date, end, type: \"FILTER_BY_DATE\" });\n    }\n  }\n\n  clearFilter() {\n    dispatch({ type: \"FILTER_CLEAR\" });\n  }\n\n  exportTasks() {\n    const body: any = { day: true };\n\n    let filename = \"\";\n\n\n    if (this.props.filter.name) {\n      body.Name = this.props.filter.name;\n      filename += `-${this.props.filter.name}`;\n    }\n\n\n    if (this.props.filter.begin) {\n      body.Begin = this.props.filter.begin.format(common.DAY_FORMAT);\n      filename += `-from-${this.props.filter.begin.format(common.DAY_FORMAT)}`;\n    }\n\n    if (this.props.filter.end) {\n      body.End = this.props.filter.end.format(common.DAY_FORMAT);\n      filename += `-to-${this.props.filter.end.format(common.DAY_FORMAT)}`;\n    }\n\n    common.post(\"/habits/export\", body, (res: any) => {\n      const elt = document.createElement(\"a\");\n      elt.setAttribute(\n        \"href\",\n        `data:text/plain;charset=utf-8,${encodeURIComponent(res.body)}`\n      );\n      elt.setAttribute(\"download\", `meditations-export${filename}.txt`);\n      elt.style.display = \"none\";\n      document.body.appendChild(elt);\n      elt.click();\n      document.body.removeChild(elt);\n    });\n  }\n\n  renderDatePicker(\n    end: boolean,\n    defaultPlaceholder: string,\n    value?: moment.Moment | null\n  ) {\n\n    return (\n      <DatePicker\n        className=\"form-control ml-0 ml-md-1 mb-md-0 mb-1\"\n        onChange={date => this.filterByDate(end, date)}\n        isClearable={true}\n        placeholderText={defaultPlaceholder}\n        value={value ? value.format(common.DAY_FORMAT) : \"\"}\n        openToDate={this.props.currentDate}\n      />\n    );\n  }\n\n  render() {\n\n    const disableButton = !(\n      this.props.filter.name ||\n      this.props.filter.begin ||\n      this.props.filter.end\n    );\n\n\n    return (\n      <div\n        id=\"controls\"\n        className=\"d-flex flex-column flex-md-row flex-items-start flex-justify-between ml-3 mr-2 mt-2 mb-2\"\n      >\n        <TimeNavigator\n          daysOnly={false}\n          getRoute={this.navigatorRoute}\n          currentDate={this.props.currentDate}\n        />\n\n        <div className=\"d-flex flex-column flex-md-row\">\n          <input\n            type=\"text\"\n            placeholder={`Filter by name (Key: ${KEYSEQ_FILTER_FOCUS})`}\n            ref={e => (this.filterByNameElement = e)}\n            className=\"form-control mb-md-0 mb-1 ml-\"\n            onChange={this.filterByName}\n          />\n\n          {this.renderDatePicker(\n            false,\n            \"Filter from...\",\n            this.props.filter.begin\n          )}\n\n          {this.renderDatePicker(true, \"...to\", this.props.filter.end)}\n\n          <button\n            disabled={disableButton}\n            className=\"btn btn-secondary btn-block ml-0 ml-md-1 mb-md-0 mb-1\"\n            onClick={() => this.clearFilter()}\n          >\n            Clear date filter\n          </button>\n          <button\n            disabled={disableButton}\n            className=\"btn btn-primary btn-block ml-0 ml-md-1 mb-md-0 mb-1\"\n            onClick={() => this.exportTasks()}\n          >\n            Export selected tasks\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n",
        "gt": [
            "'meditations/src/habits/components/ProjectScope.tsx'",
            "'meditations/src/habits/containers/HabitsRoot.tsx'",
            "'meditations/src/habits/main.tsx'",
            "'meditations/src/habits/components/HabitsControlBar.tsx'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { DDBRepository, LocalSecondaryIndexName } from '../dynamodb.repo';\nimport { LSILastEvaluatedKey } from '../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../utils/utils';\nimport { AllAttrs, DDBContestItem, KeyAttrs } from './contest.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBContestRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async get(contestId: string, discipline: Discipline) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBContestRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async put(contest: DDBContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBContestRepository Put', params));\n  }\n  public async delete(contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBContestRepository Delete', params));\n  }\n\n  public async updateProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(discipline, contestId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBContestRepository updateUrl', params));\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: !opts.descending,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and begins_with(#lsi, :sortKeyPrefix) ',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(),\n        ':sortKeyPrefix': this.transformer.itemToAttrsTransformer.LSI((opts.year || '').toString()),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBContestRepository query', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(after?: {\n    contestId: string;\n    discipline: Discipline;\n    date: string;\n  }): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date && after.discipline) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[]; name?: string; id?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    if (filter.name) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedName, :queryString)`;\n      filterExpAttrNames['#normalizedName'] = this.transformer.attrName('normalizedName');\n      filterExpAttrValues[':queryString'] = filter.name;\n    }\n    if (filter.id) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#sk_gsi, :id)`;\n      filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n      filterExpAttrValues[':id'] = filter.id;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/contests/contest.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'hydrated-ws/src/IHydratedWebSocketEventMap.ts'",
            "'hydrated-ws/src/router/Router.spec.ts'",
            "'hydrated-ws/src/router/Router.ts'",
            "'hydrated-ws/src/router/RoutedWebSocket.ts'"
        ],
        "content": "'hydrated-ws/src/IHydratedWebSocketEventMap.ts'\n:export default interface IHydratedWebSocketEventMap extends WebSocketEventMap {\n    \"connecting\": CustomEvent<number>;\n}\n\n'hydrated-ws/src/router/Router.spec.ts'\n:\n\nimport WebSocket from \"../polyfill/WebSocket\";\n\nimport {expect} from \"chai\";\nimport {IRouterConnector} from \"./IRouterConnector\";\nimport {Router} from \"./Router\";\nimport {DummyRouterConnector} from \"./DummyRouterConnector\";\nimport MessageEvent from \"../polyfill/MessageEvent\";\n\n\nclass MockWebsocketClass {\n    public received: any[] = [];\n    public closed: { code: number, reason: string } = void 0;\n    public onmessage: any;\n    public listeners: { open: any[], close: any[], message: any[] } = {open: [], close: [], message: []};\n\n    constructor(public readyState: number = WebSocket.OPEN) {\n        setTimeout(() => {\n            if (this.readyState === WebSocket.OPEN) {\n                return;\n            }\n            this.readyState = WebSocket.OPEN;\n            this.listeners.open.forEach(((clb) => clb()));\n        });\n    }\n\n    public send(data: any) {\n        this.received.push(data);\n        const event = new MessageEvent(\"message\", {\n            data\n        });\n        if (this.onmessage) {\n            this.onmessage(data);\n        }\n        this.listeners.message.forEach((callback) => callback(event));\n\n    }\n\n\n    public close(code?: number, reason?: string) {\n        this.closed = {code, reason};\n        this.readyState = WebSocket.CLOSED;\n        setTimeout(() => this.listeners.close.forEach(((clb) => clb())));\n\n    }\n\n    public addEventListener(event: \"open\" | \"close\" | \"message\", callback: (e: any) => void) {\n        this.listeners[event].push(callback);\n    }\n}\n\nconst MockWebsocket = MockWebsocketClass as any;\n\ndescribe(\"Router\", () => {\n    describe(\"set\", () => {\n        it(\"should add the Websocket\", () => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            router.set(\"id\", ws1);\n        });\n        it(\"should replace the Websocket and close the old one\", () => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            const ws2 = new MockWebsocket();\n            router.set(\"id\", ws1);\n            router.set(\"id\", ws2);\n            expect(ws1.closed).to.not.be.undefined;\n        });\n        it(\"should overwrite the Websocket\", () => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            router.set(\"id\", ws1);\n            const ws2 = new MockWebsocket();\n            router.set(\"id\", ws2);\n            router.get(\"id\").send(\"test\");\n            expect(ws1.received.length).to.equal(0);\n            expect(ws2.received.length).to.equal(1);\n        });\n    });\n    describe(\"delete\", () => {\n        it(\"should remove the Websocket\", () => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            router.set(\"id\", ws1);\n            const ws = router.get(\"id\");\n            router.delete(\"id\");\n            expect(ws.readyState).to.equal(WebSocket.CLOSED);\n        });\n    });\n    describe(\"clear\", () => {\n        it(\"should remove the Websocket\", () => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            router.set(\"id\", ws1);\n            const ws = router.get(\"id\");\n            router.clear();\n            expect(ws.readyState).to.equal(WebSocket.CLOSED);\n        });\n    });\n\n    describe(\"get\", () => {\n        it(\"should get a virtual Websocket receiving messages onmessage\", (done) => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            router.set(\"id\", ws1);\n            router.get(\"id\").onmessage = (e) => {\n                router.destroy();\n                done();\n            };\n            ws1.send(\"test should get a virtual Websocket receiving message\");\n        });\n\n        it(\"should get a virtual Websocket receiving messages addListener\", (done) => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            router.set(\"id\", ws1);\n            router.get(\"id\").addEventListener(\"message\", (e) => {\n                router.destroy();\n                done();\n            });\n            ws1.send(\"test should get a virtual Websocket receiving message\");\n        });\n    });\n\n    describe(\"send\", () => {\n        it(\"should send to the correct ws\", () => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            const ws2 = new MockWebsocket();\n            router.set(\"id1\", ws1);\n            router.set(\"id2\", ws2);\n            router.get(\"id1\").send(\"test\");\n            expect(ws1.received.length).to.equal(1);\n            expect(ws2.received.length).to.equal(0);\n        });\n\n    });\n\n    describe(\"broadcast\", () => {\n        it(\"should broadcast to all the connected ws\", () => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            const ws2 = new MockWebsocket();\n            const ws3 = new MockWebsocket();\n            router.set(\"id1\", ws1);\n            router.set(\"id2\", ws2);\n            router.set(\"id3\", ws3);\n            ws3.close();\n            router.broadcast(\"test\");\n            expect(ws1.received.length).to.equal(1);\n            expect(ws2.received.length).to.equal(1);\n            expect(ws3.received.length).to.equal(0);\n        });\n        it(\"should only broadcast if the ws are connected\", () => {\n            const router = new Router();\n            const ws1 = new MockWebsocket();\n            const ws2 = new MockWebsocket();\n            router.set(\"id1\", ws1);\n            router.set(\"id2\", ws2);\n            ws1.readyState = WebSocket.CLOSING;\n            router.broadcast(\"test\");\n            expect(ws1.received.length).to.equal(0);\n            expect(ws2.received.length).to.equal(1);\n        });\n    });\n\n    describe(\"connector\", () => {\n        let router1: Router;\n        let router2: Router;\n        let ws1: any;\n        let ws2: any;\n        beforeEach(() => {\n            const connector1 = new DummyRouterConnector();\n            const connector2 = new DummyRouterConnector();\n            router1 = new Router();\n            router1.connector = connector1;\n            router2 = new Router();\n            router2.connector = connector2;\n            ws1 = new MockWebsocket(WebSocket.CONNECTING);\n            ws2 = new MockWebsocket(WebSocket.OPEN);\n            router1.set(\"id1\", ws1);\n            router2.set(\"id2\", ws2);\n        });\n        afterEach(() => {\n            DummyRouterConnector.clear();\n        });\n        it(\"should broadcast\", (done) => {\n            setTimeout(() => {\n                router1.broadcast(\"test\");\n                setTimeout(() => {\n                    expect(ws1.received.length).to.equal(1);\n                    expect(ws2.received.length).to.equal(1);\n                    done();\n                });\n            });\n        });\n        it(\"should broadcast to open only\", (done) => {\n            setTimeout(() => {\n                ws2.close();\n                router1.broadcast(\"test\");\n                expect(ws1.received.length).to.equal(1);\n                expect(ws2.received.length).to.equal(0);\n                done();\n            });\n        });\n        it(\"should transmit messages to a remote websocket\", (done) => {\n            setTimeout(() => {\n                router1.get(\"id2\").send(\"test\");\n                expect(ws1.received.length).to.equal(0);\n                expect(ws2.received.length).to.equal(1);\n                done();\n            });\n        });\n        it(\"should get the remote websocket state\", (done) => {\n            const ws = router1.get(\"id2\");\n            setTimeout(() => {\n                expect(ws.readyState).to.equal(WebSocket.OPEN);\n                done();\n            }, 10);\n        });\n        it(\"should emit messages on a remote routed websocket\", (done) => {\n            setTimeout(() => {\n                router1.get(\"id2\").onmessage = () => done();\n                ws2.send(\"test\");\n            });\n        });\n        it(\"should transmit messages to a remote if open only\", (done) => {\n            setTimeout(() => {\n                ws2.close();\n                router1.get(\"id2\").send(\"test\");\n                expect(ws1.received.length).to.equal(0);\n                expect(ws2.received.length).to.equal(0);\n                done();\n            });\n        });\n        it(\"should get twice the same remote websocket\", (done) => {\n            setTimeout(() => {\n                router1.get(\"id2\").send(\"test\");\n                router1.get(\"id2\").send(\"test\");\n                expect(ws1.received.length).to.equal(0);\n                expect(ws2.received.length).to.equal(2);\n                done();\n            });\n        });\n        it(\"should close a remote websocket\", (done) => {\n            setTimeout(() => {\n                router1.get(\"id2\").close(999, \"test\");\n                expect(ws2.closed).to.deep.equal({code: 999, reason: \"test\"});\n                done();\n            });\n        });\n        it(\"should replace a remote websocket\", (done) => {\n            setTimeout(() => {\n                const ws3 = new MockWebsocket();\n                router1.set(\"id2\", ws3);\n                expect(ws2.closed).to.not.be.undefined;\n                done();\n            });\n        });\n        it(\"should replace a connector\", (done) => {\n            setTimeout(() => {\n                const connector3 = new DummyRouterConnector();\n                router1.connector = connector3;\n                router1.get(\"id2\").send(\"test\");\n                expect(ws1.received.length).to.equal(0);\n                expect(ws2.received.length).to.equal(1);\n                done();\n            });\n        });\n        it(\"should delete a connector\", (done) => {\n            setTimeout(() => {\n                router1.connector = null;\n                router1.get(\"id2\").send(\"test\");\n                expect(ws1.received.length).to.equal(0);\n                expect(ws2.received.length).to.equal(0);\n                done();\n            });\n        });\n    });\n});\n\n'hydrated-ws/src/router/Router.ts'\n:import {Dict} from \"../polyfill/Dict\";\nimport WebSocket from \"../polyfill/WebSocket\";\nimport {IRouterConnector} from \"./IRouterConnector\";\nimport {RoutedWebSocket} from \"./RoutedWebSocket\";\n\n\nexport class Router {\n\n    public _connector: IRouterConnector;\n\n    private readonly localWebSockets: Dict<string, WebSocket> = new Dict();\n    private readonly virtualWebSockets: Dict<string, RoutedWebSocket> = new Dict();\n\n    public clear(): void {\n        this.localWebSockets.keys().forEach((key) => this.delete(key));\n        this.virtualWebSockets.keys().forEach((key) => this.delete(key));\n    }\n\n    public destroy() {\n        this.localWebSockets.values().forEach((ws) => ws.close());\n        this.virtualWebSockets.values().forEach((ws) => ws.close());\n        this.clear();\n    }\n\n    public set connector(value: IRouterConnector) {\n        if (this._connector) {\n            this._connector.onBroadcast = void 0;\n            this._connector.onMessage = void 0;\n            this._connector.onClose = void 0;\n            this._connector.onStatus = void 0;\n        }\n        this._connector = value;\n        if (value) {\n            this._connector.onBroadcast = this.onBroadcast.bind(this);\n            this._connector.onMessage = this.onMessage.bind(this);\n            this._connector.onClose = this.onClose.bind(this);\n            this._connector.onStatus = this.onStatus.bind(this);\n            this._connector.onRequestReadyState = this.onRequestReadyState.bind(this);\n        }\n    }\n\n    public onMessage(id: string, data: any): boolean {\n        const ws = this.localWebSockets.get(id);\n        if (ws && ws.readyState === WebSocket.OPEN) {\n            ws.send(data);\n            return true;\n        }\n    }\n\n    public onRequestReadyState(id: string, data: any): number {\n        const ws = this.localWebSockets.get(id);\n        if (ws && ws.readyState === WebSocket.OPEN) {\n            return ws.readyState;\n        }\n    }\n\n    public onStatus(id: string, status: number): void {\n        if (status === WebSocket.OPEN && this.localWebSockets.has(id) &&\n            this.localWebSockets.get(id) .readyState !== status) {\n            if (this.virtualWebSockets.has(id)) {\n                this.virtualWebSockets.get(id).setReadyState(WebSocket.CLOSED);\n            }\n            this.localWebSockets.delete(id);\n\n        }\n        const ws = this.virtualWebSockets.get(id);\n        if (ws) {\n            ws.setReadyState(status);\n        }\n    }\n\n    public onBroadcast(data: any): void {\n        this.localWebSockets.values().forEach((ws) => {\n            if (ws.readyState === WebSocket.OPEN) {\n                ws.send(data);\n            }\n        });\n    }\n\n    public onClose(id: string, code: number, reason: string): boolean {\n        const ws = this.localWebSockets.get(id);\n        if (ws) {\n            ws.close(code, reason);\n            return true;\n        }\n    }\n\n    public emitState(id: string, ws: WebSocket) {\n        this.setReadyState(id, ws.readyState);\n        if (this._connector) {\n            this._connector.readyState(id, ws.readyState);\n        }\n    }\n\n    public set(id: string, ws: WebSocket) {\n        if (this.localWebSockets.get(id) === ws) {\n            return;\n        }\n        this.close(id, 1000, \"Duplicate websocket\");\n        const openListener = () => this.emitState(id, ws);\n        const messageListener = (event: MessageEvent) => this.emitMessage(id, event);\n        const closeListener = (event) => {\n            if (this.localWebSockets.get(id) === ws) {\n                this.emitState(id, ws);\n            }\n        };\n        ws.addEventListener(\"open\", openListener);\n        ws.addEventListener(\"message\", messageListener);\n        ws.addEventListener(\"close\", closeListener);\n        if (this.virtualWebSockets.has(id) && this.virtualWebSockets.get(id).readyState === ws.readyState) {\n            this.virtualWebSockets.get(id).setReadyState(WebSocket.CLOSED);\n        }\n        this.localWebSockets.set(id, ws);\n        this.emitState(id, ws);\n    }\n\n    public delete(id: string) {\n        this.localWebSockets.delete(id);\n        this.setReadyState(id, WebSocket.CLOSED);\n    }\n\n    public get(id: string): WebSocket {\n        if (!this.virtualWebSockets.has(id)) {\n            const routedWs = this.createRoutedWebsocket(id);\n            this.virtualWebSockets.set(id, routedWs);\n            if (this.localWebSockets.has(id)) {\n                routedWs.setReadyState(this.localWebSockets.get(id).readyState);\n            } else {\n                if (this._connector) {\n                    this._connector.requestReadyState(id)\n                        .then((readyState) => {\n                            if (readyState && !routedWs.readyState) {\n                                routedWs.setReadyState(readyState);\n                            }\n                        })\n                        .catch( () => void 0);\n                }\n            }\n        }\n        const ws = this.virtualWebSockets.get(id);\n        return ws;\n    }\n\n    public onMessageSubscribe(id: string, ws: RoutedWebSocket) {\n        if (this._connector) {\n            this._connector.subscribe(id, ws);\n        }\n    }\n\n    public onMessageUnsubscribe(id: string, ws: RoutedWebSocket) {\n        if (this._connector) {\n            this._connector.unsubscribe(id, ws);\n        }\n    }\n\n    public broadcast(data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n        this.onBroadcast(data);\n        if (this._connector) {\n            this._connector.broadcast(data);\n        }\n    }\n\n    private createRoutedWebsocket(id: string): RoutedWebSocket {\n        return new RoutedWebSocket(\n            (data: string | ArrayBufferLike | Blob | ArrayBufferView) => this.send(id, data),\n            (code: number, reason: string) => this.close(id, code, reason),\n            (vWs) => this.onMessageSubscribe(id, vWs),\n            (vWs) => this.onMessageUnsubscribe(id, vWs),\n        );\n    }\n    private send(id: string, data: string | ArrayBufferLike | Blob | ArrayBufferView) {\n        const ws = this.localWebSockets.get(id);\n        if (ws && ws.readyState === WebSocket.OPEN) {\n            ws.send(data);\n        } else if (this._connector) {\n            this._connector.send(id, data);\n        }\n    }\n\n    private setReadyState(id, state: number) {\n        if (this.virtualWebSockets.has(id)) {\n            this.virtualWebSockets.get(id).setReadyState(state);\n        }\n    }\n\n    private emitMessage(id, event: MessageEvent) {\n        if (this.localWebSockets.has(id) && this.virtualWebSockets.has(id)) {\n            this.virtualWebSockets.get(id).emitMessage(event);\n        }\n        if (this._connector) {\n            this._connector.emitMessage(id, event);\n        }\n    }\n\n    private close(id: string, code: number, reason: string) {\n        this.setReadyState(id, WebSocket.CLOSED);\n        if (this.localWebSockets.has(id)) {\n            this.localWebSockets.get(id).close(code, reason);\n        } else if (this._connector) {\n            this._connector.close(id, code, reason);\n        }\n    }\n\n}\n\n'hydrated-ws/src/router/RoutedWebSocket.ts'\n:import {computedFrom} from \"../computedFrom\";\nimport IHydratedWebSocketEventMap from \"../IHydratedWebSocketEventMap\";\nimport CloseEvent from \"../polyfill/CloseEvent\";\nimport Event from \"../polyfill/Event\";\nimport WebSocket from \"../polyfill/WebSocket\";\nimport {Shell} from \"../Shell\";\n\nexport class RoutedWebSocket extends Shell {\n\n    public set onmessage(f: (ev: MessageEvent) => any) {\n        super.setOnmessage(f);\n        this.checkSubscriptions();\n    }\n\n    public get onmessage(): (ev: MessageEvent) => any {\n        return super.getOnmessage();\n    }\n\n    public get url(): string {\n        return \"\";\n    }\n\n    public get bufferedAmount(): number {\n        return 0;\n    }\n\n    public get extensions(): string {\n        return \"\";\n    }\n\n    public get protocol(): string {\n        return \"\";\n    }\n\n\n    public readonly CONNECTING = WebSocket.CONNECTING;\n\n    public readonly OPEN = WebSocket.OPEN;\n\n    public readonly CLOSING = WebSocket.CLOSING;\n\n    public readonly CLOSED = WebSocket.CLOSED;\n\n    private virtualReadyState: number = null;\n    private subscribed: boolean = false;\n\n    constructor(\n        private readonly routerSend: (data: string | ArrayBuffer | Blob | ArrayBufferView) => void,\n        private readonly routerClose: (code: number, reason: string) => void,\n        private readonly onMessageSubscribe?: (ws: RoutedWebSocket) => void,\n        private readonly onMessageUnsubscribe?: (ws: RoutedWebSocket) => void,\n    ) {\n        super();\n    }\n\n    public setReadyState(state: number) {\n        if (this.virtualReadyState === state) {\n            return;\n        }\n        this.virtualReadyState = state;\n        switch (state) {\n            case this.OPEN:\n                this.dispatchEvent(new Event(\"open\"));\n                break;\n            case this.CLOSED:\n                this.dispatchEvent(new CloseEvent(\"close\"));\n                break;\n            default:\n                break;\n        }\n    }\n\n    public addEventListener<K extends keyof IHydratedWebSocketEventMap>(type: K,\n                                                                        listener: (this: WebSocket,\n                                                                                   ev: IHydratedWebSocketEventMap[K])\n                                                                            => any,\n                                                                        useCapture?: boolean): void {\n        super.addEventListener(type, listener, useCapture);\n        this.checkSubscriptions();\n    }\n\n    public removeEventListener<K extends keyof IHydratedWebSocketEventMap>(type: K,\n                                                                           listener: (this: WebSocket,\n                                                                                      ev: IHydratedWebSocketEventMap[K])\n                                                                               => any,\n                                                                           useCapture?: boolean): void {\n        super.removeEventListener(type, listener, useCapture);\n        this.checkSubscriptions();\n    }\n\n    public emitMessage(event: MessageEvent) {\n        this.dispatchEvent(event);\n    }\n\n    public send(data: string | ArrayBuffer | Blob | ArrayBufferView): void {\n        this.routerSend(data);\n    }\n\n    public close(code: number = 1000, reason?: string) {\n        this.virtualReadyState = this.CLOSED;\n        this.routerClose(code, reason);\n    }\n\n    protected getReadyState(): number {\n        return this.virtualReadyState === null ? WebSocket.CONNECTING : this.virtualReadyState;\n    }\n\n    private checkSubscriptions() {\n        if (this.onmessage || (this.listeners.has(\"message\") && this.listeners.get(\"message\").length)) {\n            if (!this.subscribed) {\n                this.subscribed = true;\n                if (this.onMessageSubscribe) {\n                    this.onMessageSubscribe(this);\n                }\n            }\n\n        } else {\n            if (this.subscribed) {\n                this.subscribed = false;\n                if (this.onMessageUnsubscribe) {\n                    this.onMessageUnsubscribe(this);\n                }\n            }\n        }\n    }\n}\n",
        "gt": [
            "'hydrated-ws/src/IHydratedWebSocketEventMap.ts'",
            "'hydrated-ws/src/router/RoutedWebSocket.ts'",
            "'hydrated-ws/src/router/Router.ts'",
            "'hydrated-ws/src/router/Router.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { Discipline } from 'shared/enums';\nimport { DDBRepository, GlobalSecondaryIndexName, LocalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey, LSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteContestItem, KeyAttrs } from './athlete.contests.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nimport { Utils } from 'shared/utils';\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteContestsRepository extends DDBRepository {\n  protected _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteContestItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async put(contest: DDBAthleteContestItem) {\n    const params: DocumentClient.PutItemInput = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(contest),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Put', params));\n  }\n\n  public async delete(athleteId: string, contestId: string, discipline: Discipline) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId, discipline, contestId),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository Delete', params));\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createLSIExclusiveStartKey(athleteId, opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const startDate = opts.betweenDates ? opts.betweenDates.start.toISODate() : '';\n    const endDate = (opts.betweenDates && !Utils.isNil(opts.betweenDates.end)\n      ? opts.betweenDates.end\n      : Utils.DateNow().toDate()\n    ).toISODate();\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: LocalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#pk = :pk and #lsi BETWEEN :startDate AND :endDate',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#lsi': this.transformer.attrName('LSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(athleteId),\n        ':startDate': this.transformer.itemToAttrsTransformer.LSI(startDate),\n        ':endDate': this.transformer.itemToAttrsTransformer.LSI(endDate),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractLSILastEvaluatedKey(data.LastEvaluatedKey as LSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryAthleteContestsByDate', params));\n  }\n\n  public async queryContestAthletes(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(contestId, discipline, after);\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteContestsRepository queryContestAthletes', params));\n  }\n\n  private extractLSILastEvaluatedKey(lastEvaluatedKey: LSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        contestId: this.transformer.attrsToItemTransformer.contestId(lastEvaluatedKey.SK_GSI),\n        discipline: this.transformer.attrsToItemTransformer.discipline(lastEvaluatedKey.SK_GSI),\n        date: this.transformer.attrsToItemTransformer.date(lastEvaluatedKey.LSI),\n      };\n    }\n    return lastKey;\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        points: this.transformer.attrsToItemTransformer.points(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createLSIExclusiveStartKey(\n    athleteId: string,\n    after?: {\n      contestId: string;\n      discipline: Discipline;\n      date: string;\n    },\n  ): LSILastEvaluatedKey {\n    let startKey: LSILastEvaluatedKey;\n    if (after && after.contestId && after.date) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(after.discipline, after.contestId),\n        LSI: this.transformer.itemToAttrsTransformer.LSI(after.date),\n      };\n    }\n    return startKey;\n  }\n\n  private createGSIExclusiveStartKey(\n    contestId: string,\n    discipline: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && !Utils.isNil(after.points)) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.points),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { disciplines?: Discipline[] }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.disciplines) {\n      for (const discipline of filter.disciplines) {\n        filterExpression =\n          (filterExpression ? filterExpression + ' or ' : '') + `contains(#sk_gsi, :discipline_${discipline})`;\n        filterExpAttrNames['#sk_gsi'] = this.transformer.attrName('SK_GSI');\n        filterExpAttrValues[`:discipline_${discipline}`] = `:${discipline}:`;\n      }\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'\n:import { Discipline } from 'shared/enums';\nimport { DDBTableKeyAttrs } from '../../interfaces/table.interface';\n\nexport type KeyAttrs = DDBTableKeyAttrs;\n\ninterface Attrs {\n  readonly place: number;\n  readonly createdAt: number;\n}\n\ninterface NonKeyAttrs extends Attrs {}\nexport type AllAttrs = KeyAttrs & NonKeyAttrs;\n\nexport interface DDBAthleteContestItem extends Attrs {\n  readonly athleteId: string;\n  readonly contestId: string;\n  readonly discipline: Discipline;\n  readonly date: string;\n  readonly points: number;\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/attributes.transformer.ts'\n:import { Injectable } from '@nestjs/common';\nimport { DDBOverloadedTableTransformer } from 'core/database/dynamodb/dynamodb.table.transformers';\nimport { Discipline } from 'shared/enums';\nimport { Utils } from 'shared/utils';\nimport {\n  buildCompositeKey,\n  decodeStringToPoint,\n  destructCompositeKey,\n  encodePointToString,\n} from '../../../utils/utils';\nimport { AllAttrs, DDBAthleteContestItem, KeyAttrs } from '../athlete.contests.interface';\n\n\n@Injectable()\nexport class AttrsTransformer extends DDBOverloadedTableTransformer<AllAttrs, DDBAthleteContestItem> {\n  constructor() {\n    super();\n  }\n  public prefixes: KeyAttrs = {\n    PK: 'Athlete',\n    SK_GSI: 'Contest',\n    LSI: 'Contest',\n    GSI_SK: '',\n  };\n\n  public attrsToItemTransformer = {\n    athleteId: (pk: string) => destructCompositeKey(pk, 1),\n    contestId: (sk_gsi: string) => destructCompositeKey(sk_gsi, 2),\n    discipline: (sk_gsi: string) => parseInt(destructCompositeKey(sk_gsi, 1), 10),\n    date: (lsi: string) => destructCompositeKey(lsi, 1),\n    points: (gsi_sk: string) => decodeStringToPoint(gsi_sk),\n  };\n\n  public itemToAttrsTransformer = {\n    PK: (id: string) => buildCompositeKey(this.prefixes.PK, id),\n    SK_GSI: (discipline: Discipline, contestId: string) =>\n      buildCompositeKey(this.prefixes.SK_GSI, !Utils.isNil(discipline) && discipline.toString(), contestId),\n    LSI: (date: string) => buildCompositeKey(this.prefixes.LSI, date),\n    GSI_SK: (points: number) => encodePointToString(points),\n  };\n\n  public transformAttrsToItem(dynamodbItem: AllAttrs): DDBAthleteContestItem {\n    const { PK, SK_GSI, LSI, GSI_SK, ...rest } = dynamodbItem;\n    return {\n      athleteId: this.attrsToItemTransformer.athleteId(PK),\n      contestId: this.attrsToItemTransformer.contestId(SK_GSI),\n      discipline: this.attrsToItemTransformer.discipline(SK_GSI),\n      date: this.attrsToItemTransformer.date(LSI),\n      points: this.attrsToItemTransformer.points(GSI_SK),\n      ...rest,\n    };\n  }\n\n  public transformItemToAttrs(item: DDBAthleteContestItem): AllAttrs {\n    const { athleteId, contestId, date, points, discipline, ...rest } = item;\n\n    return {\n      PK: this.itemToAttrsTransformer.PK(athleteId),\n      SK_GSI: this.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n      LSI: this.itemToAttrsTransformer.LSI(date),\n      GSI_SK: this.itemToAttrsTransformer.GSI_SK(points),\n      ...rest,\n    };\n  }\n\n  public primaryKey(athleteId: string, discipline: Discipline, contestId: string) {\n    return {\n      [this.attrName('PK')]: this.itemToAttrsTransformer.PK(athleteId),\n      [this.attrName('SK_GSI')]: this.itemToAttrsTransformer.SK_GSI(discipline, contestId),\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.interface.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/contests/athlete.contests.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'ngx-printer-demo/projects/ngx-printer/src/lib/helper.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.spec.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.ts'"
        ],
        "content": "'ngx-printer-demo/projects/ngx-printer/src/lib/helper.ts'\n:\nexport class Helpers {\n\n\n   public static copyCss(printWindowDoc: Document) {\n\n    const links = document.querySelectorAll('link');\n    const styles = document.querySelectorAll('style');\n    const base = document.querySelector('base');\n\n    const targetHead = printWindowDoc.getElementsByTagName('head')[0];\n\n    if (base) {\n      targetHead.appendChild(document.importNode(base, true));\n    }\n\n    links.forEach(link => {\n      targetHead.appendChild(document.importNode(link, true));\n    });\n\n    styles.forEach(style => {\n      targetHead.appendChild(document.importNode(style, true));\n    });\n  }\n\n}\n\n\n'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.spec.ts'\n:import { PrintItemMarkerDirective } from './print-item-marker.directive';\nimport { NgxPrinterService } from './ngx-printer.service';\nimport { TestBed } from '@angular/core/testing';\n\ndescribe('PrintItemMarkerDirective', () => {\n  it('should create an instance', () => {\n    const service = TestBed.get(NgxPrinterService);\n    const directive = new PrintItemMarkerDirective(null, null, service);\n    expect(directive).toBeTruthy();\n  });\n});\n\n'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'\n:import { Helpers } from \"./helper\";\nimport { ngxPrintMarkerPosition } from \"./ngx-print-marker-position.enum\";\nimport { PrintItem } from \"./print-item\";\nimport {\n  ComponentFactoryResolver,\n  EnvironmentInjector,\n  Injectable,\n  Injector,\n  Optional,\n  TemplateRef,\n  Type,\n  createComponent,\n} from \"@angular/core\";\nimport { NgxPrinterComponent } from \"./ngx-printer.component\";\nimport { BehaviorSubject } from \"rxjs\";\nimport { PrintServiceConfig } from \"./print-service-config\";\n\nexport type Content<T> = string | HTMLElement | TemplateRef<T> | Type<T>;\n\n\n@Injectable({\n  providedIn: \"root\",\n})\nexport class NgxPrinterService {\n  private printWindowOpen = new BehaviorSubject<boolean>(false);\n\n\n  private _printItems = new BehaviorSubject<PrintItem[]>([]);\n  $printItems = this._printItems.asObservable();\n\n  private openNgxPrinter: HTMLElement;\n\n\n  timeToWaitRender = 200;\n\n\n  renderClass = \"default\";\n\n\n  printOpenWindow = true;\n\n\n  appRootName = \"app-root\";\n\n\n  printPreviewOnly = false;\n\n  appRoot: HTMLElement;\n  appRootDislaySetting = \"\";\n\n  $printWindowOpen = this.printWindowOpen.asObservable();\n  eventadded = [];\n  markerPosition: ngxPrintMarkerPosition;\n\n  constructor(\n    @Optional() config: PrintServiceConfig,\n    private envInjector: EnvironmentInjector,\n  ) {\n    this.setRootConfigOptions(config);\n  }\n\n\n  private setRootConfigOptions(config: PrintServiceConfig): void {\n    if (config) {\n      config.timeToWaitRender &&\n        (this.timeToWaitRender = config.timeToWaitRender);\n\n      config.renderClass && (this.renderClass = config.renderClass);\n\n      config.appRootName && (this.appRootName = config.appRootName);\n\n      config.markerPosition && (this.markerPosition = config.markerPosition);\n\n      if (config.hasOwnProperty(\"printPreviewOnly\")) {\n        this.printPreviewOnly = config.printPreviewOnly;\n      }\n\n      if (config.hasOwnProperty(\"printOpenWindow\")) {\n        this.printOpenWindow = config.printOpenWindow;\n      }\n    }\n  }\n\n\n  public printDiv(divID: string): void {\n    const divToPrint = document.getElementById(divID);\n\n    if (divToPrint) {\n      this.print(divToPrint, this.printOpenWindow);\n    } else {\n      console.log(`div with id ${divID} not found..`);\n    }\n  }\n\n\n  public printByClassName(className: string): void {\n    const elementToPrint = document.getElementsByClassName(className);\n\n    if (elementToPrint && elementToPrint.length > 0) {\n      this.print(<HTMLScriptElement>elementToPrint[0], this.printOpenWindow);\n    } else {\n      console.log(\"element with id ${className} not found..\");\n    }\n  }\n\n\n  public printAngular(contentToPrint: any, context?: any): void {\n    const nativeEl = this.createComponent(contentToPrint, null, context);\n\n    this.print(nativeEl.nativeElement, this.printOpenWindow);\n  }\n\n\n  public printImg(imgSrc: string): void {\n    const compRef = this.createComponent(null, imgSrc);\n    const openNewWindow = this.printOpenWindow;\n\n    compRef.instance.completed.subscribe((val) => {\n      compRef.hostView.detectChanges();\n      console.log(\"completed:\", val);\n      this.print(compRef.location.nativeElement, openNewWindow);\n    });\n  }\n\n\n  public printHTMLElement(nativeElement: HTMLElement): void {\n    this.print(nativeElement, this.printOpenWindow);\n  }\n\n\n  private createComponent(\n    contentToRender: any,\n    imgSrc?: string,\n    context?: any\n  ): any {\n\n    let componentRef: any;\n\n    if (contentToRender) {\n      if (context === undefined) {\n        context = null;\n      }\n      const ngContent = this.resolveNgContent(contentToRender, context);\n\n      componentRef = createComponent(NgxPrinterComponent, {\n        environmentInjector: this.envInjector,\n        projectableNodes: ngContent\n      });\n\n    } else {\n      componentRef = createComponent(NgxPrinterComponent, {\n        environmentInjector: this.envInjector,\n      });\n    }\n\n    componentRef.instance.renderClass = this.renderClass;\n\n    if (imgSrc) {\n      componentRef.instance.imgSrc = imgSrc;\n      return componentRef;\n    }\n\n    componentRef.hostView.detectChanges();\n    return componentRef.location;\n  }\n\n\n  private print(printContent: any, printOpenWindow: boolean): void {\n    if (printOpenWindow === true) {\n      const printContentClone = document.importNode(printContent, true);\n\n      this.hideBeforePrint(printContentClone);\n      this.printInNewWindow(printContentClone);\n    }\n    if (printOpenWindow === false) {\n      const printContentClone = document.importNode(printContent, true);\n      this.hideBeforePrint(printContentClone);\n      const nativeEl = this.createComponent(printContentClone).nativeElement;\n      this.openNgxPrinter = nativeEl;\n      document.body.appendChild(this.openNgxPrinter);\n\n      this.getAppRoot();\n\n      this.appRoot && (this.appRoot.style.display = \"none\");\n\n      this.printCurrentWindow();\n    }\n  }\n\n\n  private printInNewWindow(divToPrint: HTMLElement): void {\n    const printWindow = window.open(\"\", \"PRINT\");\n    const title = document.title;\n\n    printWindow.document.write(\n      \"<HTML><HEAD><TITLE>\" + title + \"</TITLE></HEAD><BODY></BODY></HTML>\"\n    );\n\n\n    const printWindowDoc = printWindow.document;\n    Helpers.copyCss(printWindowDoc);\n\n    printWindowDoc.body.style.margin = \"0 0\";\n    printWindowDoc.body.appendChild(divToPrint);\n    printWindow.document.close();\n\n    setTimeout(\n      () => this.printTabWindow(printWindow, printWindowDoc),\n      this.timeToWaitRender\n    );\n  }\n\n\n  private printTabWindow(printWindow: Window, printWindowDoc: Document): void {\n    if (this.printPreviewOnly) {\n      return;\n    }\n    this.registerPrintEvent(printWindow, true);\n    this.printWindowOpen.next(true);\n    printWindow.focus();\n    if (printWindowDoc.execCommand(\"print\") === false) {\n      printWindow.print();\n    }\n  }\n\n\n  public printCurrentWindow(): void {\n    if (this.printPreviewOnly) {\n      return;\n    }\n    this.registerPrintEvent(window, false);\n    setTimeout(() => {\n      this.printWindowOpen.next(true);\n      if (document.execCommand(\"print\") === false) {\n        window.print();\n      }\n    }, this.timeToWaitRender);\n  }\n\n\n  private registerPrintEvent(\n    printWindow: Window,\n    printWithOpenInNewWindow: boolean\n  ) {\n    const that = this;\n    printWindow.focus();\n\n    if (that.eventadded[printWindow.name]) {\n      return;\n    }\n\n\n\n\n    printWindow.addEventListener('beforeprint', () => {});\n\n    printWindow.addEventListener('afterprint', () => {\n      this.eventadded[printWindow.name] = true;\n      console.log('afterprint');\n\n      if (printWithOpenInNewWindow) {\n        that.eventadded[printWindow.name] = false;\n      }\n      that.cleanUp(printWindow, printWithOpenInNewWindow);\n      that.printWindowOpen.next(false);\n    });\n  }\n\n\n  private cleanUp(printWindow: Window, printOpenWindow: boolean): void {\n    if (printOpenWindow === true) {\n      console.log(\"close print window\");\n      printWindow.close();\n      setTimeout(() => {\n        printWindow.close();\n      }, 20);\n    }\n    if (printOpenWindow === false) {\n      if (!this.openNgxPrinter) {\n        return;\n      }\n      if (document.body.getElementsByTagName(\"ngx-printer\").length === 0) {\n        return;\n      }\n\n      if (this.appRoot) {\n        if (this.appRootDislaySetting !== \"\") {\n          this.appRoot.style.display = this.appRootDislaySetting;\n        } else {\n          this.appRoot.style.display = \"\";\n        }\n      }\n\n      document.body.removeChild(this.openNgxPrinter);\n      this.openNgxPrinter = null;\n    }\n  }\n\n\n  private hideBeforePrint(parentDiv: HTMLElement): void {\n    const childrenOfDiv = parentDiv.querySelectorAll(\".no_print_indicator\");\n\n    for (let i = 0; i < childrenOfDiv.length; i++) {\n      const child = childrenOfDiv[i] as HTMLElement;\n      child.style.display = \"none\";\n    }\n  }\n\n\n  private getAppRoot(): void {\n    const appRoot = document.body.getElementsByTagName(this.appRootName);\n    if (appRoot.length === 0) {\n      return null;\n    } else {\n      this.appRoot = <HTMLElement>appRoot[0];\n      this.appRootDislaySetting = this.appRoot.style.display;\n    }\n  }\n\n\n  public addPrintItem(newPrintItem: PrintItem): void {\n    const tmpItems = this._printItems.getValue();\n\n    tmpItems.push(newPrintItem);\n    this._printItems.next(tmpItems);\n  }\n\n\n  public removePrintItem(idOfItemToRemove: string): void {\n    const tmpItems = this._printItems.getValue();\n    const newIitems = tmpItems.filter((item) => item.id !== idOfItemToRemove);\n\n    this._printItems.next(newIitems);\n  }\n\n\n  public getPrintItem(idOfItemToRemove: string): PrintItem {\n    const tmpItems = this._printItems.getValue();\n    const foundItem = tmpItems.find((item) => item.id === idOfItemToRemove);\n\n    return foundItem;\n  }\n\n\n  public printPrintItem(printItemToPrint: PrintItem): void {\n    this.printHTMLElement(printItemToPrint.nativeElement);\n  }\n\n\n  public printPrintItems(\n    printItemsToPrint: PrintItem[],\n    className?: string\n  ): void {\n    const newDiv = <HTMLDivElement>document.createElement(\"div\");\n\n    if (className) {\n      newDiv.classList.add(className);\n    } else {\n      newDiv.style.display = \"flex\";\n      newDiv.style.flexDirection = \"column\";\n    }\n\n    printItemsToPrint.forEach((element) => {\n      newDiv.appendChild(element.nativeElement.cloneNode(true));\n    });\n\n    this.printHTMLElement(newDiv);\n  }\n\n\n  private resolveNgContent<T>(content: Content<T>, context: any): any {\n    if (typeof content === \"string\") {\n      const element = document.createTextNode(content);\n\n      return [[element]];\n    }\n\n    if (content instanceof TemplateRef) {\n      const viewRef = content.createEmbeddedView(context);\n\n      viewRef.detectChanges();\n\n      return [viewRef.rootNodes];\n    }\n\n    if (content instanceof HTMLElement) {\n      return [[content]];\n    }\n\n\n\n    let componentRef =  createComponent(content, {\n      environmentInjector: this.envInjector,\n    });\n\n\n    componentRef.changeDetectorRef.detectChanges();\n\n    return [[componentRef.location.nativeElement]];\n  }\n}\n\n'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.ts'\n:import {\n  Directive,\n  ElementRef,\n  Renderer2,\n  OnInit,\n  Input,\n  Output,\n  EventEmitter,\n} from '@angular/core';\nimport { NgxPrinterService } from './ngx-printer.service';\nimport { ngxPrintMarkerPosition } from './ngx-print-marker-position.enum';\n\n\n\n@Directive({\n  selector: '[ngxPrintItemMarker]',\n})\nexport class PrintItemMarkerDirective implements OnInit {\n  @Input()\n  customClass = '';\n\n  @Input()\n  directPrint = false;\n\n  @Input()\n  imgPosition = ngxPrintMarkerPosition.Topleft;\n\n\n  @Input()\n  backgroundImage =\n    'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxNy4xLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+DQo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4Ig0KCSB2aWV3Qm94PSIwIDAgNTAgNTAiIGVuYWJsZS1iYWNrZ3JvdW5kPSJuZXcgMCAwIDUwIDUwIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCjxwYXRoIGQ9Ik0zOS4zODcsMjEuNDcxSDMyLjI5VjExLjE5OWMwLTAuNTUzLTAuNDQ3LTEtMS0xSDE3LjQ4NGMtMC41NTMsMC0xLDAuNDQ3LTEsMXYxMC4yNzFIOS4zODdjLTAuNTUzLDAtMSwwLjQ0Ny0xLDFWMzUuNDUNCgljMCwwLjU1MywwLjQ0NywxLDEsMWg2Ljg5NHYzLjU2NWMwLDAuNTUzLDAuNDQ3LDEsMSwxaDEzLjgwNmMwLjU1MywwLDEtMC40NDcsMS0xVjM2LjQ1aDcuMzAxYzAuNTUzLDAsMS0wLjQ0NywxLTFWMjIuNDcxDQoJQzQwLjM4NywyMS45MTgsMzkuOTM5LDIxLjQ3MSwzOS4zODcsMjEuNDcxeiBNMTguNDg0LDEyLjE5OUgzMC4yOXY5LjI3MUgxOC40ODRWMTIuMTk5eiBNMzAuMDg2LDM5LjAxNkgxOC4yOHYtNi4zMjloMTEuODA2VjM5LjAxNg0KCXogTTM4LjM4NywzNC40NWgtNi4zMDF2LTIuNzY0YzAtMC41NTMtMC40NDctMS0xLTFIMTcuMjhjLTAuNTUzLDAtMSwwLjQ0Ny0xLDF2Mi43NjRoLTUuODk0VjIzLjQ3MWg2Ljg5NA0KCWMwLjA2OCwwLjAxNCwwLjEzMSwwLjA0MSwwLjIwMywwLjA0MUgzMS4yOWMwLjA3MiwwLDAuMTM2LTAuMDI3LDAuMjAzLTAuMDQxaDYuODkzVjM0LjQ1eiIvPg0KPC9zdmc+DQo=';\n\n  imgMainStyles = {\n    'background-color': '#c3c3b6',\n    height: '16px',\n    width: '16px',\n    position: 'absolute',\n    cursor: 'pointer'\n  };\n\n  imgPositionTopLeft = {\n    left: '1px',\n    top: '1px',\n  };\n\n  imgPositionTopRight = {\n    right: '1px',\n    top: '1px',\n  };\n\n  imgPositionBottomLeft = {\n    left: '1px',\n    bottom: '1px',\n  };\n\n  imgPositionBottomRight = {\n    right: '1px',\n    bottom: '1px',\n  };\n\n\n  @Output()\n  printClicked = new EventEmitter<any>();\n\n  constructor(\n    private el: ElementRef,\n    private renderer2: Renderer2,\n    private printerService: NgxPrinterService\n  ) {}\n\n  ngOnInit() {\n    const newIndicator = document.createElement('div');\n    this.imgPosition = this.printerService.markerPosition;\n\n    this.addIndicatorDiv(this.el, newIndicator);\n\n    newIndicator.addEventListener('click', () => {\n      if (this.directPrint) {\n        const elementToPrint = this.el.nativeElement.getElementsByClassName(\n          'print_indicator'\n        );\n\n        if (elementToPrint && elementToPrint.length > 0) {\n          this.renderer2.setStyle(elementToPrint[0], 'visibility', 'hidden');\n          this.printerService.printHTMLElement(this.el.nativeElement);\n          this.renderer2.setStyle(elementToPrint[0], 'visibility', 'visible');\n        } else {\n          console.log('element with indicator class not found..');\n        }\n      }\n      this.printClicked.emit(true);\n    });\n  }\n\n\n  private addIndicatorDiv(el: ElementRef<any>, newIndicator: HTMLDivElement) {\n    const natElement = el.nativeElement;\n    this.renderer2.addClass(newIndicator, 'print_indicator');\n    this.renderer2.setStyle(natElement, 'position', 'relative');\n    this.renderer2.appendChild(el.nativeElement, newIndicator);\n    if (this.customClass === '') {\n      this.setCss(newIndicator);\n    } else {\n      this.renderer2.addClass(newIndicator, this.customClass);\n    }\n  }\n\n\n  private setCss(newIndicator: HTMLDivElement) {\n    Object.keys(this.imgMainStyles).forEach((element) => {\n      newIndicator.style.setProperty(`${element}`, this.imgMainStyles[element]);\n    });\n\n    this.setPosition(newIndicator);\n\n    const imgUrl = 'url(' + this.backgroundImage + ')';\n    newIndicator.style.setProperty(`background-image`, imgUrl);\n  }\n\n\n  private setPosition(newIndicator: HTMLDivElement) {\n    switch (this.imgPosition) {\n      case ngxPrintMarkerPosition.Topleft: {\n        Object.keys(this.imgPositionTopLeft).forEach((element) => {\n          newIndicator.style.setProperty(\n            `${element}`,\n            this.imgPositionTopLeft[element]\n          );\n        });\n        break;\n      }\n      case ngxPrintMarkerPosition.TopRight: {\n        Object.keys(this.imgPositionTopRight).forEach((element) => {\n          newIndicator.style.setProperty(\n            `${element}`,\n            this.imgPositionTopRight[element]\n          );\n        });\n        break;\n      }\n      case ngxPrintMarkerPosition.BottomLeft: {\n        Object.keys(this.imgPositionBottomLeft).forEach((element) => {\n          newIndicator.style.setProperty(\n            `${element}`,\n            this.imgPositionBottomLeft[element]\n          );\n        });\n        break;\n      }\n      case ngxPrintMarkerPosition.BottomRight: {\n        Object.keys(this.imgPositionBottomRight).forEach((element) => {\n          newIndicator.style.setProperty(\n            `${element}`,\n            this.imgPositionBottomRight[element]\n          );\n        });\n        break;\n      }\n      default: {\n        Object.keys(this.imgPositionTopLeft).forEach((element) => {\n          newIndicator.style.setProperty(\n            `${element}`,\n            this.imgPositionTopLeft[element]\n          );\n        });\n        break;\n      }\n    }\n  }\n}\n",
        "gt": [
            "'ngx-printer-demo/projects/ngx-printer/src/lib/helper.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/ngx-printer.service.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.ts'",
            "'ngx-printer-demo/projects/ngx-printer/src/lib/print-item-marker.directive.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { DDBRepository, GlobalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteDetailItem, KeyAttrs } from './athlete.details.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteDetailsRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteDetailItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async isExists(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      ProjectionExpression: this.transformer.attrName('PK'),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return true;\n        }\n        return false;\n      })\n      .catch(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository isExists', err, params);\n        return false;\n      });\n  }\n\n  public async get(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async batchGet(athleteIds: string[]) {\n    const params: DocumentClient.BatchGetItemInput = {\n      RequestItems: {\n        [this._tableName]: {\n          Keys: athleteIds.map(id => {\n            return this.transformer.primaryKey(id);\n          }),\n        },\n      },\n    };\n    return this.client\n      .batchGet(params)\n      .promise()\n      .then(data => {\n        return data.Responses[this._tableName].map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository batchGet', params));\n  }\n\n  public async put(athlete: DDBAthleteDetailItem) {\n    const params = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(athlete),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository Put', params));\n  }\n\n  public async delete(id: string) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(id),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository delete', params));\n  }\n\n  public async updateProfileUrl(athleteId: string, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository updateUrl', params));\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi and begins_with(#gsi_sk, :value) ',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        '#gsi_sk': this.transformer.attrName('GSI_SK'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ':value': this.transformer.itemToAttrsTransformer.GSI_SK(name),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return items;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletesByName', params));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: { fullName?: string };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(opts.after);\n\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletes', params));\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        name: this.transformer.attrsToItemTransformer.normalizedName(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createGSIExclusiveStartKey(after?: { athleteId: string; name: string }) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && after.name) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.name),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { fullName?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.fullName) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedFullName, :fullName)`;\n      filterExpAttrNames['#normalizedFullName'] = this.transformer.attrName('normalizedFullname');\n      filterExpAttrValues[':fullName'] = filter.fullName;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport * as moment from 'moment';\n\nimport { Utils } from 'shared/utils';\nimport { DDBRepository, GlobalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../../utils/utils';\nimport {\n  AllAttrs,\n  DDBAthleteRankingsItem,\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './athlete.rankings.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformers';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\n@Injectable()\nexport class DDBAthleteRankingsRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  private readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public async get(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(pk.athleteId, pk.rankingType, pk.year, pk.discipline, pk.gender, pk.ageCategory),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBAthleteRankingsRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async put(item: DDBAthleteRankingsItem) {\n    const params = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(item),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository Put', params));\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      KeyConditionExpression: '#pk = :pk and begins_with(#sk_gsi, :sortKeyPrefix) ',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(athleteId),\n        ':sortKeyPrefix': this.transformer.itemToAttrsTransformer.SK_GSI(\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n        ),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository getAllAthleteRankings', params));\n  }\n  public async deleteAthleteRankings(athleteId: string) {\n    const allRankings = await this.getAllAthleteRankings(athleteId);\n    const promises = [];\n\n    for (const ranking of allRankings.items) {\n      const params: AWS.DynamoDB.DocumentClient.DeleteItemInput = {\n        TableName: this._tableName,\n        Key: this.transformer.primaryKey(\n          athleteId,\n          ranking.rankingType,\n          ranking.year,\n          ranking.discipline,\n          ranking.gender,\n          ranking.ageCategory,\n        ),\n      };\n      promises.push(\n        this.client\n          .delete(params)\n          .promise()\n          .then(data => {})\n          .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository delete', params)),\n      );\n    }\n    await Promise.all(promises);\n  }\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const params: AWS.DynamoDB.DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(pk.athleteId, pk.rankingType, pk.year, pk.discipline, pk.gender, pk.ageCategory),\n    };\n    await this.client\n      .delete(params)\n      .promise()\n      .then(data => {})\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository deleteAthleteRankingsItem', params));\n  }\n\n  public async queryRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(category, opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi ',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(\n          category.rankingType,\n          category.year,\n          category.discipline,\n          category.gender,\n          category.ageCategory,\n        ),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository queryRankings', params));\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        points: this.transformer.attrsToItemTransformer.points(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createGSIExclusiveStartKey(\n    category: DDBRankingsItemPrimaryKey,\n    after?: { athleteId: string; points: number },\n  ) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && !Utils.isNil(after.points)) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(\n          category.rankingType,\n          category.year,\n          category.discipline,\n          category.gender,\n          category.ageCategory,\n        ),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.points),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter: { country?: string; id?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.country) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#country, :country)`;\n      filterExpAttrNames['#country'] = this.transformer.attrName('country');\n      filterExpAttrValues[':country'] = filter.country;\n    }\n    if (filter.id) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#pk, :id)`;\n      filterExpAttrNames['#pk'] = this.transformer.attrName('PK');\n      filterExpAttrValues[':id'] = filter.id;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/attributes.transformer.ts'\n:import { DDBOverloadedTableTransformer } from '../../../dynamodb.table.transformers';\nimport { buildCompositeKey, destructCompositeKey } from '../../../utils/utils';\nimport { AllAttrs, DDBAthleteDetailItem } from '../athlete.details.interface';\n\n\nexport class AttrsTransformer extends DDBOverloadedTableTransformer<\n  AllAttrs,\n  DDBAthleteDetailItem\n> {\n  constructor() {\n    super();\n  }\n\n  public prefixes = {\n    PK: 'Athlete',\n    SK_GSI: 'AthleteDetails',\n    LSI: '',\n    GSI_SK: ''\n  };\n\n  public attrsToItemTransformer = {\n    athleteId: (pk: string) => destructCompositeKey(pk, 1),\n    normalizedName: (gsi_sk: string) => gsi_sk,\n  };\n\n  public itemToAttrsTransformer = {\n    PK: (id: string) => buildCompositeKey(this.prefixes.PK, id),\n    SK_GSI: () => this.prefixes.SK_GSI,\n    LSI: () => undefined,\n    GSI_SK: (name: string) => name,\n  };\n\n  public transformAttrsToItem(dynamodbItem: AllAttrs): DDBAthleteDetailItem {\n    const { PK, SK_GSI, LSI, GSI_SK, ...rest } = dynamodbItem;\n    return {\n      athleteId: this.attrsToItemTransformer.athleteId(PK),\n      normalizedName: GSI_SK,\n      ...rest,\n    };\n  }\n\n  public transformItemToAttrs(item: DDBAthleteDetailItem): AllAttrs {\n    const { athleteId, normalizedName, ...rest } = item;\n    return {\n      PK: this.itemToAttrsTransformer.PK(item.athleteId),\n      SK_GSI: this.itemToAttrsTransformer.SK_GSI(),\n      LSI: this.itemToAttrsTransformer.LSI(),\n      GSI_SK: this.itemToAttrsTransformer.GSI_SK(normalizedName),\n      ...rest,\n    };\n  }\n\n  public primaryKey(athleteId: string) {\n    return {\n      [this.attrName('PK')]: this.itemToAttrsTransformer.PK(athleteId),\n      [this.attrName('SK_GSI')]: this.itemToAttrsTransformer.SK_GSI(),\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { repositoryFactory } from '../../utils/utils';\nimport { DDBAthleteDetailsRepository } from './athlete.details.repo';\n\n@Module({\n  imports: [],\n  providers: [],\n  exports: [],\n})\nexport class DDBAthleteDetailsRepoModule {\n  public static withConfig(dynamodbService: IDynamoDBService): DynamicModule {\n    const repo = repositoryFactory(\n      DDBAthleteDetailsRepository,\n      dynamodbService,\n    );\n    return {\n      module: DDBAthleteDetailsRepoModule,\n      providers: [repo],\n      exports: [repo],\n    };\n  }\n  public static forTest(dynamodbService: IDynamoDBService): ModuleMetadata {\n    const repo = repositoryFactory(\n      DDBAthleteDetailsRepository,\n      dynamodbService,\n    );\n    return {\n      providers: [repo],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'\n:import { DocumentClient } from 'aws-sdk/clients/dynamodb';\n\nexport type AttrsTransformer<T> = {\n  [P in keyof T]: ((...params: string[]) => string)\n};\nexport type AttrsTransformerOptional<T> = {\n  [P in keyof T]?: ((...params: any[]) => any)\n};\nexport type ItemTransformerOptional<T> = {\n  [P in keyof T]?: ((...params: any[]) => any)\n};\n\nexport abstract class DDBOverloadedTableTransformer<\n  TAllAttrs,\n  TTransformedItem\n> {\n  protected abstract attrsToItemTransformer: ItemTransformerOptional<\n    TTransformedItem\n  >;\n  protected abstract itemToAttrsTransformer: AttrsTransformerOptional<\n    TAllAttrs\n  >;\n\n  protected abstract transformAttrsToItem(\n    dynamodbItem: TAllAttrs,\n  ): TTransformedItem;\n\n  protected abstract transformItemToAttrs(\n    item: TTransformedItem,\n    client?: DocumentClient,\n  ): TAllAttrs;\n\n  protected attrNameTyped<T>(attr: keyof T): string {\n    return this.identity(attr);\n  }\n\n  public attrName(attr: keyof TAllAttrs): string {\n    return this.identity(attr);\n  }\n\n  protected identity(x) {\n    return x;\n  }\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { AttributeValue, StreamRecord } from 'aws-lambda';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { DDBRepository, GlobalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../../utils/utils';\nimport { AllAttrs, DDBAthleteDetailItem, KeyAttrs } from './athlete.details.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformer';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\nimport dynamoDataTypes = require('dynamodb-data-types');\nconst dynamoDbAttrValues = dynamoDataTypes.AttributeValue;\n\n@Injectable()\nexport class DDBAthleteDetailsRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  public readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public transformFromDynamoDBType(image: StreamRecord['NewImage']) {\n    const attributes = dynamoDbAttrValues.unwrap(image) as AllAttrs;\n    const item = this.transformer.transformAttrsToItem(attributes);\n    return this.entityTransformer.fromDBItem(item);\n  }\n\n  public transformToDynamoDBType(item: DDBAthleteDetailItem): { [P in keyof KeyAttrs]: AttributeValue } {\n    const attr = this.transformer.transformItemToAttrs(item);\n    return dynamoDbAttrValues.wrap(attr);\n  }\n\n  public async isExists(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      ProjectionExpression: this.transformer.attrName('PK'),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return true;\n        }\n        return false;\n      })\n      .catch(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository isExists', err, params);\n        return false;\n      });\n  }\n\n  public async get(athleteId: string) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBAthleteDetailsRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async batchGet(athleteIds: string[]) {\n    const params: DocumentClient.BatchGetItemInput = {\n      RequestItems: {\n        [this._tableName]: {\n          Keys: athleteIds.map(id => {\n            return this.transformer.primaryKey(id);\n          }),\n        },\n      },\n    };\n    return this.client\n      .batchGet(params)\n      .promise()\n      .then(data => {\n        return data.Responses[this._tableName].map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository batchGet', params));\n  }\n\n  public async put(athlete: DDBAthleteDetailItem) {\n    const params = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(athlete),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository Put', params));\n  }\n\n  public async delete(id: string) {\n    const params: DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(id),\n    };\n    return this.client\n      .delete(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository delete', params));\n  }\n\n  public async updateProfileUrl(athleteId: string, url: string) {\n    const params: DocumentClient.UpdateItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(athleteId),\n      UpdateExpression: 'SET #profileUrl = :url',\n      ConditionExpression: 'attribute_exists(#pk)',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#profileUrl': this.transformer.attrName('profileUrl'),\n      },\n      ExpressionAttributeValues: {\n        ':url': url,\n      },\n      ReturnValues: 'UPDATED_NEW',\n    };\n    return this.client\n      .update(params)\n      .promise()\n      .then(data => {\n        return data.Attributes[this.transformer.attrName('profileUrl')] as string;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository updateUrl', params));\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi and begins_with(#gsi_sk, :value) ',\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        '#gsi_sk': this.transformer.attrName('GSI_SK'),\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ':value': this.transformer.itemToAttrsTransformer.GSI_SK(name),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return items;\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletesByName', params));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: { fullName?: string };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(opts.after);\n\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteDetailsRepository queryAthletes', params));\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        name: this.transformer.attrsToItemTransformer.normalizedName(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createGSIExclusiveStartKey(after?: { athleteId: string; name: string }) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && after.name) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.name),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter?: { fullName?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.fullName) {\n      filterExpression =\n        (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#normalizedFullName, :fullName)`;\n      filterExpAttrNames['#normalizedFullName'] = this.transformer.attrName('normalizedFullname');\n      filterExpAttrValues[':fullName'] = filter.fullName;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/dynamodb.table.transformers.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/transformers/attributes.transformer.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.repo.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/details/athlete.details.module.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/shared/env_variables.ts'",
            "'Rankings-Backend/src/shared/logger.ts'",
            "'Rankings-Backend/src/shared/utils.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/shared/env_variables.ts'\n:class EnvironmentVariables {\n  public env = process.env.NODE_ENV || process.env.ENVIRONMENT || 'production';\n\n  get isDev(): boolean {\n    return !this.isProd;\n  }\n  get isProd(): boolean {\n    return this.env === 'production' || this.env === 'Prod';\n  }\n\n  get LoggerDebugLevel(): string {\n    return process.env.LoggerDebugLevel || 'debug';\n  }\n\n  get IS_OFFLINE(): boolean {\n    return process.env.IS_OFFLINE === 'true' || process.env.ENVIRONMENT === 'Local';\n  }\n\n  get morganConfig(): string {\n    return process.env.NODE_ENV === 'production' ? 'tiny' : 'combined';\n  }\n\n  get redis_host(): string {\n    return process.env.REDISHOST;\n  }\n\n  get redis_port(): string {\n    return process.env.REDISPORT;\n  }\n\n  get redis_password(): string {\n    return process.env.REDISPASSWORD;\n  }\n\n  get disable_streams(): boolean {\n    return process.env.DISABLE_STREAMS === 'true';\n  }\n  get disable_cronjob(): boolean {\n    return process.env.DISABLE_CRONJOB === 'true';\n  }\n}\n\nexport default new EnvironmentVariables();\n\n'Rankings-Backend/src/shared/logger.ts'\n:import winston = require('winston');\nimport * as WSCloudWatch from 'winston-cloudwatch';\nconst WinstonCloudWatch = WSCloudWatch as any;\n\nimport env_variables from './env_variables';\n\nconst debugLevel = env_variables.LoggerDebugLevel;\nfunction cloudWatchMessageFormatter(log: any): string {\n  const obj = {\n    logLevel: log.level,\n    message: log.message,\n    data: log.data,\n  };\n  return JSON.stringify(obj);\n}\n\nconst winstonCloudWatchTransport = new WinstonCloudWatch({\n  level: debugLevel,\n  messageFormatter: cloudWatchMessageFormatter,\n  logGroupName: 'ISA-Rankings/ApplicationLogs',\n  logStreamName: () => {\n    const date = new Date().toISOString().split('T')[0];\n    return date;\n  },\n});\n\nexport const waitForLogger = async () => {\n  return new Promise<void>((r, j) => {\n    winstonCloudWatchTransport.kthxbye(err => {\n\n      r();\n    });\n  });\n};\n\nasync function waitForTransports(l) {\n  const transportsFinished = l.transports.map(t => new Promise(resolve => t.on('finish', resolve)));\n  l.end();\n  return Promise.all(transportsFinished);\n}\n\nconst winstonFormat = () => {\n  if (env_variables.IS_OFFLINE) {\n    return winston.format.combine(winston.format.splat(), winston.format.colorize(), winston.format.simple());\n  }\n  return winston.format.combine(winston.format.splat(), winston.format.simple());\n};\n\nconst winstonTransports = () => {\n  if (env_variables.IS_OFFLINE) {\n    return [new winston.transports.Console()];\n  }\n  return [new winston.transports.Console(), winstonCloudWatchTransport];\n};\n\nexport const logger = winston.createLogger({\n  level: debugLevel,\n  exitOnError: false,\n  format: winstonFormat(),\n  transports: winstonTransports(),\n  exceptionHandlers: [winstonCloudWatchTransport],\n});\n\n'Rankings-Backend/src/shared/utils.ts'\n:import latinize = require('latinize');\nimport { isNil as _isNil } from 'lodash';\nimport * as moment from 'moment';\n\nimport { Constants } from './constants';\nimport env_variables from './env_variables';\nimport { logger } from './logger';\n\n\nexport namespace Utils {\n  export function concatParams(base: string, ...params: string[]) {\n    let str = base;\n    for (const param of params) {\n      if (param !== undefined && param !== null && param.length > 0) {\n        str = str + ':' + param;\n      } else {\n        break;\n      }\n    }\n    return str;\n  }\n\n  export function DateNow() {\n    return moment().utc();\n  }\n\n  export function unixToDate(unix: number): moment.Moment {\n    return moment.unix(unix);\n  }\n\n  export function dateToMoment(date: Date): moment.Moment {\n    if (date) {\n      return moment(date);\n    }\n    return null;\n  }\n\n  export function normalizeString(str: string) {\n    if (!str) {\n      return str;\n    }\n    return latinize(str).toLowerCase();\n  }\n\n  export async function omitReject<T>(promise: Promise<T>) {\n    return promise.then<T>(d => d).catch<null>(err => {\n      logger.debug('OmitReject Error', { err: JSON.stringify(err) });\n      return null;\n    });\n  }\n\n  export function isRequestAuthenticated(request: Express.Request) {\n    if (env_variables.isDev) {\n      return true;\n    }\n    return isNil(request.cognitoClaims);\n  }\n\n  export function isNil(...value: any) {\n    return value.every((e: any) => _isNil(e));\n  }\n\n  export function isSomeNil(...value: any) {\n    return value.some((e: any) => _isNil(e));\n  }\n  export function logThrowError(errorDesc: string, params: any) {\n    return err => {\n      logError(errorDesc, err, params);\n      throw err;\n    };\n  }\n\n  export function logError(errorDesc: string, err: any, params: any) {\n    let errMessage;\n    if (!err.requestId) {\n\n      errMessage = err.message;\n    }\n    logger.error(`Error: ${errorDesc}`, {\n      data: {\n        params: params,\n        error: errMessage || err,\n      },\n    });\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/shared/env_variables.ts'",
            "'Rankings-Backend/src/shared/logger.ts'",
            "'Rankings-Backend/src/shared/utils.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'meditations/src/habits/main.tsx'",
            "'meditations/src/habits/containers/HabitsRoot.tsx'",
            "'meditations/src/habits/components/HabitsControlBar.tsx'",
            "'meditations/src/habits/components/ProjectList.tsx'"
        ],
        "content": "'meditations/src/habits/main.tsx'\n:\n\nimport * as React from \"react\";\nimport moment from \"moment\";\nimport route from \"riot-route\";\nimport { reverse, rangeRight } from \"lodash\";\n\nimport * as common from \"../common\";\n\nimport {\n  ScopeType,\n  Project,\n  Task,\n  store,\n  dispatch,\n  HabitsState,\n  dispatchProjectListUpdate\n} from \"./state\";\nimport { HabitsRoot } from \"./containers/HabitsRoot\";\n\n\nexport const routeForView = (\n  date: moment.Moment | \"current\",\n  project?: number\n) => {\n\n  return `view/${\n    date === \"current\" ? date : date.format(common.MONTH_FORMAT)\n    }/${project ? project : 0}`;\n};\n\n\nexport const urlForView = (\n  date: moment.Moment | \"current\",\n  project?: number\n) => {\n  return `#${routeForView(date, project)}`;\n};\n\nexport const dispatchProjectUpdate = (id: number, days: number) => {\n  dispatch(dispatch => {\n    common.get(`/habits/project/${id}/${days}`, (response: Project) => {\n      dispatch({\n        type: \"UPDATE_PROJECT\",\n        project: response\n      });\n    });\n  });\n};\n\n\nexport const main = () => {\n\n  common.installRouter(\n    \"/habits#\",\n    `view/${moment().format(common.MONTH_FORMAT)}/0`,\n    {\n      no_action: () => {\n        route(routeForView(moment(), 0));\n      },\n      habits: () => { },\n      view: (datestr: string, scopestr: string) => {\n        const state = store.getState() as HabitsState;\n        const project = parseInt(scopestr, 10);\n\n\n\n\n        if (datestr === \"current\") {\n          route(routeForView(state.currentDate, project), \"?\", true);\n        }\n\n        if (state === undefined) return;\n        const date =\n          datestr === \"current\"\n            ? state.currentDate\n            : moment(datestr, common.MONTH_FORMAT);\n\n\n\n\n\n\n        if (state === undefined) return;\n        const prevDate = state.currentDate;\n        const prevProject = state.currentProject;\n\n        let timeChanged: \"NO_CHANGE\" | \"CHANGE_YEAR\" | \"CHANGE_MONTH\" =\n          \"NO_CHANGE\";\n\n        if (state.mounted === false) {\n\n          timeChanged = \"CHANGE_YEAR\";\n        } else if (\n          date.format(common.DAY_FORMAT) !== prevDate.format(common.DAY_FORMAT)\n        ) {\n\n          timeChanged = \"CHANGE_MONTH\";\n          if (date.year() !== prevDate.year()) {\n            timeChanged = \"CHANGE_YEAR\";\n          }\n        }\n\n        const projectChanged = prevProject !== project;\n\n        common.setTitle(\"Habits\", `${date.format(\"MMMM YYYY\")}`);\n        dispatch({ date, type: \"CHANGE_ROUTE\", currentProject: project });\n\n\n        if (timeChanged === \"CHANGE_YEAR\" || timeChanged === \"CHANGE_MONTH\") {\n          dispatch(dispatch => {\n            const qs = `/habits/in-month-and-days?date=${date.format(\n              common.DAY_FORMAT\n            )}`;\n            common.get(qs, (response: { Days: Task[]; Month: Task[] }) => {\n\n              const array = rangeRight(date.daysInMonth()).map((_, i) => ({\n                Date: moment(date)\n                  .clone()\n                  .date(i + 1)\n                  .format(common.DAY_FORMAT),\n                Tasks: [] as Task[]\n              }));\n\n              response.Days.forEach(t => {\n                common.processModel(t);\n                array[t.Date.date() - 1].Tasks.push(t);\n              });\n\n              response.Month.forEach(common.processModel);\n\n              dispatch({\n                date,\n                type: \"MOUNT_DAYS_AND_SCOPE\",\n                days: reverse(array),\n                scope: ScopeType.MONTH,\n                tasks: response.Month\n              });\n            });\n          });\n        }\n\n        if (timeChanged === \"CHANGE_YEAR\") {\n          dispatch(dispatch => {\n            common.get(\n              `/habits/in-year?date=${date.format(common.DAY_FORMAT)}`,\n              (tasks: Task[]) => {\n                tasks.forEach(common.processModel);\n                dispatch({\n                  date,\n                  tasks,\n                  type: \"MOUNT_SCOPE\",\n                  scope: ScopeType.YEAR\n                });\n              }\n            );\n          });\n        }\n\n\n        if (!state.pinnedProjects) {\n          dispatchProjectListUpdate(state.projectStatsDays);\n        }\n\n\n        if (projectChanged) {\n          dispatch(dispatch => {\n            common.get(\n              `/habits/in-project/${project}`,\n              (response: {\n                scope: { Name: string; ID: number };\n                tasks: Task[];\n              }) => {\n                response.tasks.forEach(common.processModel);\n                dispatch({\n                  date,\n                  type: \"MOUNT_SCOPE\",\n                  name: response.scope.Name,\n                  scope: response.scope.ID,\n                  tasks: response.tasks\n                });\n              }\n            );\n          });\n        }\n      }\n    }\n  );\n\n\n  type HabitMessage =\n    | {\n      Type: \"UPDATE_TASKS_AND_PROJECT\";\n      Datum: {\n        Tasks: Task[];\n        ProjectID?: number;\n      };\n    }\n    | {\n      Type: \"UPDATE_SCOPE\";\n      Datum: {\n        Date: string;\n        Scope: number;\n        Tasks: Task[];\n        Name: string;\n      };\n    }\n    | {\n      Type: \"GET_PROJECT_LIST\";\n      Datum: {\n        Pinned: Project[];\n        Unpinned: Project[];\n      };\n    }\n    | {\n      Type: \"GET_PROJECT\";\n      Datum: Project;\n    };\n\n  common.makeSocket(\"habits/sync\", (msg: HabitMessage) => {\n    console.log(\"Received WebSocket message\", msg);\n    switch (msg.Type) {\n      case \"UPDATE_TASKS_AND_PROJECT\":\n        msg.Datum.Tasks.forEach(common.processModel);\n\n        dispatch({\n          type: \"UPDATE_TASKS\",\n          tasks: msg.Datum.Tasks\n        });\n\n        if (msg.Datum.ProjectID) {\n          dispatchProjectUpdate(\n            msg.Datum.ProjectID,\n            store.getState().projectStatsDays\n          );\n        }\n        break;\n\n      case \"UPDATE_SCOPE\":\n        msg.Datum.Tasks.forEach(common.processModel);\n        dispatch({\n          type: \"MOUNT_SCOPE\",\n          date: moment(msg.Datum.Date, common.DAY_FORMAT),\n          scope: msg.Datum.Scope,\n          tasks: msg.Datum.Tasks,\n          name: msg.Datum.Name\n        });\n        break;\n\n      case \"GET_PROJECT\":\n        dispatchProjectUpdate(msg.Datum.ID, store.getState().projectStatsDays);\n        break;\n\n      case \"GET_PROJECT_LIST\":\n        dispatchProjectListUpdate(store.getState().projectStatsDays);\n        break;\n    }\n  });\n\n\n  common.render(\"root\", store, React.createElement(HabitsRoot));\n};\n\n'meditations/src/habits/containers/HabitsRoot.tsx'\n:import * as React from \"react\";\nimport HTML5Backend from \"react-dnd-html5-backend\";\nimport moment from \"moment\";\n\nimport * as common from \"../../common\";\nimport { MOUNT_NEXT_DAY_TIME } from \"../../common/constants\";\nimport { HabitsState, Scope } from \"../state\";\nimport { CommonUI } from \"../../common/components/CommonUI\";\nimport { Spinner } from \"../../common/components/Spinner\";\n\nimport { HabitsControlBar } from \"../components/HabitsControlBar\";\nimport { TimeScope } from \"../components/TimeScope\";\nimport { ProjectScope } from \"../components/ProjectScope\";\nimport { ProjectList } from \"../components/ProjectList\";\nimport { DndProvider } from \"react-dnd\";\n\nexport const HabitsRoot = common.connect()(\n  class extends React.Component<HabitsState> {\n\n    renderTimeScope(s?: Scope, i?: number) {\n      if (s) {\n\n        return (\n          <TimeScope\n            currentProject={this.props.currentProject}\n            key={i}\n            currentDate={this.props.currentDate}\n            scope={s}\n            filter={this.props.filter}\n            lastModifiedTask={this.props.lastModifiedTask}\n            mostRecentDay={i !== undefined && i === 0 ? true : false}\n          />\n        );\n      }\n      return <Spinner />;\n    }\n\n\n    renderProjects() {\n      if (this.props.currentProject === 0) {\n        return (\n          <ProjectList\n            hiddenProjects={this.props.hiddenProjects}\n            pinnedProjects={this.props.pinnedProjects}\n            unpinnedProjects={this.props.unpinnedProjects}\n            projectStatsDays={this.props.projectStatsDays}\n          />\n        );\n      }\n\n      if (\n        this.props.project &&\n        this.props.currentProject === this.props.project.Scope\n      ) {\n        return (\n          <ProjectScope\n            currentDate={this.props.currentDate}\n            scope={this.props.project}\n            projectStatsDays={this.props.projectStatsDays}\n          />\n        );\n      }\n\n\n      return <Spinner />;\n    }\n\n    renderDays() {\n      let { days } = this.props;\n\n      const today = moment();\n\n      if (\n        this.props.currentDate.month() === today.month() &&\n        this.props.currentDate.year() === today.year()\n      ) {\n\n\n\n\n\n        days = days.filter(\n          (d, i) =>\n            i === days.length ||\n\n            d.Date.date() <= today.date() ||\n            (d.Date.date() === today.date() + 1 &&\n              today.hour() > 24 - MOUNT_NEXT_DAY_TIME)\n        );\n      }\n\n      return days.map((d, i) => this.renderTimeScope(d, i));\n    }\n\n    render() {\n      return (\n        <div id=\"habits-root-sub\">\n          <DndProvider backend={HTML5Backend}>\n            <CommonUI {...this.props}>\n              <HabitsControlBar {...this.props} />\n              <div className=\"d-flex flex-column flex-md-row\">\n                <div id=\"scope-days\" className=\"scope-column mr-md-1\">\n                  {this.props.days ? this.renderDays() : <Spinner />}\n                </div>\n                <div id=\"scope-month\" className=\"scope-column mr-md-1\">\n                  {this.renderTimeScope(this.props.month)}\n                </div>\n                <div id=\"scope-year\" className=\"scope-column mr-md-1\">\n                  {this.renderTimeScope(this.props.year)}\n                </div>\n                <div id=\"scope-projects\" className=\"scope-column\">\n                  {this.props.pinnedProjects ? (\n                    this.renderProjects()\n                  ) : (\n                    <Spinner />\n                  )}\n                </div>\n              </div>\n            </CommonUI>\n          </DndProvider>\n        </div>\n      );\n    }\n  }\n);\n\n'meditations/src/habits/components/HabitsControlBar.tsx'\n:import * as React from \"react\";\nimport moment from \"moment\";\nimport * as Mousetrap from \"mousetrap\";\n\nimport { routeForView } from \"../main\";\nimport { dispatch, HabitsState } from \"../state\";\nimport DatePicker from \"react-datepicker\";\n\nimport * as common from \"../../common\";\nimport { KEYSEQ_FILTER_FOCUS } from \"../../common/constants\";\nimport { TimeNavigator } from \"../../common/components/TimeNavigator\";\n\n\nexport class HabitsControlBar extends React.PureComponent<HabitsState> {\n  filterByNameElement!: HTMLInputElement | null;\n\n  componentDidMount() {\n    Mousetrap.bind(KEYSEQ_FILTER_FOCUS, () => {\n      if (this.filterByNameElement) {\n        this.filterByNameElement.focus();\n      }\n      return false;\n    });\n  }\n\n  componentWillUnmount() {\n    Mousetrap.unbind(KEYSEQ_FILTER_FOCUS);\n  }\n\n\n  navigatorRoute = (\n    method: \"add\" | \"subtract\" | \"reset\",\n    unit?: \"month\" | \"year\" | \"day\"\n  ) => {\n    if (method === \"reset\") {\n      return routeForView(moment(), this.props.currentProject);\n    } else if (unit) {\n\n      const ndate = this.props.currentDate.clone()[method](1, unit);\n      return routeForView(ndate, this.props.currentProject);\n    }\n  };\n\n  navigate = (method: \"add\" | \"subtract\", unit: \"month\" | \"year\") => {\n    const ndate = this.props.currentDate.clone()[method](1, unit);\n    route(routeForView(ndate, this.props.currentProject));\n  };\n\n  filterByName = (e: React.ChangeEvent<HTMLInputElement>) => {\n    dispatch({ name: e.target.value, type: \"FILTER_BY_NAME\" });\n  };\n\n  filterByDate(end: boolean, date: moment.Moment | null) {\n    if (date) {\n      dispatch({ date, end, type: \"FILTER_BY_DATE\" });\n    }\n  }\n\n  clearFilter() {\n    dispatch({ type: \"FILTER_CLEAR\" });\n  }\n\n  exportTasks() {\n    const body: any = { day: true };\n\n    let filename = \"\";\n\n\n    if (this.props.filter.name) {\n      body.Name = this.props.filter.name;\n      filename += `-${this.props.filter.name}`;\n    }\n\n\n    if (this.props.filter.begin) {\n      body.Begin = this.props.filter.begin.format(common.DAY_FORMAT);\n      filename += `-from-${this.props.filter.begin.format(common.DAY_FORMAT)}`;\n    }\n\n    if (this.props.filter.end) {\n      body.End = this.props.filter.end.format(common.DAY_FORMAT);\n      filename += `-to-${this.props.filter.end.format(common.DAY_FORMAT)}`;\n    }\n\n    common.post(\"/habits/export\", body, (res: any) => {\n      const elt = document.createElement(\"a\");\n      elt.setAttribute(\n        \"href\",\n        `data:text/plain;charset=utf-8,${encodeURIComponent(res.body)}`\n      );\n      elt.setAttribute(\"download\", `meditations-export${filename}.txt`);\n      elt.style.display = \"none\";\n      document.body.appendChild(elt);\n      elt.click();\n      document.body.removeChild(elt);\n    });\n  }\n\n  renderDatePicker(\n    end: boolean,\n    defaultPlaceholder: string,\n    value?: moment.Moment | null\n  ) {\n\n    return (\n      <DatePicker\n        className=\"form-control ml-0 ml-md-1 mb-md-0 mb-1\"\n        onChange={date => this.filterByDate(end, date)}\n        isClearable={true}\n        placeholderText={defaultPlaceholder}\n        value={value ? value.format(common.DAY_FORMAT) : \"\"}\n        openToDate={this.props.currentDate}\n      />\n    );\n  }\n\n  render() {\n\n    const disableButton = !(\n      this.props.filter.name ||\n      this.props.filter.begin ||\n      this.props.filter.end\n    );\n\n\n    return (\n      <div\n        id=\"controls\"\n        className=\"d-flex flex-column flex-md-row flex-items-start flex-justify-between ml-3 mr-2 mt-2 mb-2\"\n      >\n        <TimeNavigator\n          daysOnly={false}\n          getRoute={this.navigatorRoute}\n          currentDate={this.props.currentDate}\n        />\n\n        <div className=\"d-flex flex-column flex-md-row\">\n          <input\n            type=\"text\"\n            placeholder={`Filter by name (Key: ${KEYSEQ_FILTER_FOCUS})`}\n            ref={e => (this.filterByNameElement = e)}\n            className=\"form-control mb-md-0 mb-1 ml-\"\n            onChange={this.filterByName}\n          />\n\n          {this.renderDatePicker(\n            false,\n            \"Filter from...\",\n            this.props.filter.begin\n          )}\n\n          {this.renderDatePicker(true, \"...to\", this.props.filter.end)}\n\n          <button\n            disabled={disableButton}\n            className=\"btn btn-secondary btn-block ml-0 ml-md-1 mb-md-0 mb-1\"\n            onClick={() => this.clearFilter()}\n          >\n            Clear date filter\n          </button>\n          <button\n            disabled={disableButton}\n            className=\"btn btn-primary btn-block ml-0 ml-md-1 mb-md-0 mb-1\"\n            onClick={() => this.exportTasks()}\n          >\n            Export selected tasks\n          </button>\n        </div>\n      </div>\n    );\n  }\n}\n\n'meditations/src/habits/components/ProjectList.tsx'\n:\nimport moment from \"moment\";\nimport * as React from \"react\";\nimport { times } from \"lodash\";\n\nimport {\n  OcticonButton,\n  OcticonSpan\n} from \"../../common/components/OcticonButton\";\nimport {\n  OcticonPlus,\n  OcticonFlame,\n  OcticonClippy,\n  OcticonTrashcan,\n  OcticonPin,\n  OcticonCheck,\n  OcticonClock,\n  OcticonArchive,\n  OcticonArrowRight,\n  OcticonArrowDown\n} from \"../../common/octicons\";\n\nimport {\n  ScopeType,\n  Project,\n  dispatchProjectListUpdate,\n  ProjectVisibility\n} from \"../state\";\nimport { urlForView } from \"../main\";\n\nimport { storeUIState, fetchStoredUIState } from \"../../common/storage\";\nimport { modalContext, ModalProvider } from \"../../common/modal\";\nimport { TaskNew, ProjectUpdate, ProjectDelete, ProjectNew } from \"../api\";\n\ninterface ProjectActivityIconProps {\n  p: Project;\n  days: number;\n}\n\n\nconst ProjectActivityIcon = (props: ProjectActivityIconProps) => {\n  const { p, days } = props;\n  const projectActivityClass = Math.min(p.CompletedTasks, 23);\n\n  const flameCount = projectActivityClass / 4;\n\n  return (\n    <>\n      {times(Math.max(1, flameCount), i => {\n        return (\n          <OcticonSpan\n            key={i}\n            icon={OcticonFlame}\n            className={`project-activity-${projectActivityClass}`}\n            title={`${p.CompletedTasks} in the last ${days} days`}\n          />\n        );\n      })}\n    </>\n  );\n};\n\nexport interface ProjectListProps {\n  pinnedProjects: Project[];\n  unpinnedProjects: Project[];\n  hiddenProjects: Project[];\n  projectStatsDays: number;\n}\n\nexport interface ProjectListState {\n  showHiddenProjects: boolean;\n}\n\ninterface ProjectListItemProps {\n  project: Project;\n  projectStatsDays?: number;\n}\n\nexport class ProjectListItem extends React.Component<ProjectListItemProps> {\n  copyLeft = () => {\n    TaskNew({\n      Name: this.props.project.Name,\n      Scope: ScopeType.DAY,\n      Date: moment()\n    });\n  };\n\n  togglePin = () => {\n    ProjectUpdate({\n      ...this.props.project,\n      Visibility:\n        this.props.project.Visibility === ProjectVisibility.Pinned\n          ? ProjectVisibility.Unpinned\n          : ProjectVisibility.Pinned\n    });\n  };\n\n  hideProject = () => {\n    ProjectUpdate({\n      ...this.props.project,\n      Visibility:\n        this.props.project.Visibility === ProjectVisibility.Hidden\n          ? ProjectVisibility.Unpinned\n          : ProjectVisibility.Hidden\n    });\n  };\n\n  deleteProject(modal: ModalProvider) {\n    return modal.openModalConfirm(\n      \"Are you sure you want to delete this project?\",\n      \"Delete this project!\",\n      () => ProjectDelete(this.props.project)\n    );\n  }\n\n  render() {\n    const project = this.props.project;\n\n    const hours = Math.floor(project.Minutes / 60);\n    const minutes = project.Minutes % 60;\n\n    return (\n      <div className=\"d-flex flex-row flex-justify-between\">\n        <div>\n          {this.props.projectStatsDays && (\n            <ProjectActivityIcon\n              p={project}\n              days={this.props.projectStatsDays}\n            />\n          )}\n\n          <a href={urlForView(\"current\", project.ID)}>{project.Name}</a>\n        </div>\n\n        <div className=\"project-controls d-flex flex-items-center\">\n          {project.CompletedTasks > 0 && (\n            <OcticonSpan icon={OcticonCheck} tooltip=\"Completed tasks\">\n              {project.CompletedTasks}\n            </OcticonSpan>\n          )}\n          {(hours > 0 || minutes > 0) && (\n            <span className=\"mr-1 tooltipped tooltipped-w\" aria-label=\"Time\">\n              <OcticonSpan icon={OcticonClock} tooltip=\"Time\" className=\"ml-1\">\n                {hours > 0 && `${hours}h${minutes > 0 ? \" \" : \"\"}`}\n                {minutes > 0 && `${minutes}m`}\n              </OcticonSpan>\n            </span>\n          )}\n          &nbsp;\n          <OcticonButton\n            icon={OcticonClippy}\n            tooltip=\"Copy to left\"\n            onClick={this.copyLeft}\n          />\n          {project.Visibility !== ProjectVisibility.Hidden && (\n            <OcticonButton\n              icon={OcticonPin}\n              tooltip={\n                project.Visibility === ProjectVisibility.Pinned\n                  ? \"Unpin project\"\n                  : \"Pin project\"\n              }\n              onClick={this.togglePin}\n            />\n          )}\n          {project.Visibility !== ProjectVisibility.Pinned && (\n            <OcticonButton\n              icon={OcticonArchive}\n              tooltip=\"(Un)hide project\"\n              onClick={this.hideProject}\n            />\n          )}\n          <modalContext.Consumer>\n            {modal => (\n              <OcticonButton\n                icon={OcticonTrashcan}\n                tooltip=\"Delete project\"\n                onClick={this.deleteProject(modal)}\n              />\n            )}\n          </modalContext.Consumer>\n        </div>\n      </div>\n    );\n  }\n}\n\n\nexport class ProjectList extends React.PureComponent<\n  ProjectListProps,\n  ProjectListState\n> {\n  projectStatsDaysInput!: HTMLInputElement;\n\n  constructor(props: ProjectListProps) {\n    super(props);\n\n    this.state = {\n      showHiddenProjects: fetchStoredUIState().showHiddenProjects\n    };\n  }\n\n  addProject(modal: ModalProvider) {\n    return modal.openModalPrompt(\n      \"New project name\",\n      \"Add new project\",\n      Name => {\n        if (Name !== \"\") {\n          ProjectNew({ Name });\n        }\n      }\n    );\n  }\n\n\n  statsFromStartOfYear = () => {\n    const days = moment().diff(moment().startOf(\"year\"), \"days\");\n    dispatchProjectListUpdate(days);\n  };\n\n  statsFromForever = () => {\n    dispatchProjectListUpdate(365 * 30);\n  };\n\n  statsFromInput = () => {\n    const n = parseInt(this.projectStatsDaysInput.value, 10);\n    if (!isNaN(n)) {\n      dispatchProjectListUpdate(n);\n    }\n  };\n\n  toggleDisplayHidden = () => {\n    this.setState({\n      showHiddenProjects: !this.state.showHiddenProjects\n    });\n\n    storeUIState({\n      showHiddenProjects: !this.state.showHiddenProjects\n    });\n  };\n\n  render() {\n    return (\n      <modalContext.Consumer>\n        {modal => (\n          <section className=\"project-list border bg-gray \">\n            <div className=\"d-flex flex-row flex-justify-between border-bottom scope-header pl-1 pr-1\">\n              <h3 className=\"scope-title\">Projects</h3>\n              <div className=\"scope-controls pr-1 pt-1 flex-self-center\">\n                <OcticonButton\n                  icon={OcticonPlus}\n                  tooltip=\"Add new project\"\n                  onClick={this.addProject(modal)}\n                />\n              </div>\n            </div>\n\n            <div className=\"pl-1 pr-1 pt-1\">\n              {this.props.pinnedProjects.map(p => (\n                <ProjectListItem\n                  projectStatsDays={this.props.projectStatsDays}\n                  key={p.ID}\n                  project={p}\n                />\n              ))}\n            </div>\n\n            <hr className=\"mt-1 mb-1\" />\n\n            <div className=\"pl-1 pr-1\">\n              {this.props.unpinnedProjects.map(p => (\n                <ProjectListItem key={p.ID} project={p} />\n              ))}\n            </div>\n\n            <div className=\"d-flex flex-row pt-1 pl-1\">\n              <h4\n                onClick={this.toggleDisplayHidden}\n                style={{ cursor: \"pointer\" }}\n              >\n                <OcticonButton\n                  icon={\n                    this.state.showHiddenProjects\n                      ? OcticonArrowDown\n                      : OcticonArrowRight\n                  }\n                />\n                &nbsp;Inactive projects\n              </h4>\n            </div>\n\n            {this.state.showHiddenProjects && (\n              <>\n                <hr className=\"mt-1 mb-1\" />\n                <div className=\"pl-1 pr-1\">\n                  {this.props.hiddenProjects.map(p => (\n                    <ProjectListItem key={p.ID} project={p} />\n                  ))}\n                </div>\n              </>\n            )}\n\n            <hr className=\"mt-1 mb-1\" />\n            <div className=\"pl-1 pr-1 pt-1 pb-1\">\n              <div className=\"d-flex flex-column flex-md-row flex-justify-between\">\n                <div>\n                  Pinned stats for last{\" \"}\n                  <strong>{this.props.projectStatsDays}</strong> days\n                </div>\n                <div className=\"pt-1 pt-md-0\">\n                  <input\n                    ref={ref => {\n                      if (ref) this.projectStatsDaysInput = ref;\n                    }}\n                    type=\"text\"\n                    size={2}\n                    placeholder=\"Enter days\"\n                    className=\"mr-1 form-control input-sm\"\n                    onBlur={this.statsFromInput}\n                  />\n                  <button\n                    className=\"btn btn-sm btn-secondary mr-1\"\n                    onClick={this.statsFromStartOfYear}\n                  >\n                    Start of year\n                  </button>\n                  <button\n                    className=\"btn btn-sm btn-secondary\"\n                    onClick={this.statsFromForever}\n                  >\n                    Forever\n                  </button>\n                </div>\n              </div>\n            </div>\n          </section>\n        )}\n      </modalContext.Consumer>\n    );\n  }\n}\n",
        "gt": [
            "'meditations/src/habits/components/HabitsControlBar.tsx'",
            "'meditations/src/habits/containers/HabitsRoot.tsx'",
            "'meditations/src/habits/main.tsx'",
            "'meditations/src/habits/components/ProjectList.tsx'"
        ]
    },
    {
        "files": [
            "'jsii-docgen/test/docgen/view/struct.test.ts'",
            "'jsii-docgen/src/docgen/view/interfaces.ts'",
            "'jsii-docgen/src/docgen/view/api-reference.ts'",
            "'jsii-docgen/src/docgen/view/documentation.ts'"
        ],
        "content": "'jsii-docgen/test/docgen/view/struct.test.ts'\n:import * as reflect from 'jsii-reflect';\nimport { Language } from '../../../src';\nimport { MarkdownRenderer } from '../../../src/docgen/render/markdown-render';\nimport { LANGUAGE_SPECIFIC } from '../../../src/docgen/view/documentation';\nimport { Struct } from '../../../src/docgen/view/struct';\nimport { Assemblies } from '../assemblies';\n\nconst assembly: reflect.Assembly = Assemblies.instance.withoutSubmodules;\n\nconst metadata = {\n  packageName: assembly.name,\n  packageVersion: assembly.version,\n};\n\nconst findStruct = (): reflect.InterfaceType => {\n  for (const iface of assembly.interfaces) {\n    if (iface.datatype) {\n      return iface;\n    }\n  }\n  throw new Error('Assembly does not contain a struct');\n};\n\ntest.each(Language.values())('%s snapshot', (language) => {\n  const { transpile } = LANGUAGE_SPECIFIC[language.toString()];\n  const markdown = new MarkdownRenderer({ language, ...metadata });\n  const struct = new Struct(transpile, findStruct()).toJson();\n  expect(struct).toMatchSnapshot();\n  expect(markdown.visitStruct(struct).render()).toMatchSnapshot();\n});\n\n'jsii-docgen/src/docgen/view/interfaces.ts'\n:import * as reflect from 'jsii-reflect';\nimport { Interface } from './interface';\nimport { InterfaceSchema } from '../schema';\nimport { Transpile } from '../transpile/transpile';\n\nexport class Interfaces {\n  private readonly interfaces: Interface[];\n\n  constructor(transpile: Transpile, interfaces: reflect.InterfaceType[]) {\n    this.interfaces = interfaces\n      .filter((i) => !Interface.isStruct(i))\n      .map((i) => new Interface(transpile, i));\n  }\n\n  public toJson(): InterfaceSchema[] {\n    return this.interfaces.map((iface) => iface.toJson());\n  }\n}\n\n'jsii-docgen/src/docgen/view/api-reference.ts'\n:import * as reflect from 'jsii-reflect';\nimport { Classes } from './classes';\nimport { Constructs } from './constructs';\nimport { Enums } from './enums';\nimport { Interfaces } from './interfaces';\nimport { Structs } from './structs';\nimport { ApiReferenceSchema } from '../schema';\nimport { Transpile } from '../transpile/transpile';\n\n\nexport class ApiReference {\n  private readonly constructs: Constructs;\n  private readonly structs: Structs;\n  private readonly interfaces: Interfaces;\n  private readonly classes: Classes;\n  private readonly enums: Enums;\n  constructor(\n    transpile: Transpile,\n    assembly: reflect.Assembly,\n    submodule?: reflect.Submodule,\n    allSubmodules?: boolean,\n  ) {\n    let classes: reflect.ClassType[];\n    let interfaces: reflect.InterfaceType[];\n    let enums: reflect.EnumType[];\n    if (allSubmodules ?? false) {\n      classes = this.sortByName([...assembly.classes, ...flatMap(assembly.allSubmodules, submod => [...submod.classes])]);\n      interfaces = this.sortByName([...assembly.interfaces, ...flatMap(assembly.allSubmodules, submod => [...submod.interfaces])]);\n      enums = this.sortByName([...assembly.enums, ...flatMap(assembly.allSubmodules, submod => [...submod.enums])]);\n    } else {\n      classes = this.sortByName(submodule ? submodule.classes : assembly.classes);\n      interfaces = this.sortByName(submodule ? submodule.interfaces : assembly.interfaces);\n      enums = this.sortByName(submodule ? submodule.enums : assembly.enums);\n    }\n\n    this.constructs = new Constructs(transpile, classes);\n    this.classes = new Classes(transpile, classes);\n    this.structs = new Structs(transpile, interfaces);\n    this.interfaces = new Interfaces(transpile, interfaces);\n    this.enums = new Enums(transpile, enums);\n  }\n\n\n  public toJson(): ApiReferenceSchema {\n    return {\n      constructs: this.constructs.toJson(),\n      classes: this.classes.toJson(),\n      structs: this.structs.toJson(),\n      interfaces: this.interfaces.toJson(),\n      enums: this.enums.toJson(),\n    };\n  }\n\n  private sortByName<Type extends reflect.Type>(arr: readonly Type[]): Type[] {\n    return [...arr].sort((s1, s2) => s1.name.localeCompare(s2.name));\n  }\n}\n\nfunction flatMap<T, U>(xs: readonly T[], fn: (value: T, index: number, array: readonly T[]) => U[]): U[] {\n  return Array.prototype.concat(...xs.map(fn));\n}\n\n'jsii-docgen/src/docgen/view/documentation.ts'\n:import * as os from 'os';\nimport * as path from 'path';\nimport { loadAssemblyFromFile, SPEC_FILE_NAME } from '@jsii/spec';\nimport * as fs from 'fs-extra';\nimport * as glob from 'glob-promise';\nimport * as reflect from 'jsii-reflect';\nimport { TargetLanguage, transliterateAssembly, UnknownSnippetMode } from 'jsii-rosetta';\nimport { Npm } from './_npm';\nimport { ApiReference } from './api-reference';\nimport { Readme } from './readme';\nimport { CorruptedAssemblyError, LanguageNotSupportedError, TransliterationError } from '../..';\nimport { Json } from '../render/json';\nimport { MarkdownDocument } from '../render/markdown-doc';\nimport { MarkdownFormattingOptions, MarkdownRenderer } from '../render/markdown-render';\nimport { Schema, CURRENT_SCHEMA_VERSION, submodulePath } from '../schema';\nimport { CSharpTranspile } from '../transpile/csharp';\nimport { GoTranspile } from '../transpile/go';\nimport { JavaTranspile } from '../transpile/java';\nimport { PythonTranspile } from '../transpile/python';\nimport { Transpile, Language } from '../transpile/transpile';\nimport { TypeScriptTranspile } from '../transpile/typescript';\n\n\nconst NOT_FOUND_IN_ASSEMBLY_REGEX = /Type '(.*)\\..*' not found in assembly (.*)$/;\n\n\nexport interface RenderOptions extends TransliterationOptions {\n\n  readonly language: Language;\n\n\n  readonly apiReference?: boolean;\n\n\n  readonly readme?: boolean;\n\n\n  readonly submodule?: string;\n\n\n  readonly allSubmodules?: boolean;\n}\n\nexport interface TransliterationOptions {\n\n  readonly loose?: boolean;\n\n\n  readonly validate?: boolean;\n}\n\nexport interface MarkdownRenderOptions extends RenderOptions, MarkdownFormattingOptions {}\n\n\nexport interface ForLocalPackageDocumentationOptions {\n\n\n  readonly assembliesDir?: string;\n}\n\nexport interface ForPackageDocumentationOptions {\n\n  readonly verbose?: boolean;\n\n\n  readonly _postInstall?: (dir: string) => Promise<void>;\n}\n\n\nexport class Documentation {\n\n\n  public static async forPackage(target: string, options: ForPackageDocumentationOptions = {}): Promise<Documentation> {\n    const workdir = await fs.mkdtemp(path.join(os.tmpdir(), path.sep));\n\n    const npm = new Npm(workdir);\n\n    if (options.verbose ?? true) {\n      console.log(`Installing package ${target}`);\n    }\n\n    const name = await npm.install(target);\n\n    if (options._postInstall != null) {\n      await options._postInstall(workdir);\n    }\n\n    const docs = await Documentation.forProject(path.join(workdir, 'node_modules', name), { ...options, assembliesDir: workdir });\n\n\n\n    docs.addCleanupDirectory(workdir);\n\n    return docs;\n  }\n\n\n  public static async forProject(root: string, options: ForLocalPackageDocumentationOptions = {}): Promise<Documentation> {\n    const manifestPath = path.join(root, 'package.json');\n    if (!(await fs.pathExists(manifestPath))) {\n      throw new Error(`Unable to locate ${manifestPath}`);\n    }\n\n\n\n    const assembliesDir = options?.assembliesDir ?? root;\n\n    const { name } = JSON.parse(await fs.readFile(manifestPath, 'utf-8'));\n    return Documentation.forAssembly(name, assembliesDir);\n  }\n\n\n  public static async forAssembly(assemblyName: string, assembliesDir: string): Promise<Documentation> {\n    return new Documentation(assemblyName, assembliesDir);\n  }\n\n  private readonly cleanupDirectories: Set<string> = new Set<string>();\n  private readonly assembliesCache: Map<string, reflect.Assembly> = new Map<string, reflect.Assembly>();\n  private assemblyFqn: string | undefined;\n\n  private constructor(\n    private readonly assemblyName: string,\n    private readonly assembliesDir: string,\n  ) {}\n\n\n  public async listSubmodules() {\n    const tsAssembly = await this.createAssembly(undefined, { loose: true, validate: false });\n    return tsAssembly.allSubmodules;\n  }\n\n  public async toIndexMarkdown(fileSuffix:string, options: RenderOptions) {\n    const assembly = await this.createAssembly(undefined, { loose: true, validate: false });\n    const submodules = await this.listSubmodules();\n    const schema = (await this.toJson({\n      ...options,\n      submodule: undefined,\n      allSubmodules: false,\n    })).content;\n\n    const ref = new MarkdownDocument({ header: { title: 'API Reference' }, id: 'api-reference' });\n\n    if (schema.version !== CURRENT_SCHEMA_VERSION) {\n      throw new Error(`Unexpected schema version: ${schema.version}`);\n    }\n\n    const renderer = new MarkdownRenderer({\n      language: options.language,\n      packageName: assembly.name,\n      packageVersion: assembly.version,\n    });\n\n    if (submodules.length) {\n      ref.section(renderer.visitSubmodules(submodules, fileSuffix));\n    }\n\n    if (schema.apiReference) {\n      ref.section(renderer.visitConstructs(schema.apiReference.constructs));\n      ref.section(renderer.visitStructs(schema.apiReference.structs));\n      ref.section(renderer.visitClasses(schema.apiReference.classes));\n      ref.section(renderer.visitInterfaces(schema.apiReference.interfaces));\n      ref.section(renderer.visitEnums(schema.apiReference.enums));\n    }\n\n    const documentation = new MarkdownDocument();\n    documentation.section(ref);\n    return documentation;\n  }\n\n\n  public async toJson(options: RenderOptions): Promise<Json<Schema>> {\n\n    const language = options.language ?? Language.TYPESCRIPT;\n    const loose = options.loose ?? true;\n    const validate = options.validate ?? false;\n    const allSubmodules = options.allSubmodules ?? false;\n\n\n\n    const tsAssembly = await this.createAssembly(undefined, { loose, validate });\n    const isSupported = language === Language.TYPESCRIPT || language.isValidConfiguration(tsAssembly?.targets?.[language.targetName]);\n    this.assemblyFqn = `${tsAssembly.name}@${tsAssembly.version}`;\n\n    if (!isSupported) {\n      throw new LanguageNotSupportedError(`Laguage ${language} is not supported for package ${this.assemblyFqn}`);\n    }\n\n    let submoduleStr = options.submodule;\n\n    if (allSubmodules && submoduleStr) {\n      throw new Error('Cannot call toJson with allSubmodules and a specific submodule both selected.');\n    }\n\n    const { assembly, transpile } = await this.languageSpecific(language, { loose, validate });\n    const targets = assembly.targets;\n\n    if (!targets) {\n      throw new Error(`Assembly ${this.assemblyFqn} does not have any targets defined`);\n    }\n\n    const submodule = submoduleStr ? this.findSubmodule(assembly, submoduleStr) : undefined;\n\n    let readme: MarkdownDocument | undefined;\n    if (options?.readme ?? false) {\n      readme = new Readme(transpile, assembly, submodule).render();\n    }\n\n    let apiReference: ApiReference | undefined;\n    if (options?.apiReference ?? true) {\n      try {\n        apiReference = new ApiReference(transpile, assembly, submodule, allSubmodules);\n      } catch (error) {\n        if (!(error instanceof Error)) {\n          throw error;\n        }\n        throw maybeCorruptedAssemblyError(error) ?? error;\n      }\n    }\n\n    const contents: Schema = {\n      version: CURRENT_SCHEMA_VERSION,\n      language: language.toString(),\n      metadata: {\n        packageName: assembly.name,\n        packageVersion: assembly.version,\n        submodule: submodulePath(submodule),\n      },\n      readme: readme?.render(),\n      apiReference: apiReference?.toJson(),\n    };\n\n    return new Json(contents);\n  }\n\n  public async toMarkdown(options: MarkdownRenderOptions): Promise<MarkdownDocument> {\n    const json = (await this.toJson(options)).content;\n    return MarkdownRenderer.fromSchema(json, {\n      anchorFormatter: options.anchorFormatter,\n      linkFormatter: options.linkFormatter,\n      typeFormatter: options.typeFormatter,\n      header: options.header,\n    });\n  }\n\n  private addCleanupDirectory(directory: string) {\n    this.cleanupDirectories.add(directory);\n  }\n\n\n  public async cleanup() {\n    for (const dir of [...this.cleanupDirectories]) {\n      await fs.remove(dir);\n      this.cleanupDirectories.delete(dir);\n    }\n  }\n\n  private async languageSpecific(\n    lang: Language,\n    options: Required<TransliterationOptions>,\n  ): Promise<{ assembly: reflect.Assembly; transpile: Transpile}> {\n    const { rosettaTarget, transpile } = LANGUAGE_SPECIFIC[lang.toString()];\n    return { assembly: await this.createAssembly(rosettaTarget, options), transpile };\n  }\n\n\n  private findSubmodule(assembly: reflect.Assembly, submodule: string): reflect.Submodule {\n    const fqnSubs = assembly.allSubmodules.filter(\n      (s) => s.fqn === submodule,\n    );\n    if (fqnSubs.length === 1) {\n      return fqnSubs[0];\n    }\n\n\n    const relSubs = assembly.allSubmodules.filter(\n      (s) => s.fqn === `${assembly.name}.${submodule}`,\n    );\n    if (relSubs.length === 1) {\n      console.error(`[WARNING] findSubmodule() is being called with a relative submodule name: '${submodule}'. Prefer the absolute name: '${assembly.name}.${submodule}'`);\n      return relSubs[0];\n    }\n\n    if (fqnSubs.length + relSubs.length === 0) {\n      throw new Error(`Submodule ${submodule} not found in assembly ${assembly.name}@${assembly.version} (neither as '${submodule}' nor as '${assembly.name}.${submodule})`);\n    }\n\n\n    if (fqnSubs.length > 1) {\n      throw new Error(`Found multiple submodules with FQN: ${submodule} in assembly ${assembly.name}@${assembly.version}`);\n    }\n    throw new Error(`Found multiple submodules with relative name: ${submodule} in assembly ${assembly.name}@${assembly.version}`);\n  }\n\n  private async createAssembly(\n    language: TargetLanguage | undefined,\n    options: Required<TransliterationOptions>,\n  ): Promise<reflect.Assembly> {\n\n    const cacheKey = `lang:${language ?? 'ts'}.loose:${options.loose}.validate:${options.validate}`;\n    const cached = this.assembliesCache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n\n    const created = await withTempDir(async (workdir: string) => {\n\n\n      await fs.copy(this.assembliesDir, workdir, {\n\n\n        filter: async (src) => {\n          const stat = await fs.stat(src);\n          return stat.isFile() || stat.isDirectory();\n        },\n      });\n\n      const ts = new reflect.TypeSystem();\n\n\n\n      const assemblies = await glob.promise(`**/${SPEC_FILE_NAME}`, {\n        cwd: path.normalize(this.assembliesDir),\n        absolute: true,\n      });\n      for (let dotJsii of assemblies) {\n\n\n\n\n\n        const spec = loadAssemblyFromFile(dotJsii, false);\n        if (language && spec.name === this.assemblyName) {\n          const packageDir = path.dirname(dotJsii);\n          try {\n            await transliterateAssembly([packageDir], [language],\n              { loose: options.loose, unknownSnippets: UnknownSnippetMode.FAIL, outdir: workdir });\n          } catch (e: any) {\n            throw new TransliterationError(`Could not transliterate snippets in '${this.assemblyFqn}' to ${language}: ${e.message}`);\n          }\n          dotJsii = path.join(workdir, `${SPEC_FILE_NAME}.${language}`);\n        }\n        await loadAssembly(dotJsii, ts, options);\n      }\n      return ts.findAssembly(this.assemblyName);\n    });\n\n    this.assembliesCache.set(cacheKey, created);\n    return created;\n  }\n}\n\nexport const LANGUAGE_SPECIFIC = {\n  [Language.PYTHON.toString()]: {\n    transpile: new PythonTranspile(),\n    rosettaTarget: TargetLanguage.PYTHON,\n  },\n  [Language.TYPESCRIPT.toString()]: {\n    transpile: new TypeScriptTranspile(),\n    rosettaTarget: undefined,\n  },\n  [Language.JAVA.toString()]: {\n    transpile: new JavaTranspile(),\n    rosettaTarget: TargetLanguage.JAVA,\n  },\n  [Language.CSHARP.toString()]: {\n    transpile: new CSharpTranspile(),\n    rosettaTarget: TargetLanguage.CSHARP,\n  },\n  [Language.GO.toString()]: {\n    transpile: new GoTranspile(),\n    rosettaTarget: TargetLanguage.GO,\n  },\n};\n\n\nasync function loadAssembly(\n  dotJsii: string,\n  ts: reflect.TypeSystem,\n  { validate }: { readonly validate?: boolean } = {},\n): Promise<reflect.Assembly> {\n  const loaded = await ts.load(dotJsii, { validate });\n\n  for (const dep of Object.keys(loaded.spec.dependencies ?? {})) {\n    if (ts.tryFindAssembly(dep) != null) {\n\n      continue;\n    }\n    try {\n\n      const depPath = require.resolve(`${dep}/.jsii`, { paths: [path.dirname(dotJsii)] });\n      await loadAssembly(depPath, ts, { validate });\n    } catch {\n\n\n\n    }\n  }\n  return loaded;\n}\n\nasync function withTempDir<T>(work: (workdir: string) => Promise<T>): Promise<T> {\n  const workdir = await fs.mkdtemp(path.join(os.tmpdir(), path.sep));\n  const cwd = process.cwd();\n  try {\n    process.chdir(workdir);\n\n\n    return await work(workdir);\n  } finally {\n    process.chdir(cwd);\n    await fs.remove(workdir);\n  }\n}\n\nexport function extractPackageName(spec: string) {\n  const firstAt = spec.indexOf('@');\n\n  if (firstAt === 0) {\n    const lastAt = spec.indexOf('@', firstAt + 1);\n    if (lastAt === -1) {\n\n      return spec;\n    } else {\n\n      return spec.substring(0, lastAt);\n    }\n  }\n\n  if (firstAt > 0) {\n\n    return spec.substring(0, firstAt);\n  }\n\n\n  return spec;\n}\n\n\nfunction maybeCorruptedAssemblyError(error: Error): CorruptedAssemblyError | undefined {\n\n  const match = error.message.match(NOT_FOUND_IN_ASSEMBLY_REGEX);\n  if (!match) {\n    return;\n  }\n  const searchedAssembly = match[2];\n  const typeAssembly = match[1];\n\n  if (searchedAssembly === typeAssembly) {\n    return new CorruptedAssemblyError(error.message);\n  }\n  return;\n}\n",
        "gt": [
            "'jsii-docgen/src/docgen/view/interfaces.ts'",
            "'jsii-docgen/src/docgen/view/api-reference.ts'",
            "'jsii-docgen/src/docgen/view/documentation.ts'",
            "'jsii-docgen/test/docgen/view/struct.test.ts'"
        ]
    },
    {
        "files": [
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/utils/utils.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'"
        ],
        "content": "'Rankings-Backend/src/core/database/database.service.ts'\n:import { Injectable } from '@nestjs/common';\n\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteRanking } from 'core/athlete/entity/athlete-ranking';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { Contest } from 'core/contest/entity/contest';\nimport { Discipline } from 'shared/enums';\nimport { DisciplineUtility } from 'shared/enums/enums-utility';\nimport { Utils } from '../../shared/utils';\nimport { DDBAthleteContestsRepository } from './dynamodb/athlete/contests/athlete.contests.repo';\nimport { DDBAthleteDetailsRepository } from './dynamodb/athlete/details/athlete.details.repo';\nimport {\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './dynamodb/athlete/rankings/athlete.rankings.interface';\nimport { DDBAthleteRankingsRepository } from './dynamodb/athlete/rankings/athlete.rankings.repo';\nimport { DDBContestRepository } from './dynamodb/contests/contest.repo';\nimport { RedisRepository } from './redis/redis.repo';\n\n@Injectable()\nexport class DatabaseService {\n  constructor(\n    private readonly athleteDetailsRepo: DDBAthleteDetailsRepository,\n    private readonly athleteContestsRepo: DDBAthleteContestsRepository,\n    private readonly athleteRankingsRepo: DDBAthleteRankingsRepository,\n    private readonly contestRepo: DDBContestRepository,\n    private readonly redisRepo: RedisRepository,\n  ) {}\n\n  public terminateConnections() {\n    if (this.redisRepo.redisConfig.isRedisConfigured) {\n      this.redisRepo.redisConfig.redisClient.quit();\n    }\n  }\n  public async getTopScoreRankingsCronJobOffset() {\n    return this.redisRepo.getTopScoreRankingsCronJobOffset();\n  }\n  public async setTopScoreRankingsCronJobOffset(offset: number) {\n    return this.redisRepo.setTopScoreRankingsCronJobOffset(offset);\n  }\n\n  public async isAthleteExists(athleteId: string) {\n    return this.athleteDetailsRepo.isExists(athleteId);\n  }\n\n  public async getAthleteDetails(athleteId: string) {\n\n\n\n\n\n\n    const dbItem = await this.athleteDetailsRepo.get(athleteId);\n    return this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearAthleteDetailsCache(athleteId: string) {\n    return this.redisRepo.clearAthleteDetail(athleteId);\n  }\n\n  public async queryAthletesByName(name: string, limit: number) {\n    const dbItems = await this.athleteDetailsRepo.queryAthletesByName(name, limit);\n    return dbItems.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n  }\n\n  public async queryAthletes(\n    limit: number,\n    opts: {\n      after?: { athleteId: string; name: string };\n      filter?: {\n        fullName?: string;\n      };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && opts.filter.fullName) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteDetailsRepo.queryAthletes(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteDetailsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthletes(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putAthlete(athlete: AthleteDetail) {\n    const dbItem = this.athleteDetailsRepo.entityTransformer.toDBItem(athlete);\n    return this.athleteDetailsRepo.put(dbItem);\n  }\n\n  public async deleteAthlete(athleteId: string) {\n    return this.athleteDetailsRepo.delete(athleteId);\n  }\n\n  public async updateAthleteProfileUrl(athleteId: string, url: string) {\n    return this.athleteDetailsRepo.updateProfileUrl(athleteId, url);\n  }\n\n  public async putContestResult(contestResult: AthleteContestResult) {\n    const dbItem = this.athleteContestsRepo.entityTransformer.toDBItem(contestResult);\n    await this.athleteContestsRepo.put(dbItem);\n  }\n\n  public async deleteContestResult(athleteId: string, contestId: string, discipline: Discipline) {\n    await this.athleteContestsRepo.delete(athleteId, contestId, discipline);\n  }\n\n  public async queryContestResults(\n    contestId: string,\n    discipline: Discipline,\n    limit: number,\n    after?: { athleteId: string; points: number },\n  ) {\n    const dbItems = await this.athleteContestsRepo.queryContestAthletes(contestId, discipline, limit, after);\n    const items = dbItems.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    return { items, lastKey: dbItems.lastKey };\n  }\n\n  public async queryAthleteContestsByDate(\n    athleteId: string,\n    limit: number,\n    opts: {\n      betweenDates?: { start: Date; end?: Date };\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[] };\n    } = {},\n  ) {\n    const queryLimit: number = limit;\n\n\n\n\n\n\n\n    const queryResult = await this.athleteContestsRepo.queryAthleteContestsByDate(athleteId, queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.athleteContestsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteContestsByDate(athleteId, limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async getAthleteRanking(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const dbItem = await this.athleteRankingsRepo.get(pk);\n    return this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async getAthleteRankingPlace(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const place = await this.redisRepo.getPlaceOfAthleteInRankingCategory(pk);\n    return place;\n  }\n\n  public async putAthleteRanking(item: AthleteRanking) {\n    const pk: DDBAthleteRankingsItemPrimaryKey = {\n      rankingType: item.rankingType,\n      ageCategory: item.ageCategory,\n      athleteId: item.id,\n      discipline: item.discipline,\n      gender: item.gender,\n      year: item.year,\n    };\n    await this.redisRepo.updatePointsOfAthleteInRankingCategory(pk, item.points);\n    const dbItem = this.athleteRankingsRepo.entityTransformer.toDBItem(item);\n    await this.athleteRankingsRepo.put(dbItem);\n  }\n\n  public async deleteAthleteRankings(athleteId: string) {\n    await this.athleteRankingsRepo.deleteAthleteRankings(athleteId);\n  }\n\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    await this.athleteRankingsRepo.deleteAthleteRankingsItem(pk);\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const dbItems = await this.athleteRankingsRepo.getAllAthleteRankings(athleteId);\n    const items = dbItems.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    return items;\n  }\n\n  public async queryAthleteRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter && (opts.filter.country || opts.filter.id)) {\n      queryLimit = 100;\n    }\n    const queryResult = await this.athleteRankingsRepo.queryRankings(queryLimit, category, {\n      after: opts.after,\n      filter: opts.filter,\n    });\n    let items = queryResult.items.map(dbItem => this.athleteRankingsRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryAthleteRankings(limit - items.length, category, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    return { items: items, lastKey: lastKey };\n  }\n\n\n\n\n  public async getContest(contestId: string, discipline: Discipline) {\n\n\n\n\n\n\n    const dbItem = await this.contestRepo.get(contestId, discipline);\n    return this.contestRepo.entityTransformer.fromDBItem(dbItem);\n  }\n\n  public async clearContestCache(contestId: string, discipline: Discipline) {\n    return this.redisRepo.clearContest(contestId, discipline);\n  }\n\n  public async queryContestsByDate(\n    limit: number,\n    opts: {\n      descending: boolean;\n      year?: number;\n      after?: {\n        contestId: string;\n        discipline: Discipline;\n        date: string;\n      };\n      filter?: { disciplines?: Discipline[]; name?: string; id?: string };\n    } = { descending: true },\n  ) {\n    let queryLimit: number = limit;\n    if (opts.filter) {\n      const filter = opts.filter;\n      if ((filter.disciplines || []).length > 0) {\n        queryLimit = Math.round(limit * (DisciplineUtility.CompetitionDisciplines.length / filter!.disciplines.length));\n      }\n      if (filter.id || filter.name) {\n        queryLimit = 50;\n      }\n    }\n    const queryResult = await this.contestRepo.queryContestsByDate(queryLimit, opts);\n    let items = queryResult.items.map(dbItem => this.contestRepo.entityTransformer.fromDBItem(dbItem));\n    let lastKey = queryResult.lastKey;\n    if (lastKey && items.length < limit) {\n      const moreQueryResults = await this.queryContestsByDate(limit - items.length, {\n        ...opts,\n        after: queryResult.lastKey,\n      });\n      items = items.concat(moreQueryResults.items);\n      lastKey = moreQueryResults.lastKey;\n    }\n    if (opts.filter && opts.filter.name && items.length > limit) {\n      items = items.slice(0, limit);\n    }\n    return { items, lastKey: lastKey };\n  }\n\n  public async putContest(contest: Contest) {\n    const dbItem = this.contestRepo.entityTransformer.toDBItem(contest);\n    await this.contestRepo.put(dbItem);\n  }\n\n  public async deleteContest(contestId: string, discipline: Discipline) {\n    await this.contestRepo.delete(contestId, discipline);\n  }\n\n  public async updateContestProfileUrl(contestId: string, discipline: Discipline, url: string) {\n    return this.contestRepo.updateProfileUrl(contestId, discipline, url);\n  }\n\n\n}\n\n'Rankings-Backend/src/core/database/database.module.ts'\n:import { DynamicModule, Module } from '@nestjs/common';\nimport { ModuleMetadata } from '@nestjs/common/interfaces';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { ClientOpts } from 'redis';\nimport { DatabaseService } from './database.service';\nimport { DDBAthleteContestsRepoModule } from './dynamodb/athlete/contests/athlete.contests.module';\nimport { DDBAthleteDetailsRepoModule } from './dynamodb/athlete/details/athlete.details.module';\nimport { DDBAthleteRankingsRepoModule } from './dynamodb/athlete/rankings/athlete.rankings.module';\nimport { DDBContestRepoModule } from './dynamodb/contests/contest.module';\nimport { RedisRepositoryModule } from './redis/redis.module';\n\n@Module({\n  imports: [],\n  providers: [DatabaseService],\n  exports: [DatabaseService],\n})\nexport class DatabaseModule {\n  public static withConfig(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): DynamicModule {\n    return {\n      module: DatabaseModule,\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n    };\n  }\n  public static forTest(\n    dynamodbService: IDynamoDBService,\n    redisOpts: ClientOpts,\n  ): ModuleMetadata {\n    return {\n      imports: [\n        DDBAthleteDetailsRepoModule.withConfig(dynamodbService),\n        DDBAthleteContestsRepoModule.withConfig(dynamodbService),\n        DDBAthleteRankingsRepoModule.withConfig(dynamodbService),\n        DDBContestRepoModule.withConfig(dynamodbService),\n        RedisRepositoryModule.withConfig(redisOpts),\n      ],\n      providers: [DatabaseService],\n      exports: [],\n    };\n  }\n}\n\n'Rankings-Backend/src/core/database/test/database-script.spec.ts'\n:import { Test } from '@nestjs/testing';\nimport { AthleteDetail } from 'core/athlete/entity/athlete-detail';\nimport { AthleteContestResult } from 'core/athlete/entity/contest-result';\nimport { DynamoDBServices } from 'core/aws/aws.services';\nimport { Contest } from 'core/contest/entity/contest';\nimport { AthleteContestRecordService } from 'dynamodb-streams/athlete/athlete-contest-record.service';\nimport { AthleteRecordsModule } from 'dynamodb-streams/athlete/athlete-records.module';\nimport { IdGenerator } from 'shared/generators/id.generator';\nimport { Utils } from 'shared/utils';\nimport { DatabaseModule } from '../database.module';\nimport { DatabaseService } from '../database.service';\nimport { ContestGender } from 'shared/enums';\n\ndescribe('Database Script', () => {\n  let databaseService: DatabaseService;\n  let athleteRecordsService: AthleteContestRecordService;\n\n  beforeAll(async () => {\n    const module = await Test.createTestingModule(DatabaseModule.forTest(new DynamoDBServices(), undefined)).compile();\n    databaseService = module.get(DatabaseService);\n\n    const module2 = await Test.createTestingModule({ imports: [AthleteRecordsModule] }).compile();\n    athleteRecordsService = module2.get(AthleteContestRecordService);\n\n    jest.setTimeout(100000);\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n\n  describe('fix', () => {\n    it('', async () => {\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    });\n  });\n});\n\n'Rankings-Backend/src/core/database/dynamodb/utils/utils.ts'\n:import { AWSError } from 'aws-sdk';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport { logger } from 'shared/logger';\nimport { Utils } from 'shared/utils';\n\n\nexport function repositoryFactory(Repo, dynamodbService: IDynamoDBService) {\n  return {\n    provide: Repo,\n    useFactory: () => {\n      return new Repo(dynamodbService);\n    },\n  };\n}\n\nexport function logDynamoDBError(errorDesc: string, err: AWSError, params: any) {\n  let errMessage;\n  if (!err.requestId) {\n\n    errMessage = err.message;\n  }\n  logger.error(`DynamoDB Error: ${errorDesc}`, {\n    data: {\n      params: params,\n      error: errMessage || err,\n    },\n  });\n}\n\nexport function logThrowDynamoDBError(errorDesc: string, params: any) {\n  return (err: AWSError) => {\n    logDynamoDBError(errorDesc, err, params);\n    throw err;\n  };\n}\n\nexport function buildCompositeKey(base: string, ...params: string[]) {\n  const str = Utils.concatParams(base, ...params);\n  return str + (str === base ? ':' : '');\n}\n\nexport function destructCompositeKey(key: string, index: number): string {\n  if (!key) {\n    return null;\n  }\n  const token = key.split(':')[index];\n  return token;\n}\n\n\nexport function encodePointToString(point: number) {\n  const digitCount = Math.max(Math.floor(Math.log10(Math.abs(point))), 0) + 1;\n\n  const prefix = String.fromCodePoint(digitCount + 33) + ' ';\n  return prefix + point.toString();\n}\n\nexport function decodeStringToPoint(point: string) {\n  return parseInt(point.split(' ')[1], 10);\n}\n\n'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'\n:import { Injectable } from '@nestjs/common';\nimport { DocumentClient } from 'aws-sdk/clients/dynamodb';\nimport { IDynamoDBService } from 'core/aws/aws.services.interface';\nimport * as moment from 'moment';\n\nimport { Utils } from 'shared/utils';\nimport { DDBRepository, GlobalSecondaryIndexName } from '../../dynamodb.repo';\nimport { GSILastEvaluatedKey } from '../../interfaces/table.interface';\nimport { logDynamoDBError, logThrowDynamoDBError } from '../../utils/utils';\nimport {\n  AllAttrs,\n  DDBAthleteRankingsItem,\n  DDBAthleteRankingsItemPrimaryKey,\n  DDBRankingsItemPrimaryKey,\n} from './athlete.rankings.interface';\nimport { AttrsTransformer } from './transformers/attributes.transformers';\nimport { EntityTransformer } from './transformers/entity.transformer';\n\n@Injectable()\nexport class DDBAthleteRankingsRepository extends DDBRepository {\n  protected readonly _tableName = 'ISA-Rankings';\n  private readonly transformer = new AttrsTransformer();\n  public readonly entityTransformer = new EntityTransformer();\n\n  constructor(dynamodbService: IDynamoDBService) {\n    super(dynamodbService);\n  }\n\n  public async get(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const params: DocumentClient.GetItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(pk.athleteId, pk.rankingType, pk.year, pk.discipline, pk.gender, pk.ageCategory),\n    };\n    return this.client\n      .get(params)\n      .promise()\n      .then(data => {\n        if (data.Item) {\n          return this.transformer.transformAttrsToItem(data.Item as AllAttrs);\n        }\n        return null;\n      })\n      .catch<null>(err => {\n        logDynamoDBError('DDBAthleteRankingsRepository get', err, params);\n        return null;\n      });\n  }\n\n  public async put(item: DDBAthleteRankingsItem) {\n    const params = {\n      TableName: this._tableName,\n      Item: this.transformer.transformItemToAttrs(item),\n    };\n    return this.client\n      .put(params)\n      .promise()\n      .then(data => data)\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository Put', params));\n  }\n\n  public async getAllAthleteRankings(athleteId: string) {\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      KeyConditionExpression: '#pk = :pk and begins_with(#sk_gsi, :sortKeyPrefix) ',\n      ExpressionAttributeNames: {\n        '#pk': this.transformer.attrName('PK'),\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n      },\n      ExpressionAttributeValues: {\n        ':pk': this.transformer.itemToAttrsTransformer.PK(athleteId),\n        ':sortKeyPrefix': this.transformer.itemToAttrsTransformer.SK_GSI(\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n          undefined,\n        ),\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository getAllAthleteRankings', params));\n  }\n  public async deleteAthleteRankings(athleteId: string) {\n    const allRankings = await this.getAllAthleteRankings(athleteId);\n    const promises = [];\n\n    for (const ranking of allRankings.items) {\n      const params: AWS.DynamoDB.DocumentClient.DeleteItemInput = {\n        TableName: this._tableName,\n        Key: this.transformer.primaryKey(\n          athleteId,\n          ranking.rankingType,\n          ranking.year,\n          ranking.discipline,\n          ranking.gender,\n          ranking.ageCategory,\n        ),\n      };\n      promises.push(\n        this.client\n          .delete(params)\n          .promise()\n          .then(data => {})\n          .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository delete', params)),\n      );\n    }\n    await Promise.all(promises);\n  }\n  public async deleteAthleteRankingsItem(pk: DDBAthleteRankingsItemPrimaryKey) {\n    const params: AWS.DynamoDB.DocumentClient.DeleteItemInput = {\n      TableName: this._tableName,\n      Key: this.transformer.primaryKey(pk.athleteId, pk.rankingType, pk.year, pk.discipline, pk.gender, pk.ageCategory),\n    };\n    await this.client\n      .delete(params)\n      .promise()\n      .then(data => {})\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository deleteAthleteRankingsItem', params));\n  }\n\n  public async queryRankings(\n    limit: number,\n    category: DDBRankingsItemPrimaryKey,\n    opts: {\n      after?: {\n        athleteId: string;\n        points: number;\n      };\n      filter?: { country?: string; id?: string };\n    } = {},\n  ) {\n    const exclusiveStartKey = this.createGSIExclusiveStartKey(category, opts.after);\n    const { filterExpression, filterExpAttrNames, filterExpAttrValues } = this.createFilterExpression(opts.filter);\n\n    const params: AWS.DynamoDB.DocumentClient.QueryInput = {\n      TableName: this._tableName,\n      IndexName: GlobalSecondaryIndexName,\n      Limit: limit,\n      ScanIndexForward: false,\n      ExclusiveStartKey: exclusiveStartKey,\n      KeyConditionExpression: '#sk_gsi = :sk_gsi ',\n      FilterExpression: filterExpression,\n      ExpressionAttributeNames: {\n        '#sk_gsi': this.transformer.attrName('SK_GSI'),\n        ...filterExpAttrNames,\n      },\n      ExpressionAttributeValues: {\n        ':sk_gsi': this.transformer.itemToAttrsTransformer.SK_GSI(\n          category.rankingType,\n          category.year,\n          category.discipline,\n          category.gender,\n          category.ageCategory,\n        ),\n        ...filterExpAttrValues,\n      },\n    };\n    return this.client\n      .query(params)\n      .promise()\n      .then(data => {\n        const items = data.Items.map((item: AllAttrs) => {\n          return this.transformer.transformAttrsToItem(item);\n        });\n        return { items: items, lastKey: this.extractGSILastEvaluatedKey(data.LastEvaluatedKey as GSILastEvaluatedKey) };\n      })\n      .catch(logThrowDynamoDBError('DDBAthleteRankingsRepository queryRankings', params));\n  }\n\n  private extractGSILastEvaluatedKey(lastEvaluatedKey: GSILastEvaluatedKey) {\n    let lastKey: any;\n    if (lastEvaluatedKey) {\n      lastKey = {\n        athleteId: this.transformer.attrsToItemTransformer.athleteId(lastEvaluatedKey.PK),\n        points: this.transformer.attrsToItemTransformer.points(lastEvaluatedKey.GSI_SK),\n      };\n    }\n    return lastKey;\n  }\n\n  private createGSIExclusiveStartKey(\n    category: DDBRankingsItemPrimaryKey,\n    after?: { athleteId: string; points: number },\n  ) {\n    let startKey: GSILastEvaluatedKey;\n    if (after && after.athleteId && !Utils.isNil(after.points)) {\n      startKey = {\n        PK: this.transformer.itemToAttrsTransformer.PK(after.athleteId),\n        SK_GSI: this.transformer.itemToAttrsTransformer.SK_GSI(\n          category.rankingType,\n          category.year,\n          category.discipline,\n          category.gender,\n          category.ageCategory,\n        ),\n        GSI_SK: this.transformer.itemToAttrsTransformer.GSI_SK(after.points),\n      };\n    }\n    return startKey;\n  }\n\n  private createFilterExpression(filter: { country?: string; id?: string }) {\n    let filterExpression = '';\n    const filterExpAttrNames = {};\n    const filterExpAttrValues = {};\n\n    if (!filter) {\n      return { filterExpression: undefined, filterExpAttrNames, filterExpAttrValues };\n    }\n    if (filter.country) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#country, :country)`;\n      filterExpAttrNames['#country'] = this.transformer.attrName('country');\n      filterExpAttrValues[':country'] = filter.country;\n    }\n    if (filter.id) {\n      filterExpression = (filterExpression ? `(${filterExpression}) and ` : '') + `contains(#pk, :id)`;\n      filterExpAttrNames['#pk'] = this.transformer.attrName('PK');\n      filterExpAttrValues[':id'] = filter.id;\n    }\n    return {\n      filterExpression: filterExpression || undefined,\n      filterExpAttrNames,\n      filterExpAttrValues,\n    };\n  }\n}\n",
        "gt": [
            "'Rankings-Backend/src/core/database/dynamodb/utils/utils.ts'",
            "'Rankings-Backend/src/core/database/dynamodb/athlete/rankings/athlete.rankings.repo.ts'",
            "'Rankings-Backend/src/core/database/database.service.ts'",
            "'Rankings-Backend/src/core/database/database.module.ts'",
            "'Rankings-Backend/src/core/database/test/database-script.spec.ts'"
        ]
    },
    {
        "files": [
            "'layout/src/Layout.ts'",
            "'layout/src/stories/dynamic/AddRemoveContent.stories.ts'",
            "'layout/src/controllers/AlignController.ts'"
        ],
        "content": "'layout/src/Layout.ts'\n:import { Container } from 'pixi.js';\nimport { AlignController } from './controllers/AlignController';\nimport { ContentController } from './controllers/ContentController';\nimport { SizeController } from './controllers/SizeController';\nimport { StyleController } from './controllers/StyleController';\nimport { PixiTextStyle } from './utils/text';\nimport { ConditionalStyles, Content, LayoutOptions, Styles } from './utils/types';\n\n\nexport class LayoutSystem\n{\n\n    container: Container;\n\n\n    id: string;\n\n\n    size: SizeController;\n\n\n    align: AlignController;\n\n\n    protected _style: StyleController;\n\n\n    content: ContentController;\n\n\n    isPortrait: boolean;\n\n\n    constructor(options?: LayoutOptions, container?: Container)\n    {\n        this.container = container || new Container();\n\n        this.id = options?.id;\n\n        if (options?.globalStyles)\n        {\n\n            const styles = options.globalStyles[this.id];\n\n            if (styles && options.styles)\n            {\n                options.styles = { ...styles, ...options.styles };\n            }\n            else if (styles)\n            {\n                options.styles = styles;\n            }\n        }\n\n\n        this.size = new SizeController(this);\n        this._style = new StyleController(this, options?.styles);\n        this.align = new AlignController(this);\n        this.content = new ContentController(\n            this,\n            options?.content,\n            options?.globalStyles\n        );\n    }\n\n\n    resize(parentWidth?: number, parentHeight?: number)\n    {\n        const width = parentWidth || this.contentWidth || this.size.parentWidth;\n        const height\n            = parentHeight || this.contentHeight || this.size.parentHeight;\n\n        this.isPortrait = width < height;\n\n        this._style.applyConditionalStyles();\n        this.size.resize(parentWidth, parentHeight);\n    }\n\n\n    refresh()\n    {\n        this.resize(this.size.parentWidth, this.size.parentHeight);\n    }\n\n\n    get contentWidth(): number | undefined\n    {\n        if (!this.container?.parent)\n        {\n            return undefined;\n        }\n\n        return this.container.parent.width;\n    }\n\n\n    get contentHeight(): number | undefined\n    {\n        if (!this.container?.parent)\n        {\n            return undefined;\n        }\n\n        return this.container.parent.height;\n    }\n\n\n    set width(value: number)\n    {\n        this.size.width = value;\n    }\n\n\n    get width()\n    {\n        return this.size.width;\n    }\n\n\n    set height(value: number)\n    {\n        this.size.height = value;\n    }\n\n\n    get height()\n    {\n        return this.size.height;\n    }\n\n\n    addContent(content: Content)\n    {\n        this.content.createContent(content);\n        this.updateParents();\n    }\n\n\n    removeChildByID(id: string)\n    {\n        this.content.removeContent(id);\n    }\n\n\n    getChildByID(id: string): Layout | Container | undefined\n    {\n        return this.content.getByID(id);\n    }\n\n\n    updateParents()\n    {\n        const rootLayout = this.getRootLayout();\n\n        rootLayout.size.resize();\n    }\n\n\n    getRootLayout(): LayoutSystem\n    {\n        if (this.container.parent?.layout)\n        {\n            return this.container.parent.layout.getRootLayout();\n        }\n\n        return this;\n    }\n\n\n    setStyles(styles: Styles & ConditionalStyles)\n    {\n        this._style.set(styles);\n        this.updateParents();\n    }\n\n\n    get textStyle(): Partial<PixiTextStyle>\n    {\n        return this._style.textStyle;\n    }\n\n\n    get style(): Styles\n    {\n        return this._style.getAll();\n    }\n\n\n    get isRootLayoutPortrait(): boolean\n    {\n        return this.getRootLayout().isPortrait === true;\n    }\n}\n\n\nexport class Layout extends Container\n{\n    override layout: LayoutSystem;\n\n\n    constructor(options?: LayoutOptions)\n    {\n        super();\n\n        this.layout = new LayoutSystem(options, this);\n    }\n\n\n    get size(): SizeController\n    {\n        return this.layout.size;\n    }\n\n\n    get align(): AlignController\n    {\n        return this.layout.align;\n    }\n\n\n    get content(): ContentController\n    {\n        return this.layout.content;\n    }\n\n\n    get id()\n    {\n        return this.layout.id;\n    }\n\n\n    set id(value: string)\n    {\n        this.layout.id = value;\n    }\n\n\n    get contentWidth(): number | undefined\n    {\n        return this.layout.contentWidth;\n    }\n\n\n    get contentHeight(): number | undefined\n    {\n        return this.layout.contentHeight;\n    }\n\n\n    override set width(value: number)\n    {\n        this.layout.width = value;\n    }\n\n\n    override get width()\n    {\n        return this.layout.width;\n    }\n\n\n    override set height(value: number)\n    {\n        this.layout.height = value;\n    }\n\n\n    override get height()\n    {\n        return this.layout.height;\n    }\n\n\n    addContent(content: Content)\n    {\n        this.layout.addContent(content);\n    }\n\n\n    removeChildByID(id: string)\n    {\n        this.layout.removeChildByID(id);\n    }\n\n\n    getChildByID(id: string): Layout | Container | undefined\n    {\n        return this.layout.getChildByID(id);\n    }\n\n\n    setStyles(styles: Styles)\n    {\n        this.layout.setStyles(styles);\n    }\n\n\n    get textStyle(): Partial<PixiTextStyle>\n    {\n        return this.layout.textStyle;\n    }\n\n\n    get style(): Styles\n    {\n        return this.layout.style;\n    }\n\n\n    resize(parentWidth?: number, parentHeight?: number)\n    {\n        this.layout.resize(parentWidth, parentHeight);\n    }\n\n\n    refresh()\n    {\n        this.resize(this.size.parentWidth, this.size.parentHeight);\n    }\n}\n\ndeclare module 'pixi.js'\n{\n    interface Container\n    {\n        initLayout(config?: LayoutOptions): Container;\n        layout?: LayoutSystem;\n        isPixiLayout?: boolean;\n    }\n}\n\nif (!Container.prototype.initLayout)\n{\n    Object.defineProperty(Container.prototype, 'initLayout', {\n        value(options?: LayoutOptions): void\n        {\n            if (!this.layout)\n            {\n                this.layout = new LayoutSystem(options, this);\n                this.isPixiLayout = true;\n            }\n\n            return this;\n        },\n    });\n}\n\n'layout/src/stories/dynamic/AddRemoveContent.stories.ts'\n:import { Container, Sprite } from 'pixi.js';\nimport { FancyButton } from '@pixi/ui';\nimport { Layout } from '../../Layout';\nimport { toolTip } from '../components/ToolTip';\nimport { argTypes, getDefaultArgs } from '../utils/argTypes';\nimport { preloadAssets } from '../utils/helpers';\n\nconst testAssets = {\n    energy: 'Icons/EnergyIcon.png',\n    gem: 'Icons/gemIcon.png',\n    star: 'Icons/Star.png',\n};\n\nconst assets = {\n    button: 'Buttons/SmallButton.png',\n    buttonHover: 'Buttons/SmallButton-hover.png',\n    buttonDown: 'Buttons/SmallButton-pressed.png',\n    plus: 'Icons/PlusIcon.png',\n    minus: 'Icons/MinusIcon.png',\n};\n\nconst args = {\n    image: Object.keys(testAssets),\n    padding: 30,\n    maxWidth: 95,\n    amount: 2,\n};\n\nclass LayoutStory\n{\n    private layout: Layout;\n    private toolTip: Layout;\n    view = new Container();\n    w: number;\n    h: number;\n\n    constructor(props)\n    {\n        this.addTooltip(\n            `'+' and '-' buttons will add or remove sprites to the layout.\\n`\n        );\n\n        preloadAssets(Object.values(assets))\n            .then(() => preloadAssets(Object.values(testAssets)))\n            .then(() => this.createLayout(props));\n    }\n\n    createLayout({ image, padding, maxWidth, amount }: any)\n    {\n        const addButton = new FancyButton({\n            defaultView: assets.button,\n            hoverView: assets.buttonHover,\n            pressedView: assets.buttonDown,\n            icon: assets.plus,\n            iconOffset: { y: -7 },\n        });\n\n        const removeButton = new FancyButton({\n            defaultView: assets.button,\n            hoverView: assets.buttonHover,\n            pressedView: assets.buttonDown,\n            icon: assets.minus,\n            iconOffset: { y: -7 },\n        });\n\n        const buttonsScale = 0.5;\n\n        this.layout = new Layout({\n            id: 'root',\n            content: {\n                icons: {\n                    content: new Array(amount)\n                        .fill(null)\n                        .map(() => Sprite.from(testAssets[image])),\n                    styles: {\n                        position: 'center',\n                        padding,\n                        maxWidth: `${maxWidth}%`,\n                        background: 'black',\n                        borderRadius: 20,\n                    },\n                },\n                controls: {\n                    content: [addButton, removeButton],\n                    styles: {\n                        position: 'bottomCenter',\n                        scale: buttonsScale,\n                        marginBottom: -20,\n                    },\n                },\n            },\n            styles: {\n                position: 'center',\n                width: '100%',\n                height: 250,\n            },\n        });\n\n        const iconsLayout: Layout = this.layout.content.getByID(\n            'icons'\n        ) as Layout;\n\n        addButton.onPress.connect(() =>\n        {\n            iconsLayout.addContent(Sprite.from(testAssets[image]));\n        });\n\n        removeButton.onPress.connect(() =>\n        {\n            const icons = iconsLayout.content.children;\n\n            if (icons.size > 0)\n            {\n                iconsLayout.removeChildByID(icons.entries().next().value[0]);\n            }\n        });\n\n        this.layout.resize(this.w, this.h);\n        this.view.addChild(this.layout);\n    }\n\n    async addTooltip(text: string)\n    {\n        this.toolTip = await toolTip(text);\n        this.view.addChild(this.toolTip);\n        this.toolTip.resize(this.w, this.h);\n    }\n\n    resize(w: number, h: number)\n    {\n        this.w = w;\n        this.h = h;\n\n        this.layout?.resize(w, h);\n        this.toolTip?.resize(w, h);\n    }\n}\n\nexport const AddRemoveContent = (params: any) => new LayoutStory(params);\n\nexport default {\n    title: 'Dynamic',\n    argTypes: argTypes(args),\n    args: getDefaultArgs(args),\n};\n\n'layout/src/controllers/AlignController.ts'\n:import { Text } from 'pixi.js';\nimport { Layout, LayoutSystem } from '../Layout';\nimport { isItJustAText } from '../utils/helpers';\n\n\nexport class AlignController\n{\n    protected layout: LayoutSystem;\n\n\n    constructor(layout: LayoutSystem)\n    {\n        this.layout = layout;\n    }\n\n\n    resize(parentWidth: number, parentHeight: number)\n    {\n        this.setSelfPosition(parentWidth, parentHeight);\n\n        this.layout.content.resize(this.layout.width, this.layout.height);\n\n\n        this.alignChildren(this.layout.width, this.layout.height);\n    }\n\n    protected alignChildren(parentWidth: number, parentHeight: number)\n    {\n        let maxChildHeight = 0;\n\n        const { style } = this.layout;\n\n        const paddingTop = style.paddingTop ?? 0;\n        const paddingRight = style.paddingRight ?? 0;\n        const paddingBottom = style.paddingBottom ?? 0;\n        const paddingLeft = style.paddingLeft ?? 0;\n\n        let x = paddingLeft;\n        let y = paddingTop;\n\n        const children = this.layout.content.children;\n\n        children.forEach((child) =>\n        {\n            if (!child.height && !child.width) return;\n\n            if (child instanceof Text && isItJustAText(this.layout))\n            {\n                const availableWidth = parentWidth - paddingLeft - paddingRight;\n\n                const align = style.textAlign;\n\n                if (child.width < availableWidth)\n                {\n                    if (align === 'center')\n                    {\n                        child.anchor.x = 0.5;\n                        child.x = parentWidth / 2;\n                    }\n                    else if (align === 'right')\n                    {\n                        child.anchor.x = 1;\n                        child.x = parentWidth - paddingRight;\n                    }\n                    else\n                    {\n                        child.anchor.x = 0;\n                        child.x = paddingLeft;\n                    }\n                }\n                else\n                {\n                    child.anchor.x = 0;\n                    child.x = paddingLeft;\n                }\n\n                const verticalAlign = style.verticalAlign;\n\n                const availableHeight\n                    = parentHeight - paddingTop - paddingBottom;\n\n                if (child.height < availableHeight)\n                {\n                    if (verticalAlign === 'middle')\n                    {\n                        child.anchor.y = 0.5;\n                        child.y = parentHeight / 2;\n                    }\n                    else if (verticalAlign === 'bottom')\n                    {\n                        child.anchor.y = 1;\n                        child.y = parentHeight - paddingBottom;\n                    }\n                    else\n                    {\n                        child.anchor.y = 0;\n                        child.y = paddingTop;\n                    }\n                }\n                else\n                {\n                    child.anchor.y = 0;\n                    child.y = paddingTop;\n                }\n\n                return;\n            }\n\n            let childDisplay = 'inline-block';\n            let childMarginLeft = 0;\n            let childMarginRight = 0;\n            let childMarginTop = 0;\n            let childMarginBottom = 0;\n\n            if (child.isPixiLayout || child instanceof Layout)\n            {\n                const childLayout = child.layout as LayoutSystem;\n\n                childDisplay = childLayout.style.display;\n                childMarginLeft = childLayout.style.marginLeft;\n                childMarginRight = childLayout.style.marginRight;\n                childMarginTop = childLayout.style.marginTop;\n                childMarginBottom = childLayout.style.marginBottom;\n\n                if (childLayout.style.position !== undefined)\n                {\n\n                    return;\n                }\n            }\n\n            let anchorX = 0;\n            let anchorY = 0;\n\n            if (style.position === undefined)\n            {\n\n                anchorX\n                    = style.anchorX !== undefined\n                        ? style.anchorX * this.layout.width\n                        : 0;\n                anchorY\n                    = style.anchorY !== undefined\n                        ? style.anchorY * this.layout.height\n                        : 0;\n            }\n\n            child.x = x + childMarginLeft - anchorX;\n            child.y = y + childMarginTop - anchorY;\n\n            if (\n                child.height + childMarginTop + childMarginBottom\n                > maxChildHeight\n            )\n            {\n                maxChildHeight\n                    = child.height + childMarginTop + childMarginBottom;\n            }\n\n            const availableWidth = parentWidth - paddingRight;\n\n            if (childDisplay === 'block' && child.width < availableWidth)\n            {\n                childDisplay = 'inline-block';\n            }\n\n            const isFeetParentWidth\n                = x + child.width + childMarginRight <= availableWidth;\n            const isFirstChild = child === this.layout.content.firstChild;\n\n            switch (childDisplay)\n            {\n                case 'inline':\n                case 'inline-block':\n                    if (!isFeetParentWidth && !isFirstChild)\n                    {\n                        x = paddingLeft + child.width + childMarginRight;\n                        y += maxChildHeight;\n\n                        child.x = paddingLeft + childMarginLeft;\n                        child.y = y + childMarginTop;\n                    }\n                    else\n                    {\n                        x += child.width + childMarginRight;\n                    }\n                    break;\n\n                default:\n                    y += child.height + childMarginBottom;\n                    break;\n            }\n        });\n    }\n\n    protected setSelfPosition(parentWidth: number, parentHeight: number)\n    {\n        const { position, marginRight, marginBottom, marginTop, marginLeft }\n            = this.layout.style || {};\n\n        const { style } = this.layout;\n\n        if (!position) return;\n\n        const scaleX = this.layout.container.scale.x;\n        const scaleY = this.layout.container.scale.y;\n        const width = this.layout.width * scaleX;\n        const height = this.layout.height * scaleY;\n\n        const anchorX = style.anchorX;\n        const anchorY = style.anchorY;\n\n        const finalPosition = {\n            x: 0,\n            y: 0,\n        };\n\n        switch (position)\n        {\n            case 'rightTop':\n            case 'topRight':\n            case 'right':\n                finalPosition.x\n                    = parentWidth - marginRight - (width * (anchorX ?? 1));\n                finalPosition.y = marginTop - (height * (anchorY ?? 0));\n                break;\n\n            case 'leftBottom':\n            case 'bottomLeft':\n            case 'bottom':\n                finalPosition.x = marginLeft - (width * (anchorX ?? 0));\n                finalPosition.y\n                    = parentHeight - marginBottom - (height * (anchorY ?? 1));\n                break;\n\n            case 'rightBottom':\n            case 'bottomRight':\n                finalPosition.x\n                    = parentWidth - marginRight - (width * (anchorX ?? 1));\n                finalPosition.y\n                    = parentHeight - marginBottom - (height * (anchorY ?? 1));\n                break;\n\n            case 'center':\n                finalPosition.x\n                    = (parentWidth / 2) - (width * (anchorX ?? 0.5)) + marginLeft;\n                finalPosition.y\n                    = (parentHeight / 2) - (height * (anchorY ?? 0.5)) + marginTop;\n                break;\n\n            case 'centerTop':\n            case 'topCenter':\n                finalPosition.x\n                    = (parentWidth / 2) - (width * (anchorX ?? 0.5)) + marginLeft;\n                finalPosition.y = marginTop - (height * (anchorY ?? 0));\n                break;\n\n            case 'centerBottom':\n            case 'bottomCenter':\n                finalPosition.x\n                    = (parentWidth / 2) - (width * (anchorX ?? 0.5)) + marginLeft;\n                finalPosition.y\n                    = parentHeight - marginBottom - (height * (anchorY ?? 1));\n                break;\n\n            case 'centerLeft':\n            case 'leftCenter':\n                finalPosition.x = marginLeft - (width * (anchorX ?? 0));\n                finalPosition.y\n                    = (parentHeight / 2) - (height * (anchorY ?? 0.5)) + marginTop;\n                break;\n\n            case 'centerRight':\n            case 'rightCenter':\n                finalPosition.x\n                    = parentWidth - marginRight - (width * (anchorX ?? 1));\n                finalPosition.y\n                    = (parentHeight / 2) - (height * (anchorY ?? 0.5)) + marginTop;\n                break;\n\n            case 'leftTop':\n            case 'topLeft':\n            case 'left':\n            case 'top':\n            default:\n                finalPosition.x = marginLeft - (width * (anchorX ?? 0));\n                finalPosition.y = marginTop - (height * (anchorY ?? 0));\n        }\n\n        this.layout.container.position.set(finalPosition.x, finalPosition.y);\n    }\n}\n",
        "gt": [
            "'layout/src/controllers/AlignController.ts'",
            "'layout/src/Layout.ts'",
            "'layout/src/stories/dynamic/AddRemoveContent.stories.ts'"
        ]
    },
    {
        "files": [
            "'hydrated-ws/src/cable/Cable.ts'",
            "'hydrated-ws/src/Shell.ts'",
            "'hydrated-ws/src/wormhole/Server.ts'",
            "'hydrated-ws/src/computedFrom.ts'"
        ],
        "content": "'hydrated-ws/src/cable/Cable.ts'\n:import { Dict } from \"../polyfill/Dict\";\nimport ErrorEvent from \"../polyfill/ErrorEvent\";\nimport { Shell } from \"../Shell\";\nimport { CableError } from \"./CableError\";\nimport { uuid } from \"./uuid\";\n\nconst isVoid = (v: any): boolean => v === void 0;\nconst voidNull = (v: any): any => v === null ? void 0 : v;\n\n\n\nexport class Cable extends Shell {\n\n\n    public static readonly PARSE_ERROR: number = -32700;\n\n\n    public static readonly INVALID_REQUEST: number = -32600;\n\n\n    public static readonly METHOD_NOT_FOUND: number = -32601;\n\n\n    public static readonly INVALID_PARAMS: number = -32602;\n\n\n    public static readonly INTERNAL_ERROR: number = -32603;\n\n\n    public static readonly SERVER_ERROR: number = -32000;\n\n\n    public static readonly TIMEOUT_ERROR: number = -32001;\n\n\n    public static readonly UNKNOWN_REQUEST: number = -32002;\n\n\n    public static readonly INVALID_CLIENT_PARAMS: number = -32603;\n\n    private static readonly id = uuid();\n    private static index = 0;\n\n    private calls: Dict<string,\n        { resolve: (value?: any) => void, reject: (error?: any) => void, timeout: any }> = new Dict();\n    private methods: Dict<string, (params) => Promise<any>> = new Dict();\n\n\n    constructor(ws: WebSocket) {\n        super();\n        this.ws = ws;\n        this.forwardEvents([\"close\", \"open\"]);\n        this.ws.addEventListener(\"message\", this.receivedMessage);\n    }\n\n\n    public register(name: string, method: (params: any) => Promise<any>) {\n        this.methods.set(name, method);\n    }\n\n\n    public async request(method: string, params?: object | any[], timeout?: number) {\n        this.guardParameters(params);\n        Cable.index++;\n        const id = `${Cable.id}-${Cable.index}`;\n        const p = new Promise((resolve, reject) => this.calls.set(id, {\n            reject,\n            resolve,\n            timeout: timeout ? setTimeout(() => this.timeout(id), timeout) : null,\n        }));\n        this.sendMessage(id, { method, params });\n        return p;\n    }\n\n\n    public notify(method: string, params?: object | any[]) {\n        this.guardParameters(params);\n        this.sendMessage(null, { method, params });\n    }\n\n\n    public destroy() {\n        this.stopForwardingEvents();\n        this.ws.removeEventListener(\"message\", this.receivedMessage);\n        this.calls.keys().forEach((id) => this.timeout(id));\n        this.calls.clear();\n        this.methods.clear();\n    }\n\n    private guardParameters(params?: object | any[]): void {\n        if (params === null || (!isVoid(params) && typeof params !== \"object\")) {\n            throw new CableError(\n                `params accept an array or an object, provided a ${params === null ? null : typeof params}`,\n                Cable.INVALID_CLIENT_PARAMS,\n            );\n        }\n    }\n\n    private timeout(id: string): void {\n        if (this.calls.has(id)) {\n            this.calls.get(id).reject(new CableError(\"Request timeout\", Cable.TIMEOUT_ERROR));\n            this.calls.delete(id);\n        }\n    }\n\n    private sendMessage(id: string, message: any) {\n        if (isVoid(id)) {\n            return;\n        }\n        message.jsonrpc = \"2.0\";\n        if (id !== null) {\n            message.id = id;\n        }\n        try {\n            this.ws.send(JSON.stringify(message));\n        } catch (e) {\n\n        }\n\n    }\n\n    private sendError(id: string, code: number, messageOrError: string | Error) {\n        let message = messageOrError ? messageOrError.toString() : \"Unknown error\";\n        if (messageOrError instanceof CableError) {\n            code = messageOrError.code;\n            message = messageOrError.message;\n        }\n        this.sendMessage(id, { error: { code, message } });\n    }\n\n    private parseMessage(message: string): any {\n        try {\n            const data: any = JSON.parse(message);\n            data.id = voidNull(data.id);\n            return data;\n        } catch (e) {\n            this.sendError(null, Cable.PARSE_ERROR, e);\n            return;\n        }\n\n    }\n\n    private receivedMessage = (e: MessageEvent): void => {\n        const data = this.parseMessage(e.data);\n        if (!data) {\n            return;\n        }\n        if (!isVoid(data.error)) {\n            this.rpcError(data.id, data.error.code, data.error.message);\n        } else if (!isVoid(data.result)) {\n            this.rpcResult(data.id, data.result);\n        } else if (!isVoid(data.method)) {\n            this.rpcCall(data.id, data.method, data.params);\n        } else {\n            this.sendError(data.id, Cable.INVALID_PARAMS, \"Unknown message type\");\n        }\n    }\n\n    private rpcCall(id: string, method: string, params: any): void {\n        if (this.methods.has(method)) {\n            this.methods.get(method).call(this, params)\n                .then((res) => {\n                    this.sendMessage(id, { result: res || null });\n                })\n                .catch(this.sendError.bind(this, id, Cable.SERVER_ERROR));\n        } else {\n            this.sendError(id, Cable.METHOD_NOT_FOUND, `Method '${method}' not found`);\n        }\n    }\n\n    private rpcResult(id: string, results: any): void {\n        if (this.calls.has(id)) {\n            clearTimeout(this.calls.get(id).timeout);\n            this.calls.get(id).resolve(results);\n            this.calls.delete(id);\n\n        } else {\n            this.dispatchEvent(new ErrorEvent(\"error\", {\n                error:\n                    new CableError(`Response received for an unknown request`, Cable.UNKNOWN_REQUEST),\n            }));\n        }\n    }\n\n    private rpcError(id: string, code: number, message: string): void {\n        const error = new CableError(message, code);\n        if (this.calls.has(id)) {\n            clearTimeout(this.calls.get(id).timeout);\n            this.calls.get(id).reject(error);\n            this.calls.delete(id);\n        } else {\n            this.dispatchEvent(new ErrorEvent(\"error\", { error }));\n        }\n    }\n\n}\n\n'hydrated-ws/src/Shell.ts'\n:import {computedFrom} from \"./computedFrom\";\nimport IHydratedWebSocketEventMap from \"./IHydratedWebSocketEventMap\";\nimport { Dict } from \"./polyfill/Dict\";\nimport WebSocket from \"./polyfill/WebSocket\";\n\nexport abstract class Shell implements WebSocket {\n\n\n    @computedFrom(\"_onclose\")\n    public get onclose(): (ev: CloseEvent) => any {\n        return this._onclose;\n    }\n\n    public set onclose(f: (ev: CloseEvent) => any) {\n        this._onclose = f;\n    }\n\n\n    @computedFrom(\"_onerror\")\n    public get onerror(): (ev: Event) => any {\n        return this._onerror;\n    }\n\n    public set onerror(f: (ev: Event) => any) {\n        this._onerror = f;\n    }\n\n\n    @computedFrom(\"_onmessage\")\n    public get onmessage(): (ev: MessageEvent) => any {\n        return this.getOnmessage();\n    }\n\n    public set onmessage(f: (ev: MessageEvent) => any) {\n        this.setOnmessage(f);\n    }\n\n\n    @computedFrom(\"_onopen\")\n    public get onopen(): (ev: Event) => any {\n        return this._onopen;\n    }\n\n    public set onopen(f: (ev: Event) => any) {\n        this._onopen = f;\n    }\n\n\n    @computedFrom(\"ws.readyState\")\n    public get readyState(): number {\n        return this.getReadyState();\n    }\n\n\n    @computedFrom(\"ws.url\")\n    public get url(): string {\n        return this.ws.url;\n    }\n\n\n    @computedFrom(\"ws.bufferedAmount\")\n    public get bufferedAmount(): number {\n        return this.ws.bufferedAmount;\n    }\n\n\n    @computedFrom(\"ws.extensions\")\n    public get extensions(): string {\n        return this.ws.extensions;\n    }\n\n    @computedFrom(\"ws.protocol\")\n    public get protocol(): string {\n        return this.ws.protocol;\n    }\n\n\n    public readonly CONNECTING = WebSocket.CONNECTING;\n\n    public readonly OPEN = WebSocket.OPEN;\n\n    public readonly CLOSING = WebSocket.CLOSING;\n\n    public readonly CLOSED = WebSocket.CLOSED;\n\n\n    public binaryType: \"blob\" | \"arraybuffer\";\n\n    protected closing: boolean = false;\n    protected ws: WebSocket;\n    protected _readyState: number = WebSocket.CONNECTING;\n    protected listeners: Dict<keyof IHydratedWebSocketEventMap,\n        Array<{\n            listener: (this: WebSocket,\n                       ev: IHydratedWebSocketEventMap[keyof IHydratedWebSocketEventMap]) => any,\n            useCapture?: boolean,\n        }>> = new Dict();\n\n    private readonly forwardListener: (evt: Event) => boolean;\n    private _onerror: (ev: Event) => any;\n    private _onmessage: (ev: MessageEvent) => any;\n    private _onopen: (ev: Event) => any;\n    private _onclose: (ev: CloseEvent) => any;\n\n    constructor(ws?: WebSocket) {\n        if (!this.dispatchEvent) {\n            throw new TypeError(\"Failed to construct. Please use the 'new' operator\");\n        }\n        this.forwardListener = this.dispatchEvent.bind(this);\n        if (ws) {\n            this.ws = ws;\n            this.forwardEvents();\n        }\n    }\n\n\n    public close(code: number = 1000, reason?: string) {\n        this.ws.close(code, reason);\n    }\n\n\n    public send(data: string | ArrayBuffer | Blob | ArrayBufferView): void {\n        if (this.ws.readyState !== WebSocket.OPEN) {\n            const err = new Error(\n                `WebSocket is not open ws is ${this.ws.readyState}, local is ${this.readyState}`,\n            );\n            throw err;\n        }\n        this.ws.send(data);\n    }\n\n\n    public addEventListener<K extends keyof IHydratedWebSocketEventMap>(type: K,\n                                                                        listener: (this: WebSocket,\n                                                                                   ev: IHydratedWebSocketEventMap[K])\n                                                                                  => any,\n                                                                        useCapture?: boolean): void {\n        let listeners = this.listeners.get(type);\n        if (!listeners) {\n            listeners = [];\n            this.listeners.set(type, listeners);\n        }\n        listeners.push({ listener, useCapture });\n    }\n\n\n    public removeEventListener<K extends keyof IHydratedWebSocketEventMap>(type: K,\n                                                                           listener: (this: WebSocket,\n                                                                                      ev: IHydratedWebSocketEventMap[K])\n                                                                                     => any,\n                                                                           useCapture?: boolean): void {\n        const listeners = this.listeners.get(type);\n        if (listeners) {\n            this.listeners.set(\n                type,\n                listeners.filter((l) => l.listener !== listener || l.useCapture !== useCapture),\n            );\n        }\n    }\n\n\n    public dispatchEvent(evt: Event): boolean {\n        const method = this[`_on${evt.type}`];\n        if (typeof method === \"function\") {\n            method.call(this, evt);\n        }\n        return (this.listeners.get(evt.type as keyof IHydratedWebSocketEventMap) || [])\n            .some(({ listener }) => listener.call(this, evt) === false) === void 0;\n    }\n\n    protected getOnmessage(): (ev: MessageEvent) => any {\n        return this._onmessage;\n    }\n\n    protected setOnmessage(f: (ev: MessageEvent) => any) {\n        this._onmessage = f;\n    }\n\n    protected forwardEvents<K extends keyof IHydratedWebSocketEventMap>(list?: K[]) {\n        (list || [\"close\", \"message\", \"open\"] as K[]).forEach((event: K): void =>\n            this.ws.addEventListener(event, this.forwardListener),\n        );\n    }\n\n    protected stopForwardingEvents() {\n        this.ws.removeEventListener(\"close\", this.forwardListener);\n        this.ws.removeEventListener(\"message\", this.forwardListener);\n        this.ws.removeEventListener(\"open\", this.forwardListener);\n    }\n\n    protected getReadyState(): number {\n        return this.ws.readyState;\n    }\n\n}\n\n'hydrated-ws/src/wormhole/Server.ts'\n:import {Cable} from \"../cable/Cable\";\nimport {Pipe} from \"../pipe/Pipe\";\nimport {Dict} from \"../polyfill/Dict\";\nimport WebSocket from \"../polyfill/WebSocket\";\nimport {Router} from \"../router/Router\";\n\nexport class Server {\n\n    public readonly router: Router;\n\n    public clients: Dict<string, { data: Pipe, cable: Pipe }> = new Dict();\n    public buffers: Dict<string, string[]> = new Dict();\n    public channels: Dict<string, { source: Pipe, target?: Pipe }> = new Dict();\n\n    constructor() {\n        this.router = new Router();\n    }\n\n    public destroy() {\n        this.router.destroy();\n        this.channels.values()\n            .forEach(({source, target}: { source: Pipe, target?: Pipe }) => {\n                if (source) {\n                    source.close();\n                }\n                if (target) {\n                    target.close();\n                }\n            });\n        this.clients.values()\n            .forEach(({data, cable}: { data: Pipe, cable?: Pipe }) => {\n                if (data) {\n                    data.close();\n                }\n                if (cable) {\n                    cable.close();\n                }\n            });\n        this.clients = void 0;\n        this.buffers = void 0;\n        this.channels = void 0;\n    }\n\n    public addWebSocket(ws: WebSocket): () => void {\n\n        const cablePipe = new Pipe(ws, \"WOHC\");\n        const cable = new Cable(cablePipe);\n        const dataPipe = new Pipe(ws, \"WOHD\");\n\n        cable.register(\"identity\", ({uuid}: { uuid: string }): Promise<void> => {\n            this.router.set(uuid, ws);\n            return new Promise((resolve) => setTimeout(resolve, 0));\n        });\n\n        cable.register(\"close\", ({channel}: { channel: string }): Promise<void> => {\n            const pipes = this.channels.get(channel);\n            if (pipes && pipes.source) {\n                pipes.source.close();\n            }\n            return new Promise((resolve) => setTimeout(resolve, 0));\n        });\n\n        cable.register(\"connect\", ({uuid, channel}: { uuid: string, channel: string }): Promise<void> => {\n            try {\n                const targetWs = this.router.get(uuid);\n                const pipes: { source: Pipe, target?: Pipe } = {source: new Pipe(dataPipe, channel, 32)};\n                this.channels.set(channel, pipes);\n                pipes.source.onmessage = (event) => {\n                    if (!this.buffers.has(channel)) {\n                        this.buffers.set(channel, []);\n                    }\n                    this.buffers.get(channel).push(event.data);\n                };\n                const connect = () => {\n                    if (!this.clients.has(uuid)) {\n                        const routedCablePipe = new Pipe(targetWs, \"WOHC\");\n                        const routedDataPipe = new Pipe(targetWs, \"WOHD\");\n                        this.clients.set(uuid, { data: routedDataPipe, cable: routedCablePipe });\n                    }\n                    const client = this.clients.get(uuid);\n                    const targetCablePipe = client.cable;\n                    const targetDataPipe = client.data;\n                    const targetCable = new Cable(targetCablePipe);\n                    pipes.target = new Pipe(targetDataPipe, channel, 32);\n                    pipes.target.onmessage = (event) => {\n                        try {\n                            pipes.source.send(event.data);\n                        } catch (e) {\n\n                        }\n                    };\n                    pipes.source.onclose = (event) => {\n                        pipes.target.close();\n                        try {\n                            targetCable.notify(\"close\", {channel});\n                        } catch (e) {\n\n                        }\n                        this.channels.delete(channel);\n                    };\n                    targetCable.request(\"open\", {channel})\n                        .then(() => {\n                            const buffer = this.buffers.get(channel) || [];\n                            while (buffer.length) {\n                                pipes.target.send(buffer.shift());\n                            }\n                            pipes.source.onmessage = (event) => {\n                                pipes.target.send(event.data);\n                            };\n                        })\n                        .catch(() => void 0);\n\n                };\n                if (targetWs.readyState === WebSocket.OPEN) {\n                    connect();\n                }\n                targetWs.addEventListener(\"open\", () => {\n                    connect();\n                });\n            } catch (e) {\n\n            }\n            return new Promise((resolve) => setTimeout(resolve, 0));\n        });\n\n        return () => {\n            cable.destroy();\n            cablePipe.close();\n            dataPipe.close();\n        };\n    }\n\n}\n\n'hydrated-ws/src/computedFrom.ts'\n:export function computedFrom(...rest) {\n    return (target, key, descriptor) => {\n        descriptor.get.dependencies = rest;\n        return descriptor;\n    };\n}\n",
        "gt": [
            "'hydrated-ws/src/computedFrom.ts'",
            "'hydrated-ws/src/Shell.ts'",
            "'hydrated-ws/src/cable/Cable.ts'",
            "'hydrated-ws/src/wormhole/Server.ts'"
        ]
    },
    {
        "files": [
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/directives/drag-handle.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/tests/grid.spec.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/grid.utils.ts'"
        ],
        "content": "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts'\n:import {\n    AfterContentInit, ChangeDetectionStrategy, Component, ContentChildren, ElementRef, Inject, Input, NgZone, OnDestroy, OnInit, QueryList, Renderer2,\n    ViewChild\n} from '@angular/core';\nimport { BehaviorSubject, iif, merge, NEVER, Observable, Subject, Subscription } from 'rxjs';\nimport { exhaustMap, filter, map, startWith, switchMap, take, takeUntil } from 'rxjs/operators';\nimport { ktdMouseOrTouchDown, ktdMouseOrTouchEnd, ktdPointerClient } from '../utils/pointer.utils';\nimport { GRID_ITEM_GET_RENDER_DATA_TOKEN, KtdGridItemRenderDataTokenType } from '../grid.definitions';\nimport { KTD_GRID_DRAG_HANDLE, KtdGridDragHandle } from '../directives/drag-handle';\nimport { KTD_GRID_RESIZE_HANDLE, KtdGridResizeHandle } from '../directives/resize-handle';\nimport { KtdGridService } from '../grid.service';\nimport { ktdOutsideZone } from '../utils/operators';\nimport { BooleanInput, coerceBooleanProperty } from '../coercion/boolean-property';\nimport { coerceNumberProperty, NumberInput } from '../coercion/number-property';\n\n@Component({\n    selector: 'ktd-grid-item',\n    templateUrl: './grid-item.component.html',\n    styleUrls: ['./grid-item.component.scss'],\n    changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class KtdGridItemComponent implements OnInit, OnDestroy, AfterContentInit {\n\n    @ContentChildren(KTD_GRID_DRAG_HANDLE, {descendants: true}) _dragHandles: QueryList<KtdGridDragHandle>;\n    @ContentChildren(KTD_GRID_RESIZE_HANDLE, {descendants: true}) _resizeHandles: QueryList<KtdGridResizeHandle>;\n    @ViewChild('resizeElem', {static: true, read: ElementRef}) resizeElem: ElementRef;\n\n\n    @Input() minW?: number;\n    @Input() minH?: number;\n    @Input() maxW?: number;\n    @Input() maxH?: number;\n\n\n    @Input() transition: string = 'transform 500ms ease, width 500ms ease, height 500ms ease';\n\n    dragStart$: Observable<MouseEvent | TouchEvent>;\n    resizeStart$: Observable<MouseEvent | TouchEvent>;\n\n\n    @Input()\n    get id(): string {\n        return this._id;\n    }\n\n    set id(val: string) {\n        this._id = val;\n    }\n\n    private _id: string;\n\n\n    @Input()\n    get dragStartThreshold(): number { return this._dragStartThreshold; }\n\n    set dragStartThreshold(val: number) {\n        this._dragStartThreshold = coerceNumberProperty(val);\n    }\n\n    private _dragStartThreshold: number = 0;\n\n\n\n    @Input()\n    get draggable(): boolean {\n        return this._draggable;\n    }\n\n    set draggable(val: boolean) {\n        this._draggable = coerceBooleanProperty(val);\n        this._draggable$.next(this._draggable);\n    }\n\n    private _draggable: boolean = true;\n    private _draggable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._draggable);\n\n\n    @Input()\n    get resizable(): boolean {\n        return this._resizable;\n    }\n\n    set resizable(val: boolean) {\n        this._resizable = coerceBooleanProperty(val);\n        this._resizable$.next(this._resizable);\n    }\n\n    private _resizable: boolean = true;\n    private _resizable$: BehaviorSubject<boolean> = new BehaviorSubject<boolean>(this._resizable);\n\n    private dragStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n    private resizeStartSubject: Subject<MouseEvent | TouchEvent> = new Subject<MouseEvent | TouchEvent>();\n\n    private subscriptions: Subscription[] = [];\n\n    constructor(public elementRef: ElementRef,\n                private gridService: KtdGridService,\n                private renderer: Renderer2,\n                private ngZone: NgZone,\n                @Inject(GRID_ITEM_GET_RENDER_DATA_TOKEN) private getItemRenderData: KtdGridItemRenderDataTokenType) {\n        this.dragStart$ = this.dragStartSubject.asObservable();\n        this.resizeStart$ = this.resizeStartSubject.asObservable();\n    }\n\n    ngOnInit() {\n        const gridItemRenderData = this.getItemRenderData(this.id)!;\n        this.setStyles(gridItemRenderData);\n    }\n\n    ngAfterContentInit() {\n        this.subscriptions.push(\n            this._dragStart$().subscribe(this.dragStartSubject),\n            this._resizeStart$().subscribe(this.resizeStartSubject),\n        );\n    }\n\n    ngOnDestroy() {\n        this.subscriptions.forEach(sub => sub.unsubscribe());\n    }\n\n    setStyles({top, left, width, height}: { top: string, left: string, width?: string, height?: string }) {\n\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transform', `translateX(${left}) translateY(${top})`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'display', `block`);\n        this.renderer.setStyle(this.elementRef.nativeElement, 'transition', this.transition);\n        if (width != null) { this.renderer.setStyle(this.elementRef.nativeElement, 'width', width); }\n        if (height != null) {this.renderer.setStyle(this.elementRef.nativeElement, 'height', height); }\n    }\n\n    private _dragStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._draggable$.pipe(\n            switchMap((draggable) => {\n                if (!draggable) {\n                    return NEVER;\n                } else {\n                    return this._dragHandles.changes.pipe(\n                        startWith(this._dragHandles),\n                        switchMap((dragHandles: QueryList<KtdGridDragHandle>) => {\n                            return iif(\n                                () => dragHandles.length > 0,\n                                merge(...dragHandles.toArray().map(dragHandle => ktdMouseOrTouchDown(dragHandle.element.nativeElement, 1))),\n                                ktdMouseOrTouchDown(this.elementRef.nativeElement, 1)\n                            ).pipe(\n                                exhaustMap((startEvent) => {\n\n\n\n\n\n\n                                    if (startEvent.target && (startEvent.target as HTMLElement).draggable && startEvent.type === 'mousedown') {\n                                        startEvent.preventDefault();\n                                    }\n\n                                    const startPointer = ktdPointerClient(startEvent);\n                                    return this.gridService.mouseOrTouchMove$(document).pipe(\n                                        takeUntil(ktdMouseOrTouchEnd(document, 1)),\n                                        ktdOutsideZone(this.ngZone),\n                                        filter((moveEvent) => {\n                                            moveEvent.preventDefault();\n                                            const movePointer = ktdPointerClient(moveEvent);\n                                            const distanceX = Math.abs(startPointer.clientX - movePointer.clientX);\n                                            const distanceY = Math.abs(startPointer.clientY - movePointer.clientY);\n\n                                            return distanceX + distanceY >= this.dragStartThreshold;\n                                        }),\n                                        take(1),\n\n                                        map(() => startEvent)\n                                    );\n                                })\n                            );\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n    private _resizeStart$(): Observable<MouseEvent | TouchEvent> {\n        return this._resizable$.pipe(\n            switchMap((resizable) => {\n                if (!resizable) {\n\n                    this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                    return NEVER;\n                } else {\n                    return this._resizeHandles.changes.pipe(\n                        startWith(this._resizeHandles),\n                        switchMap((resizeHandles: QueryList<KtdGridResizeHandle>) => {\n                            if (resizeHandles.length > 0) {\n\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'none');\n                                return merge(...resizeHandles.toArray().map(resizeHandle => ktdMouseOrTouchDown(resizeHandle.element.nativeElement, 1)));\n                            } else {\n                                this.renderer.setStyle(this.resizeElem.nativeElement, 'display', 'block');\n                                return ktdMouseOrTouchDown(this.resizeElem.nativeElement, 1);\n                            }\n                        })\n                    );\n                }\n            })\n        );\n    }\n\n\n    static ngAcceptInputType_minW: NumberInput;\n    static ngAcceptInputType_minH: NumberInput;\n    static ngAcceptInputType_maxW: NumberInput;\n    static ngAcceptInputType_maxH: NumberInput;\n    static ngAcceptInputType_draggable: BooleanInput;\n    static ngAcceptInputType_resizable: BooleanInput;\n    static ngAcceptInputType_dragStartThreshold: NumberInput;\n\n}\n\n'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/directives/drag-handle.ts'\n:import { Directive, ElementRef, InjectionToken } from '@angular/core';\n\n\nexport const KTD_GRID_DRAG_HANDLE = new InjectionToken<KtdGridDragHandle>('KtdGridDragHandle');\n\n\n@Directive({\n    selector: '[ktdGridDragHandle]',\n\n    host: {\n        class: 'ktd-grid-drag-handle'\n    },\n    providers: [{provide: KTD_GRID_DRAG_HANDLE, useExisting: KtdGridDragHandle}],\n})\n\nexport class KtdGridDragHandle {\n    constructor(\n        public element: ElementRef<HTMLElement>) {\n    }\n}\n\n'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/tests/grid.spec.ts'\n:import { ktdGetGridLayoutDiff } from '../grid.utils';\n\ndescribe('Grid utils', () => {\n\n    describe('ktdGetGridLayoutDiff', () => {\n        it('should calculate resize grid diff', () => {\n            const a = [\n                {x: 1, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 2, id: '3'}\n            ];\n            const b = [\n                {x: 1, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 3, id: '3'}\n            ];\n            expect(ktdGetGridLayoutDiff(a, b)).toEqual({3: {change: 'resize'}});\n        });\n\n        it('should calculate move items grid diff', () => {\n            const a = [\n                {x: 1, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 2, id: '3'}\n            ];\n            const b = [\n                {x: 2, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'}\n\n            ];\n            expect(ktdGetGridLayoutDiff(a, b)).toEqual({2: {change: 'move'}});\n        });\n\n        it('should calculate resize and move changes on the grid', () => {\n            const a = [\n                {x: 1, y: 1, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 1, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 2, id: '3'}\n            ];\n            const b = [\n                {x: 1, y: 2, w: 1, h: 1, id: '2'},\n                {x: 1, y: 0, w: 3, h: 1, id: '1'},\n                {x: 0, y: 1, w: 2, h: 2, id: '3'}\n            ];\n            expect(ktdGetGridLayoutDiff(a, b)).toEqual({2: {change: 'move'}, 1: {change: 'resize'}});\n        });\n    });\n\n});\n\n'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/grid.utils.ts'\n:import { compact, CompactType, getFirstCollision, Layout, LayoutItem, moveElement } from './react-grid-layout.utils';\nimport { KtdDraggingData, KtdGridCfg, KtdGridCompactType, KtdGridItemRect, KtdGridLayout, KtdGridLayoutItem } from '../grid.definitions';\nimport { ktdPointerClientX, ktdPointerClientY } from './pointer.utils';\nimport { KtdDictionary } from '../../types';\nimport { KtdGridItemComponent } from '../grid-item/grid-item.component';\n\n\nexport function ktdTrackById(index: number, item: {id: string}) {\n    return item.id;\n}\n\n\nexport function ktdGridCompact(layout: KtdGridLayout, compactType: KtdGridCompactType, cols: number): KtdGridLayout {\n    return compact(layout, compactType, cols)\n\n        .map(item => ({ id: item.id, x: item.x, y: item.y, w: item.w, h: item.h, minW: item.minW, minH: item.minH, maxW: item.maxW, maxH: item.maxH }));\n}\n\nfunction screenXPosToGridValue(screenXPos: number, cols: number, width: number): number {\n    return Math.round((screenXPos * cols) / width);\n}\n\nfunction screenYPosToGridValue(screenYPos: number, rowHeight: number, height: number): number {\n    return Math.round(screenYPos / rowHeight);\n}\n\n\nexport function ktdGetGridLayoutDiff(gridLayoutA: KtdGridLayoutItem[], gridLayoutB: KtdGridLayoutItem[]): KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> {\n    const diff: KtdDictionary<{ change: 'move' | 'resize' | 'moveresize' }> = {};\n\n    gridLayoutA.forEach(itemA => {\n        const itemB = gridLayoutB.find(_itemB => _itemB.id === itemA.id);\n        if (itemB != null) {\n            const posChanged = itemA.x !== itemB.x || itemA.y !== itemB.y;\n            const sizeChanged = itemA.w !== itemB.w || itemA.h !== itemB.h;\n            const change: 'move' | 'resize' | 'moveresize' | null = posChanged && sizeChanged ? 'moveresize' : posChanged ? 'move' : sizeChanged ? 'resize' : null;\n            if (change) {\n                diff[itemB.id] = {change};\n            }\n        }\n    });\n    return diff;\n}\n\n\nexport function ktdGridItemDragging(gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n\n    const gridItemId = gridItem.id;\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n    const offsetX = clientStartX - dragElemClientRect.left;\n    const offsetY = clientStartY - dragElemClientRect.top;\n\n\n    const gridElementLeftPosition = gridElemClientRect.left + scrollDifference.left;\n    const gridElementTopPosition = gridElemClientRect.top + scrollDifference.top;\n\n\n    const gridRelXPos = clientX - gridElementLeftPosition - offsetX;\n    const gridRelYPos = clientY - gridElementTopPosition - offsetY;\n\n\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        x: screenXPosToGridValue(gridRelXPos, config.cols, gridElemClientRect.width),\n        y: screenYPosToGridValue(gridRelYPos, config.rowHeight, gridElemClientRect.height)\n    };\n\n\n    layoutItem.x = Math.max(0, layoutItem.x);\n    layoutItem.y = Math.max(0, layoutItem.y);\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.x = Math.max(0, config.cols - layoutItem.w);\n    }\n\n\n    const layoutItems: LayoutItem[] = config.layout;\n    const draggedLayoutItem: LayoutItem = layoutItems.find(item => item.id === gridItemId)!;\n\n    let newLayoutItems: LayoutItem[] = moveElement(\n        layoutItems,\n        draggedLayoutItem,\n        layoutItem.x,\n        layoutItem.y,\n        true,\n        config.preventCollision,\n        compactionType,\n        config.cols\n    );\n\n    newLayoutItems = compact(newLayoutItems, compactionType, config.cols);\n\n    return {\n        layout: newLayoutItems,\n        draggedItemPos: {\n            top: gridRelYPos,\n            left: gridRelXPos,\n            width: dragElemClientRect.width,\n            height: dragElemClientRect.height,\n        }\n    };\n}\n\n\nexport function ktdGridItemResizing(gridItem: KtdGridItemComponent, config: KtdGridCfg, compactionType: CompactType, draggingData: KtdDraggingData): { layout: KtdGridLayoutItem[]; draggedItemPos: KtdGridItemRect } {\n    const {pointerDownEvent, pointerDragEvent, gridElemClientRect, dragElemClientRect, scrollDifference} = draggingData;\n    const gridItemId = gridItem.id;\n\n    const clientStartX = ktdPointerClientX(pointerDownEvent);\n    const clientStartY = ktdPointerClientY(pointerDownEvent);\n    const clientX = ktdPointerClientX(pointerDragEvent);\n    const clientY = ktdPointerClientY(pointerDragEvent);\n\n\n    const resizeElemOffsetX = dragElemClientRect.width - (clientStartX - dragElemClientRect.left);\n    const resizeElemOffsetY = dragElemClientRect.height - (clientStartY - dragElemClientRect.top);\n\n    const draggingElemPrevItem = config.layout.find(item => item.id === gridItemId)!;\n    const width = clientX + resizeElemOffsetX - (dragElemClientRect.left + scrollDifference.left);\n    const height = clientY + resizeElemOffsetY - (dragElemClientRect.top + scrollDifference.top);\n\n\n\n    const layoutItem: KtdGridLayoutItem = {\n        ...draggingElemPrevItem,\n        w: screenXPosToGridValue(width, config.cols, gridElemClientRect.width),\n        h: screenYPosToGridValue(height, config.rowHeight, gridElemClientRect.height)\n    };\n\n    layoutItem.w = limitNumberWithinRange(layoutItem.w, gridItem.minW ?? layoutItem.minW, gridItem.maxW ?? layoutItem.maxW);\n    layoutItem.h = limitNumberWithinRange(layoutItem.h, gridItem.minH ?? layoutItem.minH, gridItem.maxH ?? layoutItem.maxH);\n\n    if (layoutItem.x + layoutItem.w > config.cols) {\n        layoutItem.w = Math.max(1, config.cols - layoutItem.x);\n    }\n\n    if (config.preventCollision) {\n        const maxW = layoutItem.w;\n        const maxH = layoutItem.h;\n\n        let colliding = hasCollision(config.layout, layoutItem);\n        let shrunkDimension: 'w' | 'h' | undefined;\n\n        while (colliding) {\n            shrunkDimension = getDimensionToShrink(layoutItem, shrunkDimension);\n            layoutItem[shrunkDimension]--;\n            colliding = hasCollision(config.layout, layoutItem);\n        }\n\n        if (shrunkDimension === 'w') {\n            layoutItem.h = maxH;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.h--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n        if (shrunkDimension === 'h') {\n            layoutItem.w = maxW;\n\n            colliding = hasCollision(config.layout, layoutItem);\n            while (colliding) {\n                layoutItem.w--;\n                colliding = hasCollision(config.layout, layoutItem);\n            }\n        }\n\n    }\n\n    const newLayoutItems: LayoutItem[] = config.layout.map((item) => {\n        return item.id === gridItemId ? layoutItem : item;\n    });\n\n    return {\n        layout: compact(newLayoutItems, compactionType, config.cols),\n        draggedItemPos: {\n            top: dragElemClientRect.top - gridElemClientRect.top,\n            left: dragElemClientRect.left - gridElemClientRect.left,\n            width,\n            height,\n        }\n    };\n}\n\nfunction hasCollision(layout: Layout, layoutItem: LayoutItem): boolean {\n    return !!getFirstCollision(layout, layoutItem);\n}\n\nfunction getDimensionToShrink(layoutItem, lastShrunk): 'w' | 'h' {\n    if (layoutItem.h <= 1) {\n        return 'w';\n    }\n    if (layoutItem.w <= 1) {\n        return 'h';\n    }\n\n    return lastShrunk === 'w' ? 'h' : 'w';\n}\n\n\nfunction limitNumberWithinRange(num: number, min: number = 1, max: number = Infinity) {\n    return Math.min(Math.max(num, min < 1 ? 1 : min), max);\n}\n",
        "gt": [
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/directives/drag-handle.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/grid-item/grid-item.component.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/grid.utils.ts'",
            "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/tests/grid.spec.ts'"
        ]
    },
    {
        "files": [
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'",
            "'extension/src/components/Tooltip.tsx'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/components/overlay/Ambassadors.tsx'",
            "'extension/src/components/AmbassadorCard.tsx'"
        ],
        "content": "'extension/src/pages/overlay/components/overlay/Settings.tsx'\n:import { typeSafeObjectEntries } from \"../../../../utils/helpers\";\nimport { classes } from \"../../../../utils/classes\";\n\nimport useSettings from \"../../hooks/useSettings\";\n\nimport Card from \"../../../../components/Card\";\nimport Toggle from \"../Toggle\";\n\nimport type { OverlayOptionProps } from \"./Overlay\";\n\nexport default function Settings(props: OverlayOptionProps) {\n  const { className } = props;\n  const settings = useSettings();\n\n  return (\n    <Card\n      className={classes(\"absolute left-0 top-0 mx-4 my-6\", className)}\n      title=\"Extension Settings\"\n    >\n      <ul className=\"flex flex-col gap-4\">\n        {typeSafeObjectEntries(settings).map(([key, setting]) => {\n          if (!setting.configurable) return null;\n\n          return (\n            <li key={key} className=\"flex items-center\">\n              {setting.type === \"boolean\" && (\n                <Toggle\n                  label={setting.title}\n                  value={setting.value as boolean}\n                  onChange={setting.change as (value: boolean) => void}\n                />\n              )}\n            </li>\n          );\n        })}\n      </ul>\n    </Card>\n  );\n}\n\n'extension/src/components/Tooltip.tsx'\n:import {\n  useCallback,\n  useRef,\n  useState,\n  type MouseEvent,\n  useMemo,\n  useId,\n  type FocusEvent,\n  Children,\n  isValidElement,\n  cloneElement,\n} from \"react\";\n\nimport { classes } from \"../utils/classes\";\nimport { mutableDOMRect } from \"../utils/dom\";\n\ninterface TooltipProps {\n  text: string;\n  children: React.ReactNode;\n  fontSize?: string;\n  maxWidth?: string;\n}\n\nconst Tooltip = (props: TooltipProps) => {\n  const { text, children, fontSize, maxWidth } = props;\n\n  const id = useId();\n  const tooltipRef = useRef<HTMLDivElement>(null);\n  const [show, setShow] = useState(false);\n  const [position, setPosition] = useState({ top: 0, left: 0 });\n  const [above, setAbove] = useState(false);\n  const [triangleMargin, setTriangleMargin] = useState<string>();\n\n\n  const handleEnter = useCallback(\n    (e: MouseEvent<HTMLElement> | FocusEvent<HTMLElement>) => {\n      if (!tooltipRef.current) return;\n\n      const target = e.currentTarget as HTMLElement;\n      const rect = mutableDOMRect(target.getBoundingClientRect());\n\n      const offsetRect = target.offsetParent?.getBoundingClientRect();\n      if (offsetRect) {\n        rect.top -= offsetRect.top;\n        rect.bottom -= offsetRect.top;\n        rect.left -= offsetRect.left;\n        rect.right -= offsetRect.left;\n      }\n\n      const tooltipRect = tooltipRef.current.getBoundingClientRect();\n\n      if (rect.right + tooltipRect.width > window.innerWidth) {\n\n        setAbove(true);\n        setPosition({\n          top: rect.top - rect.height / 2 - tooltipRect.height,\n          left: window.innerWidth / 2 - tooltipRect.width / 2,\n        });\n\n        setTriangleMargin(`0 ${window.innerWidth / 2 - rect.right + 5}px 0 0`);\n      } else {\n\n        setAbove(false);\n        setPosition({\n          top: rect.top + rect.height / 2 - tooltipRect.height / 2,\n          left: rect.right + 10,\n        });\n\n        setTriangleMargin(\"-5px 0 0\");\n      }\n      setShow(true);\n    },\n    [],\n  );\n\n\n  const style = useMemo(\n    () => ({\n      opacity: show ? 1 : 0,\n      top: position.top,\n      left: position.left,\n      maxWidth,\n      fontSize,\n    }),\n    [show, position, maxWidth, fontSize],\n  );\n\n\n  const childrenWithProps = useMemo(\n    () =>\n      Children.map(children, (child) => {\n        if (!isValidElement(child)) return child;\n\n        return cloneElement(child as React.ReactElement, {\n          onMouseEnter: handleEnter,\n          onFocus: handleEnter,\n          onMouseLeave: () => setShow(false),\n          onBlur: () => setShow(false),\n          \"aria-describedby\": id,\n        });\n      }),\n    [children, handleEnter, id],\n  );\n\n  return (\n    <>\n      {childrenWithProps}\n      <div\n        className=\"pointer-events-none fixed z-10 w-max rounded-lg bg-black/50 p-2 shadow-lg backdrop-blur transition-opacity\"\n        ref={tooltipRef}\n        style={style}\n        id={id}\n        role=\"tooltip\"\n      >\n        <div\n          className={classes(\n            \"absolute border-[5px] border-solid border-transparent\",\n            above\n              ? \"right-1/2 top-full border-t-black/50\"\n              : \"right-full top-1/2 border-r-black/50\",\n          )}\n          style={{ margin: triangleMargin }}\n        />\n        {text}\n      </div>\n    </>\n  );\n};\n\nexport default Tooltip;\n\n'extension/src/pages/overlay/components/overlay/Overlay.tsx'\n:import {\n  useEffect,\n  useRef,\n  useCallback,\n  useState,\n  useMemo,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\nimport Welcome from \"../../../../components/Welcome\";\nimport IconWelcome from \"../../../../components/icons/IconWelcome\";\nimport IconAmbassadors from \"../../../../components/icons/IconAmbassadors\";\nimport IconSettings from \"../../../../components/icons/IconSettings\";\n\nimport {\n  isAmbassadorKey,\n  type AmbassadorKey,\n} from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\nimport { visibleUnderCursor } from \"../../../../utils/dom\";\n\nimport useChatCommand from \"../../../../hooks/useChatCommand\";\n\nimport useSettings from \"../../hooks/useSettings\";\nimport useSleeping from \"../../hooks/useSleeping\";\n\nimport AmbassadorsOverlay from \"./Ambassadors\";\nimport SettingsOverlay from \"./Settings\";\n\nimport Buttons from \"../Buttons\";\n\n\nconst commandTimeout = 10_000;\n\nconst overlayOptions = [\n  {\n    key: \"welcome\",\n    type: \"primary\",\n    icon: IconWelcome,\n    title: \"Welcome to Alveus\",\n    component: (props: OverlayOptionProps) => (\n      <Welcome\n        className={classes(\"absolute left-0 top-0 mx-4 my-6\", props.className)}\n      />\n    ),\n  },\n  {\n    key: \"ambassadors\",\n    type: \"primary\",\n    icon: IconAmbassadors,\n    title: \"Explore our Ambassadors\",\n    component: AmbassadorsOverlay,\n  },\n  {\n    key: \"settings\",\n    type: \"secondary\",\n    icon: IconSettings,\n    title: \"Extension Settings\",\n    component: SettingsOverlay,\n  },\n] as const;\n\nexport const isValidOverlayKey = (key: string) =>\n  key === \"\" || overlayOptions.some((option) => option.key === key);\n\nexport type OverlayKey = (typeof overlayOptions)[number][\"key\"] | \"\";\n\ntype ActiveAmbassadorState = {\n  key?: AmbassadorKey;\n  isCommand?: boolean;\n};\n\nexport interface OverlayOptionProps {\n  context: {\n    activeAmbassador: ActiveAmbassadorState;\n    setActiveAmbassador: Dispatch<SetStateAction<ActiveAmbassadorState>>;\n  };\n  className?: string;\n}\n\nconst hiddenClass =\n  \"invisible opacity-0 -translate-x-10 motion-reduce:translate-x-0\";\n\nexport default function Overlay() {\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n  const [activeAmbassador, setActiveAmbassador] =\n    useState<ActiveAmbassadorState>({});\n  const [visibleOption, setVisibleOption] = useState<OverlayKey>(\n    settings.openedMenu.value,\n  );\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const awakingRef = useRef(false);\n\n\n  useEffect(() => {\n    settings.openedMenu.change(visibleOption);\n  }, [visibleOption]);\n\n\n  useEffect(() => {\n    setVisibleOption(settings.openedMenu.value);\n  }, [settings.openedMenu.value]);\n\n\n  useChatCommand(\n    useCallback(\n      (command: string) => {\n        if (!settings.disableChatPopup.value) {\n          if (isAmbassadorKey(command))\n            setActiveAmbassador({ key: command, isCommand: true });\n          else if (command !== \"welcome\") return;\n\n\n          setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n\n          if (timeoutRef.current) clearTimeout(timeoutRef.current);\n          timeoutRef.current = setTimeout(() => {\n            setVisibleOption(\"\");\n            setActiveAmbassador({});\n          }, commandTimeout);\n\n\n          awakingRef.current = true;\n          wake(commandTimeout);\n        }\n      },\n      [settings.disableChatPopup.value, wake],\n    ),\n  );\n\n\n  useEffect(\n    () => () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    },\n    [],\n  );\n\n\n\n  useEffect(() => {\n    const callback = () => {\n      if (awakingRef.current) awakingRef.current = false;\n      else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    };\n    addSleepListener(\"wake\", callback);\n    return () => removeSleepListener(\"wake\", callback);\n  }, [addSleepListener, removeSleepListener]);\n\n\n  const bodyClick = useCallback((e: MouseEvent) => {\n    if (!visibleUnderCursor(e)) {\n      setVisibleOption(\"\");\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"click\", bodyClick, true);\n    return () => document.body.removeEventListener(\"click\", bodyClick, true);\n  }, [bodyClick]);\n\n\n  const bodyDblClick = useCallback((e: MouseEvent) => {\n    if (visibleUnderCursor(e)) {\n      e.stopPropagation();\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n    return () =>\n      document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n  }, [bodyDblClick]);\n\n\n  const context = useMemo<OverlayOptionProps[\"context\"]>(\n    () => ({\n      activeAmbassador,\n      setActiveAmbassador,\n    }),\n    [activeAmbassador],\n  );\n\n  return (\n    <div\n      className={classes(\n        \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          ) &&\n          hiddenClass,\n      )}\n    >\n      <Buttons\n        options={overlayOptions}\n        onClick={setVisibleOption}\n        active={visibleOption}\n      />\n      <div className=\"relative h-full w-full\">\n        {overlayOptions.map((option) => (\n          <option.component\n            key={option.key}\n            context={context}\n            className={classes(\n              \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n              visibleOption !== option.key && hiddenClass,\n            )}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n'extension/src/pages/overlay/components/overlay/Ambassadors.tsx'\n:import { useRef, useEffect, useCallback, type MouseEvent } from \"react\";\nimport { Transition } from \"@headlessui/react\";\n\nimport AmbassadorCard from \"../../../../components/AmbassadorCard\";\nimport AmbassadorButton from \"../../../../components/AmbassadorButton\";\n\nimport { useAmbassadors } from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\n\nimport type { OverlayOptionProps } from \"./Overlay\";\n\nimport IconChevron from \"../../../../components/icons/IconChevron\";\n\nconst arrowClass =\n  \"absolute border-0 cursor-pointer text-alveus-green w-full h-[var(--list-fade-padding)] z-20 transition-opacity group pt-[var(--twitch-vertical-padding)] pb-4 box-content\";\nconst arrowSvgClass =\n  \"mx-auto drop-shadow-lg overflow-visible transition-transform group-hover:scale-125 group-focus:scale-125\";\nconst arrowPathClass =\n  \"[&_path]:stroke-alveus-tan [&_path]:stroke-[0.25rem] [&_path]:[paint-order:stroke] [&_path]:transition-[stroke] [&_path]:group-hover:stroke-highlight [&_path]:group-hover:stroke-[0.375rem] [&_path]:group-focus:stroke-highlight [&_path]:group-focus:stroke-[0.375rem]\";\nconst hiddenClass = \"opacity-0 pointer-events-none\";\n\nexport default function Ambassadors(props: OverlayOptionProps) {\n  const {\n    context: { activeAmbassador, setActiveAmbassador },\n    className,\n  } = props;\n\n  const ambassadors = useAmbassadors();\n\n  const upArrowRef = useRef<HTMLButtonElement>(null);\n  const ambassadorList = useRef<HTMLDivElement>(null);\n  const downArrowRef = useRef<HTMLButtonElement>(null);\n\n\n  useEffect(() => {\n    if (\n      !ambassadorList.current ||\n      !activeAmbassador.key ||\n      !activeAmbassador.isCommand\n    )\n      return;\n\n    const offset = 200;\n    const anchorElement = ambassadorList.current.querySelector(\n      `#${activeAmbassador.key}`,\n    );\n    if (anchorElement instanceof HTMLButtonElement)\n      ambassadorList.current.scrollTo({\n        top: Math.max(0, anchorElement.offsetTop - offset),\n        behavior: \"smooth\",\n      });\n  }, [activeAmbassador]);\n\n\n  const ambassadorListScroll = useCallback(\n    (event: MouseEvent, direction: number) => {\n      if (ambassadorList.current) {\n        event.stopPropagation();\n\n        ambassadorList.current.scroll({\n          top: ambassadorList.current.scrollTop - direction,\n          left: 0,\n          behavior: \"smooth\",\n        });\n      }\n    },\n    [],\n  );\n\n\n  const handleArrowVisibility = useCallback(() => {\n    if (ambassadorList.current) {\n      if (ambassadorList.current.scrollTop === 0)\n        upArrowRef.current?.classList.add(...hiddenClass.split(\" \"));\n      else if (\n        ambassadorList.current.scrollTop +\n          ambassadorList.current.clientHeight ===\n        ambassadorList.current.scrollHeight\n      )\n        downArrowRef.current?.classList.add(...hiddenClass.split(\" \"));\n      else {\n        upArrowRef.current?.classList.remove(...hiddenClass.split(\" \"));\n        downArrowRef.current?.classList.remove(...hiddenClass.split(\" \"));\n      }\n    }\n  }, []);\n\n\n\n  useEffect(() => {\n    handleArrowVisibility();\n  }, [handleArrowVisibility]);\n\n  return (\n    <div\n      className={classes(\n        \"grid-cols-2-auto absolute left-0 top-0 z-0 grid h-full grid-rows-1\",\n        className,\n      )}\n    >\n      <div className=\"relative z-10 flex flex-col items-center\">\n        <div\n          ref={ambassadorList}\n          className=\"list-fade scrollbar-none -my-[var(--twitch-vertical-padding)] flex w-40 flex-col items-center gap-4 overflow-scroll px-4 py-[calc(var(--twitch-vertical-padding)+var(--list-fade-padding))]\"\n          onScroll={handleArrowVisibility}\n        >\n          {ambassadors.map(([key]) => (\n            <AmbassadorButton\n              key={key}\n              ambassador={key}\n              onClick={() => {\n                setActiveAmbassador((prev) =>\n                  prev.key === key ? {} : { key },\n                );\n              }}\n              className={classes(\n                \"w-full\",\n                activeAmbassador.key === key && \"outline-highlight outline\",\n              )}\n            />\n          ))}\n        </div>\n\n        <button\n          ref={upArrowRef}\n          className={classes(\n            arrowClass,\n            \"-top-[var(--twitch-vertical-padding)]\",\n            hiddenClass,\n          )}\n          onClick={(e) => ambassadorListScroll(e, 250)}\n          title=\"Scroll up\"\n          type=\"button\"\n          data-transparent-clicks\n        >\n          <IconChevron className={classes(arrowSvgClass, arrowPathClass)} />\n        </button>\n\n        <button\n          ref={downArrowRef}\n          className={classes(\n            arrowClass,\n            \"-bottom-[var(--twitch-vertical-padding)] rotate-180\",\n          )}\n          onClick={(e) => ambassadorListScroll(e, -250)}\n          title=\"Scroll down\"\n          type=\"button\"\n          data-transparent-clicks\n        >\n          <IconChevron className={classes(arrowSvgClass, arrowPathClass)} />\n        </button>\n      </div>\n\n      {ambassadors.map(([key]) => (\n        <Transition show={activeAmbassador.key === key} key={key}>\n          <AmbassadorCard\n            key={key}\n            ambassador={key}\n            onClose={() => setActiveAmbassador({})}\n            className=\"z-0 col-start-2 row-start-1 origin-[center_left] self-center transition-[opacity,transform] will-change-[opacity,transform] data-[closed]:-translate-x-10 data-[closed]:opacity-0 data-[closed]:motion-reduce:translate-x-0\"\n          />\n        </Transition>\n      ))}\n    </div>\n  );\n}\n\n'extension/src/components/AmbassadorCard.tsx'\n:import { forwardRef, useCallback, useEffect, useRef } from \"react\";\nimport type { CreateTypes } from \"canvas-confetti\";\nimport Confetti from \"react-canvas-confetti\";\n\nimport { calculateAge, formatDate, isBirthday } from \"../utils/dateManager\";\nimport {\n  getClassification,\n  getAmbassadorImages,\n  getIUCNStatus,\n  useAmbassador,\n  type AmbassadorKey,\n  type AmbassadorImage,\n} from \"../hooks/useAmbassadors\";\nimport { camelToKebab } from \"../utils/helpers\";\nimport { classes } from \"../utils/classes\";\n\nimport IconInfo from \"./icons/IconInfo\";\n\nimport Tooltip from \"./Tooltip\";\n\nimport moderatorBadge from \"../assets/mod.svg\";\nimport partyHat from \"../assets/party.svg\";\n\nconst headingClass = \"text-base text-alveus-green-400\";\n\nconst offsetPosition = (position: AmbassadorImage[\"position\"]) => {\n  const [x, y] = (position || \"50% 50%\").split(\" \");\n  return `${x} min(calc(${y} + 1.5rem), 0%)`;\n};\n\nexport interface AmbassadorCardProps {\n  ambassador: AmbassadorKey;\n  onClose?: () => void;\n  className?: string;\n}\n\nexport default forwardRef(function AmbassadorCard(\n  props: AmbassadorCardProps,\n  ref,\n) {\n  const { ambassador: ambassadorKey, onClose, className, ...extras } = props;\n  const ambassador = useAmbassador(ambassadorKey);\n  const images = getAmbassadorImages(ambassadorKey);\n\n  const mod =\n    window?.Twitch?.ext?.viewer?.role === \"broadcaster\" ||\n    window?.Twitch?.ext?.viewer?.role === \"moderator\";\n\n  const birthday = ambassador.birth && isBirthday(ambassador.birth);\n  const age = ambassador.birth ? calculateAge(ambassador.birth) : \"Unknown\";\n  const birth = ambassador.birth ? formatDate(ambassador.birth) : \"Unknown\";\n\n  const internalRef = useRef<HTMLDivElement>();\n  const callbackRef = useCallback(\n    (node: HTMLDivElement | null) => {\n      if (ref) {\n        if (typeof ref === \"function\") ref(node);\n        else ref.current = node;\n      }\n      internalRef.current = node ?? undefined;\n    },\n    [ref],\n  );\n\n  const timeout = useRef<NodeJS.Timeout>();\n  const confettiInit = useCallback(\n    ({ confetti }: { confetti: CreateTypes }) => {\n      const node = internalRef.current;\n      if (\n        !node ||\n        window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches\n      )\n        return;\n\n      timeout.current = setTimeout(() => {\n        const rect = node.getBoundingClientRect();\n        const origin = {\n          x: (rect.x + rect.width / 2) / window.innerWidth,\n          y: (rect.y + rect.height / 2) / window.innerHeight,\n        };\n\n        confetti({\n          spread: 26,\n          startVelocity: 55,\n          origin,\n          particleCount: Math.floor(200 * 0.25),\n        });\n        confetti({\n          spread: 60,\n          origin,\n          particleCount: Math.floor(200 * 0.2),\n        });\n        confetti({\n          spread: 100,\n          decay: 0.91,\n          scalar: 0.8,\n          origin,\n          particleCount: Math.floor(200 * 0.35),\n        });\n        confetti({\n          spread: 120,\n          startVelocity: 25,\n          decay: 0.92,\n          scalar: 1.2,\n          origin,\n          particleCount: Math.floor(200 * 0.1),\n        });\n        confetti({\n          spread: 120,\n          startVelocity: 45,\n          origin,\n          particleCount: Math.floor(200 * 0.1),\n        });\n      }, 500);\n    },\n    [origin],\n  );\n  useEffect(() => () => clearTimeout(timeout.current), []);\n\n  return (\n    <>\n      {birthday && <Confetti onInit={confettiInit} />}\n      <div\n        className={classes(\n          \"bg-alveus-green-900 relative flex max-h-full min-h-[min(28rem,100%)] w-80 max-w-full flex-col justify-start rounded-lg align-top text-xs shadow-xl\",\n          className,\n        )}\n        ref={callbackRef}\n        {...extras}\n      >\n        {birthday && (\n          <img\n            src={partyHat}\n            alt=\"\"\n            className=\"absolute left-1/2 top-0 z-10 h-auto w-16 -translate-x-1/2 -translate-y-[85%]\"\n          />\n        )}\n        <div className=\"relative w-full overflow-hidden rounded-t-lg\">\n          <img\n            className=\"peer aspect-[2.2] w-full object-cover sm:aspect-[1.8]\"\n            src={images[0].src}\n            alt={images[0].alt}\n            style={{ objectPosition: offsetPosition(images[0].position) }}\n          />\n\n          <div className=\"peer-hover:backdrop-blur-xs bg-alveus-green-900/50 absolute inset-x-0 top-0 flex h-9 w-full backdrop-blur-sm transition-[opacity,backdrop-filter] peer-hover:opacity-10\">\n            {props.onClose && (\n              <button\n                className=\"hover:text-highlight focus:text-highlight absolute right-1 top-1/2 block w-8 -translate-y-1/2 cursor-pointer text-center text-2xl transition-colors\"\n                onClick={onClose}\n                type=\"button\"\n                aria-label=\"Close\"\n              >\n                &times;\n              </button>\n            )}\n\n            <h2\n              className=\"w-full shrink-0 self-center overflow-hidden overflow-ellipsis text-nowrap py-1 pl-2 pr-10 text-xl\"\n              title={ambassador.name}\n            >\n              {ambassador.name}\n            </h2>\n          </div>\n        </div>\n\n        <div className=\"scrollbar-thin scrollbar-track-alveus-green-900 scrollbar-thumb-alveus-green mb-2 flex flex-auto flex-col gap-1 overflow-y-auto p-2\">\n          {mod && (\n            <div className=\"flex items-center gap-2\">\n              <img\n                className=\"h-6 w-6 object-cover\"\n                src={moderatorBadge}\n                alt=\"Moderator badge\"\n              />\n              <p>\n                Show this card to everyone by using{\" \"}\n                <code>!{ambassador.commands[0]}</code> in chat.\n              </p>\n            </div>\n          )}\n\n          <div>\n            <h3 className={headingClass}>Species</h3>\n            <p>{ambassador.species}</p>\n            <p>\n              <i>{ambassador.scientific}</i>{\" \"}\n              <span className=\"text-alveus-green-200\">\n                ({getClassification(ambassador.class)})\n              </span>\n            </p>\n          </div>\n\n          <div className=\"flex flex-wrap gap-x-6 gap-y-1 [&>*]:mr-auto\">\n            <div>\n              <h3 className={headingClass}>Sex</h3>\n              <p>{ambassador.sex || \"Unknown\"}</p>\n            </div>\n            <div>\n              <h3 className={headingClass}>Age</h3>\n              <p>\n                {age[0] === \"~\" && (\n                  <span className=\"text-base leading-none\" title=\"Approx.\">\n                    ~\n                  </span>\n                )}\n                {age.slice(age[0] === \"~\" ? 1 : 0)}\n              </p>\n            </div>\n            <div>\n              <h3 className={headingClass}>Birthday</h3>\n              <p>\n                {birth[0] === \"~\" && (\n                  <span className=\"text-base leading-none\" title=\"Approx.\">\n                    ~\n                  </span>\n                )}\n                {birth.slice(birth[0] === \"~\" ? 1 : 0)}\n              </p>\n            </div>\n          </div>\n\n          <div>\n            <h3 className={headingClass}>Story</h3>\n            <p>{ambassador.story}</p>\n          </div>\n\n          <div>\n            <h3 className={headingClass}>Conservation Mission</h3>\n            <p>{ambassador.mission}</p>\n          </div>\n\n          <div>\n            <Tooltip\n              text=\"An objective assessment system for classifying the status of plants, animals, and other organisms threatened with extinction.\"\n              maxWidth=\"18rem\"\n              fontSize=\"0.9rem\"\n            >\n              <div className=\"inline-flex items-center gap-2\">\n                <h3 className={headingClass}>Conservation Status</h3>\n                <IconInfo\n                  size={20}\n                  className=\"text-alveus-green-400 outline-highlight rounded-full transition-[outline] hover:outline\"\n                />\n              </div>\n            </Tooltip>\n            <p>IUCN: {getIUCNStatus(ambassador.iucn.status)}</p>\n          </div>\n\n          <div>\n            <h3 className={headingClass}>Native To</h3>\n            <p>{ambassador.native.text}</p>\n          </div>\n\n          <div>\n            <h3 className={headingClass}>Arrived at Alveus</h3>\n            <p>\n              {ambassador.arrival\n                ? formatDate(ambassador.arrival, false)\n                : \"Unknown\"}\n            </p>\n          </div>\n\n          <div className=\"mt-3 italic\">\n            <p>\n              Learn more about {ambassador.name} on the{\" \"}\n              <a\n                href={`https:\n                  ambassadorKey,\n                )}`}\n                rel=\"noreferrer\"\n                target=\"_blank\"\n                className=\"hover:text-highlight focus:text-highlight text-alveus-green-200 text-nowrap underline transition-colors\"\n              >\n                Alveus Sanctuary website\n              </a>\n              .\n            </p>\n          </div>\n        </div>\n      </div>\n    </>\n  );\n});\n",
        "gt": [
            "'extension/src/components/Tooltip.tsx'",
            "'extension/src/components/AmbassadorCard.tsx'",
            "'extension/src/pages/overlay/components/overlay/Ambassadors.tsx'",
            "'extension/src/pages/overlay/components/overlay/Overlay.tsx'",
            "'extension/src/pages/overlay/components/overlay/Settings.tsx'"
        ]
    }
]