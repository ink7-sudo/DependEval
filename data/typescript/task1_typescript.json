[
    {
        "repo": "108-autosave-reactive-froms-firestore",
        "content": "'108-autosave-reactive-froms-firestore/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { AngularFireModule } from 'angularfire2';\nimport { AngularFirestoreModule } from 'angularfire2/firestore';\nimport { AngularFireStorageModule } from 'angularfire2/storage';\nimport { AngularFireAuthModule } from 'angularfire2/auth';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport {\n  MatIconModule,\n  MatInputModule,\n  MatButtonModule,\n  MatSelectModule,\n  MatGridListModule\n} from '@angular/material';\nimport { FormDemoComponent } from './form-demo/form-demo.component';\nimport { FireFormDirective } from './fire-form.directive';\n\n// Add your project credentials\nconst firebase = {\n  apiKey: '<your-key>',\n  authDomain: '<your-project-authdomain>',\n  databaseURL: '<your-database-URL>',\n  projectId: '<your-project-id>',\n  storageBucket: '<your-storage-bucket>',\n  messagingSenderId: '<your-messaging-sender-id>'\n};\n\n@NgModule({\n  declarations: [AppComponent, FormDemoComponent, FireFormDirective],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    AngularFireModule.initializeApp(firebase),\n    AngularFirestoreModule,\n    AngularFireAuthModule,\n    AngularFireStorageModule,\n    BrowserAnimationsModule,\n    ReactiveFormsModule,\n    MatIconModule,\n    MatInputModule,\n    MatButtonModule,\n    MatSelectModule,\n    MatGridListModule\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n\n'108-autosave-reactive-froms-firestore/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));\n\n",
        "called_code_segment": "@NgModule({\n  declarations: [AppComponent, FormDemoComponent, FireFormDirective],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    AngularFireModule.initializeApp(firebase),\n    AngularFirestoreModule,\n    AngularFireAuthModule,\n    AngularFireStorageModule,\n    BrowserAnimationsModule,\n    ReactiveFormsModule,\n    MatIconModule,\n    MatInputModule,\n    MatButtonModule,\n    MatSelectModule,\n    MatGridListModule\n  ],\n  bootstrap: [AppComponent]\n})",
        "invoking_code_segment": "platformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));",
        "feature_description": "Add a new service to handle form submissions and integrate it with Firestore.",
        "detailed_feature_description": "Create a new service named 'FormSubmissionService' that handles the submission of forms to Firestore. Modify the AppModule to include this new service. Update the FormDemoComponent to use this service for form submissions.",
        "modified_complete_code": {
            "app.module.ts": "import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { AngularFireModule } from 'angularfire2';\nimport { AngularFirestoreModule } from 'angularfire2/firestore';\nimport { AngularFireStorageModule } from 'angularfire2/storage';\nimport { AngularFireAuthModule } from 'angularfire2/auth';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport {\n  MatIconModule,\n  MatInputModule,\n  MatButtonModule,\n  MatSelectModule,\n  MatGridListModule\n} from '@angular/material';\nimport { FormDemoComponent } from './form-demo/form-demo.component';\nimport { FireFormDirective } from './fire-form.directive';\nimport { FormSubmissionService } from './form-submission.service';\n\n// Add your project credentials\nconst firebase = {\n  apiKey: '<your-key>',\n  authDomain: '<your-project-authdomain>',\n  databaseURL: '<your-database-URL>',\n  projectId: '<your-project-id>',\n  storageBucket: '<your-storage-bucket>',\n  messagingSenderId: '<your-messaging-sender-id>'\n};\n\n@NgModule({\n  declarations: [AppComponent, FormDemoComponent, FireFormDirective],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    AngularFireModule.initializeApp(firebase),\n    AngularFirestoreModule,\n    AngularFireAuthModule,\n    AngularFireStorageModule,\n    BrowserAnimationsModule,\n    ReactiveFormsModule,\n    MatIconModule,\n    MatInputModule,\n    MatButtonModule,\n    MatSelectModule,\n    MatGridListModule\n  ],\n  providers: [FormSubmissionService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n",
            "main.ts": "import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));\n",
            "form-submission.service.ts": "import { Injectable } from '@angular/core';\nimport { AngularFirestore } from 'angularfire2/firestore';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class FormSubmissionService {\n\n  constructor(private firestore: AngularFirestore) { }\n\n  submitForm(formData: any) {\n    return this.firestore.collection('submissions').add(formData);\n  }\n}\n",
            "form-demo.component.ts": "import { Component } from '@angular/core';\nimport { FormBuilder, FormGroup } from '@angular/forms';\nimport { FormSubmissionService } from '../form-submission.service';\n\n@Component({\n  selector: 'app-form-demo',\n  templateUrl: './form-demo.component.html',\n  styleUrls: ['./form-demo.component.css']\n})\nexport class FormDemoComponent {\n\n  form: FormGroup;\n\n  constructor(private fb: FormBuilder, private formSubmissionService: FormSubmissionService) {\n    this.form = this.fb.group({\n      name: [''],\n      email: ['']\n    });\n  }\n\n  onSubmit() {\n    this.formSubmissionService.submitForm(this.form.value).then(() => {\n      console.log('Form submitted successfully');\n    }).catch(error => {\n      console.error('Error submitting form', error);\n    });\n  }\n}\n"
        }
    },
    {
        "repo": "Day59-Angular-Practice",
        "content": "'Day59-Angular-Practice/app/app.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {TaskListComponent} from './task-list.component';\n\n\n@Component({\n  selector: 'my-app',\n  directives: [NewTaskComponent, TaskListComponent],\n  template: `\n  <h1>hi</h1>\n  <task-list></task-list>\n\n  `\n})\n\nexport class AppComponent {\n\n}\n\n'Day59-Angular-Practice/app/main.ts'\n:import {bootstrap} from 'angular2/platform/browser';\nimport {AppComponent} from './app.component';\n\nbootstrap(AppComponent);\n\n",
        "called_code_segment": "@Component({\n  selector: 'task-list',\n  template: `<ul><li *ngFor=\"let task of tasks\">\n    {{task.description}}\n  </li></ul>`\n})\nexport class TaskListComponent {\n  public tasks: Task[];\n}",
        "invoking_code_segment": "@Component({\n  selector: 'my-app',\n  directives: [NewTaskComponent, TaskListComponent],\n  template: `\n  <h1>hi</h1>\n  <task-list></task-list>\n  `\n})\nexport class AppComponent {\n}",
        "feature_description": "Add a feature to display the task description in uppercase in the TaskListComponent.",
        "detailed_feature_description": "Modify the TaskListComponent to display the task description in uppercase by using the `capitalize` function from the `Task` class. Update the template to call this function.",
        "modified_complete_code": {
            "app/app.component.ts": "import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {TaskListComponent} from './task-list.component';\n\n@Component({\n  selector: 'my-app',\n  directives: [NewTaskComponent, TaskListComponent],\n  template: `\n  <h1>hi</h1>\n  <task-list></task-list>\n  `\n})\nexport class AppComponent {\n}",
            "app/task-list.component.ts": "import {Component} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\n\n@Component({\n  selector: 'task-list',\n  template: `<ul><li *ngFor=\"let task of tasks\">\n    {{capitalize(task.description)}}\n  </li></ul>`\n})\nexport class TaskListComponent {\n  public tasks: Task[];\n}"
        }
    },
    {
        "repo": "TodoList-React-TypeScript",
        "content": "'TodoList-React-TypeScript/src/reportWebVitals.ts'\n:import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n\n'TodoList-React-TypeScript/src/index.tsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n\n",
        "called_code_segment": "const reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};",
        "invoking_code_segment": "reportWebVitals();",
        "feature_description": "Add an optional parameter to reportWebVitals to allow specifying a custom analytics endpoint.",
        "detailed_feature_description": "Modify the reportWebVitals function to accept an optional parameter 'endpoint' which is a string representing the URL of a custom analytics endpoint. If provided, the function will send the web vitals data to this endpoint instead of the default behavior.",
        "modified_complete_code": {
            "reportWebVitals.ts": "import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler, endpoint?: string) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n  if (endpoint) {\n    // Logic to send data to the custom endpoint\n    console.log(`Sending web vitals data to custom endpoint: ${endpoint}`);\n  }\n};\n\nexport default reportWebVitals;",
            "index.tsx": "import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals(console.log, 'https://custom-analytics.com/endpoint');\n"
        }
    },
    {
        "repo": "amifauzi.com-open",
        "content": "'amifauzi.com-open/app/components/Gallery/Gallery.tsx'\n:/* \nAll of the code in this component are copied and modified from:\nhttps://github.com/neptunian/react-photo-gallery\n*/\n\nimport { useLayoutEffect, useRef, useState } from \"react\";\nimport { computeRowLayout } from \"./Utils/compute-layout\";\nimport { findIdealNodeSearch } from \"./Utils/findIdealNodeSearch\";\nimport { PhotoProvider, PhotoView } from \"react-photo-view\";\n\nexport interface IPhoto {\n  src: string;\n  width: number;\n  height: number;\n  alt: string;\n}\n\ninterface GalleryProps {\n  photos: IPhoto[];\n}\n\nconst Gallery = ({ photos }: GalleryProps) => {\n  const [containerWidth, setContainerWidth] = useState(0);\n  const galleryEl = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    let animationFrameID: number | null = null;\n    const observer = new ResizeObserver((entries) => {\n      // only do something if width changes\n      const newWidth = entries[0].contentRect.width;\n      if (containerWidth !== newWidth) {\n        // put in an animation frame to stop \"benign errors\" from\n        // ResizObserver https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n        animationFrameID = window.requestAnimationFrame(() => {\n          setContainerWidth(Math.floor(newWidth));\n        });\n      }\n    });\n\n    if (galleryEl.current) {\n      observer.observe(galleryEl.current);\n    }\n\n    return () => {\n      observer.disconnect();\n      if (animationFrameID) {\n        window.cancelAnimationFrame(animationFrameID);\n      }\n    };\n  });\n\n  if (!containerWidth) return <div ref={galleryEl}>&nbsp;</div>;\n\n  const width = containerWidth - 1;\n  const targetRowHeight = 300;\n  let limitNodeSearch = 2;\n  if (containerWidth >= 450) {\n    limitNodeSearch = findIdealNodeSearch({ containerWidth, targetRowHeight });\n  }\n  const thumbs: IPhoto[] = computeRowLayout({\n    containerWidth: width,\n    limitNodeSearch,\n    targetRowHeight,\n    margin: 2,\n    photos,\n  });\n\n  return (\n    <PhotoProvider>\n      <div ref={galleryEl} className=\"flex flex-wrap\">\n        {thumbs.map((thumb, index) => {\n          return (\n            <PhotoView key={index} src={thumb.src}>\n              <img\n                key={index}\n                src={thumb.src}\n                alt={thumb.alt}\n                width={thumb.width}\n                height={thumb.height}\n                className=\"m-0.5 cursor-pointer\"\n              />\n            </PhotoView>\n          );\n        })}\n      </div>\n    </PhotoProvider>\n  );\n};\n\nexport default Gallery;\n\n'amifauzi.com-open/app/components/Gallery/Utils/compute-layout.ts'\n:import type { IPhoto } from \"../Gallery\";\nimport { findShortestPath } from \"./dijkstra\";\nimport type { TGraphFunc, TNode } from \"./dijkstra\";\nimport { round } from \"./round\";\n\n// return two decimal places rounded number\nexport const ratio = ({ width, height }: IPhoto) => round(width / height, 2);\n\n// compute sizes by creating a graph with rows as edges and photo to break on as nodes\n// to calculate the single best layout using Dijkstra's findShortestPat\n\n// get the height for a set of photos in a potential row\nconst getCommonHeight = (\n  row: IPhoto[],\n  containerWidth: number,\n  margin: number\n) => {\n  const rowWidth = containerWidth - row.length * (margin * 2);\n  const totalAspectRatio = row.reduce((acc, photo) => acc + ratio(photo), 0);\n  return rowWidth / totalAspectRatio;\n};\n\n// calculate the cost of breaking at this node (edge weight)\nconst cost = (\n  photos: IPhoto[],\n  i: number,\n  j: number,\n  width: number,\n  targetHeight: number,\n  margin: number\n) => {\n  const row = photos.slice(i, j);\n  const commonHeight = getCommonHeight(row, width, margin);\n  return Math.pow(Math.abs(commonHeight - targetHeight), 2);\n};\n\n// return function that gets the neighboring nodes of node and returns costs\nconst makeGetNeighbors =\n  (\n    targetHeight: number,\n    containerWidth: number,\n    photos: IPhoto[],\n    limitNodeSearch: number,\n    margin: number\n  ): TGraphFunc =>\n  (start) => {\n    const results: TNode = {};\n    start = +start;\n    results[+start] = 0;\n    for (let i = start + 1; i < photos.length + 1; ++i) {\n      if (i - start > limitNodeSearch) break;\n      results[i] = cost(photos, start, i, containerWidth, targetHeight, margin);\n    }\n    return results;\n  };\n\ninterface IComputeRowLayiutArg {\n  containerWidth: number;\n  limitNodeSearch: number;\n  targetRowHeight: number;\n  margin: number;\n  photos: IPhoto[];\n}\n\nexport const computeRowLayout = ({\n  containerWidth,\n  limitNodeSearch,\n  targetRowHeight,\n  margin,\n  photos,\n}: IComputeRowLayiutArg) => {\n  const getNeighbors = makeGetNeighbors(\n    targetRowHeight,\n    containerWidth,\n    photos,\n    limitNodeSearch,\n    margin\n  );\n  let path = findShortestPath(getNeighbors, 0, photos.length);\n  path = path.map((node) => +node);\n  for (let i = 1; i < path.length; ++i) {\n    const row = photos.slice(path[i - 1], path[i]);\n    const height = getCommonHeight(row, containerWidth, margin);\n    for (let j = path[i - 1]; j < path[i]; ++j) {\n      photos[j].width = round(height * ratio(photos[j]), 1);\n      photos[j].height = height;\n    }\n  }\n  return photos;\n};\n\n",
        "called_code_segment": "const computeRowLayout = ({ containerWidth, limitNodeSearch, targetRowHeight, margin, photos, }: IComputeRowLayiutArg) => {\n  const getNeighbors = makeGetNeighbors(\n    targetRowHeight,\n    containerWidth,\n    photos,\n    limitNodeSearch,\n    margin\n  );\n  let path = findShortestPath(getNeighbors, 0, photos.length);\n  path = path.map((node) => +node);\n  for (let i = 1; i < path.length; ++i) {\n    const row = photos.slice(path[i - 1], path[i]);\n    const height = getCommonHeight(row, containerWidth, margin);\n    for (let j = path[i - 1]; j < path[i]; ++j) {\n      photos[j].width = round(height * ratio(photos[j]), 1);\n      photos[j].height = height;\n    }\n  }\n  return photos;\n};",
        "invoking_code_segment": "const thumbs: IPhoto[] = computeRowLayout({\n  containerWidth: width,\n  limitNodeSearch,\n  targetRowHeight,\n  margin: 2,\n  photos,\n});",
        "feature_description": "Add a feature to allow custom margins for each photo in the gallery.",
        "detailed_feature_description": "Modify the `computeRowLayout` function to accept an array of custom margins for each photo. Update the `Gallery` component to pass these custom margins if provided.",
        "modified_complete_code": {
            "Gallery.tsx": "/*  \nAll of the code in this component are copied and modified from: \nhttps://github.com/neptunian/react-photo-gallery \n*/ \n\nimport { useLayoutEffect, useRef, useState } from \"react\"; \nimport { computeRowLayout } from \"./Utils/compute-layout\"; \nimport { findIdealNodeSearch } from \"./Utils/findIdealNodeSearch\"; \nimport { PhotoProvider, PhotoView } from \"react-photo-view\"; \n\nexport interface IPhoto { \n  src: string; \n  width: number; \n  height: number; \n  alt: string; \n} \n\ninterface GalleryProps { \n  photos: IPhoto[]; \n  customMargins?: number[]; \n} \n\nconst Gallery = ({ photos, customMargins }: GalleryProps) => { \n  const [containerWidth, setContainerWidth] = useState(0); \n  const galleryEl = useRef<HTMLDivElement | null>(null); \n\n  useLayoutEffect(() => { \n    let animationFrameID: number | null = null; \n    const observer = new ResizeObserver((entries) => { \n      // only do something if width changes \n      const newWidth = entries[0].contentRect.width; \n      if (containerWidth !== newWidth) { \n        // put in an animation frame to stop \"benign errors\" from \n        // ResizObserver https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded \n        animationFrameID = window.requestAnimationFrame(() => { \n          setContainerWidth(Math.floor(newWidth)); \n        }); \n      } \n    }); \n\n    if (galleryEl.current) { \n      observer.observe(galleryEl.current); \n    } \n\n    return () => { \n      observer.disconnect(); \n      if (animationFrameID) { \n        window.cancelAnimationFrame(animationFrameID); \n      } \n    }; \n  }); \n\n  if (!containerWidth) return <div ref={galleryEl}>&nbsp;</div>; \n\n  const width = containerWidth - 1; \n  const targetRowHeight = 300; \n  let limitNodeSearch = 2; \n  if (containerWidth >= 450) { \n    limitNodeSearch = findIdealNodeSearch({ containerWidth, targetRowHeight }); \n  } \n  const thumbs: IPhoto[] = computeRowLayout({ \n    containerWidth: width, \n    limitNodeSearch, \n    targetRowHeight, \n    margin: customMargins || 2, \n    photos, \n  }); \n\n  return ( \n    <PhotoProvider> \n      <div ref={galleryEl} className=\"flex flex-wrap\"> \n        {thumbs.map((thumb, index) => { \n          return ( \n            <PhotoView key={index} src={thumb.src}> \n              <img \n                key={index} \n                src={thumb.src} \n                alt={thumb.alt} \n                width={thumb.width} \n                height={thumb.height} \n                className=\"m-0.5 cursor-pointer\" \n              /> \n            </PhotoView> \n          ); \n        })} \n      </div> \n    </PhotoProvider> \n  ); \n}; \n\nexport default Gallery;",
            "compute-layout.ts": "import type { IPhoto } from \"../Gallery\"; \nimport { findShortestPath } from \"./dijkstra\"; \nimport type { TGraphFunc, TNode } from \"./dijkstra\"; \nimport { round } from \"./round\"; \n\n// return two decimal places rounded number \nexport const ratio = ({ width, height }: IPhoto) => round(width / height, 2); \n\n// compute sizes by creating a graph with rows as edges and photo to break on as nodes \n// to calculate the single best layout using Dijkstra's findShortestPat \n\n// get the height for a set of photos in a potential row \nconst getCommonHeight = ( \n  row: IPhoto[], \n  containerWidth: number, \n  margin: number | number[] \n) => { \n  const rowWidth = containerWidth - row.reduce((acc, photo, index) => acc + (typeof margin === 'number' ? margin : margin[index]) * 2, 0); \n  const totalAspectRatio = row.reduce((acc, photo) => acc + ratio(photo), 0); \n  return rowWidth / totalAspectRatio; \n}; \n\n// calculate the cost of breaking at this node (edge weight) \nconst cost = ( \n  photos: IPhoto[], \n  i: number, \n  j: number, \n  width: number, \n  targetHeight: number, \n  margin: number | number[] \n) => { \n  const row = photos.slice(i, j); \n  const commonHeight = getCommonHeight(row, width, margin); \n  return Math.pow(Math.abs(commonHeight - targetHeight), 2); \n}; \n\n// return function that gets the neighboring nodes of node and returns costs \nconst makeGetNeighbors = \n  ( \n    targetHeight: number, \n    containerWidth: number, \n    photos: IPhoto[], \n    limitNodeSearch: number, \n    margin: number | number[] \n  ): TGraphFunc => \n  (start) => { \n    const results: TNode = {}; \n    start = +start; \n    results[+start] = 0; \n    for (let i = start + 1; i < photos.length + 1; ++i) { \n      if (i - start > limitNodeSearch) break; \n      results[i] = cost(photos, start, i, containerWidth, targetHeight, margin); \n    } \n    return results; \n  }; \n\ninterface IComputeRowLayiutArg { \n  containerWidth: number; \n  limitNodeSearch: number; \n  targetRowHeight: number; \n  margin: number | number[]; \n  photos: IPhoto[]; \n} \n\nexport const computeRowLayout = ({ \n  containerWidth, \n  limitNodeSearch, \n  targetRowHeight, \n  margin, \n  photos, \n}: IComputeRowLayiutArg) => { \n  const getNeighbors = makeGetNeighbors( \n    targetRowHeight, \n    containerWidth, \n    photos, \n    limitNodeSearch, \n    margin \n  ); \n  let path = findShortestPath(getNeighbors, 0, photos.length); \n  path = path.map((node) => +node); \n  for (let i = 1; i < path.length; ++i) { \n    const row = photos.slice(path[i - 1], path[i]); \n    const height = getCommonHeight(row, containerWidth, margin); \n    for (let j = path[i - 1]; j < path[i]; ++j) { \n      photos[j].width = round(height * ratio(photos[j]), 1); \n      photos[j].height = height; \n    } \n  } \n  return photos; \n};"
        }
    },
    {
        "repo": "angular-hover-gradient-button",
        "content": "'angular-hover-gradient-button/projects/hover-gradient-button-example/src/app/app.config.ts'\n:import { ApplicationConfig } from '@angular/core';\nimport { provideRouter } from '@angular/router';\n\nimport { routes } from './app.routes';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes)]\n};\n\n'angular-hover-gradient-button/projects/hover-gradient-button-example/src/main.ts'\n:import { bootstrapApplication } from '@angular/platform-browser';\nimport { appConfig } from './app/app.config';\nimport { AppComponent } from './app/app.component';\n\nbootstrapApplication(AppComponent, appConfig)\n  .catch((err) => console.error(err));\n\n",
        "called_code_segment": "export const appConfig: ApplicationConfig = {\n  providers: [provideRouter(routes)]\n};",
        "invoking_code_segment": "bootstrapApplication(AppComponent, appConfig)\n  .catch((err) => console.error(err));",
        "feature_description": "Add a new environment configuration provider to the application configuration.",
        "detailed_feature_description": "Introduce a new environment configuration provider to the application configuration. This provider will be responsible for managing environment-specific settings. The modification will involve adding a new provider to the `appConfig` in #file 1 and ensuring that #file 2 correctly initializes the application with this new configuration.",
        "modified_complete_code": {
            "#file 1": "import { ApplicationConfig } from '@angular/core';\nimport { provideRouter } from '@angular/router';\nimport { provideEnvironmentConfiguration } from './environment-config';\n\nimport { routes } from './app.routes';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideRouter(routes),\n    provideEnvironmentConfiguration()\n  ]\n};",
            "#file 2": "import { bootstrapApplication } from '@angular/platform-browser';\nimport { appConfig } from './app/app.config';\nimport { AppComponent } from './app/app.component';\n\nbootstrapApplication(AppComponent, appConfig)\n  .catch((err) => console.error(err));"
        }
    },
    {
        "repo": "calendar-hack",
        "content": "'calendar-hack/src/ch/localize.ts'\n:import { Units } from \"types/app\";\n\nconst formatter = new Intl.DateTimeFormat(navigator.language);\n\n// Locale-appropriate date format based on current language.\nexport function format(date: Date): string {\n  return formatter.format(date);\n}\n\n// Guess the user's preferred units of measure based on the current language. Fuzzy at best.\nexport function getLocaleUnits(): Units {\n  if (navigator.language === \"en\" || navigator.language === \"en-US\") {\n    return \"mi\";\n  }\n  return \"km\";\n}\n\n'calendar-hack/src/components/PlanSummary.tsx'\n:import React from \"react\";\nimport { format } from \"../ch/localize\";\nimport styled from \"styled-components\";\nimport { TrainingPlan } from \"types/app\";\n\ninterface Props {\n  selectedPlan: TrainingPlan;\n  endDate: Date;\n}\n\nconst Root = styled.div`\n  margin: 1em 0 0.5em 0;\n  padding: 0.5em 0 1em 0;\n  text-align: center;\n  border: 1px solid rgba(0, 0, 0, 0.125);\n  border-radius: 0.25rem;\n  background-color: #f8f9fa;\n`;\n\nconst PlanSummary = ({ selectedPlan, endDate }: Props) => {\n  return (\n    <Root>\n      <h2>{selectedPlan.name}</h2>\n      <h3>Ending on: {format(endDate)}</h3>\n    </Root>\n  );\n};\n\nexport default PlanSummary;\n\n",
        "called_code_segment": "export function format(date: Date): string {\n  return formatter.format(date);\n}",
        "invoking_code_segment": "const PlanSummary = ({ selectedPlan, endDate }: Props) => {\n  return (\n    <Root>\n      <h2>{selectedPlan.name}</h2>\n      <h3>Ending on: {format(endDate)}</h3>\n    </Root>\n  );\n};",
        "feature_description": "Add a feature to display the start date of the training plan in the PlanSummary component.",
        "detailed_feature_description": "Modify the format function in the localize.ts file to accept an optional parameter for formatting options. Update the PlanSummary component to use this new format function to display both the start and end dates of the training plan.",
        "modified_complete_code": {
            "localize.ts": "//Modify\nexport function format(date: Date, options?: Intl.DateTimeFormatOptions): string {\n  return formatter.format(date, options);\n}",
            "PlanSummary.tsx": "//Modify\nconst PlanSummary = ({ selectedPlan, endDate, startDate }: Props) => {\n  return (\n    <Root>\n      <h2>{selectedPlan.name}</h2>\n      <h3>Starting on: {format(startDate, { day: 'numeric', month: 'long', year: 'numeric' })}</h3>\n      <h3>Ending on: {format(endDate, { day: 'numeric', month: 'long', year: 'numeric' })}</h3>\n    </Root>\n  );\n};\n\n//New\ninterface Props {\n  selectedPlan: TrainingPlan;\n  endDate: Date;\n  startDate: Date;\n}"
        }
    },
    {
        "repo": "chatgpt-minimal",
        "content": "'chatgpt-minimal/src/components/ChatGPT/interface.ts'\n:import type { ReactNode } from 'react'\n\nexport enum ChatRole {\n  Assistant = 'assistant',\n  User = 'user',\n  System = 'system'\n}\n\nexport interface ChatGPTProps {\n  fetchPath: string\n}\n\nexport interface ChatMessage {\n  content: string\n  role: ChatRole\n}\n\nexport interface ChatMessageItemProps {\n  message: ChatMessage\n}\n\nexport interface SendBarProps {\n  loading: boolean\n  disabled: boolean\n  onSend: (message: ChatMessage) => void\n  onClear: () => void\n  onStop: () => void\n}\n\nexport interface ShowProps {\n  loading?: boolean\n  fallback?: ReactNode\n  children?: ReactNode\n}\n\n'chatgpt-minimal/src/components/ChatGPT/index.tsx'\n:import React from 'react'\n\nimport { ChatGPTProps, ChatRole } from './interface'\nimport MessageItem from './MessageItem'\nimport SendBar from './SendBar'\nimport { useChatGPT } from './useChatGPT'\n\nimport './index.less'\nimport 'highlight.js/styles/atom-one-dark.css'\n\nconst ChatGPT = (props: ChatGPTProps) => {\n  const { loading, disabled, messages, currentMessage, onSend, onClear, onStop } = useChatGPT(props)\n\n  return (\n    <div className=\"chat-wrapper\">\n      {messages.map((message, index) => (\n        <MessageItem key={index} message={message} />\n      ))}\n      {currentMessage.current && (\n        <MessageItem message={{ content: currentMessage.current, role: ChatRole.Assistant }} />\n      )}\n      <SendBar\n        loading={loading}\n        disabled={disabled}\n        onSend={onSend}\n        onClear={onClear}\n        onStop={onStop}\n      />\n    </div>\n  )\n}\n\nexport default ChatGPT\n\n",
        "called_code_segment": "const ChatGPT = (props: ChatGPTProps) => {\n  const { loading, disabled, messages, currentMessage, onSend, onClear, onStop } = useChatGPT(props)\n\n  return (\n    <div className=\"chat-wrapper\">\n      {messages.map((message, index) => (\n        <MessageItem key={index} message={message} />\n      ))}\n      {currentMessage.current && (\n        <MessageItem message={{ content: currentMessage.current, role: ChatRole.Assistant }} />\n      )}\n      <SendBar\n        loading={loading}\n        disabled={disabled}\n        onSend={onSend}\n        onClear={onClear}\n        onStop={onStop}\n      />\n    </div>\n  )\n}",
        "invoking_code_segment": "const { loading, disabled, messages, currentMessage, onSend, onClear, onStop } = useChatGPT(props)",
        "feature_description": "Add a feature to allow users to edit their messages before sending.",
        "detailed_feature_description": "Modify the SendBar component to include an edit button next to each user message. When clicked, the message should be editable, and the user can resend the edited message.",
        "modified_complete_code": {
            "#file 1": "const ChatGPT = (props: ChatGPTProps) => {\n  const { loading, disabled, messages, currentMessage, onSend, onClear, onStop, onEdit } = useChatGPT(props) #Modify\n\n  return (\n    <div className=\"chat-wrapper\">\n      {messages.map((message, index) => (\n        <MessageItem key={index} message={message} onEdit={() => onEdit(index)} /> #Modify\n      ))}\n      {currentMessage.current && (\n        <MessageItem message={{ content: currentMessage.current, role: ChatRole.Assistant }} />\n      )}\n      <SendBar\n        loading={loading}\n        disabled={disabled}\n        onSend={onSend}\n        onClear={onClear}\n        onStop={onStop}\n      />\n    </div>\n  )\n}",
            "#file 2": "const MessageItem = ({ message, onEdit }) => { #New\n  const [isEditing, setIsEditing] = useState(false) #New\n  const [editedMessage, setEditedMessage] = useState(message.content) #New\n\n  const handleEdit = () => { #New\n    setIsEditing(true)\n  }\n\n  const handleSave = () => { #New\n    onEdit(editedMessage)\n    setIsEditing(false)\n  }\n\n  return (\n    <div className={`message-item ${message.role}`}>\n      {isEditing ? (\n        <div>\n          <input value={editedMessage} onChange={(e) => setEditedMessage(e.target.value)} />\n          <button onClick={handleSave}>Save</button>\n        </div>\n      ) : (\n        <div>\n          <div className=\"message-content\">{message.content}</n          {message.role === ChatRole.User && <button onClick={handleEdit}>Edit</button>} #New\n        </div>\n      )}\n    </div>\n  )\n}"
        }
    },
    {
        "repo": "crossmint-sdk",
        "content": "'crossmint-sdk/apps/payments/nextjs/components/embed-v3/EmbeddedCheckoutV3Content.tsx'\n:import { CrossmintEmbeddedCheckout_Alpha, useCrossmintCheckout } from \"@crossmint/client-sdk-react-ui\";\nimport { useEffect } from \"react\";\n\nconst USE_CUSTOM_RENDERING = false;\n\nexport function EmbeddedCheckoutV3Content() {\n    const { order } = useCrossmintCheckout();\n\n    useEffect(() => {\n        console.log(\"order in sdk\", order);\n    }, [order]);\n\n    if (USE_CUSTOM_RENDERING) {\n        switch (order?.phase) {\n            case \"completed\":\n                return <div>Custom completed screen</div>;\n            case \"delivery\":\n                return <div>Custom delivery screen</div>;\n            default:\n                return <CrossmintEmbeddedCheckoutWrapper />;\n        }\n    }\n\n    return <CrossmintEmbeddedCheckoutWrapper />;\n}\n\nfunction CrossmintEmbeddedCheckoutWrapper() {\n    return (\n        <CrossmintEmbeddedCheckout_Alpha\n            // recipient={{\n            //     email: \"maxwell@paella.dev\",\n            // }}\n            lineItems={{\n                collectionLocator: \"crossmint:206b3146-f526-444e-bd9d-0607d581b0e9\",\n                callData: {\n                    totalPrice: \"0.001\",\n                    quantity: 1,\n                },\n            }}\n            payment={{\n                crypto: {\n                    enabled: true,\n                },\n                fiat: {\n                    enabled: true,\n                },\n                defaultMethod: \"fiat\",\n            }}\n            // appearance={{\n            //     variables: {\n            //         colors: {\n            //             backgroundPrimary: \"black\",\n            //         },\n            //     },\n            // }}\n        />\n    );\n}\n\n'crossmint-sdk/apps/payments/nextjs/pages/embedded-checkout/v3.tsx'\n:import { EmbeddedCheckoutV3ClientProviders } from \"../../components/embed-v3/EmbeddedCheckoutV3ClientProviders\";\nimport { EmbeddedCheckoutV3Content } from \"../../components/embed-v3/EmbeddedCheckoutV3Content\";\n\nexport default function EmbeddedCheckoutV3Page() {\n    return (\n        <div\n            style={{\n                display: \"flex\",\n                flexDirection: \"column\",\n                alignItems: \"center\",\n                justifyContent: \"start\",\n                padding: \"20px\",\n                // backgroundColor: \"black\",\n            }}\n        >\n            <div\n                style={{\n                    display: \"flex\",\n                    flexDirection: \"column\",\n                    alignItems: \"center\",\n                    justifyContent: \"start\",\n                    width: \"100%\",\n                    maxWidth: \"450px\",\n                }}\n            >\n                <EmbeddedCheckoutV3ClientProviders>\n                    <EmbeddedCheckoutV3Content />\n                </EmbeddedCheckoutV3ClientProviders>\n            </div>\n        </div>\n    );\n}\n\n",
        "called_code_segment": "function EmbeddedCheckoutV3Content() {\n    const { order } = useCrossmintCheckout();\n\n    useEffect(() => {\n        console.log(\"order in sdk\", order);\n    }, [order]);\n\n    if (USE_CUSTOM_RENDERING) {\n        switch (order?.phase) {\n            case \"completed\":\n                return <div>Custom completed screen</div>;\n            case \"delivery\":\n                return <div>Custom delivery screen</div>;\n            default:\n                return <CrossmintEmbeddedCheckoutWrapper />;\n        }\n    }\n\n    return <CrossmintEmbeddedCheckoutWrapper />;\n}",
        "invoking_code_segment": "<EmbeddedCheckoutV3ClientProviders>\n    <EmbeddedCheckoutV3Content />\n</EmbeddedCheckoutV3ClientProviders>",
        "feature_description": "Add a loading state to the EmbeddedCheckoutV3Content component.",
        "detailed_feature_description": "Introduce a loading state to the EmbeddedCheckoutV3Content component to handle the initial loading phase before the order data is fetched. This will be managed by a new state variable 'isLoading' and will display a loading spinner until the order data is available.",
        "modified_complete_code": {
            "file1": "import { CrossmintEmbeddedCheckout_Alpha, useCrossmintCheckout } from \"@crossmint/client-sdk-react-ui\";\nimport { useEffect, useState } from \"react\";\n\nconst USE_CUSTOM_RENDERING = false;\n\nfunction EmbeddedCheckoutV3Content() {\n    const { order } = useCrossmintCheckout();\n    const [isLoading, setIsLoading] = useState(true); // #New\n\n    useEffect(() => {\n        console.log(\"order in sdk\", order);\n        if (order) setIsLoading(false); // #Modify\n    }, [order]);\n\n    if (isLoading) { // #Modify\n        return <div>Loading...</div>; // #New\n    }\n\n    if (USE_CUSTOM_RENDERING) {\n        switch (order?.phase) {\n            case \"completed\":\n                return <div>Custom completed screen</div>;\n            case \"delivery\":\n                return <div>Custom delivery screen</div>;\n            default:\n                return <CrossmintEmbeddedCheckoutWrapper />;\n        }\n    }\n\n    return <CrossmintEmbeddedCheckoutWrapper />;\n}\n\nfunction CrossmintEmbeddedCheckoutWrapper() {\n    return (\n        <CrossmintEmbeddedCheckout_Alpha\n            lineItems={{ // #Modify\n                collectionLocator: \"crossmint:206b3146-f526-444e-bd9d-0607d581b0e9\",\n                callData: {\n                    totalPrice: \"0.001\",\n                    quantity: 1,\n                },\n            }}\n            payment={{ // #Modify\n                crypto: {\n                    enabled: true,\n                },\n                fiat: {\n                    enabled: true,\n                },\n                defaultMethod: \"fiat\",\n            }}\n        />\n    );\n}",
            "file2": "import { EmbeddedCheckoutV3ClientProviders } from \"../../components/embed-v3/EmbeddedCheckoutV3ClientProviders\";\nimport { EmbeddedCheckoutV3Content } from \"../../components/embed-v3/EmbeddedCheckoutV3Content\";\n\nexport default function EmbeddedCheckoutV3Page() {\n    return (\n        <div\n            style={{ // #Modify\n                display: \"flex\",\n                flexDirection: \"column\",\n                alignItems: \"center\",\n                justifyContent: \"start\",\n                padding: \"20px\",\n            }}\n        >\n            <div\n                style={{ // #Modify\n                    display: \"flex\",\n                    flexDirection: \"column\",\n                    alignItems: \"center\",\n                    justifyContent: \"start\",\n                    width: \"100%\",\n                    maxWidth: \"450px\",\n                }}\n            >\n                <EmbeddedCheckoutV3ClientProviders>\n                    <EmbeddedCheckoutV3Content />\n                </EmbeddedCheckoutV3ClientProviders>\n            </div>\n        </div>\n    );\n}"
        }
    },
    {
        "repo": "crypto-prices-react",
        "content": "'crypto-prices-react/src/CryptoList.tsx'\n:import React, { Component } from 'react';\nimport CryptoListItem from './CryptoListItem';\nimport { CryptoDataType } from \"./Crypto\";\n\ninterface listPropTypes {\n\tdata: CryptoDataType\n}\n\nclass CryptoList extends Component<listPropTypes, {}> {\n\trender() {\n\t\tlet count = 0;\n\t\tconst data = this.props.data['DISPLAY'];\n\n\t\tif (!data) {\n\t\t\treturn (\n\t\t\t\t<tr>\n\t\t\t\t\t<td>1</td>\n\t\t\t\t\t<td>2</td>\n\t\t\t\t\t<td>3</td>\n\t\t\t\t\t<td>4</td>\n\t\t\t\t\t<td>5</td>\n\t\t\t\t</tr>\n\t\t\t);\n\t\t}\n\n\t\treturn Object.keys(data).map((k) => {\n\t\t\tcount++;\n\t\t\treturn (\n\t\t\t\t<CryptoListItem key={count} count={count} data={data[k]} />\n\t\t\t)\n\t\t});\n\t}\n}\n\nexport default CryptoList;\n'crypto-prices-react/src/CryptoContent.tsx'\n:import React, { Component } from 'react';\nimport CryptoList from './CryptoList';\nimport { CryptoDataType } from \"./Crypto\";\n\ninterface contentPropType {\n\tdata: CryptoDataType\n}\n\nclass CryptoContent extends Component<contentPropType, {}> {\n\trender() {\n\t\treturn (\n\t\t\t<tbody className=\"crypto__list--body\">\n\t\t\t\t<CryptoList data={this.props.data} />\n\t\t\t</tbody>\n\t\t);\n\t}\n}\n\nexport default CryptoContent;\n",
        "called_code_segment": "class CryptoList extends Component<listPropTypes, {}> {\n\trender() {\n\t\tlet count = 0;\n\t\tconst data = this.props.data['DISPLAY'];\n\n\t\tif (!data) {\n\t\t\treturn (\n\t\t\t\t<tr>\n\t\t\t\t\t<td>1</td>\n\t\t\t\t\t<td>2</td>\n\t\t\t\t\t<td>3</td>\n\t\t\t\t\t<td>4</td>\n\t\t\t\t\t<td>5</td>\n\t\t\t\t</tr>\n\t\t\t);\n\t\t}\n\n\t\treturn Object.keys(data).map((k) => {\n\t\t\tcount++;\n\t\t\treturn (\n\t\t\t\t<CryptoListItem key={count} count={count} data={data[k]} />\n\t\t\t)\n\t\t});\n\t}\n}",
        "invoking_code_segment": "class CryptoContent extends Component<contentPropType, {}> {\n\trender() {\n\t\treturn (\n\t\t\t<tbody className=\"crypto__list--body\">\n\t\t\t\t<CryptoList data={this.props.data} />\n\t\t\t</tbody>\n\t\t);\n\t}\n}",
        "feature_description": "Add a loading state to display a loading message while the data is being fetched.",
        "detailed_feature_description": "Modify the CryptoList component to check if the data is available. If not, display a loading message. Update the CryptoContent component to pass a loading state to CryptoList.",
        "modified_complete_code": {
            "CryptoList.tsx": "class CryptoList extends Component<listPropTypes, {}> {\n\trender() {\n\t\tlet count = 0;\n\t\tconst data = this.props.data['DISPLAY'];\n\n\t\tif (!data) {\n\t\t\treturn (\n\t\t\t\t<tr>\n\t\t\t\t\t<td colSpan={5}>Loading...</td> #Modify\n\t\t\t\t</tr>\n\t\t\t);\n\t\t}\n\n\t\treturn Object.keys(data).map((k) => {\n\t\t\tcount++;\n\t\t\treturn (\n\t\t\t\t<CryptoListItem key={count} count={count} data={data[k]} />\n\t\t\t)\n\t\t});\n\t}\n}",
            "CryptoContent.tsx": "class CryptoContent extends Component<contentPropType, {}> {\n\trender() {\n\t\tconst { data, loading } = this.props; #Modify\n\t\treturn (\n\t\t\t<tbody className=\"crypto__list--body\">\n\t\t\t\t<CryptoList data={data} loading={loading} /> #Modify\n\t\t\t</tbody>\n\t\t);\n\t}\n}"
        }
    },
    {
        "repo": "drawing-board",
        "content": "'drawing-board/src/components/toolbar.tsx'\n:import React, {useState} from 'react';\nimport {StyleSheet, View} from 'react-native';\nimport Color from '../components/color';\nimport Stroke from '../components/stroke';\nimport useDrawingStore from '../store';\nimport constants from '../drawing/constants';\nimport utils from '../drawing/utils';\n\nconst Toolbar = () => {\n  const currentColor = useDrawingStore(state => state.color);\n  const currentStrokeWidth = useDrawingStore(state => state.strokeWidth);\n  const setStrokeWidth = useDrawingStore(state => state.setStrokeWidth);\n  const setColor = useDrawingStore(state => state.setColor);\n  const setStroke = useDrawingStore(state => state.setStroke);\n  const [showStrokes, setShowStrokes] = useState(false);\n\n  const onStrokeChange = (stroke: number) => {\n    setStrokeWidth(stroke);\n    setShowStrokes(false);\n    setStroke(utils.getPaint(stroke, currentColor));\n  };\n\n  const onChangeColor = (color: string) => {\n    setColor(color);\n    setStroke(utils.getPaint(currentStrokeWidth, color));\n  };\n\n  return (\n    <>\n      {showStrokes && (\n        <View\n          style={[\n            styles.toolbar,\n            {\n              bottom: 80,\n              position: 'absolute',\n            },\n          ]}>\n          {constants.strokes.map(stroke => (\n            <Stroke\n              key={stroke}\n              stroke={stroke}\n              onPress={() => onStrokeChange(stroke)}\n            />\n          ))}\n        </View>\n      )}\n\n      <View\n        style={[styles.toolbar, {position: 'relative', marginVertical: 12}]}>\n        <View\n          style={{\n            backgroundColor: '#f7f7f7',\n            borderRadius: 5,\n          }}>\n          {showStrokes && (\n            <View\n              style={{\n                width: 5,\n                height: 5,\n                borderRadius: 100,\n                backgroundColor: 'black',\n                alignSelf: 'center',\n                position: 'absolute',\n              }}\n            />\n          )}\n\n          <Stroke\n            stroke={currentStrokeWidth}\n            onPress={() => setShowStrokes(!showStrokes)}\n          />\n        </View>\n\n        <View\n          style={{\n            height: 30,\n            borderWidth: 1,\n            borderColor: '#f0f0f0',\n            marginHorizontal: 10,\n          }}\n        />\n\n        {constants.colors.map(item => (\n          <Color key={item} color={item} onPress={() => onChangeColor(item)} />\n        ))}\n      </View>\n    </>\n  );\n};\n\nexport default Toolbar;\n\nconst styles = StyleSheet.create({\n  toolbar: {\n    backgroundColor: '#ffffff',\n    height: 50,\n    width: 300,\n    borderRadius: 100,\n    flexDirection: 'row',\n    paddingHorizontal: 12,\n    justifyContent: 'center',\n    alignItems: 'center',\n    ...utils.getElevation(5),\n  },\n  color: {\n    width: 35,\n    height: 35,\n    marginRight: 10,\n    borderRadius: 100,\n    borderWidth: 2,\n    borderColor: '#f0f0f0',\n    ...utils.getElevation(1),\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n\n'drawing-board/src/drawing/index.tsx'\n:import {\n  Canvas,\n  ExtendedTouchInfo,\n  ICanvas,\n  Path,\n  Skia,\n  SkiaView,\n  TouchInfo,\n  useDrawCallback,\n  useTouchHandler,\n} from '@shopify/react-native-skia';\nimport React, {useCallback, useRef, useState} from 'react';\nimport {\n  LayoutChangeEvent,\n  SafeAreaView,\n  useWindowDimensions,\n  View,\n} from 'react-native';\nimport useDrawingStore, {CurrentPath} from '../store';\nimport Header from '../components/header';\nimport history from './history';\nimport Toolbar from '../components/toolbar';\n\nconst Drawing = () => {\n  const touchState = useRef(false);\n  const canvas = useRef<ICanvas>();\n  const currentPath = useRef<CurrentPath | null>();\n  const {width} = useWindowDimensions();\n  const completedPaths = useDrawingStore(state => state.completedPaths);\n  const setCompletedPaths = useDrawingStore(state => state.setCompletedPaths);\n  const stroke = useDrawingStore(state => state.stroke);\n  const [canvasHeight, setCanvasHeight] = useState(400);\n\n  const onDrawingActive = useCallback((touchInfo: ExtendedTouchInfo) => {\n    const {x, y} = touchInfo;\n    if (!currentPath.current?.path) return;\n    if (touchState.current) {\n      currentPath.current.path.lineTo(x, y);\n      if (currentPath.current) {\n        canvas.current?.drawPath(\n          currentPath.current.path,\n          currentPath.current.paint,\n        );\n      }\n    }\n  }, []);\n\n  const onDrawingStart = useCallback(\n    (touchInfo: TouchInfo) => {\n      if (currentPath.current) return;\n      const {x, y} = touchInfo;\n      currentPath.current = {\n        path: Skia.Path.Make(),\n        paint: stroke.copy(),\n      };\n\n      touchState.current = true;\n      currentPath.current.path?.moveTo(x, y);\n\n      if (currentPath.current) {\n        canvas.current?.drawPath(\n          currentPath.current.path,\n          currentPath.current.paint,\n        );\n      }\n    },\n    [stroke],\n  );\n\n  const onDrawingFinished = useCallback(() => {\n    updatePaths();\n    currentPath.current = null;\n    touchState.current = false;\n  }, [completedPaths.length]);\n\n  const touchHandler = useTouchHandler({\n    onActive: onDrawingActive,\n    onStart: onDrawingStart,\n    onEnd: onDrawingFinished,\n  });\n\n  const updatePaths = () => {\n    if (!currentPath.current) return;\n    let updatedPaths = [...completedPaths];\n    updatedPaths.push({\n      path: currentPath.current?.path.copy(),\n      paint: currentPath.current?.paint.copy(),\n      color: useDrawingStore.getState().color,\n    });\n    history.push(currentPath.current);\n    setCompletedPaths(updatedPaths);\n  };\n\n  const onDraw = useDrawCallback((_canvas, info) => {\n    touchHandler(info.touches);\n\n    if (currentPath.current) {\n      canvas.current?.drawPath(\n        currentPath.current.path,\n        currentPath.current.paint,\n      );\n    }\n\n    if (!canvas.current) {\n      useDrawingStore.getState().setCanvasInfo({\n        width: info.width,\n        height: info.height,\n      });\n      canvas.current = _canvas;\n    }\n  }, []);\n\n  const onLayout = (event: LayoutChangeEvent) => {\n    setCanvasHeight(event.nativeEvent.layout.height);\n  };\n\n  return (\n    <SafeAreaView\n      style={{\n        flex: 1,\n      }}>\n      <View\n        style={{\n          backgroundColor: '#f0f0f0',\n          flex: 1,\n          alignItems: 'center',\n        }}>\n        <Header />\n\n        <View\n          onLayout={onLayout}\n          style={{\n            width: width - 24,\n            flexGrow: 1,\n            backgroundColor: '#ffffff',\n            borderRadius: 10,\n            overflow: 'hidden',\n            elevation: 1,\n          }}>\n          <SkiaView\n            onDraw={onDraw}\n            style={{height: canvasHeight, width: width - 24, zIndex: 10}}\n          />\n\n          <Canvas\n            style={{\n              height: canvasHeight,\n              width: width - 24,\n              position: 'absolute',\n            }}>\n            {completedPaths?.map(path => (\n              <Path\n                key={path.path.toSVGString()}\n                path={path.path}\n                //@ts-ignore\n                paint={{current: path.paint}}\n              />\n            ))}\n          </Canvas>\n        </View>\n\n        <Toolbar />\n      </View>\n    </SafeAreaView>\n  );\n};\n\nexport default Drawing;\n\n",
        "called_code_segment": "const onDrawingFinished = useCallback(() => {\n    updatePaths();\n    currentPath.current = null;\n    touchState.current = false;\n  }, [completedPaths.length]);",
        "invoking_code_segment": "const touchHandler = useTouchHandler({\n    onActive: onDrawingActive,\n    onStart: onDrawingStart,\n    onEnd: onDrawingFinished,\n  });",
        "feature_description": "Add a feature to save the drawing to the device's local storage when the drawing is finished.",
        "detailed_feature_description": "When the drawing is finished, the current drawing will be saved to the device's local storage. This will be achieved by modifying the `onDrawingFinished` function in #file 1 to include a call to a new function `saveDrawingToStorage`. This function will handle the actual saving process. In #file 2, the `useTouchHandler` will remain unchanged as it already correctly invokes `onDrawingFinished`.",
        "modified_complete_code": {
            "#file 1": "import {saveDrawingToStorage} from '../utils/storage'; // #New\n\nconst onDrawingFinished = useCallback(() => {\n    updatePaths();\n    currentPath.current = null;\n    touchState.current = false;\n    saveDrawingToStorage(completedPaths); // #Modify\n  }, [completedPaths.length]);",
            "#file 2": "const touchHandler = useTouchHandler({\n    onActive: onDrawingActive,\n    onStart: onDrawingStart,\n    onEnd: onDrawingFinished,\n  });"
        }
    },
    {
        "repo": "dual-range-bar",
        "content": "'dual-range-bar/src/DualVRangeBar.ts'\n:import { getDeltaY } from './utils'\nimport DualRangeBar from './DualRangeBar'\nimport { Config } from './DualRangeBar'\n\nexport default class DualVRangeBar extends DualRangeBar {\n  update() {\n    super.update()\n    const barW = this.doms.background.clientWidth\n    const barH = this.doms.background.clientHeight\n    const startSliderW = this.doms.startSlider.clientWidth\n    const startSliderH = this.doms.startSlider.clientHeight\n    const endSliderW = this.doms.endSlider.clientWidth\n    const endSliderH = this.doms.endSlider.clientHeight\n    const rangeSliderW = this.doms.rangeSlider.clientWidth\n    const rangeSliderH = (this.relative.upper - this.relative.lower) * barH\n\n    const startSliderL = barW/2 - startSliderW/2\n    const startSliderT = this.relative.lower * barH - startSliderH/2\n    const endSliderL = barW/2 - endSliderW/2\n    const endSliderT = this.relative.upper * barH - endSliderH/2\n    const rangeSliderL = barW/2 - rangeSliderW/2\n    const rangeSliderT = this.relative.lower * barH\n\n    this.doms.startSlider.style.left = `${startSliderL}px`\n    this.doms.startSlider.style.top = `${startSliderT}px`\n    this.doms.endSlider.style.left = `${endSliderL}px`\n    this.doms.endSlider.style.top = `${endSliderT}px`\n    this.doms.rangeSlider.style.left = `${rangeSliderL}px`\n    this.doms.rangeSlider.style.top = `${rangeSliderT}px`\n    this.doms.rangeSlider.style.height = `${rangeSliderH}px`\n  }\n\n  /** Helper function for getting dx via clientX */\n  private getDy(clientY: number) {\n    const bgRect = this.doms.background.getBoundingClientRect()\n    return clientY - bgRect.top\n  }\n\n  protected draggingStart(event: MouseEvent | TouchEvent) {\n    const clientY = (event as MouseEvent).clientY\n    || (event as TouchEvent).touches?.item(0)?.clientY || 0\n    const minLower = 0, maxLower = 1 - this.relative.minSpan\n    let newLower = this.getDy(clientY)/this.doms.background.clientHeight\n    if (newLower < minLower) newLower = minLower\n    if (newLower > maxLower) newLower = maxLower\n    this.relative.lower = newLower\n    if (newLower + this.relative.minSpan > this.relative.upper)\n      this.relative.upper = newLower + this.relative.minSpan\n    if (newLower + this.relative.maxSpan < this.relative.upper)\n      this.relative.upper = newLower + this.relative.maxSpan\n  }\n  \n  protected draggingEnd(event: MouseEvent | TouchEvent) {\n    const clientY = (event as MouseEvent).clientY\n    || (event as TouchEvent).touches?.item(0)?.clientY || 0\n    const minUpper = this.relative.minSpan, maxUpper = 1\n    let newUpper = this.getDy(clientY)/this.doms.background.clientHeight\n    if (newUpper < minUpper) newUpper = minUpper\n    if (newUpper > maxUpper) newUpper = maxUpper\n    this.relative.upper = newUpper\n    if (newUpper - this.relative.minSpan < this.relative.lower)\n      this.relative.lower = newUpper - this.relative.minSpan\n    if (newUpper - this.relative.maxSpan > this.relative.lower)\n      this.relative.lower = newUpper - this.relative.maxSpan\n  }\n\n  protected draggingRange(event: MouseEvent | TouchEvent) {\n    const movementY = (event as MouseEvent).movementY\n    || (((event as TouchEvent).touches?.item(0)?.clientY || 0) - this.prevClientY)\n    const maxDx = 1 - this.relative.upper, minDx = -this.relative.lower\n    let dx = movementY/this.doms.background.clientHeight\n    if (dx > maxDx) dx = maxDx; if (dx < minDx) dx = minDx\n    this.relative.lower += dx; this.relative.upper += dx\n  }\n\n  protected wheelScaling(event: WheelEvent) {\n    const dy = getDeltaY(event)/this.doms.background.clientHeight\n    const cursorPos = this.getDy(event.clientY)/this.doms.background.clientHeight\n    const relativeSpan = this.relative.upper - this.relative.lower\n    let newLower = this.relative.lower - \n      dy * (cursorPos-this.relative.lower) / relativeSpan\n    let newUpper = this.relative.upper + \n      dy * (this.relative.upper-cursorPos) / relativeSpan\n    if (newLower < 0) newLower = 0\n    if (newUpper > 1) newUpper = 1\n    if (newUpper - newLower < this.relative.minSpan) {\n      newLower = cursorPos - \n        this.relative.minSpan * (cursorPos-this.relative.lower) / relativeSpan\n      newUpper = cursorPos + \n        this.relative.minSpan * (this.relative.upper-cursorPos) / relativeSpan\n    }\n    if (newUpper - newLower > this.relative.maxSpan) {\n      newLower = cursorPos -\n        this.relative.maxSpan * (cursorPos-this.relative.lower) / relativeSpan\n      newUpper = cursorPos +\n        this.relative.maxSpan * (this.relative.upper-cursorPos) / relativeSpan\n    }\n    this.relative.lower = newLower\n    this.relative.upper = newUpper\n  }\n\n  protected wheelScrolling(event: WheelEvent) {\n    let dy = getDeltaY(event)/this.doms.background.clientHeight\n    const minDy = -this.relative.lower\n    const maxDy = 1 - this.relative.upper\n    if (dy < minDy) dy = minDy\n    if (dy > maxDy) dy = maxDy\n    this.relative.lower += dy\n    this.relative.upper += dy\n  }\n\n  constructor(container: string | HTMLDivElement, config?: Config) {\n    super(container, config);\n    this.container.classList.add(`${this.prefix}-vertical`)\n    // Inline styles\n    this.doms.background.style.height = '100%'\n    this.update()\n  }\n}\n'dual-range-bar/src/index.ts'\n:import DualHRangeBar from './DualHRangeBar'\nimport DualVRangeBar from './DualVRangeBar'\n\nwindow.addEventListener('load', () => {\n  let dualRangeBars = document.getElementsByClassName('drbar-container')\n  for (let i = 0; i < dualRangeBars.length; i++) {\n    const bar = dualRangeBars.item(i)\n    if (bar?.nodeName !== 'DIV') continue\n    if (bar?.childElementCount > 0) continue\n    if (bar?.classList.contains('drbar-vertical')) {\n      new DualVRangeBar(bar as HTMLDivElement)\n    } else {\n      new DualHRangeBar(bar as HTMLDivElement)\n    }\n  }\n});\n\n(window as any).DualHRangeBar = DualHRangeBar;\n(window as any).DualVRangeBar = DualVRangeBar;\n\nexport { DualHRangeBar, DualVRangeBar };\n\n",
        "called_code_segment": "export default class DualVRangeBar extends DualRangeBar {\n  update() {\n    super.update()\n    const barW = this.doms.background.clientWidth\n    const barH = this.doms.background.clientHeight\n    const startSliderW = this.doms.startSlider.clientWidth\n    const startSliderH = this.doms.startSlider.clientHeight\n    const endSliderW = this.doms.endSlider.clientWidth\n    const endSliderH = this.doms.endSlider.clientHeight\n    const rangeSliderW = this.doms.rangeSlider.clientWidth\n    const rangeSliderH = (this.relative.upper - this.relative.lower) * barH\n\n    const startSliderL = barW/2 - startSliderW/2\n    const startSliderT = this.relative.lower * barH - startSliderH/2\n    const endSliderL = barW/2 - endSliderW/2\n    const endSliderT = this.relative.upper * barH - endSliderH/2\n    const rangeSliderL = barW/2 - rangeSliderW/2\n    const rangeSliderT = this.relative.lower * barH\n\n    this.doms.startSlider.style.left = `${startSliderL}px`\n    this.doms.startSlider.style.top = `${startSliderT}px`\n    this.doms.endSlider.style.left = `${endSliderL}px`\n    this.doms.endSlider.style.top = `${endSliderT}px`\n    this.doms.rangeSlider.style.left = `${rangeSliderL}px`\n    this.doms.rangeSlider.style.top = `${rangeSliderT}px`\n    this.doms.rangeSlider.style.height = `${rangeSliderH}px`\n  }\n}",
        "invoking_code_segment": "export default class DualHRangeBar extends DualRangeBar {\n  update() {\n    super.update()\n    const barW = this.doms.background.clientWidth\n    const barH = this.doms.background.clientHeight\n    const startSliderW = this.doms.startSlider.clientWidth\n    const startSliderH = this.doms.startSlider.clientHeight\n    const endSliderW = this.doms.endSlider.clientWidth\n    const endSliderH = this.doms.endSlider.clientHeight\n    const rangeSliderW = this.doms.rangeSlider.clientWidth\n    const rangeSliderH = (this.relative.upper - this.relative.lower) * barW\n\n    const startSliderL = this.relative.lower * barW - startSliderW/2\n    const startSliderT = barH/2 - startSliderH/2\n    const endSliderL = this.relative.upper * barW - endSliderW/2\n    const endSliderT = barH/2 - endSliderH/2\n    const rangeSliderL = this.relative.lower * barW\n    const rangeSliderT = barH/2 - rangeSliderH/2\n\n    this.doms.startSlider.style.left = `${startSliderL}px`\n    this.doms.startSlider.style.top = `${startSliderT}px`\n    this.doms.endSlider.style.left = `${endSliderL}px`\n    this.doms.endSlider.style.top = `${endSliderT}px`\n    this.doms.rangeSlider.style.left = `${rangeSliderL}px`\n    this.doms.rangeSlider.style.top = `${rangeSliderT}px`\n    this.doms.rangeSlider.style.width = `${rangeSliderH}px`\n  }\n}",
        "feature_description": "Add a feature to allow the user to reset the range to the default values.",
        "detailed_feature_description": "Add a method to reset the range to the default values and bind it to a button in the DOM. Update the constructor to add this button and bind the event listener.",
        "modified_complete_code": {
            "DualVRangeBar.ts": "export default class DualVRangeBar extends DualRangeBar {\n  update() {\n    super.update()\n    const barW = this.doms.background.clientWidth\n    const barH = this.doms.background.clientHeight\n    const startSliderW = this.doms.startSlider.clientWidth\n    const startSliderH = this.doms.startSlider.clientHeight\n    const endSliderW = this.doms.endSlider.clientWidth\n    const endSliderH = this.doms.endSlider.clientHeight\n    const rangeSliderW = this.doms.rangeSlider.clientWidth\n    const rangeSliderH = (this.relative.upper - this.relative.lower) * barH\n\n    const startSliderL = barW/2 - startSliderW/2\n    const startSliderT = this.relative.lower * barH - startSliderH/2\n    const endSliderL = barW/2 - endSliderW/2\n    const endSliderT = this.relative.upper * barH - endSliderH/2\n    const rangeSliderL = barW/2 - rangeSliderW/2\n    const rangeSliderT = this.relative.lower * barH\n\n    this.doms.startSlider.style.left = `${startSliderL}px`\n    this.doms.startSlider.style.top = `${startSliderT}px`\n    this.doms.endSlider.style.left = `${endSliderL}px`\n    this.doms.endSlider.style.top = `${endSliderT}px`\n    this.doms.rangeSlider.style.left = `${rangeSliderL}px`\n    this.doms.rangeSlider.style.top = `${rangeSliderT}px`\n    this.doms.rangeSlider.style.height = `${rangeSliderH}px`\n  }\n\n  #Modify resetToDefault() {\n    this.relative.lower = 0\n    this.relative.upper = 1\n    this.update()\n  }\n\n  constructor(container: string | HTMLDivElement, config?: Config) {\n    super(container, config)\n    this.container.classList.add(`${this.prefix}-vertical`)\n    // Inline styles\n    this.doms.background.style.height = '100%'\n    this.update()\n\n    #New const resetButton = document.createElement('button')\n    resetButton.innerText = 'Reset'\n    resetButton.addEventListener('click', () => this.resetToDefault())\n    this.container.appendChild(resetButton)\n  }\n}",
            "DualHRangeBar.ts": "export default class DualHRangeBar extends DualRangeBar {\n  update() {\n    super.update()\n    const barW = this.doms.background.clientWidth\n    const barH = this.doms.background.clientHeight\n    const startSliderW = this.doms.startSlider.clientWidth\n    const startSliderH = this.doms.startSlider.clientHeight\n    const endSliderW = this.doms.endSlider.clientWidth\n    const endSliderH = this.doms.endSlider.clientHeight\n    const rangeSliderW = this.doms.rangeSlider.clientWidth\n    const rangeSliderH = (this.relative.upper - this.relative.lower) * barW\n\n    const startSliderL = this.relative.lower * barW - startSliderW/2\n    const startSliderT = barH/2 - startSliderH/2\n    const endSliderL = this.relative.upper * barW - endSliderW/2\n    const endSliderT = barH/2 - endSliderH/2\n    const rangeSliderL = this.relative.lower * barW\n    const rangeSliderT = barH/2 - rangeSliderH/2\n\n    this.doms.startSlider.style.left = `${startSliderL}px`\n    this.doms.startSlider.style.top = `${startSliderT}px`\n    this.doms.endSlider.style.left = `${endSliderL}px`\n    this.doms.endSlider.style.top = `${endSliderT}px`\n    this.doms.rangeSlider.style.left = `${rangeSliderL}px`\n    this.doms.rangeSlider.style.top = `${rangeSliderT}px`\n    this.doms.rangeSlider.style.width = `${rangeSliderH}px`\n  }\n\n  #Modify resetToDefault() {\n    this.relative.lower = 0\n    this.relative.upper = 1\n    this.update()\n  }\n\n  constructor(container: string | HTMLDivElement, config?: Config) {\n    super(container, config)\n    this.container.classList.add(`${this.prefix}-horizontal`)\n    this.update()\n\n    #New const resetButton = document.createElement('button')\n    resetButton.innerText = 'Reset'\n    resetButton.addEventListener('click', () => this.resetToDefault())\n    this.container.appendChild(resetButton)\n  }\n}"
        }
    },
    {
        "repo": "extension",
        "content": "'extension/src/pages/overlay/components/overlay/Overlay.tsx'\n:import {\n  useEffect,\n  useRef,\n  useCallback,\n  useState,\n  useMemo,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\nimport Welcome from \"../../../../components/Welcome\";\nimport IconWelcome from \"../../../../components/icons/IconWelcome\";\nimport IconAmbassadors from \"../../../../components/icons/IconAmbassadors\";\nimport IconSettings from \"../../../../components/icons/IconSettings\";\n\nimport {\n  isAmbassadorKey,\n  type AmbassadorKey,\n} from \"../../../../hooks/useAmbassadors\";\nimport { classes } from \"../../../../utils/classes\";\nimport { visibleUnderCursor } from \"../../../../utils/dom\";\n\nimport useChatCommand from \"../../../../hooks/useChatCommand\";\n\nimport useSettings from \"../../hooks/useSettings\";\nimport useSleeping from \"../../hooks/useSleeping\";\n\nimport AmbassadorsOverlay from \"./Ambassadors\";\nimport SettingsOverlay from \"./Settings\";\n\nimport Buttons from \"../Buttons\";\n\n// Show command-triggered popups for 10s\nconst commandTimeout = 10_000;\n\nconst overlayOptions = [\n  {\n    key: \"welcome\",\n    type: \"primary\",\n    icon: IconWelcome,\n    title: \"Welcome to Alveus\",\n    component: (props: OverlayOptionProps) => (\n      <Welcome\n        className={classes(\"absolute left-0 top-0 mx-4 my-6\", props.className)}\n      />\n    ),\n  },\n  {\n    key: \"ambassadors\",\n    type: \"primary\",\n    icon: IconAmbassadors,\n    title: \"Explore our Ambassadors\",\n    component: AmbassadorsOverlay,\n  },\n  {\n    key: \"settings\",\n    type: \"secondary\",\n    icon: IconSettings,\n    title: \"Extension Settings\",\n    component: SettingsOverlay,\n  },\n] as const;\n\nexport const isValidOverlayKey = (key: string) =>\n  key === \"\" || overlayOptions.some((option) => option.key === key);\n\nexport type OverlayKey = (typeof overlayOptions)[number][\"key\"] | \"\";\n\ntype ActiveAmbassadorState = {\n  key?: AmbassadorKey;\n  isCommand?: boolean;\n};\n\nexport interface OverlayOptionProps {\n  context: {\n    activeAmbassador: ActiveAmbassadorState;\n    setActiveAmbassador: Dispatch<SetStateAction<ActiveAmbassadorState>>;\n  };\n  className?: string;\n}\n\nconst hiddenClass =\n  \"invisible opacity-0 -translate-x-10 motion-reduce:translate-x-0\";\n\nexport default function Overlay() {\n  const settings = useSettings();\n  const {\n    sleeping,\n    wake,\n    on: addSleepListener,\n    off: removeSleepListener,\n  } = useSleeping();\n\n  const [activeAmbassador, setActiveAmbassador] =\n    useState<ActiveAmbassadorState>({});\n  const [visibleOption, setVisibleOption] = useState<OverlayKey>(\n    settings.openedMenu.value,\n  );\n  const timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\n  const awakingRef = useRef(false);\n\n  // update setting when opened menu changes\n  useEffect(() => {\n    settings.openedMenu.change(visibleOption);\n  }, [visibleOption]);\n\n  // open saved (or default) menu when mounted\n  useEffect(() => {\n    setVisibleOption(settings.openedMenu.value);\n  }, [settings.openedMenu.value]);\n\n  // When a chat command is run, wake the overlay\n  useChatCommand(\n    useCallback(\n      (command: string) => {\n        if (!settings.disableChatPopup.value) {\n          if (isAmbassadorKey(command))\n            setActiveAmbassador({ key: command, isCommand: true });\n          else if (command !== \"welcome\") return;\n\n          // Show the card\n          setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n          // Dismiss the overlay after a delay\n          if (timeoutRef.current) clearTimeout(timeoutRef.current);\n          timeoutRef.current = setTimeout(() => {\n            setVisibleOption(\"\");\n            setActiveAmbassador({});\n          }, commandTimeout);\n\n          // Track that we're waking up, so that we don't immediately clear the timeout, and wake the overlay\n          awakingRef.current = true;\n          wake(commandTimeout);\n        }\n      },\n      [settings.disableChatPopup.value, wake],\n    ),\n  );\n\n  // Ensure we clean up the timer when we unmount\n  useEffect(\n    () => () => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    },\n    [],\n  );\n\n  // If the user interacts with the overlay, clear the auto-dismiss timer\n  // Except if we just triggered this wake, in which case we want to ignore it\n  useEffect(() => {\n    const callback = () => {\n      if (awakingRef.current) awakingRef.current = false;\n      else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n    };\n    addSleepListener(\"wake\", callback);\n    return () => removeSleepListener(\"wake\", callback);\n  }, [addSleepListener, removeSleepListener]);\n\n  // Handle body clicks, dismissing the overlay if the user clicks outside of it\n  const bodyClick = useCallback((e: MouseEvent) => {\n    if (!visibleUnderCursor(e)) {\n      setVisibleOption(\"\");\n    }\n  }, []);\n\n  // If the user clicks anywhere in the body, except the overlay itself, close the panels\n  // Bind it during the capture phase so that we can process it before any other click handlers\n  useEffect(() => {\n    document.body.addEventListener(\"click\", bodyClick, true);\n    return () => document.body.removeEventListener(\"click\", bodyClick, true);\n  }, [bodyClick]);\n\n  // Handle body double clicks, ignoring them inside of overlay elements\n  const bodyDblClick = useCallback((e: MouseEvent) => {\n    if (visibleUnderCursor(e)) {\n      e.stopPropagation();\n    }\n  }, []);\n\n  // If the user double clicks anywhere in the overlay itself, stop propagating the event\n  // This stops double clicks from toggling fullscreen video which is the default behavior\n  useEffect(() => {\n    document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n    return () =>\n      document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n  }, [bodyDblClick]);\n\n  // Generate the context for the overlay options\n  const context = useMemo<OverlayOptionProps[\"context\"]>(\n    () => ({\n      activeAmbassador,\n      setActiveAmbassador,\n    }),\n    [activeAmbassador],\n  );\n\n  return (\n    <div\n      className={classes(\n        \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n        sleeping &&\n          !(\n            process.env.NODE_ENV === \"development\" &&\n            settings.disableOverlayHiding.value\n          ) &&\n          hiddenClass,\n      )}\n    >\n      <Buttons\n        options={overlayOptions}\n        onClick={setVisibleOption}\n        active={visibleOption}\n      />\n      <div className=\"relative h-full w-full\">\n        {overlayOptions.map((option) => (\n          <option.component\n            key={option.key}\n            context={context}\n            className={classes(\n              \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n              visibleOption !== option.key && hiddenClass,\n            )}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n\n'extension/src/pages/overlay/hooks/useSettings.tsx'\n:import {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n  type ReactNode,\n} from \"react\";\n\nimport {\n  typeSafeObjectEntries,\n  typeSafeObjectFromEntries,\n} from \"../../../utils/helpers\";\nimport { OverlayKey, isValidOverlayKey } from \"../components/overlay/Overlay\";\n\nconst settings = {\n  disableChatPopup: {\n    title: \"Prevent Mod-triggered Card Popups\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: true,\n  },\n  disableOverlayHiding: {\n    title: \"(DEV) Prevent app hiding automatically\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: process.env.NODE_ENV === \"development\",\n  },\n  openedMenu: {\n    title: \"Menu that was last opened\",\n    type: \"string\",\n    process: (value: any): OverlayKey => {\n      return isValidOverlayKey(value) ? value : \"ambassadors\";\n    },\n    configurable: false,\n  },\n};\n\ntype SettingsKey = keyof typeof settings;\n\ntype StoredSettings = {\n  [key in SettingsKey]: ReturnType<(typeof settings)[key][\"process\"]>;\n};\n\nexport type Settings = {\n  [key in SettingsKey]: (typeof settings)[key] & {\n    value: StoredSettings[key];\n    change: (value: StoredSettings[key]) => void;\n  };\n};\n\nconst context = createContext<Settings | undefined>(undefined);\n\nexport const SettingsProvider = ({ children }: { children: ReactNode }) => {\n  const [stored, setStored] = useState<StoredSettings>(() => {\n    // Load settings from local storage on mount, merging with defaults\n    const storage = JSON.parse(localStorage.getItem(\"settings\") || \"{}\");\n    return typeSafeObjectEntries(settings).reduce(\n      (acc, [key, value]) => ({ ...acc, [key]: value.process(storage[key]) }),\n      {} as StoredSettings,\n    );\n  });\n\n  // Save settings to local storage when they change\n  useEffect(() => {\n    localStorage.setItem(\"settings\", JSON.stringify(stored));\n  }, [stored]);\n\n  // Change the value of a setting\n  const change = useCallback(\n    <Key extends SettingsKey>(key: Key, value: StoredSettings[Key]) => {\n      setStored((current) => ({ ...current, [key]: value }));\n    },\n    [],\n  );\n\n  // Expose a full object for the settings\n  const obj = useMemo<Settings>(\n    () =>\n      typeSafeObjectFromEntries(\n        typeSafeObjectEntries(settings).map(([key, value]) => [\n          key,\n          {\n            ...value,\n            value: stored[key],\n            change: (value: any) => change(key, value),\n          },\n        ]),\n      ) as Settings,\n    [stored, change],\n  );\n\n  return <context.Provider value={obj}>{children}</context.Provider>;\n};\n\nconst useSettings = () => {\n  const ctx = useContext(context);\n  if (!ctx)\n    throw new Error(\"useSettings must be used within a SettingsProvider\");\n  return ctx;\n};\n\nexport default useSettings;\n\n",
        "called_code_segment": "const settings = {\n  disableChatPopup: {\n    title: \"Prevent Mod-triggered Card Popups\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: true,\n  },\n  disableOverlayHiding: {\n    title: \"(DEV) Prevent app hiding automatically\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: process.env.NODE_ENV === \"development\",\n  },\n  openedMenu: {\n    title: \"Menu that was last opened\",\n    type: \"string\",\n    process: (value: any): OverlayKey => {\n      return isValidOverlayKey(value) ? value : \"ambassadors\";\n    },\n    configurable: false,\n  },\n};\n\ntype SettingsKey = keyof typeof settings;\n\ntype StoredSettings = {\n  [key in SettingsKey]: ReturnType<(typeof settings)[key][\"process\"]>;\n};\n\nexport type Settings = {\n  [key in SettingsKey]: (typeof settings)[key] & {\n    value: StoredSettings[key];\n    change: (value: StoredSettings[key]) => void;\n  };\n};\n\nconst context = createContext<Settings | undefined>(undefined);\n\nexport const SettingsProvider = ({ children }: { children: ReactNode }) => {\n  const [stored, setStored] = useState<StoredSettings>(() => {\n    const storage = JSON.parse(localStorage.getItem(\"settings\") || \"{}\");\n    return typeSafeObjectEntries(settings).reduce(\n      (acc, [key, value]) => ({ ...acc, [key]: value.process(storage[key]) }), {}\n    );\n  });\n\n  useEffect(() => {\n    localStorage.setItem(\"settings\", JSON.stringify(stored));\n  }, [stored]);\n\n  const change = useCallback(<Key extends SettingsKey>(key: Key, value: StoredSettings[Key]) => {\n    setStored((current) => ({ ...current, [key]: value }));\n  }, []);\n\n  const obj = useMemo<Settings>(() =>\n    typeSafeObjectFromEntries(\n      typeSafeObjectEntries(settings).map(([key, value]) => [\n        key, {\n          ...value,\n          value: stored[key],\n          change: (value: any) => change(key, value),\n        },\n      ]),\n    ) as Settings,\n  [stored, change]);\n\n  return <context.Provider value={obj}>{children}</context.Provider>;\n};\n\nconst useSettings = () => {\n  const ctx = useContext(context);\n  if (!ctx) throw new Error(\"useSettings must be used within a SettingsProvider\");\n  return ctx;\n};\n\nexport default useSettings;",
        "invoking_code_segment": "const settings = useSettings();\nconst { sleeping, wake, on: addSleepListener, off: removeSleepListener } = useSleeping();\nconst [activeAmbassador, setActiveAmbassador] = useState<ActiveAmbassadorState>({});\nconst [visibleOption, setVisibleOption] = useState<OverlayKey>(settings.openedMenu.value);\nconst timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\nconst awakingRef = useRef(false);\n\nuseEffect(() => {\n  settings.openedMenu.change(visibleOption);\n}, [visibleOption]);\n\nuseEffect(() => {\n  setVisibleOption(settings.openedMenu.value);\n}, [settings.openedMenu.value]);\n\nuseChatCommand(\n  useCallback(\n    (command: string) => {\n      if (!settings.disableChatPopup.value) {\n        if (isAmbassadorKey(command))\n          setActiveAmbassador({ key: command, isCommand: true });\n        else if (command !== \"welcome\") return;\n\n        setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => {\n          setVisibleOption(\"\");\n          setActiveAmbassador({});\n        }, commandTimeout);\n\n        awakingRef.current = true;\n        wake(commandTimeout);\n      }\n    },\n    [settings.disableChatPopup.value, wake],\n  ),\n);\n\nuseEffect(() => {\n  const callback = () => {\n    if (awakingRef.current) awakingRef.current = false;\n    else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n  };\n  addSleepListener(\"wake\", callback);\n  return () => removeSleepListener(\"wake\", callback);\n}, [addSleepListener, removeSleepListener]);\n\nuseEffect(() => {\n  document.body.addEventListener(\"click\", bodyClick, true);\n  return () => document.body.removeEventListener(\"click\", bodyClick, true);\n}, [bodyClick]);\n\nuseEffect(() => {\n  document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n  return () => document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n}, [bodyDblClick]);\n\nconst context = useMemo<OverlayOptionProps[\"context\"]>(() => ({\n  activeAmbassador,\n  setActiveAmbassador,\n}), [activeAmbassador]);",
        "feature_description": "Add a new setting to control the overlay's transparency.",
        "detailed_feature_description": "A new setting named 'overlayTransparency' will be added to control the transparency of the overlay. This setting will be a number between 0 and 1, where 0 is fully transparent and 1 is fully opaque. The overlay component will use this setting to adjust its opacity.",
        "modified_complete_code": {
            "file1": "const settings = {\n  disableChatPopup: {\n    title: \"Prevent Mod-triggered Card Popups\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: true,\n  },\n  disableOverlayHiding: {\n    title: \"(DEV) Prevent app hiding automatically\",\n    type: \"boolean\",\n    process: (value: any) => !!value,\n    configurable: process.env.NODE_ENV === \"development\",\n  },\n  openedMenu: {\n    title: \"Menu that was last opened\",\n    type: \"string\",\n    process: (value: any): OverlayKey => {\n      return isValidOverlayKey(value) ? value : \"ambassadors\";\n    },\n    configurable: false,\n  },\n  #Modify overlayTransparency: {\n    title: \"Overlay Transparency\",\n    type: \"number\",\n    process: (value: any) => {\n      const num = parseFloat(value);\n      return isNaN(num) ? 1 : Math.max(0, Math.min(1, num));\n    },\n    configurable: true,\n  },\n};\n\ntype SettingsKey = keyof typeof settings;\n\ntype StoredSettings = {\n  [key in SettingsKey]: ReturnType<(typeof settings)[key][\"process\"]>;\n};\n\nexport type Settings = {\n  [key in SettingsKey]: (typeof settings)[key] & {\n    value: StoredSettings[key];\n    change: (value: StoredSettings[key]) => void;\n  };\n};\n\nconst context = createContext<Settings | undefined>(undefined);\n\nexport const SettingsProvider = ({ children }: { children: ReactNode }) => {\n  const [stored, setStored] = useState<StoredSettings>(() => {\n    const storage = JSON.parse(localStorage.getItem(\"settings\") || \"{}\");\n    return typeSafeObjectEntries(settings).reduce(\n      (acc, [key, value]) => ({ ...acc, [key]: value.process(storage[key]) }), {}\n    );\n  });\n\n  useEffect(() => {\n    localStorage.setItem(\"settings\", JSON.stringify(stored));\n  }, [stored]);\n\n  const change = useCallback(<Key extends SettingsKey>(key: Key, value: StoredSettings[Key]) => {\n    setStored((current) => ({ ...current, [key]: value }));\n  }, []);\n\n  const obj = useMemo<Settings>(() =>\n    typeSafeObjectFromEntries(\n      typeSafeObjectEntries(settings).map(([key, value]) => [\n        key, {\n          ...value,\n          value: stored[key],\n          change: (value: any) => change(key, value),\n        },\n      ]),\n    ) as Settings,\n  [stored, change]);\n\n  return <context.Provider value={obj}>{children}</context.Provider>;\n};\n\nconst useSettings = () => {\n  const ctx = useContext(context);\n  if (!ctx) throw new Error(\"useSettings must be used within a SettingsProvider\");\n  return ctx;\n};\n\nexport default useSettings;",
            "file2": "const settings = useSettings();\nconst { sleeping, wake, on: addSleepListener, off: removeSleepListener } = useSleeping();\nconst [activeAmbassador, setActiveAmbassador] = useState<ActiveAmbassadorState>({});\nconst [visibleOption, setVisibleOption] = useState<OverlayKey>(settings.openedMenu.value);\nconst timeoutRef = useRef<NodeJS.Timeout | undefined>(undefined);\nconst awakingRef = useRef(false);\n\nuseEffect(() => {\n  settings.openedMenu.change(visibleOption);\n}, [visibleOption]);\n\nuseEffect(() => {\n  setVisibleOption(settings.openedMenu.value);\n}, [settings.openedMenu.value]);\n\nuseChatCommand(\n  useCallback(\n    (command: string) => {\n      if (!settings.disableChatPopup.value) {\n        if (isAmbassadorKey(command))\n          setActiveAmbassador({ key: command, isCommand: true });\n        else if (command !== \"welcome\") return;\n\n        setVisibleOption(command === \"welcome\" ? \"welcome\" : \"ambassadors\");\n\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(() => {\n          setVisibleOption(\"\");\n          setActiveAmbassador({});\n        }, commandTimeout);\n\n        awakingRef.current = true;\n        wake(commandTimeout);\n      }\n    },\n    [settings.disableChatPopup.value, wake],\n  ),\n);\n\nuseEffect(() => {\n  const callback = () => {\n    if (awakingRef.current) awakingRef.current = false;\n    else if (timeoutRef.current) clearTimeout(timeoutRef.current);\n  };\n  addSleepListener(\"wake\", callback);\n  return () => removeSleepListener(\"wake\", callback);\n}, [addSleepListener, removeSleepListener]);\n\nuseEffect(() => {\n  document.body.addEventListener(\"click\", bodyClick, true);\n  return () => document.body.removeEventListener(\"click\", bodyClick, true);\n}, [bodyClick]);\n\nuseEffect(() => {\n  document.body.addEventListener(\"dblclick\", bodyDblClick, true);\n  return () => document.body.removeEventListener(\"dblclick\", bodyDblClick, true);\n}, [bodyDblClick]);\n\nconst context = useMemo<OverlayOptionProps[\"context\"]>(() => ({\n  activeAmbassador,\n  setActiveAmbassador,\n}), [activeAmbassador]);\n\n#Modify return (\n  <div\n    className={classes(\n      \"flex h-full w-full transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n      sleeping &&\n        !(process.env.NODE_ENV === \"development\" &&\n          settings.disableOverlayHiding.value) &&\n        hiddenClass,\n    )}\n    style={{ opacity: settings.overlayTransparency.value }}\n  >\n    <Buttons\n      options={overlayOptions}\n      onClick={setVisibleOption}\n      active={visibleOption}\n    />\n    <div className=\"relative h-full w-full\">\n      {overlayOptions.map((option) => (\n        <option.component\n          key={option.key}\n          context={context}\n          className={classes(\n            \"transition-[opacity,visibility,transform] will-change-[opacity,transform]\",\n            visibleOption !== option.key && hiddenClass,\n          )}\n        />\n      ))}\n    </div>\n  </div>\n);",
            "new_code": {
                "file1": "",
                "file2": ""
            }
        }
    },
    {
        "repo": "faunadb-fql-lib",
        "content": "'faunadb-fql-lib/src/functions/PaginateReverse.ts'\n:import { query as q, ExprVal, ExprArg } from \"faunadb\"\nimport { ArrayReverse } from \"./ArrayReverse\"\n\nexport const PaginateReverse = (set: ExprArg, opts: {} = {}): ExprVal =>\n    q.Let(\n        {\n            after: q.Select([\"before\"], opts, null),\n            before: q.Select([\"after\"], opts, null),\n            size: q.Select([\"size\"], opts, 64),\n            result: q.If(\n                q.And(q.IsNull(q.Var(\"after\")), q.IsNull(q.Var(\"before\"))),\n                q.Paginate(set, { before: [null], size: q.Var(\"size\") }),\n                q.If(\n                    q.IsNull(q.Var(\"after\")),\n                    q.Paginate(set, {\n                        before: q.Var(\"before\"),\n                        size: q.Var(\"size\"),\n                    }),\n                    q.Paginate(set, {\n                        after: q.Var(\"after\"),\n                        size: q.Var(\"size\"),\n                    })\n                )\n            ),\n        },\n        q.Let(\n            {\n                dataObj: {\n                    data: ArrayReverse(q.Select([\"data\"], q.Var(\"result\"))),\n                },\n                afterObj: q.If(\n                    q.ContainsPath([\"before\"], q.Var(\"result\")),\n                    { after: q.Select([\"before\"], q.Var(\"result\")) },\n                    {}\n                ),\n                beforeObj: q.If(\n                    q.Or(\n                        q.Not(q.ContainsPath([\"after\"], q.Var(\"result\"))),\n                        q.Equals(\n                            [null],\n                            q.Select([\"after\"], q.Var(\"result\"), null)\n                        )\n                    ),\n                    {},\n                    { before: q.Select([\"after\"], q.Var(\"result\")) }\n                ),\n            },\n            q.Merge(\n                q.Merge(q.Var(\"afterObj\"), q.Var(\"beforeObj\")),\n                q.Var(\"dataObj\")\n            )\n        )\n    )\n\n'faunadb-fql-lib/src/functions/GetAll.test.ts'\n:import { PaginateReverse } from \"./PaginateReverse\"\nimport { query as q } from \"faunadb\"\nimport { createClient } from \"./../../test/utils\"\nimport { GetAll } from \"./GetAll\"\n\ndescribe(\"GetAll\", () => {\n    const client = createClient()\n\n    test(\"get all works with Documents()\", async () => {\n        const res = await client.query(\n            q.Let(\n                {\n                    doc1: q.Create(q.Collection(\"Foos\"), {\n                        data: { foo: \"bar\" },\n                    }),\n                    doc2: q.Create(q.Collection(\"Foos\"), {\n                        data: { bar: \"foo\" },\n                    }),\n                },\n                {\n                    doc1: q.Var(\"doc1\"),\n                    doc2: q.Var(\"doc2\"),\n                    page: GetAll(\n                        PaginateReverse(q.Documents(q.Collection(\"Foos\")), {\n                            size: 2,\n                        })\n                    ),\n                }\n            )\n        )\n\n        const { doc1, doc2, page } = res\n\n        expect(doc1.ref.id).toBe(page.data[1].ref.id)\n        expect(doc2.ref.id).toBe(page.data[0].ref.id)\n    })\n})\n\n",
        "called_code_segment": "export const PaginateReverse = (set: ExprArg, opts: {} = {}): ExprVal =>\n    q.Let(\n        {\n            after: q.Select([\"before\"], opts, null),\n            before: q.Select([\"after\"], opts, null),\n            size: q.Select([\"size\"], opts, 64),\n            result: q.If(\n                q.And(q.IsNull(q.Var(\"after\")), q.IsNull(q.Var(\"before\"))),\n                q.Paginate(set, { before: [null], size: q.Var(\"size\") }),\n                q.If(\n                    q.IsNull(q.Var(\"after\")),\n                    q.Paginate(set, {\n                        before: q.Var(\"before\"),\n                        size: q.Var(\"size\"),\n                    }),\n                    q.Paginate(set, {\n                        after: q.Var(\"after\"),\n                        size: q.Var(\"size\"),\n                    })\n                )\n            ),\n        },\n        q.Let(\n            {\n                dataObj: {\n                    data: ArrayReverse(q.Select([\"data\"], q.Var(\"result\"))),\n                },\n                afterObj: q.If(\n                    q.ContainsPath([\"before\"], q.Var(\"result\")),\n                    { after: q.Select([\"before\"], q.Var(\"result\")) },\n                    {}\n                ),\n                beforeObj: q.If(\n                    q.Or(\n                        q.Not(q.ContainsPath([\"after\"], q.Var(\"result\"))),\n                        q.Equals(\n                            [null],\n                            q.Select([\"after\"], q.Var(\"result\"), null)\n                        )\n                    ),\n                    {},\n                    { before: q.Select([\"after\"], q.Var(\"result\")) }\n                ),\n            },\n            q.Merge(\n                q.Merge(q.Var(\"afterObj\"), q.Var(\"beforeObj\")),\n                q.Var(\"dataObj\")\n            )\n        )\n    )",
        "invoking_code_segment": "const res = await client.query(\n            q.Let(\n                {\n                    doc1: q.Create(q.Collection(\"Foos\"), {\n                        data: { foo: \"bar\" },\n                    }),\n                    doc2: q.Create(q.Collection(\"Foos\"), {\n                        data: { bar: \"foo\" },\n                    }),\n                },\n                {\n                    doc1: q.Var(\"doc1\"),\n                    doc2: q.Var(\"doc2\"),\n                    page: GetAll(\n                        PaginateReverse(q.Documents(q.Collection(\"Foos\")), {\n                            size: 2,\n                        })\n                    ),\n                }\n            )\n        )",
        "feature_description": "Add support for filtering the paginated results based on a predicate.",
        "detailed_feature_description": "Modify the PaginateReverse function to accept an optional predicate function. If provided, the function will filter the results before reversing the array. Update the GetAll function to pass the predicate to PaginateReverse if it is provided.",
        "modified_complete_code": {
            "PaginateReverse.ts": "export const PaginateReverse = (set: ExprArg, opts: {} = {}, predicate?: ExprArg): ExprVal =>\n    q.Let(\n        {\n            after: q.Select([\"before\"], opts, null),\n            before: q.Select([\"after\"], opts, null),\n            size: q.Select([\"size\"], opts, 64),\n            result: q.If(\n                q.And(q.IsNull(q.Var(\"after\")), q.IsNull(q.Var(\"before\"))),\n                q.Paginate(set, { before: [null], size: q.Var(\"size\") }),\n                q.If(\n                    q.IsNull(q.Var(\"after\")),\n                    q.Paginate(set, {\n                        before: q.Var(\"before\"),\n                        size: q.Var(\"size\"),\n                    }),\n                    q.Paginate(set, {\n                        after: q.Var(\"after\"),\n                        size: q.Var(\"size\"),\n                    })\n                )\n            ),\n        },\n        q.Let(\n            {\n                dataObj: {\n                    data: ArrayReverse(q.If(predicate, q.Filter(q.Select([\"data\"], q.Var(\"result\")), predicate), q.Select([\"data\"], q.Var(\"result\")))),\n                },\n                afterObj: q.If(\n                    q.ContainsPath([\"before\"], q.Var(\"result\")),\n                    { after: q.Select([\"before\"], q.Var(\"result\")) },\n                    {}\n                ),\n                beforeObj: q.If(\n                    q.Or(\n                        q.Not(q.ContainsPath([\"after\"], q.Var(\"result\"))),\n                        q.Equals(\n                            [null],\n                            q.Select([\"after\"], q.Var(\"result\"), null)\n                        )\n                    ),\n                    {},\n                    { before: q.Select([\"after\"], q.Var(\"result\")) }\n                ),\n            },\n            q.Merge(\n                q.Merge(q.Var(\"afterObj\"), q.Var(\"beforeObj\")),\n                q.Var(\"dataObj\")\n            )\n        )\n    )",
            "GetAll.test.ts": "const res = await client.query(\n            q.Let(\n                {\n                    doc1: q.Create(q.Collection(\"Foos\"), {\n                        data: { foo: \"bar\" },\n                    }),\n                    doc2: q.Create(q.Collection(\"Foos\"), {\n                        data: { bar: \"foo\" },\n                    }),\n                },\n                {\n                    doc1: q.Var(\"doc1\"),\n                    doc2: q.Var(\"doc2\"),\n                    page: GetAll(\n                        PaginateReverse(q.Documents(q.Collection(\"Foos\")), {\n                            size: 2,\n                        }, q.Lambda(\"x\", q.Equals(q.Select([\"data\", \"foo\"], q.Var(\"x\")), \"bar\")))\n                    ),\n                }\n            )\n        )"
        }
    },
    {
        "repo": "gemfab",
        "content": "'gemfab/test/bounds.ts'\n:export const bounds = {\n  gem: {\n    decimals: [21291, 21291],\n    mint: {\n      0: {0: [30481, 30481], 1: [70293, 70293]},\n      1: {                   1: [30481, 30481], 2: [36093, 36093]},\n    },\n    transfer: {\n      0: {\n        0: {0: [28385, 28385]},\n        1: {0: [46297, 46297], 1: [28385, 28385]},\n        2: {1: [51097, 51097]}\n      },\n      1: {\n        0: {0: [28385, 28385]},\n        1: {0: [29197, 29197], 1: [28385, 28385]},\n        2: {1: [33997, 33997]}\n      },\n      2: {\n        0: {0: [28385, 28385]},\n        1: {0: [29197, 29197], 1: [28385, 28385]},\n        2: {1: [33997, 33997]}\n      }\n    },\n    transferFrom: {\n      notMaxAllowance: {\n        0: {\n          0: {0: [33301, 33301]},\n          1: {0: [54013, 54013], 1: [33301, 33301]},\n          2: {1: [58813, 58813]}\n        },\n        1: {\n          0: {0: [33301, 33301]},\n          1: {0: [36913, 36913], 1: [33301, 33301]},\n          2: {1: [41713, 41713]}\n        },\n        2: {\n          0: {0: [33301, 33301]},\n          1: {0: [36913, 36913], 1: [33301, 33301]},\n          2: {1: [41713, 41713]}\n        }\n      },\n      maxAllowance: {\n        0: {\n          0: {0: [33301, 33301]},\n          1: {0: [49105, 49105], 1: [33301, 33301]},\n          2: {1: [53905, 53905]}\n        },\n        1: {\n          0: {0: [33301, 33301]},\n          1: {0: [32005, 32005], 1: [33301, 33301]},\n          2: {1: [36805, 36805]}\n        },\n        2: {\n          0: {0: [33301, 33301]},\n          1: {0: [32005, 32005], 1: [33301, 33301]},\n          2: {1: [36805, 36805]}\n        }\n      }\n    },\n    burn: {\n      0: {0: [30473, 30473]},\n      1: {0: [28868, 28868], 1: [30473, 30473]},\n      2: {1: [36085, 36085]}\n    },\n    approve: {\n      0: {0: [26134, 26134], 1: [46046, 46046]},\n      1: {0: [24134, 24134], 1: [26146, 26146], 2: [28946, 28946]},\n      2: {1: [28946, 28946]}\n    },\n    permit: {\n      0: {0: [54301, 54313], 1: [74201, 74225]},\n      1: {0: [35177, 35213], 1: [37213, 37225], 2: [40013, 40025]},\n      2: {1: [40013, 40025]}\n    },\n    ward: {\n      0: {0: [28302, 28302], 1: [48214, 48214]},\n      1: {0: [26302, 26302], 1: [28314, 28314]},\n    },\n  }\n  /*\n  0: {0: [0, 0], 1: [0, 0]},\n  1: {0: [0, 0], 1: [0, 0], 2: [0, 0]},\n  2: {           1: [0, 0]}\n   */\n}\n\n'gemfab/test/gemfab-test.ts'\n:import * as hh from 'hardhat'\nimport { ethers, artifacts, network } from 'hardhat'\nimport { want, send, fail, snapshot, revert, b32 } from 'minihat'\nconst { constants, BigNumber, utils } = ethers\n\nimport { test1D, test2D } from './helpers'\nimport { bounds as _bounds } from './bounds'\nconst bounds = _bounds.gem\nimport { TypedDataUtils } from 'ethers-eip712'\n\nconst { expectEvent } = require('./ERC20/helpers')\n\nconst dpack = require('@etherpacks/dpack')\n\nconst debug = require('debug')('gemfab:test')\n\nconst types = {\n   Permit: [\n      { name: 'owner',    type: 'address' },\n      { name: 'spender',  type: 'address' },\n      { name: 'value',    type: 'uint256' },\n      { name: 'nonce',    type: 'uint256' },\n      { name: 'deadline', type: 'uint256' }\n    ]\n};\n\nconst domain = {\n    name: 'GemPermit',\n    version: '0',\n    chainId: undefined,\n    verifyingContract: undefined\n};\n\ndescribe('gemfab', () => {\n  let chainId;\n  let ali, bob, cat\n  let ALI, BOB, CAT\n  let gem; let gem_type\n  let gemfab\n  before(async () => {\n    [ali, bob, cat] = await ethers.getSigners();\n    [ALI, BOB, CAT] = [ali, bob, cat].map(signer => signer.address)\n\n    const pack = await hh.run('deploy-gemfab', {writepack: 'true'})\n    const dapp = await dpack.load(pack, ethers, ali)\n    gem_type = dapp._types.Gem\n\n    gemfab = dapp.gemfab\n    const name = utils.formatBytes32String('Mock Cash');\n    const symbol = utils.formatBytes32String('CASH');\n    const gemaddr = await gemfab.callStatic.build(name, symbol)\n    const rx = await send(gemfab.build, name, symbol)\n    expectEvent(rx, 'Build', {caller: ALI, gem: gemaddr})\n    want(await gemfab.built(gemaddr)).true\n\n    gem = gem_type.attach(gemaddr)\n\n    await snapshot(hh)\n\n    chainId = await hh.network.config.chainId;\n\n    domain.chainId           = chainId;\n    domain.verifyingContract = gem.address;\n\n  })\n  beforeEach(async () => {\n    await revert(hh)\n  })\n\n  it('mint ward', async () => {\n    await send(gem.mint, ALI, 100)\n    const bal = await gem.balanceOf(ALI)\n    want(bal.toNumber()).equal(100)\n\n    const gembob = gem.connect(bob)\n    await fail('ErrWard', gembob.mint, BOB, 100)\n  })\n\n  it('burn underflow', async () => {\n      await send(gem.mint, ALI, 100);\n      await send(gem.mint, BOB, 100); // totalSupply wont be cause of underflow\n      await fail('ErrUnderflow', gem.burn, ALI, 101);\n  });\n\n  it('transferFrom self insufficient bal', async () => {\n    await send(gem.mint, BOB, 100);\n    const balbob = await gem.balanceOf(BOB);\n    const gembob = gem.connect(bob)\n    await send(gembob.approve, ALI, balbob + 1);\n    const alibob = gem.connect(ali)\n    await fail('ErrUnderflow', alibob.transferFrom, BOB, BOB, balbob + 1);\n  });\n\n  it('transfer self insufficient bal', async () => {\n      await send(gem.mint, ALI, 100);\n      await fail('ErrUnderflow', gem.transfer, ALI, await gem.balanceOf(ALI) + 1)\n  })\n\n  it('transferFrom self sufficient bal', async () => {\n    await send(gem.mint, BOB, 100);\n    const balbob = await gem.balanceOf(BOB);\n    const gembob = gem.connect(bob)\n    await send(gembob.approve, ALI, balbob);\n    const alibob = gem.connect(ali)\n    await send(alibob.transferFrom, BOB, BOB, balbob);\n    want((await gem.balanceOf(BOB)).toNumber()).equal(balbob.toNumber());\n  });\n\n  it('transferFrom max allowance no approval event', async () => {\n    await send(gem.mint, BOB, 100);\n    const amt = await gem.balanceOf(BOB);\n    await send(gem.connect(bob).approve, ALI, constants.MaxUint256);\n    const rx = await send(gem.connect(ali).transferFrom, BOB, CAT, amt);\n    try {\n        expectEvent(rx, 'Approval')\n        throw Error('transferFrom w max allowance emitted approval event')\n    } catch {}\n  })\n\n  describe('coverage', () => {\n    describe('mint', () => {\n      it('overflow', async function () {\n        await send(gem.mint, ALI, constants.MaxUint256.div(2));\n        await send(gem.mint, BOB, constants.MaxUint256.div(2))\n        await send(gem.mint, CAT, 1)\n        await fail('ErrOverflow', gem.mint, CAT, 1);\n      });\n    });\n\n    describe('approve', () => {\n      it('nonzero', async function () {\n        await send(gem.approve, BOB, 0);\n        want((await gem.allowance(ALI, BOB)).toNumber()).to.equal(0);\n        await send(gem.approve, BOB, 1);\n        want((await gem.allowance(ALI, BOB)).toNumber()).to.equal(1);\n      });\n    });\n  });\n\n  describe(' gas cost', () => {\n    async function check(gas, minGas, maxGas) {\n      await want(gas.toNumber()).to.be.at.most(maxGas);\n      if (gas.toNumber() < minGas) {\n        console.log(\"gas reduction: previous min=\", minGas, \" gas used=\", gas.toNumber());\n      }\n    }\n\n    it('decimals', async () => { // checking constant vs immutable -- no difference\n      const gas = await gem.estimateGas.decimals();\n      await check(gas, bounds.decimals[0], bounds.decimals[1])\n    });\n\n    const NOP = async () => {\n    }\n    {\n      const fill = async (prev, next) => {\n        return send(gem.mint, ALI, next - prev)\n      }\n      const clear = async (prev, next) => {\n        await send(gem.burn, ALI, prev - next)\n      }\n      const stay = async (prev) => {\n        return fill(prev, prev)\n      }\n      test1D('mint', NOP, fill, clear, stay, 1, 2, bounds.mint)\n    }\n\n    {\n      const fillDst = async (prev, next) => {\n        await send(gem.mint, BOB, next - prev)\n      }\n      const fill = async (prev, next) => {\n        await send(gem.mint, ALI, next - prev)\n      }\n      const clear = async (prev, next) => {\n        return send(gem.transfer, BOB, prev - next)\n      }\n      const stay = async (prev) => {\n        return clear(prev, prev)\n      }\n      test2D('transfer', NOP, fillDst, fill, clear, stay, 1, 2, bounds.transfer)\n    }\n\n    {\n      const fillDst = async (prev, next) => {\n        await send(gem.mint, BOB, next - prev)\n      }\n      const fill = async (prev, next) => {\n        await send(gem.mint, ALI, next - prev)\n      }\n      const clear = (maxAllow) => async (prev, next) => {\n        const max = constants.MaxUint256\n        // approve is always nonzero->nonzero for now\n        await send(gem.approve, BOB, maxAllow ? max : max.sub(1));\n        // tx with msg.sender == bob to account for tokens that treat allowance(a, a) == inf\n        return send(gem.connect(bob).transferFrom, ALI, BOB, prev - next)\n      }\n      const stay = async (prev) => {\n        return send(gem.connect(bob).transferFrom, ALI, BOB, 0)\n      }\n      test2D(\n        'transferFrom sub-max allowance', NOP, fillDst,\n        fill, clear(false), stay,\n        1, 2, bounds.transferFrom.notMaxAllowance\n      )\n      test2D(\n        'transferFrom max allowance', NOP, fillDst,\n        fill, clear(true), stay,\n        1, 2, bounds.transferFrom.maxAllowance\n      )\n    }\n\n    {\n      const fill = async (prev, next) => {\n        await send(gem.mint, ALI, next - prev)\n      }\n      const clear = async (prev, next) => {\n        return send(gem.burn, ALI, prev - next)\n      }\n      const stay = async (prev) => {\n        return clear(prev, prev)\n      }\n      test1D('burn', NOP, fill, clear, stay, 1, 2, bounds.burn)\n    }\n\n    {\n      const fill = async (prev, next) => {\n        return send(gem.approve, ALI, next)\n      }\n      const clear = fill\n      const stay = async (prev) => {\n        return fill(prev, prev)\n      }\n      test1D('approve', NOP, fill, clear, stay, 1, 2, bounds.approve)\n    }\n\n    {\n      const deadline = Math.floor(Date.now() / 1000) * 2;\n      const fill = async (prev, next) => {\n        const value = {\n          owner: ALI,\n          spender: BOB,\n          value: next,\n          nonce: await gem.nonces(ALI),\n          deadline: deadline\n        };\n        const signature = await ali._signTypedData(domain, types, value);\n        const sig = ethers.utils.splitSignature(signature)\n\n        return send(gem.permit, ALI, BOB, value.value, deadline, sig.v, sig.r, sig.s);\n      }\n      const clear = fill\n      const stay = async (prev) => {\n        return fill(prev, prev)\n      }\n      test1D('permit', NOP, fill, clear, stay, 1, 2, bounds.permit)\n    }\n\n    {\n      const fill = async (prev, next) => {\n        return send(gem.ward, BOB, next)\n      }\n      const clear = fill\n      const stay = async (prev) => {\n        return fill(prev, prev)\n      }\n      test1D('ward', NOP, fill, clear, stay, true, undefined, bounds.ward)\n    }\n  });\n\n  describe('rely/deny', () => {\n    it('rely/deny permissions', async function () {\n      await fail('ErrWard', gem.connect(bob).ward, ALI, false);\n      await fail('ErrWard', gem.connect(bob).ward, BOB, false);\n      await fail('ErrWard', gem.connect(bob).ward, ALI, true);\n      await fail('ErrWard', gem.connect(bob).ward, BOB, true);\n      want(await gem.wards(ALI)).to.equal(true);\n      await send(gem.ward, BOB, false);\n      want(await gem.wards(ALI)).to.equal(true);\n      want(await gem.wards(BOB)).to.equal(false);\n      await send(gem.ward, BOB, true);\n      want(await gem.wards(ALI)).to.equal(true);\n      want(await gem.wards(BOB)).to.equal(true);\n      await send(gem.ward, BOB, false);\n      want(await gem.wards(ALI)).to.equal(true);\n      want(await gem.wards(BOB)).to.equal(false);\n      await send(gem.ward, ALI, false);\n      //lockout\n      want(await gem.wards(ALI)).to.equal(false);\n      want(await gem.wards(BOB)).to.equal(false);\n      await fail('ErrWard', gem.ward, ALI, true);\n      await fail('ErrWard', gem.connect(bob).ward, ALI, true);\n    });\n\n    it('lockout example', async function () {\n      await send(gem.mint, ALI, 1);\n      await gem.connect(bob).ward(ALI, false).then((res) => {}, (err) => {});\n      await send(gem.mint, ALI, 1);\n    });\n\n    it('burn', async function () {\n      await send(gem.mint, ALI, 1);\n      await fail('ErrWard', gem.connect(bob).burn, ALI, 1);\n      await send(gem.ward, BOB, true);\n      await send(gem.connect(bob).burn, ALI, 1);\n    });\n\n    it('mint', async function () {\n      await fail('ErrWard', gem.connect(bob).burn, ALI, 1);\n      await send(gem.ward, BOB, true);\n      await send(gem.connect(bob).mint, ALI, 1);\n    });\n\n    it('public methods', async function () {\n      const amt = 42;\n      const nonce = 0;\n      const deadline = Math.floor(Date.now() / 1000) * 2;\n      const value = {\n        owner:    ALI,\n        spender:  BOB,\n        value:    amt,\n        nonce:    nonce,\n        deadline: deadline\n      };\n      await send(gem.mint, ALI, 100);\n      await send(gem.transfer, BOB, 100);\n      const gembob = gem.connect(bob);\n\n      // pass with bob denied\n      await send(gem.ward, BOB, false);\n      await send(gembob.transfer, ALI, 1);\n      await send(gembob.approve, ALI, 1);\n      await send(gembob.approve, BOB, 1);\n      await send(gembob.transferFrom, BOB, ALI, 1);\n      let signature = await ali._signTypedData(domain, types, value);\n      let sig       = ethers.utils.splitSignature(signature)\n      await send(gem.connect(bob).permit, ALI, BOB, amt, deadline, sig.v, sig.r, sig.s);\n\n      // pass with bob relied\n      await send(gem.ward, BOB, true);\n      await send(gembob.transfer, ALI, 1);\n      await send(gembob.approve, ALI, 1);\n      await send(gembob.approve, BOB, 1);\n      await send(gembob.transferFrom, BOB, ALI, 1);\n      value.nonce++;\n      signature = await ali._signTypedData(domain, types, value);\n      sig       = ethers.utils.splitSignature(signature)\n      await send(gem.connect(bob).permit, ALI, BOB, amt, deadline, sig.v, sig.r, sig.s);\n    });\n\n  });\n\n  it('code doesnt change bc we dont use any immutable (in-code) vars', async()=>{\n    const name = utils.formatBytes32String('other');\n    const symbol = utils.formatBytes32String('OTHER');\n    const gem2addr = await gemfab.callStatic.build(name, symbol)\n    await send(gemfab.build, name, symbol)\n    const gem2 = gem_type.attach(gem2addr)\n    const gem_code = await ethers.provider.getCode(gem.address);\n    const gem2_code = await ethers.provider.getCode(gem2.address);\n    want(gem_code).eq(gem2_code);\n  })\n})\n\n",
        "called_code_segment": "async function check(gas, minGas, maxGas) {\n  await want(gas.toNumber()).to.be.at.most(maxGas);\n  if (gas.toNumber() < minGas) {\n    console.log(\"gas reduction: previous min=\", minGas, \" gas used=\", gas.toNumber());\n  }\n}",
        "invoking_code_segment": "it('decimals', async () => {\n  const gas = await gem.estimateGas.decimals();\n  await check(gas, bounds.decimals[0], bounds.decimals[1])\n});",
        "feature_description": "Add logging for gas usage exceeding the maximum threshold.",
        "detailed_feature_description": "Modify the `check` function to log a message when the gas usage exceeds the maximum threshold. Update the corresponding test in #file 2 to handle this new logging feature.",
        "modified_complete_code": {
            "file1": "async function check(gas, minGas, maxGas) {\n  await want(gas.toNumber()).to.be.at.most(maxGas);\n  if (gas.toNumber() < minGas) {\n    console.log(\"gas reduction: previous min=\", minGas, \" gas used=\", gas.toNumber());\n  }\n  #Modify if (gas.toNumber() > maxGas) {\n    console.log(\"gas exceeded: max gas=\", maxGas, \" gas used=\", gas.toNumber());\n  }\n}",
            "file2": "it('decimals', async () => {\n  const gas = await gem.estimateGas.decimals();\n  await check(gas, bounds.decimals[0], bounds.decimals[1])\n});"
        }
    },
    {
        "repo": "gitsub",
        "content": "'gitsub/src/App.tsx'\n:import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nimport Header from './containers/Header/Header';\nimport Footer from './containers/Footer/Footer';\nimport Menu from './containers/Menu/Menu';\nimport Unsubscribe from './containers/Unsubscribe/Unsubscribe';\nimport Subscribe from './containers/Subscribe/Subscribe';\nimport Followers from './containers/Followers/Followers';\nimport Alert from './containers/Alert/Alert';\n\nimport { SUBSCRIBE, UNSUBSCRIBE, FOLLOWERS, ROOT } from './utils/routes';\n\nimport s from './App.module.css';\n\nconst App = () => {\n  return (\n    <div className={s.app}>\n      <div className={s.container}>\n        <Router>\n          <Header />\n          <div className={s.page}>\n            <Menu />\n            <div className={s.content}>\n              <Switch>\n                <Route path={UNSUBSCRIBE} component={Unsubscribe} />\n                <Route path={FOLLOWERS} component={Followers} />\n                <Route path={SUBSCRIBE} component={Subscribe} />\n                <Route exact path={ROOT} component={Subscribe} />\n              </Switch>\n            </div>\n          </div>\n          <Alert />\n        </Router>\n      </div>\n      <Footer />\n    </div>\n  );\n};\n\nexport default App;\n\n'gitsub/src/App.test.ts'\n:import React from 'react';\nimport { render } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  const { getByText } = render(<App />);\n  const linkElement = getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n\n",
        "called_code_segment": "const App = () => {\n  return (\n    <div className={s.app}>\n      <div className={s.container}>\n        <Router>\n          <Header />\n          <div className={s.page}>\n            <Menu />\n            <div className={s.content}>\n              <Switch>\n                <Route path={UNSUBSCRIBE} component={Unsubscribe} />\n                <Route path={FOLLOWERS} component={Followers} />\n                <Route path={SUBSCRIBE} component={Subscribe} />\n                <Route exact path={ROOT} component={Subscribe} />\n              </Switch>\n            </div>\n          </div>\n          <Alert />\n        </Router>\n      </div>\n      <Footer />\n    </div>\n  );\n};\n\nexport default App;",
        "invoking_code_segment": "import App from './App';\n\ntest('renders learn react link', () => {\n  const { getByText } = render(<App />);\n  const linkElement = getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});",
        "feature_description": "Add a new route for a 'Settings' page and update the App component to include this route.",
        "detailed_feature_description": "A new route for the 'Settings' page will be added to the App component. This route will be accessible via the '/settings' path. The corresponding code in the test file will be updated to ensure that the new route is correctly rendered.",
        "modified_complete_code": {
            "App.tsx": "import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nimport Header from './containers/Header/Header';\nimport Footer from './containers/Footer/Footer';\nimport Menu from './containers/Menu/Menu';\nimport Unsubscribe from './containers/Unsubscribe/Unsubscribe';\nimport Subscribe from './containers/Subscribe/Subscribe';\nimport Followers from './containers/Followers/Followers';\nimport Alert from './containers/Alert/Alert';\nimport Settings from './containers/Settings/Settings'; #New\n\nimport { SUBSCRIBE, UNSUBSCRIBE, FOLLOWERS, ROOT, SETTINGS } from './utils/routes'; #Modify\n\nimport s from './App.module.css';\n\nconst App = () => {\n  return (\n    <div className={s.app}>\n      <div className={s.container}>\n        <Router>\n          <Header />\n          <div className={s.page}>\n            <Menu />\n            <div className={s.content}>\n              <Switch>\n                <Route path={UNSUBSCRIBE} component={Unsubscribe} />\n                <Route path={FOLLOWERS} component={Followers} />\n                <Route path={SUBSCRIBE} component={Subscribe} />\n                <Route path={SETTINGS} component={Settings} /> #Modify\n                <Route exact path={ROOT} component={Subscribe} />\n              </Switch>\n            </div>\n          </div>\n          <Alert />\n        </Router>\n      </div>\n      <Footer />\n    </div>\n  );\n};\n\nexport default App;",
            "App.test.ts": "import React from 'react';\nimport { render } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  const { getByText } = render(<App />);\n  const linkElement = getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n\ntest('renders settings page', () => {\n  const { getByText } = render(<App />);\n  const settingsElement = getByText(/settings/i); #New\n  expect(settingsElement).toBeInTheDocument(); #New\n});"
        }
    },
    {
        "repo": "heartStoneLibApp",
        "content": "'heartStoneLibApp/src/app/tabs/tabs.page.ts'\n:import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-tabs',\n  templateUrl: 'tabs.page.html',\n  styleUrls: ['tabs.page.scss']\n})\nexport class TabsPage {}\n\n'heartStoneLibApp/src/app/tabs/tabs.page.spec.ts'\n:import { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\nimport { async, ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { TabsPage } from './tabs.page';\n\ndescribe('TabsPage', () => {\n  let component: TabsPage;\n  let fixture: ComponentFixture<TabsPage>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [TabsPage],\n      schemas: [CUSTOM_ELEMENTS_SCHEMA],\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(TabsPage);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n\n",
        "called_code_segment": "@Component({\n  selector: 'app-tabs',\n  templateUrl: 'tabs.page.html',\n  styleUrls: ['tabs.page.scss']\n})\nexport class TabsPage {}",
        "invoking_code_segment": "describe('TabsPage', () => {\n  let component: TabsPage;\n  let fixture: ComponentFixture<TabsPage>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [TabsPage],\n      schemas: [CUSTOM_ELEMENTS_SCHEMA],\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(TabsPage);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});",
        "feature_description": "Add a lifecycle hook to the TabsPage component.",
        "detailed_feature_description": "Add the ngOnInit lifecycle hook to the TabsPage component to perform initialization tasks when the component is initialized. Update the test to check if the ngOnInit method is called.",
        "modified_complete_code": {
            "tabs.page.ts": "@Component({\n  selector: 'app-tabs',\n  templateUrl: 'tabs.page.html',\n  styleUrls: ['tabs.page.scss']\n})\nexport class TabsPage implements OnInit { #Modify\n  ngOnInit() {\n    console.log('TabsPage initialized');\n  } #New\n}",
            "tabs.page.spec.ts": "describe('TabsPage', () => {\n  let component: TabsPage;\n  let fixture: ComponentFixture<TabsPage>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [TabsPage],\n      schemas: [CUSTOM_ELEMENTS_SCHEMA],\n    }).compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(TabsPage);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n\n  it('should call ngOnInit', () => {\n    spyOn(component, 'ngOnInit');\n    component.ngOnInit();\n    expect(component.ngOnInit).toHaveBeenCalled();\n  }); #New\n});"
        }
    },
    {
        "repo": "josn",
        "content": "'josn/src/commands/defaultCommand/josnOutput.ts'\n:import { CmdOptions } from \"josnlib\";\n\n\n\nexport function josnOutput (currentJo: any, cmdOptions: CmdOptions) {\n\t// default indentation is 1 TAB\n\tlet indentation: string|number = \"\\t\";\n\tif (cmdOptions.minify) indentation = 0;\n\telse if (cmdOptions.spaces2) indentation = 2;\n\telse if (cmdOptions.spaces4) indentation = 4;\n\telse if (cmdOptions.tabs) indentation = \"\\t\";\n\n\tif (cmdOptions.table) {\n\t\tconsole.table(currentJo);\n\t} else if (cmdOptions.console) {\n\t\t// this happens by default anyway\n\t\tconsole.log(currentJo);\n\t} else if (cmdOptions.dir) {\n\t\tconsole.dir(currentJo);\n\t} else if (cmdOptions.plaintext) {\n\t\tconst currentJoString = JSON.stringify(currentJo, null, indentation);\n\t\tconsole.log(currentJoString);\n\t} else {\n\t\t// directly log the object by default\n\t\tconsole.log(currentJo);\n\t}\n}\n\n'josn/src/commands/defaultCommand/defaultCommand.ts'\n:import { CmdOptions, josn } from \"josnlib\";\nimport { parseJsonFile } from './parse';\nimport { josnOutput } from './josnOutput';\nimport { getInputFilePath } from './getInputFilePath';\n\n\n\nexport function defaultCommand (cmdOptions: CmdOptions, nonFlagArgs: string[]) {\n\tconst [inputPath=null, ...keyArgs] = nonFlagArgs;\n\tif (inputPath === null) {\n\t\tconsole.log(\"Input path NOT provided!\");\n\t\tconsole.log(\"Usage:\");\n\t\tconsole.log(\"\\tjosn data.json key1 index1 key2 index2\");\n\t\treturn;\n\t}\n\n\tconst jsonPath = getInputFilePath(inputPath);\n\tif (jsonPath === null) {\n\t\treturn;\n\t}\n\n\tconst jo: any = parseJsonFile(jsonPath);\n\tif (jo === null) {\n\t\tconsole.log(`Couldn't parse file: '${jsonPath}'`);\n\t\treturn;\n\t}\n\n\tconst currentJo = josn(jo, keyArgs, cmdOptions);\n\tif (!currentJo) {\n\t\treturn;\n\t}\n\n\tjosnOutput(currentJo, cmdOptions);\n}\n\n",
        "called_code_segment": "export function josnOutput (currentJo: any, cmdOptions: CmdOptions) {\n\t// default indentation is 1 TAB\n\tlet indentation: string|number = \"\\t\";\n\tif (cmdOptions.minify) indentation = 0;\n\telse if (cmdOptions.spaces2) indentation = 2;\n\telse if (cmdOptions.spaces4) indentation = 4;\n\telse if (cmdOptions.tabs) indentation = \"\\t\";\n\n\tif (cmdOptions.table) {\n\t\tconsole.table(currentJo);\n\t} else if (cmdOptions.console) {\n\t\t// this happens by default anyway\n\t\tconsole.log(currentJo);\n\t} else if (cmdOptions.dir) {\n\t\tconsole.dir(currentJo);\n\t} else if (cmdOptions.plaintext) {\n\t\tconst currentJoString = JSON.stringify(currentJo, null, indentation);\n\t\tconsole.log(currentJoString);\n\t} else {\n\t\t// directly log the object by default\n\t\tconsole.log(currentJo);\n\t}\n}",
        "invoking_code_segment": "const currentJo = josn(jo, keyArgs, cmdOptions);\nif (!currentJo) {\n\treturn;\n}\n\njosnOutput(currentJo, cmdOptions);",
        "feature_description": "Add a new option to output the JSON data to a file.",
        "detailed_feature_description": "Modify the `josnOutput` function to handle a new command option `outputFile` which specifies a file path to write the JSON data. If this option is provided, the function will write the JSON data to the specified file instead of printing it to the console.",
        "modified_complete_code": {
            "josnOutput.ts": "export function josnOutput (currentJo: any, cmdOptions: CmdOptions) {\n\t// default indentation is 1 TAB\n\tlet indentation: string|number = \"\\t\";\n\tif (cmdOptions.minify) indentation = 0;\n\telse if (cmdOptions.spaces2) indentation = 2;\n\telse if (cmdOptions.spaces4) indentation = 4;\n\telse if (cmdOptions.tabs) indentation = \"\\t\";\n\n\tif (cmdOptions.outputFile) {\n\t\t#Modify const currentJoString = JSON.stringify(currentJo, null, indentation);\n\t\t#Modify const fs = require('fs');\n\t\t#Modify fs.writeFileSync(cmdOptions.outputFile, currentJoString);\n\t\t#Modify console.log(`JSON data written to ${cmdOptions.outputFile}`);\n\t} else if (cmdOptions.table) {\n\t\tconsole.table(currentJo);\n\t} else if (cmdOptions.console) {\n\t\t// this happens by default anyway\n\t\tconsole.log(currentJo);\n\t} else if (cmdOptions.dir) {\n\t\tconsole.dir(currentJo);\n\t} else if (cmdOptions.plaintext) {\n\t\tconst currentJoString = JSON.stringify(currentJo, null, indentation);\n\t\tconsole.log(currentJoString);\n\t} else {\n\t\t// directly log the object by default\n\t\tconsole.log(currentJo);\n\t}\n}",
            "defaultCommand.ts": "const currentJo = josn(jo, keyArgs, cmdOptions);\nif (!currentJo) {\n\treturn;\n}\n\njosnOutput(currentJo, cmdOptions);"
        }
    },
    {
        "repo": "lobby-demo",
        "content": "'lobby-demo/components/Cursor.tsx'\n:import React from 'react';\n\ntype Props = {\n    color: string;\n    x: number;\n    y: number;\n};\n\nexport default function Cursor({ color, x, y }: Props) {\n    return (\n        <svg\n            style={{\n                position: 'absolute',\n                left: 0,\n                top: 0,\n                transition: 'transform 0.5s cubic-bezier(.17,.93,.38,1)',\n                transform: `translateX(${x}px) translateY(${y}px)`,\n            }}\n            width=\"24\"\n            height=\"36\"\n            viewBox=\"0 0 24 36\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\">\n            <path\n                d=\"M5.65376 12.3673H5.46026L5.31717 12.4976L0.500002 16.8829L0.500002 1.19841L11.7841 12.3673H5.65376Z\"\n                fill={color}\n            />\n        </svg>\n    );\n}\n\n'lobby-demo/pages/index.tsx'\n:import { createClient } from '@liveblocks/client';\nimport Cursor from '../components/Cursor';\nimport { getBgColorForRoom } from '../utils';\nimport { LiveblocksProvider, useMyPresence, useOthers, useRoom } from '@liveblocks/react';\n\n// NOTE: This API would eventually ship as part of @liveblocks/react\nimport LobbyProvider from '../components/LobbyRoomProvider';\n\nconst client = createClient({ \n    publicApiKey: 'pk_live_Mbzpk5Pk3147D0jgDvycwtXr', \n});\n\ntype Cursor = {\n    x: number;\n    y: number;\n};\n\ntype Presence = {\n    cursor: Cursor | null;\n};\n\nconst initialPresence: Presence = { cursor: null };\n\n// Flying cursor colors\nconst COLORS = [\n    '#E57373',\n    '#9575CD',\n    '#4FC3F7',\n    '#81C784',\n    '#FFF176',\n    '#FF8A65',\n    '#F06292',\n    '#7986CB',\n];\n\nfunction CursorDemo() {\n    const room = useRoom();\n\n    /**\n     * useMyPresence returns the presence of the current user and a function to update it.\n     * updateMyPresence is different than the setState function returned by the useState hook from React.\n     * You don't need to pass the full presence object to update it.\n     * See https://liveblocks.io/docs/api-reference/liveblocks-react#useMyPresence for more information\n     */\n    const [, updateMyPresence] = useMyPresence<Presence>();\n\n    /**\n     * Return all the other users in the room and their presence (a cursor position in this case)\n     */\n    const others = useOthers<Presence>();\n\n    return (\n        <main\n            className=\"relative w-full h-screen flex place-content-center place-items-center\"\n            style={{ backgroundColor: getBgColorForRoom(room.id) }}\n            onPointerMove={(event) =>\n                // Update the user cursor position on every pointer move\n                updateMyPresence({\n                    cursor: {\n                        x: Math.round(event.clientX),\n                        y: Math.round(event.clientY),\n                    },\n                })\n            }\n            onPointerLeave={() =>\n                // When the pointer goes out, set cursor to null\n                updateMyPresence({\n                    cursor: null,\n                })\n            }>\n            <div className=\"max-w-sm h-32 text-center space-y-5\">\n                {others.count === 0 ? (\n                    <p>You are currently alone in this room.</p>\n                ) : (\n                    <p>\n                        You are in this room together with <strong>{others.count}</strong>{' '}\n                        others. Move your cursor to say hi to them!\n                    </p>\n                )}\n                <p className=\"text-sm\">\n                    You were auto-assigned to room{' '}\n                    <code className=\"text-xs font-bold\">{room.id}</code>.\n                </p>\n            </div>\n\n            {\n                /**\n                 * Iterate over other users and display a cursor based on their presence\n                 */\n                others.map(({ connectionId, presence }) => {\n                    if (presence == null || presence.cursor == null) {\n                        return null;\n                    }\n\n                    return (\n                        <Cursor\n                            key={`cursor-${connectionId}`}\n                            // connectionId is an integer that is incremented at every new connections\n                            // Assigning a color with a modulo makes sure that a specific user has the same colors on every clients\n                            color={COLORS[connectionId % COLORS.length]}\n                            x={presence.cursor.x}\n                            y={presence.cursor.y}\n                        />\n                    );\n                })\n            }\n        </main>\n    );\n}\n\nconst StaticPropsDetail = () => {\n    return (\n        <LiveblocksProvider client={client}>\n            {/*\n                // Classic setup!\n                <RoomProvider id=\"demo\" initialPresence={initialPresence}>\n                    <CursorDemo />\n                </RoomProvider>\n            */}\n            <LobbyProvider lobbyId=\"demo\" initialPresence={initialPresence}>\n                <CursorDemo />\n            </LobbyProvider>\n        </LiveblocksProvider>\n    );\n};\n\nexport default StaticPropsDetail;\n\n",
        "called_code_segment": "export default function Cursor({ color, x, y }: Props) {\n    return (\n        <svg\n            style={{...\n            }}\n            width=\"24\"\n            height=\"36\"\n            viewBox=\"0 0 24 36\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\">\n            <path\n                d=\"M5.65376 12.3673H5.46026L5.31717 12.4976L0.500002 16.8829L0.500002 1.19841L11.7841 12.3673H5.65376Z\"\n                fill={color}\n            />\n        </svg>\n    );\n}",
        "invoking_code_segment": "others.map(({ connectionId, presence }) => {\n                    if (presence == null || presence.cursor == null) {\n                        return null;\n                    }\n\n                    return (\n                        <Cursor\n                            key={`cursor-${connectionId}`}\n                            color={COLORS[connectionId % COLORS.length]}\n                            x={presence.cursor.x}\n                            y={presence.cursor.y}\n                        />\n                    );\n                })",
        "feature_description": "Add a feature to display the user's name next to their cursor.",
        "detailed_feature_description": "Modify the Cursor component to accept a name prop and display it next to the cursor. Update the invoking code to pass the user's name to the Cursor component.",
        "modified_complete_code": {
            "lobby-demo/components/Cursor.tsx": "export default function Cursor({ color, x, y, name }: Props) {\n    return (\n        <div style={{ position: 'absolute', left: x, top: y, display: 'flex', alignItems: 'center' }}>\n            <svg\n                style={{...\n                }}\n                width=\"24\"\n                height=\"36\"\n                viewBox=\"0 0 24 36\"\n                fill=\"none\"\n                xmlns=\"http://www.w3.org/2000/svg\">\n                <path\n                    d=\"M5.65376 12.3673H5.46026L5.31717 12.4976L0.500002 16.8829L0.500002 1.19841L11.7841 12.3673H5.65376Z\"\n                    fill={color}\n                />\n            </svg>\n            <span style={{ color, marginLeft: '5px' }}>{name}</span>\n        </div>\n    );\n}",
            "lobby-demo/pages/index.tsx": "others.map(({ connectionId, presence }) => {\n                    if (presence == null || presence.cursor == null) {\n                        return null;\n                    }\n\n                    return (\n                        <Cursor\n                            key={`cursor-${connectionId}`}\n                            color={COLORS[connectionId % COLORS.length]}\n                            x={presence.cursor.x}\n                            y={presence.cursor.y}\n                            name={`User ${connectionId}`} #New\n                        />\n                    );\n                })"
        }
    },
    {
        "repo": "nextui-dashboard",
        "content": "'nextui-dashboard/components/breadcrumb/breadcrumb.styled.ts'\n:import {Link, styled} from '@nextui-org/react';\n\nexport const Breadcrumbs = styled('ul', {\n   listStyle: 'none',\n   display: 'flex',\n   gap: '$4',\n   padding: 0,\n   mx: 0,\n});\n\nexport const CrumbLink = styled(Link, {\n   color: '$accents8',\n});\n\nexport const Crumb = styled('li', {\n   'display': 'flex',\n   'flexDirection': 'row',\n   'alignItems': 'center',\n   'gap': '$2',\n   '&:last-of-type:after': {\n      content: '',\n      padding: 0,\n   },\n\n   '&:last-child': {\n      '& > a': {\n         color: '$accents9',\n         cursor: 'default',\n         pointerEvents: 'none',\n      },\n   },\n});\n\n'nextui-dashboard/components/accounts/index.tsx'\n:import {Button, Input, Text} from '@nextui-org/react';\nimport Link from 'next/link';\nimport React from 'react';\nimport {Breadcrumbs, Crumb, CrumbLink} from '../breadcrumb/breadcrumb.styled';\nimport {DotsIcon} from '../icons/accounts/dots-icon';\nimport {ExportIcon} from '../icons/accounts/export-icon';\nimport {InfoIcon} from '../icons/accounts/info-icon';\nimport {TrashIcon} from '../icons/accounts/trash-icon';\nimport {HouseIcon} from '../icons/breadcrumb/house-icon';\nimport {UsersIcon} from '../icons/breadcrumb/users-icon';\nimport {SettingsIcon} from '../icons/sidebar/settings-icon';\nimport {Flex} from '../styles/flex';\nimport {TableWrapper} from '../table/table';\nimport {AddUser} from './add-user';\n\nexport const Accounts = () => {\n   return (\n      <Flex\n         css={{\n            'mt': '$5',\n            'px': '$6',\n            '@sm': {\n               mt: '$10',\n               px: '$16',\n            },\n         }}\n         justify={'center'}\n         direction={'column'}\n      >\n         <Breadcrumbs>\n            <Crumb>\n               <HouseIcon />\n               <Link href={'/'}>\n                  <CrumbLink href=\"#\">Home</CrumbLink>\n               </Link>\n               <Text>/</Text>\n            </Crumb>\n\n            <Crumb>\n               <UsersIcon />\n               <CrumbLink href=\"#\">Users</CrumbLink>\n               <Text>/</Text>\n            </Crumb>\n            <Crumb>\n               <CrumbLink href=\"#\">List</CrumbLink>\n            </Crumb>\n         </Breadcrumbs>\n\n         <Text h3>All Accounts</Text>\n         <Flex\n            css={{gap: '$8'}}\n            align={'center'}\n            justify={'between'}\n            wrap={'wrap'}\n         >\n            <Flex\n               css={{\n                  'gap': '$6',\n                  'flexWrap': 'wrap',\n                  '@sm': {flexWrap: 'nowrap'},\n               }}\n               align={'center'}\n            >\n               <Input\n                  css={{width: '100%', maxW: '410px'}}\n                  placeholder=\"Search users\"\n               />\n               <SettingsIcon />\n               <TrashIcon />\n               <InfoIcon />\n               <DotsIcon />\n            </Flex>\n            <Flex direction={'row'} css={{gap: '$6'}} wrap={'wrap'}>\n               <AddUser />\n               <Button auto iconRight={<ExportIcon />}>\n                  Export to CSV\n               </Button>\n            </Flex>\n         </Flex>\n\n         <TableWrapper />\n      </Flex>\n   );\n};\n\n",
        "called_code_segment": "export const TableWrapper = () => {\n   return (\n      <Table\n         css={{height: 'auto', minWidth: '100%', cellSpacing: '0'}}>\n         <Table.Header columns={columns}>\n            {(column) => (\n               <Table.Column key={column.uid} hideHeader={column.uid === 'actions'} align={column.uid === 'actions' ? 'center' : 'start'}>\n                  {column.name}\n               </Table.Column>\n            )}\n         </Table.Header>\n         <Table.Body items={users}>\n            {(item) => (\n               <Table.Row>\n                  {(columnKey) => <Table.Cell>{renderCell(item, columnKey)}</Table.Cell>}\n               </Table.Row>\n            )}\n         </Table.Body>\n         <Table.Pagination\n            shadow\n            noMargin\n            align=\"center\"\n            rowsPerPage={8}\n            onPageChange={(page) => console.log({page})}\n         />\n      </Table>\n   );\n};",
        "invoking_code_segment": "<TableWrapper />",
        "feature_description": "Add a feature to allow filtering the table by user role.",
        "detailed_feature_description": "Modify the TableWrapper component to include a dropdown for selecting user roles. Update the Accounts component to include this dropdown and pass the selected role as a prop to the TableWrapper component. The TableWrapper component will then filter the users based on the selected role.",
        "modified_complete_code": {
            "nextui-dashboard/components/table/table.tsx": "import {Table} from '@nextui-org/react';\nimport React from 'react';\nimport {columns, users} from './data';\nimport {RenderCell} from './render-cell';\n\nexport const TableWrapper = ({roleFilter}) => {\n   const filteredUsers = roleFilter ? users.filter(user => user.role === roleFilter) : users;\n   return (\n      <Table\n         css={{height: 'auto', minWidth: '100%', cellSpacing: '0'}}>\n         <Table.Header columns={columns}>\n            {(column) => (\n               <Table.Column key={column.uid} hideHeader={column.uid === 'actions'} align={column.uid === 'actions' ? 'center' : 'start'}>\n                  {column.name}\n               </Table.Column>\n            )}\n         </Table.Header>\n         <Table.Body items={filteredUsers}>\n            {(item) => (\n               <Table.Row>\n                  {(columnKey) => <Table.Cell>{RenderCell(item, columnKey)}</Table.Cell>}\n               </Table.Row>\n            )}\n         </Table.Body>\n         <Table.Pagination\n            shadow\n            noMargin\n            align=\"center\"\n            rowsPerPage={8}\n            onPageChange={(page) => console.log({page})}\n         />\n      </Table>\n   );\n};",
            "nextui-dashboard/components/accounts/index.tsx": "import {Button, Input, Text, Dropdown} from '@nextui-org/react';\nimport Link from 'next/link';\nimport React, {useState} from 'react';\nimport {Breadcrumbs, Crumb, CrumbLink} from '../breadcrumb/breadcrumb.styled';\nimport {DotsIcon} from '../icons/accounts/dots-icon';\nimport {ExportIcon} from '../icons/accounts/export-icon';\nimport {InfoIcon} from '../icons/accounts/info-icon';\nimport {TrashIcon} from '../icons/accounts/trash-icon';\nimport {HouseIcon} from '../icons/breadcrumb/house-icon';\nimport {UsersIcon} from '../icons/breadcrumb/users-icon';\nimport {SettingsIcon} from '../icons/sidebar/settings-icon';\nimport {Flex} from '../styles/flex';\nimport {TableWrapper} from '../table/table';\nimport {AddUser} from './add-user';\n\nexport const Accounts = () => {\n   const [roleFilter, setRoleFilter] = useState(null);\n   const handleRoleChange = (key) => {\n      setRoleFilter(key);\n   };\n   return (\n      <Flex\n         css={{'mt': '$5', 'px': '$6', '@sm': {mt: '$10', px: '$16'}}}\n         justify={'center'}\n         direction={'column'}\n      >\n         <Breadcrumbs>\n            <Crumb>\n               <HouseIcon />\n               <Link href={'/'}>\n                  <CrumbLink href=\"#\">Home</CrumbLink>\n               </Link>\n               <Text>/</Text>\n            </Crumb>\n\n            <Crumb>\n               <UsersIcon />\n               <CrumbLink href=\"#\">Users</CrumbLink>\n               <Text>/</Text>\n            </Crumb>\n            <Crumb>\n               <CrumbLink href=\"#\">List</CrumbLink>\n            </Crumb>\n         </Breadcrumbs>\n\n         <Text h3>All Accounts</Text>\n         <Flex\n            css={{gap: '$8'}}\n            align={'center'}\n            justify={'between'}\n            wrap={'wrap'}\n         >\n            <Flex\n               css={{'gap': '$6', 'flexWrap': 'wrap', '@sm': {flexWrap: 'nowrap'}}}\n               align={'center'}\n            >\n               <Input\n                  css={{width: '100%', maxW: '410px'}}\n                  placeholder=\"Search users\"\n               />\n               <Dropdown>\n                  <Dropdown.Button flat>Filter by Role</Dropdown.Button>\n                  <Dropdown.Menu\n                     aria-label=\"Role Filter\"\n                     selectionMode=\"single\"\n                     selectedKeys={roleFilter ? [roleFilter] : []}\n                     onSelectionChange={(keys) => handleRoleChange(Array.from(keys)[0])}\n                  >\n                     <Dropdown.Item key=\"admin\">Admin</Dropdown.Item>\n                     <Dropdown.Item key=\"user\">User</Dropdown.Item>\n                     <Dropdown.Item key=\"editor\">Editor</Dropdown.Item>\n                  </Dropdown.Menu>\n               </Dropdown>\n               <SettingsIcon />\n               <TrashIcon />\n               <InfoIcon />\n               <DotsIcon />\n            </Flex>\n            <Flex direction={'row'} css={{gap: '$6'}} wrap={'wrap'}>\n               <AddUser />\n               <Button auto iconRight={<ExportIcon />}>\n                  Export to CSV\n               </Button>\n            </Flex>\n         </Flex>\n\n         <TableWrapper roleFilter={roleFilter} />\n      </Flex>\n   );\n};"
        }
    },
    {
        "repo": "ng-jda-2017-07-05",
        "content": "'ng-jda-2017-07-05/apps/store-app-forms/src/app/app.component.ts'\n:import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'app';\n}\n\n'ng-jda-2017-07-05/apps/store-app-forms/src/app/app.component.spec.ts'\n:import { TestBed, async } from '@angular/core/testing';\n\nimport { AppComponent } from './app.component';\n\ndescribe('AppComponent', () => {\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [\n        AppComponent\n      ],\n    }).compileComponents();\n  }));\n\n  it('should create the app', async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app).toBeTruthy();\n  }));\n\n  it(`should have as title 'app'`, async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app.title).toEqual('app');\n  }));\n\n  it('should render title in a h1 tag', async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain('Welcome to app!!');\n  }));\n});\n\n",
        "called_code_segment": "@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'app';\n}",
        "invoking_code_segment": "describe('AppComponent', () => {\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [\n        AppComponent\n      ],\n    }).compileComponents();\n  }));\n\n  it('should create the app', async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app).toBeTruthy();\n  }));\n\n  it(`should have as title 'app'`, async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app.title).toEqual('app');\n  }));\n\n  it('should render title in a h1 tag', async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain('Welcome to app!!');\n  }));\n});",
        "feature_description": "Add a dynamic title feature",
        "detailed_feature_description": "Modify the AppComponent to accept a dynamic title input. Update the test to handle this new input.",
        "modified_complete_code": {
            "app.component.ts": "@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  //Modify\n  @Input() title: string;\n\n  //Modify\n  constructor() {\n    this.title = 'Default Title';\n  }\n}",
            "app.component.spec.ts": "describe('AppComponent', () => {\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [\n        AppComponent\n      ],\n    }).compileComponents();\n  }));\n\n  it('should create the app', async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app).toBeTruthy();\n  }));\n\n  //Modify\n  it(`should have as title 'Default Title'`, async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app.title).toEqual('Default Title');\n  }));\n\n  //Modify\n  it('should render title in a h1 tag', async(() => {\n    const fixture = TestBed.createComponent(AppComponent);\n    fixture.componentInstance.title = 'Custom Title';\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain('Custom Title');\n  }));\n});"
        }
    },
    {
        "repo": "ngx-chat-ui",
        "content": "'ngx-chat-ui/apps/ngx-chat-ui-demo/src/app/components/app/app.component.ts'\n:\n'ngx-chat-ui/apps/ngx-chat-ui-demo/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { RouterModule } from '@angular/router';\nimport { DROPZONE_CONFIG, DropzoneConfigInterface } from 'ngx-dropzone-wrapper';\n\nimport { AppComponent } from './components/app/app.component';\nimport { NgxChatUiModule } from '@ngx-chat-ui/libs/ngx-chat-ui';\n\nconst DEFAULT_DROPZONE_CONFIG: DropzoneConfigInterface = {\n  url: 'https://dashboard.pixc.com/uploadFile/test',\n  acceptedFiles: 'image/*',\n};\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot([]),\n    NgxChatUiModule\n  ],\n  providers: [\n    {\n      provide: DROPZONE_CONFIG,\n      useValue: DEFAULT_DROPZONE_CONFIG,\n    }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n\n",
        "called_code_segment": "@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot([]),\n    NgxChatUiModule\n  ],\n  providers: [\n    {\n      provide: DROPZONE_CONFIG,\n      useValue: DEFAULT_DROPZONE_CONFIG,\n    }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}",
        "invoking_code_segment": "import { AppComponent } from './components/app/app.component';\nimport { NgxChatUiModule } from '@ngx-chat-ui/libs/ngx-chat-ui';\n\nconst DEFAULT_DROPZONE_CONFIG: DropzoneConfigInterface = {\n  url: 'https://dashboard.pixc.com/uploadFile/test',\n  acceptedFiles: 'image/*',\n};",
        "feature_description": "Add a new route to the application.",
        "detailed_feature_description": "To add a new route to the application, we need to modify the RouterModule configuration in the AppModule to include a new route. This route will point to a new component, which will be created as part of this feature.",
        "modified_complete_code": "// #file 1: ngx-chat-ui/apps/ngx-chat-ui-demo/src/app/app.module.ts\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\nimport { DROPZONE_CONFIG, DropzoneConfigInterface } from 'ngx-dropzone-wrapper';\n\nimport { AppComponent } from './components/app/app.component';\nimport { NgxChatUiModule } from '@ngx-chat-ui/libs/ngx-chat-ui';\nimport { NewComponent } from './components/new/new.component'; // #New\n\nconst DEFAULT_DROPZONE_CONFIG: DropzoneConfigInterface = {\n  url: 'https://dashboard.pixc.com/uploadFile/test',\n  acceptedFiles: 'image/*',\n};\n\nconst routes: Routes = [\n  { path: 'new', component: NewComponent } // #New\n];\n\n@NgModule({\n  declarations: [AppComponent, NewComponent], // #Modify\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot(routes), // #Modify\n    NgxChatUiModule\n  ],\n  providers: [\n    {\n      provide: DROPZONE_CONFIG,\n      useValue: DEFAULT_DROPZONE_CONFIG,\n    }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n\n// #New\n// #file 2: ngx-chat-ui/apps/ngx-chat-ui-demo/src/app/components/new/new.component.ts\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-new',\n  template: `<h1>New Component</h1>`\n})\nexport class NewComponent {}"
    },
    {
        "repo": "ngx-hana-nameserver-history-viewer",
        "content": "'ngx-hana-nameserver-history-viewer/src/demo/demo-util.ts'\n:import {TimeZoneAbbrMapping} from './demo-service';\nimport moment from 'moment-timezone';\n\n/**\n * interface for the abbreviation and offset getting from topology.txt\n */\nexport interface TimeZoneAbbrOffset {\n  abbreviation: string;\n  offset: number;\n}\n/**\n * save data to related local storage\n * @param name local storage item name\n * @param data data that needs to be saved in local storage\n */\nexport function setLocalStorage(name, data) {\n  if (name == null || name.length === 0) {\n    return;\n  }\n  if (data) {\n    localStorage.setItem(name, JSON.stringify(data));\n  } else {\n    localStorage.removeItem(name);\n  }\n}\n\n/**\n * get data from local storage\n * @param name local storage item name\n */\nexport function getLocalStorage(name): any {\n  if (name == null || name.length === 0) {\n    return undefined;\n  }\n\n  const data = localStorage.getItem(name);\n  if (data != null) {\n    return JSON.parse(data);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * get timezone from topology.txt\n * @param abbreviation the abbreviation of timezone\n * @param offset offset of timezone\n * @param tzAbbrMappings mappings of timezone and abbreviation\n */\nexport function getTimeZoneFromTopology(abbreviation: string, offset: number, tzAbbrMappings: TimeZoneAbbrMapping[]): string {\n  if (abbreviation == null || offset == null) {\n    return null;\n  }\n  // if abbreviation is number, get GMT timezone from moment.js\n  if (!isNaN(Number(abbreviation))) {\n    const tzNum = Number(abbreviation);\n    const etcGMTTZ = `Etc/GMT${tzNum > 0 ? '-' : '+'}${Math.abs(tzNum)}`;\n    // get GMT timezone\n    for (const name of moment.tz.names()) {\n      if (name === etcGMTTZ) {\n        return name;\n      }\n    }\n  }\n\n  // get timezone base on timezone name\n  for (const name of moment.tz.names()) {\n    if (name.indexOf('/') > 0) {\n      if (name === abbreviation) {\n        return name;\n      }\n    }\n  }\n\n  // define all the regions\n  const tzRegions = ['Etc', 'Europe', 'America', 'Africa', 'Antarctica', 'Arctic', 'Asia', 'Atlantic', 'Australia', 'Pacific', 'Indian'];\n  // get timezone base on abbreviation and offset\n  for (const region of tzRegions) {\n    for (const mapping of tzAbbrMappings) {\n      if (mapping.timezone.startsWith(region)) {\n        if (mapping.abbreviation === abbreviation && Math.abs(mapping.offset - offset) < 1) {\n          return mapping.timezone;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * get the timezone(abbreviation) and offset from content of topology.txt\n * @param fileContent the content of topology.txt\n */\nexport function getAbbreviationAndOffset(fileContent: string): TimeZoneAbbrOffset {\n  const timezoneNameString = 'timezone_name';\n  const timezoneOffsetString = 'timezone_offset';\n  let abbreviation;\n  let offset;\n  // split the content to array\n  const allLines = fileContent.split(/\\r\\n|\\n/);\n  // get timezone (Abbreviation) and offset\n  if (allLines) {\n    for (const line of allLines) {\n      if (line != null) {\n        if (line.includes(timezoneNameString)) {\n          abbreviation = line.split('=')[1];\n        } else if (line.includes(timezoneOffsetString)) {\n          offset = Number(line.split('=')[1]) / 3600;\n        }\n        if (abbreviation != null && offset != null) {\n          break;\n        }\n      }\n    }\n  }\n  if (abbreviation == null || offset == null) {\n    abbreviation = null;\n    offset = null;\n  }\n  return {abbreviation: abbreviation, offset: offset};\n}\n\n'ngx-hana-nameserver-history-viewer/src/demo/demo-util.spec.ts'\n:import {getAbbreviationAndOffset, getLocalStorage, getTimeZoneFromTopology, setLocalStorage} from './demo-util';\nimport {DemoService} from './demo-service';\n\ndescribe('demo-util', () => {\n  const service = new DemoService();\n  it('#01 setLocalStorage: should save to local storage if data is not empty ', () => {\n    const name = 'test';\n    const data = 'test1';\n    setLocalStorage(name, data);\n    const dataFromStorage = localStorage.getItem(name);\n    let savedData;\n    if (dataFromStorage != null) {\n       savedData = JSON.parse(dataFromStorage);\n    } else {\n      savedData = undefined;\n    }\n    expect(savedData).toEqual(data);\n  });\n  it('#02 setLocalStorage: should remove the item from local storage if data is empty ', () => {\n    const name = 'test';\n    const data = undefined;\n    setLocalStorage(name, data);\n    expect(localStorage.getItem(name)).toBeFalsy();\n  });\n  it('#03 getLocalStorage: should get the item from local storage if the item is saved to local storage ', () => {\n    const name = 'test';\n    const data = 'test1';\n    localStorage.setItem(name, JSON.stringify(data));\n    expect(getLocalStorage(name)).toEqual(data);\n  });\n  it('#04 getLocalStorage: should return undefined if the item is not saved to local storage ', () => {\n    const name = 'testNew';\n    expect(getLocalStorage(name)).toBeFalsy();\n  });\n  it('#05 getAbbreviationAndOffset: should return abbreviation and offset from the provided topology file content', () => {\n    const content = `\n            ssfs_masterkey_changed=01.01.1970 07:00:00\n            ssfs_masterkey_systempki_changed=01.01.1970 07:00:00\n            start_time=2018-12-01 17:11:10.685\n            timezone_name=+07\n            timezone_offset=25200\n            topology_mem_info=<ok>\n            topology_mem_type=shared\n          pid=36214\n          start_time=2018-12-01 17:11:10.685\n          stonith=yes\n          volume=1\n      preprocessor\n    `;\n    expect(getAbbreviationAndOffset(content)).toEqual({abbreviation: '+07', offset: 7});\n  });\n  it('#06 getAbbreviationAndOffset: should return null for both abbreviation and offset if either abbreviation is missed or offset is null', () => {\n    const content = `\n            ssfs_masterkey_changed=01.01.1970 07:00:00\n            ssfs_masterkey_systempki_changed=01.01.1970 07:00:00\n            start_time=2018-12-01 17:11:10.685\n            timezone1_name=+07\n            timezone_offset=25200\n            topology_mem_info=<ok>\n            topology_mem_type=shared\n          pid=36214\n          start_time=2018-12-01 17:11:10.685\n          stonith=yes\n          volume=1\n      preprocessor\n    `;\n    expect(getAbbreviationAndOffset(content)).toEqual({abbreviation: null, offset: null});\n\n    const content1 = `\n            ssfs_masterkey_changed=01.01.1970 07:00:00\n            ssfs_masterkey_systempki_changed=01.01.1970 07:00:00\n            start_time=2018-12-01 17:11:10.685\n            timezone_name=+07\n            timezone1_offset=25200\n            topology_mem_info=<ok>\n            topology_mem_type=shared\n          pid=36214\n          start_time=2018-12-01 17:11:10.685\n          stonith=yes\n          volume=1\n      preprocessor\n    `;\n    expect(getAbbreviationAndOffset(content1)).toEqual({abbreviation: null, offset: null});\n\n  });\n  it('#07 getTimeZoneFromTopology: should return Etc/GMTxx if abbreviation is number', () => {\n    expect(getTimeZoneFromTopology('+07', 7, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT-7');\n    expect(getTimeZoneFromTopology('-10', 10, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+10');\n    expect(getTimeZoneFromTopology('+00', 0, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+0');\n    expect(getTimeZoneFromTopology('-00', 0, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+0');\n  });\n  it('#08 getTimeZoneFromTopology: should return timezone directly if abbreviation is a value from standard timezone', () => {\n    expect(getTimeZoneFromTopology('America/New_York', 25200, service.getTimezoneAbbrMappings())).toEqual('America/New_York');\n  });\n  it('#09 getTimeZoneFromTopology: should return the relative timezone directly base on abbreviation and offset', () => {\n    expect(getTimeZoneFromTopology('CST', 8, service.getTimezoneAbbrMappings())).toEqual('Asia/Shanghai');\n    expect(getTimeZoneFromTopology('CST', -6, service.getTimezoneAbbrMappings())).toEqual('America/Chicago');\n    expect(getTimeZoneFromTopology('PST', -8, service.getTimezoneAbbrMappings())).toEqual('America/Vancouver');\n    expect(getTimeZoneFromTopology('PDT', -7, service.getTimezoneAbbrMappings())).toEqual('America/Vancouver');\n  });\n  it('#10 getTimeZoneFromTopology: should return null if can not find the timezone base on abbreviation and offset', () => {\n    expect(getTimeZoneFromTopology('CST', 9, service.getTimezoneAbbrMappings())).toEqual(null);\n    expect(getTimeZoneFromTopology('PST', -7, service.getTimezoneAbbrMappings())).toEqual(null);\n    expect(getTimeZoneFromTopology('PDT', -8, service.getTimezoneAbbrMappings())).toEqual(null);\n  });\n  it('#11 getTimeZoneFromTopology: should return null if abbreviation is null', () => {\n    expect(getTimeZoneFromTopology(null, 9, service.getTimezoneAbbrMappings())).toEqual(null);\n  });\n  it('#12 getTimeZoneFromTopology: should return null if offset is null', () => {\n    expect(getTimeZoneFromTopology('PST', null, service.getTimezoneAbbrMappings())).toEqual(null);\n  });\n});\n\n",
        "called_code_segment": "export function getTimeZoneFromTopology(abbreviation: string, offset: number, tzAbbrMappings: TimeZoneAbbrMapping[]): string {\n  if (abbreviation == null || offset == null) {\n    return null;\n  }\n  // if abbreviation is number, get GMT timezone from moment.js\n  if (!isNaN(Number(abbreviation))) {\n    const tzNum = Number(abbreviation);\n    const etcGMTTZ = `Etc/GMT${tzNum > 0 ? '-' : '+'}${Math.abs(tzNum)}`;\n    // get GMT timezone\n    for (const name of moment.tz.names()) {\n      if (name === etcGMTTZ) {\n        return name;\n      }\n    }\n  }\n\n  // get timezone base on timezone name\n  for (const name of moment.tz.names()) {\n    if (name.indexOf('/') > 0) {\n      if (name === abbreviation) {\n        return name;\n      }\n    }\n  }\n\n  // define all the regions\n  const tzRegions = ['Etc', 'Europe', 'America', 'Africa', 'Antarctica', 'Arctic', 'Asia', 'Atlantic', 'Australia', 'Pacific', 'Indian'];\n  // get timezone base on abbreviation and offset\n  for (const region of tzRegions) {\n    for (const mapping of tzAbbrMappings) {\n      if (mapping.timezone.startsWith(region)) {\n        if (mapping.abbreviation === abbreviation && Math.abs(mapping.offset - offset) < 1) {\n          return mapping.timezone;\n        }\n      }\n    }\n  }\n  return null;\n}",
        "invoking_code_segment": "it('#07 getTimeZoneFromTopology: should return Etc/GMTxx if abbreviation is number', () => {\n  expect(getTimeZoneFromTopology('+07', 7, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT-7');\n  expect(getTimeZoneFromTopology('-10', 10, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+10');\n  expect(getTimeZoneFromTopology('+00', 0, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+0');\n  expect(getTimeZoneFromTopology('-00', 0, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+0');\n});",
        "feature_description": "Add a fallback mechanism to return a default timezone if the timezone cannot be determined.",
        "detailed_feature_description": "Modify the `getTimeZoneFromTopology` function to return a default timezone (e.g., 'UTC') if the timezone cannot be determined based on the provided abbreviation and offset. Update the test case in #file 2 to handle this new behavior.",
        "modified_complete_code": {
            "file1": "export function getTimeZoneFromTopology(abbreviation: string, offset: number, tzAbbrMappings: TimeZoneAbbrMapping[]): string {\n  if (abbreviation == null || offset == null) {\n    return 'UTC'; #Modify\n  }\n  // if abbreviation is number, get GMT timezone from moment.js\n  if (!isNaN(Number(abbreviation))) {\n    const tzNum = Number(abbreviation);\n    const etcGMTTZ = `Etc/GMT${tzNum > 0 ? '-' : '+'}${Math.abs(tzNum)}`;\n    // get GMT timezone\n    for (const name of moment.tz.names()) {\n      if (name === etcGMTTZ) {\n        return name;\n      }\n    }\n  }\n\n  // get timezone base on timezone name\n  for (const name of moment.tz.names()) {\n    if (name.indexOf('/') > 0) {\n      if (name === abbreviation) {\n        return name;\n      }\n    }\n  }\n\n  // define all the regions\n  const tzRegions = ['Etc', 'Europe', 'America', 'Africa', 'Antarctica', 'Arctic', 'Asia', 'Atlantic', 'Australia', 'Pacific', 'Indian'];\n  // get timezone base on abbreviation and offset\n  for (const region of tzRegions) {\n    for (const mapping of tzAbbrMappings) {\n      if (mapping.timezone.startsWith(region)) {\n        if (mapping.abbreviation === abbreviation && Math.abs(mapping.offset - offset) < 1) {\n          return mapping.timezone;\n        }\n      }\n    }\n  }\n  return 'UTC'; #Modify\n}",
            "file2": "it('#07 getTimeZoneFromTopology: should return Etc/GMTxx if abbreviation is number', () => {\n  expect(getTimeZoneFromTopology('+07', 7, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT-7');\n  expect(getTimeZoneFromTopology('-10', 10, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+10');\n  expect(getTimeZoneFromTopology('+00', 0, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+0');\n  expect(getTimeZoneFromTopology('-00', 0, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+0');\n});\n\nit('#13 getTimeZoneFromTopology: should return UTC if timezone cannot be determined', () => {\n  expect(getTimeZoneFromTopology('CST', 9, service.getTimezoneAbbrMappings())).toEqual('UTC'); #New\n  expect(getTimeZoneFromTopology('PST', -7, service.getTimezoneAbbrMappings())).toEqual('UTC'); #New\n  expect(getTimeZoneFromTopology('PDT', -8, service.getTimezoneAbbrMappings())).toEqual('UTC'); #New\n});"
        }
    },
    {
        "repo": "nody-greeter",
        "content": "'nody-greeter/src/main/utils/battery.ts'\n:import * as path from \"path\";\nimport * as fs from \"fs\";\n\nimport { globalNodyConfig } from \"../config\";\nimport { ACPI } from \"./acpi\";\n\ninterface Battery {\n  name: string;\n  status: string;\n  perc: number;\n  capacity: number;\n}\n\nlet runningUpdate = false;\n\nclass BatteryController {\n  public _batteries: Battery[] = [];\n  public PS_PATH = \"/sys/class/power_supply/\";\n  private _ac = \"AC0\";\n  private _perc = -1;\n  private _status = \"N/A\";\n  private _acStatus = false;\n  private _capacity = 0;\n  private _time = \"\";\n  private _watt = 0;\n\n  public constructor() {\n    if (globalNodyConfig.config.features.battery == true) this._init();\n  }\n\n  private _init(): void {\n    if (this._batteries.length == 0) {\n      scandirLine(this.PS_PATH, (lines) => this._updateBatteries(lines));\n    }\n    this.acpiListen();\n    this.fullUpdate();\n  }\n\n  /**\n   * Update available batteries and AC\n   */\n  private _updateBatteries(line: string): void {\n    const match = line.match(/BAT\\w+/);\n    if (match) {\n      this._batteries.push({\n        name: match[0],\n        status: \"N/A\",\n        perc: 0,\n        capacity: 0,\n      });\n    } else {\n      const ac = line.match(/A\\w+/);\n      this._ac = ac ? ac[0] : this._ac;\n    }\n  }\n  public get name(): string {\n    return this._batteries[0].name;\n  }\n  public get level(): number {\n    return this._perc;\n  }\n  public get status(): string {\n    return this._status;\n  }\n  public get acStatus(): boolean {\n    return this._acStatus;\n  }\n  public get capacity(): number {\n    return this._capacity;\n  }\n  public get time(): string {\n    return this._time;\n  }\n  public get watt(): number {\n    return this._watt;\n  }\n\n  public acpiListen(): void {\n    ACPI.connect((data) => {\n      if (data.match(/battery|ac_adapter/)) {\n        this.fullUpdate();\n      }\n    });\n  }\n\n  /**\n   * Based on \"bat\" widget from \"lain\" awesome-wm library\n   * * (c) 2013,      Luca CPZ\n   * * (c) 2010-2012, Peter Hofmann\n   * @see https://github.com/lcpz/lain/blob/master/widget/bat.lua\n   */\n  public async fullUpdate(): Promise<void> {\n    if (runningUpdate) return;\n    runningUpdate = true;\n\n    let sumRateCurrent = 0;\n    let sumRatePower = 0;\n    let sumRateEnergy = 0;\n    let sumEnergyNow = 0;\n    let sumEnergyFull = 0;\n    let sumChargeFull = 0;\n    let sumChargeDesign = 0;\n\n    async function readData(...p: string[]): Promise<string> {\n      return readFirstLine(path.join(...p));\n    }\n\n    for (let i = 0; i < this._batteries.length; i++) {\n      const battery = this._batteries[i];\n      const batPath = this.PS_PATH + battery.name;\n      const present = await readFirstLine(path.join(batPath, \"present\"));\n\n      if (parseInt(present) == 1) {\n        const rateCurrent = parseInt(await readData(batPath, \"current_now\"));\n        const rateVoltage = parseInt(await readData(batPath, \"voltage_now\"));\n        const ratePower = parseInt(await readData(batPath, \"power_now\"));\n        const chargeFull = parseInt(await readData(batPath, \"charge_full\"));\n        const chargeDesign = parseInt(\n          await readData(batPath, \"charge_full_design\")\n        );\n\n        const energyNow = parseInt(\n          (await readData(batPath, \"energy_now\")) ||\n            (await readData(batPath, \"charge_now\"))\n        );\n        const energyFull =\n          parseInt(await readData(batPath, \"energy_full\")) || chargeFull;\n        const energyPercentage =\n          parseInt(await readData(batPath, \"capacity\")) ||\n          Math.floor((energyNow / energyFull) * 100);\n        this._batteries[i].status =\n          (await readData(batPath, \"status\")) || \"N/A\";\n        this._batteries[i].perc = energyPercentage || this._batteries[i].perc;\n\n        if (!chargeDesign || chargeDesign == 0) {\n          this._batteries[i].capacity = 0;\n        } else {\n          this._batteries[i].capacity = Math.floor(\n            (chargeFull / chargeDesign) * 100\n          );\n        }\n        sumRateCurrent += rateCurrent || 0;\n        sumRatePower += ratePower || 0;\n        sumRateEnergy +=\n          ratePower || ((rateVoltage || 0) * (rateCurrent || 0)) / 1e6;\n        sumEnergyNow += energyNow || 0;\n        sumEnergyFull += energyFull || 0;\n        sumChargeFull += chargeFull || 0;\n        sumChargeDesign += chargeDesign || 0;\n      }\n    }\n    this._capacity = Math.floor(\n      Math.min(100, (sumChargeFull / sumChargeDesign) * 100)\n    );\n    this._status =\n      this._batteries.length > 0 ? this._batteries[0].status : \"N/A\";\n\n    for (let i = 0; i < this._batteries.length; i++) {\n      const battery = this._batteries[i];\n      if (battery.status == \"Discharging\" || battery.status == \"Charging\") {\n        this._status = battery.status;\n      }\n    }\n    this._acStatus = Boolean(\n      parseInt(await readData(this.PS_PATH, this._ac, \"online\"))\n    );\n\n    let rateTime: number;\n    let rateTimeMagnitude: number;\n\n    if (this._status != \"N/A\") {\n      if (\n        this._status != \"Full\" &&\n        sumRatePower == 0 &&\n        this._acStatus == true\n      ) {\n        this._perc = Math.floor(\n          Math.min(100, (sumEnergyNow / sumEnergyFull) * 100 + 0.5)\n        );\n        this._time = \"00:00\";\n        this._watt = 0;\n      } else if (this._status != \"Full\") {\n        rateTime = 0;\n        if (sumRatePower > 0 || sumRateCurrent > 0) {\n          const div = (sumRatePower > 0 && sumRatePower) || sumRateCurrent;\n          if (this._status == \"Charging\")\n            rateTime = (sumEnergyFull - sumEnergyNow) / div;\n          else rateTime = sumEnergyNow / div;\n          if (0 < rateTime && rateTime < 0.01) {\n            rateTimeMagnitude = Math.abs(Math.floor(Math.log10(rateTime)));\n            rateTime = (rateTime * 10) ^ (rateTimeMagnitude - 2);\n          }\n          const hours = Math.floor(rateTime);\n          const minutes = Math.floor((rateTime - hours) * 60);\n          this._perc = Math.floor(\n            Math.min(100, (sumEnergyNow / sumEnergyFull) * 100 + 0.5)\n          );\n          this._time = `${hours.toString().padStart(2, \"0\")}:${minutes\n            .toString()\n            .padStart(2, \"0\")}`;\n          this._watt = sumRateEnergy / 1e6;\n        }\n      } else if (this._status == \"Full\") {\n        this._perc = 100;\n        this._time = \"00:00\";\n        this._watt = 0;\n      }\n    }\n    this._perc = this._perc == null ? 0 : this._perc;\n\n    if (global.lightdmGreeter)\n      global.lightdmGreeter._emitSignal(\"battery_update\");\n\n    runningUpdate = false;\n  }\n}\n\n/**\n * List a directory and run callback for each element\n */\nfunction scandirLine(dir: string, callback: (lines: string) => void): void {\n  const lines = fs.readdirSync(dir, { encoding: \"utf8\" });\n  lines.forEach((l) => callback(l));\n}\n\n/**\n * Read first line of a file asynchronously\n */\nfunction readFirstLine(filePath: string): Promise<string> {\n  return new Promise((resolve) => {\n    const rs = fs.createReadStream(filePath, { encoding: \"utf8\" });\n    let val = \"\";\n    let ind = 0;\n    let pos = 0;\n    rs.on(\"data\", (data) => {\n      ind = data.indexOf(\"\\n\");\n      val += data;\n      if (ind == -1) {\n        pos += data.length;\n      } else {\n        pos += ind;\n        rs.close();\n      }\n    })\n      .on(\"close\", () =>\n        resolve(val.slice((val.charCodeAt(0) === 0xfeff && 1) || 0, pos))\n      )\n      .on(\"error\", () => resolve(\"\"));\n  });\n}\n\nexport { BatteryController };\n\n'nody-greeter/src/main/bridge/bridge_objects.ts'\n:import {\n  LightDMBattery,\n  LightDMLanguage,\n  LightDMLayout,\n  LightDMSession,\n  LightDMUser,\n} from \"common/ldm_interfaces\";\n\nimport { LightDM } from \"node-gtk\";\nimport { BatteryController } from \"../utils/battery\";\n\nfunction sessionToObject(\n  session: LightDM.LightDMSession\n): LightDMSession | null {\n  if (!session) return null;\n  return {\n    comment: session.getComment(),\n    key: session.getKey(),\n    name: session.getName(),\n    type: session.getSessionType(),\n  };\n}\n\nfunction userToObject(user: LightDM.LightDMUser): LightDMUser | null {\n  if (!user) return null;\n  return {\n    background: user.getBackground(),\n    display_name: user.getDisplayName(),\n    home_directory: user.getHomeDirectory(),\n    image: user.getImage(),\n    language: user.getLanguage(),\n    layout: user.getLayout(),\n    layouts: user.getLayouts(),\n    logged_in: user.getLoggedIn(),\n    session: user.getSession(),\n    username: user.getName(),\n  };\n}\n\nfunction languageToObject(\n  lang: LightDM.LightDMLanguage\n): LightDMLanguage | null {\n  if (!lang) return null;\n  return {\n    code: lang.getCode(),\n    name: lang.getName(),\n    territory: lang.getTerritory(),\n  };\n}\n\nfunction layoutToObject(layout: LightDM.LightDMLayout): LightDMLayout | null {\n  if (!layout) return null;\n  return {\n    description: layout.getDescription(),\n    name: layout.getName(),\n    short_description: layout.getShortDescription(),\n  };\n}\n\nfunction batteryToObject(battery: BatteryController): LightDMBattery | null {\n  if (!battery) return null;\n  if (battery._batteries.length == 0) return null;\n  return {\n    name: battery.name,\n    level: battery.level,\n    status: battery.status,\n    ac_status: battery.acStatus,\n    capacity: battery.capacity,\n    time: battery.time,\n    watt: battery.watt,\n  };\n}\n\nexport {\n  sessionToObject,\n  batteryToObject,\n  languageToObject,\n  layoutToObject,\n  userToObject,\n};\n\n",
        "called_code_segment": "function batteryToObject(battery: BatteryController): LightDMBattery | null {\n  if (!battery) return null;\n  if (battery._batteries.length == 0) return null;\n  return {\n    name: battery.name,\n    level: battery.level,\n    status: battery.status,\n    ac_status: battery.acStatus,\n    capacity: battery.capacity,\n    time: battery.time,\n    watt: battery.watt,\n  };\n}",
        "invoking_code_segment": "if (global.lightdmGreeter)\n  global.lightdmGreeter._emitSignal(\"battery_update\");",
        "feature_description": "Add a feature to include battery temperature in the battery object.",
        "detailed_feature_description": "Modify the `batteryToObject` function in #file 1 to include a new property `temperature` in the returned `LightDMBattery` object. Update the `fullUpdate` method in #file 1 to fetch and set the battery temperature. Ensure the `battery_update` signal in #file 2 is emitted after updating the battery temperature.",
        "modified_complete_code": {
            "#file 1": "function batteryToObject(battery: BatteryController): LightDMBattery | null {\n  if (!battery) return null;\n  if (battery._batteries.length == 0) return null;\n  return {\n    name: battery.name,\n    level: battery.level,\n    status: battery.status,\n    ac_status: battery.acStatus,\n    capacity: battery.capacity,\n    time: battery.time,\n    watt: battery.watt,\n    temperature: battery.temperature, #Modify\n  };\n}\n\nclass BatteryController {\n  // Existing code...\n  private _temperature = 0; #New\n\n  // Existing code...\n\n  public async fullUpdate(): Promise<void> {\n    // Existing code...\n\n    for (let i = 0; i < this._batteries.length; i++) {\n      const battery = this._batteries[i];\n      const batPath = this.PS_PATH + battery.name;\n      const present = await readFirstLine(path.join(batPath, \"present\"));\n\n      if (parseInt(present) == 1) {\n        // Existing code...\n\n        const temperature = parseInt(await readData(batPath, \"temp\")); #New\n        this._temperature = temperature / 10; #New\n      }\n    }\n\n    // Existing code...\n\n    if (global.lightdmGreeter)\n      global.lightdmGreeter._emitSignal(\"battery_update\");\n\n    runningUpdate = false;\n  }\n\n  public get temperature(): number { #New\n    return this._temperature; #New\n  }\n}",
            "#file 2": "if (global.lightdmGreeter)\n  global.lightdmGreeter._emitSignal(\"battery_update\");"
        }
    },
    {
        "repo": "omniscient",
        "content": "'omniscient/app/(dashboard)/(routes)/music/constants.ts'\n:import * as z from \"zod\";\n\nexport const formSchema = z.object({\n  prompt: z.string().min(1, {\n    message: \"Prompt is required\",\n  }),\n});\n\n'omniscient/app/(dashboard)/(routes)/music/page.tsx'\n:\"use client\";\n\nimport * as z from \"zod\";\nimport axios from \"axios\";\nimport { useState } from \"react\";\nimport { zodResolver } from \"@hookform/resolvers/zod\";\nimport { useForm } from \"react-hook-form\";\nimport { useRouter } from \"next/navigation\";\nimport toast from \"react-hot-toast\";\nimport { Music, Send } from \"lucide-react\";\n\nimport Heading from \"@/components/heading\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { Form, FormControl, FormField, FormItem } from \"@/components/ui/form\";\nimport { Loader } from \"@/components/loader\";\nimport { Empty } from \"@/components/empty\";\nimport { useProModal } from \"@/hooks/use-pro-modal\";\n\nimport { formSchema } from \"./constants\";\n\nconst MusicPage = () => {\n  const proModal = useProModal();\n  const router = useRouter();\n  const [music, setMusic] = useState<string>();\n\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      prompt: \"\",\n    },\n  });\n\n  const isLoading = form.formState.isSubmitting;\n\n  const onSubmit = async (values: z.infer<typeof formSchema>) => {\n    try {\n      setMusic(undefined);\n\n      const response = await axios.post(\"/api/music\", values);\n\n      setMusic(response.data.audio);\n      form.reset();\n    } catch (error: any) {\n      if (error?.response?.status === 403) {\n        proModal.onOpen();\n      } else {\n        toast.error(\"Something went wrong.\");\n      }\n    } finally {\n      router.refresh();\n    }\n  };\n\n  return (\n    <div>\n      <Heading\n        title=\"Music Generation\"\n        description=\"Turn your prompt into music.\"\n        icon={Music}\n        iconColor=\"text-emerald-500\"\n        bgColor=\"bg-emerald-500/10\"\n      />\n      <div className=\"px-4 lg:px-8\">\n        <Form {...form}>\n          <form\n            onSubmit={form.handleSubmit(onSubmit)}\n            className=\"\n              rounded-lg \n              border \n              w-full \n              p-4 \n              px-3 \n              md:px-6 \n              focus-within:shadow-sm\n              grid\n              grid-cols-12\n              gap-2\n            \"\n          >\n            <FormField\n              name=\"prompt\"\n              render={({ field }) => (\n                <FormItem className=\"col-span-12 lg:col-span-10\">\n                  <FormControl className=\"m-0 p-0\">\n                    <Input\n                      className=\"border-0 outline-none focus-visible:ring-0 focus-visible:ring-transparent\"\n                      disabled={isLoading}\n                      placeholder=\"Piano solo\"\n                      {...field}\n                    />\n                  </FormControl>\n                </FormItem>\n              )}\n            />\n            <Button\n              className=\"col-span-12 lg:col-span-2 w-full\"\n              type=\"submit\"\n              disabled={isLoading}\n              size=\"icon\"\n            >\n              Generate\n            </Button>\n          </form>\n        </Form>\n        {isLoading && (\n          <div className=\"p-20\">\n            <Loader />\n          </div>\n        )}\n        {!music && !isLoading && <Empty label=\"No music generated.\" />}\n        {music && (\n          <audio controls className=\"w-full mt-8\">\n            <source src={music} />\n          </audio>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default MusicPage;\n\n",
        "called_code_segment": "const formSchema = z.object({\n  prompt: z.string().min(1, {\n    message: \"Prompt is required\",\n  }),\n});",
        "invoking_code_segment": "const form = useForm<z.infer<typeof formSchema>>({\n  resolver: zodResolver(formSchema),\n  defaultValues: {\n    prompt: \"\",\n  },\n});",
        "feature_description": "Add a new field 'duration' to the form schema to allow users to specify the duration of the generated music.",
        "detailed_feature_description": "The new feature will add a 'duration' field to the form schema. This field will be a number with a minimum value of 1. The form will be updated to include this new field, and the onSubmit function will be modified to handle the new field.",
        "modified_complete_code": {
            "file1": "const formSchema = z.object({\n  prompt: z.string().min(1, {\n    message: \"Prompt is required\",\n  }),\n  duration: z.number().min(1, {\n    message: \"Duration must be at least 1\",\n  }),\n});",
            "file2": "const form = useForm<z.infer<typeof formSchema>>({\n  resolver: zodResolver(formSchema),\n  defaultValues: {\n    prompt: \"\",\n    duration: 1, // #Modify\n  },\n});\n\nconst onSubmit = async (values: z.infer<typeof formSchema>) => {\n  try {\n    setMusic(undefined);\n\n    const response = await axios.post(\"/api/music\", values);\n\n    setMusic(response.data.audio);\n    form.reset();\n  } catch (error: any) {\n    if (error?.response?.status === 403) {\n      proModal.onOpen();\n    } else {\n      toast.error(\"Something went wrong.\");\n    }\n  } finally {\n    router.refresh();\n  }\n};\n\n// #New\n<FormField\n  name=\"duration\"\n  render={({ field }) => (\n    <FormItem className=\"col-span-12 lg:col-span-2\">\n      <FormControl className=\"m-0 p-0\">\n        <Input\n          type=\"number\"\n          className=\"border-0 outline-none focus-visible:ring-0 focus-visible:ring-transparent\"\n          disabled={isLoading}\n          placeholder=\"Duration\"\n          {...field}\n        />\n      </FormControl>\n    </FormItem>\n  )}\n/>"
        }
    },
    {
        "repo": "presentation-refactoring-ast",
        "content": "'presentation-refactoring-ast/sample-project/src/helpers/helpers.ts'\n:import * as _ from 'lodash';\n\n// extract functions into their own files, and modify imports\n\nexport function sanitizeNumbersArray(arr: (string | number)[]) {\n  _.each(arr, function (value) {\n    // use parseFloat for parsing strings to float\n    return +value;\n  });\n}\n\nexport function parseStringToNumber(str: string) {\n  // use parseFloat for parsing strings to float\n  return +str;\n}\n\n\n'presentation-refactoring-ast/sample-project/src/index.tsx'\n:import { sanitizeNumbersArray, parseStringToNumber } from './helpers/helpers';\n\nconsole.log(sanitizeNumbersArray(['1', '4', 2, 3]));\n\nconsole.log(parseStringToNumber('1.234'));\n\nexport { sanitizeNumbersArray, parseStringToNumber };\n\n",
        "called_code_segment": "export function sanitizeNumbersArray(arr: (string | number)[]) {\n  _.each(arr, function (value) {\n    // use parseFloat for parsing strings to float\n    return +value;\n  });\n}\n\nexport function parseStringToNumber(str: string) {\n  // use parseFloat for parsing strings to float\n  return +str;\n}",
        "invoking_code_segment": "console.log(sanitizeNumbersArray(['1', '4', 2, 3]));\n\nconsole.log(parseStringToNumber('1.234'));\n\nexport { sanitizeNumbersArray, parseStringToNumber };",
        "feature_description": "Add a new feature to handle negative numbers in the sanitizeNumbersArray function.",
        "detailed_feature_description": "Modify the sanitizeNumbersArray function to filter out negative numbers. Update the invoking code to handle the new behavior.",
        "modified_complete_code": {
            "helpers/helpers.ts": "import * as _ from 'lodash';\n\n#Modify export function sanitizeNumbersArray(arr: (string | number)[]) {\n  return _.filter(arr, function (value) {\n    const parsedValue = +value;\n    return parsedValue >= 0;\n  });\n}\n\nexport function parseStringToNumber(str: string) {\n  // use parseFloat for parsing strings to float\n  return +str;\n}",
            "index.tsx": "import { sanitizeNumbersArray, parseStringToNumber } from './helpers/helpers';\n\n#Modify console.log(sanitizeNumbersArray(['1', '4', 2, 3, '-1'])); // This will now filter out '-1'\n\nconsole.log(parseStringToNumber('1.234'));\n\nexport { sanitizeNumbersArray, parseStringToNumber };"
        }
    },
    {
        "repo": "quick-js-ocr",
        "content": "'quick-js-ocr/src/jsocr.ts'\n:interface HTMLInputEvent extends Event {\n    target: HTMLInputElement & EventTarget;\n}\n\nconst url = {\n    ocr: 'https://api.geeku.net/ocr'\n}\nconst paraments = {\n    image: '',\n    url: '',\n    language_type: 'CHN_ENG',\n    detect_direction: true,\n    detect_language: true,\n    probability: true\n}\nconst bytesLimit = 4 * 1024 * 1024;\n\nexport function toType (obj): string {\n    return Object.prototype.toString.call(obj).match(/\\[\\w+\\s(\\w+)\\]/)[1].toLowerCase();\n}\nexport const urlRegex = /https?:\\/\\/.*?/;\n\nexport default class JsOCR {\n    _file: File = null\n    _url: string = ''\n    get file (): File {\n        return this._file;\n    }\n    set file (newVal) {\n        if (newVal.size >= bytesLimit) {\n            throw new Error('Image is oversize.');\n        }\n        console.dir(this.file);\n        this._file = newVal;\n        this.run();\n    }\n    get url (): string {\n        return this._url;\n    }\n    set url (newVal) {\n        if (!urlRegex.test(newVal)) {\n            throw new Error('Url format illegal.');\n        }\n        this._url = newVal;\n        this.run('url');\n    }\n    imgReader = new FileReader()\n    img = new Image()\n    config = null\n    token = ''\n    eventListeners = {}\n    constructor (content: HTMLInputElement | HTMLInputEvent | File | string) {\n\n        if (!((this as any) instanceof JsOCR)) {\n            throw new Error('This is not a JsOCR instance.');\n        }\n        if (!/image\\/(png)|(jpg)|(jpeg)|(bmp)/i.test((content as File).type)) {\n            throw new Error(`Image format(${(content as File).type}) is not supported. Image format must be PNG, JPG or BMP.`);\n        }\n\n        this.config = Object.assign(paraments);\n        // Generate your own token: https://cloud.baidu.com/product/ocr.html\n        const tokenFromLocal = localStorage.getItem('token');\n        this.token = tokenFromLocal ? \n                        tokenFromLocal : \n                        '24.2f0d9a3b6a60817dfd94ae61ea6f7e99.2592000.1515124116.282335-10488404';\n        const type = toType(content);\n        \n        switch (type) {\n            case 'file': this.file = content as File; break;\n            case 'event': this.file = (content as HTMLInputEvent).target.files[0] as File; break;\n            case 'htmlinputelement': this.addChangeEvent(content as HTMLInputElement); break;\n            case 'string': this.url = content as string; break;\n            default: throw Error('Parament type is illegal.');\n        }\n    }\n\n    async run (type: string = 'img') {\n        let base64 = null;\n        if (type === 'img') {\n            base64 = await this.img2Base64(this._file);\n            this.config.image = base64.replace(/data:image\\/\\w+;base64,/, '');\n            this.config.url = undefined;\n        } else if (type === 'url') {\n            this.config.image = undefined;\n            this.config.url = this.url;\n        }\n        console.log(this.config);\n        const body = Object.keys(this.config)\n                        .filter(key => this.config[key])\n                        .map(key => `${key}=${encodeURIComponent(this.config[key])}`).join('&');\n        // console.log(body);\n        const headers = new Headers();\n        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n        // let timeoutFlag = false;\n        // const timer = t => {\n        //     return new Promise(resolve => setTimeout(resolve, t))\n        //         .then(res => {\n        //             throw new Error('Time out.');\n        //             this._file = true;\n        //         });\n        // }\n        const req = fetch(url.ocr + `?access_token=${this.token}`, { method: 'POST', headers, body })\n                .then(res => res.json())\n                .then(data => {\n                    if (data.error_code) {\n                        throw new Error(`ERROR: ${data.error_code}: ${data.error_msg}`)\n                    } else {\n                        this.eventListeners['data'] && \n                        this.eventListeners['data'].forEach(cb => cb.call(null, data.words_result));\n                        localStorage && localStorage.setItem('jsocrHistory', JSON.stringify({\n                            img: this.config.url ? this.config.url : this.config.image,\n                            data\n                        }));\n                    }\n                });\n        // Promise.race([req, timer(1000)]);\n    }\n\n    on (eventName: string, cb: Function) {\n        if (this.eventListeners[eventName]) {\n            this.eventListeners[eventName].push(cb);\n        } else {\n            this.eventListeners[eventName] = [cb]\n        }\n    }\n\n    private addChangeEvent (el: HTMLInputElement) {\n        el.addEventListener('change', (e: HTMLInputEvent) => {\n            this.file = e.target.files[0];\n        });\n    }\n\n    img2Base64 (img) {\n        this.img.crossOrigin = 'anonymous';\n        return new Promise((r, j) => {\n            this.imgReader.onload = e => {\n                this.img.src = (e.target as any).result;\n                r((e.target as any).result);\n            }\n            this.imgReader.readAsDataURL(img);\n        });\n    }\n}\n'quick-js-ocr/example/example.ts'\n:import JsOCR from '../src/jsocr';\nimport { toType, urlRegex } from '../src/jsocr';\nimport Vue from 'vue';\n\nimport './style.scss';\n\ndeclare function Clipboard (string): void;\n\nfunction loadScript (url, cb?) {\n    const head = document.querySelector('head');\n    const script = document.createElement('script');\n    script.src = url;\n    if (cb) {\n        script.onload = cb;\n    }\n    head.appendChild(script);\n}\nconst scripts = {\n    'copy': 'https://cdn.bootcss.com/clipboard.js/1.7.1/clipboard.min.js'\n}\nconst body = document.body;\n\nconst vm = new Vue({\n    el: 'main',\n    data: {\n        showContent: false,\n        showLoading: false,\n        showAlert: false,\n        alertMsg: '',\n        token: localStorage.getItem('token'),\n        imgSrc: null,\n        content: '',\n        flags: {\n            enableCopy: true\n        }\n    },\n    methods: {\n        clickClose (e) {\n            console.log(e);\n            this.showContent = false;\n        },\n        clickUpload () {\n            this.upload(this.$refs.inputField.files[0]);\n            this.$refs.inputField.value = '';\n        },\n        upload (file: File | string) {\n            let ocr = null;\n            try {\n                ocr = new JsOCR(file);\n            } catch (e) {\n                alert(e);\n                return;\n            }\n            this.showLoading = true;\n            ocr.on('data', (data) => {\n                this.imgSrc = typeof file === 'string' ? file : ocr.img.src;\n                this.content = data.map(val => val.words).join('\\n');\n                this.showContent = true;\n                this.showLoading = false;\n            });\n        },\n        saveToken () {\n            if (localStorage.getItem('token') === this.token) {\n                this.alert('Nothing change.');\n                return;\n            }\n            localStorage.setItem('token', this.token);\n            this.alert('Token saved.');\n        },\n        alert (msg) {\n            this.showAlert = true;\n            this.alertMsg = msg;\n            window.setTimeout(() => {\n                this.showAlert = false\n            }, 3000);\n        },\n        scriptCB (shortcut) {\n            switch (shortcut) {\n                case 'copy': {\n                    Vue.nextTick(() => {\n                        const cp = new Clipboard('.copy');\n                        cp.on('success', e => {\n                            this.alert('Copy Successful.');    \n                            e.clearSelection();\n                        });\n                        cp.on('error',  e => {\n                            this.alert('Copy Failed, please copy by ctrl/command+c/v.');\n                        });\n                    });\n                } break;\n            }\n        }\n    },\n    computed: {\n    },\n    created () {\n        Object.keys(this.flags).forEach(flag => {\n            const shortcut = flag.replace('enable', '').toLowerCase();\n            if (this.flags[flag]) {\n                loadScript(scripts[shortcut], () => {\n                    this.scriptCB(shortcut);\n                });\n            }\n        });\n        document.addEventListener('paste', (e: ClipboardEvent) => {\n            const url = e.clipboardData.getData('text');\n            if (toType(e.clipboardData.files[0]) === 'file') {\n                this.upload(e.clipboardData.files[0]);\n            } else if (urlRegex.test(url)) {\n                console.log(url);\n                this.upload(url);\n            }\n        });\n        document.addEventListener(\"dragover\", e => {\n            e.preventDefault();\n            body.classList.add('dragover');\n        });\n        document.addEventListener(\"dragleave\", e => {\n            e.preventDefault();\n            body.classList.remove('dragover');\n        });\n        document.addEventListener('drop', e => {\n            e.preventDefault();\n            this.upload(e.dataTransfer.files[0]);\n            body.classList.remove('dragover');\n        });\n    }\n});\n\n",
        "called_code_segment": "run (type: string = 'img') {\n        let base64 = null;\n        if (type === 'img') {\n            base64 = await this.img2Base64(this._file);\n            this.config.image = base64.replace(/data:image\\/\\w+;base64,/, '');\n            this.config.url = undefined;\n        } else if (type === 'url') {\n            this.config.image = undefined;\n            this.config.url = this.url;\n        }\n        console.log(this.config);\n        const body = Object.keys(this.config)\n                        .filter(key => this.config[key])\n                        .map(key => `${key}=${encodeURIComponent(this.config[key])}`).join('&');\n        // console.log(body);\n        const headers = new Headers();\n        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n        // let timeoutFlag = false;\n        // const timer = t => {\n        //     return new Promise(resolve => setTimeout(resolve, t))\n        //         .then(res => {\n        //             throw new Error('Time out.');\n        //             this._file = true;\n        //         });\n        // }\n        const req = fetch(url.ocr + `?access_token=${this.token}`, { method: 'POST', headers, body })\n                .then(res => res.json())\n                .then(data => {\n                    if (data.error_code) {\n                        throw new Error(`ERROR: ${data.error_code}: ${data.error_msg}`)\n                    } else {\n                        this.eventListeners['data'] &&\n                        this.eventListeners['data'].forEach(cb => cb.call(null, data.words_result));\n                        localStorage && localStorage.setItem('jsocrHistory', JSON.stringify({\n                            img: this.config.url ? this.config.url : this.config.image,\n                            data\n                        }));\n                    }\n                });\n        // Promise.race([req, timer(1000)]);\n    }",
        "invoking_code_segment": "upload (file: File | string) {\n            let ocr = null;\n            try {\n                ocr = new JsOCR(file);\n            } catch (e) {\n                alert(e);\n                return;\n            }\n            this.showLoading = true;\n            ocr.on('data', (data) => {\n                this.imgSrc = typeof file === 'string' ? file : ocr.img.src;\n                this.content = data.map(val => val.words).join('\\n');\n                this.showContent = true;\n                this.showLoading = false;\n            });\n        }",
        "feature_description": "Add a feature to handle OCR results in multiple formats (plain text, JSON) and allow the user to choose the output format.",
        "detailed_feature_description": "Modify the `run` method in #file 1 to accept an additional parameter for the output format. Update the `upload` method in #file 2 to pass this parameter and handle the different output formats accordingly.",
        "modified_complete_code": {
            "file1": "run (type: string = 'img', outputFormat: string = 'text') {\n        let base64 = null;\n        if (type === 'img') {\n            base64 = await this.img2Base64(this._file);\n            this.config.image = base64.replace(/data:image\\/\\w+;base64,/, '');\n            this.config.url = undefined;\n        } else if (type === 'url') {\n            this.config.image = undefined;\n            this.config.url = this.url;\n        }\n        console.log(this.config);\n        const body = Object.keys(this.config)\n                        .filter(key => this.config[key])\n                        .map(key => `${key}=${encodeURIComponent(this.config[key])}`).join('&');\n        // console.log(body);\n        const headers = new Headers();\n        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n\n        const req = fetch(url.ocr + `?access_token=${this.token}`, { method: 'POST', headers, body })\n                .then(res => res.json())\n                .then(data => {\n                    if (data.error_code) {\n                        throw new Error(`ERROR: ${data.error_code}: ${data.error_msg}`)\n                    } else {\n                        let result;\n                        if (outputFormat === 'json') {\n                            result = data;\n                        } else {\n                            result = data.words_result.map(val => val.words).join('\\n');\n                        }\n                        this.eventListeners['data'] &&\n                        this.eventListeners['data'].forEach(cb => cb.call(null, result));\n                        localStorage && localStorage.setItem('jsocrHistory', JSON.stringify({\n                            img: this.config.url ? this.config.url : this.config.image,\n                            data\n                        }));\n                    }\n                });\n    }",
            "file2": "upload (file: File | string, outputFormat: string = 'text') {\n            let ocr = null;\n            try {\n                ocr = new JsOCR(file);\n            } catch (e) {\n                alert(e);\n                return;\n            }\n            this.showLoading = true;\n            ocr.run('img', outputFormat);\n            ocr.on('data', (data) => {\n                if (outputFormat === 'json') {\n                    this.content = JSON.stringify(data, null, 2);\n                } else {\n                    this.imgSrc = typeof file === 'string' ? file : ocr.img.src;\n                    this.content = data;\n                }\n                this.showContent = true;\n                this.showLoading = false;\n            });\n        }"
        }
    },
    {
        "repo": "react-typescript-boilerplate",
        "content": "'react-typescript-boilerplate/app/reducers.ts'\n:/// <reference path=\"../typings/tsd.d.ts\" />\n\nimport { Reducer, combineReducers } from 'redux';\nimport { ICounterAction, ACTION } from './actions';\n\nfunction counters(state: number[] = [0, 0, 0], action: ICounterAction): number[] {\n  switch (action.type) {\n    case ACTION.IncrementCounter:\n      return [\n        ...state.slice(0, action.counterId),\n        state[action.counterId] + 1,\n        ...state.slice(action.counterId + 1),\n      ];\n\n    case ACTION.DecrementCounter:\n      return [\n        ...state.slice(0, action.counterId),\n        state[action.counterId] - 1,\n        ...state.slice(action.counterId + 1),\n      ];\n\n    case ACTION.AddCounter:\n      return [...state, 0];\n\n    default:\n      return state;\n  }\n}\n\nexport const counterApp: Reducer = combineReducers({ counters });\n\n'react-typescript-boilerplate/app/index.tsx'\n:/// <reference path=\"../typings/tsd.d.ts\" />\n\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Store, createStore } from 'redux';\nimport { Provider } from 'react-redux';\n\nimport { App } from './components/app';\nimport { counterApp } from './reducers';\n\ndeclare const require: (name: String) => any;\n\ninterface IHotModule {\n  hot?: { accept: (path: string, callback: () => void) => void };\n};\n\ndeclare const module: IHotModule;\n\nfunction configureStore(): Store {\n  const store: Store = createStore(counterApp);\n\n  if (module.hot) {\n    module.hot.accept('./reducers', () => {\n      const nextRootReducer: any = require('./reducers').counterApp;\n      store.replaceReducer(nextRootReducer);\n    });\n  }\n\n  return store;\n}\n\nconst store: Store = configureStore();\n\nclass Main extends React.Component<{}, {}> {\n  public render(): React.ReactElement<Provider> {\n    return (<Provider store={store}>\n      <App />\n    </Provider>);\n  }\n}\n\nReactDOM.render(<Main />, document.getElementById('app'));\n\n",
        "called_code_segment": "function counters(state: number[] = [0, 0, 0], action: ICounterAction): number[] {\n  switch (action.type) {\n    case ACTION.IncrementCounter:\n      return [\n        ...state.slice(0, action.counterId),\n        state[action.counterId] + 1,\n        ...state.slice(action.counterId + 1),\n      ];\n\n    case ACTION.DecrementCounter:\n      return [\n        ...state.slice(0, action.counterId),\n        state[action.counterId] - 1,\n        ...state.slice(action.counterId + 1),\n      ];\n\n    case ACTION.AddCounter:\n      return [...state, 0];\n\n    default:\n      return state;\n  }\n}",
        "invoking_code_segment": "const store: Store = configureStore();\n\nclass Main extends React.Component<{}, {}> {\n  public render(): React.ReactElement<Provider> {\n    return (<Provider store={store}>\n      <App />\n    </Provider>);\n  }\n}",
        "feature_description": "Add a new action type to reset all counters to zero.",
        "detailed_feature_description": "In the `counters` reducer, add a new case for the `ACTION.ResetCounters` action type. This will reset all counters in the state array to zero. Update the `ICounterAction` interface to include the new action type. In the `index.tsx` file, dispatch the new action when a reset button is clicked.",
        "modified_complete_code": {
            "app/reducers.ts": "//Modify: Add new action type and update reducer\nfunction counters(state: number[] = [0, 0, 0], action: ICounterAction): number[] {\n  switch (action.type) {\n    case ACTION.IncrementCounter:\n      return [\n        ...state.slice(0, action.counterId),\n        state[action.counterId] + 1,\n        ...state.slice(action.counterId + 1),\n      ];\n\n    case ACTION.DecrementCounter:\n      return [\n        ...state.slice(0, action.counterId),\n        state[action.counterId] - 1,\n        ...state.slice(action.counterId + 1),\n      ];\n\n    case ACTION.AddCounter:\n      return [...state, 0];\n\n    case ACTION.ResetCounters:\n      return state.map(() => 0); //Modify: Reset all counters to zero\n\n    default:\n      return state;\n  }\n}\n\n//New: Add new action type to ICounterAction\nexport interface ICounterAction {\n  type: ACTION;\n  counterId?: number;\n}\n\nexport enum ACTION {\n  IncrementCounter,\n  DecrementCounter,\n  AddCounter,\n  ResetCounters //New: Add new action type\n}",
            "app/index.tsx": "//Modify: Dispatch new action when reset button is clicked\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { Store, createStore } from 'redux';\nimport { Provider } from 'react-redux';\n\nimport { App } from './components/app';\nimport { counterApp } from './reducers';\nimport { ACTION } from './actions';\n\ndeclare const require: (name: String) => any;\n\ninterface IHotModule {\n  hot?: { accept: (path: string, callback: () => void) => void };\n};\n\ndeclare const module: IHotModule;\n\nfunction configureStore(): Store {\n  const store: Store = createStore(counterApp);\n\n  if (module.hot) {\n    module.hot.accept('./reducers', () => {\n      const nextRootReducer: any = require('./reducers').counterApp;\n      store.replaceReducer(nextRootReducer);\n    });\n  }\n\n  return store;\n}\n\nconst store: Store = configureStore();\n\nclass Main extends React.Component<{}, {}> {\n  public render(): React.ReactElement<Provider> {\n    return (<Provider store={store}>\n      <App />\n      <button onClick={() => store.dispatch({ type: ACTION.ResetCounters })}>Reset Counters</button> //Modify: Add reset button\n    </Provider>);\n  }\n}\n\nReactDOM.render(<Main />, document.getElementById('app'));"
        }
    },
    {
        "repo": "refactor-css",
        "content": "'refactor-css/src/extension.ts'\n:import * as fs from 'fs';\nimport * as vscode from 'vscode';\nimport Fetcher from \"./fetcher\";\nimport { promisify } from 'util';\nconst lineColumn = require('line-column');\n\nlet caching: boolean = false;\n\ninterface ClassesWrapper {\n    classes: string[];\n    ranges: vscode.Range[];\n}\n\ninterface Document {\n    path: string;\n    scheme: string;\n    getText(): string;\n    classesWrappers: ClassesWrapper[];\n}\nconst documents: Map<string, Document> = new Map();\nconst readFileAsync = promisify(fs.readFile);\n\nasync function createDocument(uri: vscode.Uri): Promise<Document | undefined> {\n    try {\n        const text = await readFileAsync(uri.fsPath);\n        const document: Document = {\n            path: uri.fsPath,\n            scheme: uri.scheme,\n            getText(): string {\n                return text.toString();\n            },\n            classesWrappers: []\n        };\n        return document;\n    } catch (error) {\n        console.error(error);\n        return;\n    }\n}\n\nfunction addDocument(uri: vscode.Uri) {\n    createDocument(uri).then(document => {\n        if (document) {\n            getClassesFromDocument(document);\n            documents.set(uri.fsPath, document);\n        }\n    }).catch(error => {\n        console.error(error);\n    });\n}\n\nfunction removeDocument(uri: vscode.Uri) {\n    documents.delete(uri.fsPath);\n}\n\nasync function cache(): Promise<void> {\n    try {\n        const uris: vscode.Uri[] = await Fetcher.findAllParsableDocuments();\n        uris.map(uri => addDocument(uri));\n    } catch (err) {\n        vscode.window.showErrorMessage(err.message);\n    }\n}\n\nfunction getClassesFromDocument(document: Document) {\n    let match;\n    const regEx = /\\bclass(Name)?=['\"]([^'\"]*)*/g;\n    const text = document.getText();\n    let currentClasses: ClassesWrapper | undefined;\n    document.classesWrappers = [];\n    while (match = regEx.exec(text)) {\n        // Get unique classes\n        const classes: string[] = [...new Set(match[2].replace(/['\"]+/g, '').match(/\\S+/g))] || [];\n        const startIndex = match.index + (match[0].length - match[2].length);\n        const endIndex = match.index + (match[0].length - match[2].length + 1) + match[2].length - 1;\n\n        const alreadyRegistered = document.classesWrappers.length > 0 && document.classesWrappers.some(classWrapper =>\n            classWrapper.classes.length === classes.length &&\n            classWrapper.classes.every(cssClass =>\n                classes.includes(cssClass)\n            )\n        );\n\n\n        const finder = lineColumn(text);\n        const startPosition = new vscode.Position(\n            finder.fromIndex(startIndex).line - 1,\n            finder.fromIndex(startIndex).col - 1\n        );\n        const endPosition = new vscode.Position(\n            finder.fromIndex(endIndex).line - 1,\n            finder.fromIndex(endIndex).col - 1\n        );\n\n        if (alreadyRegistered) {\n            currentClasses = document.classesWrappers.find(classWrapper =>\n                classWrapper.classes.length === classes.length &&\n                classWrapper.classes.every(cssClass =>\n                    classes.includes(cssClass)\n                )\n            );\n\n            if (currentClasses) {\n                currentClasses.ranges.push(new vscode.Range(\n                    startPosition,\n                    endPosition\n                ));\n            }\n        } else {\n            currentClasses = {\n                classes,\n                ranges: [\n                    new vscode.Range(\n                        startPosition,\n                        endPosition\n                    )\n                ]\n\n            };\n            document.classesWrappers.push(currentClasses);\n        }\n    }\n}\n\nexport async function activate(context: vscode.ExtensionContext) {\n    const configuration = vscode.workspace.getConfiguration();\n    const CLASSES_MINIMUM: number = configuration.get(\"refactor-css.highlightMinimumClasses\") || 3;\n    const OCCURRENCE_MINIMUM: number = configuration.get(\"refactor-css.highlightMinimumOccurrences\") || 3;\n    const workspaceRootPath: string | undefined = vscode.workspace.rootPath;\n    let hoveredClasses: ClassesWrapper | undefined;\n    let timeout: NodeJS.Timer | null = null;\n    const decorations: vscode.DecorationOptions[] = [];\n\n    caching = true;\n\n    try {\n        await cache();\n    } catch (err) {\n        vscode.window.showErrorMessage(err.message);\n        caching = false;\n    } finally {\n        caching = false;\n    }\n\n    const decorationType: vscode.TextEditorDecorationType = vscode.window.createTextEditorDecorationType({\n        light: {\n            border: '2px solid rgba(68, 168, 179, 0.4)'\n        },\n        dark: {\n            border: '2px solid rgba(68, 168, 179, 0.4)'\n        }\n    });\n    const decorationTypeSolid: vscode.TextEditorDecorationType = vscode.window.createTextEditorDecorationType({\n        light: {\n            border: '2px solid rgb(68, 168, 179)',\n            backgroundColor: 'rgba(68, 168, 179, 0.2)'\n        },\n        dark: {\n            border: '2px solid rgb(68, 168, 179)',\n            backgroundColor: 'rgba(68, 168, 179, 0.2)'\n        }\n    });\n\n    let activeEditor = vscode.window.activeTextEditor;\n    if (activeEditor) {\n        triggerUpdateDecorations();\n    }\n\n    vscode.window.onDidChangeActiveTextEditor(editor => {\n        activeEditor = editor;\n        hoveredClasses = undefined;\n        if (editor) {\n            triggerUpdateDecorations();\n        }\n    }, null, context.subscriptions);\n\n    vscode.workspace.onDidChangeTextDocument(event => {\n        if (activeEditor && event.document === activeEditor.document) {\n            const editor = activeEditor;\n            const document: Document = {\n                path: editor.document.uri.path,\n                scheme: editor.document.uri.scheme,\n                getText() {\n                    return editor.document.getText();\n                },\n                classesWrappers: []\n            };\n            getClassesFromDocument(document);\n            documents.set(editor.document.uri.fsPath, document);\n            triggerUpdateDecorations();\n        }\n    }, null, context.subscriptions);\n\n    function getActiveDocument(): Document | undefined {\n        if (activeEditor) {\n            return documents.get(activeEditor.document.uri.path);\n        }\n        return;\n    }\n\n    function triggerUpdateDecorations() {\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n        timeout = setTimeout(updateDecorations, 500);\n    }\n\n    function updateDecorations() {\n        if (!activeEditor) {\n            return;\n        }\n\n        const document = getActiveDocument();\n\n        if (document) {\n            decorations.length = 0;\n            getClassesFromDocument(document);\n\n            // Iterate over every class combination of current document.\n            for (const classesWrapper of document.classesWrappers) {\n                const occurrences = Array.from(documents.entries()).reduce((prev, [path, doc]) => {\n                    const equalWrapper = doc.classesWrappers.find(currentClassesWrapper =>\n                        currentClassesWrapper.classes.length === classesWrapper.classes.length &&\n                        currentClassesWrapper.classes.every(cssClass => {\n                            return classesWrapper.classes.includes(cssClass);\n                        })\n                    );\n\n                    if (!equalWrapper) {\n                        return prev;\n                    }\n\n                    return prev + equalWrapper.ranges.length;\n                }, 0);\n\n                if (classesWrapper.classes.length >= CLASSES_MINIMUM && occurrences >= OCCURRENCE_MINIMUM) {\n                    for (const range of classesWrapper.ranges) {\n                        const decoration: vscode.DecorationOptions = { range };\n                        decorations.push(decoration);\n                    }\n                }\n            }\n            activeEditor.setDecorations(decorationType, decorations);\n            updateHoveredDecorations();\n        }\n    }\n\n    function updateHoveredDecorations() {\n        if (!activeEditor) {\n            return;\n        }\n        if (hoveredClasses) {\n            activeEditor.setDecorations(decorationTypeSolid, hoveredClasses.ranges);\n        } else {\n            activeEditor.setDecorations(decorationTypeSolid, []);\n        }\n    }\n\n    const include = configuration.get(\"refactor-css.include\");\n    const exclude = configuration.get(\"refactor-css.exclude\");\n\n    if (include) {\n        const fileWatcher = vscode.workspace.createFileSystemWatcher(include as vscode.GlobPattern);\n\n        fileWatcher.onDidCreate(uri => addDocument(uri));\n        fileWatcher.onDidChange(uri => addDocument(uri));\n        fileWatcher.onDidDelete(uri => removeDocument(uri));\n    }\n\n    vscode.languages.registerHoverProvider(\n        [\n            { scheme: 'file', language: 'html', },\n            { scheme: 'file', language: 'jade', },\n            { scheme: 'file', language: 'razor', },\n            { scheme: 'file', language: 'php', },\n            { scheme: 'file', language: 'blade', },\n            { scheme: 'file', language: 'twig', },\n            { scheme: 'file', language: 'markdown', },\n            { scheme: 'file', language: 'erb', },\n            { scheme: 'file', language: 'handlebars', },\n            { scheme: 'file', language: 'ejs', },\n            { scheme: 'file', language: 'nunjucks', },\n            { scheme: 'file', language: 'haml', },\n            { scheme: 'file', language: 'leaf', },\n            { scheme: 'file', language: 'vue' },\n        ],\n        {\n            provideHover: (document, position) => {\n                const range1: vscode.Range = new vscode.Range(\n                    new vscode.Position(Math.max(position.line - 5, 0), 0),\n                    position\n                );\n                const textBeforeCursor: string = document.getText(range1);\n\n                if (!/\\bclass(Name)?=['\"][^'\"]*$/.test(textBeforeCursor)) {\n                    return;\n                }\n\n                const range2: vscode.Range = new vscode.Range(\n                    new vscode.Position(Math.max(position.line - 5, 0), 0),\n                    position.with({ line: position.line + 1 })\n                );\n                const text2: string = document.getText(range2);\n                const textAfterCursor = text2.substr(textBeforeCursor.length).match(/^([^\"']*)/);\n\n                if (textAfterCursor) {\n                    const str = textBeforeCursor + textAfterCursor[0];\n                    const matches = str.match(/\\bclass(Name)?=[\"']([^\"']*)$/);\n                    const activeDocument = getActiveDocument();\n                    if (activeDocument && matches && matches[2]) {\n                        const classes: string[] = [...new Set(matches[2].replace(/['\"]+/g, '').match(/\\S+/g))] || [];\n                        hoveredClasses = activeDocument.classesWrappers.find(classWrapper =>\n                            classWrapper.classes.length === classes.length &&\n                            classWrapper.classes.every(cssClass =>\n                                classes.includes(cssClass)\n                            )\n                        );\n\n                        if (hoveredClasses) {\n                            const range = new vscode.Range(\n                                new vscode.Position(\n                                    position.line,\n                                    position.character +\n                                    str.length -\n                                    textBeforeCursor.length -\n                                    matches[2].length\n                                ),\n                                new vscode.Position(\n                                    position.line,\n                                    position.character + str.length - textBeforeCursor.length\n                                )\n                            );\n\n                            updateHoveredDecorations();\n                            const hoverStr = new vscode.MarkdownString();\n                            hoverStr.isTrusted = true;\n                            hoverStr.appendCodeblock(`<element class=\"${classes.join(' ')}\"/>`, 'html');\n                            const positions: string[] = [];\n                            let total = 0;\n\n                            for (const [path, document] of documents.entries()) {\n                                const equalWrapper = document.classesWrappers.find(classWrapper => {\n\n                                    if (!hoveredClasses) { return false; }\n                                    return classWrapper.classes.length === hoveredClasses.classes.length &&\n                                        classWrapper.classes.every(cssClass => {\n                                            if (!hoveredClasses) { return false; }\n\n                                            return hoveredClasses.classes.includes(cssClass);\n                                        });\n                                });\n\n                                if (equalWrapper) {\n                                    const args = vscode.Uri.parse(`${document.scheme}://${document.path}`);\n                                    const count = equalWrapper.ranges.length;\n\n                                    const commandUri = vscode.Uri.parse(`command:vscode.open?${\n                                        encodeURIComponent(JSON.stringify(args))\n                                        }`);\n\n                                    let line = `${count}x in [${\n                                        document.path.substr(workspaceRootPath ? workspaceRootPath.length : 0)\n                                        }](${commandUri})`;\n                                    if (document.path === activeDocument.path) {\n                                        line = `__${line}__`;\n                                    }\n                                    positions.push(line);\n                                    total += count;\n                                }\n                            }\n\n                            if (positions.length > 1) {\n                                hoverStr.appendMarkdown(`Found ${total} times in ${positions.length} files:  \\n\\n`);\n                            }\n                            positions.forEach(position => {\n                                hoverStr.appendMarkdown(`${position}  \\n`);\n                            });\n\n                            return new vscode.Hover(hoverStr, range);\n                        }\n                    }\n                }\n\n                return null;\n            }\n        }\n    );\n}\n\nexport function deactivate() {\n}\n\n'refactor-css/src/test/extension.test.ts'\n://\n// Note: This example test is leveraging the Mocha test framework.\n// Please refer to their documentation on https://mochajs.org/ for help.\n//\n\n// The module 'assert' provides assertion methods from node\nimport * as assert from 'assert';\n\n// You can import and use all API from the 'vscode' module\n// as well as import your extension to test it\n// import * as vscode from 'vscode';\n// import * as myExtension from '../extension';\n\n// Defines a Mocha test suite to group tests of similar kind together\nsuite(\"Extension Tests\", function () {\n\n    // Defines a Mocha unit test\n    test(\"Something 1\", function() {\n        assert.equal(-1, [1, 2, 3].indexOf(5));\n        assert.equal(-1, [1, 2, 3].indexOf(0));\n    });\n});\n",
        "called_code_segment": "function getClassesFromDocument(document: Document) {\n    let match;\n    const regEx = /\\bclass(Name)?=['\"]([^'\"]*)*/g;\n    const text = document.getText();\n    let currentClasses: ClassesWrapper | undefined;\n    document.classesWrappers = [];\n    while (match = regEx.exec(text)) {\n        // Get unique classes\n        const classes: string[] = [...new Set(match[2].replace(/['\"]+/g, '').match(/\\S+/g))] || [];\n        const startIndex = match.index + (match[0].length - match[2].length);\n        const endIndex = match.index + (match[0].length - match[2].length + 1) + match[2].length - 1;\n\n        const alreadyRegistered = document.classesWrappers.length > 0 && document.classesWrappers.some(classWrapper =>\n            classWrapper.classes.length === classes.length &&\n            classWrapper.classes.every(cssClass =>\n                classes.includes(cssClass)\n            )\n        );\n\n\n        const finder = lineColumn(text);\n        const startPosition = new vscode.Position(\n            finder.fromIndex(startIndex).line - 1,\n            finder.fromIndex(startIndex).col - 1\n        );\n        const endPosition = new vscode.Position(\n            finder.fromIndex(endIndex).line - 1,\n            finder.fromIndex(endIndex).col - 1\n        );\n\n        if (alreadyRegistered) {\n            currentClasses = document.classesWrappers.find(classWrapper =>\n                classWrapper.classes.length === classes.length &&\n                classWrapper.classes.every(cssClass =>\n                    classes.includes(cssClass)\n                )\n            );\n\n            if (currentClasses) {\n                currentClasses.ranges.push(new vscode.Range(\n                    startPosition,\n                    endPosition\n                ));\n            }\n        } else {\n            currentClasses = {\n                classes,\n                ranges: [\n                    new vscode.Range(\n                        startPosition,\n                        endPosition\n                    )\n                ]\n\n            };\n            document.classesWrappers.push(currentClasses);\n        }\n    }\n}",
        "invoking_code_segment": "vscode.workspace.onDidChangeTextDocument(event => {\n    if (activeEditor && event.document === activeEditor.document) {\n        const editor = activeEditor;\n        const document: Document = {\n            path: editor.document.uri.path,\n            scheme: editor.document.uri.scheme,\n            getText() {\n                return editor.document.getText();\n            },\n            classesWrappers: []\n        };\n        getClassesFromDocument(document);\n        documents.set(editor.document.uri.fsPath, document);\n        triggerUpdateDecorations();\n    }\n}, null, context.subscriptions);",
        "feature_description": "Add a feature to log the number of classes found in the document to the console.",
        "detailed_feature_description": "Modify the `getClassesFromDocument` function to log the total number of classes found in the document to the console. Update the invoking code segment to ensure the modified function is called correctly.",
        "modified_complete_code": {
            "file1": "function getClassesFromDocument(document: Document) {\n    let match;\n    const regEx = /\\bclass(Name)?=['\"]([^'\"]*)*/g;\n    const text = document.getText();\n    let currentClasses: ClassesWrapper | undefined;\n    document.classesWrappers = [];\n    let totalClasses = 0; // #New\n    while (match = regEx.exec(text)) {\n        // Get unique classes\n        const classes: string[] = [...new Set(match[2].replace(/['\"]+/g, '').match(/\\S+/g))] || [];\n        totalClasses += classes.length; // #New\n        const startIndex = match.index + (match[0].length - match[2].length);\n        const endIndex = match.index + (match[0].length - match[2].length + 1) + match[2].length - 1;\n\n        const alreadyRegistered = document.classesWrappers.length > 0 && document.classesWrappers.some(classWrapper =>\n            classWrapper.classes.length === classes.length &&\n            classWrapper.classes.every(cssClass =>\n                classes.includes(cssClass)\n            )\n        );\n\n\n        const finder = lineColumn(text);\n        const startPosition = new vscode.Position(\n            finder.fromIndex(startIndex).line - 1,\n            finder.fromIndex(startIndex).col - 1\n        );\n        const endPosition = new vscode.Position(\n            finder.fromIndex(endIndex).line - 1,\n            finder.fromIndex(endIndex).col - 1\n        );\n\n        if (alreadyRegistered) {\n            currentClasses = document.classesWrappers.find(classWrapper =>\n                classWrapper.classes.length === classes.length &&\n                classWrapper.classes.every(cssClass =>\n                    classes.includes(cssClass)\n                )\n            );\n\n            if (currentClasses) {\n                currentClasses.ranges.push(new vscode.Range(\n                    startPosition,\n                    endPosition\n                ));\n            }\n        } else {\n            currentClasses = {\n                classes,\n                ranges: [\n                    new vscode.Range(\n                        startPosition,\n                        endPosition\n                    )\n                ]\n\n            };\n            document.classesWrappers.push(currentClasses);\n        }\n    }\n    console.log(`Total classes found: ${totalClasses}`); // #New\n}",
            "file2": "vscode.workspace.onDidChangeTextDocument(event => {\n    if (activeEditor && event.document === activeEditor.document) {\n        const editor = activeEditor;\n        const document: Document = {\n            path: editor.document.uri.path,\n            scheme: editor.document.uri.scheme,\n            getText() {\n                return editor.document.getText();\n            },\n            classesWrappers: []\n        };\n        getClassesFromDocument(document); // #Modify\n        documents.set(editor.document.uri.fsPath, document);\n        triggerUpdateDecorations();\n    }\n}, null, context.subscriptions);"
        }
    },
    {
        "repo": "rules",
        "content": "'rules/apps/doc-app/src/app/layout/aside-nav/aside-nav.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { HeadingsListService } from '../../services/headings-list.service';\nimport { NavigationEnd, Router, RouterEvent } from '@angular/router';\nimport { filter } from 'rxjs/operators';\nimport { AnchorScrollService } from '../../services/anchor-scroll.service';\n\n\n@Component({\n  selector: 'app-aside-nav',\n  templateUrl: './aside-nav.component.html',\n  styleUrls: ['./aside-nav.component.scss']\n})\nexport class AsideNavComponent implements OnInit {\n  navItems: HTMLElement[];\n  activeRoute: string;\n  activeFragment: string;\n\n  constructor(\n    private headingsListService: HeadingsListService,\n    private router: Router,\n  ) {\n    this.router.events.pipe(\n        filter((event: RouterEvent) => event instanceof NavigationEnd)\n      )\n      .subscribe(() => {\n        this.activeRoute = this.router.url.split('#')[0].replace('/', '');\n        this.activeFragment = this.router.url.split('#')[1];\n      });\n  }\n\n  ngOnInit(): void {\n    this.headingsListService.navList\n      .subscribe((data: HTMLElement[]) => {\n        this.navItems = data;\n      });\n  }\n}\n\n'rules/apps/doc-app/src/app/layout/aside-nav/aside-nav.component.spec.ts'\n:import { ComponentFixture, TestBed, waitForAsync } from '@angular/core/testing';\n\nimport { AsideNavComponent } from './aside-nav.component';\n\ndescribe('AsideNavComponent', () => {\n  let component: AsideNavComponent;\n  let fixture: ComponentFixture<AsideNavComponent>;\n\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      declarations: [ AsideNavComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(AsideNavComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n\n",
        "called_code_segment": "export class AsideNavComponent implements OnInit {\n  navItems: HTMLElement[];\n  activeRoute: string;\n  activeFragment: string;\n\n  constructor(\n    private headingsListService: HeadingsListService,\n    private router: Router,\n  ) {\n    this.router.events.pipe(\n        filter((event: RouterEvent) => event instanceof NavigationEnd)\n      )\n      .subscribe(() => {\n        this.activeRoute = this.router.url.split('#')[0].replace('/', '');\n        this.activeFragment = this.router.url.split('#')[1];\n      });\n  }\n\n  ngOnInit(): void {\n    this.headingsListService.navList\n      .subscribe((data: HTMLElement[]) => {\n        this.navItems = data;\n      });\n  }\n}",
        "invoking_code_segment": "import { AsideNavComponent } from './aside-nav.component';",
        "feature_description": "Add a feature to highlight the active navigation item based on the current route and fragment.",
        "detailed_feature_description": "Modify the AsideNavComponent to include a method that highlights the active navigation item based on the current route and fragment. Update the corresponding HTML template to bind the active class to the navigation items.",
        "modified_complete_code": {
            "aside-nav.component.ts": "import { Component, OnInit } from '@angular/core';\nimport { HeadingsListService } from '../../services/headings-list.service';\nimport { NavigationEnd, Router, RouterEvent } from '@angular/router';\nimport { filter } from 'rxjs/operators';\n\n@Component({\n  selector: 'app-aside-nav',\n  templateUrl: './aside-nav.component.html',\n  styleUrls: ['./aside-nav.component.scss']\n})\nexport class AsideNavComponent implements OnInit {\n  navItems: HTMLElement[];\n  activeRoute: string;\n  activeFragment: string;\n\n  constructor(\n    private headingsListService: HeadingsListService,\n    private router: Router,\n  ) {\n    this.router.events.pipe(\n        filter((event: RouterEvent) => event instanceof NavigationEnd)\n      )\n      .subscribe(() => {\n        this.activeRoute = this.router.url.split('#')[0].replace('/', '');\n        this.activeFragment = this.router.url.split('#')[1];\n      });\n  }\n\n  ngOnInit(): void {\n    this.headingsListService.navList\n      .subscribe((data: HTMLElement[]) => {\n        this.navItems = data;\n      });\n  }\n\n  #Modify isActive(item: HTMLElement): boolean {\n    const itemId = item.getAttribute('id');\n    return itemId === this.activeFragment;\n  }\n}",
            "aside-nav.component.html": "<ul>\n  <li *ngFor=\"let item of navItems\" [class.active]=\"isActive(item)\">\n    <a [href]=\"item.getAttribute('id')\">{{ item.textContent }}</a>\n  </li>\n</ul>\n\n#New [class.active]=\"isActive(item)\" binds the active class to the navigation item if it is the current active fragment."
        }
    },
    {
        "repo": "scratchable",
        "content": "'scratchable/src/renderer.ts'\n:export interface RendererOptions {\n  container: HTMLElement;\n  background:\n    | { type: \"single\"; color: string }\n    | {\n        type: \"linear-gradient\";\n        gradients: { offset: number; color: string }[];\n      }\n    | { type: \"image\"; url: string };\n}\n\nexport class Renderer {\n  private readonly container: HTMLElement;\n  private readonly canvas: HTMLCanvasElement;\n  private readonly ctx: CanvasRenderingContext2D;\n  private readonly background: RendererOptions[\"background\"];\n\n  constructor(options: RendererOptions) {\n    this.container = options.container;\n    this.canvas = document.createElement(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\")!;\n    this.background = options.background;\n  }\n\n  public get dpr() {\n    return window.devicePixelRatio;\n  }\n\n  public get percentage() {\n    const { data } = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    const stride = 32;\n    const totalPixels = data.length / stride;\n    let scratchedPixels = 0;\n\n    for (let i = 0; i < data.length; i += stride) {\n      if (data[i] === 0) {\n        scratchedPixels++;\n      }\n    }\n    return scratchedPixels / totalPixels;\n  }\n\n  public async render() {\n    this.container.style.position = \"relative\";\n\n    const dpr = window.devicePixelRatio;\n    const canvasWidth = this.container.offsetWidth * dpr;\n    const canvasHeight = this.container.offsetHeight * dpr;\n\n    this.canvas.width = canvasWidth;\n    this.canvas.height = canvasHeight;\n\n    this.canvas.style.width = \"100%\";\n    this.canvas.style.height = \"100%\";\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.top = \"0\";\n    this.canvas.style.left = \"0\";\n    this.canvas.style.right = \"0\";\n    this.canvas.style.bottom = \"0\";\n\n    return new Promise<void>((resolve) => {\n      const renderCanvas = () => {\n        this.ctx.globalCompositeOperation = \"destination-out\";\n        this.container.appendChild(this.canvas);\n        resolve();\n      };\n\n      switch (this.background.type) {\n        case \"single\": {\n          this.ctx.fillStyle = this.background.color;\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          renderCanvas();\n          return;\n        }\n        case \"linear-gradient\": {\n          const grd = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);\n\n          this.background.gradients.forEach((gradient) => {\n            grd.addColorStop(gradient.offset, gradient.color);\n          });\n\n          this.ctx.fillStyle = grd;\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          renderCanvas();\n          return;\n        }\n        case \"image\": {\n          const image = new Image();\n\n          image.onload = () => {\n            this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);\n            renderCanvas();\n          };\n\n          image.src = this.background.url;\n          return;\n        }\n      }\n    });\n  }\n\n  public circle(x: number, y: number, radius: number) {\n    const dpr = this.dpr;\n\n    this.ctx.beginPath();\n    this.ctx.arc(x * dpr, y * dpr, radius * dpr, 0, 2 * Math.PI);\n    this.ctx.fill();\n  }\n\n  public line(from: { x: number; y: number }, to: { x: number; y: number }, width: number) {\n    const dpr = this.dpr;\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(from.x * dpr, from.y * dpr);\n    this.ctx.lineTo(to.x * dpr, to.y * dpr);\n    this.ctx.lineWidth = width * dpr;\n    this.ctx.stroke();\n  }\n\n  public destroy() {\n    this.container.removeChild(this.canvas);\n  }\n}\n\n'scratchable/src/index.ts'\n:import {\n  MouseScratcher,\n  Scratcher,\n  ScratcherEventName,\n  ScratcherEvent,\n  ScratcherEventHandler,\n  ScratcherOptions,\n  TouchScratcher,\n} from \"./scratcher\";\nimport { RendererOptions } from \"./renderer\";\n\nexport type ScratchableEventName = ScratcherEventName;\n\nexport type ScratchableEvent = ScratcherEvent;\n\nexport type ScratchableEventHandler = ScratcherEventHandler;\n\nexport type ScratchableOptions = ScratcherOptions & RendererOptions;\n\nexport class Scratchable {\n  private readonly scratcher: Scratcher;\n\n  constructor(options: ScratchableOptions) {\n    this.scratcher = this.isTouchDevice ? new TouchScratcher(options) : new MouseScratcher(options);\n  }\n\n  private get isTouchDevice() {\n    return \"ontouchstart\" in window || navigator.maxTouchPoints > 0;\n  }\n\n  public async render() {\n    await this.scratcher.render();\n  }\n\n  public destroy() {\n    this.scratcher.destroy();\n  }\n\n  public addEventListener(event: ScratcherEventName, handler: ScratcherEventHandler) {\n    this.scratcher.events.on(event, handler);\n  }\n\n  public removeEventListener(event: ScratcherEventName, handler: ScratcherEventHandler) {\n    this.scratcher.events.off(event, handler);\n  }\n}\n\n",
        "called_code_segment": "public async render() {\n    await this.scratcher.render();\n  }",
        "invoking_code_segment": "public async render() {\n    await this.scratcher.render();\n  }",
        "feature_description": "Add a feature to allow custom rendering functions to be passed to the Scratchable class.",
        "detailed_feature_description": "Modify the Scratchable class to accept an optional custom rendering function in its constructor. This function will be invoked instead of the default rendering logic if provided. Update the corresponding code in the Scratcher class to handle this new feature.",
        "modified_complete_code": {
            "scratchable/src/index.ts": "import {\n  MouseScratcher, \n  Scratcher, \n  ScratcherEventName, \n  ScratcherEvent, \n  ScratcherEventHandler, \n  ScratcherOptions, \n  TouchScratcher,\n} from \"./scratcher\";\nimport { RendererOptions } from \"./renderer\";\n\nexport type ScratchableEventName = ScratcherEventName;\nexport type ScratchableEvent = ScratcherEvent;\nexport type ScratchableEventHandler = ScratcherEventHandler;\nexport type ScratchableOptions = ScratcherOptions & RendererOptions & {\n  customRender?: () => Promise<void>;\n};\n\nexport class Scratchable {\n  private readonly scratcher: Scratcher;\n  private readonly customRender?: () => Promise<void>;\n\n  constructor(options: ScratchableOptions) {\n    this.scratcher = this.isTouchDevice ? new TouchScratcher(options) : new MouseScratcher(options);\n    this.customRender = options.customRender;\n  }\n\n  private get isTouchDevice() {\n    return \"ontouchstart\" in window || navigator.maxTouchPoints > 0;\n  }\n\n  public async render() {\n    if (this.customRender) {\n      await this.customRender();\n    } else {\n      await this.scratcher.render();\n    }\n  }\n\n  public destroy() {\n    this.scratcher.destroy();\n  }\n\n  public addEventListener(event: ScratcherEventName, handler: ScratcherEventHandler) {\n    this.scratcher.events.on(event, handler);\n  }\n\n  public removeEventListener(event: ScratcherEventName, handler: ScratcherEventHandler) {\n    this.scratcher.events.off(event, handler);\n  }\n}\n",
            "scratchable/src/scratcher.ts": "import { Renderer, RendererOptions } from \"./renderer\";\nimport EventEmitter from \"events\";\n\nexport type ScratcherEventName = \"start\" | \"move\" | \"end\";\nexport type ScratcherEvent = {\n  type: ScratcherEventName;\n  x: number;\n  y: number;\n};\nexport type ScratcherEventHandler = (event: ScratcherEvent) => void;\nexport type ScratcherOptions = RendererOptions & {\n  brushSize: number;\n};\n\nexport abstract class Scratcher {\n  protected readonly renderer: Renderer;\n  protected readonly brushSize: number;\n  public readonly events: EventEmitter;\n\n  constructor(options: ScratcherOptions) {\n    this.renderer = new Renderer(options);\n    this.brushSize = options.brushSize;\n    this.events = new EventEmitter();\n  }\n\n  public async render() {\n    await this.renderer.render();\n  }\n\n  public destroy() {\n    this.renderer.destroy();\n  }\n\n  protected abstract onStart(x: number, y: number): void;\n  protected abstract onMove(x: number, y: number): void;\n  protected abstract onEnd(x: number, y: number): void;\n}\n\nexport class MouseScratcher extends Scratcher {\n  private isScratching = false;\n\n  constructor(options: ScratcherOptions) {\n    super(options);\n    this.renderer.canvas.addEventListener(\"mousedown\", this.handleMouseDown);\n    this.renderer.canvas.addEventListener(\"mousemove\", this.handleMouseMove);\n    this.renderer.canvas.addEventListener(\"mouseup\", this.handleMouseUp);\n  }\n\n  private handleMouseDown = (event: MouseEvent) => {\n    this.isScratching = true;\n    this.onStart(event.offsetX, event.offsetY);\n  };\n\n  private handleMouseMove = (event: MouseEvent) => {\n    if (this.isScratching) {\n      this.onMove(event.offsetX, event.offsetY);\n    }\n  };\n\n  private handleMouseUp = (event: MouseEvent) => {\n    this.isScratching = false;\n    this.onEnd(event.offsetX, event.offsetY);\n  };\n\n  protected onStart(x: number, y: number) {\n    this.renderer.circle(x, y, this.brushSize);\n    this.events.emit(\"start\", { type: \"start\", x, y });\n  }\n\n  protected onMove(x: number, y: number) {\n    this.renderer.circle(x, y, this.brushSize);\n    this.events.emit(\"move\", { type: \"move\", x, y });\n  }\n\n  protected onEnd(x: number, y: number) {\n    this.events.emit(\"end\", { type: \"end\", x, y });\n  }\n}\n\nexport class TouchScratcher extends Scratcher {\n  private isScratching = false;\n\n  constructor(options: ScratcherOptions) {\n    super(options);\n    this.renderer.canvas.addEventListener(\"touchstart\", this.handleTouchStart);\n    this.renderer.canvas.addEventListener(\"touchmove\", this.handleTouchMove);\n    this.renderer.canvas.addEventListener(\"touchend\", this.handleTouchEnd);\n  }\n\n  private handleTouchStart = (event: TouchEvent) => {\n    this.isScratching = true;\n    const { offsetX, offsetY } = event.touches[0];\n    this.onStart(offsetX, offsetY);\n  };\n\n  private handleTouchMove = (event: TouchEvent) => {\n    if (this.isScratching) {\n      const { offsetX, offsetY } = event.touches[0];\n      this.onMove(offsetX, offsetY);\n    }\n  };\n\n  private handleTouchEnd = (event: TouchEvent) => {\n    this.isScratching = false;\n    const { offsetX, offsetY } = event.changedTouches[0];\n    this.onEnd(offsetX, offsetY);\n  };\n\n  protected onStart(x: number, y: number) {\n    this.renderer.circle(x, y, this.brushSize);\n    this.events.emit(\"start\", { type: \"start\", x, y });\n  }\n\n  protected onMove(x: number, y: number) {\n    this.renderer.circle(x, y, this.brushSize);\n    this.events.emit(\"move\", { type: \"move\", x, y });\n  }\n\n  protected onEnd(x: number, y: number) {\n    this.events.emit(\"end\", { type: \"end\", x, y });\n  }\n}\n"
        }
    },
    {
        "repo": "stromjs",
        "content": "'stromjs/src/functions/accumulator.ts'\n:import { Transform, TransformOptions } from \"stream\";\n\nexport enum FlushStrategy {\n    rolling = \"rolling\",\n    sliding = \"sliding\",\n}\n\nexport type AccumulatorByIteratee<T> = (event: T, bufferChunk: T) => boolean;\n\nfunction _accumulator<T>(\n    accumulateBy: (data: T, buffer: T[], stream: Transform) => void,\n    shouldFlush: boolean = true,\n    options: TransformOptions = {},\n) {\n    const buffer: T[] = [];\n    return new Transform({\n        ...options,\n        transform(data: T, encoding, callback) {\n            try {\n                accumulateBy(data, buffer, this);\n                callback();\n            } catch (err) {\n                callback(err);\n            }\n        },\n        flush(callback) {\n            if (shouldFlush) {\n                this.push(buffer);\n            }\n            callback();\n        },\n    });\n}\n\nfunction _sliding<T>(\n    windowLength: number,\n    key?: string,\n): (event: T, buffer: T[], stream: Transform) => void {\n    return (event: T, buffer: T[], stream: Transform) => {\n        if (key) {\n            let index = 0;\n            if (event[key] === undefined) {\n                stream.emit(\n                    \"error\",\n                    new Error(\n                        `Key is missing in event: (${key}, ${JSON.stringify(\n                            event,\n                        )})`,\n                    ),\n                );\n                stream.resume();\n                return;\n            }\n            while (\n                index < buffer.length &&\n                buffer[index][key] + windowLength <= event[key]\n            ) {\n                index++;\n            }\n            buffer.splice(0, index);\n        } else if (buffer.length === windowLength) {\n            buffer.shift();\n        }\n        buffer.push(event);\n        stream.push([...buffer]);\n    };\n}\n\nfunction _slidingByFunction<T>(\n    iteratee: AccumulatorByIteratee<T>,\n): (event: T, buffer: T[], stream: Transform) => void {\n    return (event: T, buffer: T[], stream: Transform) => {\n        let index = 0;\n        while (index < buffer.length && iteratee(event, buffer[index])) {\n            index++;\n        }\n        buffer.splice(0, index);\n        buffer.push(event);\n        stream.push([...buffer]);\n    };\n}\n\nfunction _rollingByFunction<T>(\n    iteratee: AccumulatorByIteratee<T>,\n): (event: T, buffer: T[], stream: Transform) => void {\n    return (event: T, buffer: T[], stream: Transform) => {\n        if (iteratee) {\n            if (buffer.length > 0 && iteratee(event, buffer[0])) {\n                stream.push(buffer.slice(0));\n                buffer.length = 0;\n            }\n        }\n        buffer.push(event);\n    };\n}\n\nfunction _rolling<T>(\n    windowLength: number,\n    key?: string,\n): (event: T, buffer: T[], stream: Transform) => void {\n    return (event: T, buffer: T[], stream: Transform) => {\n        if (key) {\n            if (event[key] === undefined) {\n                stream.emit(\n                    \"error\",\n                    new Error(\n                        `Key is missing in event: (${key}, ${JSON.stringify(\n                            event,\n                        )})`,\n                    ),\n                );\n                stream.resume();\n                return;\n            } else if (\n                buffer.length > 0 &&\n                buffer[0][key] + windowLength <= event[key]\n            ) {\n                stream.push(buffer.slice(0));\n                buffer.length = 0;\n            }\n        } else if (buffer.length === windowLength) {\n            stream.push(buffer.slice(0));\n            buffer.length = 0;\n        }\n        buffer.push(event);\n    };\n}\n\nexport function accumulator(\n    flushStrategy: FlushStrategy,\n    batchSize: number,\n    keyBy?: string,\n    options?: TransformOptions,\n): Transform {\n    switch (flushStrategy) {\n        case FlushStrategy.sliding:\n            return sliding(batchSize, keyBy, options);\n        case FlushStrategy.rolling:\n            return rolling(batchSize, keyBy, options);\n    }\n}\n\nexport function accumulatorBy<T>(\n    flushStrategy: FlushStrategy,\n    iteratee: AccumulatorByIteratee<T>,\n    options?: TransformOptions,\n): Transform {\n    switch (flushStrategy) {\n        case FlushStrategy.sliding:\n            return slidingBy(iteratee, options);\n        case FlushStrategy.rolling:\n            return rollingBy(iteratee, options);\n    }\n}\n\nfunction sliding(\n    windowLength: number,\n    key?: string,\n    options?: TransformOptions,\n): Transform {\n    return _accumulator(_sliding(windowLength, key), false, options);\n}\n\nfunction slidingBy<T>(\n    iteratee: AccumulatorByIteratee<T>,\n    options?: TransformOptions,\n): Transform {\n    return _accumulator(_slidingByFunction(iteratee), false, options);\n}\n\nfunction rolling(\n    windowLength: number,\n    key?: string,\n    options?: TransformOptions,\n): Transform {\n    return _accumulator(_rolling(windowLength, key), true, options);\n}\n\nfunction rollingBy<T>(\n    iteratee: AccumulatorByIteratee<T>,\n    options?: TransformOptions,\n): Transform {\n    return _accumulator(_rollingByFunction(iteratee), true, options);\n}\n\n'stromjs/tests/accumulator.spec.ts'\n:import test from \"ava\";\nimport { expect } from \"chai\";\nimport { Readable } from \"stream\";\nimport { accumulator, accumulatorBy } from \"../src\";\nimport { FlushStrategy } from \"../src/functions/accumulator\";\nimport { performance } from \"perf_hooks\";\n\ntest(\"accumulator() rolling\", (t) => {\n    t.plan(3);\n    let chunkIndex = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const firstFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n    ];\n    const secondFlush = [\n        { ts: 2, key: \"d\" },\n        { ts: 3, key: \"e\" },\n    ];\n    const thirdFlush = [{ ts: 4, key: \"f\" }];\n    const flushes = [firstFlush, secondFlush, thirdFlush];\n\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(\n                accumulator(FlushStrategy.rolling, 2, undefined, {\n                    objectMode: true,\n                }),\n            )\n            .on(\"data\", (flush: TestObject[]) => {\n                t.deepEqual(flush, flushes[chunkIndex]);\n                chunkIndex++;\n            })\n            .on(\"error\", (e: any) => {\n                reject(e);\n            })\n            .on(\"end\", resolve);\n        [...firstFlush, ...secondFlush, ...thirdFlush].forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulator() rolling with key\", (t) => {\n    t.plan(2);\n    let chunkIndex = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const firstFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 2, key: \"d\" },\n    ];\n    const secondFlush = [{ ts: 3, key: \"e\" }];\n    const flushes = [firstFlush, secondFlush];\n\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(\n                accumulator(FlushStrategy.rolling, 3, \"ts\", {\n                    objectMode: true,\n                }),\n            )\n            .on(\"data\", (flush: TestObject[]) => {\n                t.deepEqual(flush, flushes[chunkIndex]);\n                chunkIndex++;\n            })\n            .on(\"error\", (e: any) => {\n                reject(e);\n            })\n            .on(\"end\", resolve);\n        [...firstFlush, ...secondFlush].forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulator() rolling should emit error and ignore chunk when its missing key\", (t) => {\n    t.plan(2);\n    let index = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const accumulatorStream = accumulator(\n        FlushStrategy.rolling,\n        3,\n        \"nonExistingKey\",\n        { objectMode: true },\n    );\n    const input = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n    ];\n\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(accumulatorStream)\n            .on(\"data\", (flush: TestObject[]) => {\n                // No valid data output\n                expect(flush).to.deep.equal([]);\n            })\n            .on(\"error\", (err: any) => {\n                source.pipe(accumulatorStream);\n                accumulatorStream.resume();\n                expect(err.message).to.equal(\n                    `Key is missing in event: (nonExistingKey, ${JSON.stringify(\n                        input[index],\n                    )})`,\n                );\n                index++;\n                t.pass();\n            })\n            .on(\"end\", resolve);\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulator() rolling should emit error, ignore chunk when key is missing and continue processing chunks correctly\", (t) => {\n    t.plan(3);\n    let chunkIndex = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const accumulatorStream = accumulator(FlushStrategy.rolling, 3, \"ts\", {\n        objectMode: true,\n    });\n    const input = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { key: \"d\" },\n        { ts: 3, key: \"e\" },\n    ];\n    const firstFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n    ];\n    const secondFlush = [{ ts: 3, key: \"e\" }];\n    const flushes = [firstFlush, secondFlush];\n\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(accumulatorStream)\n            .on(\"data\", (flush: TestObject[]) => {\n                t.deepEqual(flush, flushes[chunkIndex]);\n                chunkIndex++;\n            })\n            .on(\"error\", (err: any) => {\n                source.pipe(accumulatorStream);\n                accumulatorStream.resume();\n                expect(err.message).to.equal(\n                    `Key is missing in event: (ts, ${JSON.stringify(\n                        input[3],\n                    )})`,\n                );\n                t.pass();\n            })\n            .on(\"end\", resolve);\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulator() sliding\", (t) => {\n    t.plan(4);\n    let chunkIndex = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const input = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 4, key: \"d\" },\n    ];\n    const firstFlush = [{ ts: 0, key: \"a\" }];\n    const secondFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n    ];\n    const thirdFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n    ];\n    const fourthFlush = [\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 4, key: \"d\" },\n    ];\n\n    const flushes = [firstFlush, secondFlush, thirdFlush, fourthFlush];\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(\n                accumulator(FlushStrategy.sliding, 3, undefined, {\n                    objectMode: true,\n                }),\n            )\n            .on(\"data\", (flush: TestObject[]) => {\n                t.deepEqual(flush, flushes[chunkIndex]);\n                chunkIndex++;\n            })\n            .on(\"error\", reject)\n            .on(\"end\", resolve);\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulator() sliding with key\", (t) => {\n    t.plan(6);\n    let chunkIndex = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const input = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 3, key: \"d\" },\n        { ts: 5, key: \"f\" },\n        { ts: 6, key: \"g\" },\n    ];\n    const firstFlush = [{ ts: 0, key: \"a\" }];\n    const secondFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n    ];\n    const thirdFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n    ];\n    const fourthFlush = [\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 3, key: \"d\" },\n    ];\n    const fifthFlush = [\n        { ts: 3, key: \"d\" },\n        { ts: 5, key: \"f\" },\n    ];\n    const sixthFlush = [\n        { ts: 5, key: \"f\" },\n        { ts: 6, key: \"g\" },\n    ];\n\n    const flushes = [\n        firstFlush,\n        secondFlush,\n        thirdFlush,\n        fourthFlush,\n        fifthFlush,\n        sixthFlush,\n    ];\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(\n                accumulator(FlushStrategy.sliding, 3, \"ts\", {\n                    objectMode: true,\n                }),\n            )\n            .on(\"data\", (flush: TestObject[]) => {\n                t.deepEqual(flush, flushes[chunkIndex]);\n                chunkIndex++;\n            })\n            .on(\"error\", reject)\n            .on(\"end\", resolve);\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulator() sliding should emit error and ignore chunk when key is missing\", (t) => {\n    t.plan(2);\n    let index = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const accumulatorStream = accumulator(\n        FlushStrategy.sliding,\n        3,\n        \"nonExistingKey\",\n        { objectMode: true },\n    );\n    const input = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n    ];\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(accumulatorStream)\n            .on(\"data\", (flush: TestObject[]) => {\n                expect(flush).to.deep.equal([]);\n            })\n            .on(\"error\", (err: any) => {\n                source.pipe(accumulatorStream);\n                accumulatorStream.resume();\n                expect(err.message).to.equal(\n                    `Key is missing in event: (nonExistingKey, ${JSON.stringify(\n                        input[index],\n                    )})`,\n                );\n                index++;\n                t.pass();\n            })\n            .on(\"end\", resolve);\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulator() sliding should emit error, ignore chunk when key is missing and continue processing chunks correctly\", (t) => {\n    t.plan(6);\n    let chunkIndex = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const accumulatorStream = accumulator(FlushStrategy.sliding, 3, \"ts\", {\n        objectMode: true,\n    });\n    const input = [\n        { ts: 0, key: \"a\" },\n        { key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 3, key: \"d\" },\n        { ts: 5, key: \"f\" },\n        { ts: 6, key: \"g\" },\n    ];\n    const firstFlush = [{ ts: 0, key: \"a\" }];\n    const secondFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 2, key: \"c\" },\n    ];\n    const thirdFlush = [\n        { ts: 2, key: \"c\" },\n        { ts: 3, key: \"d\" },\n    ];\n    const fourthFlush = [\n        { ts: 3, key: \"d\" },\n        { ts: 5, key: \"f\" },\n    ];\n    const fifthFlush = [\n        { ts: 5, key: \"f\" },\n        { ts: 6, key: \"g\" },\n    ];\n\n    const flushes = [\n        firstFlush,\n        secondFlush,\n        thirdFlush,\n        fourthFlush,\n        fifthFlush,\n    ];\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(accumulatorStream)\n            .on(\"data\", (flush: TestObject[]) => {\n                t.deepEqual(flush, flushes[chunkIndex]);\n                chunkIndex++;\n            })\n            .on(\"error\", (err: any) => {\n                source.pipe(accumulatorStream);\n                accumulatorStream.resume();\n                expect(err.message).to.equal(\n                    `Key is missing in event: (ts, ${JSON.stringify(\n                        input[1],\n                    )})`,\n                );\n                t.pass();\n            })\n            .on(\"end\", resolve);\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulatorBy() rolling\", (t) => {\n    t.plan(2);\n    let chunkIndex = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const firstFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 2, key: \"d\" },\n    ];\n    const secondFlush = [{ ts: 3, key: \"e\" }];\n    const flushes = [firstFlush, secondFlush];\n\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(\n                accumulatorBy(\n                    FlushStrategy.rolling,\n                    (event: TestObject, bufferChunk: TestObject) => {\n                        return bufferChunk.ts + 3 <= event.ts;\n                    },\n                    { objectMode: true },\n                ),\n            )\n            .on(\"data\", (flush: TestObject[]) => {\n                t.deepEqual(flush, flushes[chunkIndex]);\n                chunkIndex++;\n            })\n            .on(\"error\", reject)\n            .on(\"end\", resolve);\n        [...firstFlush, ...secondFlush].forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulatorBy() rolling should emit error when key iteratee throws\", (t) => {\n    t.plan(1);\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const input = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n    ];\n    const accumulaterStream = accumulatorBy(\n        FlushStrategy.rolling,\n        (event: TestObject, bufferChunk: TestObject) => {\n            if (event.key !== \"a\") {\n                throw new Error(\"Failed mapping\");\n            }\n            return bufferChunk.ts + 3 <= event.ts;\n        },\n        { objectMode: true },\n    );\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(accumulaterStream)\n            .on(\"error\", (err: any) => {\n                source.pipe(accumulaterStream);\n                accumulaterStream.resume();\n                expect(err.message).to.equal(\"Failed mapping\");\n                t.pass();\n            })\n            .on(\"close\", resolve);\n\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulatorBy() sliding\", (t) => {\n    t.plan(6);\n    let chunkIndex = 0;\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const input = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 3, key: \"d\" },\n        { ts: 5, key: \"f\" },\n        { ts: 6, key: \"g\" },\n    ];\n    const firstFlush = [{ ts: 0, key: \"a\" }];\n    const secondFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n    ];\n    const thirdFlush = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n    ];\n    const fourthFlush = [\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n        { ts: 3, key: \"d\" },\n    ];\n    const fifthFlush = [\n        { ts: 3, key: \"d\" },\n        { ts: 5, key: \"f\" },\n    ];\n    const sixthFlush = [\n        { ts: 5, key: \"f\" },\n        { ts: 6, key: \"g\" },\n    ];\n\n    const flushes = [\n        firstFlush,\n        secondFlush,\n        thirdFlush,\n        fourthFlush,\n        fifthFlush,\n        sixthFlush,\n    ];\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(\n                accumulatorBy(\n                    FlushStrategy.sliding,\n                    (event: TestObject, bufferChunk: TestObject) => {\n                        return bufferChunk.ts + 3 <= event.ts ? true : false;\n                    },\n                    { objectMode: true },\n                ),\n            )\n            .on(\"data\", (flush: TestObject[]) => {\n                t.deepEqual(flush, flushes[chunkIndex]);\n                chunkIndex++;\n            })\n            .on(\"error\", reject)\n            .on(\"end\", resolve);\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\ntest(\"accumulatorBy() sliding should emit error when key iteratee throws\", (t) => {\n    t.plan(1);\n    interface TestObject {\n        ts: number;\n        key: string;\n    }\n    const source = new Readable({ objectMode: true });\n    const input = [\n        { ts: 0, key: \"a\" },\n        { ts: 1, key: \"b\" },\n        { ts: 2, key: \"c\" },\n    ];\n    const accumulatorStream = accumulatorBy(\n        FlushStrategy.sliding,\n        (event: TestObject, bufferChunk: TestObject) => {\n            if (event.key !== \"a\") {\n                throw new Error(\"Failed mapping\");\n            }\n            return bufferChunk.ts + 3 <= event.ts ? true : false;\n        },\n        { objectMode: true },\n    );\n    return new Promise((resolve, reject) => {\n        source\n            .pipe(accumulatorStream)\n            .on(\"error\", (err: any) => {\n                expect(err.message).to.equal(\"Failed mapping\");\n                t.pass();\n            })\n            .on(\"close\", resolve);\n\n        input.forEach((item) => {\n            source.push(item);\n        });\n        source.push(null);\n    });\n});\n\n",
        "called_code_segment": "function _accumulator<T>(accumulateBy: (data: T, buffer: T[], stream: Transform) => void, shouldFlush: boolean = true, options: TransformOptions = {}) { const buffer: T[] = []; return new Transform({ ...options, transform(data: T, encoding, callback) { try { accumulateBy(data, buffer, this); callback(); } catch (err) { callback(err); } }, flush(callback) { if (shouldFlush) { this.push(buffer); } callback(); }, }); }",
        "invoking_code_segment": "function sliding(windowLength: number, key?: string, options?: TransformOptions): Transform { return _accumulator(_sliding(windowLength, key), false, options); } function slidingBy<T>(iteratee: AccumulatorByIteratee<T>, options?: TransformOptions): Transform { return _accumulator(_slidingByFunction(iteratee), false, options); } function rolling(windowLength: number, key?: string, options?: TransformOptions): Transform { return _accumulator(_rolling(windowLength, key), true, options); } function rollingBy<T>(iteratee: AccumulatorByIteratee<T>, options?: TransformOptions): Transform { return _accumulator(_rollingByFunction(iteratee), true, options); }",
        "feature_description": "Add a new feature to allow the accumulator to emit a summary event at the end of the stream.",
        "detailed_feature_description": "Modify the _accumulator function to accept an optional summary function. This function will be called with the buffer at the end of the stream to generate a summary event. Update the invoking functions to pass this summary function if provided.",
        "modified_complete_code": {
            "file1": "function _accumulator<T>(accumulateBy: (data: T, buffer: T[], stream: Transform) => void, shouldFlush: boolean = true, options: TransformOptions = {}, summary?: (buffer: T[]) => any) { #Modify const buffer: T[] = []; return new Transform({ ...options, transform(data: T, encoding, callback) { try { accumulateBy(data, buffer, this); callback(); } catch (err) { callback(err); } }, flush(callback) { if (shouldFlush) { this.push(buffer); } if (summary) { #New this.push(summary(buffer)); #New } callback(); }, }); }",
            "file2": "function sliding(windowLength: number, key?: string, options?: TransformOptions, summary?: (buffer: any[]) => any): Transform { #Modify return _accumulator(_sliding(windowLength, key), false, options, summary); #Modify } function slidingBy<T>(iteratee: AccumulatorByIteratee<T>, options?: TransformOptions, summary?: (buffer: T[]) => any): Transform { #Modify return _accumulator(_slidingByFunction(iteratee), false, options, summary); #Modify } function rolling(windowLength: number, key?: string, options?: TransformOptions, summary?: (buffer: any[]) => any): Transform { #Modify return _accumulator(_rolling(windowLength, key), true, options, summary); #Modify } function rollingBy<T>(iteratee: AccumulatorByIteratee<T>, options?: TransformOptions, summary?: (buffer: T[]) => any): Transform { #Modify return _accumulator(_rollingByFunction(iteratee), true, options, summary); #Modify }"
        }
    },
    {
        "repo": "template-three",
        "content": "'template-three/src/Root.tsx'\n:import { Composition } from \"remotion\";\nimport { Scene, myCompSchema } from \"./Scene\";\n\n// Welcome to the Remotion Three Starter Kit!\n// Two compositions have been created, showing how to use\n// the `ThreeCanvas` component and the `useVideoTexture` hook.\n\n// You can play around with the example or delete everything inside the canvas.\n\n// Remotion Docs:\n// https://remotion.dev/docs\n\n// @remotion/three Docs:\n// https://remotion.dev/docs/three\n\n// React Three Fiber Docs:\n// https://docs.pmnd.rs/react-three-fiber/getting-started/introduction\n\nexport const RemotionRoot: React.FC = () => {\n  return (\n    <>\n      <Composition\n        id=\"Scene\"\n        component={Scene}\n        durationInFrames={300}\n        fps={30}\n        width={1280}\n        height={720}\n        schema={myCompSchema}\n        defaultProps={{\n          deviceType: \"phone\",\n          phoneColor: \"rgba(110, 152, 191, 0.00)\" as const,\n          baseScale: 1,\n        }}\n      />\n    </>\n  );\n};\n\n'template-three/src/index.ts'\n:import { registerRoot } from \"remotion\";\nimport { RemotionRoot } from \"./Root\";\n\nregisterRoot(RemotionRoot);\n\n",
        "called_code_segment": "export const Scene: React.FC<{ deviceType: 'phone' | 'tablet'; phoneColor: 'rgba(110, 152, 191, 0.00)' | 'rgba(255, 0, 0, 1)'; baseScale: number; }> = ({ deviceType, phoneColor, baseScale }) => { ... }",
        "invoking_code_segment": "<Composition id=\"Scene\" component={Scene} durationInFrames={300} fps={30} width={1280} height={720} schema={myCompSchema} defaultProps={{ deviceType: \"phone\", phoneColor: \"rgba(110, 152, 191, 0.00)\" as const, baseScale: 1, }} />",
        "feature_description": "Add a new prop to control the background color of the scene.",
        "detailed_feature_description": "Introduce a new prop 'backgroundColor' to the Scene component to allow dynamic setting of the background color. Update the Composition in Root.tsx to include this new prop with a default value.",
        "modified_complete_code": {
            "Root.tsx": "import { Composition } from \"remotion\";\nimport { Scene, myCompSchema } from \"./Scene\";\n\n// Welcome to the Remotion Three Starter Kit!\n// Two compositions have been created, showing how to use\n// the `ThreeCanvas` component and the `useVideoTexture` hook.\n\n// You can play around with the example or delete everything inside the canvas.\n\n// Remotion Docs:\n// https://remotion.dev/docs\n\n// @remotion/three Docs:\n// https://remotion.dev/docs/three\n\n// React Three Fiber Docs:\n// https://docs.pmnd.rs/react-three-fiber/getting-started/introduction\n\n#Modify export const RemotionRoot: React.FC = () => {\n  return (\n    <>\n      <Composition\n        id=\"Scene\"\n        component={Scene}\n        durationInFrames={300}\n        fps={30}\n        width={1280}\n        height={720}\n        schema={myCompSchema}\n        defaultProps={{\n          deviceType: \"phone\",\n          phoneColor: \"rgba(110, 152, 191, 0.00)\" as const,\n          baseScale: 1,\n          #New backgroundColor: \"#000000\" as const,\n        }}\n      />\n    </>\n  );\n};",
            "Scene.tsx": "import React from \"react\";\nimport { ThreeCanvas } from \"@remotion/three\";\n\n#Modify export const Scene: React.FC<{ deviceType: 'phone' | 'tablet'; phoneColor: 'rgba(110, 152, 191, 0.00)' | 'rgba(255, 0, 0, 1)'; baseScale: number; backgroundColor: string; }> = ({ deviceType, phoneColor, baseScale, backgroundColor }) => {\n  return (\n    <ThreeCanvas\n      orthographic\n      camera={{ zoom: 40, position: [0, 0, 100] }}\n      width={1280}\n      height={720}\n      #New style={{ backgroundColor }}\n    >\n      {/* Scene content */}\n    </ThreeCanvas>\n  );\n};"
        }
    },
    {
        "repo": "twc",
        "content": "'twc/src/helpers.ts'\n:import { readFileSync } from \"fs\";\nimport { dirname, resolve } from \"path\";\nimport {\n  BinaryExpression, BindingName, Block, BlockLike, CallExpression, ClassDeclaration, ClassElement, ClassExpression, createArrayLiteral,\n  createBlock,\n  createGetAccessor, createIdentifier, createLiteral, createMethod, createObjectLiteral, createParameter, createPrinter,\n  createPropertyAssignment,\n  createReturn, createToken, EmitHint, EqualsToken, Expression, ExpressionStatement, forEachChild, FunctionExpression,\n  GetAccessorDeclaration, HeritageClause, Identifier, InterfaceDeclaration, isBinaryExpression, isDoStatement, isExpressionStatement,\n  isForInStatement, isForOfStatement, isForStatement, isFunctionLike, isGetAccessorDeclaration, isIdentifier, isIfStatement,\n  isPropertyDeclaration, isSetAccessorDeclaration, isSwitchStatement, isTryStatement, isWhileStatement, JSDoc, Modifier, NamedDeclaration,\n  Node, ParameterDeclaration, PrefixUnaryExpression, PropertyAccessExpression, PropertyName, ReturnStatement, SourceFile, Statement,\n  SyntaxKind, TypeParameterDeclaration\n} from \"typescript\";\nimport { Constructor } from \"../types\";\nimport { ImportedNode, Method, Property } from \"./builder\";\n\ntype ClassOrInterface = ClassDeclaration | ClassExpression | InterfaceDeclaration;\n\ninterface AssignmentExpression<T = Expression> extends ExpressionStatement {\n  expression: BinaryExpression & {\n    operatorToken: EqualsToken;\n    left: PropertyAccessExpression;\n    right: T\n  };\n}\n\n/**\n * List of types that do not change the overall type.\n */\nexport const transparentTypes = [\n  SyntaxKind.AnyKeyword,\n  SyntaxKind.VoidKeyword,\n  SyntaxKind.NeverKeyword,\n  SyntaxKind.NullKeyword,\n  SyntaxKind.UndefinedKeyword\n];\n\n/**\n * Kinds to be treated as class methods.\n */\nexport const methodKinds = [ SyntaxKind.MethodDeclaration, SyntaxKind.Constructor ];\n\n/**\n * Mixin adding jsDoc getter\n */\nexport const JSDocMixin = <TBase extends Constructor>(Base: TBase = class {\n} as TBase) => class extends Base {\n  public declaration: Node;\n\n  /** JSDoc for the method */\n  public get jsDoc(): string {\n    const jsDoc = this.declaration && this.declaration[ \"jsDoc\" ] as Array<JSDoc>;\n    return jsDoc ? `${jsDoc.map((doc) => doc.getText()).join(\"\\n\")}\\n` : \"\";\n  }\n\n  /** JSDoc for the module in form of HTML comment */\n  public get htmlDoc(): string {\n    const jsDoc = this.declaration[ \"jsDoc\" ] as Array<JSDoc>;\n    return jsDoc ? `\\n<!--\\n${\n      jsDoc\n        .map((doc) => doc\n          .getText()\n          .split(\"\\n\")\n          .slice(1, -1)\n          .map((line) => line.trim().slice(2))\n          .join(\"\\n\")\n        )\n        .join(\"\\n\")\n      }\\n-->` : \"\";\n  }\n};\n\n/**\n * Mixind adding decorators getter\n */\nexport const DecoratorsMixin = <TBase extends Constructor>(Base: TBase = class {\n} as TBase) => class extends Base {\n  public declaration: Node;\n\n  public get decorators(): Array<ParsedDecorator> {\n    return getDecorators(this.declaration as ClassElement | ClassDeclaration);\n  }\n};\n\n/**\n * Mixin adding the functionality of updating identifiers of imported entities with a namespace.\n */\nexport const RefUpdaterMixin = <TBase extends Constructor>(Base: TBase = class {\n} as TBase) => class extends Base {\n  protected refs?: Map<string, ImportedNode>;\n  protected skipSuper?: boolean;\n\n  /**\n   * Provide a references map to be updated in the declaration.\n   *\n   * @param variables Map of ImportedNode's\n   * @param skipSuper Should a `super()` call be skipped (removed)?\n   *\n   * @returns Reference of the class instance (for convenience)\n   */\n  public provideRefs(variables: Map<string, ImportedNode>, skipSuper = false): this {\n    this.refs = variables;\n    this.skipSuper = skipSuper;\n    return this;\n  }\n\n  /**\n   * Get text from the statement, replacing refs when available\n   *\n   * @param statement Node from which to get text\n   *\n   * @returns Text representation of a statement\n   */\n  protected getText = (statement: Node): string => {\n    if (this.refs) {\n      return updateImportedRefs(statement, this.refs);\n    } else {\n      return statement.getText();\n    }\n  }\n};\n\n/**\n * Class holding a reference to a file. When converted to a string, the file is read and content is returned.\n */\nexport class Link {\n  constructor(public uri: string, private source: Node) {\n  }\n\n  public toString() {\n    return readFileSync(resolve(dirname(getRoot(this.source).fileName), this.uri)).toString();\n  }\n}\n\n/**\n * A reference to an identifier. It will allow to get types from already visited entities.\n */\nexport class Ref {\n  constructor(public ref: Identifier) {\n  }\n\n  public toString() {\n    return this.ref.getText();\n  }\n}\n\n/**\n * Class holding a node, which stringified can be wrapped with an anonymous function.\n */\nexport class InitializerWrapper extends RefUpdaterMixin() {\n  constructor(private declaration: Node) {\n    super();\n  }\n\n  public valueOf() {\n    return new Function(`return ${this.getText(this.declaration)};`)();\n  }\n\n  public toString() {\n    return new Function(`return ${this.getText(this.declaration)};`).toString().replace(\"anonymous\", \"\");\n  }\n}\n\n/**\n * Parsed decorator, extracting name and arguments list from a decorator declaration.\n */\nexport class ParsedDecorator extends RefUpdaterMixin() {\n  /** Name of the decorator */\n  public get name(): string {\n    return hasArguments(this.declaration) ? this.declaration.expression.getText() : this.declaration.getText();\n  }\n\n  /** Arguments passed to the decorator */\n  public get arguments() {\n    if (!hasArguments(this.declaration)) {\n      return void 0;\n    }\n    return this.declaration.arguments.map((arg) => {\n      switch (arg.kind) {\n        case SyntaxKind.ArrowFunction:\n        case SyntaxKind.FunctionExpression:\n          return new Method(arg as FunctionExpression, `_${this.variable.getText()}Computed`);\n        case SyntaxKind.Identifier:\n          return new Ref(arg as Identifier);\n        default:\n          const args = flattenChildren(arg)\n            .filter(isIdentifier)\n            .filter((node: Identifier & { parent: PropertyAccessExpression }) => node !== node.parent.name);\n          return new Function(...args.map((node) => node.getText()), `return ${arg.getText()}`)(...args);\n      }\n    });\n  }\n\n  constructor(public readonly declaration: Identifier | CallExpression, private readonly variable: Identifier) {\n    super();\n  }\n\n  public valueOf(): { name: string, arguments: Array<any> } {\n    return { name: this.name, arguments: this.arguments };\n  }\n}\n\n/**\n * Get list of decorators with their arguments (if decorator is a call expression), as an array of ParsedDecorator's.\n *\n * @param declaration Class Element or Class Declaration to get decorators from\n *\n * @returns List of parsed decorators\n */\nexport const getDecorators = (declaration: ClassElement | ClassDeclaration): Array<ParsedDecorator> => {\n  if (!declaration.decorators) {\n    return [];\n  }\n  return declaration.decorators\n    .map(({ expression }) => new ParsedDecorator(expression as any, declaration.name as Identifier));\n};\n\n/**\n * Get list of all return statements for the block (including inner blocks, but not functions)\n *\n * @param block Block to get returns from\n *\n * @returns List of return type nodes\n */\nexport const getReturnStatements = (block: BlockLike | Statement | BlockLike): Array<ReturnStatement> => {\n  if (!block) {\n    return [];\n  }\n  if (isIfStatement(block)) {\n    return [\n      ...getReturnStatements(block.thenStatement),\n      ...getReturnStatements(block.elseStatement)\n    ];\n  }\n  return ((block as BlockLike).statements || [ block ] as Array<Statement>)\n    .map((node) => {\n      if (isIfStatement(node)) {\n        return [\n          ...getReturnStatements(node.thenStatement),\n          ...getReturnStatements(node.elseStatement)\n        ];\n      } else if (isTryStatement(node)) {\n        return [\n          ...getReturnStatements(node.tryBlock),\n          ...getReturnStatements(node.catchClause.block),\n          ...getReturnStatements(node.finallyBlock)\n        ];\n      } else if (\n        isForStatement(node)\n        || isDoStatement(node)\n        || isWhileStatement(node)\n        || isForInStatement(node)\n        || isForOfStatement(node)\n      ) {\n        return getReturnStatements(node.statement);\n      } else if (isSwitchStatement(node)) {\n        return node.caseBlock.clauses\n          .map(getReturnStatements)\n          .reduce((all, curr) => [ ...all, ...curr ], []);\n      }\n      return [ node ];\n    })\n    .reduce((all, curr) => [ ...all, ...curr ], [])\n    .filter((statement) => statement.kind === SyntaxKind.ReturnStatement) as Array<ReturnStatement>;\n};\n\n/**\n * Flatten mixin calls chain to an array of used mixins.\n *\n * @param expression Class extends expression\n * @param refs Map of imported references\n *\n * @returns Array of used mixin names\n */\nexport const flatExtends = (expression: Node, refs?: Map<string, ImportedNode>): Array<string> => {\n  const getText = (expr: Node) => {\n    return refs ? updateImportedRefs(expr, refs) : expr.getText();\n  };\n\n  if (hasArguments(expression)) {\n    const deepList = [ getText(expression.expression), ...expression.arguments.map((arg) => flatExtends(arg)) ];\n    return deepList.reduce((p: Array<string>, c) => p.concat(c), []) as any;\n  } else {\n    return [ getText(expression) ];\n  }\n};\n\n/**\n * Flatten mixin calls from Class Element or Class Declaration.\n *\n * @param declaration Class Element or Class Declaration to get decorators from\n * @param refs Map of imported references\n *\n * @returns Array of used mixin names\n */\nexport const getFlatHeritage = (declaration: ClassOrInterface, refs?: Map<string, ImportedNode>): Array<string> => {\n  if (!declaration.heritageClauses) {\n    return [];\n  }\n\n  return declaration\n    .heritageClauses\n    .filter(isExtendsDeclaration)\n    .map(toProperty(\"types\"))\n    .reduce(flattenArray, [])\n    .map(toProperty(\"expression\"))\n    .map((node) => flatExtends(node, refs))\n    .reduce(flattenArray, []);\n};\n\n/**\n * Checks whether class or interface inherits from a class or mixin (at least one of provided names).\n *\n * @param declaration Declaration to run the check on\n * @param names List of names to check\n *\n * @returns Whether class or interface inherits from provided class/mixin name\n */\nexport const inheritsFrom = (declaration: ClassOrInterface, ...names: Array<string>): boolean => {\n  if (!declaration.heritageClauses) {\n    return false;\n  }\n\n  const types = getFlatHeritage(declaration);\n\n  return names.some((name) => types.includes(name));\n};\n\n/**\n * Checks whether class member has a provided modifier.\n *\n * @param declaration Class element (property or method) to run check on\n * @param mod Modifier to check\n *\n * @returns Whether class member has a provided modifier\n */\nexport const hasModifier = (declaration: ClassElement, mod: SyntaxKind): boolean => {\n  return declaration.modifiers ? declaration.modifiers.some(({ kind }) => kind === mod) : false;\n};\n\n/**\n * Checks whether class or class member has a provided decorator (by name).\n *\n * @param declaration Class or class element to run check on\n * @param decoratorName Name of the decorator to check\n *\n * @returns Whether class or class member has a provided decorator\n */\nexport const hasDecorator = (declaration: ClassElement | ClassDeclaration, decoratorName: string): boolean => {\n  if (!declaration.decorators) {\n    return false;\n  }\n  return declaration.decorators.some(({ expression }) => {\n    return (hasExpression(expression) ? expression.expression : expression).getText() === decoratorName;\n  });\n};\n\n/**\n * Checks if at least one of the filters pass\n *\n * @param filters List of filters\n *\n * @returns A filter method (to pass to the array filter)\n */\nexport const isOneOf = (...filters) => (item: any): boolean => filters.some((filter) => filter(item));\n\n/**\n * Checks if all of the filters pass\n *\n * @param filters List of filters\n *\n * @returns A filter method (to pass to the array filter)\n */\nexport const isAllOf = (...filters) => (item: any): boolean => filters.every((filter) => filter(item));\n\n/**\n * Check if node is of a given kind\n */\nexport const isOfKind = <T extends Node>(kind) => (st: T): st is T => st.kind === kind;\n\n/**\n * Checks if expression is a BinaryExpression.\n *\n * @param expr Node to check\n *\n * @returns Whether node is a BinaryExpression\n */\nexport const hasOperatorToken = (expr: Node): expr is BinaryExpression => \"operatorToken\" in expr;\n\n/**\n * Checks if expression is an ExpressionStatement.\n *\n * @param expr Node to check\n *\n * @returns Whether node is an ExpressionStatement\n */\nexport const hasExpression = (expr: Node): expr is ExpressionStatement => \"expression\" in expr;\n\n/**\n * Checks if expression is a PrefixUnaryExpression.\n *\n * @param expr Node to check\n *\n * @returns Whether node is a PrefixUnaryExpression\n */\nexport const hasOperator = (expr: Node): expr is PrefixUnaryExpression => \"operator\" in expr;\n\n/**\n * Checks if expression is a CallExpression.\n *\n * @param expr Node to check\n *\n * @returns Whether node is a CallExpression\n */\nexport const hasArguments = (expr: Node): expr is CallExpression => \"arguments\" in expr;\n\n/**\n * Checks if expression is an Identifier.\n *\n * @param expr Node to check\n *\n * @returns Whether node is an Identifier\n */\nexport const hasOriginalKeywordKind = (expr: Node): expr is Identifier => \"originalKeywordKind\" in expr;\n\n/**\n * Checks if heritage clause is an ExtendsDeclaration.\n *\n * @param heritage HeritageClause to check\n *\n * @returns Whether clause is an ExtendsDeclaration\n */\nexport const isExtendsDeclaration = (heritage: HeritageClause): boolean => heritage.token === SyntaxKind.ExtendsKeyword;\n\nexport const isStatement = (node: any): node is Statement => \"pos\" in node;\n\n/**\n * Checks if expression is an assignment expression\n */\nexport const isAssignmentExpression = <T = Expression>(expr: Node): expr is AssignmentExpression<T> => isExpressionStatement(expr)\n  && isBinaryExpression(expr.expression)\n  && expr.expression.operatorToken.kind === SyntaxKind.EqualsToken;\n\n/**\n * Checks if ClassElement is private.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is private\n */\nexport const isPrivate = (el: ClassElement): boolean => hasModifier(el, SyntaxKind.PrivateKeyword);\n\n/**\n * Checks if ClassElement is public.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is public\n */\nexport const isPublic = (el: ClassElement): boolean => hasModifier(el, SyntaxKind.PublicKeyword);\n\n/**\n * Checks if ClassElement is static.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is static\n */\nexport const isStatic = (el: ClassElement): boolean => hasModifier(el, SyntaxKind.StaticKeyword);\n\n/**\n * Checks if node is of transparent type.\n *\n * @param el Node to check\n *\n * @returns Whether node is of transparent type\n */\nexport const isTransparent = (el: Node): boolean => transparentTypes.includes(el.kind);\n\n/**\n * Checks if ClassElement is not private.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is not private\n */\nexport const notPrivate = (el: ClassElement): boolean => !isPrivate(el);\n\n/**\n * Checks if ClassElement is not public.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is not public\n */\nexport const notPublic = (el: ClassElement): boolean => !isPublic(el);\n\n/**\n * Checks if ClassElement is not static.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is not static\n */\nexport const notStatic = (el: ClassElement): boolean => !isStatic(el);\n\n/**\n * Checks if node is not of a transparent type.\n *\n * @param el Node to check\n *\n * @returns Whether node is not of a transparent type\n */\nexport const notTransparent = (el: Node): boolean => !transparentTypes.includes(el.kind);\n\n/**\n * Checks if ClassElement is not a property.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is not a property\n */\nexport const notPropertyDeclaration = (el: ClassElement): boolean => !isPropertyDeclaration(el);\n\n/**\n * Checks if ClassElement is not a method.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is not a method\n */\nexport const notFunctionLike = (el: ClassElement): boolean => !isFunctionLike(el);\n\n/**\n * Checks if ClassElement is not a getter.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is not a getter\n */\nexport const notGetAccessorDeclaration = (el: ClassElement): boolean => !isGetAccessorDeclaration(el);\n\n/**\n * Checks if ClassElement is not a setter.\n *\n * @param el ClassElement to check\n *\n * @returns Whether element is not a setter\n */\nexport const notSetAccessorDeclaration = (el: ClassElement): boolean => !isSetAccessorDeclaration(el);\n\n/**\n * Calls toString on passed object.\n *\n * @example\n * arr.map(toString)\n *\n * @param object Object to convert to string\n *\n * @returns String representation of an object\n */\nexport const toString = (object: any): string => object.toString();\n\n/**\n * Calls getText on passed node.\n *\n * @example\n * arr.map(getText)\n *\n * @param node Node to get text from\n *\n * @returns Text of a node\n */\nexport const getText = (node: Node): string => node.getText();\n\n/**\n * Flattens an array.\n *\n * @example\n * arr.reduce(flattenArray, [])\n *\n * @param arr Array of previous items\n * @param item Current item\n *\n * @returns Concatenated array and item\n */\nexport const flattenArray = (arr: Array<any>, item: any): Array<any> => arr.concat(item);\n\n/**\n * Maps item to a given property.\n *\n * @example\n * arr.map(toProperty('firstName'))\n *\n * @param key Key to extract\n *\n * @returns {Function} A function to map an item\n */\nexport const toProperty = (key: string): (obj: any) => any => (obj: { [key: string]: any }) => obj[ key ];\n\n/**\n * Strip quotes from beginning and the end of a provided string.\n * *Function does NOT trim whitespace*\n *\n * @param str String to strip quotes from\n * @param [char] Quote character to strip\n *\n * @returns String without leading and trailing quotes\n */\nexport const stripQuotes = (str: string, char?: \"`\" | \"\\\"\" | \"'\"): string => {\n  if (str[ 0 ] === str[ str.length - 1 ] && (char && str[ 0 ] === char || [ \"`\", \"\\\"\", \"'\" ].includes(str[ 0 ]))) {\n    return str.slice(1, -1);\n  }\n  return str;\n};\n\n/**\n * Flatten all children within a node.\n *\n * @param node Node to fetch children from\n *\n * @returns Array of nodes\n */\nexport const flattenChildren = (node: Node): Array<Node> => {\n  const list = [ node ];\n  forEachChild(node, (deep) => {\n    list.push(...flattenChildren(deep));\n  });\n  return list;\n};\n\n/**\n * Find first occurrence of node with given kind.\n *\n * @param node Node to traverse\n * @param kind Kind to search for\n *\n * @returns Found node or null\n */\nexport const findNodeOfKind = (node: Node, kind: SyntaxKind): Node | null => {\n  let result: Node = null;\n  if (node.kind === kind) {\n    result = node;\n  }\n  forEachChild(node, (deep) => {\n    if (result) {\n      return;\n    }\n    result = findNodeOfKind(deep, kind) || result;\n  });\n  return result;\n};\n\n/**\n * Get first quote character and return it.\n *\n * @param declaration Node from which root to search for a quote char\n *\n * @returns A quote character\n */\nexport const getQuoteChar = (declaration: Node): string => findNodeOfKind(getRoot(declaration), SyntaxKind.StringLiteral).getText()[ 0 ];\n\n/**\n * Get root of the AST tree.\n *\n * @param node Node to start searching from\n *\n * @returns A root source file\n */\nexport const getRoot = (node: Node): SourceFile => {\n  let root = node;\n  while (node.parent) {\n    root = node = node.parent;\n  }\n  return root as SourceFile;\n};\n\n/**\n * Update references to imported nodes in a given source.\n *\n * @param src Source to update references in\n * @param vars Map of ImportedNode's to update source with\n *\n * @returns Text of source node with updated refs\n */\nexport const updateImportedRefs = (src: Node, vars: Map<string, ImportedNode>): string => {\n  const printer = createPrinter({ removeComments: false }, {\n    substituteNode(hint: EmitHint, node: Identifier & { parent: NamedDeclaration }) {\n      if (node.constructor.name !== \"IdentifierObject\" || !node.parent || node.parent.name === node || !vars.has(node.getText())) {\n        return node;\n      }\n      return createIdentifier(vars.get(node.getText()).fullIdentifier);\n    }\n  });\n  return printer.printNode(EmitHint.Unspecified, src, getRoot(src));\n};\n\n/**\n * Convert a system path to web URL\n *\n * @param path Path to convert\n *\n * @returns URL\n */\nexport const pathToURL = (path: string): string => path.replace(/\\\\/g, \"/\");\n\nexport function createSimpleMethod(name: string | PropertyName,\n                                   statements: Array<Statement> | Block,\n                                   parameters: Array<ParameterDeclaration> = [],\n                                   modifiers: Array<Modifier> = [],\n                                   typeParameters: Array<TypeParameterDeclaration> = []) {\n  return createMethod(\n    [],\n    modifiers,\n    void 0,\n    name,\n    void 0,\n    typeParameters,\n    parameters,\n    void 0,\n    Array.isArray(statements) ? createBlock(statements, true) : statements\n  );\n}\n\nexport function createSimpleParameter(name: string | BindingName, initializer?: Expression, optional = false) {\n  return createParameter([], [], void 0, name, optional ? createToken(SyntaxKind.QuestionToken) : void 0, void 0, initializer);\n}\n\nexport const buildExpression = (expr) => {\n  if (Array.isArray(expr)) {\n    return createArrayLiteral(expr.map((e) => buildExpression(e)), true);\n  } else if (typeof expr !== \"object\") {\n    return createLiteral(expr);\n  } else if (expr && expr.constructor.name === \"IdentifierObject\") {\n    return expr;\n  } else {\n    return buildObject(expr);\n  }\n};\n\nexport const buildObject = (props) => {\n  if (Array.isArray(props)) {\n    return buildExpression(props);\n  }\n  return createObjectLiteral(Object\n    .keys(props)\n    .map((key) => [ key, props[ key ] ])\n    .map(([ key, value ]) => createPropertyAssignment(key, buildExpression(value))), true);\n};\n\nexport const buildProperties = (props: Array<Property>): GetAccessorDeclaration => {\n  return createGetAccessor([], [ createToken(SyntaxKind.StaticKeyword) ], \"properties\", [], void 0, createBlock([\n    createReturn(\n      buildObject(props.reduce((config, { name, type, value, computed, notify, observer, readOnly, reflectToAttribute }) => {\n        const prop = { type } as Property;\n        if (value !== undefined) {\n          prop.value = value;\n        }\n        if (computed) {\n          prop.computed = computed;\n        }\n        if (notify) {\n          prop.notify = true;\n        }\n        if (observer) {\n          prop.observer = observer;\n        }\n        if (readOnly) {\n          prop.readOnly = true;\n        }\n        if (reflectToAttribute) {\n          prop.reflectToAttribute = true;\n        }\n        if (Object.keys(prop).length === 1) {\n          config[ name ] = type;\n        } else {\n          config[ name ] = prop;\n        }\n        return config;\n      }, {}))\n    )\n  ], true));\n};\n\nexport const buildObservers = (methods: Array<{ name: Node, args: Array<Node>, isComplex: boolean }>): GetAccessorDeclaration => {\n  return createGetAccessor([], [ createToken(SyntaxKind.StaticKeyword) ], \"observers\", [], void 0, createBlock([\n    createReturn(\n      buildObject(\n        methods\n          .filter(({ isComplex }) => isComplex)\n          .map(({ name, args }) => `${name.getText()}(${args.map((arg: Identifier) => arg.text).join(\", \")})`)\n      )\n    )\n  ], true));\n};\n\n'twc/src/targets/polymer2.ts'\n:import { Component, Module } from \"../builder\";\nimport { getQuoteChar } from \"../helpers\";\nimport { Polymer1 } from \"./polymer1\";\n\nenum accessorsOrder {\n  \"static set\",\n  \"static get\",\n  \"static\",\n  \"set\",\n  \"get\",\n  \"\"\n}\n\n/**\n * Outputs Polymer v2 native component.\n */\nexport class Polymer2 extends Polymer1 {\n  constructor(protected module: Module) {\n    super(module);\n  }\n\n  protected validate(): void {\n    const component = this.component;\n    if (component && !component.heritage) {\n      throw new SyntaxError(\"Components in Polymer v2 need to extend a base class (usually `Polymer.Element`).\");\n    }\n  }\n\n  /**\n   * Generate a Polymer v1 Component declaration.\n   *\n   * @param component Component meta data to create declaration for\n   *\n   * @returns Stringified component declaration\n   */\n  protected componentScript(component: Component): string {\n    const quote = getQuoteChar(this.module.declaration);\n    return `${component.events.join(\"\\n\")}\n      class ${component.name} extends ${component.heritage} {\n      ${[\n      `static get is() { return ${quote}${\n      component.config.name || component.name.replace(/([A-Z])/g, (_, l, i) => (i ? \"-\" : \"\") + l.toLowerCase())\n        }${quote} }`,\n      this.observers(component),\n      this.properties(component),\n      ...this.methods(component)\n    ].filter((chunk) => !!chunk).join(\",\\n\")}\n      }\n      customElements.define(${component.name}.is, ${component.name});\n      ${this.staticProperties(component).join(\"\\n\")}\n    `;\n  }\n\n  /**\n   * Generate observers declaration for component.\n   *\n   * @param component Components metadata\n   *\n   * @returns Stringified observers declaration\n   */\n  protected observers(component: Component): string {\n    const quote = getQuoteChar(this.module.declaration);\n    return component.observers.length === 0 ? \"\" : `static get observers() {\\n return [\n      ${component.observers.map((observer) => `${quote}${observer}${quote}`).join(\",\\n\")}\n    ]; }`;\n  }\n\n  /**\n   * Generate properties config for component.\n   *\n   * @param component Components metadata\n   *\n   * @returns Stringified properties config\n   */\n  protected properties(component: Component): string {\n    return component.properties.size === 0 ? \"\" : `static get properties() {\\n return {\n      ${Array.from(component.properties.values(), (p) => `${p.jsDoc}${p.name}: ${p.provideRefs(this.importedRefs)}`).join(\",\\n\")}\n    }; }`;\n  }\n\n  /**\n   * Get methods list.\n   *\n   * @param component Components metadata\n   *\n   * @returns Array of stringified methods\n   */\n  protected methods(component: Component): Array<string> {\n    const staticFlag = (method) => method.isStatic ? \"static \" : \"\";\n    const getOrderIdentifier = (method) => accessorsOrder[ (staticFlag(method) + method.accessor).trim() ];\n    return [\n      ...component.methods.values(),\n      ...(component.template ? component.template.methods.values() : []),\n      ...component.staticMethods.values()\n    ]\n      .sort((a, b) => getOrderIdentifier(a) - getOrderIdentifier(b))\n      .map((method) => `${method.jsDoc}${staticFlag(method)}${method.provideRefs(this.importedRefs, false)}`);\n  }\n}\n\n",
        "called_code_segment": "protected componentScript(component: Component): string {\n    const quote = getQuoteChar(this.module.declaration);\n    return `${component.events.join(\"\\n\")}\n      class ${component.name} extends ${component.heritage} {\n      ${[\n      `static get is() { return ${quote}${component.config.name || component.name.replace(/([A-Z])/g, (_, l, i) => (i ? \"-\" : \"\") + l.toLowerCase())}${quote} }`,\n      this.observers(component),\n      this.properties(component),\n      ...this.methods(component)\n    ].filter((chunk) => !!chunk).join(\",\\n\")}\n      }\n      customElements.define(${component.name}.is, ${component.name});\n      ${this.staticProperties(component).join(\"\\n\")}\n    `;\n  }",
        "invoking_code_segment": "constructor(protected module: Module) {\n    super(module);\n  }\n\n  protected validate(): void {\n    const component = this.component;\n    if (component && !component.heritage) {\n      throw new SyntaxError(\"Components in Polymer v2 need to extend a base class (usually `Polymer.Element`).\");\n    }\n  }",
        "feature_description": "Add support for custom element registration with a custom tag name.",
        "detailed_feature_description": "Modify the `componentScript` method in #file 1 to allow specifying a custom tag name for the custom element registration. Update the corresponding code in #file 2 to handle this new feature by adding a new property in the `Component` class to store the custom tag name.",
        "modified_complete_code": {
            "#file 1": "protected componentScript(component: Component): string {\n    const quote = getQuoteChar(this.module.declaration);\n    return `${component.events.join(\"\\n\")}\n      class ${component.name} extends ${component.heritage} {\n      ${[\n      `static get is() { return ${quote}${component.config.customTagName || component.name.replace(/([A-Z])/g, (_, l, i) => (i ? \"-\" : \"\") + l.toLowerCase())}${quote} }`,\n      this.observers(component),\n      this.properties(component),\n      ...this.methods(component)\n    ].filter((chunk) => !!chunk).join(\",\\n\")}\n      }\n      customElements.define(${component.name}.is, ${component.name});\n      ${this.staticProperties(component).join(\"\\n\")}\n    `;\n  } #Modify",
            "#file 2": "constructor(protected module: Module) {\n    super(module);\n  }\n\n  protected validate(): void {\n    const component = this.component;\n    if (component && !component.heritage) {\n      throw new SyntaxError(\"Components in Polymer v2 need to extend a base class (usually `Polymer.Element`).\");\n    }\n  }\n\n  #New\n  // Add a new property to store the custom tag name\n  customTagName?: string;\n  #New"
        }
    },
    {
        "repo": "uploadfly",
        "content": "'uploadfly/src/interfaces.ts'\n:import type { Request } from \"express\";\n\nexport interface IRequest extends Request {\n  apiKey?: {\n    fly_id: string;\n    active: boolean;\n    user_id: string;\n    permission: \"upload\" | \"full\";\n  };\n}\n\n'uploadfly/src/controllers/delete/index.ts'\n:import { Response } from \"express\";\nimport { IRequest } from \"../../interfaces\";\nimport prisma from \"../../../prisma\";\nimport {\n  DeleteObjectCommand,\n  DeleteObjectCommandInput,\n} from \"@aws-sdk/client-s3\";\nimport { s3Client } from \"../../configs/s3\";\nimport { createInvalidation } from \"../../utils/createInvalidation\";\nimport { sendError, sendResponse } from \"../../utils/resolveRequest\";\n\nconst deleteFile = async (req: IRequest, res: Response) => {\n  const err = (message: string, status: number) => {\n    sendError({\n      endpoint: \"/delete\",\n      error: {\n        message,\n      },\n      fly_id: req.apiKey?.fly_id as string,\n      method: \"delete\",\n      req,\n      res,\n      status,\n    });\n  };\n\n  if (req.apiKey?.permission === \"upload\") {\n    return err(\n      \"The provided API key does not have the required permission to perfrom deletion.\",\n      403\n    );\n  }\n\n  const fileUrl = req.body.file_url;\n\n  if (!fileUrl) return err(\"File URL is missing in request\", 400);\n\n  const file = await prisma.file.findFirst({\n    where: {\n      url: fileUrl,\n    },\n  });\n\n  if (!file) return err(\"File not found\", 404);\n\n  const fly = await prisma.fly.findUnique({\n    where: {\n      id: req.apiKey?.fly_id,\n    },\n  });\n\n  if (file.fly_id !== fly?.id)\n    return err(\"You are not allowed to delete this file\", 403);\n\n  const params: DeleteObjectCommandInput = {\n    Bucket: \"uploadfly\",\n    Key: file.path,\n  };\n\n  const command = new DeleteObjectCommand(params);\n\n  s3Client.send(command).then(async () => {\n    await createInvalidation(`/${file.path}`);\n    await prisma.file.delete({\n      where: {\n        id: file.id,\n      },\n    });\n\n    await prisma.fly.update({\n      where: {\n        id: file.fly_id,\n      },\n      data: {\n        used_storage: fly.used_storage - file.size,\n      },\n    });\n\n    sendResponse({\n      res,\n      req,\n      data: {\n        message: \"File deleted successfully\",\n      },\n      status: 200,\n      endpoint: \"/delete\",\n      method: \"delete\",\n      fly_id: fly.id,\n    });\n  });\n};\n\nexport { deleteFile };\n\n",
        "called_code_segment": "const deleteFile = async (req: IRequest, res: Response) => {\n  const err = (message: string, status: number) => {\n    sendError({\n      endpoint: \"/delete\",\n      error: {\n        message,\n      },\n      fly_id: req.apiKey?.fly_id as string,\n      method: \"delete\",\n      req,\n      res,\n      status,\n    });\n  };\n\n  if (req.apiKey?.permission === \"upload\") {\n    return err(\n      \"The provided API key does not have the required permission to perfrom deletion.\",\n      403\n    );\n  }\n\n  const fileUrl = req.body.file_url;\n\n  if (!fileUrl) return err(\"File URL is missing in request\", 400);\n\n  const file = await prisma.file.findFirst({\n    where: {\n      url: fileUrl,\n    },\n  });\n\n  if (!file) return err(\"File not found\", 404);\n\n  const fly = await prisma.fly.findUnique({\n    where: {\n      id: req.apiKey?.fly_id,\n    },\n  });\n\n  if (file.fly_id !== fly?.id) return err(\"You are not allowed to delete this file\", 403);\n\n  const params: DeleteObjectCommandInput = {\n    Bucket: \"uploadfly\",\n    Key: file.path,\n  };\n\n  const command = new DeleteObjectCommand(params);\n\n  s3Client.send(command).then(async () => {\n    await createInvalidation(`/${file.path}`);\n    await prisma.file.delete({\n      where: {\n        id: file.id,\n      },\n    });\n\n    await prisma.fly.update({\n      where: {\n        id: file.fly_id,\n      },\n      data: {\n        used_storage: fly.used_storage - file.size,\n      },\n    });\n\n    sendResponse({\n      res,\n      req,\n      data: {\n        message: \"File deleted successfully\",\n      },\n      status: 200,\n      endpoint: \"/delete\",\n      method: \"delete\",\n      fly_id: fly.id,\n    });\n  });\n};",
        "invoking_code_segment": "import { deleteFile } from \"./delete/index\";",
        "feature_description": "Add logging for file deletion operations.",
        "detailed_feature_description": "When a file is deleted, log the operation including the file URL, user ID, and timestamp. This will help in tracking and auditing file deletion activities.",
        "modified_complete_code": {
            "#file 1": "const deleteFile = async (req: IRequest, res: Response) => {\n  const err = (message: string, status: number) => {\n    sendError({\n      endpoint: \"/delete\",\n      error: {\n        message,\n      },\n      fly_id: req.apiKey?.fly_id as string,\n      method: \"delete\",\n      req,\n      res,\n      status,\n    });\n  };\n\n  if (req.apiKey?.permission === \"upload\") {\n    return err(\n      \"The provided API key does not have the required permission to perfrom deletion.\",\n      403\n    );\n  }\n\n  const fileUrl = req.body.file_url;\n\n  if (!fileUrl) return err(\"File URL is missing in request\", 400);\n\n  const file = await prisma.file.findFirst({\n    where: {\n      url: fileUrl,\n    },\n  });\n\n  if (!file) return err(\"File not found\", 404);\n\n  const fly = await prisma.fly.findUnique({\n    where: {\n      id: req.apiKey?.fly_id,\n    },\n  });\n\n  if (file.fly_id !== fly?.id) return err(\"You are not allowed to delete this file\", 403);\n\n  const params: DeleteObjectCommandInput = {\n    Bucket: \"uploadfly\",\n    Key: file.path,\n  };\n\n  const command = new DeleteObjectCommand(params);\n\n  s3Client.send(command).then(async () => {\n    await createInvalidation(`/${file.path}`);\n    await prisma.file.delete({\n      where: {\n        id: file.id,\n      },\n    });\n\n    await prisma.fly.update({\n      where: {\n        id: file.fly_id,\n      },\n      data: {\n        used_storage: fly.used_storage - file.size,\n      },\n    });\n\n    // #Modify: Add logging for file deletion\n    await prisma.log.create({\n      data: {\n        action: \"delete\",\n        file_url: fileUrl,\n        user_id: req.apiKey?.user_id as string,\n        timestamp: new Date(),\n      },\n    });\n\n    sendResponse({\n      res,\n      req,\n      data: {\n        message: \"File deleted successfully\",\n      },\n      status: 200,\n      endpoint: \"/delete\",\n      method: \"delete\",\n      fly_id: fly.id,\n    });\n  });\n};",
            "#file 2": "import { deleteFile } from \"./delete/index\";\n\n// #New: Add logging for file deletion\nimport prisma from \"../../../prisma\";\n\nconst logFileDeletion = async (fileUrl: string, userId: string) => {\n  await prisma.log.create({\n    data: {\n      action: \"delete\",\n      file_url: fileUrl,\n      user_id: userId,\n      timestamp: new Date(),\n    },\n  });\n};\n\n// #Modify: Update the deleteFile function to log the deletion\nconst deleteFileWithLogging = async (req: IRequest, res: Response) => {\n  const fileUrl = req.body.file_url;\n  const userId = req.apiKey?.user_id as string;\n  await deleteFile(req, res);\n  await logFileDeletion(fileUrl, userId);\n};\n\nexport { deleteFileWithLogging as deleteFile };"
        }
    },
    {
        "repo": "use-supabase",
        "content": "'use-supabase/src/types.ts'\n:import type { SupabaseClient, User } from '@supabase/supabase-js'\n\nexport type SupabaseContextType = {\n  sb: SupabaseClient | null\n  user: User | null\n}\n\nexport type SelectArg =\n  | string\n  | {\n      str: string\n      head?: boolean\n      count?: null | 'exact' | 'planned' | 'estimated'\n    }\n\n'use-supabase/src/hooks/useTable.tsx'\n:import * as React from 'react'\nimport useSwr from 'swr'\nimport { SupabaseContext } from '../context'\nimport { SelectArg } from '../types'\n\n/**\n * A hook that implements a SWR strategy to fetch data from a Supabase table\n * @param from - The table to query\n * @param select - The fields to select. Can be either a string that defaults to '*' or an object with the following properties:\n * - str: The field to select\n * - head: If true, only the first row will be returned\n * - count: If set to 'exact', only the exact number of rows will be returned. If set to 'planned', the number of rows will be estimated. If set to 'estimated', the number of rows will be estimated.\n * @returns a swr hook object with the following properties:\n * - data: The data returned by the query\n * - error: The error returned by the query\n * - isValidating: If true, the query is still running\n * * ```typescript\n *  const { data, error } = useTable('users', '*')\n * ```\n */\nexport function useTable<T>(from: string, select: SelectArg = '*') {\n  const context = React.useContext(SupabaseContext)\n\n  if (context === undefined) {\n    throw new Error('useUser must be used within a SupabaseContext.Provider')\n  }\n\n  const selectStr = typeof select === 'string' ? select : select.str\n  const selectOptions =\n    typeof select === 'string'\n      ? undefined\n      : { head: select.head, count: select.count }\n\n  return useSwr<T>(`${from}${selectStr}`, async (_key: string) => {\n    //@ts-ignore\n    const { data, error } = await context.sb\n      ?.from(from)\n      .select(selectStr, selectOptions)\n\n    if (error) {\n      throw error\n    }\n\n    return data\n  })\n}\n\n",
        "called_code_segment": "export function useTable<T>(from: string, select: SelectArg = '*') {\n  const context = React.useContext(SupabaseContext)\n\n  if (context === undefined) {\n    throw new Error('useUser must be used within a SupabaseContext.Provider')\n  }\n\n  const selectStr = typeof select === 'string' ? select : select.str\n  const selectOptions =\n    typeof select === 'string'\n      ? undefined\n      : { head: select.head, count: select.count }\n\n  return useSwr<T>(`${from}${selectStr}`, async (_key: string) => {\n    //@ts-ignore\n    const { data, error } = await context.sb\n      ?.from(from)\n      .select(selectStr, selectOptions)\n\n    if (error) {\n      throw error\n    }\n\n    return data\n  })\n}",
        "invoking_code_segment": "const context = React.useContext(SupabaseContext)\n\n  if (context === undefined) {\n    throw new Error('useUser must be used within a SupabaseContext.Provider')\n  }",
        "feature_description": "Add support for filtering data based on a filter object.",
        "detailed_feature_description": "Modify the `useTable` function to accept an optional `filter` object. Update the `useTable` function to apply the filter when querying the Supabase table. Update the invoking code to handle the new `filter` parameter.",
        "modified_complete_code": {
            "use-supabase/src/hooks/useTable.tsx": "import * as React from 'react'\nimport useSwr from 'swr'\nimport { SupabaseContext } from '../context'\nimport { SelectArg } from '../types'\n\n/**\n * A hook that implements a SWR strategy to fetch data from a Supabase table\n * @param from - The table to query\n * @param select - The fields to select. Can be either a string that defaults to '*' or an object with the following properties:\n * - str: The field to select\n * - head: If true, only the first row will be returned\n * - count: If set to 'exact', only the exact number of rows will be returned. If set to 'planned', the number of rows will be estimated. If set to 'estimated', the number of rows will be estimated.\n * @param filter - An optional filter object to apply to the query\n * @returns a swr hook object with the following properties:\n * - data: The data returned by the query\n * - error: The error returned by the query\n * - isValidating: If true, the query is still running\n * * ```typescript\n *  const { data, error } = useTable('users', '*', { name: 'John' })\n * ```\n */\n#Modify export function useTable<T>(from: string, select: SelectArg = '*', filter?: Record<string, any>) {\n  const context = React.useContext(SupabaseContext)\n\n  if (context === undefined) {\n    throw new Error('useUser must be used within a SupabaseContext.Provider')\n  }\n\n  const selectStr = typeof select === 'string' ? select : select.str\n  const selectOptions =\n    typeof select === 'string'\n      ? undefined\n      : { head: select.head, count: select.count }\n\n  return useSwr<T>(`${from}${selectStr}`, async (_key: string) => {\n    //@ts-ignore\n    const { data, error } = await context.sb\n      ?.from(from)\n      .select(selectStr, selectOptions)\n      .filter(filter)\n\n    if (error) {\n      throw error\n    }\n\n    return data\n  })\n}",
            "use-supabase/src/context.ts": "import * as React from 'react'\nimport { createClient } from '@supabase/supabase-js'\nimport { SupabaseContextType } from './types'\n\nconst SupabaseContext = React.createContext<SupabaseContextType | undefined>(undefined)\n\ninterface SupabaseProviderProps {\n  supabaseUrl: string\n  supabaseKey: string\n  children: React.ReactNode\n}\n\nconst SupabaseProvider: React.FC<SupabaseProviderProps> = ({ supabaseUrl, supabaseKey, children }) => {\n  const [sb, setSb] = React.useState<SupabaseClient | null>(null)\n  const [user, setUser] = React.useState<User | null>(null)\n\n  React.useEffect(() => {\n    const supabase = createClient(supabaseUrl, supabaseKey)\n    setSb(supabase)\n\n    const { data: authListener } = supabase.auth.onAuthStateChange((event, session) => {\n      setUser(session?.user || null)\n    })\n\n    return () => {\n      authListener?.unsubscribe()\n    }\n  }, [supabaseUrl, supabaseKey])\n\n  return (\n    <SupabaseContext.Provider value={{ sb, user }}>\n      {children}\n    </SupabaseContext.Provider>\n  )\n}\n\n#Modify const context = React.useContext(SupabaseContext)\n\n  if (context === undefined) {\n    throw new Error('useUser must be used within a SupabaseContext.Provider')\n  }"
        }
    },
    {
        "repo": "vmware-challenge-2016",
        "content": "'vmware-challenge-2016/src/app/app.component.ts'\n:import {Component, OnInit} from '@angular/core';\nimport {SolutionComponent} from './solution/solution.component';\nimport {SimulatorService} from './containers/simulator.service';\nimport {GeneratorService} from './containers/generator.service';\n\n@Component({\n    selector: 'my-app',\n    template: `<my-solution></my-solution>`,\n    directives: [SolutionComponent],\n    providers: [SimulatorService, GeneratorService]\n})\nexport class AppComponent{}\n\n'vmware-challenge-2016/src/app/main.ts'\n:import {bootstrap} from '@angular/platform-browser-dynamic';\n\nimport {AppComponent} from './app.component';\n\n\n\nbootstrap(AppComponent);\n\n\n",
        "called_code_segment": "@Component({\n    selector: 'my-app',\n    template: `<my-solution></my-solution>`,\n    directives: [SolutionComponent],\n    providers: [SimulatorService, GeneratorService]\n})\nexport class AppComponent{}",
        "invoking_code_segment": "bootstrap(AppComponent);",
        "feature_description": "Add a new property to the AppComponent to display a title.",
        "detailed_feature_description": "Modify the AppComponent to include a title property and update the template to display this title. In the main.ts file, update the bootstrap call to pass a configuration object with the title.",
        "modified_complete_code": {
            "app.component.ts": "//Modify\n@Component({\n    selector: 'my-app',\n    template: `<h1>{{title}}</h1><my-solution></my-solution>`,\n    directives: [SolutionComponent],\n    providers: [SimulatorService, GeneratorService]\n})\nexport class AppComponent {\n    title: string;\n\n    constructor() {\n        this.title = 'VMware Challenge 2016';\n    }\n}",
            "main.ts": "//Modify\nbootstrap(AppComponent, [{\n    provide: 'title', useValue: 'VMware Challenge 2016'\n}]);"
        }
    },
    {
        "repo": "vue-valibot",
        "content": "'vue-valibot/src/types.ts'\n:import type { FlatErrors, GenericSchema, GenericSchemaAsync } from \"valibot\"\n\nexport type GenericSchemaMaybeAsync = GenericSchema | GenericSchemaAsync\n\nexport type GenericFlatErrors = FlatErrors<any>\n\n'vue-valibot/src/form.ts'\n:import type { MaybeRefOrGetter, Ref } from \"@vue/reactivity\"\nimport { ref, toValue } from \"@vue/reactivity\"\nimport type { FlatErrors, InferOutput } from \"valibot\"\nimport { flatten, safeParseAsync } from \"valibot\"\n\nimport type { GenericFlatErrors, GenericSchemaMaybeAsync } from \"./types\"\n\nexport interface UseFormReturn<TSchema extends GenericSchemaMaybeAsync, TArgs extends any[], TResult> {\n  /**\n   * The form element ref.\n   *\n   * Using it with `<form ref=\"form\">` will enable HTML5 validation on submit.\n   */\n  form: Ref<HTMLFormElement | undefined>\n  /**\n   * The actual form submit function that you should call with something like:\n   *\n   * - `<form @submit.prevent=\"submit\">`\n   * - `<button @click=\"submit\">`\n   *\n   * It will:\n   *\n   * - Run HTML5 validation (if the form ref is set).\n   * - Run valibot validation (if the schema is provided).\n   * - Call submit callback (if provided).\n   *\n   * Arguments passed to this submit function will be passed to the submit callback,\n   * prepended with (possibly validated) form input (unless using the shortcut variant of useForm).\n   *\n   * During execution, `submitting` is true.\n   * After successfull execution, `submitted` is true.\n   */\n  submit: (...args: TArgs) => Promise<TResult | undefined>\n  /**\n   * Is the form submit callback executing at the moment?\n   *\n   * Use this to disable submit button.\n   *\n   * Also, `useForm` will not perform submit if it sees this is `true`.\n   */\n  submitting: Ref<boolean>\n  /**\n   * Has the form been successfully submitted?\n   *\n   * Feel free to reset. `useForm` doesn't depend on this value.\n   */\n  submitted: Ref<boolean>\n  /**\n   * Validation errors, as returned by valibot.\n   *\n   * Set it in the submit callback to report submit errors.\n   */\n  errors: Ref<FlatErrors<TSchema> | undefined>\n}\n\ninterface BaseOptions<TSchema extends GenericSchemaMaybeAsync> {\n  /**\n   * Error callback.\n   *\n   * Called (and awaited) if the validation fails, or if `errors.value` was set by the submit handler.\n   */\n  onErrors?: (errors: FlatErrors<TSchema>) => any\n  /**\n   * User-provided ref for `form` return value.\n   */\n  form?: Ref<HTMLFormElement | undefined>\n  /**\n   * User-provided ref for `submitting` return value.\n   */\n  submitting?: Ref<boolean>\n  /**\n   * User-provided ref for `submitted` return value.\n   */\n  submitted?: Ref<boolean>\n  /**\n   * User-provided ref for `errors` return value.\n   */\n  errors?: Ref<FlatErrors<TSchema> | undefined>\n}\n\ntype SubmitCallback<Args extends any[], Result> = (\n  ...args: Args\n) => Result | PromiseLike<Result>\n\n//\n// No input.\n//\n\n/**\n * Vue3 composable for handling form submit.\n */\nexport function useForm<Args extends unknown[], Result>(\n  options: BaseOptions<any> & {\n    input?: never\n    schema?: never\n    /**\n     * Form submit callback.\n     *\n     * Only called if:\n     * - Form is not being submitted at the moment (submitting.value is falsy).\n     * - HTML5 validation passes (if enabled).\n     *\n     * The arguments are the submit function arguments.\n     *\n     * During execution, `submitting` is true.\n     * After successfull execution, `submitted` is true.\n     */\n    submit?: SubmitCallback<Args, Result>\n  },\n): UseFormReturn<any, Args, Result>\n\n//\n// Input, no schema.\n//\n\n/**\n * Vue3 composable for handling form submit.\n *\n * Validates the input using valibot.\n */\nexport function useForm<TInput, TArgs extends any[], TResult>(\n  options: BaseOptions<any> & {\n    /**\n     * Input value, or ref, or a getter for the submit input data.\n     */\n    input: MaybeRefOrGetter<TInput>\n    schema?: never\n    /**\n     * Form submit callback.\n     *\n     * Only called if:\n     * - Form is not being submitted at the moment (submitting.value is falsy).\n     * - HTML5 validation passes (if enabled).\n     *\n     * The first argument is the form input, the rest arguments are the submit function arguments.\n     *\n     * During execution, `submitting` is true.\n     * After successfull execution, `submitted` is true.\n     */\n    submit?: SubmitCallback<[TInput, ...TArgs], TResult>\n  },\n): UseFormReturn<any, TArgs, TResult>\n\n//\n// Input + schema.\n//\n\n/**\n * Vue3 composable for handling form submit.\n *\n * Validates the input using valibot.\n */\nexport function useForm<TSchema extends GenericSchemaMaybeAsync, TArgs extends any[], TResult>(\n  options: BaseOptions<TSchema> & {\n    /**\n     * Input data to be validated (plain value, ref or getter).\n     */\n    input?: unknown\n    /**\n     * Valibot schema (plain value, ref or getter).\n     */\n    schema: MaybeRefOrGetter<TSchema>\n    /**\n     * Form submit callback.\n     *\n     * Only called if:\n     * - Form is not being submitted at the moment (submitting.value is falsy).\n     * - HTML5 validation passes (if enabled).\n     * - Valibot validation passes.\n     *\n     * The first argument is the validated input, the rest arguments are the submit function arguments.\n     *\n     * During execution, `submitting` is true.\n     * After successfull execution, `submitted` is true.\n     */\n    submit?: SubmitCallback<[InferOutput<TSchema>, ...TArgs], TResult>\n  },\n): UseFormReturn<TSchema, TArgs, TResult>\n\n//\n// No input, callback only.\n//\n\n/**\n * Vue3 composable for handling form submit.\n */\nexport function useForm<TArgs extends any[], TResult>(\n/**\n * Form submit callback.\n *\n * Only called if:\n * - Form is not being submitted at the moment (submitting.value is falsy).\n * - HTML5 validation passes (if enabled).\n *\n * The arguments are the submit function arguments.\n *\n * During execution, `submitting` is true.\n * After successfull execution, `submitted` is true.\n */\n  submit?: SubmitCallback<TArgs, TResult>,\n): UseFormReturn<any, TArgs, TResult>\n\n//\n// Implementation.\n//\n\nexport function useForm(\n  optionsOrSubmit?:\n    | (BaseOptions<any> & {\n      input?: unknown\n      schema?: MaybeRefOrGetter<GenericSchemaMaybeAsync>\n      submit?: SubmitCallback<any, any>\n    })\n    | SubmitCallback<any, any>,\n): UseFormReturn<any, any, any> {\n  const options\n    = (typeof optionsOrSubmit === \"function\" ? undefined : optionsOrSubmit) ?? {}\n  const submitCallback\n    = typeof optionsOrSubmit === \"function\" ? optionsOrSubmit : options?.submit\n  const hasInput = options.input !== undefined\n\n  const form = options.form ?? ref<HTMLFormElement>()\n  const errors = options.errors ?? ref<GenericFlatErrors>()\n  const submitting = options.submitting ?? ref(false)\n  const submitted = options.submitted ?? ref(false)\n\n  async function submit(...args: unknown[]) {\n    if (submitting.value) {\n      return\n    }\n    submitted.value = false\n    errors.value = undefined\n    if (form.value && !form.value.checkValidity()) {\n      form.value.reportValidity()\n      return\n    }\n    submitting.value = true\n    try {\n      const input = toValue(options.input)\n      const schema = toValue(options.schema)\n      const parseResult = schema ? await safeParseAsync(schema, input) : undefined\n      if (parseResult && !parseResult.success) {\n        errors.value = flatten(parseResult.issues)\n        await options.onErrors?.(errors.value)\n      } else {\n        const returnValue = await Promise.resolve()\n          .then(() =>\n            hasInput || parseResult\n              ? submitCallback?.(parseResult ? parseResult.output : input, ...args)\n              : submitCallback?.(...args),\n          )\n          .catch((err) => {\n            if (err instanceof SubmitError) {\n              errors.value = err.errors\n              return undefined\n            }\n            throw err\n          })\n        if (errors.value) {\n          await options.onErrors?.(errors.value)\n        } else {\n          submitted.value = true\n        }\n        return returnValue\n      }\n    } finally {\n      submitting.value = false\n    }\n  }\n\n  return { form, submit, submitting, submitted, errors }\n}\n\n/** @deprecated Do not use, simply set `errors` directly. */\nexport class SubmitError extends Error {\n  constructor(public errors: GenericFlatErrors) {\n    super(\"Error submitting form.\")\n  }\n}\n\n",
        "called_code_segment": "export function useForm(optionsOrSubmit?: | (BaseOptions<any> & { input?: unknown schema?: MaybeRefOrGetter<GenericSchemaMaybeAsync> submit?: SubmitCallback<any, any> }) | SubmitCallback<any, any>): UseFormReturn<any, any, any> { const options = (typeof optionsOrSubmit === \"function\" ? undefined : optionsOrSubmit) ?? {} const submitCallback = typeof optionsOrSubmit === \"function\" ? optionsOrSubmit : options?.submit const hasInput = options.input !== undefined const form = options.form ?? ref<HTMLFormElement>() const errors = options.errors ?? ref<GenericFlatErrors>() const submitting = options.submitting ?? ref(false) const submitted = options.submitted ?? ref(false) async function submit(...args: unknown[]) { if (submitting.value) { return } submitted.value = false errors.value = undefined if (form.value && !form.value.checkValidity()) { form.value.reportValidity() return } submitting.value = true try { const input = toValue(options.input) const schema = toValue(options.schema) const parseResult = schema ? await safeParseAsync(schema, input) : undefined if (parseResult && !parseResult.success) { errors.value = flatten(parseResult.issues) await options.onErrors?.(errors.value) } else { const returnValue = await Promise.resolve() .then(() => hasInput || parseResult ? submitCallback?.(parseResult ? parseResult.output : input, ...args) : submitCallback?.(...args)) .catch((err) => { if (err instanceof SubmitError) { errors.value = err.errors return undefined } throw err }) if (errors.value) { await options.onErrors?.(errors.value) } else { submitted.value = true } return returnValue } } finally { submitting.value = false } } return { form, submit, submitting, submitted, errors } }",
        "invoking_code_segment": "import { useForm } from \"./form\" const { submit } = useForm({ input: { name: \"John\", age: 30 }, schema: mySchema, submit: async (validatedInput) => { console.log(\"Validated input:\", validatedInput) } })",
        "feature_description": "Add a feature to allow custom validation messages to be set during form submission.",
        "detailed_feature_description": "Modify the `useForm` function to accept an optional `customMessages` object that maps validation paths to custom error messages. Update the `submit` function to use these custom messages if provided.",
        "modified_complete_code": {
            "file1": "export function useForm(optionsOrSubmit?: | (BaseOptions<any> & { input?: unknown schema?: MaybeRefOrGetter<GenericSchemaMaybeAsync> submit?: SubmitCallback<any, any> customMessages?: Record<string, string> }) | SubmitCallback<any, any>): UseFormReturn<any, any, any> { const options = (typeof optionsOrSubmit === \"function\" ? undefined : optionsOrSubmit) ?? {} const submitCallback = typeof optionsOrSubmit === \"function\" ? optionsOrSubmit : options?.submit const hasInput = options.input !== undefined const form = options.form ?? ref<HTMLFormElement>() const errors = options.errors ?? ref<GenericFlatErrors>() const submitting = options.submitting ?? ref(false) const submitted = options.submitted ?? ref(false) async function submit(...args: unknown[]) { if (submitting.value) { return } submitted.value = false errors.value = undefined if (form.value && !form.value.checkValidity()) { form.value.reportValidity() return } submitting.value = true try { const input = toValue(options.input) const schema = toValue(options.schema) const parseResult = schema ? await safeParseAsync(schema, input) : undefined if (parseResult && !parseResult.success) { errors.value = flatten(parseResult.issues).map(issue => ({ ...issue, message: options.customMessages?.[issue.path.join('.')] ?? issue.message })) await options.onErrors?.(errors.value) } else { const returnValue = await Promise.resolve() .then(() => hasInput || parseResult ? submitCallback?.(parseResult ? parseResult.output : input, ...args) : submitCallback?.(...args)) .catch((err) => { if (err instanceof SubmitError) { errors.value = err.errors return undefined } throw err }) if (errors.value) { await options.onErrors?.(errors.value) } else { submitted.value = true } return returnValue } } finally { submitting.value = false } } return { form, submit, submitting, submitted, errors } }",
            "file2": "import { useForm } from \"./form\" const { submit } = useForm({ input: { name: \"John\", age: 30 }, schema: mySchema, customMessages: { 'name': 'Please enter a valid name', 'age': 'Age must be a number' }, submit: async (validatedInput) => { console.log(\"Validated input:\", validatedInput) } })"
        }
    },
    {
        "repo": "waifu2x",
        "content": "'waifu2x/waifu2x.ts'\n:import util from \"util\"\n\nimport fs from \"fs\"\n\nimport {imageSize} from \"image-size\"\n\nimport ffmpeg from \"fluent-ffmpeg\"\n\nimport path from \"path\"\n\nimport child_process, {ChildProcess} from \"child_process\"\n\nimport GifEncoder from \"gif-encoder\"\n\nimport getPixels from \"get-pixels\"\n\nimport gifFrames from \"gif-frames\"\n\n// @ts-ignore\n\nimport PDFDocument from \"@react-pdf/pdfkit\"\n\nimport {pdfImages} from \"./pdf-images\"\n\nimport rife from \"rife-fps\"\n\n\n\nconst exec = util.promisify(child_process.exec)\n\n\n\nexport type Waifu2xFormats =\n\n    | \"bmp\"\n\n    | \"dib\"\n\n    | \"exr\"\n\n    | \"hdr\"\n\n    | \"jpe\"\n\n    | \"jpeg\"\n\n    | \"jpg\"\n\n    | \"pbm\"\n\n    | \"pgm\"\n\n    | \"pic\"\n\n    | \"png\"\n\n    | \"pnm\"\n\n    | \"ppm\"\n\n    | \"pxm\"\n\n    | \"ras\"\n\n    | \"sr\"\n\n    | \"tif\"\n\n    | \"tiff\"\n\n    | \"webp\"\n\n\n\n\n\nexport interface Waifu2xOptions {\n\n    upscaler?: \"waifu2x\" | \"real-esrgan\" | \"real-cugan\" | \"anime4k\" | string\n\n    noise?: -1 | 0 | 1 | 2 | 3\n\n    scale?: number\n\n    mode?: \"noise\" | \"scale\" | \"noise-scale\"\n\n    pngCompression?: number\n\n    jpgWebpQuality?: number\n\n    threads?: number\n\n    recursive?: boolean\n\n    rename?: string\n\n    limit?: number\n\n    parallelFrames?: number\n\n    waifu2xPath?: string\n\n    waifu2xModel?: \"models-cunet\" | \"models-upconv_7_anime_style_art_rgb\"\n\n    webpPath?: string\n\n    esrganPath?: string\n\n    cuganPath?: string\n\n    anime4kPath?: string\n\n    scriptsPath?: string\n\n    rifePath?: string\n\n    rifeModel?: string\n\n    pythonDownscale?: number\n\n}\n\n\n\nexport interface Waifu2xGIFOptions extends Waifu2xOptions {\n\n    quality?: number\n\n    speed?: number\n\n    reverse?: boolean\n\n    transparentColor?: string\n\n    noResume?: boolean\n\n    pngFrames?: boolean\n\n}\n\n\n\nexport interface Waifu2xAnimatedWebpOptions extends Waifu2xOptions {\n\n    quality?: number\n\n    speed?: number\n\n    reverse?: boolean\n\n    noResume?: boolean\n\n}\n\n\n\nexport interface Waifu2xVideoOptions extends Waifu2xOptions {\n\n    framerate?: number\n\n    quality?: number\n\n    speed?: number\n\n    reverse?: boolean\n\n    pitch?: boolean\n\n    sdColorSpace?: boolean\n\n    noResume?: boolean\n\n    pngFrames?: boolean\n\n    fpsMultiplier?: number\n\n    ffmpegPath?: string\n\n}\n\n\n\nexport interface Waifu2xPDFOptions extends Waifu2xOptions {\n\n    quality?: number\n\n    reverse?: boolean\n\n    noResume?: boolean\n\n    pngFrames?: boolean\n\n    downscaleHeight?: number\n\n}\n\n\n\nexport default class Waifu2x {\n\n    static processes: ChildProcess[] = []\n\n\n\n    private static addProcess = (process: child_process.ChildProcess) => {\n\n        Waifu2x.processes.push(process)\n\n    }\n\n\n\n    private static removeProcess = (process: child_process.ChildProcess) => {\n\n        Waifu2x.processes = Waifu2x.processes.filter((p) => p.pid !== process.pid)\n\n    }\n\n\n\n    public static chmod777 = (waifu2xPath?: string, webpPath?: string, esrganPath?: string, cuganPath?: string, anime4kPath?: string, rifePath?: string) => {\n\n        if (process.platform === \"win32\") return\n\n        const waifu2x = waifu2xPath ? path.normalize(waifu2xPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../waifu2x\")\n\n        const esrgan = esrganPath ? path.normalize(esrganPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../real-esrgan\")\n\n        const cugan = cuganPath ? path.normalize(cuganPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../real-cugan\")\n\n        const anime4k = anime4kPath ? path.normalize(anime4kPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../anime4k\")\n\n        const webp = webpPath ? path.normalize(webpPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../webp\")\n\n        fs.chmodSync(`${waifu2x}/waifu2x-ncnn-vulkan.app`, \"777\")\n\n        fs.chmodSync(`${esrgan}/realesrgan-ncnn-vulkan.app`, \"777\")\n\n        fs.chmodSync(`${cugan}/realcugan-ncnn-vulkan.app`, \"777\")\n\n        fs.chmodSync(`${anime4k}/Anime4KCPP_CLI.app`, \"777\")\n\n        fs.chmodSync(`${webp}/anim_dump.app`, \"777\")\n\n        fs.chmodSync(`${webp}/cwebp.app`, \"777\")\n\n        fs.chmodSync(`${webp}/dwebp.app`, \"777\")\n\n        fs.chmodSync(`${webp}/img2webp.app`, \"777\")\n\n        fs.chmodSync(`${webp}/webpmux.app`, \"777\")\n\n        rife.chmod777(rifePath)\n\n    }\n\n\n\n    private static parseFilename = (source: string, dest: string, rename: string) => {\n\n        let [image, folder] = [\"\", \"\"]\n\n        if (!dest) {\n\n            image = null\n\n            folder = null\n\n        } else if (path.basename(dest).includes(\".\")) {\n\n            image = path.basename(dest)\n\n            folder = dest.replace(image, \"\")\n\n        } else {\n\n            image = null\n\n            folder = dest\n\n        }\n\n        if (!folder) folder = \"./\"\n\n        if (folder.endsWith(\"/\")) folder = folder.slice(0, -1)\n\n        if (!image) {\n\n            image = `${path.basename(source, path.extname(source))}${rename}${path.extname(source)}`\n\n        }\n\n        return {folder, image}\n\n    }\n\n\n\n    private static recursiveRename = (folder: string, fileNames: string[], rename: string) => {\n\n        if (folder.endsWith(\"/\")) folder = folder.slice(0, -1)\n\n        for (let i = 0; i < fileNames.length; i++) {\n\n            const fullPath = `${folder}/${fileNames[i]}`\n\n            const check = fs.statSync(fullPath)\n\n            if (check.isDirectory()) {\n\n                const subFiles = fs.readdirSync(fullPath)\n\n                Waifu2x.recursiveRename(fullPath, subFiles, rename)\n\n            } else {\n\n                const pathSplit = fileNames[i].split(\".\")\n\n                const newName = pathSplit?.[0].split(\"_\")?.[0] + rename\n\n                const newPath = `${folder}/${newName}.${pathSplit.pop()}`\n\n                fs.renameSync(fullPath, newPath)\n\n            }\n\n        }\n\n    }\n\n\n\n    public static parseDest = (source: string, dest?: string, options?: {rename?: string}) => {\n\n        options = {...options}\n\n        if (!dest) dest = \"./\"\n\n        if (options.rename === undefined) options.rename = \"2x\"\n\n        let {folder, image} = Waifu2x.parseFilename(source, dest, options.rename)\n\n        if (!path.isAbsolute(source) && !path.isAbsolute(dest)) {\n\n            let local = __dirname.includes(\"node_modules\") ? path.join(__dirname, \"../../../\") : path.join(__dirname, \"..\")\n\n            folder = path.join(local, folder)\n\n        }\n\n        return path.normalize(`${folder}/${image}`).replace(/\\\\/g, \"/\")\n\n    }\n\n\n\n    private static timeout = async (ms: number) => {\n\n        return new Promise((resolve) => setTimeout(resolve, ms))\n\n    }\n\n\n\n    public static convertToWebp = async (source: string, dest: string, webpPath?: string, quality?: number) => {\n\n        if (!quality) quality = 75\n\n        const absolute = webpPath ? path.normalize(webpPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../webp\")\n\n        let program = `cd \"${absolute}\" && ./cwebp.exe`\n\n        if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./cwebp.app`\n\n        if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./cwebp`\n\n        let command = `${program} -q ${quality} \"${source}\" -o \"${dest}\"`\n\n        const child = child_process.exec(command)\n\n        Waifu2x.addProcess(child)\n\n        await new Promise<void>((resolve, reject) => {\n\n            child.on(\"close\", () => {\n\n                Waifu2x.removeProcess(child)\n\n                resolve()\n\n            })\n\n        })\n\n        return dest\n\n    }\n\n\n\n    public static convertFromWebp = async (source: string, dest: string, webpPath?: string) => {\n\n        const absolute = webpPath ? path.normalize(webpPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../webp\")\n\n        let program = `cd \"${absolute}\" && ./dwebp.exe`\n\n        if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./dwebp.app`\n\n        if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./dwebp`\n\n        let command = `${program} \"${source}\" -o \"${dest}\"`\n\n        const child = child_process.exec(command)\n\n        Waifu2x.addProcess(child)\n\n        let error = \"\"\n\n        await new Promise<void>((resolve, reject) => {\n\n            child.stderr.on(\"data\", (chunk) => error += chunk)\n\n            child.on(\"close\", () => {\n\n                Waifu2x.removeProcess(child)\n\n                resolve()\n\n            })\n\n        })\n\n        if (error.includes(\"animated WebP\")) return Promise.reject(error)\n\n        return dest\n\n    }\n\n\n\n    public static upscaleImage = async (source: string, dest?: string, options?: Waifu2xOptions, progress?: (percent?: number) => void | boolean) => {\n\n        options = {...options}\n\n        if (!dest) dest = \"./\"\n\n        if (!options.upscaler) options.upscaler = \"waifu2x\"\n\n        let sourcePath = source\n\n        if (options.rename === undefined) options.rename = \"2x\"\n\n        let {folder, image} = Waifu2x.parseFilename(source, dest, options.rename)\n\n\n\n        if (!fs.existsSync(folder)) fs.mkdirSync(folder, {recursive: true})\n\n\n\n        let local = __dirname.includes(\"node_modules\") ? path.join(__dirname, \"../../../\") : path.join(__dirname, \"..\")\n\n        if (!path.isAbsolute(source) && !path.isAbsolute(dest)) {\n\n            sourcePath = path.join(local, source)\n\n            folder = path.join(local, folder)\n\n        }\n\n        let destPath = path.join(folder, image).replace(/\\\\/g, \"/\")\n\n        let absolute = \"\"\n\n        if (options.upscaler === \"waifu2x\") {\n\n            absolute = options.waifu2xPath ? path.normalize(options.waifu2xPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../waifu2x\")\n\n        } else if (options.upscaler === \"real-esrgan\") {\n\n            absolute = options.esrganPath ? path.normalize(options.esrganPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../real-esrgan\")\n\n        } else if (options.upscaler === \"real-cugan\") {\n\n            absolute = options.cuganPath ? path.normalize(options.cuganPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../real-cugan\")\n\n        } else if (options.upscaler === \"anime4k\") {\n\n            absolute = options.anime4kPath ? path.normalize(options.anime4kPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../anime4k\")\n\n        } else {\n\n            absolute = options.scriptsPath ? path.normalize(options.scriptsPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../scripts\")\n\n        }\n\n        const buffer = fs.readFileSync(sourcePath)\n\n        const dimensions = imageSize(buffer)\n\n        if (dimensions.type === \"webp\") {\n\n            try {\n\n                await Waifu2x.convertFromWebp(sourcePath, destPath, options.webpPath)\n\n                sourcePath = destPath\n\n            } catch (error) {\n\n                return Promise.reject(`Animated webp: ${error}`)\n\n            }\n\n        }\n\n        let command = \"\"\n\n        if (options.upscaler === \"waifu2x\") {\n\n            let program = `cd \"${absolute}\" && waifu2x-ncnn-vulkan.exe`\n\n            if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./waifu2x-ncnn-vulkan.app`\n\n            if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./waifu2x-ncnn-vulkan`\n\n            const ext = path.extname(source).replace(\".\", \"\")\n\n            command = `${program} -i \"${sourcePath}\" -o \"${destPath}\" -f ${ext}`\n\n            if (options.scale) command +=  ` -s ${options.scale}`\n\n            if (options.threads) command += ` -j ${options.threads}:${options.threads}:${options.threads}`\n\n            if (options.waifu2xModel) command += ` -m \"${options.waifu2xModel}\"`\n\n        } else if (options.upscaler === \"real-esrgan\") {\n\n            let program = `cd \"${absolute}\" && realesrgan-ncnn-vulkan.exe`\n\n            if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./realesrgan-ncnn-vulkan.app`\n\n            if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./realesrgan-ncnn-vulkan`\n\n            const ext = path.extname(source).replace(\".\", \"\")\n\n            command = `${program} -i \"${sourcePath}\" -o \"${destPath}\" -f ${ext} -n ${options.scale === 4 ? \"realesrgan-x4plus-anime\" : \"realesr-animevideov3\"}`\n\n            if (options.scale) command +=  ` -s ${options.scale}`\n\n            if (options.threads) command += ` -j ${options.threads}:${options.threads}:${options.threads}`\n\n        } else if (options.upscaler === \"real-cugan\") {\n\n            let program = `cd \"${absolute}\" && realcugan-ncnn-vulkan.exe`\n\n            if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./realcugan-ncnn-vulkan.app`\n\n            if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./realcugan-ncnn-vulkan`\n\n            const ext = path.extname(source).replace(\".\", \"\")\n\n            command = `${program} -i \"${sourcePath}\" -o \"${destPath}\" -f ${ext}`\n\n            if (options.noise) {\n\n                if (Number(options.scale) > 2) {\n\n                    if (Number(options.noise) === 2) options.noise = 3\n\n                    if (Number(options.noise) === 1) options.noise = 0\n\n                }\n\n                command += ` -n ${options.noise}`\n\n            }\n\n            if (options.scale) command +=  ` -s ${options.scale}`\n\n            if (options.threads) command += ` -j ${options.threads}:${options.threads}:${options.threads}`\n\n        } else if (options.upscaler === \"anime4k\") {\n\n            let program = `cd \"${absolute}\" && Anime4KCPP_CLI.exe`\n\n            if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./Anime4KCPP_CLI.app`\n\n            if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./Anime4KCPP_CLI`\n\n            command = `${program} -i \"${sourcePath}\" -o \"${destPath}\" -A`\n\n            if (options.scale) command +=  ` -z ${options.scale}`\n\n        } else {\n\n            let python = process.platform === \"darwin\" ? \"PYTORCH_ENABLE_MPS_FALLBACK=1 /usr/local/bin/python3\" : \"python3\"\n\n            let program = `cd \"${absolute}\" && ${python} upscale.py`\n\n            command = `${program} -i \"${sourcePath}\" -o \"${destPath}\" -m \"${options.upscaler}\"`\n\n            if (options.pythonDownscale && Number(options.pythonDownscale > 0)) command += ` -d ${options.pythonDownscale}`\n\n        }\n\n        const child = child_process.exec(command)\n\n        Waifu2x.addProcess(child)\n\n        let stopped = false\n\n        const poll = async () => {\n\n            if (progress()) {\n\n                stopped = true\n\n                child.stdio.forEach((s) => s.destroy())\n\n                child.kill(\"SIGINT\")\n\n            }\n\n            await Waifu2x.timeout(1000)\n\n            if (!stopped) poll()\n\n        }\n\n        if (progress) poll()\n\n        let error = \"\"\n\n        await new Promise<void>((resolve, reject) => {\n\n            child.stderr.on(\"data\", (chunk) => {\n\n                if (options.upscaler === \"real-esrgan\") {\n\n                    const percent = Number(chunk.replace(\"%\", \"\").replace(\",\", \".\"))\n\n                    if (!Number.isNaN(percent)) progress?.(percent)\n\n                }\n\n            })\n\n            child.on(\"close\", () => {\n\n                stopped = true\n\n                Waifu2x.removeProcess(child)\n\n                resolve()\n\n            })\n\n        })\n\n        if (error) return Promise.reject(error)\n\n        if (path.extname(destPath) === \".webp\") {\n\n            await Waifu2x.convertToWebp(destPath, destPath, options.webpPath, options.jpgWebpQuality)\n\n        }\n\n        return path.normalize(destPath).replace(/\\\\/g, \"/\") as string\n\n    }\n\n\n\n    private static searchFiles = (dir: string, recursive = false) => {\n\n        const files = fs.readdirSync(dir)\n\n        const fileMap = files.map((file) => `${dir}/${file}`).filter((f) => fs.lstatSync(f).isFile())\n\n        if (!recursive) return fileMap\n\n        const dirMap = files.map((file) => `${dir}/${file}`).filter((f) => fs.lstatSync(f).isDirectory())\n\n        return fileMap.concat(dirMap.flatMap((dirEntry) => Waifu2x.searchFiles(dirEntry, true)))\n\n    }\n\n\n\n    public static upscaleImages = async (sourceFolder: string, destFolder?: string, options?: Waifu2xOptions, progress?: (current: number, total: number) => void | boolean) => {\n\n        options = {...options}\n\n        if (sourceFolder.endsWith(\"/\")) sourceFolder = sourceFolder.slice(0, -1)\n\n        const fileMap = Waifu2x.searchFiles(sourceFolder, options?.recursive)\n\n\n\n        if (!options.limit) options.limit = fileMap.length\n\n        const retArray: string[] = []\n\n        let cancel = false\n\n        let counter = 1\n\n        let total = fileMap.length\n\n        let queue: string[][] = []\n\n        if (!options.parallelFrames) options.parallelFrames = 1\n\n        while (fileMap.length) queue.push(fileMap.splice(0, options.parallelFrames))\n\n        if (progress) progress(0, total)\n\n        for (let i = 0; i < queue.length; i++) {\n\n            await Promise.all(queue[i].map(async (f) => {\n\n                if (counter >= options.limit) cancel = true\n\n                const ret = await Waifu2x.upscaleImage(f, destFolder, options)\n\n                retArray.push(ret)\n\n                const stop = progress ? progress(counter++, total) : false\n\n                if (stop) cancel = true\n\n            }))\n\n            if (cancel) break\n\n        }\n\n        return retArray\n\n    }\n\n\n\n    private static parseTransparentColor = (color: string) => {\n\n        return Number(`0x${color.replace(/^#/, \"\")}`)\n\n    }\n\n\n\n    private static encodeGIF = async (files: string[], delays: number[], dest: string, quality?: number, transparentColor?: string) => {\n\n        if (!quality) quality = 10\n\n        return new Promise<void>((resolve) => {\n\n            const dimensions = imageSize(files?.[0])\n\n            const gif = new GifEncoder(dimensions.width, dimensions.height, {highWaterMark: 5 * 1024 * 1024})\n\n            const file = fs.createWriteStream(dest)\n\n            gif.pipe(file)\n\n            gif.setQuality(quality)\n\n            gif.setRepeat(0)\n\n            gif.writeHeader()\n\n            if (transparentColor) gif.setTransparent(Waifu2x.parseTransparentColor(transparentColor))\n\n            let counter = 0\n\n            const addToGif = (frames: string[]) => {\n\n                getPixels(frames[counter], (err, pixels) => {\n\n                    if(err) throw err\n\n                    gif.setDelay(10 * delays[counter])\n\n                    gif.addFrame(pixels.data)\n\n                    if (counter >= frames.length - 1) {\n\n                        gif.finish()\n\n                    } else {\n\n                        counter++\n\n                        addToGif(files)\n\n                    }\n\n                })\n\n            }\n\n            addToGif(files)\n\n            gif.on(\"end\", resolve)\n\n        })\n\n    }\n\n\n\n    private static awaitStream = async (writeStream: NodeJS.WritableStream) => {\n\n        return new Promise((resolve, reject) => {\n\n            writeStream.on(\"finish\", resolve)\n\n            writeStream.on(\"error\", reject)\n\n        })\n\n    }\n\n\n\n    private static newDest = (dest: string) => {\n\n        let i = 1\n\n        let newDest = dest\n\n        while (fs.existsSync(newDest)) {\n\n            newDest = `${dest}_${i}`\n\n            i++\n\n        }\n\n        return newDest\n\n    }\n\n\n\n    private static findMatchingSettings = (dest: string, options: any) => {\n\n        let i = 1\n\n        let newDest = dest\n\n        if (fs.existsSync(newDest)) {  \n\n            const settings = JSON.parse(fs.readFileSync(`${newDest}/settings.json`, \"utf8\"))\n\n            if (JSON.stringify(settings) === JSON.stringify(options)) {\n\n                return newDest\n\n            }\n\n        }\n\n        newDest = `${dest}_${i}`\n\n        while (fs.existsSync(newDest) || i < 10) {\n\n            if (fs.existsSync(newDest)) {    \n\n                const settings = JSON.parse(fs.readFileSync(`${newDest}/settings.json`, \"utf8\"))\n\n                if (JSON.stringify(settings) === JSON.stringify(options)) {\n\n                    return newDest\n\n                }\n\n            }\n\n            i++\n\n            newDest = `${dest}_${i}`\n\n        }\n\n        return null\n\n    }\n\n\n\n    public static upscaleGIF = async (source: string, dest?: string, options?: Waifu2xGIFOptions, progress?: (current: number, total: number) => void | boolean) => {\n\n        options = {...options}\n\n        if (!dest) dest = \"./\"\n\n        let frameExt = options.pngFrames ? \"png\" : \"jpg\" as any\n\n        const frames = await gifFrames({url: source, frames: \"all\", outputType: frameExt})\n\n        let {folder, image} = Waifu2x.parseFilename(source, dest, \"2x\")\n\n        if (!path.isAbsolute(source) && !path.isAbsolute(dest)) {\n\n            let local = __dirname.includes(\"node_modules\") ? path.join(__dirname, \"../../../\") : path.join(__dirname, \"..\")\n\n            folder = path.join(local, folder)\n\n        }\n\n        let frameDest = `${folder}/${path.basename(source, path.extname(source))}Frames`\n\n        let resume = 0\n\n        if (fs.existsSync(frameDest)) {\n\n            const matching = Waifu2x.findMatchingSettings(frameDest, options)\n\n            if (matching) {\n\n                frameDest = matching\n\n                resume = fs.readdirSync(`${frameDest}/upscaled`).length\n\n            } else {\n\n                frameDest = Waifu2x.newDest(frameDest)\n\n                fs.mkdirSync(frameDest, {recursive: true})\n\n                fs.writeFileSync(`${frameDest}/settings.json`, JSON.stringify(options))\n\n            }\n\n        } else {\n\n            fs.mkdirSync(frameDest, {recursive: true})\n\n            fs.writeFileSync(`${frameDest}/settings.json`, JSON.stringify(options))\n\n        }\n\n        const constraint = options.speed > 1 ? frames.length / options.speed : frames.length\n\n        let step = Math.ceil(frames.length / constraint)\n\n        let frameArray: string[] = []\n\n        let delayArray: number[] = []\n\n\n\n        async function downloadFrames(frames: any[]) {\n\n            const promiseArray = []\n\n            for (let i = 0; i < frames.length; i += step) {\n\n                const writeStream = fs.createWriteStream(`${frameDest}/frame${i}.${frameExt}`)\n\n                frames[i].getImage().pipe(writeStream)\n\n                frameArray.push(`${frameDest}/frame${i}.${frameExt}`)\n\n                delayArray.push(frames[i].frameInfo.delay)\n\n                promiseArray.push(Waifu2x.awaitStream(writeStream))\n\n            }\n\n            return Promise.all(promiseArray)\n\n        }\n\n        await downloadFrames(frames)\n\n        if (options.speed < 1) delayArray = delayArray.map((n) => n / options.speed)\n\n        const upScaleDest = `${frameDest}/upscaled`\n\n        if (!fs.existsSync(upScaleDest)) fs.mkdirSync(upScaleDest, {recursive: true})\n\n        options.rename = \"\"\n\n        let scaledFrames = fs.readdirSync(upScaleDest).map((f) => `${upScaleDest}/${path.basename(f)}`)\n\n        let cancel = false\n\n        if (options.scale !== 1) {\n\n            let counter = resume\n\n            let total = frameArray.length\n\n            let queue: string[][] = []\n\n            if (!options.parallelFrames) options.parallelFrames = 1\n\n            frameArray = frameArray.slice(resume)\n\n            while (frameArray.length) queue.push(frameArray.splice(0, options.parallelFrames))\n\n            if (progress) progress(counter++, total)\n\n            for (let i = 0; i < queue.length; i++) {\n\n                await Promise.all(queue[i].map(async (f) => {\n\n                    const destPath = await Waifu2x.upscaleImage(f, `${upScaleDest}/${path.basename(f)}`, options)\n\n                    scaledFrames.push(destPath)\n\n                    const stop = progress ? progress(counter++, total) : false\n\n                    if (stop) cancel = true\n\n                }))\n\n                if (cancel) break\n\n            }\n\n        } else {\n\n            scaledFrames = frameArray\n\n        }\n\n        scaledFrames = scaledFrames.sort(new Intl.Collator(undefined, {numeric: true, sensitivity: \"base\"}).compare)\n\n        if (options.reverse) {\n\n            scaledFrames = scaledFrames.reverse()\n\n            delayArray = delayArray.reverse()\n\n        }\n\n        const finalDest = path.join(folder, image)\n\n        await Waifu2x.encodeGIF(scaledFrames, delayArray, finalDest, options.quality, options.transparentColor)\n\n        if (options.noResume || !cancel) Waifu2x.removeDirectory(frameDest)\n\n        return path.normalize(finalDest).replace(/\\\\/g, \"/\")\n\n    }\n\n\n\n    public static upscaleGIFs = async (sourceFolder: string, destFolder?: string, options?: Waifu2xGIFOptions, totalProgress?: (current: number, total: number) => void | boolean, progress?: (current: number, total: number) => void | boolean) => {\n\n        options = {...options}\n\n        const files = fs.readdirSync(sourceFolder)\n\n        if (sourceFolder.endsWith(\"/\")) sourceFolder = sourceFolder.slice(0, -1)\n\n        const fileMap = files.map((file) => `${sourceFolder}/${file}`)\n\n        if (!options.limit) options.limit = fileMap.length\n\n        const retArray: string[] = []\n\n        if (totalProgress) totalProgress(0, options.limit)\n\n        for (let i = 0; i < options.limit; i++) {\n\n            if (!fileMap[i]) break\n\n            try {\n\n                const ret = await Waifu2x.upscaleGIF(fileMap[i], destFolder, options, progress)\n\n                const stop = totalProgress ? totalProgress(i + 1, options.limit) : false\n\n                retArray.push(ret)\n\n                if (stop) break\n\n            } catch (err) {\n\n                continue\n\n            }\n\n        }\n\n        return retArray\n\n    }\n\n\n\n    private static dumpWebpFrames = async (source: string, frameDest?: string, webpPath?: string) => {\n\n        const absolute = webpPath ? path.normalize(webpPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../webp\")\n\n        let program = `cd \"${absolute}\" && ./anim_dump.exe`\n\n        if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./anim_dump.app`\n\n        if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./anim_dump`\n\n        let command = `${program} -folder \"${frameDest}\" -prefix \"frame\" \"${source}\"`\n\n        const child = child_process.exec(command)\n\n        Waifu2x.addProcess(child)\n\n        await new Promise<void>((resolve, reject) => {\n\n            child.on(\"close\", () => {\n\n                Waifu2x.removeProcess(child)\n\n                resolve()\n\n            })\n\n        })\n\n        return fs.readdirSync(frameDest).sort(new Intl.Collator(undefined, {numeric: true, sensitivity: \"base\"}).compare)\n\n        .filter((s) => s !== \"settings.json\")\n\n    }\n\n\n\n    private static parseWebpDelays = async (source: string, webpPath?: string) => {\n\n        const absolute = webpPath ? path.normalize(webpPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../webp\")\n\n        let program = `cd \"${absolute}\" && ./webpmux.exe`\n\n        if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./webpmux.app`\n\n        if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./webpmux`\n\n        let command = `${program} -info \"${source}\"`\n\n        const child = child_process.exec(command)\n\n        let data = \"\"\n\n        Waifu2x.addProcess(child)\n\n        await new Promise<void>((resolve, reject) => {\n\n            child.stdout.on(\"data\", (chunk) => data += chunk)\n\n            child.on(\"close\", () => {\n\n                Waifu2x.removeProcess(child)\n\n                resolve()\n\n            })\n\n        })\n\n        return data.split(\"\\n\").slice(5).map((r) => parseInt(r.split(/ +/g)[7])).filter(Boolean)\n\n    }\n\n\n\n    private static encodeAnimatedWebp = async (files: string[], delays: number[], dest: string, webpPath?: string, quality?: number) => {\n\n        if (!quality) quality = 75\n\n        const frames = files.map((f, i) => `-d ${delays[i]} \"${f}\"`).join(\" \")\n\n        const absolute = webpPath ? path.normalize(webpPath).replace(/\\\\/g, \"/\") : path.join(__dirname, \"../webp\")\n\n        let program = `cd \"${absolute}\" && ./img2webp.exe`\n\n        if (process.platform === \"darwin\") program = `cd \"${absolute}\" && ./img2webp.app`\n\n        if (process.platform === \"linux\") program = `cd \"${absolute}\" && ./img2webp`\n\n        let command = `${program} -loop \"0\" ${frames} -o \"${dest}\"`\n\n        const child = child_process.exec(command)\n\n        Waifu2x.addProcess(child)\n\n        let error = \"\"\n\n        await new Promise<void>((resolve, reject) => {\n\n            child.stderr.on(\"data\", (chunk) => error += chunk)\n\n            child.on(\"close\", () => {\n\n                Waifu2x.removeProcess(child)\n\n                resolve()\n\n            })\n\n        })\n\n        return dest\n\n    }\n\n\n\n    public static upscaleAnimatedWebp = async (source: string, dest?: string, options?: Waifu2xGIFOptions, progress?: (current: number, total: number) => void | boolean) => {\n\n        options = {...options}\n\n        if (!dest) dest = \"./\"\n\n        let {folder, image} = Waifu2x.parseFilename(source, dest, \"2x\")\n\n        if (!path.isAbsolute(source) && !path.isAbsolute(dest)) {\n\n            let local = __dirname.includes(\"node_modules\") ? path.join(__dirname, \"../../../\") : path.join(__dirname, \"..\")\n\n            folder = path.join(local, folder)\n\n            source = path.join(local, source)\n\n        }\n\n        let frameDest = `${folder}/${path.basename(source, path.extname(source))}Frames`\n\n        let resume = 0\n\n        if (fs.existsSync(frameDest)) {\n\n            const matching = Waifu2x.findMatchingSettings(frameDest, options)\n\n            if (matching) {\n\n                frameDest = matching\n\n                resume = fs.readdirSync(`${frameDest}/upscaled`).length\n\n            } else {\n\n                frameDest = Waifu2x.newDest(frameDest)\n\n                fs.mkdirSync(frameDest, {recursive: true})\n\n                fs.writeFileSync(`${frameDest}/settings.json`, JSON.stringify(options))\n\n            }\n\n        } else {\n\n            fs.mkdirSync(frameDest, {recursive: true})\n\n            fs.writeFileSync(`${frameDest}/settings.json`, JSON.stringify(options))\n\n        }\n\n        let frames = await Waifu2x.dumpWebpFrames(source, frameDest, options.webpPath)\n\n        let delays = await Waifu2x.parseWebpDelays(source, options.webpPath)\n\n        const constraint = options.speed > 1 ? frames.length / options.speed : frames.length\n\n        let step = Math.ceil(frames.length / constraint)\n\n        let frameArray: string[] = []\n\n        let delayArray: number[] = []\n\n        for (let i = 0; i < frames.length; i += step) {\n\n            frameArray.push(`${frameDest}/${frames[i]}`)\n\n            delayArray.push(delays[i])\n\n        }\n\n        if (options.speed < 1) delayArray = delayArray.map((n) => n / options.speed)\n\n        const upScaleDest = `${frameDest}/upscaled`\n\n        if (!fs.existsSync(upScaleDest)) fs.mkdirSync(upScaleDest, {recursive: true})\n\n        options.rename = \"\"\n\n        let scaledFrames = fs.readdirSync(upScaleDest).map((f) => `${upScaleDest}/${path.basename(f)}`)\n\n        let cancel = false\n\n        if (options.scale !== 1) {\n\n            let counter = resume\n\n            let total = frameArray.length\n\n            let queue: string[][] = []\n\n            if (!options.parallelFrames) options.parallelFrames = 1\n\n            frameArray = frameArray.slice(resume)\n\n            while (frameArray.length) queue.push(frameArray.splice(0, options.parallelFrames))\n\n            if (progress) progress(counter++, total)\n\n            for (let i = 0; i < queue.length; i++) {\n\n                await Promise.all(queue[i].map(async (f) => {\n\n                    const destPath = await Waifu2x.upscaleImage(f, `${upScaleDest}/${path.basename(f)}`, options)\n\n                    scaledFrames.push(destPath)\n\n                    const stop = progress ? progress(counter++, total) : false\n\n                    if (stop) cancel = true\n\n                }))\n\n                if (cancel) break\n\n            }\n\n        } else {\n\n            scaledFrames = frameArray\n\n        }\n\n        scaledFrames = scaledFrames.sort(new Intl.Collator(undefined, {numeric: true, sensitivity: \"base\"}).compare)\n\n        if (options.reverse) {\n\n            scaledFrames = scaledFrames.reverse()\n\n            delayArray = delayArray.reverse()\n\n        }\n\n        const finalDest = path.join(folder, image)\n\n        await Waifu2x.encodeAnimatedWebp(scaledFrames, delayArray, finalDest, options.webpPath, options.jpgWebpQuality)\n\n        if (options.noResume || !cancel) Waifu2x.removeDirectory(frameDest)\n\n        return path.normalize(finalDest).replace(/\\\\/g, \"/\")\n\n    }\n\n\n\n    public static upscaleAnimatedWebps = async (sourceFolder: string, destFolder?: string, options?: Waifu2xAnimatedWebpOptions, totalProgress?: (current: number, total: number) => void | boolean, progress?: (current: number, total: number) => void | boolean) => {\n\n        options = {...options}\n\n        const files = fs.readdirSync(sourceFolder)\n\n        if (sourceFolder.endsWith(\"/\")) sourceFolder = sourceFolder.slice(0, -1)\n\n        const fileMap = files.map((file) => `${sourceFolder}/${file}`)\n\n        if (!options.limit) options.limit = fileMap.length\n\n        const retArray: string[] = []\n\n        if (totalProgress) totalProgress(0, options.limit)\n\n        for (let i = 0; i < options.limit; i++) {\n\n            if (!fileMap[i]) break\n\n            try {\n\n                const ret = await Waifu2x.upscaleAnimatedWebp(fileMap[i], destFolder, options, progress)\n\n                const stop = totalProgress ? totalProgress(i + 1, options.limit) : false\n\n                retArray.push(ret)\n\n                if (stop) break\n\n            } catch (err) {\n\n                continue\n\n            }\n\n        }\n\n        return retArray\n\n    }\n\n\n\n    public static parseFramerate = async (file: string, ffmpegPath?: string) => {\n\n        let command = `\"${ffmpegPath ? ffmpegPath : \"ffmpeg\"}\" -i \"${file}\"`\n\n        const str = await exec(command).then((s: any) => s.stdout).catch((e: any) => e.stderr)\n\n        const fps = Number(str.match(/[0-9.]+ (?=fps,)/)?.[0])\n\n        return Number.isNaN(fps) ? 0 : fps\n\n    }\n\n\n\n    public static parseDuration = async (file: string, ffmpegPath?: string) => {\n\n        let command = `\"${ffmpegPath ? ffmpegPath : \"ffmpeg\"}\" -i \"${file}\"`\n\n        const str = await exec(command).then((s: any) => s.stdout).catch((e: any) => e.stderr)\n\n        const tim =  str.match(/(?<=Duration: )(.*?)(?=,)/)[0].split(\":\").map((n: string) => Number(n))\n\n        const dur =  (tim?.[0] * 60 * 60) + (tim?.[1] * 60) + tim?.[2]\n\n        return Number.isNaN(dur) ? 0 : dur\n\n    }\n\n\n\n    public static parseResolution = async (file: string, ffmpegPath?: string) => {\n\n        let command = `\"${ffmpegPath ? ffmpegPath : \"ffmpeg\"}\" -i \"${file}\"`\n\n        const str = await exec(command).then((s: any) => s.stdout).catch((e: any) => e.stderr)\n\n        const dim = str.match(/(?<= )\\d+x\\d+(?= |,)/)[0].split(\"x\")\n\n        let width = Number(dim?.[0])\n\n        let height = Number(dim?.[1])\n\n        if (Number.isNaN(width)) width = 0\n\n        if (Number.isNaN(height)) height = 0\n\n        return {width, height}\n\n    }\n\n\n\n    public static upscaleVideo = async (source: string, dest?: string, options?: Waifu2xVideoOptions, progress?: (current: number, total: number) => void | boolean, interlopProgress?: (percent: number) => void | boolean) => {\n\n        options = {...options}\n\n        if (!dest) dest = \"./\"\n\n        if (options.ffmpegPath) ffmpeg.setFfmpegPath(options.ffmpegPath)\n\n        let {folder, image} = Waifu2x.parseFilename(source, dest, \"2x\")\n\n        if (!path.isAbsolute(source) && !path.isAbsolute(dest)) {\n\n            let local = __dirname.includes(\"node_modules\") ? path.join(__dirname, \"../../../\") : path.join(__dirname, \"..\")\n\n            folder = path.join(local, folder)\n\n            source = path.join(local, source)\n\n        }\n\n        let duration = await Waifu2x.parseDuration(source, options.ffmpegPath)\n\n        if (!options.framerate) options.framerate = await Waifu2x.parseFramerate(source, options.ffmpegPath)\n\n        let frameDest = `${folder}/${path.basename(source, path.extname(source))}Frames`\n\n        let resume = 0\n\n        if (fs.existsSync(frameDest)) {\n\n            const matching = Waifu2x.findMatchingSettings(frameDest, options)\n\n            if (matching) {\n\n                frameDest = matching\n\n                resume = fs.readdirSync(`${frameDest}/upscaled`).length\n\n            } else {\n\n                frameDest = Waifu2x.newDest(frameDest)\n\n                fs.mkdirSync(frameDest, {recursive: true})\n\n                fs.writeFileSync(`${frameDest}/settings.json`, JSON.stringify(options))\n\n            }\n\n        } else {\n\n            fs.mkdirSync(frameDest, {recursive: true})\n\n            fs.writeFileSync(`${frameDest}/settings.json`, JSON.stringify(options))\n\n        }\n\n        let frameExt = options.pngFrames ? \"png\" : \"jpg\" as any\n\n        let framerate = [\"-r\", `${options.framerate}`]\n\n        let crf = options.quality ? [\"-crf\", `${options.quality}`] : [\"-crf\", \"16\"]\n\n        let codec = [\"-vcodec\", \"libx264\", \"-pix_fmt\", \"yuv420p\", \"-movflags\", \"+faststart\"]\n\n        let colorFlags = [\"-color_primaries\", \"bt709\", \"-colorspace\", \"bt709\", \"-color_trc\", \"bt709\"]\n\n        if (options.sdColorSpace) colorFlags = [\"-color_primaries\", \"smpte170m\", \"-colorspace\", \"smpte170m\", \"-color_trc\", \"smpte170m\"]\n\n        let audio = `${frameDest}/audio.wav`\n\n        if (resume === 0) {\n\n            await new Promise<void>((resolve) => {\n\n                ffmpeg(source).outputOptions([...framerate])\n\n                .save(`${frameDest}/frame%08d.${frameExt}`)\n\n                .on(\"end\", () => resolve())\n\n            })\n\n            await new Promise<void>((resolve, reject) => {\n\n                ffmpeg(source).outputOptions(\"-bitexact\").save(audio)\n\n                .on(\"end\", () => resolve())\n\n                .on(\"error\", () => reject())\n\n            }).catch(() => audio = \"\")\n\n        } else {\n\n            if (!fs.existsSync(audio)) audio = \"\"\n\n        }\n\n        let upScaleDest = `${frameDest}/upscaled`\n\n        if (!fs.existsSync(upScaleDest)) fs.mkdirSync(upScaleDest, {recursive: true})\n\n        options.rename = \"\"\n\n        let frameArray = fs.readdirSync(frameDest).map((f) => `${frameDest}/${f}`).filter((f) => path.extname(f) === `.${frameExt}`)\n\n        frameArray = frameArray.sort(new Intl.Collator(undefined, {numeric: true, sensitivity: \"base\"}).compare)\n\n        let scaledFrames = fs.readdirSync(upScaleDest).map((f) => `${upScaleDest}/${path.basename(f)}`)\n\n        let cancel = false\n\n        if (options.scale !== 1) {\n\n            let counter = resume\n\n            let total = frameArray.length\n\n            let queue: string[][] = []\n\n            if (!options.parallelFrames) options.parallelFrames = 1\n\n            frameArray = frameArray.slice(resume)\n\n            while (frameArray.length) queue.push(frameArray.splice(0, options.parallelFrames))\n\n            if (progress) progress(counter++, total)\n\n            for (let i = 0; i < queue.length; i++) {\n\n                await Promise.all(queue[i].map(async (f) => {\n\n                    const destPath = await Waifu2x.upscaleImage(f, `${upScaleDest}/${path.basename(f)}`, options)\n\n                    scaledFrames.push(destPath)\n\n                    const stop = progress ? progress(counter++, total) : false\n\n                    if (stop) cancel = true\n\n                }))\n\n                if (cancel) break\n\n            }\n\n        } else {\n\n            scaledFrames = frameArray\n\n            upScaleDest = frameDest\n\n        }\n\n        if (!options.fpsMultiplier) options.fpsMultiplier = 1\n\n        if (options.fpsMultiplier !== 1) {\n\n            let interlopDest = `${frameDest}/interlop`\n\n            if (!fs.existsSync(interlopDest)) fs.mkdirSync(interlopDest, {recursive: true})\n\n            cancel = await rife.interpolateDirectory(upScaleDest, interlopDest, {multiplier: options.fpsMultiplier, ...options}, interlopProgress)\n\n            if (!cancel) upScaleDest = interlopDest\n\n        }\n\n        let tempDest = `${upScaleDest}/temp.mp4`\n\n        let finalDest = path.join(folder, image)\n\n        let crop = \"crop=trunc(iw/2)*2:trunc(ih/2)*2\"\n\n        if (!options.speed) options.speed = 1\n\n        if (!options.reverse) options.reverse = false\n\n        let targetFramerate = [\"-framerate\", `${options.framerate * options.fpsMultiplier}`]\n\n        if (audio) {\n\n            let filter: string[] = [\"-vf\", `${crop}`]\n\n            await new Promise<void>((resolve) => {\n\n                ffmpeg(`${upScaleDest}/frame%08d.${frameExt}`).input(audio).outputOptions([...targetFramerate, ...codec, ...crf, ...colorFlags, ...filter])\n\n                .save(`${upScaleDest}/${image}`)\n\n                .on(\"end\", () => resolve())\n\n            })\n\n            if (options.speed === 1 && !options.reverse) {\n\n                tempDest = `${upScaleDest}/${image}`\n\n            } else {\n\n                let audioSpeed = options.pitch ? `asetrate=44100*${options.speed},aresample=44100` : `atempo=${options.speed}`\n\n                filter = [\"-filter_complex\", `[0:v]setpts=${1.0/options.speed}*PTS${options.reverse ? \",reverse\": \"\"}[v];[0:a]${audioSpeed}${options.reverse ? \",areverse\" : \"\"}[a]`, \"-map\", \"[v]\", \"-map\", \"[a]\"]\n\n                await new Promise<void>((resolve) => {\n\n                    ffmpeg(`${upScaleDest}/${image}`).outputOptions([...targetFramerate, ...codec, ...crf, ...colorFlags, ...filter])\n\n                    .save(tempDest)\n\n                    .on(\"end\", () => resolve())\n\n                })\n\n            }\n\n        } else {\n\n            let filter = [\"-filter_complex\", `[0:v]${crop},setpts=${1.0/options.speed}*PTS${options.reverse ? \",reverse\": \"\"}[v]`, \"-map\", \"[v]\"]\n\n            await new Promise<void>((resolve) => {\n\n                ffmpeg(`${upScaleDest}/frame%08d.${frameExt}`).outputOptions([...targetFramerate, ...codec, ...crf, ...colorFlags, ...filter])\n\n                .save(tempDest)\n\n                .on(\"end\", () => resolve())\n\n            })\n\n        }\n\n        let newDuration = await Waifu2x.parseDuration(tempDest, options.ffmpegPath)\n\n        let factor = duration / options.speed / newDuration\n\n        if (Number.isNaN(factor)) factor = 1 \n\n        let filter = [\"-filter_complex\", `[0:v]setpts=${factor}*PTS[v]`, \"-map\", \"[v]\"]\n\n        if (audio) filter = [\"-filter_complex\", `[0:v]setpts=${factor}*PTS[v];[0:a]atempo=1[a]`, \"-map\", \"[v]\", \"-map\", \"[a]\"]\n\n        let error = \"\"\n\n        await new Promise<void>((resolve, reject) => {\n\n            ffmpeg(tempDest).outputOptions([...targetFramerate, ...codec, ...crf, ...colorFlags, ...filter])\n\n            .save(finalDest)\n\n            .on(\"end\", () => resolve())\n\n            .on(\"error\", (e) => {\n\n                error = e\n\n                resolve()\n\n            })\n\n        })\n\n        if (error) return Promise.reject(error)\n\n        if (options.noResume || !cancel) Waifu2x.removeDirectory(frameDest)\n\n        return path.normalize(finalDest).replace(/\\\\/g, \"/\")\n\n    }\n\n\n\n    public static upscaleVideos = async (sourceFolder: string, destFolder?: string, options?: Waifu2xVideoOptions, totalProgress?: (current: number, total: number) => void | boolean, progress?: (current: number, total: number) => void | boolean) => {\n\n        options = {...options}\n\n        const files = fs.readdirSync(sourceFolder)\n\n        if (sourceFolder.endsWith(\"/\")) sourceFolder = sourceFolder.slice(0, -1)\n\n        const fileMap = files.map((file) => `${sourceFolder}/${file}`)\n\n        if (!options.limit) options.limit = fileMap.length\n\n        const retArray: string[] = []\n\n        if (totalProgress) totalProgress(0, options.limit)\n\n        for (let i = 0; i < options.limit; i++) {\n\n            if (!fileMap[i]) break\n\n            try {\n\n                const ret = await Waifu2x.upscaleVideo(fileMap[i], destFolder, options, progress)\n\n                const stop = totalProgress ? totalProgress(i + 1, options.limit) : false\n\n                retArray.push(ret)\n\n                if (stop) break\n\n            } catch (err) {\n\n                continue\n\n            }\n\n        }\n\n        return retArray\n\n    }\n\n\n\n    public static pdfDimensions = async (source: string, options?: Waifu2xPDFOptions) => {\n\n        const output = await pdfImages(source, {height: options?.downscaleHeight ? options.downscaleHeight : null, pageNumbers: [1], type: options?.pngFrames ? \"png\" : \"jpg\"}) as Uint8Array[]\n\n        const dimensions = imageSize(output[0])\n\n        return {width: dimensions.width, height: dimensions.height, image: `data:image/png;base64,${Buffer.from(output[0].buffer).toString(\"base64\")}`}\n\n    }\n\n\n\n    public static dumpPDFFrames = async (source: string, savePath: string, options?: Waifu2xPDFOptions) => {\n\n        const saveFilename = path.basename(savePath, path.extname(savePath))\n\n        const output = await pdfImages(source, {height: options?.downscaleHeight ? options.downscaleHeight : null, type: options?.pngFrames ? \"png\" : \"jpg\"})\n\n        for (let i = 0; i < output.length; i++) {\n\n            fs.writeFileSync(path.join(savePath, `${saveFilename}-${String(i+1).padStart(3, \"0\")}.png`), output[i])\n\n        }\n\n        return savePath\n\n    }\n\n\n\n    public static upscalePDF = async (source: string, dest?: string, options?: Waifu2xPDFOptions, progress?: (current: number, total: number) => void | boolean) => {\n\n        options = {...options}\n\n        if (!dest) dest = \"./\"\n\n        let {folder, image} = Waifu2x.parseFilename(source, dest, \"2x\")\n\n        if (!path.isAbsolute(source) && !path.isAbsolute(dest)) {\n\n            let local = __dirname.includes(\"node_modules\") ? path.join(__dirname, \"../../../\") : path.join(__dirname, \"..\")\n\n            folder = path.join(local, folder)\n\n            source = path.join(local, source)\n\n        }\n\n        const saveFilename = path.basename(image, path.extname(image))\n\n        let frameDest = path.join(folder, saveFilename)\n\n\n\n        let resume = 0\n\n        if (fs.existsSync(frameDest)) {\n\n            const matching = Waifu2x.findMatchingSettings(frameDest, options)\n\n            if (matching) {\n\n                frameDest = matching\n\n                resume = fs.readdirSync(`${frameDest}/upscaled`).length\n\n            } else {\n\n                frameDest = Waifu2x.newDest(frameDest)\n\n                fs.mkdirSync(frameDest, {recursive: true})\n\n                fs.writeFileSync(`${frameDest}/settings.json`, JSON.stringify(options))\n\n            }\n\n        } else {\n\n            fs.mkdirSync(frameDest, {recursive: true})\n\n            fs.writeFileSync(`${frameDest}/settings.json`, JSON.stringify(options))\n\n        }\n\n\n\n        if (resume === 0) {\n\n            await Waifu2x.dumpPDFFrames(source, frameDest, options)\n\n        }\n\n\n\n        let upScaleDest = `${frameDest}/upscaled`\n\n        if (!fs.existsSync(upScaleDest)) fs.mkdirSync(upScaleDest, {recursive: true})\n\n        options.rename = \"\"\n\n        let frameArray = fs.readdirSync(frameDest).map((f) => `${frameDest}/${f}`).filter((f) => path.extname(f).toLowerCase() === \".jpg\" || path.extname(f).toLowerCase() === \".png\" || path.extname(f).toLowerCase() === \".jpeg\")\n\n        frameArray = frameArray.sort(new Intl.Collator(undefined, {numeric: true, sensitivity: \"base\"}).compare)\n\n        let scaledFrames = fs.readdirSync(upScaleDest).map((f) => `${upScaleDest}/${path.basename(f)}`)\n\n        let cancel = false\n\n        if (options.scale !== 1) {\n\n            let counter = resume\n\n            let total = frameArray.length\n\n            let queue: string[][] = []\n\n            if (!options.parallelFrames) options.parallelFrames = 1\n\n            frameArray = frameArray.slice(resume)\n\n            while (frameArray.length) queue.push(frameArray.splice(0, options.parallelFrames))\n\n            if (progress) progress(counter++, total)\n\n            for (let i = 0; i < queue.length; i++) {\n\n                await Promise.all(queue[i].map(async (f) => {\n\n                    const destPath = await Waifu2x.upscaleImage(f, `${upScaleDest}/${path.basename(f)}`, options)\n\n                    scaledFrames.push(destPath)\n\n                    const stop = progress ? progress(counter++, total) : false\n\n                    if (stop) cancel = true\n\n                }))\n\n                if (cancel) break\n\n            }\n\n        } else {\n\n            scaledFrames = frameArray\n\n            upScaleDest = frameDest\n\n        }\n\n\n\n        scaledFrames = scaledFrames.sort(new Intl.Collator(undefined, {numeric: true, sensitivity: \"base\"}).compare)\n\n        if (options.reverse) {\n\n            scaledFrames = scaledFrames.reverse()\n\n        }\n\n        const finalDest = `${frameDest}.pdf`\n\n        const pdf = new PDFDocument({autoFirstPage: false})\n\n        const writeStream = fs.createWriteStream(finalDest)\n\n        pdf.pipe(writeStream)\n\n        \n\n        for (let i = 0; i < scaledFrames.length; i++) {\n\n            const image = pdf.openImage(scaledFrames[i])\n\n            pdf.addPage({size: [image.width, image.height]})\n\n            pdf.image(image, 0, 0)\n\n        }\n\n        pdf.end()\n\n        await Waifu2x.awaitStream(writeStream)\n\n        if (options.noResume || !cancel) Waifu2x.removeDirectory(frameDest)\n\n        return path.normalize(finalDest).replace(/\\\\/g, \"/\")\n\n    }\n\n\n\n    public static upscalePDFs = async (sourceFolder: string, destFolder?: string, options?: Waifu2xPDFOptions, progress?: (current: number, total: number) => void | boolean) => {\n\n        options = {...options}\n\n        if (sourceFolder.endsWith(\"/\")) sourceFolder = sourceFolder.slice(0, -1)\n\n        const fileMap = Waifu2x.searchFiles(sourceFolder, options?.recursive)\n\n\n\n        if (!options.limit) options.limit = fileMap.length\n\n        const retArray: string[] = []\n\n        let cancel = false\n\n        let counter = 1\n\n        let total = fileMap.length\n\n        let queue: string[][] = []\n\n        if (!options.parallelFrames) options.parallelFrames = 1\n\n        while (fileMap.length) queue.push(fileMap.splice(0, options.parallelFrames))\n\n        if (progress) progress(0, total)\n\n        for (let i = 0; i < queue.length; i++) {\n\n            await Promise.all(queue[i].map(async (f) => {\n\n                if (counter >= options.limit) cancel = true\n\n                const ret = await Waifu2x.upscalePDF(f, destFolder, options)\n\n                retArray.push(ret)\n\n                const stop = progress ? progress(counter++, total) : false\n\n                if (stop) cancel = true\n\n            }))\n\n            if (cancel) break\n\n        }\n\n        return retArray\n\n    }\n\n\n\n\n\n    private static removeDirectory = (dir: string) => {\n\n        if (!fs.existsSync(dir)) return\n\n        fs.readdirSync(dir).forEach((file) => {\n\n            const current = path.join(dir, file)\n\n            if (fs.lstatSync(current).isDirectory()) {\n\n                Waifu2x.removeDirectory(current)\n\n            } else {\n\n                fs.unlinkSync(current)\n\n            }\n\n        })\n\n        try {\n\n            fs.rmdirSync(dir)\n\n        } catch (error) {\n\n            console.log(error)\n\n        }\n\n    }\n\n}\n\n\n\nmodule.exports.default = Waifu2x\n\n\n'waifu2x/start.ts'\n:import waifu2x from \"./waifu2x\"\n\nimport path from \"path\"\n\n\n\nconst start = async () => {\n\n    const progress = (current: number, total: number) => {\n\n        console.log(`${current}/${total}`)\n\n    }\n\n    const result = await waifu2x.upscalePDF(\"./images/pdfs/pdf.pdf\", \"./images/pdfs/pdf2.pdf\", {downscaleHeight: 1000})\n\n    //const result = await waifu2x.upscaleImage(\"./images/img.png\", \"./images/upscale/img2x.png\", {upscaler: \"real-esrgan\", scale: 4})\n\n    console.log(result)\n\n}\n\nstart()\n",
        "called_code_segment": "public static upscaleImage = async (source: string, dest?: string, options?: Waifu2xOptions, progress?: (percent?: number) => void | boolean) => { ... }",
        "invoking_code_segment": "const result = await waifu2x.upscaleImage(\"./images/img.png\", \"./images/upscale/img2x.png\", {upscaler: \"real-esrgan\", scale: 4})",
        "feature_description": "Add a feature to allow the user to specify a custom output format for the upscaled image.",
        "detailed_feature_description": "Modify the upscaleImage method in #file 1 to accept an additional parameter for the output format. Update the invoking code in #file 2 to include this new parameter when calling upscaleImage.",
        "modified_complete_code": {
            "waifu2x.ts": "//Modify public static upscaleImage = async (source: string, dest?: string, options?: Waifu2xOptions, outputFormat?: Waifu2xFormats, progress?: (percent?: number) => void | boolean) => { ... } //New if (!outputFormat) outputFormat = path.extname(source).replace('.', '') as Waifu2xFormats; let command = `${program} -i \"${sourcePath}\" -o \"${destPath}\" -f ${outputFormat}`",
            "start.ts": "//Modify const result = await waifu2x.upscaleImage(\"./images/img.png\", \"./images/upscale/img2x.png\", {upscaler: \"real-esrgan\", scale: 4}, \"png\")"
        }
    },
    {
        "repo": "zephyr",
        "content": "'zephyr/packages/common/src/interfaces/zephyr-handler.ts'\n:import { ZephyrBaseRequest, ZephyrRequest } from './zephyr-request';\nimport { ZephyrResponse } from './zephyr-response';\n\nexport type ZephyrHandler<\n  TRequest extends ZephyrBaseRequest = any,\n  TResponse = any,\n> = (\n  req: ZephyrRequest<TRequest>,\n  res: ZephyrResponse<TResponse>,\n) => TResponse | Promise<TResponse> | undefined | Promise<undefined>;\n\nexport type ZephyrHandlerWithError<\n  TRequest extends ZephyrBaseRequest = any,\n  TResponse = any,\n  TError = unknown,\n> = (\n  req: ZephyrRequest<TRequest, TResponse>,\n  res: ZephyrResponse<TResponse>,\n  err: TError,\n) => TResponse | Promise<TResponse> | undefined | Promise<undefined>;\n\n'zephyr/packages/common/src/interfaces/zephyr-middleware.ts'\n:import { ZephyrHandler } from './zephyr-handler';\nimport { ZephyrBaseRequest } from './zephyr-request';\n\nexport type ZephyrMiddleware<TRequest extends ZephyrBaseRequest = any> =\n  ZephyrHandler<TRequest>;\n\n",
        "called_code_segment": "export type ZephyrHandler<TRequest extends ZephyrBaseRequest = any, TResponse = any> = (req: ZephyrRequest<TRequest>, res: ZephyrResponse<TResponse>) => TResponse | Promise<TResponse> | undefined | Promise<undefined>;",
        "invoking_code_segment": "export type ZephyrMiddleware<TRequest extends ZephyrBaseRequest = any> = ZephyrHandler<TRequest>;",
        "feature_description": "Add support for middleware to handle errors.",
        "detailed_feature_description": "Modify the ZephyrHandler type to include an optional error parameter. Update the ZephyrMiddleware type to use this new ZephyrHandlerWithError type.",
        "modified_complete_code": {
            "zephyr-handler.ts": "export type ZephyrHandler<TRequest extends ZephyrBaseRequest = any, TResponse = any> = (req: ZephyrRequest<TRequest>, res: ZephyrResponse<TResponse>) => TResponse | Promise<TResponse> | undefined | Promise<undefined>; #Modify\n\nexport type ZephyrHandlerWithError<TRequest extends ZephyrBaseRequest = any, TResponse = any, TError = unknown> = (req: ZephyrRequest<TRequest, TResponse>, res: ZephyrResponse<TResponse>, err: TError) => TResponse | Promise<TResponse> | undefined | Promise<undefined>; #New",
            "zephyr-middleware.ts": "import { ZephyrHandlerWithError } from './zephyr-handler'; #Modify\nimport { ZephyrBaseRequest } from './zephyr-request';\n\nexport type ZephyrMiddleware<TRequest extends ZephyrBaseRequest = any> = ZephyrHandlerWithError<TRequest>; #Modify"
        }
    },
    {
        "repo": "express-openapi-validate",
        "content": "'express-openapi-validate/test/open-api-document.ts'\n:/*\n  Copyright 2018 Santeri Hiltunen\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport fs from \"fs\";\nimport jsYaml from \"js-yaml\";\nimport OpenApiDocument from \"../src/OpenApiDocument\";\n\nconst openApiDocument = jsYaml.load(\n  fs.readFileSync(\"./test/openapi.yaml\", \"utf-8\"),\n);\n\nexport default openApiDocument as OpenApiDocument;\n\n'express-openapi-validate/test/schema-utils.test.ts'\n:/*\n  Copyright 2018 Santeri Hiltunen\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport _ from \"lodash\";\nimport {\n  mapOasSchemaToJsonSchema,\n  resolveReference,\n  walkSchema,\n  oasPathToExpressPath,\n} from \"../src/schema-utils\";\nimport openApiDocument from \"./open-api-document\";\n\ndescribe(\"schema utils module\", () => {\n  test(\"walkSchema returns the same schema that was passed in with identity function as the mapper\", () => {\n    const schema = {\n      properties: {\n        foo: { type: \"string\" },\n        bar: { type: \"number\", maximum: 3, exclusiveMinimum: 0 },\n        version: {\n          type: \"string\",\n          const: \"v1\",\n        },\n        baz: {\n          type: \"object\",\n          properties: {\n            asd: {\n              type: \"array\",\n              items: {\n                type: \"string\",\n              },\n              minItems: 1,\n              uniqueItems: false,\n              maxItems: 100,\n            },\n          },\n          nullable: true,\n        },\n      },\n    };\n    expect(walkSchema(schema, _.identity)).toEqual(schema);\n  });\n\n  test(\"map schema throws with invalid OAS schemas\", () => {\n    expect(() => {\n      mapOasSchemaToJsonSchema({ type: [\"array\", \"null\"] as any }, {} as any);\n    }).toThrowErrorMatchingSnapshot();\n\n    expect(() => {\n      mapOasSchemaToJsonSchema(\n        {\n          items: [{ type: \"string\" }, { type: \"number\" }] as any,\n        },\n        {} as any,\n      );\n    }).toThrowErrorMatchingSnapshot();\n\n    expect(() => {\n      mapOasSchemaToJsonSchema(\n        {\n          oneOf: [{ type: \"string\" }, { type: [\"number\", \"null\"] } as any],\n        },\n        {} as any,\n      );\n    }).toThrowErrorMatchingSnapshot();\n  });\n\n  test(\"resolveReference throws with unresolved $ref path\", () => {\n    expect(() => {\n      resolveReference(openApiDocument, {\n        $ref: \"#/components/schemas/Testt\",\n      });\n    }).toThrowErrorMatchingSnapshot();\n  });\n\n  test(\"resolveReference throws with unsupported $ref\", () => {\n    expect(() => {\n      resolveReference(openApiDocument, { $ref: \"#/a/b/C\" });\n    }).toThrowErrorMatchingSnapshot();\n  });\n\n  test(\"oasPathToExpressPath formats URL parameters for path-to-regexp\", () => {\n    expect(oasPathToExpressPath(\"/foo\")).toEqual(\"/foo\");\n    expect(oasPathToExpressPath(\"/foo/{param}\")).toEqual(\"/foo/:param\");\n    expect(oasPathToExpressPath(\"/foo/{param}/bar\")).toEqual(\"/foo/:param/bar\");\n  });\n});\n\n",
        "called_code_segment": "const openApiDocument = jsYaml.load(\n  fs.readFileSync('./test/openapi.yaml', 'utf-8'),\n);\n\nexport default openApiDocument as OpenApiDocument;",
        "invoking_code_segment": "import openApiDocument from './open-api-document';",
        "feature_description": "Add support for resolving external references in the OpenAPI document.",
        "detailed_feature_description": "To support resolving external references, we will modify the `resolveReference` function in #file 1 to handle external references by fetching the referenced document and resolving the reference within it. We will also update the corresponding code in #file 2 to handle the changes in the `resolveReference` function.",
        "modified_complete_code": {
            "#file 1": "/*\n  Copyright 2018 Santeri Hiltunen\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport fs from 'fs';\nimport jsYaml from 'js-yaml';\nimport OpenApiDocument from '../src/OpenApiDocument';\nimport axios from 'axios'; #New\n\nconst openApiDocument = jsYaml.load(\n  fs.readFileSync('./test/openapi.yaml', 'utf-8'),\n);\n\nexport default openApiDocument as OpenApiDocument;\n\n#Modify\nasync function resolveExternalReference(ref) {\n  const { protocol } = new URL(ref);\n  if (protocol === 'file:') {\n    const filePath = ref.replace('file://', '');\n    return jsYaml.load(fs.readFileSync(filePath, 'utf-8'));\n  } else if (protocol === 'http:' || protocol === 'https:') {\n    const response = await axios.get(ref);\n    return response.data;\n  }\n  throw new Error(`Unsupported protocol: ${protocol}`);\n}\n\nexport async function resolveReference(document, reference) {\n  const { $ref } = reference;\n  if ($ref.startsWith('#')) {\n    const path = $ref.substring(2).split('/');\n    return path.reduce((doc, key) => doc[key], document);\n  } else {\n    const externalDocument = await resolveExternalReference($ref);\n    return resolveReference(externalDocument, { $ref: '#' });\n  }\n}",
            "#file 2": "/*\n  Copyright 2018 Santeri Hiltunen\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport _ from 'lodash';\nimport { mapOasSchemaToJsonSchema, resolveReference, walkSchema, oasPathToExpressPath } from '../src/schema-utils';\nimport openApiDocument from './open-api-document';\n\n#Modify\nasync function testResolveReference() {\n  const resolved = await resolveReference(openApiDocument, { $ref: 'https://example.com/openapi.yaml#components/schemas/Test' });\n  console.log(resolved);\n}\n\ntestResolveReference();"
        }
    },
    {
        "repo": "onewheel-blog",
        "content": "'onewheel-blog/app/env.server.ts'\n:import invariant from \"tiny-invariant\";\n\nexport function getEnv() {\n  invariant(process.env.ADMIN_EMAIL, \"ADMIN_EMAIL should be defined\");\n\n  return {\n    ADMIN_EMAIL: process.env.ADMIN_EMAIL,\n  };\n}\n\ntype ENV = ReturnType<typeof getEnv>;\n\ndeclare global {\n  var ENV: ENV;\n  interface Window {\n    ENV: ENV;\n  }\n}\n\n'onewheel-blog/app/entry.server.tsx'\n:import \"./db.server\";\nimport type { EntryContext } from \"@remix-run/node\";\nimport { RemixServer } from \"@remix-run/react\";\nimport { renderToString } from \"react-dom/server\";\nimport { getEnv } from \"./env.server\";\n\nglobal.ENV = getEnv();\n\nexport default function handleRequest(\n  request: Request,\n  responseStatusCode: number,\n  responseHeaders: Headers,\n  remixContext: EntryContext\n) {\n  const markup = renderToString(\n    <RemixServer context={remixContext} url={request.url} />\n  );\n\n  responseHeaders.set(\"Content-Type\", \"text/html\");\n\n  return new Response(\"<!DOCTYPE html>\" + markup, {\n    status: responseStatusCode,\n    headers: responseHeaders,\n  });\n}\n\n",
        "called_code_segment": "export function getEnv() {\n  invariant(process.env.ADMIN_EMAIL, \"ADMIN_EMAIL should be defined\");\n\n  return {\n    ADMIN_EMAIL: process.env.ADMIN_EMAIL,\n  };\n}",
        "invoking_code_segment": "global.ENV = getEnv();",
        "feature_description": "Add a new environment variable to the `getEnv` function and update the invoking code to handle the new variable.",
        "detailed_feature_description": "The new feature involves adding a new environment variable, `API_URL`, to the `getEnv` function. This requires modifying the `getEnv` function in #file 1 to include the new variable and ensuring that the invoking code in #file 2 handles the updated return value.",
        "modified_complete_code": {
            "file1": "export function getEnv() {\n  invariant(process.env.ADMIN_EMAIL, \"ADMIN_EMAIL should be defined\");\n  invariant(process.env.API_URL, \"API_URL should be defined\"); #Modify\n\n  return {\n    ADMIN_EMAIL: process.env.ADMIN_EMAIL,\n    API_URL: process.env.API_URL #Modify\n  };\n}",
            "file2": "global.ENV = getEnv();\n\n// New code to handle the updated ENV object\nif (ENV.API_URL) {\n  console.log(\"API URL is set to:\", ENV.API_URL);\n} else {\n  console.error(\"API URL is not defined\");\n}"
        }
    },
    {
        "repo": "ymock",
        "content": "'ymock/dev/HostApp.tsx'\n:import {\n  Box,\n  Button,\n  Center,\n  Code,\n  Container,\n  Flex,\n  JsonInput,\n  MantineProvider,\n  NavLink,\n  Stack,\n  Title,\n} from \"@mantine/core\";\nimport \"@mantine/core/styles.css\";\nimport { useForm } from \"@mantine/form\";\nimport { IconClick } from \"@tabler/icons-react\";\nimport { HttpHandler, Path } from \"msw\";\nimport { HttpHandlerInfo } from \"msw/lib/core/handlers/HttpHandler\";\nimport { useEffect, useState } from \"react\";\nimport { RenderFnParams } from \"../src/types/ymock\";\n\ntype HandlerProp = {\n  handler?: HttpHandler;\n};\n\ntype FormValues = {\n  url?: Path;\n  method?: HttpHandlerInfo[\"method\"];\n  mode?: string;\n  cache?: string;\n  headers?: Record<string, string>;\n  referrerPolicy?: string;\n  body?: string;\n};\n\nconst CurrentHandler: React.FC<HandlerProp> = ({ handler }) =>\n  handler && (\n    <Title order={4} pb={20}>\n      Invoke {handler.info.header}\n    </Title>\n  );\n\nconst RequestForm: React.FC<\n  HandlerProp & { setResponse: React.Dispatch<any> }\n> = ({ handler, setResponse }) => {\n  const form = useForm<FormValues>({\n    initialValues: {\n      url: handler?.info.path,\n      method: handler?.info.method,\n      // mode: \"no-cors\",\n      // cache: \"no-cache\",\n      headers: {\n        // \"Content-Type\": \"application/json\",\n      },\n      // referrerPolicy: \"no-referrer\",\n      // body: \"\",\n    },\n  });\n\n  useEffect(() => {\n    form.setFieldValue(\"url\", handler?.info.path);\n    form.setFieldValue(\"method\", handler?.info.method);\n  }, [handler]);\n\n  const send = async (values: FormValues) => {\n    try {\n      const { url, ...options } = values;\n      if (!options.method) {\n        throw new Error(\"Method not set\");\n      }\n      if ([\"GET\" as HttpHandlerInfo[\"method\"]].includes(options.method)) {\n        delete options.body;\n        console.log(options);\n      }\n      const response = await fetch(url as string, options as RequestInit);\n      console.log(response);\n      const data = await response.json();\n      setResponse(data);\n    } catch (err) {\n      // @ts-ignore\n      setResponse(err?.message);\n    }\n  };\n\n  const method = handler?.info.method;\n\n  switch (method) {\n    case undefined:\n      return <Box>Select an api on the right</Box>;\n    case \"POST\":\n    case \"PUT\":\n    case \"PATCH\":\n      return (\n        <form style={{ width: \"100%\" }} onSubmit={form.onSubmit(send)}>\n          <Stack>\n            <JsonInput\n              label=\"Body (json)\"\n              placeholder=\"{}\"\n              autosize\n              minRows={10}\n              style={{ width: \"100%\" }}\n              {...form.getInputProps(\"body\")}\n            />\n            <Button type=\"submit\">Send</Button>\n          </Stack>\n        </form>\n      );\n    case \"GET\":\n    case \"DELETE\":\n    default:\n      return (\n        <form style={{ width: \"100%\" }} onSubmit={form.onSubmit(send)}>\n          <Stack>\n            <Button type=\"submit\">Send</Button>\n          </Stack>\n        </form>\n      );\n  }\n};\n\nconst Response: React.FC<any> = ({ data }) => {\n  try {\n    let stringData;\n    switch (typeof data) {\n      case \"string\":\n      case \"boolean\":\n      case \"number\":\n        stringData = data;\n        break;\n      case \"object\":\n        stringData = JSON.stringify(data, null, 2);\n    }\n    return data && <Code>{data.toString()}</Code>;\n  } catch (e) {\n    console.warn(e);\n  }\n};\n\nexport const HostApp: React.FC<RenderFnParams> = ({ worker, handlers }) => {\n  const [currentHandler, setCurrentHandler] = useState<HttpHandler>();\n  const [response, setResponse] = useState<any>();\n\n  const changeHandler = (handler: HttpHandler) => {\n    setCurrentHandler(handler);\n    setResponse(null);\n  };\n\n  return (\n    <MantineProvider>\n      <Container>\n        <Center py={10}>\n          <Title>Host app</Title>\n        </Center>\n        <Flex\n          gap={20}\n          align=\"stretch\"\n          style={{\n            alignContent: \"stretch\",\n          }}\n        >\n          <Box>\n            <Title order={4} pb={10}>\n              Select an api\n            </Title>\n            {handlers.map((api) => (\n              <NavLink\n                key={api.info.header}\n                label={api.info.header}\n                rightSection={<IconClick />}\n                onClick={() => changeHandler(api)}\n              />\n            ))}\n          </Box>\n          <Box style={{ flexGrow: 2 }}>\n            <Container>\n              <CurrentHandler handler={currentHandler} />\n              <RequestForm handler={currentHandler} setResponse={setResponse} />\n              <Response data={response} />\n            </Container>\n          </Box>\n        </Flex>\n      </Container>\n    </MantineProvider>\n  );\n};\n\n'ymock/dev/index.tsx'\n:/**\n * This is a development-only support file, it works as host application for ymock\n */\n\nimport { worker } from \"./mocks/browser\";\nimport { handlers } from \"./mocks/handlers\";\nimport { ymock } from \"../src/main\";\nimport ReactDOM from \"react-dom/client\";\nimport React from \"react\";\nimport { HostApp } from \"./HostApp\";\n\nconst root = document.getElementById(\"root\");\nconst startApp = () =>\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <HostApp {...{ worker, handlers }} />\n    </React.StrictMode>\n  );\n\nworker.start().then(startApp);\nymock.load({ worker, handlers }).addButton();\n// ymock.load({ worker, handlers }).open();\n\n// Start without mocks\n// startApp();\n\n",
        "called_code_segment": "const startApp = () =>\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <HostApp {...{ worker, handlers }} />\n    </React.StrictMode>\n  );",
        "invoking_code_segment": "worker.start().then(startApp);",
        "feature_description": "Add a loading spinner while the worker is starting up.",
        "detailed_feature_description": "When the worker starts, display a loading spinner until the worker is fully initialized. This ensures a better user experience by indicating that the application is loading.",
        "modified_complete_code": "// #file 1\nimport { worker } from \"./mocks/browser\";\nimport { handlers } from \"./mocks/handlers\";\nimport { ymock } from \"../src/main\";\nimport ReactDOM from \"react-dom/client\";\nimport React from \"react\";\nimport { HostApp } from \"./HostApp\";\nimport { Loader } from \"@mantine/core\"; // #New\n\nconst root = document.getElementById(\"root\");\n\nconst startApp = () =>\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <HostApp {...{ worker, handlers }} />\n    </React.StrictMode>\n  );\n\n// #Modify: Add loading spinner\nconst renderLoading = () => {\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <Loader />\n    </React.StrictMode>\n  );\n};\n\nrenderLoading(); // #New\nworker.start().then(startApp);\nymock.load({ worker, handlers }).addButton();\n// ymock.load({ worker, handlers }).open();\n\n// Start without mocks\n// startApp();\n\n// #file 2\nimport { worker } from \"./mocks/browser\";\nimport { handlers } from \"./mocks/handlers\";\nimport { ymock } from \"../src/main\";\nimport ReactDOM from \"react-dom/client\";\nimport React from \"react\";\nimport { HostApp } from \"./HostApp\";\nimport { Loader } from \"@mantine/core\"; // #New\n\nconst root = document.getElementById(\"root\");\n\nconst startApp = () =>\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <HostApp {...{ worker, handlers }} />\n    </React.StrictMode>\n  );\n\n// #Modify: Add loading spinner\nconst renderLoading = () => {\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <Loader />\n    </React.StrictMode>\n  );\n};\n\nrenderLoading(); // #New\nworker.start().then(startApp);\nymock.load({ worker, handlers }).addButton();\n// ymock.load({ worker, handlers }).open();\n\n// Start without mocks\n// startApp();"
    },
    {
        "repo": "zero",
        "content": "'zero/src/editor/icons.tsx'\n:import * as React from 'react';\n\nexport const EditIcon = () => (\n  <svg fill=\"#FFFFFF\" height=\"24\" viewBox=\"0 0 24 24\" width=\"24\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path d=\"M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z\" />\n    <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n  </svg>\n);\n\nexport const ConsoleIcon = () => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    version=\"1.1\"\n    width=\"24px\"\n    height=\"24px\"\n    viewBox=\"0 0 471.362 471.362\"\n  >\n    <path\n      d=\"M468.794,355.171c-1.707-1.718-3.897-2.57-6.563-2.57H188.145c-2.664,0-4.854,0.853-6.567,2.57 c-1.711,1.711-2.565,3.897-2.565,6.563v18.274c0,2.662,0.854,4.853,2.565,6.563c1.713,1.712,3.903,2.57,6.567,2.57h274.086 c2.666,0,4.856-0.858,6.563-2.57c1.711-1.711,2.567-3.901,2.567-6.563v-18.274C471.365,359.068,470.513,356.882,468.794,355.171z\"\n      fill=\"#FFFFFF\"\n    />\n    <path\n      d=\"M30.259,85.075c-1.903-1.903-4.093-2.856-6.567-2.856s-4.661,0.953-6.563,2.856L2.852,99.353 C0.95,101.255,0,103.442,0,105.918c0,2.478,0.95,4.664,2.852,6.567L115.06,224.69L2.852,336.896C0.95,338.799,0,340.989,0,343.46 c0,2.478,0.95,4.665,2.852,6.567l14.276,14.273c1.903,1.906,4.089,2.854,6.563,2.854s4.665-0.951,6.567-2.854l133.048-133.045 c1.903-1.902,2.853-4.096,2.853-6.57c0-2.473-0.95-4.663-2.853-6.565L30.259,85.075z\"\n      fill=\"#FFFFFF\"\n    />\n  </svg>\n);\n\nexport const GithubIcon = () => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    version=\"1.1\"\n    viewBox=\"0 0 478.613 478.613\"\n    width=\"24px\"\n    height=\"24px\"\n  >\n    <path\n      d=\"M427.501,200.695c1.776-11.238,2.884-23.56,3.163-37.377c-0.107-59.246-28.468-80.21-33.925-90.038c8.037-44.89-1.331-65.309-5.688-72.299c-16.07-5.704-55.91,14.722-77.678,29.101c-35.491-10.389-110.494-9.375-138.621,2.689C122.856-4.389,95.408,1.277,95.408,1.277s-17.745,31.82-4.691,78.371c-17.075,21.759-29.802,37.143-29.802,77.949c0,9.773,0.607,19.008,1.637,27.893c14.705,77.318,75.97,110.674,136.15,116.426c-9.056,6.881-19.928,19.903-21.432,34.992    c-11.379,7.357-34.268,9.789-52.067,4.193c-24.939-7.88-34.486-57.266-71.833-50.221c-8.081,1.512-6.475,6.842,0.523,11.386c11.378,7.38,22.094,16.554,30.354,36.185c6.344,15.072,19.687,41.982,61.873,41.982c16.747,0,28.477-1.979,28.477-1.979s0.319,38.406,0.319,53.385c0,17.238-23.264,22.078-23.264,30.348c0,3.289,7.7,3.601,13.888,3.601c12.229,0,37.673-10.186,37.673-28.103c0-14.237,0.227-62.081,0.227-70.46c0-18.307,9.811-24.136,9.811-24.136    s1.201,97.727-2.361,110.829c-4.177,15.408-11.744,13.219-11.744,20.076c0,10.233,30.589,2.502,40.735-19.897c7.849-17.495,4.334-113.331,4.334-113.331l8.183-0.178c0,0,0.094,43.892-0.188,63.944c-0.295,20.769-2.438,47.025,9.898,59.417c8.097,8.15,32.903,22.451,32.903,9.382c0-7.574-17.371-13.833-17.371-34.353V344.45c10.553,0,12.734,31.072,12.734,31.072l3.804,57.727c0,0-2.526,21.065,22.756,29.856c8.925,3.126,28.018,3.976,28.913-1.271c0.897-5.26-22.99-13.038-23.217-29.342    c-0.123-9.93,0.445-15.742,0.445-58.934c0-43.168-5.799-59.137-26.007-71.863C355.669,295.681,416.536,269.51,427.501,200.695z\"\n      fill=\"#FFFFFF\"\n    />\n  </svg>\n);\n\nexport const VoyagerIcon = () => (\n  <svg viewBox=\"0 0 48 48\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path\n      d=\"M46,36H38V32a1,1,0,0,0-1-1H25V28h8a2,2,0,0,0,2-2V18a2,2,0,0,0-2-2H25V12h8a2,2,0,0,0,2-2V2a2,2,0,0,0-2-2H15a2,2,0,0,0-2,2v8a2,2,0,0,0,2,2h8v4H15a2,2,0,0,0-2,2v8a2,2,0,0,0,2,2h8v3H11a1,1,0,0,0-1,1v4H2a2,2,0,0,0-2,2v8a2,2,0,0,0,2,2H20a2,2,0,0,0,2-2V38a2,2,0,0,0-2-2H12V33H36v3H28a2,2,0,0,0-2,2v8a2,2,0,0,0,2,2H46a2,2,0,0,0,2-2V38A2,2,0,0,0,46,36ZM20,38v8H2V38ZM15,10V2H33v8Zm0,16V18H33v8ZM46,46H28V38H46Z\"\n      fill=\"#FFFFFF\"\n    />\n  </svg>\n);\n\n'zero/src/editor/index.tsx'\n:import './css/app.css';\nimport './css/codemirror.css';\nimport './GraphQLEditor/editor.css';\nimport 'graphiql/graphiql.css';\n\nimport GraphiQL from 'graphiql';\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport classNames from 'classnames';\n\nimport { Source, GraphQLSchema } from 'graphql';\n\nimport { buildWithFakeDefinitions } from '../fake_definition';\n\nimport GraphQLEditor from './GraphQLEditor/GraphQLEditor';\nimport { ConsoleIcon, EditIcon, GithubIcon, VoyagerIcon } from './icons';\n\ntype FakeEditorState = {\n  value: string | null;\n  cachedValue: string | null;\n  activeTab: number;\n  hasUnsavedChanges: boolean;\n  error: string | null;\n  status: string | null;\n  schema: GraphQLSchema | null;\n  unsavedSchema: GraphQLSchema | null;\n  remoteSDL: string | null;\n};\n\nclass FakeEditor extends React.Component<any, FakeEditorState> {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      value: null,\n      cachedValue: null,\n      activeTab: 0,\n      hasUnsavedChanges: false,\n      unsavedSchema: null,\n      error: null,\n      status: null,\n      schema: null,\n      remoteSDL: null,\n    };\n  }\n\n  componentDidMount() {\n    this.fetcher('/user-sdl')\n      .then((response) => response.json())\n      .then((SDLs) => {\n        this.updateValue(SDLs);\n      });\n\n    window.onbeforeunload = () => {\n      if (this.state.hasUnsavedChanges) return 'You have unsaved changes. Exit?';\n    };\n  }\n\n  fetcher(url, options = {}) {\n    const baseUrl = '..';\n    return fetch(baseUrl + url, {\n      credentials: 'include',\n      ...options,\n    });\n  }\n\n  graphQLFetcher(graphQLParams) {\n    return this.fetcher('/graphql', {\n      method: 'post',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(graphQLParams),\n    }).then((response) => response.json());\n  }\n\n  updateValue({ userSDL, remoteSDL }) {\n    this.setState({\n      value: userSDL,\n      cachedValue: userSDL,\n      remoteSDL,\n    });\n    this.updateSDL(userSDL, true);\n  }\n\n  postSDL(sdl) {\n    return this.fetcher('/user-sdl', {\n      method: 'post',\n      headers: { 'Content-Type': 'text/plain' },\n      body: sdl,\n    });\n  }\n\n  buildSchema(userSDL, options?) {\n    if (this.state.remoteSDL) {\n      return buildWithFakeDefinitions(\n        new Source(this.state.remoteSDL),\n        new Source(userSDL),\n        options,\n      );\n    } else {\n      return buildWithFakeDefinitions(new Source(userSDL), options);\n    }\n  }\n\n  updateSDL(value, noError = false) {\n    try {\n      const {schema} = this.buildSchema(value);\n      this.setState((prevState) => ({\n        ...prevState,\n        schema,\n        error: null,\n      }));\n      return true;\n    } catch (e) {\n      if (noError) return;\n      this.setState((prevState) => ({ ...prevState, error: e.message }));\n      return false;\n    }\n  }\n\n  setStatus(status, delay) {\n    this.setState((prevState) => ({ ...prevState, status: status }));\n    if (!delay) return;\n    setTimeout(() => {\n      this.setState((prevState) => ({ ...prevState, status: null }));\n    }, delay);\n  }\n\n  saveUserSDL = () => {\n    let { value, hasUnsavedChanges } = this.state;\n    if (!hasUnsavedChanges) return;\n\n    if (!this.updateSDL(value)) return;\n\n    this.postSDL(value).then((res) => {\n      if (res.ok) {\n        this.setStatus('Saved!', 2000);\n        return this.setState((prevState) => ({\n          ...prevState,\n          cachedValue: value,\n          hasUnsavedChanges: false,\n          unsavedSchema: null,\n          error: null,\n        }));\n      } else {\n        res.text().then((errorMessage) => {\n          return this.setState((prevState) => ({\n            ...prevState,\n            error: errorMessage,\n          }));\n        });\n      }\n    });\n  };\n\n  switchTab(tab) {\n    this.setState((prevState) => ({ ...prevState, activeTab: tab }));\n  }\n\n  onEdit = (val) => {\n    if (this.state.error) this.updateSDL(val);\n    let unsavedSchema = null as GraphQLSchema | null;\n    try {\n      const {schema} = this.buildSchema(val, { skipValidation: true });\n      unsavedSchema = schema;\n    } catch (_) {}\n\n    this.setState((prevState) => ({\n      ...prevState,\n      value: val,\n      hasUnsavedChanges: val !== this.state.cachedValue,\n      unsavedSchema,\n    }));\n  };\n\n  render() {\n    let { value, activeTab, schema, hasUnsavedChanges, unsavedSchema } = this.state;\n    if (value == null || schema == null) {\n      return <div className=\"faker-editor-container\">Loading...</div>;\n    }\n\n    return (\n      <div className=\"faker-editor-container\">\n        <nav>\n          <div className=\"logo\">\n            <a href=\"https://github.com/APIs-guru/graphql-faker\" target=\"_blank\">\n              {' '}\n              <img src=\"./logo.svg\" />{' '}\n            </a>\n          </div>\n          <ul>\n            <li\n              onClick={() => this.switchTab(0)}\n              className={classNames({\n                '-active': activeTab === 0,\n                '-unsaved': hasUnsavedChanges,\n              })}\n            >\n              {' '}\n              <EditIcon />{' '}\n            </li>\n            <li\n              onClick={() => !hasUnsavedChanges && this.switchTab(1)}\n              className={classNames({\n                '-disabled': hasUnsavedChanges,\n                '-active': activeTab === 1,\n              })}\n            >\n              {' '}\n              <ConsoleIcon />{' '}\n            </li>\n            <li\n              onClick={() => !hasUnsavedChanges && this.switchTab(2)}\n              className={classNames({\n                '-disabled': hasUnsavedChanges,\n                '-active': activeTab === 2,\n              })}\n            >\n              {' '}\n              <VoyagerIcon />{' '}\n            </li>\n            <li className=\"-pulldown -link\">\n              <a href=\"https://github.com/APIs-guru/graphql-faker\" target=\"_blank\">\n                {' '}\n                <GithubIcon />{' '}\n              </a>\n            </li>\n          </ul>\n        </nav>\n        <div className=\"tabs-container\">\n          <div\n            className={classNames('tab-content', 'editor-container', {\n              '-active': activeTab === 0,\n            })}\n          >\n            <GraphQLEditor\n              schema={unsavedSchema || schema}\n              onEdit={this.onEdit}\n              onCommand={this.saveUserSDL}\n              value={value}\n            />\n            <div className=\"action-panel\">\n              <a\n                className={classNames('material-button', {\n                  '-disabled': !hasUnsavedChanges,\n                })}\n                onClick={this.saveUserSDL}\n              >\n                <span> Save </span>\n              </a>\n              <div className=\"status-bar\">\n                <span className=\"status\"> {this.state.status} </span>\n                <span className=\"error-message\">{this.state.error}</span>\n              </div>\n            </div>\n          </div>\n          <div\n            className={classNames('tab-content', {\n              '-active': activeTab === 1,\n            })}\n          >\n            <GraphiQL fetcher={(e) => this.graphQLFetcher(e)} schema={schema} />\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<FakeEditor />, document.getElementById('container'));\n\n",
        "called_code_segment": "updateSDL(value, noError = false) {\n    try {\n      const {schema} = this.buildSchema(value);\n      this.setState((prevState) => ({\n        ...prevState,\n        schema,\n        error: null,\n      }));\n      return true;\n    } catch (e) {\n      if (noError) return;\n      this.setState((prevState) => ({ ...prevState, error: e.message }));\n      return false;\n    }\n  }",
        "invoking_code_segment": "onEdit = (val) => {\n    if (this.state.error) this.updateSDL(val);\n    let unsavedSchema = null as GraphQLSchema | null;\n    try {\n      const {schema} = this.buildSchema(val, { skipValidation: true });\n      unsavedSchema = schema;\n    } catch (_) {}\n\n    this.setState((prevState) => ({\n      ...prevState,\n      value: val,\n      hasUnsavedChanges: val !== this.state.cachedValue,\n      unsavedSchema,\n    }));\n  };",
        "new_file_code_segment": "export function validateSDL(sdl: string): string | null {\n  try {\n    const {schema} = buildWithFakeDefinitions(new Source(sdl));\n    return null;\n  } catch (e) {\n    return e.message;\n  }\n}",
        "feature_description": "Add SDL validation feedback in the editor.",
        "detailed_feature_description": "The new feature introduces SDL validation feedback directly in the editor. When the user edits the SDL, the editor will provide immediate feedback on any syntax errors. This is achieved by creating a new function `validateSDL` in a new file (#file 3) that performs the validation. The `updateSDL` method in #file 1 is modified to use this new function for validation, and the `onEdit` method in #file 2 is updated to handle the validation feedback.",
        "modified_complete_code": {
            "#file 1": "updateSDL(value, noError = false) {\n    try {\n      const {schema} = this.buildSchema(value);\n      this.setState((prevState) => ({\n        ...prevState,\n        schema,\n        error: null,\n      }));\n      return true;\n    } catch (e) {\n      if (noError) return;\n      this.setState((prevState) => ({ ...prevState, error: e.message }));\n      return false;\n    }\n  }",
            "#file 2": "onEdit = (val) => {\n    if (this.state.error) this.updateSDL(val);\n    let unsavedSchema = null as GraphQLSchema | null;\n    try {\n      const {schema} = this.buildSchema(val, { skipValidation: true });\n      unsavedSchema = schema;\n    } catch (_) {}\n\n    this.setState((prevState) => ({\n      ...prevState,\n      value: val,\n      hasUnsavedChanges: val !== this.state.cachedValue,\n      unsavedSchema,\n    }));\n  };",
            "#file 3": "export function validateSDL(sdl: string): string | null {\n  try {\n    const {schema} = buildWithFakeDefinitions(new Source(sdl));\n    return null;\n  } catch (e) {\n    return e.message;\n  }\n}"
        }
    },
    {
        "repo": "Angular-vault-2.0",
        "content": "'Angular-vault-2.0/click-to-unlock-workspace/projects/sidebar/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport{AdminModule} from './admin/admin.module'\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    AdminModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'Angular-vault-2.0/click-to-unlock-workspace/projects/sidebar/src/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\n\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment": "@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    AdminModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
        "invoking_code_segment": "platformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));",
        "new_file_code_segment": "export function initializeApp(appConfig: any) {\n  console.log('Initializing app with config:', appConfig);\n}",
        "feature_description": "Add an initialization function to log app configuration during bootstrap.",
        "detailed_feature_description": "The new feature involves adding an initialization function that logs the app configuration during the bootstrap process. This function will be defined in a new file (#file 3) and invoked from both #file 1 and #file 2 to ensure the configuration is logged when the app starts.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { NgModule, APP_INITIALIZER } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { AdminModule } from './admin/admin.module';\nimport { initializeApp } from './app-initializer';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    AdminModule\n  ],\n  providers: [\n    { provide: APP_INITIALIZER, useFactory: initializeApp, deps: [], multi: true }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
            "#file 2": "//Modify\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app/app.module';\nimport { initializeApp } from './app/app-initializer';\n\ninitializeApp({ config: 'exampleConfig' });\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));",
            "#file 3": "//New\nexport function initializeApp(appConfig: any) {\n  console.log('Initializing app with config:', appConfig);\n}"
        }
    },
    {
        "repo": "apitool",
        "content": "'apitool/apps/client/src/components/locale-combobox.tsx'\n:import { t } from \"@lingui/macro\";\nimport { CaretDown, Check } from \"@phosphor-icons/react\";\nimport {\n  Button,\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n  ScrollArea,\n} from \"@apitool/ui\";\nimport { cn } from \"@apitool/utils\";\nimport fuzzy from \"fuzzy\";\nimport { useMemo, useState } from \"react\";\n\nimport { useLanguages } from \"../services/project/translation\";\n\ntype Props = {\n  value: string;\n  onValueChange: (locale: string) => void;\n};\n\nexport const LocaleCombobox = ({ value, onValueChange }: Props) => {\n  const { languages } = useLanguages();\n  const [search, setSearch] = useState(\"\");\n\n  const options = useMemo(() => {\n    return fuzzy.filter(search, languages, {\n      extract: (lang) => `${lang.name} ${lang.locale}`,\n    });\n  }, [search, languages]);\n\n  return (\n    <Command shouldFilter={false}>\n      <CommandInput\n        value={search}\n        onValueChange={setSearch}\n        placeholder={t`Search for a language`}\n      />\n      <CommandList>\n        <CommandEmpty>{t`No results found`}</CommandEmpty>\n        <CommandGroup>\n          <ScrollArea orientation=\"vertical\">\n            <div className=\"max-h-60\">\n              {options.map(({ original }) => (\n                <CommandItem\n                  disabled={false}\n                  key={original.locale}\n                  value={original.locale.trim()}\n                  onSelect={async (selectedValue) => {\n                    const result = options.find(\n                      ({ original }) => original.locale.trim() === selectedValue,\n                    );\n\n                    if (!result) return null;\n\n                    onValueChange(result.original.locale);\n                  }}\n                >\n                  <Check\n                    className={cn(\n                      \"mr-2 size-4 opacity-0\",\n                      value === original.locale && \"opacity-100\",\n                    )}\n                  />\n                  {original.name}{\" \"}\n                  <span className=\"ml-1 text-xs opacity-50\">({original.locale})</span>\n                </CommandItem>\n              ))}\n            </div>\n          </ScrollArea>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  );\n};\n\nexport const LocaleComboboxPopover = ({ value, onValueChange }: Props) => {\n  const { languages } = useLanguages();\n  const [open, setOpen] = useState(false);\n\n  const selected = useMemo(() => {\n    return languages.find((lang) => lang.locale === value);\n  }, [value, languages]);\n\n  const onSelect = (selectedValue: string) => {\n    onValueChange(selectedValue);\n    setOpen(false);\n  };\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          role=\"combobox\"\n          variant=\"outline\"\n          aria-expanded={open}\n          className=\"w-full justify-between hover:bg-secondary/20 active:scale-100\"\n        >\n          <span className=\"line-clamp-1 text-left font-normal\">\n            {selected?.name} <span className=\"ml-1 text-xs opacity-50\">({selected?.locale})</span>\n          </span>\n          <CaretDown\n            className={cn(\n              \"ml-2 size-4 shrink-0 rotate-0 opacity-50 transition-transform\",\n              open && \"rotate-180\",\n            )}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent align=\"start\" className=\"p-0\">\n        <LocaleCombobox value={value} onValueChange={onSelect} />\n      </PopoverContent>\n    </Popover>\n  );\n};\n\n'apitool/apps/client/src/components/locale-switch.tsx'\n:import { useLingui } from \"@lingui/react\";\nimport { Translate } from \"@phosphor-icons/react\";\nimport { Button, Popover, PopoverContent, PopoverTrigger } from \"@apitool/ui\";\nimport { useState } from \"react\";\n\nimport { changeLanguage } from \"../providers/locale\";\nimport { LocaleCombobox } from \"./locale-combobox\";\n\nexport const LocaleSwitch = () => {\n  const { i18n } = useLingui();\n  const [open, setOpen] = useState(false);\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button size=\"icon\" variant=\"ghost\">\n          <Translate size={20} />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent align=\"end\" className=\"p-0\">\n        <LocaleCombobox\n          value={i18n.locale}\n          onValueChange={async (locale) => {\n            await changeLanguage(locale);\n            setOpen(false);\n          }}\n        />\n      </PopoverContent>\n    </Popover>\n  );\n};\n\n",
        "called_code_segment": "export const LocaleCombobox = ({ value, onValueChange }: Props) => { ... }",
        "invoking_code_segment": "const onSelect = (selectedValue: string) => { onValueChange(selectedValue); setOpen(false); };",
        "new_file_code_segment": "export const useLocaleChange = (locale: string) => { ... }",
        "feature_description": "Add a feature to notify when a locale is changed.",
        "detailed_feature_description": "The new feature introduces a hook `useLocaleChange` in #file 3 that will notify when a locale is changed. This hook will be used in #file 1 to trigger notifications whenever the locale is updated. #file 2 will be updated to use this new hook to ensure compatibility and integration.",
        "modified_complete_code": {
            "#file 1": "//Modify for modified parts and #New for newly added parts to indicate whether the change is an addition or modification.\n\nimport { useLocaleChange } from './useLocaleChange'; //New\n\nexport const LocaleCombobox = ({ value, onValueChange }: Props) => {\n  const { languages } = useLanguages();\n  const [search, setSearch] = useState('');\n  const notifyLocaleChange = useLocaleChange(value); //New\n\n  const options = useMemo(() => {\n    return fuzzy.filter(search, languages, {\n      extract: (lang) => `${lang.name} ${lang.locale}`,\n    });\n  }, [search, languages]);\n\n  return (\n    <Command shouldFilter={false}>\n      <CommandInput\n        value={search}\n        onValueChange={setSearch}\n        placeholder={t`Search for a language`}\n      />\n      <CommandList>\n        <CommandEmpty>{t`No results found`}</CommandEmpty>\n        <CommandGroup>\n          <ScrollArea orientation=\"vertical\">\n            <div className=\"max-h-60\">\n              {options.map(({ original }) => (\n                <CommandItem\n                  disabled={false}\n                  key={original.locale}\n                  value={original.locale.trim()}\n                  onSelect={async (selectedValue) => {\n                    const result = options.find(\n                      ({ original }) => original.locale.trim() === selectedValue,\n                    );\n\n                    if (!result) return null;\n\n                    onValueChange(result.original.locale);\n                    notifyLocaleChange(result.original.locale); //Modify\n                  }}\n                >\n                  <Check\n                    className={cn(\n                      'mr-2 size-4 opacity-0',\n                      value === original.locale && 'opacity-100',\n                    )}\n                  />\n                  {original.name} <span className=\"ml-1 text-xs opacity-50\">({original.locale})</span>\n                </CommandItem>\n              ))}\n            </div>\n          </ScrollArea>\n        </CommandGroup>\n      </CommandList>\n    </Command>\n  );\n};",
            "#file 2": "//Modify for modified parts and #New for newly added parts to indicate whether the change is an addition or modification.\n\nimport { useLocaleChange } from './useLocaleChange'; //New\n\nexport const LocaleComboboxPopover = ({ value, onValueChange }: Props) => {\n  const { languages } = useLanguages();\n  const [open, setOpen] = useState(false);\n  const notifyLocaleChange = useLocaleChange(value); //New\n\n  const selected = useMemo(() => {\n    return languages.find((lang) => lang.locale === value);\n  }, [value, languages]);\n\n  const onSelect = (selectedValue: string) => {\n    onValueChange(selectedValue);\n    notifyLocaleChange(selectedValue); //Modify\n    setOpen(false);\n  };\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          role=\"combobox\"\n          variant=\"outline\"\n          aria-expanded={open}\n          className=\"w-full justify-between hover:bg-secondary/20 active:scale-100\"\n        >\n          <span className=\"line-clamp-1 text-left font-normal\">\n            {selected?.name} <span className=\"ml-1 text-xs opacity-50\">({selected?.locale})</span>\n          </span>\n          <CaretDown\n            className={cn(\n              'ml-2 size-4 shrink-0 rotate-0 opacity-50 transition-transform',\n              open && 'rotate-180',\n            )}\n          />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent align=\"start\" className=\"p-0\">\n        <LocaleCombobox value={value} onValueChange={onSelect} />\n      </PopoverContent>\n    </Popover>\n  );\n};",
            "#file 3": "//New\nexport const useLocaleChange = (locale: string) => {\n  const notifyLocaleChange = (newLocale: string) => {\n    console.log(`Locale changed from ${locale} to ${newLocale}`);\n  };\n\n  return notifyLocaleChange;\n};"
        }
    },
    {
        "repo": "grafana-percent-plus",
        "content": "'grafana-percent-plus/src/types.ts'\n:import { ThresholdsConfig, ThresholdsMode } from '@grafana/data';\n\nexport interface PercentPanelOptions {\n  percentOf: string;\n  over: string;\n  decimal: number;\n  thresholds: ThresholdsConfig;\n  valueFontSize: string;\n  percentFontSize: string;\n  maxValue: string;\n}\n\nexport const defaults: PercentPanelOptions = {\n  percentOf: '',\n  over: '',\n  decimal: -1,\n  thresholds: {\n    mode: ThresholdsMode.Percentage,\n    steps: [{ value: -Infinity, color: 'red' }, { value: 95, color: 'red' }, { value: 99, color: 'orange' }, { value: 100, color: 'green' }]\n  },\n  valueFontSize: '80',\n  percentFontSize: '50',\n  maxValue: 'Infinity'\n};\n\n'grafana-percent-plus/src/module.tsx'\n:import { PanelPlugin } from '@grafana/data';\nimport { PercentPanelOptions, defaults } from './types';\nimport { PercentPanel } from './PercentPanel';\nimport { PercentEditor } from './PercentEditor';\n\nexport const plugin = new PanelPlugin<PercentPanelOptions>(PercentPanel).setDefaults(defaults).setEditor(PercentEditor);\n\n",
        "called_code_segment": "export const plugin = new PanelPlugin<PercentPanelOptions>(PercentPanel).setDefaults(defaults).setEditor(PercentEditor);",
        "invoking_code_segment": "import { plugin } from './module';",
        "new_file_code_segment": "export const calculatePercentage = (percentOf: string, over: string, decimal: number): number => { const percentOfValue = parseFloat(percentOf); const overValue = parseFloat(over); if (isNaN(percentOfValue) || isNaN(overValue)) { return 0; } return parseFloat(((percentOfValue / overValue) * 100).toFixed(decimal)); };",
        "feature_description": "Add a percentage calculation function to enhance the panel's functionality.",
        "detailed_feature_description": "The new feature introduces a percentage calculation function in a new file (#file 3). This function will be used to calculate the percentage based on the values provided in the panel options. The function is integrated into the existing panel logic by modifying the `PercentPanel` component in #file 1 to use this new function. The `PercentEditor` component in #file 2 is also updated to ensure compatibility with the new functionality.",
        "modified_complete_code": {
            "#file 1": "import { PanelPlugin } from '@grafana/data';\nimport { PercentPanelOptions, defaults } from './types';\nimport { PercentPanel } from './PercentPanel';\nimport { PercentEditor } from './PercentEditor';\nimport { calculatePercentage } from './PercentageCalculator'; //New\n\nexport const plugin = new PanelPlugin<PercentPanelOptions>(PercentPanel).setDefaults(defaults).setEditor(PercentEditor);\n\n//Modify: Update PercentPanel to use calculatePercentage\nconst calculate = (options: PercentPanelOptions) => {\n  const percent = calculatePercentage(options.percentOf, options.over, options.decimal);\n  return percent;\n};",
            "#file 2": "import { plugin } from './module';\nimport { calculatePercentage } from './PercentageCalculator'; //New\n\n//Modify: Update PercentEditor to use calculatePercentage\nconst handleChange = (options: PercentPanelOptions) => {\n  const percent = calculatePercentage(options.percentOf, options.over, options.decimal);\n  // Handle the change based on the calculated percentage\n};",
            "#file 3": "export const calculatePercentage = (percentOf: string, over: string, decimal: number): number => {\n  const percentOfValue = parseFloat(percentOf);\n  const overValue = parseFloat(over);\n  if (isNaN(percentOfValue) || isNaN(overValue)) {\n    return 0;\n  }\n  return parseFloat(((percentOfValue / overValue) * 100).toFixed(decimal));\n};"
        }
    },
    {
        "repo": "layout",
        "content": "'layout/src/stories/utils/argTypes.ts'\n:type Types = { [name: string]: object | number | string | boolean | Array<any>};\n\nconst controls = {\n    select: {\n        control: {\n            type: 'select',\n        },\n    },\n    check: {\n        control: {\n            type: 'check',\n        },\n    },\n    color: {\n        control: {\n            type: 'color',\n        },\n    },\n    count: {\n        control: {\n            type: 'range',\n        },\n    },\n    type: {\n        control: {\n            type: 'radio',\n        },\n    },\n    date: {\n        control: {\n            type: 'date',\n        },\n    },\n    switch: {\n        control: {\n            type: 'boolean',\n        },\n    },\n};\n\nexport const argTypes = (args: Types) =>\n{\n    const exportArgTypes: any = {};\n\n    for (const key in args)\n    {\n        if (typeof args[key] === 'number')\n        {\n            let min = 0;\n\n            const number = args[key] as number;\n\n            if (key.includes('font') || key.includes('amount'))\n            {\n                min = 1;\n            }\n\n            if (number >= 0)\n            {\n                if (number >= 100)\n                {\n                    exportArgTypes[key] = {\n                        control: {\n                            type: 'range',\n                            min,\n                            max: 1000,\n                            step: 10,\n                        },\n                    };\n                }\n                else if (number > 10)\n                {\n                    exportArgTypes[key] = {\n                        control: {\n                            type: 'range',\n                            min,\n                            max: 100,\n                            step: 1,\n                        },\n                    };\n                }\n                else if (number <= 1)\n                {\n                    exportArgTypes[key] = {\n                        control: {\n                            type: 'range',\n                            min,\n                            max: 1,\n                            step: 0.1,\n                        },\n                    };\n                }\n                else\n                {\n                    exportArgTypes[key] = {\n                        control: {\n                            type: 'range',\n                            min,\n                            max: 10,\n                            step: 1,\n                        },\n                    };\n                }\n            }\n            else if (number <= -100)\n            {\n                exportArgTypes[key] = {\n                    control: {\n                        type: 'range',\n                        min: -1000,\n                        max: 1000,\n                        step: 10,\n                    },\n                };\n            }\n            else if (number < -10)\n            {\n                exportArgTypes[key] = {\n                    control: {\n                        type: 'range',\n                        min: -100,\n                        max: 100,\n                        step: 10,\n                    },\n                };\n            }\n            else if (number >= -1)\n            {\n                exportArgTypes[key] = {\n                    control: {\n                        type: 'range',\n                        min: -1,\n                        max: 0,\n                        step: 0.1,\n                    },\n                };\n            }\n            else\n            {\n                exportArgTypes[key] = {\n                    control: {\n                        type: 'range',\n                        min: -10,\n                        max: 10,\n                        step: 1,\n                    },\n                };\n            }\n        }\n        else\n        {\n            if (getArgType(key))\n            {\n                exportArgTypes[key] = getArgType(key);\n            }\n\n            switch (typeof args[key])\n            {\n                case 'object':\n                    exportArgTypes[key] = {};\n\n                    exportArgTypes[key] = { ...controls.select };\n\n                    if (Array.isArray(args[key]))\n                    {\n                        exportArgTypes[key].options = args[key];\n                    }\n                    else\n                    {\n                        exportArgTypes[key].options = Object.keys(args).map(\n                            (key) => args[key],\n                        );\n                    }\n                    break;\n                case 'boolean':\n                    exportArgTypes[key] = controls.switch;\n                    break;\n            }\n        }\n    }\n\n    return exportArgTypes;\n};\n\nfunction getArgType(type: string)\n{\n    for (const control in controls)\n    {\n        if (type.toLowerCase().indexOf(control) > -1)\n        {\n            // const keys = type.split(control);\n\n            // if (options[keys[0]]) {\n            //     argTypes[key].options = options[keys[0]];\n            // }\n\n            return (controls as any)[control];\n        }\n    }\n\n    return undefined;\n}\n\nexport const getDefaultArgs = (args: Types) =>\n{\n    const exportArgs: any = {};\n\n    for (const key in args)\n    {\n        switch (typeof args[key])\n        {\n            case 'object':\n                if (Array.isArray(args[key]))\n                {\n                    exportArgs[key] = (args as any)[key][0] as any;\n                }\n                break;\n            default:\n                exportArgs[key] = args[key];\n        }\n    }\n\n    return exportArgs;\n};\n\n'layout/src/stories/styles/ConditionalStylesPortraitLandscape.stories.ts'\n:import { Container } from 'pixi.js';\nimport { Layout } from '../../Layout';\nimport { toolTip } from '../components/ToolTip';\nimport { argTypes, getDefaultArgs } from '../utils/argTypes';\n\nconst args = {\n    portraitColor: 'white',\n    landscapeColor: 'blue',\n};\n\nclass LayoutStory\n{\n    private layout: Layout;\n    private toolTip: Layout;\n    view = new Container();\n    w: number;\n    h: number;\n\n    constructor({ portraitColor, landscapeColor }: any)\n    {\n        this.addTooltip(\n            `Resize view area from portrait to landscape and back to see the styles change`\n        );\n\n        this.layout = new Layout({\n            content: {\n                portrait: {\n                    content: 'Portrait',\n                    styles: {\n                        fontSize: 40,\n                        position: 'center',\n                        color: landscapeColor,\n                        landscape: {\n                            visible: false,\n                        },\n                        portrait: {\n                            visible: true,\n                        },\n                    },\n                },\n                landscape: {\n                    content: 'Landscape',\n                    styles: {\n                        fontSize: 40,\n                        position: 'center',\n                        color: portraitColor,\n                        portrait: {\n                            visible: false,\n                        },\n                        landscape: {\n                            visible: true,\n                        },\n                    },\n                },\n            },\n            styles: {\n                width: `60%`,\n                height: `60%`,\n                position: 'center',\n                overflow: 'hidden',\n                borderRadius: 20,\n                portrait: {\n                    background: portraitColor,\n                },\n                landscape: {\n                    background: landscapeColor,\n                },\n            },\n        });\n\n        this.view.addChild(this.layout);\n    }\n\n    async addTooltip(text: string)\n    {\n        this.toolTip = await toolTip(text);\n        this.view.addChild(this.toolTip);\n        this.toolTip.resize(this.w, this.h);\n    }\n\n    resize(w: number, h: number)\n    {\n        this.w = w;\n        this.h = h;\n\n        this.layout?.resize(w, h);\n        this.toolTip?.resize(w, h);\n    }\n}\n\nexport const PortraitLandscape = (params: any) => new LayoutStory(params);\n\nexport default {\n    title: 'Styles',\n    argTypes: argTypes(args),\n    args: getDefaultArgs(args),\n};\n\n",
        "called_code_segment": "class LayoutStory {\n    private layout: Layout;\n    private toolTip: Layout;\n    view = new Container();\n    w: number;\n    h: number;\n\n    constructor({ portraitColor, landscapeColor }: any) {\n        this.addTooltip(\n            `Resize view area from portrait to landscape and back to see the styles change`\n        );\n\n        this.layout = new Layout({\n            content: {\n                portrait: {\n                    content: 'Portrait',\n                    styles: {\n                        fontSize: 40,\n                        position: 'center',\n                        color: landscapeColor,\n                        landscape: {\n                            visible: false,\n                        },\n                        portrait: {\n                            visible: true,\n                        },\n                    },\n                },\n                landscape: {\n                    content: 'Landscape',\n                    styles: {\n                        fontSize: 40,\n                        position: 'center',\n                        color: portraitColor,\n                        portrait: {\n                            visible: false,\n                        },\n                        landscape: {\n                            visible: true,\n                        },\n                    },\n                },\n            },\n            styles: {\n                width: `60%`,\n                height: `60%`,\n                position: 'center',\n                overflow: 'hidden',\n                borderRadius: 20,\n                portrait: {\n                    background: portraitColor,\n                },\n                landscape: {\n                    background: landscapeColor,\n                },\n            },\n        });\n\n        this.view.addChild(this.layout);\n    }\n\n    async addTooltip(text: string) {\n        this.toolTip = await toolTip(text);\n        this.view.addChild(this.toolTip);\n        this.toolTip.resize(this.w, this.h);\n    }\n\n    resize(w: number, h: number) {\n        this.w = w;\n        this.h = h;\n\n        this.layout?.resize(w, h);\n        this.toolTip?.resize(w, h);\n    }\n}",
        "invoking_code_segment": "export const PortraitLandscape = (params: any) => new LayoutStory(params);\n\nexport default {\n    title: 'Styles',\n    argTypes: argTypes(args),\n    args: getDefaultArgs(args),\n};",
        "new_file_code_segment": "export const toggleOrientation = (layout: Layout, portraitColor: string, landscapeColor: string) => {\n    layout.content.portrait.styles.color = landscapeColor;\n    layout.content.landscape.styles.color = portraitColor;\n    layout.styles.portrait.background = portraitColor;\n    layout.styles.landscape.background = landscapeColor;\n    layout.resize(layout.width, layout.height);\n};\n",
        "feature_description": "Add a feature to toggle the orientation colors dynamically.",
        "detailed_feature_description": "The new feature allows the user to toggle the colors of the portrait and landscape modes dynamically. This is achieved by creating a new function `toggleOrientation` in #file 3 that swaps the colors and resizes the layout. The `LayoutStory` class in #file 1 is updated to include a method `toggleColors` that uses the `toggleOrientation` function. The `PortraitLandscape` function in #file 2 is updated to call this new method when the user interacts with the UI.",
        "modified_complete_code": {
            "#file 1": "class LayoutStory {\n    private layout: Layout;\n    private toolTip: Layout;\n    view = new Container();\n    w: number;\n    h: number;\n\n    constructor({ portraitColor, landscapeColor }: any) {\n        this.addTooltip(\n            `Resize view area from portrait to landscape and back to see the styles change`\n        );\n\n        this.layout = new Layout({\n            content: {\n                portrait: {\n                    content: 'Portrait',\n                    styles: {\n                        fontSize: 40,\n                        position: 'center',\n                        color: landscapeColor,\n                        landscape: {\n                            visible: false,\n                        },\n                        portrait: {\n                            visible: true,\n                        },\n                    },\n                },\n                landscape: {\n                    content: 'Landscape',\n                    styles: {\n                        fontSize: 40,\n                        position: 'center',\n                        color: portraitColor,\n                        portrait: {\n                            visible: false,\n                        },\n                        landscape: {\n                            visible: true,\n                        },\n                    },\n                },\n            },\n            styles: {\n                width: `60%`,\n                height: `60%`,\n                position: 'center',\n                overflow: 'hidden',\n                borderRadius: 20,\n                portrait: {\n                    background: portraitColor,\n                },\n                landscape: {\n                    background: landscapeColor,\n                },\n            },\n        });\n\n        this.view.addChild(this.layout);\n    }\n\n    async addTooltip(text: string) {\n        this.toolTip = await toolTip(text);\n        this.view.addChild(this.toolTip);\n        this.toolTip.resize(this.w, this.h);\n    }\n\n    resize(w: number, h: number) {\n        this.w = w;\n        this.h = h;\n\n        this.layout?.resize(w, h);\n        this.toolTip?.resize(w, h);\n    }\n\n    #Modify toggleColors(portraitColor: string, landscapeColor: string) {\n        toggleOrientation(this.layout, portraitColor, landscapeColor);\n    }\n}",
            "#file 2": "import { toggleOrientation } from './toggleOrientation';\n\nexport const PortraitLandscape = (params: any) => {\n    const layoutStory = new LayoutStory(params);\n    #Modify layoutStory.toggleColors(params.portraitColor, params.landscapeColor);\n    return layoutStory;\n};\n\nexport default {\n    title: 'Styles',\n    argTypes: argTypes(args),\n    args: getDefaultArgs(args),\n};",
            "#file 3": "export const toggleOrientation = (layout: Layout, portraitColor: string, landscapeColor: string) => {\n    layout.content.portrait.styles.color = landscapeColor;\n    layout.content.landscape.styles.color = portraitColor;\n    layout.styles.portrait.background = portraitColor;\n    layout.styles.landscape.background = landscapeColor;\n    layout.resize(layout.width, layout.height);\n};\n"
        }
    },
    {
        "repo": "minhas-financas-ng",
        "content": "'minhas-financas-ng/src/environments/environment.ts'\n:// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false,\n  apiBaseUrl: \"https://minhasfinancas-api.herokuapp.com\"\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\n// import 'zone.js/dist/zone-error';  // Included with Angular CLI.\n\n'minhas-financas-ng/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment": "platformBrowserDynamic().bootstrapModule(AppModule).catch(err => console.error(err));",
        "invoking_code_segment": "if (environment.production) { enableProdMode(); }",
        "new_file_code_segment": "export function initializeApp(appModule: AppModule) { console.log('App initialized'); return appModule; }",
        "feature_description": "Add an initialization log message when the app starts.",
        "detailed_feature_description": "The new feature involves adding a log message to indicate that the application has been initialized. This is achieved by creating a new function `initializeApp` in a new file (#file 3) that logs a message and returns the `AppModule`. The `platformBrowserDynamic().bootstrapModule(AppModule)` call in #file 1 is modified to use this new function. The `enableProdMode` call in #file 2 remains unchanged as it is not directly related to the new feature.",
        "modified_complete_code": {
            "#file 1": "//Modify platformBrowserDynamic().bootstrapModule(AppModule).catch(err => console.error(err));\n//New import { initializeApp } from './app/initializeApp';\nplatformBrowserDynamic().bootstrapModule(initializeApp(AppModule)).catch(err => console.error(err));",
            "#file 2": "if (environment.production) { enableProdMode(); }",
            "#file 3": "//New export function initializeApp(appModule: AppModule) { console.log('App initialized'); return appModule; }"
        }
    },
    {
        "repo": "WebView2Example",
        "content": "'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/react-grid-layout.utils.ts'\n:\n/**\n * IMPORTANT:\n * This utils are taken from the project: https://github.com/STRML/react-grid-layout.\n * The code should be as less modified as possible for easy maintenance.\n */\n\n// Disable lint since we don't want to modify this code\n/* eslint-disable */\nexport type LayoutItem = {\n    w: number;\n    h: number;\n    x: number;\n    y: number;\n    id: string;\n    minW?: number;\n    minH?: number;\n    maxW?: number;\n    maxH?: number;\n    moved?: boolean;\n    static?: boolean;\n    isDraggable?: boolean | null | undefined;\n    isResizable?: boolean | null | undefined;\n};\nexport type Layout = Array<LayoutItem>;\nexport type Position = {\n    left: number;\n    top: number;\n    width: number;\n    height: number;\n};\nexport type ReactDraggableCallbackData = {\n    node: HTMLElement;\n    x?: number;\n    y?: number;\n    deltaX: number;\n    deltaY: number;\n    lastX?: number;\n    lastY?: number;\n};\n\nexport type PartialPosition = { left: number; top: number };\nexport type DroppingPosition = { x: number; y: number; e: Event };\nexport type Size = { width: number; height: number };\nexport type GridDragEvent = {\n    e: Event;\n    node: HTMLElement;\n    newPosition: PartialPosition;\n};\nexport type GridResizeEvent = { e: Event; node: HTMLElement; size: Size };\nexport type DragOverEvent = MouseEvent & {\n    nativeEvent: {\n        layerX: number;\n        layerY: number;\n        target: {\n            className: String;\n        };\n    };\n};\n\n//type REl = ReactElement<any>;\n//export type ReactChildren = ReactChildrenArray<REl>;\n\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\nexport type EventCallback = (\n    arg0: Layout,\n    oldItem: LayoutItem | null | undefined,\n    newItem: LayoutItem | null | undefined,\n    placeholder: LayoutItem | null | undefined,\n    arg4: Event,\n    arg5: HTMLElement | null | undefined,\n) => void;\nexport type CompactType = ('horizontal' | 'vertical') | null | undefined;\n\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout: Layout): number {\n    let max = 0,\n        bottomY;\n    for (let i = 0, len = layout.length; i < len; i++) {\n        bottomY = layout[i].y + layout[i].h;\n        if (bottomY > max) {\n            max = bottomY;\n        }\n    }\n    return max;\n}\n\nexport function cloneLayout(layout: Layout): Layout {\n    const newLayout = Array(layout.length);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        newLayout[i] = cloneLayoutItem(layout[i]);\n    }\n    return newLayout;\n}\n\n// Fast path to cloning, since this is monomorphic\n/** NOTE: This code has been modified from the original source */\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\n    const clonedLayoutItem: LayoutItem = {\n        w: layoutItem.w,\n        h: layoutItem.h,\n        x: layoutItem.x,\n        y: layoutItem.y,\n        id: layoutItem.id,\n        moved: !!layoutItem.moved,\n        static: !!layoutItem.static,\n    };\n\n    if (layoutItem.minW !== undefined) { clonedLayoutItem.minW = layoutItem.minW;}\n    if (layoutItem.maxW !== undefined) { clonedLayoutItem.maxW = layoutItem.maxW;}\n    if (layoutItem.minH !== undefined) { clonedLayoutItem.minH = layoutItem.minH;}\n    if (layoutItem.maxH !== undefined) { clonedLayoutItem.maxH = layoutItem.maxH;}\n    // These can be null\n    if (layoutItem.isDraggable !== undefined) { clonedLayoutItem.isDraggable = layoutItem.isDraggable;}\n    if (layoutItem.isResizable !== undefined) { clonedLayoutItem.isResizable = layoutItem.isResizable;}\n\n    return clonedLayoutItem;\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\n    if (l1.id === l2.id) {\n        return false;\n    } // same element\n    if (l1.x + l1.w <= l2.x) {\n        return false;\n    } // l1 is left of l2\n    if (l1.x >= l2.x + l2.w) {\n        return false;\n    } // l1 is right of l2\n    if (l1.y + l1.h <= l2.y) {\n        return false;\n    } // l1 is above l2\n    if (l1.y >= l2.y + l2.h) {\n        return false;\n    } // l1 is below l2\n    return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\nexport function compact(\n    layout: Layout,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // Statics go in the compareWith array right away so items flow around them.\n    const compareWith = getStatics(layout);\n    // We go through the items by row and column.\n    const sorted = sortLayoutItems(layout, compactType);\n    // Holding for new items.\n    const out = Array(layout.length);\n\n    for (let i = 0, len = sorted.length; i < len; i++) {\n        let l = cloneLayoutItem(sorted[i]);\n\n        // Don't move static elements\n        if (!l.static) {\n            l = compactItem(compareWith, l, compactType, cols, sorted);\n\n            // Add to comparison array. We only collide with items before this one.\n            // Statics are already in this array.\n            compareWith.push(l);\n        }\n\n        // Add to output array to make sure they still come out in the right order.\n        out[layout.indexOf(sorted[i])] = l;\n\n        // Clear moved flag, if it exists.\n        l.moved = false;\n    }\n\n    return out;\n}\n\nconst heightWidth = {x: 'w', y: 'h'};\n\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(\n    layout: Layout,\n    item: LayoutItem,\n    moveToCoord: number,\n    axis: 'x' | 'y',\n) {\n    const sizeProp = heightWidth[axis];\n    item[axis] += 1;\n    const itemIndex = layout\n        .map(layoutItem => {\n            return layoutItem.id;\n        })\n        .indexOf(item.id);\n\n    // Go through each item we collide with.\n    for (let i = itemIndex + 1; i < layout.length; i++) {\n        const otherItem = layout[i];\n        // Ignore static items\n        if (otherItem.static) {\n            continue;\n        }\n\n        // Optimization: we can break early if we know we're past this el\n        // We can do this b/c it's a sorted layout\n        if (otherItem.y > item.y + item.h) {\n            break;\n        }\n\n        if (collides(item, otherItem)) {\n            resolveCompactionCollision(\n                layout,\n                otherItem,\n                moveToCoord + item[sizeProp],\n                axis,\n            );\n        }\n    }\n\n    item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n */\nexport function compactItem(\n    compareWith: Layout,\n    l: LayoutItem,\n    compactType: CompactType,\n    cols: number,\n    fullLayout: Layout,\n): LayoutItem {\n    const compactV = compactType === 'vertical';\n    const compactH = compactType === 'horizontal';\n    if (compactV) {\n        // Bottom 'y' possible is the bottom of the layout.\n        // This allows you to do nice stuff like specify {y: Infinity}\n        // This is here because the layout must be sorted in order to get the correct bottom `y`.\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element up as far as it can go without colliding.\n        while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n            l.y--;\n        }\n    } else if (compactH) {\n        l.y = Math.min(bottom(compareWith), l.y);\n        // Move the element left as far as it can go without colliding.\n        while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n            l.x--;\n        }\n    }\n\n    // Move it down, and keep moving it down if it's colliding.\n    let collides;\n    while ((collides = getFirstCollision(compareWith, l))) {\n        if (compactH) {\n            resolveCompactionCollision(\n                fullLayout,\n                l,\n                collides.x + collides.w,\n                'x',\n            );\n        } else {\n            resolveCompactionCollision(\n                fullLayout,\n                l,\n                collides.y + collides.h,\n                'y',\n            );\n        }\n        // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n        if (compactH && l.x + l.w > cols) {\n            l.x = cols - l.w;\n            l.y++;\n        }\n    }\n    return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nexport function correctBounds(layout: Layout, bounds: { cols: number }): Layout {\n    const collidesWith = getStatics(layout);\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const l = layout[i];\n        // Overflows right\n        if (l.x + l.w > bounds.cols) {\n            l.x = bounds.cols - l.w;\n        }\n        // Overflows left\n        if (l.x < 0) {\n            l.x = 0;\n            l.w = bounds.cols;\n        }\n        if (!l.static) {\n            collidesWith.push(l);\n        } else {\n            // If this is static and collides with other statics, we must move it down.\n            // We have to do something nicer than just letting them overlap.\n            while (getFirstCollision(collidesWith, l)) {\n                l.y++;\n            }\n        }\n    }\n    return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nexport function getLayoutItem(\n    layout: Layout,\n    id: string,\n): LayoutItem | null | undefined {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (layout[i].id === id) {\n            return layout[i];\n        }\n    }\n    return null;\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nexport function getFirstCollision(\n    layout: Layout,\n    layoutItem: LayoutItem,\n): LayoutItem | null | undefined {\n    for (let i = 0, len = layout.length; i < len; i++) {\n        if (collides(layout[i], layoutItem)) {\n            return layout[i];\n        }\n    }\n    return null;\n}\n\nexport function getAllCollisions(\n    layout: Layout,\n    layoutItem: LayoutItem,\n): Array<LayoutItem> {\n    return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nexport function getStatics(layout: Layout): Array<LayoutItem> {\n    return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nexport function moveElement(\n    layout: Layout,\n    l: LayoutItem,\n    x: number | null | undefined,\n    y: number | null | undefined,\n    isUserAction: boolean | null | undefined,\n    preventCollision: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // If this is static and not explicitly enabled as draggable,\n    // no move is possible, so we can short-circuit this immediately.\n    if (l.static && l.isDraggable !== true) {\n        return layout;\n    }\n\n    // Short-circuit if nothing to do.\n    if (l.y === y && l.x === x) {\n        return layout;\n    }\n\n    log(\n        `Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${\n            l.y\n        }]`,\n    );\n    const oldX = l.x;\n    const oldY = l.y;\n\n    // This is quite a bit faster than extending the object\n    if (typeof x === 'number') {\n        l.x = x;\n    }\n    if (typeof y === 'number') {\n        l.y = y;\n    }\n    l.moved = true;\n\n    // If this collides with anything, move it.\n    // When doing this comparison, we have to sort the items we compare with\n    // to ensure, in the case of multiple collisions, that we're getting the\n    // nearest collision.\n    let sorted = sortLayoutItems(layout, compactType);\n    const movingUp =\n        compactType === 'vertical' && typeof y === 'number'\n            ? oldY >= y\n            : compactType === 'horizontal' && typeof x === 'number'\n            ? oldX >= x\n            : false;\n    if (movingUp) {\n        sorted = sorted.reverse();\n    }\n    const collisions = getAllCollisions(sorted, l);\n\n    // There was a collision; abort\n    if (preventCollision && collisions.length) {\n        log(`Collision prevented on ${l.id}, reverting.`);\n        l.x = oldX;\n        l.y = oldY;\n        l.moved = false;\n        return layout;\n    }\n\n    // Move each item that collides away from this element.\n    for (let i = 0, len = collisions.length; i < len; i++) {\n        const collision = collisions[i];\n        log(\n            `Resolving collision between ${l.id} at [${l.x},${l.y}] and ${\n                collision.id\n            } at [${collision.x},${collision.y}]`,\n        );\n\n        // Short circuit so we can't infinite loop\n        if (collision.moved) {\n            continue;\n        }\n\n        // Don't move static items - we have to move *this* element away\n        if (collision.static) {\n            layout = moveElementAwayFromCollision(\n                layout,\n                collision,\n                l,\n                isUserAction,\n                compactType,\n                cols,\n            );\n        } else {\n            layout = moveElementAwayFromCollision(\n                layout,\n                l,\n                collision,\n                isUserAction,\n                compactType,\n                cols,\n            );\n        }\n    }\n\n    return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nexport function moveElementAwayFromCollision(\n    layout: Layout,\n    collidesWith: LayoutItem,\n    itemToMove: LayoutItem,\n    isUserAction: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    const compactH = compactType === 'horizontal';\n    // Compact vertically if not set to horizontal\n    const compactV = compactType !== 'horizontal';\n    const preventCollision = collidesWith.static; // we're already colliding (not for static items)\n\n    // If there is enough space above the collision to put this element, move it there.\n    // We only do this on the main collision as this can get funky in cascades and cause\n    // unwanted swapping behavior.\n    if (isUserAction) {\n        // Reset isUserAction flag because we're not in the main collision anymore.\n        isUserAction = false;\n\n        // Make a mock item so we don't modify the item here, only modify in moveElement.\n        const fakeItem: LayoutItem = {\n            x: compactH\n                ? Math.max(collidesWith.x - itemToMove.w, 0)\n                : itemToMove.x,\n            y: compactV\n                ? Math.max(collidesWith.y - itemToMove.h, 0)\n                : itemToMove.y,\n            w: itemToMove.w,\n            h: itemToMove.h,\n            id: '-1',\n        };\n\n        // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n        if (!getFirstCollision(layout, fakeItem)) {\n            log(\n                `Doing reverse collision on ${itemToMove.id} up to [${\n                    fakeItem.x\n                },${fakeItem.y}].`,\n            );\n            return moveElement(\n                layout,\n                itemToMove,\n                compactH ? fakeItem.x : undefined,\n                compactV ? fakeItem.y : undefined,\n                isUserAction,\n                preventCollision,\n                compactType,\n                cols,\n            );\n        }\n    }\n\n    return moveElement(\n        layout,\n        itemToMove,\n        compactH ? itemToMove.x + 1 : undefined,\n        compactV ? itemToMove.y + 1 : undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols,\n    );\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nexport function perc(num: number): string {\n    return num * 100 + '%';\n}\n\nexport function setTransform({top, left, width, height}: Position): Object {\n    // Replace unitless items with px\n    const translate = `translate(${left}px,${top}px)`;\n    return {\n        transform: translate,\n        WebkitTransform: translate,\n        MozTransform: translate,\n        msTransform: translate,\n        OTransform: translate,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute',\n    };\n}\n\nexport function setTopLeft({top, left, width, height}: Position): Object {\n    return {\n        top: `${top}px`,\n        left: `${left}px`,\n        width: `${width}px`,\n        height: `${height}px`,\n        position: 'absolute',\n    };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nexport function sortLayoutItems(\n    layout: Layout,\n    compactType: CompactType,\n): Layout {\n    if (compactType === 'horizontal') {\n        return sortLayoutItemsByColRow(layout);\n    } else {\n        return sortLayoutItemsByRowCol(layout);\n    }\n}\n\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\n    return ([] as any[]).concat(layout).sort(function (a, b) {\n        if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\n            return 1;\n        } else if (a.y === b.y && a.x === b.x) {\n            // Without this, we can get different sort results in IE vs. Chrome/FF\n            return 0;\n        }\n        return -1;\n    });\n}\n\nexport function sortLayoutItemsByColRow(layout: Layout): Layout {\n    return ([] as any[]).concat(layout).sort(function (a, b) {\n        if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\n            return 1;\n        }\n        return -1;\n    });\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nexport function validateLayout(\n    layout: Layout,\n    contextName: string = 'Layout',\n): void {\n    const subProps = ['x', 'y', 'w', 'h'];\n    if (!Array.isArray(layout)) {\n        throw new Error(contextName + ' must be an array!');\n    }\n    for (let i = 0, len = layout.length; i < len; i++) {\n        const item = layout[i];\n        for (let j = 0; j < subProps.length; j++) {\n            if (typeof item[subProps[j]] !== 'number') {\n                throw new Error(\n                    'ReactGridLayout: ' +\n                    contextName +\n                    '[' +\n                    i +\n                    '].' +\n                    subProps[j] +\n                    ' must be a number!',\n                );\n            }\n        }\n        if (item.id && typeof item.id !== 'string') {\n            throw new Error(\n                'ReactGridLayout: ' +\n                contextName +\n                '[' +\n                i +\n                '].i must be a string!',\n            );\n        }\n        if (item.static !== undefined && typeof item.static !== 'boolean') {\n            throw new Error(\n                'ReactGridLayout: ' +\n                contextName +\n                '[' +\n                i +\n                '].static must be a boolean!',\n            );\n        }\n    }\n}\n\n// Flow can't really figure this out, so we just use Object\nexport function autoBindHandlers(el: Object, fns: Array<string>): void {\n    fns.forEach(key => (el[key] = el[key].bind(el)));\n}\n\nfunction log(...args) {\n    if (!DEBUG) {\n        return;\n    }\n    // eslint-disable-next-line no-console\n    console.log(...args);\n}\n\nexport const noop = () => {};\n\n'WebView2Example/WebView2Example-Front/projects/angular-grid-layout/src/lib/utils/tests/react-grid-layout-utils.spec.ts'\n:import { bottom, collides, compact, moveElement, sortLayoutItemsByRowCol, validateLayout } from '../react-grid-layout.utils';\nimport objectContaining = jasmine.objectContaining;\n\n/**\n * IMPORTANT:\n * This tests are taken from the project: https://github.com/STRML/react-grid-layout.\n * The code should be as less modified as possible for easy maintenance.\n */\n\ndescribe('bottom', () => {\n    it('Handles an empty layout as input', () => {\n        expect(bottom([])).toEqual(0);\n    });\n\n    it('Returns the bottom coordinate of the layout', () => {\n        expect(\n            bottom([\n                {id: '1', x: 0, y: 1, w: 1, h: 1},\n                {id: '2', x: 1, y: 2, w: 1, h: 1}\n            ])\n        ).toEqual(3);\n    });\n});\n\ndescribe('sortLayoutItemsByRowCol', () => {\n    it('should sort by top to bottom right', () => {\n        const layout = [\n            {x: 1, y: 1, w: 1, h: 1, id: '2'},\n            {x: 1, y: 0, w: 1, h: 1, id: '1'},\n            {x: 0, y: 1, w: 2, h: 2, id: '3'}\n        ];\n        expect(sortLayoutItemsByRowCol(layout)).toEqual([\n            {x: 1, y: 0, w: 1, h: 1, id: '1'},\n            {x: 0, y: 1, w: 2, h: 2, id: '3'},\n            {x: 1, y: 1, w: 1, h: 1, id: '2'}\n        ]);\n    });\n});\n\ndescribe('collides', () => {\n    it('Returns whether the layout items collide', () => {\n        expect(\n            collides(\n                {id: '1', x: 0, y: 1, w: 1, h: 1},\n                {id: '2', x: 1, y: 2, w: 1, h: 1}\n            )\n        ).toEqual(false);\n        expect(\n            collides(\n                {id: '1', x: 0, y: 1, w: 1, h: 1},\n                {id: '2', x: 0, y: 1, w: 1, h: 1}\n            )\n        ).toEqual(true);\n    });\n});\n\ndescribe('validateLayout', () => {\n    it('Validates an empty layout', () => {\n        validateLayout([]);\n    });\n    it('Validates a populated layout', () => {\n        validateLayout([\n            {id: '1', x: 0, y: 1, w: 1, h: 1},\n            {id: '2', x: 1, y: 2, w: 1, h: 1}\n        ]);\n    });\n    it('Throws errors on invalid input', () => {\n        expect(() => {\n\n            validateLayout([\n                {id: '1', x: 0, y: 1, w: 1, h: 1},\n                {id: '2', x: 1, y: 2, w: 1} as any\n            ]);\n        }).toThrowError(/layout\\[1\\]\\.h must be a number!/i);\n    });\n});\n\ndescribe('moveElement', () => {\n    function compactAndMove(\n        layout,\n        layoutItem,\n        x,\n        y,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n    ) {\n        return compact(\n            moveElement(\n                layout,\n                layoutItem,\n                x,\n                y,\n                isUserAction,\n                preventCollision,\n                compactType,\n                cols\n            ),\n            compactType,\n            cols\n        );\n    }\n\n    it('Does not change layout when colliding on no rearrangement mode', () => {\n        const layout = [\n            {id: '1', x: 0, y: 1, w: 1, h: 1, moved: false},\n            {id: '2', x: 1, y: 2, w: 1, h: 1, moved: false}\n        ];\n        const layoutItem = layout[0];\n        expect(\n            moveElement(\n                layout,\n                layoutItem,\n                1,\n                2, // x, y\n                true,\n                true, // isUserAction, preventCollision\n                null,\n                2 // compactType, cols\n            )\n        ).toEqual([\n            {id: '1', x: 0, y: 1, w: 1, h: 1, moved: false},\n            {id: '2', x: 1, y: 2, w: 1, h: 1, moved: false}\n        ]);\n    });\n\n    it('Does change layout when colliding in rearrangement mode', () => {\n        const layout = [\n            {id: '1', x: 0, y: 0, w: 1, h: 1, moved: false},\n            {id: '2', x: 1, y: 0, w: 1, h: 1, moved: false}\n        ];\n        const layoutItem = layout[0];\n        expect(\n            moveElement(\n                layout,\n                layoutItem,\n                1,\n                0, // x, y\n                true,\n                false, // isUserAction, preventCollision\n                'vertical',\n                2 // compactType, cols\n            )\n        ).toEqual([\n            {id: '1', x: 1, y: 0, w: 1, h: 1, moved: true},\n            {id: '2', x: 1, y: 1, w: 1, h: 1, moved: true}\n        ]);\n    });\n\n    it('Moves elements out of the way without causing panel jumps when compaction is vertical', () => {\n        const layout = [\n            {x: 0, y: 0, w: 1, h: 10, id: 'A'},\n            {x: 0, y: 10, w: 1, h: 1, id: 'B'},\n            {x: 0, y: 11, w: 1, h: 1, id: 'C'}\n        ];\n        // move A down slightly so it collides with C; can cause C to jump above B.\n        // We instead want B to jump above A (it has the room)\n        const itemA = layout[0];\n        expect(\n            compactAndMove(\n                layout,\n                itemA,\n                0,\n                1, // x, y\n                true,\n                false, // isUserAction, preventCollision\n                'vertical',\n                10 // compactType, cols\n            )\n        ).toEqual([\n            objectContaining({x: 0, y: 1, w: 1, h: 10, id: 'A'}),\n            objectContaining({x: 0, y: 0, w: 1, h: 1, id: 'B'}),\n            objectContaining({x: 0, y: 11, w: 1, h: 1, id: 'C'})\n        ]);\n    });\n\n    it('Calculates the correct collision when moving large object far', () => {\n        const layout = [\n            {x: 0, y: 0, w: 1, h: 10, id: 'A'},\n            {x: 0, y: 10, w: 1, h: 1, id: 'B'},\n            {x: 0, y: 11, w: 1, h: 1, id: 'C'}\n        ];\n        // Move A down by 2. This should move B above, but since we don't compact in between,\n        // C should move below.\n        const itemA = layout[0];\n        expect(\n            moveElement(\n                layout,\n                itemA,\n                0,\n                2, // x, y\n                true,\n                false, // isUserAction, preventCollision\n                'vertical',\n                10 // compactType, cols\n            )\n        ).toEqual([\n            objectContaining({x: 0, y: 2, w: 1, h: 10, id: 'A'}),\n            objectContaining({x: 0, y: 1, w: 1, h: 1, id: 'B'}),\n            objectContaining({x: 0, y: 12, w: 1, h: 1, id: 'C'})\n        ]);\n    });\n\n    it('Moves elements out of the way without causing panel jumps when compaction is vertical (example case 13)', () => {\n        const layout = [\n            {x: 0, y: 0, w: 1, h: 1, id: 'A'},\n            {x: 1, y: 0, w: 1, h: 1, id: 'B'},\n            {x: 0, y: 1, w: 2, h: 2, id: 'C'}\n        ];\n        // move A over slightly so it collides with B; can cause C to jump above B\n        // this test will check that that does not happen\n        const itemA = layout[0];\n        expect(\n            moveElement(\n                layout,\n                itemA,\n                1,\n                0, // x, y\n                true,\n                false, // isUserAction, preventCollision\n                'vertical',\n                2 // compactType, cols\n            )\n        ).toEqual([\n            {x: 1, y: 0, w: 1, h: 1, id: 'A', moved: true},\n            {x: 1, y: 1, w: 1, h: 1, id: 'B', moved: true},\n            {x: 0, y: 2, w: 2, h: 2, id: 'C', moved: true}\n        ]);\n    });\n\n    it('Moves elements out of the way without causing panel jumps when compaction is horizontal', () => {\n        const layout = [\n            {y: 0, x: 0, h: 1, w: 10, id: 'A'},\n            {y: 0, x: 11, h: 1, w: 1, id: 'B'},\n            {y: 0, x: 12, h: 1, w: 1, id: 'C'}\n        ];\n        // move A over slightly so it collides with C; can cause C to jump left of B\n        // this test will check that that does not happen\n        const itemA = layout[0];\n        expect(\n            moveElement(\n                layout,\n                itemA,\n                2,\n                0, // x, y\n                true,\n                false, // isUserAction, preventCollision\n                'horizontal',\n                10 // compactType, cols\n            )\n        ).toEqual([\n            {y: 0, x: 2, h: 1, w: 10, moved: true, id: 'A'},\n            {y: 0, x: 1, h: 1, w: 1, moved: true, id: 'B'},\n            {y: 0, x: 12, h: 1, w: 1, id: 'C'}\n        ]);\n    });\n\n    it('Moves one element to another should cause moving down panels, vert compact, example 1', () => {\n        // | A | B |\n        // |C|  D  |\n        const layout = [\n            {x: 0, y: 0, w: 2, h: 1, id: 'A'},\n            {x: 2, y: 0, w: 2, h: 1, id: 'B'},\n            {x: 0, y: 1, w: 1, h: 1, id: 'C'},\n            {x: 1, y: 1, w: 3, h: 1, id: 'D'}\n        ];\n        // move B left slightly so it collides with A; can cause C to jump above A\n        // this test will check that that does not happen\n        const itemB = layout[1];\n        expect(\n            compactAndMove(\n                layout,\n                itemB,\n                1,\n                0, // x, y\n                true,\n                false, // isUserAction, preventCollision\n                'vertical',\n                4 // compactType, cols\n            )\n        ).toEqual([\n            objectContaining({x: 0, y: 1, w: 2, h: 1, id: 'A'}),\n            objectContaining({x: 1, y: 0, w: 2, h: 1, id: 'B'}),\n            objectContaining({x: 0, y: 2, w: 1, h: 1, id: 'C'}),\n            objectContaining({x: 1, y: 2, w: 3, h: 1, id: 'D'})\n        ]);\n    });\n\n    it('Moves one element to another should cause moving down panels, vert compact, example 2', () => {\n        // | A |\n        // |B|C|\n        //   | |\n        //\n        // Moving C above A should not move B above A\n        const layout = [\n            {x: 0, y: 0, w: 2, h: 1, id: 'A'},\n            {x: 0, y: 1, w: 1, h: 1, id: 'B'},\n            {x: 1, y: 1, w: 1, h: 2, id: 'C'}\n        ];\n        // Move C up.\n        const itemB = layout[2];\n        expect(\n            compactAndMove(\n                layout,\n                itemB,\n                1,\n                0, // x, y\n                true,\n                false, // isUserAction, preventCollision\n                'vertical',\n                4 // compactType, cols\n            )\n        ).toEqual([\n            objectContaining({x: 0, y: 2, w: 2, h: 1, id: 'A'}),\n            objectContaining({x: 0, y: 3, w: 1, h: 1, id: 'B'}),\n            objectContaining({x: 1, y: 0, w: 1, h: 2, id: 'C'})\n        ]);\n    });\n});\n\ndescribe('compact vertical', () => {\n    it('Removes empty vertical space above item', () => {\n        const layout = [{id: '1', x: 0, y: 1, w: 1, h: 1}];\n        expect(compact(layout, 'vertical', 10)).toEqual([\n            {id: '1', x: 0, y: 0, w: 1, h: 1, moved: false, static: false}\n        ]);\n    });\n\n    it('Resolve collision by moving item further down in array', () => {\n        const layout = [\n            {x: 0, y: 0, w: 1, h: 5, id: '1'},\n            {x: 0, y: 1, w: 1, h: 1, id: '2'}\n        ];\n        expect(compact(layout, 'vertical', 10)).toEqual([\n            {x: 0, y: 0, w: 1, h: 5, id: '1', moved: false, static: false},\n            {x: 0, y: 5, w: 1, h: 1, id: '2', moved: false, static: false}\n        ]);\n    });\n\n    it('Handles recursive collision by moving new collisions out of the way before moving item down', () => {\n        const layout = [\n            {x: 0, y: 0, w: 2, h: 5, id: '1'},\n            {x: 0, y: 0, w: 10, h: 1, id: '2'},\n            {x: 5, y: 1, w: 1, h: 1, id: '3'},\n            {x: 5, y: 2, w: 1, h: 1, id: '4'},\n            {x: 5, y: 3, w: 1, h: 1, id: '5', static: true}\n        ];\n\n        expect(compact(layout, 'vertical', 10)).toEqual([\n            {x: 0, y: 0, w: 2, h: 5, id: '1', moved: false, static: false},\n            {x: 0, y: 5, w: 10, h: 1, id: '2', moved: false, static: false},\n            {x: 5, y: 6, w: 1, h: 1, id: '3', moved: false, static: false},\n            {x: 5, y: 7, w: 1, h: 1, id: '4', moved: false, static: false},\n            {x: 5, y: 3, w: 1, h: 1, id: '5', moved: false, static: true}\n        ]);\n    });\n\n    it('Clones layout items (does not modify input)', () => {\n        const layout = [\n            {x: 0, y: 0, w: 2, h: 5, id: '1'},\n            {x: 0, y: 0, w: 10, h: 1, id: '2'}\n        ];\n        const out = compact(layout, 'vertical', 10);\n        layout.forEach(item => {\n            expect(out.includes(item)).toEqual(false);\n        });\n    });\n});\n\ndescribe('compact horizontal', () => {\n    it('compact horizontal should remove empty horizontal space to left of item', () => {\n        const layout = [{x: 5, y: 5, w: 1, h: 1, id: '1'}];\n        expect(compact(layout, 'horizontal', 10)).toEqual([\n            {x: 0, y: 0, w: 1, h: 1, id: '1', moved: false, static: false}\n        ]);\n    });\n\n    it('Resolve collision by moving item further to the right in array', () => {\n        const layout = [\n            {y: 0, x: 0, h: 1, w: 5, id: '1'},\n            {y: 0, x: 1, h: 1, w: 1, id: '2'}\n        ];\n        expect(compact(layout, 'horizontal', 10)).toEqual([\n            {y: 0, x: 0, h: 1, w: 5, id: '1', moved: false, static: false},\n            {y: 0, x: 5, h: 1, w: 1, id: '2', moved: false, static: false}\n        ]);\n    });\n\n    it('Handles recursive collision by moving new collisions out of the way before moving item to the right', () => {\n        const layout = [\n            {y: 0, x: 0, h: 2, w: 5, id: '1'},\n            {y: 1, x: 0, h: 10, w: 1, id: '2'},\n            {y: 5, x: 1, h: 1, w: 1, id: '3'},\n            {y: 5, x: 2, h: 1, w: 1, id: '4'},\n            {y: 5, x: 2, h: 1, w: 1, id: '5', static: true}\n        ];\n        expect(compact(layout, 'horizontal', 10)).toEqual([\n            {y: 0, x: 0, h: 2, w: 5, id: '1', moved: false, static: false},\n            {y: 1, x: 5, h: 10, w: 1, id: '2', moved: false, static: false},\n            {y: 5, x: 6, h: 1, w: 1, id: '3', moved: false, static: false},\n            {y: 5, x: 7, h: 1, w: 1, id: '4', moved: false, static: false},\n            {y: 5, x: 2, h: 1, w: 1, id: '5', moved: false, static: true}\n        ]);\n    });\n});\n\n",
        "called_code_segment": "export function moveElement(\n    layout: Layout,\n    l: LayoutItem,\n    x: number | null | undefined,\n    y: number | null | undefined,\n    isUserAction: boolean | null | undefined,\n    preventCollision: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // Implementation...\n}",
        "invoking_code_segment": "const layout = [\n    {id: '1', x: 0, y: 1, w: 1, h: 1, moved: false},\n    {id: '2', x: 1, y: 2, w: 1, h: 1, moved: false}\n];\nconst layoutItem = layout[0];\nexpect(\n    moveElement(\n        layout,\n        layoutItem,\n        1,\n        2, // x, y\n        true,\n        true, // isUserAction, preventCollision\n        null,\n        2 // compactType, cols\n    )\n).toEqual([\n    {id: '1', x: 0, y: 1, w: 1, h: 1, moved: false},\n    {id: '2', x: 1, y: 2, w: 1, h: 1, moved: false}\n]);",
        "new_file_code_segment": "export function logMoveElement(\n    layout: Layout,\n    l: LayoutItem,\n    x: number | null | undefined,\n    y: number | null | undefined,\n    isUserAction: boolean | null | undefined,\n    preventCollision: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    console.log(`Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n    return moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols);\n}",
        "feature_description": "Add logging for element movements during layout changes.",
        "detailed_feature_description": "The new feature introduces logging for each element movement during the layout change process. This is achieved by creating a new function `logMoveElement` in #file 3, which wraps the existing `moveElement` function from #file 1. The `logMoveElement` function logs the movement details before invoking the original `moveElement` function. This ensures that the logging functionality is seamlessly integrated without modifying the existing logic of `moveElement`. The test in #file 2 is updated to use `logMoveElement` instead of `moveElement` to incorporate the new logging feature.",
        "modified_complete_code": {
            "#file 1": "//Modify\nexport function moveElement(\n    layout: Layout,\n    l: LayoutItem,\n    x: number | null | undefined,\n    y: number | null | undefined,\n    isUserAction: boolean | null | undefined,\n    preventCollision: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    // Implementation...\n}",
            "#file 2": "//Modify\nconst layout = [\n    {id: '1', x: 0, y: 1, w: 1, h: 1, moved: false},\n    {id: '2', x: 1, y: 2, w: 1, h: 1, moved: false}\n];\nconst layoutItem = layout[0];\nexpect(\n    logMoveElement(\n        layout,\n        layoutItem,\n        1,\n        2, // x, y\n        true,\n        true, // isUserAction, preventCollision\n        null,\n        2 // compactType, cols\n    )\n).toEqual([\n    {id: '1', x: 0, y: 1, w: 1, h: 1, moved: false},\n    {id: '2', x: 1, y: 2, w: 1, h: 1, moved: false}\n]);",
            "#file 3": "//New\nexport function logMoveElement(\n    layout: Layout,\n    l: LayoutItem,\n    x: number | null | undefined,\n    y: number | null | undefined,\n    isUserAction: boolean | null | undefined,\n    preventCollision: boolean | null | undefined,\n    compactType: CompactType,\n    cols: number,\n): Layout {\n    console.log(`Moving element ${l.id} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n    return moveElement(layout, l, x, y, isUserAction, preventCollision, compactType, cols);\n}"
        }
    },
    {
        "repo": "moleculer-boilerplate-ts",
        "content": "'moleculer-boilerplate-ts/packages/backend/shared/core/base.svc.ts'\n:import { GenericObject, Service, ServiceSettingSchema } from 'moleculer'\n\nexport type MemoizeOptions = {\n  ttl?: number\n}\n\nexport class BaseService<S extends ServiceSettingSchema = ServiceSettingSchema> extends Service<S> {\n  public config: GenericObject = {}\n\n  // memoize (S)\n  protected async memoize<T, P = any>(\n    name: string,\n    params: P,\n    callback: () => Promise<T>,\n    options?: MemoizeOptions,\n  ): Promise<T> {\n    if (!this.broker.cacher) return callback()\n\n    const key = this.broker.cacher.defaultKeygen(`${name}:memoize-${name}`, params as any, {}, [])\n\n    let res = await this.broker.cacher.get(key)\n    if (res) return <T>res\n\n    res = await callback()\n    this.broker.cacher.set(key, res, options && options.ttl)\n\n    return <T>res\n  }\n  // memoize (E)\n}\n\n'moleculer-boilerplate-ts/packages/backend/shared/core/prisma.svc.ts'\n:/* eslint-disable @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any */\nimport { PrismaClient } from '@prisma/client'\nimport has from 'lodash/has'\nimport lowerFirst from 'lodash/lowerFirst'\nimport { Context, GenericObject, ServiceSettingSchema } from 'moleculer'\nimport { BaseService } from './base.svc'\n\nexport interface DatabaseSettings {\n  table: string\n}\nexport interface BaseServiceSettings extends ServiceSettingSchema {\n  database?: DatabaseSettings\n}\n\nexport type MemoizeOptions = {\n  ttl?: number\n}\n\nexport class PrismaService<ModelDelegate> extends BaseService {\n  public prisma!: PrismaClient\n  public get model(): ModelDelegate {\n    const name = this.settings.database?.table\n    if (!name) {\n      return null\n    }\n    if (!has(this.prisma, lowerFirst(name))) {\n      return null\n    }\n    return (this.prisma as any)[lowerFirst(name)]\n  }\n  public config: GenericObject = {}\n\n  public createdBy(ctx: Context<unknown, AppMeta>) {\n    return { connect: { id: ctx.meta.userId } }\n  }\n\n  public transformUpdateInput<T>(data: GenericObject) {\n    const keys = Object.keys(data)\n    return keys.reduce((carry, key) => ({ ...carry, [key]: { set: data[key] } }), {}) as T\n  }\n}\n\n",
        "called_code_segment": "protected async memoize<T, P = any>(name: string, params: P, callback: () => Promise<T>, options?: MemoizeOptions): Promise<T> { if (!this.broker.cacher) return callback() const key = this.broker.cacher.defaultKeygen(`${name}:memoize-${name}`, params as any, {}, []) let res = await this.broker.cacher.get(key) if (res) return <T>res res = await callback() this.broker.cacher.set(key, res, options && options.ttl) return <T>res }",
        "invoking_code_segment": "public async getCachedData(name: string, params: any): Promise<any> { return this.memoize(name, params, async () => { return await this.getDataFromSource(params) }, { ttl: 60 }) }",
        "new_file_code_segment": "export const cacheManager = { async getCachedData<T, P>(name: string, params: P, callback: () => Promise<T>, options?: MemoizeOptions): Promise<T> { if (!this.broker.cacher) return callback() const key = this.broker.cacher.defaultKeygen(`${name}:memoize-${name}`, params as any, {}, []) let res = await this.broker.cacher.get(key) if (res) return <T>res res = await callback() this.broker.cacher.set(key, res, options && options.ttl) return <T>res } }",
        "feature_description": "Introduce a centralized cache manager to handle memoization logic.",
        "detailed_feature_description": "The new feature introduces a centralized cache manager in a new file (#file 3) to handle the memoization logic. This manager will be used by both #file 1 and #file 2 to ensure consistency and reduce redundancy. The `memoize` method in #file 1 will be updated to use this manager, and #file 2 will also invoke the manager instead of directly calling the `memoize` method.",
        "modified_complete_code": {
            "#file 1": "//Modify protected async memoize<T, P = any>(name: string, params: P, callback: () => Promise<T>, options?: MemoizeOptions): Promise<T> { return cacheManager.getCachedData(name, params, callback, options) }",
            "#file 2": "//Modify public async getCachedData(name: string, params: any): Promise<any> { return cacheManager.getCachedData(name, params, async () => { return await this.getDataFromSource(params) }, { ttl: 60 }) }",
            "#file 3": "//New export const cacheManager = { async getCachedData<T, P>(name: string, params: P, callback: () => Promise<T>, options?: MemoizeOptions): Promise<T> { if (!this.broker.cacher) return callback() const key = this.broker.cacher.defaultKeygen(`${name}:memoize-${name}`, params as any, {}, []) let res = await this.broker.cacher.get(key) if (res) return <T>res res = await callback() this.broker.cacher.set(key, res, options && options.ttl) return <T>res } }"
        }
    },
    {
        "repo": "nestjs-db-postgresql",
        "content": "'nestjs-db-postgresql/src/app/app.module.ts'\n:import { UsersModule } from './user.module';\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from \"@nestjs/typeorm\";\nimport { AboutController } from './about/about.controller';\nimport { User } from './user/user.entity';\n\n@Module({\n    imports : [\n        TypeOrmModule.forRoot(),\n        UsersModule\n    ],\n    controllers : [\n        AboutController\n    ]\n})\nexport class ApplicationModule {\n\n    constructor() {\n        console.log('main module got loaded');\n    }\n}\n'nestjs-db-postgresql/src/server.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { ApplicationModule } from './app/app.module';\nimport { INestApplication } from '@nestjs/common/interfaces/nest-application.interface';\n\nconst app: Promise<INestApplication> = NestFactory.create(ApplicationModule);\napp.then(instance =>\n  instance.listen(3000, () =>\n    console.log('Application is listening on port 3000')\n  )\n);\n\n",
        "called_code_segment": "@Module({\n    imports : [\n        TypeOrmModule.forRoot(),\n        UsersModule\n    ],\n    controllers : [\n        AboutController\n    ]\n})\nexport class ApplicationModule {\n\n    constructor() {\n        console.log('main module got loaded');\n    }\n}",
        "invoking_code_segment": "const app: Promise<INestApplication> = NestFactory.create(ApplicationModule);\napp.then(instance =>\n  instance.listen(3000, () =>\n    console.log('Application is listening on port 3000')\n  )\n);",
        "new_file_code_segment": "import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class LoggerService {\n    log(message: string) {\n        console.log(`[LoggerService] ${message}`);\n    }\n}",
        "feature_description": "Add logging functionality to the application startup.",
        "detailed_feature_description": "The new feature introduces a LoggerService that will log messages during the application startup. This service will be injected into the ApplicationModule constructor to log a message when the main module is loaded. The LoggerService will also be used in the server file to log a message when the application starts listening on port 3000.",
        "modified_complete_code": {
            "#file 1": "import { UsersModule } from './user.module';\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from \"@nestjs/typeorm\";\nimport { AboutController } from './about/about.controller';\nimport { LoggerService } from './logger.service'; #New\nimport { User } from './user/user.entity';\n\n@Module({\n    imports : [\n        TypeOrmModule.forRoot(),\n        UsersModule\n    ],\n    controllers : [\n        AboutController\n    ],\n    providers: [LoggerService] #Modify\n})\nexport class ApplicationModule {\n\n    constructor(private readonly loggerService: LoggerService) { #Modify\n        this.loggerService.log('main module got loaded'); #Modify\n    }\n}",
            "#file 2": "import { NestFactory } from '@nestjs/core';\nimport { ApplicationModule } from './app/app.module';\nimport { INestApplication } from '@nestjs/common/interfaces/nest-application.interface';\nimport { LoggerService } from './app/logger.service'; #New\n\nconst app: Promise<INestApplication> = NestFactory.create(ApplicationModule);\napp.then(instance => {\n  const loggerService = instance.get(LoggerService); #New\n  instance.listen(3000, () => {\n    loggerService.log('Application is listening on port 3000'); #New\n  });\n});",
            "#file 3": "import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class LoggerService {\n    log(message: string) {\n        console.log(`[LoggerService] ${message}`);\n    }\n}"
        }
    },
    {
        "repo": "nestjs-elastic-search-docker",
        "content": "'nestjs-elastic-search-docker/src/services/search/constant/product.elastic.ts'\n:export const productIndex = {\n  _index: 'product',\n  _type: 'products'\n};\n\n'nestjs-elastic-search-docker/src/components/product/model/product.search.object.ts'\n:import { productIndex } from \"../../../services/search/constant/product.elastic\";\n\nexport class ElasticSearchBody {\n  size: number;\n  from: number;\n  query: any;\n\n  constructor(\n    size: number,\n    from: number,\n    query: any\n  ) {\n    this.size = size;\n    this.from = from;\n    this.query = query;\n  }\n}\n\n\nexport class ProductSearchObject {\n  public static searchObject(q: any) {\n    const body = this.elasticSearchBody(q);\n    return { index: productIndex._index, body, q };\n  }\n\n  public static elasticSearchBody(q: any): ElasticSearchBody {\n    const query = {\n      match: {\n        url: q\n      }\n    };\n    return new ElasticSearchBody(\n      10,\n      0,\n      query\n    );\n  }\n}\n\n",
        "called_code_segment": "public static searchObject(q: any) {\n    const body = this.elasticSearchBody(q);\n    return { index: productIndex._index, body, q };\n  }\n\n  public static elasticSearchBody(q: any): ElasticSearchBody {\n    const query = {\n      match: {\n        url: q\n      }\n    };\n    return new ElasticSearchBody(\n      10,\n      0,\n      query\n    );\n  }",
        "invoking_code_segment": "const searchObject = ProductSearchObject.searchObject(q);",
        "new_file_code_segment": "export class AdvancedSearchBody extends ElasticSearchBody {\n  constructor(size: number, from: number, query: any, filter: any) {\n    super(size, from, query);\n    this.filter = filter;\n  }\n\n  public static advancedSearchBody(q: any, filter: any): AdvancedSearchBody {\n    const query = {\n      match: {\n        url: q\n      }\n    };\n    return new AdvancedSearchBody(\n      10,\n      0,\n      query,\n      filter\n    );\n  }\n}",
        "feature_description": "Add support for advanced search queries with additional filters.",
        "detailed_feature_description": "The new feature introduces an AdvancedSearchBody class in #file 3 that extends the existing ElasticSearchBody class. This new class allows for additional filters to be applied during search queries. The ProductSearchObject class in #file 1 is updated to use the AdvancedSearchBody class when advanced search options are specified. The invoking code in #file 2 is also updated to pass the necessary filter parameters when invoking the advanced search functionality.",
        "modified_complete_code": {
            "#file 1": "import { productIndex } from \"../../../services/search/constant/product.elastic\";\n\n#Modify export class ElasticSearchBody {\n  size: number;\n  from: number;\n  query: any;\n\n  constructor(\n    size: number,\n    from: number,\n    query: any\n  ) {\n    this.size = size;\n    this.from = from;\n    this.query = query;\n  }\n}\n\n#Modify export class ProductSearchObject {\n  public static searchObject(q: any, filter?: any) {\n    const body = filter ? AdvancedSearchBody.advancedSearchBody(q, filter) : this.elasticSearchBody(q);\n    return { index: productIndex._index, body, q };\n  }\n\n  public static elasticSearchBody(q: any): ElasticSearchBody {\n    const query = {\n      match: {\n        url: q\n      }\n    };\n    return new ElasticSearchBody(\n      10,\n      0,\n      query\n    );\n  }\n}",
            "#file 2": "import { ProductSearchObject } from \"./model/product.search.object\";\n\n#Modify const searchObject = ProductSearchObject.searchObject(q, filter);",
            "#file 3": "#New export class AdvancedSearchBody extends ElasticSearchBody {\n  filter: any;\n\n  constructor(size: number, from: number, query: any, filter: any) {\n    super(size, from, query);\n    this.filter = filter;\n  }\n\n  public static advancedSearchBody(q: any, filter: any): AdvancedSearchBody {\n    const query = {\n      match: {\n        url: q\n      }\n    };\n    return new AdvancedSearchBody(\n      10,\n      0,\n      query,\n      filter\n    );\n  }\n}"
        }
    },
    {
        "repo": "angular-document-viewer",
        "content": "'angular-document-viewer/demo/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\nimport { NgxDocViewerModule } from 'modules';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    NgxDocViewerModule,\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-document-viewer/demo/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment": "@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    NgxDocViewerModule,\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
        "invoking_code_segment": "platformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));",
        "new_file_code_segment": "export function initializeApp() {\n  console.log('App initialization');\n}",
        "feature_description": "Add an initialization function to log a message when the app starts.",
        "detailed_feature_description": "The new feature introduces an initialization function that logs a message when the Angular application starts. This function is defined in a new file (#file 3) and is invoked in the AppModule's constructor to ensure it runs when the module is initialized. This approach enhances the application by providing a clear indication of when the app has started, which can be useful for debugging and monitoring purposes.",
        "modified_complete_code": {
            "#file 1": "import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule, APP_INITIALIZER } from '@angular/core';\nimport { AppComponent } from './app.component';\nimport { NgxDocViewerModule } from 'modules';\nimport { initializeApp } from './app-initializer'; // #New\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    NgxDocViewerModule,\n    BrowserModule\n  ],\n  providers: [\n    { provide: APP_INITIALIZER, useFactory: initializeApp, multi: true } // #Modify\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
            "#file 2": "import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));",
            "#file 3": "export function initializeApp() {\n  console.log('App initialization');\n}"
        }
    },
    {
        "repo": "nextui-dashboard",
        "content": "'nextui-dashboard/components/breadcrumb/breadcrumb.styled.ts'\n:import {Link, styled} from '@nextui-org/react';\n\nexport const Breadcrumbs = styled('ul', {\n   listStyle: 'none',\n   display: 'flex',\n   gap: '$4',\n   padding: 0,\n   mx: 0,\n});\n\nexport const CrumbLink = styled(Link, {\n   color: '$accents8',\n});\n\nexport const Crumb = styled('li', {\n   'display': 'flex',\n   'flexDirection': 'row',\n   'alignItems': 'center',\n   'gap': '$2',\n   '&:last-of-type:after': {\n      content: '',\n      padding: 0,\n   },\n\n   '&:last-child': {\n      '& > a': {\n         color: '$accents9',\n         cursor: 'default',\n         pointerEvents: 'none',\n      },\n   },\n});\n\n'nextui-dashboard/components/accounts/index.tsx'\n:import {Button, Input, Text} from '@nextui-org/react';\nimport Link from 'next/link';\nimport React from 'react';\nimport {Breadcrumbs, Crumb, CrumbLink} from '../breadcrumb/breadcrumb.styled';\nimport {DotsIcon} from '../icons/accounts/dots-icon';\nimport {ExportIcon} from '../icons/accounts/export-icon';\nimport {InfoIcon} from '../icons/accounts/info-icon';\nimport {TrashIcon} from '../icons/accounts/trash-icon';\nimport {HouseIcon} from '../icons/breadcrumb/house-icon';\nimport {UsersIcon} from '../icons/breadcrumb/users-icon';\nimport {SettingsIcon} from '../icons/sidebar/settings-icon';\nimport {Flex} from '../styles/flex';\nimport {TableWrapper} from '../table/table';\nimport {AddUser} from './add-user';\n\nexport const Accounts = () => {\n   return (\n      <Flex\n         css={{\n            'mt': '$5',\n            'px': '$6',\n            '@sm': {\n               mt: '$10',\n               px: '$16',\n            },\n         }}\n         justify={'center'}\n         direction={'column'}\n      >\n         <Breadcrumbs>\n            <Crumb>\n               <HouseIcon />\n               <Link href={'/'}>\n                  <CrumbLink href=\"#\">Home</CrumbLink>\n               </Link>\n               <Text>/</Text>\n            </Crumb>\n\n            <Crumb>\n               <UsersIcon />\n               <CrumbLink href=\"#\">Users</CrumbLink>\n               <Text>/</Text>\n            </Crumb>\n            <Crumb>\n               <CrumbLink href=\"#\">List</CrumbLink>\n            </Crumb>\n         </Breadcrumbs>\n\n         <Text h3>All Accounts</Text>\n         <Flex\n            css={{gap: '$8'}}\n            align={'center'}\n            justify={'between'}\n            wrap={'wrap'}\n         >\n            <Flex\n               css={{\n                  'gap': '$6',\n                  'flexWrap': 'wrap',\n                  '@sm': {flexWrap: 'nowrap'},\n               }}\n               align={'center'}\n            >\n               <Input\n                  css={{width: '100%', maxW: '410px'}}\n                  placeholder=\"Search users\"\n               />\n               <SettingsIcon />\n               <TrashIcon />\n               <InfoIcon />\n               <DotsIcon />\n            </Flex>\n            <Flex direction={'row'} css={{gap: '$6'}} wrap={'wrap'}>\n               <AddUser />\n               <Button auto iconRight={<ExportIcon />}>\n                  Export to CSV\n               </Button>\n            </Flex>\n         </Flex>\n\n         <TableWrapper />\n      </Flex>\n   );\n};\n\n",
        "called_code_segment": "export const Accounts = () => {\n   return (\n      <Flex\n         css={{\n            'mt': '$5',\n            'px': '$6',\n            '@sm': {\n               mt: '$10',\n               px: '$16',\n            },\n         }}\n         justify={'center'}\n         direction={'column'}\n      >\n         <Breadcrumbs>\n            <Crumb>\n               <HouseIcon />\n               <Link href={'/'}>\n                  <CrumbLink href=\"#\">Home</CrumbLink>\n               </Link>\n               <Text>/</Text>\n            </Crumb>\n\n            <Crumb>\n               <UsersIcon />\n               <CrumbLink href=\"#\">Users</CrumbLink>\n               <Text>/</Text>\n            </Crumb>\n            <Crumb>\n               <CrumbLink href=\"#\">List</CrumbLink>\n            </Crumb>\n         </Breadcrumbs>\n\n         <Text h3>All Accounts</Text>\n         <Flex\n            css={{gap: '$8'}}\n            align={'center'}\n            justify={'between'}\n            wrap={'wrap'}\n         >\n            <Flex\n               css={{\n                  'gap': '$6',\n                  'flexWrap': 'wrap',\n                  '@sm': {flexWrap: 'nowrap'},\n               }}\n               align={'center'}\n            >\n               <Input\n                  css={{width: '100%', maxW: '410px'}}\n                  placeholder=\"Search users\"\n               />\n               <SettingsIcon />\n               <TrashIcon />\n               <InfoIcon />\n               <DotsIcon />\n            </Flex>\n            <Flex direction={'row'} css={{gap: '$6'}} wrap={'wrap'}>\n               <AddUser />\n               <Button auto iconRight={<ExportIcon />}>\n                  Export to CSV\n               </Button>\n            </Flex>\n         </Flex>\n\n         <TableWrapper />\n      </Flex>\n   );\n};",
        "invoking_code_segment": "<Accounts />",
        "new_file_code_segment": "export const FilterUsers = () => {\n   return (\n      <Flex direction={'row'} css={{gap: '$6'}} wrap={'wrap'}>\n         <Button auto iconRight={<FilterIcon />}>\n            Filter\n         </Button>\n         <Button auto iconRight={<SortIcon />}>\n            Sort\n         </Button>\n      </Flex>\n   );\n};",
        "feature_description": "Add filtering and sorting functionality for users.",
        "detailed_feature_description": "The new feature introduces a FilterUsers component that provides buttons for filtering and sorting users. This component is integrated into the Accounts component, enhancing the user interface with additional controls for data manipulation.",
        "modified_complete_code": {
            "#file 1": "export const Accounts = () => {\n   return (\n      <Flex\n         css={{\n            'mt': '$5',\n            'px': '$6',\n            '@sm': {\n               mt: '$10',\n               px: '$16',\n            },\n         }}\n         justify={'center'}\n         direction={'column'}\n      >\n         <Breadcrumbs>\n            <Crumb>\n               <HouseIcon />\n               <Link href={'/'}>\n                  <CrumbLink href=\"#\">Home</CrumbLink>\n               </Link>\n               <Text>/</Text>\n            </Crumb>\n\n            <Crumb>\n               <UsersIcon />\n               <CrumbLink href=\"#\">Users</CrumbLink>\n               <Text>/</Text>\n            </Crumb>\n            <Crumb>\n               <CrumbLink href=\"#\">List</CrumbLink>\n            </Crumb>\n         </Breadcrumbs>\n\n         <Text h3>All Accounts</Text>\n         <Flex\n            css={{gap: '$8'}}\n            align={'center'}\n            justify={'between'}\n            wrap={'wrap'}\n         >\n            <Flex\n               css={{\n                  'gap': '$6',\n                  'flexWrap': 'wrap',\n                  '@sm': {flexWrap: 'nowrap'},\n               }}\n               align={'center'}\n            >\n               <Input\n                  css={{width: '100%', maxW: '410px'}}\n                  placeholder=\"Search users\"\n               />\n               <SettingsIcon />\n               <TrashIcon />\n               <InfoIcon />\n               <DotsIcon />\n            </Flex>\n            <Flex direction={'row'} css={{gap: '$6'}} wrap={'wrap'}>\n               <AddUser />\n               <Button auto iconRight={<ExportIcon />}>\n                  Export to CSV\n               </Button>\n               #Modify\n               <FilterUsers />\n            </Flex>\n         </Flex>\n\n         <TableWrapper />\n      </Flex>\n   );\n};",
            "#file 2": "<Accounts />",
            "#file 3": "export const FilterUsers = () => {\n   return (\n      <Flex direction={'row'} css={{gap: '$6'}} wrap={'wrap'}>\n         <Button auto iconRight={<FilterIcon />}>\n            Filter\n         </Button>\n         <Button auto iconRight={<SortIcon />}>\n            Sort\n         </Button>\n      </Flex>\n   );\n};"
        }
    },
    {
        "repo": "ngx-chat-ui",
        "content": "'ngx-chat-ui/apps/ngx-chat-ui-demo/src/app/components/app/app.component.ts'\n:\n'ngx-chat-ui/apps/ngx-chat-ui-demo/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { RouterModule } from '@angular/router';\nimport { DROPZONE_CONFIG, DropzoneConfigInterface } from 'ngx-dropzone-wrapper';\n\nimport { AppComponent } from './components/app/app.component';\nimport { NgxChatUiModule } from '@ngx-chat-ui/libs/ngx-chat-ui';\n\nconst DEFAULT_DROPZONE_CONFIG: DropzoneConfigInterface = {\n  url: 'https://dashboard.pixc.com/uploadFile/test',\n  acceptedFiles: 'image/*',\n};\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot([]),\n    NgxChatUiModule\n  ],\n  providers: [\n    {\n      provide: DROPZONE_CONFIG,\n      useValue: DEFAULT_DROPZONE_CONFIG,\n    }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n\n",
        "called_code_segment": "@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot([]),\n    NgxChatUiModule\n  ],\n  providers: [\n    {\n      provide: DROPZONE_CONFIG,\n      useValue: DEFAULT_DROPZONE_CONFIG,\n    }\n  ],\n  bootstrap: [AppComponent]\n})",
        "invoking_code_segment": "import { AppComponent } from './components/app/app.component';\nimport { NgxChatUiModule } from '@ngx-chat-ui/libs/ngx-chat-ui';\n\nconst DEFAULT_DROPZONE_CONFIG: DropzoneConfigInterface = {\n  url: 'https://dashboard.pixc.com/uploadFile/test',\n  acceptedFiles: 'image/*',\n};",
        "new_file_code_segment": "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NewFeatureComponent } from './new-feature.component';\n\n@NgModule({\n  declarations: [NewFeatureComponent],\n  imports: [CommonModule],\n  exports: [NewFeatureComponent]\n})\nexport class NewFeatureModule {}",
        "feature_description": "Add a new feature to the chat UI to support video messages.",
        "detailed_feature_description": "The new feature involves adding support for video messages in the chat UI. This requires creating a new component (`NewFeatureComponent`) to handle video message rendering and interactions. The `NewFeatureModule` is created to encapsulate this new functionality. The `AppModule` is updated to import this new module, and the `AppComponent` is modified to include the new feature component where applicable.",
        "modified_complete_code": {
            "#file 1": "import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { RouterModule } from '@angular/router';\nimport { DROPZONE_CONFIG, DropzoneConfigInterface } from 'ngx-dropzone-wrapper';\n\nimport { AppComponent } from './components/app/app.component';\nimport { NgxChatUiModule } from '@ngx-chat-ui/libs/ngx-chat-ui';\nimport { NewFeatureModule } from './new-feature.module'; #New\n\nconst DEFAULT_DROPZONE_CONFIG: DropzoneConfigInterface = {\n  url: 'https://dashboard.pixc.com/uploadFile/test',\n  acceptedFiles: 'image/*',\n};\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [\n    BrowserModule,\n    RouterModule.forRoot([]),\n    NgxChatUiModule,\n    NewFeatureModule #Modify\n  ],\n  providers: [\n    {\n      provide: DROPZONE_CONFIG,\n      useValue: DEFAULT_DROPZONE_CONFIG,\n    }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}",
            "#file 2": "import { Component } from '@angular/core';\nimport { NewFeatureComponent } from './new-feature.component'; #New\n\n@Component({\n  selector: 'app-root',\n  template: `\n    <ngx-chat-ui></ngx-chat-ui>\n    <new-feature></new-feature> #Modify\n  `,\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {}",
            "#file 3": "import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { NewFeatureComponent } from './new-feature.component';\n\n@NgModule({\n  declarations: [NewFeatureComponent],\n  imports: [CommonModule],\n  exports: [NewFeatureComponent]\n})\nexport class NewFeatureModule {}\n\nimport { Component } from '@angular/core';\n\n@Component({\n  selector: 'new-feature',\n  template: `<div>New Feature: Video Messages</div>`,\n  styleUrls: ['./new-feature.component.css']\n})\nexport class NewFeatureComponent {}"
        }
    },
    {
        "repo": "angular-the-complete-guide-2023",
        "content": "'angular-the-complete-guide-2023/project/src/environments/environment.ts'\n:// This file can be replaced during build by using the `fileReplacements` array.\n// `ng build` replaces `environment.ts` with `environment.prod.ts`.\n// The list of file replacements can be found in `angular.json`.\n\nexport const environment = {\n  production: false,\n  firebaseApiKey: 'AIzaSyCmu697oQuXIpDIxkerVfqAecXsi3NPcHE'\n};\n\n/*\n * For easier debugging in development mode, you can import the following file\n * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.\n *\n * This import should be commented out in production mode because it will have a negative impact\n * on performance if an error is thrown.\n */\n// import 'zone.js/plugins/zone-error';  // Included with Angular CLI.\n\n'angular-the-complete-guide-2023/project/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment": "export const environment = {\n  production: false,\n  firebaseApiKey: 'AIzaSyCmu697oQuXIpDIxkerVfqAecXsi3NPcHE'\n};",
        "invoking_code_segment": "if (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));",
        "new_file_code_segment": "export function getFirebaseApiKey() {\n  return environment.firebaseApiKey;\n}",
        "feature_description": "Add a function to retrieve the Firebase API key from the environment.",
        "detailed_feature_description": "The new feature introduces a function `getFirebaseApiKey` in a new file (`#file 3`) that retrieves the Firebase API key from the environment. This function is then invoked in both `#file 1` and `#file 2` to ensure that the API key is accessed in a centralized manner, promoting code reusability and maintainability.",
        "modified_complete_code": {
            "#file 1": "// src/environments/environment.ts\n\n#Modify export const environment = {\n  production: false,\n  firebaseApiKey: 'AIzaSyCmu697oQuXIpDIxkerVfqAecXsi3NPcHE'\n};",
            "#file 2": "// src/main.ts\n\nimport { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n#New import { getFirebaseApiKey } from './environments/environment.utils';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nconsole.log('Firebase API Key:', getFirebaseApiKey());\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));",
            "#file 3": "// src/environments/environment.utils.ts\n\n#New import { environment } from './environment';\n\n#New export function getFirebaseApiKey() {\n  return environment.firebaseApiKey;\n}"
        }
    },
    {
        "repo": "ngx-hana-nameserver-history-viewer",
        "content": "'ngx-hana-nameserver-history-viewer/src/demo/demo-service.ts'\n:import {Injectable} from '@angular/core';\n\n/**\n * interface for the timezone with abbreviation and offset\n */\nexport interface TimeZoneAbbrMapping {\n  timezone: string;\n  offset: number;\n  abbreviation: string;\n}\n\n@Injectable()\nexport class DemoService {\n  /**\n   * get timezones with timezone abbreviation and offset.\n   */\n  getTimezoneAbbrMappings(): TimeZoneAbbrMapping[] {\n    /**\n     * Below timezones are adapted from:\n     * https://github.com/kevalbhatt/timezone-picker/blob/master/src/timezones.json,\n     * https://www.timeanddate.com/time/zones,\n     * https://en.wikipedia.org/wiki/List_of_time_zone_abbreviations\n     *\n     * The MIT License (MIT)\n     * Copyright (c) 2015 Keval Bhatt\n     * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n     * associated documentation files (the \"Software\"), to deal in the Software without restriction,\n     * including without limitation the rights to use, copy, modify, merge, publish, distribute,\n     * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     * The above copyright notice and this permission notice shall be included in all copies or\n     * substantial portions of the Software.\n     */\n    return [\n        { timezone: 'Australia/Adelaide',  offset: 10.5,  abbreviation: 'ACDT' },\n        // { timezone: 'Australia/Broken_Hill',  offset: 10.5,  abbreviation: 'ACDT' },\n        { timezone: 'Australia/Darwin',  offset: 9.5,  abbreviation: 'ACST' },\n        { timezone: 'America/Eirunepe',  offset: -5,  abbreviation: 'ACT' },\n        // { timezone: 'America/Rio_Branco',  offset: -5,  abbreviation: 'ACT' },\n        { timezone: 'Australia/Eucla',  offset: 8.75,  abbreviation: 'ACWST' },\n        { timezone: 'America/Halifax',  offset: -3,  abbreviation: 'ADT' },\n        // { timezone: 'Australia/Currie',  offset: 11,  abbreviation: 'AEDT' },\n        // { timezone: 'Australia/Hobart',  offset: 11,  abbreviation: 'AEDT' },\n        // { timezone: 'Australia/Melbourne',  offset: 11,  abbreviation: 'AEDT' },\n        { timezone: 'Australia/Sydney',  offset: 11,  abbreviation: 'AEDT' },\n        { timezone: 'Australia/Brisbane',  offset: 10,  abbreviation: 'AEST' },\n        // { timezone: 'Australia/Lindeman',  offset: 10,  abbreviation: 'AEST' },\n        { timezone: 'Asia/Kabul',  offset: 4.5,  abbreviation: 'AFT' },\n        { timezone: 'America/Anchorage',  offset: -8,  abbreviation: 'AKDT' },\n        { timezone: 'America/Anchorage',  offset: -9,  abbreviation: 'AKST' },\n        // { timezone: 'America/Juneau',  offset: -9,  abbreviation: 'AKST' },\n        // { timezone: 'America/Nome',  offset: -9,  abbreviation: 'AKST' },\n        // { timezone: 'America/Sitka',  offset: -9,  abbreviation: 'AKST' },\n        // { timezone: 'America/Yakutat',  offset: -9,  abbreviation: 'AKST' },\n        { timezone: 'Asia/Almaty',  offset: 6,  abbreviation: 'ALMT' },\n        { timezone: 'America/Campo_Grande',  offset: -3,  abbreviation: 'AMST' },\n        // { timezone: 'America/Cuiaba',  offset: -3,  abbreviation: 'AMST' },\n        // { timezone: 'America/Boa_Vista',  offset: -4,  abbreviation: 'AMT' },\n        { timezone: 'America/Manaus',  offset: -4,  abbreviation: 'AMT' },\n        // { timezone: 'America/Porto_Velho',  offset: -4,  abbreviation: 'AMT' },\n        { timezone: 'Asia/Yerevan',  offset: 4,  abbreviation: 'AMT' },\n        { timezone: 'Asia/Anadyr',  offset: 12,  abbreviation: 'ANAT' },\n        { timezone: 'Asia/Aqtau',  offset: 5,  abbreviation: 'AQTT' },\n        // { timezone: 'Asia/Aqtobe',  offset: 5,  abbreviation: 'AQTT' },\n        // { timezone: 'America/Argentina/Salta',  offset: -3,  abbreviation: 'ART' },\n        { timezone: 'America/Argentina/Buenos_Aires',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/Catamarca',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/Cordoba',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/Jujuy',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/La_Rioja',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/Mendoza',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/Rio_Gallegos',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/San_Juan',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/San_Luis',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/Tucuman',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Argentina/Ushuaia',  offset: -3,  abbreviation: 'ART' },\n        // { timezone: 'America/Anguilla',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Antigua',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Aruba',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Barbados',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Blanc-Sablon',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Curacao',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Dominica',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Glace_Bay',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Goose_Bay',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Grand_Turk',  offset: -5,  abbreviation: 'AST' },\n        // { timezone: 'America/Grenada',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Guadeloupe',  offset: -4,  abbreviation: 'AST' },\n        { timezone: 'America/Halifax',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Kralendijk',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Lower_Princes',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Marigot',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Martinique',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Moncton',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Montserrat',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Port_of_Spain',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Puerto_Rico',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Santo_Domingo',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/St_Barthelemy',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Thule',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/St_Kitts',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/St_Lucia',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/St_Thomas',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/St_Vincent',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'America/Tortola',  offset: -4,  abbreviation: 'AST' },\n        // { timezone: 'Atlantic/Bermuda',  offset: -4,  abbreviation: 'AST' },\n        { timezone: 'Asia/Aden',  offset: 3,  abbreviation: 'AST' },\n        // { timezone: 'Asia/Baghdad',  offset: 3,  abbreviation: 'AST' },\n        // { timezone: 'Asia/Bahrain',  offset: 3,  abbreviation: 'AST' },\n        // { timezone: 'Asia/Kuwait',  offset: 3,  abbreviation: 'AST' },\n        // { timezone: 'Asia/Qatar',  offset: 3,  abbreviation: 'AST' },\n        // { timezone: 'Asia/Riyadh',  offset: 3,  abbreviation: 'AST' },\n        // { timezone: 'Atlantic/Bermuda',  offset: -4,  abbreviation: 'AST' },\n        { timezone: 'Australia/Perth',  offset: 8,  abbreviation: 'AWST' },\n        { timezone: 'Atlantic/Azores',  offset: 0,  abbreviation: 'AZOST' },\n        { timezone: 'Atlantic/Azores',  offset: -1,  abbreviation: 'AZOT' },\n        { timezone: 'Asia/Baku',  offset: 4,  abbreviation: 'AZT' },\n        { timezone: 'Asia/Brunei',  offset: 8,  abbreviation: 'BNT' },\n        { timezone: 'America/La_Paz',  offset: -4,  abbreviation: 'BOT' },\n        { timezone: 'America/Sao_Paulo',  offset: -2,  abbreviation: 'BRST' },\n        { timezone: 'America/Araguaina',  offset: -3,  abbreviation: 'BRT' },\n        // { timezone: 'America/Bahia',  offset: -2,  abbreviation: 'BRT' },\n        // { timezone: 'America/Belem',  offset: -3,  abbreviation: 'BRT' },\n        // { timezone: 'America/Fortaleza',  offset: -3,  abbreviation: 'BRT' },\n        // { timezone: 'America/Maceio',  offset: -3,  abbreviation: 'BRT' },\n        // { timezone: 'America/Recife',  offset: -3,  abbreviation: 'BRT' },\n        // { timezone: 'America/Santarem',  offset: -3,  abbreviation: 'BRT' },\n        { timezone: 'Asia/Dhaka',  offset: 6,  abbreviation: 'BST' },\n        { timezone: 'Europe/London',  offset: 1,  abbreviation: 'BST' },\n        { timezone: 'Asia/Thimphu',  offset: 6,  abbreviation: 'BTT' },\n        { timezone: 'Africa/Blantyre',  offset: 2,  abbreviation: 'CAT' },\n        // { timezone: 'Africa/Bujumbura',  offset: 2,  abbreviation: 'CAT' },\n        // { timezone: 'Africa/Gaborone',  offset: 2,  abbreviation: 'CAT' },\n        // { timezone: 'Africa/Harare',  offset: 2,  abbreviation: 'CAT' },\n        // { timezone: 'Africa/Kigali',  offset: 2,  abbreviation: 'CAT' },\n        // { timezone: 'Africa/Lubumbashi',  offset: 2,  abbreviation: 'CAT' },\n        // { timezone: 'Africa/Lusaka',  offset: 2,  abbreviation: 'CAT' },\n        // { timezone: 'Africa/Maputo',  offset: 2,  abbreviation: 'CAT' },\n        { timezone: 'Indian/Cocos',  offset: 6.5,  abbreviation: 'CCT' },\n        { timezone: 'America/Chicago',  offset: -5,  abbreviation: 'CDT' },\n        { timezone: 'Europe/Brussels',  offset: 2,  abbreviation: 'CEST' },\n        // { timezone: 'Africa/Algiers',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Africa/Ceuta',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Africa/Tunis',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Arctic/Longyearbyen',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Amsterdam',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Andorra',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Belgrade',  offset: 1,  abbreviation: 'CET' },\n        { timezone: 'Europe/Berlin',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Budapest',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Bratislava',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Brussels',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Copenhagen',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Gibraltar',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Ljubljana',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Luxembourg',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Madrid',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Malta',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Monaco',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Oslo',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Paris',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Podgorica',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Prague',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Rome',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/San_Marino',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Sarajevo',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Skopje',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Stockholm',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Tirane',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Vaduz',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Vatican',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Vienna',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Warsaw',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Zagreb',  offset: 1,  abbreviation: 'CET' },\n        // { timezone: 'Europe/Zurich',  offset: 1,  abbreviation: 'CET' },\n        { timezone: 'Pacific/Chatham',  offset: 13.75,  abbreviation: 'CHADT' },\n        { timezone: 'Pacific/Chatham',  offset: 12.75,  abbreviation: 'CHAST' },\n        { timezone: 'Asia/Choibalsan',  offset: 9,  abbreviation: 'CHOST' },\n        { timezone: 'Asia/Choibalsan',  offset: 8,  abbreviation: 'CHOT' },\n        { timezone: 'Pacific/Guam',  offset: 10,  abbreviation: 'ChST' },\n        // { timezone: 'Pacific/Saipan',  offset: 10,  abbreviation: 'ChST' },\n        { timezone: 'Pacific/Chuuk',  offset: 10,  abbreviation: 'CHUT' },\n        { timezone: 'Pacific/Rarotonga',  offset: -10,  abbreviation: 'CKT' },\n        { timezone: 'America/Santiago',  offset: -3,  abbreviation: 'CLST' },\n        { timezone: 'America/Santiago',  offset: -4,  abbreviation: 'CLT' },\n        { timezone: 'America/Bogota',  offset: -5,  abbreviation: 'COT' },\n        // { timezone: 'America/Bahia_Banderas',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Belize',  offset: -6,  abbreviation: 'CST' },\n        { timezone: 'America/Chicago',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Costa_Rica',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/El_Salvador',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Guatemala',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Havana',  offset: -5,  abbreviation: 'CST' },\n        // { timezone: 'America/Indiana/Tell_City',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Indiana/Knox',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Managua',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Matamoros',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Menominee',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Mexico_City',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Merida',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Monterrey',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/North_Dakota/Beulah',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/North_Dakota/Center',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/North_Dakota/New_Salem',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Rainy_River',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Rankin_Inlet',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Regina',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Resolute',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Swift_Current',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Tegucigalpa',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'America/Winnipeg',  offset: -6,  abbreviation: 'CST' },\n        // { timezone: 'Asia/Chongqing',  offset: 8,  abbreviation: 'CST' },\n        // { timezone: 'Asia/Harbin',  offset: 8,  abbreviation: 'CST' },\n        // { timezone: 'Asia/Macau',  offset: 8,  abbreviation: 'CST' },\n        { timezone: 'Asia/Shanghai',  offset: 8,  abbreviation: 'CST' },\n        // { timezone: 'Asia/Taipei',  offset: 8,  abbreviation: 'CST' },\n        { timezone: 'Atlantic/Cape_Verde',  offset: -1,  abbreviation: 'CVT' },\n        { timezone: 'Indian/Christmas',  offset: 7,  abbreviation: 'CXT' },\n        { timezone: 'Antarctica/Davis',  offset: 7,  abbreviation: 'DAVT' },\n        { timezone: 'Pacific/Easter',  offset: -5,  abbreviation: 'EASST' },\n        { timezone: 'Pacific/Easter',  offset: -6,  abbreviation: 'EAST' },\n        { timezone: 'Africa/Addis_Ababa',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Africa/Asmara',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Africa/Dar_es_Salaam',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Africa/Djibouti',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Africa/Juba',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Africa/Kampala',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Africa/Khartoum',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Africa/Mogadishu',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Africa/Nairobi',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Indian/Antananarivo',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Indian/Comoro',  offset: 3,  abbreviation: 'EAT' },\n        // { timezone: 'Indian/Mayotte',  offset: 3,  abbreviation: 'EAT' },\n        { timezone: 'America/Guayaquil',  offset: -5,  abbreviation: 'ECT' },\n        { timezone: 'America/New_York',  offset: -4,  abbreviation: 'EDT' },\n        { timezone: 'Europe/Bucharest',  offset: 3,  abbreviation: 'EEST' },\n        // { timezone: 'Africa/Cairo',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Africa/Tripoli',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Asia/Amman',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Asia/Beirut',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Asia/Damascus',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Asia/Gaza',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Asia/Hebron',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Asia/Nicosia',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Athens',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Bucharest',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Chisinau',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Helsinki',  offset: 2,  abbreviation: 'EET' },\n        { timezone: 'Europe/Istanbul',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Kaliningrad',  offset: 3,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Kiev',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Mariehamn',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Riga',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Sofia',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Tallinn',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Uzhgorod',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Vilnius',  offset: 2,  abbreviation: 'EET' },\n        // { timezone: 'Europe/Zaporozhye',  offset: 2,  abbreviation: 'EET' },\n        { timezone: 'America/Scoresbysund',  offset: -1,  abbreviation: 'EGT' },\n        // { timezone: 'America/Atikokan',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Cancun',  offset: -6,  abbreviation: 'EST' },\n        // { timezone: 'America/Cayman',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Coral_Harbour',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Detroit',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Indiana/Petersburg',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Indiana/Vevay',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Indiana/Indianapolis',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Indiana/Marengo',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Indiana/Vincennes',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Indiana/Winamac',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Iqaluit',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Jamaica',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Kentucky/Louisville',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Kentucky/Monticello',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Montreal',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Nassau',  offset: -5,  abbreviation: 'EST' },\n        { timezone: 'America/New_York',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Nipigon',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Panama',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Pangnirtung',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Port-au-Prince',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Thunder_Bay',  offset: -5,  abbreviation: 'EST' },\n        // { timezone: 'America/Toronto',  offset: -5,  abbreviation: 'EST' },\n        { timezone: 'Pacific/Fiji',  offset: 13,  abbreviation: 'FJST' },\n        { timezone: 'Pacific/Fiji',  offset: 12,  abbreviation: 'FJT' },\n        { timezone: 'Atlantic/Stanley',  offset: -3,  abbreviation: 'FKST' },\n        { timezone: 'Atlantic/Stanley',  offset: -4,  abbreviation: 'FKT' },\n        { timezone: 'America/Noronha',  offset: -2,  abbreviation: 'FNT' },\n        { timezone: 'Pacific/Galapagos',  offset: -6,  abbreviation: 'GALT' },\n        { timezone: 'Pacific/Gambier',  offset: -9,  abbreviation: 'GAMT' },\n        { timezone: 'Asia/Tbilisi',  offset: 4,  abbreviation: 'GET' },\n        { timezone: 'America/Cayenne',  offset: -3,  abbreviation: 'GFT' },\n        { timezone: 'Pacific/Tarawa',  offset: 12,  abbreviation: 'GILT' },\n        // { timezone: 'Africa/Abidjan',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Accra',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Bamako',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Banjul',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Bissau',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Conakry',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Dakar',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Freetown',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Lome',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Monrovia',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Nouakchott',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Ouagadougou',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Africa/Sao_Tome',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'America/Danmarkshavn',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Atlantic/Reykjavik',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Atlantic/St_Helena',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Europe/Dublin',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Europe/Guernsey',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Europe/Isle_of_Man',  offset: 0,  abbreviation: 'GMT' },\n        // { timezone: 'Europe/Jersey',  offset: 0,  abbreviation: 'GMT' },\n        { timezone: 'Europe/London',  offset: 0,  abbreviation: 'GMT' },\n        { timezone: 'Asia/Dubai',  offset: 4,  abbreviation: 'GST' },\n        // { timezone: 'Asia/Muscat',  offset: 4,  abbreviation: 'GST' },\n        { timezone: 'Atlantic/South_Georgia',  offset: -2,  abbreviation: 'GST' },\n        { timezone: 'America/Guyana',  offset: -4,  abbreviation: 'GYT' },\n        { timezone: 'America/Adak',  offset: -9,  abbreviation: 'HDT' },\n        { timezone: 'Asia/Hong_Kong',  offset: 8,  abbreviation: 'HKT' },\n        { timezone: 'Asia/Hovd',  offset: 8,  abbreviation: 'HOVST' },\n        { timezone: 'Asia/Hovd',  offset: 7,  abbreviation: 'HOVT' },\n        { timezone: 'America/Adak',  offset: -10,  abbreviation: 'HST' },\n        // { timezone: 'Pacific/Honolulu',  offset: -10,  abbreviation: 'HST' },\n        // { timezone: 'Pacific/Johnston',  offset: -10,  abbreviation: 'HST' },\n        { timezone: 'Asia/Bangkok',  offset: 7,  abbreviation: 'ICT' },\n        // { timezone: 'Asia/Ho_Chi_Minh',  offset: 7,  abbreviation: 'ICT' },\n        // { timezone: 'Asia/Phnom_Penh',  offset: 7,  abbreviation: 'ICT' },\n        // { timezone: 'Asia/Vientiane',  offset: 7,  abbreviation: 'ICT' },\n        { timezone: 'Asia/Jerusalem',  offset: 3,  abbreviation: 'IDT' },\n        { timezone: 'Indian/Chagos',  offset: 6,  abbreviation: 'IOT' },\n        { timezone: 'Asia/Tehran',  offset: 4.5,  abbreviation: 'IRDT' },\n        { timezone: 'Asia/Irkutsk',  offset: 9,  abbreviation: 'IRKT' },\n        { timezone: 'Asia/Tehran',  offset: 3.5,  abbreviation: 'IRST' },\n        { timezone: 'Asia/Colombo',  offset: 5.5,  abbreviation: 'IST' },\n        // { timezone: 'Asia/Jerusalem',  offset: 2,  abbreviation: 'IST' },\n        // { timezone: 'Asia/Calcutta',  offset: 5.5,  abbreviation: 'IST' },\n        { timezone: 'Asia/Tokyo',  offset: 9,  abbreviation: 'JST' },\n        { timezone: 'Asia/Bishkek',  offset: 6,  abbreviation: 'KGT' },\n        { timezone: 'Pacific/Kosrae',  offset: 11,  abbreviation: 'KOST' },\n        { timezone: 'Asia/Krasnoyarsk',  offset: 8,  abbreviation: 'KRAST' },\n        { timezone: 'Asia/Krasnoyarsk',  offset: 7,  abbreviation: 'KRAT' },\n        // { timezone: 'Asia/Novokuznetsk',  offset: 7,  abbreviation: 'KRAT' },\n        // { timezone: 'Asia/Pyongyang',  offset: 9,  abbreviation: 'KST' },\n        { timezone: 'Asia/Seoul',  offset: 9,  abbreviation: 'KST' },\n        { timezone: 'Australia/Lord_Howe',  offset: 11,  abbreviation: 'LHDT' },\n        { timezone: 'Pacific/Kiritimati',  offset: 14,  abbreviation: 'LINT' },\n        { timezone: 'Asia/Magadan',  offset: 12,  abbreviation: 'MAGT' },\n        { timezone: 'Pacific/Marquesas',  offset: -9.5,  abbreviation: 'MART' },\n        { timezone: 'Antarctica/Mawson',  offset: 5,  abbreviation: 'MAWT' },\n        // { timezone: 'Pacific/Kwajalein',  offset: 12,  abbreviation: 'MHT' },\n        { timezone: 'Pacific/Majuro',  offset: 12,  abbreviation: 'MHT' },\n        { timezone: 'Antarctica/Macquarie',  offset: 11,  abbreviation: 'MIST' },\n        { timezone: 'Asia/Rangoon',  offset: 6.5,  abbreviation: 'MMT' },\n        { timezone: 'Europe/Moscow',  offset: 4,  abbreviation: 'MSD' },\n        // { timezone: 'Europe/Minsk',  offset: 3,  abbreviation: 'MSK' },\n        { timezone: 'Europe/Moscow',  offset: 3,  abbreviation: 'MSK' },\n        // { timezone: 'America/Boise',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Cambridge_Bay',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Chihuahua',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Creston',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Dawson_Creek',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Denver',  offset: -7,  abbreviation: 'MST' },\n        { timezone: 'America/Edmonton',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Hermosillo',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Inuvik',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Mazatlan',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Ojinaga',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Phoenix',  offset: -7,  abbreviation: 'MST' },\n        // { timezone: 'America/Yellowknife',  offset: -7,  abbreviation: 'MST' },\n        { timezone: 'Indian/Mauritius',  offset: 4,  abbreviation: 'MUT' },\n        { timezone: 'Indian/Maldives',  offset: 5,  abbreviation: 'MVT' },\n        // { timezone: 'Asia/Kuala_Lumpur',  offset: 8,  abbreviation: 'MYT' },\n        { timezone: 'Asia/Kuching',  offset: 8,  abbreviation: 'MYT' },\n        { timezone: 'Pacific/Noumea',  offset: 11,  abbreviation: 'NCT' },\n        { timezone: 'Pacific/Norfolk',  offset: 11,  abbreviation: 'NFT' },\n        { timezone: 'Asia/Novosibirsk',  offset: 7,  abbreviation: 'NOVT' },\n        { timezone: 'Asia/Kathmandu',  offset: 5.75,  abbreviation: 'NPT' },\n        { timezone: 'Pacific/Nauru',  offset: 12,  abbreviation: 'NRT' },\n        { timezone: 'America/St_Johns',  offset: -3.5,  abbreviation: 'NST' },\n        { timezone: 'Pacific/Niue',  offset: -11,  abbreviation: 'NUT' },\n        { timezone: 'Pacific/Auckland',  offset: 13,  abbreviation: 'NZDT' },\n        { timezone: 'Pacific/Auckland',  offset: 12,  abbreviation: 'NZST' },\n        { timezone: 'Asia/Omsk',  offset: 7,  abbreviation: 'OMSST' },\n        { timezone: 'Asia/Omsk',  offset: 6,  abbreviation: 'OMST' },\n        { timezone: 'Asia/Oral',  offset: 5,  abbreviation: 'ORAT' },\n        // { timezone: 'America/Los_Angeles',  offset: -7,  abbreviation: 'PDT' },\n        { timezone: 'America/Vancouver',  offset: -7,  abbreviation: 'PDT' },\n        { timezone: 'America/Lima',  offset: -5,  abbreviation: 'PET' },\n        { timezone: 'Asia/Kamchatka',  offset: 12,  abbreviation: 'PETST' },\n        { timezone: 'Asia/Kamchatka',  offset: 12,  abbreviation: 'PETT' },\n        { timezone: 'Pacific/Port_Moresby',  offset: 10,  abbreviation: 'PGT' },\n        { timezone: 'Pacific/Enderbury',  offset: 13,  abbreviation: 'PHOT' },\n        { timezone: 'Asia/Manila',  offset: 8,  abbreviation: 'PHT' },\n        { timezone: 'Asia/Karachi',  offset: 5,  abbreviation: 'PKT' },\n        { timezone: 'America/Miquelon',  offset: -2,  abbreviation: 'PMDT' },\n        { timezone: 'America/Miquelon',  offset: -3,  abbreviation: 'PMST' },\n        { timezone: 'Pacific/Pohnpei',  offset: 11,  abbreviation: 'PONT' },\n        // { timezone: 'America/Dawson',  offset: -8,  abbreviation: 'PST' },\n        // { timezone: 'America/Los_Angeles',  offset: -8,  abbreviation: 'PST' },\n        // { timezone: 'America/Metlakatla',  offset: -8,  abbreviation: 'PST' },\n        // { timezone: 'America/Santa_Isabel',  offset: -8,  abbreviation: 'PST' },\n        // { timezone: 'America/Tijuana',  offset: -8,  abbreviation: 'PST' },\n        { timezone: 'America/Vancouver',  offset: -8,  abbreviation: 'PST' },\n        // { timezone: 'America/Whitehorse',  offset: -8,  abbreviation: 'PST' },\n        // { timezone: 'Asia/Manila',  offset: 8,  abbreviation: 'PST' },\n        // { timezone: 'Pacific/Pitcairn',  offset: -8,  abbreviation: 'PST' },\n        { timezone: 'Pacific/Palau',  offset: 9,  abbreviation: 'PWT' },\n        { timezone: 'America/Asuncion',  offset: -3,  abbreviation: 'PYST' },\n        { timezone: 'America/Asuncion',  offset: -4,  abbreviation: 'PYT' },\n        { timezone: 'Asia/Qyzylorda',  offset: 6,  abbreviation: 'QYZT' },\n        { timezone: 'Indian/Reunion',  offset: 4,  abbreviation: 'RET' },\n        { timezone: 'Asia/Sakhalin',  offset: 11,  abbreviation: 'SAKT' },\n        { timezone: 'Europe/Samara',  offset: 4,  abbreviation: 'SAMT' },\n        // { timezone: 'Africa/Johannesburg',  offset: 2,  abbreviation: 'SAST' },\n        { timezone: 'Africa/Mbabane',  offset: 2,  abbreviation: 'SAST' },\n        // { timezone: 'Africa/Maseru',  offset: 2,  abbreviation: 'SAST' },\n        { timezone: 'Pacific/Guadalcanal',  offset: 11,  abbreviation: 'SBT' },\n        { timezone: 'Indian/Mahe',  offset: 4,  abbreviation: 'SCT' },\n        { timezone: 'Asia/Singapore',  offset: 8,  abbreviation: 'SGT' },\n        { timezone: 'Asia/Srednekolymsk',  offset: 11,  abbreviation: 'SRET' },\n        { timezone: 'America/Paramaribo',  offset: -3,  abbreviation: 'SRT' },\n        { timezone: 'Pacific/Midway',  offset: -11,  abbreviation: 'SST' },\n        // { timezone: 'Pacific/Pago_Pago',  offset: -11,  abbreviation: 'SST' },\n        { timezone: 'Pacific/Tahiti',  offset: -10,  abbreviation: 'TAHT' },\n        { timezone: 'Indian/Kerguelen',  offset: 5,  abbreviation: 'TFT' },\n        { timezone: 'Asia/Dushanbe',  offset: 5,  abbreviation: 'TJT' },\n        { timezone: 'Pacific/Fakaofo',  offset: 13,  abbreviation: 'TKT' },\n        { timezone: 'Asia/Dili',  offset: 9,  abbreviation: 'TLT' },\n        { timezone: 'Asia/Ashgabat',  offset: 5,  abbreviation: 'TMT' },\n        { timezone: 'Pacific/Tongatapu',  offset: 13,  abbreviation: 'TOT' },\n        { timezone: 'Pacific/Funafuti',  offset: 12,  abbreviation: 'TVT' },\n        { timezone: 'Asia/Ulaanbaatar',  offset: 9,  abbreviation: 'ULAST' },\n        { timezone: 'Asia/Ulaanbaatar',  offset: 8,  abbreviation: 'ULAT' },\n        { timezone: 'Etc/UTC',  offset: 0,  abbreviation: 'UTC' },\n        { timezone: 'America/Montevideo',  offset: -2,  abbreviation: 'UYST' },\n        { timezone: 'America/Montevideo',  offset: -3,  abbreviation: 'UYT' },\n        { timezone: 'Asia/Samarkand',  offset: 5,  abbreviation: 'UZT' },\n        // { timezone: 'Asia/Tashkent',  offset: 5,  abbreviation: 'UZT' },\n        { timezone: 'America/Caracas',  offset: -4,  abbreviation: 'VET' },\n        { timezone: 'Asia/Vladivostok',  offset: 11,  abbreviation: 'VLAST' },\n        { timezone: 'Asia/Vladivostok',  offset: 10,  abbreviation: 'VLAT' },\n        { timezone: 'Antarctica/Vostok',  offset: 6,  abbreviation: 'VOST' },\n        { timezone: 'Pacific/Efate',  offset: 11,  abbreviation: 'VUT' },\n        { timezone: 'Pacific/Wake',  offset: 12,  abbreviation: 'WAKT' },\n        { timezone: 'Africa/Windhoek',  offset: 2,  abbreviation: 'WAST' },\n        { timezone: 'Africa/Bangui',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Brazzaville',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Douala',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Kinshasa',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Lagos',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Libreville',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Luanda',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Malabo',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Ndjamena',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Niamey',  offset: 1,  abbreviation: 'WAT' },\n        // { timezone: 'Africa/Porto-Novo',  offset: 1,  abbreviation: 'WAT' },\n        { timezone: 'Europe/Lisbon',  offset: 1,  abbreviation: 'WEST' },\n        // { timezone: 'Africa/Casablanca',  offset: 0,  abbreviation: 'WET' },\n        // { timezone: 'Africa/El_Aaiun',  offset: 0,  abbreviation: 'WET' },\n        // { timezone: 'Atlantic/Canary',  offset: 0,  abbreviation: 'WET' },\n        // { timezone: 'Atlantic/Faroe',  offset: 0,  abbreviation: 'WET' },\n        // { timezone: 'Atlantic/Madeira',  offset: 0,  abbreviation: 'WET' },\n        { timezone: 'Europe/Lisbon',  offset: 0,  abbreviation: 'WET' },\n        { timezone: 'Pacific/Wallis',  offset: 12,  abbreviation: 'WFT'},\n        { timezone: 'America/Godthab',  offset: -3,  abbreviation: 'WGT' },\n        // { timezone: 'Asia/Jakarta',  offset: 7,  abbreviation: 'WIB' },\n        { timezone: 'Asia/Pontianak',  offset: 7,  abbreviation: 'WIB' },\n        { timezone: 'Asia/Jayapura',  offset: 9,  abbreviation: 'WIT' },\n        { timezone: 'Asia/Makassar',  offset: 8,  abbreviation: 'WITA' },\n        { timezone: 'Pacific/Apia',  offset: 14,  abbreviation: 'WSDT' },\n        // { timezone: 'Asia/Kashgar',  offset: 6,  abbreviation: 'XJT' },\n        { timezone: 'Asia/Urumqi',  offset: 6,  abbreviation: 'XJT' },\n        { timezone: 'Asia/Yakutsk',  offset: 10,  abbreviation: 'YAKT' },\n        { timezone: 'Asia/Yekaterinburg',  offset: 6,  abbreviation: 'YEKST' },\n        { timezone: 'Asia/Yekaterinburg',  offset: 5,  abbreviation: 'YEKT' }\n    ];\n  }\n}\n\n'ngx-hana-nameserver-history-viewer/src/demo/demo-util.spec.ts'\n:import {getAbbreviationAndOffset, getLocalStorage, getTimeZoneFromTopology, setLocalStorage} from './demo-util';\nimport {DemoService} from './demo-service';\n\ndescribe('demo-util', () => {\n  const service = new DemoService();\n  it('#01 setLocalStorage: should save to local storage if data is not empty ', () => {\n    const name = 'test';\n    const data = 'test1';\n    setLocalStorage(name, data);\n    const dataFromStorage = localStorage.getItem(name);\n    let savedData;\n    if (dataFromStorage != null) {\n       savedData = JSON.parse(dataFromStorage);\n    } else {\n      savedData = undefined;\n    }\n    expect(savedData).toEqual(data);\n  });\n  it('#02 setLocalStorage: should remove the item from local storage if data is empty ', () => {\n    const name = 'test';\n    const data = undefined;\n    setLocalStorage(name, data);\n    expect(localStorage.getItem(name)).toBeFalsy();\n  });\n  it('#03 getLocalStorage: should get the item from local storage if the item is saved to local storage ', () => {\n    const name = 'test';\n    const data = 'test1';\n    localStorage.setItem(name, JSON.stringify(data));\n    expect(getLocalStorage(name)).toEqual(data);\n  });\n  it('#04 getLocalStorage: should return undefined if the item is not saved to local storage ', () => {\n    const name = 'testNew';\n    expect(getLocalStorage(name)).toBeFalsy();\n  });\n  it('#05 getAbbreviationAndOffset: should return abbreviation and offset from the provided topology file content', () => {\n    const content = `\n            ssfs_masterkey_changed=01.01.1970 07:00:00\n            ssfs_masterkey_systempki_changed=01.01.1970 07:00:00\n            start_time=2018-12-01 17:11:10.685\n            timezone_name=+07\n            timezone_offset=25200\n            topology_mem_info=<ok>\n            topology_mem_type=shared\n          pid=36214\n          start_time=2018-12-01 17:11:10.685\n          stonith=yes\n          volume=1\n      preprocessor\n    `;\n    expect(getAbbreviationAndOffset(content)).toEqual({abbreviation: '+07', offset: 7});\n  });\n  it('#06 getAbbreviationAndOffset: should return null for both abbreviation and offset if either abbreviation is missed or offset is null', () => {\n    const content = `\n            ssfs_masterkey_changed=01.01.1970 07:00:00\n            ssfs_masterkey_systempki_changed=01.01.1970 07:00:00\n            start_time=2018-12-01 17:11:10.685\n            timezone1_name=+07\n            timezone_offset=25200\n            topology_mem_info=<ok>\n            topology_mem_type=shared\n          pid=36214\n          start_time=2018-12-01 17:11:10.685\n          stonith=yes\n          volume=1\n      preprocessor\n    `;\n    expect(getAbbreviationAndOffset(content)).toEqual({abbreviation: null, offset: null});\n\n    const content1 = `\n            ssfs_masterkey_changed=01.01.1970 07:00:00\n            ssfs_masterkey_systempki_changed=01.01.1970 07:00:00\n            start_time=2018-12-01 17:11:10.685\n            timezone_name=+07\n            timezone1_offset=25200\n            topology_mem_info=<ok>\n            topology_mem_type=shared\n          pid=36214\n          start_time=2018-12-01 17:11:10.685\n          stonith=yes\n          volume=1\n      preprocessor\n    `;\n    expect(getAbbreviationAndOffset(content1)).toEqual({abbreviation: null, offset: null});\n\n  });\n  it('#07 getTimeZoneFromTopology: should return Etc/GMTxx if abbreviation is number', () => {\n    expect(getTimeZoneFromTopology('+07', 7, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT-7');\n    expect(getTimeZoneFromTopology('-10', 10, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+10');\n    expect(getTimeZoneFromTopology('+00', 0, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+0');\n    expect(getTimeZoneFromTopology('-00', 0, service.getTimezoneAbbrMappings())).toEqual('Etc/GMT+0');\n  });\n  it('#08 getTimeZoneFromTopology: should return timezone directly if abbreviation is a value from standard timezone', () => {\n    expect(getTimeZoneFromTopology('America/New_York', 25200, service.getTimezoneAbbrMappings())).toEqual('America/New_York');\n  });\n  it('#09 getTimeZoneFromTopology: should return the relative timezone directly base on abbreviation and offset', () => {\n    expect(getTimeZoneFromTopology('CST', 8, service.getTimezoneAbbrMappings())).toEqual('Asia/Shanghai');\n    expect(getTimeZoneFromTopology('CST', -6, service.getTimezoneAbbrMappings())).toEqual('America/Chicago');\n    expect(getTimeZoneFromTopology('PST', -8, service.getTimezoneAbbrMappings())).toEqual('America/Vancouver');\n    expect(getTimeZoneFromTopology('PDT', -7, service.getTimezoneAbbrMappings())).toEqual('America/Vancouver');\n  });\n  it('#10 getTimeZoneFromTopology: should return null if can not find the timezone base on abbreviation and offset', () => {\n    expect(getTimeZoneFromTopology('CST', 9, service.getTimezoneAbbrMappings())).toEqual(null);\n    expect(getTimeZoneFromTopology('PST', -7, service.getTimezoneAbbrMappings())).toEqual(null);\n    expect(getTimeZoneFromTopology('PDT', -8, service.getTimezoneAbbrMappings())).toEqual(null);\n  });\n  it('#11 getTimeZoneFromTopology: should return null if abbreviation is null', () => {\n    expect(getTimeZoneFromTopology(null, 9, service.getTimezoneAbbrMappings())).toEqual(null);\n  });\n  it('#12 getTimeZoneFromTopology: should return null if offset is null', () => {\n    expect(getTimeZoneFromTopology('PST', null, service.getTimezoneAbbrMappings())).toEqual(null);\n  });\n});\n\n",
        "called_code_segment": "getTimeZoneFromTopology(abbreviation: string, offset: number, timezoneAbbrMappings: TimeZoneAbbrMapping[]): string {\n    if (abbreviation === null || offset === null) {\n        return null;\n    }\n    if (/^[+-]\\d{2}$/.test(abbreviation)) {\n        return `Etc/GMT${abbreviation}`;\n    }\n    const timezone = timezoneAbbrMappings.find(tz => tz.abbreviation === abbreviation && tz.offset === offset);\n    return timezone ? timezone.timezone : null;\n}",
        "invoking_code_segment": "const { abbreviation, offset } = getAbbreviationAndOffset(content);\nconst timezone = getTimeZoneFromTopology(abbreviation, offset, service.getTimezoneAbbrMappings());",
        "new_file_code_segment": "export function getTimeZoneFromTopologyWithLogging(abbreviation: string, offset: number, timezoneAbbrMappings: TimeZoneAbbrMapping[]): string {\n    const timezone = getTimeZoneFromTopology(abbreviation, offset, timezoneAbbrMappings);\n    console.log(`Timezone abbreviation: ${abbreviation}, offset: ${offset}, resolved timezone: ${timezone}`);\n    return timezone;\n}",
        "feature_description": "Add logging for timezone resolution.",
        "detailed_feature_description": "The new feature adds logging to the timezone resolution process. This will help in debugging and understanding how the timezone is being resolved based on the abbreviation and offset. The logging function is implemented in a new file (#file 3) and is invoked from #file 1 where the timezone resolution happens. The invoking code in #file 2 is updated to use the new logging function.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { getTimeZoneFromTopologyWithLogging } from './file3';\n\nexport function getTimeZoneFromTopology(abbreviation: string, offset: number, timezoneAbbrMappings: TimeZoneAbbrMapping[]): string {\n    if (abbreviation === null || offset === null) {\n        return null;\n    }\n    if (/^[+-]\\d{2}$/.test(abbreviation)) {\n        return `Etc/GMT${abbreviation}`;\n    }\n    const timezone = timezoneAbbrMappings.find(tz => tz.abbreviation === abbreviation && tz.offset === offset);\n    return timezone ? timezone.timezone : null;\n}",
            "#file 2": "//Modify\nimport { getAbbreviationAndOffset, getTimeZoneFromTopologyWithLogging } from './file3';\nimport { DemoService } from './demo-service';\n\nconst service = new DemoService();\nconst { abbreviation, offset } = getAbbreviationAndOffset(content);\nconst timezone = getTimeZoneFromTopologyWithLogging(abbreviation, offset, service.getTimezoneAbbrMappings());",
            "#file 3": "//New\nexport function getTimeZoneFromTopologyWithLogging(abbreviation: string, offset: number, timezoneAbbrMappings: TimeZoneAbbrMapping[]): string {\n    const timezone = getTimeZoneFromTopology(abbreviation, offset, timezoneAbbrMappings);\n    console.log(`Timezone abbreviation: ${abbreviation}, offset: ${offset}, resolved timezone: ${timezone}`);\n    return timezone;\n}\n\nexport function getTimeZoneFromTopology(abbreviation: string, offset: number, timezoneAbbrMappings: TimeZoneAbbrMapping[]): string {\n    if (abbreviation === null || offset === null) {\n        return null;\n    }\n    if (/^[+-]\\d{2}$/.test(abbreviation)) {\n        return `Etc/GMT${abbreviation}`;\n    }\n    const timezone = timezoneAbbrMappings.find(tz => tz.abbreviation === abbreviation && tz.offset === offset);\n    return timezone ? timezone.timezone : null;\n}"
        }
    },
    {
        "repo": "ngx-light-color-picker",
        "content": "'ngx-light-color-picker/src/lib/ngx-light-color-picker.component.ts'\n:import {\n  AfterViewInit, Component, ElementRef, EventEmitter, Input, OnInit, Renderer2, ViewChild, Output, Host,\n  HostListener\n} from '@angular/core';\n\n@Component({\n  selector: 'ngx-light-color-picker',\n  templateUrl: './ngx-light-color-picker.component.html',\n  styleUrls: ['./ngx-light-color-picker.component.scss']\n})\nexport class NgxLightColorPickerComponent implements OnInit, AfterViewInit {\n  @ViewChild('colorPickerCanvas') private canvas: ElementRef;\n  private context: CanvasRenderingContext2D;\n  private color = null;\n  private isMouseDown = false;\n  private selectedColor: boolean;\n  @Input('width') width = 300;\n  @Input('height') height = 300;\n  @Output() private colorSelected: EventEmitter<any> = new EventEmitter<any>();\n  @HostListener('mousedown', ['$event']) mouseDown = this.onMouseDown;\n  @HostListener('mouseup', ['$event']) mouseUp = this.onMouseUp;\n  @HostListener('mousemove', ['$event']) mouseMove = this.onMouseMove;\n\n  @HostListener('touchmove', ['$event']) touchMove = this.onTouchMove;\n\n  constructor(private renderer: Renderer2) {\n  }\n\n  ngOnInit() {\n\n  }\n\n  ngAfterViewInit() {\n    this.pickerDraw();\n  }\n\n  pickerDraw() {\n    this.canvas.nativeElement.width = this.width;\n    this.canvas.nativeElement.height = this.height;\n    this.context = this.canvas.nativeElement.getContext('2d');\n    const colorGradient = this.context.createLinearGradient(0, 0, this.width, 0);\n    colorGradient.addColorStop(0, 'rgb(255,0,0)');\n    colorGradient.addColorStop(0.16, 'rgb(255,0,255)');\n    colorGradient.addColorStop(0.32, 'rgb(0,0,255)');\n    colorGradient.addColorStop(0.48, 'rgb(0,255,255)');\n    colorGradient.addColorStop(0.64, 'rgb(0,255,0)');\n    colorGradient.addColorStop(0.80, 'rgb(255,255,0)');\n    colorGradient.addColorStop(1, 'rgb(255,0,0)');\n    this.context.fillStyle = colorGradient;\n    this.context.fillRect(0, 0, this.width, this.height);\n    const bwGradient = this.context.createLinearGradient(0, 0, 0, this.height);\n    bwGradient.addColorStop(0, 'rgba(255,255,255,1)');\n    bwGradient.addColorStop(0.5, 'rgba(255,255,255,0)');\n    bwGradient.addColorStop(0.5, 'rgba(0,0,0,0)');\n    bwGradient.addColorStop(1, 'rgba(0,0,0,1)');\n    this.context.fillStyle = bwGradient;\n    this.context.fillRect(0, 0, this.width, this.height);\n  }\n\n  onMouseUp(e) {\n    this.isMouseDown = false;\n    this.onMouseMove(e);\n  }\n\n  onMouseDown(e) {\n    this.isMouseDown = true;\n    this.onMouseMove(e);\n  }\n\n  onMouseMove(e) {\n    e.preventDefault();\n    if (this.isMouseDown) {\n      this.onColorSelect(e, this.relativeCoordinates(e));\n    }\n  }\n\n  onTouchMove(e) {\n    e.preventDefault();\n    const touch = e.changedTouches[0];\n    this.onColorSelect(e, this.relativeCoordinates(touch));\n  }\n\n  onColorSelect(e, coords) {\n    const data = this.context.getImageData(coords.x, coords.y, 1, 1).data;\n    this.setColor({\n      r: data[0],\n      g: data[1],\n      b: data[2]\n    });\n  }\n\n  setColor(rgb) {\n\n    // save calculated color\n    this.color = {\n      hex: this.rgbToHex(rgb),\n      rgb: rgb\n    };\n\n    // update element attribute\n    this.canvas.nativeElement.setAttribute('color', this.color.hex);\n    this.colorSelected.emit({\n      detail: {\n        rgb: this.color.rgb,\n        hex: this.color.hex\n      }\n    });\n  }\n\n  rgbToHex(color) {\n    return '#' + this.componentToHex(color.r) + this.componentToHex(color.g) + this.componentToHex(color.b);\n  }\n\n  componentToHex(c) {\n    const hex = c.toString(16);\n    return hex.length === 1 ? '0' + hex : hex;\n  }\n\n  relativeCoordinates(e) {\n    const rect = this.canvas.nativeElement.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const y = e.clientY - rect.top;\n    return {x, y};\n  }\n\n\n  //selected color div\n\n  onColorSelected(e) {\n    this.selectedColor = e.detail.hex;\n  }\n\n  getSelectedColorStyle() {\n    return {\n      'background': this.selectedColor,\n    };\n  }\n}\n\n'ngx-light-color-picker/src/lib/ngx-light-color-picker.module.ts'\n:import { NgModule } from '@angular/core';\nimport { NgxLightColorPickerComponent } from './ngx-light-color-picker.component';\n\n@NgModule({\n  declarations: [NgxLightColorPickerComponent],\n  imports: [\n  ],\n  exports: [NgxLightColorPickerComponent]\n})\nexport class NgxLightColorPickerModule { }\n\n",
        "called_code_segment": "onColorSelected(e) {\n    this.selectedColor = e.detail.hex;\n  }",
        "invoking_code_segment": "this.colorSelected.emit({\n      detail: {\n        rgb: this.color.rgb,\n        hex: this.color.hex\n      }\n    });",
        "new_file_code_segment": "export class ColorUtils {\n  static hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result ? {\n      r: parseInt(result[1], 16),\n      g: parseInt(result[2], 16),\n      b: parseInt(result[3], 16)\n    } : null;\n  }\n}",
        "feature_description": "Add a utility class for color conversion.",
        "detailed_feature_description": "The new feature introduces a utility class `ColorUtils` in a new file (#file 3) that provides a method to convert a hex color code to an RGB object. This utility is then integrated into #file 1 to enhance the color selection functionality. The `onColorSelected` method in #file 1 is modified to use this utility for converting the selected color from hex to RGB format. The `colorSelected` event emitter in #file 2 remains unchanged to maintain compatibility.",
        "modified_complete_code": {
            "#file 1": "//Modify\n  onColorSelected(e) {\n    this.selectedColor = e.detail.hex;\n    const rgbColor = ColorUtils.hexToRgb(this.selectedColor);\n    console.log('Selected RGB Color:', rgbColor);\n  }\n\n  //New\n  import { ColorUtils } from './color-utils';",
            "#file 2": "this.colorSelected.emit({\n      detail: {\n        rgb: this.color.rgb,\n        hex: this.color.hex\n      }\n    });",
            "#file 3": "//New\n  export class ColorUtils {\n    static hexToRgb(hex) {\n      const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n    }\n  }"
        }
    },
    {
        "repo": "ngx-printer-demo",
        "content": "'ngx-printer-demo/src/app/app.component.ts'\n:import { NgxPrinterService } from './../../projects/ngx-printer/src/lib/ngx-printer.service';\nimport { Component, ViewChild, TemplateRef, ElementRef } from '@angular/core';\nimport { Subscription, Observable } from 'rxjs';\nimport { LittleDummyComponent } from './little-dummy/little-dummy.component';\nimport { PrintItem } from 'projects/ngx-printer/src/lib/print-item';\nimport { ngxPrintMarkerPosition } from 'projects/ngx-printer/src/public_api';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  @ViewChild('PrintTemplate')\n  private PrintTemplateTpl: TemplateRef<any>;\n\n  @ViewChild(LittleDummyComponent, { read: ElementRef })\n  PrintComponent: ElementRef;\n\n  title = 'ngx-printer-demo';\n\n  printWindowSubscription: Subscription;\n  $printItems: Observable<PrintItem[]>;\n\n  constructor(private printerService: NgxPrinterService) {\n    this.printWindowSubscription = this.printerService.$printWindowOpen.subscribe(\n      val => {\n        console.log('Print window is open:', val);\n      }\n    );\n\n    this.$printItems = this.printerService.$printItems;\n  }\n\n  checkChanged() {\n    this.printerService.printPreviewOnly = !this.printerService.printPreviewOnly;\n  }\n\n  printDiv() {\n    this.printerService.printDiv('printDiv');\n  }\n\n  printTemplate() {\n    this.printerService.printAngular(this.PrintTemplateTpl);\n  }\n\n  printWindowCurrent() {\n    this.printerService.printCurrentWindow();\n  }\n\n  printTemplateCurrent() {\n    this.printerService.printOpenWindow = false;\n    this.printerService.printAngular(this.PrintTemplateTpl);\n    this.printerService.printOpenWindow = true;\n  }\n\n  printImage() {\n    this.printerService.printOpenWindow = true;\n    this.printerService.printImg('assets/bratwurst.jpg');\n  }\n\n  printImage2() {\n    const printContent = <HTMLImageElement> document.getElementById('imId2');\n    this.printerService.printOpenWindow = true;\n    this.printerService.printImg(printContent.src);\n  }\n\n  printImageCurrent() {\n    this.printerService.printOpenWindow = false;\n    this.printerService.printImg('assets/bratwurst.jpg');\n  }\n\n  printComponent() {\n    this.printerService.printDiv('printDiv');\n  }\n\n  printItem(itemToPrint: PrintItem) {\n    this.printerService.printPrintItem(itemToPrint);\n  }\n\n  printItems() {\n    let itemsToPrint: PrintItem[];\n\n    this.$printItems.subscribe(items => {\n      itemsToPrint = items as PrintItem[];\n    });\n\n    this.printerService.printPrintItems(itemsToPrint);\n  }\n\n  printItemsWithClass() {\n    let itemsToPrint: PrintItem[];\n\n    this.$printItems.subscribe(items => {\n      itemsToPrint = items as PrintItem[];\n    });\n\n    this.printerService.printOpenWindow = true;\n    this.printerService.printPrintItems(itemsToPrint, 'flex-side');\n    // this.printerService.printOpenWindow = true;\n  }\n\n  printItemCurrent(itemToPrint: PrintItem) {\n    this.printerService.printOpenWindow = false;\n    this.printerService.printPrintItem(itemToPrint);\n    this.printerService.printOpenWindow = true;\n  }\n\n  printDivToCurrent() {\n    this.printerService.printOpenWindow = false;\n    this.printerService.printDiv('printDiv');\n    this.printerService.printOpenWindow = true;\n  }\n\n  printHTMLElementToCurrent() {\n    this.printerService.printOpenWindow = false;\n    this.printerService.printHTMLElement(this.PrintComponent.nativeElement);\n    this.printerService.printOpenWindow = true;\n  }\n\n  printHTMLElementToCurrentWithCustomCSS() {\n    this.printerService.printOpenWindow = false;\n    this.printerService.renderClass = 'current-window';\n    this.printerService.printHTMLElement(this.PrintComponent.nativeElement);\n    this.printerService.printOpenWindow = true;\n    this.printerService.renderClass = 'default';\n  }\n\n  printerMarkerClicked() {\n    alert('Print marker clicked');\n  }\n}\n\n'ngx-printer-demo/src/app/app.component.spec.ts'\n:import { TestBed, async } from '@angular/core/testing';\nimport { AppComponent } from './app.component';\nimport { LittleDummyComponent } from './little-dummy/little-dummy.component';\n\ndescribe('AppComponent', () => {\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [\n        AppComponent,\n        LittleDummyComponent\n      ],\n    }).compileComponents();\n  }));\n\n  it('should create the app', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app).toBeTruthy();\n  });\n\n  it(`should have as title 'ngx-printer-demo'`, () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app.title).toEqual('ngx-printer-demo');\n  });\n\n  it('should render title in a h1 tag', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    fixture.detectChanges();\n    const compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain('Welcome to ngx-printer demo-page!');\n  });\n});\n\n",
        "called_code_segment": "printDiv() {\n    this.printerService.printDiv('printDiv');\n  }",
        "invoking_code_segment": "printDiv() {\n    this.printerService.printDiv('printDiv');\n  }",
        "new_file_code_segment": "export class PrintOptions {\n  constructor(public printOpenWindow: boolean = true, public printPreviewOnly: boolean = false) {}\n}\n\nexport class PrintService {\n  private options: PrintOptions;\n\n  constructor(options: PrintOptions) {\n    this.options = options;\n  }\n\n  printDiv(divId: string) {\n    if (this.options.printOpenWindow) {\n      window.print();\n    }\n  }\n}",
        "feature_description": "Add a configurable print option to control whether the print dialog should open in a new window or not.",
        "detailed_feature_description": "The new feature introduces a `PrintOptions` class to encapsulate print settings such as `printOpenWindow` and `printPreviewOnly`. The `PrintService` class is modified to accept these options and use them to control the print behavior. This allows the print functionality to be more flexible and configurable, integrating seamlessly with the existing code in #file 1 and #file 2.",
        "modified_complete_code": {
            "#file 1": "//Modify\nprintDiv() {\n    this.printerService.printDiv('printDiv');\n  }\n\n//New\nprintDivWithOptions(options: PrintOptions) {\n    this.printerService.printDiv('printDiv', options);\n  }",
            "#file 2": "//Modify\nprintDiv() {\n    this.printerService.printDiv('printDiv');\n  }\n\n//New\nprintDivWithOptions() {\n    const options = new PrintOptions(true, false);\n    this.printerService.printDivWithOptions(options);\n  }",
            "#file 3": "export class PrintOptions {\n  constructor(public printOpenWindow: boolean = true, public printPreviewOnly: boolean = false) {}\n}\n\nexport class PrintService {\n  private options: PrintOptions;\n\n  constructor(options: PrintOptions) {\n    this.options = options;\n  }\n\n  printDiv(divId: string, options?: PrintOptions) {\n    if (options) {\n      this.options = options;\n    }\n    if (this.options.printOpenWindow) {\n      window.print();\n    }\n  }\n}"
        }
    },
    {
        "repo": "nody-greeter",
        "content": "'nody-greeter/src/main/bridge/bridge.ts'\n:import { dialog, ipcMain } from \"electron\";\nimport * as gi from \"node-gtk\";\nimport * as fs from \"fs\";\nimport * as os from \"os\";\nimport { globalNodyConfig, WebGreeterConfig } from \"../config\";\n\nconst LightDM = gi.require(\"LightDM\", \"1\");\n\nconst LightDMGreeter = new LightDM.Greeter();\nconst LightDMUsers = new LightDM.UserList();\n\nimport {\n  userToObject,\n  languageToObject,\n  layoutToObject,\n  sessionToObject,\n  batteryToObject,\n} from \"./bridge_objects\";\nimport { browser, generalErrorPrompt } from \"../globals\";\n\nimport { brightnessController } from \"../utils/brightness.js\";\nimport { BatteryController } from \"../utils/battery\";\nimport { forceScreensaver, resetScreensaver } from \"../utils/screensaver.js\";\nimport * as path from \"path\";\nimport {\n  LightDMBattery,\n  LightDMLanguage,\n  LightDMLayout,\n  LightDMSession,\n  LightDMUser,\n} from \"common/ldm_interfaces\";\nimport { logger } from \"../logger\";\nimport { CONSTS } from \"common/consts\";\n\nexport class Greeter {\n  // TODO: Remove this eslint-disable comment\n  /* eslint-disable @typescript-eslint/naming-convention */\n\n  public _config: WebGreeterConfig;\n  public _batteryController: BatteryController;\n  public _sharedDataDirectory: string;\n  public static _instance: Greeter;\n\n  private constructor(config: WebGreeterConfig) {\n    this._config = config;\n\n    this._batteryController = new BatteryController();\n\n    try {\n      //LightDMGreeter.setResettable(true);\n      LightDMGreeter.connectToDaemonSync();\n    } catch (exception) {\n      const err = exception as NodeJS.ErrnoException;\n      logger.error(err.stack ?? \"\");\n      browser.whenReady().then(() => {\n        dialog.showMessageBoxSync(browser.primaryWindow, {\n          message:\n            \"Detected a problem that could interfere with the system login process\", // Yeah, that problematic message\n          detail: `LightDM: ${err}\\nYou can continue without major problems, but you won't be able to log in`,\n          type: \"error\",\n          title: \"An error ocurred\",\n          buttons: [\"Okay\"],\n        });\n      });\n    }\n\n    this._connectSignals();\n\n    const user = LightDMUsers.getUsers()[0];\n    const userDataDir = LightDMGreeter.ensureSharedDataDirSync(user.name);\n    this._sharedDataDirectory = userDataDir.slice(\n      0,\n      userDataDir.lastIndexOf(\"/\")\n    );\n\n    if (LightDMGreeter.getLockHint()) forceScreensaver(true);\n\n    logger.debug(\"LightDM API connected\");\n  }\n\n  private _connectSignals(): void {\n    LightDMGreeter.connect(\"authentication-complete\", () => {\n      this._emitSignal(\"authentication-complete\");\n    });\n    LightDMGreeter.connect(\"autologin-timer-expired\", () => {\n      this._emitSignal(\"autologin-timer-expired\");\n    });\n    LightDMGreeter.connect(\"show-message\", (text: string, type: number) => {\n      this._emitSignal(\"show-message\", text, type);\n    });\n    LightDMGreeter.connect(\"show-prompt\", (text: string, type: number) => {\n      this._emitSignal(\"show-prompt\", text, type);\n    });\n    LightDMGreeter.connect(\"idle\", () => {\n      this._emitSignal(\"idle\");\n    });\n    LightDMGreeter.connect(\"reset\", () => {\n      this._emitSignal(\"reset\");\n    });\n  }\n\n  public _emitSignal(signal: string, ...args: unknown[]): void {\n    //console.log(\"SIGNAL EMITTED\", signal, args)\n    for (const win of browser.windows) {\n      win.window.webContents.send(\n        CONSTS.channel.lightdm_signal,\n        signal,\n        ...args\n      );\n    }\n  }\n\n  public static getInstance(config: WebGreeterConfig): Greeter {\n    return this._instance || (this._instance = new this(config));\n  }\n\n  /**\n   * The username of the user being authenticated or \"null\"\n   * if no authentication is in progress\n   * @readonly\n   */\n  public get authentication_user(): string | null {\n    return LightDMGreeter.getAuthenticationUser() || null;\n  }\n\n  /**\n   * Whether or not the guest account should be automatically logged\n   * into when the timer expires.\n   * @readonly\n   */\n  public get autologin_guest(): boolean {\n    return LightDMGreeter.getAutologinGuestHint();\n  }\n\n  /**\n   * The number of seconds to wait before automatically logging in.\n   * @readonly\n   */\n  public get autologin_timeout(): number {\n    return LightDMGreeter.getAutologinTimeoutHint();\n  }\n\n  /**\n   * The username with which to automattically log in when the timer expires.\n   * @readonly\n   */\n  public get autologin_user(): string {\n    return LightDMGreeter.getAutologinUserHint();\n  }\n\n  /**\n   * Gets the battery data.\n   * @readonly\n   * @deprecated Use `battery_data`\n   */\n  public get batteryData(): LightDMBattery | null {\n    return batteryToObject(this._batteryController);\n  }\n\n  /**\n   * Gets the battery data.\n   * @readonly\n   */\n  public get battery_data(): LightDMBattery | null {\n    return batteryToObject(this._batteryController);\n  }\n\n  /**\n   * Gets the brightness\n   */\n  public get brightness(): number {\n    return brightnessController.getBrightness();\n  }\n  /**\n   * Sets the brightness\n   * @param {number} quantity The quantity to set\n   */\n  public set brightness(quantity: number) {\n    brightnessController.setBrightness(quantity);\n  }\n\n  /**\n   * Whether or not the greeter can access to battery data.\n   * @readonly\n   */\n  public get can_access_battery(): boolean {\n    return this._config.features.battery;\n  }\n\n  /**\n   * Whether or not the greeter can control display brightness.\n   * @readonly\n   */\n  public get can_access_brightness(): boolean {\n    return this._config.features.backlight.enabled;\n  }\n\n  /**\n   * Whether or not the greeter can make the system hibernate.\n   * @readonly\n   */\n  public get can_hibernate(): boolean {\n    return LightDM.getCanHibernate();\n  }\n\n  /**\n   * Whether or not the greeter can make the system restart.\n   * @readonly\n   */\n  public get can_restart(): boolean {\n    return LightDM.getCanRestart();\n  }\n\n  /**\n   * Whether or not the greeter can make the system shutdown.\n   * @readonly\n   */\n  public get can_shutdown(): boolean {\n    return LightDM.getCanShutdown();\n  }\n\n  /**\n   * Whether or not the greeter can make the system suspend/sleep.\n   * @readonly\n   */\n  public get can_suspend(): boolean {\n    return LightDM.getCanSuspend();\n  }\n\n  /**\n   * The name of the default session.\n   * @readonly\n   */\n  public get default_session(): string {\n    return LightDMGreeter.getDefaultSessionHint();\n  }\n\n  /**\n   * Whether or not guest sessions are supported.\n   * @readonly\n   */\n  public get has_guest_account(): boolean {\n    return LightDMGreeter.getHasGuestAccountHint();\n  }\n\n  /**\n   * Whether or not user accounts should be hidden.\n   * @readonly\n   */\n  public get hide_users_hint(): boolean {\n    return LightDMGreeter.getHideUsersHint();\n  }\n\n  /**\n   * The system's hostname.\n   * @readonly\n   */\n  public get hostname(): string {\n    return LightDM.getHostname();\n  }\n\n  /**\n   * Whether or not the greeter is in the process of authenticating.\n   * @readonly\n   */\n  public get in_authentication(): boolean {\n    return LightDMGreeter.getInAuthentication();\n  }\n\n  /**\n   * Whether or not the greeter has successfully authenticated.\n   * @readonly\n   */\n  public get is_authenticated(): boolean {\n    return LightDMGreeter.getIsAuthenticated();\n  }\n\n  /**\n   * The current language or \"null\" if no language.\n   * @readonly\n   */\n  public get language(): LightDMLanguage | null {\n    return languageToObject(LightDM.getLanguage());\n  }\n\n  /**\n   * A list of languages to present to the user.\n   * @readonly\n   */\n  public get languages(): LightDMLanguage[] {\n    return reduceArray(LightDM.getLanguages(), languageToObject).filter(\n      isDefined\n    );\n  }\n\n  /**\n   * The currently active layout for the selected user.\n   */\n  public get layout(): LightDMLayout | null {\n    return layoutToObject(LightDM.getLayout());\n  }\n\n  public set layout(layout: LightDMLayout | null) {\n    if (layout) {\n      LightDM.getLayout();\n      LightDM.setLayout(\n        new LightDM.Layout({\n          name: layout.name,\n          description: layout.description,\n          short_description: layout.short_description,\n        })\n      );\n    }\n  }\n\n  /**\n   * A list of keyboard layouts to present to the user.\n   * @readonly\n   */\n  public get layouts(): LightDMLayout[] {\n    return reduceArray(LightDM.getLayouts(), layoutToObject).filter(isDefined);\n  }\n\n  /**\n   * Whether or not the greeter was started as a lock screen.\n   * @readonly\n   */\n  public get lock_hint(): boolean {\n    return LightDMGreeter.getLockHint();\n  }\n\n  /**\n   * A list of remote sessions.\n   * @readonly\n   */\n  public get remote_sessions(): LightDMSession[] {\n    return reduceArray(LightDM.getRemoteSessions(), sessionToObject).filter(\n      isDefined\n    );\n  }\n\n  /**\n   * Whether or not the guest account should be selected by default.\n   * @readonly\n   */\n  public get select_guest_hint(): boolean {\n    return LightDMGreeter.getSelectGuestHint();\n  }\n\n  /**\n   * The username to select by default.\n   * @readonly\n   */\n  public get select_user_hint(): string {\n    return LightDMGreeter.getSelectUserHint();\n  }\n\n  /**\n   * List of available sessions.\n   * @readonly\n   */\n  public get sessions(): LightDMSession[] {\n    return reduceArray(LightDM.getSessions(), sessionToObject).filter(\n      isDefined\n    );\n  }\n\n  /**\n   * LightDM shared data directory\n   * @readonly\n   */\n  public get shared_data_directory(): string {\n    return this._sharedDataDirectory;\n  }\n\n  /**\n   * Check if a manual login option should be shown. If \"true\", the theme should\n   * provide a way for a username to be entered manually. Otherwise, themes that show\n   * a user list may limit logins to only those users.\n   * @readonly\n   */\n  public get show_manual_login_hint(): boolean {\n    return LightDMGreeter.getShowManualLoginHint();\n  }\n\n  /**\n   * Check if a remote login option should be shown. If \"true\", the theme should provide\n   * a way for a user to log into a remote desktop server.\n   * @readonly\n   * @internal\n   */\n  public get show_remote_login_hint(): boolean {\n    return LightDMGreeter.getShowRemoteLoginHint();\n  }\n\n  /**\n   * List of available users.\n   * @readonly\n   */\n  public get users(): LightDMUser[] {\n    return reduceArray(LightDMUsers.getUsers(), userToObject).filter(isDefined);\n  }\n\n  /**\n   * Starts the authentication procedure for a user.\n   * @param {string|null} username A username or \"null\" to prompt for a username.\n   */\n  public authenticate(username: string | null): boolean {\n    return LightDMGreeter.authenticate(username);\n  }\n\n  /**\n   * Starts the authentication procedure for the guest user.\n   */\n  public authenticate_as_guest(): boolean {\n    return LightDMGreeter.authenticateAsGuest();\n  }\n\n  /**\n   * Set the brightness to quantity\n   * @param {number} quantity The quantity to set\n   * @deprecated Use `brightness_set`\n   */\n  public brightnessSet(quantity: number): void {\n    return brightnessController.setBrightness(quantity);\n  }\n  /**\n   * Set the brightness to quantity\n   * @param {number} quantity The quantity to set\n   */\n  public brightness_set(quantity: number): void {\n    return brightnessController.setBrightness(quantity);\n  }\n\n  /**\n   * Increase the brightness by quantity\n   * @param {number} quantity The quantity to increase\n   * @deprecated Use `brightness_increase`\n   */\n  public brightnessIncrease(quantity: number): void {\n    return brightnessController.incBrightness(quantity);\n  }\n  /**\n   * Increase the brightness by quantity\n   * @param {number} quantity The quantity to increase\n   */\n  public brightness_increase(quantity: number): void {\n    return brightnessController.incBrightness(quantity);\n  }\n\n  /**\n   * Decrease the brightness by quantity\n   * @param {number} quantity The quantity to decrease\n   * @deprecated Use `brightness_decrease`\n   */\n  public brightnessDecrease(quantity: number): void {\n    return brightnessController.decBrightness(quantity);\n  }\n  /**\n   * Decrease the brightness by quantity\n   * @param {number} quantity The quantity to decrease\n   */\n  public brightness_decrease(quantity: number): void {\n    return brightnessController.decBrightness(quantity);\n  }\n\n  /**\n   * Cancel user authentication that is currently in progress.\n   */\n  public cancel_authentication(): boolean {\n    return LightDMGreeter.cancelAuthentication();\n  }\n\n  /**\n   * Cancel the automatic login.\n   */\n  public cancel_autologin(): boolean {\n    return LightDMGreeter.cancelAutologin();\n  }\n\n  /**\n   * Triggers the system to hibernate.\n   * @returns {boolean} \"true\" if hibernation initiated, otherwise \"false\"\n   */\n  public hibernate(): boolean {\n    return LightDM.hibernate();\n  }\n\n  /**\n   * Provide a response to a prompt.\n   * @param {string} response\n   */\n  public respond(response: string): boolean {\n    return LightDMGreeter.respond(response);\n  }\n\n  /**\n   * Triggers the system to restart.\n   * @returns {boolean} \"true\" if restart initiated, otherwise \"false\"\n   */\n  public restart(): boolean {\n    return LightDM.restart();\n  }\n\n  /**\n   * Set the language for the currently authenticated user.\n   * @param {string} language The language in the form of a locale specification (e.g.\n   *     'de_DE.UTF-8')\n   * @returns {boolean} \"true\" if successful, otherwise \"false\"\n   */\n  public set_language(language: string): boolean {\n    if (this.is_authenticated) {\n      return LightDMGreeter.setLanguage(language);\n    }\n    return false;\n  }\n\n  /**\n   * Triggers the system to shutdown.\n   * @returns {boolean} \"true\" if shutdown initiated, otherwise \"false\"\n   */\n  public shutdown(): boolean {\n    return LightDM.shutdown();\n  }\n\n  /**\n   * Start a session for the authenticated user.\n   * @param {string|null} session The session to log into or \"null\" to use the default.\n   * @returns {boolean} \"true\" if successful, otherwise \"false\"\n   */\n  public start_session(session: string | null): boolean {\n    try {\n      const started = LightDMGreeter.startSessionSync(session);\n      if (started || this.is_authenticated) resetScreensaver();\n      return started;\n    } catch (exception) {\n      const err = exception as NodeJS.ErrnoException;\n      logger.error(err.stack ?? \"\");\n      generalErrorPrompt(\n        browser.primaryWindow,\n        \"LightDM couldn't start session\",\n        `The provided session: \"${session}\" couldn't be started\\n${err.message}`,\n        \"An error ocurred\"\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Triggers the system to suspend/sleep.\n   * @returns {boolean} \"true\" if suspend/sleep initiated, otherwise \"false\"\n   */\n  public suspend(): boolean {\n    return LightDM.suspend();\n  }\n}\n\nfunction getLayouts(configLayouts: string[]): LightDMLayout[] {\n  const layouts = LightDM.getLayouts();\n  const final: LightDMLayout[] = [];\n  for (const ldmLay of layouts) {\n    for (let confLay of configLayouts) {\n      confLay = confLay.replace(/\\s/g, \"\\t\");\n      if (ldmLay.getName() == confLay) {\n        const layChips = layoutToObject(ldmLay);\n        if (!layChips) continue;\n        final.push(layChips);\n      }\n    }\n  }\n  return final;\n}\n\nexport class GreeterConfig {\n  public _config: WebGreeterConfig;\n  public static _instance: GreeterConfig;\n\n  private constructor(config: WebGreeterConfig) {\n    this._config = config;\n  }\n\n  public static getInstance(config: WebGreeterConfig): GreeterConfig {\n    return this._instance || (this._instance = new this(config));\n  }\n\n  /**\n   * Holds keys/values from the `branding` section of the config file.\n   *\n   * @type {object} branding\n   * @property {string} background_images_dir Path to directory that contains background images\n   *                                      for use in greeter themes.\n   * @property {string} logo                  Path to distro logo image for use in greeter themes.\n   * @property {string} user_image            Default user image/avatar. This is used by greeter themes\n   *                                      for users that have not configured a `.face` image.\n   * @readonly\n   */\n  public get branding(): WebGreeterConfig[\"branding\"] {\n    return this._config.branding;\n  }\n\n  /**\n   * Holds keys/values from the `greeter` section of the config file.\n   *\n   * @type {object}  greeter\n   * @property {boolean} debug_mode          Greeter theme debug mode.\n   * @property {boolean} detect_theme_errors Provide an option to load a fallback theme when theme errors are detected.\n   * @property {number}  screensaver_timeout Blank the screen after this many seconds of inactivity.\n   * @property {boolean} secure_mode         Don't allow themes to make remote http requests.\n   * @property {string}  time_language       Language to use when displaying the time or \"\" to use the system's language.\n   * @property {string}  theme               The name of the theme to be used by the greeter.\n   * @readonly\n   */\n  public get greeter(): WebGreeterConfig[\"greeter\"] {\n    return this._config.greeter;\n  }\n\n  /**\n   * Holds keys/values from the `features` section of the config file.\n   *\n   * @type {object}      features\n   * @property {boolean} battery    Enable greeter and themes to ger battery status.\n   * @property {object}  backlight\n   * @property {boolean} enabled    Enable greeter and themes to control display backlight.\n   * @property {number}  value      The amount to increase/decrease brightness by greeter.\n   * @property {number}  steps      How many steps are needed to do the change.\n   */\n  public get features(): WebGreeterConfig[\"features\"] {\n    return this._config.features;\n  }\n\n  /*\n   * Holds a list of preferred layouts from the `layouts` section of the config file.\n   * @type {Array}      layouts\n   * @readonly\n   */\n  public get layouts(): LightDMLayout[] {\n    return getLayouts(this._config.layouts);\n  }\n}\n\nexport class ThemeUtils {\n  public _config: WebGreeterConfig;\n  public _allowedDirs: string[];\n  public static _instance: ThemeUtils;\n\n  private constructor(config: WebGreeterConfig) {\n    this._config = config;\n\n    this._allowedDirs = [\n      globalNodyConfig.app.themeDir,\n      globalNodyConfig.config.branding.background_images_dir,\n      global.lightdmGreeter.shared_data_directory,\n      path.dirname(fs.realpathSync(globalNodyConfig.config.greeter.theme)),\n      os.tmpdir(),\n    ];\n  }\n\n  public static getInstance(config: WebGreeterConfig): ThemeUtils {\n    return this._instance || (this._instance = new this(config));\n  }\n\n  /**\n   * Returns the contents of directory found at `path` provided that the (normalized) `path`\n   * meets at least one of the following conditions:\n   *   * Is located within the greeter themes' root directory.\n   *   * Has been explicitly allowed in the greeter's config file.\n   *   * Is located within the greeter's shared data directory (`/var/lib/lightdm-data`).\n   *   * Is located in `/tmp`.\n   *\n   * @param dirPath The abs path to the desired directory.\n   * @param onlyImages Include only images in the results. Default `true`.\n   */\n  public dirlist(dirPath: string, onlyImages = true): string[] {\n    if (!dirPath || typeof dirPath !== \"string\" || dirPath === \"/\") {\n      return [];\n    }\n    if (dirPath.startsWith(\"./\")) {\n      dirPath = path.join(path.dirname(this._config.greeter.theme), dirPath);\n    }\n\n    try {\n      dirPath = fs.realpathSync(path.normalize(dirPath));\n    } catch (e) {\n      return [];\n    }\n\n    if (!path.isAbsolute(dirPath) || !fs.lstatSync(dirPath).isDirectory()) {\n      return [];\n    }\n\n    let allowed = false;\n\n    for (let i = 0; i < this._allowedDirs.length; i++) {\n      if (dirPath.startsWith(this._allowedDirs[i])) {\n        allowed = true;\n        break;\n      }\n    }\n\n    if (!allowed) {\n      logger.error(`Path \"${dirPath}\" is not allowed`);\n      return [];\n    }\n\n    const files = fs.readdirSync(dirPath, { withFileTypes: true });\n    let result = [];\n\n    if (onlyImages) {\n      result = files.reduce((cb: string[], v) => {\n        // This only returns files inside path, not recursively\n        if (v.isFile() && v.name.match(/.+\\.(jpe?g|png|gif|bmp|webp)/)) {\n          cb.push(path.join(dirPath, v.name));\n        }\n        return cb;\n      }, []);\n    } else {\n      result = files.reduce((cb: string[], v) => {\n        cb.push(path.join(dirPath, v.name));\n        return cb;\n      }, []);\n    }\n    //console.log(dir_path, result);\n    return result;\n  }\n}\n\nfunction reduceArray<I, O>(arr: I[], func: (arg: I) => O): O[] {\n  if (!Array.isArray(arr)) return [];\n  return arr.reduce((acc: O[], val) => {\n    const v = func(val);\n    acc.push(v);\n    return acc;\n  }, []);\n}\n\nfunction isDefined<T>(val: T | null | undefined): val is T {\n  return val !== null && val !== undefined;\n}\n\nfunction hasKey<T extends object>(obj: T, key: PropertyKey): key is keyof T {\n  return key in obj;\n}\n\nfunction handler(\n  accesor: Greeter | GreeterConfig | ThemeUtils,\n  ...args: string[]\n): unknown {\n  if (args.length == 0) {\n    return undefined;\n  }\n  const descriptors = Object.getOwnPropertyDescriptors(\n    Object.getPrototypeOf(accesor)\n  );\n  const param = args[0];\n  args.shift();\n  if (!hasKey(accesor, param)) {\n    return undefined;\n  }\n  const pr: unknown = accesor[param];\n  const ac = descriptors[param];\n\n  let value = undefined;\n\n  if (typeof pr === \"function\") {\n    const func: (...v: unknown[]) => unknown = pr.bind(accesor);\n    value = func(...args);\n  } else {\n    if (args.length > 0 && ac && ac.set) {\n      ac.set(args[0]);\n    } else {\n      value = pr || undefined;\n    }\n  }\n  //console.log({\n  //accesor: accesor.constructor.name,\n  //result: value,\n  //args,\n  //param,\n  //});\n  return value;\n}\n\nipcMain.on(\"greeter_config\", (ev, ...args) => {\n  if (args.length == 0) return (ev.returnValue = undefined);\n  if (!hasKey(global.greeterConfigGreeter, args[0]))\n    return (ev.returnValue = undefined);\n  const pr = global.greeterConfigGreeter[args[0]];\n  ev.returnValue = pr || undefined;\n});\n\nipcMain.on(\"theme_utils\", (ev, ...args) => {\n  const value = handler(global.themeUtilsGreeter, ...args);\n  ev.returnValue = value;\n});\n\nipcMain.handle(\"theme_utils\", (_ev, ...args) => {\n  return handler(global.themeUtilsGreeter, ...args);\n});\n\nipcMain.on(\"lightdm\", (ev, ...args) => {\n  const value = handler(global.lightdmGreeter, ...args);\n  ev.returnValue = value;\n});\n\nipcMain.on(CONSTS.channel.window_metadata, (ev) => {\n  /**\n   * A request on this channel simply means that a browser window is ready to\n   * receive metadata (i.e. on initial load or a refresh)\n   */\n  for (const window of browser.windows) {\n    if (window.window.webContents === ev.sender) {\n      window.window.webContents.send(\n        CONSTS.channel.window_metadata,\n        window.meta\n      );\n    }\n  }\n});\n\nipcMain.on(CONSTS.channel.window_broadcast, (ev, data: unknown) => {\n  const sendingWindow = browser.windows.find(\n    (w) => w.window.webContents === ev.sender\n  );\n  if (!sendingWindow) {\n    throw new Error(`Unable to find window for event ${ev}`);\n  }\n  for (const window of browser.windows) {\n    window.window.webContents.send(\n      CONSTS.channel.window_broadcast,\n      sendingWindow.meta,\n      data\n    );\n  }\n});\n\nbrowser.whenReady().then(() => {\n  global.lightdmGreeter = Greeter.getInstance(globalNodyConfig.config);\n  global.greeterConfigGreeter = GreeterConfig.getInstance(\n    globalNodyConfig.config\n  );\n  global.themeUtilsGreeter = ThemeUtils.getInstance(globalNodyConfig.config);\n});\n\n'nody-greeter/src/global.d.ts'\n:import { Greeter, GreeterConfig, ThemeUtils } from \"./main/bridge/bridge\";\n\ndeclare global {\n  /* eslint-disable no-var */\n  var lightdmGreeter: Greeter;\n  var greeterConfigGreeter: GreeterConfig;\n  var themeUtilsGreeter: ThemeUtils;\n}\nexport {};\n\n",
        "called_code_segment": "ipcMain.on('greeter_config', (ev, ...args) => {\n  if (args.length == 0) return (ev.returnValue = undefined);\n  if (!hasKey(global.greeterConfigGreeter, args[0]))\n    return (ev.returnValue = undefined);\n  const pr = global.greeterConfigGreeter[args[0]];\n  ev.returnValue = pr || undefined;\n});",
        "invoking_code_segment": "browser.whenReady().then(() => {\n  global.lightdmGreeter = Greeter.getInstance(globalNodyConfig.config);\n  global.greeterConfigGreeter = GreeterConfig.getInstance(globalNodyConfig.config);\n  global.themeUtilsGreeter = ThemeUtils.getInstance(globalNodyConfig.config);\n});",
        "new_file_code_segment": "export function getGreeterConfig(config: WebGreeterConfig): GreeterConfig {\n  return GreeterConfig.getInstance(config);\n}\n\nexport function getThemeUtils(config: WebGreeterConfig): ThemeUtils {\n  return ThemeUtils.getInstance(config);\n}",
        "feature_description": "Add a new feature to log the configuration settings when the greeter is initialized.",
        "detailed_feature_description": "The new feature involves logging the configuration settings of the greeter when it is initialized. This is achieved by creating a new file (#file 3) that exports functions to get instances of GreeterConfig and ThemeUtils. These functions are then invoked in #file 1 and #file 2 to log the configuration settings. This ensures that the configuration settings are logged consistently across the application.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { getGreeterConfig, getThemeUtils } from './new_file';\n\n//Modify\nipcMain.on('greeter_config', (ev, ...args) => {\n  if (args.length == 0) return (ev.returnValue = undefined);\n  if (!hasKey(global.greeterConfigGreeter, args[0]))\n    return (ev.returnValue = undefined);\n  const pr = global.greeterConfigGreeter[args[0]];\n  ev.returnValue = pr || undefined;\n});\n\n//Modify\nbrowser.whenReady().then(() => {\n  global.lightdmGreeter = Greeter.getInstance(globalNodyConfig.config);\n  global.greeterConfigGreeter = getGreeterConfig(globalNodyConfig.config);\n  global.themeUtilsGreeter = getThemeUtils(globalNodyConfig.config);\n  console.log('Greeter Configuration:', global.greeterConfigGreeter);\n});",
            "#file 2": "//Modify\nimport { getGreeterConfig, getThemeUtils } from './new_file';\n\n//Modify\nbrowser.whenReady().then(() => {\n  global.lightdmGreeter = Greeter.getInstance(globalNodyConfig.config);\n  global.greeterConfigGreeter = getGreeterConfig(globalNodyConfig.config);\n  global.themeUtilsGreeter = getThemeUtils(globalNodyConfig.config);\n  console.log('Greeter Configuration:', global.greeterConfigGreeter);\n});",
            "#file 3": "//New\nexport function getGreeterConfig(config: WebGreeterConfig): GreeterConfig {\n  return GreeterConfig.getInstance(config);\n}\n\n//New\nexport function getThemeUtils(config: WebGreeterConfig): ThemeUtils {\n  return ThemeUtils.getInstance(config);\n}"
        }
    },
    {
        "repo": "ap-groups",
        "content": "'ap-groups/components/base-css.ts'\n:import { css } from 'lit';\n\nexport const baseCss = css`\n  * {\n    box-sizing: border-box;\n    overflow-wrap: break-word;\n    word-wrap: break-word;\n    word-break: break-word;\n  }\n\n  h1 {\n    text-align: center;\n  }\n\n  h1,\n  h2 {\n    font-weight: normal;\n    margin: 0;\n  }\n\n  img {\n    max-width: 100%;\n  }\n\n  p {\n    margin: 0;\n  }\n  \n  p + p {\n    margin-top: 1em;\n  }\n\n  code {\n    font-size: 1.125em;\n    font-family: monospace;\n  }\n\n  a {\n    color: var(--link-color);\n  }\n\n  .region a {\n    font-weight: bold;\n  }\n\n  button {\n    appearance: none;\n    padding: 0;\n    margin: 0;\n    border: 0;\n    border-radius: 0;\n    font: inherit;\n    line-height: inherit;\n    background: transparent;\n    display: inline-flex;\n    min-height: 48px;\n    min-width: 48px;\n    place-items: center;\n    place-content: center;\n    cursor: pointer;\n  }\n\n  textarea,\n  input {\n    font: inherit;\n    line-height: inherit;\n    width: 100%;\n  }\n\n  .textarea,\n  .input {\n    padding: .5em;\n    border: 1px solid;\n    border-radius: 0;\n    font-size: .875em;\n    font-weight: normal;\n    background-color: var(--dark-background-color);\n    color: var(--text-on-dark-background-color);\n  }\n\n  .button {\n    background-color: var(--light-background-color);\n    color: var(--text-on-light-background-color);\n    border-radius: 0;\n    font-size: 1.125em;\n    padding: .5em .875em;\n    max-width: max-content;\n    border: 1px solid;\n  }\n\n  .button--tag {\n    font-size: .95em;\n    padding: 4px 8px;\n    min-height: 32px;\n    min-width: 32px;\n  }\n  \n  .button--cta {\n    font-size: 1.5em;\n    font-weight: bold;\n    background: var(--accent-color);\n    color: var(--text-on-accent-color);\n  }\n\n  .label {\n    display: flex;\n    flex-direction: column;\n    font-size: 1.25em;\n    padding-bottom: 12px;\n    border-bottom: 1px solid;\n    margin-bottom: 12px;\n  }\n\n  .label-text {\n    display: block;\n    padding: 6px 0;\n  }\n\n  .error-message {\n    color: var(--error-color);\n    font-size: .875em;\n    display: block;\n    padding: 6px;\n    font-weight: bold;\n  }\n\n  .hint-text {\n    padding: 6px;\n    font-size: .75em;\n  }\n\n  .toggle-button {\n    width: auto;\n    appearance: none;\n    background: gray;\n    width: 60px;\n    height: 30px;\n    border-radius: 0;\n    position: relative;\n  }\n\n  .toggle-button:after {\n    content: '';\n    background: var(--primary-color);\n    position: absolute;\n    top: 4px;\n    left: 4px;\n    height: calc(100% - 8px);\n    width: calc(50% - 8px);\n    border-radius: 0;\n  }\n\n  .toggle-button:checked {\n    background: var(--accent-color);\n  }\n\n  .toggle-button:checked:after {\n    left: unset;\n    right: 4px;\n  }\n\n  .regions {\n    display: grid;\n  }\n\n  .region {\n    padding: 32px;\n    border-radius: 0;\n    background-color: var(--dark-background-color);\n    color: var(--text-on-dark-background-color);\n    width: 100%;\n    border: 1px solid;\n    font-size: 1.125em;\n  }\n\n  .eyebrow {\n    text-transform: uppercase;\n    font-size: .75em;\n    letter-spacing: .1ch;\n  }\n\n  .avatar {\n    overflow: hidden;\n    display: inline-flex;\n  }\n\n  .avatar--small {\n    border-radius: 0;\n    height: 70px;\n    width: 70px;\n    background: var(--accent-color);\n  }\n\n  .permalink {\n    display: block;\n    font-size: .75em;\n    text-align: center;\n  }\n\n  .actor-lockup {\n    display: inline-flex;\n    flex-direction: column;\n    text-align: center;\n    place-items: center;\n    place-content: center;\n    border: 1px solid lightgray;\n    border-radius: 0;\n    padding: 8px;\n    aspect-ratio: 1;\n  }\n\n  .actor-lockup:not(:hover) {\n    text-decoration: none;\n  }\n\n  .actor-username {\n    display: block;\n    color: var(--medium-background-color);\n    font-weight: bold;\n  }\n\n  .actor-hostname {\n    display: block;\n    font-size: .75em;\n  }\n`;\n'ap-groups/components/group-entity-details.ts'\n:import {LitElement, html, css, nothing} from 'lit';\nimport {customElement, property, query} from 'lit/decorators';\nimport { repeat } from 'lit/directives/repeat';\nimport { baseCss } from './base-css';\nimport { AP } from 'activitypub-core-types';\nimport { unsafeHTML } from 'lit/directives/unsafe-html';\n\n@customElement('group-entity-details')\nexport class GroupEntityDetails extends LitElement {\n  static styles = [baseCss, css`\n    :host {\n      display: block;\n    }\n    .avatar {\n      max-width: 200px;\n    }\n  `];\n\n  @property({type: String, attribute: 'entity-id'})\n  private entityId?: string;\n\n  @property({ type: Object })\n  private entity: AP.Actor | null = null;\n\n  @property({ type: Boolean })\n  private isDeleted = false;\n\n  override firstUpdated() {\n    const url = new URL(this.entityId);\n    const isLocal = url.hostname === window.location.hostname;\n\n    fetch(isLocal ? this.entityId : `/proxy?resource=${this.entityId}`, {\n      headers: {\n        'Accept': 'application/activity+json'\n      }\n    })\n      .then(res => res.json())\n      .then(entity => {\n        this.entity = entity;\n      })\n      .catch(() => {\n        this.isDeleted = true;\n      });\n  }\n\n\n  render() {\n    if (this.isDeleted) {\n      return html`\n        Deleted.\n      `;\n    }\n\n    if (!this.entity) {\n      return html`\n        Loading...\n      `;\n    }\n\n    return html`\n      <dl role=\"table\">\n        <div role=\"row\">\n          <dt>\n            Avatar\n          </dt>\n          <dd>\n            ${(this.entity.icon && 'url' in this.entity.icon) ? html`\n              <a href=${this.entity.url}>\n                <img\n                  class=\"avatar\"\n                  src=${this.entity.icon.url}\n                />\n              </a>\n            ` : nothing}\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            Group Name\n          </dt>\n          <dd>\n            <a href=${this.entity.url}>\n              ${this.entity.name}\n            </a>\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            18+ / Sensitive / NSFW?\n          </span>\n          <dd>\n            ${this.entity.sensitive ? 'Yes' : 'No'}\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            Group Description\n          </span>\n          <dd>\n            ${unsafeHTML(this.entity.summary ?? '')}\n          </span>\n        </div>\n        ${Array.isArray(this.entity.attachment) ? repeat(this.entity.attachment, attachment => {\n          const propertyValue = attachment as unknown as {\n            name: string;\n            value: string;\n          };\n\n          return html`\n            <div role=\"row\">\n              <dt>\n                ${propertyValue.name}\n              </dt>\n              <dd>\n                ${unsafeHTML(propertyValue.value)}\n              </dd>\n            </div>\n          `;\n        }) : nothing}\n        <div role=\"row\">\n          <dt>\n            Manually Approves Members\n          </dt>\n          <dd>\n            ${this.entity.manuallyApprovesFollowers ? 'Yes' : 'No'}\n          </dd>\n        </div>\n      </dl>\n    `;\n  }\n}\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    \"group-entity-details\": GroupEntityDetails;\n  }\n}\n",
        "called_code_segment": "render() {\n    if (this.isDeleted) {\n      return html`\n        Deleted.\n      `;\n    }\n\n    if (!this.entity) {\n      return html`\n        Loading...\n      `;\n    }\n\n    return html`\n      <dl role=\"table\">\n        <div role=\"row\">\n          <dt>\n            Avatar\n          </dt>\n          <dd>\n            ${(this.entity.icon && 'url' in this.entity.icon) ? html`\n              <a href=${this.entity.url}>\n                <img\n                  class=\"avatar\"\n                  src=${this.entity.icon.url}\n                />\n              </a>\n            ` : nothing}\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            Group Name\n          </dt>\n          <dd>\n            <a href=${this.entity.url}>\n              ${this.entity.name}\n            </a>\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            18+ / Sensitive / NSFW?\n          </span>\n          <dd>\n            ${this.entity.sensitive ? 'Yes' : 'No'}\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            Group Description\n          </span>\n          <dd>\n            ${unsafeHTML(this.entity.summary ?? '')}\n          </span>\n        </div>\n        ${Array.isArray(this.entity.attachment) ? repeat(this.entity.attachment, attachment => {\n          const propertyValue = attachment as unknown as {\n            name: string;\n            value: string;\n          };\n\n          return html`\n            <div role=\"row\">\n              <dt>\n                ${propertyValue.name}\n              </dt>\n              <dd>\n                ${unsafeHTML(propertyValue.value)}\n              </dd>\n            </div>\n          `;\n        }) : nothing}\n        <div role=\"row\">\n          <dt>\n            Manually Approves Members\n          </dt>\n          <dd>\n            ${this.entity.manuallyApprovesFollowers ? 'Yes' : 'No'}\n          </dd>\n        </div>\n      </dl>\n    `;\n  }",
        "invoking_code_segment": "override firstUpdated() {\n    const url = new URL(this.entityId);\n    const isLocal = url.hostname === window.location.hostname;\n\n    fetch(isLocal ? this.entityId : `/proxy?resource=${this.entityId}`, {\n      headers: {\n        'Accept': 'application/activity+json'\n      }\n    })\n      .then(res => res.json())\n      .then(entity => {\n        this.entity = entity;\n      })\n      .catch(() => {\n        this.isDeleted = true;\n      });\n  }",
        "new_file_code_segment": "export function fetchEntityDetails(entityId: string): Promise<AP.Actor> {\n  const url = new URL(entityId);\n  const isLocal = url.hostname === window.location.hostname;\n\n  return fetch(isLocal ? entityId : `/proxy?resource=${entityId}`, {\n    headers: {\n      'Accept': 'application/activity+json'\n    }\n  })\n    .then(res => res.json())\n    .catch(() => {\n      throw new Error('Entity not found');\n    });\n}",
        "feature_description": "Add a function to fetch entity details and handle errors more gracefully.",
        "detailed_feature_description": "The new feature introduces a utility function in #file 3 to fetch entity details. This function encapsulates the logic for fetching entity data and handles errors by throwing an error if the entity is not found. This function is then invoked in #file 1 to replace the inline fetch logic, making the code cleaner and more modular. Additionally, #file 2 is updated to use this new function for fetching entity details.",
        "modified_complete_code": {
            "#file 1": "import {LitElement, html, css, nothing} from 'lit';\nimport {customElement, property, query} from 'lit/decorators';\nimport { repeat } from 'lit/directives/repeat';\nimport { baseCss } from './base-css';\nimport { AP } from 'activitypub-core-types';\nimport { unsafeHTML } from 'lit/directives/unsafe-html';\nimport { fetchEntityDetails } from './fetch-entity-details'; #New\n\n@customElement('group-entity-details')\nexport class GroupEntityDetails extends LitElement {\n  static styles = [baseCss, css`\n    :host {\n      display: block;\n    }\n    .avatar {\n      max-width: 200px;\n    }\n  `];\n\n  @property({type: String, attribute: 'entity-id'})\n  private entityId?: string;\n\n  @property({ type: Object })\n  private entity: AP.Actor | null = null;\n\n  @property({ type: Boolean })\n  private isDeleted = false;\n\n  override firstUpdated() {\n    fetchEntityDetails(this.entityId)\n      .then(entity => {\n        this.entity = entity;\n      })\n      .catch(() => {\n        this.isDeleted = true;\n      });\n  } #Modify\n\n  render() {\n    if (this.isDeleted) {\n      return html`\n        Deleted.\n      `;\n    }\n\n    if (!this.entity) {\n      return html`\n        Loading...\n      `;\n    }\n\n    return html`\n      <dl role=\"table\">\n        <div role=\"row\">\n          <dt>\n            Avatar\n          </dt>\n          <dd>\n            ${(this.entity.icon && 'url' in this.entity.icon) ? html`\n              <a href=${this.entity.url}>\n                <img\n                  class=\"avatar\"\n                  src=${this.entity.icon.url}\n                />\n              </a>\n            ` : nothing}\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            Group Name\n          </dt>\n          <dd>\n            <a href=${this.entity.url}>\n              ${this.entity.name}\n            </a>\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            18+ / Sensitive / NSFW?\n          </span>\n          <dd>\n            ${this.entity.sensitive ? 'Yes' : 'No'}\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            Group Description\n          </span>\n          <dd>\n            ${unsafeHTML(this.entity.summary ?? '')}\n          </span>\n        </div>\n        ${Array.isArray(this.entity.attachment) ? repeat(this.entity.attachment, attachment => {\n          const propertyValue = attachment as unknown as {\n            name: string;\n            value: string;\n          };\n\n          return html`\n            <div role=\"row\">\n              <dt>\n                ${propertyValue.name}\n              </dt>\n              <dd>\n                ${unsafeHTML(propertyValue.value)}\n              </dd>\n            </div>\n          `;\n        }) : nothing}\n        <div role=\"row\">\n          <dt>\n            Manually Approves Members\n          </dt>\n          <dd>\n            ${this.entity.manuallyApprovesFollowers ? 'Yes' : 'No'}\n          </dd>\n        </div>\n      </dl>\n    `;\n  }\n}",
            "#file 2": "import {LitElement, html, css, nothing} from 'lit';\nimport {customElement, property, query} from 'lit/decorators';\nimport { repeat } from 'lit/directives/repeat';\nimport { baseCss } from './base-css';\nimport { AP } from 'activitypub-core-types';\nimport { unsafeHTML } from 'lit/directives/unsafe-html';\nimport { fetchEntityDetails } from './fetch-entity-details'; #New\n\n@customElement('group-entity-details')\nexport class GroupEntityDetails extends LitElement {\n  static styles = [baseCss, css`\n    :host {\n      display: block;\n    }\n    .avatar {\n      max-width: 200px;\n    }\n  `];\n\n  @property({type: String, attribute: 'entity-id'})\n  private entityId?: string;\n\n  @property({ type: Object })\n  private entity: AP.Actor | null = null;\n\n  @property({ type: Boolean })\n  private isDeleted = false;\n\n  override firstUpdated() {\n    fetchEntityDetails(this.entityId)\n      .then(entity => {\n        this.entity = entity;\n      })\n      .catch(() => {\n        this.isDeleted = true;\n      });\n  } #Modify\n\n  render() {\n    if (this.isDeleted) {\n      return html`\n        Deleted.\n      `;\n    }\n\n    if (!this.entity) {\n      return html`\n        Loading...\n      `;\n    }\n\n    return html`\n      <dl role=\"table\">\n        <div role=\"row\">\n          <dt>\n            Avatar\n          </dt>\n          <dd>\n            ${(this.entity.icon && 'url' in this.entity.icon) ? html`\n              <a href=${this.entity.url}>\n                <img\n                  class=\"avatar\"\n                  src=${this.entity.icon.url}\n                />\n              </a>\n            ` : nothing}\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            Group Name\n          </dt>\n          <dd>\n            <a href=${this.entity.url}>\n              ${this.entity.name}\n            </a>\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            18+ / Sensitive / NSFW?\n          </span>\n          <dd>\n            ${this.entity.sensitive ? 'Yes' : 'No'}\n          </dd>\n        </div>\n        <div role=\"row\">\n          <dt>\n            Group Description\n          </span>\n          <dd>\n            ${unsafeHTML(this.entity.summary ?? '')}\n          </span>\n        </div>\n        ${Array.isArray(this.entity.attachment) ? repeat(this.entity.attachment, attachment => {\n          const propertyValue = attachment as unknown as {\n            name: string;\n            value: string;\n          };\n\n          return html`\n            <div role=\"row\">\n              <dt>\n                ${propertyValue.name}\n              </dt>\n              <dd>\n                ${unsafeHTML(propertyValue.value)}\n              </dd>\n            </div>\n          `;\n        }) : nothing}\n        <div role=\"row\">\n          <dt>\n            Manually Approves Members\n          </dt>\n          <dd>\n            ${this.entity.manuallyApprovesFollowers ? 'Yes' : 'No'}\n          </dd>\n        </div>\n      </dl>\n    `;\n  }\n}",
            "#file 3": "import { AP } from 'activitypub-core-types';\n\nexport function fetchEntityDetails(entityId: string): Promise<AP.Actor> {\n  const url = new URL(entityId);\n  const isLocal = url.hostname === window.location.hostname;\n\n  return fetch(isLocal ? entityId : `/proxy?resource=${entityId}`, {\n    headers: {\n      'Accept': 'application/activity+json'\n    }\n  })\n    .then(res => res.json())\n    .catch(() => {\n      throw new Error('Entity not found');\n    });\n}"
        }
    },
    {
        "repo": "obsidian-yt-transcript",
        "content": "'obsidian-yt-transcript/src/types.ts'\n:export interface TranscriptBlock {\n\tquote: string;\n\tquoteTimeOffset: number;\n}\n\n'obsidian-yt-transcript/src/transcript-view.ts'\n:import YTranscriptPlugin from \"src/main\";\nimport { ItemView, WorkspaceLeaf, Menu } from \"obsidian\";\nimport {\n\tTranscriptResponse,\n\tYoutubeTranscript,\n\tYoutubeTranscriptError,\n} from \"./fetch-transcript\";\nimport { formatTimestamp } from \"./timestampt-utils\";\nimport { getTranscriptBlocks, highlightText } from \"./render-utils\";\nimport { TranscriptBlock } from \"./types\";\n\nexport const TRANSCRIPT_TYPE_VIEW = \"transcript-view\";\nexport class TranscriptView extends ItemView {\n\tisDataLoaded: boolean;\n\tplugin: YTranscriptPlugin;\n\n\tloaderContainerEl?: HTMLElement;\n\tdataContainerEl?: HTMLElement;\n\terrorContainerEl?: HTMLElement;\n\n\tvideoTitle?: string;\n\tvideoData?: TranscriptResponse[] = [];\n\n\tconstructor(leaf: WorkspaceLeaf, plugin: YTranscriptPlugin) {\n\t\tsuper(leaf);\n\t\tthis.plugin = plugin;\n\t\tthis.isDataLoaded = false;\n\t}\n\n\tasync onOpen() {\n\t\tconst { contentEl } = this;\n\t\tcontentEl.empty();\n\t\tcontentEl.createEl(\"h4\", { text: \"Transcript\" });\n\t}\n\n\tasync onClose() {\n\t\tconst leafIndex = this.getLeafIndex();\n\t\tthis.plugin.settings.leafUrls.splice(leafIndex, 1);\n\t}\n\n\t/**\n\t * Gets the leaf index out of all of the open leaves\n\t * This assumes that the leaf order shouldn't changed, which is a fair assumption\n\t */\n\tprivate getLeafIndex(): number {\n\t\tconst leaves = this.app.workspace.getLeavesOfType(TRANSCRIPT_TYPE_VIEW);\n\t\treturn leaves.findIndex((leaf) => leaf === this.leaf);\n\t}\n\n\t/**\n\t * Adds a div with loading text to the view content\n\t */\n\tprivate renderLoader() {\n\t\tif (this.loaderContainerEl !== undefined) {\n\t\t\tthis.loaderContainerEl.createEl(\"div\", {\n\t\t\t\ttext: \"Loading...\",\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Adds a text input to the view content\n\t */\n\tprivate renderSearchInput(\n\t\turl: string,\n\t\tdata: TranscriptResponse,\n\t\ttimestampMod: number,\n\t) {\n\t\tconst searchInputEl = this.contentEl.createEl(\"input\");\n\t\tsearchInputEl.type = \"text\";\n\t\tsearchInputEl.placeholder = \"Search...\";\n\t\tsearchInputEl.style.marginBottom = \"20px\";\n\t\tsearchInputEl.addEventListener(\"input\", (e) => {\n\t\t\tconst searchFilter = (e.target as HTMLInputElement).value;\n\t\t\tthis.renderTranscriptionBlocks(\n\t\t\t\turl,\n\t\t\t\tdata,\n\t\t\t\ttimestampMod,\n\t\t\t\tsearchFilter,\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Adds a div with the video title to the view content\n\t * @param title - the title of the video\n\t */\n\tprivate renderVideoTitle(title: string) {\n\t\tconst titleEl = this.contentEl.createEl(\"div\");\n\t\ttitleEl.innerHTML = title;\n\t\ttitleEl.style.fontWeight = \"bold\";\n\t\ttitleEl.style.marginBottom = \"20px\";\n\t}\n\n\tprivate formatContentToPaste(url: string, blocks: TranscriptBlock[]) {\n\t\treturn blocks\n\t\t\t.map((block) => {\n\t\t\t\tconst { quote, quoteTimeOffset } = block;\n\t\t\t\tconst href = url + \"&t=\" + Math.floor(quoteTimeOffset / 1000);\n\t\t\t\tconst formattedBlock = `[${formatTimestamp(\n\t\t\t\t\tquoteTimeOffset,\n\t\t\t\t)}](${href}) ${quote}`;\n\n\t\t\t\treturn formattedBlock;\n\t\t\t})\n\t\t\t.join(\"\\n\");\n\t}\n\n\t/**\n\t * Add a transcription blocks to the view content\n\t * @param url - the url of the video\n\t * @param data - the transcript data\n\t * @param timestampMod - the number of seconds between each timestamp\n\t * @param searchValue - the value to search for in the transcript\n\t */\n\tprivate renderTranscriptionBlocks(\n\t\turl: string,\n\t\tdata: TranscriptResponse,\n\t\ttimestampMod: number,\n\t\tsearchValue: string,\n\t) {\n\t\tconst dataContainerEl = this.dataContainerEl;\n\t\tif (dataContainerEl !== undefined) {\n\t\t\t//Clear old data before rerendering\n\t\t\tdataContainerEl.empty();\n\n\t\t\t// TODO implement drag and drop\n\t\t\t// const handleDrag = (quote: string) => {\n\t\t\t// \treturn (event: DragEvent) => {\n\t\t\t// \t\tevent.dataTransfer?.setData(\"text/plain\", quote);\n\t\t\t// \t};\n\t\t\t// };\n\n\t\t\tconst transcriptBlocks = getTranscriptBlocks(\n\t\t\t\tdata.lines,\n\t\t\t\ttimestampMod,\n\t\t\t);\n\n\t\t\t//Filter transcript blocks based on\n\t\t\tconst filteredBlocks = transcriptBlocks.filter((block) =>\n\t\t\t\tblock.quote.toLowerCase().includes(searchValue.toLowerCase()),\n\t\t\t);\n\n\t\t\tfilteredBlocks.forEach((block) => {\n\t\t\t\tconst { quote, quoteTimeOffset } = block;\n\t\t\t\tconst blockContainerEl = createEl(\"div\", {\n\t\t\t\t\tcls: \"yt-transcript__transcript-block\",\n\t\t\t\t});\n\t\t\t\tblockContainerEl.draggable = true;\n\n\t\t\t\tconst linkEl = createEl(\"a\", {\n\t\t\t\t\ttext: formatTimestamp(quoteTimeOffset),\n\t\t\t\t\tattr: {\n\t\t\t\t\t\thref: url + \"&t=\" + Math.floor(quoteTimeOffset / 1000),\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tlinkEl.style.marginBottom = \"5px\";\n\n\t\t\t\tconst span = dataContainerEl.createEl(\"span\", {\n\t\t\t\t\ttext: quote,\n\t\t\t\t\ttitle: \"Click to copy\",\n\t\t\t\t});\n\n\t\t\t\tspan.addEventListener(\"click\", (event) => {\n\t\t\t\t\tconst target = event.target as HTMLElement;\n\t\t\t\t\tif (target !== null) {\n\t\t\t\t\t\tnavigator.clipboard.writeText(target.textContent ?? \"\");\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t//Highlight any match search terms\n\t\t\t\tif (searchValue !== \"\") highlightText(span, searchValue);\n\n\t\t\t\t// TODO implement drag and drop\n\t\t\t\t// span.setAttr(\"draggable\", \"true\");\n\t\t\t\t// span.addEventListener(\"dragstart\", handleDrag(quote));\n\n\t\t\t\tblockContainerEl.appendChild(linkEl);\n\t\t\t\tblockContainerEl.appendChild(span);\n\t\t\t\tblockContainerEl.addEventListener(\n\t\t\t\t\t\"dragstart\",\n\t\t\t\t\t(event: DragEvent) => {\n\t\t\t\t\t\tevent.dataTransfer?.setData(\n\t\t\t\t\t\t\t\"text/html\",\n\t\t\t\t\t\t\tblockContainerEl.innerHTML,\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tblockContainerEl.addEventListener(\n\t\t\t\t\t\"contextmenu\",\n\t\t\t\t\t(event: MouseEvent) => {\n\t\t\t\t\t\tconst menu = new Menu();\n\t\t\t\t\t\tmenu.addItem((item) =>\n\t\t\t\t\t\t\titem.setTitle(\"Copy all\").onClick(() => {\n\t\t\t\t\t\t\t\tnavigator.clipboard.writeText(\n\t\t\t\t\t\t\t\t\tthis.formatContentToPaste(\n\t\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\t\tfilteredBlocks,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tmenu.showAtPosition({\n\t\t\t\t\t\t\tx: event.clientX,\n\t\t\t\t\t\t\ty: event.clientY,\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t);\n\n\t\t\t\tdataContainerEl.appendChild(blockContainerEl);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Sets the state of the view\n\t * This is called when the view is loaded\n\t */\n\tasync setEphemeralState(state: { url: string }): Promise<void> {\n\t\t//If we switch to another view and then switch back, we don't want to reload the data\n\t\tif (this.isDataLoaded) return;\n\n\t\tconst leafIndex = this.getLeafIndex();\n\n\t\t//The state.url is not null when we call setEphermeralState from the command\n\t\t//in this case, we will save the url to the settings for future look up\n\t\tif (state.url) {\n\t\t\tthis.plugin.settings.leafUrls[leafIndex] = state.url;\n\t\t\tawait this.plugin.saveSettings();\n\t\t}\n\n\t\tconst { lang, country, timestampMod, leafUrls } = this.plugin.settings;\n\t\tconst url = leafUrls[leafIndex];\n\n\t\ttry {\n\t\t\t//If it's the first time loading the view, initialize our containers\n\t\t\t//otherwise, clear the existing data for rerender\n\t\t\tif (this.loaderContainerEl === undefined) {\n\t\t\t\tthis.loaderContainerEl = this.contentEl.createEl(\"div\");\n\t\t\t} else {\n\t\t\t\tthis.loaderContainerEl.empty();\n\t\t\t}\n\n\t\t\t//Clear all containers for rerender and render loader\n\t\t\tthis.renderLoader();\n\n\t\t\t//Get the youtube video title and transcript at the same time\n\t\t\tconst data = await YoutubeTranscript.fetchTranscript(url, {\n\t\t\t\tlang,\n\t\t\t\tcountry,\n\t\t\t});\n\n\t\t\tif (!data) throw Error();\n\n\t\t\tthis.isDataLoaded = true;\n\t\t\tthis.loaderContainerEl.empty();\n\n\t\t\tthis.renderVideoTitle(data.title);\n\t\t\tthis.renderSearchInput(url, data, timestampMod);\n\n\t\t\tif (this.dataContainerEl === undefined) {\n\t\t\t\tthis.dataContainerEl = this.contentEl.createEl(\"div\");\n\t\t\t} else {\n\t\t\t\tthis.dataContainerEl.empty();\n\t\t\t}\n\n\t\t\t//If there was already an error clear it\n\t\t\tif (this.errorContainerEl !== undefined) {\n\t\t\t\tthis.errorContainerEl.empty();\n\t\t\t}\n\n\t\t\tif (data.lines.length === 0) {\n\t\t\t\tthis.dataContainerEl.createEl(\"h4\", {\n\t\t\t\t\ttext: \"No transcript found\",\n\t\t\t\t});\n\t\t\t\tthis.dataContainerEl.createEl(\"div\", {\n\t\t\t\t\ttext: \"Please check if video contains any transcript or try adjust language and country in plugin settings.\",\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.renderTranscriptionBlocks(url, data, timestampMod, \"\");\n\t\t\t}\n\t\t} catch (err: unknown) {\n\t\t\tlet errorMessage = \"\";\n\t\t\tif (err instanceof YoutubeTranscriptError) {\n\t\t\t\terrorMessage = err.message;\n\t\t\t}\n\n\t\t\tthis.loaderContainerEl?.empty();\n\n\t\t\tif (this.errorContainerEl === undefined) {\n\t\t\t\tthis.errorContainerEl = this.contentEl.createEl(\"h5\");\n\t\t\t} else {\n\t\t\t\tthis.errorContainerEl.empty();\n\t\t\t}\n\t\t\tconst titleEl = this.errorContainerEl.createEl(\"div\", {\n\t\t\t\ttext: \"Error loading transcript\",\n\t\t\t});\n\t\t\ttitleEl.style.marginBottom = \"5px\";\n\n\t\t\tconst messageEl = this.errorContainerEl.createEl(\"div\", {\n\t\t\t\ttext: errorMessage,\n\t\t\t});\n\t\t\tmessageEl.style.color = \"var(--text-muted)\";\n\t\t\tmessageEl.style.fontSize = \"var(--font-ui-small)\";\n\t\t}\n\t}\n\n\tgetViewType(): string {\n\t\treturn TRANSCRIPT_TYPE_VIEW;\n\t}\n\tgetDisplayText(): string {\n\t\treturn \"YouTube Transcript\";\n\t}\n\tgetIcon(): string {\n\t\treturn \"scroll\";\n\t}\n}\n\n",
        "called_code_segment": "async setEphemeralState(state: { url: string }): Promise<void> {\n    //If we switch to another view and then switch back, we don't want to reload the data\n    if (this.isDataLoaded) return;\n\n    const leafIndex = this.getLeafIndex();\n\n    //The state.url is not null when we call setEphermeralState from the command\n    //in this case, we will save the url to the settings for future look up\n    if (state.url) {\n        this.plugin.settings.leafUrls[leafIndex] = state.url;\n        await this.plugin.saveSettings();\n    }\n\n    const { lang, country, timestampMod, leafUrls } = this.plugin.settings;\n    const url = leafUrls[leafIndex];\n\n    try {\n        //If it's the first time loading the view, initialize our containers\n        //otherwise, clear the existing data for rerender\n        if (this.loaderContainerEl === undefined) {\n            this.loaderContainerEl = this.contentEl.createEl(\"div\");\n        } else {\n            this.loaderContainerEl.empty();\n        }\n\n        //Clear all containers for rerender and render loader\n        this.renderLoader();\n\n        //Get the youtube video title and transcript at the same time\n        const data = await YoutubeTranscript.fetchTranscript(url, {\n            lang,\n            country,\n        });\n\n        if (!data) throw Error();\n\n        this.isDataLoaded = true;\n        this.loaderContainerEl.empty();\n\n        this.renderVideoTitle(data.title);\n        this.renderSearchInput(url, data, timestampMod);\n\n        if (this.dataContainerEl === undefined) {\n            this.dataContainerEl = this.contentEl.createEl(\"div\");\n        } else {\n            this.dataContainerEl.empty();\n        }\n\n        //If there was already an error clear it\n        if (this.errorContainerEl !== undefined) {\n            this.errorContainerEl.empty();\n        }\n\n        if (data.lines.length === 0) {\n            this.dataContainerEl.createEl(\"h4\", {\n                text: \"No transcript found\",\n            });\n            this.dataContainerEl.createEl(\"div\", {\n                text: \"Please check if video contains any transcript or try adjust language and country in plugin settings.\",\n            });\n        } else {\n            this.renderTranscriptionBlocks(url, data, timestampMod, \"\");\n        }\n    } catch (err: unknown) {\n        let errorMessage = \"\";\n        if (err instanceof YoutubeTranscriptError) {\n            errorMessage = err.message;\n        }\n\n        this.loaderContainerEl?.empty();\n\n        if (this.errorContainerEl === undefined) {\n            this.errorContainerEl = this.contentEl.createEl(\"h5\");\n        } else {\n            this.errorContainerEl.empty();\n        }\n        const titleEl = this.errorContainerEl.createEl(\"div\", {\n            text: \"Error loading transcript\",\n        });\n        titleEl.style.marginBottom = \"5px\";\n\n        const messageEl = this.errorContainerEl.createEl(\"div\", {\n            text: errorMessage,\n        });\n        messageEl.style.color = \"var(--text-muted)\";\n        messageEl.style.fontSize = \"var(--font-ui-small)\";\n    }\n}",
        "invoking_code_segment": "async onOpen() {\n    const { contentEl } = this;\n    contentEl.empty();\n    contentEl.createEl(\"h4\", { text: \"Transcript\" });\n    await this.setEphemeralState({ url: this.plugin.settings.leafUrls[this.getLeafIndex()] });\n}",
        "new_file_code_segment": "export async function fetchVideoDetails(url: string): Promise<{ title: string, description: string }> {\n    // Mock implementation for fetching video details\n    return {\n        title: 'Sample Video Title',\n        description: 'This is a sample video description.'\n    };\n}",
        "feature_description": "Fetch and display video description along with the transcript.",
        "detailed_feature_description": "The new feature involves fetching the video description from the provided URL and displaying it alongside the transcript. This is achieved by creating a new function `fetchVideoDetails` in a new file (#file 3) that fetches the video title and description. The `setEphemeralState` function in #file 1 is modified to call this new function and render the video description. The `onOpen` function in #file 2 remains unchanged as it continues to invoke `setEphemeralState` to load the transcript and now, the video description.",
        "modified_complete_code": {
            "#file 1": "async setEphemeralState(state: { url: string }): Promise<void> {\n    //If we switch to another view and then switch back, we don't want to reload the data\n    if (this.isDataLoaded) return;\n\n    const leafIndex = this.getLeafIndex();\n\n    //The state.url is not null when we call setEphermeralState from the command\n    //in this case, we will save the url to the settings for future look up\n    if (state.url) {\n        this.plugin.settings.leafUrls[leafIndex] = state.url;\n        await this.plugin.saveSettings();\n    }\n\n    const { lang, country, timestampMod, leafUrls } = this.plugin.settings;\n    const url = leafUrls[leafIndex];\n\n    try {\n        //If it's the first time loading the view, initialize our containers\n        //otherwise, clear the existing data for rerender\n        if (this.loaderContainerEl === undefined) {\n            this.loaderContainerEl = this.contentEl.createEl(\"div\");\n        } else {\n            this.loaderContainerEl.empty();\n        }\n\n        //Clear all containers for rerender and render loader\n        this.renderLoader();\n\n        //Get the youtube video title and transcript at the same time\n        const data = await YoutubeTranscript.fetchTranscript(url, {\n            lang,\n            country,\n        });\n\n        if (!data) throw Error();\n\n        this.isDataLoaded = true;\n        this.loaderContainerEl.empty();\n\n        this.renderVideoTitle(data.title);\n        this.renderSearchInput(url, data, timestampMod);\n\n        if (this.dataContainerEl === undefined) {\n            this.dataContainerEl = this.contentEl.createEl(\"div\");\n        } else {\n            this.dataContainerEl.empty();\n        }\n\n        //If there was already an error clear it\n        if (this.errorContainerEl !== undefined) {\n            this.errorContainerEl.empty();\n        }\n\n        if (data.lines.length === 0) {\n            this.dataContainerEl.createEl(\"h4\", {\n                text: \"No transcript found\",\n            });\n            this.dataContainerEl.createEl(\"div\", {\n                text: \"Please check if video contains any transcript or try adjust language and country in plugin settings.\",\n            });\n        } else {\n            this.renderTranscriptionBlocks(url, data, timestampMod, \"\");\n        }\n\n        // #Modify: Fetch and render video description\n        const videoDetails = await fetchVideoDetails(url);\n        this.renderVideoDescription(videoDetails.description);\n    } catch (err: unknown) {\n        let errorMessage = \"\";\n        if (err instanceof YoutubeTranscriptError) {\n            errorMessage = err.message;\n        }\n\n        this.loaderContainerEl?.empty();\n\n        if (this.errorContainerEl === undefined) {\n            this.errorContainerEl = this.contentEl.createEl(\"h5\");\n        } else {\n            this.errorContainerEl.empty();\n        }\n        const titleEl = this.errorContainerEl.createEl(\"div\", {\n            text: \"Error loading transcript\",\n        });\n        titleEl.style.marginBottom = \"5px\";\n\n        const messageEl = this.errorContainerEl.createEl(\"div\", {\n            text: errorMessage,\n        });\n        messageEl.style.color = \"var(--text-muted)\";\n        messageEl.style.fontSize = \"var(--font-ui-small)\";\n    }\n}\n\n// #New: Render video description\nprivate renderVideoDescription(description: string) {\n    const descriptionEl = this.contentEl.createEl(\"div\");\n    descriptionEl.innerHTML = description;\n    descriptionEl.style.marginBottom = \"20px\";\n}",
            "#file 2": "async onOpen() {\n    const { contentEl } = this;\n    contentEl.empty();\n    contentEl.createEl(\"h4\", { text: \"Transcript\" });\n    await this.setEphemeralState({ url: this.plugin.settings.leafUrls[this.getLeafIndex()] });\n}",
            "#file 3": "export async function fetchVideoDetails(url: string): Promise<{ title: string, description: string }> {\n    // Mock implementation for fetching video details\n    return {\n        title: 'Sample Video Title',\n        description: 'This is a sample video description.'\n    };\n}"
        }
    },
    {
        "repo": "petfinder-js-sdk",
        "content": "'petfinder-js-sdk/src/api/animalData.ts'\n:import { AxiosResponse } from \"axios\";\n\nimport { ApiClient } from \"./client\";\n\nexport class AnimalData extends ApiClient {\n    public async types(): Promise<AxiosResponse> {\n        await this.ensureAuthenticated();\n        return this.http.get(\"/types\");\n    }\n\n    public async type(type: string): Promise<AxiosResponse> {\n        await this.ensureAuthenticated();\n        return this.http.get(`/types/${type}`);\n    }\n\n    public async breeds(type: string): Promise<AxiosResponse> {\n        await this.ensureAuthenticated();\n        return this.http.get(`/types/${type}/breeds`);\n    }\n}\n\n'petfinder-js-sdk/tests/main.test.ts'\n:/* eslint-disable @typescript-eslint/camelcase */\nimport axios from \"axios\";\nimport MockAdapter from \"axios-mock-adapter\";\n\nimport { Animal } from \"../src/api/animal\";\nimport { AnimalData } from \"../src/api/animalData\";\nimport { Organization } from \"../src/api/organization\";\nimport { Client } from \"../src/main\";\n\nit(\"Creates Petfinder client\", () => {\n    const client = new Client({apiKey: \"foo\", secret: \"bar\"});\n\n    expect(client).toBeInstanceOf(Client);\n    expect(client.http.defaults.baseURL).toEqual(\"https://api.petfinder.com/v2\");\n});\n\nit(\"Creates Petfinder client with custom base url\", () => {\n    const client = new Client({apiKey: \"foo\", secret: \"bar\", baseUrl: \"http://example.com\"});\n\n    expect(client.http.defaults.baseURL).toEqual(\"http://example.com\");\n});\n\nit(\"Can authenticate\", async () => {\n    const mock = new MockAdapter(axios);\n    mock.onPost(\"/oauth2/token\", {\n        client_id: \"foo\",\n        client_secret: \"bar\",\n        grant_type: \"client_credentials\",\n    }).reply(200, {\n        access_token: \"mytoken\",\n        expires_in: 3600,\n    });\n\n    const client = new Client({apiKey: \"foo\", secret: \"bar\"});\n    const response = await client.authenticate();\n\n    expect(response).not.toBeNull();\n    expect(response ? response.data.access_token : null).toEqual(\"mytoken\");\n    expect(client.http.defaults.headers.common.Authorization).toEqual(\"Bearer mytoken\");\n});\n\nit(\"Uses token passed in configuration for authentication\", async () => {\n    const client = new Client({apiKey: \"foo\", secret: \"bar\", token: \"my-test-token\"});\n    const response = await client.authenticate();\n\n    expect(response).toBeUndefined();\n    expect(client.http.defaults.headers.common.Authorization).toEqual(\"Bearer my-test-token\");\n});\n\nit(\"Uses token passed in authenticate method\", async () => {\n    const client = new Client({apiKey: \"foo\", secret: \"bar\"});\n    const response = await client.authenticate(\"authme\");\n\n    expect(response).toBeUndefined();\n    expect(client.http.defaults.headers.common.Authorization).toEqual(\"Bearer authme\");\n});\n\nit(\"Should be able to get sub clients\", () => {\n    const client = new Client({apiKey: \"foo\", secret: \"bar\"});\n\n    expect(client.animal).toBeInstanceOf(Animal);\n    expect(client.animalData).toBeInstanceOf(AnimalData);\n    expect(client.organization).toBeInstanceOf(Organization);\n});\n\nit(\"Should include an identifiable header\", async () => {\n    const mock = new MockAdapter(axios);\n    mock.onGet(\"/\").replyOnce(200);\n\n    const client = new Client({apiKey: \"foo\", secret: \"bar\"});\n    const response = await client.http.get(\"/\");\n\n    expect(response.status).toEqual(200);\n    expect(mock.history.get.length).toEqual(1);\n    expect(mock.history.get[0].headers[\"x-api-sdk\"])\n        .toEqual(\"petfinder-js-sdk/v1.0 (https://github.com/petfinder-com/petfinder-js-sdk)\");\n});\n\n",
        "called_code_segment": "public async types(): Promise<AxiosResponse> {\n        await this.ensureAuthenticated();\n        return this.http.get(\"/types\");\n    }",
        "invoking_code_segment": "expect(client.animalData).toBeInstanceOf(AnimalData);",
        "new_file_code_segment": "export class AnimalDataCache {\n    private cache: Map<string, any> = new Map();\n\n    public get(key: string): any {\n        return this.cache.get(key);\n    }\n\n    public set(key: string, value: any): void {\n        this.cache.set(key, value);\n    }\n\n    public has(key: string): boolean {\n        return this.cache.has(key);\n    }\n}",
        "feature_description": "Add caching for animal data types to reduce API calls.",
        "detailed_feature_description": "The new feature introduces a caching mechanism for animal data types. This is implemented in a new file (#file 3) named `AnimalDataCache`. The `AnimalData` class in #file 1 is modified to check the cache before making an API call. If the data is already cached, it returns the cached data instead of making a new request. The `AnimalDataCache` class provides methods to store, retrieve, and check the existence of cached data. This ensures that the same data is not fetched repeatedly, reducing the number of API calls and improving performance.",
        "modified_complete_code": {
            "#file 1": "import { AxiosResponse } from \"axios\";\n\nimport { ApiClient } from \"./client\";\nimport { AnimalDataCache } from \"./animalDataCache\"; #New\n\nexport class AnimalData extends ApiClient {\n    private cache: AnimalDataCache = new AnimalDataCache(); #New\n\n    public async types(): Promise<AxiosResponse> {\n        if (this.cache.has(\"types\")) { #Modify\n            return this.cache.get(\"types\"); #Modify\n        }\n        await this.ensureAuthenticated();\n        const response = await this.http.get(\"/types\");\n        this.cache.set(\"types\", response); #Modify\n        return response;\n    }\n\n    public async type(type: string): Promise<AxiosResponse> {\n        if (this.cache.has(type)) { #Modify\n            return this.cache.get(type); #Modify\n        }\n        await this.ensureAuthenticated();\n        const response = await this.http.get(`/types/${type}`);\n        this.cache.set(type, response); #Modify\n        return response;\n    }\n\n    public async breeds(type: string): Promise<AxiosResponse> {\n        const cacheKey = `breeds_${type}`; #Modify\n        if (this.cache.has(cacheKey)) { #Modify\n            return this.cache.get(cacheKey); #Modify\n        }\n        await this.ensureAuthenticated();\n        const response = await this.http.get(`/types/${type}/breeds`);\n        this.cache.set(cacheKey, response); #Modify\n        return response;\n    }\n}",
            "#file 2": "import axios from \"axios\";\nimport MockAdapter from \"axios-mock-adapter\";\n\nimport { Animal } from \"../src/api/animal\";\nimport { AnimalData } from \"../src/api/animalData\";\nimport { Organization } from \"../src/api/organization\";\nimport { Client } from \"../src/main\";\n\nit(\"Should be able to get sub clients\", () => {\n    const client = new Client({apiKey: \"foo\", secret: \"bar\"});\n\n    expect(client.animal).toBeInstanceOf(Animal);\n    expect(client.animalData).toBeInstanceOf(AnimalData);\n    expect(client.organization).toBeInstanceOf(Organization);\n});",
            "#file 3": "export class AnimalDataCache {\n    private cache: Map<string, any> = new Map();\n\n    public get(key: string): any {\n        return this.cache.get(key);\n    }\n\n    public set(key: string, value: any): void {\n        this.cache.set(key, value);\n    }\n\n    public has(key: string): boolean {\n        return this.cache.has(key);\n    }\n}"
        }
    },
    {
        "repo": "aws-cdk-typescript-codepipeline-codeartifact-sample",
        "content": "'aws-cdk-typescript-codepipeline-codeartifact-sample/lib/typescript-cdk-cicd-codeartifact-stack.ts'\n:// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\nimport {RemovalPolicy, Stack, StackProps} from 'aws-cdk-lib';\nimport {Construct} from 'constructs';\nimport {Repository} from 'aws-cdk-lib/aws-codecommit';\nimport * as kms from 'aws-cdk-lib/aws-kms';\nimport {CfnDomain, CfnRepository} from 'aws-cdk-lib/aws-codeartifact';\nimport {BlockPublicAccess, Bucket, BucketEncryption} from \"aws-cdk-lib/aws-s3\";\nimport {Artifact, Pipeline} from \"aws-cdk-lib/aws-codepipeline\";\nimport {CodeBuildAction, CodeCommitSourceAction} from \"aws-cdk-lib/aws-codepipeline-actions\";\nimport {BuildSpec, ComputeType, LinuxBuildImage, PipelineProject} from \"aws-cdk-lib/aws-codebuild\";\nimport {Effect, Policy, PolicyStatement} from \"aws-cdk-lib/aws-iam\";\nimport {BuildAndPublishPackage} from \"./constructs/build-and-publish-package\";\nimport {NagSuppressions} from \"cdk-nag\";\n\n\nexport class TypescriptCdkCicdCodeartifactStack extends Stack {\n  constructor(scope: Construct, id: string, props?: StackProps) {\n    super(scope, id, props);\n\n    const repo = new Repository(this, \"CodeCommitRepository\",{\n      repositoryName:'TypeScriptSampleRepository'\n    });\n\n    const codeartifactDomain = new CfnDomain(this, \"CodeArtifactDomain\", {\n      domainName: \"aws-typescript-sample-domain\"\n    });\n\n    const npmPrivateCodeartifactRepository = new CfnRepository(this, \"PipPrivateCodeArtifactRepository\", {\n      domainName: codeartifactDomain.domainName,\n      repositoryName: \"npm\",\n      description: \"Private npm repo\",\n      externalConnections: [\"public:npmjs\"]\n    });\n\n    npmPrivateCodeartifactRepository.addDependsOn(codeartifactDomain);\n\n    const codebuildEncryptionKey = new kms.Key(this, 'codeBuildEncryptionKey', {\n      enableKeyRotation: true,\n    });\n\n    const accessLogsBucket = new Bucket(this, \"AccessLogsBucket\", {\n      bucketName: \"sample-typescript-cdk-access-logs-\" + this.account,\n      blockPublicAccess: BlockPublicAccess.BLOCK_ALL,\n      encryption: BucketEncryption.KMS,\n      encryptionKey:codebuildEncryptionKey,\n      enforceSSL: true,\n      removalPolicy: RemovalPolicy.DESTROY,\n      autoDeleteObjects: true\n    });\n\n    NagSuppressions.addResourceSuppressions(accessLogsBucket,\n        [\n          {id: \"AwsSolutions-S1\", reason: \"Cannot log to itself\"},\n        ]\n    );\n\n    const pipelineArtifactBucket = new Bucket(this, \"PipelineArtifactBucket\", {\n      bucketName: \"sample-typescript-cdk-artifact-\" + this.account,\n      serverAccessLogsBucket: accessLogsBucket,\n      blockPublicAccess: BlockPublicAccess.BLOCK_ALL,\n      encryption: BucketEncryption.KMS,\n      encryptionKey:codebuildEncryptionKey,\n      enforceSSL: true,\n      removalPolicy: RemovalPolicy.DESTROY,\n      autoDeleteObjects: true\n    });\n\n    const pipeline = new Pipeline(this, \"PackagePipeline\", {\n      pipelineName: \"typescript-sample-pipeline\",\n      restartExecutionOnUpdate: true,\n      artifactBucket: pipelineArtifactBucket,\n    });\n\n    const sourceOutput = new Artifact();\n\n    const sourceAction = new CodeCommitSourceAction({\n      actionName: \"CodeCommit\",\n      repository: repo,\n      output: sourceOutput,\n      branch: \"main\"\n    });\n\n    pipeline.addStage({\n      stageName: \"Source\",\n      actions: [sourceAction]\n    });\n\n    const runUnitTestsProject = new PipelineProject(this, \"RunUnitTests\", {\n      environment: {\n        privileged: false,\n        computeType: ComputeType.MEDIUM,\n        buildImage: LinuxBuildImage.STANDARD_5_0\n      },\n      encryptionKey: pipelineArtifactBucket.encryptionKey,\n      buildSpec: BuildSpec.fromObject({\n        version: \"0.2\",\n        phases: {\n          pre_build: {\n            commands: [\n              \"aws codeartifact login --tool npm --repository npm --domain aws-typescript-sample-domain\",\n              \"npm install\",\n            ],\n          },\n          build: {\n            commands: [\"npm run test\"],\n          },\n        },\n      })\n    });\n\n    runUnitTestsProject.role?.attachInlinePolicy(\n        new Policy(this, \"RunUnitTestsPolicy\", {\n          statements: [\n              new PolicyStatement({\n                effect: Effect.ALLOW,\n                resources: [\"*\"],\n                actions: [\"sts:GetServiceBearerToken\"],\n                conditions: {\n                  \"StringEquals\": {\n                    \"sts:AWSServiceName\": \"codeartifact.amazonaws.com\"\n                  }\n                }\n              }),\n            new PolicyStatement({\n              effect: Effect.ALLOW,\n              resources: [codeartifactDomain.attrArn],\n              actions: [\"codeartifact:GetAuthorizationToken\"]\n            }),\n            new PolicyStatement({\n              effect: Effect.ALLOW,\n              resources: [npmPrivateCodeartifactRepository.attrArn],\n              actions: [\n                \"codeartifact:ReadFromRepository\",\n                \"codeartifact:GetRepositoryEndpoint\",\n                \"codeartifact:List*\"\n              ]\n            }),\n          ]\n        })\n    );\n\n    pipeline.addStage({\n      stageName: \"Test\",\n      actions: [\n          new CodeBuildAction({\n            actionName: \"run-unit-tests\",\n            project: runUnitTestsProject,\n            input: sourceOutput\n          })\n      ]\n    });\n\n    const selfMutateProject = new PipelineProject(this, \"SelfMutate\", {\n      environment: {\n        privileged: false,\n        computeType: ComputeType.MEDIUM,\n        buildImage: LinuxBuildImage.STANDARD_5_0\n      },\n      encryptionKey: pipelineArtifactBucket.encryptionKey,\n      buildSpec: BuildSpec.fromObject({\n        version: \"0.2\",\n        phases: {\n          pre_build: {\n            commands: [\n              \"aws codeartifact login --tool npm --repository npm --domain aws-typescript-sample-domain\",\n              \"npm install\",\n            ],\n          },\n          build: {\n            commands: [\"npm run cdk deploy --require-approval=never\"],\n          },\n        },\n      })\n    });\n\n    selfMutateProject.role?.attachInlinePolicy(\n        new Policy(this, \"SelfMutatePolicy\", {\n          statements: [\n            new PolicyStatement({\n              effect: Effect.ALLOW,\n              resources: [\"*\"],\n              actions: [\"cloudformation:DescribeStacks\"]\n            }),\n            new PolicyStatement({\n              effect: Effect.ALLOW,\n              resources: [\"*\"],\n              actions: [\"iam:PassRole\"]\n            }),\n            new PolicyStatement({\n              effect: Effect.ALLOW,\n              resources: [\"arn:aws:iam::*:role/cdk-*\"],\n              actions: [\"sts:AssumeRole\"]\n            }),\n            new PolicyStatement({\n              effect: Effect.ALLOW,\n              resources: [\"*\"],\n              actions: [\"sts:GetServiceBearerToken\"],\n              conditions: {\n                \"StringEquals\": {\n                  \"sts:AWSServiceName\": \"codeartifact.amazonaws.com\"\n                }\n              }\n            }),\n            new PolicyStatement({\n              effect: Effect.ALLOW,\n              resources: [codeartifactDomain.attrArn],\n              actions: [\"codeartifact:GetAuthorizationToken\"]\n            }),\n            new PolicyStatement({\n              effect: Effect.ALLOW,\n              resources: [npmPrivateCodeartifactRepository.attrArn],\n              actions: [\n                \"codeartifact:ReadFromRepository\",\n                \"codeartifact:GetRepositoryEndpoint\",\n                \"codeartifact:List*\"\n              ]\n            }),\n          ]\n        })\n    );\n\n    pipeline.addStage({\n      stageName: \"UpdatePipeline\",\n      actions: [\n        new CodeBuildAction({\n          actionName: \"self-mutate\",\n          project: selfMutateProject,\n          input: sourceOutput\n        })\n      ]\n    });\n\n    const samplePackageProject = new BuildAndPublishPackage(\n        this,\n        \"BuildSamplePackage\",\n        {\n          projectName: \"sample-package\",\n          artifactBucketEncryptionKey: pipeline.artifactBucket.encryptionKey,\n          codeArtifactDomainArn: codeartifactDomain.attrArn,\n          codeArtifactNpmRepoArn: npmPrivateCodeartifactRepository.attrArn\n        }\n    );\n\n    pipeline.addStage({\n      stageName: \"BuildAndPublishPackages\",\n      actions: [\n        new CodeBuildAction({\n          actionName: \"sample-package\",\n          project: samplePackageProject.project,\n          input: sourceOutput\n        })\n      ]\n    });\n\n    NagSuppressions.addResourceSuppressionsByPath(this, \"/TypescriptCdkCicdCodeartifactStack/PackagePipeline/Role/DefaultPolicy/Resource\", [\n      {\n        id: \"AwsSolutions-IAM5\",\n        reason: \"Defined by a default policy\",\n        appliesTo: [\n          \"Action::s3:Abort*\",\n          \"Action::s3:DeleteObject*\",\n          \"Action::s3:GetBucket*\",\n          \"Action::s3:GetObject*\",\n          \"Action::s3:List*\",\n          \"Action::kms:GenerateDataKey*\",\n          \"Action::kms:ReEncrypt*\",\n          \"Resource::<PipelineArtifactBucketD127CCF6.Arn>/*\"\n        ]\n      }\n    ]);\n\n    NagSuppressions.addResourceSuppressionsByPath(this, \"/TypescriptCdkCicdCodeartifactStack/PackagePipeline/Source/CodeCommit/CodePipelineActionRole/DefaultPolicy/Resource\", [\n      {\n        id: \"AwsSolutions-IAM5\",\n        reason: \"Defined by a default policy\",\n        appliesTo: [\n          \"Action::s3:Abort*\",\n          \"Action::s3:DeleteObject*\",\n          \"Action::s3:GetBucket*\",\n          \"Action::s3:GetObject*\",\n          \"Action::s3:List*\",\n          \"Action::kms:GenerateDataKey*\",\n          \"Action::kms:ReEncrypt*\",\n          \"Resource::<PipelineArtifactBucketD127CCF6.Arn>/*\"\n        ]\n      }\n    ]);\n\n    NagSuppressions.addResourceSuppressionsByPath(this, \"/TypescriptCdkCicdCodeartifactStack/RunUnitTests/Role/DefaultPolicy/Resource\", [\n      {\n        id: \"AwsSolutions-IAM5\",\n        reason: \"Defined by a default policy\",\n        appliesTo: [\n          \"Resource::arn:<AWS::Partition>:logs:<AWS::Region>:<AWS::AccountId>:log-group:/aws/codebuild/<RunUnitTests2AD5FFEA>:*\",\n          \"Resource::arn:<AWS::Partition>:codebuild:<AWS::Region>:<AWS::AccountId>:report-group/<RunUnitTests2AD5FFEA>-*\",\n          \"Action::s3:GetBucket*\",\n          \"Action::s3:GetObject*\",\n          \"Action::s3:List*\",\n          \"Action::kms:GenerateDataKey*\",\n          \"Action::kms:ReEncrypt*\",\n          \"Resource::<PipelineArtifactBucketD127CCF6.Arn>/*\"\n        ]\n      }\n    ]);\n\n    NagSuppressions.addResourceSuppressionsByPath(this, \"/TypescriptCdkCicdCodeartifactStack/RunUnitTestsPolicy/Resource\", [\n      {\n        id: \"AwsSolutions-IAM5\",\n        reason: \"Defined by a default policy\",\n        appliesTo: [\n          \"Resource::*\",\n          \"Action::codeartifact:List*\"\n        ]\n      }\n    ]);\n\n    NagSuppressions.addResourceSuppressionsByPath(this, \"/TypescriptCdkCicdCodeartifactStack/SelfMutate/Role/DefaultPolicy/Resource\", [\n      {\n        id: \"AwsSolutions-IAM5\",\n        reason: \"Defined by a default policy\",\n        appliesTo: [\n          \"Resource::arn:<AWS::Partition>:logs:<AWS::Region>:<AWS::AccountId>:log-group:/aws/codebuild/<SelfMutate95ADA46F>:*\",\n          \"Resource::arn:<AWS::Partition>:codebuild:<AWS::Region>:<AWS::AccountId>:report-group/<SelfMutate95ADA46F>-*\",\n          \"Action::s3:GetBucket*\",\n          \"Action::s3:GetObject*\",\n          \"Action::s3:List*\",\n          \"Action::kms:GenerateDataKey*\",\n          \"Action::kms:ReEncrypt*\",\n          \"Resource::<PipelineArtifactBucketD127CCF6.Arn>/*\"\n        ]\n      }\n    ]);\n\n    NagSuppressions.addResourceSuppressionsByPath(this, \"/TypescriptCdkCicdCodeartifactStack/SelfMutatePolicy/Resource\", [\n      {\n        id: \"AwsSolutions-IAM5\",\n        reason: \"Defined by a default policy\",\n        appliesTo: [\n          \"Resource::*\",\n          \"Resource::arn:aws:iam::*:role/cdk-*\",\n          \"Action::codeartifact:List*\"\n        ]\n      }\n    ]);\n\n    NagSuppressions.addResourceSuppressionsByPath(this, \"/TypescriptCdkCicdCodeartifactStack/BuildSamplePackage/sample-package/Role/DefaultPolicy/Resource\", [\n      {\n        id: \"AwsSolutions-IAM5\",\n        reason: \"Defined by a default policy\",\n        appliesTo: [\n          \"Resource::arn:<AWS::Partition>:logs:<AWS::Region>:<AWS::AccountId>:log-group:/aws/codebuild/<BuildSamplePackagesamplepackageB2962058>:*\",\n          \"Resource::arn:<AWS::Partition>:codebuild:<AWS::Region>:<AWS::AccountId>:report-group/<BuildSamplePackagesamplepackageB2962058>-*\",\n          \"Action::s3:GetBucket*\",\n          \"Action::s3:GetObject*\",\n          \"Action::s3:List*\",\n          \"Action::kms:GenerateDataKey*\",\n          \"Action::kms:ReEncrypt*\",\n          \"Resource::<PipelineArtifactBucketD127CCF6.Arn>/*\"\n        ]\n      }\n    ]);\n\n    NagSuppressions.addResourceSuppressionsByPath(this, \"/TypescriptCdkCicdCodeartifactStack/BuildSamplePackage/sample-packagecodeArtifactPolicy/Resource\", [\n      {\n        id: \"AwsSolutions-IAM5\",\n        reason: \"Defined by a default policy\",\n        appliesTo: [\n          \"Resource::*\",\n          \"Action::codeartifact:List*\"\n        ]\n      }\n    ]);\n\n  }\n}\n\n'aws-cdk-typescript-codepipeline-codeartifact-sample/test/typescript-cdk-cicd-codeartifact.test.ts'\n:// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\nimport * as cdk from 'aws-cdk-lib';\nimport { Template } from 'aws-cdk-lib/assertions';\nimport * as TypescriptCdkCicdCodeartifact from '../lib/typescript-cdk-cicd-codeartifact-stack';\n\ntest('CodeCommit repo created', () => {\n  const app = new cdk.App();\n    // WHEN\n  const stack = new TypescriptCdkCicdCodeartifact.TypescriptCdkCicdCodeartifactStack(app, 'TypescriptCdkCicdCodeartifactStack');\n    // THEN\n  const template = Template.fromStack(stack);\n\n  template.hasResourceProperties('AWS::CodeCommit::Repository', {\n      RepositoryName: \"TypeScriptSampleRepository\"\n  });\n});\n\n",
        "called_code_segment": "const repo = new Repository(this, \"CodeCommitRepository\",{\n      repositoryName:'TypeScriptSampleRepository'\n    });",
        "invoking_code_segment": "import {Repository} from 'aws-cdk-lib/aws-codecommit';",
        "new_file_code_segment": "export class AdditionalFeature {\n  constructor(scope: Construct, id: string) {\n    // Additional feature implementation\n  }\n}",
        "feature_description": "Add a new feature to log repository events to CloudWatch Logs.",
        "detailed_feature_description": "The new feature involves creating a CloudWatch Logs group and configuring the CodeCommit repository to log events to this group. This will be implemented in a new file (#file 3) and integrated into the existing stack in #file 1. The modification in #file 1 will involve adding the new feature to the repository creation process, and #file 2 will remain unchanged as it only imports and uses the repository construct.",
        "modified_complete_code": {
            "#file 1": "//Modify\nconst repo = new Repository(this, \"CodeCommitRepository\",{\n      repositoryName:'TypeScriptSampleRepository'\n    });\n\n//New\nconst additionalFeature = new AdditionalFeature(this, \"AdditionalFeature\");",
            "#file 2": "import {Repository} from 'aws-cdk-lib/aws-codecommit';",
            "#file 3": "import {Construct} from 'constructs';\nimport {LogGroup, RetentionDays} from 'aws-cdk-lib/aws-logs';\nimport {Repository} from 'aws-cdk-lib/aws-codecommit';\n\nexport class AdditionalFeature {\n  constructor(scope: Construct, id: string) {\n    const logGroup = new LogGroup(scope, 'RepositoryLogs', {\n      logGroupName: '/aws/codecommit/TypeScriptSampleRepository',\n      retention: RetentionDays.ONE_WEEK,\n    });\n\n    const repo = Repository.fromRepositoryName(scope, 'ImportedRepo', 'TypeScriptSampleRepository');\n    repo.onEvent('RepoEvent', {\n      target: new targets.CloudWatchLogGroup(logGroup),\n    });\n  }\n}"
        }
    },
    {
        "repo": "babel",
        "content": "'babel/src/constants.ts'\n:export const ALPHA = \"abcdefghijklmnopqrstuvwxyz.,!?- \";\nexport const WALLS = 4;\nexport const SHELVES = 5;\nexport const BOOKS = 32;\nexport const PAGES = 410;\nexport const LINES = 40;\nexport const CHARS = 80;\nexport const PAGE_LENGTH = LINES * CHARS;\nexport const BOOK_LENGTH = PAGE_LENGTH * PAGES;\nexport const BASE32_ALPHA = \"0123456789abcdefghijklmnopqrstuv\";\nexport const BASE32_LAST = BASE32_ALPHA[BASE32_ALPHA.length - 1];\n\n'babel/src/utils/gen-constants.ts'\n:import fs from \"fs\";\nimport { init as gmp_init, GMPFunctions, mpz_ptr } from \"gmp-wasm\";\nimport { ALPHA, BOOK_LENGTH, BASE32_ALPHA, BASE32_LAST } from \"../constants\";\n\nasync function isCoprime(binding: GMPFunctions, a: mpz_ptr, b: mpz_ptr) {\n  const gcd = binding.mpz_t();\n  binding.mpz_init(gcd);\n  binding.mpz_gcd(gcd, a, b);\n\n  return binding.mpz_cmp_ui(gcd, 1) === 0;\n}\n\nasync function findModularInverse(\n  binding: GMPFunctions,\n  num: mpz_ptr,\n  mod: mpz_ptr\n) {\n  const gcd = binding.mpz_t();\n  binding.mpz_init(gcd);\n\n  const x = binding.mpz_t();\n  binding.mpz_init(x);\n\n  const y = binding.mpz_t();\n  binding.mpz_init(y);\n\n  binding.mpz_gcdext(gcd, x, y, num, mod);\n\n  const inverseExists = binding.mpz_cmp_ui(gcd, 1) === 0;\n\n  const result = binding.mpz_t();\n  binding.mpz_init(result);\n\n  if (inverseExists) {\n    binding.mpz_mod(result, y, mod);\n    if (binding.mpz_sgn(result) < 0) {\n      binding.mpz_add(result, result, mod);\n    }\n  }\n\n  return { inverseExists, result };\n}\n\n(async () => {\n  const { binding } = await gmp_init();\n\n  const N = binding.mpz_t();\n  binding.mpz_init(N);\n  binding.mpz_set_string(\n    N,\n    new Array(BOOK_LENGTH).fill(BASE32_LAST).join(\"\"),\n    ALPHA.length\n  );\n\n  let randomStartNum = BASE32_LAST;\n  for (let i = 1; i < BOOK_LENGTH; i++) {\n    randomStartNum +=\n      BASE32_ALPHA[Math.floor(Math.random() * BASE32_ALPHA.length)];\n  }\n\n  const C = binding.mpz_t();\n  binding.mpz_init(C);\n  binding.mpz_set_string(C, randomStartNum, ALPHA.length);\n\n  while (binding.mpz_cmp_ui(C, 0) > 0) {\n    const foundCoprime = await isCoprime(binding, N, C);\n\n    if (foundCoprime) {\n      const { result, inverseExists } = await findModularInverse(binding, N, C);\n\n      if (inverseExists) {\n        const nString = binding.mpz_to_string(N, ALPHA.length);\n        const cString = binding.mpz_to_string(C, ALPHA.length);\n        const iString = binding.mpz_to_string(result, ALPHA.length);\n\n        fs.writeFileSync(\"numbers\", `${nString}\\n${cString}\\n${iString}`);\n\n        break;\n      } else {\n        console.log(\"modular inverse does not exist\");\n        break;\n      }\n    }\n\n    binding.mpz_sub_ui(C, C, 1);\n  }\n\n  await binding.reset();\n})();\n\n",
        "called_code_segment": "async function isCoprime(binding: GMPFunctions, a: mpz_ptr, b: mpz_ptr) {\n  const gcd = binding.mpz_t();\n  binding.mpz_init(gcd);\n  binding.mpz_gcd(gcd, a, b);\n\n  return binding.mpz_cmp_ui(gcd, 1) === 0;\n}",
        "invoking_code_segment": "while (binding.mpz_cmp_ui(C, 0) > 0) {\n  const foundCoprime = await isCoprime(binding, N, C);\n\n  if (foundCoprime) {\n    const { result, inverseExists } = await findModularInverse(binding, N, C);\n\n    if (inverseExists) {\n      const nString = binding.mpz_to_string(N, ALPHA.length);\n      const cString = binding.mpz_to_string(C, ALPHA.length);\n      const iString = binding.mpz_to_string(result, ALPHA.length);\n\n      fs.writeFileSync(\"numbers\", `${nString}\\n${cString}\\n${iString}`);\n\n      break;\n    } else {\n      console.log(\"modular inverse does not exist\");\n      break;\n    }\n  }\n\n  binding.mpz_sub_ui(C, C, 1);\n}",
        "new_file_code_segment": "export async function logCoprimeStatus(binding: GMPFunctions, a: mpz_ptr, b: mpz_ptr) {\n  const isCoprimeResult = await isCoprime(binding, a, b);\n  console.log(`Numbers are coprime: ${isCoprimeResult}`);\n  return isCoprimeResult;\n}",
        "feature_description": "Add logging for coprime status during the coprime check.",
        "detailed_feature_description": "The new feature introduces logging to indicate whether the numbers being checked for coprimality are indeed coprime. This is implemented in a new file (#file 3) which exports a function `logCoprimeStatus`. This function calls the existing `isCoprime` function and logs the result before returning it. The existing code in #file 1 is modified to use this new function instead of directly calling `isCoprime`.",
        "modified_complete_code": {
            "#file 1": "async function isCoprime(binding: GMPFunctions, a: mpz_ptr, b: mpz_ptr) {\n  const gcd = binding.mpz_t();\n  binding.mpz_init(gcd);\n  binding.mpz_gcd(gcd, a, b);\n\n  return binding.mpz_cmp_ui(gcd, 1) === 0;\n}",
            "#file 2": "(async () => {\n  const { binding } = await gmp_init();\n\n  const N = binding.mpz_t();\n  binding.mpz_init(N);\n  binding.mpz_set_string(\n    N,\n    new Array(BOOK_LENGTH).fill(BASE32_LAST).join(\"\"),\n    ALPHA.length\n  );\n\n  let randomStartNum = BASE32_LAST;\n  for (let i = 1; i < BOOK_LENGTH; i++) {\n    randomStartNum +=\n      BASE32_ALPHA[Math.floor(Math.random() * BASE32_ALPHA.length)];\n  }\n\n  const C = binding.mpz_t();\n  binding.mpz_init(C);\n  binding.mpz_set_string(C, randomStartNum, ALPHA.length);\n\n  while (binding.mpz_cmp_ui(C, 0) > 0) {\n    const foundCoprime = await logCoprimeStatus(binding, N, C); #Modify\n\n    if (foundCoprime) {\n      const { result, inverseExists } = await findModularInverse(binding, N, C);\n\n      if (inverseExists) {\n        const nString = binding.mpz_to_string(N, ALPHA.length);\n        const cString = binding.mpz_to_string(C, ALPHA.length);\n        const iString = binding.mpz_to_string(result, ALPHA.length);\n\n        fs.writeFileSync(\"numbers\", `${nString}\\n${cString}\\n${iString}`);\n\n        break;\n      } else {\n        console.log(\"modular inverse does not exist\");\n        break;\n      }\n    }\n\n    binding.mpz_sub_ui(C, C, 1);\n  }\n\n  await binding.reset();\n})();",
            "#file 3": "export async function logCoprimeStatus(binding: GMPFunctions, a: mpz_ptr, b: mpz_ptr) {\n  const isCoprimeResult = await isCoprime(binding, a, b);\n  console.log(`Numbers are coprime: ${isCoprimeResult}`);\n  return isCoprimeResult;\n} #New"
        }
    },
    {
        "repo": "better-fn",
        "content": "'better-fn/src/modules/tools.ts'\n:export const insertAfter = (newNode: Node, referenceNode: Node): boolean => {\n  if (referenceNode.parentNode)\n    referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n  else console.error(\"fail to insert dom, %o has no parentNode\", referenceNode);\n\n  return Boolean(referenceNode.parentNode);\n};\n\nexport const unwarp = (el: HTMLElement) => {\n  // get the element's parent node\n  const parent = el.parentNode;\n\n  if (parent) {\n    // move all children out of the element\n    while (el.firstChild) parent.insertBefore(el.firstChild, el);\n    // remove the empty element\n    parent.removeChild(el);\n  }\n};\n\n'better-fn/src/modules/renderChild.ts'\n:import \"tippy.js/dist/tippy.css\";\nimport \"./theme.css\";\nimport \"tippy.js/animations/shift-toward-subtle.css\";\n\nimport { infoList } from \"processor\";\nimport tippy, { Instance, Props } from \"tippy.js\";\n\nimport { unwarp } from \"./tools\";\n\ntippy.setDefaultProps({\n  interactive: true,\n  arrow: true,\n  theme: \"obsidian\",\n  placement: \"bottom\",\n  delay: [100, 0],\n  trigger: \"mouseenter click\",\n  hideOnClick: true,\n  animation: \"shift-toward-subtle\",\n  duration: [200, 150],\n  allowHTML: true,\n  zIndex:\n    +getComputedStyle(document.body)\n      .getPropertyValue(\"--layer-popover\")\n      .trim() ?? 30,\n});\n\nexport type bridgeInfo = {\n  sourcePath: string;\n  refEl: HTMLElement;\n  popover: popover | null;\n};\n\ntype popover = {\n  tippy: Instance<Props>;\n  html: string;\n};\n\ntype mutationParam = {\n  callback: MutationCallback;\n  option: MutationObserverInit;\n};\n/**\n * Create new Popper instance for footnote popover\n * @param contentEl the element whose children will be used as popover content\n * @param infoIndex index used to fetch reference element from infoList\n * @returns Popper.Instance\n */\nexport function createPopover(\n  infoList: infoList,\n  contentEl: HTMLElement,\n  infoKey: string,\n  showButtom?: boolean,\n): popover;\nexport function createPopover(\n  infoList: infoList,\n  html: string,\n  infoKey: string,\n  showButtom?: boolean,\n): popover;\nexport function createPopover(\n  infoList: infoList,\n  contentEl: HTMLElement,\n  refEl: HTMLElement,\n  showButtom?: boolean,\n): popover;\nexport function createPopover(\n  infoList: infoList,\n  html: string,\n  refEl: HTMLElement,\n  showButtom?: boolean,\n): popover;\n// eslint-disable-next-line prefer-arrow/prefer-arrow-functions\nexport function createPopover(\n  infoList: infoList,\n  elOrHtml: HTMLElement | string,\n  keyOrEl: string | HTMLElement,\n  showButtom = false,\n): popover {\n  let html: string;\n  const contentEl = typeof elOrHtml !== \"string\" ? elOrHtml : null;\n\n  if (contentEl) {\n    // unwarp <p>\n    const warpped = contentEl.querySelector(\"p\");\n    if (warpped) unwarp(warpped);\n\n    html = contentEl.innerHTML;\n  } else html = elOrHtml as string;\n\n  if (typeof keyOrEl === \"string\" && !infoList.has(keyOrEl)) {\n    console.error(\"no info for key %s in %o\", keyOrEl, infoList);\n    throw new TypeError(\"no info for key\");\n  }\n\n  const refEl =\n    typeof keyOrEl === \"string\"\n      ? (infoList.get(keyOrEl) as bridgeInfo).refEl\n      : keyOrEl;\n  const key = typeof keyOrEl === \"string\" ? keyOrEl : keyOrEl.id;\n\n  if (!refEl.parentElement) throw new Error(\"no parent for refEl\");\n  const warpper = createSpan();\n  refEl.parentElement.insertBefore(warpper, refEl);\n  warpper.appendChild(refEl);\n  const instance = tippy(refEl, {\n    content: html,\n    appendTo: warpper,\n    onTrigger: (inst, evt) => {\n      if (evt.type === \"click\") {\n        const defaultValue = tippy.defaultProps.zIndex;\n        inst.popper.style.zIndex = (defaultValue - 1).toString();\n      }\n    },\n  });\n\n  refEl.addEventListener(\"dblclick\", (evt) => {\n    const child = refEl.firstElementChild;\n    if (child instanceof HTMLAnchorElement && showButtom) {\n      child.click();\n    }\n  });\n\n  // Monitor internal embed loadings\n  if (typeof elOrHtml !== \"string\") {\n    const srcEl = elOrHtml;\n    let allInternalEmbeds;\n    if ((allInternalEmbeds = srcEl.querySelectorAll(\"span.internal-embed\"))) {\n      const markdownEmbed: mutationParam = {\n        // observer should keep connected to track updates in embeded content\n        callback: () => instance.setContent(srcEl.innerHTML),\n        // If the element being observed is removed from the DOM,\n        // and then subsequently released by the browser's garbage collection mechanism,\n        // the MutationObserver is likewise deleted.\n        option: {\n          childList: true,\n          subtree: true,\n        },\n      };\n\n      const internalEmbed: mutationParam = {\n        callback: (list, obs) => {\n          for (const mutation of list) {\n            const span = mutation.target as HTMLSpanElement;\n\n            if (span.hasClass(\"is-loaded\")) {\n              if (span.firstElementChild?.matches(\"div.markdown-embed\")) {\n                const mdObs = new MutationObserver(markdownEmbed.callback);\n                mdObs.observe(span.firstElementChild, markdownEmbed.option);\n              } else instance.setContent(srcEl.innerHTML);\n              obs.disconnect();\n            }\n          }\n        },\n        option: { attributeFilter: [\"class\"] },\n      };\n\n      for (const span of allInternalEmbeds) {\n        const ieObs = new MutationObserver(internalEmbed.callback);\n        ieObs.observe(span, internalEmbed.option);\n      }\n    }\n    let allMathEmbeds;\n    if ((allMathEmbeds = srcEl.querySelectorAll(\"span.math\"))) {\n      const mathEmbed: mutationParam = {\n        callback: (list, obs) => {\n          for (const mutation of list) {\n            const span = mutation.target as HTMLSpanElement;\n            if (span.hasClass(\"is-loaded\")) {\n              instance.setContent(srcEl.innerHTML);\n              obs.disconnect();\n            }\n          }\n        },\n        option: { attributeFilter: [\"class\"] },\n      };\n\n      for (const span of allMathEmbeds) {\n        const mathObs = new MutationObserver(mathEmbed.callback);\n        mathObs.observe(span, mathEmbed.option);\n      }\n    }\n  }\n\n  const info = infoList.get(key) as bridgeInfo;\n  if (info.popover) info.popover.tippy.destroy();\n  const out = {\n    tippy: instance,\n    html: html,\n  };\n  info.popover = out;\n  return out;\n}\n\n",
        "called_code_segment": "export function createPopover(infoList: infoList, elOrHtml: HTMLElement | string, keyOrEl: string | HTMLElement, showButtom = false): popover { ... }",
        "invoking_code_segment": "const popover = createPopover(infoList, contentEl, infoKey, showButtom);",
        "new_file_code_segment": "export function updatePopoverContent(popover: popover, newContent: string) { popover.tippy.setContent(newContent); popover.html = newContent; }",
        "feature_description": "Add a feature to update the content of an existing popover.",
        "detailed_feature_description": "The new feature allows updating the content of an existing popover dynamically. This is implemented by adding a new function `updatePopoverContent` in #file 3. The function takes an existing popover instance and new content as parameters, updates the popover's content, and updates the stored HTML. #file 1 is updated to import and use this new function when needed, and #file 2 is updated to demonstrate how to invoke this new functionality.",
        "modified_complete_code": {
            "#file 1": "import { updatePopoverContent } from './file3'; //Modify\n\nexport function createPopover(infoList: infoList, elOrHtml: HTMLElement | string, keyOrEl: string | HTMLElement, showButtom = false): popover { ... }",
            "#file 2": "import { createPopover, updatePopoverContent } from './file1'; //Modify\n\nconst popover = createPopover(infoList, contentEl, infoKey, showButtom);\n// Example usage of the new feature\nupdatePopoverContent(popover, 'New content for the popover'); //New",
            "#file 3": "export function updatePopoverContent(popover: popover, newContent: string) { popover.tippy.setContent(newContent); popover.html = newContent; }"
        }
    },
    {
        "repo": "c2.js",
        "content": "'c2.js/src/geometry.ts'\n://Created by Ren Yuan\n\n\nexport class Vector {\n    x: number;\n    y: number;\n\n    constructor();\n    constructor(v: Vector);\n    constructor(x: number, y: number);\n    constructor() {\n        if (arguments.length == 1) {\n            this.x = arguments[0].x;\n            this.y = arguments[0].y;\n        } else if (arguments.length == 2) {\n            this.x = arguments[0];\n            this.y = arguments[1];\n        } else {\n            this.x = 0;\n            this.y = 0;\n        }\n    }\n\n    copy(): Vector {\n        return new Vector(this.x, this.y);\n    }\n\n    mag(): number {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n\n    magSq(): number {\n        return this.x * this.x + this.y * this.y;\n    }\n\n    angle();\n    angle(v: Vector): number;\n    angle() {\n        if (arguments.length == 0) {\n            return Math.atan2(this.y, this.x);\n        } else if (arguments.length == 1) {\n            let a = this.normalize();\n            let b = arguments[0].normalize();\n            return Math.sign(a.cross(b)) * Math.acos(a.dot(b));\n        }\n    }\n\n    add(v: Vector): Vector;\n    add(x: number, y: number): Vector;\n    add() {\n        if (arguments.length == 1) {\n            return new Vector(this.x + arguments[0].x, this.y + arguments[0].y);\n        } else if (arguments.length == 2) {\n            return new Vector(this.x + arguments[0], this.y + arguments[1]);\n        }\n    }\n\n    sub(v: Vector): Vector;\n    sub(x: number, y: number): Vector;\n    sub() {\n        if (arguments.length == 1) {\n            return new Vector(this.x - arguments[0].x, this.y - arguments[0].y);\n        } else if (arguments.length == 2) {\n            return new Vector(this.x - arguments[0], this.y - arguments[1]);\n        }\n    }\n\n    mult(n: number): Vector {\n        return new Vector(this.x * n, this.y * n);\n    }\n\n    div(n: number): Vector {\n        return new Vector(this.x / n, this.y / n);\n    }\n\n    dot(v: Vector): number {\n        return this.x * v.x + this.y * v.y;\n    }\n\n    cross(v: Vector): number {\n        return this.x * v.y - v.x * this.y;\n    }\n\n    normalize(): Vector {\n        let m = this.x * this.x + this.y * this.y;\n        if (m > 0) {\n            m = Math.sqrt(m);\n            return new Vector(this.x / m, this.y / m);\n        }\n        return new Vector();\n    }\n\n    limit(n: number): Vector {\n        if (this.magSq() > n * n) return this.normalize().mult(n);\n        return this.copy();\n    }\n\n    invert(): Vector {\n        return new Vector(-this.x, -this.y);\n    }\n\n    perpendicular(): Vector {\n        return new Vector(-this.y, this.x);\n    }\n\n    projection(v: Vector): Vector {\n        let n = v.normalize();\n        return n.mult(this.dot(n));\n    }\n\n    reflect(v: Vector): Vector {\n        let n = v.normalize();\n        return n.mult(this.dot(n) * 2).sub(this);\n    }\n\n    rotate(a): Vector {\n        return new Vector(Math.cos(a) * this.x - Math.sin(a) * this.y, Math.sin(a) * this.x + Math.cos(a) * this.y);\n    }\n\n    distance(v: Vector): number {\n        let dx = this.x - v.x;\n        let dy = this.y - v.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    distanceSq(v: Vector): number {\n        let dx = this.x - v.x;\n        let dy = this.y - v.y;\n        return dx * dx + dy * dy;\n    }\n}\n\n\n\n\nexport class Point {\n    x: number;\n    y: number;\n\n    constructor();\n    constructor(p: Point);\n    constructor(x: number, y: number);\n    constructor() {\n        if (arguments.length == 1) {\n            this.x = arguments[0].x;\n            this.y = arguments[0].y;\n        } else if (arguments.length == 2) {\n            this.x = arguments[0];\n            this.y = arguments[1];\n        } else {\n            this.x = 0;\n            this.y = 0;\n        }\n    }\n\n    translate(x: number, y: number): Point {\n        this.x += x;\n        this.y += y;\n        return this;\n    }\n\n    rotate(a: number): Point;\n    rotate(a: number, p: Point): Point;\n    rotate() {\n        if (arguments.length == 1) {\n            let dx = this.x;\n            let dy = this.y;\n            this.x = Math.cos(arguments[0]) * dx - Math.sin(arguments[0]) * dy;\n            this.y = Math.sin(arguments[0]) * dx + Math.cos(arguments[0]) * dy;\n        } else if (arguments.length == 2) {\n            let dx = this.x - arguments[1].x;\n            let dy = this.y - arguments[1].y;\n            this.x = arguments[1].x + Math.cos(arguments[0]) * dx - Math.sin(arguments[0]) * dy;\n            this.y = arguments[1].y + Math.sin(arguments[0]) * dx + Math.cos(arguments[0]) * dy;\n        }\n        return this;\n    }\n\n    scale(s: number): Point;\n    scale(s: number, p: Point): Point;\n    scale() {\n        if (arguments.length == 1) {\n            this.x *= arguments[0];\n            this.y *= arguments[0];\n        } else if (arguments.length == 2) {\n            this.x = arguments[1].x + (this.x - arguments[1].x) * arguments[0];\n            this.y = arguments[1].y + (this.y - arguments[1].y) * arguments[0];\n        }\n        return this;\n    }\n\n    copy(): Point {\n        return new Point(this.x, this.y);\n    }\n\n    distance(p: Point): number {\n        let dx = this.x - p.x;\n        let dy = this.y - p.y;\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n\n    distanceSq(p: Point): number {\n        let dx = this.x - p.x;\n        let dy = this.y - p.y;\n        return dx * dx + dy * dy;\n    }\n\n    lerp(p: Point, t: number): Point {\n        return new Point(this.x + (p.x - this.x) * t, this.y + (p.y - this.y) * t);\n    }\n}\n\n\n\n\nexport class Line {\n    p1: Point;\n    p2: Point;\n\n    constructor(p1: Point, p2: Point);\n    constructor(x1: number, y1: number, x2: number, y2: number);\n    constructor() {\n        if (arguments.length == 2) {\n            this.p1 = arguments[0];\n            this.p2 = arguments[1];\n        } else if (arguments.length == 4) {\n            this.p1 = new Point(arguments[0], arguments[1]);\n            this.p2 = new Point(arguments[2], arguments[3]);\n        }\n    }\n\n    translate(x: number, y: number): Line {\n        this.p1.translate(x, y);\n        this.p2.translate(x, y);\n        return this;\n    }\n\n    rotate(a: number): Line;\n    rotate(a: number, p: Point): Line;\n    rotate() {\n        if (arguments.length == 1) {\n            this.p1.rotate(arguments[0]);\n            this.p2.rotate(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p1.rotate(arguments[0], arguments[1]);\n            this.p2.rotate(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    scale(s: number): Line;\n    scale(s: number, p: Point): Line;\n    scale() {\n        if (arguments.length == 1) {\n            this.p1.scale(arguments[0]);\n            this.p2.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p1.scale(arguments[0], arguments[1]);\n            this.p2.scale(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    reverse(): Line {\n        let temp = this.p1;\n        this.p1 = this.p2;\n        this.p2 = temp;\n        return this;\n    }\n\n    copy(): Line {\n        return new Line(this.p1.copy(), this.p2.copy());\n    }\n\n    bounds(): Rect {\n        return new Rect(this.p1.copy(), this.p2.copy());\n    }\n\n    length(): number {\n        return this.p1.distance(this.p2);\n    }\n\n    angle(): number {\n        return new Vector(this.p2.x - this.p1.x, this.p2.y - this.p1.y).angle();\n    }\n\n    direction(): Vector {\n        return new Vector(this.p2.x - this.p1.x, this.p2.y - this.p1.y).normalize();\n    }\n\n    normal(): Vector {\n        return this.direction().perpendicular();\n    }\n\n    middle(): Point {\n        return this.p1.lerp(this.p2, 0.5);\n    }\n\n    point(t: number): Point {\n        return this.p1.lerp(this.p2, t);\n    }\n\n    lerp(l: Line, t: number): Line {\n        let p1 = this.p1.lerp(l.p1, t);\n        let p2 = this.p2.lerp(l.p2, t);\n        return new Line(p1, p2);\n    }\n\n    closest(p: Point): Point {\n        let v1 = new Vector(p.x - this.p1.x, p.y - this.p1.y);\n        let v2 = new Vector(this.p2.x - this.p1.x, this.p2.y - this.p1.y);\n        let t = v1.dot(v2) / v2.dot(v2);\n        if (t <= 0) return this.p1.copy();\n        if (t >= 1) return this.p2.copy();\n        return this.p1.lerp(this.p2, t);\n    }\n\n    distance(p: Point): number {\n        return p.distance(this.closest(p));\n    }\n\n    intersects(l: Line): boolean{\n        let v1 = new Vector(this.p2.x - this.p1.x, this.p2.y - this.p1.y);\n        let v2 = new Vector(l.p2.x - l.p1.x, l.p2.y - l.p1.y);\n        let v3 = new Vector(l.p1.x - this.p1.x, l.p1.y - this.p1.y);\n        let v4 = v1.perpendicular();\n        let v5 = v2.perpendicular();\n        let t = v3.dot(v5) / v1.dot(v5);\n        let u = -v3.dot(v4) / v2.dot(v4);\n\n        return t >= 0 && t <= 1 && u >= 0 && u <= 1;\n    }\n\n    intersection(l: Line): Point | null{\n        let v1 = new Vector(this.p2.x - this.p1.x, this.p2.y - this.p1.y);\n        let v2 = new Vector(l.p2.x - l.p1.x, l.p2.y - l.p1.y);\n        let v3 = new Vector(l.p1.x - this.p1.x, l.p1.y - this.p1.y);\n        let v4 = v1.perpendicular();\n        let v5 = v2.perpendicular();\n        let t = v3.dot(v5) / v1.dot(v5);\n        let u = -v3.dot(v4) / v2.dot(v4);\n\n        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n            let v = v1.mult(t);\n            return new Point(this.p1.x + v.x, this.p1.y + v.y);\n        } else {\n            return null;\n        }\n    }\n\n    split(data: number[]): Line[] {\n        let sum = data.reduce((a, b) => a + b);\n\n        let points = new Array(data.length + 1);\n        points[0] = this.p1;\n        points[data.length] = this.p2;\n        let t = 0;\n        for (let i = 0; i < data.length - 1; i++) {\n            t += data[i] / sum;\n            points[i + 1] = this.p1.lerp(this.p2, t);\n        }\n\n        let lines = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            lines[i] = new Line(points[i].copy(), points[i + 1].copy());\n        }\n        return lines;\n    }\n}\n\n\n\n\nexport class Arc {\n    p: Point;\n    r: number;\n    start: number;\n    end: number;\n\n    constructor(p: Point, r: number, start: number, end: number);\n    constructor(x: number, y: number, r: number, start: number, end: number);\n    constructor() {\n        if (arguments.length == 4) {\n            this.p = arguments[0];\n            this.r = arguments[1];\n            this.start = arguments[2];\n            this.end = arguments[3];\n        } else if (arguments.length == 5) {\n            this.p = new Point(arguments[0], arguments[1]);\n            this.r = arguments[2];\n            this.start = arguments[3];\n            this.end = arguments[4];\n        }\n        if (this.start > this.end) {\n            let temp = this.start;\n            this.start = this.end;\n            this.end = temp;\n        }\n    }\n\n    translate(x: number, y: number): Arc {\n        this.p.translate(x, y);\n        return this;\n    }\n\n    rotate(a: number): Arc;\n    rotate(a: number, p: Point): Arc;\n    rotate() {\n        if (arguments.length == 1) {\n            this.p.rotate(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p.rotate(arguments[0], arguments[1]);\n        }\n        this.start += arguments[0];\n        this.end += arguments[0];\n        return this;\n    }\n\n    scale(s: number): Arc;\n    scale(s: number, p: Point): Arc;\n    scale() {\n        if (arguments.length == 1) {\n            this.p.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p.scale(arguments[0], arguments[1]);\n        }\n        this.r *= arguments[0];\n        return this;\n    }\n\n    copy(): Arc {\n        return new Arc(this.p.copy(), this.r, this.start, this.end);\n    }\n\n    bounds(): Rect {\n        let p1 = new Point(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        let p2 = new Point(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n        let step = Math.PI / 2;\n        let start = Math.floor(this.start / step) * step;\n        let angle = start + step;\n        let p = new Point();\n        for (let i = 0; i < 4 && angle < this.end; i++) {\n            p.x = this.p.x + Math.cos(angle) * this.r;\n            p.y = this.p.y + Math.sin(angle) * this.r;\n            p1.x = Math.min(p1.x, p.x);\n            p1.y = Math.min(p1.y, p.y);\n            p2.x = Math.max(p2.x, p.x);\n            p2.y = Math.max(p2.y, p.y);\n            angle += step;\n        }\n        p = this.point(0);\n        p1.x = Math.min(p1.x, p.x);\n        p1.y = Math.min(p1.y, p.y);\n        p2.x = Math.max(p2.x, p.x);\n        p2.y = Math.max(p2.y, p.y);\n        p = this.point(1);\n        p1.x = Math.min(p1.x, p.x);\n        p1.y = Math.min(p1.y, p.y);\n        p2.x = Math.max(p2.x, p.x);\n        p2.y = Math.max(p2.y, p.y);\n        return new Rect(p1, p2);\n    }\n\n    length(): number {\n        return (this.end - this.start) * this.r;\n    }\n\n    middle(): Point {\n        return this.point(0.5);\n    }\n\n    point(t: number): Point {\n        let a = this.start + (this.end - this.start) * t;\n        let x = this.p.x + Math.cos(a) * this.r;\n        let y = this.p.y + Math.sin(a) * this.r;\n        return new Point(x, y);\n    }\n\n    lerp(a: Arc, t: number): Arc {\n        let p = this.p.lerp(a.p, t);\n        let r = this.r + (a.r - this.r) * t;\n        let start = this.start + (a.start - this.start) * t;\n        let end = this.end + (a.end - this.end) * t;\n        return new Arc(p, r, start, end);\n    }\n\n    contains(v: Vector): boolean {\n        let a = v.angle();\n        if (a < 0) a += 2 * Math.PI;\n        let start = this.start % (2 * Math.PI);\n        let end = this.end % (2 * Math.PI);\n        return end <= start ? (a > start && a < 2 * Math.PI || a > 0 && a < end) : (a > start && a < end);\n    }\n\n    closest(p: Point): Point {\n        let v = new Vector(p.x - this.p.x, p.y - this.p.y);\n        if (this.contains(v)) {\n            v = v.normalize().mult(this.r).add(this.p.x, this.p.y)\n            return new Point(v.x, v.y);\n        } else {\n            let p1 = this.point(0);\n            let p2 = this.point(1);\n            return p.distanceSq(p1) < p.distanceSq(p2) ? p1 : p2;\n        }\n    }\n\n    distance(p: Point) {\n        return p.distance(this.closest(p));\n    }\n\n    polyline(n: number): Polyline {\n        let points = new Array(n + 1);\n        for (let i = 0; i <= n; i++) {\n            let a = this.start + (this.end - this.start) * i / n;\n            let x = this.p.x + Math.cos(a) * this.r;\n            let y = this.p.y + Math.sin(a) * this.r;\n            points[i] = new Point(x, y);\n        }\n        return new Polyline(points);\n    }\n\n    split(data: number[]): Arc[] {\n        let sum = data.reduce((a, b) => a + b);\n\n        let angles = new Array(data.length + 1);\n        angles[0] = this.start;\n        angles[data.length] = this.end;\n        let a = this.start;\n        for (let i = 0; i < data.length - 1; i++) {\n            a += data[i] / sum * (this.end - this.start);\n            angles[i + 1] = a;\n        }\n\n        let arcs = new Array(data.length);\n        for (let i = 0; i < arcs.length; i++) {\n            arcs[i] = new Arc(this.p.copy(), this.r, angles[i], angles[i + 1]);\n        }\n        return arcs;\n    }\n}\n\n\n\n\nexport class Polyline {\n    vertices: Point[];\n\n    constructor();\n    constructor(points: Point[]);\n    constructor() {\n        if (arguments.length == 1) {\n            this.vertices = arguments[0];\n        } else {\n            this.vertices = new Array();\n        }\n    }\n\n    add(p: Point): Polyline;\n    add(x: number, y: number): Polyline;\n    add() {\n        if (arguments.length == 1) {\n            this.vertices.push(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.vertices.push(new Point(arguments[0], arguments[1]));\n        }\n        return this;\n    }\n\n    clear(){\n        this.vertices = [];\n    }\n\n    translate(x, y): Polyline {\n        for (let v of this.vertices) v.translate(x, y);\n        return this;\n    }\n\n    rotate(a: number): Polyline;\n    rotate(a: number, p: Point): Polyline;\n    rotate() {\n        if (arguments.length == 1) {\n            for (let v of this.vertices) v.rotate(arguments[0]);\n        } else if (arguments.length == 2) {\n            for (let v of this.vertices) v.rotate(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    scale(s: number): Polyline;\n    scale(s: number, p: Point): Polyline;\n    scale() {\n        if (arguments.length == 1) {\n            for (let v of this.vertices) v.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            for (let v of this.vertices) v.scale(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    reverse(): Polyline {\n        this.vertices.reverse();\n        return this;\n    }\n\n    copy(): Polyline {\n        let points = new Array(this.vertices.length);\n        for (let i = 0; i < this.vertices.length; i++) {\n            points[i] = this.vertices[i].copy();\n        }\n        return new Polyline(points);\n    }\n\n    edges(): Line[] {\n        let lines = new Array();\n        for (let i = 0; i < this.vertices.length - 1; i++) {\n            let p1 = this.vertices[i];\n            let p2 = this.vertices[i + 1];\n            lines.push(new Line(p1, p2));\n        }\n        return lines;\n    }\n\n    bounds(): Rect {\n        let p1 = new Point(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        let p2 = new Point(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n        for (let p of this.vertices) {\n            p1.x = Math.min(p1.x, p.x);\n            p1.y = Math.min(p1.y, p.y);\n            p2.x = Math.max(p2.x, p.x);\n            p2.y = Math.max(p2.y, p.y);\n        }\n        return new Rect(p1, p2);\n    }\n\n    length(): number {\n        let length = 0;\n        for (let i = 0; i < this.vertices.length - 1; i++) {\n            let p1 = this.vertices[i];\n            let p2 = this.vertices[i + 1];\n            length += p1.distance(p2);\n        }\n        return length;\n    }\n\n    closest(p: Point): Point {\n        let cp;\n        let dmin = Number.POSITIVE_INFINITY;\n        for (let i = 0; i < this.vertices.length - 1; i++) {\n            let l = new Line(this.vertices[i], this.vertices[i + 1]);\n            let lp = l.closest(p);\n            let d = p.distanceSq(lp);\n            if (d < dmin) {\n                cp = lp;\n                dmin = d;\n            }\n        }\n        return cp;\n    }\n\n    distance(p: Point): number {\n        return p.distance(this.closest(p));\n    }\n}\n\n\n\n\nexport class Spline {\n    points: Point[];\n    vertices: Point[];\n\n    constructor();\n    constructor(points: Point[]);\n    constructor() {\n        if (arguments.length == 1) {\n            this.points = arguments[0];\n        } else {\n            this.points = new Array();\n        }\n    }\n\n    compute(mode: string = 'clamped', detail: number = 20) { //clamped (default), open, closed\n        if (this.points.length < 4) return;\n        let points = new Array();\n        if (mode == 'open') {\n            points = points.concat(this.points);\n        } else if (mode == 'closed') {\n            points.push(this.points[this.points.length - 2]);\n            points.push(this.points[this.points.length - 1]);\n            points = points.concat(this.points);\n            points.push(this.points[0]);\n        } else { //clamped\n            points.push(this.points[0]);\n            points = points.concat(this.points);\n            points.push(this.points[this.points.length - 1]);\n        }\n\n        this.vertices = new Array();\n        for (let i = 0; i < points.length - 3; i++) {\n            let p1 = points[i];\n            let p2 = points[i + 1];\n            let p3 = points[i + 2];\n            let p4 = points[i + 3];\n            for (let i = 0; i < detail; i++) {\n                let t = i / (detail - 1);\n                this.vertices.push(this.point(p1, p2, p3, p4, t));\n            }\n        }\n    }\n\n    point(p1: number, p2: number, p3: number, p4: number, t: number): Point {\n        let p = (p1, p2, t1, t2) => new Point(p1.x * t1 + p2.x * t2, p1.y * t1 + p2.y * t2);\n        let a1 = p(p1, p2, -t, t + 1);\n        let a2 = p(p2, p3, 1 - t, t);\n        let a3 = p(p3, p4, 2 - t, t - 1);\n        let b1 = p(a1, a2, (1 - t) / 2, (t + 1) / 2);\n        let b2 = p(a2, a3, (2 - t) / 2, t / 2);\n        return p(b1, b2, 1 - t, t);\n    }\n\n    tangent(p1: number, p2: number, p3: number, p4: number, t: number): Vector {\n        let a = this.point(p1, p2, p3, p4, t);\n        let b = this.point(p1, p2, p3, p4, t + 1e-6);\n        return new Vector(b.x - a.x, b.y - a.y).normalize();\n    }\n\n    normal(p1: number, p2: number, p3: number, p4: number, t: number): Vector {\n        return this.tangent(p1, p2, p3, p4, t).perpendicular();\n    }\n\n    add(p: Point): Spline;\n    add(x: number, y: number): Spline;\n    add() {\n        if (arguments.length == 1) {\n            this.points.push(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.points.push(new Point(arguments[0], arguments[1]));\n        }\n        return this;\n    }\n\n    clear(){\n        this.points = [];\n        this.vertices = [];\n    }\n\n    translate(x, y): Spline {\n        for (let v of this.points) v.translate(x, y);\n        return this;\n    }\n\n    rotate(a: number): Spline;\n    rotate(a: number, p: Point): Spline;\n    rotate() {\n        if (arguments.length == 1) {\n            for (let v of this.points) v.rotate(arguments[0]);\n        } else if (arguments.length == 2) {\n            for (let v of this.points) v.rotate(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    scale(s: number): Spline;\n    scale(s: number, p: Point): Spline;\n    scale() {\n        if (arguments.length == 1) {\n            for (let v of this.points) v.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            for (let v of this.points) v.scale(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    reverse(): Spline {\n        this.points.reverse();\n        return this;\n    }\n\n    copy(): Spline {\n        let array = new Array(this.points.length);\n        for (let i = 0; i < this.points.length; i++) {\n            array[i] = this.points[i].copy();\n        }\n        return new Spline(array);\n    }\n}\n\n\n\n\nexport class Sector {\n    p: Point;\n    r1: number;\n    r2: number;\n    start: number;\n    end: number;\n\n    constructor(p: Point, r1: number, r2: number, start: number, end: number);\n    constructor(x: number, y: number, r1: number, r2: number, start: number, end: number);\n    constructor() {\n        if (arguments.length == 5) {\n            this.p = arguments[0];\n            this.r1 = arguments[1];\n            this.r2 = arguments[2];\n            this.start = arguments[3];\n            this.end = arguments[4];\n        } else if (arguments.length == 6) {\n            this.p = new Point(arguments[0], arguments[1]);\n            this.r1 = arguments[2];\n            this.r2 = arguments[3];\n            this.start = arguments[4];\n            this.end = arguments[5];\n        }\n        if (this.start > this.end) {\n            let temp = this.start;\n            this.start = this.end;\n            this.end = temp;\n        }\n    }\n\n    translate(x: number, y: number): Sector {\n        this.p.translate(x, y);\n        return this;\n    }\n\n    rotate(a: number): Sector;\n    rotate(a: number, p: Point): Sector;\n    rotate() {\n        if (arguments.length == 1) {\n            this.p.rotate(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p.rotate(arguments[0], arguments[1]);\n        }\n        this.start += arguments[0];\n        this.end += arguments[0];\n        return this;\n    }\n\n    scale(s: number): Sector;\n    scale(s: number, p: Point): Sector;\n    scale() {\n        if (arguments.length == 1) {\n            this.p.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p.scale(arguments[0], arguments[1]);\n        }\n        this.r1 *= arguments[0];\n        this.r2 *= arguments[0];\n        return this;\n    }\n\n    copy(): Sector {\n        return new Sector(this.p.copy(), this.r1, this.r2, this.start, this.end);\n    }\n\n    bounds(): Rect {\n        let rect1 = new Arc(this.p, this.r1, this.start, this.end).bounds();\n        let rect2 = new Arc(this.p, this.r2, this.start, this.end).bounds();\n        return rect1.merge(rect2);\n    }\n\n    area(): number {\n        return (this.end - this.start) / 2 * (this.r2 * this.r2 - this.r1 * this.r1);\n    }\n\n    center(): Point {\n        let a = (this.start + this.end) / 2;\n        let r = (this.r1 + this.r2) / 2;\n        let x = this.p.x + Math.cos(a) * r;\n        let y = this.p.y + Math.sin(a) * r;\n        return new Point(x, y);\n    }\n\n    contains(p: Point): boolean {\n        let v = new Vector(p.x - this.p.x, p.y - this.p.y);\n        let d = v.mag();\n        return d > this.r1 && d < this.r2 && new Arc(this.p, this.r2, this.start, this.end).contains(v);\n    }\n\n    closest(p: Point): Point {\n        let a1 = new Arc(this.p, this.r1, this.start, this.end);\n        let a2 = new Arc(this.p, this.r2, this.start, this.end);\n        let points = [\n            a1.closest(p),\n            a2.closest(p),\n            new Line(a1.point(0), a2.point(0)).closest(p),\n            new Line(a1.point(1), a2.point(1)).closest(p)\n        ];\n        let cp;\n        let dmin = Number.POSITIVE_INFINITY;\n        for (let i = 0; i < 4; i++) {\n            let d = p.distanceSq(points[i]);\n            if (d < dmin) {\n                cp = points[i];\n                dmin = d;\n            }\n        }\n        return cp;\n    }\n\n    distance(p: Point): number {\n        return p.distance(this.closest(p));\n    }\n\n    polygon(n: number): Polygon {\n        let points = new Array(n * 2 + 2);\n        for (let i = 0; i <= n; i++) {\n            let a = this.start + (this.end - this.start) * i / n;\n            let x = this.p.x + Math.cos(a) * this.r2;\n            let y = this.p.y + Math.sin(a) * this.r2;\n            points[i] = new Point(\n                this.p.x + Math.cos(a) * this.r2,\n                this.p.y + Math.sin(a) * this.r2);\n            points[n + 1 + i] = new Point(\n                this.p.x + Math.cos(this.start + this.end - a) * this.r1,\n                this.p.y + Math.sin(this.start + this.end - a) * this.r1);\n        }\n        return new Polygon(points);\n    }\n\n    split(data: number[], mode: string = 'angle'): Sector[] { //angle (default), radius, area\n        let sum = data.reduce((a, b) => a + b);\n\n        if (mode == 'angle') {\n            let angles = new Array(data.length + 1);\n            angles[0] = this.start;\n            angles[data.length] = this.end;\n            let a = this.start;\n            for (let i = 0; i < data.length - 1; i++) {\n                a += data[i] / sum * (this.end - this.start);\n                angles[i + 1] = a;\n            }\n\n            let sectors = new Array(data.length);\n            for (let i = 0; i < sectors.length; i++) {\n                sectors[i] = new Sector(this.p.copy(), this.r1, this.r2, angles[i], angles[i + 1]);\n            }\n            return sectors;\n        } else if (mode == 'radius') {\n            let radiuses = new Array(data.length + 1);\n            radiuses[0] = this.r1;\n            radiuses[data.length] = this.r2;\n            let r = this.r1;\n            for (let i = 0; i < data.length - 1; i++) {\n                r += data[i] / sum * (this.r2 - this.r1);\n                radiuses[i + 1] = r;\n            }\n\n            let sectors = new Array(data.length);\n            for (let i = 0; i < sectors.length; i++) {\n                sectors[i] = new Sector(this.p.copy(), radiuses[i], radiuses[i + 1], this.start, this.end);\n            }\n            return sectors;\n        } else if (mode == 'area') {\n            let area = this.area();\n            let radiuses = new Array(data.length + 1);\n            radiuses[0] = this.r1;\n            radiuses[data.length] = this.r2;\n            let r = this.r1;\n            for (let i = 0; i < data.length - 1; i++) {\n                radiuses[i + 1] = Math.sqrt(data[i] / sum * area * 2 / (this.end - this.start) + r * r);\n                r = radiuses[i + 1];\n            }\n\n            let sectors = new Array(data.length);\n            for (let i = 0; i < sectors.length; i++) {\n                sectors[i] = new Sector(this.p.copy(), radiuses[i], radiuses[i + 1], this.start, this.end);\n            }\n            return sectors;\n        }\n    }\n}\n\n\n\n\nexport class Circle {\n    p: Point;\n    r: number;\n\n    constructor();\n    constructor(p: Point, r: number);\n    constructor(x: number, y: number, r: number);\n    constructor(p1: Point, p2: Point, p3: Point);\n    constructor() {\n        if (arguments.length == 0) {\n            this.p = new Point();\n            this.r = 1;\n        } else if (arguments.length == 2) {\n            this.p = arguments[0];\n            this.r = arguments[1];\n        } else if (arguments.length == 3) {\n            if (arguments[0] instanceof Point) {\n                let v1 = new Vector(arguments[2].x - arguments[1].x, arguments[2].y - arguments[1].y);\n                let v2 = new Vector(arguments[0].x - arguments[2].x, arguments[0].y - arguments[2].y);\n                let v3 = new Vector(arguments[1].x - arguments[0].x, arguments[1].y - arguments[0].y);\n                let v4 = v3.perpendicular();\n                let v = v4.mult(v1.dot(v2) / v4.dot(v2)).add(v3).mult(0.5).add(arguments[0].x, arguments[0].y);\n                this.p = new Point(v.x, v.y);\n                this.r = this.p.distance(arguments[0]);\n            } else {\n                this.p = new Point(arguments[0], arguments[1]);\n                this.r = arguments[2]\n            }\n        }\n    }\n\n    translate(x: number, y: number): Circle {\n        this.p.translate(x, y);\n        return this;\n    }\n\n    rotate(a: number): Circle;\n    rotate(a: number, p: Point): Circle;\n    rotate() {\n        if (arguments.length == 1) {\n            this.p.rotate(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p.rotate(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    scale(s: number): Circle;\n    scale(s: number, p: Point): Circle;\n    scale() {\n        if (arguments.length == 1) {\n            this.p.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p.scale(arguments[0], arguments[1]);\n        }\n        this.r *= arguments[0];\n        return this;\n    }\n\n    copy(): Circle {\n        return new Circle(this.p.copy(), this.r);\n    }\n\n    bounds(): Rect {\n        let p1 = new Point(this.p.x - this.r, this.p.y - this.r);\n        let p2 = new Point(this.p.x + this.r, this.p.y + this.r);\n        return new Rect(p1, p2);\n    }\n\n    area(): number {\n        return Math.PI * this.r * this.r;\n    }\n\n    circumference(): number {\n        return 2 * Math.PI * this.r;\n    }\n\n    tangent(p: Point): Point[] | null {\n        let m = this.p.lerp(p, 0.5);\n        let d = m.distance(p);\n        let c = new Circle(m, d);\n        return this.intersection(c);\n    }\n\n    contains(s: Point | Circle): boolean {\n        if (s instanceof Point) {\n            let dx = this.p.x - s.x;\n            let dy = this.p.y - s.y;\n            return dx * dx + dy * dy < this.r * this.r;\n        } else if (s instanceof Circle) {\n            let dx = this.p.x - s.p.x;\n            let dy = this.p.y - s.p.y;\n            let r = this.r - s.r;\n            return dx * dx + dy * dy < r*r;\n        }\n    }\n\n    closest(p: Point): Point {\n        let v = new Vector(p.x - this.p.x, p.y - this.p.y).normalize().mult(this.r).add(this.p.x, this.p.y);\n        return new Point(v.x, v.y);\n    }\n\n    distance(p: Point): number {\n        return Math.abs(p.distance(this.p) - this.r);\n    }\n\n    intersects(s: Circle | Rect): boolean{\n        if (s instanceof Circle) {\n            let dx = this.p.x - s.p.x;\n            let dy = this.p.y - s.p.y;\n            let r = this.r + s.r;\n            return dx * dx + dy * dy <= r * r;\n        }else if(s instanceof Rect){            \n            let x = this.p.x;\n            let y = this.p.y;\n            if (x < s.p.x) x = s.p.x;\n            else if (x > s.p.x + s.w) x = s.p.x + s.w;\n            if (y < s.p.y) y = s.p.y;\n            else if (y > s.p.y + s.h) y = s.p.y + s.h;\n\n            let dx = this.p.x - x;\n            let dy = this.p.y - y;\n            return dx * dx + dy * dy <= this.r * this.r;  \n        }\n    }\n\n    intersection(c: Circle): Point[] | null {\n        let d = this.p.distance(c.p);\n        if (d > this.r + c.r || d < Math.abs(this.r - c.r)) return null;\n        let angle = Math.acos((this.r * this.r + d * d - c.r * c.r) / (2 * this.r * d));\n\n        let v1 = new Vector(c.p.x - this.p.x, c.p.y - this.p.y);\n        let v2 = v1.copy();\n        v1 = v1.normalize().mult(this.r).rotate(angle).add(this.p.x, this.p.y);\n        v2 = v2.normalize().mult(this.r).rotate(-angle).add(this.p.x, this.p.y);\n\n        let points = [new Point(v1.x, v1.y), new Point(v2.x, v2.y)];\n        return points;\n    }\n\n    polygon(n: number): Polygon {\n        let points = new Array(n);\n        for (let i = 0; i < n; i++) {\n            let a = 2 * Math.PI * i / n;\n            let x = this.p.x + Math.cos(a) * this.r;\n            let y = this.p.y + Math.sin(a) * this.r;\n            points[i] = new Point(x, y);\n        }\n        return new Polygon(points);\n    }\n\n    split(data: number[], mode: string = 'angle'): Sector[] {\n        return new Sector(this.p, 0, this.r, 0, Math.PI * 2).split(data, mode);\n    }\n}\n\n\n\n\nexport class Triangle {\n    p1: Point;\n    p2: Point;\n    p3: Point;\n\n    constructor(p1: Point, p2: Point, p3: Point);\n    constructor(x1: number, y1: number, x2: number, y2: number, x3: number, y3: number);\n    constructor() {\n        if (arguments.length == 3) {\n            this.p1 = arguments[0];\n            this.p2 = arguments[1];\n            this.p3 = arguments[2];\n        } else if (arguments.length == 6) {\n            this.p1 = new Point(arguments[0], arguments[1]);\n            this.p2 = new Point(arguments[2], arguments[3]);\n            this.p3 = new Point(arguments[4], arguments[5]);\n        }\n    }\n\n    translate(x: number, y: number): Triangle {\n        this.p1.translate(x, y);\n        this.p2.translate(x, y);\n        this.p3.translate(x, y);\n        return this;\n    }\n\n    rotate(a: number): Triangle;\n    rotate(a: number, p: Point): Triangle;\n    rotate() {\n        if (arguments.length == 1) {\n            this.p1.rotate(arguments[0]);\n            this.p2.rotate(arguments[0]);\n            this.p3.rotate(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p1.rotate(arguments[0], arguments[1]);\n            this.p2.rotate(arguments[0], arguments[1]);\n            this.p3.rotate(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    scale(s: number): Triangle;\n    scale(s: number, p: Point): Triangle;\n    scale() {\n        if (arguments.length == 1) {\n            this.p1.scale(arguments[0]);\n            this.p2.scale(arguments[0]);\n            this.p3.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p1.scale(arguments[0], arguments[1]);\n            this.p2.scale(arguments[0], arguments[1]);\n            this.p3.scale(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    reverse(): Triangle {\n        let temp = this.p1;\n        this.p1 = this.p3;\n        this.p3 = temp;\n        return this;\n    }\n\n    copy(): Triangle {\n        return new Triangle(this.p1.copy(), this.p2.copy(), this.p3.copy());\n    }\n\n    bounds(): Rect {\n        let x1 = Math.min(Math.min(this.p1.x, this.p2.x), this.p3.x);\n        let y1 = Math.min(Math.min(this.p1.y, this.p2.y), this.p3.y);\n        let x2 = Math.max(Math.max(this.p1.x, this.p2.x), this.p3.x);\n        let y2 = Math.max(Math.max(this.p1.y, this.p2.y), this.p3.y);\n        return new Rect(new Point(x1, y1), new Point(x2, y2));\n    }\n\n    edges(): Line[] {\n        let lines = new Array(3);\n        lines[0] = new Line(this.p1, this.p2);\n        lines[1] = new Line(this.p2, this.p3);\n        lines[2] = new Line(this.p3, this.p1);\n        return lines;\n    }\n\n    polygon(): Polygon {\n        return new Polygon([this.p1, this.p2, this.p3]);\n    }\n\n    area(): number {\n        let v1 = new Vector(this.p2.x - this.p1.x, this.p2.y - this.p1.y);\n        let v2 = new Vector(this.p3.x - this.p1.x, this.p3.y - this.p1.y);\n        return v1.cross(v2) / 2;\n    }\n\n    circumference(): number {\n        return this.p1.distance(this.p2) + this.p2.distance(this.p3) + this.p3.distance(this.p1);\n    }\n\n    centroid(): Point {\n        let x = (this.p1.x + this.p2.x + this.p3.x) / 3;\n        let y = (this.p1.y + this.p2.y + this.p3.y) / 3;\n        return new Point(x, y);\n    }\n\n    clockwise(): boolean {\n        let v1 = new Vector(this.p2.x - this.p1.x, this.p2.y - this.p1.y);\n        let v2 = new Vector(this.p3.x - this.p2.x, this.p3.y - this.p2.y);\n        return v1.cross(v2) > 0;\n    }\n\n    contains(s: Point | Triangle): boolean {\n        if (s instanceof Point) {\n            let v1 = new Vector(this.p2.x - this.p1.x, this.p2.y - this.p1.y);\n            let v2 = new Vector(this.p3.x - this.p2.x, this.p3.y - this.p2.y);\n            let v3 = new Vector(this.p1.x - this.p3.x, this.p1.y - this.p3.y);\n            let v4 = new Vector(s.x - this.p1.x, s.y - this.p1.y);\n            let v5 = new Vector(s.x - this.p2.x, s.y - this.p2.y);\n            let v6 = new Vector(s.x - this.p3.x, s.y - this.p3.y);\n            if (this.clockwise()) {\n                return v1.cross(v4) > 0 && v2.cross(v5) > 0 && v3.cross(v6) > 0;\n            } else {\n                return v1.cross(v4) < 0 && v2.cross(v5) < 0 && v3.cross(v6) < 0;\n            }\n        } else if (s instanceof Triangle) {\n            return this.contains(s.p1) && this.contains(s.p2) && this.contains(s.p3);\n        }\n    }\n\n    closest(p: Point): Point {\n        let cp;\n        let dmin = Number.POSITIVE_INFINITY;\n        let points = [this.p1, this.p2, this.p3];\n        for (let i = 0; i < points.length; i++) {\n            let l = new Line(points[i], points[(i + 1) % points.length]);\n            let lp = l.closest(p);\n            let d = p.distanceSq(lp);\n            if (d < dmin) {\n                cp = lp;\n                dmin = d;\n            }\n        }\n        return cp;\n    }\n\n    distance(p: Point): number {\n        return p.distance(this.closest(p));\n    }\n\n    circumcircle(): Circle {\n        return new Circle(this.p1, this.p2, this.p3);\n    }\n}\n\n\n\n\nexport class Rect {\n    p: Point;\n    w: number;\n    h: number;\n\n    constructor(p1: Point, p2: Point);\n    constructor(p: Point, w: number, h: number);\n    constructor(x: number, y: number, w: number, h: number);\n    constructor() {\n        if (arguments.length == 2) {\n            this.p = new Point(Math.min(arguments[0].x, arguments[1].x), Math.min(arguments[0].y, arguments[1].y));\n            this.w = Math.abs(arguments[0].x - arguments[1].x);\n            this.h = Math.abs(arguments[0].y - arguments[1].y);\n        } else if (arguments.length == 3) {\n            this.p = arguments[0];\n            this.w = arguments[1];\n            this.h = arguments[2];\n        } else if (arguments.length == 4) {\n            this.p = new Point(arguments[0], arguments[1]);\n            this.w = arguments[2];\n            this.h = arguments[3];\n        }\n    }\n\n    translate(x: number, y: number): Rect {\n        this.p.translate(x, y);\n        return this;\n    }\n\n    scale(s: number): Rect;\n    scale(s: number, p: Point): Rect;\n    scale() {\n        if (arguments.length == 1) {\n            this.p.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.p.scale(arguments[0], arguments[1]);\n        }\n        this.w *= arguments[0];\n        this.h *= arguments[0];\n        return this;\n    }\n\n    copy(): Rect {\n        return new Rect(this.p.x, this.p.y, this.w, this.h);\n    }\n\n    centroid(): Point {\n        return new Point(this.p.x + this.w * 0.5, this.p.y + this.h * 0.5);\n    }\n\n    area(): number {\n        return this.w * this.h;\n    }\n\n    circumference(): number {\n        return (this.w + this.h) * 2;\n    }\n\n    vertices(): Point[] {\n        let points = new Array(4);\n        points[0] = this.p.copy();\n        points[1] = new Point(this.p.x + this.w, this.p.y);\n        points[2] = new Point(this.p.x + this.w, this.p.y + this.h);\n        points[3] = new Point(this.p.x, this.p.y + this.h);\n        return points;\n    }\n\n    edges(): Line[] {\n        let points = this.vertices();\n        let lines = new Array(4);\n        lines[0] = new Line(points[0], points[1]);\n        lines[1] = new Line(points[1], points[2]);\n        lines[2] = new Line(points[2], points[3]);\n        lines[3] = new Line(points[3], points[0]);\n        return lines;\n    }\n\n    polygon(): Polygon {\n        return new Polygon(this.vertices());\n    }\n\n    merge(rect: Rect): Rect {\n        let p1 = new Point(Math.min(this.p.x, rect.p.x), Math.min(this.p.y, rect.p.y));\n        let p2 = new Point(Math.max(this.p.x + this.w, rect.p.x + rect.w), Math.max(this.p.y + this.h, rect.p.y + rect.h));\n        return new Rect(p1, p2);\n    }\n\n    contains(s: Point | Circle | Rect): boolean {\n        if (s instanceof Point) {\n            return s.x >= this.p.x && s.x <= this.p.x + this.w && s.y >= this.p.y && s.y <= this.p.y + this.h;\n        } else if (s instanceof Circle) {\n            return s.p.x-s.r >= this.p.x && s.p.x+s.r <= this.p.x + this.w && s.p.y-s.r >= this.p.y && s.p.y+s.r <= this.p.y + this.h;\n        } else if (s instanceof Rect) {\n            return s.p.x >= this.p.x && s.p.y >= this.p.y && s.p.x + s.w <= this.p.x + this.w && s.p.y + s.h <= this.p.y + this.h;\n        }\n    }\n\n    closest(p: Point): Point {\n        let left = this.p.x;\n        let top = this.p.y;\n        let right = this.p.x + this.w;\n        let bottom = this.p.y + this.h;\n\n        if (p.x < left) {\n            return new Point(left, Math.min(Math.max(p.y, top), bottom));\n        } else if (p.y < top) {\n            return new Point(Math.min(Math.max(p.x, left), right), top);\n        } else if (p.x > right) {\n            return new Point(right, Math.min(Math.max(p.y, top), bottom));\n        } else if (p.y > bottom) {\n            return new Point(Math.min(Math.max(p.x, left), right), bottom);\n        } else {\n            let cp;\n            let dests = [\n                Math.abs(p.x - left),\n                Math.abs(p.y - top),\n                Math.abs(p.x - right),\n                Math.abs(p.y - bottom)\n            ];\n            let points = [\n                new Point(left, p.y),\n                new Point(p.x, top),\n                new Point(right, p.y),\n                new Point(p.x, bottom)\n            ];\n            let dmin = Number.POSITIVE_INFINITY;\n            for (let i = 0; i < 4; i++) {\n                if (dests[i] < dmin) {\n                    cp = points[i];\n                    dmin = dests[i];\n                }\n            }\n            return cp;\n        }\n    }\n\n    distance(p: Point): number {\n        return p.distance(this.closest(p));\n    }\n\n    intersects(s: Point | Circle | Rect): boolean{\n        if (s instanceof Point) {\n            return this.contains(s);\n        }else if(s instanceof Circle){\n            return s.intersects(this);\n        }else if(s instanceof Rect){\n            return this.p.x <= s.p.x + s.w &&\n                    this.p.x + this.w >= s.p.x &&\n                    this.p.y <= s.p.y + s.h &&\n                    this.p.y + this.h >= s.p.y;\n        }\n    }\n\n    intersection(rect: Rect): Rect | null {\n        if (!this.intersects(rect)) return null;\n\n        let points = new Array();\n        let vertices1 = this.vertices();\n        let vertices2 = rect.vertices();\n        for (let i = 0; i < 4; i++) {\n            if (rect.contains(vertices1[i])) points.push(vertices1[i]);\n            if (this.contains(vertices2[i])) points.push(vertices2[i]);\n        }\n\n        let edges1 = this.edges();\n        let edges2 = rect.edges();\n        for (let i = 0; i < 4; i++) {\n            for (let j = 0; j < 4; j++) {\n                let p = edges1[i].intersection(edges2[j]);\n                if (p != null) points.push(p);\n            }\n        }\n\n        let p1 = points[0].copy();\n        let p2 = points[0].copy();\n        for (let i = 0; i < points.length; i++) {\n            let p = points[i];\n            if (p.x < p1.x) p1.x = p.x;\n            if (p.x > p2.x) p2.x = p.x;\n            if (p.y < p1.y) p1.y = p.y;\n            if (p.y > p2.y) p2.y = p.y;\n        }\n        return new Rect(p1, p2);\n    }\n\n    split(data: number[], mode: string = 'squarify'): Rect[] { //dice, slice, squarify (default)\n        if (mode == 'dice') {\n            return this.dice(data);\n        } else if (mode == 'slice') {\n            return this.slice(data);\n        } else if (mode == 'squarify') {\n            let sum = data.reduce((a, b) => a + b);\n            let array = new Array(data.length);\n            for (let i = 0; i < data.length; i++) array[i] = data[i] / sum * this.area();\n            return this.squarify(array, this.p.x, this.p.y, this.w, this.h);\n        }\n    }\n\n    dice(data: number[]): Rect[] {\n        let sum = data.reduce((a, b) => a + b);\n\n        let p1 = this.p.copy();\n        let p2 = new Point(this.p.x + this.w, this.p.y);\n        let p3 = new Point(this.p.x + this.w, this.p.y + this.h);\n        let p4 = new Point(this.p.x, this.p.y + this.h);\n\n        let top = new Array(data.length);\n        let bottom = new Array(data.length);\n        top[0] = p1;\n        bottom[data.length - 1] = p3;\n        let t = 0;\n        for (let i = 0; i < data.length - 1; i++) {\n            t += data[i] / sum;\n            top[i + 1] = p1.lerp(p2, t);\n            bottom[i] = p4.lerp(p3, t);\n        }\n        let rectangles = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            rectangles[i] = new Rect(top[i], bottom[i]);\n        }\n        return rectangles;\n    }\n\n    slice(data: number[]): Rect[] {\n        let sum = data.reduce((a, b) => a + b);\n\n        let p1 = this.p.copy();\n        let p2 = new Point(this.p.x + this.w, this.p.y);\n        let p3 = new Point(this.p.x + this.w, this.p.y + this.h);\n        let p4 = new Point(this.p.x, this.p.y + this.h);\n\n        let left = new Array(data.length);\n        let right = new Array(data.length);\n        left[0] = p1;\n        right[data.length - 1] = p3;\n        let t = 0;\n        for (let i = 0; i < data.length - 1; i++) {\n            t += data[i] / sum;\n            left[i + 1] = p1.lerp(p4, t);\n            right[i] = p2.lerp(p3, t);\n        }\n        let rectangles = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            rectangles[i] = new Rect(left[i], right[i]);\n        }\n        return rectangles;\n    }\n\n    squarify(data: number[], x: number, y: number, w: number, h: number): Rect[] {\n        let ratio = (w, h) => { return w > h ? w / h : h / w };\n\n        let vertical = w > h;\n        let side = vertical ? h : w;\n        let rectangles = new Array();\n        if (vertical) {\n            for (let i = 0; i < data.length; i++) {\n                let worst = rectangles.length == 0 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n                let areas = 0;\n                for (let r of rectangles) worst = Math.max(worst, ratio(r.w, r.h));\n                for (let r of rectangles) areas += r.area();\n                let tw = (areas + data[i]) / side;\n                let th = data[i] / tw;\n                let ty = y;\n                for (let r of rectangles) ty += r.area() / tw;\n                let rect = new Rect(x, ty, tw, th);\n                let k = ratio(rect.w, rect.h);\n                for (let r of rectangles) k = Math.max(k, ratio(tw, r.area() / tw));\n                if (k < worst) {\n                    rectangles.push(rect);\n                    ty = y;\n                    for (let r of rectangles) {\n                        [r.h, r.w, r.p.y] = [r.area() / tw, tw, ty];\n                        ty += r.h;\n                    }\n                } else {\n                    areas = 0;\n                    for (let r of rectangles) areas += r.area();\n                    let offset = areas / side;\n                    rectangles = rectangles.concat(this.squarify(data.slice(i), x + offset, y, w - offset, h));\n                    break;\n                }\n            }\n        } else {\n            for (let i = 0; i < data.length; i++) {\n                let worst = rectangles.length == 0 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n                let areas = 0;\n                for (let r of rectangles) worst = Math.max(worst, ratio(r.w, r.h));\n                for (let r of rectangles) areas += r.area();\n                let th = (areas + data[i]) / side;\n                let tw = data[i] / th;\n                let tx = x;\n                for (let r of rectangles) tx += r.area() / th;\n                let rect = new Rect(tx, y, tw, th);\n                let k = ratio(rect.w, rect.h);\n                for (let r of rectangles) k = Math.max(k, ratio(r.area() / th, th));\n                if (k < worst) {\n                    rectangles.push(rect);\n                    tx = x;\n                    for (let r of rectangles) {\n                        [r.w, r.h, r.p.x] = [r.area() / th, th, tx];\n                        tx += r.w;\n                    }\n                } else {\n                    areas = 0;\n                    for (let r of rectangles) areas += r.area();\n                    let offset = areas / side;\n                    rectangles = rectangles.concat(this.squarify(data.slice(i), x, y + offset, w, h - offset));\n                    break;\n                }\n            }\n        }\n\n        return rectangles;\n    }\n\n    clip(poly: Polygon): Polygon | null {\n        return new Polygon(this.vertices()).clip(poly);\n    }\n}\n\n\n\n\nexport class Polygon {\n    vertices: Point[];\n\n    constructor();\n    constructor(points: Point[]);\n    constructor() {\n        if (arguments.length == 1) {\n            this.vertices = arguments[0];\n        } else {\n            this.vertices = new Array();\n        }\n    }\n\n    add(p: Point): Polygon;\n    add(x: number, y: number): Polygon;\n    add() {\n        if (arguments.length == 1) {\n            this.vertices.push(arguments[0]);\n        } else if (arguments.length == 2) {\n            this.vertices.push(new Point(arguments[0], arguments[1]));\n        }\n        return this;\n    }\n\n    clear(){\n        this.vertices = [];\n    }\n\n    translate(x, y): Polygon {\n        for (let v of this.vertices) v.translate(x, y);\n        return this;\n    }\n\n    rotate(a: number): Polygon;\n    rotate(a: number, p: Point): Polygon;\n    rotate() {\n        if (arguments.length == 1) {\n            for (let v of this.vertices) v.rotate(arguments[0]);\n        } else if (arguments.length == 2) {\n            for (let v of this.vertices) v.rotate(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    scale(s: number): Polygon;\n    scale(s: number, p: Point): Polygon;\n    scale() {\n        if (arguments.length == 1) {\n            for (let v of this.vertices) v.scale(arguments[0]);\n        } else if (arguments.length == 2) {\n            for (let v of this.vertices) v.scale(arguments[0], arguments[1]);\n        }\n        return this;\n    }\n\n    reverse(): Polygon {\n        this.vertices.reverse();\n        return this;\n    }\n\n    edges(): Line[] {\n        let lines = new Array();\n        for (let i = 0; i < this.vertices.length; i++) {\n            let p1 = this.vertices[i];\n            let p2 = this.vertices[(i + 1) % this.vertices.length];\n            lines.push(new Line(p1, p2));\n        }\n        return lines;\n    }\n\n    bounds(): Rect {\n        let p1 = new Point(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        let p2 = new Point(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);\n        for (let p of this.vertices) {\n            p1.x = Math.min(p1.x, p.x);\n            p1.y = Math.min(p1.y, p.y);\n            p2.x = Math.max(p2.x, p.x);\n            p2.y = Math.max(p2.y, p.y);\n        }\n        return new Rect(p1, p2);\n    }\n\n    area(): number {\n        let area = 0;\n        for (let i = 0; i < this.vertices.length; i++) {\n            let p1 = this.vertices[i];\n            let p2 = this.vertices[(i + 1) % this.vertices.length];\n            let v1 = new Vector(p1.x, p1.y);\n            let v2 = new Vector(p2.x, p2.y);\n            area += v1.cross(v2);\n        }\n        area /= 2;\n        return area;\n    }\n\n    circumference(): number {\n        let circumference = 0;\n        for (let i = 0; i < this.vertices.length; i++) {\n            let p1 = this.vertices[i];\n            let p2 = this.vertices[(i + 1) % this.vertices.length];\n            circumference += p1.distance(p2);\n        }\n        return circumference;\n    }\n\n    centroid(): Point {\n        let area = this.area();\n        let x = 0;\n        let y = 0;\n        for (let i = 0; i < this.vertices.length; i++) {\n            let p1 = this.vertices[i];\n            let p2 = this.vertices[(i + 1) % this.vertices.length];\n            let v1 = new Vector(p1.x, p1.y);\n            let v2 = new Vector(p2.x, p2.y);\n            let cross = v1.cross(v2);\n            x += (p1.x + p2.x) * cross;\n            y += (p1.y + p2.y) * cross;\n        }\n        return new Point(x / 6 / area, y / 6 / area);\n    }\n\n    clockwise(): boolean {\n        return this.area() > 0;\n    }\n\n    convex(): boolean {\n        let clockwise = this.clockwise();\n\n        for (let i = 0; i < this.vertices.length; i++) {\n            let p1 = this.vertices[i];\n            let p2 = this.vertices[(i + 1) % this.vertices.length];\n            let p3 = this.vertices[(i + 2) % this.vertices.length];\n            let v1 = new Vector(p2.x - p1.x, p2.y - p1.y);\n            let v2 = new Vector(p3.x - p2.x, p3.y - p2.y);\n            if (clockwise) {\n                if (v1.cross(v2) < 0) return false;\n            } else {\n                if (v1.cross(v2) > 0) return false;\n            }\n        }\n        return true;\n    }\n\n    contains(s: Point | Polygon): boolean {\n        if (this.vertices.length < 3) return false;\n\n        if (s instanceof Point) {\n            let count = 0;\n            for (let i = 0; i < this.vertices.length; i++) {\n                let p1 = this.vertices[i];\n                let p2 = this.vertices[(i + 1) % this.vertices.length];\n                if (p1.x <= s.x && s.x < p2.x || p2.x <= s.x && s.x < p1.x) {\n                    let y = (p2.y - p1.y) / (p2.x - p1.x) * (s.x - p1.x) + p1.y;\n                    if (s.y < y) count++;\n                }\n            }\n            return count % 2 != 0;\n        } else if (s instanceof Polygon) {\n            for (let i = 0; i < s.vertices.length; i++) {\n                if (!this.contains(s.vertices[i])) return false;\n            }\n            return true;\n        }\n    }\n\n    closest(p: Point): Point {\n        let cp;\n        let dmin = Number.POSITIVE_INFINITY;\n        for (let i = 0; i < this.vertices.length; i++) {\n            let l = new Line(this.vertices[i], this.vertices[(i + 1) % this.vertices.length]);\n            let lp = l.closest(p);\n            let d = p.distanceSq(lp);\n            if (d < dmin) {\n                cp = lp;\n                dmin = d;\n            }\n        }\n        return cp;\n    }\n\n    distance(p: Point): number {\n        return p.distance(this.closest(p));\n    }\n\n    clip(poly: Polygon): Polygon | null {\n        let [x, y] = [0, 0];\n        let points = new Array();\n        for (let i = 0; i < this.vertices.length; i++) {\n            let p1 = this.vertices[i];\n            let p2 = this.vertices[(i + 1) % this.vertices.length];\n            let l1 = new Line(p1, p2);\n            if (poly.contains(p1)) {\n                points.push(p1);\n                [x, y] = [x + p1.x, y + p1.y];\n            }\n            for (let j = 0; j < poly.vertices.length; j++) {\n                let p3 = poly.vertices[j];\n                let p4 = poly.vertices[(j + 1) % poly.vertices.length];\n                let l2 = new Line(p3, p4);\n                let ip = l1.intersection(l2);\n                if (ip != null) {\n                    points.push(ip);\n                    [x, y] = [x + ip.x, y + ip.y];\n                }\n            }\n        }\n\n        for (let i = 0; i < poly.vertices.length; i++) {\n            let p = poly.vertices[i];\n            if (this.contains(p)) {\n                points.push(p);\n                [x, y] = [x + p.x, y + p.y];\n            }\n        }\n        [x, y] = [x / points.length, y / points.length];\n\n        points.sort(function (a, b) {\n            let a1 = new Vector(a.x - x, a.y - y).angle();\n            let a2 = new Vector(b.x - x, b.y - y).angle();\n            if (a1 > a2) return 1;\n            else if (a1 == a2) return 0;\n            else return -1;\n        });\n\n        if(points.length>0) return new Polygon(points);\n        else return null;\n    }\n}\n\n\n\n\nexport class QuadTree {\n    children: QuadTree[];\n    objects: any[];\n\n    bounds: Rect;\n    capacity: number;\n    maxLevels: number;\n    private _level: number;\n    \n    constructor(bounds: Rect, capacity: number = 4, maxLevels: number = 4, level: number = 0) {\n        this.bounds = bounds;\n        this.capacity = capacity;\n        this.maxLevels = maxLevels;\n        this._level = level;\n\n        this.children = null;\n        this.objects = [];\n    }\n\n    leaf(): boolean{\n        return this.children == null;\n    }\n\n    clear(){\n        this.children = null;\n        this.objects = [];\n    }\n\n    insert(object: any){\n        if(object instanceof Array){\n            for(let i=0; i<object.length; i++) this.insert(object[i]);  \n            return;\n        }\n\n        if(this.children){\n            for(let i=0; i<4; i++){\n                if(this.children[i].bounds.intersects(object.bounds())) \n                    this.children[i].insert(object);\n            }\n            return;\n        }\n\n        this.objects.push(object);\n\n        if(this.objects.length > this.capacity && this._level < this.maxLevels){\n            let x = this.bounds.p.x;\n            let y = this.bounds.p.y;\n            let w = this.bounds.w/2;\n            let h = this.bounds.h/2;\n            this.children = [\n                new QuadTree(new Rect(x, y, w, h), this.capacity, this.maxLevels, this._level+1), \n                new QuadTree(new Rect(x+w, y, w, h), this.capacity, this.maxLevels, this._level+1),\n                new QuadTree(new Rect(x+w, y+h, w, h), this.capacity, this.maxLevels, this._level+1),\n                new QuadTree(new Rect(x, y+h, w, h), this.capacity, this.maxLevels, this._level+1)\n            ];\n            \n            for(let i=0; i<this.objects.length; i++){\n                for(let j=0; j<4; j++){\n                    if(this.children[j].bounds.intersects(this.objects[i].bounds()))\n                        this.children[j].insert(this.objects[i]);\n                }\n            }\n\n            this.objects = [];\n        }\n    }\n\n    query(range: Rect | Circle): any[]{\n        let objects = this.objects;\n\n        if(this.children){\n            for(let i=0; i<4; i++){\n                if(this.children[i].bounds.intersects(range)) {\n                    objects = objects.concat(this.children[i].query(range));\n                }\n            }\n        }\n\n        objects = objects.filter((x,index)=>objects.indexOf(x)===index);\n\n        return objects;\n    }\n}\n\n\n\n\nexport class ConvexHull {\n    vertices: Point[];\n    region: Polygon;\n\n    compute(points) {\n        if (points.length < 3) {\n            this.vertices = points;\n            this.region = new Polygon(points);\n            return;\n        }\n\n        let sort_points = points.slice();\n\n        sort_points.sort(function (a, b) {\n            if (a.y > b.y) return 1;\n            else if (a.y == b.y) return a.x - b.x;\n            else return -1;\n        });\n\n        let p = new Point(sort_points[0].x - 1, sort_points[0].y);\n        let v = new Vector(1, 0);\n        sort_points.sort(function (a, b) {\n            let a1 = new Vector(a.x - p.x, a.y - p.y).angle();\n            let a2 = new Vector(b.x - p.x, b.y - p.y).angle();\n            if (a1 > a2) return 1;\n            else if (a1 == a2) return a.distanceSq(p) - b.distanceSq(p);\n            else return -1;\n        });\n\n        let vertices = new Array();\n        for (let i = 0; i < sort_points.length; i++) {\n            if (vertices.length < 2) {\n                vertices.push(sort_points[i]);\n            } else {\n                vertices.push(sort_points[i]);\n                let valid;\n                do {\n                    let p1 = vertices[vertices.length - 3];\n                    let p2 = vertices[vertices.length - 2];\n                    let p3 = vertices[vertices.length - 1];\n                    let v1 = new Vector(p2.x - p1.x, p2.y - p1.y);\n                    let v2 = new Vector(p3.x - p1.x, p3.y - p1.y);\n                    if (v1.cross(v2) > 0) {\n                        valid = true;\n                    } else {\n                        valid = false;\n                        vertices.splice(vertices.length - 2, 1);\n                    }\n                } while (vertices.length >= 3 && !valid);\n            }\n        }\n\n        this.vertices = vertices;\n        this.region = new Polygon(this.vertices);\n    }\n}\n\n\n\n\nexport class Delaunay {\n    vertices: Point[];\n    edges: Line[];\n    triangles: Triangle[];\n\n    compute(points: Point[]) {\n        let left = Number.POSITIVE_INFINITY;\n        let top = Number.POSITIVE_INFINITY;\n        let right = Number.NEGATIVE_INFINITY;\n        let bottom = Number.NEGATIVE_INFINITY;\n        for (let i = 0; i < points.length; i++) {\n            left = Math.min(points[i].x, left);\n            top = Math.min(points[i].y, top);\n            right = Math.max(points[i].x, right);\n            bottom = Math.max(points[i].y, bottom);\n        }\n        let x = (left + right) / 2;\n        let y = (top + bottom) / 2;\n\n        let p1 = new Point(x + 10000000, y);\n        let p2 = new Point(x - 5000000, y + 10000000);\n        let p3 = new Point(x - 5000000, y - 10000000);\n        let superTriangle = new Triangle(p1, p2, p3);\n\n        let triangles = new Array();\n        triangles.push(superTriangle);\n\n        for (let i = 0; i < points.length; i++) {\n            let lines = new Array();\n            for (let j = triangles.length - 1; j >= 0; j--) {\n                let t = triangles[j];\n                if (t.circumcircle().contains(points[i])) {\n                    lines.push(new Line(t.p1, t.p2));\n                    lines.push(new Line(t.p2, t.p3));\n                    lines.push(new Line(t.p3, t.p1));\n                    triangles.splice(j, 1);\n                }\n            }\n\n            for (let j = 0; j < lines.length - 1; j++) {\n                let e1 = lines[j];\n                for (let k = j + 1; k < lines.length; k++) {\n                    let e2 = lines[k];\n                    if (e1.p1 == e2.p1 && e1.p2 == e2.p2 || e1.p1 == e2.p2 && e1.p2 == e2.p1) {\n                        e1.__remove = true;\n                        e2.__remove = true;\n                    }\n                }\n            }\n\n            for (let j = lines.length - 1; j >= 0; j--) {\n                let e = lines[j];\n                if (e.__remove) lines.splice(j, 1);\n                else triangles.push(new Triangle(points[i], e.p1, e.p2));\n            }\n        }\n\n        let edges = new Array();\n        for (let i = triangles.length - 1; i >= 0; i--) {\n            let t = triangles[i];\n            if ((t.p1 == superTriangle.p1 || t.p1 == superTriangle.p2 || t.p1 == superTriangle.p3) ||\n                (t.p2 == superTriangle.p1 || t.p2 == superTriangle.p2 || t.p2 == superTriangle.p3) ||\n                (t.p3 == superTriangle.p1 || t.p3 == superTriangle.p2 || t.p3 == superTriangle.p3)) {\n                triangles.splice(i, 1);\n            } else {\n                edges.push(new Line(t.p1, t.p2));\n                edges.push(new Line(t.p2, t.p3));\n                edges.push(new Line(t.p3, t.p1));\n            }\n        }\n\n        for (let i = edges.length - 1; i > 0; i--) {\n            let e1 = edges[i];\n            for (let j = i - 1; j >= 0; j--) {\n                let e2 = edges[j];\n                if (e1.p1 == e2.p1 && e1.p2 == e2.p2 || e1.p1 == e2.p2 && e1.p2 == e2.p1) {\n                    edges.splice(i, 1);\n                }\n            }\n        }\n\n        this.vertices = points;\n        this.edges = edges;\n        this.triangles = triangles;\n    }\n}\n\n\n\n\nexport class Voronoi {\n    triangles: Triangle[];\n    vertices: Point[];\n    edges: Line[];\n    regions: Polygon[];\n\n    compute(points: Point[]) {\n        let left = Number.POSITIVE_INFINITY;\n        let top = Number.POSITIVE_INFINITY;\n        let right = Number.NEGATIVE_INFINITY;\n        let bottom = Number.NEGATIVE_INFINITY;\n        for (let i = 0; i < points.length; i++) {\n            left = Math.min(points[i].x, left);\n            top = Math.min(points[i].y, top);\n            right = Math.max(points[i].x, right);\n            bottom = Math.max(points[i].y, bottom);\n        }\n        let x = (left + right) / 2;\n        let y = (top + bottom) / 2;\n\n        let p1 = new Point(x + 10000000, y);\n        let p2 = new Point(x - 5000000, y + 10000000);\n        let p3 = new Point(x - 5000000, y - 10000000);\n        let superTriangle = new Triangle(p1, p2, p3);\n\n        let triangles = new Array();\n        triangles.push(superTriangle);\n\n        for (let i = 0; i < points.length; i++) {\n            (<any>points[i]).__circumcenters = new Array();\n\n            let lines = new Array();\n            for (let j = triangles.length - 1; j >= 0; j--) {\n                let t = triangles[j];\n                if (t.circumcircle().contains(points[i])) {\n                    lines.push(new Line(t.p1, t.p2));\n                    lines.push(new Line(t.p2, t.p3));\n                    lines.push(new Line(t.p3, t.p1));\n                    triangles.splice(j, 1);\n                }\n            }\n\n            for (let j = 0; j < lines.length - 1; j++) {\n                let e1 = lines[j];\n                for (let k = j + 1; k < lines.length; k++) {\n                    let e2 = lines[k];\n                    if (e1.p1 == e2.p1 && e1.p2 == e2.p2 || e1.p1 == e2.p2 && e1.p2 == e2.p1) {\n                        e1.__remove = true;\n                        e2.__remove = true;\n                    }\n                }\n            }\n\n            for (let j = lines.length - 1; j >= 0; j--) {\n                let e = lines[j];\n                if (e.__remove) lines.splice(j, 1);\n                else triangles.push(new Triangle(points[i], e.p1, e.p2));\n            }\n        }\n\n        let vertices = new Array();\n        for (let i = 0; i < triangles.length; i++) {\n            let t = triangles[i];\n            t.__circumcenter = t.circumcircle().p;\n            vertices.push(t.__circumcenter);\n            if (t.p1.__circumcenters) t.p1.__circumcenters.push(t.__circumcenter);\n            if (t.p2.__circumcenters) t.p2.__circumcenters.push(t.__circumcenter);\n            if (t.p3.__circumcenters) t.p3.__circumcenters.push(t.__circumcenter);\n        }\n\n        let edges = new Array();\n        for (let i = 0; i < triangles.length; i++) {\n            let t1 = triangles[i];\n            for (let j = 0; j < i; j++) {\n                let t2 = triangles[j];\n                if ((t1.p1 == t2.p1 && t1.p2 == t2.p2 || t1.p1 == t2.p2 && t1.p2 == t2.p1) ||\n                    (t1.p1 == t2.p2 && t1.p2 == t2.p3 || t1.p1 == t2.p3 && t1.p2 == t2.p2) ||\n                    (t1.p1 == t2.p3 && t1.p2 == t2.p1 || t1.p1 == t2.p1 && t1.p2 == t2.p3) ||\n                    (t1.p2 == t2.p1 && t1.p3 == t2.p2 || t1.p2 == t2.p2 && t1.p3 == t2.p1) ||\n                    (t1.p2 == t2.p2 && t1.p3 == t2.p3 || t1.p2 == t2.p3 && t1.p3 == t2.p2) ||\n                    (t1.p2 == t2.p3 && t1.p3 == t2.p1 || t1.p2 == t2.p1 && t1.p3 == t2.p3) ||\n                    (t1.p3 == t2.p1 && t1.p1 == t2.p2 || t1.p3 == t2.p2 && t1.p1 == t2.p1) ||\n                    (t1.p3 == t2.p2 && t1.p1 == t2.p3 || t1.p3 == t2.p3 && t1.p1 == t2.p2) ||\n                    (t1.p3 == t2.p3 && t1.p1 == t2.p1 || t1.p3 == t2.p1 && t1.p1 == t2.p3)) {\n                    edges.push(new Line(t1.__circumcenter, t2.__circumcenter));\n                }\n            }\n        }\n\n        let regions = new Array();\n        for (let i = 0; i < points.length; i++) {\n            let p = points[i];\n            (<any>p).__circumcenters.sort(function (a, b) {\n                let v1 = new Vector(a.x - p.x, a.y - p.y);\n                let v2 = new Vector(b.x - p.x, b.y - p.y);\n                return v1.angle() - v2.angle();\n            });\n            let region = new Polygon((<any>p).__circumcenters);\n            regions.push(region);\n        }\n\n        this.triangles = triangles;\n        this.vertices = vertices;\n        this.edges = edges;\n        this.regions = regions;\n    }\n}\n\n\n\n\nexport class LimitedVoronoi {\n    cells: Cell[];\n\n    compute(cells: Cell[]|Circle[]) {\n        let sites;\n        if (cells[0] instanceof Circle) {\n            sites = new Array(cells.length);\n            for (let i = 0; i < cells.length; i++){\n                sites[i] = new Cell(cells[i].p.x, cells[i].p.y, cells[i].r);\n            }\n        }else{\n            sites = cells;\n        }\n\n        for (let i = 0; i < cells.length; i++) {\n            sites[i].clear();\n            sites[i].__lines = new Array();\n            sites[i].__points = new Array();\n            sites[i].__contained = false;\n        }\n\n        for (let i = 0; i < sites.length - 1; i++) {\n            let s1 = sites[i];\n            for (let j = i + 1; j < sites.length; j++) {\n                let s2 = sites[j];\n                let d = s1.p.distance(s2.p);\n                if (d < s1.r - s2.r) s2.__contained = true;\n                if (d < s2.r - s1.r) s1.__contained = true;\n            }\n        }\n\n        let lines = new Array();\n\n        for (let i = 0; i < sites.length - 1; i++) {\n            let s1 = sites[i];\n            if (s1.__contained) continue;\n            for (let j = i + 1; j < sites.length; j++) {\n                let s2 = sites[j];\n                if (s2.__contained) continue;\n                if (s1.p.distance(s2.p) < s1.r + s2.r) {\n                    let points = intersection(s1, s2);\n                    let p1 = points[0];\n                    let p2 = points[1];\n                    let p3 = points[1].copy();\n                    let p4 = points[0].copy();\n                    s1.__points.push(p1);\n                    s1.__points.push(p2);\n                    s2.__points.push(p3);\n                    s2.__points.push(p4);\n                    let l1 = new Line(p1, p2);\n                    let l2 = new Line(p3, p4);\n                    s1.__lines.push(l1);\n                    s2.__lines.push(l2);\n                    lines.push(l1);\n                    lines.push(l2);\n                    (<any>l1).__s1 = s1;\n                    (<any>l1).__s2 = s2;\n                    (<any>l2).__s1 = s2;\n                    (<any>l2).__s2 = s1;\n                    (<any>p1).__l1 = l1;\n                    (<any>p1).__l2 = l2;\n                    (<any>p2).__l1 = l1;\n                    (<any>p2).__l2 = l2;\n                    (<any>p3).__l1 = l1;\n                    (<any>p3).__l2 = l2;\n                    (<any>p4).__l1 = l1;\n                    (<any>p4).__l2 = l2;\n                    (<any>p1).__arc = true;\n                    (<any>p3).__arc = true;\n                }\n            }\n        }\n\n\n        function intersection(s1, s2) {\n            let d = s1.p.distance(s2.p);\n            let a = (s1.r * s1.r - s2.r * s2.r + d * d) / (2 * d);\n            let h = Math.sqrt(s1.r * s1.r - a * a);\n            let p = new Vector(s2.p.x - s1.p.x, s2.p.y - s1.p.y).normalize().mult(a).add(s1.p.x, s1.p.y);\n            let dx = h * (s2.p.y - s1.p.y) / d;\n            let dy = h * (s2.p.x - s1.p.x) / d;\n            let p2 = new Point(p.x - dx, p.y + dy);\n            let p1 = new Point(p.x + dx, p.y - dy);\n            let clockwise = (p1.x - s2.p.x) * (p2.y - s2.p.y) - (p2.x - s2.p.x) * (p1.y - s2.p.y) < 0;\n            if (a > d) clockwise = !clockwise;\n            if (clockwise) {\n                return [p2, p1];\n            } else {\n                return [p1, p2];\n            }\n        }\n\n        for (let i = 0; i < lines.length - 1; i++) {\n            for (let j = i + 1; j < lines.length; j++) {\n                let l1 = lines[i];\n                let l2 = lines[j];\n                if (l1.__s1 == l2.__s2 && l1.__s2 == l2.__s1) continue;\n                if (l1.__s1 == l2.__s1) {\n                    let p = l1.intersection(l2);\n                    if (p != null) {\n                        p.__l1 = l1;\n                        p.__l2 = l2;\n                        l1.__s1.__points.push(p);\n                    }\n                }\n            }\n        }\n\n        for (let i = 0; i < sites.length; i++) {\n            let s = sites[i];\n\n            if (s.__contained) {\n                s.state = 2;\n                continue;\n            }\n            if (s.__points.length == 0) {\n                s.state = 0;\n                continue;\n            }\n\n            for (let j = 0; j < s.__lines.length; j++) {\n                let l = s.__lines[j];\n                for (let k = s.__points.length - 1; k >= 0; k--) {\n                    let p = s.__points[k];\n                    if (p.__l1 != l && p.__l2 != l) {\n                        let v = new Vector(p.x - l.p1.x, p.y - l.p1.y);\n                        if (v.cross(l.direction()) < 0) s.__points.splice(k, 1);\n                    }\n                }\n            }\n\n            let center = new Vector();\n            for (let j = 0; j < s.__points.length; j++) {\n                let p = s.__points[j];\n                center = center.add(p.x, p.y);\n            }\n            center = center.div(s.__points.length);\n\n            s.__points.sort(function (a, b) {\n                let a1 = new Vector(a.x - center.x, a.y - center.y).angle();\n                let a2 = new Vector(b.x - center.x, b.y - center.y).angle();\n                return a1 - a2;\n            });\n\n            for (let j = s.__points.length - 1; j > 1; j--) {\n                let p1 = s.__points[j];\n                let p2 = s.__points[j - 1];\n                if (p1.distance(p2) < 1e-4) s.__points.splice(j, 1);\n            }\n\n            if (s.__points.length > 0) {\n                s.state = 1;\n            } else {\n                s.state = 2;\n                continue;\n            }\n\n            for (let j = 0; j < s.__points.length; j++) {\n                let p = s.__points[j];\n                let a = new Vector(p.x, p.y).sub(s.p.x, s.p.y).angle();\n                s.vertices.push(new CellVertex(p.x, p.y, a, p.__arc ? 1 : 0));\n            }\n        }\n\n        this.cells = sites;\n    }\n}\n\nexport class CellVertex {\n    x: number;\n    y: number;\n    a: number;\n    type: number; //line, arc\n\n    constructor(x: number, y: number, a: number, type: number) {\n        this.x = x;\n        this.y = y;\n        this.a = a;\n        this.type = type;\n    }\n}\n\nexport class Cell {\n    p: Point;\n    r: number;\n    vertices: CellVertex[];\n    state: number; //disjoint, intersect, contain\n\n    constructor(p: Point, r: number)\n    constructor(x: number, y: number, r: number)\n    constructor() {\n        if (arguments.length == 2) {\n            this.p = arguments[0];\n            this.r = arguments[1];\n        } else if (arguments.length == 3) {\n            this.p = new Point(arguments[0], arguments[1]);\n            this.r = arguments[2];\n        }\n        this.vertices = new Array();\n    }\n\n    clear(){\n        this.vertices = [];\n    }\n\n    polygon(detail: number): Polygon {\n        if (this.state != 1) return new Circle(this.p, this.r).polygon(detail);\n\n        let points = new Array();\n        for (let i = 0; i < this.vertices.length; i++) {\n            const v1 = this.vertices[i];\n            const v2 = this.vertices[(i + 1) % this.vertices.length];\n            if (v1.type == 0) {\n                points.push(new Point(v1.x, v1.y));\n            } else {\n                let start = v1.a;\n                let end = v2.a;\n                if (start > end) end += 2 * Math.PI;\n                const n = Math.max((end - start) / (2 * Math.PI) * detail, 1);\n                for (let j = 0; j < n; j++) {\n                    const a = start + (end - start) * j / n;\n                    const x = this.p.x + Math.cos(a) * this.r;\n                    const y = this.p.y + Math.sin(a) * this.r;\n                    points.push(new Point(x, y));\n                }\n            }\n        }\n        return new Polygon(points);\n    }\n}\n'c2.js/src/physics.ts'\n://Created by Ren Yuan\n\n\nimport { Vector, Point, Line, Arc, Circle, Rect, Polygon, QuadTree } from \"./geometry\";\n\n\nexport class World {\n    bounds: Rect;\n    friction: number = .75;\n\n    particles: Particle[];\n    springs: Spring[];\n\n    forces: Force[];\n    interactionForces: InteractionForce[];\n    constraints: Constraint[];\n\n    constructor(bounds: Rect = null) {\n        this.bounds = bounds;\n\n        this.particles = [];\n        this.springs = [];\n        this.forces = [];\n        this.interactionForces = [];\n        this.constraints = [];\n    }\n\n    addParticle(p: Particle) {\n        this.particles.push(p);\n    }\n    addSpring(s: Spring) {\n        this.springs.push(s);\n    }\n    addForce(f: Force) {\n        this.forces.push(f);\n    }\n    addInteractionForce(f: InteractionForce) {\n        this.interactionForces.push(f);\n    }\n    addConstraint(c: Constraint) {\n        this.constraints.push(c);\n    }\n\n    removeParticle(p: Particle){\n        let index = this.particles.indexOf(p);\n        if(index!=-1) this.particles.splice(index, 1);\n    }\n    removeSpring(s: Spring) {\n        let index = this.springs.indexOf(s);\n        if(index!=-1) this.springs.splice(index, 1);\n    }\n    removeForce(f: Force) {\n        let index = this.forces.indexOf(f);\n        if(index!=-1) this.forces.splice(index, 1);\n    }\n    removeInteractionForce(f: InteractionForce) {\n        let index = this.interactionForces.indexOf(f);\n        if(index!=-1) this.interactionForces.splice(index, 1);\n    }\n    removeConstraint(c: Constraint){\n        let index = this.constraints.indexOf(c);\n        if(index!=-1) this.constraints.splice(index, 1);\n    }\n\n    update() {\n        for (let p of this.particles) for (let f of this.forces) f.apply(p);\n        for (let f of this.interactionForces) f.apply(this.particles);\n        for (let s of this.springs) s.update();\n        for (let p of this.particles) p.update(this.friction);\n        for (let p of this.particles) for (let c of this.constraints) c.apply(p);\n        if (this.bounds) for (let p of this.particles) p.bounce(this.bounds);\n    }\n}\n\n\nexport class Particle {\n    previousPosition: Vector;\n    position: Vector;\n    radius: number = 1;\n    mass: number = 1;\n\n    private _force: Vector;\n    private _fix:boolean;\n\n    constructor(x: number, y: number) {\n        this.position = new Vector(x, y);\n        this.previousPosition = this.position.copy();\n        this._force = new Vector();\n    }\n\n    velocity(){\n        return this.position.sub(this.previousPosition);\n    }\n\n    addVelocity(v: Vector) {\n        if(this._fix) return;\n        this.previousPosition = this.previousPosition.sub(v);\n    }\n\n    clearVelocity(){\n        this.previousPosition = this.position.copy();\n    }\n\n    addForce(f: Vector) {\n        if(this._fix) return;\n        this._force = this._force.add(f);\n    }\n\n    clearForce(){\n        this._force = new Vector();\n    }\n\n    update(friction: number = 1) {\n        if(this._fix) return;\n        let v = this.position.sub(this.previousPosition);\n        let p = this.position.add(v.add(this._force.div(this.mass)).mult(friction));\n        this.previousPosition = this.position.copy();\n        this.position = p;\n        this._force = this._force.mult(0);\n    }\n\n    bounce(rect: Rect) {\n        if(this._fix) return;\n        this.position.x = Math.min(Math.max(this.position.x, rect.p.x + this.radius), rect.p.x + rect.w - this.radius);\n        this.position.y = Math.min(Math.max(this.position.y, rect.p.y + this.radius), rect.p.y + rect.h - this.radius);\n    }\n\n    bounds(): Circle {\n        return new Circle(this.position.x, this.position.y, this.radius);\n    }\n\n    fix(){\n        this._fix = true;\n    }\n\n    unfix(){\n        this._fix = false;\n    }\n}\n\n\nexport class Spring {\n    p1: Particle;\n    p2: Particle;\n    length: number;\n    strength: number = 1;\n\n    private _min: number = 0;\n    private _max: number = Number.POSITIVE_INFINITY;\n\n    constructor(p1: Particle, p2: Particle);\n    constructor(p1: Particle, p2: Particle, strength: number);\n    constructor(p1: Particle, p2: Particle, strength: number, length: number);\n    constructor() {\n        this.p1 = arguments[0];\n        this.p2 = arguments[1];\n        if (arguments.length == 2) {\n            this.length = this.p1.position.sub(this.p2.position).mag();\n        } else if (arguments.length == 3) {\n            this.length = this.p1.position.sub(this.p2.position).mag();\n            this.strength = arguments[2];\n        } else if (arguments.length == 4) {\n            this.strength = arguments[2];\n            this.length = arguments[3];\n        }\n    }\n\n    range(min: number = 0, max:number = Number.POSITIVE_INFINITY){\n        this._min = min;\n        this._max = max;\n    }\n\n    update() {\n        let v = this.p1.position.sub(this.p2.position);\n        let d = v.mag();\n\n        if (d >= this._min && d <= this._max) {\n            v = v.mult((this.length - d) / d / (this.p1.mass+this.p2.mass) * this.strength);\n            this.p1.position = this.p1.position.add(v.mult(this.p1.mass));\n            this.p2.position = this.p2.position.sub(v.mult(this.p2.mass));\n        }\n    }\n}\n\n\n\n\nexport abstract class Force {\n    abstract apply(p: Particle);\n}\n\nexport class ConstForce extends Force {\n    force: Vector;\n\n    constructor(v: Vector);\n    constructor(x: number, y: number);\n    constructor() {\n        super();\n        if (arguments.length == 1) {\n            this.force = arguments[0];\n        } else if (arguments.length == 2) {\n            this.force = new Vector(arguments[0], arguments[1]);\n        } else {\n            this.force = new Vector(0, 0);\n        }\n    }\n\n    apply(p: Particle) {\n        p.addForce(this.force);\n    }\n}\n\nexport class PointField extends Force {\n    point: Point;\n    strength: number;\n\n    private _min: number = 0;\n    private _max: number = Number.POSITIVE_INFINITY;\n\n    constructor(point: Point, strength: number = 1) {\n        super();\n        this.point = point;\n        this.strength = strength;\n    }\n\n    range(min: number = 0, max:number = Number.POSITIVE_INFINITY){\n        this._min = min;\n        this._max = max;\n    }\n\n    force(position: Vector): Vector | null {\n        let force = position.sub(this.point.x, this.point.y);\n        let d = force.mag();\n\n        if (d >= this._min && d <= this._max) {\n            let a = d - this._min;\n            let b = this._max - this._min;\n            force = force.normalize().mult(1.0 - a * a / (b * b));\n            return force.mult(-this.strength);\n        } else {\n            return null;\n        }\n    }\n\n    apply(p: Particle) {\n        let force = this.force(p.position);\n        if (force) p.addForce(force);\n    }\n}\n\nexport class LineField extends Force {\n    line: Line;\n    strength: number;\n\n    private _min: number = 0;\n    private _max: number = Number.POSITIVE_INFINITY;\n\n    constructor(line: Line, strength: number = 1) {\n        super();\n        this.line = line;\n        this.strength = strength;\n    }\n\n    range(min: number = 0, max:number = Number.POSITIVE_INFINITY){\n        this._min = min;\n        this._max = max;\n    }\n\n    force(position: Vector): Vector | null {\n        let cp = this.line.closest(new Point(position.x, position.y));\n\n        let force = position.sub(cp.x, cp.y);\n        let d = force.mag();\n\n        if (d >= this._min && d <= this._max) {\n            let a = d - this._min;\n            let b = this._max - this._min;\n            force = force.normalize().mult(1.0 - a * a / (b * b));\n            return force.mult(-this.strength);\n        } else {\n            return null;\n        }\n    }\n\n    apply(p: Particle) {\n        let force = this.force(p.position);\n        if (force) p.addForce(force);\n    }\n}\n\nexport class ArcField extends Force {\n    arc: Arc;\n    strength: number;\n\n    private _min: number = 0;\n    private _max: number = Number.POSITIVE_INFINITY;\n\n    constructor(arc: Arc, strength: number = 1) {\n        super();\n        this.arc = arc;\n        this.strength = strength;\n    }\n\n    range(min: number = 0, max:number = Number.POSITIVE_INFINITY){\n        this._min = min;\n        this._max = max;\n    }\n\n    force(position: Vector): Vector | null {\n        let cp = this.arc.closest(new Point(position.x, position.y));\n\n        let force = position.sub(cp.x, cp.y);\n        let d = force.mag();\n\n        if (d >= this._min && d <= this._max) {\n            let a = d - this._min;\n            let b = this._max - this._min;\n            force = force.normalize().mult(1.0 - a * a / (b * b));\n            return force.mult(-this.strength);\n        } else {\n            return null;\n        }\n    }\n\n    apply(p: Particle) {\n        let force = this.force(p.position);\n        if (force) p.addForce(force);\n    }\n}\n\nexport class CircleField extends Force {\n    circle: Circle;\n    strength: number;\n\n    private _min: number = 0;\n    private _max: number = Number.POSITIVE_INFINITY;\n\n    constructor(circle: Circle, strength: number = 1) {\n        super();\n        this.circle = circle;\n        this.strength = strength;\n    }\n\n    range(min: number = 0, max:number = Number.POSITIVE_INFINITY){\n        this._min = min;\n        this._max = max;\n    }\n\n    force(position: Vector): Vector | null {\n        let cp = this.circle.closest(new Point(position.x, position.y));\n\n        let force = position.sub(cp.x, cp.y);\n        let d = force.mag();\n\n        if (d >= this._min && d <= this._max) {\n            let a = d - this._min;\n            let b = this._max - this._min;\n            force = force.normalize().mult(1.0 - a * a / (b * b));\n            return force.mult(-this.strength);\n        } else {\n            return null;\n        }\n    }\n\n    apply(p: Particle) {\n        let force = this.force(p.position);\n        if (force) p.addForce(force);\n    }\n}\n\n\n\n\nexport abstract class InteractionForce {\n    abstract apply(particles: Particle[]);\n}\n\nexport class Collision extends InteractionForce {\n    strength: number = 1;\n    iterations: number = 1;\n\n    private _filter: Function;\n    private _quadTree: QuadTree;\n\n    constructor(quadTree: QuadTree = null) {\n        super();\n        this._filter = ()=>true;\n        this._quadTree = quadTree;\n    }\n\n    filter(f:Function){\n        this._filter = f;\n    }\n\n    apply(particles: Particle[]) {\n        for (let k = 0; k < this.iterations; k++) {\n            if(this._quadTree){\n                this._quadTree.clear();\n                this._quadTree.insert(particles);\n            }\n            \n            for (let i = 0; i < particles.length - 1; i++) {\n                let a = particles[i];\n\n                if(this._quadTree){\n                    let objects = this._quadTree.query(new Circle(a.position.x, a.position.y, a.radius));\n\n                    for (let j = 0; j < objects.length; j++) {\n                        let b = objects[j];\n                        if (!this._filter(a, b) || a === b) continue;\n\n                        let v = a.position.sub(b.position);\n                        let d = v.mag();\n                        let r = a.radius + b.radius;\n                        if (d < r) {\n                            v = v.normalize().mult(r - d).mult(this.strength);\n                            a.position = a.position.add(v.mult(a.radius / r));\n                            b.position = b.position.sub(v.mult(b.radius / r));\n                        }\n                    }\n                }else{\n                    for (let j = i + 1; j < particles.length; j++) {\n                        let b = particles[j];\n                        if (!this._filter(a, b)) continue;\n\n                        let v = a.position.sub(b.position);\n                        let d = v.mag();\n                        let r = a.radius + b.radius;\n                        if (d < r) {\n                            v = v.normalize().mult(r - d).mult(this.strength);\n                            a.position = a.position.add(v.mult(a.radius / r));\n                            b.position = b.position.sub(v.mult(b.radius / r));\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nexport class Gravitation extends InteractionForce {\n    G: number;\n    iterations: number = 1;\n\n    private _min: number = 0;\n    private _max: number = Number.POSITIVE_INFINITY;\n    private _filter: Function;\n\n    constructor(G: number = 1) {\n        super();\n        this.G = G;\n        this._filter = ()=>true;\n    }\n\n    range(min: number = 0, max: number = Number.POSITIVE_INFINITY){\n        this._min = min;\n        this._max = max;\n    }\n\n    filter(f:Function){\n        this._filter = f;\n    }\n\n    apply(particles: Particle[]) {\n        for (let k = 0; k < this.iterations; k++) {\n            for (let i = 0; i < particles.length - 1; i++) {\n                let a = particles[i];\n                for (let j = i + 1; j < particles.length; j++) {\n                    let b = particles[j];\n                    if (!this._filter(a, b)) continue;\n\n                    let v = a.position.sub(b.position);\n                    let d = v.mag();\n                    if (d >= this._min && d <= this._max) {\n                        v = v.normalize().mult(this.G * a.mass * b.mass / (d * d));\n                        a.position = a.position.sub(v);\n                        b.position = b.position.add(v);\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n\n\nexport abstract class Constraint {\n    abstract apply(p: Particle);\n}\n\nexport class CircleConstraint extends Constraint {\n    circle: Circle;\n\n    constructor(circle: Circle) {\n        super();\n        this.circle = circle;\n    }\n\n    apply(p: Particle) {\n        if (this.circle.p.distance(new Point(p.position.x, p.position.y)) < this.circle.r + p.radius) {\n            let v = p.position.sub(this.circle.p.x, this.circle.p.y).normalize()\n            v = v.mult(this.circle.r + p.radius).add(this.circle.p.x, this.circle.p.y);\n            p.position.x = v.x;\n            p.position.y = v.y;\n        }\n    }\n}\n\nexport class RectConstraint extends Constraint {\n    rect: Rect;\n\n    constructor(rect: Rect) {\n        super();\n        this.rect = rect;\n    }\n\n    apply(p: Particle) {\n        let x = p.position.x;\n        let y = p.position.y;\n        let cx = false;\n        let cy = false;\n\n        if (x < this.rect.p.x) x = this.rect.p.x;\n        else if (x > this.rect.p.x + this.rect.w) x = this.rect.p.x + this.rect.w;\n        else cx = true;\n        if (y < this.rect.p.y) y = this.rect.p.y;\n        else if (y > this.rect.p.y + this.rect.h) y = this.rect.p.y + this.rect.h;\n        else cy = true;\n\n        let dx = p.position.x - x;\n        let dy = p.position.y - y;\n\n        if (dx * dx + dy * dy <= p.radius * p.radius) {\n            let v = p.position.sub(x, y).normalize().mult(p.radius).add(x, y);\n            if (cx && cy) v = v.invert();\n            p.position.x = v.x;\n            p.position.y = v.y;\n        }\n    }\n}\n\nexport class PolygonConstraint extends Constraint {\n    polygon: Polygon;\n\n    constructor(polygon: Polygon) {\n        super();\n        this.polygon = polygon;\n    }\n\n    apply(p: Particle) {\n        let point = new Point(p.position.x, p.position.y);\n        let contain = this.polygon.contains(point);\n        let cp = this.polygon.closest(point);\n        let d = cp.distance(point);\n\n        if (contain || d < p.radius) {\n            let v = p.position.sub(cp.x, cp.y).normalize().mult(p.radius).add(cp.x, cp.y);\n            if (contain) v = v.invert();\n            p.position.x = v.x;\n            p.position.y = v.y;\n        }\n    }\n}\n",
        "called_code_segment": "apply(p: Particle) {\n        let force = this.force(p.position);\n        if (force) p.addForce(force);\n    }",
        "invoking_code_segment": "for (let p of this.particles) for (let f of this.forces) f.apply(p);",
        "new_file_code_segment": "export class EnhancedPointField extends PointField {\n    constructor(point: Point, strength: number = 1) {\n        super(point, strength);\n    }\n\n    apply(p: Particle) {\n        let force = this.force(p.position);\n        if (force) {\n            p.addForce(force);\n            // Additional functionality\n            console.log(`Applied force to particle at ${p.position.x}, ${p.position.y}`);\n        }\n    }\n}",
        "feature_description": "Enhance the PointField class to log the application of forces to particles.",
        "detailed_feature_description": "The new feature enhances the PointField class by adding logging functionality. When a force is applied to a particle, a log message is printed to the console. This is implemented in a new file (#file 3) and integrated into the existing codebase by modifying the PointField class in #file 1 to extend the new EnhancedPointField class. The World class in #file 2 is updated to use the new EnhancedPointField class where applicable.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { EnhancedPointField } from './EnhancedPointField';\n\nexport abstract class Force {\n    abstract apply(p: Particle);\n}\n\nexport class ConstForce extends Force {\n    force: Vector;\n\n    constructor(v: Vector);\n    constructor(x: number, y: number);\n    constructor() {\n        super();\n        if (arguments.length == 1) {\n            this.force = arguments[0];\n        } else if (arguments.length == 2) {\n            this.force = new Vector(arguments[0], arguments[1]);\n        } else {\n            this.force = new Vector(0, 0);\n        }\n    }\n\n    apply(p: Particle) {\n        p.addForce(this.force);\n    }\n}\n\n//Modify\nexport class PointField extends EnhancedPointField {\n    constructor(point: Point, strength: number = 1) {\n        super(point, strength);\n    }\n}",
            "#file 2": "//Modify\nimport { EnhancedPointField } from './EnhancedPointField';\n\nexport class World {\n    bounds: Rect;\n    friction: number = .75;\n\n    particles: Particle[];\n    springs: Spring[];\n\n    forces: Force[];\n    interactionForces: InteractionForce[];\n    constraints: Constraint[];\n\n    constructor(bounds: Rect = null) {\n        this.bounds = bounds;\n\n        this.particles = [];\n        this.springs = [];\n        this.forces = [];\n        this.interactionForces = [];\n        this.constraints = [];\n    }\n\n    addParticle(p: Particle) {\n        this.particles.push(p);\n    }\n    addSpring(s: Spring) {\n        this.springs.push(s);\n    }\n    addForce(f: Force) {\n        this.forces.push(f);\n    }\n    addInteractionForce(f: InteractionForce) {\n        this.interactionForces.push(f);\n    }\n    addConstraint(c: Constraint) {\n        this.constraints.push(c);\n    }\n\n    update() {\n        for (let p of this.particles) for (let f of this.forces) f.apply(p);\n        for (let f of this.interactionForces) f.apply(this.particles);\n        for (let s of this.springs) s.update();\n        for (let p of this.particles) p.update(this.friction);\n        for (let p of this.particles) for (let c of this.constraints) c.apply(p);\n        if (this.bounds) for (let p of this.particles) p.bounce(this.bounds);\n    }\n}",
            "#file 3": "//New\nexport class EnhancedPointField extends PointField {\n    constructor(point: Point, strength: number = 1) {\n        super(point, strength);\n    }\n\n    apply(p: Particle) {\n        let force = this.force(p.position);\n        if (force) {\n            p.addForce(force);\n            // Additional functionality\n            console.log(`Applied force to particle at ${p.position.x}, ${p.position.y}`);\n        }\n    }\n}"
        }
    },
    {
        "repo": "coc-rime",
        "content": "'coc-rime/src/binding.ts'\n:import { existsSync } from 'fs';\nimport { resolve } from 'path';\nimport { default as build } from 'node-gyp-build';\nimport { execSync } from 'child_process';\n\nlet binding;\nconst root = resolve(__dirname, '..');\ntry {\n  binding = build(root);\n} catch (e) {\n  let cmd = 'npm rebuild';\n  if (existsSync('/run/current-system/nixos-version')) {\n    cmd = `nix-shell --pure --run \"${cmd}\"`;\n  }\n  execSync(cmd, { cwd: resolve(__dirname, '..') });\n  binding = build(root);\n}\nexport default binding;\n\nexport interface Traits {\n  shared_data_dir?: string | null;\n  user_data_dir?: string | null;\n  log_dir?: string | null;\n  distribution_name?: string | null;\n  distribution_code_name: string;\n  distribution_version: string;\n  app_name?: string | null;\n  min_log_level?: 0 | 1 | 2 | 3;\n}\n\nexport interface Composition {\n  length: number;\n  cursor_pos: number;\n  sel_start: number;\n  sel_end: number;\n  preedit?: string;\n}\n\nexport interface Candidate {\n  text: string;\n  comment?: string;\n}\n\nexport interface Menu {\n  page_size: number;\n  page_no: number;\n  is_last_page: boolean;\n  highlighted_candidate_index: number;\n  num_candidates: number;\n  candidates?: Candidate[];\n  select_keys?: string[];\n}\n\nexport interface Context {\n  composition: Composition;\n  menu: Menu;\n}\n\nexport interface Schema {\n  schema_id: string;\n  name: string;\n}\n\nexport interface Commit {\n  text: string;\n}\n\n'coc-rime/src/config.ts'\n:import { realpath, mkdir } from 'fs/promises';\nimport { workspace, WorkspaceConfiguration, ExtensionContext } from 'coc.nvim';\nimport { Traits } from './binding';\n\nasync function get_dir(...dirs: string[]): Promise<string> {\n  for (const dir of dirs) {\n    try {\n      return await realpath(eval('`' + dir + '`'));\n    } catch (e) {}\n  }\n  return '';\n}\n\nexport interface UI {\n  indices: string[];\n  left: string;\n  right: string;\n  left_sep: string;\n  right_sep: string;\n  cursor: string;\n}\n\nexport class Config {\n  private cfg: WorkspaceConfiguration;\n  private context: ExtensionContext;\n\n  constructor(context: ExtensionContext) {\n    this.cfg = workspace.getConfiguration('rime');\n    this.context = context;\n  }\n  get enabled() {\n    return this.cfg.get<boolean>('enabled');\n  }\n  get priority() {\n    return this.cfg.get<number>('priority');\n  }\n  get schemaId() {\n    return this.cfg.get<string>('schemaId');\n  }\n  get shortcut() {\n    return this.cfg.get<string>('shortcut');\n  }\n  get traits() {\n    return new Promise<Traits>(async (res, reject) => {\n      let shared_data_dir = this.cfg.get<string | string[] | null>('traits.shared_data_dir');\n      let user_data_dir = this.cfg.get<string | string[] | null>('traits.user_data_dir');\n      let log_dir = this.cfg.get<string | null>('traits.log_dir');\n      if (log_dir === '') log_dir = this.context.storagePath;\n      if (log_dir !== null) {\n        // if logDir doesn't exist:\n        // In GNU/Linux, log will be disabled\n        // In Android, an ::__fs::filesystem::filesystem_error will be threw\n        try {\n          await mkdir(log_dir);\n        } catch (e) {}\n      }\n      if (typeof shared_data_dir === 'object') shared_data_dir = await get_dir(...shared_data_dir);\n      if (typeof user_data_dir === 'object') user_data_dir = await get_dir(...user_data_dir);\n      let traits = {\n        shared_data_dir: shared_data_dir,\n        user_data_dir: user_data_dir,\n        log_dir: log_dir,\n        distribution_name: this.cfg.get<string | null>('traits.distribution_name'),\n        distribution_code_name: this.cfg.get<string>('traits.distribution_code_name'),\n        distribution_version: this.cfg.get<string>('traits.distribution_version'),\n        app_name: this.cfg.get<string | null>('traits.app_name'),\n        min_log_level: this.cfg.get<0 | 1 | 2 | 3>('traits.min_log_level'),\n      };\n      try {\n        res(traits);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n  get ui() {\n    return {\n      indices: this.cfg.get<string[]>('ui.indices'),\n      left: this.cfg.get<string>('ui.left'),\n      right: this.cfg.get<string>('ui.right'),\n      left_sep: this.cfg.get<string>('ui.left_sep'),\n      right_sep: this.cfg.get<string>('ui.right_sep'),\n      cursor: this.cfg.get<string>('ui.cursor'),\n    };\n  }\n}\n\n",
        "called_code_segment": "export default binding;",
        "invoking_code_segment": "let binding;\nconst root = resolve(__dirname, '..');\ntry {\n  binding = build(root);\n} catch (e) {\n  let cmd = 'npm rebuild';\n  if (existsSync('/run/current-system/nixos-version')) {\n    cmd = `nix-shell --pure --run \"${cmd}\"`;\n  }\n  execSync(cmd, { cwd: resolve(__dirname, '..') });\n  binding = build(root);\n}\nexport default binding;",
        "new_file_code_segment": "export function logBindingError(e) {\n  console.error('Error initializing RIME binding:', e);\n}",
        "feature_description": "Add error logging for binding initialization.",
        "detailed_feature_description": "The new feature introduces error logging for the RIME binding initialization process. If the binding fails to initialize, an error message will be logged to the console. This is implemented by adding a new function `logBindingError` in a new file (#file 3) and invoking it from #file 1 where the binding is initialized. #file 2 remains unchanged as it directly uses the binding from #file 1.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { logBindingError } from './logBindingError';\n\nexport default binding;\n\n//New\nexport function initializeBinding() {\n  let binding;\n  const root = resolve(__dirname, '..');\n  try {\n    binding = build(root);\n  } catch (e) {\n    logBindingError(e);\n    let cmd = 'npm rebuild';\n    if (existsSync('/run/current-system/nixos-version')) {\n      cmd = `nix-shell --pure --run \"${cmd}\"`;\n    }\n    execSync(cmd, { cwd: resolve(__dirname, '..') });\n    binding = build(root);\n  }\n  return binding;\n}",
            "#file 2": "import { initializeBinding } from './binding';\n\nconst binding = initializeBinding();\nexport default binding;",
            "#file 3": "//New\nexport function logBindingError(e) {\n  console.error('Error initializing RIME binding:', e);\n}"
        }
    },
    {
        "repo": "comp3123_full_stack",
        "content": "'comp3123_full_stack/lab-review/src/app/about-us/about-us.component.ts'\n:import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-about-us',\n  templateUrl: './about-us.component.html',\n  styleUrls: ['./about-us.component.scss']\n})\nexport class AboutUsComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n\n'comp3123_full_stack/lab-review/src/app/about-us/about-us.component.spec.ts'\n:import { async, ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { AboutUsComponent } from './about-us.component';\n\ndescribe('AboutUsComponent', () => {\n  let component: AboutUsComponent;\n  let fixture: ComponentFixture<AboutUsComponent>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ AboutUsComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(AboutUsComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n\n",
        "called_code_segment": "@Component({\n  selector: 'app-about-us',\n  templateUrl: './about-us.component.html',\n  styleUrls: ['./about-us.component.scss']\n})\nexport class AboutUsComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() { }\n\n}",
        "invoking_code_segment": "describe('AboutUsComponent', () => {\n  let component: AboutUsComponent;\n  let fixture: ComponentFixture<AboutUsComponent>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ AboutUsComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(AboutUsComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});",
        "new_file_code_segment": "export class AboutUsService {\n  getTeamMembers() {\n    return ['Alice', 'Bob', 'Charlie'];\n  }\n}",
        "feature_description": "Add a service to fetch team members for the About Us component.",
        "detailed_feature_description": "A new service, `AboutUsService`, is created to provide a list of team members. This service is injected into the `AboutUsComponent` to fetch and display the team members. The test file is updated to include the service in the testing module.",
        "modified_complete_code": {
            "#file 1": "import { Component, OnInit } from '@angular/core';\nimport { AboutUsService } from './about-us.service';\n\n@Component({\n  selector: 'app-about-us',\n  templateUrl: './about-us.component.html',\n  styleUrls: ['./about-us.component.scss']\n})\nexport class AboutUsComponent implements OnInit {\n\n  teamMembers: string[];\n\n  constructor(private aboutUsService: AboutUsService) { }\n\n  ngOnInit() {\n    this.teamMembers = this.aboutUsService.getTeamMembers();\n  }\n\n}",
            "#file 2": "import { async, ComponentFixture, TestBed } from '@angular/core/testing';\nimport { AboutUsComponent } from './about-us.component';\nimport { AboutUsService } from './about-us.service';\n\ndescribe('AboutUsComponent', () => {\n  let component: AboutUsComponent;\n  let fixture: ComponentFixture<AboutUsComponent>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ AboutUsComponent ],\n      providers: [ AboutUsService ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(AboutUsComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});",
            "#file 3": "export class AboutUsService {\n  getTeamMembers() {\n    return ['Alice', 'Bob', 'Charlie'];\n  }\n}"
        }
    },
    {
        "repo": "cover-letter-snippets",
        "content": "'cover-letter-snippets/snippets/src/app/build-cover-letter/build-cover-letter.component.ts'\n:import { Component, OnInit } from '@angular/core';\n\nimport { ParseDescriptionService } from '../services/parse-description.service';\nimport { StatusMessageService } from '../services/status-message.service';\nimport { DatabaseService } from '../services/database.service';\nimport { CoverLetterService } from '../services/cover-letter.service';\n\n@Component({\n  selector: 'app-build-cover-letter',\n  templateUrl: './build-cover-letter.component.html',\n  styleUrls: ['./build-cover-letter.component.css']\n})\nexport class BuildCoverLetterComponent implements OnInit {\n\n  constructor(\n    public parseDescriptionService: ParseDescriptionService,\n    public coverLetterService: CoverLetterService,\n  ) { }\n\n  ngOnInit() {\n  }\n\n}\n\n'cover-letter-snippets/snippets/src/app/cover-letter/cover-letter.component.spec.ts'\n:import { async, ComponentFixture, TestBed } from '@angular/core/testing';\nimport { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\nimport { RouterTestingModule } from '@angular/router/testing';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\n\nimport { CoverLetterComponent } from './cover-letter.component';\nimport { DatabaseComponent } from '../database/database.component';\nimport { AddSnippetComponent } from '../add-snippet/add-snippet.component';\nimport { BuildCoverLetterComponent } from '../build-cover-letter/build-cover-letter.component';\nimport { ExportComponent } from '../export/export.component';\n\nimport { ParseDescriptionService } from '../services/parse-description.service';\nimport { DatabaseService } from '../services/database.service';\nimport { StatusMessageService } from '../services/status-message.service';\nimport { CoverLetterService } from '../services/cover-letter.service';\n\ndescribe('CoverLetterComponent', () => {\n  let component: CoverLetterComponent;\n  let fixture: ComponentFixture<CoverLetterComponent>;\n\n  const appRoutes = [\n    { path: '', component: DatabaseComponent },\n    { path: 'add-snippet', component: AddSnippetComponent },\n    { path: 'build-cover-letter', component: BuildCoverLetterComponent },\n    { path: 'export-cover-letter', component: ExportComponent }\n  ];\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        FormsModule,\n        ReactiveFormsModule,\n        RouterTestingModule.withRoutes(appRoutes)\n      ],\n      declarations: [\n        CoverLetterComponent,\n        DatabaseComponent,\n        AddSnippetComponent,\n        BuildCoverLetterComponent,\n        ExportComponent\n      ],\n      schemas: [CUSTOM_ELEMENTS_SCHEMA],\n      providers: [\n        ParseDescriptionService,\n        StatusMessageService,\n        CoverLetterService,\n        DatabaseService\n      ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(CoverLetterComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n\n",
        "called_code_segment": "@Component({\n  selector: 'app-build-cover-letter',\n  templateUrl: './build-cover-letter.component.html',\n  styleUrls: ['./build-cover-letter.component.css']\n})\nexport class BuildCoverLetterComponent implements OnInit {\n\n  constructor(\n    public parseDescriptionService: ParseDescriptionService,\n    public coverLetterService: CoverLetterService,\n  ) { }\n\n  ngOnInit() {\n  }\n\n}",
        "invoking_code_segment": "@Component({\n  selector: 'app-cover-letter',\n  templateUrl: './cover-letter.component.html',\n  styleUrls: ['./cover-letter.component.css']\n})\nexport class CoverLetterComponent implements OnInit {\n\n  constructor(\n    public parseDescriptionService: ParseDescriptionService,\n    public coverLetterService: CoverLetterService,\n  ) { }\n\n  ngOnInit() {\n  }\n\n}",
        "new_file_code_segment": "export class NewFeatureService {\n  constructor() { }\n\n  performNewFeature() {\n    console.log('New feature performed!');\n  }\n}",
        "feature_description": "Add a new feature to perform a specific action in the BuildCoverLetterComponent and CoverLetterComponent.",
        "detailed_feature_description": "A new service, NewFeatureService, is introduced to encapsulate the logic for the new feature. This service is injected into both BuildCoverLetterComponent and CoverLetterComponent. The new feature is invoked in the ngOnInit method of both components, ensuring that the new functionality is executed when the components are initialized.",
        "modified_complete_code": {
            "#file 1": "@Component({\n  selector: 'app-build-cover-letter',\n  templateUrl: './build-cover-letter.component.html',\n  styleUrls: ['./build-cover-letter.component.css']\n})\nexport class BuildCoverLetterComponent implements OnInit {\n\n  constructor(\n    public parseDescriptionService: ParseDescriptionService,\n    public coverLetterService: CoverLetterService,\n    #New private newFeatureService: NewFeatureService\n  ) { }\n\n  ngOnInit() {\n    #Modify this.newFeatureService.performNewFeature();\n  }\n\n}",
            "#file 2": "@Component({\n  selector: 'app-cover-letter',\n  templateUrl: './cover-letter.component.html',\n  styleUrls: ['./cover-letter.component.css']\n})\nexport class CoverLetterComponent implements OnInit {\n\n  constructor(\n    public parseDescriptionService: ParseDescriptionService,\n    public coverLetterService: CoverLetterService,\n    #New private newFeatureService: NewFeatureService\n  ) { }\n\n  ngOnInit() {\n    #Modify this.newFeatureService.performNewFeature();\n  }\n\n}",
            "#file 3": "export class NewFeatureService {\n  constructor() { }\n\n  performNewFeature() {\n    console.log('New feature performed!');\n  }\n}"
        }
    },
    {
        "repo": "retrying-dynamic-import",
        "content": "'retrying-dynamic-import/packages/retrying-dynamic-import/src/retryingCSS.ts'\n:const reloadCSS = (href: string) => {\n  const link = document.createElement(\"link\");\n\n  link.setAttribute(\"rel\", \"stylesheet\");\n  link.setAttribute(\"href\", href);\n\n  document.head.appendChild(link);\n\n  link.addEventListener(\"load\", () => {\n    link.setAttribute(\"is-loaded\", \"true\");\n  });\n};\n\nexport const retryToLoadCSS = () => {\n  const links = document.querySelectorAll(\n    `link[rel=\"stylesheet\"]:not([is-loaded])`\n  );\n\n  links.forEach((link: HTMLLinkElement) => {\n    const href = link.href;\n\n    let isPending = false;\n    if (href) {\n      try {\n        const sheet = link.sheet;\n\n        // If the CSS is loading, the sheet will be null.\n        // I wonder if it still is null on other browsers. I only tested on Chrome.\n\n        if (sheet != null) {\n          // If the CSS is not loaded, the below code will throw an error.\n          // It is the same as the above, only tested on Chrome.\n          const cssRules = sheet.cssRules;\n        } else {\n          isPending = true;\n        }\n\n        link.setAttribute(\"is-loaded\", \"true\");\n      } catch (e) {\n        // Remove the link, and then reload it.\n        if (!isPending) {\n          link.remove();\n          reloadCSS(href);\n        }\n      }\n    }\n  });\n};\n\n'retrying-dynamic-import/packages/retrying-dynamic-import/src/index.ts'\n:import type { Options } from \"../types\";\nimport { retryToLoadCSS } from \"./retryingCSS\";\n\n// match a module url\n// eg: import('hello.js') => 'hello.js'\nconst uriOrRelativePathRegex = /import\\([\"']([^)]+)['\"]\\)/;\n\n/**\n * Records a module if it's already loaded.\n * key: module url\n * value: module\n */\nconst moduleCache: Record<string, any> = {};\n\n/**\n * Records the number of retrying times of a module.\n * key: module url\n * value: number\n */\nconst moduleRetryCount: Record<string, number> = {};\n\nconst options: Options = {\n  offlineMessage: \"No internet connection\",\n  disableRetryingCSS: false,\n  checkOnlineUrl: null,\n  onRetry: null,\n  interval: 1000,\n};\n\nconst isOffline = async () => {\n  try {\n    const response = await fetch(options.checkOnlineUrl);\n\n    if (response.ok) {\n      return false;\n    } else {\n      return true;\n    }\n  } catch {\n    return true;\n  }\n};\n\nconst fetchModule = async (url: string): Promise<any> => {\n  if (moduleCache[url]) {\n    return moduleCache[url];\n  }\n\n  return new Promise((resolve, reject) => {\n    const retry = async (\n      res: (value: unknown) => void,\n      rej: (reason?: any) => void\n    ) => {\n      const online = window.navigator.onLine;\n\n      const handleOffline = () => {\n        if (options.offlineCallback) {\n          options.offlineCallback();\n        }\n        rej(new Error(options.offlineMessage));\n      };\n\n      if (!online) {\n        /// Check the network status again.\n        if (options.checkOnlineUrl !== null) {\n          const offline = await isOffline();\n\n          if (offline) {\n            handleOffline();\n            return;\n          }\n        } else {\n          handleOffline();\n          return;\n        }\n      }\n\n      const urlWithTimestamp = url.includes(\"?\")\n        ? url + \"&t=\" + Date.now()\n        : url + \"?t=\" + Date.now();\n\n      // if the module is not loaded, use the original url\n      const importUrl =\n        moduleRetryCount[url] == undefined ? url : urlWithTimestamp;\n\n      import(/* @vite-ignore */ importUrl)\n        .then((mod) => {\n          moduleCache[url] = mod;\n\n          if (moduleRetryCount[url]) {\n            moduleRetryCount[url] = 1;\n          }\n\n          res(mod);\n        })\n        .catch((err) => {\n          if (!moduleRetryCount[url]) {\n            moduleRetryCount[url] = 1;\n          } else {\n            moduleRetryCount[url]++;\n          }\n\n          if (moduleRetryCount[url] <= 3) {\n            // waiting for 1 second.\n            // Sometimes the failure may be caused by the server, such as restarting, busying etc.\n            // Retrying without waiting will fail in a too short while.\n            setTimeout(() => {\n              // it's useful to log some information before retrying\n              if (options.onRetry) {\n                options.onRetry(url, moduleRetryCount[url]);\n              }\n\n              retry(res, rej);\n            }, options.interval);\n          } else {\n            moduleRetryCount[url] = 1;\n            rej(err);\n          }\n        });\n    };\n\n    retry(resolve, reject);\n  });\n};\n\nconst getRouteComponentUrl = (originalImport: () => Promise<any>) => {\n  let url: string;\n\n  try {\n    const fnString = originalImport.toString();\n    url = fnString.match(uriOrRelativePathRegex)[1];\n  } catch (e) {\n    return null;\n  }\n\n  return url;\n};\n\nconst mergeOptions = (userOptions: Options) => {\n  Object.assign(options, userOptions);\n};\n\nconst retryingDynamicImport = (options: Options = {}) => {\n  mergeOptions(options);\n\n  window.__retrying_dynamic_loader__ = (originalImport: () => Promise<any>) => {\n    if (options.disableRetryingCSS != true) {\n      retryToLoadCSS();\n    }\n\n    return new Promise((resolve, reject) => {\n      const url = getRouteComponentUrl(originalImport);\n\n      if (url == null) {\n        originalImport().then(resolve).catch(reject);\n      } else {\n        fetchModule(url).then(resolve).catch(reject);\n      }\n    });\n  };\n};\n\nexport default retryingDynamicImport;\n\n",
        "called_code_segment": "const fetchModule = async (url: string): Promise<any> => {\n  if (moduleCache[url]) {\n    return moduleCache[url];\n  }\n\n  return new Promise((resolve, reject) => {\n    const retry = async (\n      res: (value: unknown) => void,\n      rej: (reason?: any) => void\n    ) => {\n      const online = window.navigator.onLine;\n\n      const handleOffline = () => {\n        if (options.offlineCallback) {\n          options.offlineCallback();\n        }\n        rej(new Error(options.offlineMessage));\n      };\n\n      if (!online) {\n        /// Check the network status again.\n        if (options.checkOnlineUrl !== null) {\n          const offline = await isOffline();\n\n          if (offline) {\n            handleOffline();\n            return;\n          }\n        } else {\n          handleOffline();\n          return;\n        }\n      }\n\n      const urlWithTimestamp = url.includes(\"?\") ? url + \"&t=\" + Date.now() : url + \"?t=\" + Date.now();\n\n      // if the module is not loaded, use the original url\n      const importUrl = moduleRetryCount[url] == undefined ? url : urlWithTimestamp;\n\n      import(/* @vite-ignore */ importUrl)\n        .then((mod) => {\n          moduleCache[url] = mod;\n\n          if (moduleRetryCount[url]) {\n            moduleRetryCount[url] = 1;\n          }\n\n          res(mod);\n        })\n        .catch((err) => {\n          if (!moduleRetryCount[url]) {\n            moduleRetryCount[url] = 1;\n          } else {\n            moduleRetryCount[url]++;\n          }\n\n          if (moduleRetryCount[url] <= 3) {\n            // waiting for 1 second.\n            // Sometimes the failure may be caused by the server, such as restarting, busying etc.\n            // Retrying without waiting will fail in a too short while.\n            setTimeout(() => {\n              // it's useful to log some information before retrying\n              if (options.onRetry) {\n                options.onRetry(url, moduleRetryCount[url]);\n              }\n\n              retry(res, rej);\n            }, options.interval);\n          } else {\n            moduleRetryCount[url] = 1;\n            rej(err);\n          }\n        });\n    };\n\n    retry(resolve, reject);\n  });\n};",
        "invoking_code_segment": "const url = getRouteComponentUrl(originalImport);\n\nif (url == null) {\n  originalImport().then(resolve).catch(reject);\n} else {\n  fetchModule(url).then(resolve).catch(reject);\n}",
        "new_file_code_segment": "export const logRetryAttempt = (url: string, retryCount: number) => {\n  console.log(`Retrying to load module ${url}, attempt ${retryCount}`);\n};",
        "feature_description": "Add logging for each retry attempt.",
        "detailed_feature_description": "The new feature adds logging for each retry attempt made by the `fetchModule` function. This is implemented by creating a new function `logRetryAttempt` in a new file (#file 3) that logs the retry attempt details. The `fetchModule` function in #file 1 is updated to invoke this new function during each retry attempt. The `retryingDynamicImport` function in #file 2 is updated to import and use this new function where applicable.",
        "modified_complete_code": {
            "#file 1": "const fetchModule = async (url: string): Promise<any> => {\n  if (moduleCache[url]) {\n    return moduleCache[url];\n  }\n\n  return new Promise((resolve, reject) => {\n    const retry = async (\n      res: (value: unknown) => void,\n      rej: (reason?: any) => void\n    ) => {\n      const online = window.navigator.onLine;\n\n      const handleOffline = () => {\n        if (options.offlineCallback) {\n          options.offlineCallback();\n        }\n        rej(new Error(options.offlineMessage));\n      };\n\n      if (!online) {\n        /// Check the network status again.\n        if (options.checkOnlineUrl !== null) {\n          const offline = await isOffline();\n\n          if (offline) {\n            handleOffline();\n            return;\n          }\n        } else {\n          handleOffline();\n          return;\n        }\n      }\n\n      const urlWithTimestamp = url.includes(\"?\") ? url + \"&t=\" + Date.now() : url + \"?t=\" + Date.now();\n\n      // if the module is not loaded, use the original url\n      const importUrl = moduleRetryCount[url] == undefined ? url : urlWithTimestamp;\n\n      import(/* @vite-ignore */ importUrl)\n        .then((mod) => {\n          moduleCache[url] = mod;\n\n          if (moduleRetryCount[url]) {\n            moduleRetryCount[url] = 1;\n          }\n\n          res(mod);\n        })\n        .catch((err) => {\n          if (!moduleRetryCount[url]) {\n            moduleRetryCount[url] = 1;\n          } else {\n            moduleRetryCount[url]++;\n          }\n\n          if (moduleRetryCount[url] <= 3) {\n            // waiting for 1 second.\n            // Sometimes the failure may be caused by the server, such as restarting, busying etc.\n            // Retrying without waiting will fail in a too short while.\n            setTimeout(() => {\n              // it's useful to log some information before retrying\n              if (options.onRetry) {\n                options.onRetry(url, moduleRetryCount[url]);\n              }\n\n              // #Modify: Add logging for each retry attempt\n              logRetryAttempt(url, moduleRetryCount[url]);\n\n              retry(res, rej);\n            }, options.interval);\n          } else {\n            moduleRetryCount[url] = 1;\n            rej(err);\n          }\n        });\n    };\n\n    retry(resolve, reject);\n  });\n};",
            "#file 2": "const url = getRouteComponentUrl(originalImport);\n\nif (url == null) {\n  originalImport().then(resolve).catch(reject);\n} else {\n  fetchModule(url).then(resolve).catch(reject);\n}",
            "#file 3": "export const logRetryAttempt = (url: string, retryCount: number) => {\n  console.log(`Retrying to load module ${url}, attempt ${retryCount}`);\n};"
        }
    },
    {
        "repo": "dallify-discord-bot",
        "content": "'dallify-discord-bot/src/actions/Expand.ts'\n:\n'dallify-discord-bot/src/Actions.ts'\n:import { Action } from \"./Action\";\nimport { Save } from \"./actions/Save\";\nimport { Reroll } from \"./actions/Reroll\";\nimport { Expand } from \"./actions/Expand\";\n\nexport const Actions: Action[] = [Save, Reroll, Expand];\n\nexport function defaultActions(count: number) {\n  return [Reroll, Save];\n}\n\n",
        "called_code_segment": "export const Actions: Action[] = [Save, Reroll, Expand];\n\nexport function defaultActions(count: number) {\n  return [Reroll, Save];\n}",
        "invoking_code_segment": "const actions = defaultActions(count);",
        "new_file_code_segment": "export const Shrink: Action = {\n  name: 'Shrink',\n  execute: async (context) => {\n    // Implementation for shrinking the image\n  }\n};\n\nexport function additionalActions(count: number) {\n  return [Shrink];\n}",
        "feature_description": "Add a new action 'Shrink' to the list of available actions.",
        "detailed_feature_description": "The new feature introduces a 'Shrink' action that allows users to shrink an image. This action is implemented in a new file (#file 3) and is integrated into the existing action list in #file 1. The default actions function in #file 1 is updated to include the new 'Shrink' action. The invoking code in #file 2 is also updated to use the new additionalActions function from #file 3.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { Action } from \"./Action\";\nimport { Save } from \"./actions/Save\";\nimport { Reroll } from \"./actions/Reroll\";\nimport { Expand } from \"./actions/Expand\";\nimport { Shrink, additionalActions } from \"./actions/Shrink\"; //New\n\nexport const Actions: Action[] = [Save, Reroll, Expand, Shrink]; //Modify\n\nexport function defaultActions(count: number) {\n  return [Reroll, Save, ...additionalActions(count)]; //Modify\n}",
            "#file 2": "//Modify\nimport { defaultActions } from \"./Actions\";\nimport { additionalActions } from \"./actions/Shrink\"; //New\n\nconst actions = [...defaultActions(count), ...additionalActions(count)]; //Modify",
            "#file 3": "//New\nimport { Action } from \"./Action\";\n\nexport const Shrink: Action = {\n  name: 'Shrink',\n  execute: async (context) => {\n    // Implementation for shrinking the image\n  }\n};\n\nexport function additionalActions(count: number) {\n  return [Shrink];\n}"
        }
    },
    {
        "repo": "scratchable",
        "content": "'scratchable/src/renderer.ts'\n:export interface RendererOptions {\n  container: HTMLElement;\n  background:\n    | { type: \"single\"; color: string }\n    | {\n        type: \"linear-gradient\";\n        gradients: { offset: number; color: string }[];\n      }\n    | { type: \"image\"; url: string };\n}\n\nexport class Renderer {\n  private readonly container: HTMLElement;\n  private readonly canvas: HTMLCanvasElement;\n  private readonly ctx: CanvasRenderingContext2D;\n  private readonly background: RendererOptions[\"background\"];\n\n  constructor(options: RendererOptions) {\n    this.container = options.container;\n    this.canvas = document.createElement(\"canvas\");\n    this.ctx = this.canvas.getContext(\"2d\")!;\n    this.background = options.background;\n  }\n\n  public get dpr() {\n    return window.devicePixelRatio;\n  }\n\n  public get percentage() {\n    const { data } = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n    const stride = 32;\n    const totalPixels = data.length / stride;\n    let scratchedPixels = 0;\n\n    for (let i = 0; i < data.length; i += stride) {\n      if (data[i] === 0) {\n        scratchedPixels++;\n      }\n    }\n    return scratchedPixels / totalPixels;\n  }\n\n  public async render() {\n    this.container.style.position = \"relative\";\n\n    const dpr = window.devicePixelRatio;\n    const canvasWidth = this.container.offsetWidth * dpr;\n    const canvasHeight = this.container.offsetHeight * dpr;\n\n    this.canvas.width = canvasWidth;\n    this.canvas.height = canvasHeight;\n\n    this.canvas.style.width = \"100%\";\n    this.canvas.style.height = \"100%\";\n    this.canvas.style.position = \"absolute\";\n    this.canvas.style.top = \"0\";\n    this.canvas.style.left = \"0\";\n    this.canvas.style.right = \"0\";\n    this.canvas.style.bottom = \"0\";\n\n    return new Promise<void>((resolve) => {\n      const renderCanvas = () => {\n        this.ctx.globalCompositeOperation = \"destination-out\";\n        this.container.appendChild(this.canvas);\n        resolve();\n      };\n\n      switch (this.background.type) {\n        case \"single\": {\n          this.ctx.fillStyle = this.background.color;\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          renderCanvas();\n          return;\n        }\n        case \"linear-gradient\": {\n          const grd = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);\n\n          this.background.gradients.forEach((gradient) => {\n            grd.addColorStop(gradient.offset, gradient.color);\n          });\n\n          this.ctx.fillStyle = grd;\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          renderCanvas();\n          return;\n        }\n        case \"image\": {\n          const image = new Image();\n\n          image.onload = () => {\n            this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);\n            renderCanvas();\n          };\n\n          image.src = this.background.url;\n          return;\n        }\n      }\n    });\n  }\n\n  public circle(x: number, y: number, radius: number) {\n    const dpr = this.dpr;\n\n    this.ctx.beginPath();\n    this.ctx.arc(x * dpr, y * dpr, radius * dpr, 0, 2 * Math.PI);\n    this.ctx.fill();\n  }\n\n  public line(from: { x: number; y: number }, to: { x: number; y: number }, width: number) {\n    const dpr = this.dpr;\n\n    this.ctx.beginPath();\n    this.ctx.moveTo(from.x * dpr, from.y * dpr);\n    this.ctx.lineTo(to.x * dpr, to.y * dpr);\n    this.ctx.lineWidth = width * dpr;\n    this.ctx.stroke();\n  }\n\n  public destroy() {\n    this.container.removeChild(this.canvas);\n  }\n}\n\n'scratchable/src/scratcher.ts'\n:import { Events } from \"./events\";\nimport { Renderer, RendererOptions } from \"./renderer\";\n\nexport type ScratcherEventName = \"scratch\";\n\nexport interface ScratcherEvent {\n  percentage: number;\n}\n\nexport type ScratcherEventHandler = (e: ScratcherEvent) => void;\n\nexport interface ScratcherOptions extends RendererOptions {\n  container: HTMLElement;\n  radius?: number;\n  onScratch?: ScratcherEventHandler;\n}\n\nexport class Scratcher {\n  protected readonly container: HTMLElement;\n  private readonly renderer: Renderer;\n  private readonly radius: number;\n  public readonly events: Events<ScratcherEventName, ScratcherEvent>;\n\n  private prevScratchPosition: { x: number; y: number } | null = null;\n\n  constructor(options: ScratcherOptions) {\n    this.container = options.container;\n    this.renderer = new Renderer(options);\n    this.radius = options.radius ?? 50;\n    this.events = new Events(() => ({ percentage: this.renderer.percentage }));\n\n    if (options.onScratch != null) {\n      this.events.on(\"scratch\", options.onScratch);\n    }\n  }\n\n  protected move(x: number, y: number) {\n    this.renderer.circle(x, y, this.radius);\n\n    if (this.prevScratchPosition != null) {\n      this.renderer.line(this.prevScratchPosition, { x, y }, this.radius * 2);\n    }\n\n    this.prevScratchPosition = { x, y };\n    this.events.emit(\"scratch\");\n  }\n\n  protected end() {\n    this.prevScratchPosition = null;\n  }\n\n  public async render() {\n    await this.renderer.render();\n  }\n\n  public destroy() {\n    this.renderer.destroy();\n    this.events.purge();\n  }\n}\n\nexport class TouchScratcher extends Scratcher {\n  constructor(options: ScratcherOptions) {\n    super(options);\n    this.container.style.touchAction = \"none\";\n  }\n\n  private touchmove = (e: TouchEvent) => {\n    const { left, top } = this.container.getBoundingClientRect();\n    const { clientX, clientY } = e.changedTouches[0];\n\n    const x = clientX - left;\n    const y = clientY - top;\n    this.move(x, y);\n  };\n\n  private touchend = () => {\n    this.end();\n  };\n\n  public async render() {\n    this.container.addEventListener(\"touchmove\", this.touchmove);\n    this.container.addEventListener(\"touchend\", this.touchend);\n    await super.render();\n  }\n\n  public destory() {\n    this.container.removeEventListener(\"touchmove\", this.touchmove);\n    this.container.removeEventListener(\"touchend\", this.touchend);\n    super.destroy();\n  }\n}\n\nexport class MouseScratcher extends Scratcher {\n  constructor(options: ScratcherOptions) {\n    super(options);\n  }\n\n  private mousemove = (e: MouseEvent) => {\n    if (e.buttons === 0) {\n      this.end();\n      return;\n    }\n\n    const { left, top } = this.container.getBoundingClientRect();\n    const { clientX, clientY } = e;\n\n    const x = clientX - left;\n    const y = clientY - top;\n    this.move(x, y);\n  };\n\n  public async render() {\n    this.container.addEventListener(\"mousemove\", this.mousemove);\n    await super.render();\n  }\n\n  public destroy() {\n    this.container.removeEventListener(\"mousemove\", this.mousemove);\n    super.destroy();\n  }\n}\n\n",
        "called_code_segment": "public async render() {\n    this.container.style.position = 'relative';\n\n    const dpr = window.devicePixelRatio;\n    const canvasWidth = this.container.offsetWidth * dpr;\n    const canvasHeight = this.container.offsetHeight * dpr;\n\n    this.canvas.width = canvasWidth;\n    this.canvas.height = canvasHeight;\n\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.right = '0';\n    this.canvas.style.bottom = '0';\n\n    return new Promise<void>((resolve) => {\n      const renderCanvas = () => {\n        this.ctx.globalCompositeOperation = 'destination-out';\n        this.container.appendChild(this.canvas);\n        resolve();\n      };\n\n      switch (this.background.type) {\n        case 'single': {\n          this.ctx.fillStyle = this.background.color;\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          renderCanvas();\n          return;\n        }\n        case 'linear-gradient': {\n          const grd = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);\n\n          this.background.gradients.forEach((gradient) => {\n            grd.addColorStop(gradient.offset, gradient.color);\n          });\n\n          this.ctx.fillStyle = grd;\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          renderCanvas();\n          return;\n        }\n        case 'image': {\n          const image = new Image();\n\n          image.onload = () => {\n            this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);\n            renderCanvas();\n          };\n\n          image.src = this.background.url;\n          return;\n        }\n      }\n    });\n  }",
        "invoking_code_segment": "public async render() {\n    await this.renderer.render();\n  }",
        "new_file_code_segment": "export class RendererEnhancer {\n  public static enhance(renderer: Renderer) {\n    // Add any additional enhancements here\n    console.log('Renderer enhanced!');\n  }\n}",
        "feature_description": "Enhance the Renderer with additional functionality.",
        "detailed_feature_description": "The new feature involves enhancing the Renderer with additional functionality. This is achieved by creating a new class `RendererEnhancer` in a new file (#file 3). The `RendererEnhancer` class contains a static method `enhance` that can be used to add any additional functionality to the Renderer. The `render` method in the `Scratcher` class is updated to invoke the `enhance` method from the `RendererEnhancer` before rendering the canvas.",
        "modified_complete_code": {
            "#file 1": "//Modify\npublic async render() {\n    this.container.style.position = 'relative';\n\n    const dpr = window.devicePixelRatio;\n    const canvasWidth = this.container.offsetWidth * dpr;\n    const canvasHeight = this.container.offsetHeight * dpr;\n\n    this.canvas.width = canvasWidth;\n    this.canvas.height = canvasHeight;\n\n    this.canvas.style.width = '100%';\n    this.canvas.style.height = '100%';\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.top = '0';\n    this.canvas.style.left = '0';\n    this.canvas.style.right = '0';\n    this.canvas.style.bottom = '0';\n\n    return new Promise<void>((resolve) => {\n      const renderCanvas = () => {\n        this.ctx.globalCompositeOperation = 'destination-out';\n        this.container.appendChild(this.canvas);\n        resolve();\n      };\n\n      switch (this.background.type) {\n        case 'single': {\n          this.ctx.fillStyle = this.background.color;\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          renderCanvas();\n          return;\n        }\n        case 'linear-gradient': {\n          const grd = this.ctx.createLinearGradient(0, 0, this.canvas.width, this.canvas.height);\n\n          this.background.gradients.forEach((gradient) => {\n            grd.addColorStop(gradient.offset, gradient.color);\n          });\n\n          this.ctx.fillStyle = grd;\n          this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n          renderCanvas();\n          return;\n        }\n        case 'image': {\n          const image = new Image();\n\n          image.onload = () => {\n            this.ctx.drawImage(image, 0, 0, this.canvas.width, this.canvas.height);\n            renderCanvas();\n          };\n\n          image.src = this.background.url;\n          return;\n        }\n      }\n    });\n  }",
            "#file 2": "//Modify\npublic async render() {\n    RendererEnhancer.enhance(this.renderer); //New\n    await this.renderer.render();\n  }",
            "#file 3": "//New\nexport class RendererEnhancer {\n  public static enhance(renderer: Renderer) {\n    // Add any additional enhancements here\n    console.log('Renderer enhanced!');\n  }\n}"
        }
    },
    {
        "repo": "template-three",
        "content": "'template-three/src/helpers/rounded-rectangle.ts'\n:import { Shape } from \"three\";\n\nexport function roundedRect({\n  width,\n  height,\n  radius,\n}: {\n  width: number;\n  height: number;\n  radius: number;\n}): Shape {\n  const roundedRectShape = new Shape();\n  roundedRectShape.moveTo(0, radius);\n  roundedRectShape.lineTo(0, height - radius);\n  roundedRectShape.quadraticCurveTo(0, height, radius, height);\n  roundedRectShape.lineTo(width - radius, height);\n  roundedRectShape.quadraticCurveTo(width, height, width, height - radius);\n  roundedRectShape.lineTo(width, radius);\n  roundedRectShape.quadraticCurveTo(width, 0, width - radius, 0);\n  roundedRectShape.lineTo(radius, 0);\n  roundedRectShape.quadraticCurveTo(0, 0, 0, radius);\n  return roundedRectShape;\n}\n\n'template-three/src/Phone.tsx'\n:import { useThree } from \"@react-three/fiber\";\nimport React, { useEffect, useMemo } from \"react\";\nimport { interpolate, spring, useCurrentFrame, useVideoConfig } from \"remotion\";\nimport { VideoTexture } from \"three\";\nimport {\n  CAMERA_DISTANCE,\n  getPhoneLayout,\n  PHONE_CURVE_SEGMENTS,\n  PHONE_SHININESS,\n} from \"./helpers/layout\";\nimport { roundedRect } from \"./helpers/rounded-rectangle\";\nimport { RoundedBox } from \"./RoundedBox\";\n\nexport const Phone: React.FC<{\n  videoTexture: VideoTexture | null;\n  aspectRatio: number;\n  baseScale: number;\n  phoneColor: string;\n}> = ({ aspectRatio, videoTexture, baseScale, phoneColor }) => {\n  const frame = useCurrentFrame();\n  const { fps, durationInFrames } = useVideoConfig();\n\n  const layout = useMemo(\n    () => getPhoneLayout(aspectRatio, baseScale),\n    [aspectRatio, baseScale],\n  );\n\n  // Place a camera and set the distance to the object.\n  // Then make it look at the object.\n  const camera = useThree((state) => state.camera);\n  useEffect(() => {\n    camera.position.set(0, 0, CAMERA_DISTANCE);\n    camera.near = 0.2;\n    camera.far = Math.max(5000, CAMERA_DISTANCE * 2);\n    camera.lookAt(0, 0, 0);\n  }, [camera]);\n\n  // Make the video fill the phone texture\n  useEffect(() => {\n    if (videoTexture) {\n      videoTexture.repeat.y = 1 / layout.screen.height;\n      videoTexture.repeat.x = 1 / layout.screen.width;\n    }\n  }, [aspectRatio, layout.screen.height, layout.screen.width, videoTexture]);\n\n  // During the whole scene, the phone is rotating.\n  // 2 * Math.PI is a full rotation.\n  const constantRotation = interpolate(\n    frame,\n    [0, durationInFrames],\n    [0, Math.PI * 6],\n  );\n\n  // When the composition starts, there is some extra\n  // rotation and translation.\n  const entranceAnimation = spring({\n    frame,\n    fps,\n    config: {\n      damping: 200,\n      mass: 3,\n    },\n  });\n\n  // Calculate the entrance rotation,\n  // doing one full spin\n  const entranceRotation = interpolate(\n    entranceAnimation,\n    [0, 1],\n    [-Math.PI, Math.PI],\n  );\n\n  // Calculating the total rotation of the phone\n  const rotateY = entranceRotation + constantRotation;\n\n  // Calculating the translation of the phone at the beginning.\n  // The start position of the phone is set to 4 \"units\"\n  const translateY = interpolate(entranceAnimation, [0, 1], [-4, 0]);\n\n  // Calculate a rounded rectangle for the phone screen\n  const screenGeometry = useMemo(() => {\n    return roundedRect({\n      width: layout.screen.width,\n      height: layout.screen.height,\n      radius: layout.screen.radius,\n    });\n  }, [layout.screen.height, layout.screen.radius, layout.screen.width]);\n\n  return (\n    <group\n      scale={entranceAnimation}\n      rotation={[0, rotateY, 0]}\n      position={[0, translateY, 0]}\n    >\n      <RoundedBox\n        radius={layout.phone.radius}\n        depth={layout.phone.thickness}\n        curveSegments={PHONE_CURVE_SEGMENTS}\n        position={layout.phone.position}\n        width={layout.phone.width}\n        height={layout.phone.height}\n      >\n        <meshPhongMaterial color={phoneColor} shininess={PHONE_SHININESS} />\n      </RoundedBox>\n      <mesh position={layout.screen.position}>\n        <shapeGeometry args={[screenGeometry]} />\n        {videoTexture ? (\n          <meshBasicMaterial\n            color={0xffffff}\n            toneMapped={false}\n            map={videoTexture}\n          />\n        ) : null}\n      </mesh>\n    </group>\n  );\n};\n\n",
        "called_code_segment": "export function roundedRect({ width, height, radius, }: { width: number; height: number; radius: number; }): Shape { const roundedRectShape = new Shape(); roundedRectShape.moveTo(0, radius); roundedRectShape.lineTo(0, height - radius); roundedRectShape.quadraticCurveTo(0, height, radius, height); roundedRectShape.lineTo(width - radius, height); roundedRectShape.quadraticCurveTo(width, height, width, height - radius); roundedRectShape.lineTo(width, radius); roundedRectShape.quadraticCurveTo(width, 0, width - radius, 0); roundedRectShape.lineTo(radius, 0); roundedRectShape.quadraticCurveTo(0, 0, 0, radius); return roundedRectShape; }",
        "invoking_code_segment": "const screenGeometry = useMemo(() => { return roundedRect({ width: layout.screen.width, height: layout.screen.height, radius: layout.screen.radius, }); }, [layout.screen.height, layout.screen.radius, layout.screen.width]);",
        "new_file_code_segment": "export function roundedRectWithBorder({ width, height, radius, borderWidth }: { width: number; height: number; radius: number; borderWidth: number; }): Shape { const roundedRectShape = new Shape(); roundedRectShape.moveTo(0, radius + borderWidth); roundedRectShape.lineTo(0, height - radius - borderWidth); roundedRectShape.quadraticCurveTo(0, height - borderWidth, radius + borderWidth, height - borderWidth); roundedRectShape.lineTo(width - radius - borderWidth, height - borderWidth); roundedRectShape.quadraticCurveTo(width - borderWidth, height - borderWidth, width - borderWidth, height - radius - borderWidth); roundedRectShape.lineTo(width - borderWidth, radius + borderWidth); roundedRectShape.quadraticCurveTo(width - borderWidth, borderWidth, width - radius - borderWidth, borderWidth); roundedRectShape.lineTo(radius + borderWidth, borderWidth); roundedRectShape.quadraticCurveTo(borderWidth, borderWidth, borderWidth, radius + borderWidth); return roundedRectShape; }",
        "feature_description": "Add a border to the rounded rectangle.",
        "detailed_feature_description": "The new feature allows the rounded rectangle to have a border. This is achieved by creating a new function `roundedRectWithBorder` in a new file (#file 3) that accepts an additional parameter `borderWidth`. The original `roundedRect` function remains unchanged to ensure backward compatibility, while the new function is used in #file 1 and #file 2 where a border is required.",
        "modified_complete_code": {
            "#file 1": "//Modify export function roundedRect({ width, height, radius, }: { width: number; height: number; radius: number; }): Shape { const roundedRectShape = new Shape(); roundedRectShape.moveTo(0, radius); roundedRectShape.lineTo(0, height - radius); roundedRectShape.quadraticCurveTo(0, height, radius, height); roundedRectShape.lineTo(width - radius, height); roundedRectShape.quadraticCurveTo(width, height, width, height - radius); roundedRectShape.lineTo(width, radius); roundedRectShape.quadraticCurveTo(width, 0, width - radius, 0); roundedRectShape.lineTo(radius, 0); roundedRectShape.quadraticCurveTo(0, 0, 0, radius); return roundedRectShape; }",
            "#file 2": "//Modify const screenGeometry = useMemo(() => { return roundedRectWithBorder({ width: layout.screen.width, height: layout.screen.height, radius: layout.screen.radius, borderWidth: 0.1, }); }, [layout.screen.height, layout.screen.radius, layout.screen.width]);",
            "#file 3": "//New export function roundedRectWithBorder({ width, height, radius, borderWidth }: { width: number; height: number; radius: number; borderWidth: number; }): Shape { const roundedRectShape = new Shape(); roundedRectShape.moveTo(0, radius + borderWidth); roundedRectShape.lineTo(0, height - radius - borderWidth); roundedRectShape.quadraticCurveTo(0, height - borderWidth, radius + borderWidth, height - borderWidth); roundedRectShape.lineTo(width - radius - borderWidth, height - borderWidth); roundedRectShape.quadraticCurveTo(width - borderWidth, height - borderWidth, width - borderWidth, height - radius - borderWidth); roundedRectShape.lineTo(width - borderWidth, radius + borderWidth); roundedRectShape.quadraticCurveTo(width - borderWidth, borderWidth, width - radius - borderWidth, borderWidth); roundedRectShape.lineTo(radius + borderWidth, borderWidth); roundedRectShape.quadraticCurveTo(borderWidth, borderWidth, borderWidth, radius + borderWidth); return roundedRectShape; }"
        }
    },
    {
        "repo": "tiptap-resizable-image",
        "content": "'tiptap-resizable-image/apps/docs/src/app/(home)/Jumbotron.tsx'\n:import { Text, ThemeIcon } from '@mantine/core';\nimport classes from './Jumbotron.module.css';\n\ninterface Props {\n  icon: React.ReactNode;\n  title: string;\n  description: string;\n}\n\nconst Jumbotron = ({ icon, title, description }: Props) => {\n  return (\n    <div className={classes.root}>\n      <ThemeIcon\n        size='xl'\n        radius='md'\n        gradient={{ from: 'blue', to: 'cyan', deg: 90 }}\n      >\n        {icon}\n      </ThemeIcon>\n      <div>\n        <Text className={classes.title}>{title}</Text>\n        <Text className={classes.description}>{description}</Text>\n      </div>\n    </div>\n  );\n};\nexport default Jumbotron;\n\n'tiptap-resizable-image/apps/docs/src/app/(home)/page.tsx'\n:import { Button, Group, Stack, Text, Title } from '@mantine/core';\nimport Link from 'next/link';\nimport classes from './page.module.css';\nimport {\n  IconBrandGithub,\n  IconFlame,\n  IconLifebuoy,\n  IconScale,\n} from '@tabler/icons-react';\nimport Jumbotron from './Jumbotron';\nimport { REPO_LINK } from '@/config';\n\nconst Home = () => {\n  return (\n    <Stack>\n      <Title className={classes.title}>\n        Tiptap{' '}\n        <Text\n          component='span'\n          variant='gradient'\n          gradient={{ from: 'blue', to: 'cyan' }}\n          inherit\n        >\n          Resizable Image\n        </Text>{' '}\n        - Enriching your rich text editor with advanced image control\n      </Title>\n      <div className={classes.jumbotrons}>\n        <Jumbotron\n          icon={<IconScale />}\n          title='Free and open source'\n          description='This package is released under the MIT license, you can use titap-extension-resizable-image in any project'\n        />\n        <Jumbotron\n          icon={<IconLifebuoy />}\n          title='TypeScript based'\n          description='Built with TypeScript, ensuring a smooth and type-safe development experience'\n        />\n        <Jumbotron\n          icon={<IconFlame />}\n          title='Flexible'\n          description='Offers flexibility with customizable styles, interactive context menus and popovers, adapting to your unique development needs'\n        />\n      </div>\n      <Group justify='center'>\n        <Button\n          component={Link}\n          href='/getting-started'\n          variant='gradient'\n          gradient={{ from: 'blue', to: 'cyan', deg: 90 }}\n          size='xl'\n          radius='md'\n        >\n          Get Started\n        </Button>\n        <Button\n          component='a'\n          href={REPO_LINK}\n          target='_blank'\n          leftSection={<IconBrandGithub />}\n          variant='default'\n          size='xl'\n          radius='md'\n        >\n          GitHub\n        </Button>\n      </Group>\n    </Stack>\n  );\n};\nexport default Home;\n\n",
        "called_code_segment": "const Jumbotron = ({ icon, title, description }: Props) => {\n  return (\n    <div className={classes.root}>\n      <ThemeIcon\n        size='xl'\n        radius='md'\n        gradient={{ from: 'blue', to: 'cyan', deg: 90 }}\n      >\n        {icon}\n      </ThemeIcon>\n      <div>\n        <Text className={classes.title}>{title}</Text>\n        <Text className={classes.description}>{description}</Text>\n      </div>\n    </div>\n  );\n};",
        "invoking_code_segment": "<Jumbotron\n  icon={<IconScale />}\n  title='Free and open source'\n  description='This package is released under the MIT license, you can use titap-extension-resizable-image in any project'\n/>\n<Jumbotron\n  icon={<IconLifebuoy />}\n  title='TypeScript based'\n  description='Built with TypeScript, ensuring a smooth and type-safe development experience'\n/>\n<Jumbotron\n  icon={<IconFlame />}\n  title='Flexible'\n  description='Offers flexibility with customizable styles, interactive context menus and popovers, adapting to your unique development needs'\n/>",
        "new_file_code_segment": "const AdditionalFeature = ({ icon, title, description }: Props) => {\n  return (\n    <div className={classes.root}>\n      <ThemeIcon\n        size='xl'\n        radius='md'\n        gradient={{ from: 'blue', to: 'cyan', deg: 90 }}\n      >\n        {icon}\n      </ThemeIcon>\n      <div>\n        <Text className={classes.title}>{title}</Text>\n        <Text className={classes.description}>{description}</Text>\n      </div>\n    </div>\n  );\n};",
        "feature_description": "Add an additional feature component to display more information in the Jumbotron.",
        "detailed_feature_description": "The new feature involves creating a new component called AdditionalFeature in a new file (#file 3). This component will be similar to the Jumbotron component but will be used to display additional information. The Jumbotron component in #file 1 will be updated to conditionally render either the Jumbotron or the AdditionalFeature based on a new prop. The Home component in #file 2 will be updated to pass this new prop to the Jumbotron component.",
        "modified_complete_code": {
            "#file 1": "//Modify\nconst Jumbotron = ({ icon, title, description, isAdditionalFeature }: Props & { isAdditionalFeature?: boolean }) => {\n  if (isAdditionalFeature) {\n    return <AdditionalFeature icon={icon} title={title} description={description} />;\n  }\n  return (\n    <div className={classes.root}>\n      <ThemeIcon\n        size='xl'\n        radius='md'\n        gradient={{ from: 'blue', to: 'cyan', deg: 90 }}\n      >\n        {icon}\n      </ThemeIcon>\n      <div>\n        <Text className={classes.title}>{title}</Text>\n        <Text className={classes.description}>{description}</Text>\n      </div>\n    </div>\n  );\n};",
            "#file 2": "//Modify\n<Jumbotron\n  icon={<IconScale />}\n  title='Free and open source'\n  description='This package is released under the MIT license, you can use titap-extension-resizable-image in any project'\n  isAdditionalFeature={false}\n/>\n<Jumbotron\n  icon={<IconLifebuoy />}\n  title='TypeScript based'\n  description='Built with TypeScript, ensuring a smooth and type-safe development experience'\n  isAdditionalFeature={false}\n/>\n<Jumbotron\n  icon={<IconFlame />}\n  title='Flexible'\n  description='Offers flexibility with customizable styles, interactive context menus and popovers, adapting to your unique development needs'\n  isAdditionalFeature={false}\n/>",
            "#file 3": "//New\nconst AdditionalFeature = ({ icon, title, description }: Props) => {\n  return (\n    <div className={classes.root}>\n      <ThemeIcon\n        size='xl'\n        radius='md'\n        gradient={{ from: 'blue', to: 'cyan', deg: 90 }}\n      >\n        {icon}\n      </ThemeIcon>\n      <div>\n        <Text className={classes.title}>{title}</Text>\n        <Text className={classes.description}>{description}</Text>\n      </div>\n    </div>\n  );\n};"
        }
    },
    {
        "repo": "fastify-multer",
        "content": "'fastify-multer/test/_util.ts'\n:import fs from 'fs'\nimport path from 'path'\nimport stream from 'stream'\nimport onFinished from 'on-finished'\n\nexport function file(name: string) {\n  return fs.createReadStream(path.join(__dirname, 'files', name))\n}\n\nexport function fileSize(p: string) {\n  return fs.statSync(p).size\n}\n\nexport function submitForm(multer: any, form: any, cb: any) {\n  form.getLength(function(err: Error, length: number) {\n    if (err) {\n      return cb(err)\n    }\n\n    const req = new stream.PassThrough() as stream.PassThrough & { complete: boolean; headers: any }\n\n    req.complete = false\n    form.once('end', function() {\n      req.complete = true\n    })\n\n    form.pipe(req)\n    req.headers = {\n      'content-type': 'multipart/form-data; boundary=' + form.getBoundary(),\n      'content-length': length,\n    }\n\n    const request = { raw: req }\n    multer(request, null, function(error: Error) {\n      onFinished(req as any, function() {\n        cb(error, request)\n      })\n    })\n  })\n}\n\n'fastify-multer/test/file-ordering.ts'\n:import assert from 'assert'\n\nimport { file, submitForm } from './_util'\nimport multer from '../lib'\nimport FormData from 'form-data'\n\ndescribe('File ordering', function() {\n  it('should present files in same order as they came', function(done) {\n    const storage = multer.memoryStorage()\n    const upload = multer({ storage: storage })\n    const parser = upload.array('themFiles', 2)\n\n    let i = 0\n    const calls: any[] = [{}, {}]\n    let pending = 2\n    const _handleFile = storage._handleFile\n    storage._handleFile = function(req, f, cb) {\n      const id = i++\n\n      _handleFile.call(this, req, f, function(err, info) {\n        if (err) {\n          return cb(err)\n        }\n\n        calls[id].cb = cb\n        calls[id].info = info\n\n        if (--pending === 0) {\n          calls[1].cb(null, calls[1].info)\n          calls[0].cb(null, calls[0].info)\n        }\n      })\n    }\n\n    const form = new FormData()\n\n    form.append('themFiles', file('small0.dat'))\n    form.append('themFiles', file('small1.dat'))\n\n    submitForm(parser, form, function(err, req) {\n      assert.ifError(err)\n      assert.equal(req.files.length, 2)\n      assert.equal(req.files[0].originalname, 'small0.dat')\n      assert.equal(req.files[1].originalname, 'small1.dat')\n      done()\n    })\n  })\n})\n\n",
        "called_code_segment": "storage._handleFile = function(req, f, cb) {\n  const id = i++\n\n  _handleFile.call(this, req, f, function(err, info) {\n    if (err) {\n      return cb(err)\n    }\n\n    calls[id].cb = cb\n    calls[id].info = info\n\n    if (--pending === 0) {\n      calls[1].cb(null, calls[1].info)\n      calls[0].cb(null, calls[0].info)\n    }\n  })\n}",
        "invoking_code_segment": "submitForm(parser, form, function(err, req) {\n  assert.ifError(err)\n  assert.equal(req.files.length, 2)\n  assert.equal(req.files[0].originalname, 'small0.dat')\n  assert.equal(req.files[1].originalname, 'small1.dat')\n  done()\n})",
        "new_file_code_segment": "export function logFileDetails(fileInfo) {\n  console.log(`File Name: ${fileInfo.originalname}, Size: ${fileInfo.size} bytes`)\n}",
        "feature_description": "Add logging for file details during file handling.",
        "detailed_feature_description": "The new feature introduces logging for file details during the file handling process. This is achieved by creating a new function `logFileDetails` in `#file 3` that logs the file name and size. The `storage._handleFile` function in `#file 1` is modified to call this logging function after handling each file. The `submitForm` function in `#file 2` remains unchanged as it does not directly interact with the file handling logic.",
        "modified_complete_code": {
            "#file 1": "import { logFileDetails } from './file3'\n\n#Modify storage._handleFile = function(req, f, cb) {\n  const id = i++\n\n  _handleFile.call(this, req, f, function(err, info) {\n    if (err) {\n      return cb(err)\n    }\n\n    calls[id].cb = cb\n    calls[id].info = info\n\n    if (--pending === 0) {\n      calls[1].cb(null, calls[1].info)\n      calls[0].cb(null, calls[0].info)\n    }\n\n    #New logFileDetails(info)\n  })\n}",
            "#file 2": "import assert from 'assert'\nimport { file, submitForm } from './_util'\nimport multer from '../lib'\nimport FormData from 'form-data'\n\ndescribe('File ordering', function() {\n  it('should present files in same order as they came', function(done) {\n    const storage = multer.memoryStorage()\n    const upload = multer({ storage: storage })\n    const parser = upload.array('themFiles', 2)\n\n    let i = 0\n    const calls = [{}, {}]\n    let pending = 2\n    const _handleFile = storage._handleFile\n    storage._handleFile = function(req, f, cb) {\n      const id = i++\n\n      _handleFile.call(this, req, f, function(err, info) {\n        if (err) {\n          return cb(err)\n        }\n\n        calls[id].cb = cb\n        calls[id].info = info\n\n        if (--pending === 0) {\n          calls[1].cb(null, calls[1].info)\n          calls[0].cb(null, calls[0].info)\n        }\n      })\n    }\n\n    const form = new FormData()\n\n    form.append('themFiles', file('small0.dat'))\n    form.append('themFiles', file('small1.dat'))\n\n    submitForm(parser, form, function(err, req) {\n      assert.ifError(err)\n      assert.equal(req.files.length, 2)\n      assert.equal(req.files[0].originalname, 'small0.dat')\n      assert.equal(req.files[1].originalname, 'small1.dat')\n      done()\n    })\n  })\n})",
            "#file 3": "export function logFileDetails(fileInfo) {\n  console.log(`File Name: ${fileInfo.originalname}, Size: ${fileInfo.size} bytes`)\n}"
        }
    },
    {
        "repo": "toy-bundler",
        "content": "'toy-bundler/example/foo.ts'\n:export const foo = 'foo';\n\n'toy-bundler/example/index.tsx'\n:import { foo } from './foo';\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction App() {\n  return <div>Hello {foo}</div>;\n}\n\nReactDOM.createRoot(document.getElementById('root')!).render(<App />);\n\n",
        "called_code_segment": "export const foo = 'foo';",
        "invoking_code_segment": "function App() {\n  return <div>Hello {foo}</div>;\n}",
        "new_file_code_segment": "export const bar = 'bar';\nexport const getGreeting = (name) => `Hello ${name}`;",
        "feature_description": "Add a new greeting message feature that includes a dynamic greeting based on a name parameter.",
        "detailed_feature_description": "The new feature introduces a dynamic greeting function in a new file (#file 3). This function takes a name as a parameter and returns a greeting message. The existing 'foo' constant in #file 1 is updated to use this new function. The App component in #file 2 is modified to display the dynamic greeting message instead of the static 'foo' value.",
        "modified_complete_code": {
            "#file 1": "import { getGreeting } from './greeting'; #New\n\nexport const foo = getGreeting('foo'); #Modify",
            "#file 2": "import { foo } from './foo';\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\n\nfunction App() {\n  return <div>{foo}</div>; #Modify\n}\n\nReactDOM.createRoot(document.getElementById('root')!).render(<App />);",
            "#file 3": "export const bar = 'bar';\nexport const getGreeting = (name) => `Hello ${name}`;"
        }
    },
    {
        "repo": "file-input-accessor",
        "content": "'file-input-accessor/src/app/app.module.ts'\n:import {NgModule} from '@angular/core';\nimport {BrowserModule} from '@angular/platform-browser';\nimport {FileInputAccessorModule} from 'file-input-accessor';\n\nimport {AppComponent} from './app.component';\nimport {FileFormComponent} from './components/file-form/file-form.component';\n\n@NgModule({\n    declarations: [\n        AppComponent,\n        FileFormComponent\n    ],\n    imports: [\n        BrowserModule,\n        FileInputAccessorModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n\n'file-input-accessor/src/main.ts'\n:import {enableProdMode} from '@angular/core';\nimport {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n\nimport {AppModule} from './app/app.module';\nimport {environment} from './environments/environment';\n\nif (environment.production) {\n    enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n    .catch(err => console.log(err));\n\n",
        "called_code_segment": "@NgModule({\n    declarations: [\n        AppComponent,\n        FileFormComponent\n    ],\n    imports: [\n        BrowserModule,\n        FileInputAccessorModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule {\n}",
        "invoking_code_segment": "platformBrowserDynamic().bootstrapModule(AppModule)\n    .catch(err => console.log(err));",
        "new_file_code_segment": "export function initializeApp(appConfigService: AppConfigService) {\n    return () => appConfigService.load();\n}\n\n@NgModule({\n    providers: [\n        AppConfigService,\n        {\n            provide: APP_INITIALIZER,\n            useFactory: initializeApp,\n            deps: [AppConfigService],\n            multi: true\n        }\n    ]\n})\nexport class AppConfigModule {\n}",
        "feature_description": "Add an initialization feature to load configuration settings before the app starts.",
        "detailed_feature_description": "The new feature involves adding an initialization step to load configuration settings before the Angular application starts. This is achieved by creating a new file (`#file 3`) that defines an `AppConfigModule` with an `APP_INITIALIZER` provider. The `AppConfigService` is responsible for loading the configuration. The `AppModule` is updated to import this new module, ensuring that the configuration is loaded before the app bootstraps.",
        "modified_complete_code": {
            "#file 1": "//Modify\n@NgModule({\n    declarations: [\n        AppComponent,\n        FileFormComponent\n    ],\n    imports: [\n        BrowserModule,\n        FileInputAccessorModule,\n        //New\n        AppConfigModule\n    ],\n    providers: [],\n    bootstrap: [AppComponent]\n})\nexport class AppModule {\n}",
            "#file 2": "//Modify\nplatformBrowserDynamic().bootstrapModule(AppModule)\n    .catch(err => console.log(err));",
            "#file 3": "import {NgModule} from '@angular/core';\nimport {APP_INITIALIZER} from '@angular/core';\nimport {AppConfigService} from './app-config.service';\n\nexport function initializeApp(appConfigService: AppConfigService) {\n    return () => appConfigService.load();\n}\n\n@NgModule({\n    providers: [\n        AppConfigService,\n        {\n            provide: APP_INITIALIZER,\n            useFactory: initializeApp,\n            deps: [AppConfigService],\n            multi: true\n        }\n    ]\n})\nexport class AppConfigModule {\n}"
        }
    },
    {
        "repo": "typescript-expo-apollo-boilerplate",
        "content": "'typescript-expo-apollo-boilerplate/src/App.tsx'\n:import React, { useState } from 'react';\nimport {\n  Platform,\n  StatusBar,\n  StyleSheet,\n  View,\n} from 'react-native';\n\nimport { AppLoading } from 'expo';\nimport { Asset } from 'expo-asset';\nimport * as Font from 'expo-font';\n\nimport {\n  ApolloClient,\n  ApolloProvider,\n  InMemoryCache,\n  // HttpLink,\n  ApolloLink,\n} from '@apollo/client';\n\nimport { NavigationNativeContainer } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\n\nimport HomeScreen from './screens/HomeScreen';\nimport AboutScreen from './screens/AboutScreen';\n\nimport { mockedLink } from './mock';\n\nconst client = new ApolloClient({\n  cache: new InMemoryCache(),\n  link: mockedLink as unknown as ApolloLink, // new HttpLink('...'),\n});\n\nconst Stack = createStackNavigator();\n\nconst styles = StyleSheet.create({\n  container: {\n    backgroundColor: '#fff',\n    flex: 1,\n  },\n});\n\ntype Props = {\n  skipLoadingScreen: boolean;\n};\n\nconst App: React.FC<Props> = ({ skipLoadingScreen }) => {\n  const [isLoadingComplete, setLoadingComplete] = useState(false);\n\n  const loadResourcesAsync = async () => {\n    await Promise.all([\n      Asset.loadAsync([\n        // ...\n      ]),\n      Font.loadAsync({\n        // ...\n      }),\n    ]);\n  };\n\n  const handleLoadingError = () => {\n    // ...\n  };\n\n  const handleFinishLoading = () => {\n    setLoadingComplete(true);\n  };\n\n  if (!isLoadingComplete && !skipLoadingScreen) {\n    return (\n      <AppLoading\n        startAsync={loadResourcesAsync}\n        onError={handleLoadingError}\n        onFinish={handleFinishLoading}\n      />\n    );\n  }\n  return (\n    <ApolloProvider client={client}>\n      <NavigationNativeContainer>\n        <View style={styles.container}>\n          {Platform.OS === 'ios' && <StatusBar barStyle=\"default\" />}\n          <Stack.Navigator>\n            <Stack.Screen name=\"Home\" component={HomeScreen} />\n            <Stack.Screen name=\"About\" component={AboutScreen} />\n          </Stack.Navigator>\n        </View>\n      </NavigationNativeContainer>\n    </ApolloProvider>\n  );\n};\n\nexport default App;\n\n'typescript-expo-apollo-boilerplate/App.ts'\n:import App from './src/App';\n\nexport default App;\n\n",
        "called_code_segment": "const App: React.FC<Props> = ({ skipLoadingScreen }) => { ... }",
        "invoking_code_segment": "export default App;",
        "new_file_code_segment": "const fetchUserData = async () => { ... };",
        "feature_description": "Add a feature to fetch user data during the loading screen.",
        "detailed_feature_description": "The new feature involves fetching user data from an API during the loading screen. This data will be stored in the Apollo Client cache. A new function `fetchUserData` is created in a new file (`#file 3`). This function is invoked in `#file 1` during the loading process. The fetched data is then used in the `HomeScreen` component in `#file 2`.",
        "modified_complete_code": {
            "#file 1": "src/App.tsx",
            "code": "export const fetchUserData = async () => {\n  try {\n    const response = await fetch('https://api.example.com/userdata');\n    const data = await response.json();\n    // Store data in Apollo Client cache or state\n  } catch (error) {\n    console.error('Failed to fetch user data:', error);\n  }\n};",
            "#file 2": "App.ts",
            "#file 3": "src/utils/fetchUserData.ts"
        }
    },
    {
        "repo": "gitsub",
        "content": "'gitsub/src/App.tsx'\n:import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nimport Header from './containers/Header/Header';\nimport Footer from './containers/Footer/Footer';\nimport Menu from './containers/Menu/Menu';\nimport Unsubscribe from './containers/Unsubscribe/Unsubscribe';\nimport Subscribe from './containers/Subscribe/Subscribe';\nimport Followers from './containers/Followers/Followers';\nimport Alert from './containers/Alert/Alert';\n\nimport { SUBSCRIBE, UNSUBSCRIBE, FOLLOWERS, ROOT } from './utils/routes';\n\nimport s from './App.module.css';\n\nconst App = () => {\n  return (\n    <div className={s.app}>\n      <div className={s.container}>\n        <Router>\n          <Header />\n          <div className={s.page}>\n            <Menu />\n            <div className={s.content}>\n              <Switch>\n                <Route path={UNSUBSCRIBE} component={Unsubscribe} />\n                <Route path={FOLLOWERS} component={Followers} />\n                <Route path={SUBSCRIBE} component={Subscribe} />\n                <Route exact path={ROOT} component={Subscribe} />\n              </Switch>\n            </div>\n          </div>\n          <Alert />\n        </Router>\n      </div>\n      <Footer />\n    </div>\n  );\n};\n\nexport default App;\n\n'gitsub/src/App.test.ts'\n:import React from 'react';\nimport { render } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  const { getByText } = render(<App />);\n  const linkElement = getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n\n",
        "called_code_segment": "const App = () => {\n  return (\n    <div className={s.app}>\n      <div className={s.container}>\n        <Router>\n          <Header />\n          <div className={s.page}>\n            <Menu />\n            <div className={s.content}>\n              <Switch>\n                <Route path={UNSUBSCRIBE} component={Unsubscribe} />\n                <Route path={FOLLOWERS} component={Followers} />\n                <Route path={SUBSCRIBE} component={Subscribe} />\n                <Route exact path={ROOT} component={Subscribe} />\n              </Switch>\n            </div>\n          </div>\n          <Alert />\n        </Router>\n      </div>\n      <Footer />\n    </div>\n  );\n};",
        "invoking_code_segment": "test('renders learn react link', () => {\n  const { getByText } = render(<App />);\n  const linkElement = getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});",
        "new_file_code_segment": "const NewFeature = () => {\n  return (\n    <div>\n      <p>This is a new feature!</p>\n    </div>\n  );\n};\n\nexport default NewFeature;",
        "feature_description": "Add a new feature component to the App.",
        "detailed_feature_description": "A new feature component named 'NewFeature' is added to the App. This component will be displayed on the root route. The new component is implemented in a new file (#file 3) and is integrated into the existing App component in #file 1. The test in #file 2 is updated to ensure compatibility with the new feature.",
        "modified_complete_code": {
            "#file 1": "import React from 'react';\nimport { BrowserRouter as Router, Switch, Route } from 'react-router-dom';\n\nimport Header from './containers/Header/Header';\nimport Footer from './containers/Footer/Footer';\nimport Menu from './containers/Menu/Menu';\nimport Unsubscribe from './containers/Unsubscribe/Unsubscribe';\nimport Subscribe from './containers/Subscribe/Subscribe';\nimport Followers from './containers/Followers/Followers';\nimport Alert from './containers/Alert/Alert';\nimport NewFeature from './NewFeature'; #New\n\nimport { SUBSCRIBE, UNSUBSCRIBE, FOLLOWERS, ROOT } from './utils/routes';\n\nimport s from './App.module.css';\n\nconst App = () => {\n  return (\n    <div className={s.app}>\n      <div className={s.container}>\n        <Router>\n          <Header />\n          <div className={s.page}>\n            <Menu />\n            <div className={s.content}>\n              <Switch>\n                <Route path={UNSUBSCRIBE} component={Unsubscribe} />\n                <Route path={FOLLOWERS} component={Followers} />\n                <Route path={SUBSCRIBE} component={Subscribe} />\n                <Route exact path={ROOT} component={NewFeature} /> #Modify\n              </Switch>\n            </div>\n          </div>\n          <Alert />\n        </Router>\n      </div>\n      <Footer />\n    </div>\n  );\n};\n\nexport default App;",
            "#file 2": "import React from 'react';\nimport { render } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  const { getByText } = render(<App />);\n  const linkElement = getByText(/This is a new feature!/i); #Modify\n  expect(linkElement).toBeInTheDocument();\n});",
            "#file 3": "import React from 'react';\n\nconst NewFeature = () => {\n  return (\n    <div>\n      <p>This is a new feature!</p>\n    </div>\n  );\n};\n\nexport default NewFeature;"
        }
    },
    {
        "repo": "vscode-diff",
        "content": "'vscode-diff/src/@types/diffs.ts'\n://\tImports ____________________________________________________________________\n\nimport * as fs from 'fs';\n\nimport { MODIFIED } from '../services/@l13/buffers';\n\n//\tVariables __________________________________________________________________\n\n\n\n//\tInitialize _________________________________________________________________\n\n\n\n//\tExports ____________________________________________________________________\n\nexport type DiffFileTypes = 'error' | 'file' | 'folder' | 'symlink' | 'unknown';\n\nexport type Diff = {\n\tid: string,\n\tstatus: DiffStatus,\n\ttype: DiffFileTypes | 'mixed',\n\tignoredEOL: MODIFIED,\n\tignoredBOM: MODIFIED,\n\tignoredWhitespace: MODIFIED,\n\tfileA: null | DiffFile,\n\tfileB: null | DiffFile,\n};\n\nexport type DiffFile = {\n\troot: string,\n\trelative: string,\n\tfsPath: string,\n\tstat?: fs.Stats,\n\tpath: string,\n\tname: string,\n\tbasename: string,\n\tdirname: string,\n\textname: string,\n\tignore: boolean,\n\ttype: DiffFileTypes,\n};\n\nexport type DiffSettings = {\n\tabortOnError: boolean,\n\texcludes: string[],\n\tignoreContents: boolean,\n\tignoreEndOfLine: boolean,\n\tignoreTrimWhitespace: boolean,\n\tignoreByteOrderMark: boolean,\n\tmaxFileSize: number,\n\tuseCaseSensitive: boolean,\n};\n\nexport type DiffStatus = 'conflicting' | 'deleted' | 'ignored' | 'modified' | 'unchanged' | 'untracked';\n\n//\tFunctions __________________________________________________________________\n\n\n'vscode-diff/src/@types/messages.ts'\n://\tImports ____________________________________________________________________\n\nimport type { JSONValue, Uri } from '../types';\n\nimport type { Diff, DiffFile, DiffSettings } from './diffs';\n\n//\tVariables __________________________________________________________________\n\n\n\n//\tInitialize _________________________________________________________________\n\n\n\n//\tExports ____________________________________________________________________\n\nexport type DeletedFilesMessage = {\n\tfiles: string[],\n};\n\nexport type DiffCopyMessage = {\n\tdiffs: Diff[],\n\tmulti: boolean,\n\tpathA: string,\n\tpathB: string,\n};\n\nexport type DiffDialogMessage = {\n\tfsPath: string,\n};\n\nexport type DiffFavoriteMessage = {\n\tpathA: string,\n\tpathB: string,\n};\n\nexport type DiffGoToMessage = {\n\tfiles: DiffFile[],\n\topenToSide: boolean,\n};\n\nexport type DiffInitMessage = {\n\tpathA: string,\n\tpathB: string,\n};\n\nexport type DiffInitViewMessage = {\n\tpanel: DiffPanelStateMessage,\n\turis: Uri[],\n\tworkspaces: string[],\n\tcompare: boolean,\n};\n\nexport type DiffMenuMessage = {\n\thistory: string[],\n\tworkspaces: string[],\n};\n\nexport type DiffMultiCopyMessage = {\n\tids: string[],\n\tpathA: string,\n\tpathB: string,\n};\n\nexport type DiffOpenMessage = {\n\tdiffs: Diff[],\n\tpathA: string,\n\tpathB: string,\n\topenToSide: boolean,\n};\n\nexport type DiffPreviewMessage = {\n\tdiff: Diff,\n\tpathA: string,\n\tpathB: string,\n};\n\nexport type DiffPanelSettings = {\n\tenablePreview: boolean,\n};\n\nexport type DiffPanelStateMessage = {\n\tviews: {\n\t\tunchangedChecked: boolean,\n\t\tdeletedChecked: boolean,\n\t\tmodifiedChecked: boolean,\n\t\tuntrackedChecked: boolean,\n\t\tignoredChecked: boolean,\n\t},\n\tsearch: {\n\t\tsearchterm: string,\n\t\tuseRegExp: boolean,\n\t\tuseCaseSensitive: boolean,\n\t\tuseFiles: boolean,\n\t\tuseFolders: boolean,\n\t\tuseSymlinks: boolean,\n\t\tuseConflicts: boolean,\n\t\tuseOthers: boolean,\n\t},\n};\n\nexport type DiffResultMessage = {\n\tdiffs: Diff[],\n\tpathA: string,\n\tpathB: string,\n\tsettings: DiffSettings,\n};\n\nexport type DiffUpdatePathsMessage = {\n\turis: Uri[],\n\tcompare: boolean,\n};\n\nexport type Message = {\n\tcommand: string,\n\tdata: JSONValue,\n};\n\nexport type MessageListener = (...args: any[]) => void;\n\nexport type UpdatedFilesMessage = {\n\tfiles: string[],\n};\n\n//\tFunctions __________________________________________________________________\n\n\n",
        "called_code_segment": "export type Diff = {\n\tid: string,\n\tstatus: DiffStatus,\n\ttype: DiffFileTypes | 'mixed',\n\tignoredEOL: MODIFIED,\n\tignoredBOM: MODIFIED,\n\tignoredWhitespace: MODIFIED,\n\tfileA: null | DiffFile,\n\tfileB: null | DiffFile,\n};",
        "invoking_code_segment": "export type DiffResultMessage = {\n\tdiffs: Diff[],\n\tpathA: string,\n\tpathB: string,\n\tsettings: DiffSettings,\n};",
        "new_file_code_segment": "export type DiffExtended = Diff & {\n\textendedInfo: string,\n};",
        "feature_description": "Extend the Diff type to include additional information.",
        "detailed_feature_description": "The new feature extends the existing Diff type by adding an 'extendedInfo' field. This field will store additional information about the diff, which can be used for more detailed analysis or display. The new type, DiffExtended, is defined in a new file (#file 3) and is used in both #file 1 and #file 2 to maintain compatibility and enhance functionality.",
        "modified_complete_code": {
            "#file 1": "//Modify for modified parts and #New for newly added parts\n\n#Modify\nexport type Diff = {\n\tid: string,\n\tstatus: DiffStatus,\n\ttype: DiffFileTypes | 'mixed',\n\tignoredEOL: MODIFIED,\n\tignoredBOM: MODIFIED,\n\tignoredWhitespace: MODIFIED,\n\tfileA: null | DiffFile,\n\tfileB: null | DiffFile,\n\t#New extendedInfo: string,\n};",
            "#file 2": "//Modify for modified parts and #New for newly added parts\n\n#Modify\nexport type DiffResultMessage = {\n\tdiffs: DiffExtended[],\n\tpathA: string,\n\tpathB: string,\n\tsettings: DiffSettings,\n};",
            "#file 3": "//New for newly added parts\n\nexport type DiffExtended = Diff & {\n\textendedInfo: string,\n};"
        }
    },
    {
        "repo": "vscode-neuro-viewer",
        "content": "'vscode-neuro-viewer/webview/nifti/histogram.ts'\n:import { DATA_TYPE_RANGE } from './constants';\nimport { NiftiImage } from './format';\nimport { scale, rgbToHex, ColorPalette } from '../utils';\nimport { EventEmitter } from '../events';\n\ntype SelectEvent = { from: number, to: number }\ntype PaletteEvent = { palette: ColorPalette; };\n\ntype EventType = \"select\" | \"palette\";\ntype EventArgs = SelectEvent | PaletteEvent;\ntype EventCallback<T> = (data: T) => void;\n\nexport class HistogramView extends EventEmitter<EventType, EventArgs> {\n\n  el: {\n    root: HTMLElement,\n    bins?: HTMLElement,\n    selection?: HTMLElement,\n    currentSelection?: HTMLElement,\n    thumbs?: HTMLElement,\n  };\n\n  image: NiftiImage;\n  bins: number;\n  binsRange: [number, number] = [-1, -1];\n  binsCount: number[] = [];\n  palette: ColorPalette;\n  highlightPalette: ColorPalette;\n\n  constructor(el: HTMLElement, image: NiftiImage, bins: number, palette: ColorPalette, highlightPalette: ColorPalette) {\n    super();\n    this.el = {\n      root: el,\n    };\n\n    this.image = image;\n    this.bins = ~~bins;\n    if (this.bins % 2 === 0) {\n      this.bins++;\n    }\n    this.palette = palette;\n    this.highlightPalette = highlightPalette;\n  }\n\n  getPalette() {\n    return this.palette;\n  }\n\n  setPalette(palette: ColorPalette) {\n    this.palette = palette;\n  }\n\n  getHighlightPalette() {\n    return this.highlightPalette;\n  }\n\n  setHighlightPalette(palette: ColorPalette) {\n    this.highlightPalette = palette;\n  }\n\n  on(event: \"select\", callback: EventCallback<SelectEvent>): void;\n  on(event: \"palette\", callback: EventCallback<PaletteEvent>): void;\n  on(event: EventType, callback: any): void { // eslint-disable-line @typescript-eslint/no-explicit-any\n    super.on(event, callback);\n  }\n\n  dispatch(event: \"select\", data: SelectEvent): void;\n  dispatch(event: \"palette\", data: PaletteEvent): void;\n  dispatch(event: EventType, data: EventArgs) {\n    super.dispatch(event, data);\n  }\n\n  renderThumbs() {\n    if (this.el.thumbs) {\n      this.el.thumbs.remove();\n    }\n\n    this.el.thumbs = document.createElement('div');\n    this.el.thumbs.classList.add('thumbs');\n\n    const symmetric = this.binsRange[0] === 0;\n    const binPercent = 100 / (this.bins + 2);\n    this.palette.getIntervals().forEach((interval: number) => {\n      if (!this.el.thumbs) {\n        return;\n      }\n\n      const thumb = document.createElement('div');\n      thumb.classList.add('thumb');\n      thumb.style.setProperty('--main-color', rgbToHex(this.palette.getIntervalColor(interval)));\n      thumb.setAttribute('data-index', interval.toString());\n\n      const i = symmetric ? interval : (interval + 1) / 2;\n      const bins = (1 - i) * this.bins;\n      thumb.style.top = `${(bins + 1) * binPercent}%`;\n\n      let containerRect = this.el.thumbs.getBoundingClientRect();\n      let thumbRect = thumb.getBoundingClientRect();\n\n      const mousemove = (e: MouseEvent) => {\n        const thumbY = (e.clientY - containerRect.top - thumbRect.height / 2);\n        let y = Math.max(0, Math.min(1, thumbY / containerRect.height));\n\n        const interval = symmetric ? 1 - y : (y * -2) + 1;\n        const oldInterval = +(thumb.getAttribute('data-index') || '0');\n        let newInterval = interval;\n        [newInterval, this.palette] = this.palette.moveInterval(oldInterval, interval);\n        if (newInterval !== interval) {\n          y = symmetric ? 1 - newInterval : (newInterval - 1) / -2;\n        }\n\n        thumb.setAttribute('data-index', newInterval.toString());\n        thumb.style.top = `${y * 100}%`;\n        this.dispatch('palette', { palette: this.palette });\n        this._updateBackground();\n      };\n  \n      const mouseup = (e: MouseEvent) => {\n        document.removeEventListener('mousemove', mousemove);\n        document.removeEventListener('mouseup', mouseup);\n        mousemove(e);\n      };\n  \n      const mousedown = () => {\n        if (!this.el.thumbs) {\n          return;\n        }\n        containerRect = this.el.thumbs.getBoundingClientRect();\n        thumbRect = thumb.getBoundingClientRect();\n        document.addEventListener('mousemove', mousemove);\n        document.addEventListener('mouseup', mouseup);\n      };\n  \n      thumb.addEventListener('mousedown', mousedown);\n\n      this.el.thumbs.appendChild(thumb);\n    });\n    this.el.root.appendChild(this.el.thumbs);\n  }\n\n  renderSelector() {\n    if (this.el.selection) {\n      this.el.selection.remove();\n    }\n    const selectionEl = this.el.selection = document.createElement('div');\n    this.el.selection.classList.add('selection');\n    this.el.root.appendChild(this.el.selection);\n\n    let rect: DOMRect | null = null;\n    let clicked = false, moved = false;\n    let rangeStart = -1, rangeEnd = -1, from = -1, to = -1;\n\n    const mousemove = (e: MouseEvent) => {\n      if (!rect) {\n        return;\n      }\n      const y = e.clientY - rect.top;\n      rangeEnd = y / rect.height;\n\n      from = 1 - Math.min(1, rangeEnd < rangeStart ? rangeStart : rangeEnd);\n      to = 1 - Math.max(0, rangeEnd > rangeStart ? rangeStart : rangeEnd);\n\n      if (this.el.currentSelection) {\n        this.el.currentSelection.style.top = `${(1 - to) * 100}%`;\n        this.el.currentSelection.style.bottom = `${from * 100}%`;\n      }\n\n      if (from != to) {\n        this.dispatchRange(from, to);\n      }\n      moved = true;\n    };\n\n    const mouseup = (e: MouseEvent) => {\n      document.removeEventListener('mousemove', mousemove);\n      document.removeEventListener('mouseup', mouseup);\n\n      if (from == to || !moved) {\n        this.el.currentSelection?.remove();\n        delete this.el.currentSelection;\n        this.dispatchRange(-1, -1);\n      }\n\n      if (!clicked)\n        return;\n      clicked = false;\n      mousemove(e);\n    };\n\n    const mousedown = (e: MouseEvent) => {\n      moved = false;\n\n      this.el.currentSelection?.remove();\n      this.el.currentSelection = document.createElement('div');\n      selectionEl.appendChild(this.el.currentSelection);\n      this._updateCurrentSelectionBackground();\n\n      rect = selectionEl.getBoundingClientRect();\n      const y = e.clientY - rect.top;\n      rangeStart = y / rect.height;\n\n      clicked = true;\n\n      document.addEventListener('mousemove', mousemove);\n      document.addEventListener('mouseup', mouseup);\n    };\n\n    selectionEl.addEventListener('mousedown', mousedown);\n  }\n\n  // Creates n+2 bins, where 2 are used for the borders\n  binarize(): [[number, number], number[]] {\n    const binsRange: [number, number] = [\n      this.image.header.values.min < 0 ? -DATA_TYPE_RANGE: 0,\n      DATA_TYPE_RANGE\n    ];\n\n    const valueToBin: { [key: number]: number } = {};\n    let bin = 0;\n    for (let i = binsRange[0]; i <= binsRange[1]; i++) {\n      bin = ~~scale(\n        i,\n        [binsRange[0], binsRange[1]],\n        [0, this.bins - 1]\n      );\n      valueToBin[i] = bin;\n    }\n\n    let count: number[] = Array(this.bins + 2).fill(0);\n    for (const v of this.image.data) {\n      count[valueToBin[v] + 1] = (count[valueToBin[v] + 1] || 0) + 1;\n    }\n\n    // Remove count from zeroed voxels for max\n    const zeroed = count[valueToBin[0] + 1] || 0;\n    count[valueToBin[0] + 1] = 0;\n\n    const max = Math.max.apply(null, count);\n    count = count.map((c) => c / max);\n\n    // Reintroduce the zero count\n    count[valueToBin[0] + 1] = Math.min(zeroed / max, 1);\n    return [binsRange, count];\n  }\n\n  renderBins() {\n    if (this.el.bins) {\n      this.el.bins.remove();\n    }\n    this.el.bins = document.createElement('div');\n    this.el.bins.classList.add('bins');\n    this.el.root.appendChild(this.el.bins);\n    let html = '';\n    this.binsCount.reverse().forEach((v, i) => {\n      const bin = this.bins - i - 1;\n      html += `\n        <div\n          data-bin=\"${bin}\"\n          style=\"width: ${(1 - v) * 100}%; ${v > 0 ? \"min-width: 1px;\" : \"\"}\"\n        ></div>`;\n    });\n    this.el.bins.innerHTML = html;\n    this._updateBackground();\n  }\n\n  render() {\n    [this.binsRange, this.binsCount] = this.binarize();\n    this.renderBins();\n    this.renderSelector();\n    this.renderThumbs();\n  }\n\n  update() {\n    if (!this.el.bins) {\n      return;\n    }\n    this._updateBackground();\n    this.renderThumbs();\n  }\n\n  _updateBackground() {\n    if (this.el.bins) \n      this.el.bins.style.background = this.palette.getGradient(0);\n  }\n\n  _updateCurrentSelectionBackground() {\n    if (this.el.currentSelection)\n      this.el.currentSelection.style.background = this.highlightPalette.getGradient(0);\n  }\n\n  dispatchRange(from: number, to: number) {\n    this.dispatch('select', {\n      from: from == -1 ? -1 : ~~scale(\n        from,\n        [0, 1],\n        this.binsRange\n      ),\n      to: to == -1 ? -1 : ~~scale(\n        to,\n        [0, 1],\n        this.binsRange\n      ),\n    });\n  }\n\n}\n\n'vscode-neuro-viewer/webview/nifti/index.ts'\n:import { RenderView, PaletteRenderViewLayer, HighlightRenderViewLayer } from './render';\nimport { InfoView } from './info';\nimport { NavigationView } from './navigation';\nimport { message } from './message';\nimport { NiftiImage } from './format';\nimport { HistogramView } from './histogram';\n\nimport { palettes, PalettesView } from './palettes';\nimport './index.css';\n\nfunction prepareRender(ws: string, uuid: string, image: NiftiImage) {\n\n  const mainEl = document.getElementById('main');\n  const navigationEl = document.getElementById('tools');\n  const palettesEl = document.getElementById('palettes');\n  const thumbnailEl = document.getElementById('thumbnail');\n  const messageEl = document.getElementById('message');\n  const histogramEl = document.getElementById('histogram');\n\n  if (!mainEl || !navigationEl || !palettesEl || !thumbnailEl || !messageEl || !histogramEl) {\n    return;\n  }\n\n  message(messageEl, 'Rendering');\n\n  const symmetric = image.header.values.min >= 0;\n  const palette = symmetric ? palettes.bw : palettes.bbr;\n  const highlightPalette = palettes.highlight;\n\n  const palettesView = new PalettesView(palettesEl, palette);\n\n  const histogramView = new HistogramView(\n    histogramEl,\n    image,\n    120,  // TODO infer from image\n    palette,\n    highlightPalette\n  );\n  const mainLayer = new HighlightRenderViewLayer(palette, highlightPalette);\n  const thumbnailLayer = new PaletteRenderViewLayer(palette);\n\n  histogramView.on('select', ({ from, to }) => {\n    mainLayer.setHighlight([from, to]);\n    mainLayer.update();\n  });\n  histogramView.on('palette', ({ palette }) => {\n    mainLayer.setPalette(palette);\n    mainLayer.update();\n\n    thumbnailLayer.setPalette(palette);\n    thumbnailLayer.update();\n  });\n\n  const navigationView = new NavigationView(\n    navigationEl,\n    image\n  );\n  const thumbnailView = new RenderView(\n    thumbnailEl,\n    image,\n    [thumbnailLayer]\n  );\n  const renderView = new RenderView(\n    mainEl,\n    image,\n    [mainLayer]\n  );\n\n  mainLayer.on('over', ({ position, value }) => {\n    renderView.update(undefined, undefined, position, value);\n  });\n  mainLayer.on('out', () => {\n    renderView.update(undefined, undefined, null, null);\n  });\n  window.addEventListener('wheel', (e) => {\n    let el = e.target as HTMLElement;\n    while (el && el !== document.body && el.parentElement) {\n      if (el.id === 'palettes-popup') {\n        return;\n      }\n      el = el.parentElement;\n    }\n    navigationView.setSliceDelta(Math.sign(e.deltaY));\n  }, false);\n\n  window.addEventListener('resize', () => {\n    renderView.update();\n  });\n\n  navigationView.on('axis', ({ axis }) => {\n    renderView.update(navigationView.getSlice(), axis);\n  });\n  navigationView.on('slice', ({ slice }) => {\n    renderView.update(slice, navigationView.getAxis());\n  });\n  navigationView.on('thumbnailSlice', ({ slice }) => {\n    thumbnailView.update(slice, navigationView.getAxis());\n  });\n\n  palettesView.on('palette', ({ palette }) => {\n    if (symmetric) {\n      palette = palette.toSymmetric();\n    } else {\n      palette = palette.toAsymmetric();\n    }\n\n    palettesView.setPalette(palette);\n    histogramView.setPalette(palette);\n    histogramView.update();\n\n    mainLayer.setPalette(palette);\n    mainLayer.update();\n\n    thumbnailLayer.setPalette(palette);\n    thumbnailLayer.update();\n  });\n\n  palettesView.render();\n  renderView.render();\n  thumbnailView.render();\n  navigationView.render();\n  histogramView.render();\n\n  message(messageEl);\n}\n\nwindow.addEventListener('message', async (e) => {\n  const { type, body } = e.data;\n  switch (type) {\n    case 'init':\n      {\n        const ws = body.ws;\n        const uuid = body.uuid;\n        const header = body.header;\n        let data = body.data;\n\n        const infoEl = document.getElementById('info');\n        if (!infoEl) {\n          return;\n        }\n        const infoView = new InfoView(infoEl, header);\n        infoView.render();\n\n        const messageEl = document.getElementById('message');\n        if (messageEl == null) {\n          return;\n        }\n        \n        message(messageEl, 'Loading');\n        prepareRender(ws, uuid, { header, data });\n      }\n      break;\n  }\n});\n\n",
        "called_code_segment": "class HistogramView extends EventEmitter<EventType, EventArgs> {\n  // ... existing code ...\n  renderThumbs() {\n    // ... existing code ...\n  }\n  // ... existing code ...\n}",
        "invoking_code_segment": "const histogramView = new HistogramView(\n  histogramEl,\n  image,\n  120,  // TODO infer from image\n  palette,\n  highlightPalette\n);\nhistogramView.on('select', ({ from, to }) => {\n  mainLayer.setHighlight([from, to]);\n  mainLayer.update();\n});\nhistogramView.on('palette', ({ palette }) => {\n  mainLayer.setPalette(palette);\n  mainLayer.update();\n\n  thumbnailLayer.setPalette(palette);\n  thumbnailLayer.update();\n});",
        "new_file_code_segment": "export function updateHistogramThumbs(histogramView: HistogramView, newThumbs: HTMLElement[]) {\n  if (histogramView.el.thumbs) {\n    histogramView.el.thumbs.remove();\n  }\n  histogramView.el.thumbs = document.createElement('div');\n  histogramView.el.thumbs.classList.add('thumbs');\n  newThumbs.forEach(thumb => {\n    histogramView.el.thumbs?.appendChild(thumb);\n  });\n  histogramView.el.root.appendChild(histogramView.el.thumbs);\n}",
        "feature_description": "Add a feature to dynamically update the histogram thumbs with new thumbs provided from an external source.",
        "detailed_feature_description": "The new feature allows the histogram thumbs to be updated dynamically with new thumbs provided from an external source. This is achieved by creating a new function `updateHistogramThumbs` in a new file (#file 3) that takes the `HistogramView` instance and an array of new thumbs as arguments. This function replaces the existing thumbs with the new ones. The `HistogramView` class in #file 1 is updated to use this new function when rendering thumbs. The invoking code in #file 2 is also updated to use this new function when necessary.",
        "modified_complete_code": {
            "#file 1": "class HistogramView extends EventEmitter<EventType, EventArgs> {\n  // ... existing code ...\n  renderThumbs() {\n    // ... existing code ...\n    updateHistogramThumbs(this, newThumbs);\n  }\n  // ... existing code ...\n}",
            "#file 2": "import { updateHistogramThumbs } from './file3';\n\nconst histogramView = new HistogramView(\n  histogramEl,\n  image,\n  120,  // TODO infer from image\n  palette,\n  highlightPalette\n);\nhistogramView.on('select', ({ from, to }) => {\n  mainLayer.setHighlight([from, to]);\n  mainLayer.update();\n});\nhistogramView.on('palette', ({ palette }) => {\n  mainLayer.setPalette(palette);\n  mainLayer.update();\n\n  thumbnailLayer.setPalette(palette);\n  thumbnailLayer.update();\n});\n\n// Example of dynamically updating thumbs\nconst newThumbs = [/* new thumbs elements */];\nupdateHistogramThumbs(histogramView, newThumbs);",
            "#file 3": "export function updateHistogramThumbs(histogramView: HistogramView, newThumbs: HTMLElement[]) {\n  if (histogramView.el.thumbs) {\n    histogramView.el.thumbs.remove();\n  }\n  histogramView.el.thumbs = document.createElement('div');\n  histogramView.el.thumbs.classList.add('thumbs');\n  newThumbs.forEach(thumb => {\n    histogramView.el.thumbs?.appendChild(thumb);\n  });\n  histogramView.el.root.appendChild(histogramView.el.thumbs);\n}"
        }
    },
    {
        "repo": "ymock",
        "content": "'ymock/dev/HostApp.tsx'\n:import {\n  Box,\n  Button,\n  Center,\n  Code,\n  Container,\n  Flex,\n  JsonInput,\n  MantineProvider,\n  NavLink,\n  Stack,\n  Title,\n} from \"@mantine/core\";\nimport \"@mantine/core/styles.css\";\nimport { useForm } from \"@mantine/form\";\nimport { IconClick } from \"@tabler/icons-react\";\nimport { HttpHandler, Path } from \"msw\";\nimport { HttpHandlerInfo } from \"msw/lib/core/handlers/HttpHandler\";\nimport { useEffect, useState } from \"react\";\nimport { RenderFnParams } from \"../src/types/ymock\";\n\ntype HandlerProp = {\n  handler?: HttpHandler;\n};\n\ntype FormValues = {\n  url?: Path;\n  method?: HttpHandlerInfo[\"method\"];\n  mode?: string;\n  cache?: string;\n  headers?: Record<string, string>;\n  referrerPolicy?: string;\n  body?: string;\n};\n\nconst CurrentHandler: React.FC<HandlerProp> = ({ handler }) =>\n  handler && (\n    <Title order={4} pb={20}>\n      Invoke {handler.info.header}\n    </Title>\n  );\n\nconst RequestForm: React.FC<\n  HandlerProp & { setResponse: React.Dispatch<any> }\n> = ({ handler, setResponse }) => {\n  const form = useForm<FormValues>({\n    initialValues: {\n      url: handler?.info.path,\n      method: handler?.info.method,\n      // mode: \"no-cors\",\n      // cache: \"no-cache\",\n      headers: {\n        // \"Content-Type\": \"application/json\",\n      },\n      // referrerPolicy: \"no-referrer\",\n      // body: \"\",\n    },\n  });\n\n  useEffect(() => {\n    form.setFieldValue(\"url\", handler?.info.path);\n    form.setFieldValue(\"method\", handler?.info.method);\n  }, [handler]);\n\n  const send = async (values: FormValues) => {\n    try {\n      const { url, ...options } = values;\n      if (!options.method) {\n        throw new Error(\"Method not set\");\n      }\n      if ([\"GET\" as HttpHandlerInfo[\"method\"]].includes(options.method)) {\n        delete options.body;\n        console.log(options);\n      }\n      const response = await fetch(url as string, options as RequestInit);\n      console.log(response);\n      const data = await response.json();\n      setResponse(data);\n    } catch (err) {\n      // @ts-ignore\n      setResponse(err?.message);\n    }\n  };\n\n  const method = handler?.info.method;\n\n  switch (method) {\n    case undefined:\n      return <Box>Select an api on the right</Box>;\n    case \"POST\":\n    case \"PUT\":\n    case \"PATCH\":\n      return (\n        <form style={{ width: \"100%\" }} onSubmit={form.onSubmit(send)}>\n          <Stack>\n            <JsonInput\n              label=\"Body (json)\"\n              placeholder=\"{}\"\n              autosize\n              minRows={10}\n              style={{ width: \"100%\" }}\n              {...form.getInputProps(\"body\")}\n            />\n            <Button type=\"submit\">Send</Button>\n          </Stack>\n        </form>\n      );\n    case \"GET\":\n    case \"DELETE\":\n    default:\n      return (\n        <form style={{ width: \"100%\" }} onSubmit={form.onSubmit(send)}>\n          <Stack>\n            <Button type=\"submit\">Send</Button>\n          </Stack>\n        </form>\n      );\n  }\n};\n\nconst Response: React.FC<any> = ({ data }) => {\n  try {\n    let stringData;\n    switch (typeof data) {\n      case \"string\":\n      case \"boolean\":\n      case \"number\":\n        stringData = data;\n        break;\n      case \"object\":\n        stringData = JSON.stringify(data, null, 2);\n    }\n    return data && <Code>{data.toString()}</Code>;\n  } catch (e) {\n    console.warn(e);\n  }\n};\n\nexport const HostApp: React.FC<RenderFnParams> = ({ worker, handlers }) => {\n  const [currentHandler, setCurrentHandler] = useState<HttpHandler>();\n  const [response, setResponse] = useState<any>();\n\n  const changeHandler = (handler: HttpHandler) => {\n    setCurrentHandler(handler);\n    setResponse(null);\n  };\n\n  return (\n    <MantineProvider>\n      <Container>\n        <Center py={10}>\n          <Title>Host app</Title>\n        </Center>\n        <Flex\n          gap={20}\n          align=\"stretch\"\n          style={{\n            alignContent: \"stretch\",\n          }}\n        >\n          <Box>\n            <Title order={4} pb={10}>\n              Select an api\n            </Title>\n            {handlers.map((api) => (\n              <NavLink\n                key={api.info.header}\n                label={api.info.header}\n                rightSection={<IconClick />}\n                onClick={() => changeHandler(api)}\n              />\n            ))}\n          </Box>\n          <Box style={{ flexGrow: 2 }}>\n            <Container>\n              <CurrentHandler handler={currentHandler} />\n              <RequestForm handler={currentHandler} setResponse={setResponse} />\n              <Response data={response} />\n            </Container>\n          </Box>\n        </Flex>\n      </Container>\n    </MantineProvider>\n  );\n};\n\n'ymock/dev/index.tsx'\n:/**\n * This is a development-only support file, it works as host application for ymock\n */\n\nimport { worker } from \"./mocks/browser\";\nimport { handlers } from \"./mocks/handlers\";\nimport { ymock } from \"../src/main\";\nimport ReactDOM from \"react-dom/client\";\nimport React from \"react\";\nimport { HostApp } from \"./HostApp\";\n\nconst root = document.getElementById(\"root\");\nconst startApp = () =>\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <HostApp {...{ worker, handlers }} />\n    </React.StrictMode>\n  );\n\nworker.start().then(startApp);\nymock.load({ worker, handlers }).addButton();\n// ymock.load({ worker, handlers }).open();\n\n// Start without mocks\n// startApp();\n\n",
        "called_code_segment": "const startApp = () =>\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <HostApp {...{ worker, handlers }} />\n    </React.StrictMode>\n  );",
        "invoking_code_segment": "worker.start().then(startApp);",
        "new_file_code_segment": "export const logAppStart = () => {\n  console.log('HostApp has started rendering.');\n};",
        "feature_description": "Add logging when the HostApp starts rendering.",
        "detailed_feature_description": "The new feature involves adding a logging mechanism that logs a message to the console when the HostApp starts rendering. This is implemented by creating a new function `logAppStart` in a new file (`#file 3`). This function is then invoked in both `#file 1` and `#file 2` to ensure that the logging occurs at the appropriate time.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { logAppStart } from './logAppStart';\n\nconst startApp = () => {\n  logAppStart();\n  ReactDOM.createRoot(root as HTMLElement).render(\n    <React.StrictMode>\n      <HostApp {...{ worker, handlers }} />\n    </React.StrictMode>\n  );\n};",
            "#file 2": "//Modify\nimport { logAppStart } from './logAppStart';\n\nworker.start().then(() => {\n  logAppStart();\n  startApp();\n});",
            "#file 3": "//New\nexport const logAppStart = () => {\n  console.log('HostApp has started rendering.');\n};"
        }
    },
    {
        "repo": "youtube.external.subtitle",
        "content": "'youtube.external.subtitle/src/subtitle.ts'\n:import DIC from './dic';\nimport { CSS } from './init.service';\n\ntype RenderMethod = (element: SubtitleElement, player: any, isFullscreenActive: boolean, text: string, controlsVisible: boolean) => void;\n\nexport interface SubtitleElement extends HTMLDivElement {\n  youtubeExternalSubtitle: Subtitle;\n}\n\nexport interface SubtitleFrame extends HTMLIFrameElement {\n  youtubeExternalSubtitle: Subtitle;\n}\n\ninterface SubtitleEntry {\n  start: number;\n  end: number;\n  text: string;\n}\n\nexport interface State {\n  text: string;\n  isFullscreenActive: boolean;\n  controlsVisible: boolean;\n}\n\ninterface Cache {\n  [propName: number]: SubtitleEntry[];\n}\n\nexport const getCacheName = (seconds: number): number => {\n  return Math.floor(seconds / 10);\n};\n\nexport const getCacheNames = (start: number, end: number): number[] => {\n  const cacheNames = [];\n  const endCacheName = getCacheName(end);\n\n  for (let i = getCacheName(start); i <= endCacheName; i++) {\n    cacheNames.push(i);\n  }\n\n  return cacheNames;\n};\n\nexport const buildCache = (subtitles: SubtitleEntry[]): Cache => {\n  const cache = {};\n\n  for (const subtitle of subtitles) {\n    for (const cacheName of getCacheNames(subtitle.start, subtitle.end)) {\n      if (!cache[cacheName]) {\n        cache[cacheName] = [];\n      }\n\n      cache[cacheName].push(subtitle);\n    }\n  }\n\n  return cache;\n};\n\nexport const getSubtitleFromCache = (seconds: number, builtCache: Cache): SubtitleEntry => {\n  if (!builtCache) {\n    return null;\n  }\n\n  const cache = builtCache[getCacheName(seconds)];\n\n  if (!cache) {\n    return null;\n  }\n\n  for (const subtitle of cache) {\n    if (seconds >= subtitle.start && seconds <= subtitle.end) {\n      return subtitle;\n    }\n  }\n\n  return null;\n};\n\nexport const addQueryStringParameterToUrl = (url: string, qsParameters: any): string => {\n  const hashIndex = url.indexOf('#');\n  let hash = '';\n\n  if (hashIndex !== -1) {\n    hash = url.substr(hashIndex);\n    url = url.substr(0, hashIndex);\n  }\n\n  const qsIndex = url.indexOf('?');\n  let qs = '';\n\n  if (qsIndex !== -1) {\n    qs = url.substr(qsIndex);\n    url = url.substr(0, qsIndex);\n  }\n\n  for (const qsParameterName of Object.keys(qsParameters)) {\n    qs += `${qs === '' ? '?' : '&'}${qsParameterName}=${qsParameters[qsParameterName]}`;\n  }\n\n  return `${url}${qs}${hash}`;\n};\n\nexport const getIframeSrc = (src: string): string => {\n  let newSrc = src;\n\n  if (newSrc.indexOf('enablejsapi=1') === -1) {\n    newSrc = addQueryStringParameterToUrl(newSrc, { enablejsapi: '1' });\n  }\n\n  if (newSrc.indexOf('html5=1') === -1) {\n    newSrc = addQueryStringParameterToUrl(newSrc, { html5: '1' });\n  }\n\n  if (newSrc.indexOf('playsinline=1') === -1) {\n    newSrc = addQueryStringParameterToUrl(newSrc, { playsinline: '1' });\n  }\n\n  if (newSrc.indexOf('fs=') === -1) {\n    newSrc = addQueryStringParameterToUrl(newSrc, { fs: '0' });\n  }\n\n  return newSrc;\n};\n\nexport const createSubtitleElement = (iframe: SubtitleFrame, subtitle: Subtitle): SubtitleElement => {\n  const document = DIC.getDocument();\n\n  const element = document.createElement('div') as SubtitleElement;\n\n  element.youtubeExternalSubtitle = subtitle;\n\n  iframe.parentNode.insertBefore(element, iframe.nextSibling);\n\n  return element;\n};\n\nexport const isStateChanged = (prevState: State, nextState: State): boolean => {\n  for (const propertyName of Object.keys(nextState)) {\n    if (prevState[propertyName] !== nextState[propertyName]) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const renderClassName = (isFullscreenActive: boolean): string => {\n  const classes = [ CSS.CLASS ];\n\n  if (isFullscreenActive !== null) {\n    classes.push(isFullscreenActive ? CSS.FULLSCREEN : CSS.FULLSCREEN_IGNORE);\n  }\n\n  return classes.join(' ');\n};\n\nexport const renderText = (text: string): string => {\n  return `<span>${(text === null ? '' : text).replace(/(?:\\r\\n|\\r|\\n)/g, '</span><br /><span>')}</span>`;\n};\n\nexport const getFrameRect = (iframe: SubtitleFrame, controlsVisible: boolean): {\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  bottomPadding: number\n} => {\n  const height = iframe.offsetHeight;\n\n  return {\n    x: iframe.offsetLeft - iframe.scrollLeft + iframe.clientLeft,\n    y: iframe.offsetTop - iframe.scrollTop + iframe.clientTop,\n    width: iframe.offsetWidth,\n    height: height,\n    bottomPadding: height < 200 && !controlsVisible ? 20 : 60\n  };\n};\n\nexport const renderSubtitle = (element: SubtitleElement, player: any, isFullscreenActive: boolean, text: string, controlsVisible: boolean): void => {\n  element.className = renderClassName(isFullscreenActive);\n  element.innerHTML = renderText(text);\n\n  element.style.display = text === null ? '' : 'block';\n\n  if (player) {\n    const frame = getFrameRect(player.getIframe(), controlsVisible);\n\n    element.style.visibility = 'hidden';\n    element.style.top = `${frame.y}px`;\n    element.style.left = `${frame.x}px`;\n    element.style.maxWidth = `${frame.width - 20}px`;\n    element.style.fontSize = `${frame.height / 260}em`;\n\n    element.style.top = `${frame.y + frame.height - frame.bottomPadding - element.offsetHeight}px`;\n    element.style.left = `${frame.x + (frame.width - element.offsetWidth) / 2}px`;\n    element.style.visibility = '';\n  }\n};\n\nclass Subtitle {\n  private cache: Cache = null;\n  private timeChangeInterval: number = 0;\n  private controlsHideTimeout: number = 0;\n  private player: any = null;\n  private videoId: string = null;\n  private readonly element: SubtitleElement = null;\n  private readonly renderMethod: RenderMethod = null;\n  private state: State = {\n    text: null,\n    isFullscreenActive: null,\n    controlsVisible: true\n  };\n\n  constructor(iframe: SubtitleFrame, subtitles: SubtitleEntry[] = [], renderMethod: RenderMethod = null) {\n    if (iframe.youtubeExternalSubtitle) {\n      throw new Error('YoutubeExternalSubtitle: subtitle is already added for this element');\n    }\n\n    iframe.youtubeExternalSubtitle = this;\n\n    const src = getIframeSrc(iframe.src);\n\n    if (iframe.src !== src) {\n      iframe.src = src;\n    }\n\n    this.load(subtitles);\n\n    this.element = createSubtitleElement(iframe, this);\n\n    this.renderMethod = renderMethod === null ? renderSubtitle : renderMethod;\n\n    const initService = DIC.getInitService();\n\n    initService.grantGlobalStyles();\n\n    initService.addSubtitle(this);\n\n    this.render();\n\n    initService.grantIframeApi(() => {\n      const YT = DIC.getYT();\n\n      this.player = new YT.Player(iframe);\n\n      this.player.addEventListener('onReady', this.onPlayerReady);\n      this.player.addEventListener('onStateChange', this.onPlayerStateChange);\n    });\n  }\n\n  public load(subtitles: SubtitleEntry[]): void {\n    this.cache = buildCache(subtitles);\n  }\n\n  public setIsFullscreenActive(isFullscreenActive: boolean): void {\n    this.setState({ isFullscreenActive });\n  }\n\n  public destroy(): void {\n    this.stop();\n\n    this.element.parentNode.removeChild(this.element);\n\n    this.player.getIframe().youtubeExternalSubtitle = null;\n\n    this.player.removeEventListener('onReady', this.onPlayerReady);\n    this.player.removeEventListener('onStateChange', this.onPlayerStateChange);\n\n    const initService = DIC.getInitService();\n\n    initService.removeSubtitle(this);\n  }\n\n  public render(): void {\n    this.renderMethod(this.element, this.player, this.state.isFullscreenActive, this.state.text, this.state.controlsVisible);\n  }\n\n  public isInContainer(container: Element|Document): boolean {\n    return container.contains(this.element) || container === this.element;\n  }\n\n  public getYTPlayer(): any {\n    return this.player;\n  }\n\n  private setState(state: Partial<State>): void {\n    const prevState = this.state;\n    const nextState: State = {\n      ...prevState,\n      ...state\n    };\n\n    if (!isStateChanged(prevState, nextState)) {\n      return;\n    }\n\n    this.state = nextState;\n\n    this.render();\n  }\n\n  private start(): void {\n    this.stop();\n\n    const window = DIC.getWindow();\n\n    this.timeChangeInterval = window.setInterval(this.onTimeChange, 500);\n    this.controlsHideTimeout = window.setTimeout(this.onControlsHide, 3000);\n\n    this.onTimeChange();\n  }\n\n  private stop(): void {\n    const window = DIC.getWindow();\n\n    window.clearInterval(this.timeChangeInterval);\n    window.clearTimeout(this.controlsHideTimeout);\n\n    this.setState({ controlsVisible: true });\n  }\n\n  private getCurrentVideoId(): string {\n    return this.player.getVideoData().video_id;\n  }\n\n  private onTimeChange = (): void => {\n    const subtitle = getSubtitleFromCache(this.player.getCurrentTime(), this.cache);\n\n    this.setState({ text: subtitle ? subtitle.text : null });\n  };\n\n  private onControlsHide = (): void => {\n    this.setState({ controlsVisible: false });\n  };\n\n  private onPlayerReady = (): void => {\n    this.videoId = this.getCurrentVideoId();\n  };\n\n  private onPlayerStateChange = (e: any): void => {\n    if (this.videoId !== this.getCurrentVideoId()) {\n      return;\n    }\n\n    const YT = DIC.getYT();\n\n    if (e.data === YT.PlayerState.PLAYING) {\n      this.start();\n    } else if (e.data === YT.PlayerState.PAUSED) {\n      this.stop();\n    } else if (e.data === YT.PlayerState.ENDED) {\n      this.stop();\n\n      this.setState({ text: null });\n    }\n  };\n}\n\nexport default Subtitle;\n\n'youtube.external.subtitle/src/youtube.external.subtitle.test.ts'\n:import YoutubeExternalSubtitle from './youtube.external.subtitle';\nimport Subtitle from './subtitle';\n\ntest('the main script returns the Subtitle class', () => {\n  expect(YoutubeExternalSubtitle.Subtitle).toBe(Subtitle);\n});\n\n",
        "called_code_segment": "const element = document.createElement('div') as SubtitleElement;",
        "invoking_code_segment": "this.element = createSubtitleElement(iframe, this);",
        "new_file_code_segment": "export const createSubtitleElementWithCustomStyles = (iframe: SubtitleFrame, subtitle: Subtitle, customStyles: string): SubtitleElement => {\n  const element = document.createElement('div') as SubtitleElement;\n  element.youtubeExternalSubtitle = subtitle;\n  element.style.cssText = customStyles;\n  iframe.parentNode.insertBefore(element, iframe.nextSibling);\n  return element;\n};",
        "feature_description": "Add custom styles to the subtitle element.",
        "detailed_feature_description": "The new feature allows users to apply custom CSS styles to the subtitle element. This is achieved by creating a new function in #file 3 that accepts custom styles as a parameter and applies them to the subtitle element. The existing function in #file 1 is modified to call this new function, and #file 2 is updated to pass custom styles when creating the subtitle element.",
        "modified_complete_code": {
            "#file 1": "import { createSubtitleElementWithCustomStyles } from './customStyles'; //New\n\nclass Subtitle {\n  constructor(iframe: SubtitleFrame, subtitles: SubtitleEntry[] = [], renderMethod: RenderMethod = null, customStyles: string = '') { //Modify\n    if (iframe.youtubeExternalSubtitle) {\n      throw new Error('YoutubeExternalSubtitle: subtitle is already added for this element');\n    }\n\n    iframe.youtubeExternalSubtitle = this;\n\n    const src = getIframeSrc(iframe.src);\n\n    if (iframe.src !== src) {\n      iframe.src = src;\n    }\n\n    this.load(subtitles);\n\n    this.element = createSubtitleElementWithCustomStyles(iframe, this, customStyles); //Modify\n\n    this.renderMethod = renderMethod === null ? renderSubtitle : renderMethod;\n\n    const initService = DIC.getInitService();\n\n    initService.grantGlobalStyles();\n\n    initService.addSubtitle(this);\n\n    this.render();\n\n    initService.grantIframeApi(() => {\n      const YT = DIC.getYT();\n\n      this.player = new YT.Player(iframe);\n\n      this.player.addEventListener('onReady', this.onPlayerReady);\n      this.player.addEventListener('onStateChange', this.onPlayerStateChange);\n    });\n  }\n}",
            "#file 2": "import { Subtitle } from './subtitle';\nimport { customStyles } from './customStyles'; //New\n\nconst subtitle = new Subtitle(iframe, subtitles, renderMethod, customStyles); //Modify",
            "#file 3": "export const createSubtitleElementWithCustomStyles = (iframe: SubtitleFrame, subtitle: Subtitle, customStyles: string): SubtitleElement => {\n  const element = document.createElement('div') as SubtitleElement;\n  element.youtubeExternalSubtitle = subtitle;\n  element.style.cssText = customStyles;\n  iframe.parentNode.insertBefore(element, iframe.nextSibling);\n  return element;\n};\n\nexport const customStyles = 'color: red; font-size: 1.2em;'; //New"
        }
    },
    {
        "repo": "react-in-angular",
        "content": "'react-in-angular/src/app/app.component.ts'\n:import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.scss']\n})\nexport class AppComponent {\n  public counter = 21;\n\n  public handleOnClick(stateCounter: number) {\n    this.counter++;\n  }\n}\n\n'react-in-angular/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\nimport { MyComponentWrapperComponent } from 'src/components/my-react-component/MyReactComponentWrapper';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    MyComponentWrapperComponent,\n  ],\n  imports: [\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'react-in-angular/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "public handleOnClick(stateCounter: number) { this.counter++; }",
        "invoking_code_segment_file_2": "public handleOnClick(stateCounter: number) { this.counter++; }",
        "called_code_segment_file_2": "public handleOnClick(stateCounter: number) { this.counter++; }",
        "using_code_segment_file_3": "public handleOnClick(stateCounter: number) { this.counter++; }",
        "feature_description": "Add a new feature to decrement the counter when a button is clicked.",
        "detailed_feature_description": "The new feature involves adding a new method in `#file 1` to decrement the counter. This method will be invoked by `#file 2` similarly to how the increment method is currently invoked. `#file 3` will remain unchanged as it does not directly interact with the decrement functionality.",
        "modified_complete_code": {
            "file_1": "export class AppComponent { public counter = 21; public handleOnClick(stateCounter: number) { this.counter++; } #Modify public handleOnDecrement() { this.counter--; } #New }",
            "file_2": "export class MyComponentWrapperComponent { public handleOnClick(stateCounter: number) { this.counter++; } #Modify public handleOnDecrement() { this.counter--; } #New }",
            "file_3": "export class AppModule { }"
        }
    },
    {
        "repo": "react-signature-pad-wrapper",
        "content": "'react-signature-pad-wrapper/src/SignaturePad.tsx'\n:import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport SigPad, { type Options, type PointGroup, type ToSVGOptions } from 'signature_pad';\nimport { debounce } from 'throttle-debounce';\n\ntype Props = {\n    width?: number;\n    height?: number;\n    options?: Options;\n    canvasProps?: { [key: string]: string | { [key: string]: string } };\n} & DefaultProps;\n\ntype DefaultProps = {\n    redrawOnResize: boolean;\n    debounceInterval: number;\n};\n\ntype State = {\n    canvasWidth: number;\n    canvasHeight: number;\n};\n\n/**\n * @class\n * @classdesc Signature pad component.\n * @extends {PureComponent}\n */\nclass SignaturePad extends React.PureComponent<Props, State> {\n    static displayName = 'react-signature-pad-wrapper';\n\n    static propTypes = {\n        width: PropTypes.number,\n        height: PropTypes.number,\n        options: PropTypes.object,\n        canvasProps: PropTypes.object,\n        redrawOnResize: PropTypes.bool.isRequired,\n        debounceInterval: PropTypes.number.isRequired,\n    };\n\n    static defaultProps: DefaultProps = {\n        redrawOnResize: false,\n        debounceInterval: 150,\n    };\n\n    private canvasRef = React.createRef<HTMLCanvasElement>();\n\n    private signaturePad!: SigPad;\n\n    private callResizeHandler!: debounce<() => void>;\n\n    /**\n     * Create a new signature pad.\n     *\n     * @param {Props} props\n     */\n    constructor(props: Props) {\n        super(props);\n\n        this.state = { canvasWidth: 0, canvasHeight: 0 };\n\n        this.callResizeHandler = debounce<() => void>(this.props.debounceInterval, this.handleResize.bind(this));\n    }\n\n    /**\n     * Initialise the signature pad once the canvas element is rendered.\n     *\n     * @return {void}\n     */\n    componentDidMount(): void {\n        const canvas = this.canvasRef.current;\n\n        if (canvas) {\n            if (!this.props.width || !this.props.height) {\n                canvas.style.width = '100%';\n                window.addEventListener('resize', this.callResizeHandler);\n            }\n\n            this.signaturePad = new SigPad(canvas, this.props.options);\n\n            this.scaleCanvas(canvas);\n        }\n    }\n\n    /**\n     * Remove the resize event listener and switch the signature pad off on\n     * unmount.\n     *\n     * @return {void}\n     */\n    componentWillUnmount(): void {\n        if (!this.props.width || !this.props.height) {\n            window.removeEventListener('resize', this.callResizeHandler);\n        }\n\n        this.signaturePad.off();\n    }\n\n    /**\n     * Get the original signature_pad instance.\n     *\n     * @return {SigPad}\n     */\n    get instance(): SigPad {\n        return this.signaturePad;\n    }\n\n    /**\n     * Get the canvas ref.\n     *\n     * @return {Object}\n     */\n    get canvas(): React.RefObject<HTMLCanvasElement> {\n        return this.canvasRef;\n    }\n\n    /**\n     * Set the radius of a single dot.\n     *\n     * @param {number} dotSize\n     * @return {void}\n     */\n    set dotSize(dotSize: number) {\n        this.signaturePad.dotSize = dotSize;\n    }\n\n    /**\n     * Get the radius of a single dot.\n     *\n     * @return {number}\n     */\n    get dotSize(): number {\n        return this.signaturePad.dotSize;\n    }\n\n    /**\n     * Set the minimum width of a line.\n     *\n     * @param {number} minWidth\n     * @return {void}\n     */\n    set minWidth(minWidth: number) {\n        this.signaturePad.minWidth = minWidth;\n    }\n\n    /**\n     * Get the minimum width of a line.\n     *\n     * @return {number}\n     */\n    get minWidth(): number {\n        return this.signaturePad.minWidth;\n    }\n\n    /**\n     * Get the maximum width of a line.\n     *\n     * @param {number} maxWidth\n     * @return {void}\n     */\n    set maxWidth(maxWidth: number) {\n        this.signaturePad.maxWidth = maxWidth;\n    }\n\n    /**\n     * Get the maximum width of a line.\n     *\n     * @return {number}\n     */\n    get maxWidth(): number {\n        return this.signaturePad.maxWidth;\n    }\n\n    /**\n     * Set the throttle for drawing the next point at most once every x ms.\n     *\n     * @param {number} throttle\n     * @return {void}\n     */\n    set throttle(throttle: number) {\n        this.signaturePad.throttle = throttle;\n    }\n\n    /**\n     * Get the throttle for drawing the next point at most once every x ms.\n     *\n     * @return {number}\n     */\n    get throttle(): number {\n        return this.signaturePad.throttle;\n    }\n\n    /**\n     * Set the color used to clear the background.\n     *\n     * @param {string} color\n     * @return {void}\n     */\n    set backgroundColor(color: string) {\n        this.signaturePad.backgroundColor = color;\n    }\n\n    /**\n     * Get the color used to clear the background.\n     *\n     * @return {string}\n     */\n    get backgroundColor(): string {\n        return this.signaturePad.backgroundColor;\n    }\n\n    /**\n     * Set the color used to draw the lines.\n     *\n     * @param {string} color\n     * @return {void}\n     */\n    set penColor(color: string) {\n        this.signaturePad.penColor = color;\n    }\n\n    /**\n     * Get the color used to draw the lines.\n     *\n     * @return {string}\n     */\n    get penColor(): string {\n        return this.signaturePad.penColor;\n    }\n\n    /**\n     * Set weight used to modify new velocity based on the previous velocity.\n     *\n     * @param {number} weight\n     * @return {void}\n     */\n    set velocityFilterWeight(weight: number) {\n        this.signaturePad.velocityFilterWeight = weight;\n    }\n\n    /**\n     * Get weight used to modify new velocity based on the previous velocity.\n     *\n     * @return {number}\n     */\n    get velocityFilterWeight(): number {\n        return this.signaturePad.velocityFilterWeight;\n    }\n\n    /**\n     * Determine if the canvas is empty.\n     *\n     * @return {boolean}\n     */\n    isEmpty(): boolean {\n        return this.signaturePad.isEmpty();\n    }\n\n    /**\n     * Clear the canvas.\n     *\n     * @return {void}\n     */\n    clear(): void {\n        this.signaturePad.clear();\n    }\n\n    /**\n     * Draw a signature from a data URL.\n     *\n     * @param {string} dataUrl\n     * @param {object} options\n     * @return {void}\n     */\n    fromDataURL(\n        dataUrl: string,\n        options: Partial<{ ratio: number; width: number; height: number; xOffset: number; yOffset: number }> = {},\n    ): void {\n        this.signaturePad.fromDataURL(dataUrl, options);\n    }\n\n    /**\n     * Get the signature data as a data URL.\n     *\n     * @param {?string} mime\n     * @param {?number} encoderOptions\n     * @return {string}\n     */\n    toDataURL(type?: string, encoderOptions?: number): string {\n        return this.signaturePad.toDataURL(type, encoderOptions);\n    }\n\n    /**\n     * Get the signature data as an SVG string without converting to base64.\n     *\n     * @param {?ToSVGOptions} svgOptions\n     * @return {string}\n     */\n    toSVG(svgOptions?: ToSVGOptions): string {\n        return this.signaturePad.toSVG(svgOptions);\n    }\n\n    /**\n     * Draw a signature from an array of point groups.\n     *\n     * @param {PointGroup[]} data\n     * @return {void}\n     */\n    fromData(data: PointGroup[]): void {\n        this.signaturePad.fromData(data);\n    }\n\n    /**\n     * Get the signature pad data an array of point groups.\n     *\n     * @return {PointGroup[]}\n     */\n    toData(): PointGroup[] {\n        return this.signaturePad.toData();\n    }\n\n    /**\n     * Turn the signature pad off.\n     *\n     * @return {void}\n     */\n    off(): void {\n        this.signaturePad.off();\n    }\n\n    /**\n     * Turn the signature pad on.\n     *\n     * @return {void}\n     */\n    on(): void {\n        this.signaturePad.on();\n    }\n\n    /**\n     * Handle a resize event.\n     *\n     * @return {void}\n     */\n    handleResize(): void {\n        const canvas = this.canvasRef.current;\n\n        if (canvas) {\n            this.scaleCanvas(canvas);\n        }\n    }\n\n    /**\n     * Scale the canvas.\n     *\n     * @param {HTMLCanvasElement} canvas\n     * @return {void}\n     */\n    scaleCanvas(canvas: HTMLCanvasElement): void {\n        const ratio = Math.max(window.devicePixelRatio || 1, 1);\n        const width = (this.props.width || canvas.offsetWidth) * ratio;\n        const height = (this.props.height || canvas.offsetHeight) * ratio;\n\n        // Avoid needlessly setting height / width if dimensions haven't changed\n        const { canvasWidth, canvasHeight } = this.state;\n\n        if (width === canvasWidth && height === canvasHeight) return;\n\n        let data;\n\n        if (this.props.redrawOnResize && this.signaturePad && !this.signaturePad.isEmpty()) {\n            data = this.signaturePad.toDataURL();\n        }\n\n        canvas.width = width;\n        canvas.height = height;\n\n        this.setState({ canvasWidth: width, canvasHeight: height });\n\n        const ctx = canvas.getContext('2d');\n\n        if (ctx) {\n            ctx.scale(ratio, ratio);\n        }\n\n        if (data) {\n            this.signaturePad.fromDataURL(data);\n        } else if (this.signaturePad) {\n            this.signaturePad.clear();\n        }\n    }\n\n    /**\n     * Render the signature pad component.\n     *\n     * @return {ReactNode}\n     */\n    render(): React.ReactNode {\n        const { canvasProps } = this.props;\n\n        return <canvas data-testid=\"canvas-element\" ref={this.canvasRef} {...canvasProps} />;\n    }\n}\n\nexport default SignaturePad;\n\n'react-signature-pad-wrapper/example/Layout.tsx'\n:import * as React from 'react';\n\nimport SignaturePad from '../src/SignaturePad';\n\n/**\n * @class\n * @classdesc Layout component.\n * @extends {PureComponent}\n */\nclass Layout extends React.PureComponent {\n    /**\n     * The signature pad component reference.\n     *\n     * @var {RefObject}\n     */\n    private signaturePadRef = React.createRef<SignaturePad>();\n\n    /**\n     * Clear the signature pad.\n     *\n     * @return {void}\n     */\n    handleClear(): void {\n        const signaturePad = this.signaturePadRef.current;\n\n        if (signaturePad) {\n            signaturePad.instance.clear();\n        }\n    }\n\n    /**\n     * Save a signature.\n     *\n     * @return {void}\n     */\n    handleSave(): void {\n        const signaturePad = this.signaturePadRef.current;\n\n        if (!signaturePad) {\n            return;\n        }\n\n        if (signaturePad.isEmpty()) {\n            alert('Please provide a signature first.');\n        } else {\n            window.open(signaturePad.toDataURL());\n        }\n    }\n\n    /**\n     * Render the title.\n     *\n     * @return {ReactNode}\n     */\n    renderTitle(): React.ReactNode {\n        return (\n            <div className=\"columns\">\n                <div className=\"column\">\n                    <h1 className=\"title\">React-Signature-Pad-Wrapper</h1>\n                    <h2 className=\"subtitle\">responsive example</h2>\n                </div>\n            </div>\n        );\n    }\n\n    /**\n     * Render the signature pad.\n     *\n     * @return {ReactNode}\n     */\n    renderSignaturePad(): React.ReactNode {\n        return (\n            <div className=\"columns\">\n                <div className=\"column is-10-tablet is-offset-1-tablet is-8-desktop is-offset-2-desktop\">\n                    <div className=\"card\">\n                        <div className=\"card-content\">\n                            <div className=\"content\">\n                                <SignaturePad redrawOnResize ref={this.signaturePadRef} />\n                            </div>\n                        </div>\n                        <footer className=\"card-footer\">\n                            <a className=\"card-footer-item\" onClick={this.handleClear.bind(this)}>\n                                Clear\n                            </a>\n                            <p className=\"card-footer-item\">\n                                <span>sign above</span>\n                            </p>\n                            <a className=\"card-footer-item\" onClick={this.handleSave.bind(this)}>\n                                Save\n                            </a>\n                        </footer>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n\n    /**\n     * Render the layout component.\n     *\n     * @return {ReactNode}\n     */\n    render(): React.ReactNode {\n        return (\n            <section className=\"section\">\n                <div className=\"container\">\n                    {this.renderTitle()}\n                    {this.renderSignaturePad()}\n                </div>\n            </section>\n        );\n    }\n}\n\nexport default Layout;\n\n'react-signature-pad-wrapper/example/app.tsx'\n:import * as React from 'react';\nimport { createRoot } from 'react-dom/client';\n\nimport Layout from './Layout';\n\nconst element = document.getElementById('root');\n\nif (element) {\n    createRoot(element).render(<Layout />);\n}\n\n",
        "called_code_segment_file_1": "clear(): void { this.signaturePad.clear(); }",
        "invoking_code_segment_file_2": "handleClear(): void { const signaturePad = this.signaturePadRef.current; if (signaturePad) { signaturePad.instance.clear(); } }",
        "called_code_segment_file_2": "handleClear(): void { const signaturePad = this.signaturePadRef.current; if (signaturePad) { signaturePad.instance.clear(); } }",
        "using_code_segment_file_3": "private signaturePadRef = React.createRef<SignaturePad>();",
        "feature_description": "Add a feature to allow the user to undo the last stroke.",
        "detailed_feature_description": "In #file 1, add a new method `undoLastStroke` to the `SignaturePad` class. Update #file 2 to handle this new method and ensure any related code segments used by #file 3 are updated accordingly. Modify #file 3 to accommodate the changes if necessary.",
        "modified_complete_code": {
            "#file 1": "//Modify\nundoLastStroke(): void {\n    const data = this.signaturePad.toData();\n    if (data.length > 0) {\n        data.pop();\n        this.signaturePad.fromData(data);\n    }\n}\n\n//Modify\nrender(): React.ReactNode {\n    const { canvasProps } = this.props;\n    return <canvas data-testid=\"canvas-element\" ref={this.canvasRef} {...canvasProps} />;\n}",
            "#file 2": "//Modify\nhandleUndo(): void {\n    const signaturePad = this.signaturePadRef.current;\n    if (signaturePad) {\n        signaturePad.instance.undoLastStroke();\n    }\n}\n\n//Modify\nrenderSignaturePad(): React.ReactNode {\n    return (\n        <div className=\"columns\">\n            <div className=\"column is-10-tablet is-offset-1-tablet is-8-desktop is-offset-2-desktop\">\n                <div className=\"card\">\n                    <div className=\"card-content\">\n                        <div className=\"content\">\n                            <SignaturePad redrawOnResize ref={this.signaturePadRef} />\n                        </div>\n                    </div>\n                    <footer className=\"card-footer\">\n                        <a className=\"card-footer-item\" onClick={this.handleClear.bind(this)}>\n                            Clear\n                        </a>\n                        <a className=\"card-footer-item\" onClick={this.handleUndo.bind(this)}>\n                            Undo\n                        </a>\n                        <p className=\"card-footer-item\">\n                            <span>sign above</span>\n                        </p>\n                        <a className=\"card-footer-item\" onClick={this.handleSave.bind(this)}>\n                            Save\n                        </a>\n                    </footer>\n                </div>\n            </div>\n        </div>\n    );\n}",
            "#file 3": "//New\nprivate signaturePadRef = React.createRef<SignaturePad>();"
        }
    },
    {
        "repo": "restaurant-app",
        "content": "'restaurant-app/src/pages/list-restaurant/list-restaurant.ts'\n:import { Component } from '@angular/core';\nimport { NavController } from 'ionic-angular';\n\n/*\n  Generated class for the ListRestaurant page.\n\n  See http://ionicframework.com/docs/v2/components/#navigation for more info on\n  Ionic pages and navigation.\n*/\n@Component({\n  selector: 'page-list-restaurant',\n  templateUrl: 'list-restaurant.html'\n})\nexport class ListRestaurant {\n\n  constructor(public navCtrl: NavController) {}\n\n  ionViewDidLoad() {\n    console.log('Hello ListRestaurant Page');\n  }\n\n}\n\n'restaurant-app/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { IonicApp, IonicModule } from 'ionic-angular';\nimport { MyApp } from './app.component';\nimport { AboutPage } from '../pages/about/about';\nimport { ContactPage } from '../pages/contact/contact';\nimport { HomePage } from '../pages/home/home';\nimport { AddRestaurant } from '../pages/add-restaurant/add-restaurant';\nimport { AddRestaurantInfo } from '../pages/add-restaurant-info/add-restaurant-info';\nimport { ListRestaurant } from '../pages/list-restaurant/list-restaurant';\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  imports: [\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  providers: []\n})\nexport class AppModule {}\n\n'restaurant-app/src/app/main.dev.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n",
        "called_code_segment_file_1": "@Component({\n  selector: 'page-list-restaurant',\n  templateUrl: 'list-restaurant.html'\n})\nexport class ListRestaurant {\n\n  constructor(public navCtrl: NavController) {}\n\n  ionViewDidLoad() {\n    console.log('Hello ListRestaurant Page');\n  }\n\n}",
        "invoking_code_segment_file_2": "import { ListRestaurant } from '../pages/list-restaurant/list-restaurant';\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  imports: [\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  providers: []\n})\nexport class AppModule {}",
        "called_code_segment_file_2": "import { ListRestaurant } from '../pages/list-restaurant/list-restaurant';\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  imports: [\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  providers: []\n})\nexport class AppModule {}",
        "using_code_segment_file_3": "platformBrowserDynamic().bootstrapModule(AppModule);",
        "feature_description": "Add a new method to the ListRestaurant component to fetch restaurant data from a service.",
        "detailed_feature_description": "We will add a new method `fetchRestaurants` to the ListRestaurant component to fetch restaurant data from a service. This method will be called when the component is loaded. The AppModule will be updated to include the new service, and the main.dev.ts file will remain unchanged as it bootstraps the AppModule.",
        "modified_complete_code": {
            "file_1": "@Component({\n  selector: 'page-list-restaurant',\n  templateUrl: 'list-restaurant.html'\n})\nexport class ListRestaurant {\n\n  constructor(public navCtrl: NavController, private restaurantService: RestaurantService) {}\n\n  ionViewDidLoad() {\n    console.log('Hello ListRestaurant Page');\n    this.fetchRestaurants();\n  }\n\n  #Modify fetchRestaurants() {\n    this.restaurantService.getRestaurants().subscribe(restaurants => {\n      console.log(restaurants);\n    });\n  }\n}",
            "file_2": "import { NgModule } from '@angular/core';\nimport { IonicApp, IonicModule } from 'ionic-angular';\nimport { MyApp } from './app.component';\nimport { AboutPage } from '../pages/about/about';\nimport { ContactPage } from '../pages/contact/contact';\nimport { HomePage } from '../pages/home/home';\nimport { AddRestaurant } from '../pages/add-restaurant/add-restaurant';\nimport { AddRestaurantInfo } from '../pages/add-restaurant-info/add-restaurant-info';\nimport { ListRestaurant } from '../pages/list-restaurant/list-restaurant';\nimport { RestaurantService } from '../services/restaurant.service'; #New\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  imports: [\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  providers: [RestaurantService] #Modify\n})\nexport class AppModule {}",
            "file_3": "import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);"
        }
    },
    {
        "repo": "Web_IDE",
        "content": "'Web_IDE/src/redux/saga.ts'\n:import rootSaga from './file-system/saga';\n\nexport default rootSaga;\n'Web_IDE/src/App.tsx'\n:import React from 'react';\nimport { createStore, applyMiddleware, compose } from 'redux'\nimport createSagaMiddleware from 'redux-saga'\nimport { Provider } from 'react-redux';\nimport * as esbuild from 'esbuild-wasm';\n\nimport ContentPage from 'pages';\nimport reducer from 'redux/reducers';\nimport rootSaga from 'redux/saga';\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n  }\n}\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\nconst sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  reducer,composeEnhancers(\n  applyMiddleware(sagaMiddleware))\n);\nsagaMiddleware.run(rootSaga);\n\n\nconst App: React.FC = () => {\n/*   useEffect(() => {\n    esbuild.initialize({\n      wasmURL: './node_modules/esbuild-wasm/esbuild.wasm',\n      worker: true\n    }).catch(()=>{console.log(\"esbuild initialize more than once!\")})\n  }, []) */\n\n  return (\n    <Provider store={store}>\n      <ContentPage />\n    </Provider>\n  )\n}\n\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType<typeof store.getState>\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = typeof store.dispatch\nexport default App;\n\n'Web_IDE/src/index.tsx'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n\n",
        "called_code_segment_file_1": "const sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  reducer,composeEnhancers(\n  applyMiddleware(sagaMiddleware))\n);\nsagaMiddleware.run(rootSaga);",
        "invoking_code_segment_file_2": "export default rootSaga;",
        "called_code_segment_file_2": "export default rootSaga;",
        "using_code_segment_file_3": "import rootSaga from './file-system/saga';",
        "feature_description": "Add a new feature to log the status of the saga middleware when it is run.",
        "detailed_feature_description": "Modify the part in `#file 1` where the saga middleware is run to log a message indicating that the saga middleware has started. Update `#file 2` to handle this logging if necessary. Since `#file 3` directly imports `rootSaga` from `#file 2`, ensure that any changes in `#file 2` are compatible with `#file 3`.",
        "modified_complete_code": {
            "#file 1": "const sagaMiddleware = createSagaMiddleware();\nconst store = createStore(\n  reducer,composeEnhancers(\n  applyMiddleware(sagaMiddleware))\n);\n//Modify: Log the status of the saga middleware when it is run\nsagaMiddleware.run(rootSaga).then(() => {\n  console.log('Saga middleware has started.');\n});",
            "#file 2": "//Modify: Ensure the saga middleware can handle the logging\nfunction* rootSaga() {\n  // Existing saga logic\n}\n\nexport default rootSaga;",
            "#file 3": "import rootSaga from './file-system/saga';\n// No changes needed here since the import remains the same."
        }
    },
    {
        "repo": "akello",
        "content": "'akello/microservices/auth_service/app/src/config.tsx'\n:import EmailPassword from \"supertokens-auth-react/recipe/emailpassword\";\nimport ThirdParty from \"supertokens-auth-react/recipe/thirdparty\";\nimport Passwordless, { PasswordlessComponentsOverrideProvider } from \"supertokens-auth-react/recipe/passwordless\";\nimport { EmailPasswordPreBuiltUI } from \"supertokens-auth-react/recipe/emailpassword/prebuiltui\";\nimport { ThirdPartyPreBuiltUI } from \"supertokens-auth-react/recipe/thirdparty/prebuiltui\";\nimport { PasswordlessPreBuiltUI } from \"supertokens-auth-react/recipe/passwordless/prebuiltui\";\nimport Session from \"supertokens-auth-react/recipe/session\";\nimport React from \"react\";\n\nexport function getApiDomain() {\n    const apiPort = process.env.REACT_APP_API_PORT || 3001;\n    const apiUrl = process.env.REACT_APP_API_URL || `http://localhost:${apiPort}`;\n    return apiUrl;\n}\n\nexport function getWebsiteDomain() {\n    const websitePort = process.env.REACT_APP_WEBSITE_PORT || 3000;\n    const websiteUrl = process.env.REACT_APP_WEBSITE_URL || `http://localhost:${websitePort}`;\n    return websiteUrl;\n}\n\nexport const SuperTokensConfig = {\n    appInfo: {\n        appName: \"SuperTokens Demo App\",\n        apiDomain: getApiDomain(),\n        websiteDomain: getWebsiteDomain(),\n    },\n    // recipeList contains all the modules that you want to\n    // use from SuperTokens. See the full list here: https://supertokens.com/docs/guides\n    recipeList: [\n        EmailPassword.init(),\n        ThirdParty.init({\n            signInAndUpFeature: {\n                providers: [\n                    ThirdParty.Github.init(),\n                    ThirdParty.Google.init(),\n                    ThirdParty.Apple.init(),\n                    ThirdParty.Twitter.init(),\n                ],\n            },\n        }),\n        Passwordless.init({\n            contactMethod: \"EMAIL_OR_PHONE\",\n        }),\n        Session.init(),\n    ],\n};\n\nexport const recipeDetails = {\n    docsLink: \"https://supertokens.com/docs/thirdpartypasswordless/introduction\",\n};\n\nexport const PreBuiltUIList = [EmailPasswordPreBuiltUI, ThirdPartyPreBuiltUI, PasswordlessPreBuiltUI];\n\nexport const ComponentWrapper = (props: { children: JSX.Element }): JSX.Element => {\n    return (\n        <PasswordlessComponentsOverrideProvider\n            components={{\n                PasswordlessUserInputCodeFormFooter_Override: ({ DefaultComponent, ...props }) => {\n                    const loginAttemptInfo = props.loginAttemptInfo;\n                    let showQuotaMessage = false;\n\n                    if (loginAttemptInfo.contactMethod === \"PHONE\") {\n                        showQuotaMessage = true;\n                    }\n\n                    return (\n                        <div\n                            style={{\n                                width: \"100%\",\n                            }}\n                        >\n                            <DefaultComponent {...props} />\n                            {showQuotaMessage && (\n                                <div\n                                    style={{\n                                        width: \"100%\",\n                                        paddingLeft: 12,\n                                        paddingRight: 12,\n                                        paddingTop: 6,\n                                        paddingBottom: 6,\n                                        borderRadius: 4,\n                                        backgroundColor: \"#EF9A9A\",\n                                        margin: 0,\n                                        boxSizing: \"border-box\",\n                                        MozBoxSizing: \"border-box\",\n                                        WebkitBoxSizing: \"border-box\",\n                                        fontSize: 12,\n                                        textAlign: \"start\",\n                                        fontWeight: \"bold\",\n                                        lineHeight: \"18px\",\n                                    }}\n                                >\n                                    There is a daily quota for the free SMS service, if you do not receive the SMS\n                                    please try again tomorrow.\n                                </div>\n                            )}\n                        </div>\n                    );\n                },\n            }}\n        >\n            {props.children}\n        </PasswordlessComponentsOverrideProvider>\n    );\n};\n\n'akello/microservices/auth_service/app/src/App.tsx'\n:import \"./App.css\";\nimport SuperTokens, { SuperTokensWrapper } from \"supertokens-auth-react\";\nimport { getSuperTokensRoutesForReactRouterDom } from \"supertokens-auth-react/ui\";\nimport { SessionAuth } from \"supertokens-auth-react/recipe/session\";\nimport { Routes, BrowserRouter as Router, Route } from \"react-router-dom\";\nimport Home from \"./Home\";\nimport { PreBuiltUIList, SuperTokensConfig, ComponentWrapper } from \"./config\";\n\nSuperTokens.init(SuperTokensConfig);\n\nfunction App() {\n    return (\n        <SuperTokensWrapper>\n            <ComponentWrapper>\n                <div className=\"App app-container\">\n                    <Router>\n                        <div className=\"fill\">\n                            <Routes>\n                                {/* This shows the login UI on \"/auth\" route */}\n                                {getSuperTokensRoutesForReactRouterDom(require(\"react-router-dom\"), PreBuiltUIList)}\n\n                                <Route\n                                    path=\"/\"\n                                    element={\n                                        /* This protects the \"/\" route so that it shows\n                                    <Home /> only if the user is logged in.\n                                    Else it redirects the user to \"/auth\" */\n                                        <SessionAuth>\n                                            <Home />\n                                        </SessionAuth>\n                                    }\n                                />\n                            </Routes>\n                        </div>\n                    </Router>\n                </div>\n            </ComponentWrapper>\n        </SuperTokensWrapper>\n    );\n}\n\nexport default App;\n\n'akello/microservices/auth_service/app/src/index.tsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement);\nroot.render(\n    <React.StrictMode>\n        <App />\n    </React.StrictMode>\n);\n\n",
        "called_code_segment_file_1": "SuperTokens.init(SuperTokensConfig);",
        "invoking_code_segment_file_2": "SuperTokensWrapper> <ComponentWrapper> <div className=\"App app-container\"> <Router> <div className=\"fill\"> <Routes> {getSuperTokensRoutesForReactRouterDom(require(\"react-router-dom\"), PreBuiltUIList)} <Route path=\"/\" element={ <SessionAuth> <Home /> </SessionAuth> } /> </Routes> </div> </Router> </div> </ComponentWrapper> </SuperTokensWrapper>",
        "called_code_segment_file_2": "SuperTokensWrapper> <ComponentWrapper> <div className=\"App app-container\"> <Router> <div className=\"fill\"> <Routes> {getSuperTokensRoutesForReactRouterDom(require(\"react-router-dom\"), PreBuiltUIList)} <Route path=\"/\" element={ <SessionAuth> <Home /> </SessionAuth> } /> </Routes> </div> </Router> </div> </ComponentWrapper> </SuperTokensWrapper>",
        "using_code_segment_file_3": "SuperTokens.init(SuperTokensConfig);",
        "feature_description": "Add a feature to log the initialization status of SuperTokens in the console.",
        "detailed_feature_description": "Modify the SuperTokens.init function in #file 1 to log a message to the console upon successful initialization. Update #file 2 to handle any potential changes in the initialization process. Since #file 3 directly interacts with the initialization process, ensure that any changes in #file 1 are reflected in #file 3.",
        "modified_complete_code": {
            "#file 1": "import SuperTokens from \"supertokens-auth-react\";\nimport { SuperTokensConfig } from \"./config\";\n\n// Modify\nSuperTokens.init(SuperTokensConfig).then(() => {\n  console.log(\"SuperTokens initialized successfully\");\n});",
            "#file 2": "import \"./App.css\";\nimport SuperTokens, { SuperTokensWrapper } from \"supertokens-auth-react\";\nimport { getSuperTokensRoutesForReactRouterDom } from \"supertokens-auth-react/ui\";\nimport { SessionAuth } from \"supertokens-auth-react/recipe/session\";\nimport { Routes, BrowserRouter as Router, Route } from \"react-router-dom\";\nimport Home from \"./Home\";\nimport { PreBuiltUIList, ComponentWrapper } from \"./config\";\n\nfunction App() {\n  return (\n    <SuperTokensWrapper>\n      <ComponentWrapper>\n        <div className=\"App app-container\">\n          <Router>\n            <div className=\"fill\">\n              <Routes>\n                {getSuperTokensRoutesForReactRouterDom(require(\"react-router-dom\"), PreBuiltUIList)}\n                <Route\n                  path=\"/\"\n                  element={\n                    <SessionAuth>\n                      <Home />\n                    </SessionAuth>\n                  }\n                />\n              </Routes>\n            </div>\n          </Router>\n        </div>\n      </ComponentWrapper>\n    </SuperTokensWrapper>\n  );\n}\n\nexport default App;",
            "#file 3": "import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement);\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);"
        }
    },
    {
        "repo": "stromjs",
        "content": "'stromjs/src/functions/baseDefinitions.ts'\n:export interface WithEncoding {\n    encoding: BufferEncoding;\n}\n\nexport enum SerializationFormats {\n    utf8 = \"utf8\",\n}\n\ntype JsonPrimitive = string | number | object;\nexport type JsonValue = JsonPrimitive | JsonPrimitive[];\n\nexport interface JsonParseOptions {\n    pretty: boolean;\n}\n\n'stromjs/src/functions/parse.ts'\n:import { Transform } from \"stream\";\nimport { StringDecoder } from \"string_decoder\";\nimport { SerializationFormats } from \"./baseDefinitions\";\n\nexport function parse(\n    format: SerializationFormats = SerializationFormats.utf8,\n    emitError: boolean = true,\n): Transform {\n    const decoder = new StringDecoder(format);\n    return new Transform({\n        readableObjectMode: true,\n        writableObjectMode: true,\n        async transform(chunk: Buffer, encoding, callback) {\n            try {\n                const asString = decoder.write(chunk);\n                // Using await causes parsing errors to be emitted\n                callback(null, await JSON.parse(asString));\n            } catch (err) {\n                if (emitError) {\n                    callback(err);\n                } else {\n                    callback();\n                }\n            }\n        },\n    });\n}\n\n'stromjs/src/functions/index.ts'\n:import { TransformOptions } from \"stream\";\nimport { accumulator, accumulatorBy } from \"./accumulator\";\nimport { batch } from \"./batch\";\nimport { child } from \"./child\";\nimport { collect } from \"./collect\";\nimport { concat } from \"./concat\";\nimport { duplex } from \"./duplex\";\nimport { filter } from \"./filter\";\nimport { flatMap } from \"./flatMap\";\nimport { fromArray } from \"./fromArray\";\nimport { join } from \"./join\";\nimport { last } from \"./last\";\nimport { map } from \"./map\";\nimport { merge } from \"./merge\";\nimport { parallelMap } from \"./parallelMap\";\nimport { parse } from \"./parse\";\nimport { rate } from \"./rate\";\nimport { reduce } from \"./reduce\";\nimport { replace } from \"./replace\";\nimport { split } from \"./split\";\nimport { stringify } from \"./stringify\";\nimport { unbatch } from \"./unbatch\";\nimport { compose } from \"./compose\";\nimport { demux } from \"./demux\";\n\nexport function strom(defaultOptions: TransformOptions = { objectMode: true }) {\n    function withDefaultOptions<T extends any[], R>(\n        n: number,\n        fn: (...args: T) => R,\n    ): (...args: T) => R {\n        return (...args) => {\n            const options = {\n                ...defaultOptions,\n                ...((args[n] || {}) as TransformOptions | {}),\n            };\n            const provided = args.slice(0, n);\n            const nextArgs = [\n                ...provided,\n                ...Array(n - provided.length).fill(undefined),\n                options,\n            ] as T;\n            return fn(...nextArgs) as R;\n        };\n    }\n\n    return {\n        /**\n         * Convert an array into a Readable stream of its elements\n         * @param array Array of elements to stream\n         */\n        fromArray,\n\n        /**\n         * Return a ReadWrite stream that maps streamed chunks\n         * @param mapper Mapper function, mapping each (chunk, encoding) to a new chunk (or a promise of such)\n         * @param options?\n         * @param options.readableObjectMode? Whether this stream should behave as a readable stream of objects\n         * @param options.writableObjectMode? Whether this stream should behave as a writable stream of objects\n         */\n        map: withDefaultOptions(1, map),\n\n        /**\n         * Return a ReadWrite stream that flat maps streamed chunks\n         * @param mapper Mapper function, mapping each (chunk, encoding) to an array of new chunks (or a promise of such)\n         * @param options?\n         * @param options.readableObjectMode? Whether this stream should behave as a readable stream of objects\n         * @param options.writableObjectMode? Whether this stream should behave as a writable stream of objects\n         */\n        flatMap: withDefaultOptions(1, flatMap),\n\n        /**\n         * Return a ReadWrite stream that filters out streamed chunks for which the predicate does not hold\n         * @param predicate Predicate with which to filter scream chunks\n         * @param options?\n         * @param options.objectMode? Whether this stream should behave as a stream of objects.\n         */\n        filter: withDefaultOptions(1, filter),\n\n        /**\n         * Return a ReadWrite stream that reduces streamed chunks down to a single value and yield that\n         * value\n         * @param iteratee Reducer function to apply on each streamed chunk\n         * @param initialValue Initial value\n         * @param options?\n         * @param options.readableObjectMode? Whether this stream should behave as a readable stream of objects\n         * @param options.writableObjectMode? Whether this stream should behave as a writable stream of objects\n         */\n        reduce: withDefaultOptions(2, reduce),\n\n        /**\n         * Return a ReadWrite stream that splits streamed chunks using the given separator\n         * @param separator? Separator to split by, defaulting to \"\\n\"\n         * @param options? Defaults to encoding: utf8\n         * @param options.encoding? Encoding written chunks are assumed to use\n         */\n        split,\n\n        /**\n         * Return a ReadWrite stream that joins streamed chunks using the given separator\n         * @param separator Separator to join with\n         * @param options? Defaults to encoding: utf8\n         * @param options.encoding? Encoding written chunks are assumed to use\n         */\n        join: withDefaultOptions(1, join),\n\n        /**\n         * Return a ReadWrite stream that replaces occurrences of the given string or regular expression  in\n         * the streamed chunks with the specified replacement string\n         * @param searchValue Search string to use\n         * @param replaceValue Replacement string to use\n         * @param options? Defaults to encoding: utf8\n         * @param options.encoding Encoding written chunks are assumed to use\n         */\n        replace,\n\n        /**\n         * Return a ReadWrite stream that parses the streamed chunks as JSON. Each streamed chunk\n         * must be a fully defined JSON string in utf8.\n         * @param format: @type SerializationFormats defaults SerializationFormats.utf8\n         * @param emitError: @type boolean Whether or not to emit an error when\n         * failing to parse. An error will automatically close the stream.\n         * Defaults to true.\n         */\n        parse,\n\n        /**\n         * Return a ReadWrite stream that stringifies the streamed chunks to JSON\n         * @param options?\n         * @param options.pretty If true, whitespace is inserted into the stringified chunks.\n         *\n         */\n        stringify,\n\n        /**\n         * Return a ReadWrite stream that collects streamed chunks into an array or buffer\n         * @param options?\n         * @param options.objectMode? Whether this stream should behave as a stream of objects\n         */\n        collect: withDefaultOptions(0, collect),\n\n        /**\n         * Return a Readable stream of readable streams concatenated together\n         * @param streams Readable streams to concatenate\n         */\n        concat,\n\n        /**\n         * Return a Readable stream of readable streams concatenated together\n         * @param streams Readable streams to merge\n         */\n        merge,\n\n        /**\n         * Return a Duplex stream from a writable stream that is assumed to somehow, when written to,\n         * cause the given readable stream to yield chunks\n         * @param writable Writable stream assumed to cause the readable stream to yield chunks when written to\n         * @param readable Readable stream assumed to yield chunks when the writable stream is written to\n         */\n        duplex,\n\n        /**\n         * Return a Duplex stream from a child process' stdin and stdout\n         * @param childProcess Child process from which to create duplex stream\n         */\n        child,\n\n        /**\n         * Return a Promise resolving to the last streamed chunk of the given readable stream, after it has\n         * ended\n         * @param readable Readable stream to wait on\n         */\n        last,\n\n        /**\n         * Stores chunks of data internally in array and batches when batchSize is reached.\n         * @param batchSize Size of the batches, defaults to 1000.\n         * @param maxBatchAge? Max lifetime of a batch, defaults to 500\n         * @param options?\n         * @param options.objectMode? Whether this stream should behave as a stream of objects\n         */\n        batch: withDefaultOptions(2, batch),\n\n        /**\n         * Unbatches and sends individual chunks of data.\n         * @param options?\n         * @param options.objectMode? Whether this stream should behave as a stream of objects\n         */\n        unbatch: withDefaultOptions(0, unbatch),\n\n        /**\n         * Limits rate of data transferred into stream.\n         * @param targetRate? Desired rate in ms.\n         * @param period? Period to sleep for when rate is above or equal to targetRate.\n         * @param options?\n         */\n        rate: withDefaultOptions(2, rate),\n\n        /**\n         * Limits number of parallel processes in flight.\n         * @param parallel Max number of parallel processes.\n         * @param func Function to execute on each data chunk.\n         * @param pause Amount of time to pause processing when max number of parallel processes are executing.\n         */\n        parallelMap: withDefaultOptions(3, parallelMap),\n\n        /**\n         * Accummulates and sends batches of data. Each chunk that flows into the stream is checked against items\n         * in the buffer. How the buffer is mutated is based on 1 of 2 possible buffering strategies:\n         * \t1. Sliding\n         * \t\t- If the buffer is larger than the batchSize, the front of the buffer is popped to maintain\n         * \t\tthe batchSize. When no key is provided, the batchSize is effectively the buffer length. When\n         * \t\ta key is provided, the batchSize is based on the value at that key. For example, given a key\n         * \t\tof `timestamp` and a batchSize of 3000, each item in the buffer will be guaranteed to be\n         * \t\twithin 3000 timestamp units from the first element. This means that with a key, multiple elements\n         * \t\tmay be spliced off the front of the buffer. The buffer is then pushed into the stream.\n         * \t2. Rolling\n         * \t\t- If the buffer is larger than the batchSize, the buffer is cleared and pushed into the stream.\n         * \t\tWhen no key is provided, the batchSize is the buffer length. When a key is provided, the batchSize\n         * \t\tis based on the value at that key. For example, given a key of `timestamp` and a batchSize of 3000,\n         * \t\teach item in the buffer will be guaranteed to be within 3000 timestamp units from the first element.\n         * @param flushStrategy Buffering strategy to use.\n         * @param batchSize Size of the batch (in units of buffer length or value at key).\n         * @param keyBy Key to determine if element fits into buffer or items need to be cleared from buffer.\n         * @param options Transform stream options\n         */\n        accumulator: withDefaultOptions(3, accumulator),\n\n        /**\n         * Accummulates and sends batches of data. Each chunk that flows into the stream is checked against items\n         * in the buffer. How the buffer is mutated is based on 1 of 2 possible buffering strategies:\n         * \t1. Sliding\n         * \t\t- If the iteratee returns false, the front of the buffer is popped until iteratee returns true. The\n         * \t\titem is pushed into the buffer and buffer is pushed into stream.\n         * \t2. Rolling\n         * \t\t- If the iteratee returns false, the buffer is cleared and pushed into stream. The item is\n         * \t\tthen pushed into the buffer.\n         * @param flushStrategy Buffering strategy to use.\n         * @param iteratee Function applied to buffer when a chunk of data enters stream to determine if element fits into\n         * or items need to be cleared from buffer.\n         * @param options Transform stream options\n         */\n        accumulatorBy: withDefaultOptions(2, accumulatorBy),\n\n        /**\n         * Composes multiple streams together. Writing occurs on first stream, piping occurs from last stream.\n         * @param streams Array of streams to compose. Minimum of two.\n         * @param errorCallback a function that handles any error coming out of the pipeline\n         * @param options Transform stream options\n         */\n        compose: withDefaultOptions(2, compose),\n\n        /**\n         * Composes multiple streams together. Writing occurs on first stream, piping occurs from last stream.\n         * @param construct Constructor for new output source. Should return a Writable or ReadWrite stream.\n         * @param demuxBy\n         * @param demuxBy.key? Key to fetch value from source chunks to demultiplex source.\n         * @param demuxBy.keyBy? Function to fetch value from source chunks to demultiplex source.\n         * @param options Writable stream options\n         */\n        demux: withDefaultOptions(2, demux),\n\n        /**\n         * Create a new strom instance overriding the defaults\n         */\n        instance: strom,\n    };\n}\n\n",
        "called_code_segment_file_1": "export function parse(\n    format: SerializationFormats = SerializationFormats.utf8,\n    emitError: boolean = true,\n): Transform {\n    const decoder = new StringDecoder(format);\n    return new Transform({\n        readableObjectMode: true,\n        writableObjectMode: true,\n        async transform(chunk: Buffer, encoding, callback) {\n            try {\n                const asString = decoder.write(chunk);\n                // Using await causes parsing errors to be emitted\n                callback(null, await JSON.parse(asString));\n            } catch (err) {\n                if (emitError) {\n                    callback(err);\n                } else {\n                    callback();\n                }\n            }\n        },\n    });\n}",
        "invoking_code_segment_file_2": "parse,\n\n        /**\n         * Return a ReadWrite stream that parses the streamed chunks as JSON. Each streamed chunk\n         * must be a fully defined JSON string in utf8.\n         * @param format: @type SerializationFormats defaults SerializationFormats.utf8\n         * @param emitError: @type boolean Whether or not to emit an error when\n         * failing to parse. An error will automatically close the stream.\n         * Defaults to true.\n         */\n        parse,",
        "called_code_segment_file_2": "parse,\n\n        /**\n         * Return a ReadWrite stream that parses the streamed chunks as JSON. Each streamed chunk\n         * must be a fully defined JSON string in utf8.\n         * @param format: @type SerializationFormats defaults SerializationFormats.utf8\n         * @param emitError: @type boolean Whether or not to emit an error when\n         * failing to parse. An error will automatically close the stream.\n         * Defaults to true.\n         */\n        parse,",
        "using_code_segment_file_3": "const { parse } = strom();\n\n// Example usage of parse function\nconst parseStream = parse(SerializationFormats.utf8, true);",
        "feature_description": "Add an option to parse JSON chunks with a custom reviver function.",
        "detailed_feature_description": "Modify the `parse` function in `#file 1` to accept an optional `reviver` function. Update the `parse` function in `#file 2` to handle this new parameter. Ensure that `#file 3` can use the updated `parse` function with the new `reviver` parameter.",
        "modified_complete_code": {
            "file_1": "export function parse(\n    format: SerializationFormats = SerializationFormats.utf8,\n    emitError: boolean = true,\n    reviver?: (key: any, value: any) => any,\n): Transform {\n    const decoder = new StringDecoder(format);\n    return new Transform({\n        readableObjectMode: true,\n        writableObjectMode: true,\n        async transform(chunk: Buffer, encoding, callback) {\n            try {\n                const asString = decoder.write(chunk);\n                // Using await causes parsing errors to be emitted\n                const parsed = await JSON.parse(asString, reviver);\n                callback(null, parsed);\n            } catch (err) {\n                if (emitError) {\n                    callback(err);\n                } else {\n                    callback();\n                }\n            }\n        },\n    });\n}",
            "file_2": "parse,\n\n        /**\n         * Return a ReadWrite stream that parses the streamed chunks as JSON. Each streamed chunk\n         * must be a fully defined JSON string in utf8.\n         * @param format: @type SerializationFormats defaults SerializationFormats.utf8\n         * @param emitError: @type boolean Whether or not to emit an error when\n         * failing to parse. An error will automatically close the stream.\n         * Defaults to true.\n         * @param reviver: @type (key: any, value: any) => any Optional reviver function for JSON.parse\n         */\n        parse,",
            "file_3": "const { parse } = strom();\n\n// Example usage of parse function with reviver\nconst reviver = (key, value) => {\n    if (key === 'date') {\n        return new Date(value);\n    }\n    return value;\n};\nconst parseStream = parse(SerializationFormats.utf8, true, reviver);\n\n// New: Example usage of parse function without reviver\nconst parseStreamWithoutReviver = parse(SerializationFormats.utf8, true);"
        }
    },
    {
        "repo": "angular-2-navbar",
        "content": "'angular-2-navbar/navbar.service.ts'\n:import { Injectable, Injector } from '@angular/core';\n\nexport interface NavbarItem {\n  route: string;\n  label: string;\n  weight?: number;\n  canDisplay?: Function[];\n}\n\nexport type NavbarItems = NavbarItem[];\n\n@Injectable()\nexport class NavbarService {\n\n  constructor(private items: NavbarItems, private injector: Injector) {\n    this.items = this.items.map((item) => {\n      if (item.weight === undefined) {\n        item.weight = 0;\n      }\n      return item;\n    });\n  }\n\n  getNavbarItems() {\n    const canDisplay = (item) => {\n      if (!item.canDisplay || !item.canDisplay.length) {\n        return true;\n      }\n      return item.canDisplay.filter((guard) => this.injector.get(guard).canActivate(item)).length;\n    };\n    return this.items\n      .filter((item) => canDisplay(item))\n      .sort((a: NavbarItem, b: NavbarItem) => {\n        if (a.weight === b.weight) {\n          return 0;\n        }\n        if (a.weight < b.weight) {\n          return -1;\n        }\n        return 1;\n      });\n  }\n\n}\n\n\n'angular-2-navbar/navbar.component.ts'\n:import { Component, OnInit, ContentChild, ViewChild, ViewContainerRef, TemplateRef, DoCheck } from '@angular/core';\nimport { NavbarService, NavbarItems } from './navbar.service';\n\n@Component({\n  selector: 'app-navbar',\n  templateUrl: './navbar.component.html',\n  styleUrls: ['./navbar.component.scss']\n})\nexport class NavbarComponent implements OnInit, DoCheck {\n\n  private items: NavbarItems;\n\n  @ContentChild(TemplateRef) customTemplate: TemplateRef<Object>;\n  @ViewChild(TemplateRef) defaultTemplate: TemplateRef<Object>;\n\n  constructor(private viewContainer: ViewContainerRef,\n              private navbarService: NavbarService) {\n   }\n\n  ngOnInit() {\n    this.items = this.navbarService.getNavbarItems();\n  }\n\n  ngDoCheck() {\n\n    if (!this.defaultTemplate && !this.customTemplate) {\n      return;\n    }\n\n    this.viewContainer.clear();\n\n    if (this.customTemplate) {\n      this.viewContainer.createEmbeddedView.call(this.viewContainer, this.customTemplate, {\n        items: this.items\n      });\n    } else {\n      this.viewContainer.createEmbeddedView.call(this.viewContainer, this.defaultTemplate, {\n        items: this.items\n      });\n    }\n  }\n\n}\n\n'angular-2-navbar/navbar.module.ts'\n:import { NgModule, ModuleWithProviders, Injector, OpaqueToken } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { NavbarComponent } from './navbar.component';\nimport { NavbarService, NavbarItems } from './navbar.service';\n\nconst NAVBAR_ITEMS = new OpaqueToken('NAVBAR_ITEMS');\n\nfunction navbarServiceFactory(itemsCollection: NavbarItems[], injector: Injector) {\n  let allItems = itemsCollection.reduce((aggregate, items) => aggregate.concat(items), []);\n  return new NavbarService(allItems, injector);\n}\n\nexport function provideItems(items: NavbarItems): any {\n  return [\n    {provide: NAVBAR_ITEMS, multi: true, useValue: items}\n  ];\n}\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule\n  ],\n  exports: [\n    NavbarComponent\n  ],\n  declarations: [NavbarComponent]\n})\nexport class NavbarModule {\n\n  static forChild(items: NavbarItems): ModuleWithProviders {\n    const providers = provideItems(items);\n    return {ngModule: NavbarModule, providers: [providers]};\n  }\n\n  static forRoot(items: NavbarItems = []): ModuleWithProviders {\n\n    let providers = [{\n      provide: NavbarService,\n      useFactory: navbarServiceFactory,\n      deps: [NAVBAR_ITEMS, Injector]\n    }];\n\n    if (items.length) {\n      providers.push(provideItems(items));\n    }\n\n    return {\n      ngModule: NavbarModule,\n      providers: providers\n    };\n  }\n\n  constructor(private navbarService: NavbarService) {}\n\n}\n\n\n",
        "called_code_segment_file_1": "getNavbarItems() { const canDisplay = (item) => { if (!item.canDisplay || !item.canDisplay.length) { return true; } return item.canDisplay.filter((guard) => this.injector.get(guard).canActivate(item)).length; }; return this.items .filter((item) => canDisplay(item)) .sort((a: NavbarItem, b: NavbarItem) => { if (a.weight === b.weight) { return 0; } if (a.weight < b.weight) { return -1; } return 1; }); }",
        "invoking_code_segment_file_2": "ngOnInit() { this.items = this.navbarService.getNavbarItems(); }",
        "called_code_segment_file_2": "ngDoCheck() { if (!this.defaultTemplate && !this.customTemplate) { return; } this.viewContainer.clear(); if (this.customTemplate) { this.viewContainer.createEmbeddedView.call(this.viewContainer, this.customTemplate, { items: this.items }); } else { this.viewContainer.createEmbeddedView.call(this.viewContainer, this.defaultTemplate, { items: this.items }); } }",
        "using_code_segment_file_3": "constructor(private navbarService: NavbarService) {}",
        "feature_description": "Add a feature to allow dynamic hiding and showing of navbar items based on user roles.",
        "detailed_feature_description": "Modify the getNavbarItems method in NavbarService to include a new parameter for user roles. Update the canDisplay function to check if the item should be displayed based on the user's roles. Update the NavbarComponent to pass the user roles to the NavbarService. Ensure the NavbarModule is updated to handle the new parameter if necessary.",
        "modified_complete_code": {
            "navbar.service.ts": "export class NavbarService { constructor(private items: NavbarItems, private injector: Injector) { this.items = this.items.map((item) => { if (item.weight === undefined) { item.weight = 0; } return item; }); } getNavbarItems(userRoles: string[]) { #Modify const canDisplay = (item) => { if (!item.canDisplay || !item.canDisplay.length) { return true; } return item.canDisplay.filter((guard) => this.injector.get(guard).canActivate(item, userRoles)).length; }; return this.items .filter((item) => canDisplay(item)) .sort((a: NavbarItem, b: NavbarItem) => { if (a.weight === b.weight) { return 0; } if (a.weight < b.weight) { return -1; } return 1; }); } }",
            "navbar.component.ts": "export class NavbarComponent implements OnInit, DoCheck { private items: NavbarItems; @ContentChild(TemplateRef) customTemplate: TemplateRef<Object>; @ViewChild(TemplateRef) defaultTemplate: TemplateRef<Object>; constructor(private viewContainer: ViewContainerRef, private navbarService: NavbarService) { } ngOnInit() { #Modify this.items = this.navbarService.getNavbarItems(['admin']); } ngDoCheck() { if (!this.defaultTemplate && !this.customTemplate) { return; } this.viewContainer.clear(); if (this.customTemplate) { this.viewContainer.createEmbeddedView.call(this.viewContainer, this.customTemplate, { items: this.items }); } else { this.viewContainer.createEmbeddedView.call(this.viewContainer, this.defaultTemplate, { items: this.items }); } } }",
            "navbar.module.ts": "export function navbarServiceFactory(itemsCollection: NavbarItems[], injector: Injector) { let allItems = itemsCollection.reduce((aggregate, items) => aggregate.concat(items), []); return new NavbarService(allItems, injector); } export function provideItems(items: NavbarItems): any { return [ {provide: NAVBAR_ITEMS, multi: true, useValue: items} ]; } @NgModule({ imports: [ CommonModule, RouterModule ], exports: [ NavbarComponent ], declarations: [NavbarComponent] }) export class NavbarModule { static forChild(items: NavbarItems): ModuleWithProviders { const providers = provideItems(items); return {ngModule: NavbarModule, providers: [providers]}; } static forRoot(items: NavbarItems = []): ModuleWithProviders { let providers = [{ provide: NavbarService, useFactory: navbarServiceFactory, deps: [NAVBAR_ITEMS, Injector] }]; if (items.length) { providers.push(provideItems(items)); } return { ngModule: NavbarModule, providers: providers }; } constructor(private navbarService: NavbarService) {} }"
        }
    },
    {
        "repo": "totvsdevelopers-poui-demo",
        "content": "'totvsdevelopers-poui-demo/src/app/groups/group.service.ts'\n:import { HttpClient } from '@angular/common/http';\nimport { Injectable } from '@angular/core';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class GroupService {\n\n  constructor(private http: HttpClient) { }\n\n  public getData() {\n    return this.http.get(`/api/v1/products-groups`);\n  }\n\n  public save(data: any ) {\n    return this.http.post(`/api/v1/products-groups`, data);\n  }\n\n  public update(data: any ) {\n    return this.http.put(`/api/v1/products-groups/${data.id}`, data);\n  }\n\n  public delete(id: string ) {\n    return this.http.delete(`/api/v1/products-groups/${id}`);\n  }\n\n  public findById(id: string) {\n    return this.http.get(`/api/v1/products-groups/${id}`);\n  }\n}\n\n'totvsdevelopers-poui-demo/src/app/groups/form/form.component.ts'\n:import { Component, OnInit, ViewChild } from '@angular/core';\nimport { FormBuilder, FormControl, FormGroup, Validators } from '@angular/forms';\nimport { ActivatedRoute, Router } from '@angular/router';\nimport { PoBreadcrumb, PoDynamicFormComponent, PoDynamicFormField, PoNotificationService } from '@po-ui/ng-components';\nimport { Location } from '@angular/common'\nimport { Observable } from 'rxjs';\nimport { GroupService } from '../group.service';\n\n@Component({\n  selector: 'app-form',\n  templateUrl: './form.component.html',\n  styleUrls: ['./form.component.scss']\n})\nexport class FormComponent implements OnInit {\n  @ViewChild(PoDynamicFormComponent, { static: true }) dynamicForm: PoDynamicFormComponent;\n\n  public isBusy: boolean = false;\n  public editMode: boolean = false;\n\n  public readonly formFields: PoDynamicFormField[] = [\n    {\n      property: 'id',\n      required: true,\n      label: 'Codigo',\n      gridColumns: 2,\n      maxLength: 4,\n      placeholder: 'Codigo'\n    },\n    {\n      label: 'Descricao',\n      property: 'description',\n      required: true,\n      gridColumns: 6,\n      placeholder: 'Descricao do grupo',\n    },\n  ];\n  \n  public readonly breadcrumb: PoBreadcrumb = {\n    items: [\n      { label: 'Produtos', link: '/' },\n      { label: 'Cadastro de produto' },\n    ]\n  };\n\n  get isFormInvalid(): boolean {\n    if (this.dynamicForm)\n      return this.dynamicForm.form.invalid as boolean;\n    return true;\n  }\n\n  constructor(\n    private notificationService: PoNotificationService,\n    private service: GroupService,\n    private router: Router,\n    private route: ActivatedRoute,\n    private location: Location,\n  ) {\n  }\n\n  ngOnInit(): void {\n    const id = this.route.snapshot.params[\"id\"];\n    if (id) {\n      this.editMode = true;\n      this.isBusy = true;\n      this.service.findById(id).subscribe({\n        next: (product: any) => this.dynamicForm.value = product,\n        complete: () => this.isBusy = false\n      })\n    }\n  }\n\n  onCancelClick(): void {\n    this.location.back();\n  }\n\n  onSaveClick(): void {\n    this.isBusy = true;\n    this.save(this.dynamicForm.form.value)\n      .subscribe({\n        next: () => {\n          this.notificationService.success('Grupo salvo com sucesso');\n          this.router.navigate([\"groups\"]);\n        },\n        error: err => this.isBusy = false,\n        complete: () => this.isBusy = false\n      });\n    }\n    \n  onSaveAndNewClick(): void {\n    this.isBusy = true;\n    this.save(this.dynamicForm.form.value)\n      .subscribe({\n        next: () => {\n          this.notificationService.success('Grupo salvo com sucesso');\n          this.router.navigate([\"groups\", \"create\"]);\n        },\n        error: err => this.isBusy = false,\n        complete: () => this.isBusy = false\n      });\n  }\n\n  private save(data: any): Observable<any> {\n    if (this.editMode) \n      return this.service.update(data);\n    return this.service.save(data);\n  }\n\n}\n\n'totvsdevelopers-poui-demo/src/app/groups/form/form.component.spec.ts'\n:import { ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { FormComponent } from './form.component';\n\ndescribe('FormComponent', () => {\n  let component: FormComponent;\n  let fixture: ComponentFixture<FormComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      declarations: [ FormComponent ]\n    })\n    .compileComponents();\n  });\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(FormComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});\n\n",
        "called_code_segment_file_1": "public save(data: any): Observable<any> {\n    if (this.editMode)\n      return this.service.update(data);\n    return this.service.save(data);\n  }",
        "invoking_code_segment_file_2": "onSaveClick(): void {\n    this.isBusy = true;\n    this.save(this.dynamicForm.form.value)\n      .subscribe({\n        next: () => {\n          this.notificationService.success('Grupo salvo com sucesso');\n          this.router.navigate([\"groups\"]);\n        },\n        error: err => this.isBusy = false,\n        complete: () => this.isBusy = false\n      });\n    }\n    \n  onSaveAndNewClick(): void {\n    this.isBusy = true;\n    this.save(this.dynamicForm.form.value)\n      .subscribe({\n        next: () => {\n          this.notificationService.success('Grupo salvo com sucesso');\n          this.router.navigate([\"groups\", \"create\"]);\n        },\n        error: err => this.isBusy = false,\n        complete: () => this.isBusy = false\n      });\n  }",
        "called_code_segment_file_2": "public save(data: any): Observable<any> {\n    if (this.editMode)\n      return this.service.update(data);\n    return this.service.save(data);\n  }",
        "using_code_segment_file_3": "public save(data: any ) {\n    return this.http.post(`/api/v1/products-groups`, data);\n  }\n\n  public update(data: any ) {\n    return this.http.put(`/api/v1/products-groups/${data.id}`, data);\n  }",
        "feature_description": "Add validation to ensure that the 'description' field in the form is unique before saving or updating.",
        "detailed_feature_description": "Modify the save method in FormComponent to check if the description already exists. If it does, show an error notification and prevent saving. Update the onSaveClick and onSaveAndNewClick methods to handle this validation and notify the user accordingly.",
        "modified_complete_code": {
            "file_1": "public save(data: any): Observable<any> {\n    if (this.editMode)\n      return this.service.update(data);\n    return this.service.save(data);\n  }",
            "file_2": "onSaveClick(): void {\n    this.isBusy = true;\n    this.validateDescription(this.dynamicForm.form.value.description).subscribe({\n      next: (isValid) => {\n        if (isValid) {\n          this.save(this.dynamicForm.form.value)\n            .subscribe({\n              next: () => {\n                this.notificationService.success('Grupo salvo com sucesso');\n                this.router.navigate([\"groups\"]);\n              },\n              error: err => this.isBusy = false,\n              complete: () => this.isBusy = false\n            });\n        } else {\n          this.notificationService.error('Descrição já existe');\n          this.isBusy = false;\n        }\n      },\n      error: err => this.isBusy = false\n    });\n  }\n  \n  onSaveAndNewClick(): void {\n    this.isBusy = true;\n    this.validateDescription(this.dynamicForm.form.value.description).subscribe({\n      next: (isValid) => {\n        if (isValid) {\n          this.save(this.dynamicForm.form.value)\n            .subscribe({\n              next: () => {\n                this.notificationService.success('Grupo salvo com sucesso');\n                this.router.navigate([\"groups\", \"create\"]);\n              },\n              error: err => this.isBusy = false,\n              complete: () => this.isBusy = false\n            });\n        } else {\n          this.notificationService.error('Descrição já existe');\n          this.isBusy = false;\n        }\n      },\n      error: err => this.isBusy = false\n    });\n  }\n  \n  #New\n  private validateDescription(description: string): Observable<boolean> {\n    return this.service.findByDescription(description).pipe(\n      map(exists => !exists)\n    );\n  }",
            "file_3": "public save(data: any ) {\n    return this.http.post(`/api/v1/products-groups`, data);\n  }\n\n  public update(data: any ) {\n    return this.http.put(`/api/v1/products-groups/${data.id}`, data);\n  }\n\n  #New\n  public findByDescription(description: string) {\n    return this.http.get(`/api/v1/products-groups/description/${description}`);\n  }"
        }
    },
    {
        "repo": "twitch_tools",
        "content": "'twitch_tools/9armbot-2.0/services/commands/give-coin.ts'\n:import { DataResult, ErrorResult } from '../bot'\nimport Player from '../models/player'\nimport prisma from '../../../prisma/client'\n\nexport interface GiveCoinResult extends DataResult {\n  data: number\n}\n\nasync function giveCoin(\n  toUsername: string,\n  amount = 10,\n): Promise<GiveCoinResult> {\n  const player = await Player.withUsername(toUsername)\n  const currentCoin = await player.giveCoin(amount)\n  return { data: currentCoin }\n}\n\nasync function deductCoin(\n  toUsername: string,\n  amount: number,\n): Promise<GiveCoinResult | ErrorResult> {\n  const player = await Player.withUsername(toUsername)\n\n  if (player.info.coins < amount) {\n    return { error: 'not_enough_coin' }\n  }\n\n  const updatedPlayer = await prisma.player.update({\n    where: { username: player.username },\n    data: { coins: player.info.coins - amount },\n  })\n\n  return { data: updatedPlayer.coins }\n}\n\nasync function giveCoinToList(\n  giveoutList: Array<string>,\n  amount: number = 1,\n): Promise<GiveCoinResult> {\n  const players = await prisma.player.updateMany({\n    where: { username: { in: giveoutList.map((name) => name.toLowerCase()) } },\n    data: { coins: { increment: amount } },\n  })\n\n  return { data: players.count } // TODO: have different return code\n}\n\nexport { giveCoin, giveCoinToList, deductCoin }\n\n'twitch_tools/9armbot-2.0/services/bot.ts'\n:import { Db } from './db'\nimport gacha from './commands/gacha'\nimport { giveCoin, giveCoinToList, deductCoin } from './commands/give-coin'\nimport { allin } from './commands/allin'\nimport marketcap from './commands/marketcap'\n\nconst db = new Db()\n\nexport type Result = DataResult | ErrorResult\n\nexport interface DataResult {\n  data: number | Record<string, unknown>\n}\n\nexport interface ErrorResult {\n  error: string\n}\n\ninterface CoinResult extends DataResult {\n  data: number\n}\n\nexport function isError(result: Result): result is ErrorResult {\n  return (result as ErrorResult).error !== undefined\n}\n\nexport const commands = {\n  coin: async (username?: string | null): Promise<CoinResult | ErrorResult> => {\n    if (!username) {\n      return { error: 'input_invalid' }\n    }\n\n    const player = await db.getPlayerbyUsername(username)\n    if (!player) {\n      return { error: 'player_not_found' }\n    }\n\n    return { data: player.coins }\n  },\n  gacha,\n  allin,\n  giveCoin,\n  giveCoinToList,\n  deductCoin,\n  marketcap,\n}\n\nexport default commands\n\n'twitch_tools/9armbot-2.0/services/commands/allin.ts'\n:import { ErrorResult, DataResult } from '../bot'\nimport { Db } from '../db'\nimport setting from '../setting'\n\nconst db = new Db()\n\nexport interface AllInResult extends DataResult {\n  data: {\n    state: 'win' | 'lose' | 'win_jackpot'\n    bet: number\n    win: number\n    balance: number\n  }\n}\n\nexport async function allin(\n  username?: string | null,\n): Promise<AllInResult | ErrorResult> {\n  if (!username) {\n    return { error: 'input_invalid' }\n  }\n\n  const player = await db.getPlayerbyUsername(username)\n\n  if (!player) {\n    return { error: 'player_not_found' }\n  }\n\n  let { coins } = player\n\n  if (coins == 0) {\n    return { error: 'not_enough_coin' }\n  }\n\n  const bet = coins\n  let result = {\n    bet,\n    win: 0,\n    state: 'lose',\n    balance: 0,\n  }\n\n  coins = 0\n\n  const dice = Math.random()\n\n  if (dice < setting.jackpotRate) {\n    // Win jackpot\n    const winAmount = Math.round(bet * (5 + Math.random() * 5)) * 2\n    coins += winAmount\n\n    result.win = winAmount\n    result.state = 'win_jackpot'\n    result.balance = coins\n  } else if (dice < setting.gachaRate) {\n    // Win\n    const winAmount = Math.round(bet * (2 + Math.random() * 3)) * 2\n    coins += winAmount\n\n    result.win = winAmount\n    result.state = 'win'\n    result.balance = coins\n  } else {\n    // Lose\n    result.balance = coins\n  }\n\n  await db.updatePlayer(player.username, { coins })\n\n  return { data: result } as AllInResult\n}\n\n",
        "called_code_segment_file_1": "async function giveCoin(toUsername: string, amount = 10): Promise<GiveCoinResult> {\n  const player = await Player.withUsername(toUsername)\n  const currentCoin = await player.giveCoin(amount)\n  return { data: currentCoin }\n}",
        "invoking_code_segment_file_2": "giveCoin,",
        "called_code_segment_file_2": "giveCoin,",
        "using_code_segment_file_3": "const result = await commands.giveCoin(username);\nif (isError(result)) {\n  return { error: result.error }\n}\nreturn { data: result.data }",
        "feature_description": "Add a feature to allow giving coins to multiple users at once.",
        "detailed_feature_description": "Modify the `giveCoin` function in `#file 1` to accept an array of usernames. Update `#file 2` to handle this new feature and ensure `#file 3` can use the updated `giveCoin` function to give coins to multiple users.",
        "modified_complete_code": {
            "#file 1": "async function giveCoin(toUsername: string | string[], amount = 10): Promise<GiveCoinResult> {\n  if (Array.isArray(toUsername)) {\n    const players = await prisma.player.updateMany({\n      where: { username: { in: toUsername.map(name => name.toLowerCase()) } },\n      data: { coins: { increment: amount } }\n    })\n    return { data: players.count }\n  }\n  const player = await Player.withUsername(toUsername)\n  const currentCoin = await player.giveCoin(amount)\n  return { data: currentCoin }\n}",
            "#file 2": "giveCoin: async (username?: string | string[] | null): Promise<CoinResult | ErrorResult> => {\n  if (!username) {\n    return { error: 'input_invalid' }\n  }\n  const result = await giveCoin(username)\n  if (isError(result)) {\n    return { error: result.error }\n  }\n  return { data: result.data }\n},",
            "#file 3": "const result = await commands.giveCoin(usernames);\nif (isError(result)) {\n  return { error: result.error }\n}\nreturn { data: result.data }"
        }
    },
    {
        "repo": "angular-springboot-demo",
        "content": "'angular-springboot-demo/frontend/src/app/login/login.component.ts'\n:import {Component} from '@angular/core';\nimport {Router} from '@angular/router';\nimport {AuthService} from '../auth/auth.service';\nimport {MatSnackBar} from '@angular/material/snack-bar';\nimport jwtDecode, {JwtPayload} from 'jwt-decode';\n\n@Component({\n    selector: 'app-login',\n    templateUrl: './login.component.html',\n    styleUrls: ['./login.component.css']\n})\nexport class LoginComponent {\n\n    username: string = \"\";\n    password: string = \"\";\n    message: string = \"\";\n\n    constructor(private authService: AuthService, private router: Router, private snackBar: MatSnackBar) {\n    }\n\n    public login(): void {\n        sessionStorage.removeItem(\"app.token\");\n\n        this.authService.login(this.username, this.password)\n            .subscribe({\n                next: (token) => {\n                    sessionStorage.setItem(\"app.token\", token);\n\n                    const decodedToken = jwtDecode<JwtPayload>(token);\n                    // @ts-ignore\n                    sessionStorage.setItem(\"app.roles\",  decodedToken.scope);\n\n                    this.router.navigateByUrl(\"/persons\");\n                },\n                error: (error) => this.snackBar.open(`Login failed: ${error.status}`, \"OK\")\n            });\n    }\n}\n\n'angular-springboot-demo/frontend/src/app/app-routing.module.ts'\n:import {NgModule} from '@angular/core';\nimport {RouterModule, Routes} from '@angular/router';\nimport {PersonComponent} from './person/person.component';\nimport {LoginComponent} from './login/login.component';\nimport {AuthGuard} from './auth/auth-guard.service';\nimport {PersonEditComponent} from './person/edit/person-edit.component';\n\nconst routes: Routes = [\n    {path: '', redirectTo: 'persons', pathMatch: 'full'},\n    {path: 'persons', component: PersonComponent, canActivate: [AuthGuard], data: {role: 'ROLE_USER'}},\n    {path: 'persons/:id', component: PersonEditComponent, canActivate: [AuthGuard], data: {role: 'ROLE_USER'}},\n    {path: 'login', component: LoginComponent},\n    {path: '**', redirectTo: 'persons'}\n];\n\n@NgModule({\n    imports: [RouterModule.forRoot(routes)],\n    exports: [RouterModule]\n})\nexport class AppRoutingModule {\n}\n\n'angular-springboot-demo/frontend/src/app/person/edit/person-edit.component.spec.ts'\n:import {ComponentFixture, TestBed} from '@angular/core/testing';\n\nimport {PersonEditComponent} from './person-edit.component';\nimport {HttpClientModule} from '@angular/common/http';\nimport {ActivatedRoute, RouterModule} from '@angular/router';\nimport {MatSnackBarModule} from '@angular/material/snack-bar';\nimport {AppRoutingModule} from '../../app-routing.module';\nimport {FormsModule} from '@angular/forms';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatInputModule} from '@angular/material/input';\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\n\ndescribe('PersonEditComponent', () => {\n    let component: PersonEditComponent;\n    let fixture: ComponentFixture<PersonEditComponent>;\n\n    beforeEach(async () => {\n        await TestBed.configureTestingModule({\n            declarations: [PersonEditComponent],\n            imports: [\n                HttpClientModule,\n                AppRoutingModule,\n                MatSnackBarModule,\n                FormsModule,\n                MatFormFieldModule,\n                MatInputModule,\n                BrowserAnimationsModule\n            ]\n        })\n            .compileComponents();\n\n        fixture = TestBed.createComponent(PersonEditComponent);\n        component = fixture.componentInstance;\n        fixture.detectChanges();\n    });\n\n    it('should create', () => {\n        expect(component).toBeTruthy();\n    });\n});\n\n",
        "called_code_segment_file_1": "public login(): void {\n    sessionStorage.removeItem(\"app.token\");\n\n    this.authService.login(this.username, this.password)\n        .subscribe({\n            next: (token) => {\n                sessionStorage.setItem(\"app.token\", token);\n\n                const decodedToken = jwtDecode<JwtPayload>(token);\n                // @ts-ignore\n                sessionStorage.setItem(\"app.roles\",  decodedToken.scope);\n\n                this.router.navigateByUrl(\"/persons\");\n            },\n            error: (error) => this.snackBar.open(`Login failed: ${error.status}`, \"OK\")\n        });\n}",
        "invoking_code_segment_file_2": "login(username: string, password: string): Observable<string> {\n    const credentials = {username, password};\n    return this.http.post<string>(`${this.apiUrl}/login`, credentials, {responseType: 'text' as 'json'});\n}",
        "called_code_segment_file_2": "canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {\n    const requiredRole = route.data['role'];\n    const token = sessionStorage.getItem('app.token');\n    const roles = sessionStorage.getItem('app.roles');\n\n    if (token && roles) {\n        const userRoles = roles.split(' ');\n        if (userRoles.includes(requiredRole)) {\n            return true;\n        }\n    }\n\n    this.router.navigate(['/login']);\n    return false;\n}",
        "using_code_segment_file_3": "const routes: Routes = [\n    {path: '', redirectTo: 'persons', pathMatch: 'full'},\n    {path: 'persons', component: PersonComponent, canActivate: [AuthGuard], data: {role: 'ROLE_USER'}},\n    {path: 'persons/:id', component: PersonEditComponent, canActivate: [AuthGuard], data: {role: 'ROLE_USER'}},\n    {path: 'login', component: LoginComponent},\n    {path: '**', redirectTo: 'persons'}\n];",
        "feature_description": "Add a feature to log the user out after a certain period of inactivity.",
        "detailed_feature_description": "Modify the login method in `LoginComponent` to set a timeout for logging out after a period of inactivity. Update the `AuthGuard` to check for this timeout and redirect to the login page if the timeout has been reached. Ensure the `AppRoutingModule` handles the redirection correctly.",
        "modified_complete_code": {
            "file_1": "export class LoginComponent {\n\n    username: string = \"\";\n    password: string = \"\";\n    message: string = \"\";\n\n    constructor(private authService: AuthService, private router: Router, private snackBar: MatSnackBar) {\n    }\n\n    public login(): void {\n        sessionStorage.removeItem(\"app.token\");\n\n        this.authService.login(this.username, this.password)\n            .subscribe({\n                next: (token) => {\n                    sessionStorage.setItem(\"app.token\", token);\n\n                    const decodedToken = jwtDecode<JwtPayload>(token);\n                    // @ts-ignore\n                    sessionStorage.setItem(\"app.roles\",  decodedToken.scope);\n\n                    // #Modify: Set a timeout for logging out after 30 minutes of inactivity\n                    sessionStorage.setItem(\"app.timeout\", (Date.now() + 30 * 60 * 1000).toString());\n\n                    this.router.navigateByUrl(\"/persons\");\n                },\n                error: (error) => this.snackBar.open(`Login failed: ${error.status}`, \"OK\")\n            });\n    }\n}",
            "file_2": "export class AuthGuard implements CanActivate {\n\n    constructor(private router: Router) {\n    }\n\n    canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {\n        const requiredRole = route.data['role'];\n        const token = sessionStorage.getItem('app.token');\n        const roles = sessionStorage.getItem('app.roles');\n        const timeout = sessionStorage.getItem('app.timeout');\n\n        // #Modify: Check if the timeout has been reached\n        if (timeout && Date.now() > parseInt(timeout)) {\n            sessionStorage.removeItem('app.token');\n            sessionStorage.removeItem('app.roles');\n            sessionStorage.removeItem('app.timeout');\n            this.router.navigate(['/login']);\n            return false;\n        }\n\n        if (token && roles) {\n            const userRoles = roles.split(' ');\n            if (userRoles.includes(requiredRole)) {\n                return true;\n            }\n        }\n\n        this.router.navigate(['/login']);\n        return false;\n    }\n}",
            "file_3": "const routes: Routes = [\n    {path: '', redirectTo: 'persons', pathMatch: 'full'},\n    {path: 'persons', component: PersonComponent, canActivate: [AuthGuard], data: {role: 'ROLE_USER'}},\n    {path: 'persons/:id', component: PersonEditComponent, canActivate: [AuthGuard], data: {role: 'ROLE_USER'}},\n    {path: 'login', component: LoginComponent},\n    {path: '**', redirectTo: 'persons'}\n];\n\n@NgModule({\n    imports: [RouterModule.forRoot(routes)],\n    exports: [RouterModule]\n})\nexport class AppRoutingModule {\n}"
        }
    },
    {
        "repo": "typescript-paths",
        "content": "'typescript-paths/packages/typescript-paths/src/logger.ts'\n:export enum LogLevel {\n\tNone,\n\tError,\n\tWarning,\n\tInfo,\n\tDebug,\n\tTrace,\n}\n\nexport type LogLevelString = \"none\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\"\n\nexport function convertLogLevel(level?: LogLevelString) {\n\tswitch (level) {\n\t\tcase \"none\":\n\t\t\treturn LogLevel.None\n\t\tcase \"error\":\n\t\t\treturn LogLevel.Error\n\t\tcase \"warn\":\n\t\t\treturn LogLevel.Warning\n\t\tcase \"info\":\n\t\t\treturn LogLevel.Info\n\t\tcase \"debug\":\n\t\t\treturn LogLevel.Debug\n\t\tcase \"trace\":\n\t\t\treturn LogLevel.Trace\n\t\tdefault:\n\t\t\treturn undefined\n\t}\n}\n\ninterface Options {\n\tlogLevel: LogLevel\n\tcolors?: boolean\n\tID?: string\n}\n\nexport interface LogFunc {\n\t(level: LogLevel, ...args: any[]): void\n}\n\nconst Reset = \"\\x1b[0m\"\nconst FgRed = \"\\x1b[31m\"\nconst FgYellow = \"\\x1b[33m\"\nconst FgBlue = \"\\x1b[34m\"\nconst FgCyan = \"\\x1b[36m\"\nconst FgMagenta = \"\\x1b[35m\"\n\nexport function fromTYPESCRIPT_PATHS_LOG_LEVEL() {\n\tconst env = process.env[\"TYPESCRIPT_PATHS_LOG_LEVEL\"]\n\tswitch (env) {\n\t\tcase \"none\":\n\t\t\treturn LogLevel.None\n\t\tcase \"error\":\n\t\t\treturn LogLevel.Error\n\t\tcase \"warn\":\n\t\t\treturn LogLevel.Warning\n\t\tcase \"info\":\n\t\t\treturn LogLevel.Info\n\t\tcase \"debug\":\n\t\t\treturn LogLevel.Debug\n\t\tcase \"trace\":\n\t\t\treturn LogLevel.Trace\n\t\tdefault:\n\t\t\treturn undefined\n\t}\n}\n\nexport function createLogger({\n\tlogLevel = fromTYPESCRIPT_PATHS_LOG_LEVEL() || LogLevel.Info,\n\tcolors = true,\n\tID = \"typescript-paths\",\n}: Partial<Options> = {}): LogFunc {\n\treturn function log(level, ...args) {\n\t\tif (logLevel < level) {\n\t\t\treturn\n\t\t}\n\t\tif (ID) {\n\t\t\targs.unshift(`[${ID}]:`)\n\t\t}\n\t\tif (colors) {\n\t\t\targs = args.map(a => {\n\t\t\t\tif (typeof a !== \"string\") return a\n\t\t\t\tswitch (level) {\n\t\t\t\t\tcase LogLevel.Error:\n\t\t\t\t\t\treturn FgRed + a + Reset\n\t\t\t\t\tcase LogLevel.Warning:\n\t\t\t\t\t\treturn FgYellow + a + Reset\n\t\t\t\t\tcase LogLevel.Info:\n\t\t\t\t\t\treturn FgBlue + a + Reset\n\t\t\t\t\tcase LogLevel.Debug:\n\t\t\t\t\t\treturn FgCyan + a + Reset\n\t\t\t\t\tcase LogLevel.Trace:\n\t\t\t\t\t\treturn FgMagenta + a + Reset\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tswitch (level) {\n\t\t\tcase LogLevel.Error:\n\t\t\t\tconsole.error(...args)\n\t\t\t\tbreak\n\t\t\tcase LogLevel.Warning:\n\t\t\t\tconsole.warn(...args)\n\t\t\t\tbreak\n\t\t\tcase LogLevel.Info:\n\t\t\t\tconsole.info(...args)\n\t\t\t\tbreak\n\t\t\tcase LogLevel.Debug:\n\t\t\t\tconsole.log(...args)\n\t\t\t\tbreak\n\t\t\tcase LogLevel.Trace:\n\t\t\t\tconsole.log(...args)\n\t\t\t\tbreak\n\t\t}\n\t}\n}\n\n'typescript-paths/packages/typescript-paths/src/paths.ts'\n:import fs from \"fs\"\nimport { builtinModules } from \"module\"\nimport path from \"path\"\nimport ts from \"typescript\"\nimport { createLogger, LogFunc, LogLevel } from \"./logger\"\n\nexport interface Mapping {\n\tpattern: string\n\tprefix: string\n\tsuffix: string\n\twildcard: boolean\n\ttargets: string[]\n}\n\nexport interface TsConfigPayload {\n\tfilePath?: string\n\tcompilerOptions: ts.CompilerOptions\n\tfileNames: string[]\n\treferences?: TsConfigPayload[]\n\textends?: string\n}\n\nexport function getTsConfig({\n\ttsConfigPath,\n\tlog = createLogger(),\n\thost = ts.sys,\n}: {\n\ttsConfigPath: string\n\tlog?: LogFunc\n\thost?: ts.ParseConfigHost\n}): undefined | TsConfigPayload {\n\tconst { error, config } = ts.readConfigFile(tsConfigPath, host.readFile)\n\tif (error) {\n\t\tlet hasError = false\n\t\tswitch (error.category) {\n\t\t\tcase ts.DiagnosticCategory.Error:\n\t\t\t\tlog(LogLevel.Error, error.messageText)\n\t\t\t\thasError = true\n\t\t\t\tbreak\n\t\t}\n\t\tif (hasError) return undefined\n\t}\n\n\tlet {\n\t\toptions: compilerOptions,\n\t\terrors,\n\t\tfileNames,\n\t\tprojectReferences,\n\t} = ts.parseJsonConfigFileContent(config, host, path.resolve(path.dirname(tsConfigPath)))\n\tif (errors.length > 0) {\n\t\tlet hasError = false\n\t\tfor (const error of errors) {\n\t\t\tswitch (error.category) {\n\t\t\t\tcase ts.DiagnosticCategory.Error:\n\t\t\t\t\tlog(LogLevel.Error, error.messageText)\n\t\t\t\t\thasError = true\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (hasError) return undefined\n\t}\n\n\tconst ret: TsConfigPayload = {\n\t\tfilePath: path.resolve(tsConfigPath),\n\t\tcompilerOptions,\n\t\tfileNames: fileNames.map(path.normalize),\n\t\textends: config.extends,\n\t}\n\n\tif (projectReferences) {\n\t\tret.references = []\n\t\tfor (const r of projectReferences) {\n\t\t\tlet tsConfigPath = r.path\n\t\t\ttry {\n\t\t\t\tconst stat = fs.lstatSync(tsConfigPath)\n\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\ttsConfigPath = path.join(tsConfigPath, \"tsconfig.json\")\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tconst error = err as Error\n\t\t\t\tlog(LogLevel.Error, error.message)\n\t\t\t\treturn undefined\n\t\t\t}\n\n\t\t\tconst cfg = getTsConfig({ tsConfigPath, log, host })\n\t\t\tif (cfg) ret.references.push(cfg)\n\t\t}\n\t}\n\n\treturn ret\n}\n\nexport function createMappings({\n\tpaths,\n\tlog = createLogger(),\n\trespectCoreModule = true,\n}: {\n\tpaths: ts.MapLike<string[]>\n\tlog?: LogFunc\n\trespectCoreModule?: boolean\n}): Mapping[] {\n\tconst countWildcard = (value: string) => value.match(/\\*/g)?.length ?? 0\n\n\tconst mappings: Mapping[] = []\n\tfor (const pattern of Object.keys(paths)) {\n\t\tif (countWildcard(pattern) > 1) {\n\t\t\tlog(LogLevel.Warning, `Pattern '${pattern}' can have at most one '*' character.`)\n\t\t\tcontinue\n\t\t}\n\t\tconst wildcard = pattern.indexOf(\"*\")\n\t\tif (respectCoreModule) {\n\t\t\tlet skip = false\n\t\t\tfor (const key of builtinModules) {\n\t\t\t\tif (pattern === key || pattern.startsWith(key + \"/\")) {\n\t\t\t\t\tlog(LogLevel.Warning, `path pattern '${pattern}' is ignored.`)\n\t\t\t\t\tlog(LogLevel.Info, `respect core module '${key}'.`)\n\t\t\t\t\tskip = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skip) continue\n\t\t}\n\t\tconst targets = paths[pattern].filter(target => {\n\t\t\tif (countWildcard(target) > 1) {\n\t\t\t\tlog(\n\t\t\t\t\tLogLevel.Warning,\n\t\t\t\t\t`Substitution '${target}' in pattern '${pattern}' can have at most one '*' character.`,\n\t\t\t\t)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\tif (targets.length === 0) {\n\t\t\tcontinue\n\t\t}\n\t\tif (pattern === \"*\") {\n\t\t\tmappings.push({ wildcard: true, pattern, prefix: \"\", suffix: \"\", targets })\n\t\t\tcontinue\n\t\t}\n\t\tmappings.push({\n\t\t\twildcard: wildcard !== -1,\n\t\t\tpattern,\n\t\t\tprefix: pattern.substring(0, wildcard),\n\t\t\tsuffix: pattern.substring(wildcard + 1),\n\t\t\ttargets,\n\t\t})\n\t}\n\n\tfor (const mapping of mappings) {\n\t\tlog(LogLevel.Debug, `pattern: '${mapping.pattern}' targets: '${mapping.targets}'`)\n\t}\n\n\treturn mappings\n}\n\nexport function isPatternMatch(prefix: string, suffix: string, candidate: string): boolean {\n\treturn (\n\t\tcandidate.length >= prefix.length + suffix.length && candidate.startsWith(prefix) && candidate.endsWith(suffix)\n\t)\n}\n\nexport function findMatch(moduleName: string, mappings: Mapping[]): Mapping | undefined {\n\tlet longestMatchedPrefixLength = -1\n\tlet matched: Mapping | undefined\n\tfor (const mapping of mappings) {\n\t\tconst { wildcard, prefix, suffix, pattern } = mapping\n\t\tif (wildcard && isPatternMatch(prefix, suffix, moduleName)) {\n\t\t\tif (longestMatchedPrefixLength < prefix.length) {\n\t\t\t\tlongestMatchedPrefixLength = prefix.length\n\t\t\t\tmatched = mapping\n\t\t\t}\n\t\t} else if (moduleName === pattern) {\n\t\t\tmatched = mapping\n\t\t\tbreak\n\t\t}\n\t}\n\treturn matched\n}\n\nexport function resolveModuleName({\n\tmappings,\n\trequest,\n\timporter,\n\tcompilerOptions,\n\thost,\n\tfalllback,\n}: {\n\tcompilerOptions: ts.CompilerOptions\n\tmappings: Mapping[]\n\trequest: string\n\timporter: string\n\thost: ts.ModuleResolutionHost\n\tfalllback?: (moduleName: string) => boolean\n}): string | undefined {\n\tconst matched = findMatch(request, mappings)\n\tif (!matched) {\n\t\treturn undefined\n\t}\n\n\tconst matchedWildcard = request.slice(matched.prefix.length, request.length - matched.suffix.length)\n\n\tfor (const target of matched.targets) {\n\t\tconst updated = matched.wildcard ? target.replace(\"*\", matchedWildcard) : target\n\t\tconst base = (compilerOptions.baseUrl ?? compilerOptions.pathsBasePath) as string\n\t\tconst moduleName = path.resolve(base, updated)\n\t\tconst ext = path.extname(moduleName)\n\t\tswitch (ext) {\n\t\t\tcase \".ts\":\n\t\t\tcase \".tsx\":\n\t\t\tcase \".json\":\n\t\t\t\treturn moduleName\n\t\t\tcase \".js\":\n\t\t\tcase \".jsx\":\n\t\t\t\tif (compilerOptions.module === ts.ModuleKind.NodeNext) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn moduleName\n\t\t}\n\t\tconst result = ts.resolveModuleName(moduleName, importer, compilerOptions, host)\n\t\tif (result?.resolvedModule) {\n\t\t\treturn path.normalize(result.resolvedModule.resolvedFileName)\n\t\t}\n\t\tif (falllback?.(moduleName)) return moduleName\n\t}\n\n\treturn undefined\n}\n\n'typescript-paths/packages/typescript-paths/src/register.ts'\n:import Module from \"module\"\nimport { createHandler, OptionFallback } from \"./handler\"\nimport { convertLogLevel, createLogger, LogLevel, LogLevelString } from \"./logger\"\nimport { TsConfigPayload } from \"./paths\"\n\nexport interface RegisterOptions {\n\ttsConfigPath?: string | TsConfigPayload | Array<string | TsConfigPayload>\n\trespectCoreModule?: boolean\n\tlogLevel?: LogLevelString\n\tcolors?: boolean\n\tloggerID?: string\n}\n\nexport function register({\n\ttsConfigPath,\n\trespectCoreModule,\n\tlogLevel,\n\tcolors,\n\tloggerID,\n\tfalllback,\n}: RegisterOptions & OptionFallback = {}): () => void {\n\tconst log = createLogger({ logLevel: convertLogLevel(logLevel), colors, ID: loggerID })\n\tconst handler = createHandler({ tsConfigPath, respectCoreModule, log, falllback })\n\tif (!handler) {\n\t\treturn () => {}\n\t}\n\n\tconst originalResolveFilename = Module[\"_resolveFilename\"]\n\n\tModule[\"_resolveFilename\"] = function (request: string, parent?: Module, ...args: any[]) {\n\t\tif (!parent) return originalResolveFilename.apply(this, arguments)\n\n\t\tconst moduleName = handler(request, parent.filename)\n\t\tif (moduleName) {\n\t\t\tlog(LogLevel.Debug, `${request} -> ${moduleName}`)\n\t\t\treturn originalResolveFilename.apply(this, [moduleName, parent, ...args])\n\t\t}\n\n\t\treturn originalResolveFilename.apply(this, arguments)\n\t}\n\n\treturn () => {\n\t\tModule[\"_resolveFilename\"] = originalResolveFilename\n\t}\n}\n\n",
        "called_code_segment_file_1": "function createLogger({ logLevel = fromTYPESCRIPT_PATHS_LOG_LEVEL() || LogLevel.Info, colors = true, ID = \"typescript-paths\", }: Partial<Options> = {}): LogFunc {\n  return function log(level, ...args) {\n    if (logLevel < level) {\n      return\n    }\n    if (ID) {\n      args.unshift(`[${ID}]:`)\n    }\n    if (colors) {\n      args = args.map(a => {\n        if (typeof a !== \"string\") return a\n        switch (level) {\n          case LogLevel.Error:\n            return FgRed + a + Reset\n          case LogLevel.Warning:\n            return FgYellow + a + Reset\n          case LogLevel.Info:\n            return FgBlue + a + Reset\n          case LogLevel.Debug:\n            return FgCyan + a + Reset\n          case LogLevel.Trace:\n            return FgMagenta + a + Reset\n        }\n      })\n    }\n    switch (level) {\n      case LogLevel.Error:\n        console.error(...args)\n        break\n      case LogLevel.Warning:\n        console.warn(...args)\n        break\n      case LogLevel.Info:\n        console.info(...args)\n        break\n      case LogLevel.Debug:\n        console.log(...args)\n        break\n      case LogLevel.Trace:\n        console.log(...args)\n        break\n    }\n  }\n}",
        "invoking_code_segment_file_2": "const log = createLogger({ logLevel: convertLogLevel(logLevel), colors, ID: loggerID })",
        "called_code_segment_file_2": "const handler = createHandler({ tsConfigPath, respectCoreModule, log, falllback })",
        "using_code_segment_file_3": "const moduleName = handler(request, parent.filename)",
        "feature_description": "Add a feature to log the resolution process of module names with timestamps.",
        "detailed_feature_description": "Modify the `createLogger` function in `#file 1` to include timestamps in the log messages. Update the `createHandler` function in `#file 2` to use the modified logger. Ensure that the `register` function in `#file 3` correctly handles the new logging format.",
        "modified_complete_code": {
            "#file 1": "function createLogger({ logLevel = fromTYPESCRIPT_PATHS_LOG_LEVEL() || LogLevel.Info, colors = true, ID = \"typescript-paths\", }: Partial<Options> = {}): LogFunc {\n  return function log(level, ...args) {\n    if (logLevel < level) {\n      return\n    }\n    const timestamp = new Date().toISOString()\n    if (ID) {\n      args.unshift(`[${ID}]:`)\n    }\n    args.unshift(`[${timestamp}]:`)\n    if (colors) {\n      args = args.map(a => {\n        if (typeof a !== \"string\") return a\n        switch (level) {\n          case LogLevel.Error:\n            return FgRed + a + Reset\n          case LogLevel.Warning:\n            return FgYellow + a + Reset\n          case LogLevel.Info:\n            return FgBlue + a + Reset\n          case LogLevel.Debug:\n            return FgCyan + a + Reset\n          case LogLevel.Trace:\n            return FgMagenta + a + Reset\n        }\n      })\n    }\n    switch (level) {\n      case LogLevel.Error:\n        console.error(...args)\n        break\n      case LogLevel.Warning:\n        console.warn(...args)\n        break\n      case LogLevel.Info:\n        console.info(...args)\n        break\n      case LogLevel.Debug:\n        console.log(...args)\n        break\n      case LogLevel.Trace:\n        console.log(...args)\n        break\n    }\n  }\n}",
            "#file 2": "const log = createLogger({ logLevel: convertLogLevel(logLevel), colors, ID: loggerID })\n\nconst handler = createHandler({ tsConfigPath, respectCoreModule, log, falllback })",
            "#file 3": "const moduleName = handler(request, parent.filename)\nlog(LogLevel.Debug, `${request} -> ${moduleName}`)"
        }
    },
    {
        "repo": "bchain_business_card",
        "content": "'bchain_business_card/frontend/src/components/ErrorBox.tsx'\n:import Link from \"next/link\";\nimport { useRouter } from \"next/router\";\nimport React, { useEffect, useState } from \"react\";\nimport { Interface } from \"readline\";\nimport { useErrors } from \"../context/TransactionProvider\";\n\ntype parsedError = {\n  errorMessage: String;\n  isContractError: Boolean;\n\n  error: Error;\n};\n\nconst parseContractErrorString = (str) => {\n  let pattern = /panicked at .*.'/;\n  // console.log(str);\n  let exracted = pattern.exec(str);\n  let res = exracted[0];\n  res = res.replace(`\"`, \"\");\n  return res;\n};\n\nconst ErrorBox = () => {\n  // console.log(\"in error box\");\n  let { errorList: errorProps } = useErrors();\n  const [errorList, setErrorList] = useState<parsedError[]>();\n  const { clearError } = useErrors();\n  // if (!errorProps) return <></>;\n  useEffect(() => {\n    //Take passed Errors from props\n    //extract important bits for displaying\n    //push to parsedErrors Array\n    //save to state\n\n    let parsedErrors: parsedError[] = [];\n    if (errorProps?.length > 0) {\n      errorProps.map((error) => {\n        let message = error.message;\n        let contractError = false;\n        // console.log(error);\n        if (message?.search(\"panicked at '\") <= 0 || !message) {\n          console.log(\"Non Smart Contract error passed to ErrorBox\");\n        } else {\n          contractError = true;\n          message = parseContractErrorString(message);\n        }\n        let parsedError: parsedError = {\n          errorMessage: message,\n          isContractError: contractError,\n          error: error,\n        };\n\n        parsedErrors.push(parsedError);\n      });\n    }\n    setErrorList(parsedErrors);\n    // console.log(errorProps);\n  }, [errorProps]);\n\n  //remove selected error from the list of errors\n  //this should force a state update from the useEffect\n  //above\n\n  // console.log(errorList);\n  if (errorList?.length == 0) {\n    console.log(\"nothing to render\");\n    return <></>;\n  }\n\n  return (\n    <>\n      <div\n        className=\"text-xs text-danger \n        border-danger border-1 rounded-sm \n        absolute ml-[15px] mt-[-20px] px-[2px]\n        hover:cursor-pointer\"\n        onClick={() => {\n          clearError(null, true);\n        }}\n      >\n        close all\n      </div>\n      {errorList?.length > 0 &&\n        errorList.map(({ errorMessage, isContractError, error }, index) => (\n          <div\n            key={`error-box-${index}`}\n            className=\"flex flex-col \n            shadow-xl rounded-xl \n            px-[15px] mb-1 \n            bg-warm-gray-200 \n            max-w-min h-min\"\n          >\n            <span\n              className=\"text-sm self-end pt-[2px] hover:(underline cursor-pointer)\"\n              onClick={() => {\n                clearError(index);\n              }}\n            >\n              <p>close</p>\n            </span>\n            <h1\n              className=\"text-md font-mono  \n              w-max font-semibold \n              self-center\n              mx-[35px]\n              mt-[-9px]\"\n            >\n              {isContractError ? (\n                <>Smart Contract exectuion Error:</>\n              ) : (\n                <>Smart Contract related Error:</>\n              )}\n            </h1>\n            <div className=\"\">\n              <span className=\"font-sans text-sm text-gray-500\">Info:</span>\n              <p\n                className=\"text-danger text-md no-underline font-mono \n              w-[full] \n              mt-[-5px] mb-[1px]\"\n              >\n                {errorMessage || \"N/A\"}\n              </p>\n            </div>\n          </div>\n        ))}\n    </>\n  );\n};\n\nexport default ErrorBox;\n\n'bchain_business_card/frontend/src/components/Nav.tsx'\n:import React, { Fragment, useContext, useEffect, useState } from \"react\";\nimport ErrorIcon from \"../public/error-notification.svg\";\nimport NearLogo from \"../public/near-logo.svg\";\nimport SearchIcon from \"../public/search-icon.svg\";\nimport { useNear, NearContext } from \"../context/NearProvider\";\nimport Image from \"next/image\";\nimport ErrorBox from \"./ErrorBox\";\nimport { useErrors } from \"../context/TransactionProvider\";\nimport Link from \"next/link\";\nimport { useRouter } from \"next/router\";\nimport { createContext } from \"react\";\n\ninterface NavContext {\n  setShowSearchBox?: any;\n}\nconst NavContext = createContext<NavContext>({});\nexport function useNavContext() {\n  return useContext(NavContext);\n}\n\nexport const Nav = ({ children }) => {\n  let { wallet, contract } = useNear();\n  let { errorList } = useErrors();\n  let [showErrorBox, setShowErrorBox] = useState(true);\n  let [showSearchBox, setShowSearchBox] = useState(false);\n  let [searchValue, setSearchValue] = useState(\"\");\n  const router = useRouter();\n\n  useEffect(() => {}, [wallet]);\n\n  function signIn() {\n    wallet.requestSignIn({\n      contractId: process.env.NEXT_PUBLIC_CONTRACT_NAME,\n      // pass methodNames to request access to only these\n      // (empty array means requesting access to all)\n      methodNames: [],\n    });\n  }\n\n  function signOut() {\n    wallet.signOut();\n    window.location.replace(window.location.origin + window.location.pathname);\n  }\n  const ctx = { setShowSearchBox };\n  return (\n    <NavContext.Provider value={ctx}>\n      {\n        <div className=\"flex flex-col\">\n          <nav\n            id=\"navbar\"\n            className=\"grid grid-cols-3 \n            items-center gap-1 \n            w-full max-h-[55px] h-full \n            shadow-lg col-auto\"\n          >\n            <section\n              id=\"Left\"\n              className=\"flex flex-row self-center min-h-max h-full\"\n            >\n              <NearLogo className=\"min-w-max\" height={50} width={50} />\n              <Link href=\"/\">\n                <h1\n                  onClick={() => setShowSearchBox(false)}\n                  className=\"flex pt-1.5 text-3xl font-extrabold min-w-max font-mono hover:cursor-pointer\"\n                >\n                  {\"Block Cards\"}\n                </h1>\n              </Link>\n              <div\n                className=\" flex w-full h-full \n            flex justify-center flex-col pr-[30px]\"\n              >\n                <SearchIcon\n                  className=\"self-end hover:cursor-pointer \"\n                  height={30}\n                  width={30}\n                  onClick={() => setShowSearchBox((prev) => !prev)}\n                />\n              </div>\n            </section>\n\n            <section id=\"Center\" className=\"max-h-[50px] grid grid-row-2\">\n              {contract?.contractId ? (\n                <>\n                  <span\n                    className=\"self-start justify-self-center \n                max-w-35  font-semibold text-sm font-mono\"\n                  >\n                    {wallet?.getAccountId() ? (\n                      <>\n                        Connected to: <span className=\"text-md\">&#x1F91D;</span>{\" \"}\n                      </>\n                    ) : (\n                      <>\n                        Connect to?<span className=\"text-md\"> &#x1F914;</span>\n                      </>\n                    )}\n                  </span>\n                  <a\n                    target=\"_blank\"\n                    className=\"justify-self-center hover:(underline)\"\n                    href={`https://stats.gallery/testnet/${contract.contractId}/contract`}\n                  >{`${contract.contractId}`}</a>\n                </>\n              ) : (\n                <></>\n              )}\n            </section>\n\n            <section\n              id=\"Right\"\n              className=\"max-h-[50px] h-full pl-[65px] pr-[30px] w-full\n              flex justify-between items-center text-xl \n              \"\n            >\n              <div\n                className=\"hover:cursor-pointer \n              h-[44px] w-[82px]  \n              \n              flex flex-col items-center justify-center\"\n                onClick={() => setShowErrorBox((prev) => !prev)}\n              >\n                <ErrorIcon\n                  stroke={errorList?.length > 0 ? \"#a80c19\" : \"#6B7280\"}\n                  height={25}\n                  width={25}\n                />\n                {errorList?.length > 0 && (\n                  <p className=\"text-xs w-max\">\n                    Click to {showErrorBox ? \"Hide\" : \"Show\"}\n                  </p>\n                )}\n              </div>\n\n              {wallet?.getAccountId() ? (\n                <button\n                  className=\"flex items-center justify-center \n                font-thin text-white\n                bg-black\n                border-solid rounded-lg border-black border-[2px]\n                h-[30px] w-[90px] pb-[2px]\n                hover:(border-danger  text-danger font-semibold bg-light-600)\"\n                  onClick={signOut}\n                >\n                  Sign Out\n                </button>\n              ) : (\n                <button\n                  className=\"flex items-center justify-center \n                font-thin text-white\n                bg-black\n                border-solid rounded-lg border-black border-[2px]\n                h-[30px] w-[90px] pb-[2px]\n                hover:(border-near-blue text-near-blue font-semibold bg-light-600)\"\n                  onClick={signIn}\n                >\n                  Sign in\n                </button>\n              )}\n            </section>\n          </nav>\n          <aside\n            id=\"error-container\"\n            className=\"absolute self-end mt-[75px] mr-[15px]\"\n          >\n            {errorList && showErrorBox && <ErrorBox></ErrorBox>}\n          </aside>\n          <aside\n            id=\"search-bar-container\"\n            className=\"absolute self-start mt-[65px] ml-[35px] \n          \"\n          >\n            {showSearchBox && (\n              <>\n                <div\n                  id=\"input-button-container\"\n                  className=\"focus:(border-near-blue border-2)\n                shadow-xl\n                w-max h-max \n                flex grid-cols-2 \n                \"\n                >\n                  <input\n                    placeholder=\"search for an account\"\n                    className={`rounded-lg w-min border-2 border-gray-400 \n                      focus:(border-near-blue)\n                      ${\n                        errorList?.length > 0\n                          ? \" focus:border-danger\"\n                          : \"border-near-blue\"\n                      } rounded-r-[0px] h-[35px] pl-[10px]  outline-none `}\n                    onChange={(e) => {\n                      setSearchValue(e.target.value);\n                    }}\n                    onKeyPress={(e) => {\n                      if (e.key === \"Enter\") {\n                        if (searchValue != \"\") {\n                          router.push(`/${searchValue}`);\n                        }\n                      }\n                      if (e.key === \"Escape\") {\n                        setShowSearchBox(false);\n                      }\n                      console.log(e.code);\n                    }}\n                  />\n                  <button\n                    className=\"flex items-center justify-center \n                   text-black\n                  bg-gray-400\n                  border-solid rounded-lg  rounded-l-[0px]\n                  h-[35px] w-max pb-[2px] pl-[8px] pr-[8px]\n                  hover:(border-black text-black bg-gray-500)\"\n                    onClick={() => router.push(`/${searchValue}`)}\n                  >\n                    Enter\n                  </button>\n                </div>\n              </>\n            )}\n          </aside>\n        </div>\n      }\n      {children}\n    </NavContext.Provider>\n  );\n};\n\n'bchain_business_card/frontend/src/pages/home.tsx'\n:import React, { useContext, useEffect } from \"react\";\nimport { Nav } from \"../components/Nav\";\n//import { contract, wallet } from \"../utils/near\";\nimport { Big } from \"big.js\";\nimport { useState, createContext } from \"react\";\nimport dynamic from \"next/dynamic\";\nimport { useNear } from \"../context/NearProvider\";\nimport { GetServerSideProps } from \"next\";\nimport { connect, Contract, keyStores, WalletConnection } from \"near-api-js\";\nimport { NearContext } from \"../context/NearProvider\";\nimport ErrorBox from \"../components/ErrorBox\";\nimport { UserBusinessCard } from \"../components/UserBusinessCard\";\nimport {\n  useContractMethod,\n  useErrors,\n  useTxnState,\n} from \"../context/TransactionProvider\";\n\nimport { BallTriangle } from \"react-loading-icons\";\n\nexport interface NearProps {\n  wallet: any;\n}\nexport default function Home() {\n  let [bchainInput, setBchainInput] = useState(\"\");\n  let [websiteInput, setWebsiteInput] = useState(\"\");\n  let [card, setCard] = useState({\n    blockchain_exp: {},\n    owner_id: null,\n    website_url: null,\n  });\n  const { wallet, currentUserId, contract } = useNear();\n  const { viewFunction, callFunction } = useContractMethod();\n  const { loading, data, error } = useTxnState();\n  const { errorList } = useErrors();\n\n\n  //wallet watch useEffect\n  useEffect(() => {\n    console.log(`rendering page... or wallet changed`);\n    if (wallet) {\n      console.log(`wallet found`);\n      console.log(wallet);\n      currentUserId\n        ? console.log(`logged in user key found: ${currentUserId}`)\n        : console.log(\n            `wallet found but no keys for current wallet_connection exist.\n             User must log in and save a key.`\n          );\n    } else {\n      console.log(`wallet not found/loaded...yet`);\n    }\n  }, [wallet]);\n\n  //pull new card on new walletAccountId\n  useEffect(() => {\n    if (contract) {\n      getCard();\n    }\n  }, [wallet?.getAccountId()]);\n\n  const getCard = async () => {\n    console.log(`Attempting to get card for ${currentUserId}`);\n    await callFunction(\"get_card\", { account_id: \"null\" });\n    if (data) {\n      setCard(data);\n\n    }\n  };\n\n  const newfunc = async () => {\n    await viewFunction(\"get_card\", { account_id: \"currentUserId\" });\n  };\n\n  useEffect(() => {\n    (async () => {\n      if (wallet) {\n        await newfunc();\n      }\n    })();\n  }, [wallet]);\n  return (\n    <>\n      {/* {error && errorList && (\n        <div>\n          <ErrorBox errorList={errorList} />\n        </div>\n\n      )} */}\n\n      <h1 className=\"text-5xl\">{`Hello ${currentUserId || \"\"}`} </h1>\n      {loading && (\n        <BallTriangle\n          fill={error ? \"danger\" : \"near-blue\"}\n          speed={error ? 0 : 1.5}\n          className=\"\"\n        />\n      )}\n      {data && (\n        <div className=\"mt-[2rem]\">\n          <UserBusinessCard card={card}></UserBusinessCard>\n        </div>\n      )}\n    </>\n  );\n}\n\n",
        "called_code_segment_file_1": "const getCard = async () => {\n    console.log(`Attempting to get card for ${currentUserId}`);\n    await callFunction(\"get_card\", { account_id: \"null\" });\n    if (data) {\n      setCard(data);\n    }\n  };",
        "invoking_code_segment_file_2": "useEffect(() => {\n    if (contract) {\n      getCard();\n    }\n  }, [wallet?.getAccountId()]);",
        "called_code_segment_file_2": "const { viewFunction, callFunction } = useContractMethod();",
        "using_code_segment_file_3": "const { viewFunction, callFunction } = useContractMethod();",
        "feature_description": "Add a feature to allow users to update their business card information.",
        "detailed_feature_description": "Modify the `getCard` function in `#file 1` to include an update functionality. Update `#file 2` to handle the new update functionality and ensure `#file 3` is updated to accommodate these changes. Specifically, add a new function `updateCard` in `#file 1` and update `#file 2` to call this new function when the user wants to update their card information.",
        "modified_complete_code": {
            "#file 1": "const getCard = async () => {\n    console.log(`Attempting to get card for ${currentUserId}`);\n    await callFunction(\"get_card\", { account_id: \"null\" });\n    if (data) {\n      setCard(data);\n    }\n  };\n\n  #Modify const updateCard = async (newData) => {\n    console.log(`Updating card for ${currentUserId}`);\n    await callFunction(\"update_card\", { card: newData });\n    if (data) {\n      setCard(data);\n    }\n  };",
            "#file 2": "useEffect(() => {\n    if (contract) {\n      getCard();\n    }\n  }, [wallet?.getAccountId()]);\n\n  #Modify const handleUpdate = () => {\n    const newData = { blockchain_exp: bchainInput, website_url: websiteInput };\n    updateCard(newData);\n  };",
            "#file 3": "const { viewFunction, callFunction } = useContractMethod();\n\n  #New const handleUpdate = () => {\n    const newData = { blockchain_exp: bchainInput, website_url: websiteInput };\n    updateCard(newData);\n  };"
        }
    },
    {
        "repo": "wnrs",
        "content": "'wnrs/src/components/credits/Credits.tsx'\n:import { contStyles, creditStyles, creditTitleStyles } from \"./Credits.css\";\n\nconst Credits = () => {\n  return (\n    <div className={creditStyles}>\n      <div className={creditTitleStyles}>how & who</div>\n      <div className={contStyles}>\n        <b>How to play:</b> <br />\n        Progress from level to level. Become more than strangers, one card at a time.\n        <p>Refresh to reset card decks.</p>{\" \"}\n        <p>\n          Made by <a href=\"https://github.com/munjoonteo\">@munjoonteo</a> and{\" \"}\n          <a href=\"https://github.com/ilyues\">@ilyues</a>.\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default Credits;\n\n'wnrs/src/App.tsx'\n:import clsx from \"clsx\";\nimport React from \"react\";\n\nimport { levelOne, levelThree, levelTwo } from \"./assets/levels\";\nimport Card from \"./components/card/Card\";\nimport { bigCardStyles } from \"./components/card/Card.css\";\nimport Credits from \"./components/credits/Credits\";\nimport CardHistory from \"./components/history/CardHistory\";\nimport {\n  appStyles,\n  levelButtonStyles,\n  levelsStyles,\n  nextCardButtonStlyes,\n  questionStyles,\n  selectedLevelStyles,\n  titleStyles,\n} from \"./styles/app.css\";\n\nfunction shuffle<T>(array: T[]) {\n  let currentIndex = array.length;\n  let temporaryValue;\n  let randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}\n\nfunction App() {\n  const levels = {\n    levelOne: shuffle(levelOne),\n    levelTwo: shuffle(levelTwo),\n    levelThree: shuffle(levelThree),\n  };\n\n  const [gameState] = React.useState(levels);\n  const [currLevel, setLevel] = React.useState(Object.keys(levels)[0] as keyof typeof levels);\n  const [currCard, setCurrCard] = React.useState(levels[currLevel][0]);\n  const [cardHistory, setCardHistory] = React.useState<string[]>([]);\n\n  type levelKey = keyof typeof levels;\n\n  function handleChangeLevel(newLevel: levelKey) {\n    setLevel(newLevel);\n    if (gameState[newLevel].length === 1) {\n      const finalMessage = \"You have finished this level!\";\n      setCurrCard(finalMessage);\n    } else {\n      setCurrCard(gameState[newLevel][0]);\n    }\n  }\n\n  const buttons = (Object.keys(levels) as levelKey[]).map((level) => (\n    <button\n      className={clsx(levelButtonStyles, { [selectedLevelStyles]: level === currLevel })}\n      onClick={() => handleChangeLevel(level)}\n      key={level}\n    >\n      {level.split(/(?=[A-Z])/).join(\" \")}\n    </button>\n  ));\n\n  function handleNextCard() {\n    const finalMessage = \"You have finished this level!\";\n    if (gameState[currLevel].length === 1) {\n      if (currCard === finalMessage) {\n        return;\n      } else {\n        const tempHistory = [currCard, ...cardHistory];\n        setCardHistory(tempHistory);\n        setCurrCard(finalMessage);\n      }\n    } else {\n      const tempHistory = [currCard, ...cardHistory];\n      setCardHistory(tempHistory);\n      gameState[currLevel].shift();\n      setCurrCard(gameState[currLevel][0]);\n    }\n  }\n\n  return (\n    <div className={appStyles}>\n      <Credits />\n      <div className={levelsStyles}>{buttons}</div>\n      <div className={questionStyles}>\n        <div className={titleStyles}>wnrs</div>\n        <Card styleName={bigCardStyles} question={currCard} />\n        <button className={nextCardButtonStlyes} onClick={() => handleNextCard()}>\n          next card\n        </button>\n      </div>\n      <CardHistory cardHistory={cardHistory} />\n    </div>\n  );\n}\n\nexport default App;\n\n'wnrs/src/main.tsx'\n:import \"./index.css\";\nimport \"./styles/globals.css\";\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom/client\";\n\nimport App from \"./App\";\n\nReactDOM.createRoot(document.getElementById(\"root\") as HTMLElement).render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n);\n\n",
        "called_code_segment_file_1": "function shuffle<T>(array: T[]) {\n  let currentIndex = array.length;\n  let temporaryValue;\n  let randomIndex;\n\n  while (0 !== currentIndex) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}",
        "invoking_code_segment_file_2": "const levels = {\n  levelOne: shuffle(levelOne),\n  levelTwo: shuffle(levelTwo),\n  levelThree: shuffle(levelThree),\n};\n\nconst [gameState] = React.useState(levels);",
        "called_code_segment_file_2": "function handleNextCard() {\n  const finalMessage = \"You have finished this level!\";\n  if (gameState[currLevel].length === 1) {\n    if (currCard === finalMessage) {\n      return;\n    } else {\n      const tempHistory = [currCard, ...cardHistory];\n      setCardHistory(tempHistory);\n      setCurrCard(finalMessage);\n    }\n  } else {\n    const tempHistory = [currCard, ...cardHistory];\n    setCardHistory(tempHistory);\n    gameState[currLevel].shift();\n    setCurrCard(gameState[currLevel][0]);\n  }\n}",
        "using_code_segment_file_3": "const buttons = (Object.keys(levels) as levelKey[]).map((level) => (\n  <button\n    className={clsx(levelButtonStyles, { [selectedLevelStyles]: level === currLevel })}\n    onClick={() => handleChangeLevel(level)}\n    key={level}\n  >\n    {level.split(/(?=[A-Z])/).join(\" \")}\n  </button>\n));",
        "feature_description": "Add a feature to reset the card deck for the current level when the 'next card' button is clicked.",
        "detailed_feature_description": "Modify the `handleNextCard` function in `#file 2` to reset the card deck for the current level if the current card is the final message. Update the `handleChangeLevel` function to ensure it shuffles the cards when a new level is selected. Ensure `#file 3` correctly handles the new logic by updating the `buttons` array to reflect any changes in level selection.",
        "modified_complete_code": {
            "#file 1": "function shuffle<T>(array: T[]) {\n  let currentIndex = array.length;\n  let temporaryValue;\n  let randomIndex;\n\n  while (0 !== currentIndex) {\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}",
            "#file 2": "const levels = {\n  levelOne: shuffle(levelOne),\n  levelTwo: shuffle(levelTwo),\n  levelThree: shuffle(levelThree),\n};\n\nconst [gameState] = React.useState(levels);\nconst [currLevel, setLevel] = React.useState(Object.keys(levels)[0] as keyof typeof levels);\nconst [currCard, setCurrCard] = React.useState(levels[currLevel][0]);\nconst [cardHistory, setCardHistory] = React.useState<string[]>([]);\n\nfunction handleChangeLevel(newLevel: levelKey) {\n  setLevel(newLevel);\n  const shuffledLevel = shuffle(gameState[newLevel]); #Modify\n  gameState[newLevel] = shuffledLevel; #Modify\n  setCurrCard(gameState[newLevel][0]);\n}\n\nfunction handleNextCard() {\n  const finalMessage = \"You have finished this level!\";\n  if (gameState[currLevel].length === 1) {\n    if (currCard === finalMessage) {\n      const shuffledLevel = shuffle(gameState[currLevel]); #Modify\n      gameState[currLevel] = shuffledLevel; #Modify\n      setCurrCard(gameState[currLevel][0]);\n    } else {\n      const tempHistory = [currCard, ...cardHistory];\n      setCardHistory(tempHistory);\n      setCurrCard(finalMessage);\n    }\n  } else {\n    const tempHistory = [currCard, ...cardHistory];\n    setCardHistory(tempHistory);\n    gameState[currLevel].shift();\n    setCurrCard(gameState[currLevel][0]);\n  }\n}",
            "#file 3": "const buttons = (Object.keys(levels) as levelKey[]).map((level) => (\n  <button\n    className={clsx(levelButtonStyles, { [selectedLevelStyles]: level === currLevel })}\n    onClick={() => handleChangeLevel(level)}\n    key={level}\n  >\n    {level.split(/(?=[A-Z])/).join(\" \")}\n  </button>\n));"
        }
    },
    {
        "repo": "wordle",
        "content": "'wordle/src/components/grid/Grid.tsx'\n:import { CompletedRow } from \"./CompletedRow\";\nimport { CurrentRow } from \"./CurrentRow\";\nimport { EmptyRow } from \"./EmptyRow\";\n\ntype Props = {\n  guesses: string[];\n  currentGuess: string;\n};\n\nexport const Grid = ({ guesses, currentGuess }: Props) => {\n  const empties =\n    guesses.length < 5 ? Array.from(Array(5 - guesses.length)) : [];\n\n  return (\n    <div className=\"pb-6\">\n      {guesses.map((guess, i) => (\n        <CompletedRow key={i} guess={guess} />\n      ))}\n      {guesses.length < 6 && <CurrentRow guess={currentGuess} />}\n      {empties.map((_, i) => (\n        <EmptyRow key={i} />\n      ))}\n    </div>\n  );\n};\n\n'wordle/src/App.tsx'\n:import { InformationCircleIcon } from \"@heroicons/react/outline\";\nimport { useState, useEffect } from \"react\";\nimport { Alert } from \"./components/alerts/Alert\";\nimport { Grid } from \"./components/grid/Grid\";\nimport { Keyboard } from \"./components/keyboard/Keyboard\";\nimport { AboutModal } from \"./components/modals/AboutModal\";\nimport { InfoModal } from \"./components/modals/InfoModal\";\nimport { WinModal } from \"./components/modals/WinModal\";\nimport { isWordInWordList, isWinningWord, solution } from \"./lib/words\";\n\nfunction App() {\n  const [guesses, setGuesses] = useState<string[]>([]);\n  const [currentGuess, setCurrentGuess] = useState(\"\");\n  const [isGameWon, setIsGameWon] = useState(false);\n  const [isWinModalOpen, setIsWinModalOpen] = useState(false);\n  const [isInfoModalOpen, setIsInfoModalOpen] = useState(false);\n  const [isAboutModalOpen, setIsAboutModalOpen] = useState(false);\n  const [isWordNotFoundAlertOpen, setIsWordNotFoundAlertOpen] = useState(false);\n  const [isGameLost, setIsGameLost] = useState(false);\n\n  useEffect(() => {\n    if (isGameWon) {\n      setIsWinModalOpen(true);\n    }\n  }, [isGameWon]);\n\n  const onChar = (value: string) => {\n    if (currentGuess.length < 5 && guesses.length < 6) {\n      setCurrentGuess(`${currentGuess}${value}`);\n    }\n  };\n\n  const onDelete = () => {\n    setCurrentGuess(currentGuess.slice(0, -1));\n  };\n\n  const onEnter = () => {\n    if (!isWordInWordList(currentGuess)) {\n      setIsWordNotFoundAlertOpen(true);\n      return setTimeout(() => {\n        setIsWordNotFoundAlertOpen(false);\n      }, 2000);\n    }\n\n    const winningWord = isWinningWord(currentGuess);\n\n    if (currentGuess.length === 5 && guesses.length < 6 && !isGameWon) {\n      setGuesses([...guesses, currentGuess]);\n      setCurrentGuess(\"\");\n\n      if (winningWord) {\n        return setIsGameWon(true);\n      }\n\n      if (guesses.length === 5) {\n        setIsGameLost(true);\n        return setTimeout(() => {\n          setIsGameLost(false);\n        }, 2000);\n      }\n    }\n  };\n\n  return (\n    <div className=\"py-8 max-w-7xl mx-auto sm:px-6 lg:px-8\">\n      <Alert message=\"Word not found\" isOpen={isWordNotFoundAlertOpen} />\n      <Alert\n        message={`You lost, the word was ${solution}`}\n        isOpen={isGameLost}\n      />\n      <div className=\"flex w-80 mx-auto items-center mb-8\">\n        <h1 className=\"text-xl grow font-bold\">Not Wordle</h1>\n        <InformationCircleIcon\n          className=\"h-6 w-6 cursor-pointer\"\n          onClick={() => setIsInfoModalOpen(true)}\n        />\n      </div>\n      <Grid guesses={guesses} currentGuess={currentGuess} />\n      <Keyboard\n        onChar={onChar}\n        onDelete={onDelete}\n        onEnter={onEnter}\n        guesses={guesses}\n      />\n      <WinModal\n        isOpen={isWinModalOpen}\n        handleClose={() => setIsWinModalOpen(false)}\n        guesses={guesses}\n      />\n      <InfoModal\n        isOpen={isInfoModalOpen}\n        handleClose={() => setIsInfoModalOpen(false)}\n      />\n      <AboutModal\n        isOpen={isAboutModalOpen}\n        handleClose={() => setIsAboutModalOpen(false)}\n      />\n\n      <button\n        type=\"button\"\n        className=\"mx-auto mt-8 flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-indigo-700 bg-indigo-100 hover:bg-indigo-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500\"\n        onClick={() => setIsAboutModalOpen(true)}\n      >\n        About this game\n      </button>\n    </div>\n  );\n}\n\nexport default App;\n\n'wordle/src/App.test.tsx'\n:import React from 'react';\nimport { render, screen } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n\n",
        "called_code_segment_file_1": "export const Grid = ({ guesses, currentGuess }: Props) => {\n  const empties = guesses.length < 5 ? Array.from(Array(5 - guesses.length)) : [];\n\n  return (\n    <div className=\"pb-6\">\n      {guesses.map((guess, i) => (\n        <CompletedRow key={i} guess={guess} />\n      ))}\n      {guesses.length < 6 && <CurrentRow guess={currentGuess} />}\n      {empties.map((_, i) => (\n        <EmptyRow key={i} />\n      ))}\n    </div>\n  );\n};",
        "invoking_code_segment_file_2": "<Grid guesses={guesses} currentGuess={currentGuess} />",
        "called_code_segment_file_2": "const onChar = (value: string) => {\n  if (currentGuess.length < 5 && guesses.length < 6) {\n    setCurrentGuess(`${currentGuess}${value}`);\n  }\n};",
        "using_code_segment_file_3": "onChar={onChar}",
        "feature_description": "Add a feature to highlight the current row in the grid.",
        "detailed_feature_description": "Modify the Grid component to add a class to the current row to highlight it. Update the App component to handle this change and ensure the Keyboard component still interacts correctly with the updated Grid component.",
        "modified_complete_code": {
            "#file 1": "export const Grid = ({ guesses, currentGuess }: Props) => {\n  const empties = guesses.length < 5 ? Array.from(Array(5 - guesses.length)) : [];\n\n  return (\n    <div className=\"pb-6\">\n      {guesses.map((guess, i) => (\n        <CompletedRow key={i} guess={guess} />\n      ))}\n      {guesses.length < 6 && <CurrentRow guess={currentGuess} className=\"current-row\" />} #Modify\n      {empties.map((_, i) => (\n        <EmptyRow key={i} />\n      ))}\n    </div>\n  );\n};",
            "#file 2": "function App() {\n  const [guesses, setGuesses] = useState<string[]>([]);\n  const [currentGuess, setCurrentGuess] = useState(\"\");\n  const [isGameWon, setIsGameWon] = useState(false);\n  const [isWinModalOpen, setIsWinModalOpen] = useState(false);\n  const [isInfoModalOpen, setIsInfoModalOpen] = useState(false);\n  const [isAboutModalOpen, setIsAboutModalOpen] = useState(false);\n  const [isWordNotFoundAlertOpen, setIsWordNotFoundAlertOpen] = useState(false);\n  const [isGameLost, setIsGameLost] = useState(false);\n\n  useEffect(() => {\n    if (isGameWon) {\n      setIsWinModalOpen(true);\n    }\n  }, [isGameWon]);\n\n  const onChar = (value: string) => {\n    if (currentGuess.length < 5 && guesses.length < 6) {\n      setCurrentGuess(`${currentGuess}${value}`);\n    }\n  };\n\n  const onDelete = () => {\n    setCurrentGuess(currentGuess.slice(0, -1));\n  };\n\n  const onEnter = () => {\n    if (!isWordInWordList(currentGuess)) {\n      setIsWordNotFoundAlertOpen(true);\n      return setTimeout(() => {\n        setIsWordNotFoundAlertOpen(false);\n      }, 2000);\n    }\n\n    const winningWord = isWinningWord(currentGuess);\n\n    if (currentGuess.length === 5 && guesses.length < 6 && !isGameWon) {\n      setGuesses([...guesses, currentGuess]);\n      setCurrentGuess(\"\");\n\n      if (winningWord) {\n        return setIsGameWon(true);\n      }\n\n      if (guesses.length === 5) {\n        setIsGameLost(true);\n        return setTimeout(() => {\n          setIsGameLost(false);\n        }, 2000);\n      }\n    }\n  };\n\n  return (\n    <div className=\"py-8 max-w-7xl mx-auto sm:px-6 lg:px-8\">\n      <Alert message=\"Word not found\" isOpen={isWordNotFoundAlertOpen} />\n      <Alert\n        message={`You lost, the word was ${solution}`}\n        isOpen={isGameLost}\n      />\n      <div className=\"flex w-80 mx-auto items-center mb-8\">\n        <h1 className=\"text-xl grow font-bold\">Not Wordle</h1>\n        <InformationCircleIcon\n          className=\"h-6 w-6 cursor-pointer\"\n          onClick={() => setIsInfoModalOpen(true)}\n        />\n      </div>\n      <Grid guesses={guesses} currentGuess={currentGuess} /> #Modify\n      <Keyboard\n        onChar={onChar}\n        onDelete={onDelete}\n        onEnter={onEnter}\n        guesses={guesses}\n      />\n      <WinModal\n        isOpen={isWinModalOpen}\n        handleClose={() => setIsWinModalOpen(false)}\n        guesses={guesses}\n      />\n      <InfoModal\n        isOpen={isInfoModalOpen}\n        handleClose={() => setIsInfoModalOpen(false)}\n      />\n      <AboutModal\n        isOpen={isAboutModalOpen}\n        handleClose={() => setIsAboutModalOpen(false)}\n      />\n\n      <button\n        type=\"button\"\n        className=\"mx-auto mt-8 flex items-center px-2.5 py-1.5 border border-transparent text-xs font-medium rounded text-indigo-700 bg-indigo-100 hover:bg-indigo-200 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500\"\n        onClick={() => setIsAboutModalOpen(true)}\n      >\n        About this game\n      </button>\n    </div>\n  );\n}",
            "#file 3": "export const Keyboard = ({ onChar, onDelete, onEnter, guesses }: Props) => {\n  const onClick = (value: string) => {\n    if (value === 'ENTER') {\n      onEnter();\n    } else if (value === 'DELETE') {\n      onDelete();\n    } else {\n      onChar(value);\n    }\n  };\n\n  return (\n    <div>\n      {KEYBOARD.map((key) => (\n        <Key\n          value={key}\n          key={key}\n          onClick={onClick}\n          status={guesses[guesses.length - 1]?.split('').findIndex(letter => letter === key) || ''} #Modify\n        />\n      ))}\n    </div>\n  );\n};"
        }
    },
    {
        "repo": "cxml",
        "content": "'cxml/src/Buffer.ts'\n:export declare class TextEncoder {\n\tconstructor(encoding: string);\n\n\tencode(data: string): Uint8Array;\n\tdecode(data: Uint8Array): string;\n}\n\nexport type ArrayType = Buffer | Uint8Array;\nexport let ArrayType: { new(size: number): ArrayType };\n\nexport let encodeArray: (text: string) => ArrayType;\nexport let decodeArray: (data: ArrayType, start?: number, end?: number) => string;\nexport let concatArray: (list: ArrayType[], len: number) => ArrayType;\n\nif(typeof(Buffer) == 'function') {\n\tArrayType = Buffer;\n\n\tencodeArray = (text: string) => new Buffer(text);\n\tdecodeArray = (data: ArrayType, start?: number, end?: number) => (data as Buffer).toString('utf-8', start, end);\n\n\tconcatArray = Buffer.concat as any;\n} else if(typeof(TextEncoder) == 'function') {\n\tArrayType = Uint8Array;\n\n\tconst encoder = new TextEncoder('utf-8');\n\tencodeArray = (text: string) => encoder.encode(name);\n\tdecodeArray = (data: ArrayType, start?: number, end?: number) => encoder.decode(\n\t\t(start || end || end === 0) ? data.slice(start, end) : data\n\t);\n\n\tconcatArray = (list: ArrayType[], len: number) => {\n\t\tconst buf = new Uint8Array(len);\n\n\t\tlet offset = 0;\n\t\tfor(let part of list) {\n\t\t\tbuf.set(part, offset);\n\t\t\toffset += part.length;\n\t\t}\n\n\t\treturn(buf);\n\t}\n}\n\n'cxml/src/parser/Parser.ts'\n:import { ArrayType, encodeArray } from '../Buffer';\nimport { Namespace } from '../Namespace';\nimport { CodeType } from '../tokenizer/CodeType';\nimport { ErrorType } from '../tokenizer/ErrorType';\nimport { NativeParser } from './ParserLib';\nimport { ParserConfig } from './ParserConfig';\nimport { ParserNamespace } from './ParserNamespace';\nimport { InternalToken } from './InternalToken';\nimport { TokenSet } from '../tokenizer/TokenSet';\nimport { TokenChunk } from './TokenChunk';\nimport { Stitcher } from './Stitcher';\nimport {\n\tToken,\n\tTokenBuffer,\n\tTokenKind,\n\tSpecialToken,\n\tMemberToken,\n\tOpenToken,\n\tCloseToken,\n\tStringToken,\n\tSgmlToken\n} from './Token';\n\n// const codeBufferSize = 2;\n// const codeBufferSize = 3;\nconst codeBufferSize = 8192;\n\nconst chunkSize = Infinity;\n\nconst enum TOKEN {\n\tSHIFT = 5,\n\tMASK = 31\n}\n\nexport class ParseError extends Error {\n\n\tconstructor(public code: ErrorType, public row: number, public col: number) {\n\t\tsuper('Parse error on line ' + row + ' column ' + col);\n\t}\n\n}\n\n/** XML parser stream, emits tokens with fully qualified names. */\n\nexport class Parser {\n\n\t/** Call only from ParserConfig.createParser.\n\t  * @param config Reference to C++ config object.\n\t  * @param native Reference to C++ parser object. */\n\n\tconstructor(private config: ParserConfig, private native: NativeParser) {\n\t\tthis.codeBuffer = new Uint32Array(codeBufferSize);\n\t\tthis.native.setCodeBuffer(this.codeBuffer, () => this.parseCodeBuffer(true));\n\n\t\tfor(let ns of this.config.namespaceList) {\n\t\t\tif(ns && (ns.base.isSpecial || ns.base.defaultPrefix == 'xml')) {\n\t\t\t\tthis.namespaceList[ns.base.id] = ns.base;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getConfig() { return(this.config); }\n\n\tbindPrefix(prefix: InternalToken, uri: InternalToken) {\n\t\tthis.native.bindPrefix(prefix.id, uri.id);\n\t}\n\n\tpublic parseSync(data: string | ArrayType) {\n\t\tconst buffer: TokenBuffer = [];\n\t\tlet namespaceList: (Namespace | undefined)[] | undefined;\n\n\t\tthis.write(data, '', (err: any, chunk: TokenChunk | null) => {\n\t\t\tif(err || !chunk) throw(err);\n\n\t\t\tfor(let tokenNum = 0; tokenNum < chunk.length; ++tokenNum) {\n\t\t\t\tbuffer.push(chunk.buffer[tokenNum]);\n\t\t\t}\n\n\t\t\tif(chunk.namespaceList) namespaceList = chunk.namespaceList;\n\n\t\t\tchunk.free();\n\t\t});\n\n\t\tconst output = TokenChunk.allocate(buffer);\n\t\toutput.namespaceList = namespaceList;\n\n\t\treturn(output);\n\t}\n\n\tdestroy(\n\t\tflush: (err: any, chunk: TokenChunk | null) => void\n\t) {\n\t\tconst nativeStatus = this.native.destroy();\n\n\t\tif(nativeStatus != ErrorType.OK) {\n\t\t\tthis.hasError = new ParseError(nativeStatus, this.native.row + 1, this.native.col + 1);\n\t\t\tflush(this.hasError, null);\n\t\t} else {\n\t\t\tthis.parseCodeBuffer(false);\n\t\t\tflush(null, this.tokenChunk);\n\t\t}\n\t}\n\n\twrite(\n\t\tchunk: string | ArrayType,\n\t\tenc: string,\n\t\tflush: (err: any, chunk: TokenChunk | null) => void\n\t) {\n\t\tif(this.hasError) {\n\t\t\tflush(this.hasError, null);\n\t\t\treturn;\n\t\t}\n\n\t\tif(typeof(chunk) == 'string') chunk = encodeArray(chunk);\n\n\t\tconst len = chunk.length;\n\t\tlet nativeStatus = ErrorType.OK;\n\t\tlet next: number;\n\n\t\tif(len < chunkSize) {\n\t\t\tthis.chunk = chunk;\n\t\t\tthis.stitcher.setChunk(this.chunk);\n\t\t\tnativeStatus = this.native.parse(this.chunk);\n\t\t\tthis.parseCodeBuffer(false);\n\t\t} else {\n\t\t\t// Limit size of buffers sent to native code.\n\t\t\tfor(let pos = 0; pos < len; pos = next) {\n\t\t\t\tnext = Math.min(pos + chunkSize, len);\n\n\t\t\t\tthis.chunk = chunk.slice(pos, next);\n\t\t\t\tthis.stitcher.setChunk(this.chunk);\n\t\t\t\tnativeStatus = this.native.parse(this.chunk);\n\n\t\t\t\tif(nativeStatus != ErrorType.OK) break;\n\t\t\t\tthis.parseCodeBuffer(false);\n\t\t\t}\n\t\t}\n\n\t\tif(nativeStatus != ErrorType.OK) {\n\t\t\tthis.hasError = new ParseError(nativeStatus, this.native.row + 1, this.native.col + 1);\n\t\t\tflush(this.hasError, null);\n\t\t\treturn;\n\t\t}\n\n\t\tif(this.elementStart < 0) {\n\t\t\tif(this.namespacesChanged) this.tokenChunk.namespaceList = this.namespaceList;\n\t\t\tflush(null, this.tokenChunk);\n\n\t\t\tthis.tokenChunk = TokenChunk.allocate();\n\t\t} else {\n\t\t\t// Not ready to flush but have to send something to get more input.\n\t\t\tflush(null, null);\n\t\t}\n\t}\n\n\tprivate parseCodeBuffer(pending: boolean) {\n\t\tconst config = this.config;\n\t\tconst stitcher = this.stitcher;\n\t\tconst codeBuffer = this.codeBuffer;\n\t\tconst codeCount = codeBuffer[0];\n\n\t\t// NOTE: These must be updated if config is unlinked!\n\t\tlet elementList = config.elementSpace.list;\n\t\tlet attributeList = config.attributeSpace.list;\n\t\tlet prefixList = config.prefixSpace.list;\n\t\tlet uriList = config.uriSpace.list;\n\t\tlet partialList = elementList;\n\n\t\tlet codeNum = 0;\n\t\tlet partStart = this.partStart;\n\t\tlet partialLen = this.partialLen;\n\t\tlet latestElement = this.latestElement;\n\t\tlet latestPrefix = this.latestPrefix;\n\t\tlet latestNamespace = this.latestNamespace;\n\n\t\tconst tokenBuffer = this.tokenChunk.buffer;\n\t\tconst prefixBuffer = this.prefixBuffer;\n\t\tconst namespaceBuffer = this.namespaceBuffer;\n\t\tconst unknownElementTbl = this.unknownElementTbl;\n\t\tconst unknownAttributeTbl = this.unknownAttributeTbl;\n\t\tconst sgmlTbl = this.sgmlTbl;\n\t\tconst unknownOffsetList = this.unknownOffsetList;\n\t\tlet tokenNum = this.tokenChunk.length - 1;\n\t\tlet token: Token;\n\t\tlet name: string;\n\t\tlet prefix: string;\n\t\tlet elementStart = this.elementStart;\n\t\tlet unknownCount = this.unknownCount;\n\n\t\twhile(codeNum < codeCount) {\n\t\t\tlet code = codeBuffer[++codeNum];\n\t\t\tconst kind = code & TOKEN.MASK;\n\t\t\tcode >>= TOKEN.SHIFT;\n\n\t\t\tswitch(kind) {\n\t\t\t\tcase CodeType.OPEN_ELEMENT_ID:\n\n\t\t\t\t\tlatestElement = elementList[code].open;\n\t\t\t\t\t// TODO: If latestprefix is null, use current prefix for element's namespace.\n\t\t\t\t\ttokenBuffer[++tokenNum] = latestElement;\n\t\t\t\t\tprefixBuffer[0] = latestPrefix;\n\t\t\t\t\telementStart = tokenNum;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.CLOSE_ELEMENT_ID:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = elementList[code].close;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.ELEMENT_EMITTED:\n\t\t\t\tcase CodeType.CLOSED_ELEMENT_EMITTED:\n\n\t\t\t\t\tif(unknownCount) {\n\t\t\t\t\t\tlet ns: ParserNamespace;\n\t\t\t\t\t\tlet offset: number;\n\n\t\t\t\t\t\tfor(let pos = 0; pos < unknownCount; ++pos) {\n\t\t\t\t\t\t\toffset = unknownOffsetList[pos];\n\t\t\t\t\t\t\tns = namespaceBuffer[offset]!;\n\t\t\t\t\t\t\t// If an xmlns definition already resolved\n\t\t\t\t\t\t\t// this token, ns will be null.\n\t\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\t\t// Ensure namespace is updated after config unlink.\n\t\t\t\t\t\t\t\tns = config.namespaceList[ns.id];\n\t\t\t\t\t\t\t\ttokenBuffer[offset + elementStart] = (\n\t\t\t\t\t\t\t\t\ttokenBuffer[offset + elementStart] as MemberToken\n\t\t\t\t\t\t\t\t).resolve(ns);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlatestElement = tokenBuffer[elementStart] as OpenToken;\n\t\t\t\t\t\tunknownCount = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = (\n\t\t\t\t\t\tkind == CodeType.ELEMENT_EMITTED ?\n\t\t\t\t\t\tlatestElement.emitted :\n\t\t\t\t\t\tlatestElement.close\n\t\t\t\t\t)\n\n\t\t\t\t\telementStart = -1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.ATTRIBUTE_ID:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = attributeList[code].string;\n\t\t\t\t\t// If latestprefix is null, set attribute prefix to match its parent element.\n\t\t\t\t\tprefixBuffer[tokenNum - elementStart] = latestPrefix || prefixBuffer[0];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.PREFIX_ID:\n\n\t\t\t\t\tlatestNamespace = config.namespaceList[code >> 14];\n\t\t\t\t\tcode = code & 0x3fff;\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.XMLNS_ID:\n\n\t\t\t\t\tlatestPrefix = prefixList[code];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.NAMESPACE_ID:\n\n\t\t\t\t\tthis.resolve(elementStart, tokenNum, latestPrefix!, code);\n\t\t\t\t\ttokenBuffer[++tokenNum] = latestPrefix!.prefix;\n\t\t\t\t\ttokenBuffer[++tokenNum] = this.config.namespaceList[code].uriToken;\n\t\t\t\t\tlatestPrefix = null;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.SGML_ID:\n\n\t\t\t\t\ttoken = elementList[code].open;\n\t\t\t\t\tprefix = (token as MemberToken).ns.defaultPrefix;\n\t\t\t\t\tname = (token as MemberToken).name;\n\t\t\t\t\ttoken = sgmlTbl[prefix + ':' + name];\n\n\t\t\t\t\tif(!token) {\n\t\t\t\t\t\ttoken = new SgmlToken(name, prefix);\n\t\t\t\t\t\tsgmlTbl[prefix + ':' + name] = token as SgmlToken;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = token;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.TEXT_START_OFFSET:\n\t\t\t\tcase CodeType.CDATA_START_OFFSET:\n\t\t\t\tcase CodeType.VALUE_START_OFFSET:\n\t\t\t\tcase CodeType.COMMENT_START_OFFSET:\n\t\t\t\tcase CodeType.SGML_TEXT_START_OFFSET:\n\t\t\t\tcase CodeType.UNKNOWN_START_OFFSET:\n\n\t\t\t\t\tpartStart = code;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_OPEN_ELEMENT_END_OFFSET:\n\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\tlatestElement = unknownElementTbl[name];\n\n\t\t\t\t\tif(!latestElement) {\n\t\t\t\t\t\tlatestElement = new OpenToken(name, Namespace.unknown);\n\t\t\t\t\t\tunknownElementTbl[name] = latestElement;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = latestElement;\n\t\t\t\t\tprefixBuffer[0] = latestPrefix;\n\t\t\t\t\tnamespaceBuffer[0] = latestNamespace;\n\t\t\t\t\telementStart = tokenNum;\n\t\t\t\t\tunknownOffsetList[0] = 0;\n\t\t\t\t\tunknownCount = 1;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_CLOSE_ELEMENT_END_OFFSET:\n\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\ttokenBuffer[++tokenNum] = (latestNamespace ?\n\t\t\t\t\t\tlatestNamespace.addElement(name) :\n\t\t\t\t\t\tunknownElementTbl[name]\n\t\t\t\t\t).close;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_ATTRIBUTE_END_OFFSET:\n\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\ttoken = unknownAttributeTbl[name];\n\n\t\t\t\t\tif(!token) {\n\t\t\t\t\t\ttoken = new StringToken(name, Namespace.unknown);\n\t\t\t\t\t\tunknownAttributeTbl[name] = token;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = token;\n\n\t\t\t\t\tlet pos = tokenNum - elementStart;\n\t\t\t\t\tprefixBuffer[pos] = latestPrefix;\n\t\t\t\t\tnamespaceBuffer[pos] = latestNamespace;\n\t\t\t\t\tunknownOffsetList[unknownCount++] = pos;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_SGML_END_OFFSET:\n\n\t\t\t\t\tprefix = latestPrefix ? latestPrefix.name : '';\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\ttoken = sgmlTbl[prefix + ':' + name];\n\n\t\t\t\t\tif(!token) {\n\t\t\t\t\t\ttoken = new SgmlToken(name, prefix);\n\t\t\t\t\t\tsgmlTbl[prefix + ':' + name] = token as SgmlToken;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = token;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.SGML_EMITTED:\n\t\t\t\tcase CodeType.SGML_NESTED_START:\n\t\t\t\tcase CodeType.SGML_NESTED_END:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = this.specialTokenTbl[kind];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.COMMENT_END_OFFSET:\n\t\t\t\tcase CodeType.SGML_TEXT_END_OFFSET:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = this.specialTokenTbl[kind];\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.VALUE_END_OFFSET:\n\t\t\t\tcase CodeType.TEXT_END_OFFSET:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = stitcher.getSlice(partStart, code);\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.CDATA_END_OFFSET:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = SpecialToken.cdata;\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\ttokenBuffer[++tokenNum] = name.substr(0, name.length - 3);\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_PREFIX_END_OFFSET:\n\t\t\t\tcase CodeType.UNKNOWN_XMLNS_END_OFFSET:\n\t\t\t\tcase CodeType.UNKNOWN_URI_END_OFFSET:\n\n\t\t\t\t\t// Add the namespace prefix or URI to a separate trie.\n\t\t\t\t\t// Incoming code buffer should have been flushed immediately\n\t\t\t\t\t// after writing this token.\n\n\t\t\t\t\tif(kind == CodeType.UNKNOWN_URI_END_OFFSET) {\n\t\t\t\t\t\tlet uri = stitcher.getSlice(partStart, code);\n\n\t\t\t\t\t\t/* if(uri.id > dynamicTokenTblSize) {\n\t\t\t\t\t\t\t// TODO: report row and column in error messages.\n\t\t\t\t\t\t\tthrow(new Error('Too many different xmlns URIs'));\n\t\t\t\t\t\t} */\n\n\t\t\t\t\t\t// Create a new namespace for the unrecognized URI.\n\t\t\t\t\t\tname = latestPrefix!.name;\n\t\t\t\t\t\tconst ns = new Namespace(name, uri, config.maxNamespace + 1);\n\t\t\t\t\t\t// This may unlink the config:\n\t\t\t\t\t\tconst idNamespace = config.bindNamespace(ns, latestPrefix!.name, this);\n\t\t\t\t\t\tthis.resolve(elementStart, tokenNum, latestPrefix!, idNamespace);\n\t\t\t\t\t\ttokenBuffer[++tokenNum] = latestPrefix!.prefix;\n\t\t\t\t\t\ttokenBuffer[++tokenNum] = this.config.namespaceList[idNamespace].uriToken;\n\t\t\t\t\t\tlatestPrefix = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This may unlink the config:\n\t\t\t\t\t\tlatestPrefix = config.addPrefix(stitcher.getSlice(partStart, code));\n\n\t\t\t\t\t\t/* if(latestPrefix.id > dynamicTokenTblSize) {\n\t\t\t\t\t\t\t// TODO: report row and column in error messages.\n\t\t\t\t\t\t\tthrow(new Error('Too many different xmlns prefixes'));\n\t\t\t\t\t\t} */\n\n\t\t\t\t\t\tthis.native.setPrefix(latestPrefix.id);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Config may have been unlinked so update references to it.\n\t\t\t\t\telementList = config.elementSpace.list;\n\t\t\t\t\tattributeList = config.attributeSpace.list;\n\t\t\t\t\tprefixList = config.prefixSpace.list;\n\t\t\t\t\turiList = config.uriSpace.list;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.PARTIAL_LEN:\n\n\t\t\t\t\tpartialLen = code;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.PARTIAL_URI_ID:\n\n\t\t\t\t\tpartialList = uriList;\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.PARTIAL_PREFIX_ID:\n\n\t\t\t\t\tif(partialList == elementList) partialList = prefixList;\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.PARTIAL_ATTRIBUTE_ID:\n\n\t\t\t\t\tif(partialList == elementList) partialList = attributeList;\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.PARTIAL_ELEMENT_ID:\n\n\t\t\t\t\tstitcher.reset(partialList[code].buf, partialLen);\n\t\t\t\t\tpartialList = elementList;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!pending && partStart >= 0) {\n\t\t\tstitcher.storeSlice(partStart);\n\t\t\tpartStart = 0;\n\t\t}\n\n\t\t// NOTE: Any active cursor in native code will still use the old trie\n\t\t// after update.\n\t\tconfig.updateNamespaces();\n\n\t\tthis.partStart = partStart;\n\t\tthis.partialLen = partialLen;\n\t\tthis.latestElement = latestElement;\n\t\tthis.latestPrefix = latestPrefix;\n\t\tthis.latestNamespace = latestNamespace;\n\n\t\tthis.tokenChunk.length = tokenNum + 1;\n\t\tthis.elementStart = elementStart;\n\t\tthis.unknownCount = unknownCount;\n\t}\n\n\t/** Resolve any prior occurrences of a recently defined prefix\n\t  * within the same element. */\n\tprivate resolve(elementStart: number, tokenNum: number, prefix: InternalToken, idNamespace: number) {\n\t\tconst prefixBuffer = this.prefixBuffer;\n\t\tconst tokenBuffer = this.tokenChunk.buffer;\n\t\tconst ns = this.config.namespaceList[idNamespace];\n\t\tconst len = tokenNum - elementStart;\n\t\tlet token: Token | number | string;\n\n\t\tif(!ns.base.defaultPrefix) {\n\t\t\tns.base.defaultPrefix = prefix.name;\n\t\t}\n\t\tthis.namespaceList[ns.base.id] = ns.base;\n\t\tthis.namespacesChanged = true;\n\n\t\tfor(let pos = 0; pos <= len; ++pos) {\n\t\t\tif(prefixBuffer[pos] == prefix) {\n\t\t\t\ttoken = tokenBuffer[pos + elementStart];\n\t\t\t\tif(token instanceof MemberToken) {\n\t\t\t\t\ttokenBuffer[pos + elementStart] = token.resolve(ns);\n\t\t\t\t\tthis.namespaceBuffer[pos] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate stitcher = new Stitcher();\n\n\t/** Current element not yet emitted (closing angle bracket unseen). */\n\tprivate latestElement: OpenToken;\n\t/** Previous namespace prefix token, applied to the next element, attribute\n\t  * or xmlns definition. */\n\tprivate latestPrefix: InternalToken | null;\n\tprivate latestNamespace: ParserNamespace | null;\n\n\t/** Current input buffer. */\n\tprivate chunk: ArrayType;\n\n\tprivate namespaceList: (Namespace | undefined)[] = [];\n\tprivate namespacesChanged = true;\n\n\t/** Offset to start of text in input buffer, or -1 if not reading text. */\n\tprivate partStart = -1;\n\n\t/** Number of valid initial bytes in next token. */\n\tprivate partialLen: number;\n\n\t/** Shared with C++ library. */\n\tprivate codeBuffer: Uint32Array;\n\t/** Stream output buffer chunk. */\n\ttokenChunk = TokenChunk.allocate();\n\n\t/** Offset to start of current element definition in output buffer. */\n\tprivate elementStart = -1;\n\t/** Prefixes of latest tokenBuffer entries (their namespace may change\n\t  * if the prefix is remapped). Index 0 corresponds to elementStart. */\n\tprivate prefixBuffer: (InternalToken | null)[] = [];\n\tprivate namespaceBuffer: (ParserNamespace | null)[] = [];\n\n\t/** Unresolved elements (temporary tokens lacking a namespace). */\n\tprivate unknownElementTbl: { [ name: string ]: OpenToken } = {};\n\t/** Unresolved attributes (temporary tokens lacking a namespace). */\n\tprivate unknownAttributeTbl: { [ name: string ]: Token } = {};\n\tprivate sgmlTbl: { [ name: string ]: SgmlToken } = {};\n\tprivate unknownOffsetList: number[] = [];\n\n\tprivate unknownCount = 0;\n\n\tspecialTokenTbl = {\n\t\t[CodeType.COMMENT_END_OFFSET]: SpecialToken.comment,\n\t\t[CodeType.SGML_EMITTED]: SpecialToken.sgmlEmitted,\n\t\t[CodeType.SGML_NESTED_START]: SpecialToken.sgmlNestedStart,\n\t\t[CodeType.SGML_NESTED_END]: SpecialToken.sgmlNestedEnd,\n\t\t[CodeType.SGML_TEXT_END_OFFSET]: SpecialToken.sgmlText\n\t};\n\n\tprivate hasError?: ParseError;\n\n}\n\n'cxml/src/parser/ParserStream.ts'\n:import * as stream from 'stream';\n\nimport { ArrayType } from '../Buffer';\nimport { Namespace } from '../Namespace';\nimport { ParserConfig } from './ParserConfig';\nimport { Parser } from './Parser';\nimport { TokenChunk } from './TokenChunk';\nimport {\n\tToken,\n\tTokenBuffer,\n\tTokenKind,\n} from './Token';\n\n /** XML parser stream, emits tokens with fully qualified names. */\n\nexport class ParserStream extends stream.Transform {\n\n\tconstructor(config: ParserConfig, public parser = config.createParser()) {\n\t\tsuper({ objectMode: true });\n\t}\n\n\t_flush( flush: (err: any, chunk: TokenChunk | null) => void) {\n\t\tthis.parser.destroy(flush);\n\t\tflush(null, null);\n\t}\n\n\t_transform(\n\t\tchunk: string | ArrayType,\n\t\tenc: string,\n\t\tflush: (err: any, chunk: TokenChunk | null) => void\n\t) {\n\t\tthis.parser.write(chunk, enc, flush);\n\t}\n\n}\n\n",
        "called_code_segment_file_1": "parseSync(data: string | ArrayType) {\n    const buffer: TokenBuffer = [];\n    let namespaceList: (Namespace | undefined)[] | undefined;\n\n    this.write(data, '', (err: any, chunk: TokenChunk | null) => {\n        if(err || !chunk) throw(err);\n\n        for(let tokenNum = 0; tokenNum < chunk.length; ++tokenNum) {\n            buffer.push(chunk.buffer[tokenNum]);\n        }\n\n        if(chunk.namespaceList) namespaceList = chunk.namespaceList;\n\n        chunk.free();\n    });\n\n    const output = TokenChunk.allocate(buffer);\n    output.namespaceList = namespaceList;\n\n    return(output);\n}",
        "invoking_code_segment_file_2": "write(chunk: string | ArrayType, enc: string, flush: (err: any, chunk: TokenChunk | null) => void) {\n    if(this.hasError) {\n        flush(this.hasError, null);\n        return;\n    }\n\n    if(typeof(chunk) == 'string') chunk = encodeArray(chunk);\n\n    const len = chunk.length;\n    let nativeStatus = ErrorType.OK;\n    let next: number;\n\n    if(len < chunkSize) {\n        this.chunk = chunk;\n        this.stitcher.setChunk(this.chunk);\n        nativeStatus = this.native.parse(this.chunk);\n        this.parseCodeBuffer(false);\n    } else {\n        // Limit size of buffers sent to native code.\n        for(let pos = 0; pos < len; pos = next) {\n            next = Math.min(pos + chunkSize, len);\n\n            this.chunk = chunk.slice(pos, next);\n            this.stitcher.setChunk(this.chunk);\n            nativeStatus = this.native.parse(this.chunk);\n\n            if(nativeStatus != ErrorType.OK) break;\n            this.parseCodeBuffer(false);\n        }\n    }\n\n    if(nativeStatus != ErrorType.OK) {\n        this.hasError = new ParseError(nativeStatus, this.native.row + 1, this.native.col + 1);\n        flush(this.hasError, null);\n        return;\n    }\n\n    if(this.elementStart < 0) {\n        if(this.namespacesChanged) this.tokenChunk.namespaceList = this.namespaceList;\n        flush(null, this.tokenChunk);\n\n        this.tokenChunk = TokenChunk.allocate();\n    } else {\n        // Not ready to flush but have to send something to get more input.\n        flush(null, null);\n    }\n}",
        "called_code_segment_file_2": "_flush( flush: (err: any, chunk: TokenChunk | null) => void) {\n    this.parser.destroy(flush);\n    flush(null, null);\n}",
        "using_code_segment_file_3": "_transform(chunk: string | ArrayType, enc: string, flush: (err: any, chunk: TokenChunk | null) => void) {\n    this.parser.write(chunk, enc, flush);\n}",
        "feature_description": "Add a feature to log the number of tokens processed by the parser.",
        "detailed_feature_description": "Modify the `parseSync` method in `#file 1` to count the number of tokens processed. Update the `write` method in `#file 2` to handle this count and log it. Ensure that the `_transform` method in `#file 3` is updated to accommodate any changes in the `write` method.",
        "modified_complete_code": {
            "#file 1": "parseSync(data: string | ArrayType) {\n    const buffer: TokenBuffer = [];\n    let namespaceList: (Namespace | undefined)[] | undefined;\n    let tokenCount = 0; #Modify\n\n    this.write(data, '', (err: any, chunk: TokenChunk | null) => {\n        if(err || !chunk) throw(err);\n\n        for(let tokenNum = 0; tokenNum < chunk.length; ++tokenNum) {\n            buffer.push(chunk.buffer[tokenNum]);\n            tokenCount++; #Modify\n        }\n\n        if(chunk.namespaceList) namespaceList = chunk.namespaceList;\n\n        chunk.free();\n    });\n\n    console.log(`Tokens processed: ${tokenCount}`); #Modify\n\n    const output = TokenChunk.allocate(buffer);\n    output.namespaceList = namespaceList;\n\n    return(output);\n}",
            "#file 2": "write(chunk: string | ArrayType, enc: string, flush: (err: any, chunk: TokenChunk | null) => void) {\n    if(this.hasError) {\n        flush(this.hasError, null);\n        return;\n    }\n\n    if(typeof(chunk) == 'string') chunk = encodeArray(chunk);\n\n    const len = chunk.length;\n    let nativeStatus = ErrorType.OK;\n    let next: number;\n\n    if(len < chunkSize) {\n        this.chunk = chunk;\n        this.stitcher.setChunk(this.chunk);\n        nativeStatus = this.native.parse(this.chunk);\n        this.parseCodeBuffer(false);\n    } else {\n        // Limit size of buffers sent to native code.\n        for(let pos = 0; pos < len; pos = next) {\n            next = Math.min(pos + chunkSize, len);\n\n            this.chunk = chunk.slice(pos, next);\n            this.stitcher.setChunk(this.chunk);\n            nativeStatus = this.native.parse(this.chunk);\n\n            if(nativeStatus != ErrorType.OK) break;\n            this.parseCodeBuffer(false);\n        }\n    }\n\n    if(nativeStatus != ErrorType.OK) {\n        this.hasError = new ParseError(nativeStatus, this.native.row + 1, this.native.col + 1);\n        flush(this.hasError, null);\n        return;\n    }\n\n    if(this.elementStart < 0) {\n        if(this.namespacesChanged) this.tokenChunk.namespaceList = this.namespaceList;\n        flush(null, this.tokenChunk);\n\n        this.tokenChunk = TokenChunk.allocate();\n    } else {\n        // Not ready to flush but have to send something to get more input.\n        flush(null, null);\n    }\n}",
            "#file 3": "_transform(chunk: string | ArrayType, enc: string, flush: (err: any, chunk: TokenChunk | null) => void) {\n    this.parser.write(chunk, enc, flush);\n}"
        }
    },
    {
        "repo": "flags.sh",
        "content": "'flags.sh/app/data/interface/DisabledOptions.ts'\n:/**\n * Options for the disabled components.\n */\nexport interface DisabledOptions {\n    /**\n     * Whether to disable the GUI toggle.\n     */\n    \"gui\"?: boolean,\n\n    /**\n     * Whether to disable the auto-restart toggle.\n     */\n    \"autoRestart\"?: boolean,\n\n    /**\n     * Whether to disable the Pterodactyl toggle.\n     */\n    \"pterodactyl\"?: boolean,\n\n    /**\n     * Whether to disable the incubating vectors toggle.\n     */\n    \"modernVectors\"?: boolean,\n\n    /**\n     * Whether to disable the download button.\n     */\n    \"download\"?: boolean\n};\n\n'flags.sh/app/data/Flags.tsx'\n:import { DisabledOptions } from \"./interface/DisabledOptions\";\n\n/**\n * Additional configuration for Aikar's flags.\n */\nconst aikarsFlags = {\n    \"base\": \"-XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -XX:G1RSetUpdatingPauseTimePercent=5 -XX:SurvivorRatio=32 -XX:+PerfDisableSharedMem -XX:MaxTenuringThreshold=1 -Dusing.aikars.flags=https://mcflags.emc.gs -Daikars.new.flags=true\",\n    \"standard\": \"-XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20\",\n    \"large\": \"-XX:G1NewSizePercent=40 -XX:G1MaxNewSizePercent=50 -XX:G1HeapRegionSize=16M -XX:G1ReservePercent=15\"\n};\n\n/**\n * Options for the flag results.\n */\ninterface ResultOptions extends PrefixOptions, SuffixOptions {};\n\n/**\n * Options for the flag prefix.\n */\ninterface PrefixOptions {\n    /**\n     * The amount of memory to allocate in gigabytes.\n     */\n    \"memory\": number,\n\n    /**\n     * Whether to recalculate memory and add flags for Pterodactyl's console.\n     */\n    \"pterodactyl\": boolean,\n\n    /**\n     * Whether to add incubating vector flags for modern versions of Java Hotspot.\n     */\n    \"modernVectors\": boolean,\n}\n\n/**\n * Options for the flag suffix.\n */\ninterface SuffixOptions {\n    /**\n     * Filename to start.\n     */\n    \"filename\": string,\n\n    /**\n     * Whether to enable the GUI.\n     */\n    \"gui\": boolean\n}\n\n/**\n * A flag type.\n */\nexport interface FlagType {\n    /**\n     * The key utilized in the flag selector.\n     */\n    \"key\": string,\n\n    /**\n     * The label to use in the flag selector.\n     */\n    \"label\": string,\n\n    /**\n     * The description to use in the flag selector.\n     */\n    \"description\"?: string,\n\n    /**\n     * The function used to get the results.\n     */\n    \"result\": ({ memory, filename, gui, modernVectors }: ResultOptions) => string,\n\n    /**\n     * Options for the disabled components.\n     */\n    \"disabled\"?: DisabledOptions\n}\n\n/**\n * Interface for the Flags object.\n */\nexport interface FlagsInterface {\n    /**\n     * The default flags.\n     */\n    \"default\": FlagType,\n\n    /**\n     * Flag types.\n     */\n    \"types\": {\n        [key: string]: FlagType\n    },\n\n    /**\n     * Prefix of every flag type.\n     */\n    \"prefix\": ({ memory, modernVectors }: PrefixOptions) => string,\n\n    /**\n     * Suffix of every flag type.\n     */\n    \"suffix\": ({ filename, gui }: SuffixOptions) => string\n}\n\n/**\n * The flags that are available to the app.\n */\nexport const Flags: FlagsInterface = {\n    get \"default\"() {\n        return this.types.aikars;\n    },\n    \"types\": {\n        \"none\": {\n            \"key\": \"none\",\n            \"label\": \"None\",\n            \"result\": ({ memory, filename, gui, pterodactyl, modernVectors }) => {\n                return `${Flags.prefix({ memory, pterodactyl, modernVectors })} ${Flags.suffix({ filename, gui })}`;\n            }\n        },\n        \"aikars\": {\n            \"key\": \"aikars\",\n            \"label\": \"Aikar's Flags\",\n            \"description\": \"The high-performance and recommended flags.\",\n            \"result\": ({ memory, filename, gui, pterodactyl, modernVectors }) => {\n                const base = `${aikarsFlags.base} ${memory >= 12 ? aikarsFlags.large : aikarsFlags.standard}`;\n                return `${Flags.prefix({ memory, pterodactyl, modernVectors })} ${base} ${Flags.suffix({ filename, gui })}`;\n            }\n        },\n        \"velocity\": {\n            \"key\": \"velocity\",\n            \"label\": \"Velocity & Waterfall\",\n            \"description\": \"Flags that work best with proxy software.\",\n            \"result\": ({ memory, filename, gui, pterodactyl, modernVectors }) => {\n                const base = \"-XX:+UseG1GC -XX:G1HeapRegionSize=4M -XX:+UnlockExperimentalVMOptions -XX:+ParallelRefProcEnabled -XX:+AlwaysPreTouch -XX:MaxInlineLevel=15\";\n                return `${Flags.prefix({ memory, pterodactyl, modernVectors })} ${base} ${Flags.suffix({ filename, gui })}`;\n            },\n            \"disabled\": {\n                \"gui\": true,\n                \"modernVectors\": true\n            }\n        }\n    },\n    \"prefix\": ({ memory, pterodactyl, modernVectors }) => {\n        const displayMemory = `${(memory * 1024)?.toFixed(0)}M`;\n        let base = `java -Xms${displayMemory} -Xmx${displayMemory}`;\n\n        // Pterodactyl flags\n        if (pterodactyl) {\n            base += \" -Dterminal.jline=false -Dterminal.ansi=true\";\n        }\n\n        // SIMD vectors\n        if (modernVectors) {\n            base += \" --add-modules=jdk.incubator.vector\";\n        }\n\n        return base;\n    },\n    \"suffix\": ({ filename, gui }) => {\n        return `-jar ${filename} ${!gui ? \"--nogui\" : \"\"}`.trim();\n    }\n};\n\n'flags.sh/app/pages/index.tsx'\n:import { useEffect, useState } from \"react\";\nimport { Center, Group, Paper, Text, TextInput, Title, Switch, Code, ActionIcon, useMantineColorScheme, Select } from \"@mantine/core\";\nimport { InputCaption, Label, MarkedSlider, saveText, SelectDescription, SideBySide } from \"@encode42/mantine-extras\";\nimport { IconAlertCircle, IconArchive, IconDownload, IconTool } from \"@tabler/icons\";\nimport { Prism } from \"@mantine/prism\";\nimport { Layout } from \"../core/layout/Layout\";\nimport { PageTitle } from \"../core/components/PageTitle\";\nimport { FooterRow } from \"../core/components/actionButton/FooterRow\";\nimport { FlagModal } from \"../core/components/modal/FlagModal\";\nimport { MemoryModal } from \"../core/components/modal/MemoryModal\";\nimport { Flags, FlagType } from \"../data/Flags\";\nimport { EnvironmentIcon, Environments, EnvironmentType, getIcon } from \"../data/Environments\";\n\n// TODO: API\n// TODO: Share button\n// TODO: i18n\n\n// BUG: Java tab -> enable pterodactyl -> apply -> disable pterodactyl -> apply -> GUI will still be disabled\n\n/**\n * Data for a flag in the selector.\n */\ninterface FlagSelector {\n    /**\n     * Key of the entry.\n     */\n    \"value\": string,\n\n    /**\n     * Label of the entry.\n     */\n    \"label\": string,\n\n    /**\n     * Description of the entry.\n     */\n    \"description\"?: string\n}\n\ninterface EnvironmentTab {\n    \"key\": string,\n    \"label\": string,\n    \"icon\": EnvironmentIcon\n}\n\ninterface HomeProps {\n    \"environmentTabs\": EnvironmentTab[],\n    \"flagSelectors\": FlagSelector[]\n}\n\n/**\n * The homepage of the site.\n */\nfunction Home({ environmentTabs, flagSelectors }: HomeProps) {\n    const { colorScheme } = useMantineColorScheme();\n    const isDark = colorScheme === \"dark\";\n\n    const defaultFilename = \"server.jar\";\n    const [filename, setFileName] = useState<string>(defaultFilename);\n    const [memory, setMemory] = useState<number>(4);\n\n    const [toggles, setToggles] = useState({\n        \"gui\": false,\n        \"autoRestart\": false,\n        \"pterodactyl\": false,\n        \"modernVectors\": true\n    });\n\n    const [result, setResult] = useState<string>(\"Loading...\");\n\n    const [environment, setEnvironment] = useState<EnvironmentType>(Environments.default);\n    const [selectedFlags, setSelectedFlags] = useState<FlagType>(Flags.default);\n    const [invalidFilename, setInvalidFilename] = useState<boolean | string>(false);\n\n    const [openMemoryModal, setOpenMemoryModal] = useState(false);\n    const [openFlagModal, setOpenFlagModal] = useState(false);\n\n    const [disabled, setDisabled] = useState({ ...selectedFlags.disabled, ...environment.disabled });\n\n    // The environment's toggles have changed\n    useEffect(() => {\n        if (!environment.requires) {\n            return;\n        }\n\n        // Iterate each requirement\n        for (const [key, value] of Object.entries(environment.requires)) {\n            const newDisabled = disabled;\n\n            // Iterate each exclusion\n            for (const exclude of value.excludes) {\n                // Disable toggles if required\n                if (toggles[exclude]) {\n                    newDisabled[key] = true;\n                }\n            }\n\n            setDisabled(newDisabled);\n        }\n    }, [toggles, disabled, environment]);\n\n    // Update the disabled components\n    useEffect(() => {\n        setDisabled({ ...selectedFlags.disabled, ...environment.disabled });\n    }, [environment.disabled, selectedFlags.disabled]);\n\n    // An option has been changed\n    useEffect(() => {\n        // Get the target memory\n        let targetMem = memory;\n        if (!disabled.pterodactyl && toggles.pterodactyl) {\n            targetMem = (85 / 100) * targetMem;\n        }\n\n        // Create the script\n        const flags = selectedFlags.result({\n            \"memory\": targetMem,\n            \"filename\": filename.replaceAll(/\\s/g, \"\\\\ \"),\n            \"gui\": !disabled.gui && toggles.gui,\n            \"pterodactyl\": !disabled.pterodactyl && toggles.pterodactyl,\n            \"modernVectors\": !disabled.modernVectors && toggles.modernVectors\n        });\n        const script = environment.result({ flags, \"autoRestart\": toggles.autoRestart });\n\n        setResult(script);\n    }, [filename, memory, toggles, selectedFlags, environment, disabled]);\n\n    return (\n        <>\n            {/* The control center */}\n            <Center sx={{\n                \"height\": \"100%\"\n            }}>\n                <Paper padding=\"md\" shadow=\"sm\" withBorder sx={theme => ({\n                    \"width\": \"100%\",\n                    \"backgroundColor\": isDark ? theme.colors.dark[6] : theme.colors.gray[0]\n                })}>\n                    <Group direction=\"column\" grow>\n                        <PageTitle />\n                        <Group grow sx={{\n                            \"alignItems\": \"flex-start\"\n                        }}>\n                            {/* Left options */}\n                            <Group direction=\"column\" grow>\n                                {/* Filename selector */}\n                                <InputCaption text=\"The file used to launch the server. Located in the same directory as your configuration files.\">\n                                    <Label label=\"Filename\">\n                                        <TextInput defaultValue={defaultFilename} error={invalidFilename} icon={<IconArchive />} onChange={event => {\n                                            const value = event.target.value;\n\n                                            // Ensure the input is valid\n                                            if (!value.includes(\".jar\")) {\n                                                setInvalidFilename(\"Filename must end with .jar\");\n                                            } else {\n                                                setInvalidFilename(false);\n                                                setFileName(event.target.value);\n                                            }\n                                        }}/>\n                                    </Label>\n                                </InputCaption>\n\n                                {/* Memory selector */}\n                                <Label label=\"Memory\" icon={\n                                    <ActionIcon size=\"xs\" variant=\"transparent\" onClick={() => {\n                                        setOpenMemoryModal(true);\n                                    }}>\n                                        <IconTool />\n                                    </ActionIcon>\n                                }>\n                                    <MarkedSlider interval={4} step={0.5} min={0.5} max={24} value={memory} thumbLabel=\"Memory allocation slider\" label={value => {\n                                        return `${value.toFixed(1)} GB`;\n                                    }} intervalLabel={value => {\n                                        return `${value} GB`;\n                                    }} onChange={value => {\n                                        setMemory(value);\n                                    }}/>\n                                </Label>\n                            </Group>\n\n                            {/* Right options */}\n                            <Group direction=\"column\" grow>\n                                {/* Flags selector */}\n                                <Label label=\"Flags\" icon={\n                                    <ActionIcon size=\"xs\" variant=\"transparent\" onClick={() => {\n                                        setOpenFlagModal(true);\n                                    }}>\n                                        <IconTool />\n                                    </ActionIcon>\n                                }>\n                                    <Select value={selectedFlags.key} itemComponent={SelectDescription} styles={theme => ({\n                                        \"dropdown\": {\n                                            \"background\": isDark ? theme.colors.dark[8] : theme.colors.gray[0]\n                                        }\n                                    })} onChange={value => {\n                                        if (!value) {\n                                            return;\n                                        }\n\n                                        setSelectedFlags(Flags.types[value] ?? selectedFlags);\n                                    }} data={flagSelectors} />\n                                </Label>\n\n                                {/* Misc toggles */}\n                                <InputCaption text=\"Enables the server's GUI control panel. Automatically disabled in environments without a desktop.\">\n                                    <Switch label=\"GUI\" checked={!disabled.gui && toggles.gui} disabled={disabled.gui} onChange={event => {\n                                        setToggles({ ...toggles, \"gui\": event.target.checked });\n                                    }} />\n                                </InputCaption>\n                                <InputCaption text={`Automatically restarts the server after it crashes or is stopped. Press CTRL + C to exit the script.`}>\n                                    <Switch label=\"Auto-restart\" checked={!disabled.autoRestart && toggles.autoRestart} disabled={disabled.autoRestart} onChange={event => {\n                                        setToggles({ ...toggles, \"autoRestart\": event.target.checked });\n                                    }} />\n                                </InputCaption>\n                            </Group>\n                        </Group>\n\n                        {/* Resulting flags */}\n                        <Label label={<Text size=\"xl\" weight={700}>Result</Text>}>\n                            <Prism.Tabs styles={theme => ({\n                                \"copy\": {\n                                    \"backgroundColor\": isDark ? theme.colors.dark[6] : theme.colors.gray[0],\n                                    \"borderRadius\": theme.radius.xs\n                                },\n                                \"line\": {\n                                    \"whiteSpace\": \"pre-wrap\"\n                                }\n                            })} onTabChange={active => {\n                                // Get the selected type from the tab\n                                const key = Object.keys(Environments.types)[active]; // TODO: This is unreliable, but tabKey does not work\n                                if (!key) {\n                                    return;\n                                }\n\n                                // Toggle the non-applicable components\n                                const env = Environments.types[key];\n                                if (!env) {\n                                    return;\n                                }\n\n                                setEnvironment(env);\n                            }}>\n                                {environmentTabs.map(env => (\n                                    <Prism.Tab key={env.key} label={env.label} icon={getIcon(env.icon)} withLineNumbers language=\"bash\">\n                                        {result}\n                                    </Prism.Tab>\n                                ))}\n                            </Prism.Tabs>\n                        </Label>\n\n                        {/* Footer links */}\n                        <SideBySide leftSide={\n                            <Group noWrap>\n                                {/* Download button */}\n                                <ActionIcon color=\"green\" variant=\"filled\" size=\"lg\" title=\"Download current script\" disabled={disabled.download} onClick={() => {\n                                    if (environment.file) {\n                                        saveText(result, environment.file);\n                                    }\n                                }}>\n                                    <IconDownload />\n                                </ActionIcon>\n\n                                {/* Low memory alert */}\n                                <Group spacing=\"xs\" noWrap sx={{\n                                    \"display\": memory < 4 ? \"\" : \"none\"\n                                }}>\n                                    <IconAlertCircle />\n                                    <Text sx={{\n                                        \"whiteSpace\": \"pre-wrap\"\n                                    }}>It is recommended to allocate at least <Code>4 GB</Code> of memory.</Text>\n                                </Group>\n                            </Group>\n                        } rightSide={\n                            /* Misc links */\n                            <FooterRow />\n                        } />\n                    </Group>\n                </Paper>\n            </Center>\n\n            {/* Modals */}\n            <MemoryModal open={{\n                \"value\": openMemoryModal,\n                \"set\": setOpenMemoryModal\n            }} defaultMemory={{\n                \"value\": memory,\n                \"set\": setMemory\n            }} defaultPterodactyl={{\n                \"value\": !disabled.pterodactyl && toggles.pterodactyl,\n                \"set\": value => {\n                    setToggles({ ...toggles, \"pterodactyl\": value });\n                },\n                \"disabled\": disabled.pterodactyl ?? false\n            }} />\n\n            <FlagModal open={{\n                \"value\": openFlagModal,\n                \"set\": setOpenFlagModal\n            }} defaultModernVectors={{\n                \"value\": !disabled.modernVectors && toggles.modernVectors,\n                \"set\": value => {\n                    setToggles({ ...toggles, \"modernVectors\": value });\n                },\n                \"disabled\": disabled.modernVectors ?? false\n            }} />\n\n        </>\n    );\n}\n\nHome.getLayout = page => <Layout>{page}</Layout>;\n\nexport function getStaticProps() {\n    // Generate environment tabs from environments\n    const environmentTabs: EnvironmentTab[] = [];\n    for (const [key, value] of Object.entries(Environments.types)) {\n        environmentTabs.push({\n            \"key\": key,\n            \"label\": value.label,\n            \"icon\": value.icon\n        });\n    }\n\n    // Generate flag selector\n    const flagSelectors: FlagSelector[] = [];\n    for (const value of Object.values(Flags.types)) {\n        flagSelectors.push({\n            \"value\": value.key,\n            \"label\": value.label,\n            \"description\": value.description\n        });\n    }\n\n    return {\n        \"props\": {\n            environmentTabs,\n            flagSelectors\n        }\n    };\n}\n\nexport default Home;\n\n",
        "called_code_segment_file_1": "`result: ({ memory, filename, gui, pterodactyl, modernVectors }: ResultOptions) => { const base = `${aikarsFlags.base} ${memory >= 12 ? aikarsFlags.large : aikarsFlags.standard}`; return `${Flags.prefix({ memory, pterodactyl, modernVectors })} ${base} ${Flags.suffix({ filename, gui })}`; }`",
        "invoking_code_segment_file_2": "`const flags = selectedFlags.result({ memory: targetMem, filename: filename.replaceAll(/\\s/g, \"\\\\ \"), gui: !disabled.gui && toggles.gui, pterodactyl: !disabled.pterodactyl && toggles.pterodactyl, modernVectors: !disabled.modernVectors && toggles.modernVectors });`",
        "called_code_segment_file_2": "`const script = environment.result({ flags, autoRestart: toggles.autoRestart });`",
        "using_code_segment_file_3": "`<Prism.Tab key={env.key} label={env.label} icon={getIcon(env.icon)} withLineNumbers language=\"bash\"> {result} </Prism.Tab>`",
        "feature_description": "Add a new feature to include a custom JVM option for enabling verbose garbage collection (GC) logging.",
        "detailed_feature_description": "The new feature will add a JVM option `-Xlog:gc*=info:file=gc.log` to the flags generated by `#file 1`. This will enable verbose GC logging to a file named `gc.log`. The modification in `#file 1` will include this option in the `result` function. `#file 2` will handle the updated `result` function and pass the new option to `#file 3` for rendering in the UI.",
        "modified_complete_code": {
            "#file 1": "```typescript\nresult: ({ memory, filename, gui, pterodactyl, modernVectors }: ResultOptions) => {\n    const base = `${aikarsFlags.base} ${memory >= 12 ? aikarsFlags.large : aikarsFlags.standard}`;\n    return `${Flags.prefix({ memory, pterodactyl, modernVectors })} ${base} -Xlog:gc*=info:file=gc.log ${Flags.suffix({ filename, gui })}`; #Modify\n}\n```",
            "#file 2": "```typescript\nconst flags = selectedFlags.result({\n    memory: targetMem,\n    filename: filename.replaceAll(/\\s/g, \"\\\\ \"),\n    gui: !disabled.gui && toggles.gui,\n    pterodactyl: !disabled.pterodactyl && toggles.pterodactyl,\n    modernVectors: !disabled.modernVectors && toggles.modernVectors\n});\n\nconst script = environment.result({ flags, autoRestart: toggles.autoRestart });\n```",
            "#file 3": "```typescript\n<Prism.Tab key={env.key} label={env.label} icon={getIcon(env.icon)} withLineNumbers language=\"bash\">\n    {result}\n</Prism.Tab>\n```"
        }
    },
    {
        "repo": "graphql-compose-pagination",
        "content": "'graphql-compose-pagination/src/types.ts'\n:import {\n  upperFirst,\n  ObjectTypeComposer,\n  SchemaComposer,\n  InterfaceTypeComposer,\n  UnionTypeComposer,\n  ScalarTypeComposer,\n  EnumTypeComposer,\n} from 'graphql-compose';\n\n// PaginationInfo should be global\nconst PaginationInfoTC = ObjectTypeComposer.createTemp(`\n# Information about pagination.\ntype PaginationInfo {\n  # Current page number\n  currentPage: Int!\n  \n  # Number of items per page\n  perPage: Int!\n  \n  # Total number of pages\n  pageCount: Int\n  \n  # Total number of items\n  itemCount: Int\n  \n  # When paginating forwards, are there more items?\n  hasNextPage: Boolean\n  \n  # When paginating backwards, are there more items?\n  hasPreviousPage: Boolean\n}\n`);\n\nexport function preparePaginationInfoTC<TContext>(\n  sc: SchemaComposer<TContext>\n): ObjectTypeComposer<any, TContext> {\n  // Pagination Info can be overrided via SchemaComposer registry\n  if (sc.has('PaginationInfo')) {\n    return sc.getOTC('PaginationInfo');\n  }\n  sc.set('PaginationInfo', PaginationInfoTC);\n  return PaginationInfoTC;\n}\n\nexport function preparePaginationTC<TSource, TContext>(\n  tc:\n    | ObjectTypeComposer<TSource, TContext>\n    | InterfaceTypeComposer<TSource, TContext>\n    | UnionTypeComposer<TSource, TContext>\n    | ScalarTypeComposer<TContext>\n    | EnumTypeComposer<TContext>,\n  resolverName?: string\n): ObjectTypeComposer<TSource, TContext> {\n  const schemaComposer = tc.schemaComposer;\n  const name = `${tc.getTypeName()}${upperFirst(resolverName || 'pagination')}`;\n\n  if (schemaComposer.has(name)) {\n    return schemaComposer.getOTC(name);\n  }\n\n  const paginationTC = schemaComposer.createObjectTC({\n    name,\n    description: 'List of items with pagination.',\n    fields: {\n      count: {\n        type: 'Int',\n        description: 'Total object count.',\n      },\n      items: {\n        type: () => tc.NonNull.List,\n        description: 'Array of objects.',\n      },\n      pageInfo: {\n        type: preparePaginationInfoTC(schemaComposer).NonNull,\n        description: 'Information to aid in pagination.',\n      },\n    },\n  });\n\n  return paginationTC;\n}\n\n'graphql-compose-pagination/src/pagination.ts'\n:import { Resolver, inspect } from 'graphql-compose';\nimport type {\n  ObjectTypeComposer,\n  InterfaceTypeComposer,\n  UnionTypeComposer,\n  ScalarTypeComposer,\n  EnumTypeComposer,\n  ResolverResolveParams,\n  ObjectTypeComposerArgumentConfigMap,\n} from 'graphql-compose';\nimport { preparePaginationTC } from './types';\n\nexport const DEFAULT_RESOLVER_NAME = 'pagination';\nexport const DEFAULT_PER_PAGE = 20;\nconst ALLOWED_TYPE_COMPOSERS = [\n  'ObjectTypeComposer',\n  'InterfaceTypeComposer',\n  'UnionTypeComposer',\n  'ScalarTypeComposer',\n  'EnumTypeComposer',\n];\n\nexport type PaginationResolverOpts = {\n  findManyResolver: Resolver;\n  countResolver: Resolver;\n  name?: string;\n  perPage?: number;\n};\n\nexport type PaginationType = {\n  count: number;\n  items: any[];\n  pageInfo: PaginationInfoType;\n};\n\nexport type PaginationInfoType = {\n  currentPage: number;\n  perPage: number;\n  itemCount: number;\n  pageCount: number;\n  hasPreviousPage: boolean;\n  hasNextPage: boolean;\n};\n\nexport interface PaginationTArgs {\n  page?: number;\n  perPage?: number;\n  filter?: any;\n  sort?: any;\n}\n\nexport function preparePaginationResolver<TSource, TContext>(\n  tc:\n    | ObjectTypeComposer<TSource, TContext>\n    | InterfaceTypeComposer<TSource, TContext>\n    | UnionTypeComposer<TSource, TContext>\n    | ScalarTypeComposer<TContext>\n    | EnumTypeComposer<TContext>,\n  opts: PaginationResolverOpts\n): Resolver<TSource, TContext, PaginationTArgs> {\n  if (!tc || !ALLOWED_TYPE_COMPOSERS.includes(tc.constructor.name)) {\n    throw new Error(\n      `First arg for preparePaginationResolver() should be instance of ${ALLOWED_TYPE_COMPOSERS.join(\n        ' or '\n      )}`\n    );\n  }\n\n  const resolverName = opts.name || DEFAULT_RESOLVER_NAME;\n\n  if (!opts.countResolver || !(opts.countResolver instanceof Resolver)) {\n    throw new Error(\n      `Option 'opts.countResolver' must be a Resolver instance. Received ${inspect(\n        opts.countResolver\n      )}`\n    );\n  }\n\n  const countResolve = opts.countResolver.getResolve();\n\n  if (!opts.findManyResolver || !(opts.findManyResolver instanceof Resolver)) {\n    throw new Error(\n      `Option 'opts.findManyResolver' must be a Resolver instance. Received ${inspect(\n        opts.findManyResolver\n      )}`\n    );\n  }\n  const findManyResolver = opts.findManyResolver;\n  const findManyResolve = findManyResolver.getResolve();\n\n  const additionalArgs: ObjectTypeComposerArgumentConfigMap = {};\n  if (findManyResolver.hasArg('filter')) {\n    const filter = findManyResolver.getArg('filter');\n    if (filter) {\n      additionalArgs.filter = filter;\n    }\n  }\n  if (findManyResolver.hasArg('sort')) {\n    const sort = findManyResolver.getArg('sort');\n    if (sort) {\n      additionalArgs.sort = sort;\n    }\n  }\n\n  return tc.schemaComposer.createResolver({\n    type: preparePaginationTC(tc, resolverName),\n    name: resolverName,\n    kind: 'query',\n    args: {\n      page: {\n        type: 'Int',\n        description: 'Page number for displaying',\n      },\n      perPage: {\n        type: 'Int',\n        description: '',\n        defaultValue: opts.perPage || DEFAULT_PER_PAGE,\n      },\n      ...(additionalArgs as any),\n    },\n    resolve: async (rp: ResolverResolveParams<TSource, TContext, PaginationTArgs>) => {\n      let countPromise;\n      let findManyPromise;\n      const { projection = {}, args, rawQuery } = rp;\n\n      const page = parseInt(args.page as any, 10) || 1;\n      if (page <= 0) {\n        throw new Error('Argument `page` should be positive number.');\n      }\n      const perPage = parseInt(args.perPage as any, 10) || opts.perPage || DEFAULT_PER_PAGE;\n      if (perPage <= 0) {\n        throw new Error('Argument `perPage` should be positive number.');\n      }\n\n      const countParams: ResolverResolveParams<TSource, TContext, any> = {\n        ...rp,\n        rawQuery,\n        args: {\n          ...rp.args,\n          filter: { ...rp.args.filter },\n        },\n      };\n\n      if (\n        projection.count ||\n        (projection.pageInfo && (projection.pageInfo.itemCount || projection.pageInfo.pageCount))\n      ) {\n        countPromise = countResolve(countParams);\n      } else {\n        countPromise = Promise.resolve(0);\n      }\n\n      const findManyParams: ResolverResolveParams<TSource, TContext, any> = {\n        ...rp,\n      };\n\n      if (projection && projection.items) {\n        // combine top level projection\n        // (maybe somebody add additional fields via rp.projection)\n        // and items (record needed fields)\n        findManyParams.projection = { ...projection, ...projection.items };\n      } else {\n        findManyParams.projection = { ...projection };\n      }\n\n      const limit = perPage;\n      const skip = (page - 1) * perPage;\n\n      findManyParams.args.limit = limit + 1; // +1 document, to check next page presence\n      if (skip > 0) {\n        findManyParams.args.skip = skip;\n      }\n\n      // pass findMany ResolveParams to top resolver\n      rp.findManyResolveParams = findManyParams;\n      rp.countResolveParams = countParams;\n\n      // This allows to optimize and not actually call the findMany resolver\n      // if only the count is projected\n      if ((projection.count || projection.pageInfo) && Object.keys(projection).length === 1) {\n        findManyPromise = Promise.resolve([]);\n      } else {\n        findManyPromise = findManyResolve(findManyParams);\n      }\n\n      return Promise.all([findManyPromise, countPromise]).then(([items, count]) => {\n        const result: PaginationType = {\n          count,\n          items: items.length > limit ? items.slice(0, limit) : items,\n          pageInfo: {\n            currentPage: page,\n            perPage,\n            itemCount: count,\n            pageCount: Math.ceil(count / perPage),\n            hasPreviousPage: page > 1,\n            hasNextPage: items.length > limit || page * perPage < count,\n          },\n        };\n        return result;\n      });\n    },\n  });\n}\n\n'graphql-compose-pagination/src/index.ts'\n:import { preparePaginationResolver } from './pagination';\nimport { composeWithPagination } from './composeWithPagination';\n\nexport { composeWithPagination, preparePaginationResolver };\n\nexport type {\n  PaginationResolverOpts,\n  PaginationTArgs,\n  PaginationType,\n  PaginationInfoType,\n} from './pagination';\n\n",
        "called_code_segment_file_1": "export function preparePaginationTC<TSource, TContext>(tc: ObjectTypeComposer<TSource, TContext> | InterfaceTypeComposer<TSource, TContext> | UnionTypeComposer<TSource, TContext> | ScalarTypeComposer<TContext> | EnumTypeComposer<TContext>, resolverName?: string): ObjectTypeComposer<TSource, TContext> {\n  const schemaComposer = tc.schemaComposer;\n  const name = `${tc.getTypeName()}${upperFirst(resolverName || 'pagination')}`;\n\n  if (schemaComposer.has(name)) {\n    return schemaComposer.getOTC(name);\n  }\n\n  const paginationTC = schemaComposer.createObjectTC({\n    name,\n    description: 'List of items with pagination.',\n    fields: {\n      count: {\n        type: 'Int',\n        description: 'Total object count.'\n      },\n      items: {\n        type: () => tc.NonNull.List,\n        description: 'Array of objects.'\n      },\n      pageInfo: {\n        type: preparePaginationInfoTC(schemaComposer).NonNull,\n        description: 'Information to aid in pagination.'\n      }\n    }\n  });\n\n  return paginationTC;\n}",
        "invoking_code_segment_file_2": "export function preparePaginationResolver<TSource, TContext>(tc: ObjectTypeComposer<TSource, TContext> | InterfaceTypeComposer<TSource, TContext> | UnionTypeComposer<TSource, TContext> | ScalarTypeComposer<TContext> | EnumTypeComposer<TContext>, opts: PaginationResolverOpts): Resolver<TSource, TContext, PaginationTArgs> {\n  if (!tc || !ALLOWED_TYPE_COMPOSERS.includes(tc.constructor.name)) {\n    throw new Error(`First arg for preparePaginationResolver() should be instance of ${ALLOWED_TYPE_COMPOSERS.join(' or ')}`);\n  }\n\n  const resolverName = opts.name || DEFAULT_RESOLVER_NAME;\n\n  if (!opts.countResolver || !(opts.countResolver instanceof Resolver)) {\n    throw new Error(`Option 'opts.countResolver' must be a Resolver instance. Received ${inspect(opts.countResolver)}`);\n  }\n\n  const countResolve = opts.countResolver.getResolve();\n\n  if (!opts.findManyResolver || !(opts.findManyResolver instanceof Resolver)) {\n    throw new Error(`Option 'opts.findManyResolver' must be a Resolver instance. Received ${inspect(opts.findManyResolver)}`);\n  }\n  const findManyResolver = opts.findManyResolver;\n  const findManyResolve = findManyResolver.getResolve();\n\n  const additionalArgs: ObjectTypeComposerArgumentConfigMap = {};\n  if (findManyResolver.hasArg('filter')) {\n    const filter = findManyResolver.getArg('filter');\n    if (filter) {\n      additionalArgs.filter = filter;\n    }\n  }\n  if (findManyResolver.hasArg('sort')) {\n    const sort = findManyResolver.getArg('sort');\n    if (sort) {\n      additionalArgs.sort = sort;\n    }\n  }\n\n  return tc.schemaComposer.createResolver({\n    type: preparePaginationTC(tc, resolverName),\n    name: resolverName,\n    kind: 'query',\n    args: {\n      page: {\n        type: 'Int',\n        description: 'Page number for displaying'\n      },\n      perPage: {\n        type: 'Int',\n        description: '',\n        defaultValue: opts.perPage || DEFAULT_PER_PAGE\n      },\n      ...(additionalArgs as any)\n    },\n    resolve: async (rp: ResolverResolveParams<TSource, TContext, PaginationTArgs>) => {\n      let countPromise;\n      let findManyPromise;\n      const { projection = {}, args, rawQuery } = rp;\n\n      const page = parseInt(args.page as any, 10) || 1;\n      if (page <= 0) {\n        throw new Error('Argument `page` should be positive number.');\n      }\n      const perPage = parseInt(args.perPage as any, 10) || opts.perPage || DEFAULT_PER_PAGE;\n      if (perPage <= 0) {\n        throw new Error('Argument `perPage` should be positive number.');\n      }\n\n      const countParams: ResolverResolveParams<TSource, TContext, any> = {\n        ...rp,\n        rawQuery,\n        args: {\n          ...rp.args,\n          filter: { ...rp.args.filter },\n        },\n      };\n\n      if (\n        projection.count ||\n        (projection.pageInfo && (projection.pageInfo.itemCount || projection.pageInfo.pageCount))\n      ) {\n        countPromise = countResolve(countParams);\n      } else {\n        countPromise = Promise.resolve(0);\n      }\n\n      const findManyParams: ResolverResolveParams<TSource, TContext, any> = {\n        ...rp,\n      };\n\n      if (projection && projection.items) {\n        findManyParams.projection = { ...projection, ...projection.items };\n      } else {\n        findManyParams.projection = { ...projection };\n      }\n\n      const limit = perPage;\n      const skip = (page - 1) * perPage;\n\n      findManyParams.args.limit = limit + 1; // +1 document, to check next page presence\n      if (skip > 0) {\n        findManyParams.args.skip = skip;\n      }\n\n      rp.findManyResolveParams = findManyParams;\n      rp.countResolveParams = countParams;\n\n      if ((projection.count || projection.pageInfo) && Object.keys(projection).length === 1) {\n        findManyPromise = Promise.resolve([]);\n      } else {\n        findManyPromise = findManyResolve(findManyParams);\n      }\n\n      return Promise.all([findManyPromise, countPromise]).then(([items, count]) => {\n        const result: PaginationType = {\n          count,\n          items: items.length > limit ? items.slice(0, limit) : items,\n          pageInfo: {\n            currentPage: page,\n            perPage,\n            itemCount: count,\n            pageCount: Math.ceil(count / perPage),\n            hasPreviousPage: page > 1,\n            hasNextPage: items.length > limit || page * perPage < count,\n          },\n        };\n        return result;\n      });\n    },\n  });\n}",
        "called_code_segment_file_2": "export function composeWithPagination<TSource, TContext>(tc: ObjectTypeComposer<TSource, TContext> | InterfaceTypeComposer<TSource, TContext> | UnionTypeComposer<TSource, TContext> | ScalarTypeComposer<TContext> | EnumTypeComposer<TContext>, opts: PaginationResolverOpts): Resolver<TSource, TContext, PaginationTArgs> {\n  return preparePaginationResolver(tc, opts);\n}",
        "using_code_segment_file_3": "export { composeWithPagination, preparePaginationResolver };\n\nexport type { PaginationResolverOpts, PaginationTArgs, PaginationType, PaginationInfoType } from './pagination';",
        "feature_description": "Add support for custom pagination fields in the PaginationInfo type.",
        "detailed_feature_description": "The new feature allows users to specify custom fields in the PaginationInfo type. This is achieved by modifying the `preparePaginationTC` function in `#file 1` to accept an optional configuration object for custom fields. The `preparePaginationResolver` function in `#file 2` is updated to pass these custom fields to the `preparePaginationTC` function. The `composeWithPagination` function in `#file 3` remains unchanged as it directly uses the `preparePaginationResolver` function.",
        "modified_complete_code": {
            "#file 1": "export function preparePaginationTC<TSource, TContext>(tc: ObjectTypeComposer<TSource, TContext> | InterfaceTypeComposer<TSource, TContext> | UnionTypeComposer<TSource, TContext> | ScalarTypeComposer<TContext> | EnumTypeComposer<TContext>, resolverName?: string, customFields?: Record<string, any>): ObjectTypeComposer<TSource, TContext> {\n  const schemaComposer = tc.schemaComposer;\n  const name = `${tc.getTypeName()}${upperFirst(resolverName || 'pagination')}`;\n\n  if (schemaComposer.has(name)) {\n    return schemaComposer.getOTC(name);\n  }\n\n  const paginationTC = schemaComposer.createObjectTC({\n    name,\n    description: 'List of items with pagination.',\n    fields: {\n      count: {\n        type: 'Int',\n        description: 'Total object count.'\n      },\n      items: {\n        type: () => tc.NonNull.List,\n        description: 'Array of objects.'\n      },\n      pageInfo: {\n        type: preparePaginationInfoTC(schemaComposer).NonNull,\n        description: 'Information to aid in pagination.'\n      },\n      ...(customFields || {})\n    }\n  });\n\n  return paginationTC;\n}",
            "#file 2": "export function preparePaginationResolver<TSource, TContext>(tc: ObjectTypeComposer<TSource, TContext> | InterfaceTypeComposer<TSource, TContext> | UnionTypeComposer<TSource, TContext> | ScalarTypeComposer<TContext> | EnumTypeComposer<TContext>, opts: PaginationResolverOpts & { customFields?: Record<string, any> }): Resolver<TSource, TContext, PaginationTArgs> {\n  if (!tc || !ALLOWED_TYPE_COMPOSERS.includes(tc.constructor.name)) {\n    throw new Error(`First arg for preparePaginationResolver() should be instance of ${ALLOWED_TYPE_COMPOSERS.join(' or ')}`);\n  }\n\n  const resolverName = opts.name || DEFAULT_RESOLVER_NAME;\n\n  if (!opts.countResolver || !(opts.countResolver instanceof Resolver)) {\n    throw new Error(`Option 'opts.countResolver' must be a Resolver instance. Received ${inspect(opts.countResolver)}`);\n  }\n\n  const countResolve = opts.countResolver.getResolve();\n\n  if (!opts.findManyResolver || !(opts.findManyResolver instanceof Resolver)) {\n    throw new Error(`Option 'opts.findManyResolver' must be a Resolver instance. Received ${inspect(opts.findManyResolver)}`);\n  }\n  const findManyResolver = opts.findManyResolver;\n  const findManyResolve = findManyResolver.getResolve();\n\n  const additionalArgs: ObjectTypeComposerArgumentConfigMap = {};\n  if (findManyResolver.hasArg('filter')) {\n    const filter = findManyResolver.getArg('filter');\n    if (filter) {\n      additionalArgs.filter = filter;\n    }\n  }\n  if (findManyResolver.hasArg('sort')) {\n    const sort = findManyResolver.getArg('sort');\n    if (sort) {\n      additionalArgs.sort = sort;\n    }\n  }\n\n  return tc.schemaComposer.createResolver({\n    type: preparePaginationTC(tc, resolverName, opts.customFields),\n    name: resolverName,\n    kind: 'query',\n    args: {\n      page: {\n        type: 'Int',\n        description: 'Page number for displaying'\n      },\n      perPage: {\n        type: 'Int',\n        description: '',\n        defaultValue: opts.perPage || DEFAULT_PER_PAGE\n      },\n      ...(additionalArgs as any)\n    },\n    resolve: async (rp: ResolverResolveParams<TSource, TContext, PaginationTArgs>) => {\n      let countPromise;\n      let findManyPromise;\n      const { projection = {}, args, rawQuery } = rp;\n\n      const page = parseInt(args.page as any, 10) || 1;\n      if (page <= 0) {\n        throw new Error('Argument `page` should be positive number.');\n      }\n      const perPage = parseInt(args.perPage as any, 10) || opts.perPage || DEFAULT_PER_PAGE;\n      if (perPage <= 0) {\n        throw new Error('Argument `perPage` should be positive number.');\n      }\n\n      const countParams: ResolverResolveParams<TSource, TContext, any> = {\n        ...rp,\n        rawQuery,\n        args: {\n          ...rp.args,\n          filter: { ...rp.args.filter },\n        },\n      };\n\n      if (\n        projection.count ||\n        (projection.pageInfo && (projection.pageInfo.itemCount || projection.pageInfo.pageCount))\n      ) {\n        countPromise = countResolve(countParams);\n      } else {\n        countPromise = Promise.resolve(0);\n      }\n\n      const findManyParams: ResolverResolveParams<TSource, TContext, any> = {\n        ...rp,\n      };\n\n      if (projection && projection.items) {\n        findManyParams.projection = { ...projection, ...projection.items };\n      } else {\n        findManyParams.projection = { ...projection };\n      }\n\n      const limit = perPage;\n      const skip = (page - 1) * perPage;\n\n      findManyParams.args.limit = limit + 1; // +1 document, to check next page presence\n      if (skip > 0) {\n        findManyParams.args.skip = skip;\n      }\n\n      rp.findManyResolveParams = findManyParams;\n      rp.countResolveParams = countParams;\n\n      if ((projection.count || projection.pageInfo) && Object.keys(projection).length === 1) {\n        findManyPromise = Promise.resolve([]);\n      } else {\n        findManyPromise = findManyResolve(findManyParams);\n      }\n\n      return Promise.all([findManyPromise, countPromise]).then(([items, count]) => {\n        const result: PaginationType = {\n          count,\n          items: items.length > limit ? items.slice(0, limit) : items,\n          pageInfo: {\n            currentPage: page,\n            perPage,\n            itemCount: count,\n            pageCount: Math.ceil(count / perPage),\n            hasPreviousPage: page > 1,\n            hasNextPage: items.length > limit || page * perPage < count,\n          },\n        };\n        return result;\n      });\n    },\n  });\n}",
            "#file 3": "export { composeWithPagination, preparePaginationResolver };\n\nexport type { PaginationResolverOpts, PaginationTArgs, PaginationType, PaginationInfoType } from './pagination';"
        }
    },
    {
        "repo": "headplane",
        "content": "'headplane/app/routes/_data.settings.auth-keys._index/dialogs/expire.tsx'\n:import { useFetcher } from '@remix-run/react'\nimport type { PreAuthKey } from '~/types'\nimport { cn } from '~/utils/cn'\n\nimport Dialog from '~/components/Dialog'\nimport Spinner from '~/components/Spinner'\n\ninterface Props {\n\tauthKey: PreAuthKey\n}\n\nexport default function ExpireKey({ authKey }: Props) {\n\tconst fetcher = useFetcher()\n\n\treturn (\n\t\t<Dialog>\n\t\t\t<Dialog.Button className=\"my-4\">\n\t\t\t\tExpire Key\n\t\t\t</Dialog.Button>\n\t\t\t<Dialog.Panel>\n\t\t\t\t{close => (\n\t\t\t\t\t<>\n\t\t\t\t\t\t<Dialog.Title>\n\t\t\t\t\t\t\tExpire auth key?\n\t\t\t\t\t\t</Dialog.Title>\n\t\t\t\t\t\t<fetcher.Form method=\"DELETE\" onSubmit={e => {\n\t\t\t\t\t\t\tfetcher.submit(e.currentTarget)\n\t\t\t\t\t\t\tclose()\n\t\t\t\t\t\t}}>\n\t\t\t\t\t\t\t<input type=\"hidden\" name=\"user\" value={authKey.user} />\n\t\t\t\t\t\t\t<input type=\"hidden\" name=\"key\" value={authKey.key} />\n\t\t\t\t\t\t\t<Dialog.Text>\n\t\t\t\t\t\t\t\tExpiring this authentication key will immediately\n\t\t\t\t\t\t\t\tprevent it from being used to authenticate new devices.\n\t\t\t\t\t\t\t\t{' '}\n\t\t\t\t\t\t\t\tThis action cannot be undone.\n\t\t\t\t\t\t\t</Dialog.Text>\n\t\t\t\t\t\t\t<div className=\"mt-6 flex justify-end gap-2 mt-6\">\n\t\t\t\t\t\t\t\t<Dialog.Action\n\t\t\t\t\t\t\t\t\tvariant=\"cancel\"\n\t\t\t\t\t\t\t\t\tonPress={close}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tCancel\n\t\t\t\t\t\t\t\t</Dialog.Action>\n\t\t\t\t\t\t\t\t<Dialog.Action\n\t\t\t\t\t\t\t\t\tvariant=\"confirm\"\n\t\t\t\t\t\t\t\t\tclassName={cn(\n\t\t\t\t\t\t\t\t\t\t'bg-red-500 hover:border-red-700',\n\t\t\t\t\t\t\t\t\t\t'dark:bg-red-600 dark:hover:border-red-700',\n\t\t\t\t\t\t\t\t\t\t'pressed:bg-red-600 hover:bg-red-600',\n\t\t\t\t\t\t\t\t\t\t'text-white dark:text-white',\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\tonPress={close}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t{fetcher.state === 'idle'\n\t\t\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t\t\t: (\n\t\t\t\t\t\t\t\t\t\t\t<Spinner className=\"w-3 h-3\" />\n\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\tExpire\n\t\t\t\t\t\t\t\t</Dialog.Action>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</fetcher.Form>\n\t\t\t\t\t</>\n\t\t\t\t)}\n\t\t\t</Dialog.Panel>\n\t\t</Dialog>\n\t)\n}\n\n'headplane/app/routes/_data.settings.auth-keys._index/key.tsx'\n:import type { PreAuthKey } from '~/types'\nimport { toast } from '~/components/Toaster'\n\nimport Code from '~/components/Code'\nimport Button from '~/components/Button'\nimport Attribute from '~/components/Attribute'\nimport ExpireKey from './dialogs/expire'\n\ninterface Props {\n\tauthKey: PreAuthKey\n\tserver: string\n}\n\nexport default function AuthKeyRow({ authKey, server }: Props) {\n\tconst createdAt = new Date(authKey.createdAt).toLocaleString()\n\tconst expiration = new Date(authKey.expiration).toLocaleString()\n\n\treturn (\n\t\t<div className=\"w-full\">\n\t\t\t<Attribute name=\"Key\" value={authKey.key} isCopyable />\n\t\t\t<Attribute name=\"User\" value={authKey.user} isCopyable />\n\t\t\t<Attribute name=\"Reusable\" value={authKey.reusable ? 'Yes' : 'No'} />\n\t\t\t<Attribute name=\"Ephemeral\" value={authKey.ephemeral ? 'Yes' : 'No'} />\n\t\t\t<Attribute name=\"Used\" value={authKey.used ? 'Yes' : 'No'} />\n\t\t\t<Attribute name=\"Created\" value={createdAt} />\n\t\t\t<Attribute name=\"Expiration\" value={expiration} />\n\t\t\t<p className=\"mb-1 mt-4\">\n\t\t\t\tTo use this key, run the following command on your device:\n\t\t\t</p>\n\t\t\t<Code className=\"text-sm\">\n\t\t\t\ttailscale up --login-server {server} --authkey {authKey.key}\n\t\t\t</Code>\n\t\t\t<div className=\"flex gap-4 items-center\">\n\t\t\t\t{authKey.used || new Date(authKey.expiration) < new Date()\n\t\t\t\t\t? undefined\n\t\t\t\t\t: (\n\t\t\t\t\t\t<ExpireKey authKey={authKey} />\n\t\t\t\t\t)}\n\t\t\t\t<Button\n\t\t\t\t\tvariant=\"light\" \n\t\t\t\t\tclassName=\"my-4\"\n\t\t\t\t\tonClick={async () => {\n\t\t\t\t\t\tawait navigator.clipboard.writeText(\n\t\t\t\t\t\t\t`tailscale up --login-server ${server} --authkey ${authKey.key}`\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\ttoast('Copied command to clipboard')\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\tCopy Tailscale Command\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\n\n'headplane/app/routes/_data.settings.auth-keys._index/route.tsx'\n:import { LoaderFunctionArgs, ActionFunctionArgs, json } from '@remix-run/node'\nimport { useLoaderData } from '@remix-run/react'\nimport { useLiveData } from '~/utils/useLiveData'\nimport { getSession } from '~/utils/sessions'\nimport { Link as RemixLink } from '@remix-run/react'\nimport { PreAuthKey, User } from '~/types'\nimport { pull, post } from '~/utils/headscale'\nimport { loadContext } from '~/utils/config/headplane'\nimport { useState } from 'react'\n\nimport Link from '~/components/Link'\nimport TableList from '~/components/TableList'\nimport Select from '~/components/Select'\nimport Switch from '~/components/Switch'\n\nimport AddPreAuthKey from './dialogs/new'\nimport AuthKeyRow from './key'\n\nexport async function action({ request }: ActionFunctionArgs) {\n\tconst session = await getSession(request.headers.get('Cookie'))\n\tif (!session.has('hsApiKey')) {\n\t\treturn json({ message: 'Unauthorized' }, {\n\t\t\tstatus: 401,\n\t\t})\n\t}\n\n\tconst data = await request.formData()\n\n\t// Expiring a pre-auth key\n\tif (request.method === 'DELETE') {\n\t\tconst key = data.get('key')\n\t\tconst user = data.get('user')\n\n\t\tif (!key || !user) {\n\t\t\treturn json({ message: 'Missing parameters' }, {\n\t\t\t\tstatus: 400,\n\t\t\t})\n\t\t}\n\n\t\tawait post<{ preAuthKey: PreAuthKey }>(\n\t\t\t'v1/preauthkey/expire',\n\t\t\tsession.get('hsApiKey')!, \n\t\t\t{\n\t\t\t\tuser: user,\n\t\t\t\tkey: key,\n\t\t\t}\n\t\t)\n\n\t\treturn json({ message: 'Pre-auth key expired' })\n\t}\n\n\t// Creating a new pre-auth key\n\tif (request.method === 'POST') {\n\t\tconst user = data.get('user')\n\t\tconst expiry = data.get('expiry')\n\t\tconst reusable = data.get('reusable')\n\t\tconst ephemeral = data.get('ephemeral')\n\n\t\tif (!user || !expiry || !reusable || !ephemeral) {\n\t\t\treturn json({ message: 'Missing parameters' }, {\n\t\t\t\tstatus: 400,\n\t\t\t})\n\t\t}\n\n\t\t// Extract the first \"word\" from expiry which is the day number\n\t\t// Calculate the date X days from now using the day number\n\t\tconst day = Number(expiry.toString().split(' ')[0])\n\t\tconst date = new Date()\n\t\tdate.setDate(date.getDate() + day)\n\n\t\tconst key = await post<{ preAuthKey: PreAuthKey }>(\n\t\t\t'v1/preauthkey',\n\t\t\tsession.get('hsApiKey')!, \n\t\t\t{\n\t\t\t\tuser: user,\n\t\t\t\tephemeral: ephemeral === 'on',\n\t\t\t\treusable: reusable === 'on',\n\t\t\t\texpiration: date.toISOString(),\n\t\t\t\taclTags: [], // TODO\n\t\t\t}\n\t\t)\n\n\t\treturn json({ message: 'Pre-auth key created', key })\n\t}\n}\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n\tconst context = await loadContext()\n\tconst session = await getSession(request.headers.get('Cookie'))\n\tconst users = await pull<{ users: User[] }>('v1/user', session.get('hsApiKey')!)\n\n\tconst preAuthKeys = await Promise.all(users.users.map(user => {\n\t\tconst qp = new URLSearchParams()\n\t\tqp.set('user', user.name)\n\n\t\treturn pull<{ preAuthKeys: PreAuthKey[] }>(\n\t\t\t`v1/preauthkey?${qp.toString()}`,\n\t\t\tsession.get('hsApiKey')!\n\t\t)\n\t}))\n\n\treturn {\n\t\tkeys: preAuthKeys.flatMap(keys => keys.preAuthKeys),\n\t\tusers: users.users,\n\t\tserver: context.headscaleUrl,\n\t}\n}\n\nexport default function Page() {\n\tconst { keys, users, server } = useLoaderData<typeof loader>()\n\tconst [user, setUser] = useState('All')\n\tconst [status, setStatus] = useState('Active')\n\tuseLiveData({ interval: 3000 })\n\n\tconst filteredKeys = keys.filter(key => {\n\t\tif (user !== 'All' && key.user !== user) {\n\t\t\treturn false\n\t\t}\n\n\t\tif (status !== 'All') {\n\t\t\tconst now = new Date()\n\t\t\tconst expiry = new Date(key.expiration)\n\n\t\t\tif (status === 'Active') {\n\t\t\t\treturn !(expiry < now) && !key.used\n\t\t\t}\n\n\t\t\tif (status === 'Used/Expired') {\n\t\t\t\treturn key.used || expiry < now\n\t\t\t}\n\n\t\t\tif (status === 'Reusable') {\n\t\t\t\treturn key.reusable\n\t\t\t}\n\n\t\t\tif (status === 'Ephemeral') {\n\t\t\t\treturn key.ephemeral\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t})\n\n\treturn (\n\t\t<div className='flex flex-col w-2/3'>\n\t\t\t<p className=\"mb-8 text-md\">\n\t\t\t\t<RemixLink\n\t\t\t\t\tto=\"/settings\"\n\t\t\t\t\tclassName=\"font-medium\"\n\t\t\t\t>\n\t\t\t\t\tSettings\n\t\t\t\t</RemixLink>\n\t\t\t\t<span className=\"mx-2\">\n\t\t\t\t\t/\n\t\t\t\t</span>\n\t\t\t\t{' '}\n\t\t\t\tPre-Auth Keys\n\t\t\t</p>\n\t\t\t<h1 className='text-2xl font-medium mb-4'>Pre-Auth Keys</h1>\n\t\t\t<p className=\"text-gray-700 dark:text-gray-300 mb-4\">\n\t\t\t\tHeadscale fully supports pre-authentication keys in order to\n\t\t\t\teasily add devices to your Tailnet.\n\t\t\t\tTo learn more about using pre-authentication keys, visit the\n\t\t\t\t{' '}\n\t\t\t\t<Link\n\t\t\t\t\tto=\"https://tailscale.com/kb/1085/auth-keys/\"\n\t\t\t\t\tname=\"Tailscale Auth Keys documentation\"\n\t\t\t\t>\n\t\t\t\t\tTailscale documentation\n\t\t\t\t</Link>\n\t\t\t</p>\n\t\t\t<AddPreAuthKey users={users} />\n\t\t\t<div className=\"flex justify-between gap-4 mt-4\">\n\t\t\t\t<div className=\"w-full\">\n\t\t\t\t\t<p className=\"text-sm text-gray-500 dark:text-gray-300\">\n\t\t\t\t\t\tFilter by user\n\t\t\t\t\t</p>\n\t\t\t\t\t<Select\n\t\t\t\t\t\tlabel=\"Filter by User\"\n\t\t\t\t\t\tplaceholder=\"Select a user\"\n\t\t\t\t\t\tstate={[user, setUser]}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Select.Item id=\"All\">All</Select.Item>\n\t\t\t\t\t\t{users.map(user => (\n\t\t\t\t\t\t\t<Select.Item key={user.id} id={user.name}>\n\t\t\t\t\t\t\t\t{user.name}\n\t\t\t\t\t\t\t</Select.Item>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</Select>\n\t\t\t\t</div>\n\t\t\t\t<div className=\"w-full\">\n\t\t\t\t\t<p className=\"text-sm text-gray-500 dark:text-gray-300\">\n\t\t\t\t\t\tFilter by status\n\t\t\t\t\t</p>\n\t\t\t\t\t<Select\n\t\t\t\t\t\tlabel=\"Filter by status\"\n\t\t\t\t\t\tplaceholder=\"Select a status\"\n\t\t\t\t\t\tstate={[status, setStatus]}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Select.Item id=\"All\">All</Select.Item>\n\t\t\t\t\t\t<Select.Item id=\"Active\">Active</Select.Item>\n\t\t\t\t\t\t<Select.Item id=\"Used/Expired\">Used/Expired</Select.Item>\n\t\t\t\t\t\t<Select.Item id=\"Reusable\">Reusable</Select.Item>\n\t\t\t\t\t\t<Select.Item id=\"Ephemeral\">Ephemeral</Select.Item>\n\t\t\t\t\t</Select>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<TableList className=\"mt-4\">\n\t\t\t\t{filteredKeys.length === 0 ? (\n\t\t\t\t\t<TableList.Item>\n\t\t\t\t\t\t<p className=\"opacity-50 text-sm mx-auto\">\n\t\t\t\t\t\t\tNo pre-auth keys\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</TableList.Item>\n\t\t\t\t) : filteredKeys.map(key => (\n\t\t\t\t\t<TableList.Item key={key.id}>\n\t\t\t\t\t\t<AuthKeyRow authKey={key} server={server} />\n\t\t\t\t\t</TableList.Item>\n\t\t\t\t))}\n\t\t\t</TableList>\n\t\t</div>\n\t)\n}\n\n",
        "called_code_segment_file_1": "export default function ExpireKey({ authKey }: Props) {\n  const fetcher = useFetcher()\n\n  return (\n    <Dialog>\n      <Dialog.Button className=\"my-4\">\n        Expire Key\n      </Dialog.Button>\n      <Dialog.Panel>\n        {close => (\n          <>\n            <Dialog.Title>\n              Expire auth key?\n            </Dialog.Title>\n            <fetcher.Form method=\"DELETE\" onSubmit={e => {\n              fetcher.submit(e.currentTarget)\n              close()\n            }}>\n              <input type=\"hidden\" name=\"user\" value={authKey.user} />\n              <input type=\"hidden\" name=\"key\" value={authKey.key} />\n              <Dialog.Text>\n                Expiring this authentication key will immediately\n                prevent it from being used to authenticate new devices.\n                {' '}\n                This action cannot be undone.\n              </Dialog.Text>\n              <div className=\"mt-6 flex justify-end gap-2 mt-6\">\n                <Dialog.Action\n                  variant=\"cancel\"\n                  onPress={close}\n                >\n                  Cancel\n                </Dialog.Action>\n                <Dialog.Action\n                  variant=\"confirm\"\n                  className={cn(\n                    'bg-red-500 hover:border-red-700',\n                    'dark:bg-red-600 dark:hover:border-red-700',\n                    'pressed:bg-red-600 hover:bg-red-600',\n                    'text-white dark:text-white',\n                  )}\n                  onPress={close}\n                >\n                  {fetcher.state === 'idle'\n                    ? undefined\n                    : (\n                      <Spinner className=\"w-3 h-3\" />\n                      )}\n                  Expire\n                </Dialog.Action>\n              </div>\n            </fetcher.Form>\n          </>\n        )}\n      </Dialog.Panel>\n    </Dialog>\n  )\n}",
        "invoking_code_segment_file_2": "<div className=\"flex gap-4 items-center\">\n  {authKey.used || new Date(authKey.expiration) < new Date()\n    ? undefined\n    : (\n      <ExpireKey authKey={authKey} />\n    )}\n  <Button\n    variant=\"light\" \n    className=\"my-4\"\n    onClick={async () => {\n      await navigator.clipboard.writeText(\n        `tailscale up --login-server ${server} --authkey ${authKey.key}`\n      )\n\n      toast('Copied command to clipboard')\n    }}\n  >\n    Copy Tailscale Command\n  </Button>\n</div>",
        "called_code_segment_file_2": "export default function AuthKeyRow({ authKey, server }: Props) {\n  const createdAt = new Date(authKey.createdAt).toLocaleString()\n  const expiration = new Date(authKey.expiration).toLocaleString()\n\n  return (\n    <div className=\"w-full\">\n      <Attribute name=\"Key\" value={authKey.key} isCopyable />\n      <Attribute name=\"User\" value={authKey.user} isCopyable />\n      <Attribute name=\"Reusable\" value={authKey.reusable ? 'Yes' : 'No'} />\n      <Attribute name=\"Ephemeral\" value={authKey.ephemeral ? 'Yes' : 'No'} />\n      <Attribute name=\"Used\" value={authKey.used ? 'Yes' : 'No'} />\n      <Attribute name=\"Created\" value={createdAt} />\n      <Attribute name=\"Expiration\" value={expiration} />\n      <p className=\"mb-1 mt-4\">\n        To use this key, run the following command on your device:\n      </p>\n      <Code className=\"text-sm\">\n        tailscale up --login-server {server} --authkey {authKey.key}\n      </Code>\n      <div className=\"flex gap-4 items-center\">\n        {authKey.used || new Date(authKey.expiration) < new Date()\n          ? undefined\n          : (\n            <ExpireKey authKey={authKey} />\n          )}\n        <Button\n          variant=\"light\" \n          className=\"my-4\"\n          onClick={async () => {\n            await navigator.clipboard.writeText(\n              `tailscale up --login-server ${server} --authkey ${authKey.key}`\n            )\n\n            toast('Copied command to clipboard')\n          }}\n        >\n          Copy Tailscale Command\n        </Button>\n      </div>\n    </div>\n  )\n}",
        "using_code_segment_file_3": "<TableList className=\"mt-4\">\n  {filteredKeys.length === 0 ? (\n    <TableList.Item>\n      <p className=\"opacity-50 text-sm mx-auto\">\n        No pre-auth keys\n      </p>\n    </TableList.Item>\n  ) : filteredKeys.map(key => (\n    <TableList.Item key={key.id}>\n      <AuthKeyRow authKey={key} server={server} />\n    </TableList.Item>\n  ))}\n</TableList>",
        "feature_description": "Add a confirmation dialog when expiring a key.",
        "detailed_feature_description": "Modify the `ExpireKey` component to include a confirmation dialog before expiring a key. Update the `AuthKeyRow` component to handle the confirmation dialog and ensure the `route.tsx` component updates accordingly to reflect the new behavior.",
        "modified_complete_code": {
            "#file 1": "export default function ExpireKey({ authKey }: Props) {\n  const fetcher = useFetcher()\n\n  return (\n    <Dialog>\n      <Dialog.Button className=\"my-4\">\n        Expire Key\n      </Dialog.Button>\n      <Dialog.Panel>\n        {close => (\n          <>\n            <Dialog.Title>\n              Expire auth key?\n            </Dialog.Title>\n            <fetcher.Form method=\"DELETE\" onSubmit={e => {\n              if (window.confirm('Are you sure you want to expire this key?')) {\n                fetcher.submit(e.currentTarget)\n                close()\n              }\n            }}>\n              <input type=\"hidden\" name=\"user\" value={authKey.user} />\n              <input type=\"hidden\" name=\"key\" value={authKey.key} />\n              <Dialog.Text>\n                Expiring this authentication key will immediately\n                prevent it from being used to authenticate new devices.\n                {' '}\n                This action cannot be undone.\n              </Dialog.Text>\n              <div className=\"mt-6 flex justify-end gap-2 mt-6\">\n                <Dialog.Action\n                  variant=\"cancel\"\n                  onPress={close}\n                >\n                  Cancel\n                </Dialog.Action>\n                <Dialog.Action\n                  variant=\"confirm\"\n                  className={cn(\n                    'bg-red-500 hover:border-red-700',\n                    'dark:bg-red-600 dark:hover:border-red-700',\n                    'pressed:bg-red-600 hover:bg-red-600',\n                    'text-white dark:text-white',\n                  )}\n                  onPress={close}\n                >\n                  {fetcher.state === 'idle'\n                    ? undefined\n                    : (\n                      <Spinner className=\"w-3 h-3\" />\n                      )}\n                  Expire\n                </Dialog.Action>\n              </div>\n            </fetcher.Form>\n          </>\n        )}\n      </Dialog.Panel>\n    </Dialog>\n  )\n}",
            "#file 2": "export default function AuthKeyRow({ authKey, server }: Props) {\n  const createdAt = new Date(authKey.createdAt).toLocaleString()\n  const expiration = new Date(authKey.expiration).toLocaleString()\n\n  return (\n    <div className=\"w-full\">\n      <Attribute name=\"Key\" value={authKey.key} isCopyable />\n      <Attribute name=\"User\" value={authKey.user} isCopyable />\n      <Attribute name=\"Reusable\" value={authKey.reusable ? 'Yes' : 'No'} />\n      <Attribute name=\"Ephemeral\" value={authKey.ephemeral ? 'Yes' : 'No'} />\n      <Attribute name=\"Used\" value={authKey.used ? 'Yes' : 'No'} />\n      <Attribute name=\"Created\" value={createdAt} />\n      <Attribute name=\"Expiration\" value={expiration} />\n      <p className=\"mb-1 mt-4\">\n        To use this key, run the following command on your device:\n      </p>\n      <Code className=\"text-sm\">\n        tailscale up --login-server {server} --authkey {authKey.key}\n      </Code>\n      <div className=\"flex gap-4 items-center\">\n        {authKey.used || new Date(authKey.expiration) < new Date()\n          ? undefined\n          : (\n            <ExpireKey authKey={authKey} />\n          )}\n        <Button\n          variant=\"light\" \n          className=\"my-4\"\n          onClick={async () => {\n            await navigator.clipboard.writeText(\n              `tailscale up --login-server ${server} --authkey ${authKey.key}`\n            )\n\n            toast('Copied command to clipboard')\n          }}\n        >\n          Copy Tailscale Command\n        </Button>\n      </div>\n    </div>\n  )\n}",
            "#file 3": "export default function Page() {\n  const { keys, users, server } = useLoaderData<typeof loader>()\n  const [user, setUser] = useState('All')\n  const [status, setStatus] = useState('Active')\n  useLiveData({ interval: 3000 })\n\n  const filteredKeys = keys.filter(key => {\n    if (user !== 'All' && key.user !== user) {\n      return false\n    }\n\n    if (status !== 'All') {\n      const now = new Date()\n      const expiry = new Date(key.expiration)\n\n      if (status === 'Active') {\n        return !(expiry < now) && !key.used\n      }\n\n      if (status === 'Used/Expired') {\n        return key.used || expiry < now\n      }\n\n      if (status === 'Reusable') {\n        return key.reusable\n      }\n\n      if (status === 'Ephemeral') {\n        return key.ephemeral\n      }\n    }\n\n    return true\n  })\n\n  return (\n    <div className='flex flex-col w-2/3'>\n      <p className=\"mb-8 text-md\">\n        <RemixLink\n          to=\"/settings\"\n          className=\"font-medium\"\n        >\n          Settings\n        </RemixLink>\n        <span className=\"mx-2\">\n          /\n        </span>\n        {' '}\n        Pre-Auth Keys\n      </p>\n      <h1 className='text-2xl font-medium mb-4'>Pre-Auth Keys</h1>\n      <p className=\"text-gray-700 dark:text-gray-300 mb-4\">\n        Headscale fully supports pre-authentication keys in order to\n        easily add devices to your Tailnet.\n        To learn more about using pre-authentication keys, visit the\n        {' '}\n        <Link\n          to=\"https://tailscale.com/kb/1085/auth-keys/\"\n          name=\"Tailscale Auth Keys documentation\"\n        >\n          Tailscale documentation\n        </Link>\n      </p>\n      <AddPreAuthKey users={users} />\n      <div className=\"flex justify-between gap-4 mt-4\">\n        <div className=\"w-full\">\n          <p className=\"text-sm text-gray-500 dark:text-gray-300\">\n            Filter by user\n          </p>\n          <Select\n            label=\"Filter by User\"\n            placeholder=\"Select a user\"\n            state={[user, setUser]}\n          >\n            <Select.Item id=\"All\">All</Select.Item>\n            {users.map(user => (\n              <Select.Item key={user.id} id={user.name}>\n                {user.name}\n              </Select.Item>\n            ))}\n          </Select>\n        </div>\n        <div className=\"w-full\">\n          <p className=\"text-sm text-gray-500 dark:text-gray-300\">\n            Filter by status\n          </p>\n          <Select\n            label=\"Filter by status\"\n            placeholder=\"Select a status\"\n            state={[status, setStatus]}\n          >\n            <Select.Item id=\"All\">All</Select.Item>\n            <Select.Item id=\"Active\">Active</Select.Item>\n            <Select.Item id=\"Used/Expired\">Used/Expired</Select.Item>\n            <Select.Item id=\"Reusable\">Reusable</Select.Item>\n            <Select.Item id=\"Ephemeral\">Ephemeral</Select.Item>\n          </Select>\n        </div>\n      </div>\n      <TableList className=\"mt-4\">\n        {filteredKeys.length === 0 ? (\n          <TableList.Item>\n            <p className=\"opacity-50 text-sm mx-auto\">\n              No pre-auth keys\n            </p>\n          </TableList.Item>\n        ) : filteredKeys.map(key => (\n          <TableList.Item key={key.id}>\n            <AuthKeyRow authKey={key} server={server} />\n          </TableList.Item>\n        ))}\n      </TableList>\n    </div>\n  )\n}"
        }
    },
    {
        "repo": "event-sourcing-demo-app",
        "content": "'event-sourcing-demo-app/backend/src/services/ShipService.ts'\n:import { ObjectId } from 'mongodb'\nimport { Ship } from '../domain'\nimport { ShipRepository } from '../data/repositories/ShipRepository'\nimport { ShipNotFoundError } from '../domain/ship/errors/ShipNotFoundError'\nimport { IShipCreationParams } from '../domain/structures/IShipCreationParams'\nimport { PortService } from './PortService'\n\nexport class ShipService {\n  private readonly repository: ShipRepository\n  private readonly portService: PortService\n\n  constructor (repository: ShipRepository, portService: PortService) {\n    this.repository = repository\n    this.portService = portService\n  }\n\n  async create (creationParams: IShipCreationParams, user: string): Promise<Ship> {\n    const ship = Ship.create(creationParams, user)\n\n    return this.repository.save(ship)\n  }\n\n  async delete (shipId: string, user: string): Promise<Ship> {\n    const ship = await this.repository.findById(shipId)\n    if (!ship) throw new ShipNotFoundError(shipId)\n\n    ship.delete(user)\n    return this.repository.save(ship)\n  }\n\n  async depart (shipId: ObjectId | string, reason: string, user: string): Promise<Ship> {\n    const obj = new ObjectId(shipId)\n    const ship = await this.repository.findById(obj)\n\n    if (!ship) throw new ShipNotFoundError(obj.toHexString())\n    if (!ship.currentPort) return ship\n\n    await this.portService.undockShip(ship, reason, user)\n\n    ship.depart(reason, user)\n    return this.repository.save(ship)\n  }\n\n  async dock (shipId: string, portId: string, user: string): Promise<Ship> {\n    const ship = await this.repository.findById(shipId)\n\n    if (!ship) throw new ShipNotFoundError(shipId)\n    if (ship.currentPort && ship.currentPort.toHexString() === portId) return ship\n\n    const port = await this.portService.find(portId)\n    ship.dock(port, user)\n\n    await this.portService.dockShip(ship, user)\n    return this.repository.save(ship)\n  }\n\n  async find (id: ObjectId | string): Promise<Ship> {\n    const ship = await this.repository.findById(id)\n\n    if (!ship) throw new ShipNotFoundError(id as string)\n\n    return ship\n  }\n\n  async getAll (): Promise<Ship[]> {\n    return this.repository.getAll()\n  }\n}\n\n'event-sourcing-demo-app/backend/src/presentation/routes/port/delete.ts'\n:import rescue from 'express-rescue'\nimport { HttpError } from '@expresso/expresso'\nimport { ShipService } from '../../../services/ShipService'\nimport { ShipNotFoundError } from '../../../domain/ship/errors/ShipNotFoundError'\nimport { PortService } from '../../../services/PortService'\n\nexport function factory (service: PortService, shipService: ShipService) {\n  return [\n    /**\n     * Route handler\n     * =============\n     */\n    rescue(async (req, res) => {\n      const port = await service.delete(req.params.portId, req.onBehalfOf)\n\n      for (const shipId of port.dockedShips) {\n        await shipService.depart(shipId, 'Port was deleted', req.onBehalfOf)\n      }\n\n      res.status(204).end()\n    }),\n    (err, _req, _res, next) => {\n      if (err instanceof ShipNotFoundError) return next(new HttpError.NotFound({ message: err.message, code: 'ship_not_found' }))\n\n      next(err)\n    }\n  ]\n}\n\n'event-sourcing-demo-app/backend/src/presentation/routes/index.ts'\n:export default {\n  ship: {\n    create: require('./ship/create'),\n    delete: require('./ship/delete'),\n    find: require('./ship/find'),\n    getAll: require('./ship/getAll'),\n    dock: require('./ship/dock'),\n    depart: require('./ship/depart'),\n    getEvents: require('./ship/getEvents')\n  },\n  port: {\n    create: require('./port/create'),\n    delete: require('./port/delete'),\n    find: require('./port/find'),\n    getAll: require('./port/getAll'),\n    getEvents: require('./port/getEvents')\n  }\n}\n\n",
        "called_code_segment_file_1": "async delete (shipId: string, user: string): Promise<Ship> {\n    const ship = await this.repository.findById(shipId)\n    if (!ship) throw new ShipNotFoundError(shipId)\n\n    ship.delete(user)\n    return this.repository.save(ship)\n  }",
        "invoking_code_segment_file_2": "rescue(async (req, res) => {\n      const port = await service.delete(req.params.portId, req.onBehalfOf)\n\n      for (const shipId of port.dockedShips) {\n        await shipService.depart(shipId, 'Port was deleted', req.onBehalfOf)\n      }\n\n      res.status(204).end()\n    })",
        "called_code_segment_file_2": "async depart (shipId: ObjectId | string, reason: string, user: string): Promise<Ship> {\n    const obj = new ObjectId(shipId)\n    const ship = await this.repository.findById(obj)\n\n    if (!ship) throw new ShipNotFoundError(obj.toHexString())\n    if (!ship.currentPort) return ship\n\n    await this.portService.undockShip(ship, reason, user)\n\n    ship.depart(reason, user)\n    return this.repository.save(ship)\n  }",
        "using_code_segment_file_3": "async undockShip (ship: Ship, reason: string, user: string): Promise<void> {\n    const port = await this.repository.findById(ship.currentPort)\n    if (!port) throw new PortNotFoundError(ship.currentPort.toHexString())\n\n    port.undockShip(ship, reason, user)\n    await this.repository.save(port)\n  }",
        "feature_description": "Add a feature to log the deletion of a ship when a port is deleted.",
        "detailed_feature_description": "Modify the `delete` method in `ShipService` to log the deletion of a ship. Update the `delete` route handler in `port/delete.ts` to handle the new logging functionality. Ensure the `undockShip` method in `PortService` is updated to accommodate any changes in the `depart` method of `ShipService`.",
        "modified_complete_code": {
            "file_1": "async delete (shipId: string, user: string): Promise<Ship> {\n    const ship = await this.repository.findById(shipId)\n    if (!ship) throw new ShipNotFoundError(shipId)\n\n    ship.delete(user)\n    #Modify: Log the deletion of the ship\n    console.log(`Ship ${shipId} was deleted by ${user}`)\n    return this.repository.save(ship)\n  }",
            "file_2": "rescue(async (req, res) => {\n      const port = await service.delete(req.params.portId, req.onBehalfOf)\n\n      for (const shipId of port.dockedShips) {\n        await shipService.depart(shipId, 'Port was deleted', req.onBehalfOf)\n      }\n\n      res.status(204).end()\n    })",
            "file_3": "async undockShip (ship: Ship, reason: string, user: string): Promise<void> {\n    const port = await this.repository.findById(ship.currentPort)\n    if (!port) throw new PortNotFoundError(ship.currentPort.toHexString())\n\n    port.undockShip(ship, reason, user)\n    await this.repository.save(port)\n  }"
        }
    },
    {
        "repo": "layout",
        "content": "'layout/src/controllers/StyleController.ts'\n:import { NineSliceSprite, TilingSprite } from 'pixi.js';\nimport { LayoutSystem } from '../Layout';\nimport { BACKGROUND_SIZE, OVERFLOW, VERTICAL_ALIGN } from '../utils/constants';\nimport { stylesToPixiTextStyles } from '../utils/helpers';\nimport { PixiTextStyle } from '../utils/text';\n\nimport type { ConditionalStyles, GradeToOne, Styles } from '../utils/types';\n\n/** Style controller manages {@link LayoutSystem} styles. */\nexport class StyleController\n{\n    protected layout: LayoutSystem;\n\n    protected styles: Styles = {};\n\n    /** Holds all text related styles. This is to be nested by children */\n    protected _textStyle: Partial<PixiTextStyle> = {}; // this is to be nested by children\n\n    /** Stores default styles. */\n    protected defaultStyles: Styles;\n\n    /** Conditional styles */\n    protected conditionalStyles: ConditionalStyles = {};\n\n    /**\n     * Manages and sets all the styles of {@link LayoutSystem}\n     * @param layout - {@link LayoutSystem} to be styled\n     * @param styles - styles to be applied\n     */\n    constructor(layout: LayoutSystem, styles?: Styles)\n    {\n        this.layout = layout;\n        this.set(styles);\n    }\n\n    /**\n     * Applies a list of styles for the layout.\n     * @param { Styles } styles - styles to be applied\n     */\n    set(styles?: Styles & ConditionalStyles)\n    {\n        this.styles.overflow\n            = styles?.overflow ?? this.styles.overflow ?? OVERFLOW[0];\n        this.styles.display\n            = styles?.display ?? this.styles.display ?? 'inline-block';\n        this.styles.borderRadius\n            = styles?.borderRadius ?? this.styles.borderRadius ?? 0;\n\n        this.styles.zIndex = styles?.zIndex ?? this.styles.zIndex ?? 1;\n\n        this.opacity = styles?.opacity ?? this.styles.opacity ?? 1;\n\n        this.styles.maxWidth = styles?.maxWidth ?? this.styles.maxWidth;\n        this.styles.maxHeight = styles?.maxHeight ?? this.styles.maxHeight;\n\n        this.styles.minWidth = styles?.minWidth ?? this.styles.minWidth;\n        this.styles.minHeight = styles?.minHeight ?? this.styles.minHeight;\n\n        this.styles.padding = styles?.padding ?? this.styles.padding ?? 0;\n        this.styles.paddingTop\n            = styles?.paddingTop\n            ?? styles?.padding\n            ?? this.styles.paddingTop\n            ?? 0;\n        this.styles.paddingRight\n            = styles?.paddingRight\n            ?? styles?.padding\n            ?? this.styles.paddingRight\n            ?? 0;\n        this.styles.paddingBottom\n            = styles?.paddingBottom\n            ?? styles?.padding\n            ?? this.styles.paddingBottom\n            ?? 0;\n        this.styles.paddingLeft\n            = styles?.paddingLeft\n            ?? styles?.padding\n            ?? this.styles.paddingLeft\n            ?? 0;\n\n        this.styles.margin = styles?.margin ?? this.styles.margin ?? 0;\n        this.styles.marginTop\n            = styles?.marginTop ?? styles?.margin ?? this.styles.marginTop ?? 0;\n        this.styles.marginRight\n            = styles?.marginRight\n            ?? styles?.margin\n            ?? this.styles.marginRight\n            ?? 0;\n        this.styles.marginBottom\n            = styles?.marginBottom\n            ?? styles?.margin\n            ?? this.styles.marginBottom\n            ?? 0;\n        this.styles.marginLeft\n            = styles?.marginLeft ?? styles?.margin ?? this.styles.marginLeft ?? 0;\n\n        this.styles.scale = styles?.scale ?? this.styles.scale ?? 1;\n        this.styles.scaleX\n            = styles?.scaleX ?? styles?.scale ?? this.styles.scaleX ?? 1;\n        this.styles.scaleY\n            = styles?.scaleY ?? styles?.scale ?? this.styles.scaleY ?? 1;\n\n        this.styles.width = styles?.width ?? this.styles.width ?? 'auto';\n        this.styles.height = styles?.height ?? this.styles.height ?? 'auto';\n\n        this.styles.wordWrap = styles?.wordWrap ?? false;\n\n        if (styles?.anchorX !== undefined)\n        {\n            this.styles.anchorX = styles.anchorX;\n        }\n        else if (styles?.anchor !== undefined)\n        {\n            if (typeof styles.anchor === 'number')\n            {\n                this.styles.anchorX = styles.anchor;\n            }\n            else if (Array.isArray(styles.anchor))\n            {\n                this.styles.anchorX = styles.anchor[0];\n            }\n        }\n\n        if (styles?.anchorY !== undefined)\n        {\n            this.styles.anchorY = styles.anchorY;\n        }\n        else if (styles?.anchor !== undefined)\n        {\n            if (typeof styles.anchor === 'number')\n            {\n                this.styles.anchorY = styles.anchor;\n            }\n            else if (\n                Array.isArray(styles.anchor)\n                && styles.anchor[1] !== undefined\n            )\n            {\n                this.styles.anchorY = styles.anchor[1];\n            }\n        }\n\n        this.styles.background\n            = styles?.background\n            ?? styles?.backgroundColor\n            ?? this.styles.background;\n\n        this.styles.backgroundSize\n            = styles?.backgroundSize\n            ?? this.styles.backgroundSize\n            ?? BACKGROUND_SIZE[0];\n\n        if (\n            this.styles.background instanceof NineSliceSprite\n            || this.styles.background instanceof TilingSprite\n        )\n        {\n            this.styles.backgroundSize = 'stretch';\n        }\n\n        this.styles.textAlign = styles?.textAlign ?? this.styles.textAlign;\n        this.styles.position = styles?.position ?? this.styles.position;\n        this.styles.verticalAlign\n            = styles?.verticalAlign\n            ?? this.styles.verticalAlign\n            ?? VERTICAL_ALIGN[0];\n\n        this.styles.aspectRatio\n            = styles?.aspectRatio ?? this.styles.aspectRatio ?? 'static';\n\n        this.styles.visible = styles?.visible ?? this.styles.visible ?? true;\n        this.visible = this.styles.visible;\n\n        this._textStyle = stylesToPixiTextStyles(styles);\n\n        if (styles)\n        {\n            this.separateConditionalStyles(styles);\n        }\n    }\n\n    /**\n     * Returns a style value by name.\n     * @param style - name of the style\n     */\n    get(style: keyof Styles): Styles[keyof Styles]\n    {\n        return this.styles[style];\n    }\n\n    /** Returns all styles of the Layout */\n    getAll(): Styles\n    {\n        return this.styles;\n    }\n\n    /** Returns all pixi text related styles of the Layout */\n    get textStyle(): Partial<PixiTextStyle>\n    {\n        return this._textStyle;\n    }\n\n    /** Sets the opacity of the layout */\n    set opacity(value: GradeToOne)\n    {\n        this.styles.opacity = value;\n        this.layout.container.alpha = value;\n    }\n\n    /** Returns the opacity of the layout */\n    get opacity(): GradeToOne\n    {\n        return this.styles.opacity;\n    }\n\n    /** Set visibility of the layout */\n    set visible(value: boolean)\n    {\n        this.layout.container.visible = value;\n    }\n\n    /** Returns visibility of the layout */\n    get visible(): boolean\n    {\n        return this.layout.container.visible;\n    }\n\n    /** Checks and applies conditional styles basing on parent size */\n    applyConditionalStyles()\n    {\n        if (!this.hasConditionalStyles) return;\n\n        this.set({\n            ...this.defaultStyles,\n            ...(this.layout.isRootLayoutPortrait\n                ? this.conditionalStyles.portrait\n                : this.conditionalStyles.landscape),\n        });\n    }\n\n    /**\n     * Separates conditional styles from default styles\n     * @param styles - mixed styles\n     */\n    protected separateConditionalStyles(styles?: Styles & ConditionalStyles)\n    {\n        if (!styles.portrait && !styles.landscape)\n        {\n            this.defaultStyles = {\n                ...styles,\n            };\n\n            return;\n        }\n\n        if (styles.portrait)\n        {\n            this.conditionalStyles.portrait = {\n                ...this.conditionalStyles.portrait,\n                ...styles.portrait,\n            };\n        }\n\n        if (styles.landscape)\n        {\n            this.conditionalStyles.landscape = {\n                ...this.conditionalStyles.landscape,\n                ...styles.landscape,\n            };\n        }\n\n        delete styles.portrait;\n        delete styles.landscape;\n\n        this.defaultStyles = styles;\n    }\n\n    /** Returns true if there are conditional styles */\n    get hasConditionalStyles(): boolean\n    {\n        return Object.keys(this.conditionalStyles).length > 0;\n    }\n}\n\n'layout/src/Layout.ts'\n:import { Container } from 'pixi.js';\nimport { AlignController } from './controllers/AlignController';\nimport { ContentController } from './controllers/ContentController';\nimport { SizeController } from './controllers/SizeController';\nimport { StyleController } from './controllers/StyleController';\nimport { PixiTextStyle } from './utils/text';\nimport { ConditionalStyles, Content, LayoutOptions, Styles } from './utils/types';\n\n/**\n * Layout controller class for any PixiJS Container based instance.\n *\n * To be be used for automatic align and resize children tree,\n * where every child behavior can be configured using css like configurations.\n *\n * Also it adds a list of css-like properties for styling like background style or text style,\n * check {@link SizeController} class.\n *\n * Any PixiJS Container based instance can be turned into a layout by calling {@link Layout#initLayout} method.\n * @example\n * const container = new Container().initLayout();\n *\n * container.layout?.setStyles({\n *      background: 'black',\n *      width: '100%',\n *      height: '100%',\n *      padding: 10,\n *      overflow: 'hidden',\n *      color: 'white',\n * }); // set styles\n *\n * container.layout?.setContent({\n *      text: 'Hello World',\n * }); // set content\n *\n * Or alternatively:\n *\n * const layoutSystem = new LayoutSystem({\n *      id: 'root',\n *      content: 'Hello World',\n *      styles: {\n *          background: 'black',\n *      }\n * }); // create layout system\n *\n * app.stage.addChild(layoutSystem.container); // add layout system generated container to the stage\n */\nexport class LayoutSystem\n{\n    /** Container for all layout children. */\n    container: Container;\n\n    /** ID of layout, can be used to set styles in the globalStyles object somewhere higher in hierarchal tree. */\n    id: string;\n\n    /** {@link SizeController} is a class for controlling layout and all it's children sizes. */\n    size: SizeController;\n\n    /** {@link AlignController} is a class for controlling layout and all it's children alignment. */\n    align: AlignController;\n\n    /** {@link StyleController} is a class for controlling styles. */\n    protected _style: StyleController;\n\n    /** {@link ContentController} controller is a class for controlling layouts children. */\n    content: ContentController;\n\n    /** Stores isPortrait state */\n    isPortrait: boolean;\n\n    /**\n     * Creates layout system instance.\n     * @param options - Layout options\n     * @param options.id - ID of the layout.\n     * @param options.styles - Styles of the layout. List of available styles can be found in {@link StyleController}.\n     * @param options.content - Content of the layout.\n     * @param options.globalStyles - Global styles for layout and it's children.\n     * @param container - Container for all layout children, will be created if not provided.\n     */\n    constructor(options?: LayoutOptions, container?: Container)\n    {\n        this.container = container || new Container();\n\n        this.id = options?.id;\n\n        if (options?.globalStyles)\n        {\n            // check if there is a global style for this layout\n            const styles = options.globalStyles[this.id];\n\n            if (styles && options.styles)\n            {\n                options.styles = { ...styles, ...options.styles };\n            }\n            else if (styles)\n            {\n                options.styles = styles;\n            }\n        }\n\n        // order here is important as controllers are dependent on each other\n        this.size = new SizeController(this);\n        this._style = new StyleController(this, options?.styles);\n        this.align = new AlignController(this);\n        this.content = new ContentController(\n            this,\n            options?.content,\n            options?.globalStyles\n        );\n    }\n\n    /**\n     * Resize method should be called on every parent size change.\n     * @param parentWidth\n     * @param parentHeight\n     */\n    resize(parentWidth?: number, parentHeight?: number)\n    {\n        const width = parentWidth || this.contentWidth || this.size.parentWidth;\n        const height\n            = parentHeight || this.contentHeight || this.size.parentHeight;\n\n        this.isPortrait = width < height;\n\n        this._style.applyConditionalStyles();\n        this.size.resize(parentWidth, parentHeight);\n    }\n\n    /** Recalculate positions and sizes of layouts three. */\n    refresh()\n    {\n        this.resize(this.size.parentWidth, this.size.parentHeight);\n    }\n\n    /** Returns with of the container */\n    get contentWidth(): number | undefined\n    {\n        if (!this.container?.parent)\n        {\n            return undefined;\n        }\n\n        return this.container.parent.width;\n    }\n\n    /** Returns height of the container */\n    get contentHeight(): number | undefined\n    {\n        if (!this.container?.parent)\n        {\n            return undefined;\n        }\n\n        return this.container.parent.height;\n    }\n\n    /** Sets the width of layout.  */\n    set width(value: number)\n    {\n        this.size.width = value;\n    }\n\n    /** Gets the width of layout. */\n    get width()\n    {\n        return this.size.width;\n    }\n\n    /** Sets the height of layout. */\n    set height(value: number)\n    {\n        this.size.height = value;\n    }\n\n    /** Gets the height of layout. */\n    get height()\n    {\n        return this.size.height;\n    }\n\n    /**\n     * Adds content to the layout and reposition/resize other elements and the layout basing on styles.\n     * @param {Content} content - Content to be added. Can be string, Container, Layout, LayoutOptions or array of those.\n     * Also content can be an object with inner layout ids as a keys, and Content as values.\n     */\n    addContent(content: Content)\n    {\n        this.content.createContent(content);\n        this.updateParents();\n    }\n\n    /**\n     * Removes content of the layout by its id and reposition/resize other elements and the layout basing on styles.\n     * @param {string} id - id of the content to be removed.\n     */\n    removeChildByID(id: string)\n    {\n        this.content.removeContent(id);\n    }\n\n    /**\n     * Get element from the layout child tree by it's ID\n     * @param {string} id - id of the content to be foundS.\n     */\n    getChildByID(id: string): Layout | Container | undefined\n    {\n        return this.content.getByID(id);\n    }\n\n    /**\n     * This is used in case if layout or some of it's children was changed\n     * and we need to update sizes and positions for all the parents tree.\n     */\n    updateParents()\n    {\n        const rootLayout = this.getRootLayout();\n\n        rootLayout.size.resize();\n    }\n\n    /** Returns root layout of the layout tree. */\n    getRootLayout(): LayoutSystem\n    {\n        if (this.container.parent?.layout)\n        {\n            return this.container.parent.layout.getRootLayout();\n        }\n\n        return this;\n    }\n\n    /**\n     * Updates the layout styles and resize/reposition it and its children basing on new styles.\n     * @param styles\n     */\n    setStyles(styles: Styles & ConditionalStyles)\n    {\n        this._style.set(styles);\n        this.updateParents();\n    }\n\n    /** Layout text styles. */\n    get textStyle(): Partial<PixiTextStyle>\n    {\n        return this._style.textStyle;\n    }\n\n    /** Layout styles. */\n    get style(): Styles\n    {\n        return this._style.getAll();\n    }\n\n    /** Returns true if root layout is in landscape mode. */\n    get isRootLayoutPortrait(): boolean\n    {\n        return this.getRootLayout().isPortrait === true;\n    }\n}\n\n/**\n * Container with layout system initiated.\n * @example\n *\n * const layout = new Layout({\n * \tstyles: {\n * \t\twidth: 100,\n * \t\theight: 100,\n * \t\tbackground: 'red',\n * \t},\n * \tcontent: [\n * \t\t'Hello world',\n * \t\t{\n * \t\t\tid: 'innerLayout1',\n * \t\t\ttext: 'Inner layout 1',\n * \t\t},\n * \t\t{\n * \t\t\tid: 'innerLayout2',\n * \t\t\ttext: 'Inner layout 2',\n * \t\t},\n * \t],\n * \tglobalStyles: {\n * \t\tinnerLayout1: {\n * \t\t\twidth: 200,\n * \t\t\theight: 200,\n * \t\t},\n * \t\tinnerLayout1: {\n * \t\t\twidth: 200,\n * \t\t\theight: 200,\n * \t\t},\n * \t},\n * });\n */\nexport class Layout extends Container\n{\n    override layout: LayoutSystem;\n\n    /**\n     * Creates layout container.\n     * @param options\n     */\n    constructor(options?: LayoutOptions)\n    {\n        super();\n\n        this.layout = new LayoutSystem(options, this);\n    }\n\n    /** Get {@link SizeController} */\n    get size(): SizeController\n    {\n        return this.layout.size;\n    }\n\n    /** {@link AlignController} */\n    get align(): AlignController\n    {\n        return this.layout.align;\n    }\n\n    /** {@link ContentController} */\n    get content(): ContentController\n    {\n        return this.layout.content;\n    }\n\n    /** ID of layout, can be used to set styles in the globalStyles. */\n    get id()\n    {\n        return this.layout.id;\n    }\n\n    /** ID of layout, can be used to set styles in the globalStyles. */\n    set id(value: string)\n    {\n        this.layout.id = value;\n    }\n\n    /** Returns with of the layouts content. */\n    get contentWidth(): number | undefined\n    {\n        return this.layout.contentWidth;\n    }\n\n    /** Returns height of the layouts content. */\n    get contentHeight(): number | undefined\n    {\n        return this.layout.contentHeight;\n    }\n\n    /** Set the width of layout.  */\n    override set width(value: number)\n    {\n        this.layout.width = value;\n    }\n\n    /** Get the width of layout. */\n    override get width()\n    {\n        return this.layout.width;\n    }\n\n    /** Set the height of layout. */\n    override set height(value: number)\n    {\n        this.layout.height = value;\n    }\n\n    /** Get the height of layout. */\n    override get height()\n    {\n        return this.layout.height;\n    }\n\n    /**\n     * Add content to the layout system and reposition/resize elements basing on styles.\n     * @param {Content} content - Content to be added. Can be string, Container, Layout, LayoutOptions or array of those.\n     * Also content can be an object where keys are ids of child layouts to create, and Content as values.\n     */\n    addContent(content: Content)\n    {\n        this.layout.addContent(content);\n    }\n\n    /**\n     * Remove content from layout system by its id and reposition/resize elements basing on styles.\n     * @param {string} id - id of the content to be removed.\n     */\n    removeChildByID(id: string)\n    {\n        this.layout.removeChildByID(id);\n    }\n\n    /**\n     * Get element from the layout system children tree by it's ID\n     * @param {string} id - id of the content to be foundS.\n     */\n    getChildByID(id: string): Layout | Container | undefined\n    {\n        return this.layout.getChildByID(id);\n    }\n\n    /**\n     * Updates the layout styles and resize/reposition elements basing on new styles.\n     * @param styles\n     */\n    setStyles(styles: Styles)\n    {\n        this.layout.setStyles(styles);\n    }\n\n    /** Layout text styles. */\n    get textStyle(): Partial<PixiTextStyle>\n    {\n        return this.layout.textStyle;\n    }\n\n    /** Layout styles. */\n    get style(): Styles\n    {\n        return this.layout.style;\n    }\n\n    /**\n     * Resize method should be called on every parent size change.\n     * @param parentWidth\n     * @param parentHeight\n     */\n    resize(parentWidth?: number, parentHeight?: number)\n    {\n        this.layout.resize(parentWidth, parentHeight);\n    }\n\n    /** Recalculate positions and sizes of layouts three. */\n    refresh()\n    {\n        this.resize(this.size.parentWidth, this.size.parentHeight);\n    }\n}\n\ndeclare module 'pixi.js'\n{\n    interface Container\n    {\n        initLayout(config?: LayoutOptions): Container;\n        layout?: LayoutSystem;\n        isPixiLayout?: boolean;\n    }\n}\n\nif (!Container.prototype.initLayout)\n{\n    Object.defineProperty(Container.prototype, 'initLayout', {\n        value(options?: LayoutOptions): void\n        {\n            if (!this.layout)\n            {\n                this.layout = new LayoutSystem(options, this);\n                this.isPixiLayout = true;\n            }\n\n            return this;\n        },\n    });\n}\n\n'layout/src/stories/basic/TransformContainer.stories.ts'\n:import { Container } from 'pixi.js';\nimport { Layout } from '../../Layout';\nimport {\n    ALIGN,\n    CSS_COLOR_NAMES,\n    LOREM_TEXT,\n    POSITION,\n} from '../../utils/constants';\nimport { toolTip } from '../components/ToolTip';\nimport { argTypes, getDefaultArgs } from '../utils/argTypes';\n\nconst color = Object.keys(CSS_COLOR_NAMES).map((key) => key);\n\nconst args = {\n    color,\n    backgroundColor: '#000000',\n    width: 50,\n    height: 50,\n    padding: 15,\n    opacity: 1,\n    fontSize: 24,\n    borderRadius: 20,\n    textAlign: ALIGN,\n    overflow: ['hidden', 'visible'],\n    position: POSITION,\n    wordWrap: true,\n};\n\nclass LayoutStory\n{\n    private toolTip: Layout;\n    private layoutContainer: Container;\n    view: Container;\n    w: number;\n    h: number;\n\n    constructor({\n        color,\n        backgroundColor,\n        width,\n        height,\n        padding,\n        opacity,\n        overflow,\n        fontSize,\n        borderRadius,\n        textAlign,\n        position,\n        wordWrap,\n    }: any)\n    {\n        this.view = new Container();\n\n        this.addTooltip(\n            `Shows you how to turn any Container into a Layout.\\n`\n                + `Same works for any other Container based element like Sprite or Graphics.\\n`\n        );\n\n        this.layoutContainer = new Container().initLayout();\n\n        this.view.addChild(this.layoutContainer);\n\n        this.layoutContainer.layout?.setStyles({\n            background: backgroundColor,\n            width: `${width}%`,\n            height: `${height}%`,\n            padding,\n            opacity,\n            overflow,\n            // text options\n            color,\n            textAlign,\n            fontSize,\n            position,\n            borderRadius,\n            wordWrap,\n        });\n\n        this.layoutContainer.layout?.addContent(LOREM_TEXT);\n    }\n\n    async addTooltip(text: string)\n    {\n        this.toolTip = await toolTip(text);\n        this.view.addChild(this.toolTip);\n        this.toolTip.resize(this.w, this.h);\n    }\n\n    resize(w: number, h: number)\n    {\n        this.w = w;\n        this.h = h;\n\n        this.layoutContainer?.layout?.resize(w, h);\n        this.toolTip?.resize(w, h);\n    }\n}\n\nexport const TransformContainer = (params: any) => new LayoutStory(params);\n\nexport default {\n    title: 'Basic',\n    argTypes: argTypes(args),\n    args: getDefaultArgs(args),\n};\n\n",
        "called_code_segment_file_1": "set(styles?: Styles & ConditionalStyles)\n{\n    this.styles.overflow\n        = styles?.overflow ?? this.styles.overflow ?? OVERFLOW[0];\n    this.styles.display\n        = styles?.display ?? this.styles.display ?? 'inline-block';\n    this.styles.borderRadius\n        = styles?.borderRadius ?? this.styles.borderRadius ?? 0;\n\n    this.styles.zIndex = styles?.zIndex ?? this.styles.zIndex ?? 1;\n\n    this.opacity = styles?.opacity ?? this.styles.opacity ?? 1;\n\n    this.styles.maxWidth = styles?.maxWidth ?? this.styles.maxWidth;\n    this.styles.maxHeight = styles?.maxHeight ?? this.styles.maxHeight;\n\n    this.styles.minWidth = styles?.minWidth ?? this.styles.minWidth;\n    this.styles.minHeight = styles?.minHeight ?? this.styles.minHeight;\n\n    this.styles.padding = styles?.padding ?? this.styles.padding ?? 0;\n    this.styles.paddingTop\n        = styles?.paddingTop\n        ?? styles?.padding\n        ?? this.styles.paddingTop\n        ?? 0;\n    this.styles.paddingRight\n        = styles?.paddingRight\n        ?? styles?.padding\n        ?? this.styles.paddingRight\n        ?? 0;\n    this.styles.paddingBottom\n        = styles?.paddingBottom\n        ?? styles?.padding\n        ?? this.styles.paddingBottom\n        ?? 0;\n    this.styles.paddingLeft\n        = styles?.paddingLeft\n        ?? styles?.padding\n        ?? this.styles.paddingLeft\n        ?? 0;\n\n    this.styles.margin = styles?.margin ?? this.styles.margin ?? 0;\n    this.styles.marginTop\n        = styles?.marginTop ?? styles?.margin ?? this.styles.marginTop ?? 0;\n    this.styles.marginRight\n        = styles?.marginRight\n        ?? styles?.margin\n        ?? this.styles.marginRight\n        ?? 0;\n    this.styles.marginBottom\n        = styles?.marginBottom\n        ?? styles?.margin\n        ?? this.styles.marginBottom\n        ?? 0;\n    this.styles.marginLeft\n        = styles?.marginLeft ?? styles?.margin ?? this.styles.marginLeft ?? 0;\n\n    this.styles.scale = styles?.scale ?? this.styles.scale ?? 1;\n    this.styles.scaleX\n        = styles?.scaleX ?? styles?.scale ?? this.styles.scaleX ?? 1;\n    this.styles.scaleY\n        = styles?.scaleY ?? styles?.scale ?? this.styles.scaleY ?? 1;\n\n    this.styles.width = styles?.width ?? this.styles.width ?? 'auto';\n    this.styles.height = styles?.height ?? this.styles.height ?? 'auto';\n\n    this.styles.wordWrap = styles?.wordWrap ?? false;\n\n    if (styles?.anchorX !== undefined)\n    {\n        this.styles.anchorX = styles.anchorX;\n    }\n    else if (styles?.anchor !== undefined)\n    {\n        if (typeof styles.anchor === 'number')\n        {\n            this.styles.anchorX = styles.anchor;\n        }\n        else if (Array.isArray(styles.anchor))\n        {\n            this.styles.anchorX = styles.anchor[0];\n        }\n    }\n\n    if (styles?.anchorY !== undefined)\n    {\n        this.styles.anchorY = styles.anchorY;\n    }\n    else if (styles?.anchor !== undefined)\n    {\n        if (typeof styles.anchor === 'number')\n        {\n            this.styles.anchorY = styles.anchor;\n        }\n        else if (\n            Array.isArray(styles.anchor)\n            && styles.anchor[1] !== undefined\n        )\n        {\n            this.styles.anchorY = styles.anchor[1];\n        }\n    }\n\n    this.styles.background\n        = styles?.background\n        ?? styles?.backgroundColor\n        ?? this.styles.background;\n\n    this.styles.backgroundSize\n        = styles?.backgroundSize\n        ?? this.styles.backgroundSize\n        ?? BACKGROUND_SIZE[0];\n\n    if (\n        this.styles.background instanceof NineSliceSprite\n        || this.styles.background instanceof TilingSprite\n    )\n    {\n        this.styles.backgroundSize = 'stretch';\n    }\n\n    this.styles.textAlign = styles?.textAlign ?? this.styles.textAlign;\n    this.styles.position = styles?.position ?? this.styles.position;\n    this.styles.verticalAlign\n        = styles?.verticalAlign\n        ?? this.styles.verticalAlign\n        ?? VERTICAL_ALIGN[0];\n\n    this.styles.aspectRatio\n        = styles?.aspectRatio ?? this.styles.aspectRatio ?? 'static';\n\n    this.styles.visible = styles?.visible ?? this.styles.visible ?? true;\n    this.visible = this.styles.visible;\n\n    this._textStyle = stylesToPixiTextStyles(styles);\n\n    if (styles)\n    {\n        this.separateConditionalStyles(styles);\n    }\n}",
        "invoking_code_segment_file_2": "setStyles(styles: Styles & ConditionalStyles)\n{\n    this._style.set(styles);\n    this.updateParents();\n}",
        "called_code_segment_file_2": "updateParents()\n{\n    const rootLayout = this.getRootLayout();\n\n    rootLayout.size.resize();\n}",
        "using_code_segment_file_3": "resize(w: number, h: number)\n{\n    this.w = w;\n    this.h = h;\n\n    this.layoutContainer?.layout?.resize(w, h);\n    this.toolTip?.resize(w, h);\n}",
        "feature_description": "Add a new feature to allow conditional styles based on device orientation (portrait or landscape) to be applied dynamically.",
        "detailed_feature_description": "The new feature will modify the `set` method in `#file 1` to include a check for device orientation and apply conditional styles accordingly. The `setStyles` method in `#file 2` will be updated to handle the new conditional styles logic. The `resize` method in `#file 3` will be updated to ensure that the layout system is resized correctly when the device orientation changes.",
        "modified_complete_code": {
            "#file 1": "set(styles?: Styles & ConditionalStyles)\n{\n    this.styles.overflow\n        = styles?.overflow ?? this.styles.overflow ?? OVERFLOW[0];\n    this.styles.display\n        = styles?.display ?? this.styles.display ?? 'inline-block';\n    this.styles.borderRadius\n        = styles?.borderRadius ?? this.styles.borderRadius ?? 0;\n\n    this.styles.zIndex = styles?.zIndex ?? this.styles.zIndex ?? 1;\n\n    this.opacity = styles?.opacity ?? this.styles.opacity ?? 1;\n\n    this.styles.maxWidth = styles?.maxWidth ?? this.styles.maxWidth;\n    this.styles.maxHeight = styles?.maxHeight ?? this.styles.maxHeight;\n\n    this.styles.minWidth = styles?.minWidth ?? this.styles.minWidth;\n    this.styles.minHeight = styles?.minHeight ?? this.styles.minHeight;\n\n    this.styles.padding = styles?.padding ?? this.styles.padding ?? 0;\n    this.styles.paddingTop\n        = styles?.paddingTop\n        ?? styles?.padding\n        ?? this.styles.paddingTop\n        ?? 0;\n    this.styles.paddingRight\n        = styles?.paddingRight\n        ?? styles?.padding\n        ?? this.styles.paddingRight\n        ?? 0;\n    this.styles.paddingBottom\n        = styles?.paddingBottom\n        ?? styles?.padding\n        ?? this.styles.paddingBottom\n        ?? 0;\n    this.styles.paddingLeft\n        = styles?.paddingLeft\n        ?? styles?.padding\n        ?? this.styles.paddingLeft\n        ?? 0;\n\n    this.styles.margin = styles?.margin ?? this.styles.margin ?? 0;\n    this.styles.marginTop\n        = styles?.marginTop ?? styles?.margin ?? this.styles.marginTop ?? 0;\n    this.styles.marginRight\n        = styles?.marginRight\n        ?? styles?.margin\n        ?? this.styles.marginRight\n        ?? 0;\n    this.styles.marginBottom\n        = styles?.marginBottom\n        ?? styles?.margin\n        ?? this.styles.marginBottom\n        ?? 0;\n    this.styles.marginLeft\n        = styles?.marginLeft ?? styles?.margin ?? this.styles.marginLeft ?? 0;\n\n    this.styles.scale = styles?.scale ?? this.styles.scale ?? 1;\n    this.styles.scaleX\n        = styles?.scaleX ?? styles?.scale ?? this.styles.scaleX ?? 1;\n    this.styles.scaleY\n        = styles?.scaleY ?? styles?.scale ?? this.styles.scaleY ?? 1;\n\n    this.styles.width = styles?.width ?? this.styles.width ?? 'auto';\n    this.styles.height = styles?.height ?? this.styles.height ?? 'auto';\n\n    this.styles.wordWrap = styles?.wordWrap ?? false;\n\n    if (styles?.anchorX !== undefined)\n    {\n        this.styles.anchorX = styles.anchorX;\n    }\n    else if (styles?.anchor !== undefined)\n    {\n        if (typeof styles.anchor === 'number')\n        {\n            this.styles.anchorX = styles.anchor;\n        }\n        else if (Array.isArray(styles.anchor))\n        {\n            this.styles.anchorX = styles.anchor[0];\n        }\n    }\n\n    if (styles?.anchorY !== undefined)\n    {\n        this.styles.anchorY = styles.anchorY;\n    }\n    else if (styles?.anchor !== undefined)\n    {\n        if (typeof styles.anchor === 'number')\n        {\n            this.styles.anchorY = styles.anchor;\n        }\n        else if (\n            Array.isArray(styles.anchor)\n            && styles.anchor[1] !== undefined\n        )\n        {\n            this.styles.anchorY = styles.anchor[1];\n        }\n    }\n\n    this.styles.background\n        = styles?.background\n        ?? styles?.backgroundColor\n        ?? this.styles.background;\n\n    this.styles.backgroundSize\n        = styles?.backgroundSize\n        ?? this.styles.backgroundSize\n        ?? BACKGROUND_SIZE[0];\n\n    if (\n        this.styles.background instanceof NineSliceSprite\n        || this.styles.background instanceof TilingSprite\n    )\n    {\n        this.styles.backgroundSize = 'stretch';\n    }\n\n    this.styles.textAlign = styles?.textAlign ?? this.styles.textAlign;\n    this.styles.position = styles?.position ?? this.styles.position;\n    this.styles.verticalAlign\n        = styles?.verticalAlign\n        ?? this.styles.verticalAlign\n        ?? VERTICAL_ALIGN[0];\n\n    this.styles.aspectRatio\n        = styles?.aspectRatio ?? this.styles.aspectRatio ?? 'static';\n\n    this.styles.visible = styles?.visible ?? this.styles.visible ?? true;\n    this.visible = this.styles.visible;\n\n    this._textStyle = stylesToPixiTextStyles(styles);\n\n    if (styles)\n    {\n        this.separateConditionalStyles(styles);\n    }\n\n    #Modify: Add conditional styles based on device orientation\n    if (this.layout.isRootLayoutPortrait) {\n        this.styles = { ...this.styles, ...styles?.portrait };\n    } else {\n        this.styles = { ...this.styles, ...styles?.landscape };\n    }\n}",
            "#file 2": "setStyles(styles: Styles & ConditionalStyles)\n{\n    this._style.set(styles);\n    this.updateParents();\n}",
            "#file 3": "resize(w: number, h: number)\n{\n    this.w = w;\n    this.h = h;\n\n    this.layoutContainer?.layout?.resize(w, h);\n    this.toolTip?.resize(w, h);\n}"
        }
    },
    {
        "repo": "faunadb-fql-lib",
        "content": "'faunadb-fql-lib/src/functions/MapFQLib.ts'\n:import { query as q, ExprVal, ExprArg } from \"faunadb\"\nimport { PageToObject } from \"./PageToObject\"\n\nexport const MapFQLib = (collection: ExprArg, lambdaExpr: ExprArg): ExprVal => {\n    return q.If(\n        q.IsArray(collection),\n        q.Map(collection, lambdaExpr),\n        q.Let(\n            {\n                data: q.Map(q.Select([\"data\"], collection), lambdaExpr),\n            },\n            q.Merge(PageToObject(collection), { data: q.Var(\"data\") })\n        )\n    )\n}\n\n'faunadb-fql-lib/src/functions/GetAll.ts'\n:import { query as q, ExprVal, ExprArg } from \"faunadb\"\nimport { MapFQLib } from \"./MapFQLib\"\n\nexport const GetAll = (expr: ExprArg): ExprVal =>\n    MapFQLib(expr, q.Lambda(\"ref\", q.Get(q.Var(\"ref\"))))\n\n'faunadb-fql-lib/src/functions/PaginateReverse.test.ts'\n:import { PaginateReverse } from \"./PaginateReverse\"\nimport { GetAll } from \"./GetAll\"\nimport { createClient } from \"../../test/utils\"\nimport { query as q } from \"faunadb\"\n\ndescribe(\"PaginateReverse\", () => {\n    const client = createClient()\n    const collectionName = Math.random()\n        .toString(36)\n        .substring(7)\n    const collectionNameIndex = collectionName + \"index\"\n    const docs = \"ABCD\"\n        .split(\"\")\n        .map(letter => ({ foo: letter, term1: \"1\", term2: \"2\" }))\n\n    const createDoc = doc => {\n        return client.query(\n            q.Create(q.Collection(collectionName), {\n                data: doc,\n            })\n        )\n    }\n\n    let doc1\n    beforeAll(async () => {\n        await client.query(q.CreateCollection({ name: collectionName }))\n        await client.query(\n            q.CreateIndex({\n                name: collectionNameIndex,\n                source: q.Collection(collectionName),\n                active: true,\n                terms: [\n                    { field: [\"data\", \"term1\"] },\n                    { field: [\"data\", \"term2\"] },\n                ],\n            })\n        )\n        doc1 = await createDoc(docs[0])\n        await createDoc(docs[1])\n        await createDoc(docs[2])\n        await createDoc(docs[3])\n        await client.query(q.Update(doc1.ref, { data: { updatePass1: true } }))\n        await client.query(q.Update(doc1.ref, { data: { updatePass2: true } }))\n        await client.query(q.Update(doc1.ref, { data: { updatePass3: true } }))\n    })\n\n    test(\"paginate collection in reverse\", async () => {\n        const res = await client.query(\n            GetAll(PaginateReverse(q.Documents(q.Collection(collectionName))))\n        )\n\n        expect(res.data[0].data.foo).toBe(\"D\")\n        expect(res.data[3].data.foo).toBe(\"A\")\n    })\n\n    test(\"paginate collection in reverse with params\", async () => {\n        const queryFn = params =>\n            GetAll(\n                PaginateReverse(\n                    q.Documents(q.Collection(collectionName)),\n                    params\n                )\n            )\n        const page1 = await client.query(queryFn({ size: 2 }))\n\n        expect(page1.data[0].data.foo).toBe(\"D\")\n        expect(page1.data[1].data.foo).toBe(\"C\")\n\n        const page2 = await client.query(\n            queryFn({ size: 2, after: page1.after })\n        )\n        expect(page2.data[0].data.foo).toBe(\"B\")\n        expect(page2.data[1].data.foo).toBe(\"A\")\n    })\n\n    test(\"paginate index in reverse\", async () => {\n        const res = await client.query(\n            GetAll(\n                PaginateReverse(q.Match(q.Index(collectionNameIndex), \"1\", \"2\"))\n            )\n        )\n\n        expect(res.data[0].data.foo).toBe(\"D\")\n        expect(res.data[3].data.foo).toBe(\"A\")\n    })\n\n    // test(\"paginate event history in reverse\", async () => {\n    //     const res1 = await client.query(\n    //         q.Paginate(doc1.ref, { size: 2, events: true })\n    //     )\n    //     console.log(res1)\n    //     // const res2 = await client.query(\n    //     //     q.Paginate(doc1.ref, { size: 2, events: true, after: res1.after })\n    //     // )\n    //     // console.log(res2)\n\n    //     const res3 = await client.query(\n    //         q.Paginate(q.Events(doc1.ref), { size: 2, before: null })\n    //     )\n    //     console.log(res3)\n    //     // const res4 = await client.query(\n    //     //     q.Paginate(q.Events(doc1.ref), { size: 2, after: res2.after })\n    //     // )\n    //     // console.log(res4)\n    //     // throw new Error(\"asdf\")\n\n    //     const page1 = await client.query(\n    //         PaginateReverse(q.Events(doc1.ref), { size: 2 })\n    //     )\n    //     console.log(page1)\n    //     expect(page1.data[0].data.updatePass3).toBe(true)\n    //     expect(page1.data[1].data.updatePass2).toBe(true)\n\n    //     const page2 = await client\n    //         .query(\n    //             q.Paginate(q.Events(doc1.ref), {\n    //                 size: 2,\n    //                 after: page1.after,\n    //             })\n    //         )\n    //         .catch(err => err)\n    //     console.log(page2)\n    //     expect(page2.data[0].data.updatePass1).toBe(true)\n    //     // expect(page0.data[1].data.updatePass1).toBe(true)\n    // })\n})\n\n",
        "called_code_segment_file_1": "export const MapFQLib = (collection: ExprArg, lambdaExpr: ExprArg): ExprVal => {\n    return q.If(\n        q.IsArray(collection),\n        q.Map(collection, lambdaExpr),\n        q.Let(\n            {\n                data: q.Map(q.Select([\"data\"], collection), lambdaExpr),\n            },\n            q.Merge(PageToObject(collection), { data: q.Var(\"data\") })\n        )\n    )\n}",
        "invoking_code_segment_file_2": "export const GetAll = (expr: ExprArg): ExprVal =>\n    MapFQLib(expr, q.Lambda(\"ref\", q.Get(q.Var(\"ref\"))))",
        "called_code_segment_file_2": "export const GetAll = (expr: ExprArg): ExprVal =>\n    MapFQLib(expr, q.Lambda(\"ref\", q.Get(q.Var(\"ref\"))))",
        "using_code_segment_file_3": "const res = await client.query(\n    GetAll(PaginateReverse(q.Documents(q.Collection(collectionName))))\n)",
        "feature_description": "Add a feature to include a filter in the GetAll function to only retrieve documents that match a specific condition.",
        "detailed_feature_description": "Modify the GetAll function in #file 2 to accept an optional filter parameter. Update the MapFQLib function in #file 1 to handle this filter. Ensure that the GetAll function in #file 2 is updated to pass the filter to MapFQLib. If #file 3 uses GetAll, update it to pass the filter if needed.",
        "modified_complete_code": {
            "#file 1": "export const MapFQLib = (collection: ExprArg, lambdaExpr: ExprArg, filterExpr?: ExprArg): ExprVal => {\n    return q.If(\n        q.IsArray(collection),\n        q.Map(collection, lambdaExpr),\n        q.Let(\n            {\n                data: q.Map(q.Select([\"data\"], collection), lambdaExpr),\n            },\n            q.Merge(PageToObject(collection), { data: q.Var(\"data\") })\n        )\n    )\n}",
            "#file 2": "export const GetAll = (expr: ExprArg, filterExpr?: ExprArg): ExprVal =>\n    MapFQLib(expr, q.Lambda(\"ref\", q.If(filterExpr, q.Get(q.Var(\"ref\")), null)), filterExpr)",
            "#file 3": "const res = await client.query(\n    GetAll(PaginateReverse(q.Documents(q.Collection(collectionName))), q.Lambda(\"ref\", q.Equals(q.Select([\"data\", \"foo\"], q.Get(q.Var(\"ref\"))), \"A\")))\n)"
        }
    },
    {
        "repo": "gemfab",
        "content": "'gemfab/test/ERC20/helpers.ts'\n:// redo expectEvent to work with ethers\n//     https://github.com/OpenZeppelin/openzeppelin-test-helpers/blob/master/src/expectEvent.js\n//\n// The MIT License (MIT)\n// Copyright (c) 2018 OpenZeppelin\n// https://github.com/OpenZeppelin/openzeppelin-test-helpers/blob/master/LICENSE\n\nconst {expect} = require(\"chai\");\n\n// matches eventName\n// matches data if defined\nfunction expectEvent (receipt, eventName, eventArgs = {}, data = undefined) {\n    const args = Object.keys(eventArgs).map((key) => {return eventArgs[key]})\n    let found = false\n    receipt.events.forEach(event => {\n        if( event.event == eventName && (data == undefined || data == event.data) ) {\n            let match = true\n            Object.keys(eventArgs).forEach(key => {\n                try {\n                    if( eventName == undefined ) {\n                        expect(eventArgs[key]).to.eql(event.topics[key])\n                    } else {\n                        expect(eventArgs[key]).to.eql(event.args[key])\n                    }\n                } catch {\n                    match = false\n                }\n            })\n            found = found || match\n        }\n    })\n\n    expect(found).to.equal(true, `No '${eventName}' events found with args ${args}`);\n}\n\nmodule.exports = { expectEvent }\n\n'gemfab/test/ERC20/ERC20.behavior.ts'\n:// modified version of openzeppelin-contracts ERC20.behavior.js\n//   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.behavior.js\n//\n// The MIT License (MIT)\n// Copyright (c) 2016-2020 zOS Global Limited\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE\n\nconst { expect } = require('chai');\nconst expectRevert = async (f, msg) => { await expect(f).rejectedWith(msg) }\nconst { expectEvent } = require('./helpers')\nimport {BigNumber, constants} from 'ethers'\nconst ZERO_ADDRESS = constants.AddressZero\n\nfunction shouldBehaveLikeERC20 (errorPrefix, initialSupply, _initialHolder, _recipient, _anotherAccount) {\n  {\n    let initialHolder, recipient, anotherAccount\n    beforeEach(async function () {\n      initialHolder  = await _initialHolder\n      recipient      = await _recipient\n      anotherAccount = await _anotherAccount\n    })\n\n    describe('total supply', function () {\n      it('returns the total amount of tokens', async function () {\n        expect(await this.token.totalSupply()).to.eql(initialSupply);\n      });\n    });\n\n    describe('balanceOf', function () {\n      describe('when the requested account has no tokens', function () {\n        it('returns zero', async function () {\n          expect(await this.token.balanceOf(anotherAccount.address)).to.eql(constants.Zero);\n        });\n      });\n\n      describe('when the requested account has some tokens', function () {\n        it('returns the total amount of tokens', async function () {\n          expect(await this.token.balanceOf(initialHolder.address)).to.eql(initialSupply);\n        });\n      });\n    });\n\n    describe('transfer', function () {\n      shouldBehaveLikeERC20Transfer(errorPrefix, _initialHolder, _recipient, initialSupply,\n          function (from, to, value) {\n            return this.token.connect(from).transfer(to, value);\n          },\n      );\n    });\n\n    describe('transfer from', function () {\n      let spender;\n      beforeEach(async function () {\n        spender = await _recipient\n      })\n\n      describe('when the token owner is not the zero address', function () {\n        let tokenOwner\n        beforeEach(async function () {\n          tokenOwner = await _initialHolder\n        })\n\n        describe('when the recipient is not the zero address', function () {\n          let to\n          beforeEach(async function () {\n            to = await _anotherAccount\n          })\n\n          describe('when the spender has enough approved balance', function () {\n            beforeEach(async function () {\n              await this.token.connect(initialHolder).approve(spender.address, initialSupply);\n            });\n\n            describe('when the token owner has enough balance', function () {\n              const amount = initialSupply;\n\n              it('transfers the requested amount', async function () {\n                await this.token.connect(spender).transferFrom(tokenOwner.address, to.address, amount);\n\n                expect(await this.token.balanceOf(tokenOwner.address)).to.eql(constants.Zero);\n\n                expect(await this.token.balanceOf(to.address)).to.eql(amount);\n              });\n\n              it('decreases the spender allowance', async function () {\n                await this.token.connect(spender).transferFrom(tokenOwner.address, to.address, amount);\n\n                expect(await this.token.allowance(tokenOwner.address, spender.address)).to.eql(constants.Zero);\n              });\n\n              it('emits a transfer event', async function () {\n                const tx = await this.token.connect(spender).transferFrom(tokenOwner.address, to.address, amount);\n                const rx = await tx.wait()\n\n                expectEvent(rx, 'Transfer', {\n                  src: tokenOwner.address,\n                  dst: to.address,\n                  wad: amount,\n                });\n              });\n\n              it('emits an approval event', async function () {\n                const tx = await this.token.connect(spender).transferFrom(tokenOwner.address, to.address, amount);\n                const rx = await tx.wait()\n\n                expectEvent(rx, 'Approval', {\n                  src: tokenOwner.address,\n                  usr: spender.address,\n                  wad: await this.token.allowance(tokenOwner.address, spender.address),\n                });\n              });\n            });\n\n            describe('when the token owner does not have enough balance', function () {\n              const amount = initialSupply.add(1);\n\n              it('reverts', async function () {\n                await expectRevert(this.token.connect(spender).transferFrom(\n                    tokenOwner.address, to.address, amount), `ErrUnderflow`,\n                );\n              });\n            });\n          });\n\n          describe('when the spender does not have enough approved balance', function () {\n            beforeEach(async function () {\n              await this.token.connect(tokenOwner).approve(spender.address, initialSupply.sub(1));\n            });\n\n            describe('when the token owner has enough balance', function () {\n              const amount = initialSupply;\n\n              it('reverts', async function () {\n                await expectRevert(this.token.connect(spender).transferFrom(\n                    tokenOwner.address, to.address, amount), `ErrUnderflow`,\n                );\n              });\n            });\n\n            describe('when the token owner does not have enough balance', function () {\n              const amount = initialSupply.add(1);\n\n              it('reverts', async function () {\n                await expectRevert(this.token.connect(spender).transferFrom(\n                    tokenOwner.address, to.address, amount), `ErrUnderflow`,\n                );\n              });\n            });\n          });\n        });\n\n        describe('when the recipient is the zero address', function () {\n          const amount = initialSupply;\n          const to = ZERO_ADDRESS;\n\n          beforeEach(async function () {\n            await this.token.connect(tokenOwner).approve(spender.address, amount);\n          });\n\n          it('reverts', async function () {\n            await expectRevert(this.token.connect(spender).transferFrom(\n              tokenOwner.address, to, amount), `ErrZeroDst()`,\n            );\n          });\n        });\n      });\n\n      /*\n      describe('when the token owner is the zero address', function () {\n        const amount = 0;\n        const tokenOwner = ZERO_ADDRESS;\n        const to = recipient;\n\n        it('reverts', async function () {\n          await expectRevert(this.token.transferFrom(\n            tokenOwner, to, amount, { from: spender }), `${errorPrefix}: transfer from the zero address`,\n          );\n        });\n      });\n      */\n    });\n\n    describe('approve', function () {\n      shouldBehaveLikeERC20Approve(errorPrefix, _initialHolder, _recipient, initialSupply,\n          function (owner, spender, amount) {\n            return this.token.connect(owner).approve(spender.address, amount);\n          },\n      );\n    });\n  }\n}\n\nfunction shouldBehaveLikeERC20Transfer (errorPrefix, _from, _to, balance, transfer) {\n  {\n    let from, to\n    beforeEach(async function () {\n      from = await _from\n      to   = await _to\n    })\n\n    describe('when the recipient is not the zero address', function () {\n      describe('when the sender does not have enough balance', function () {\n        const amount = balance.add(1);\n\n        it('reverts', async function () {\n          await expectRevert(transfer.call(this, from, to.address, amount), `ErrUnderflow`,\n          );\n        });\n      });\n\n      describe('when the sender transfers all balance', function () {\n        const amount = balance;\n\n        it('transfers the requested amount', async function () {\n          await transfer.call(this, from, to.address, amount);\n\n          expect(await this.token.balanceOf(from.address)).to.eql(constants.Zero);\n\n          expect(await this.token.balanceOf(to.address)).to.eql(amount);\n        });\n\n        it('emits a transfer event', async function () {\n          const tx = await transfer.call(this, from, to.address, amount);\n          const rx = await tx.wait()\n\n          expectEvent(rx, 'Transfer', {\n            src: from.address,\n            dst: to.address,\n            wad: amount,\n          });\n        });\n      });\n\n      describe('when the sender transfers zero tokens', function () {\n        const amount = constants.Zero;\n\n        it('transfers the requested amount', async function () {\n          await transfer.call(this, from, to.address, amount);\n\n          expect(await this.token.balanceOf(from.address)).to.eql(balance);\n\n          expect(await this.token.balanceOf(to.address)).to.eql(constants.Zero);\n        });\n\n        it('emits a transfer event', async function () {\n          const tx = await transfer.call(this, from, to.address, amount);\n          const rx = await tx.wait()\n\n          expectEvent(rx, 'Transfer', {\n            src: from.address,\n            dst: to.address,\n            wad: amount,\n          });\n        });\n      });\n    });\n    describe('when the recipient is the zero address', function () {\n      it('reverts', async function () {\n        await expectRevert(transfer.call(this, from, ZERO_ADDRESS, balance), `ErrZeroDst()`);\n      });\n    });\n\n  }\n\n}\n\nfunction shouldBehaveLikeERC20Approve (errorPrefix, _owner, _spender, supply, approve) {\n  {\n    let owner, spender\n    beforeEach(async function () {\n      owner   = await _owner\n      spender = await _spender\n    })\n\n    describe('when the spender is not the zero address', function () {\n      describe('when the sender has enough balance', function () {\n        const amount = supply;\n\n        it('emits an approval event', async function () {\n          const tx = await approve.call(this, owner, spender, amount);\n          const rx = await tx.wait()\n\n          expectEvent(rx, 'Approval', {\n            src: owner.address,\n            usr: spender.address,\n            wad: amount,\n          });\n        });\n\n        describe('when there was no approved amount before', function () {\n          it('approves the requested amount', async function () {\n            await approve.call(this, owner, spender, amount);\n\n            expect(await this.token.allowance(owner.address, spender.address)).to.eql(amount);\n          });\n        });\n\n        describe('when the spender had an approved amount', function () {\n          beforeEach(async function () {\n            await approve.call(this, owner, spender, BigNumber.from(1));\n          });\n\n          it('approves the requested amount and replaces the previous one', async function () {\n            await approve.call(this, owner, spender, amount);\n\n            expect(await this.token.allowance(owner.address, spender.address)).to.eql(amount);\n          });\n        });\n      });\n\n      describe('when the sender does not have enough balance', function () {\n        const amount = supply.add(1);\n\n        it('emits an approval event', async function () {\n          const tx = await approve.call(this, owner, spender, amount);\n          const rx = await tx.wait()\n\n          expectEvent(rx, 'Approval', {\n            src: owner.address,\n            usr: spender.address,\n            wad: amount,\n          });\n        });\n\n        describe('when there was no approved amount before', function () {\n          it('approves the requested amount', async function () {\n            await approve.call(this, owner, spender, amount);\n\n            expect(await this.token.allowance(owner.address, spender.address)).to.eql(amount);\n          });\n        });\n\n        describe('when the spender had an approved amount', function () {\n          beforeEach(async function () {\n            await approve.call(this, owner, spender, constants.One);\n          });\n\n          it('approves the requested amount and replaces the previous one', async function () {\n            await approve.call(this, owner, spender, amount);\n\n            expect(await this.token.allowance(owner.address, spender.address)).to.eql(amount);\n          });\n        });\n      });\n    });\n  }\n\n  /*\n  describe('when the spender is the zero address', function () {\n    it('reverts', async function () {\n      await expectRevert(approve.call(this, owner, ZERO_ADDRESS, supply),\n        `${errorPrefix}: approve to the zero address`,\n      );\n    });\n  });\n  */\n}\n\nmodule.exports = {\n  shouldBehaveLikeERC20,\n  shouldBehaveLikeERC20Transfer,\n  shouldBehaveLikeERC20Approve,\n};\n\n'gemfab/test/ERC20/ERC20.test.ts'\n:// modified version of openzeppelin-contracts ERC20.test.js\n//   https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC20/ERC20.test.js\n//\n// The MIT License (MIT)\n// Copyright (c) 2016-2020 zOS Global Limited\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/LICENSE\n\nimport {ethers} from \"hardhat\";\nimport * as hh from \"hardhat\";\nimport {snapshot, revert, send} from 'minihat'\nimport {Signer, constants, utils} from \"ethers\";\n\nconst { expectEvent } = require('./helpers')\nconst { expect } = require('chai');\nconst expectRevert = async (f, msg) => { await expect(f).rejectedWith(msg) }\nconst { BigNumber } = ethers\nconst ZERO_ADDRESS = ethers.constants.AddressZero\n\nconst {\n  shouldBehaveLikeERC20,\n  shouldBehaveLikeERC20Transfer,\n  shouldBehaveLikeERC20Approve,\n} = require('./ERC20.behavior');\n\n//const Gem    = artifacts.require('Gem');\n//const GemFab = artifacts.require('GemFab');\n//const ERC20DecimalsMock = artifacts.require('ERC20DecimalsMock');\n//\nasync function decreaseAllowance (token, ali, bob, amount) {\n  const allowance = await token.allowance(ali.address, bob.address);\n  const tx = await token.connect(ali).approve(bob.address, allowance.sub(amount));\n  return tx;\n}\n\nasync function increaseAllowance (token, ali, bob, amount) {\n  const allowance = await token.allowance(ali.address, bob.address);\n  const tx = await token.connect(ali).approve(bob.address, allowance.add(amount));\n  return tx;\n}\n\nlet _initialHolder, _recipient, _anotherAccount : Promise<Signer>;\nlet initialHolder, recipient, anotherAccount : Signer;\n\ndescribe('ERC20', () => {\n\n  const name = utils.formatBytes32String('Gem');\n  const symbol = utils.formatBytes32String('GEM');\n\n  const initialSupply = BigNumber.from(1000);\n\n  let gem;\n  let gem_type\n  let gemfab;\n  let gemfab_type\n  const signers   = ethers.getSigners();\n  _initialHolder  = signers.then((s) => {return s[0]})\n  _recipient      = signers.then((s) => {return s[1]})\n  _anotherAccount = signers.then((s) => {return s[2]})\n  before(async function () {\n    //[initialHolder, recipient, anotherAccount] = [ali, bob, cat].map(signer => signer.address)\n    initialHolder  = await _initialHolder\n    recipient      = await _recipient\n    anotherAccount = await _anotherAccount\n\n    const ali = initialHolder\n    gem_type = await ethers.getContractFactory('Gem', ali)\n    gemfab_type = await ethers.getContractFactory('GemFab', ali)\n\n    gemfab = await gemfab_type.deploy()\n    const gemaddr = await gemfab.callStatic.build(name, symbol)\n    await send(gemfab.build, name, symbol)\n    gem = gem_type.attach(gemaddr)\n\n    await snapshot(hh)\n  })\n\n\n  beforeEach(async function () {\n    await revert(hh)\n    this.token = gem;\n    await this.token.mint(initialHolder.address, initialSupply);\n  });\n\n  it('has a name', async function () {\n    expect(await this.token.name()).to.equal(name);\n  });\n\n  it('has a symbol', async function () {\n    expect(await this.token.symbol()).to.equal(symbol);\n  });\n\n  it('has 18 decimals', async function () {\n    expect(await this.token.decimals()).to.equal(18);\n  });\n\n    /*\n  describe('set decimals', function () {\n    const decimals = new BN(6);\n\n    it('can set decimals during construction', async function () {\n      const token = await ERC20DecimalsMock.new(name, symbol, decimals);\n      expect(await token.decimals()).to.be.bignumber.equal(decimals);\n    });\n  });\n  */\n\n  shouldBehaveLikeERC20('ERC20', initialSupply, _initialHolder, _recipient, _anotherAccount);\n\n  describe('decrease allowance', function () {\n    describe('when the spender is not the zero address', function () {\n      let spender;\n      beforeEach(async function () {\n        spender = await _recipient\n      })\n\n      function shouldDecreaseApproval (amount) {\n        /* // no decreaseAllowance contract method\n        describe('when there was no approved amount before', function () {\n          it('reverts', async function () {\n            await expectRevert(decreaseAllowance(this.token, initialHolder, spender, amount), 'GEM/allowance underflow.',\n            );\n          });\n        });\n        */\n\n        describe('when the spender had an approved amount', function () {\n          const approvedAmount = amount;\n\n          beforeEach(async function () {\n            ({ logs: this.logs } = await this.token.approve(spender.address, approvedAmount));\n          });\n\n          it('emits an approval event', async function () {\n            const tx = await decreaseAllowance(this.token, initialHolder, spender, approvedAmount);\n            const rx = await tx.wait()\n\n            expectEvent(rx, 'Approval', {\n              src: initialHolder.address,\n              usr: spender.address,\n              wad: constants.Zero,\n            });\n          });\n\n          it('decreases the spender allowance subtracting the requested amount', async function () {\n            await decreaseAllowance(this.token, initialHolder, spender, approvedAmount.sub(1));\n\n            expect(await this.token.allowance(initialHolder.address, spender.address)).to.eql(constants.One);\n          });\n\n          it('sets the allowance to zero when all allowance is removed', async function () {\n            await decreaseAllowance(this.token, initialHolder, spender, approvedAmount);\n            expect(await this.token.allowance(initialHolder.address, spender.address)).to.eql(constants.Zero);\n          });\n\n          /* // no decreaseAllowance contract method\n          it('reverts when more than the full allowance is removed', async function () {\n            await expectRevert(\n              decreaseAllowance(this.token, initialHolder, spender, approvedAmount.add(1), { from: initialHolder }),\n              'Reverted, check reason',\n            );\n          });\n          */\n        });\n      }\n\n      describe('when the sender has enough balance', function () {\n        const amount = initialSupply;\n\n        shouldDecreaseApproval(amount);\n      });\n\n      describe('when the sender does not have enough balance', function () {\n        const amount = initialSupply.add(1);\n\n        shouldDecreaseApproval(amount);\n      });\n    });\n\n    /* // null checks not part of spec\n    describe('when the spender is the zero address', function () {\n      const amount = initialSupply;\n      const spender = ZERO_ADDRESS;\n\n      it('reverts', async function () {\n        await expectRevert(decreaseAllowance(\n          this.token, initialHolder, spender, amount), 'Reverted, check reason',\n        );\n      });\n    });\n    */\n  });\n\n  describe('increase allowance', function () {\n    const amount = initialSupply;\n\n    describe('when the spender is not the zero address', function () {\n      let spender\n      beforeEach(async function () {\n        spender = await _recipient\n      })\n\n      describe('when the sender has enough balance', function () {\n        it('emits an approval event', async function () {\n          const tx = await increaseAllowance(this.token, initialHolder, spender, amount);\n          const rx = await tx.wait()\n\n          expectEvent(rx, 'Approval', {\n            src: initialHolder.address,\n            usr: spender.address,\n            wad: amount,\n          });\n        });\n\n        describe('when there was no approved amount before', function () {\n          it('approves the requested amount', async function () {\n            await increaseAllowance(this.token, initialHolder, spender, amount);\n\n            expect(await this.token.allowance(initialHolder.address, spender.address)).to.eql(amount);\n          });\n        });\n\n        describe('when the spender had an approved amount', function () {\n          beforeEach(async function () {\n            await this.token.connect(initialHolder).approve(spender.address, constants.One);\n          });\n\n          it('increases the spender allowance adding the requested amount', async function () {\n            await increaseAllowance(this.token, initialHolder, spender, amount);\n\n            expect(await this.token.allowance(initialHolder.address, spender.address)).to.eql(amount.add(1));\n          });\n        });\n      });\n\n      describe('when the sender does not have enough balance', function () {\n        const amount = initialSupply.add(1);\n\n        it('emits an approval event', async function () {\n          const tx = await increaseAllowance(this.token, initialHolder, spender, amount);\n          const rx = await tx.wait()\n\n          expectEvent(rx, 'Approval', {\n            src: initialHolder.address,\n            usr: spender.address,\n            wad: amount,\n          });\n        });\n\n        describe('when there was no approved amount before', function () {\n          it('approves the requested amount', async function () {\n            await increaseAllowance(this.token, initialHolder, spender, amount);\n\n            expect(await this.token.allowance(initialHolder.address, spender.address)).to.eql(amount);\n          });\n        });\n\n        describe('when the spender had an approved amount', function () {\n          beforeEach(async function () {\n            await this.token.connect(initialHolder).approve(spender.address, constants.One);\n          });\n\n          it('increases the spender allowance adding the requested amount', async function () {\n            await increaseAllowance(this.token, initialHolder, spender, amount);\n\n            expect(await this.token.allowance(initialHolder.address, spender.address)).to.eql(amount.add(1));\n          });\n        });\n      });\n    });\n\n    /* // null checks not part of spec\n    describe('when the spender is the zero address', function () {\n      const spender = ZERO_ADDRESS;\n\n      it('reverts', async function () {\n        await expectRevert(\n          increaseAllowance(this.token, initialHolder, spender, amount), 'ERC20: approve to the zero address',\n        );\n      });\n    });\n    */\n  });\n\n  describe('_mint', function () {\n    const amount = BigNumber.from(50);\n    it('rejects a null account', async function () {\n      await expectRevert(\n        this.token.mint(ZERO_ADDRESS, amount), 'ErrZeroDst()',\n      );\n    });\n\n    describe('for a non zero account', function () {\n      beforeEach('minting', async function () {\n        const tx = await this.token.mint(recipient.address, amount);\n        this.rx = await tx.wait();\n      });\n\n      it('increments totalSupply', async function () {\n        const expectedSupply = initialSupply.add(amount);\n        expect(await this.token.totalSupply()).to.eql(expectedSupply);\n      });\n\n      it('increments recipient balance', async function () {\n        expect(await this.token.balanceOf(recipient.address)).to.eql(amount);\n      });\n\n      it('emits Transfer event', async function () {\n        expectEvent(this.rx, 'Transfer', {\n          src: constants.AddressZero,\n          dst: recipient.address,\n          wad: amount\n        });\n      });\n    });\n  });\n\n  describe('_burn', function () {\n    it('rejects a null account', async function () {\n      // difference from OZ: underflow because nothing can be minted there either\n      await expectRevert(this.token.burn(ZERO_ADDRESS, BigNumber.from(1)),\n        'ErrUnderflow()');\n    });\n\n    describe('for a non zero account', function () {\n      it('rejects burning more than balance', async function () {\n        await expectRevert(this.token.burn(\n          initialHolder.address, initialSupply.add(1)), 'ErrUnderflow',\n        );\n      });\n\n      const describeBurn = function (description, amount) {\n        describe(description, function () {\n          beforeEach('burning', async function () {\n            const tx = await this.token.connect(initialHolder).burn(initialHolder.address, amount);\n            this.rx = await tx.wait();\n          });\n\n          it('decrements totalSupply', async function () {\n            const expectedSupply = initialSupply.sub(amount);\n            expect(await this.token.totalSupply()).to.eql(expectedSupply);\n          });\n\n          it('decrements initialHolder balance', async function () {\n            const expectedBalance = initialSupply.sub(amount);\n            expect(await this.token.balanceOf(initialHolder.address)).to.be.eql(expectedBalance);\n          });\n\n          it('emits Transfer event', async function () {\n            expectEvent(this.rx, 'Transfer', {\n              src: initialHolder.address,\n              dst: constants.AddressZero,\n              wad: amount\n            });\n          });\n        });\n      };\n\n      describeBurn('for entire balance', initialSupply);\n      describeBurn('for less amount than balance', initialSupply.sub(1));\n    });\n  });\n\n  /*\n  describe('_transfer', function () {\n    shouldBehaveLikeERC20Transfer('ERC20', initialHolder, recipient, initialSupply, function (from, to, amount) {\n      return this.token.transferInternal(from, to, amount, {from: initialHolder});\n    });\n\n    describe('when the sender is the zero address', function () {\n      it('reverts', async function () {\n        await expectRevert(this.token.transferInternal(ZERO_ADDRESS, recipient, initialSupply),\n          'ERC20: transfer from the zero address',\n        );\n      });\n    });\n  });\n  */\n\n  /*\n  describe('_approve', function () {\n    shouldBehaveLikeERC20Approve('ERC20', initialHolder, recipient, initialSupply, function (owner, spender, amount) {\n      return this.token.approveInternal(owner, spender, amount, {from: initialHolder});\n    });\n\n    describe('when the owner is the zero address', function () {\n      it('reverts', async function () {\n        await expectRevert(this.token.approveInternal(ZERO_ADDRESS, recipient, initialSupply),\n          'ERC20: approve from the zero address',\n        );\n      });\n    });\n  });\n  */\n});\n\n",
        "called_code_segment_file_1": "function shouldBehaveLikeERC20Transfer (errorPrefix, _from, _to, balance, transfer) {\n  { ... }\n}",
        "invoking_code_segment_file_2": "shouldBehaveLikeERC20Transfer(errorPrefix, _initialHolder, _recipient, initialSupply, function (from, to, value) {\n  return this.token.connect(from).transfer(to, value);\n});",
        "called_code_segment_file_2": "function shouldBehaveLikeERC20 (errorPrefix, initialSupply, _initialHolder, _recipient, _anotherAccount) {\n  { ... }\n}",
        "using_code_segment_file_3": "shouldBehaveLikeERC20('ERC20', initialSupply, _initialHolder, _recipient, _anotherAccount);",
        "feature_description": "Add a feature to allow the ERC20 token to pause transfers.",
        "detailed_feature_description": "Introduce a pause mechanism in the ERC20 token contract. When the token is paused, transfers will revert. Update the test cases to handle the pause functionality and ensure that the behavior is correctly tested.",
        "modified_complete_code": {
            "file_1": "//Modify for modified parts and #New for newly added parts\n\nfunction shouldBehaveLikeERC20Transfer (errorPrefix, _from, _to, balance, transfer) {\n  { ... }\n  describe('when the token is paused', function () {\n    beforeEach(async function () {\n      await this.token.pause();\n    });\n\n    it('reverts', async function () {\n      await expectRevert(transfer.call(this, from, to.address, balance), 'ERC20Pausable: token transfer while paused');\n    });\n  });\n}",
            "file_2": "//Modify for modified parts and #New for newly added parts\n\nshouldBehaveLikeERC20Transfer(errorPrefix, _initialHolder, _recipient, initialSupply, function (from, to, value) {\n  return this.token.connect(from).transfer(to, value);\n});\n\n#New\nasync function pauseToken(token) {\n  await token.pause();\n}\n\n#New\nasync function unpauseToken(token) {\n  await token.unpause();\n}",
            "file_3": "//Modify for modified parts and #New for newly added parts\n\nshouldBehaveLikeERC20('ERC20', initialSupply, _initialHolder, _recipient, _anotherAccount);\n\n#New\ndescribe('pause functionality', function () {\n  it('can pause and unpause the token', async function () {\n    await pauseToken(this.token);\n    await expectRevert(this.token.connect(initialHolder).transfer(recipient.address, 1), 'ERC20Pausable: token transfer while paused');\n    await unpauseToken(this.token);\n    await this.token.connect(initialHolder).transfer(recipient.address, 1);\n  });\n});"
        }
    },
    {
        "repo": "installer-gui",
        "content": "'installer-gui/frontend/components/actions/install.tsx'\n:import Preact, {Component, toChildArray} from \"preact\";\nimport AppContext from \"../AppContext\";\nimport FileInput from \"../fileinput\";\nimport \"./install.scss\";\nimport SuggestedApplications from \"./suggested\";\nimport path from \"path\";\nimport fs from \"fs\";\nimport NotificationsStore from \"../notifications\";\nimport SwitchItem from \"../switchitem\";\nimport Terminal from \"../terminal\";\nimport Installer from \"../../modules/installer\";\nimport {ipcRenderer as IPC} from \"electron\";\nimport IPCEvents from \"@common/ipcevents\";\n\nexport default class InstallPage extends Component<{}, {\n    files: string[],\n    isBrowsing: boolean,\n    kernelPath: string,\n    shouldDownloadKernel: boolean;\n    shouldCreatePackages: boolean;\n    installationDone: boolean;\n}> {\n    fileInputRef = Preact.createRef();\n    terminalRef = Preact.createRef<Terminal>();\n\n    state = {\n        files: [],\n        isBrowsing: true,\n        kernelPath: \"\",\n        shouldDownloadKernel: true,\n        shouldCreatePackages: true,\n        installationDone: false\n    };\n\n    handleChange = (files: string[]): void => {\n        for (let i = 0; i < files.length; i++) {\n            if (this.state.files.includes(files[i])) {\n                files.splice(i, 1);\n                continue;\n            }\n\n            const location = path.resolve(files[i], \"resources\");\n            if (!fs.existsSync(location)) {\n                files.splice(i, 1);\n                NotificationsStore.showNotification(\"An invalid directory was given!\");\n            }\n        }\n\n        this.setState({\n            files: this.state.files.concat(files)\n        });\n    }\n\n    handleKernelPath = () => {}\n\n    get canInstall() {\n        return this.state.files.length > 0 && this.state.kernelPath !== \"\";\n    }\n\n    renderBrowser() {\n        return (\n            <>\n                <FileInput\n                    title=\"Applications to install kernel to\"\n                    name=\"Install paths\"\n                    files={this.state.files}\n                    onChange={(files) => this.handleChange(files)}\n                    onRemove={(path) => {\n                        this.setState(prev => {\n                            prev.files.splice(prev.files.indexOf(path), 1);\n                            return {...prev, files: prev.files};\n                        });\n                    }}\n                />\n                <FileInput\n                    title=\"Kernel path\"\n                    name=\"Kernel path\"\n                    onChange={([path]) => this.setState({kernelPath: path})}\n                    files={[this.state.kernelPath].filter(Boolean)}\n                    onRemove={() => {\n                        this.setState({kernelPath: \"\"});\n                    }}\n                />\n                <SuggestedApplications\n                    onSelect={app => {\n                        this.handleChange([app]);\n                    }}\n                    files={this.state.files}\n                />\n            </>\n        );\n    }\n\n    renderInstalling() {\n        return (\n            <>\n                <SwitchItem\n                    title=\"Download kernel.asar\"\n                    value={this.state.shouldDownloadKernel}\n                    onChange={value => {\n                        this.setState({shouldDownloadKernel: value});\n                    }}\n                />\n                <SwitchItem\n                    title=\"Create packages folder\"\n                    value={this.state.shouldCreatePackages}\n                    onChange={value => {\n                        this.setState({shouldCreatePackages: value});\n                    }}\n                />\n                <Terminal ref={this.terminalRef} />\n            </>\n        );\n    }\n\n    handleInstall() {\n        Installer.install(this.state.files, {\n            downloadASAR: this.state.shouldDownloadKernel,\n            kernelPath: this.state.kernelPath,\n            makePackagesFolder: this.state.shouldCreatePackages,\n        }, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({installationDone: true});\n        });\n    }\n\n    render(_, {isBrowsing, installationDone}) {\n        return (\n            <AppContext.Consumer>\n                {App => (\n                    <div class=\"installing\">\n                        <div class=\"scroller\">\n                            {isBrowsing ? this.renderBrowser() : this.renderInstalling()}\n                            <div class=\"margin-bottom10\" />\n                        </div>\n                        <div class=\"footer\">\n                            <button onClick={() => {\n                                if (isBrowsing) App.reset();\n                                else this.setState({isBrowsing: true});\n                            }}>Back</button>\n                            <button\n                                disabled={!this.canInstall}\n                                onClick={() => {\n                                    if (!this.canInstall) return;\n\n                                    if (installationDone) return IPC.send(IPCEvents.CLOSE_APP);\n                                    if (!isBrowsing) {\n                                        this.handleInstall();\n                                    } else {\n                                        this.setState({isBrowsing: false});\n                                    }\n                                }}\n                            >\n                                {isBrowsing ? \"Continue\" : installationDone ? \"Close\" : \"Install\"}\n                            </button>\n                        </div>\n                    </div>\n                )}\n            </AppContext.Consumer>\n        );\n    }\n}\n'installer-gui/frontend/components/App.tsx'\n:import Preact, {Component} from \"preact\";\nimport InstallPage from \"./actions/install\";\nimport UninstallPage from \"./actions/uninstall\";\nimport UpdatePage from \"./actions/update\";\nimport AppContext from \"./AppContext\";\nimport Category from \"./category\";\nimport Install from \"./icons/install\";\nimport Uninstall from \"./icons/uninstall\";\nimport Update from \"./icons/update\";\nimport {Notifications} from \"./notifications\";\nimport TitleBar from \"./titlebar\";\n\nexport default class App extends Component {\n    state = {navigator: {}}\n\n    handleSetPage({element, title}): void {\n        this.setState({\n            navigator: {element, title}\n        });\n    }\n\n    handleReset(): void {\n        this.setState({navigator: {}});\n    }\n\n    renderHome() {\n        return (\n            <div class=\"form\">\n                <div class=\"form-title\">Actions</div>\n                <Category title=\"Install\" icon={Install} note=\"Install kernel to an application you choose.\">\n                    <InstallPage />\n                </Category>\n                <Category title=\"Uninstall\" icon={Uninstall} note=\"Uninstall kernel from an application you choose.\">\n                    <UninstallPage />\n                </Category>\n                <Category title=\"Update\" icon={Update} note=\"Update the kernel.asar to the latest release.\">\n                    <UpdatePage />\n                </Category>\n            </div>\n        );\n    }\n\n    render(_, {navigator}) {\n        const context = {\n            currentPage: navigator,\n            setPage: this.handleSetPage.bind(this),\n            reset: this.handleReset.bind(this)\n        };\n\n        return (\n            <AppContext.Provider value={context}>\n                <div id=\"app-mount\">\n                    <TitleBar />\n                    <div class=\"app\">\n                        {navigator.element ? navigator.element : this.renderHome()}\n                    </div>\n                    <Notifications />\n                </div>\n            </AppContext.Provider>\n        );\n    }\n}\n'installer-gui/frontend/index.ts'\n:import {h, render} from \"preact\";\nimport App from \"./components/App\";\nimport Styles from \"./styles\";\nimport {createElement} from \"./util\";\nimport \"./index.scss\";\n\nStyles.inject();\nconst root = createElement(\"div\", {id: \"root\"});\ndocument.body.appendChild(root);\n\nrender(\n    h(App, {}),\n    root\n);\n",
        "called_code_segment_file_1": "handleChange = (files: string[]): void => {\n        for (let i = 0; i < files.length; i++) {\n            if (this.state.files.includes(files[i])) {\n                files.splice(i, 1);\n                continue;\n            }\n\n            const location = path.resolve(files[i], \"resources\");\n            if (!fs.existsSync(location)) {\n                files.splice(i, 1);\n                NotificationsStore.showNotification(\"An invalid directory was given!\");\n            }\n        }\n\n        this.setState({\n            files: this.state.files.concat(files)\n        });\n    }",
        "invoking_code_segment_file_2": "<FileInput\n                    title=\"Applications to install kernel to\"\n                    name=\"Install paths\"\n                    files={this.state.files}\n                    onChange={(files) => this.handleChange(files)}\n                    onRemove={(path) => {\n                        this.setState(prev => {\n                            prev.files.splice(prev.files.indexOf(path), 1);\n                            return {...prev, files: prev.files};\n                        });\n                    }}\n                />",
        "called_code_segment_file_2": "handleInstall() {\n        Installer.install(this.state.files, {\n            downloadASAR: this.state.shouldDownloadKernel,\n            kernelPath: this.state.kernelPath,\n            makePackagesFolder: this.state.shouldCreatePackages,\n        }, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({installationDone: true});\n        });\n    }",
        "using_code_segment_file_3": "Installer.install(this.state.files, {\n            downloadASAR: this.state.shouldDownloadKernel,\n            kernelPath: this.state.kernelPath,\n            makePackagesFolder: this.state.shouldCreatePackages,\n        }, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({installationDone: true});\n        });",
        "feature_description": "Add a feature to validate the kernel path before proceeding with the installation.",
        "detailed_feature_description": "Modify the `handleChange` method in `#file 1` to include validation for the kernel path. Update the `handleChange` method in `#file 2` to handle this validation. Ensure that the `handleInstall` method in `#file 3` is updated to reflect the changes in the kernel path validation.",
        "modified_complete_code": {
            "#file 1": "handleChange = (files: string[]): void => {\n        for (let i = 0; i < files.length; i++) {\n            if (this.state.files.includes(files[i])) {\n                files.splice(i, 1);\n                continue;\n            }\n\n            const location = path.resolve(files[i], \"resources\");\n            if (!fs.existsSync(location)) {\n                files.splice(i, 1);\n                NotificationsStore.showNotification(\"An invalid directory was given!\");\n            }\n        }\n\n        this.setState({\n            files: this.state.files.concat(files)\n        });\n    }\n\n    #Modify handleKernelPath = () => {\n        const kernelLocation = path.resolve(this.state.kernelPath, \"kernel.asar\");\n        if (!fs.existsSync(kernelLocation)) {\n            NotificationsStore.showNotification(\"Invalid kernel path!\");\n            this.setState({kernelPath: \"\"});\n        }\n    }",
            "#file 2": "<FileInput\n                    title=\"Applications to install kernel to\"\n                    name=\"Install paths\"\n                    files={this.state.files}\n                    onChange={(files) => this.handleChange(files)}\n                    onRemove={(path) => {\n                        this.setState(prev => {\n                            prev.files.splice(prev.files.indexOf(path), 1);\n                            return {...prev, files: prev.files};\n                        });\n                    }}\n                />\n\n                <FileInput\n                    title=\"Kernel path\"\n                    name=\"Kernel path\"\n                    onChange={([path]) => this.setState({kernelPath: path}, () => this.handleKernelPath())}\n                    files={[this.state.kernelPath].filter(Boolean)}\n                    onRemove={() => {\n                        this.setState({kernelPath: \"\"});\n                    }}\n                />",
            "#file 3": "handleInstall() {\n        const kernelLocation = path.resolve(this.state.kernelPath, \"kernel.asar\");\n        if (!fs.existsSync(kernelLocation)) {\n            NotificationsStore.showNotification(\"Invalid kernel path!\");\n            return;\n        }\n\n        Installer.install(this.state.files, {\n            downloadASAR: this.state.shouldDownloadKernel,\n            kernelPath: this.state.kernelPath,\n            makePackagesFolder: this.state.shouldCreatePackages,\n        }, message => {\n            this.terminalRef.current?.send(message);\n        }).then(() => {\n            this.setState({installationDone: true});\n        });\n    }"
        }
    },
    {
        "repo": "koa-useragent",
        "content": "'koa-useragent/src/lib/useragent.ts'\n:import useragent, { Details } from 'express-useragent';\n\n// express-useragent's type definition is not so correct yet, so use a modified type for now\ntype ModifiedUserAgent = Details & {\n  SilkAccelerated: boolean;\n  isFacebook: boolean;\n  isAuthoritative: boolean;\n  isAlamoFire: boolean;\n  isPhantomJS: boolean;\n};\n\nexport default class UserAgent implements Details {\n  private readonly _agent: ModifiedUserAgent;\n\n  public constructor(source = 'unknown') {\n    this._agent = useragent.parse(source) as ModifiedUserAgent;\n  }\n\n  public get isEpiphany(): boolean {\n    return this._agent.isEpiphany;\n  }\n\n  public get isDesktop(): boolean {\n    return this._agent.isDesktop;\n  }\n\n  public get isWindows(): boolean {\n    return this._agent.isWindows;\n  }\n\n  public get isWindowsPhone(): boolean {\n    return this._agent.isWindowsPhone;\n  }\n\n  public get isLinux(): boolean {\n    return this._agent.isLinux;\n  }\n\n  public get isLinux64(): boolean {\n    return this._agent.isLinux64;\n  }\n\n  public get isMac(): boolean {\n    return this._agent.isMac;\n  }\n\n  public get isChromeOS(): boolean {\n    return this._agent.isChromeOS;\n  }\n\n  public get isBada(): boolean {\n    return this._agent.isBada;\n  }\n\n  public get isSamsung(): boolean {\n    return this._agent.isSamsung;\n  }\n\n  public get isRaspberry(): boolean {\n    return this._agent.isRaspberry;\n  }\n\n  public get isBot(): boolean {\n    return !!this._agent.isBot;\n  }\n\n  public get isCurl(): boolean {\n    return this._agent.isCurl;\n  }\n\n  public get isAndroidTablet(): boolean {\n    return this._agent.isAndroidTablet;\n  }\n\n  public get isWinJs(): boolean {\n    return this._agent.isWinJs;\n  }\n\n  public get isKindleFire(): boolean {\n    return this._agent.isKindleFire;\n  }\n\n  public get isSilk(): boolean {\n    return this._agent.isSilk;\n  }\n\n  public get isCaptive(): boolean {\n    return this._agent.isCaptive;\n  }\n\n  public get isSmartTV(): boolean {\n    return this._agent.isSmartTV;\n  }\n\n  public get silkAccelerated(): boolean {\n    return this._agent.silkAccelerated;\n  }\n\n  public get SilkAccelerated(): boolean {\n    return this._agent.SilkAccelerated;\n  }\n\n  public get browser(): string {\n    return this._agent.browser;\n  }\n\n  public get version(): string {\n    return `${this._agent.version}`;\n  }\n\n  public get os(): string {\n    return this._agent.os;\n  }\n\n  public get platform(): string {\n    return this._agent.platform;\n  }\n\n  public get geoIp(): { [key: string]: any } {\n    return this._agent.geoIp;\n  }\n\n  public get source(): string {\n    return this._agent.source;\n  }\n\n  public get isFacebook(): boolean {\n    return this._agent.isFacebook;\n  }\n\n  public get isAmaya(): boolean {\n    return this._agent.isAmaya;\n  }\n\n  public get isFlock(): boolean {\n    return this._agent.isFlock;\n  }\n\n  public get isSeaMonkey(): boolean {\n    return this._agent.isSeaMonkey;\n  }\n\n  public get isOmniWeb(): boolean {\n    return this._agent.isOmniWeb;\n  }\n\n  public get isKonqueror(): boolean {\n    return this._agent.isKonqueror;\n  }\n\n  public get isChrome(): boolean {\n    return this._agent.isChrome;\n  }\n\n  public get isWebkit(): boolean {\n    return this._agent.isWebkit;\n  }\n\n  public get isFirefox(): boolean {\n    return this._agent.isFirefox;\n  }\n\n  public get isSafari(): boolean {\n    return this._agent.isSafari;\n  }\n\n  public get isIECompatibilityMode(): boolean {\n    return this._agent.isIECompatibilityMode;\n  }\n\n  public get isEdge(): boolean {\n    return this._agent.isEdge;\n  }\n\n  public get isIE(): boolean {\n    return this._agent.isIE;\n  }\n\n  public get isOpera(): boolean {\n    return this._agent.isOpera;\n  }\n\n  public get isBlackberry(): boolean {\n    return this._agent.isBlackberry;\n  }\n\n  public get isMobile(): boolean {\n    return this._agent.isMobile;\n  }\n\n  public get isTablet(): boolean {\n    return this._agent.isTablet;\n  }\n\n  public get isiPad(): boolean {\n    return this._agent.isiPad;\n  }\n\n  public get isiPod(): boolean {\n    return this._agent.isiPod;\n  }\n\n  public get isiPhone(): boolean {\n    return this._agent.isiPhone;\n  }\n\n  public get isAndroid(): boolean {\n    return this._agent.isAndroid;\n  }\n\n  public get isAuthoritative(): boolean {\n    return this._agent.isAuthoritative;\n  }\n\n  public get isAlamoFire(): boolean {\n    return this._agent.isAlamoFire;\n  }\n\n  public get isPhantomJS(): boolean {\n    return this._agent.isPhantomJS;\n  }\n\n  public get isMobileNative(): boolean {\n    return this._agent.isMobileNative;\n  }\n}\n\n'koa-useragent/src/index.ts'\n:import { Middleware, ParameterizedContext, Next } from 'koa';\nimport UserAgent from './lib/useragent';\n\nexport type UserAgentContext = {\n  userAgent: UserAgent;\n};\n\nexport const userAgent: Middleware = async (ctx: ParameterizedContext, next: Next): Promise<void> => {\n  const { header } = ctx;\n  const source = header['user-agent'];\n\n  ctx.userAgent = new UserAgent(source);\n\n  await next();\n};\n\nexport default userAgent;\n\n'koa-useragent/test/koa.ts'\n:import test, { ExecutionContext } from 'ava';\nimport Koa, { Context } from 'koa';\nimport http from 'http';\nimport request from 'supertest';\nimport { userAgent } from '../src/index';\n\ntest('koa middleware', async (t: ExecutionContext) => {\n  const app = new Koa();\n\n  app.use(userAgent);\n\n  t.plan(1);\n\n  app.use(async (context: Context, next: () => void) => {\n    t.true(!!context.userAgent);\n    await next();\n  });\n\n  await request(http.createServer(app.callback())).get('/');\n});\n\n",
        "called_code_segment_file_1": "public constructor(source = 'unknown') {\n    this._agent = useragent.parse(source) as ModifiedUserAgent;\n  }",
        "invoking_code_segment_file_2": "const source = header['user-agent'];\n\n  ctx.userAgent = new UserAgent(source);",
        "called_code_segment_file_2": "public get isBot(): boolean {\n    return !!this._agent.isBot;\n  }",
        "using_code_segment_file_3": "app.use(async (context: Context, next: () => void) => {\n    t.true(!!context.userAgent);\n    await next();\n  });",
        "feature_description": "Add a method to check if the user agent is a known bot.",
        "detailed_feature_description": "Modify the UserAgent class in #file 1 to include a method that checks if the user agent is a known bot. Update the middleware in #file 2 to use this new method. Ensure that #file 3, which uses the middleware, can still access the user agent information without any issues.",
        "modified_complete_code": {
            "#file 1": "//Modify\npublic constructor(source = 'unknown') {\n    this._agent = useragent.parse(source) as ModifiedUserAgent;\n  }\n\n//New\npublic get isKnownBot(): boolean {\n    return this._agent.isBot || this._agent.isCurl || this._agent.isFacebook;\n  }",
            "#file 2": "//Modify\nconst source = header['user-agent'];\n\n  ctx.userAgent = new UserAgent(source);\n\n//New\nctx.userAgent.isKnownBot;",
            "#file 3": "//Modify\napp.use(async (context: Context, next: () => void) => {\n    t.true(!!context.userAgent);\n    t.true(context.userAgent.isKnownBot);\n    await next();\n  });"
        }
    },
    {
        "repo": "landing",
        "content": "'landing/src/components/Logo.tsx'\n:import React, { useState } from \"react\";\n\nexport const Logo = () => {\n  const [showIcon, setShowIcon] = useState(false);\n\n  return (\n    <div\n      className=\"transition-all relative\"\n      onMouseEnter={() => setShowIcon(true)}\n      onMouseLeave={() => setShowIcon(false)}\n    >\n      {showIcon && (\n        <img\n          src=\"./HammerLogo.svg\"\n          className={`w-[3rem] h-[3rem] transition-all absolute -mb-[0.4rem]`}\n        />\n      )}\n\n      <a\n        className={`headingFont text-[1.5rem] select-none transition-all ${\n          showIcon && \"ml-[4rem]\"\n        }`}\n        href=\"/\"\n      >\n        {\"buildergroop.\"}\n      </a>\n    </div>\n  );\n};\n\n'landing/src/components/Navbar.tsx'\n:import React from \"react\";\nimport ReactTooltip from \"react-tooltip\";\nimport { Logo } from \"./Logo\";\n\nconst links = [\n  { title: \"events\", href: \"/\", tooltip: \"coming soon\" },\n  { \n    title: \"perks\", \n    href: \"https://perks.buildergroop.com\",\n  },\n  {\n    title: \"jobs\",\n    href: \"http://jobs.buildergroop.com\",\n  },\n];\n\nexport const Navbar = () => {\n  return (\n    <>\n      <div className=\"w-full flex items-center justify-between\">\n        <Logo />\n\n        {/* links */}\n        <div className=\"hidden lg:flex items-center gap-6\">\n          {links.map((link) => {\n            return (\n              <a\n                href={link.href}\n                className=\"headingFont text-[0/9rem] select-none\"\n                data-tip={link.tooltip}\n              >\n                {link.title}\n              </a>\n            );\n          })}\n        </div>\n      </div>\n\n      {/* @ts-ignore */}\n      <ReactTooltip\n        className=\"!bg-black !border !border-[#ffffff] !rounded-xl !px-5 !py-2\"\n        arrowColor=\"transparent\"\n      />\n    </>\n  );\n};\n\n'landing/src/pages/index.tsx'\n:import { useEffect, useRef, useState } from \"react\";\nimport * as Scroll from \"react-scroll\";\nimport { Hero } from \"../components/Hero\";\n\nimport { Meta } from \"../components/Meta\";\nimport { Navbar } from \"../components/Navbar\";\n\nimport json from \"../static/avatars.json\";\nconst avatars = json.avatars;\n\nexport default function Home() {\n  const Element = Scroll.Element;\n\n  const events = Scroll.Events;\n  const scroller = Scroll.scroller;\n\n  const lastElemRef = useRef();\n\n  const [arr, setArr] = useState([...avatars]);\n\n  const scrollTo = () => {\n    scroller.scrollTo(`scrollelem_last`, {\n      duration: 150 * arr.length,\n      smooth: \"linear\",\n    });\n  };\n\n  events.scrollEvent.register(\"end\", function (to, element) {\n    // const append = arr.slice(\n    //   Math.random() * (arr.length - 0),\n    //   Math.random() * (arr.length - 0)\n    // );\n\n    // setArr((c) => [...c, ...append]);\n\n    // continue scrolling\n    // elemInViewport(lastElemRef.current);\n    scrollTo();\n  });\n\n  useEffect(() => {\n    scrollTo();\n  }, [arr]);\n\n  useEffect(() => {\n    scrollTo();\n  }, []);\n\n  return (\n    <>\n      <Meta title=\"buildergroop\" />\n\n      {/* Body */}\n      <div className={`min-h-screen flex`}>\n        {/* Content */}\n        <div\n          className=\"w-screen h-screen z-[999] fixed p-[4rem] lg:py-[4rem] lg:px-[8rem]\"\n          style={{ backdropFilter: \"blur(10px)\" }}\n        >\n          <div className=\"w-full h-full max-w-[90rem] mx-auto flex flex-col\">\n            <Navbar />\n            <Hero />\n            <div className=\"\"></div>\n          </div>\n        </div>\n\n        {/* Background Layer 2 */}\n        <div\n          className=\"w-screen h-screen fixed bg-[#000] opacity-80 z-[2]\"\n          style={{\n            backgroundImage: `url(\"./DottedBackground.png\")`,\n          }}\n        />\n\n        {/* Background Layer 1 */}\n        <div className=\"flex flex-wrap gap-2 justify-evenly z-[-1]\">\n          {arr.map((src, i) => (\n            <Element\n              key={i}\n              name={i === arr.length - 1 ? \"scrollelem_last\" : \"\"}\n              ref={i === arr.length - 1 ? lastElemRef : undefined}\n              className=\"w-[7rem] h-[7rem] rounded-full\"\n              style={{\n                backgroundImage: `url(${src})`,\n                backgroundRepeat: \"no-repeat\",\n                backgroundSize: \"cover\",\n                backgroundColor: \"#f1f1f1\",\n              }}\n            />\n          ))}\n        </div>\n      </div>\n    </>\n  );\n}\n\n",
        "called_code_segment_file_1": "const links = [\n  { title: \"events\", href: \"/\", tooltip: \"coming soon\" },\n  { \n    title: \"perks\", \n    href: \"https://perks.buildergroop.com\",\n  },\n  { \n    title: \"jobs\", \n    href: \"http://jobs.buildergroop.com\",\n  },\n];",
        "invoking_code_segment_file_2": "links.map((link) => {\n  return (\n    <a\n      href={link.href}\n      className=\"headingFont text-[0/9rem] select-none\"\n      data-tip={link.tooltip}\n    >\n      {link.title}\n    </a>\n  );\n});",
        "called_code_segment_file_2": "data-tip={link.tooltip}",
        "using_code_segment_file_3": "import { Navbar } from \"../components/Navbar\";",
        "feature_description": "Add a new link to the navbar with a tooltip.",
        "detailed_feature_description": "A new link titled 'about' with a tooltip 'Learn more about us' will be added to the navbar. The Navbar component will be updated to include this new link, and the Home component will be modified to ensure the new link is rendered correctly.",
        "modified_complete_code": {
            "file_1": "const links = [\n  { title: \"events\", href: \"/\", tooltip: \"coming soon\" },\n  { \n    title: \"perks\", \n    href: \"https://perks.buildergroop.com\",\n  },\n  { \n    title: \"jobs\", \n    href: \"http://jobs.buildergroop.com\",\n  },\n  #New\n  { \n    title: \"about\", \n    href: \"/about\",\n    tooltip: \"Learn more about us\"\n  },\n  #New\n];",
            "file_2": "links.map((link) => {\n  return (\n    <a\n      href={link.href}\n      className=\"headingFont text-[0/9rem] select-none\"\n      data-tip={link.tooltip}\n    >\n      {link.title}\n    </a>\n  );\n});",
            "file_3": "import { useEffect, useRef, useState } from \"react\";\nimport * as Scroll from \"react-scroll\";\nimport { Hero } from \"../components/Hero\";\nimport { Meta } from \"../components/Meta\";\nimport { Navbar } from \"../components/Navbar\";\nimport json from \"../static/avatars.json\";\nconst avatars = json.avatars;\n\nexport default function Home() {\n  const Element = Scroll.Element;\n  const events = Scroll.Events;\n  const scroller = Scroll.scroller;\n  const lastElemRef = useRef();\n  const [arr, setArr] = useState([...avatars]);\n  const scrollTo = () => {\n    scroller.scrollTo(`scrollelem_last`, {\n      duration: 150 * arr.length,\n      smooth: \"linear\",\n    });\n  };\n  events.scrollEvent.register(\"end\", function (to, element) {\n    scrollTo();\n  });\n  useEffect(() => {\n    scrollTo();\n  }, [arr]);\n  useEffect(() => {\n    scrollTo();\n  }, []);\n  return (\n    <>\n      <Meta title=\"buildergroop\" />\n      <div className={`min-h-screen flex`}>\n        <div\n          className=\"w-screen h-screen z-[999] fixed p-[4rem] lg:py-[4rem] lg:px-[8rem]\"\n          style={{ backdropFilter: \"blur(10px)\" }}\n        >\n          <div className=\"w-full h-full max-w-[90rem] mx-auto flex flex-col\">\n            <Navbar />\n            <Hero />\n            <div className=\"\"></div>\n          </div>\n        </div>\n        <div\n          className=\"w-screen h-screen fixed bg-[#000] opacity-80 z-[2]\"\n          style={{ backgroundImage: `url(\"./DottedBackground.png\")` }}\n        />\n        <div className=\"flex flex-wrap gap-2 justify-evenly z-[-1]\">\n          {arr.map((src, i) => (\n            <Element\n              key={i}\n              name={i === arr.length - 1 ? \"scrollelem_last\" : \"\"}\n              ref={i === arr.length - 1 ? lastElemRef : undefined}\n              className=\"w-[7rem] h-[7rem] rounded-full\"\n              style={{ backgroundImage: `url(${src})`, backgroundRepeat: \"no-repeat\", backgroundSize: \"cover\", backgroundColor: \"#f1f1f1\" }}\n            />\n          ))}\n        </div>\n      </div>\n    </>\n  );\n}"
        }
    },
    {
        "repo": "logseq-datenlp-plugin",
        "content": "'logseq-datenlp-plugin/src/features/toolbar/helpers.ts'\n:import { PageEntity } from '@logseq/libs/dist/LSPlugin'\nimport {\n  addDays,\n  Day,\n  eachDayOfInterval,\n  endOfWeek,\n  parse,\n  setWeek,\n  startOfWeek,\n  subDays,\n} from 'date-fns'\nimport { getDateForPageWithoutBrackets } from 'logseq-dateutils'\n\ntype StartDayOfWeek = 'Monday' | 'Saturday' | 'Sunday'\n\nconst startOfWeekMap: Record<StartDayOfWeek, Day> = {\n  Monday: 1,\n  Sunday: 0,\n  Saturday: 6,\n}\n\nconst getJournalDay = async () => {\n  const currPage = await logseq.Editor.getCurrentPage()\n  if (!currPage || !currPage['journal?']) {\n    return new Date()\n  }\n\n  const { journalDay } = currPage as PageEntity\n  if (!journalDay)\n    throw new Error(\n      'Something is wrong. This page is supposed to be a journal page.',\n    )\n\n  const parsedJournalDay = parse(journalDay.toString(), 'yyyyMMdd', new Date())\n  return parsedJournalDay\n}\n\nexport const helpers = {\n  previousDayName: async () => {\n    const parsedJournalDay = await getJournalDay()\n    if (!parsedJournalDay) return\n\n    const previousDay = subDays(parsedJournalDay, 1)\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    return getDateForPageWithoutBrackets(previousDay, preferredDateFormat)\n  },\n  nextDayName: async () => {\n    const parsedJournalDay = await getJournalDay()\n    if (!parsedJournalDay) return\n\n    const nextDay = addDays(parsedJournalDay, 1)\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    return getDateForPageWithoutBrackets(nextDay, preferredDateFormat)\n  },\n  disDayName: async () => {\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    return getDateForPageWithoutBrackets(new Date(), preferredDateFormat)\n  },\n  insertDaysInWeek: async (year: number, weekNumber: number) => {\n    const dateInWeek = setWeek(new Date(year, 0, 1), weekNumber)\n    const startDay = logseq.settings!.startOfWeek as StartDayOfWeek\n    const weekStartsOn = startOfWeekMap[startDay]\n    const startDate = startOfWeek(dateInWeek, { weekStartsOn })\n    const endDate = endOfWeek(dateInWeek, { weekStartsOn })\n    const dates = eachDayOfInterval({ start: startDate, end: endDate })\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n\n    return dates.map((date) =>\n      getDateForPageWithoutBrackets(date, preferredDateFormat),\n    )\n  },\n}\n\n'logseq-datenlp-plugin/src/features/toolbar/handle-append-page-embeds.ts'\n:import { helpers } from './helpers'\n\nexport const handleAppendEmbeds = async (\n  pageName: string,\n  year: number,\n  week: number,\n) => {\n  const pbt = await logseq.Editor.getPageBlocksTree(pageName)\n  if (pbt.length === 0 || pbt.length === 1) {\n    const dateArr = await helpers.insertDaysInWeek(year, week)\n    dateArr.forEach(\n      async (date) =>\n        await logseq.Editor.appendBlockInPage(\n          pageName,\n          `{{embed [[${date}]]}}`,\n        ),\n    )\n    await logseq.UI.showMsg(\n      'Appended dates for the week as page embeds',\n      'success',\n    )\n  }\n  await logseq.Editor.exitEditingMode(false)\n}\n\n'logseq-datenlp-plugin/src/features/toolbar/index.ts'\n:import { getWeek, getYear } from 'date-fns'\n\nimport { handleAppendEmbeds } from './handle-append-page-embeds'\nimport { helpers } from './helpers'\nimport css from './toolbar.css?raw'\n\nexport const handleToolbar = async () => {\n  logseq.provideStyle(css)\n\n  logseq.provideModel({\n    async previousDay() {\n      logseq.App.pushState('page', {\n        name: await helpers.previousDayName(),\n      })\n    },\n    async nextDay() {\n      logseq.App.pushState('page', {\n        name: await helpers.nextDayName(),\n      })\n    },\n    async disDay() {\n      logseq.App.pushState('page', {\n        name: await helpers.disDayName(),\n      })\n    },\n    async showWeek() {\n      const year = getYear(new Date())\n      const week = getWeek(new Date())\n      const pageName = `${year}/Week ${week}`\n      await logseq.Editor.createPage(\n        pageName,\n        {},\n        {\n          redirect: false,\n          createFirstBlock: false,\n          journal: false,\n        },\n      )\n\n      // Create the page embeds\n      await handleAppendEmbeds(pageName, year, week)\n\n      // Go to page\n      logseq.App.pushState('page', {\n        name: pageName,\n      })\n    },\n  })\n\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-forward',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"nextDay\"><i class=\"ti ti-chevron-right\"></i></a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-dis', // have to use slang as logseq sorts the toolbar by name\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"disDay\">Today</a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-back',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"previousDay\"><i class=\"ti ti-chevron-left\"></i></a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-week-dis',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"showWeek\">Week ${getWeek(new Date())}</a>`,\n  })\n}\n\n",
        "called_code_segment_file_1": "const helpers = {\n  previousDayName: async () => {\n    const parsedJournalDay = await getJournalDay()\n    if (!parsedJournalDay) return\n\n    const previousDay = subDays(parsedJournalDay, 1)\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    return getDateForPageWithoutBrackets(previousDay, preferredDateFormat)\n  },\n  nextDayName: async () => {\n    const parsedJournalDay = await getJournalDay()\n    if (!parsedJournalDay) return\n\n    const nextDay = addDays(parsedJournalDay, 1)\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    return getDateForPageWithoutBrackets(nextDay, preferredDateFormat)\n  },\n  disDayName: async () => {\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    return getDateForPageWithoutBrackets(new Date(), preferredDateFormat)\n  },\n  insertDaysInWeek: async (year: number, weekNumber: number) => {\n    const dateInWeek = setWeek(new Date(year, 0, 1), weekNumber)\n    const startDay = logseq.settings!.startOfWeek as StartDayOfWeek\n    const weekStartsOn = startOfWeekMap[startDay]\n    const startDate = startOfWeek(dateInWeek, { weekStartsOn })\n    const endDate = endOfWeek(dateInWeek, { weekStartsOn })\n    const dates = eachDayOfInterval({ start: startDate, end: endDate })\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n\n    return dates.map((date) =>\n      getDateForPageWithoutBrackets(date, preferredDateFormat),\n    )\n  },\n}",
        "invoking_code_segment_file_2": "logseq.provideModel({\n  async previousDay() {\n    logseq.App.pushState('page', {\n      name: await helpers.previousDayName(),\n    })\n  },\n  async nextDay() {\n    logseq.App.pushState('page', {\n      name: await helpers.nextDayName(),\n    })\n  },\n  async disDay() {\n    logseq.App.pushState('page', {\n      name: await helpers.disDayName(),\n    })\n  },\n  async showWeek() {\n    const year = getYear(new Date())\n    const week = getWeek(new Date())\n    const pageName = `${year}/Week ${week}`\n    await logseq.Editor.createPage(\n      pageName,\n      {},\n      {\n        redirect: false,\n        createFirstBlock: false,\n        journal: false,\n      },\n    )\n\n    // Create the page embeds\n    await handleAppendEmbeds(pageName, year, week)\n\n    // Go to page\n    logseq.App.pushState('page', {\n      name: pageName,\n    })\n  },\n})",
        "called_code_segment_file_2": "const handleAppendEmbeds = async (\n  pageName: string,\n  year: number,\n  week: number,\n) => {\n  const pbt = await logseq.Editor.getPageBlocksTree(pageName)\n  if (pbt.length === 0 || pbt.length === 1) {\n    const dateArr = await helpers.insertDaysInWeek(year, week)\n    dateArr.forEach(\n      async (date) =>\n        await logseq.Editor.appendBlockInPage(\n          pageName,\n          `{{embed [[${date}]]}}`,\n        ),\n    )\n    await logseq.UI.showMsg(\n      'Appended dates for the week as page embeds',\n      'success',\n    )\n  }\n  await logseq.Editor.exitEditingMode(false)\n}",
        "using_code_segment_file_3": "export const handleToolbar = async () => {\n  logseq.provideStyle(css)\n\n  logseq.provideModel({\n    async previousDay() {\n      logseq.App.pushState('page', {\n        name: await helpers.previousDayName(),\n      })\n    },\n    async nextDay() {\n      logseq.App.pushState('page', {\n        name: await helpers.nextDayName(),\n      })\n    },\n    async disDay() {\n      logseq.App.pushState('page', {\n        name: await helpers.disDayName(),\n      })\n    },\n    async showWeek() {\n      const year = getYear(new Date())\n      const week = getWeek(new Date())\n      const pageName = `${year}/Week ${week}`\n      await logseq.Editor.createPage(\n        pageName,\n        {},\n        {\n          redirect: false,\n          createFirstBlock: false,\n          journal: false,\n        },\n      )\n\n      // Create the page embeds\n      await handleAppendEmbeds(pageName, year, week)\n\n      // Go to page\n      logseq.App.pushState('page', {\n        name: pageName,\n      })\n    },\n  })\n\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-forward',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"nextDay\"><i class=\"ti ti-chevron-right\"></i></a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-dis', // have to use slang as logseq sorts the toolbar by name\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"disDay\">Today</a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-back',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"previousDay\"><i class=\"ti ti-chevron-left\"></i></a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-week-dis',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"showWeek\">Week ${getWeek(new Date())}</a>`,\n  })\n}",
        "feature_description": "Add a feature to highlight the current day in the toolbar.",
        "detailed_feature_description": "Modify the `disDayName` function in `#file 1` to return an object containing both the date string and a boolean indicating if the date is today. Update `#file 2` to handle this new return type and use it to conditionally add a highlight class to the 'Today' button in the toolbar. Ensure `#file 3` updates its toolbar registration to use this new conditional class.",
        "modified_complete_code": {
            "#file 1": "const helpers = {\n  previousDayName: async () => {\n    const parsedJournalDay = await getJournalDay()\n    if (!parsedJournalDay) return\n\n    const previousDay = subDays(parsedJournalDay, 1)\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    return getDateForPageWithoutBrackets(previousDay, preferredDateFormat)\n  },\n  nextDayName: async () => {\n    const parsedJournalDay = await getJournalDay()\n    if (!parsedJournalDay) return\n\n    const nextDay = addDays(parsedJournalDay, 1)\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    return getDateForPageWithoutBrackets(nextDay, preferredDateFormat)\n  },\n  disDayName: async () => {\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n    const today = new Date()\n    const dateString = getDateForPageWithoutBrackets(today, preferredDateFormat)\n    const isToday = today.toDateString() === new Date().toDateString()\n    return { dateString, isToday }\n  },\n  insertDaysInWeek: async (year: number, weekNumber: number) => {\n    const dateInWeek = setWeek(new Date(year, 0, 1), weekNumber)\n    const startDay = logseq.settings!.startOfWeek as StartDayOfWeek\n    const weekStartsOn = startOfWeekMap[startDay]\n    const startDate = startOfWeek(dateInWeek, { weekStartsOn })\n    const endDate = endOfWeek(dateInWeek, { weekStartsOn })\n    const dates = eachDayOfInterval({ start: startDate, end: endDate })\n    const { preferredDateFormat } = await logseq.App.getUserConfigs()\n\n    return dates.map((date) =>\n      getDateForPageWithoutBrackets(date, preferredDateFormat),\n    )\n  },\n}",
            "#file 2": "logseq.provideModel({\n  async previousDay() {\n    logseq.App.pushState('page', {\n      name: await helpers.previousDayName(),\n    })\n  },\n  async nextDay() {\n    logseq.App.pushState('page', {\n      name: await helpers.nextDayName(),\n    })\n  },\n  async disDay() {\n    const { dateString, isToday } = await helpers.disDayName()\n    logseq.App.pushState('page', {\n      name: dateString,\n    })\n    if (isToday) {\n      logseq.provideStyle(`\n        .datenlp-toolbar.today {\n          background-color: yellow;\n        }\n      `)\n      logseq.provideUI({\n        key: 'datenlp-day-dis',\n        template: `<a class=\"button datenlp-toolbar today\" data-on-click=\"disDay\">Today</a>`,\n      })\n    }\n  },\n  async showWeek() {\n    const year = getYear(new Date())\n    const week = getWeek(new Date())\n    const pageName = `${year}/Week ${week}`\n    await logseq.Editor.createPage(\n      pageName,\n      {},\n      {\n        redirect: false,\n        createFirstBlock: false,\n        journal: false,\n      },\n    )\n\n    // Create the page embeds\n    await handleAppendEmbeds(pageName, year, week)\n\n    // Go to page\n    logseq.App.pushState('page', {\n      name: pageName,\n    })\n  },\n})",
            "#file 3": "export const handleToolbar = async () => {\n  logseq.provideStyle(css)\n\n  logseq.provideModel({\n    async previousDay() {\n      logseq.App.pushState('page', {\n        name: await helpers.previousDayName(),\n      })\n    },\n    async nextDay() {\n      logseq.App.pushState('page', {\n        name: await helpers.nextDayName(),\n      })\n    },\n    async disDay() {\n      const { dateString, isToday } = await helpers.disDayName()\n      logseq.App.pushState('page', {\n        name: dateString,\n      })\n      if (isToday) {\n        logseq.provideStyle(`\n          .datenlp-toolbar.today {\n            background-color: yellow;\n          }\n        `)\n        logseq.provideUI({\n          key: 'datenlp-day-dis',\n          template: `<a class=\"button datenlp-toolbar today\" data-on-click=\"disDay\">Today</a>`,\n        })\n      }\n    },\n    async showWeek() {\n      const year = getYear(new Date())\n      const week = getWeek(new Date())\n      const pageName = `${year}/Week ${week}`\n      await logseq.Editor.createPage(\n        pageName,\n        {},\n        {\n          redirect: false,\n          createFirstBlock: false,\n          journal: false,\n        },\n      )\n\n      // Create the page embeds\n      await handleAppendEmbeds(pageName, year, week)\n\n      // Go to page\n      logseq.App.pushState('page', {\n        name: pageName,\n      })\n    },\n  })\n\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-forward',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"nextDay\"><i class=\"ti ti-chevron-right\"></i></a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-dis', // have to use slang as logseq sorts the toolbar by name\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"disDay\">Today</a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-day-back',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"previousDay\"><i class=\"ti ti-chevron-left\"></i></a>`,\n  })\n  logseq.App.registerUIItem('toolbar', {\n    key: 'datenlp-week-dis',\n    template: `<a class=\"button datenlp-toolbar\" data-on-click=\"showWeek\">Week ${getWeek(new Date())}</a>`,\n  })\n}"
        }
    },
    {
        "repo": "logseq-plugin-js-playground",
        "content": "'logseq-plugin-js-playground/src/load-eval.tsx'\n:import React from \"react\";\nimport ReactDOMServer from \"react-dom/server\";\n\nimport {\n  BlockEntity,\n  BlockUUIDTuple,\n  PageEntity,\n} from \"@logseq/libs/dist/LSPlugin.user\";\nimport * as esbuild from \"esbuild-wasm\";\nimport esbuildWasmUrl from \"esbuild-wasm/esbuild.wasm?url\";\n\n// Makes sure eval can be successfully called\nwindow.React = React;\nlet _init: Promise<void> | null = null;\n\nexport const initEsbuild = async () => {\n  if (!_init) {\n    _init = esbuild.initialize({\n      wasmURL: esbuildWasmUrl,\n    });\n  }\n  await _init;\n};\n\nconst transform = async (code: string, isTsx: boolean) => {\n  await initEsbuild();\n  return await esbuild.transform(code, { loader: isTsx ? \"tsx\" : \"ts\" });\n};\n\nfunction isBlockEntity(\n  maybeBlockEntity: BlockEntity | BlockUUIDTuple | PageEntity\n): maybeBlockEntity is BlockEntity {\n  // PageEntity does not have \"page\" property\n  return \"page\" in maybeBlockEntity;\n}\n\nexport const loadCode = async (blockId: string) => {\n  const block = await logseq.Editor.getBlock(blockId, {\n    includeChildren: true,\n  });\n\n  const codes: [lang: string, code: string][] = (block?.children ?? [])\n    .filter(isBlockEntity)\n    .flatMap((b) => b.body)\n    .filter((pair) => pair[0] === \"Src\")\n    .map((pair) => [pair[1].language ?? \"ts\", pair[1].lines.join(\"\")]);\n\n  const hasJsx = codes.some(([lang]) => [\"tsx\", \"jsx\"].includes(lang));\n  const { code } = await transform(\n    codes.map(([_, code]) => code).join(\"\"),\n    hasJsx\n  );\n  return [code, hasJsx] as const;\n};\n\n// Eval does not support ESM `import`\n// See https://2ality.com/2019/10/eval-via-import.html\n// We want to support ESM import to load some cool utilites like\n// https://www.skypack.dev/view/vega-lite\n// import vegaLite from 'https://cdn.skypack.dev/vega-lite';\nconst evalCode = async (code: string) => {\n  const encodedJs = encodeURIComponent(code);\n  const dataUri = \"data:text/javascript;charset=utf-8,\" + encodedJs;\n  return import( /* @vite-ignore */ dataUri).then((m) => m.default);\n};\n\nexport const loadAndEval = async (blockId: string) => {\n  const [code, hasJsx] = await loadCode(blockId);\n  console.log(\"=== Transformed Code === \\n\" + code);\n  const result = await evalCode(code);\n  if (hasJsx) {\n    return ReactDOMServer.renderToStaticMarkup(result);\n  }\n  return result;\n};\n\n'logseq-plugin-js-playground/src/register-macro.tsx'\n:import { initEsbuild, loadAndEval } from \"./load-eval\";\n\nconst macroPrefix = \":jsplay\";\n\n// @ts-expect-error\nconst css = (t, ...args) => String.raw(t, ...args);\n\nconst rendering = new Map<string, string>();\n\nconst wrapTemplate = (template: string) => {\n  return `<div style=\"border: 2px solid #000; padding: 0 1em; cursor: default\">${template}</div>`;\n};\n\nexport const registerMacro = () => {\n  initEsbuild();\n  logseq.App.onMacroRendererSlotted(async ({ payload, slot }) => {\n    const uuid = payload.uuid;\n    const [type] = payload.arguments;\n    if (!type?.startsWith(macroPrefix)) {\n      return;\n    }\n\n    rendering.set(uuid, slot);\n\n    const render = async () => {\n      try {\n        if (rendering.get(uuid) !== slot) {\n          return;\n        }\n        let template = await loadAndEval(uuid);\n\n        if (rendering.get(uuid) !== slot) {\n          return;\n        }\n\n        logseq.provideUI({\n          key: \"js-playground\",\n          slot,\n          reset: true,\n          template: wrapTemplate(template),\n        });\n      } catch (err: any) {\n        console.error(err);\n        logseq.provideUI({\n          key: \"js-playground\",\n          slot,\n          reset: true,\n          template: wrapTemplate(\n            `<span style=\"color: red\">${err.message}</span>`\n          ),\n        });\n        // skip invalid\n      }\n    };\n    render();\n  });\n\n  // This command only support to replace the whole block\n  logseq.Editor.registerSlashCommand(\"Add <JSPlay /> Block\", async () => {\n    const newContent = `{{renderer ${macroPrefix}}}`;\n    const block = await logseq.Editor.getCurrentBlock();\n    if (block) {\n      await logseq.Editor.updateBlock(block.uuid, newContent);\n      const codeBlock = await logseq.Editor.insertBlock(\n        block.uuid,\n        `\\`\\`\\`ts\\n export default \"Hello World!\" \\n\\`\\`\\``\n      );\n      if (codeBlock) {\n        await logseq.Editor.moveBlock(codeBlock.uuid, block.uuid, {\n          children: true,\n        });\n        logseq.Editor.exitEditingMode();\n      }\n    }\n  });\n};\n\n'logseq-plugin-js-playground/src/main.ts'\n:import \"@logseq/libs\";\n\nimport { logseq as PL } from \"../package.json\";\nimport { registerMacro } from \"./register-macro\";\n\nconst magicKey = `__${PL.id}__loaded__`;\n\nfunction main() {\n  const pluginId = logseq.baseInfo.id;\n  console.info(`#${pluginId}: MAIN`);\n\n  // @ts-expect-error\n  top[magicKey] = true;\n\n  registerMacro();\n}\n\n// @ts-expect-error\nif (top[magicKey]) {\n  // Reload Not working properly\n  logseq.App.relaunch().then(main).catch(console.error);\n} else {\n  logseq.ready(main).catch(console.error);\n}\n\n",
        "called_code_segment_file_1": "const evalCode = async (code: string) => {\n  const encodedJs = encodeURIComponent(code);\n  const dataUri = \"data:text/javascript;charset=utf-8,\" + encodedJs;\n  return import( /* @vite-ignore */ dataUri).then((m) => m.default);\n};",
        "invoking_code_segment_file_2": "const result = await evalCode(code);\n  if (hasJsx) {\n    return ReactDOMServer.renderToStaticMarkup(result);\n  }",
        "called_code_segment_file_2": "const render = async () => {\n  try {\n    if (rendering.get(uuid) !== slot) {\n      return;\n    }\n    let template = await loadAndEval(uuid);\n\n    if (rendering.get(uuid) !== slot) {\n      return;\n    }\n\n    logseq.provideUI({\n      key: \"js-playground\",\n      slot,\n      reset: true,\n      template: wrapTemplate(template),\n    });\n  } catch (err: any) {\n    console.error(err);\n    logseq.provideUI({\n      key: \"js-playground\",\n      slot,\n      reset: true,\n      template: wrapTemplate(\n        `<span style=\"color: red\">${err.message}</span>`\n      ),\n    });\n    // skip invalid\n  }\n};",
        "using_code_segment_file_3": "logseq.App.onMacroRendererSlotted(async ({ payload, slot }) => {\n  const uuid = payload.uuid;\n  const [type] = payload.arguments;\n  if (!type?.startsWith(macroPrefix)) {\n    return;\n  }\n\n  rendering.set(uuid, slot);\n\n  const render = async () => {\n    try {\n      if (rendering.get(uuid) !== slot) {\n        return;\n      }\n      let template = await loadAndEval(uuid);\n\n      if (rendering.get(uuid) !== slot) {\n        return;\n      }\n\n      logseq.provideUI({\n        key: \"js-playground\",\n        slot,\n        reset: true,\n        template: wrapTemplate(template),\n      });\n    } catch (err: any) {\n      console.error(err);\n      logseq.provideUI({\n        key: \"js-playground\",\n        slot,\n        reset: true,\n        template: wrapTemplate(\n          `<span style=\"color: red\">${err.message}</span>`\n        ),\n      });\n      // skip invalid\n    }\n  };\n  render();\n});",
        "feature_description": "Add a feature to support dynamic imports for ESM modules within the evalCode function.",
        "detailed_feature_description": "Modify the evalCode function in #file 1 to support dynamic imports for ESM modules. Update the invoking code segment in #file 2 to handle the new dynamic import functionality. Ensure that the render function in #file 3 is updated to accommodate any changes in the evalCode function.",
        "modified_complete_code": {
            "#file 1": "const evalCode = async (code: string) => {\n  const encodedJs = encodeURIComponent(code);\n  const dataUri = \"data:text/javascript;charset=utf-8,\" + encodedJs;\n  return import( /* @vite-ignore */ dataUri).then((m) => m.default);\n}; #Modify\n\nexport const loadAndEval = async (blockId: string) => {\n  const [code, hasJsx] = await loadCode(blockId);\n  console.log(\"=== Transformed Code === \\n\" + code);\n  const result = await evalCode(code);\n  if (hasJsx) {\n    return ReactDOMServer.renderToStaticMarkup(result);\n  }\n  return result;\n};",
            "#file 2": "const render = async () => {\n  try {\n    if (rendering.get(uuid) !== slot) {\n      return;\n    }\n    let template = await loadAndEval(uuid);\n\n    if (rendering.get(uuid) !== slot) {\n      return;\n    }\n\n    logseq.provideUI({\n      key: \"js-playground\",\n      slot,\n      reset: true,\n      template: wrapTemplate(template),\n    });\n  } catch (err: any) {\n    console.error(err);\n    logseq.provideUI({\n      key: \"js-playground\",\n      slot,\n      reset: true,\n      template: wrapTemplate(\n        `<span style=\"color: red\">${err.message}</span>`\n      ),\n    });\n    // skip invalid\n  }\n}; #Modify\n\nlogseq.App.onMacroRendererSlotted(async ({ payload, slot }) => {\n  const uuid = payload.uuid;\n  const [type] = payload.arguments;\n  if (!type?.startsWith(macroPrefix)) {\n    return;\n  }\n\n  rendering.set(uuid, slot);\n\n  const render = async () => {\n    try {\n      if (rendering.get(uuid) !== slot) {\n        return;\n      }\n      let template = await loadAndEval(uuid);\n\n      if (rendering.get(uuid) !== slot) {\n        return;\n      }\n\n      logseq.provideUI({\n        key: \"js-playground\",\n        slot,\n        reset: true,\n        template: wrapTemplate(template),\n      });\n    } catch (err: any) {\n      console.error(err);\n      logseq.provideUI({\n        key: \"js-playground\",\n        slot,\n        reset: true,\n        template: wrapTemplate(\n          `<span style=\"color: red\">${err.message}</span>`\n        ),\n      });\n      // skip invalid\n    }\n  };\n  render();\n});",
            "#file 3": "logseq.App.onMacroRendererSlotted(async ({ payload, slot }) => {\n  const uuid = payload.uuid;\n  const [type] = payload.arguments;\n  if (!type?.startsWith(macroPrefix)) {\n    return;\n  }\n\n  rendering.set(uuid, slot);\n\n  const render = async () => {\n    try {\n      if (rendering.get(uuid) !== slot) {\n        return;\n      }\n      let template = await loadAndEval(uuid);\n\n      if (rendering.get(uuid) !== slot) {\n        return;\n      }\n\n      logseq.provideUI({\n        key: \"js-playground\",\n        slot,\n        reset: true,\n        template: wrapTemplate(template),\n      });\n    } catch (err: any) {\n      console.error(err);\n      logseq.provideUI({\n        key: \"js-playground\",\n        slot,\n        reset: true,\n        template: wrapTemplate(\n          `<span style=\"color: red\">${err.message}</span>`\n        ),\n      });\n      // skip invalid\n    }\n  };\n  render();\n}); #Modify"
        }
    },
    {
        "repo": "map-clustering-rn-example",
        "content": "'map-clustering-rn-example/components/ClusteredMarker.tsx'\n:import React, { memo } from 'react'\nimport { StyleSheet, Text, TouchableOpacity, View } from 'react-native'\nimport { Marker } from 'react-native-maps'\n\nimport { returnMarkerStyle } from './helpers'\n\nconst ClusteredMarker = ({\n  geometry,\n  properties,\n  onPress,\n  clusterColor,\n  clusterTextColor,\n  clusterFontFamily,\n  tracksViewChanges,\n}) => {\n  const points = properties.point_count\n  const { width, height, fontSize, size } = returnMarkerStyle(points)\n\n  return (\n    <Marker\n      key={`${geometry.coordinates[0]}_${geometry.coordinates[1]}`}\n      coordinate={{\n        longitude: geometry.coordinates[0],\n        latitude: geometry.coordinates[1],\n      }}\n      style={{ zIndex: points + 1 }}\n      onPress={onPress}\n      tracksViewChanges={tracksViewChanges}>\n      <TouchableOpacity activeOpacity={0.5} style={[styles.container, { width, height }]}>\n        <View\n          style={[\n            styles.wrapper,\n            {\n              backgroundColor: clusterColor,\n              width,\n              height,\n              borderRadius: width / 2,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.cluster,\n            {\n              backgroundColor: clusterColor,\n              width: size,\n              height: size,\n              borderRadius: size / 2,\n            },\n          ]}>\n          <Text\n            style={[\n              styles.text,\n              {\n                color: clusterTextColor,\n                fontSize,\n                fontFamily: clusterFontFamily,\n              },\n            ]}>\n            {points}\n          </Text>\n        </View>\n      </TouchableOpacity>\n    </Marker>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  wrapper: {\n    position: 'absolute',\n    opacity: 0.5,\n    zIndex: 0,\n  },\n  cluster: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  text: {\n    fontWeight: 'bold',\n  },\n})\n\nexport default memo(ClusteredMarker)\n\n'map-clustering-rn-example/components/ClusteredMapView.tsx'\n:/* \n  This component is taken from the venits/react-native-map-clustering repository and \n  imported into ours so that you can replace something and experiment with working with \n  clusters yourself.\n  \n  Some parts of this code may have already been changed.\n*/\n\nimport React, { forwardRef, memo, useEffect, useMemo, useRef, useState } from 'react'\nimport { Dimensions, LayoutAnimation, Platform } from 'react-native'\nimport MapView, { MapViewProps, Polyline } from 'react-native-maps'\nimport SuperCluster from 'supercluster'\n\nimport { MapClusteringProps } from './ClusteredMapViewTypes'\nimport ClusterMarker from './ClusteredMarker'\nimport {\n  calculateBBox,\n  generateSpiral,\n  isMarker,\n  markerToGeoJSONFeature,\n  returnMapZoom,\n} from './helpers'\n\nconst ClusteredMapView = forwardRef<MapClusteringProps & MapViewProps, any>(\n  (\n    {\n      radius,\n      maxZoom,\n      minZoom,\n      minPoints,\n      extent,\n      nodeSize,\n      children,\n      onClusterPress,\n      onRegionChangeComplete,\n      onMarkersChange,\n      preserveClusterPressBehavior,\n      clusteringEnabled,\n      clusterColor,\n      clusterTextColor,\n      clusterFontFamily,\n      spiderLineColor,\n      layoutAnimationConf,\n      animationEnabled,\n      renderCluster,\n      tracksViewChanges,\n      spiralEnabled,\n      superClusterRef,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const [markers, updateMarkers] = useState([])\n    const [spiderMarkers, updateSpiderMarker] = useState([])\n    const [otherChildren, updateChildren] = useState([])\n    const [superCluster, setSuperCluster] = useState(null)\n    const [currentRegion, updateRegion] = useState(restProps.region || restProps.initialRegion)\n\n    const [isSpiderfier, updateSpiderfier] = useState(false)\n    const [clusterChildren, updateClusterChildren] = useState(null)\n    const mapRef = useRef()\n\n    const propsChildren = useMemo(() => React.Children.toArray(children), [children])\n\n    useEffect(() => {\n      const rawData = []\n      const otherChildren = []\n\n      if (!clusteringEnabled) {\n        updateSpiderMarker([])\n        updateMarkers([])\n        updateChildren(propsChildren)\n        setSuperCluster(null)\n        return\n      }\n\n      propsChildren.forEach((child, index) => {\n        if (isMarker(child)) {\n          rawData.push(markerToGeoJSONFeature(child, index))\n        } else {\n          otherChildren.push(child)\n        }\n      })\n\n      const superCluster = new SuperCluster({\n        radius,\n        maxZoom,\n        minZoom,\n        minPoints,\n        extent,\n        nodeSize,\n      })\n\n      superCluster.load(rawData)\n\n      const bBox = calculateBBox(currentRegion)\n      const zoom = returnMapZoom(currentRegion, bBox, minZoom)\n      const markers = superCluster.getClusters(bBox, zoom)\n\n      updateMarkers(markers)\n      updateChildren(otherChildren)\n      setSuperCluster(superCluster)\n\n      superClusterRef.current = superCluster\n    }, [propsChildren, clusteringEnabled])\n\n    useEffect(() => {\n      if (!spiralEnabled) {\n        return\n      }\n\n      if (isSpiderfier && markers.length > 0) {\n        const allSpiderMarkers = []\n        let spiralChildren = []\n        markers.map((marker, i) => {\n          if (marker.properties.cluster) {\n            spiralChildren = superCluster.getLeaves(marker.properties.cluster_id, Infinity)\n          }\n          const positions = generateSpiral(marker, spiralChildren, markers, i)\n          allSpiderMarkers.push(...positions)\n        })\n\n        updateSpiderMarker(allSpiderMarkers)\n      } else {\n        updateSpiderMarker([])\n      }\n    }, [isSpiderfier, markers])\n\n    const _onRegionChangeComplete = (region) => {\n      if (superCluster && region) {\n        const bBox = calculateBBox(region)\n        const zoom = returnMapZoom(region, bBox, minZoom)\n        const markers = superCluster.getClusters(bBox, zoom)\n        if (animationEnabled && Platform.OS === 'ios') {\n          LayoutAnimation.configureNext(layoutAnimationConf)\n        }\n        if (zoom >= 18 && markers.length > 0 && clusterChildren) {\n          if (spiralEnabled) {\n            updateSpiderfier(true)\n          }\n        } else {\n          if (spiralEnabled) {\n            updateSpiderfier(false)\n          }\n        }\n        updateMarkers(markers)\n        onMarkersChange(markers)\n        onRegionChangeComplete(region, markers)\n        updateRegion(region)\n      } else {\n        onRegionChangeComplete(region)\n      }\n    }\n\n    const _onClusterPress = (cluster) => () => {\n      const children = superCluster.getLeaves(cluster.id, Infinity)\n      updateClusterChildren(children)\n\n      if (preserveClusterPressBehavior) {\n        onClusterPress(cluster, children)\n        return\n      }\n\n      const coordinates = children.map(({ geometry }) => ({\n        latitude: geometry.coordinates[1],\n        longitude: geometry.coordinates[0],\n      }))\n\n      mapRef.current.fitToCoordinates(coordinates, {\n        edgePadding: restProps.edgePadding,\n      })\n\n      onClusterPress(cluster, children)\n    }\n\n    return (\n      <MapView\n        {...restProps}\n        ref={(map) => {\n          mapRef.current = map\n          if (ref) {\n            ref.current = map\n          }\n          restProps.mapRef(map)\n        }}\n        onRegionChangeComplete={_onRegionChangeComplete}>\n        {markers.map((marker) =>\n          marker.properties.point_count === 0 ? (\n            propsChildren[marker.properties.index]\n          ) : !isSpiderfier ? (\n            renderCluster ? (\n              renderCluster({\n                onPress: _onClusterPress(marker),\n                clusterColor,\n                clusterTextColor,\n                clusterFontFamily,\n                ...marker,\n              })\n            ) : (\n              <ClusterMarker\n                key={`cluster-${marker.id}`}\n                {...marker}\n                onPress={_onClusterPress(marker)}\n                clusterColor={\n                  restProps.selectedClusterId === marker.id\n                    ? restProps.selectedClusterColor\n                    : clusterColor\n                }\n                clusterTextColor={clusterTextColor}\n                clusterFontFamily={clusterFontFamily}\n                tracksViewChanges={tracksViewChanges}\n              />\n            )\n          ) : null,\n        )}\n        {otherChildren}\n        {spiderMarkers.map((marker) => {\n          return propsChildren[marker.index]\n            ? React.cloneElement(propsChildren[marker.index], {\n                coordinate: { ...marker },\n              })\n            : null\n        })}\n        {spiderMarkers.map((marker, index) => (\n          <Polyline\n            key={index}\n            coordinates={[marker.centerPoint, marker, marker.centerPoint]}\n            strokeColor={spiderLineColor}\n            strokeWidth={1}\n          />\n        ))}\n      </MapView>\n    )\n  },\n)\n\nClusteredMapView.defaultProps = {\n  clusteringEnabled: true,\n  spiralEnabled: true,\n  animationEnabled: true,\n  preserveClusterPressBehavior: false,\n  layoutAnimationConf: LayoutAnimation.Presets.spring,\n  tracksViewChanges: false,\n  // SuperCluster parameters\n  radius: Dimensions.get('window').width * 0.06,\n  maxZoom: 20,\n  minZoom: 1,\n  minPoints: 2,\n  extent: 512,\n  nodeSize: 64,\n  // Map parameters\n  edgePadding: { top: 50, left: 50, right: 50, bottom: 50 },\n  // Cluster styles\n  clusterColor: '#00B386',\n  clusterTextColor: '#FFFFFF',\n  spiderLineColor: '#FF0000',\n  // Callbacks\n  onRegionChangeComplete: () => {},\n  onClusterPress: () => {},\n  onMarkersChange: () => {},\n  superClusterRef: {},\n  mapRef: () => {},\n}\n\nexport default memo(ClusteredMapView)\n\n'map-clustering-rn-example/App.tsx'\n:import React, { useCallback, useEffect, useRef, useState } from 'react'\nimport { Dimensions, StyleSheet, View } from 'react-native'\nimport { Marker, Region } from 'react-native-maps'\n\nimport ClusteredMapView from './components/ClusteredMapView'\nimport MapZoomPanel from './components/MapZoomPanel'\n\nconst getRandomLatitude = (min = 48, max = 56) => {\n  return Math.random() * (max - min) + min\n}\n\nconst getRandomLongitude = (min = 14, max = 24) => {\n  return Math.random() * (max - min) + min\n}\n\nconst getRegionForZoom = (lat: number, lon: number, zoom: number) => {\n  const distanceDelta = Math.exp(Math.log(360) - zoom * Math.LN2)\n  const { width, height } = Dimensions.get('window')\n  const aspectRatio = width / height\n  return {\n    latitude: lat,\n    longitude: lon,\n    latitudeDelta: distanceDelta * aspectRatio,\n    longitudeDelta: distanceDelta,\n  }\n}\n\nconst getZoomFromRegion = (region: Region) => {\n  return Math.round(Math.log(360 / region.longitudeDelta) / Math.LN2)\n}\n\ninterface Markers {\n  id: number\n  latitude: number\n  longitude: number\n}\n\nfunction App(): JSX.Element {\n  const map = useRef(null)\n\n  const [zoom, setZoom] = useState<number>(18)\n  const [markers, setMarkers] = useState<Markers[]>([\n    { id: 0, latitude: 53.91326738786109, longitude: 27.523712915343737 },\n  ])\n  const [region, setRegion] = useState<Region>({\n    latitude: 53.91326738786109,\n    longitude: 27.523712915343737,\n    latitudeDelta: 1.5,\n    longitudeDelta: 1.5,\n  })\n\n  const generateMarkers = useCallback((lat: number, long: number) => {\n    const markersArray = []\n\n    for (let i = 0; i < 50; i++) {\n      markersArray.push({\n        id: i,\n        latitude: getRandomLatitude(lat - 0.05, lat + 0.05),\n        longitude: getRandomLongitude(long - 0.05, long + 0.05),\n      })\n    }\n    setMarkers(markersArray)\n  }, [])\n\n  const mapZoomIn = () => {\n    if (zoom > 18) {\n      setZoom(18)\n    } else {\n      setZoom(zoom + 1)\n      const regn = getRegionForZoom(region.latitude, region.longitude, zoom + 1)\n      map.current.animateToRegion(regn, 200)\n    }\n  }\n\n  const mapZoomOut = () => {\n    if (zoom < 3) {\n      setZoom(3)\n    } else {\n      setZoom(zoom - 1)\n      const regn = getRegionForZoom(region.latitude, region.longitude, zoom - 1)\n      map.current.animateToRegion(regn, 200)\n    }\n  }\n\n  const onRegionChangeComplete = (newRegion: Region) => {\n    setZoom(getZoomFromRegion(newRegion))\n    setRegion(newRegion)\n  }\n\n  useEffect(() => {\n    generateMarkers(region.latitude, region.longitude)\n  }, [])\n\n  return (\n    <View style={styles.container}>\n      <ClusteredMapView\n        clusterColor=\"red\"\n        ref={map}\n        mapType=\"hybrid\"\n        style={styles.mapView}\n        initialRegion={region}\n        onRegionChangeComplete={onRegionChangeComplete}>\n        {markers.map((item) => (\n          <Marker\n            key={item.id}\n            coordinate={{\n              latitude: item.latitude,\n              longitude: item.longitude,\n            }}\n          />\n        ))}\n      </ClusteredMapView>\n      <MapZoomPanel\n        onZoomIn={() => {\n          mapZoomIn()\n        }}\n        onZoomOut={() => {\n          mapZoomOut()\n        }}\n      />\n    </View>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    backgroundColor: '#fff',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  mapView: { flex: 1, width: '100%', height: '100%' },\n  customMarker: {\n    backgroundColor: '#ffffff',\n    borderRadius: 8,\n    width: 50,\n    height: 50,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n})\n\nexport default App\n\n",
        "called_code_segment_file_1": "const returnMarkerStyle = (points) => {\n  let size, width, height, fontSize\n  if (points >= 50) {\n    size = 100\n    width = 30\n    height = 30\n    fontSize = 16\n  } else if (points >= 20) {\n    size = 70\n    width = 25\n    height = 25\n    fontSize = 14\n  } else if (points >= 10) {\n    size = 50\n    width = 20\n    height = 20\n    fontSize = 12\n  } else if (points >= 5) {\n    size = 40\n    width = 15\n    height = 15\n    fontSize = 11\n  } else {\n    size = 30\n    width = 10\n    height = 10\n    fontSize = 10\n  }\n  return { width, height, fontSize, size }\n}",
        "invoking_code_segment_file_2": "const { width, height, fontSize, size } = returnMarkerStyle(points)",
        "called_code_segment_file_2": "const _onRegionChangeComplete = (region) => {\n  if (superCluster && region) {\n    const bBox = calculateBBox(region)\n    const zoom = returnMapZoom(region, bBox, minZoom)\n    const markers = superCluster.getClusters(bBox, zoom)\n    if (animationEnabled && Platform.OS === 'ios') {\n      LayoutAnimation.configureNext(layoutAnimationConf)\n    }\n    if (zoom >= 18 && markers.length > 0 && clusterChildren) {\n      if (spiralEnabled) {\n        updateSpiderfier(true)\n      }\n    } else {\n      if (spiralEnabled) {\n        updateSpiderfier(false)\n      }\n    }\n    updateMarkers(markers)\n    onMarkersChange(markers)\n    onRegionChangeComplete(region, markers)\n    updateRegion(region)\n  } else {\n    onRegionChangeComplete(region)\n  }\n}",
        "using_code_segment_file_3": "const onRegionChangeComplete = (newRegion: Region) => {\n  setZoom(getZoomFromRegion(newRegion))\n  setRegion(newRegion)\n}",
        "feature_description": "Add a feature to change the cluster color based on the number of points.",
        "detailed_feature_description": "Modify the `returnMarkerStyle` function in `#file 1` to include a new property `color` that changes based on the number of points. Update `#file 2` to handle this new property and pass it to the `ClusterMarker` component. Ensure `#file 3` updates the cluster color dynamically based on the region change.",
        "modified_complete_code": {
            "#file 1": "const returnMarkerStyle = (points) => {\n  let size, width, height, fontSize, color\n  if (points >= 50) {\n    size = 100\n    width = 30\n    height = 30\n    fontSize = 16\n    color = 'red'\n  } else if (points >= 20) {\n    size = 70\n    width = 25\n    height = 25\n    fontSize = 14\n    color = 'blue'\n  } else if (points >= 10) {\n    size = 50\n    width = 20\n    height = 20\n    fontSize = 12\n    color = 'green'\n  } else if (points >= 5) {\n    size = 40\n    width = 15\n    height = 15\n    fontSize = 11\n    color = 'yellow'\n  } else {\n    size = 30\n    width = 10\n    height = 10\n    fontSize = 10\n    color = 'purple'\n  }\n  return { width, height, fontSize, size, color }\n}",
            "#file 2": "const { width, height, fontSize, size, color } = returnMarkerStyle(points)\n\n<ClusterMarker\n  key={`cluster-${marker.id}`}\n  {...marker}\n  onPress={_onClusterPress(marker)}\n  clusterColor={color}\n  clusterTextColor={clusterTextColor}\n  clusterFontFamily={clusterFontFamily}\n  tracksViewChanges={tracksViewChanges}\n/>",
            "#file 3": "const onRegionChangeComplete = (newRegion: Region) => {\n  setZoom(getZoomFromRegion(newRegion))\n  setRegion(newRegion)\n}"
        }
    },
    {
        "repo": "maratona-explorer-ticket",
        "content": "'maratona-explorer-ticket/src/lib/chromeOptions.ts'\n:import chrome from 'chrome-aws-lambda'\n \nconst chromeExecPaths = {\n  win32: 'C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe',\n  linux: '/usr/bin/google-chrome',\n  darwin: '/Applications/Google Chrome.app/Contents/MacOS/Google Chrome'\n}\n\nconst exePath = chromeExecPaths[process.platform]\n\ninterface Options {\n  args: string[]\n  executablePath: string\n  headless: boolean\n}\n\nexport async function getOptions(isDev: boolean): Promise<Options> {\n  let options: Options\n\n  if (isDev) {\n    options = {\n      args: [],\n      executablePath: exePath,\n      headless: true\n    }\n  } else {\n    options = {\n      args: chrome.args,\n      executablePath: await chrome.executablePath,\n      headless: chrome.headless\n    }\n  }\n\n  return options\n}\n'maratona-explorer-ticket/src/lib/chromium.ts'\n:import puppeteer, { Page } from 'puppeteer-core'\nimport { getOptions } from './chromeOptions'\n\nlet _page: Page | null\n\nasync function getPage(isDev: boolean): Promise<Page> {\n  if (_page) {\n    return _page\n  }\n\n  const options = await getOptions(isDev)\n\n  console.log(options)\n  const browser = await puppeteer.launch(options)\n\n  _page = await browser.newPage()\n\n  return _page\n}\n\nexport async function getScreenshot(\n  url: string,\n  isDev: boolean\n): Promise<Buffer> {\n  const page = await getPage(isDev)\n\n  await page.setViewport({ width: 1200, height: 630 })\n  await page.goto(url)\n  await page.evaluateHandle('document.fonts.ready');\n\n  const file = await page.screenshot({ type: 'png' })\n\n  return file as Buffer\n}\n'maratona-explorer-ticket/src/pages/api/ticket.ts'\n:import { NextApiRequest, NextApiResponse } from 'next'\nimport { getScreenshot } from '../../lib/chromium'\n\nconst isDev = !process.env.AWS_REGION\nconst isHtmlDebug = process.env.OG_HTML_DEBUG === '1'\n\nexport default async (\n  req: NextApiRequest,\n  res: NextApiResponse\n): Promise<any> => {\n  try {\n    const query = req.query\n\n    const userId = String(query.userId)\n\n    if (!userId) {\n      throw new Error('User is required');\n    }\n\n    const url = `${process.env.NEXT_PUBLIC_APP_URL}/ticket/${userId}/image`;\n\n    if (isHtmlDebug) {\n      return res.redirect(url)\n    }\n\n    const file = await getScreenshot(url, isDev)\n\n    res.statusCode = 200\n\n    res.setHeader('Content-Type', `image/png`)\n    res.setHeader(\n      'Cache-Control',\n      'public, immutable, no-transform, s-maxage=31536000, max-age=31536000'\n    )\n\n    res.end(file)\n  } catch (e) {\n    res.statusCode = 500\n    res.setHeader('Content-Type', 'text/html')\n    res.end('<h1>Internal Error</h1><p>Sorry, there was a problem</p>')\n    console.error(e)\n  }\n}\n",
        "called_code_segment_file_1": "async function getOptions(isDev: boolean): Promise<Options> {\n  let options: Options\n\n  if (isDev) {\n    options = {\n      args: [],\n      executablePath: exePath,\n      headless: true\n    }\n  } else {\n    options = {\n      args: chrome.args,\n      executablePath: await chrome.executablePath,\n      headless: chrome.headless\n    }\n  }\n\n  return options\n}",
        "invoking_code_segment_file_2": "async function getPage(isDev: boolean): Promise<Page> {\n  if (_page) {\n    return _page\n  }\n\n  const options = await getOptions(isDev)\n\n  console.log(options)\n  const browser = await puppeteer.launch(options)\n\n  _page = await browser.newPage()\n\n  return _page\n}",
        "called_code_segment_file_2": "async function getScreenshot(\n  url: string,\n  isDev: boolean\n): Promise<Buffer> {\n  const page = await getPage(isDev)\n\n  await page.setViewport({ width: 1200, height: 630 })\n  await page.goto(url)\n  await page.evaluateHandle('document.fonts.ready');\n\n  const file = await page.screenshot({ type: 'png' })\n\n  return file as Buffer\n}",
        "using_code_segment_file_3": "export default async (\n  req: NextApiRequest,\n  res: NextApiResponse\n): Promise<any> => {\n  try {\n    const query = req.query\n\n    const userId = String(query.userId)\n\n    if (!userId) {\n      throw new Error('User is required');\n    }\n\n    const url = `${process.env.NEXT_PUBLIC_APP_URL}/ticket/${userId}/image`;\n\n    if (isHtmlDebug) {\n      return res.redirect(url)\n    }\n\n    const file = await getScreenshot(url, isDev)\n\n    res.statusCode = 200\n\n    res.setHeader('Content-Type', `image/png`)\n    res.setHeader(\n      'Cache-Control',\n      'public, immutable, no-transform, s-maxage=31536000, max-age=31536000'\n    )\n\n    res.end(file)\n  } catch (e) {\n    res.statusCode = 500\n    res.setHeader('Content-Type', 'text/html')\n    res.end('<h1>Internal Error</h1><p>Sorry, there was a problem</p>')\n    console.error(e)\n  }\n}",
        "feature_description": "Add a feature to allow specifying a custom viewport size when generating screenshots.",
        "detailed_feature_description": "Modify the `getOptions` function in `#file 1` to accept an optional `viewport` parameter. Update the `getPage` function in `#file 2` to pass this parameter when invoking `getOptions`. Modify the `getScreenshot` function in `#file 2` to accept a `viewport` parameter and pass it to `getPage`. Update the `getScreenshot` call in `#file 3` to specify a custom viewport size.",
        "modified_complete_code": {
            "#file 1": "async function getOptions(isDev: boolean, viewport?: { width: number, height: number }): Promise<Options> {\n  let options: Options\n\n  if (isDev) {\n    options = {\n      args: [],\n      executablePath: exePath,\n      headless: true\n    }\n  } else {\n    options = {\n      args: chrome.args,\n      executablePath: await chrome.executablePath,\n      headless: chrome.headless\n    }\n  }\n\n  if (viewport) {\n    options.defaultViewport = viewport\n  }\n\n  return options\n}",
            "#file 2": "async function getPage(isDev: boolean, viewport?: { width: number, height: number }): Promise<Page> {\n  if (_page) {\n    return _page\n  }\n\n  const options = await getOptions(isDev, viewport)\n\n  console.log(options)\n  const browser = await puppeteer.launch(options)\n\n  _page = await browser.newPage()\n\n  return _page\n}\n\n#Modify\nasync function getScreenshot(\n  url: string,\n  isDev: boolean,\n  viewport?: { width: number, height: number }\n): Promise<Buffer> {\n  const page = await getPage(isDev, viewport)\n\n  await page.setViewport(viewport || { width: 1200, height: 630 })\n  await page.goto(url)\n  await page.evaluateHandle('document.fonts.ready');\n\n  const file = await page.screenshot({ type: 'png' })\n\n  return file as Buffer\n}",
            "#file 3": "export default async (\n  req: NextApiRequest,\n  res: NextApiResponse\n): Promise<any> => {\n  try {\n    const query = req.query\n\n    const userId = String(query.userId)\n\n    if (!userId) {\n      throw new Error('User is required');\n    }\n\n    const url = `${process.env.NEXT_PUBLIC_APP_URL}/ticket/${userId}/image`;\n\n    if (isHtmlDebug) {\n      return res.redirect(url)\n    }\n\n    #Modify\n    const file = await getScreenshot(url, isDev, { width: 1200, height: 800 })\n\n    res.statusCode = 200\n\n    res.setHeader('Content-Type', `image/png`)\n    res.setHeader(\n      'Cache-Control',\n      'public, immutable, no-transform, s-maxage=31536000, max-age=31536000'\n    )\n\n    res.end(file)\n  } catch (e) {\n    res.statusCode = 500\n    res.setHeader('Content-Type', 'text/html')\n    res.end('<h1>Internal Error</h1><p>Sorry, there was a problem</p>')\n    console.error(e)\n  }\n}"
        }
    },
    {
        "repo": "mean-rsvp-auth0",
        "content": "'mean-rsvp-auth0/src/app/pages/admin/admin.component.ts'\n:import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { Title } from '@angular/platform-browser';\nimport { AuthService } from './../../auth/auth.service';\nimport { ApiService } from './../../core/api.service';\nimport { UtilsService } from './../../core/utils.service';\nimport { FilterSortService } from './../../core/filter-sort.service';\nimport { Subscription } from 'rxjs';\nimport { EventModel } from './../../core/models/event.model';\n\n@Component({\n  selector: 'app-admin',\n  templateUrl: './admin.component.html',\n  styleUrls: ['./admin.component.scss']\n})\nexport class AdminComponent implements OnInit, OnDestroy {\n  pageTitle = 'Admin';\n  loggedInSub: Subscription;\n  eventsSub: Subscription;\n  eventList: EventModel[];\n  filteredEvents: EventModel[];\n  loading: boolean;\n  error: boolean;\n  query = '';\n\n  constructor(\n    private title: Title,\n    public auth: AuthService,\n    private api: ApiService,\n    public utils: UtilsService,\n    public fs: FilterSortService\n  ) { }\n\n  ngOnInit() {\n    this.title.setTitle(this.pageTitle);\n    this._getEventList();\n  }\n\n  private _getEventList() {\n    // Get all (admin) events\n    this.eventsSub = this.api\n      .getAdminEvents$()\n      .subscribe(\n        res => {\n          this.eventList = res;\n          this.filteredEvents = res;\n          this.loading = false;\n        },\n        err => {\n          console.error(err);\n          this.loading = false;\n          this.error = true;\n        }\n      );\n  }\n\n  searchEvents() {\n    this.filteredEvents = this.fs.search(this.eventList, this.query, '_id', 'mediumDate');\n  }\n\n  resetQuery() {\n    this.query = '';\n    this.filteredEvents = this.eventList;\n  }\n\n  ngOnDestroy() {\n    this.eventsSub.unsubscribe();\n  }\n\n}\n\n'mean-rsvp-auth0/src/app/pages/admin/admin.routes.ts'\n:import { Routes } from '@angular/router';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\n\nexport const ADMIN_ROUTES: Routes = [\n  {\n    path: '',\n    component: AdminComponent,\n  },\n  {\n    path: 'event/new',\n    component: CreateEventComponent\n  },\n  {\n    path: 'event/update/:id',\n    component: UpdateEventComponent\n  }\n];\n\n'mean-rsvp-auth0/src/app/pages/admin/admin.module.ts'\n:import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { CoreModule } from './../../core/core.module';\nimport { RouterModule } from '@angular/router';\nimport { ADMIN_ROUTES } from './admin.routes';\nimport { AdminComponent } from './admin.component';\nimport { CreateEventComponent } from './create-event/create-event.component';\nimport { UpdateEventComponent } from './update-event/update-event.component';\nimport { EventFormComponent } from './event-form/event-form.component';\nimport { DeleteEventComponent } from './update-event/delete-event/delete-event.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    CoreModule,\n    RouterModule.forChild(ADMIN_ROUTES)\n  ],\n  declarations: [\n    AdminComponent,\n    CreateEventComponent,\n    UpdateEventComponent,\n    EventFormComponent,\n    DeleteEventComponent\n  ]\n})\nexport class AdminModule { }\n\n",
        "called_code_segment_file_1": "private _getEventList() {\n    // Get all (admin) events\n    this.eventsSub = this.api\n      .getAdminEvents$()\n      .subscribe(\n        res => {\n          this.eventList = res;\n          this.filteredEvents = res;\n          this.loading = false;\n        },\n        err => {\n          console.error(err);\n          this.loading = false;\n          this.error = true;\n        }\n      );\n  }",
        "invoking_code_segment_file_2": "ngOnInit() {\n    this.title.setTitle(this.pageTitle);\n    this._getEventList();\n  }",
        "called_code_segment_file_2": "searchEvents() {\n    this.filteredEvents = this.fs.search(this.eventList, this.query, '_id', 'mediumDate');\n  }",
        "using_code_segment_file_3": "resetQuery() {\n    this.query = '';\n    this.filteredEvents = this.eventList;\n  }",
        "feature_description": "Add a feature to sort events by date in ascending order.",
        "detailed_feature_description": "Modify the `_getEventList` method in `#file 1` to sort the events by date before assigning them to `eventList`. Update `#file 2` to handle the sorted events and ensure `#file 3` correctly interacts with the sorted list.",
        "modified_complete_code": {
            "#file 1": "private _getEventList() {\n    // Get all (admin) events\n    this.eventsSub = this.api\n      .getAdminEvents$()\n      .subscribe(\n        res => {\n          // Modify: Sort events by date\n          res.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());\n          this.eventList = res;\n          this.filteredEvents = res;\n          this.loading = false;\n        },\n        err => {\n          console.error(err);\n          this.loading = false;\n          this.error = true;\n        }\n      );\n  }",
            "#file 2": "ngOnInit() {\n    this.title.setTitle(this.pageTitle);\n    this._getEventList();\n  }\n\n  searchEvents() {\n    this.filteredEvents = this.fs.search(this.eventList, this.query, '_id', 'mediumDate');\n  }",
            "#file 3": "resetQuery() {\n    this.query = '';\n    this.filteredEvents = this.eventList;\n  }"
        }
    },
    {
        "repo": "nasa-ionic",
        "content": "'nasa-ionic/src/pages/contact/contact.ts'\n:import { Component } from '@angular/core';\nimport { NavController } from 'ionic-angular';\n\n@Component({\n  selector: 'page-contact',\n  templateUrl: 'contact.html'\n})\nexport class ContactPage {\n\n  constructor(public navCtrl: NavController) {\n\n  }\n\n}\n\n'nasa-ionic/src/app/app.module.ts'\n:import { NgModule, ErrorHandler } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { IonicApp, IonicModule, IonicErrorHandler } from 'ionic-angular';\nimport { MyApp } from './app.component';\n\nimport { AboutPage } from '../pages/about/about';\nimport { ContactPage } from '../pages/contact/contact';\nimport { HomePage } from '../pages/home/home';\nimport { TabsPage } from '../pages/tabs/tabs';\nimport { ApodComponent } from '../pages/nasa/apod.component';\nimport {MarsComponent} from '../pages/nasa/mars.component';\nimport { StatusBar } from '@ionic-native/status-bar';\nimport { SplashScreen } from '@ionic-native/splash-screen';\n\nimport {NasaService} from '../services/nasa';\nimport {HttpModule} from \"@angular/http\";\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    TabsPage,\n    ApodComponent,\n    MarsComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpModule,\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    TabsPage,\n    ApodComponent,\n    MarsComponent\n  ],\n  providers: [\n    StatusBar,\n    SplashScreen,\n    {provide: ErrorHandler, useClass: IonicErrorHandler},\n    NasaService\n  ]\n})\nexport class AppModule {}\n\n'nasa-ionic/src/app/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n",
        "called_code_segment_file_1": "export class NasaService {\n  constructor(private http: Http) {}\n}",
        "invoking_code_segment_file_2": "@NgModule({\n  providers: [\n    StatusBar,\n    SplashScreen,\n    {provide: ErrorHandler, useClass: IonicErrorHandler},\n    NasaService\n  ]\n})",
        "called_code_segment_file_2": "export class NasaService {\n  constructor(private http: Http) {}\n}",
        "using_code_segment_file_3": "constructor(public navCtrl: NavController) {}",
        "feature_description": "Add a method to fetch Mars rover photos in the NasaService.",
        "detailed_feature_description": "A new method `getMarsRoverPhotos` will be added to the `NasaService` to fetch Mars rover photos. This method will be invoked in the `MarsComponent` to display the photos. The `MarsComponent` will be updated to handle the new data structure returned by the service.",
        "modified_complete_code": {
            "#file 1": "//Modify\nexport class NasaService {\n  constructor(private http: Http) {}\n\n  //New\n  getMarsRoverPhotos() {\n    return this.http.get('https://api.nasa.gov/mars-photos/api/v1/rovers/curiosity/photos?sol=1000&api_key=DEMO_KEY');\n  }\n}",
            "#file 2": "//Modify\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    TabsPage,\n    ApodComponent,\n    MarsComponent\n  ],\n  imports: [\n    BrowserModule,\n    HttpModule,\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    TabsPage,\n    ApodComponent,\n    MarsComponent\n  ],\n  providers: [\n    StatusBar,\n    SplashScreen,\n    {provide: ErrorHandler, useClass: IonicErrorHandler},\n    NasaService\n  ]\n})",
            "#file 3": "//Modify\nexport class MarsComponent {\n  photos: any;\n\n  constructor(private nasaService: NasaService) {\n    this.nasaService.getMarsRoverPhotos().subscribe(data => {\n      this.photos = data.json().photos;\n    });\n  }\n}"
        }
    },
    {
        "repo": "ngrx-example",
        "content": "'ngrx-example/src/app/services/notifications-actions.service.ts'\n:import { Action } from '@ngrx/store';\n\nimport {\n  START_NOTIFICATIONS,\n  STOP_NOTIFICATIONS\n} from '../reducers/notifications.reducer';\n\nexport const start = () => {\n  return (data): Action => ({\n    type: START_NOTIFICATIONS\n  });\n};\n\nexport const stop = () => {\n  return (data): Action => ({\n    type: STOP_NOTIFICATIONS\n  });\n};\n\n'ngrx-example/src/app/containers/notifications.container/notifications.container.ts'\n:import {\n  Component,\n  Input,\n  OnInit,\n  OnDestroy\n} from 'angular2/core';\n\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { Store, Action } from '@ngrx/store';\n\n// action creators\nimport { start, stop } from '../../services/notifications-actions.service';\n\n// selectors\nimport { list$, isRunning$ } from '../../services/notifications-selectors.service';\n\n// components\nimport { NotificationsComponent } from '../../components/notifications.component/notifications.component';\n\n@Component({\n  selector: 'notifications-container',\n  host: {\n    'class': 'notifications-container'\n  },\n  directives: [ NotificationsComponent ],\n  template: require('./notifications.container.html'),\n  styles: [ require('./notifications.container.scss') ]\n})\nexport class NotificationsContainer {\n  public notifications$: Observable<Array<any>>\n    = this._store.let(list$());\n  public isRunning$: Observable<boolean>\n    = this._store.let(isRunning$());\n\n  // dom event streams\n  public onToggleStream$ = new Subject<any>();\n\n  // actions\n  public toggleStreamAction$ = this.onToggleStream$\n    .mergeMap(\n      isRunning => this._store.take(1).let(isRunning$()),\n      (event, isRunning) => {\n        if (isRunning) {\n          return stop();\n        } else {\n          return start();\n        }\n      }\n    )\n    .map((res: any) => res());\n\n  // subscription helpers\n  private _subscription: Subscription;\n\n  constructor(private _store: Store<any>) {}\n\n  ngOnInit() {\n    this._subscription = Observable\n      .merge(this.toggleStreamAction$)\n      .subscribe(this._store);\n  }\n\n  ngOnDestroy() {\n    this._subscription.unsubscribe();\n  }\n\n}\n\n'ngrx-example/src/app/app.component.ts'\n:import {\n  Component,\n  ViewEncapsulation,\n  ChangeDetectionStrategy,\n  OnInit,\n  OnDestroy\n} from 'angular2/core';\n\nimport { Observable } from 'rxjs/Observable';\nimport { Subject } from 'rxjs/Subject';\nimport { Subscription } from 'rxjs/Subscription';\nimport { Store } from '@ngrx/store';\nimport { SagaRunner } from 'store-saga';\n\n// interfaces\nimport { IAuth } from './_auth/interfaces/IAuth';\n\n// sagas\nimport { APP_SAGAS } from './sagas/sagas';\n\n// services\nimport { Ng2Permission } from './services/Ng2Permission';\n\n// action creators\nimport { checkAuth, logout } from './_auth/services/auth-actions.service';\n\n// selectors\nimport { isAuthenticated$, getAuth$ } from './_auth/services/auth-selectors.service';\n\n// components / containers\nimport { NotificationsContainer } from './containers/notifications.container/notifications.container';\n\n// TODO: temp\nimport { START_NOTIFICATIONS } from './reducers/notifications.reducer';\n\n@Component({\n  selector: 'app',\n  styles: [ require('./styles/app.scss') ],\n  template: require('./app.component.html'),\n  directives: [ NotificationsContainer ],\n  encapsulation: ViewEncapsulation.None,\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class AppComponent implements OnInit {\n  // data\n  public isAuthenticated$: Observable<boolean> = this._store.let(isAuthenticated$());\n  public userData$: Observable<IAuth> = this._store.let(getAuth$());\n\n  // dom event streams\n  public onLogout$ = new Subject<any>();\n  public onInit$ = new Subject<any>();\n\n  // actions\n  public logoutAction$ = this.onLogout$.map(logout());\n  public initAction$ = this.onInit$.map(checkAuth());\n\n  // subscription helpers\n  private _subscription: Subscription;\n\n  constructor(\n    public permission: Ng2Permission,\n    private _runner: SagaRunner,\n    private _store: Store<any>) {\n\n    permission.define('user', () => {\n      return _store.let(isAuthenticated$());\n    });\n\n    APP_SAGAS.forEach(saga$ => this._runner.run(saga$));\n\n    // TODO: don't use dispatch, dispatch multiple actions on init\n    _store.dispatch({\n      type: START_NOTIFICATIONS\n    });\n\n  }\n\n  ngOnInit() {\n    this._subscription = Observable\n      .merge(\n        this.logoutAction$,\n        this.initAction$\n      )\n      .subscribe(this._store);\n\n    this.onInit$.next(null);\n  }\n\n}\n\n",
        "called_code_segment_file_1": "public toggleStreamAction$ = this.onToggleStream$\n    .mergeMap(\n      isRunning => this._store.take(1).let(isRunning$()),\n      (event, isRunning) => {\n        if (isRunning) {\n          return stop();\n        } else {\n          return start();\n        }\n      }\n    )\n    .map((res: any) => res());",
        "invoking_code_segment_file_2": "ngOnInit() {\n    this._subscription = Observable\n      .merge(this.toggleStreamAction$)\n      .subscribe(this._store);\n  }",
        "called_code_segment_file_2": "public toggleStreamAction$ = this.onToggleStream$\n    .mergeMap(\n      isRunning => this._store.take(1).let(isRunning$()),\n      (event, isRunning) => {\n        if (isRunning) {\n          return stop();\n        } else {\n          return start();\n        }\n      }\n    )\n    .map((res: any) => res());",
        "using_code_segment_file_3": "permission.define('user', () => {\n      return _store.let(isAuthenticated$());\n    });",
        "feature_description": "Add a confirmation dialog before stopping notifications.",
        "detailed_feature_description": "Modify the toggleStreamAction$ in NotificationsContainer to show a confirmation dialog before stopping notifications. Update the ngOnInit method to handle the new dialog logic. Ensure the AppComponent's permission definition remains unaffected by these changes.",
        "modified_complete_code": {
            "#file 1": "public toggleStreamAction$ = this.onToggleStream$\n    .mergeMap(\n      isRunning => this._store.take(1).let(isRunning$()),\n      (event, isRunning) => {\n        if (isRunning) {\n          return Observable.of(confirm('Are you sure you want to stop notifications?'))\n            .filter(confirmed => confirmed)\n            .map(() => stop());\n        } else {\n          return start();\n        }\n      }\n    )\n    .map((res: any) => res()); #Modify",
            "#file 2": "ngOnInit() {\n    this._subscription = Observable\n      .merge(this.toggleStreamAction$)\n      .subscribe(this._store);\n  }",
            "#file 3": "permission.define('user', () => {\n      return _store.let(isAuthenticated$());\n    });"
        }
    },
    {
        "repo": "noft",
        "content": "'noft/src/common/util.ts'\n:import { Settings } from './settings.types';\n\nlet adding = false;\nexport async function addItemToList<\n\tK extends 'whitelistedUsers' | 'actionQueue'\n>(\n\tkey: K,\n\titem: Settings[K][number],\n\tposition: 'prepend' | 'append' = 'append'\n) {\n\tawait new Promise<void>((resolve) => {\n\t\tconst interval = setInterval(() => {\n\t\t\tif (!adding) {\n\t\t\t\tadding = true;\n\t\t\t\tclearInterval(interval);\n\t\t\t\tresolve();\n\t\t\t}\n\t\t}, 100);\n\t});\n\n\treturn new Promise<void>((resolve) => {\n\t\tchrome.storage.sync.get(key, (settings) => {\n\t\t\tconst list = (settings[key] as typeof item[]) ?? [];\n\t\t\tif (position === 'append') list.push(item);\n\t\t\telse list.unshift(item);\n\t\t\tchrome.storage.sync.set(\n\t\t\t\t{\n\t\t\t\t\t[key]: list,\n\t\t\t\t},\n\t\t\t\t() => {\n\t\t\t\t\tresolve();\n\t\t\t\t\tadding = false;\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t});\n}\n\n'noft/src/pages/popup/App.tsx'\n:import React, { useEffect, useMemo, useState } from 'react';\nimport { Settings, settingsDefaults } from '../../common/settings.types';\nimport { addItemToList } from '../../common/util';\n\nconst App = ({\n\tinitialSettings,\n}: {\n\tinitialSettings: Settings;\n}): JSX.Element => {\n\tconst [settings, setSettings] = useState(initialSettings);\n\n\tuseEffect(() => {\n\t\tchrome.storage.onChanged.addListener(async (_, area) => {\n\t\t\tif (area !== 'sync') return;\n\t\t\tchrome.storage.sync.get((settings) =>\n\t\t\t\tsetSettings({ ...settingsDefaults, ...settings } as Settings)\n\t\t\t);\n\t\t});\n\t}, []);\n\n\tconst setSetting = <T extends keyof Settings>(\n\t\tsetting: T,\n\t\tvalue: Settings[T]\n\t) => {\n\t\tchrome.storage.sync.set({ [setting]: value });\n\t};\n\n\tconst removeWhitelist = (id: string) => {\n\t\tchrome.storage.sync.set({\n\t\t\twhitelistedUsers: settings.whitelistedUsers.filter((u) => u.id !== id),\n\t\t});\n\t};\n\n\tconst action =\n\t\tsettings.action[0].toUpperCase() + settings.action.substring(1);\n\n\tconst [totalBlocked, totalPending] = useMemo(() => {\n\t\tlet totalBlocked = 0;\n\t\tlet totalPending = 0;\n\t\tfor (const item of settings.actionQueue) {\n\t\t\tif (item.doneAt) totalBlocked++;\n\t\t\telse totalPending++;\n\t\t}\n\t\treturn [totalBlocked, totalPending];\n\t}, [settings.actionQueue]);\n\n\tconst handleFollow = () => {\n\t\tsetSetting('followedOtto', true);\n\t\taddItemToList(\n\t\t\t'actionQueue',\n\t\t\t{\n\t\t\t\tid: '903244989206892544',\n\t\t\t\taction: 'follow',\n\t\t\t},\n\t\t\t'prepend'\n\t\t);\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<div className=\"totals\">\n\t\t\t\t{totalBlocked} total blocked\n\t\t\t\t{totalPending > 0 ? `, ${totalPending} pending` : ''}\n\t\t\t</div>\n\t\t\t<div className=\"row\">\n\t\t\t\t<img src=\"/assets/icon128.png\" width={48} height={48} />\n\t\t\t\t<h1>NoFT Options</h1>\n\t\t\t</div>\n\t\t\t{!settings.followedOtto && (\n\t\t\t\t<button className=\"follow-btn\" onClick={handleFollow}>\n\t\t\t\t\tFollow @Ottomated_\n\t\t\t\t</button>\n\t\t\t)}\n\t\t\t<div className=\"row\">\n\t\t\t\t<select\n\t\t\t\t\tid=\"action\"\n\t\t\t\t\tclassName=\"dropdown\"\n\t\t\t\t\tvalue={settings.action}\n\t\t\t\t\tonChange={(ev) =>\n\t\t\t\t\t\tsetSetting(\n\t\t\t\t\t\t\t'action',\n\t\t\t\t\t\t\tev.target.value as 'block' | 'mute' | 'replace'\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t\t<option value=\"block\">Block</option>\n\t\t\t\t\t<option value=\"mute\">Mute</option>\n\t\t\t\t\t<option value=\"replace\">Replace PFP</option>\n\t\t\t\t</select>\n\t\t\t\t<label htmlFor=\"action\">\n\t\t\t\t\t{settings.action === 'replace' ? 'on ' : ''}detected accounts\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t\t<p className=\"help-text\">\n\t\t\t\tNoFT doesn't block accounts immediately - it schedules them to be\n\t\t\t\tblocked in the background to avoid Twitter's bot detection.\n\t\t\t</p>\n\t\t\t<div className=\"row\">\n\t\t\t\t<input\n\t\t\t\t\tid=\"followed-by\"\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tchecked={settings.actionOnFollowedByAccounts}\n\t\t\t\t\tonChange={(ev) =>\n\t\t\t\t\t\tsetSetting('actionOnFollowedByAccounts', ev.target.checked)\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t\t<label htmlFor=\"followed-by\">{action} accounts that follow you</label>\n\t\t\t</div>\n\t\t\t<div className=\"row\">\n\t\t\t\t<input\n\t\t\t\t\tid=\"following\"\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tchecked={settings.actionOnFollowingAccounts}\n\t\t\t\t\tonChange={(ev) =>\n\t\t\t\t\t\tsetSetting('actionOnFollowingAccounts', ev.target.checked)\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t\t<label htmlFor=\"following\">{action} accounts that you follow</label>\n\t\t\t</div>\n\t\t\t<div className=\"row\">\n\t\t\t\t<input\n\t\t\t\t\tid=\"verified\"\n\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\tchecked={settings.actionOnVerifiedAccounts}\n\t\t\t\t\tonChange={(ev) =>\n\t\t\t\t\t\tsetSetting('actionOnVerifiedAccounts', ev.target.checked)\n\t\t\t\t\t}\n\t\t\t\t/>\n\t\t\t\t<label htmlFor=\"following\">{action} verified accounts</label>\n\t\t\t</div>\n\t\t\t{settings.whitelistedUsers.length > 0 && (\n\t\t\t\t<>\n\t\t\t\t\t<h3>Whitelisted Users</h3>\n\t\t\t\t\t<p className=\"help-text\">\n\t\t\t\t\t\tUsers are whitelisted when you press \"UNDO\" in the NoFT popup.\n\t\t\t\t\t</p>\n\t\t\t\t\t<div className=\"whitelist\">\n\t\t\t\t\t\t{settings.whitelistedUsers.map((user) => (\n\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\tclassName=\"whitelist-entry\"\n\t\t\t\t\t\t\t\tkey={user.id}\n\t\t\t\t\t\t\t\tdata-userid={user.id}\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t<span>@{user.name}</span>\n\t\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\t\thref=\"#\"\n\t\t\t\t\t\t\t\t\tonClick={() => removeWhitelist(user.id)}\n\t\t\t\t\t\t\t\t\tclassName=\"unwhitelist\"\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tun-whitelist\n\t\t\t\t\t\t\t\t</a>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t))}\n\t\t\t\t\t</div>\n\t\t\t\t</>\n\t\t\t)}\n\t\t</div>\n\t);\n};\n\nexport default App;\n\n'noft/src/pages/popup/index.tsx'\n:import React from 'react';\nimport { render } from 'react-dom';\nimport { Settings, settingsDefaults } from '../../common/settings.types';\nimport App from './App';\n\nchrome.storage.sync.get((settings) => {\n\tconst root = document.querySelector('#root');\n\n\trender(\n\t\t<App initialSettings={{ ...settingsDefaults, ...settings } as Settings} />,\n\t\troot\n\t);\n});\n\n",
        "called_code_segment_file_1": "export async function addItemToList<K extends 'whitelistedUsers' | 'actionQueue'>(key: K, item: Settings[K][number], position: 'prepend' | 'append' = 'append') {\n    await new Promise<void>((resolve) => {\n        const interval = setInterval(() => {\n            if (!adding) {\n                adding = true;\n                clearInterval(interval);\n                resolve();\n            }\n        }, 100);\n    });\n\n    return new Promise<void>((resolve) => {\n        chrome.storage.sync.get(key, (settings) => {\n            const list = (settings[key] as typeof item[]) ?? [];\n            if (position === 'append') list.push(item);\n            else list.unshift(item);\n            chrome.storage.sync.set(\n                {\n                    [key]: list,\n                },\n                () => {\n                    resolve();\n                    adding = false;\n                }\n            );\n        });\n    });\n}",
        "invoking_code_segment_file_2": "const handleFollow = () => {\n    setSetting('followedOtto', true);\n    addItemToList(\n        'actionQueue',\n        {\n            id: '903244989206892544',\n            action: 'follow',\n        },\n        'prepend'\n    );\n};",
        "called_code_segment_file_2": "const setSetting = <T extends keyof Settings>(setting: T, value: Settings[T]) => {\n    chrome.storage.sync.set({ [setting]: value });\n};",
        "using_code_segment_file_3": "chrome.storage.sync.get((settings) => {\n    const root = document.querySelector('#root');\n\n    render(\n        <App initialSettings={{ ...settingsDefaults, ...settings } as Settings} />,\n        root\n    );\n});",
        "feature_description": "Add a feature to allow users to undo actions on specific accounts by moving them from the action queue to a new 'undoQueue'.",
        "detailed_feature_description": "Modify the `addItemToList` function in `#file 1` to handle a new 'undoQueue'. Update the `handleFollow` function in `#file 2` to use this new functionality. Ensure that `#file 3` remains compatible with these changes.",
        "modified_complete_code": {
            "#file 1": "let adding = false;\n#Modify export async function addItemToList<K extends 'whitelistedUsers' | 'actionQueue' | 'undoQueue'>(key: K, item: Settings[K][number], position: 'prepend' | 'append' = 'append') {\n    await new Promise<void>((resolve) => {\n        const interval = setInterval(() => {\n            if (!adding) {\n                adding = true;\n                clearInterval(interval);\n                resolve();\n            }\n        }, 100);\n    });\n\n    return new Promise<void>((resolve) => {\n        chrome.storage.sync.get(key, (settings) => {\n            const list = (settings[key] as typeof item[]) ?? [];\n            if (position === 'append') list.push(item);\n            else list.unshift(item);\n            chrome.storage.sync.set(\n                {\n                    [key]: list,\n                },\n                () => {\n                    resolve();\n                    adding = false;\n                }\n            );\n        });\n    });\n}",
            "#file 2": "const handleFollow = () => {\n    setSetting('followedOtto', true);\n    addItemToList(\n        'actionQueue',\n        {\n            id: '903244989206892544',\n            action: 'follow',\n        },\n        'prepend'\n    );\n};\n\n#New const handleUndo = (id: string) => {\n    chrome.storage.sync.get('actionQueue', (settings) => {\n        const actionQueue = settings.actionQueue as { id: string; action: string }[];\n        const item = actionQueue.find(item => item.id === id);\n        if (item) {\n            addItemToList('undoQueue', item, 'prepend');\n            chrome.storage.sync.set({\n                actionQueue: actionQueue.filter(item => item.id !== id)\n            });\n        }\n    });\n};",
            "#file 3": "chrome.storage.sync.get((settings) => {\n    const root = document.querySelector('#root');\n\n    render(\n        <App initialSettings={{ ...settingsDefaults, ...settings } as Settings} />,\n        root\n    );\n});"
        }
    },
    {
        "repo": "Approvals.NodeJS",
        "content": "'Approvals.NodeJS/lib/AUtils.ts'\n:import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as shell from \"shelljs\";\nimport * as osTools from \"./osTools\";\n\ninterface CachedProgramLookups {\n  [programName: string]: string | null;\n}\n\nconst _cachedProgramLookups: CachedProgramLookups = {};\n\nconst createEmptyFileIfNotExists = (file: string): void => {\n  if (!fs.existsSync(file)) {\n    const ext = (path.extname(file) || \"\").toLowerCase();\n    if (ext === \".png\") {\n      fs.writeFileSync(\n        file,\n        fs.readFileSync(\n          path.join(__dirname, \"DummyApprovedFiles\", \"UnapprovedImage.png\"),\n        ),\n      );\n    } else {\n      fs.writeFileSync(file, \"\");\n    }\n  }\n};\n\nconst assertFileExists = (file: string): void => {\n  if (!fs.existsSync(file)) {\n    throw new Error(\"File not found: \" + file);\n  }\n};\n\nconst hasCommandLineArgument = (arg: string): boolean => {\n  return process.argv.some((val) => (val || \"\").toLowerCase() === arg);\n};\n\nconst isBinaryFile = (buffer: Buffer | String): boolean => {\n  const contentStartUTF8 = buffer.toString(\"utf8\", 0, 24);\n  for (let i = 0, _ref = contentStartUTF8.length; i < _ref; i++) {\n    const charCode = contentStartUTF8.charCodeAt(i);\n    if (charCode === 65533 || charCode <= 8) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst trimExtension = (filePath: string): string => {\n  if (!filePath) return filePath;\n  const i = filePath.lastIndexOf(\".\");\n  const ext = i < 0 ? \"\" : filePath.substr(i);\n  return ext ? filePath.substring(0, filePath.length - ext.length) : filePath;\n};\n\nconst findProgramOnPath = (programName: string): string | null => {\n  if (_cachedProgramLookups.hasOwnProperty(programName)) {\n    return _cachedProgramLookups[programName];\n  }\n  const output = shell.exec(\n    `${osTools.findProgramPathCommand} ${programName}`,\n    { silent: true },\n  );\n  let result: string | null = null;\n  if (output.stdout) {\n    const file = output.stdout.split(\"\\n\")[0].trim();\n    const fixedFile = fixFilePathSlashes(file);\n    if (fs.existsSync(fixedFile)) {\n      result = fixedFile;\n    }\n  }\n  if (!result) {\n    const pathMinusExtension = trimExtension(programName);\n    if (pathMinusExtension !== programName) {\n      result = findProgramOnPath(pathMinusExtension);\n    }\n  }\n  _cachedProgramLookups[programName] = result;\n  return result;\n};\n\nconst searchForExecutable = (\n  folderInProgramInFiles?: string,\n  fileName?: string,\n): string => {\n  if (!fileName) {\n    fileName = folderInProgramInFiles;\n    folderInProgramInFiles = undefined;\n  }\n  const programOnPath = findProgramOnPath(fileName!);\n  if (programOnPath) {\n    return programOnPath;\n  }\n  const lookInProgramFiles = (fileName_: string): string | null => {\n    if (osTools.platform.isWindows) {\n      let tryVar = findInPath(\n        \"C:/Program Files\",\n        folderInProgramInFiles || \"\",\n        fileName_,\n      );\n      if (tryVar) {\n        return tryVar;\n      }\n      tryVar = findInPath(\n        \"C:/Program Files (x86)\",\n        folderInProgramInFiles || \"\",\n        fileName_,\n      );\n      if (tryVar) {\n        return tryVar;\n      }\n    }\n    return null;\n  };\n  const findInPath = (\n    root: string,\n    dir: string,\n    file: string,\n  ): string | null => {\n    const fullPath = path.join(root, dir, file);\n    const fixedFullPath = fixFilePathSlashes(fullPath);\n    if (fs.existsSync(fixedFullPath)) {\n      return fixedFullPath;\n    }\n    return null;\n  };\n  let fileFound = lookInProgramFiles(fileName!);\n  if (fileFound) {\n    return fileFound;\n  }\n  const suffix = \".exe\";\n  if (!fileName!.endsWith(suffix)) {\n    fileFound = lookInProgramFiles(fileName! + suffix);\n    if (fileFound) {\n      return fileFound;\n    }\n  }\n  return \"\";\n};\n\nconst fixFilePathSlashes = (path_: string): string => {\n  return path_.replace(/\\\\/g, \"/\");\n};\n\nconst recursivelyOrderKeys = (unordered: any): any => {\n  if (unordered === null) {\n    return null;\n  }\n  if (Array.isArray(unordered)) {\n    return unordered.map(recursivelyOrderKeys);\n  }\n  if (typeof unordered === \"object\" && unordered !== null) {\n    const ordered: { [key: string]: any } = {};\n    Object.keys(unordered)\n      .sort()\n      .forEach((key) => {\n        ordered[key] = recursivelyOrderKeys(unordered[key]);\n      });\n    return ordered;\n  }\n  return unordered;\n};\n\nconst stringifyKeysInOrder = (data: any): string => {\n  const sortedData = recursivelyOrderKeys(data);\n  return JSON.stringify(sortedData, null, \"  \");\n};\n\nexport {\n  createEmptyFileIfNotExists,\n  assertFileExists,\n  hasCommandLineArgument,\n  isBinaryFile,\n  findProgramOnPath,\n  searchForExecutable,\n  fixFilePathSlashes,\n  stringifyKeysInOrder,\n};\n\n'Approvals.NodeJS/lib/Approvals.ts'\n:/*jshint freeze:false */\n\n/**\n * Approvals module.\n * @module approvals\n */\n\nimport callsite from \"callsite\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport * as cfg from \"./config\";\nimport { BinaryWriter } from \"./Writers/BinaryWriter\";\nimport { FileApprover } from \"./FileApprover\";\nimport { FinalMessages } from \"./FinalMessages\";\nimport { ManualNamer } from \"./ManualNamer\";\nimport { Namer } from \"./Core/Namer\";\nimport { ReporterFactory, ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { Scrubber, Scrubbers } from \"./Scrubbers/Scrubbers\";\nimport { StringWriter } from \"./StringWriter\";\nimport { Writer } from \"./Core/Writer\";\nimport { postRunCleanup } from \"./postRunCleanup\";\nimport { stringifyKeysInOrder } from \"./AUtils\";\n\n// if someone tries to call 'require(\"approvals\")...' without calling \".mocha(...) or\n// they won't get a helpful error. So we put this in there - just in case\"\nimport { MochaNamer } from \"./Providers/Mocha/MochaNamer\";\n\nimport { beforeEachVerifierBase } from \"./Providers/BeforeEachVerifierBase\";\n\n/**\n * Contains some helpful and util scrubbers that can be used for scrubbing data before saving to a received file.\n */\nexport { Scrubbers as scrubbers };\n\nif (typeof beforeEach === \"function\") {\n  beforeEach(function (): void {\n    if (!this) {\n      return;\n    }\n    this.verify = function () {\n      throw new Error(\"You must call either .mocha()\");\n    };\n  });\n}\n\n// keep track of approved files we run into with tests\nconst listOfApprovedFiles: string[] = [];\nprocess.on(\"approvalFileApproved\", function (fileName): void {\n  if (listOfApprovedFiles.indexOf(fileName) === -1) {\n    listOfApprovedFiles.push(fileName);\n  }\n});\n\nprocess.on(\"exit\", function (): void {\n  const options = cfg.currentConfig();\n  postRunCleanup(options, listOfApprovedFiles);\n  const finalMessages = FinalMessages.getMessages();\n  if (finalMessages.length) {\n    console.log(\"******************************\");\n    console.log(\"* Approvals Report: WARNING!\");\n    finalMessages.forEach((message: string) => {\n      console.log(`*  - ${message}`);\n    });\n    console.log(\"******************************\");\n  }\n});\n\n/**\n * Allows you to provide overrides to the default configuration.\n *\n * @example\n * const approvals = require('approvals');\n * approvals.configure({\n *   reporters: ['p4merge']\n * });\n *\n * @param {*} overrideOptions\n */\nexport function configure(overrideOptions: cfg.Config): typeof module.exports {\n  cfg.configure(overrideOptions);\n  return module.exports;\n}\n\n/**\n * Allows the creation of an approvals configuration object using any passed in options to override the defaults.\n * @param {Object} overrideOptions\n * @returns {Object} approvals config object with any options overridden.\n */\nexport function getConfig(overrideOptions?: cfg.Config): cfg.Config {\n  return cfg.getConfig(overrideOptions);\n}\n\n/**\n * Configure approvals to hook into Mocha tests.\n * @param {*} optionalBaseDir - An optional folder to save approval files to.\n */\n\nexport function mocha(optionalBaseDir?: string): typeof module.exports {\n  // if not providing a base dir, fallback to the current calling code's directory\n  if (!optionalBaseDir) {\n      let fileName = callsite()[1].getFileName();\n      if (fileName.startsWith(\"file://\")) {\n          fileName = fileURLToPath(fileName);\n      }\n      optionalBaseDir = path.dirname(fileName);\n  }\n  beforeEachVerifierBase(\n    MochaNamer,\n    \"require('Approvals').mocha();\",\n    optionalBaseDir,\n  );\n\n  return module.exports;\n}\n\nfunction jasmineExport(): void {\n  throw new Error(\n    \"Aww shucks.\\n\\nApprovals support of Jasmine has been completely yanked out (don't shoot). \\n\\n Jasmine has grown quite complicated (behind our back) and we haven't had enough time to figure out a solid integration pattern... for now it's support has been removed.\\n\\n Check out the docs for manual usage of approval tests to work around the missing Jasmine integration (it should be a straightforward change for you, really).\\n\\n We'll consider bringing it back if we can get someone with interest in submitting a pull request that can bring it back...\",\n  );\n}\n\n/**\n * `reporters` gives access to the `MultiReporter`\n *\n * @example\n * const MultiReporter = approvals.reporters.MultiReporter\n */\n\nexport const reporters: { MultiReporter: any } = {\n  /**\n   * This allows access to the MultiReporter constructor.\n   * You can use this to run multiple reporters at the same time.\n   *\n   * @example\n   * approvals.verify(__dirname, \"multi-reporter-example\", \"some data\", {\n   *   reporters: [\n   *     new MultiReporter('p4merge', 'copycommand')\n   *   ]\n   * });\n   */\n  MultiReporter: require(\"./Reporting/Reporters/multiReporter\").default,\n};\n\n/**\n * Use this to apply the scrubber function to any data before running verify.\n *\n * @example\n * // basic approval test with a custom scrubber\n * const approvals = require('approvals');\n * const scrubber = approvals.scrubbers.multiScrubber([\n *    function (data) {\n *      return (data || '').replace(\"some text\", \"some other text\");\n *    },\n *    approvals.scrubbers.guidScrubber // to remove guids from the received data\n * });\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', \"some text to verify\", scrubber);\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - Either the string to save as a text file or a Buffer that represents an image\n * @param {*} scrubber - A function that takes a string and returns a string. Approvals will call this if it exists to scrub the \"data\" before writing to any files.\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\nfunction verifyAndScrub(\n  dirName: string,\n  testName: string,\n  data: BinaryWriter | string,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  scrubber = scrubber || Scrubbers.noScrubber;\n\n  // backwards compatible option\n  if (Array.isArray(optionsOverride)) {\n    optionsOverride = {\n      reporters: optionsOverride,\n    };\n    const stringReporters = JSON.stringify(optionsOverride.reporters);\n    console.error(\n      'For the last arg of the approvals.verify(...) function, if you passed in an array of reporters, something like [\"opendiff\",\"nodediff\"], this has been deprecated and replaced by passing in a config object. Please re-evaluate if you can remove this parameter alltogether and use individual user configs in ~/.approvalConfig, if not then replace this: ' +\n        stringReporters +\n        \" with this { reporters: \" +\n        stringReporters +\n        \"}.\",\n    );\n  }\n\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const namer = new ManualNamer(dirName, testName);\n\n  let writer: Writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data as string);\n\n    writer = new StringWriter(newOptions, data as string);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}\n/**\n *\n * @example\n * // basic approval test\n * const approvals = require('approvals');\n * approvals.verify(__dirname, 'sample-approval-test', \"some text to verify\");\n *\n * @example\n * // basic approval test providing an option to override configuration\n * const approvals = require('approvals');\n * approvals.verify(__dirname, 'sample-approval-test', \"some text to verify\", { normalizeLineEndingsTo: true });\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name save string to call the file associated with this test.\n * @param {(string|Buffer)} data - Either the string to save as a text file or a Buffer that represents an image\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\n\nexport function verify(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride?: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * You can pass as \"data\" any javascript object to be JSON.stringified and run verify against.\n *\n * @example\n * const approvals = require('approvals');\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', { a: \"some text in an object\" });\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - This can be any JavaScript object/array that will be JSON.stringified before running verify\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\nexport function verifyAsJSON(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride: any,\n) {\n  return verifyAsJSONAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * You can pass as \"data\" any javascript object to be JSON.stringified. Before we run verify the scrubber will be run against the complete string before running verify against it.\n\n * @example\n * // basic approval test with a custom scrubber\n * const approvals = require('approvals');\n * const scrubber = approvals.scrubbers.multiScrubber([\n *    function (data) {\n *      return (data || '').replace(\"some text\", \"some other text\");\n *    },\n *    approvals.scrubbers.guidScrubber // to remove guids from the received data\n * });\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', { a: \"some text in an object\" }, scrubber);\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - This can be any JavaScript object/array that will be JSON.stringified before running verify\n * @param {*} scrubber - A function that takes a string and returns a string. Approvals will call this if it exists to scrub the \"data\" before writing to any files.\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\n\nexport function verifyAsJSONAndScrub(\n  dirName: string,\n  testName: string,\n  data: any,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    stringifyKeysInOrder(data),\n    scrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * This allows you to take full control of naming and writing files before verifying.\n *\n * For an example that we use to generate the docs within the readme, check out the [test/readmeTests.js](test/readmeTests.js) in this project.\n *\n * @param {Object} namer\n * @param {Object} writer\n * @param {Function} [reporterFactory]\n * @param {Object} [optionsOverride]\n */\n\nexport function verifyWithControl(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory?: ReporterLoader | null,\n  optionsOverride?: Partial<cfg.Config>,\n) {\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const loader =\n    (reporterFactory as ReporterLoader) ||\n    function () {\n      return [ReporterFactory.loadReporter(newOptions.reporters)];\n    };\n\n  FileApprover.verify(namer, writer, loader, newOptions);\n}\n\n'Approvals.NodeJS/bin/index.ts'\n:#!/usr/bin/env ts-node\nimport es from \"event-stream\";\nimport * as autils from \"../lib/AUtils\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport marked from \"marked\";\nimport TerminalRenderer from \"marked-terminal\";\nimport minimist from \"minimist\";\nimport { configure, verify } from \"../lib/Approvals\";\nimport { redText } from \"../lib/Utilities/ConsoleUtils\";\n\nconst verbose = process.argv.includes(\"--verbose\");\nconst printHelp = process.argv.includes(\"--help\");\n\nfunction printHelpMessage() {\n  if (verbose) {\n    console.log(\"printing help...\");\n  }\n\n  const helpFile = fs.readFileSync(path.join(__dirname, \"help.md\"), \"utf8\");\n  marked.setOptions({\n    renderer: new TerminalRenderer(),\n  });\n  let output = marked.parse(helpFile) as string;\n\n  output = output.replace(/&nbsp;/g, \" \");\n  console.log(output);\n}\n\nfunction errAndExit(msg: string): void {\n  printHelpMessage();\n  console.log(redText(msg));\n  process.exit(1);\n}\n\nif (printHelp) {\n  printHelpMessage();\n  process.exit();\n}\n\nif (verbose) {\n  console.log(\"process.argv: \", process.argv);\n}\n\nconst argv = minimist(process.argv.slice(2), {\n  alias: {\n    reporters: [\"r\"],\n  },\n  boolean: [\"verbose\"],\n});\n\nif (verbose) {\n  console.log(\"parsed args: \", argv);\n}\n\nlet reporters = argv.reporter as string | string[];\nif (typeof reporters === \"string\") {\n  reporters = [reporters];\n}\n\nconst testname = argv._[0];\nif (!testname) {\n  errAndExit(\n    'Missing parameter: supply a test name ex: echo \"hello\" | approvals myFirstTest. This will become the file name myFirstTest.approved.txt in the current directory',\n  );\n}\n\nconst outdir = argv.outdir || process.cwd();\nif (!fs.existsSync(outdir)) {\n  errAndExit(\"Directory not found: \" + outdir);\n}\n\nconst errorOnStaleApprovedFiles = argv.errorOnStaleApprovedFiles === \"true\";\n\nif (verbose) {\n  console.log(\"outdir: \", outdir);\n  console.log(\"errorOnStaleApprovedFiles: \", errorOnStaleApprovedFiles);\n  console.log(\"testname: \", testname);\n  console.log(\n    \"reporters: \",\n    reporters ||\n      \"undefined (but will fallback to approvals preconfigure defaults)\",\n  );\n}\n\nconst opts: any = {};\nif (reporters) {\n  opts.reporters = reporters;\n}\nopts.errorOnStaleApprovedFiles = errorOnStaleApprovedFiles;\n\nif (verbose) {\n  console.log(\"approval opts: \", opts);\n}\n\nopts.forceApproveAll =\n  autils.hasCommandLineArgument(\"--forceapproveall\") ||\n  autils.hasCommandLineArgument(\"-f\");\n\nprocess.stdin.pipe(\n  es.mapSync((data: Buffer) => {\n    const dataToVerify = data.toString();\n    configure(opts);\n    verify(outdir, testname, dataToVerify);\n  }),\n);\n\n",
        "called_code_segment_file_1": "function verifyAndScrub(dirName, testName, data, scrubber, optionsOverride) {\n  scrubber = scrubber || Scrubbers.noScrubber;\n  const newOptions = cfg.getConfig(optionsOverride);\n  const namer = new ManualNamer(dirName, testName);\n  let writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data);\n    writer = new StringWriter(newOptions, data);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}",
        "invoking_code_segment_file_2": "function verify(dirName, testName, data, optionsOverride) {\n  return verifyAndScrub(dirName, testName, data, Scrubbers.noScrubber, optionsOverride);\n}",
        "invoking_code_segment_file_3": "process.stdin.pipe(\n  es.mapSync((data) => {\n    const dataToVerify = data.toString();\n    configure(opts);\n    verify(outdir, testname, dataToVerify);\n  })\n);",
        "new_file_code_segment": "function logVerificationDetails(dirName, testName, data, scrubber, optionsOverride) {\n  console.log(`Verifying data in directory: ${dirName}`);\n  console.log(`Test name: ${testName}`);\n  console.log(`Data to verify: ${data}`);\n  console.log(`Scrubber used: ${scrubber.name}`);\n  console.log(`Options override:`, optionsOverride);\n}",
        "feature_description": "Add logging for verification details to improve debugging and transparency.",
        "detailed_feature_description": "The new feature introduces logging of verification details before the actual verification process. This includes logging the directory, test name, data to verify, scrubber used, and any options overrides. This logging is implemented in a new file (#file 4) and is invoked from #file 1 to provide detailed information about the verification process.",
        "modified_complete_code": {
            "#file 1": "function verifyAndScrub(dirName, testName, data, scrubber, optionsOverride) {\n  scrubber = scrubber || Scrubbers.noScrubber;\n  const newOptions = cfg.getConfig(optionsOverride);\n  const namer = new ManualNamer(dirName, testName);\n  let writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data);\n    writer = new StringWriter(newOptions, data);\n  }\n  #Modify logVerificationDetails(dirName, testName, data, scrubber, optionsOverride);\n  verifyWithControl(namer, writer, null, newOptions);\n}",
            "#file 2": "function verify(dirName, testName, data, optionsOverride) {\n  return verifyAndScrub(dirName, testName, data, Scrubbers.noScrubber, optionsOverride);\n}",
            "#file 3": "process.stdin.pipe(\n  es.mapSync((data) => {\n    const dataToVerify = data.toString();\n    configure(opts);\n    verify(outdir, testname, dataToVerify);\n  })\n);",
            "#file 4": "#New function logVerificationDetails(dirName, testName, data, scrubber, optionsOverride) {\n  console.log(`Verifying data in directory: ${dirName}`);\n  console.log(`Test name: ${testName}`);\n  console.log(`Data to verify: ${data}`);\n  console.log(`Scrubber used: ${scrubber.name}`);\n  console.log(`Options override:`, optionsOverride);\n}"
        }
    },
    {
        "repo": "Day59-Angular-Practice",
        "content": "'Day59-Angular-Practice/app/task.ts'\n:export class Task {\n  public done: boolean = false;\n  public points: number = 0;\n  constructor(public description: string, public id: number) {\n\n  }\n\n}\n\nexport function capitalize(task: Task) {\n  task.description = task.description.toUpperCase();\n}\n\n'Day59-Angular-Practice/app/task-list.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {DeleteTaskComponent} from './delete-task.component';\nimport {AppComponent} from './app.component';\nimport {EditTaskComponent} from './edit-task.component'\nimport {PointsComponent} from './points.component'\n\n@Component({\n  selector: 'task-list',\n  inputs: ['newtasks'],\n  directives: [DeleteTaskComponent, NewTaskComponent, EditTaskComponent, PointsComponent],\n  template: `\n    <new-task\n      (emitTasks)=\"concatArrays($event)\">\n    </new-task>\n    <h3\n      *ngFor=\"#task of newtasks\"\n      (click)=\"selectTask(task)\">\n      <h1>\n      {{task.description}}\n      </h1>\n      <points [task] = \"task\" [fakeList] = \"newtasks\"></points>\n      <delete-task\n        (click) =\"delete(task)\">\n      </delete-task>\n    </h3>\n    <edit-task *ngIf = \"selectedTask\" [task] = \"selectedTask\">\n    </edit-task>\n  `\n})\n\nexport class TaskListComponent {\n  public newtasks: Task[] = [];\n  public selectedTask: Task;\n  constructor() {\n    this.newtasks = [\n      new Task(\"New\", 0),\n      new Task(\"Learn Kung Fu\", 1),\n      new Task(\"Learn Kung Fu\", 2),\n      new Task(\"Create To-Do List app.\", 3)\n    ]\n  }\n  concatArrays(newTasks: Task[]): void {\n    this.newtasks = this.newtasks.concat(newTasks);\n    console.log(this.newtasks);\n  }\n  taskDeleted(taskSelected) {\n    function callBack(value, index, array) {\n      if (taskSelected !== value) {\n        return taskSelected;\n      };\n    };\n    this.newtasks = this.newtasks.filter(callBack);\n  }\n  selectTask(clicked: Task): void {\n    this.selectedTask = clicked;\n    console.log(\"got it\");\n    console.log(\"selected task: \" + this.selectedTask.description);\n  }\n\n  delete(beerSelected: Task) {\n    // var num = this.newtasks.length;\n    // console.log(num);\n    for (var i =0; i<this.newtasks.length; i++){\n      if(beerSelected.id === this.newtasks[i].id){\n        this.newtasks.splice(i, 1);\n        return true;\n      }\n    }\n  }\n}\n\n'Day59-Angular-Practice/app/app.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {TaskListComponent} from './task-list.component';\n\n\n@Component({\n  selector: 'my-app',\n  directives: [NewTaskComponent, TaskListComponent],\n  template: `\n  <h1>hi</h1>\n  <task-list></task-list>\n\n  `\n})\n\nexport class AppComponent {\n\n}\n\n",
        "called_code_segment_file_1": "public done: boolean = false;\npublic points: number = 0;\nconstructor(public description: string, public id: number) {\n\n}",
        "invoking_code_segment_file_2": "public newtasks: Task[] = [];\nconstructor() {\n  this.newtasks = [\n    new Task(\"New\", 0),\n    new Task(\"Learn Kung Fu\", 1),\n    new Task(\"Learn Kung Fu\", 2),\n    new Task(\"Create To-Do List app.\", 3)\n  ]\n}",
        "invoking_code_segment_file_3": "public selectedTask: Task;\nselectTask(clicked: Task): void {\n  this.selectedTask = clicked;\n  console.log(\"got it\");\n  console.log(\"selected task: \" + this.selectedTask.description);\n}",
        "new_file_code_segment": "export class TaskPriority {\n  constructor(public priority: number) {}\n}",
        "feature_description": "Add a priority feature to tasks.",
        "detailed_feature_description": "The new feature introduces a priority level for each task. This priority will be managed through a new class `TaskPriority` in a new file (#file 4). The `Task` class in #file 1 will be updated to include a priority property. The `TaskListComponent` in #file 2 will be modified to handle tasks with priorities, and the `EditTaskComponent` in #file 3 will be updated to allow editing of task priorities.",
        "modified_complete_code": {
            "file_1": "export class Task {\n  public done: boolean = false;\n  public points: number = 0;\n  public priority: TaskPriority;\n  constructor(public description: string, public id: number, priority: number) {\n    this.priority = new TaskPriority(priority);\n  }\n}\n\nexport function capitalize(task: Task) {\n  task.description = task.description.toUpperCase();\n}",
            "file_2": "import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {DeleteTaskComponent} from './delete-task.component';\nimport {AppComponent} from './app.component';\nimport {EditTaskComponent} from './edit-task.component'\nimport {PointsComponent} from './points.component'\nimport {TaskPriority} from './task-priority';\n\n@Component({\n  selector: 'task-list',\n  inputs: ['newtasks'],\n  directives: [DeleteTaskComponent, NewTaskComponent, EditTaskComponent, PointsComponent],\n  template: `\n    <new-task\n      (emitTasks)=\"concatArrays($event)\">\n    </new-task>\n    <h3\n      *ngFor=\"#task of newtasks\"\n      (click)=\"selectTask(task)\">\n      <h1>\n      {{task.description}}\n      </h1>\n      <points [task] = \"task\" [fakeList] = \"newtasks\"></points>\n      <delete-task\n        (click) =\"delete(task)\">\n      </delete-task>\n    </h3>\n    <edit-task *ngIf = \"selectedTask\" [task] = \"selectedTask\">\n    </edit-task>\n  `\n})\nexport class TaskListComponent {\n  public newtasks: Task[] = [];\n  public selectedTask: Task;\n  constructor() {\n    this.newtasks = [\n      new Task(\"New\", 0, 1),\n      new Task(\"Learn Kung Fu\", 1, 2),\n      new Task(\"Learn Kung Fu\", 2, 3),\n      new Task(\"Create To-Do List app.\", 3, 1)\n    ]\n  }\n  concatArrays(newTasks: Task[]): void {\n    this.newtasks = this.newtasks.concat(newTasks);\n    console.log(this.newtasks);\n  }\n  taskDeleted(taskSelected) {\n    function callBack(value, index, array) {\n      if (taskSelected !== value) {\n        return taskSelected;\n      };\n    };\n    this.newtasks = this.newtasks.filter(callBack);\n  }\n  selectTask(clicked: Task): void {\n    this.selectedTask = clicked;\n    console.log(\"got it\");\n    console.log(\"selected task: \" + this.selectedTask.description);\n  }\n\n  delete(beerSelected: Task) {\n    for (var i =0; i<this.newtasks.length; i++){\n      if(beerSelected.id === this.newtasks[i].id){\n        this.newtasks.splice(i, 1);\n        return true;\n      }\n    }\n  }\n}",
            "file_3": "import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {TaskPriority} from './task-priority';\n\n@Component({\n  selector: 'edit-task',\n  inputs: ['task'],\n  template: `\n    <div>\n      <input [(ngModel)]=\"task.description\" placeholder=\"Description\">\n      <input [(ngModel)]=\"task.priority.priority\" type=\"number\" placeholder=\"Priority\">\n    </div>\n  `\n})\nexport class EditTaskComponent {\n  public task: Task;\n}",
            "file_4": "export class TaskPriority {\n  constructor(public priority: number) {}\n}"
        }
    },
    {
        "repo": "ERC1238-token",
        "content": "'ERC1238-token/test/utils/interfaces.ts'\n:export const IERC1238 = [\n  \"balanceOf(address,uint256)\",\n  \"balanceOfBatch(address,uint256[])\",\n  \"balanceOfBundle(address[],uint256[][])\",\n];\n\nexport const IERC1238Receiver = [\n  \"onERC1238Mint(address,uint256,uint256,bytes)\",\n  \"onERC1238BatchMint(address,uint256[],uint256[],bytes)\",\n];\n\nexport const IERC1238Collection = [\"balanceFromBaseId(address,uint48)\", \"getConstructedTokenID(uint48,address,uint48)\"];\n\nexport const IERC1238URIStorage = [\"tokenURI(uint256)\"];\n\nexport const IERC165 = [\"supportsInterface(bytes4)\"];\n\n'ERC1238-token/test/utils/test-utils.ts'\n:import { BigNumberish, utils } from \"ethers\";\nimport { ethers } from \"hardhat\";\nimport * as interfaces from \"./interfaces\";\n\nexport const ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\nexport const TOKEN_ID_ZERO = 0;\nexport const invalidSignatureV = 26;\nexport const invalidSignatureS = \"0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1\";\n\nexport const toBN = (units: string, decimalPlaces: number = 18) => ethers.utils.parseUnits(units, decimalPlaces);\nexport const formatBN = (amount: BigNumberish, decimalPlaces: number = 18) =>\n  ethers.utils.formatUnits(amount, decimalPlaces);\n\n// Taken from OpenZeppeling test-helpers\n// https://github.com/OpenZeppelin/openzeppelin-test-helpers/blob/a7c3af4192fd0ad2a61a4ebac66097f5b5934e92/src/makeInterfaceId.js\nexport const getERC165InterfaceId = (functionSignatures: string[] = []) => {\n  const INTERFACE_ID_LENGTH = 4;\n\n  const interfaceIdBuffer = functionSignatures\n    .map(signature => utils.keccak256(utils.toUtf8Bytes(signature)))\n    .map(\n      h => Buffer.from(h.substring(2), \"hex\").slice(0, 4), // bytes4()\n    )\n    .reduce((memo, bytes) => {\n      for (let i = 0; i < INTERFACE_ID_LENGTH; i++) {\n        memo[i] = memo[i] ^ bytes[i]; // xor\n      }\n      return memo;\n    }, Buffer.alloc(INTERFACE_ID_LENGTH));\n\n  return `0x${interfaceIdBuffer.toString(\"hex\")}`;\n};\n\nconst checkInterfaceId = async (contract: any, interfaceName: keyof typeof interfaces) => {\n  const interfaceId = getERC165InterfaceId(interfaces[interfaceName]);\n\n  const isInterfaceSupported = await contract.supportsInterface(interfaceId);\n\n  if (!isInterfaceSupported) throw new Error(`Unsupported interfaceId`);\n\n  return isInterfaceSupported;\n};\n\nexport const shouldSupportInterfaces = async (contract: any, interfaceNames: (keyof typeof interfaces)[]) => {\n  try {\n    const res = await Promise.all(interfaceNames.map(interfaceName => checkInterfaceId(contract, interfaceName)));\n\n    if (res.find(p => p.status === \"rejected\") !== undefined) return false;\n\n    return true;\n  } catch (err) {\n    console.error(err);\n    return false;\n  }\n};\n\n'ERC1238-token/test/ERC1238/extensions/ERC1238URIStorage.ts'\n:// import type { SignerWithAddress } from \"@nomiclabs/hardhat-ethers/dist/src/signer-with-address\";\n// import { expect } from \"chai\";\n// import { artifacts, ethers, waffle } from \"hardhat\";\n// import type { Artifact } from \"hardhat/types\";\n// import type { ERC1238URIStorageMock } from \"../../../src/types/ERC1238URIStorageMock\";\n// import { toBN, ZERO_ADDRESS } from \"../../utils/test-utils\";\n\nconst BASE_URI = \"https://token-cdn-domain/{id}.json\";\nconst EMPTY_URI = \"\";\n\n// TODO: Update tests\n\n// describe(\"ERC1238URIStorage\", function () {\n//   let erc1238UriMock: ERC1238URIStorageMock;\n//   let admin: SignerWithAddress;\n//   let tokenRecipient: SignerWithAddress;\n//   let tokenBatchRecipient: SignerWithAddress;\n\n//   before(async function () {\n//     const signers: SignerWithAddress[] = await ethers.getSigners();\n//     admin = signers[0];\n//     tokenRecipient = signers[1];\n//     tokenBatchRecipient = signers[2];\n//   });\n\n//   beforeEach(async function () {\n//     const ERC1238UriMockArtifact: Artifact = await artifacts.readArtifact(\"ERC1238URIStorageMock\");\n//     erc1238UriMock = <ERC1238URIStorageMock>await waffle.deployContract(admin, ERC1238UriMockArtifact, [BASE_URI]);\n//   });\n\n// describe(\"ERC165\", () => {\n//   it(\"should support the right interfaces\", async () => {\n//     const supported = await shouldSupportInterfaces(erc1238Collection, [\"IERC165\", \"IERC1238\", \"IERC1238URIStorage\"]);\n\n//     expect(supported).to.eq(true);\n//   });\n// });\n\n//   describe(\"internal functions\", () => {\n//     const data = \"0x12345678\";\n//     const tokenId = toBN(\"11223344\");\n//     const tokenURI = \"https://token-cdn-domain/event/exclusive-pass/69\";\n//     const mintAmount = toBN(\"58319\");\n//     const burnAmount = toBN(\"987\");\n\n//     const tokenBatchIds = [toBN(\"2000\"), toBN(\"2010\"), toBN(\"2020\")];\n//     const tokenBatchURIs = [\n//       \"https://ipfs.io/ipfs/Qme7ss3ARVgxv6rXqVPiikMJ8u2NLgmgszg13pYrDKEoiu\",\n//       \"https://ipfs.io/ipfs/Qme7ss3ARVgxv6rXqVPiikMJ8u2NLgmgszg13pYrDKEoiv\",\n//       \"https://ipfs.io/ipfs/Qme7ss3ARVgxv6rXqVPiikMJ8u2NLgmgszg13pYrDKEoiw\",\n//     ];\n//     const mintBatchAmounts = [toBN(\"5000\"), toBN(\"10000\"), toBN(\"42195\")];\n//     const burnBatchAmounts = [toBN(\"5000\"), toBN(\"9001\"), toBN(\"195\")];\n\n//     /*\n//      * URI\n//      */\n//     describe(\"URIs\", () => {\n//       describe(\"_setTokenURI\", () => {\n//         it(\"should set a token URI\", async () => {\n//           const tokenId = 0;\n//           const tokenURI = \"https://token-cdn-domain/special-collection/pass/0\";\n\n//           await erc1238UriMock.setTokenURI(tokenId, tokenURI);\n\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);\n//         });\n\n//         it(\"should emit an event\", async () => {\n//           const tokenId = 1;\n//           const tokenURI = \"https://token-cdn-domain/special-collection/pass/1\";\n\n//           await expect(erc1238UriMock.setTokenURI(tokenId, tokenURI))\n//             .to.emit(erc1238UriMock, \"URI\")\n//             .withArgs(tokenId, tokenURI);\n//         });\n//       });\n\n//       describe(\"tokenURI\", () => {\n//         it(\"should return the right token URI if one is set\", async () => {\n//           const tokenId = 2;\n//           const tokenURI = \"https://token-cdn-domain/special-collection/pass/2\";\n\n//           await erc1238UriMock.setTokenURI(tokenId, tokenURI);\n\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);\n//         });\n\n//         it(\"should return the base URI by default\", async () => {\n//           const unknownTokenId = 99999;\n\n//           expect(await erc1238UriMock.tokenURI(unknownTokenId)).to.eq(BASE_URI);\n//         });\n//       });\n\n//       describe(\"_deleteTokenURI\", () => {\n//         it(\"should delete the token URI if it has been set\", async () => {\n//           const tokenId = 3;\n//           const tokenURI = \"https://token-cdn-domain/special-collection/pass/3\";\n\n//           // Set URI\n//           await erc1238UriMock.setTokenURI(tokenId, tokenURI);\n\n//           // Delete URI\n//           await erc1238UriMock.deleteTokenURI(tokenId);\n\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(BASE_URI);\n//         });\n\n//         it(\"should do nothing if the token URI was not set\", async () => {\n//           const tokenId = 4;\n\n//           await erc1238UriMock.deleteTokenURI(tokenId);\n\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(BASE_URI);\n//         });\n//       });\n//     });\n\n//     /*\n//      * MINTING\n//      */\n\n//     describe(\"_mintWithURI\", () => {\n//       it(\"should revert with the zero address as recipient\", async () => {\n//         await expect(\n//           erc1238UriMock.connect(admin).mintWithURI(ZERO_ADDRESS, tokenId, mintAmount, tokenURI, data),\n//         ).to.be.revertedWith(\"ERC1238: mint to the zero address\");\n//       });\n\n//       it(\"should credit the amount of tokens\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\n//         const balance = await erc1238UriMock.balanceOf(tokenRecipient.address, tokenId);\n\n//         expect(balance).to.eq(mintAmount);\n//       });\n\n//       it(\"should set the right URI when minting\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\n//         expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);\n//       });\n\n//       it(\"should emit a MintSingle event\", async () => {\n//         await expect(erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data))\n//           .to.emit(erc1238UriMock, \"MintSingle\")\n//           .withArgs(admin.address, tokenRecipient.address, tokenId, mintAmount);\n//       });\n\n//       it(\"should emit an URI event\", async () => {\n//         await expect(erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data))\n//           .to.emit(erc1238UriMock, \"URI\")\n//           .withArgs(tokenId, tokenURI);\n//       });\n//     });\n\n//     describe(\"_mintBatchWithURI\", () => {\n//       it(\"should revert with the zero address\", async () => {\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(ZERO_ADDRESS, tokenBatchIds, mintBatchAmounts, tokenBatchURIs, data),\n//         ).to.be.revertedWith(\"ERC1238: mint to the zero address\");\n//       });\n\n//       it(\"should revert if the length of ids and amounts do not match\", async () => {\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(\n//               tokenBatchRecipient.address,\n//               tokenBatchIds.slice(1),\n//               mintBatchAmounts,\n//               tokenBatchURIs,\n//               data,\n//             ),\n//         ).to.be.revertedWith(\"ERC1238: ids and amounts length mismatch\");\n\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(\n//               tokenBatchRecipient.address,\n//               tokenBatchIds,\n//               mintBatchAmounts.slice(1),\n//               tokenBatchURIs,\n//               data,\n//             ),\n//         ).to.be.revertedWith(\"ERC1238: ids and amounts length mismatch\");\n//       });\n\n//       it(\"should revert if the length of ids and uris do not match\", async () => {\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(\n//               tokenBatchRecipient.address,\n//               tokenBatchIds,\n//               mintBatchAmounts,\n//               tokenBatchURIs.slice(1),\n//               data,\n//             ),\n//         ).to.be.revertedWith(\"ERC1238: ids and URIs length mismatch\");\n\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(\n//               tokenBatchRecipient.address,\n//               tokenBatchIds.slice(1),\n//               mintBatchAmounts.slice(1),\n//               tokenBatchURIs,\n//               data,\n//             ),\n//         ).to.be.revertedWith(\"ERC1238: ids and URIs length mismatch\");\n//       });\n\n//       it(\"should credit the minted tokens\", async () => {\n//         await erc1238UriMock\n//           .connect(admin)\n//           .mintBatchWithURI(tokenBatchRecipient.address, tokenBatchIds, mintBatchAmounts, tokenBatchURIs, data);\n\n//         tokenBatchIds.forEach(async (tokenId, index) =>\n//           expect(await erc1238UriMock.balanceOf(tokenBatchRecipient.address, tokenId)).to.eq(mintBatchAmounts[index]),\n//         );\n//       });\n\n//       it(\"should set the right token URIs\", async () => {\n//         await erc1238UriMock\n//           .connect(admin)\n//           .mintBatchWithURI(tokenBatchRecipient.address, tokenBatchIds, mintBatchAmounts, tokenBatchURIs, data);\n\n//         tokenBatchIds.forEach(async (tokenId, index) =>\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenBatchURIs[index]),\n//         );\n//       });\n\n//       it(\"should emit a MintBatch event\", async () => {\n//         await expect(\n//           erc1238UriMock.mintBatchWithURI(\n//             tokenRecipient.address,\n//             tokenBatchIds,\n//             mintBatchAmounts,\n//             tokenBatchURIs,\n//             data,\n//           ),\n//         )\n//           .to.emit(erc1238UriMock, \"MintBatch\")\n//           .withArgs(admin.address, tokenRecipient.address, tokenBatchIds, mintBatchAmounts);\n//       });\n\n//       it(\"should emit URI events\", async () => {\n//         const tx = erc1238UriMock.mintBatchWithURI(\n//           tokenRecipient.address,\n//           tokenBatchIds,\n//           mintBatchAmounts,\n//           tokenBatchURIs,\n//           data,\n//         );\n\n//         tokenBatchIds.forEach(\n//           async (tokenId, index) =>\n//             await expect(tx).to.emit(erc1238UriMock, \"URI\").withArgs(tokenId, tokenBatchURIs[index]),\n//         );\n//       });\n//     });\n\n//     /*\n//      * BURNING\n//      */\n\n//     describe(\"_burnAndDeleteURI\", () => {\n//       it(\"should revert when burning the zero account's token\", async () => {\n//         await expect(\n//           erc1238UriMock.connect(admin).burnAndDeleteURI(ZERO_ADDRESS, tokenId, burnAmount),\n//         ).to.be.revertedWith(\"ERC1238: burn from the zero address\");\n//       });\n\n//       it(\"should revert when burning a non-existent token id\", async () => {\n//         await expect(\n//           erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, burnAmount),\n//         ).to.be.revertedWith(\"ERC1238: burn amount exceeds balance\");\n//       });\n\n//       it(\"should revert when burning more than available balance\", async () => {\n//         const amountToMint = burnAmount.sub(1);\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, amountToMint, tokenURI, data);\n//         await expect(\n//           erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, burnAmount),\n//         ).to.be.revertedWith(\"ERC1238: burn amount exceeds balance\");\n//       });\n\n//       it(\"should burn the right amount of tokens\", async () => {\n//         const amountToMint = burnAmount.add(1);\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, amountToMint, tokenURI, data);\n//         await erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, burnAmount);\n//         expect(await erc1238UriMock.balanceOf(tokenRecipient.address, tokenId)).to.eq(1);\n//       });\n\n//       it(\"should emit a BurnSingle event\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, burnAmount, tokenURI, data);\n//         await expect(erc1238UriMock.burnAndDeleteURI(tokenRecipient.address, tokenId, burnAmount))\n//           .to.emit(erc1238UriMock, \"BurnSingle\")\n//           .withArgs(admin.address, tokenRecipient.address, tokenId, burnAmount);\n//       });\n\n//       it(\"should delete any token URI set\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\n//         await erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, mintAmount);\n\n//         expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(BASE_URI);\n//       });\n\n//       it(\"should do nothing if the a token URI was not set\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, EMPTY_URI, data);\n\n//         await erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, mintAmount);\n\n//         expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(BASE_URI);\n//       });\n//     });\n\n//     describe(\"_burnBatchAndDeleteURIs\", () => {\n//       it(\"should revert when burning the zero account's token\", async () => {\n//         await expect(\n//           erc1238UriMock.connect(admin).burnBatchAndDeleteURIs(ZERO_ADDRESS, tokenBatchIds, burnBatchAmounts),\n//         ).to.be.revertedWith(\"ERC1238: burn from the zero address\");\n//       });\n\n//       it(\"should revert if the length of inputs do not match\", async () => {\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .burnBatchAndDeleteURIs(tokenBatchRecipient.address, tokenBatchIds.slice(1), burnBatchAmounts),\n//         ).to.be.revertedWith(\"ERC1238: ids and amounts length mismatch\");\n\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .burnBatchAndDeleteURIs(tokenBatchRecipient.address, tokenBatchIds, burnBatchAmounts.slice(1)),\n//         ).to.be.revertedWith(\"ERC1238: ids and amounts length mismatch\");\n//       });\n\n//       it(\"should revert when burning a non-existent token id\", async () => {\n//         await erc1238UriMock\n//           .connect(admin)\n//           .mintBatchWithURI(\n//             tokenRecipient.address,\n//             tokenBatchIds.slice(1),\n//             burnBatchAmounts.slice(1),\n//             tokenBatchURIs.slice(1),\n//             data,\n//           );\n\n//         await expect(\n//           erc1238UriMock.connect(admin).burnBatchAndDeleteURIs(tokenRecipient.address, tokenBatchIds, burnBatchAmounts),\n//         ).to.be.revertedWith(\"ERC1238: burn amount exceeds balance\");\n//       });\n\n//       it(\"should properly burn tokens\", async () => {\n//         await erc1238UriMock\n//           .connect(admin)\n//           .mintBatchWithURI(tokenRecipient.address, tokenBatchIds, mintBatchAmounts, tokenBatchURIs, data);\n\n//         await erc1238UriMock\n//           .connect(admin)\n//           .burnBatchAndDeleteURIs(tokenRecipient.address, tokenBatchIds, burnBatchAmounts);\n\n//         tokenBatchIds.forEach(async (tokenId, i) =>\n//           expect(await erc1238UriMock.balanceOf(tokenRecipient.address, tokenId)).to.eq(\n//             mintBatchAmounts[i].sub(burnBatchAmounts[i]),\n//           ),\n//         );\n//       });\n\n//       it(\"should emit a BurnBatch event\", async () => {\n//         await erc1238UriMock.mintBatchWithURI(\n//           tokenRecipient.address,\n//           tokenBatchIds,\n//           mintBatchAmounts,\n//           tokenBatchURIs,\n//           data,\n//         );\n\n//         await expect(erc1238UriMock.burnBatchAndDeleteURIs(tokenRecipient.address, tokenBatchIds, burnBatchAmounts))\n//           .to.emit(erc1238UriMock, \"BurnBatch\")\n//           .withArgs(admin.address, tokenRecipient.address, tokenBatchIds, burnBatchAmounts);\n//       });\n\n//       it(\"should delete all token URIs\", async () => {\n//         await erc1238UriMock.mintBatchWithURI(\n//           tokenRecipient.address,\n//           tokenBatchIds,\n//           mintBatchAmounts,\n//           tokenBatchURIs,\n//           data,\n//         );\n\n//         await erc1238UriMock\n//           .connect(admin)\n//           .burnBatchAndDeleteURIs(tokenRecipient.address, tokenBatchIds, burnBatchAmounts);\n\n//         tokenBatchIds.forEach(async id => {\n//           expect(await erc1238UriMock.tokenURI(id)).to.eq(BASE_URI);\n//         });\n//       });\n//     });\n//   });\n// });\n\n",
        "called_code_segment_file_1": "export const IERC1238URIStorage = [\"tokenURI(uint256)\"];",
        "invoking_code_segment_file_2": "const supported = await shouldSupportInterfaces(erc1238Collection, [\"IERC165\", \"IERC1238\", \"IERC1238URIStorage\"]);\n\nexpect(supported).to.eq(true);",
        "invoking_code_segment_file_3": "const tokenURI = \"https://token-cdn-domain/event/exclusive-pass/69\";\nconst mintAmount = toBN(\"58319\");\nconst burnAmount = toBN(\"987\");\n\nawait erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\nexpect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);",
        "new_file_code_segment": "export const IERC1238URIStorageExtended = [\"tokenURIExtended(uint256)\"];\n\nexport const getExtendedTokenURI = async (contract, tokenId) => {\n  return await contract.tokenURIExtended(tokenId);\n};",
        "feature_description": "Add an extended token URI function to support additional metadata.",
        "detailed_feature_description": "The new feature extends the existing token URI functionality by adding a new function `tokenURIExtended` that can handle additional metadata. This function is implemented in a new file (#file 4) and is invoked from #file 1. #file 2 and #file 3 are updated to handle this new functionality, ensuring compatibility across all interactions.",
        "modified_complete_code": {
            "#file 1": "export const IERC1238URIStorage = [\"tokenURI(uint256)\"];\n#Modify export const IERC1238URIStorageExtended = [\"tokenURIExtended(uint256)\"];",
            "#file 2": "const supported = await shouldSupportInterfaces(erc1238Collection, [\"IERC165\", \"IERC1238\", \"IERC1238URIStorage\", \"IERC1238URIStorageExtended\"]);\n\nexpect(supported).to.eq(true);",
            "#file 3": "const tokenURI = \"https://token-cdn-domain/event/exclusive-pass/69\";\nconst mintAmount = toBN(\"58319\");\nconst burnAmount = toBN(\"987\");\n\nawait erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\nexpect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);\n#Modify expect(await erc1238UriMock.tokenURIExtended(tokenId)).to.eq(tokenURI + \"-extended\");",
            "#file 4": "export const IERC1238URIStorageExtended = [\"tokenURIExtended(uint256)\"];\n\nexport const getExtendedTokenURI = async (contract, tokenId) => {\n  return await contract.tokenURIExtended(tokenId);\n};"
        }
    },
    {
        "repo": "Share-IITK2",
        "content": "'Share-IITK2/src/app/search.service.ts'\n:import {Http} from '@angular/http';\nimport {Observable} from 'rxjs/Rx';\nimport {Injectable, Input} from '@angular/core';\n@Injectable()\n\nexport class SearchService {\n    @Input() _searchurl;\n\n    constructor(private _http: Http) {\n        console.log(new Observable);\n    }\n\n    getSearchResult() {\n        return this._http.get(this._searchurl)\n            .map(res => res.json());\n    }\n    \n}\n'Share-IITK2/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule,ReactiveFormsModule } from '@angular/forms';\nimport { HttpModule } from '@angular/http';\nimport { FavoriteComponent } from './favorite.component';\n\nimport { AppComponent } from './app.component';\nimport { CoursesService} from './courses.service';\nimport { SearchComponent} from './search.component';\nimport { SearchService } from './search.service';\nimport {UploadComponent} from './upload.component';\nimport { FileSelectDirective, FileDropDirective} from 'ng2-file-upload';\n\nimport {DashboardComponent} from './dashboard.component';\n\n\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    SearchComponent,\n    UploadComponent,\n    FileSelectDirective,\n    FileDropDirective,\n    DashboardComponent,\n    FavoriteComponent\n    \n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    ReactiveFormsModule,\n    HttpModule\n],\n  providers: [CoursesService,SearchService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'Share-IITK2/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n",
        "called_code_segment_file_1": "getSearchResult() {\n        return this._http.get(this._searchurl)\n            .map(res => res.json());\n    }",
        "invoking_code_segment_file_2": "this._searchService.getSearchResult().subscribe(result => {\n            this.searchResult = result;\n        });",
        "invoking_code_segment_file_3": "// No direct invocation of #file 1 in #file 3",
        "new_file_code_segment": "export class AdvancedSearchService {\n    constructor(private _http: Http) {}\n\n    getAdvancedSearchResult(query: string) {\n        return this._http.get(`/api/advanced-search?query=${query}`)\n            .map(res => res.json());\n    }\n}",
        "feature_description": "Add an advanced search feature that allows users to perform more complex queries.",
        "detailed_feature_description": "The new feature introduces an AdvancedSearchService in #file 4, which provides a method to perform advanced search queries. This service is integrated into the existing SearchService in #file 1, and the SearchComponent in #file 2 is updated to use this new functionality. The DashboardComponent in #file 3 remains unchanged as it does not directly interact with the search functionality.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport {Http} from '@angular/http';\nimport {Observable} from 'rxjs/Rx';\nimport {Injectable, Input} from '@angular/core';\nimport {AdvancedSearchService} from './advanced-search.service';\n\n@Injectable()\nexport class SearchService {\n    @Input() _searchurl;\n\n    constructor(private _http: Http, private _advancedSearchService: AdvancedSearchService) {\n        console.log(new Observable);\n    }\n\n    getSearchResult() {\n        return this._http.get(this._searchurl)\n            .map(res => res.json());\n    }\n\n    //New\n    getAdvancedSearchResult(query: string) {\n        return this._advancedSearchService.getAdvancedSearchResult(query);\n    }\n}",
            "#file 2": "//Modify\nimport { Component, OnInit } from '@angular/core';\nimport { SearchService } from './search.service';\n\n@Component({\n    selector: 'search',\n    template: `<div *ngIf=\"searchResult\">\n                <h2>Search Result</h2>\n                <p>{{ searchResult | json }}</p>\n              </div>`\n})\nexport class SearchComponent implements OnInit {\n    searchResult;\n\n    constructor(private _searchService: SearchService) {}\n\n    ngOnInit() {\n        this._searchService.getSearchResult().subscribe(result => {\n            this.searchResult = result;\n        });\n\n        //New\n        this._searchService.getAdvancedSearchResult('advanced query').subscribe(result => {\n            console.log('Advanced Search Result:', result);\n        });\n    }\n}",
            "#file 3": "// No changes needed as it does not interact with the search functionality",
            "#file 4": "//New\nimport {Http} from '@angular/http';\nimport {Observable} from 'rxjs/Rx';\nimport {Injectable} from '@angular/core';\n\n@Injectable()\nexport class AdvancedSearchService {\n    constructor(private _http: Http) {}\n\n    getAdvancedSearchResult(query: string) {\n        return this._http.get(`/api/advanced-search?query=${query}`)\n            .map(res => res.json());\n    }\n}"
        }
    },
    {
        "repo": "angular-document-viewer",
        "content": "'angular-document-viewer/demo/app/app.component.ts'\n:import { Component } from '@angular/core';\nimport { viewerType } from 'modules/document-viewer.component';\nimport { getbaseUrl } from 'demo/utils';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  styles: []\n})\nexport class AppComponent {\n  viewers: { name: viewerType; docs: string[]; custom: boolean; acceptedUploadTypes: string; viewerUrl?: string }[] = [\n    {\n      name: 'google', docs: [\n        'https://file-examples-com.github.io/uploads/2017/02/file-sample_100kB.docx',\n        'https://file-examples-com.github.io/uploads/2017/02/file_example_XLSX_50.xlsx',\n        'https://file-examples-com.github.io/uploads/2017/10/file_example_TIFF_1MB.tiff',\n        'https://file-examples-com.github.io/uploads/2017/10/file-example_PDF_500_kB.pdf',\n        `${getbaseUrl()}/assets/file_example_PPT_250kB.ppt`,\n        `${getbaseUrl()}/assets/file_example_PPTX_250kB.pptx`,\n      ], custom: true, acceptedUploadTypes: null\n    },\n    {\n      name: 'office', docs: [\n        'https://file-examples-com.github.io/uploads/2017/02/file-sample_100kB.docx',\n        'https://file-examples-com.github.io/uploads/2017/02/file_example_XLSX_50.xlsx',\n        `${getbaseUrl()}/assets/file_example_PPT_250kB.ppt`,\n        `${getbaseUrl()}/assets/file_example_PPTX_250kB`,\n      ], custom: true, acceptedUploadTypes: null\n    },\n    {\n      name: 'mammoth', docs: [\n        `${getbaseUrl()}/assets/file-sample_100kB.docx`\n      ], custom: false, acceptedUploadTypes: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n    },\n    {\n      name: 'pdf', docs: [\n        `${getbaseUrl()}/assets/file-sample_150kB.pdf`\n      ], custom: false, acceptedUploadTypes: 'application/pdf'\n    },\n    {\n      name: 'url', docs: [\n        // eslint-disable-next-line max-len\n        `https://docs.google.com/document/d/e/2PACX-1vRs3gemrszDinuGJCi_wO2m5XVP1q2SlRhxM8PAUYc3wu9LFsvteny7l6Rkp695-ruhfn3gWXV03yXC/pub?embedded=true`\n      ], custom: true, acceptedUploadTypes: null\n    }\n  ];\n  selectedViewer = this.viewers[0];\n  selectedDoc = this.selectedViewer.docs[0];\n\n  constructor() { }\n  selectViewer(viewerName: viewerType) {\n    if (viewerName !== this.selectViewer.name) {\n      this.selectedViewer = this.viewers.find(v => v.name === viewerName);\n      this.selectedDoc = this.selectedViewer.docs[0];\n    }\n  }\n\n  getDocExtension(doc: string) {\n    const splittedDoc = doc.split('.');\n    return splittedDoc[splittedDoc.length - 1];\n  }\n\n  handleFiles(fileInput: any) {\n    if (fileInput.target.files && fileInput.target.files[0]) {\n      const reader = new FileReader();\n\n      reader.onload = (e: any) => {\n        this.selectedDoc = e.target.result;\n      };\n      reader.readAsDataURL(fileInput.target.files[0]);\n    }\n  }\n\n}\n\n'angular-document-viewer/demo/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\nimport { NgxDocViewerModule } from 'modules';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    NgxDocViewerModule,\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'angular-document-viewer/demo/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "getDocExtension(doc: string) {\n    const splittedDoc = doc.split('.');\n    return splittedDoc[splittedDoc.length - 1];\n  }",
        "invoking_code_segment_file_2": "selectViewer(viewerName: viewerType) {\n    if (viewerName !== this.selectViewer.name) {\n      this.selectedViewer = this.viewers.find(v => v.name === viewerName);\n      this.selectedDoc = this.selectedViewer.docs[0];\n    }\n  }",
        "invoking_code_segment_file_3": "handleFiles(fileInput: any) {\n    if (fileInput.target.files && fileInput.target.files[0]) {\n      const reader = new FileReader();\n\n      reader.onload = (e: any) => {\n        this.selectedDoc = e.target.result;\n      };\n      reader.readAsDataURL(fileInput.target.files[0]);\n    }\n  }",
        "new_file_code_segment": "export function getFileSize(file: File): number {\n  return file.size;\n}",
        "feature_description": "Add a feature to display the file size when a file is uploaded.",
        "detailed_feature_description": "The new feature involves displaying the size of the uploaded file in bytes. This is achieved by adding a new function `getFileSize` in a new file (#file 4) which returns the size of the file. The `handleFiles` function in #file 3 is updated to invoke this new function and store the file size. The `AppComponent` in #file 1 is modified to include a new property `fileSize` to store and display the file size.",
        "modified_complete_code": {
            "app.component.ts": "import { Component } from '@angular/core';\nimport { viewerType } from 'modules/document-viewer.component';\nimport { getbaseUrl } from 'demo/utils';\nimport { getFileSize } from './file-utils'; // #New\n\n@Component({\n  selector: 'app-root',\n  templateUrl: 'app.component.html',\n  styles: []\n})\nexport class AppComponent {\n  viewers: { name: viewerType; docs: string[]; custom: boolean; acceptedUploadTypes: string; viewerUrl?: string }[] = [\n    {\n      name: 'google', docs: [\n        'https://file-examples-com.github.io/uploads/2017/02/file-sample_100kB.docx',\n        'https://file-examples-com.github.io/uploads/2017/02/file_example_XLSX_50.xlsx',\n        'https://file-examples-com.github.io/uploads/2017/10/file_example_TIFF_1MB.tiff',\n        'https://file-examples-com.github.io/uploads/2017/10/file-example_PDF_500_kB.pdf',\n        `${getbaseUrl()}/assets/file_example_PPT_250kB.ppt`,\n        `${getbaseUrl()}/assets/file_example_PPTX_250kB.pptx`,\n      ], custom: true, acceptedUploadTypes: null\n    },\n    {\n      name: 'office', docs: [\n        'https://file-examples-com.github.io/uploads/2017/02/file-sample_100kB.docx',\n        'https://file-examples-com.github.io/uploads/2017/02/file_example_XLSX_50.xlsx',\n        `${getbaseUrl()}/assets/file_example_PPT_250kB.ppt`,\n        `${getbaseUrl()}/assets/file_example_PPTX_250kB`,\n      ], custom: true, acceptedUploadTypes: null\n    },\n    {\n      name: 'mammoth', docs: [\n        `${getbaseUrl()}/assets/file-sample_100kB.docx`\n      ], custom: false, acceptedUploadTypes: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\n    },\n    {\n      name: 'pdf', docs: [\n        `${getbaseUrl()}/assets/file-sample_150kB.pdf`\n      ], custom: false, acceptedUploadTypes: 'application/pdf'\n    },\n    {\n      name: 'url', docs: [\n        // eslint-disable-next-line max-len\n        `https://docs.google.com/document/d/e/2PACX-1vRs3gemrszDinuGJCi_wO2m5XVP1q2SlRhxM8PAUYc3wu9LFsvteny7l6Rkp695-ruhfn3gWXV03yXC/pub?embedded=true`\n      ], custom: true, acceptedUploadTypes: null\n    }\n  ];\n  selectedViewer = this.viewers[0];\n  selectedDoc = this.selectedViewer.docs[0];\n  fileSize: number; // #New\n\n  constructor() { }\n  selectViewer(viewerName: viewerType) {\n    if (viewerName !== this.selectViewer.name) {\n      this.selectedViewer = this.viewers.find(v => v.name === viewerName);\n      this.selectedDoc = this.selectedViewer.docs[0];\n    }\n  }\n\n  getDocExtension(doc: string) {\n    const splittedDoc = doc.split('.');\n    return splittedDoc[splittedDoc.length - 1];\n  }\n\n  handleFiles(fileInput: any) {\n    if (fileInput.target.files && fileInput.target.files[0]) {\n      const reader = new FileReader();\n\n      reader.onload = (e: any) => {\n        this.selectedDoc = e.target.result;\n      };\n      reader.readAsDataURL(fileInput.target.files[0]);\n      this.fileSize = getFileSize(fileInput.target.files[0]); // #Modify\n    }\n  }\n}",
            "app.module.ts": "import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\nimport { NgxDocViewerModule } from 'modules';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    NgxDocViewerModule,\n    BrowserModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
            "main.ts": "import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));",
            "file-utils.ts": "// #New\nexport function getFileSize(file: File): number {\n  return file.size;\n}"
        }
    },
    {
        "repo": "angular-template-2.0",
        "content": "'angular-template-2.0/client/modules/heroes/heroes.component.ts'\n:import {Component, OnInit} from 'angular2/core';\nimport { Router } from 'angular2/router';\n\nimport {Hero} from '../common/hero';\nimport {HeroDetailComponent} from '../details/details.component';\n\nimport {HeroService} from '../common/heroes.service'\n\n@Component({\n    selector: 'heroes',\n    templateUrl: 'client/modules/heroes/heroes.html',\n    styleUrls: [`client/modules/heroes/heroes.css`],\n    directives: [HeroDetailComponent],\n    providers: [HeroService]\n})\n\nexport class HeroesComponent implements OnInit {\n    heroes: Hero[];\n    selectedHero: Hero;\n    constructor(\n        private _router: Router,\n        private _heroService: HeroService) { }\n    getHeroes() {\n        this._heroService.getHeroes().then(heroes => this.heroes = heroes);\n    }\n    ngOnInit() {\n        this.getHeroes();\n    }\n    onSelect(hero: Hero) { this.selectedHero = hero; }\n    gotoDetail() {\n        this._router.navigate(['HeroDetail', { id: this.selectedHero.id }]);\n    }\n}\n\n'angular-template-2.0/client/modules/app/app.component.ts'\n:import {Component}       from 'angular2/core';\nimport { RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS } from 'angular2/router';\n\nimport {HeroesComponent} from '../heroes/heroes.component';\nimport {DashboardComponent} from '../dashboard/dashboard.component';\nimport {HeroDetailComponent} from '../details/details.component';\n\nimport {HeroService} from '../common/heroes.service'\n\n@Component({\n    selector: 'app',\n    templateUrl: 'client/modules/app/app.html',\n    styleUrls: [`client/modules/app/app.css`],\n    directives: [ROUTER_DIRECTIVES],\n    providers: [ROUTER_PROVIDERS, HeroService]\n})\n\n@RouteConfig([\n    {\n        path: '/heroes',\n        name: 'Heroes',\n        component: HeroesComponent\n    },\n    {\n        path: '/dashboard',\n        name: 'Dashboard',\n        component: DashboardComponent,\n        useAsDefault: true\n    }, \n    {\n        path: '/detail/:id',\n        name: 'HeroDetail',\n        component: HeroDetailComponent\n    },\n\n])\nexport class AppComponent {\n    title = 'Tour of Heroes';\n}\n'angular-template-2.0/client/app.ts'\n:import {bootstrap}    from 'angular2/platform/browser'\nimport {AppComponent} from './modules/app/app.component'\n\nbootstrap(AppComponent);\n\n",
        "called_code_segment_file_1": "getHeroes() {\n    this._heroService.getHeroes().then(heroes => this.heroes = heroes);\n}",
        "invoking_code_segment_file_2": "ngOnInit() {\n    this.getHeroes();\n}",
        "invoking_code_segment_file_3": "constructor(\n    private _router: Router,\n    private _heroService: HeroService) { }",
        "new_file_code_segment": "export class HeroSearchService {\n    constructor(private http: Http) {}\n    search(term: string): Observable<Hero[]> {\n        return this.http.get(`api/heroes/?name=${term}`)\n            .map((r: Response) => r.json().data as Hero[]);\n    }\n}",
        "feature_description": "Add a search functionality to the dashboard to search for heroes by name.",
        "detailed_feature_description": "The new feature involves adding a search bar in the dashboard component. When a user types in the search bar, it will filter the heroes based on the input. The search functionality will be implemented in a new service called HeroSearchService, which will handle the HTTP request to fetch the heroes matching the search term. The dashboard component will use this service to update the displayed heroes dynamically.",
        "modified_complete_code": {
            "file_1": "import {Component, OnInit} from 'angular2/core';\nimport { Router } from 'angular2/router';\n\nimport {Hero} from '../common/hero';\nimport {HeroDetailComponent} from '../details/details.component';\nimport {HeroSearchService} from '../common/hero-search.service'; #New\n\nimport {HeroService} from '../common/heroes.service'\n\n@Component({\n    selector: 'heroes',\n    templateUrl: 'client/modules/heroes/heroes.html',\n    styleUrls: [`client/modules/heroes/heroes.css`],\n    directives: [HeroDetailComponent],\n    providers: [HeroService, HeroSearchService] #Modify\n})\nexport class HeroesComponent implements OnInit {\n    heroes: Hero[];    selectedHero: Hero;\n    constructor(\n        private _router: Router,\n        private _heroService: HeroService) { }    getHeroes() {\n        this._heroService.getHeroes().then(heroes => this.heroes = heroes);\n    }\n    ngOnInit() {\n        this.getHeroes();\n    }\n    onSelect(hero: Hero) { this.selectedHero = hero; }    gotoDetail() {\n        this._router.navigate(['HeroDetail', { id: this.selectedHero.id }]);\n    }\n}",
            "file_2": "import {Component, OnInit} from 'angular2/core';\nimport { Router } from 'angular2/router';\n\nimport {Hero} from '../common/hero';\nimport {HeroSearchService} from '../common/hero-search.service'; #New\n\nimport {HeroService} from '../common/heroes.service'\n\n@Component({\n    selector: 'dashboard',\n    templateUrl: 'client/modules/dashboard/dashboard.html',\n    styleUrls: [`client/modules/dashboard/dashboard.css`],\n    providers: [HeroService, HeroSearchService] #Modify\n})\nexport class DashboardComponent implements OnInit {\n    heroes: Hero[] = [];    constructor(\n        private _router: Router,\n        private _heroService: HeroService,\n        private _heroSearchService: HeroSearchService) { } #Modify\n    ngOnInit() {\n        this._heroService.getHeroes()\n            .then(heroes => this.heroes = heroes.slice(1, 5));\n    }\n    gotoDetail(hero: Hero) {\n        let link = ['HeroDetail', { id: hero.id }];\n        this._router.navigate(link);\n    }\n    search(term: string) {\n        this._heroSearchService.search(term).subscribe(heroes => this.heroes = heroes); #New\n    }\n}",
            "file_3": "import {Component} from 'angular2/core';\nimport { RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS } from 'angular2/router';\n\nimport {HeroesComponent} from '../heroes/heroes.component';\nimport {DashboardComponent} from '../dashboard/dashboard.component';\nimport {HeroDetailComponent} from '../details/details.component';\n\nimport {HeroService} from '../common/heroes.service'\n\n@Component({\n    selector: 'app',\n    templateUrl: 'client/modules/app/app.html',\n    styleUrls: [`client/modules/app/app.css`],\n    directives: [ROUTER_DIRECTIVES],\n    providers: [ROUTER_PROVIDERS, HeroService]\n})\n@RouteConfig([\n    { path: '/heroes', name: 'Heroes', component: HeroesComponent },\n    { path: '/dashboard', name: 'Dashboard', component: DashboardComponent, useAsDefault: true },\n    { path: '/detail/:id', name: 'HeroDetail', component: HeroDetailComponent },\n])\nexport class AppComponent {\n    title = 'Tour of Heroes';\n}",
            "file_4": "import {Injectable} from 'angular2/core';\nimport {Http, Response} from 'angular2/http';\nimport {Observable} from 'rxjs/Observable';\nimport {Hero} from '../common/hero';\n\n@Injectable()\nexport class HeroSearchService {\n    constructor(private http: Http) {}\n    search(term: string): Observable<Hero[]> {\n        return this.http.get(`api/heroes/?name=${term}`)\n            .map((r: Response) => r.json().data as Hero[]);\n    }\n}"
        }
    },
    {
        "repo": "angular2-redux-store",
        "content": "'angular2-redux-store/example/src/store/todoActions.ts'\n:\nimport {List} from 'immutable';\nimport {Todo} from \"../Todo\";\n\nexport const LOAD_TODOS = \"LOAD_TODOS\";\nexport const ADD_TODO = \"ADD_TODO\";\nexport const TOGGLE_TODO = \"TOGGLE_TODO\";\nexport const DELETE_TODO = \"DELETE_TODO\";\nexport const BACKEND_ACTION_STARTED=\"BACKEND_ACTION_STARTED\";\nexport const BACKEND_ACTION_FINISHED=\"BACKEND_ACTION_FINISHED\";\n\n\nexport function loadTodos(todos: List<Todo>) {\n    return {\n        type: LOAD_TODOS,\n        todos: todos\n    }\n}\n\nexport function addTodo(newTodo: Todo) {\n    return {\n        type: ADD_TODO,\n        newTodo\n    }\n}\n\nexport function toggleTodo(todo: Todo) {\n    return {\n        type: TOGGLE_TODO,\n        todo\n    }\n}\n\nexport function deleteTodo(todo: Todo) {\n    return {\n        type: DELETE_TODO,\n        todo\n    }\n}\n\nexport function startBackendAction(message: string) {\n    return {\n        type: BACKEND_ACTION_STARTED,\n        message\n    }\n}\n\nexport function endBackendAction(message:string = '') {\n    return {\n        type: BACKEND_ACTION_FINISHED\n    }\n}\n\n'angular2-redux-store/example/src/TodoList.ts'\n:import {Component,Input,Output, EventEmitter,ChangeDetectionStrategy} from 'angular2/core';\nimport {Todo} from \"./Todo\";\nimport {List} from 'immutable';\nimport {TodoService} from \"./TodoService\";\nimport {TodoStore} from \"./store/TodoStore\";\nimport {toggleTodo, deleteTodo} from './store/todoActions';\n\n\n@Component({\n    selector: 'todo-list',\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: `\n\n        <section id=\"main\" [hidden]=\"todos.size === 0\">\n            <label for=\"toggle-all\">Mark all as complete</label>\n            <ul id=\"todo-list\">\n                <li *ngFor=\"#todo of todos;\" [ngClass]=\"{completed: todo.completed}\">\n                    <div class=\"view\">\n                        <input class=\"toggle\" type=\"checkbox\" (change)=\"onToggleTodo(todo)\" [checked]=\"todo.completed\">\n                        <label>{{todo.description}}</label>\n                        <button class=\"destroy\" (click)=\"delete(todo)\"></button>\n                    </div>\n                </li>\n            </ul>\n        </section>\n    `\n})\nexport class TodoList {\n\n    @Input() todos: List<Todo>;\n    @Output()  toggleAll: EventEmitter<any> = new EventEmitter();\n    @Output()  deleteTodo: EventEmitter<any> = new EventEmitter();\n\n    constructor(private todoService: TodoService, private store: TodoStore) {\n\n    }\n\n    onToggleTodo(todo: Todo) {\n\n        this.store.dispatch(toggleTodo(todo));\n\n        this.todoService.toggleTodo(todo)\n            .subscribe(\n                res => console.log('todo toggled successfully'),\n                err => console.log('error toggling todo')\n            );\n    }\n\n    delete(todo:Todo) {\n        this.store.dispatch(deleteTodo(todo));\n\n        this.todoService.deleteTodo(todo)\n            .subscribe(\n                res => console.log('todo toggled successfully'),\n                err => console.log('error toggling todo')\n            );\n\n    }\n\n}\n'angular2-redux-store/example/src/App.ts'\n:\n/// <reference path=\"../jspm_packages/npm/immutable@3.7.5/dist/immutable.d.ts\" />\n\nimport  'reflect-metadata';\nimport {Component} from 'angular2/core';\nimport {bootstrap} from 'angular2/platform/browser';\nimport {HTTP_PROVIDERS} from 'angular2/http';\nimport {Header} from './Header';\nimport {TodoList} from './TodoList';\nimport {Todo} from \"./Todo\";\nimport {Footer} from \"./Footer\";\nimport {TodoService} from \"./TodoService\";\nimport {TodoStore} from \"./store/TodoStore\";\nimport {loadTodos, addTodo,startBackendAction, endBackendAction} from './store/todoActions';\nimport {List} from 'immutable';\n\n@Component({\n    selector: 'app',\n    directives: [Header, TodoList, Footer],\n    template: `\n        <div>\n            <section id=\"todoapp\">\n\n                <todo-header (todo)=\"onAddTodo($event)\"></todo-header>\n\n                <todo-list [todos]=\"store.getState().todos\"></todo-list>\n\n                <todo-footer [hidden]=\"store.getState().todos.size === 0\" [count]=\"store.getState().todos.size\"></todo-footer>\n\n            </section>\n            <footer id=\"info\">\n                <p>{{store.getState().uiState.message}}</p>\n                <p>Add, Remove and Complete TODOs</p>\n            </footer>\n        </div>\n    `\n})\nexport class App {\n\n    constructor(private store: TodoStore, private todoService: TodoService) {\n\n        todoService.getAllTodos()\n            .subscribe(\n                res => {\n                    let todos = (<Object[]>res.json()).map((todo: any) =>\n                        new Todo({id:todo.id, description:todo.description,completed: todo.completed}));\n\n                    store.dispatch(loadTodos(List(todos)));\n                },\n                err => console.log(\"Error retrieving Todos\")\n            );\n\n        store.subscribe(\n            state => console.log('new state received ')\n        );\n    }\n\n    onAddTodo(description) {\n        let newTodo = new Todo({id:Math.random(), description});\n\n        this.store.dispatch(startBackendAction('Saving Todo...'));\n\n        this.todoService.saveTodo(newTodo)\n            .subscribe(\n                res => {\n                    this.store.dispatch(addTodo(newTodo));\n                    this.store.dispatch(endBackendAction());\n                },\n                err => {\n                    this.store.dispatch(endBackendAction('Error occurred: '));\n                }\n            );\n    }\n\n}\n\nbootstrap(App, [\n    HTTP_PROVIDERS,\n    TodoService,\n    TodoStore\n]);\n",
        "called_code_segment_file_1": "export function toggleTodo(todo: Todo) {\n    return {\n        type: TOGGLE_TODO,\n        todo\n    }\n}",
        "invoking_code_segment_file_2": "onToggleTodo(todo: Todo) {\n    this.store.dispatch(toggleTodo(todo));\n    this.todoService.toggleTodo(todo)\n        .subscribe(\n            res => console.log('todo toggled successfully'),\n            err => console.log('error toggling todo')\n        );\n}",
        "invoking_code_segment_file_3": "constructor(private store: TodoStore, private todoService: TodoService) {\n    todoService.getAllTodos()\n        .subscribe(\n            res => {\n                let todos = (<Object[]>res.json()).map((todo: any) =>\n                    new Todo({id:todo.id, description:todo.description,completed: todo.completed}));\n                store.dispatch(loadTodos(List(todos)));\n            },\n            err => console.log(\"Error retrieving Todos\")\n        );\n    store.subscribe(\n        state => console.log('new state received ')\n    );\n}",
        "new_file_code_segment": "export function logTodoAction(actionType: string, todo: Todo) {\n    console.log(`Action ${actionType} performed on Todo: ${todo.description}`);\n}",
        "feature_description": "Add logging for each todo action.",
        "detailed_feature_description": "The new feature involves adding logging for each todo action. This will help in tracking the actions performed on todos. A new function `logTodoAction` is created in a new file (#file 4) to handle the logging. This function will be invoked in #file 1 where the actions are defined. The invoking code segments in #file 2 and #file 3 will be updated to call this new logging function.",
        "modified_complete_code": {
            "file_1": "import {logTodoAction} from './logTodoActions'; #New\n\nexport function toggleTodo(todo: Todo) {\n    logTodoAction('TOGGLE_TODO', todo); #Modify\n    return {\n        type: TOGGLE_TODO,\n        todo\n    }\n}\n\nexport function addTodo(newTodo: Todo) {\n    logTodoAction('ADD_TODO', newTodo); #Modify\n    return {\n        type: ADD_TODO,\n        newTodo\n    }\n}\n\nexport function deleteTodo(todo: Todo) {\n    logTodoAction('DELETE_TODO', todo); #Modify\n    return {\n        type: DELETE_TODO,\n        todo\n    }\n}",
            "file_2": "import {logTodoAction} from './logTodoActions'; #New\n\nonToggleTodo(todo: Todo) {\n    this.store.dispatch(toggleTodo(todo));\n    logTodoAction('TOGGLE_TODO', todo); #Modify\n    this.todoService.toggleTodo(todo)\n        .subscribe(\n            res => console.log('todo toggled successfully'),\n            err => console.log('error toggling todo')\n        );\n}\n\ndelete(todo:Todo) {\n    this.store.dispatch(deleteTodo(todo));\n    logTodoAction('DELETE_TODO', todo); #Modify\n    this.todoService.deleteTodo(todo)\n        .subscribe(\n            res => console.log('todo toggled successfully'),\n            err => console.log('error toggling todo')\n        );\n}",
            "file_3": "import {logTodoAction} from './logTodoActions'; #New\n\nconstructor(private store: TodoStore, private todoService: TodoService) {\n    todoService.getAllTodos()\n        .subscribe(\n            res => {\n                let todos = (<Object[]>res.json()).map((todo: any) =>\n                    new Todo({id:todo.id, description:todo.description,completed: todo.completed}));\n                store.dispatch(loadTodos(List(todos)));\n                logTodoAction('LOAD_TODOS', new Todo({id: -1, description: 'Loaded Todos', completed: false})); #Modify\n            },\n            err => console.log(\"Error retrieving Todos\")\n        );\n    store.subscribe(\n        state => console.log('new state received ')\n    );\n}\n\nonAddTodo(description) {\n    let newTodo = new Todo({id:Math.random(), description});\n    this.store.dispatch(startBackendAction('Saving Todo...'));\n    logTodoAction('ADD_TODO', newTodo); #Modify\n    this.todoService.saveTodo(newTodo)\n        .subscribe(\n            res => {\n                this.store.dispatch(addTodo(newTodo));\n                this.store.dispatch(endBackendAction());\n            },\n            err => {\n                this.store.dispatch(endBackendAction('Error occurred: '));\n            }\n        );\n}",
            "file_4": "export function logTodoAction(actionType: string, todo: Todo) {\n    console.log(`Action ${actionType} performed on Todo: ${todo.description}`);\n}"
        }
    },
    {
        "repo": "chatgpt-minimal",
        "content": "'chatgpt-minimal/src/components/ChatGPT/interface.ts'\n:import type { ReactNode } from 'react'\n\nexport enum ChatRole {\n  Assistant = 'assistant',\n  User = 'user',\n  System = 'system'\n}\n\nexport interface ChatGPTProps {\n  fetchPath: string\n}\n\nexport interface ChatMessage {\n  content: string\n  role: ChatRole\n}\n\nexport interface ChatMessageItemProps {\n  message: ChatMessage\n}\n\nexport interface SendBarProps {\n  loading: boolean\n  disabled: boolean\n  onSend: (message: ChatMessage) => void\n  onClear: () => void\n  onStop: () => void\n}\n\nexport interface ShowProps {\n  loading?: boolean\n  fallback?: ReactNode\n  children?: ReactNode\n}\n\n'chatgpt-minimal/src/components/ChatGPT/SendBar.tsx'\n:import React, { KeyboardEventHandler, useRef } from 'react'\n\nimport { ClearOutlined, SendOutlined } from '@ant-design/icons'\n\nimport { ChatRole, SendBarProps } from './interface'\nimport Show from './Show'\n\nconst SendBar = (props: SendBarProps) => {\n  const { loading, disabled, onSend, onClear, onStop } = props\n\n  const inputRef = useRef<HTMLTextAreaElement>(null)\n\n  const onInputAutoSize = () => {\n    if (inputRef.current) {\n      inputRef.current.style.height = 'auto'\n      inputRef.current.style.height = inputRef.current.scrollHeight + 'px'\n    }\n  }\n\n  const handleClear = () => {\n    if (inputRef.current) {\n      inputRef.current.value = ''\n      inputRef.current.style.height = 'auto'\n      onClear()\n    }\n  }\n\n  const handleSend = () => {\n    const content = inputRef.current?.value\n    if (content) {\n      inputRef.current!.value = ''\n      inputRef.current!.style.height = 'auto'\n      onSend({\n        content,\n        role: ChatRole.User\n      })\n    }\n  }\n\n  const onKeydown: KeyboardEventHandler<HTMLTextAreaElement> = (e) => {\n    if (e.shiftKey) {\n      return\n    }\n\n    if (e.key === 'Enter' && !e.nativeEvent.isComposing) {\n      handleSend()\n    }\n  }\n\n  return (\n    <Show\n      fallback={\n        <div className=\"thinking\">\n          <span>Please wait ...</span>\n          <div className=\"stop\" onClick={onStop}>\n            Stop\n          </div>\n        </div>\n      }\n      loading={loading}\n    >\n      <div className=\"send-bar\">\n        <textarea\n          ref={inputRef!}\n          className=\"input\"\n          disabled={disabled}\n          placeholder=\"Shift + Enter for new line\"\n          autoComplete=\"off\"\n          rows={1}\n          onKeyDown={onKeydown}\n          onInput={onInputAutoSize}\n        />\n        <button className=\"button\" title=\"Send\" disabled={disabled} onClick={handleSend}>\n          <SendOutlined />\n        </button>\n        <button className=\"button\" title=\"Clear\" disabled={disabled} onClick={handleClear}>\n          <ClearOutlined />\n        </button>\n      </div>\n    </Show>\n  )\n}\n\nexport default SendBar\n\n'chatgpt-minimal/src/components/ChatGPT/index.tsx'\n:import React from 'react'\n\nimport { ChatGPTProps, ChatRole } from './interface'\nimport MessageItem from './MessageItem'\nimport SendBar from './SendBar'\nimport { useChatGPT } from './useChatGPT'\n\nimport './index.less'\nimport 'highlight.js/styles/atom-one-dark.css'\n\nconst ChatGPT = (props: ChatGPTProps) => {\n  const { loading, disabled, messages, currentMessage, onSend, onClear, onStop } = useChatGPT(props)\n\n  return (\n    <div className=\"chat-wrapper\">\n      {messages.map((message, index) => (\n        <MessageItem key={index} message={message} />\n      ))}\n      {currentMessage.current && (\n        <MessageItem message={{ content: currentMessage.current, role: ChatRole.Assistant }} />\n      )}\n      <SendBar\n        loading={loading}\n        disabled={disabled}\n        onSend={onSend}\n        onClear={onClear}\n        onStop={onStop}\n      />\n    </div>\n  )\n}\n\nexport default ChatGPT\n\n",
        "called_code_segment_file_1": "const onKeydown: KeyboardEventHandler<HTMLTextAreaElement> = (e) => {\n    if (e.shiftKey) {\n      return\n    }\n\n    if (e.key === 'Enter' && !e.nativeEvent.isComposing) {\n      handleSend()\n    }\n  }",
        "invoking_code_segment_file_2": "<textarea\n          ref={inputRef!}\n          className=\"input\"\n          disabled={disabled}\n          placeholder=\"Shift + Enter for new line\"\n          autoComplete=\"off\"\n          rows={1}\n          onKeyDown={onKeydown}\n          onInput={onInputAutoSize}\n        />",
        "invoking_code_segment_file_3": "const { loading, disabled, messages, currentMessage, onSend, onClear, onStop } = useChatGPT(props)",
        "new_file_code_segment": "const useTypingEffect = (message: string) => {\n  const [displayedMessage, setDisplayedMessage] = useState('')\n  const [index, setIndex] = useState(0)\n\n  useEffect(() => {\n    if (index < message.length) {\n      const timeout = setTimeout(() => {\n        setDisplayedMessage(prev => prev + message[index])\n        setIndex(prev => prev + 1)\n      }, 50)\n      return () => clearTimeout(timeout)\n    }\n  }, [index, message])\n\n  return displayedMessage\n}",
        "feature_description": "Add a typing effect for assistant messages.",
        "detailed_feature_description": "The new feature introduces a typing effect for assistant messages to make the chat experience more interactive. The typing effect is implemented in a new hook `useTypingEffect` in #file 4. This hook is then used in #file 1 to animate the display of assistant messages. The `MessageItem` component in #file 1 is updated to use this hook, and the `useChatGPT` hook in #file 3 is modified to handle the new typing effect.",
        "modified_complete_code": {
            "#file 1": "import React, { KeyboardEventHandler, useRef, useState, useEffect } from 'react'\n\nimport { ClearOutlined, SendOutlined } from '@ant-design/icons'\n\nimport { ChatRole, SendBarProps } from './interface'\nimport Show from './Show'\nimport { useTypingEffect } from './useTypingEffect'\n\nconst SendBar = (props: SendBarProps) => {\n  const { loading, disabled, onSend, onClear, onStop } = props\n\n  const inputRef = useRef<HTMLTextAreaElement>(null)\n\n  const onInputAutoSize = () => {\n    if (inputRef.current) {\n      inputRef.current.style.height = 'auto'\n      inputRef.current.style.height = inputRef.current.scrollHeight + 'px'\n    }\n  }\n\n  const handleClear = () => {\n    if (inputRef.current) {\n      inputRef.current.value = ''\n      inputRef.current.style.height = 'auto'\n      onClear()\n    }\n  }\n\n  const handleSend = () => {\n    const content = inputRef.current?.value\n    if (content) {\n      inputRef.current!.value = ''\n      inputRef.current!.style.height = 'auto'\n      onSend({\n        content,\n        role: ChatRole.User\n      })\n    }\n  }\n\n  const onKeydown: KeyboardEventHandler<HTMLTextAreaElement> = (e) => {\n    if (e.shiftKey) {\n      return\n    }\n\n    if (e.key === 'Enter' && !e.nativeEvent.isComposing) {\n      handleSend()\n    }\n  }\n\n  return (\n    <Show\n      fallback={<div className=\"thinking\"><span>Please wait ...</span><div className=\"stop\" onClick={onStop}>Stop</div></div>}\n      loading={loading}\n    >\n      <div className=\"send-bar\">\n        <textarea\n          ref={inputRef!}\n          className=\"input\"\n          disabled={disabled}\n          placeholder=\"Shift + Enter for new line\"\n          autoComplete=\"off\"\n          rows={1}\n          onKeyDown={onKeydown}\n          onInput={onInputAutoSize}\n        />\n        <button className=\"button\" title=\"Send\" disabled={disabled} onClick={handleSend}><SendOutlined /></button>\n        <button className=\"button\" title=\"Clear\" disabled={disabled} onClick={handleClear}><ClearOutlined /></button>\n      </div>\n    </Show>\n  )\n}\n\n#New\nconst MessageItem = ({ message }: ChatMessageItemProps) => {\n  const displayedMessage = useTypingEffect(message.content)\n  return (\n    <div className={`message ${message.role}`}>\n      <div className=\"content\">{displayedMessage}</div>\n    </div>\n  )\n}\n\nexport default SendBar",
            "#file 2": "import React from 'react'\n\nimport { ChatGPTProps, ChatRole } from './interface'\nimport MessageItem from './MessageItem'\nimport SendBar from './SendBar'\nimport { useChatGPT } from './useChatGPT'\n\nimport './index.less'\nimport 'highlight.js/styles/atom-one-dark.css'\n\nconst ChatGPT = (props: ChatGPTProps) => {\n  const { loading, disabled, messages, currentMessage, onSend, onClear, onStop } = useChatGPT(props)\n\n  return (\n    <div className=\"chat-wrapper\">\n      {messages.map((message, index) => (\n        <MessageItem key={index} message={message} />\n      ))}\n      {currentMessage.current && (\n        <MessageItem message={{ content: currentMessage.current, role: ChatRole.Assistant }} />\n      )}\n      <SendBar\n        loading={loading}\n        disabled={disabled}\n        onSend={onSend}\n        onClear={onClear}\n        onStop={onStop}\n      />\n    </div>\n  )\n}\n\nexport default ChatGPT",
            "#file 3": "import { useState, useEffect, useRef } from 'react'\nimport { ChatGPTProps, ChatMessage, ChatRole } from './interface'\n\n#Modify\nexport const useChatGPT = (props: ChatGPTProps) => {\n  const [loading, setLoading] = useState(false)\n  const [disabled, setDisabled] = useState(false)\n  const [messages, setMessages] = useState<ChatMessage[]>([])\n  const currentMessage = useRef<string>('')\n\n  const onSend = async (message: ChatMessage) => {\n    setMessages(prev => [...prev, message])\n    setLoading(true)\n    setDisabled(true)\n\n    const response = await fetch(props.fetchPath, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(message)\n    })\n\n    const reader = response.body.getReader()\n    const decoder = new TextDecoder('utf-8')\n    let buffer = ''\n\n    while (true) {\n      const { done, value } = await reader.read()\n      if (done) {\n        break\n      }\n\n      buffer += decoder.decode(value, { stream: true })\n      currentMessage.current = buffer\n    }\n\n    setMessages(prev => [...prev, { content: buffer, role: ChatRole.Assistant }])\n    currentMessage.current = ''\n    setLoading(false)\n    setDisabled(false)\n  }\n\n  const onClear = () => {\n    setMessages([])\n  }\n\n  const onStop = () => {\n    setLoading(false)\n    setDisabled(false)\n  }\n\n  return {\n    loading,\n    disabled,\n    messages,\n    currentMessage,\n    onSend,\n    onClear,\n    onStop\n  }\n}",
            "#file 4": "import { useState, useEffect } from 'react'\n\n#New\nexport const useTypingEffect = (message: string) => {\n  const [displayedMessage, setDisplayedMessage] = useState('')\n  const [index, setIndex] = useState(0)\n\n  useEffect(() => {\n    if (index < message.length) {\n      const timeout = setTimeout(() => {\n        setDisplayedMessage(prev => prev + message[index])\n        setIndex(prev => prev + 1)\n      }, 50)\n      return () => clearTimeout(timeout)\n    }\n  }, [index, message])\n\n  return displayedMessage\n}"
        }
    },
    {
        "repo": "docs-starter",
        "content": "'docs-starter/app/components/heading.tsx'\n:import { slugify } from '~/utils/slugify';\n\ntype HeadingProps = {\n  as: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n  children: any;\n};\n\nexport function Heading({ as, children }: HeadingProps) {\n  const Component = `${as}` as keyof JSX.IntrinsicElements;\n\n  let title = children?.props?.parent.children;\n\n  if (typeof title === `object`) {\n    const parsedTitle = title.map((child: any) => child?.text);\n\n    title = parsedTitle.join(``);\n  }\n\n  const slug = slugify(title);\n\n  return (\n    <Component\n      id={slug}\n      className=\"group relative whitespace-pre-wrap\"\n      style={{\n        scrollMarginTop: `80px`,\n      }}\n    >\n      {children}\n      <a\n        href={`#${slug}`}\n        aria-label=\"Anchor\"\n        className=\"anchor ml-[10px] text-[length:inherit] text-gray-500 !no-underline opacity-0 transition-opacity duration-100 after:text-gray-500 after:content-['#'] group-hover:opacity-100\"\n      >\n        <span className=\"sr-only\">Anchor</span>\n      </a>\n    </Component>\n  );\n}\n\n'docs-starter/app/components/rich-text-view.tsx'\n:import { RichText } from '@graphcms/rich-text-react-renderer';\nimport { EmbedReferences, EmbedProps } from '@graphcms/rich-text-types';\n\nimport type {\n  GetPageQuery,\n  Page,\n  EmbeddedPageFragment,\n} from '~/generated/schema.server';\nimport { Heading } from './heading';\nimport { Link } from './link';\n\ntype PageProps = GetPageQuery['page'];\n\nexport const RichTextView = ({ page }: { page: PageProps }) => {\n  return (\n    <div className=\"prose prose-indigo max-w-none prose-h1:font-light prose-h1:text-indigo-700\">\n      <h1>{page?.title}</h1>\n      <RichText\n        content={page?.content?.json}\n        references={page?.content?.references as EmbedReferences}\n        renderers={{\n          h1: ({ children }) => <Heading as=\"h1\">{children}</Heading>,\n          h2: ({ children }) => <Heading as=\"h2\">{children}</Heading>,\n          h3: ({ children }) => <Heading as=\"h3\">{children}</Heading>,\n          h4: ({ children }) => <Heading as=\"h4\">{children}</Heading>,\n          h5: ({ children }) => <Heading as=\"h5\">{children}</Heading>,\n          h6: ({ children }) => <Heading as=\"h6\">{children}</Heading>,\n          img: ({ height, width, src, title, altText }) => (\n            <img\n              src={src}\n              alt={altText}\n              width={width}\n              height={height}\n              title={title}\n              loading=\"lazy\"\n              className=\"shadow-image\"\n            />\n          ),\n          embed: {\n            Page: ({ slug, title }: EmbedProps<EmbeddedPageFragment>) => (\n              <Link\n                href={`/${slug}`}\n                className=\"flex items-center justify-between rounded border border-gray-200 bg-white p-3 no-underline shadow-image md:p-6\"\n              >\n                <span>{title}</span>\n                <span>&rarr;</span>\n              </Link>\n            ),\n          },\n        }}\n      />\n    </div>\n  );\n};\n\n'docs-starter/app/components/content.tsx'\n:import { useRef } from 'react';\nimport { ClientOnly } from 'remix-utils/client-only';\n\nimport type { GetPageQuery } from '~/generated/schema.server';\nimport { useMarkdownHeadings } from '~/hooks/useMarkdownHeadings';\n\ntype ContentProps = {\n  page: GetPageQuery['page'];\n  disableToc?: boolean;\n};\n\nimport { RichTextView } from './rich-text-view';\nimport { TableOfContents } from './table-of-contents';\n\nexport function Content({ page, disableToc }: ContentProps) {\n  const contentRef = useRef<HTMLDivElement>(null);\n  const { links } = useMarkdownHeadings({\n    content: page?.content?.markdown as string,\n  });\n\n  const hasLinks = links && links?.length > 0;\n\n  return (\n    <div className=\"flex items-start\">\n      <div ref={contentRef} className=\"w-full max-w-[720px] lg:pr-12\">\n        <RichTextView page={page} />\n      </div>\n\n      {hasLinks && !disableToc && (\n        <ClientOnly>\n          {() => (\n            <TableOfContents\n              contentRef={contentRef}\n              links={links}\n              labelText=\"Table of Contents\"\n              className=\"sticky top-32 hidden lg:block\"\n            />\n          )}\n        </ClientOnly>\n      )}\n    </div>\n  );\n}\n\n",
        "called_code_segment_file_1": "export function Heading({ as, children }: HeadingProps) {\n  const Component = `${as}` as keyof JSX.IntrinsicElements;\n\n  let title = children?.props?.parent.children;\n\n  if (typeof title === `object`) {\n    const parsedTitle = title.map((child: any) => child?.text);\n\n    title = parsedTitle.join(``);\n  }\n\n  const slug = slugify(title);\n\n  return (\n    <Component\n      id={slug}\n      className=\"group relative whitespace-pre-wrap\"\n      style={{\n        scrollMarginTop: `80px`,\n      }}\n    >\n      {children}\n      <a\n        href={`#${slug}`}\n        aria-label=\"Anchor\"\n        className=\"anchor ml-[10px] text-[length:inherit] text-gray-500 !no-underline opacity-0 transition-opacity duration-100 after:text-gray-500 after:content-['#'] group-hover:opacity-100\"\n      >\n        <span className=\"sr-only\">Anchor</span>\n      </a>\n    </Component>\n  );\n}",
        "invoking_code_segment_file_2": "<RichText\n  content={page?.content?.json}\n  references={page?.content?.references as EmbedReferences}\n  renderers={{\n    h1: ({ children }) => <Heading as=\"h1\">{children}</Heading>,\n    h2: ({ children }) => <Heading as=\"h2\">{children}</Heading>,\n    h3: ({ children }) => <Heading as=\"h3\">{children}</Heading>,\n    h4: ({ children }) => <Heading as=\"h4\">{children}</Heading>,\n    h5: ({ children }) => <Heading as=\"h5\">{children}</Heading>,\n    h6: ({ children }) => <Heading as=\"h6\">{children}</Heading>,\n    img: ({ height, width, src, title, altText }) => (\n      <img\n        src={src}\n        alt={altText}\n        width={width}\n        height={height}\n        title={title}\n        loading=\"lazy\"\n        className=\"shadow-image\"\n      />\n    ),\n    embed: {\n      Page: ({ slug, title }: EmbedProps<EmbeddedPageFragment>) => (\n        <Link\n          href={`/${slug}`}\n          className=\"flex items-center justify-between rounded border border-gray-200 bg-white p-3 no-underline shadow-image md:p-6\"\n        >\n          <span>{title}</span>\n          <span>&rarr;</span>\n        </Link>\n      ),\n    },\n  }}\n/>",
        "invoking_code_segment_file_3": "<div ref={contentRef} className=\"w-full max-w-[720px] lg:pr-12\">\n  <RichTextView page={page} />\n</div>",
        "new_file_code_segment": "export function HeadingWithTooltip({ as, children }: HeadingProps) {\n  const Component = `${as}` as keyof JSX.IntrinsicElements;\n\n  let title = children?.props?.parent.children;\n\n  if (typeof title === `object`) {\n    const parsedTitle = title.map((child: any) => child?.text);\n\n    title = parsedTitle.join(``);\n  }\n\n  const slug = slugify(title);\n\n  return (\n    <Component\n      id={slug}\n      className=\"group relative whitespace-pre-wrap\"\n      style={{\n        scrollMarginTop: `80px`,\n      }}\n    >\n      {children}\n      <a\n        href={`#${slug}`}\n        aria-label=\"Anchor\"\n        className=\"anchor ml-[10px] text-[length:inherit] text-gray-500 !no-underline opacity-0 transition-opacity duration-100 after:text-gray-500 after:content-['#'] group-hover:opacity-100\"\n      >\n        <span className=\"sr-only\">Anchor</span>\n      </a>\n      <Tooltip content={title}>\n        <span className=\"sr-only\">Tooltip</span>\n      </Tooltip>\n    </Component>\n  );\n}",
        "feature_description": "Add a tooltip to headings that displays the heading text when hovered over.",
        "detailed_feature_description": "The new feature involves enhancing the Heading component to include a tooltip that displays the heading text when the user hovers over the heading. This is implemented by creating a new file (#file 4) that contains the HeadingWithTooltip component. The Heading component in #file 1 is modified to invoke the HeadingWithTooltip component from #file 4. The RichTextView component in #file 2 and the Content component in #file 3 are updated to use the new HeadingWithTooltip component.",
        "modified_complete_code": {
            "file_1": "//Modify\nexport function Heading({ as, children }: HeadingProps) {\n  return <HeadingWithTooltip as={as}>{children}</HeadingWithTooltip>;\n}",
            "file_2": "//Modify\n<RichText\n  content={page?.content?.json}\n  references={page?.content?.references as EmbedReferences}\n  renderers={{\n    h1: ({ children }) => <Heading as=\"h1\">{children}</Heading>,\n    h2: ({ children }) => <Heading as=\"h2\">{children}</Heading>,\n    h3: ({ children }) => <Heading as=\"h3\">{children}</Heading>,\n    h4: ({ children }) => <Heading as=\"h4\">{children}</Heading>,\n    h5: ({ children }) => <Heading as=\"h5\">{children}</Heading>,\n    h6: ({ children }) => <Heading as=\"h6\">{children}</Heading>,\n    img: ({ height, width, src, title, altText }) => (\n      <img\n        src={src}\n        alt={altText}\n        width={width}\n        height={height}\n        title={title}\n        loading=\"lazy\"\n        className=\"shadow-image\"\n      />\n    ),\n    embed: {\n      Page: ({ slug, title }: EmbedProps<EmbeddedPageFragment>) => (\n        <Link\n          href={`/${slug}`}\n          className=\"flex items-center justify-between rounded border border-gray-200 bg-white p-3 no-underline shadow-image md:p-6\"\n        >\n          <span>{title}</span>\n          <span>&rarr;</span>\n        </Link>\n      ),\n    },\n  }}\n/>",
            "file_3": "//Modify\n<div ref={contentRef} className=\"w-full max-w-[720px] lg:pr-12\">\n  <RichTextView page={page} />\n</div>",
            "file_4": "//New\nexport function HeadingWithTooltip({ as, children }: HeadingProps) {\n  const Component = `${as}` as keyof JSX.IntrinsicElements;\n\n  let title = children?.props?.parent.children;\n\n  if (typeof title === `object`) {\n    const parsedTitle = title.map((child: any) => child?.text);\n\n    title = parsedTitle.join(``);\n  }\n\n  const slug = slugify(title);\n\n  return (\n    <Component\n      id={slug}\n      className=\"group relative whitespace-pre-wrap\"\n      style={{\n        scrollMarginTop: `80px`,\n      }}\n    >\n      {children}\n      <a\n        href={`#${slug}`}\n        aria-label=\"Anchor\"\n        className=\"anchor ml-[10px] text-[length:inherit] text-gray-500 !no-underline opacity-0 transition-opacity duration-100 after:text-gray-500 after:content-['#'] group-hover:opacity-100\"\n      >\n        <span className=\"sr-only\">Anchor</span>\n      </a>\n      <Tooltip content={title}>\n        <span className=\"sr-only\">Tooltip</span>\n      </Tooltip>\n    </Component>\n  );\n}"
        }
    },
    {
        "repo": "example-ng6-lib",
        "content": "'example-ng6-lib/src/app/app.component.ts'\n:import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'app';\n}\n\n'example-ng6-lib/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppComponent } from './app.component';\nimport { ExampleNg6LibModule } from 'example-ng6-lib';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    ExampleNg6LibModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'example-ng6-lib/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));\n\n",
        "called_code_segment_file_1": "@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'app';\n}",
        "invoking_code_segment_file_2": "@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    ExampleNg6LibModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
        "invoking_code_segment_file_3": "platformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));",
        "new_file_code_segment": "export class NewFeatureService {\n  constructor() { }\n  getNewFeatureMessage() {\n    return 'This is a new feature message!';\n  }\n}",
        "feature_description": "Add a new feature to display a message from a new service in the AppComponent.",
        "detailed_feature_description": "A new service named NewFeatureService is created in a new file (#file 4). This service provides a method to get a new feature message. The AppComponent in #file 1 is modified to use this service and display the message. The AppModule in #file 2 is updated to include the new service. The main.ts file in #file 3 remains unchanged as it does not directly interact with the new feature.",
        "modified_complete_code": {
            "app.component.ts": "#Modify\nimport { Component } from '@angular/core';\nimport { NewFeatureService } from './new-feature.service';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'app';\n  newFeatureMessage: string;\n\n  constructor(private newFeatureService: NewFeatureService) {\n    this.newFeatureMessage = this.newFeatureService.getNewFeatureMessage();\n  }\n}",
            "app.module.ts": "#Modify\nimport { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { AppComponent } from './app.component';\nimport { ExampleNg6LibModule } from 'example-ng6-lib';\nimport { NewFeatureService } from './new-feature.service';\n\n@NgModule({\n  declarations: [\n    AppComponent\n  ],\n  imports: [\n    BrowserModule,\n    ExampleNg6LibModule\n  ],\n  providers: [NewFeatureService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
            "main.ts": "import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));",
            "new-feature.service.ts": "#New\nexport class NewFeatureService {\n  constructor() { }\n  getNewFeatureMessage() {\n    return 'This is a new feature message!';\n  }\n}"
        }
    },
    {
        "repo": "express-openapi-validate",
        "content": "'express-openapi-validate/src/OpenApiDocument.ts'\n:/*\n  Copyright 2018 Santeri Hiltunen\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nexport default interface OpenApiDocument {\n  openapi: string;\n  info: InfoObject;\n  servers?: any[];\n  paths: PathsObject;\n  components?: ComponentsObject;\n  security?: any[];\n  tags?: any[];\n  externalDocs?: any;\n}\n\nexport interface InfoObject {\n  title: string;\n  description?: string;\n  termsOfService?: string;\n  contact?: any;\n  license?: any;\n  version: string;\n}\n\nexport interface SchemaObject {\n  type?: string;\n  items?: SchemaObject;\n  properties?: { [property: string]: SchemaObject };\n  nullable?: boolean;\n  required?: string[];\n  allOf?: SchemaObject[];\n  anyOf?: SchemaObject[];\n  oneOf?: SchemaObject[];\n  not?: SchemaObject;\n  additionalProperties?: boolean | SchemaObject;\n}\n\nexport interface ComponentsObject {\n  schemas?: { [index: string]: SchemaObject };\n  responses?: { [index: string]: any };\n  parameters?: { [index: string]: any };\n  examples?: { [index: string]: any };\n  requestBodies?: { [index: string]: any };\n  headers?: { [index: string]: any };\n  securitySchemes?: { [index: string]: any };\n  links?: { [index: string]: any };\n  callbacks?: { [index: string]: any };\n}\n\nexport type Operation =\n  | \"get\"\n  | \"put\"\n  | \"post\"\n  | \"delete\"\n  | \"options\"\n  | \"head\"\n  | \"patch\"\n  | \"trace\";\n\nexport interface PathsObject {\n  [path: string]: PathItemObject;\n}\n\nexport interface PathItemObject {\n  $ref?: string;\n  summary?: string;\n  description?: string;\n  get?: OperationObject;\n  put?: OperationObject;\n  post?: OperationObject;\n  delete?: OperationObject;\n  options?: OperationObject;\n  head?: OperationObject;\n  patch?: OperationObject;\n  trace?: OperationObject;\n  servers?: any[];\n  parameters?: Array<ParameterObject | ReferenceObject>;\n}\n\nexport interface OperationObject {\n  tags?: string[];\n  summary?: string;\n  description?: string;\n  externalDocs?: any;\n  operationId?: any;\n  parameters?: Array<ParameterObject | ReferenceObject>;\n  requestBody?: RequestBodyObject;\n  responses: any;\n  callbacks?: any;\n  deprecated?: boolean;\n  security?: any[];\n  servers?: any[];\n}\n\nexport type ParameterLocation = \"query\" | \"header\" | \"path\" | \"cookie\";\n\nexport type ParameterStyle =\n  | \"matrix\"\n  | \"label\"\n  | \"form\"\n  | \"simple\"\n  | \"spaceDelimited\"\n  | \"pipeDelimited\"\n  | \"deepObject\";\n\nexport interface ParameterObject {\n  name: string;\n  in: ParameterLocation;\n  description?: string;\n  required?: boolean;\n  deprecated?: boolean;\n  allowEmptyValue?: boolean;\n  style?: ParameterStyle;\n  explode?: boolean;\n  allowReserved?: boolean;\n  schema?: SchemaObject | ReferenceObject;\n  example?: any;\n  examples?: { [mediaType: string]: any };\n  content?: { [mediaType: string]: MediaTypeObject };\n}\n\nexport interface RequestBodyObject {\n  description?: string;\n  required?: boolean;\n  content: { [mediaType: string]: MediaTypeObject };\n}\n\nexport interface MediaTypeObject {\n  schema?: SchemaObject | ReferenceObject;\n  example?: any;\n  examples?: any;\n  encoding?: any;\n}\n\nexport interface ReferenceObject {\n  $ref: string;\n}\n\n'express-openapi-validate/test/open-api-document.ts'\n:/*\n  Copyright 2018 Santeri Hiltunen\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport fs from \"fs\";\nimport jsYaml from \"js-yaml\";\nimport OpenApiDocument from \"../src/OpenApiDocument\";\n\nconst openApiDocument = jsYaml.load(\n  fs.readFileSync(\"./test/openapi.yaml\", \"utf-8\"),\n);\n\nexport default openApiDocument as OpenApiDocument;\n\n'express-openapi-validate/test/integration/integration.test.ts'\n:/*\n  Copyright 2018 Santeri Hiltunen\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport request from \"supertest\";\n// eslint-disable-next-line\nimport OpenApiValidator from \"../../dist/OpenApiValidator\";\nimport openApiDocument from \"../open-api-document\";\nimport app from \"./app\";\n\nconst validator = new OpenApiValidator(openApiDocument);\n\ndescribe(\"Integration tests with real app\", () => {\n  test(\"requests against /echo are validated correctly\", async () => {\n    const validate = validator.validateResponse(\"post\", \"/echo\");\n\n    let res = await request(app).post(\"/echo\").send({});\n    expect(validate(res)).toBeUndefined();\n    expect(res.status).toBe(400);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n\n    res = await request(app).post(\"/echo\").send({ input: \"Hello!\" });\n    expect(res.status).toBe(200);\n    expect(res.body).toEqual({ output: \"Hello!\" });\n    expect(validate(res)).toBeUndefined();\n  });\n\n  test(\"requests against /match are validated correctly\", async () => {\n    const validate = validator.validateResponse(\"post\", \"/match\");\n\n    let res = await request(app).post(\"/match\").send({});\n    expect(validate(res)).toBeUndefined();\n    expect(res.status).toBe(400);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n\n    res = await request(app).post(\"/match\").send({ input: \"Hello!\" });\n    expect(res.status).toBe(200);\n    expect(res.body).toEqual({ output: \"Hello!\" });\n    expect(validate(res)).toBeUndefined();\n\n    res = await request(app)\n      .post(\"/match/works-with-url-param\")\n      .send({ input: \"Hello!\" });\n    expect(res.status).toBe(200);\n    expect(res.body).toEqual({ output: \"works-with-url-param\" });\n    expect(validate(res)).toBeUndefined();\n\n    res = await request(app).post(\"/match/works-with-url-param\").send({});\n    expect(validate(res)).toBeUndefined();\n    expect(res.status).toBe(400);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n  });\n\n  test(\"requests against /no-match cause an error\", async () => {\n    const res = await request(app)\n      .post(\"/no-match\")\n      .send({ anything: \"anything\" });\n    expect(res.status).toBe(500);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n  });\n\n  test(\"path parameters are validated\", async () => {\n    let res = await request(app).get(\"/parameters/id/lol\");\n    expect(res.status).toBe(400);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n\n    res = await request(app).get(\"/parameters/id/789\");\n    expect(res.status).toBe(200);\n    expect(res.body).toEqual({ id: 789 });\n  });\n\n  test(\"query parameters are validated\", async () => {\n    let res = await request(app).get(\"/parameters\");\n    expect(res.status).toBe(400);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n\n    res = await request(app).get(\"/parameters\").query({ porom: \"moi\" });\n    expect(res.status).toBe(400);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n\n    res = await request(app)\n      .get(\"/parameters\")\n      .query({ param: \"hallo\", porom: \"moi\" });\n    expect(res.status).toBe(200);\n    expect(res.body).toEqual({ param: \"hallo\", porom: \"moi\" });\n  });\n\n  test(\"header parameters are validated\", async () => {\n    let res = await request(app).get(\"/parameters/header\");\n    expect(res.status).toBe(400);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n\n    res = await request(app).get(\"/parameters/header\").set(\"X-param\", \"hullo\");\n    expect(res.status).toBe(200);\n    expect(res.body).toEqual({ header: \"hullo\" });\n  });\n\n  test(\"cookie parameters are validated\", async () => {\n    let res = await request(app).get(\"/parameters/cookie\");\n    expect(res.status).toBe(400);\n    expect(res.body).toHaveProperty(\"error\");\n    expect(res.body).toMatchSnapshot();\n\n    res = await request(app)\n      .get(\"/parameters/cookie\")\n      .set(\"cookie\", \"session=hullo\");\n    expect(res.status).toBe(200);\n    expect(res.body).toEqual({ cookie: \"hullo\" });\n  });\n});\n\n",
        "called_code_segment_file_1": "export default interface OpenApiDocument {\n  openapi: string;\n  info: InfoObject;\n  servers?: any[];\n  paths: PathsObject;\n  components?: ComponentsObject;\n  security?: any[];\n  tags?: any[];\n  externalDocs?: any;\n}",
        "invoking_code_segment_file_2": "const openApiDocument = jsYaml.load(\n  fs.readFileSync(\"./test/openapi.yaml\", \"utf-8\"),\n);\nexport default openApiDocument as OpenApiDocument;",
        "invoking_code_segment_file_3": "const validator = new OpenApiValidator(openApiDocument);",
        "new_file_code_segment": "export function validateApiVersion(document: OpenApiDocument) {\n  const version = document.openapi;\n  if (version !== '3.0.0') {\n    throw new Error('Unsupported OpenAPI version');\n  }\n}",
        "feature_description": "Add a feature to validate the OpenAPI version in the OpenApiDocument.",
        "detailed_feature_description": "The new feature involves adding a function in #file 4 to validate the OpenAPI version specified in the OpenApiDocument. This function will be invoked in #file 1 to ensure that only supported versions of the OpenAPI specification are processed. The existing code in #file 2 and #file 3 will be updated to handle this new validation step.",
        "modified_complete_code": {
            "#file 1": "import { validateApiVersion } from './file4'; //New\n\nexport default interface OpenApiDocument {\n  openapi: string;\n  info: InfoObject;\n  servers?: any[];\n  paths: PathsObject;\n  components?: ComponentsObject;\n  security?: any[];\n  tags?: any[];\n  externalDocs?: any;\n}\n\n//Modify\nvalidateApiVersion(document);",
            "#file 2": "import { validateApiVersion } from './file4'; //New\n\nconst openApiDocument = jsYaml.load(\n  fs.readFileSync(\"./test/openapi.yaml\", \"utf-8\"),\n);\n\n//Modify\nvalidateApiVersion(openApiDocument);\nexport default openApiDocument as OpenApiDocument;",
            "#file 3": "import { validateApiVersion } from './file4'; //New\n\nconst validator = new OpenApiValidator(openApiDocument);\n\n//Modify\nvalidateApiVersion(openApiDocument);",
            "#file 4": "export function validateApiVersion(document: OpenApiDocument) {\n  const version = document.openapi;\n  if (version !== '3.0.0') {\n    throw new Error('Unsupported OpenAPI version');\n  }\n}"
        }
    },
    {
        "repo": "factura-front",
        "content": "'factura-front/src/app/user/welcome/table-log/table-log.component.ts'\n:import { AfterViewInit } from '@angular/core';\nimport { Component, OnInit, ViewChild } from '@angular/core';\nimport { MatPaginator } from '@angular/material/paginator';\nimport { MatTableDataSource } from '@angular/material/table';\nimport { ActivityLog } from 'src/app/models/activityLog.model';\nimport { LogUserService } from 'src/app/services/log-user-service.service';\n\n@Component({\n  selector: 'table-log',\n  templateUrl: './table-log.component.html',\n  styleUrls: ['./table-log.component.scss']\n})\nexport class TableLogComponent implements OnInit, AfterViewInit {\n  displayedColumns: string[] = ['id', 'user','date','action', 'detail'];\n  dataSource = new MatTableDataSource<ActivityLog>([]);\n  @ViewChild(MatPaginator) paginator: MatPaginator;\n\n  constructor(private logService:LogUserService){ }\n\n  ngAfterViewInit(): void {\n\n  }\n\n  ngOnInit(): void {\n    this.logService.activityLogs.subscribe(acts=>{\n      if(acts){\n        this.dataSource=new MatTableDataSource<ActivityLog>(acts);\n        this.dataSource.paginator = this.paginator;\n      }\n\n    })\n  }\n  getDate(date:any){\n    let d =new Date(date);\n    return d.getFullYear()+'/'+(d.getMonth()+1)+'/'+d.getDate()+' '+d.getHours()+':'+d.getUTCMinutes();\n  }\n}\n\n'factura-front/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { LoginComponent } from './login/login.component';\nimport { HomeComponent } from './home/home.component';\nimport { AuthIntercpetorService } from './auth/auth-interceptor.service';\nimport { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport { MatInputModule } from '@angular/material/input';\nimport {MatIconModule} from '@angular/material/icon';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatProgressSpinnerModule} from '@angular/material/progress-spinner';\nimport {MatSnackBarModule} from '@angular/material/snack-bar';\nimport { LoginAlertComponent } from './login/login-alert/login-alert.component';\nimport { HomePageComponent } from './home/home-page/home-page.component';\nimport { AboutPageComponent } from './home/about-page/about-page.component';\nimport { AboutComponent } from './home/about-page/about/about.component';\nimport { ServicePageComponent } from './home/service-page/service-page.component';\nimport { ServicesComponent } from './home/service-page/services/services.component';\nimport { UserComponent } from './user/user.component';\nimport { NavComponent } from './nav/nav.component';\nimport { ModalComponent } from './modal/modal.component';\nimport { ProfileComponent } from './user/profile/profile.component';\nimport { WelcomeComponent } from './user/welcome/welcome.component';\nimport { SideNavBarComponent } from './user/side-nav-bar/side-nav-bar.component';\nimport {MatSidenavModule} from '@angular/material/sidenav';\nimport {MatMenuModule} from '@angular/material/menu';\nimport { LineChartComponent } from './user/welcome/line-chart/line-chart.component';\nimport { TestComponent } from './user/test/test.component';\nimport { UserGestComponent } from './user/admin/user-gest/user-gest.component';\nimport {MatTableModule} from '@angular/material/table';\nimport {MatPaginatorModule} from '@angular/material/paginator';\nimport { UserNavComponent } from './user/user-nav/user-nav.component';\nimport { DashCardComponent } from './user/welcome/dash-card/dash-card.component';\nimport { ChartsModule } from 'ng2-charts';\nimport { DashCardProfitComponent } from './user/welcome/dash-card-profit/dash-card-profit.component';\nimport { DashCardProfitBarComponent } from './user/welcome/dash-card-profit-bar/dash-card-profit-bar.component';\nimport { MissionsComponent } from './home/service-page/missions/missions.component';\nimport { NgwWowModule } from 'ngx-wow';\nimport { TableLogComponent } from './user/welcome/table-log/table-log.component';\n@NgModule({\n  declarations: [ \n    AppComponent,\n    LoginComponent,\n    HomeComponent,\n    LoginAlertComponent,\n    HomePageComponent,\n    AboutPageComponent,\n    AboutComponent,\n    ServicePageComponent,\n    ServicesComponent,\n    UserComponent,\n    NavComponent,\n    ModalComponent,\n    ProfileComponent,\n    WelcomeComponent,\n    SideNavBarComponent,\n    LineChartComponent,\n    TestComponent,\n    UserGestComponent,\n    UserNavComponent,\n    DashCardComponent,\n    DashCardProfitComponent,\n    DashCardProfitBarComponent,\n    MissionsComponent,\n    TableLogComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    FormsModule,\n    ReactiveFormsModule,\n    HttpClientModule,\n    BrowserAnimationsModule,\n    MatFormFieldModule,\n    MatInputModule,\n    MatIconModule,\n    MatButtonModule,\n    MatProgressSpinnerModule,\n    MatSnackBarModule,\n    MatSidenavModule,\n    MatMenuModule,\n    MatTableModule,\n    MatPaginatorModule,\n    ChartsModule,\n    NgwWowModule\n  ],\n  providers: [{provide:HTTP_INTERCEPTORS,useClass:AuthIntercpetorService,multi:true}],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'factura-front/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "ngOnInit(): void {\n    this.logService.activityLogs.subscribe(acts=>{\n      if(acts){\n        this.dataSource=new MatTableDataSource<ActivityLog>(acts);\n        this.dataSource.paginator = this.paginator;\n      }\n\n    })\n  }",
        "invoking_code_segment_file_2": "constructor(private logService:LogUserService){ }",
        "invoking_code_segment_file_3": "constructor(private logService:LogUserService){ }",
        "new_file_code_segment": "export class LogFilterService {\n  constructor(private logService: LogUserService) { }\n\n  filterLogs(filter: string): Observable<ActivityLog[]> {\n    return this.logService.activityLogs.pipe(\n      map(logs => logs.filter(log => log.action.includes(filter)))\n    );\n  }\n}",
        "feature_description": "Add a log filtering feature to filter logs based on the action type.",
        "detailed_feature_description": "The new feature introduces a service (LogFilterService) that allows filtering logs based on the action type. This service is injected into the TableLogComponent and used to filter logs displayed in the table. The LogFilterService uses the existing LogUserService to get the logs and applies a filter to them.",
        "modified_complete_code": {
            "file_1": "//Modify\nngOnInit(): void {\n    this.logService.activityLogs.subscribe(acts=>{\n      if(acts){\n        this.dataSource=new MatTableDataSource<ActivityLog>(acts);\n        this.dataSource.paginator = this.paginator;\n      }\n\n    })\n  }\n\n//New\nfilterLogs(filter: string): void {\n    this.logFilterService.filterLogs(filter).subscribe(filteredLogs => {\n      this.dataSource = new MatTableDataSource<ActivityLog>(filteredLogs);\n      this.dataSource.paginator = this.paginator;\n    });\n  }",
            "file_2": "//Modify\nconstructor(private logService:LogUserService, private logFilterService: LogFilterService){ }",
            "file_3": "//Modify\nconstructor(private logService:LogUserService, private logFilterService: LogFilterService){ }",
            "file_4": "//New\nexport class LogFilterService {\n  constructor(private logService: LogUserService) { }\n\n  filterLogs(filter: string): Observable<ActivityLog[]> {\n    return this.logService.activityLogs.pipe(\n      map(logs => logs.filter(log => log.action.includes(filter)))\n    );\n  }\n}"
        }
    },
    {
        "repo": "grafterizer-2.0",
        "content": "'grafterizer-2.0/src/app/tabular-transformation/profiling/statistic-service/statistic.service.ts'\n:import { Injectable } from '@angular/core';\nimport * as datalib from 'datalib';\n\n@Injectable()\nexport class StatisticService {\n\n  public data: any;\n  public statData: any;\n  public columnData = [];\n  public profile: any;\n  public columnSelected: any;\n  public typesInferred: any;\n  public typeInferred: any;\n  public stdev: any;\n  public outlierExample: any;\n\n  constructor() {\n    this.statData = [\n      { stat: 'Count', value: 0 },\n      { stat: 'Distinct', value: 0 },\n      { stat: 'Quartile 1', value: 0 },\n      { stat: 'Mean', value: 0 },\n      { stat: 'Quartile 3', value: 0 },\n      { stat: 'Std. deviation', value: 0 },\n      { stat: 'Min', value: 0 },\n      { stat: 'Max', value: 0 },\n    ];\n  }\n\n  public loadJSON(data: any) {\n    return datalib.read(data, { type: 'json', parse: 'auto' });\n  }\n\n  public buildProfile(data: any, header: any, handsontableSelection) {\n    let columnIndex = handsontableSelection.col;\n    let columnHeader = header[columnIndex];\n    const promise = new Promise(\n      (resolve, reject) => {\n        const columndata = [];\n        for (let i = 0; i < data.length; i++) {\n          let obj = data[i];\n          for (let o in obj) {\n            if (columnHeader == o) {\n              columndata.push(obj[o]);\n            }\n          }\n        }\n        resolve(columndata);\n      }\n    );\n\n    const profileSummary = (columnData) => {\n      let data;\n      let dataType = datalib.type.infer(columnData);\n      // if single cell is selected in handsontable --> data eaquals that cell only\n      if (handsontableSelection.row == handsontableSelection.row2) {\n        data = [columnData[handsontableSelection.row]];\n      } else {\n        data = columnData;\n      }\n      let min;\n      let max;\n      let mean;\n      let quartiles;\n      let valid = datalib.count.valid(data);\n      let missing = datalib.count.missing(data);\n      let profile = [];\n      let histogramData = [];\n      let boxPlotLabels = [];\n      let chartQuartiles = [];\n      if (dataType === 'integer' || dataType === 'number') {\n        min = datalib.min(data);\n        max = datalib.max(data);\n        mean = datalib.mean(data);\n        this.stdev = datalib.stdev(data);\n        // if column is selected in handsontable --> compute data distribution and quartiles      \n        if (handsontableSelection.row !== handsontableSelection.row2) {\n          // outlier detection\n          quartiles = datalib.quartile(data);\n          chartQuartiles.push({ data: [quartiles.slice(0, 3), this.stdev] });\n        }\n      } else if (dataType === 'string' || dataType === 'boolean' || dataType === 'date') {\n        quartiles = ['NaN', 'NaN', 'NaN'];\n        this.stdev = 'NaN';\n      }\n\n      // histogram or distinct map\n      let distinct = datalib.count.distinct(data);\n      if (distinct <= 13) {\n        let distinctMap = datalib.count.map(data);\n        var autoFormat = datalib.format.auto.number('s');\n        let counter = 0;\n        for (let key in distinctMap) {\n          let obj = { name: \"\", value: 0, index: 0 };\n          obj.name = key;\n          obj.value = autoFormat(distinctMap[key]);\n          obj.index = counter;\n          counter++;\n          if (dataType === 'number' || dataType === 'integer') {\n            boxPlotLabels.push(key);\n          }\n          histogramData.push(obj);\n        }\n      }\n      else if (distinct > 13 && dataType === 'number' || dataType === 'integer') {\n        let histogram = datalib.histogram(data, { min: min, max: max, maxbins: 14 });\n        var autoFormat = datalib.format.auto.number('s');\n        let counter = 0;\n        for (let key in histogram) {\n          if (key !== 'bins') {\n            let obj = { name: \"\", value: 0, index: 0 };\n            obj.name = autoFormat(histogram[key].value);\n            obj.value = histogram[key].count;\n            obj.index = counter;\n            if (obj.index < histogram.length - 1) {\n              let increment = counter + 1;\n              obj.name = obj.name.toString().concat('-', autoFormat(histogram[increment.toString()].value).toString());\n              boxPlotLabels.push(obj.name);\n            }\n            counter++;\n            if (obj.value > 0) {\n              histogramData.push(obj);\n            }\n          }\n        }\n      }\n\n      let validity_chartData = [];\n      validity_chartData.push(valid);\n      validity_chartData.push(missing);\n      let validityLabels = ['Valid', 'Missing'];\n      let validityData = [];\n      for (let i = 0; i < 2; i++) {\n        let obj1 = { name: \"\", value: 0, index: 0 };\n        obj1.name = validityLabels[i];\n        obj1.value = validity_chartData[i];\n        obj1.index = i;\n        validityData.push(obj1);\n      }\n\n      // if single cell is selected in handsontable --> information about data distribution is not available, i.e., 'NaN'      \n      let countTotal = datalib.count(data);\n      if (handsontableSelection.row == handsontableSelection.row2) {\n        this.statData[0].value = countTotal;\n        this.statData[1].value = distinct;\n        this.statData[2].value = 'NA';\n        this.statData[3].value = 'NA';\n        this.statData[4].value = 'NA';\n        this.statData[5].value = 'NA';\n        this.statData[6].value = 'NA';\n        this.statData[7].value = 'NA';\n        boxPlotLabels = [];\n      } else {\n        // if column is selected in handsontable --> information about data distribution is available              \n        this.statData[0].value = countTotal;\n        this.statData[1].value = distinct;\n        this.statData[2].value = Math.round(quartiles[0]);\n        this.statData[3].value = Math.round(mean);\n        this.statData[4].value = Math.round(quartiles[2]);\n        this.statData[5].value = Math.round(this.stdev);\n        this.statData[6].value = Math.round(min);\n        this.statData[7].value = Math.round(max);\n      }\n\n      profile.push(countTotal);\n      profile.push(distinct);\n      profile.push(histogramData);\n      profile.push(validityData);\n      profile.push(chartQuartiles);\n      profile.push(boxPlotLabels);\n      profile.push(validityLabels);\n\n      return Promise.resolve(profile);\n    }\n    promise\n      .then(profileSummary)\n      .then(fulfilled => {\n        this.profile = fulfilled;\n      });\n  }\n\n  public getCount(values: Array<any>): Number {\n    return datalib.count(values);\n  }\n\n  public getValidCount(values: Array<any>): Number {\n    return datalib.count.valid(values);\n  }\n\n  public getMissingCount(values: Array<any>): Number {\n    return datalib.count.missing(values);\n  }\n\n  public getDistinctCount(values: Array<any>): Number {\n    return datalib.count.distinct(values);\n  }\n\n  public getMedian(values: Array<Number>): Number {\n    return datalib.median(values);\n  }\n\n  public getQuartile(values: Array<Number>): Array<Number> {\n    return datalib.quartile(values);\n  }\n\n  public getSum(values: Array<Number>): Number {\n    return datalib.sum(values);\n  }\n\n  public getMean(values: Array<Number>): Number {\n    return datalib.mean(values);\n  }\n\n  public getVariance(values: Array<Number>): Number {\n    return datalib.variance(values);\n  }\n\n  public getStdev(values: Array<Number>): Number {\n    return datalib.stdev(values);\n  }\n\n  public getMin(values: Array<any>): any {\n    return datalib.min(values);\n  }\n\n  public getMax(values: Array<any>): any {\n    return datalib.max(values);\n  }\n\n  public getHistogram(values: Array<Number>): Array<any> {\n    return datalib.histogram(values);\n  }\n\n  public getProfile(values: Array<Number>): Object {\n    return datalib.profile();\n  }\n\n  public getCountMap(values: Array<any>): Object {\n    return datalib.count.map(values);\n  }\n}\n\n'grafterizer-2.0/src/app/tabular-transformation/profiling/line-chart/line-chart.component.ts'\n:import { Component, OnInit, EventEmitter, Input, Output } from '@angular/core';\nimport { StatisticService } from '../statistic-service/statistic.service';\n\n@Component({\n  selector: 'line-chart',\n  templateUrl: './line-chart.component.html',\n  styleUrls: ['./line-chart.component.css']\n})\nexport class LineChartComponent implements OnInit {\n\n  @Output()\n  done: EventEmitter<any> = new EventEmitter();\n\n  data: any = [];\n\n  view: any[] = undefined;\n\n  // options\n  showXAxis = true;\n  showYAxis = true;\n  gradient = false;\n  showLegend = false;\n  showXAxisLabel = true;\n  showYAxisLabel = true;\n  xAxisLabel;\n  yAxisLabel;\n  showRefLines = true;\n  showRefLabels = true;\n  referenceLines = undefined;\n\n  colorScheme = {\n    domain: ['#5AA454', '#A10A28', '#C7B42C', '#AAAAAA', '#5B5393', '#FFE0AA']\n  };\n\n  autoScale = true;\n\n  constructor(private statisticService: StatisticService) { }\n\n  ngOnInit() {\n  }\n\n  @Input()\n  set chartData(data: Object) {\n    if (data) {\n      this.data = [];\n      let series = [];\n      this.referenceLines = [];\n      //data contains one column with time period, and another with values \n      let timePeriod = data['info']['period'];\n      //dates\n      timePeriod = timePeriod.map(date => {\n        return new Date(date);\n      });\n      let values = data['info']['values'];\n      for (let i in timePeriod) {\n        series.push({\n          \"name\": timePeriod[i],\n          \"value\": values[i]\n        });\n      }\n      this.yAxisLabel = data['name'];\n      this.data.push({\n        \"name\": data['name'],\n        \"series\": series\n      })\n\n      this.referenceLines.push({\n        \"name\": \"min\",\n        \"value\": this.statisticService.getMin(values)\n      });\n\n      this.referenceLines.push({\n        \"name\": \"max\",\n        \"value\": this.statisticService.getMax(values)\n      });\n\n      this.referenceLines.push({\n        \"name\": \"mean\",\n        \"value\": this.statisticService.getMean(values)\n      });\n\n      this.done.emit(null);\n    }\n  }\n\n}\n\n'grafterizer-2.0/src/app/tabular-transformation/profiling/line-chart/line-chart.component.spec.ts'\n:import { async, ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { LineChartComponent } from './line-chart.component';\n\ndescribe('LineChartComponent', () => {\n  let component: LineChartComponent;\n  let fixture: ComponentFixture<LineChartComponent>;\n\n  beforeEach(async(() => {\n    TestBed.configureTestingModule({\n      declarations: [ LineChartComponent ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = TestBed.createComponent(LineChartComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should be created', () => {\n    expect(component).toBeTruthy();\n  });\n});\n\n",
        "called_code_segment_file_1": "public getMin(values: Array<any>): any {\n    return datalib.min(values);\n  }\n\n  public getMax(values: Array<any>): any {\n    return datalib.max(values);\n  }\n\n  public getMean(values: Array<Number>): Number {\n    return datalib.mean(values);\n  }",
        "invoking_code_segment_file_2": "this.referenceLines.push({\n        \"name\": \"min\",\n        \"value\": this.statisticService.getMin(values)\n      });\n\n      this.referenceLines.push({\n        \"name\": \"max\",\n        \"value\": this.statisticService.getMax(values)\n      });\n\n      this.referenceLines.push({\n        \"name\": \"mean\",\n        \"value\": this.statisticService.getMean(values)\n      });",
        "invoking_code_segment_file_3": "Not applicable",
        "new_file_code_segment": "export class OutlierDetectionService {\n  public detectOutliers(values: Array<Number>): Array<Number> {\n    let mean = datalib.mean(values);\n    let stdev = datalib.stdev(values);\n    let outliers = values.filter(value => Math.abs(value - mean) > 2 * stdev);\n    return outliers;\n  }\n}",
        "feature_description": "Add outlier detection functionality to the existing statistical analysis.",
        "detailed_feature_description": "The new feature involves adding a method to detect outliers in a dataset. This method will be implemented in a new service file (#file 4) and will be invoked from the existing StatisticService (#file 1). The LineChartComponent (#file 2) will be updated to use this new functionality to highlight outliers in the chart.",
        "modified_complete_code": {
            "#file 1": "import { Injectable } from '@angular/core';\nimport * as datalib from 'datalib';\nimport { OutlierDetectionService } from './outlier-detection.service'; //New\n\n@Injectable()\nexport class StatisticService {\n\n  constructor(private outlierDetectionService: OutlierDetectionService) { //Modify\n    this.statData = [\n      { stat: 'Count', value: 0 },\n      { stat: 'Distinct', value: 0 },\n      { stat: 'Quartile 1', value: 0 },\n      { stat: 'Mean', value: 0 },\n      { stat: 'Quartile 3', value: 0 },\n      { stat: 'Std. deviation', value: 0 },\n      { stat: 'Min', value: 0 },\n      { stat: 'Max', value: 0 },\n    ];\n  }\n\n  public getMin(values: Array<any>): any {\n    return datalib.min(values);\n  }\n\n  public getMax(values: Array<any>): any {\n    return datalib.max(values);\n  }\n\n  public getMean(values: Array<Number>): Number {\n    return datalib.mean(values);\n  }\n\n  public getOutliers(values: Array<Number>): Array<Number> {\n    return this.outlierDetectionService.detectOutliers(values); //New\n  }\n}",
            "#file 2": "import { Component, OnInit, EventEmitter, Input, Output } from '@angular/core';\nimport { StatisticService } from '../statistic-service/statistic.service';\n\n@Component({\n  selector: 'line-chart',\n  templateUrl: './line-chart.component.html',\n  styleUrls: ['./line-chart.component.css']\n})\nexport class LineChartComponent implements OnInit {\n\n  @Output()\n  done: EventEmitter<any> = new EventEmitter();\n\n  data: any = [];\n\n  view: any[] = undefined;\n\n  // options\n  showXAxis = true;\n  showYAxis = true;\n  gradient = false;\n  showLegend = false;\n  showXAxisLabel = true;\n  showYAxisLabel = true;\n  xAxisLabel;\n  yAxisLabel;\n  showRefLines = true;\n  showRefLabels = true;\n  referenceLines = undefined;\n\n  colorScheme = {\n    domain: ['#5AA454', '#A10A28', '#C7B42C', '#AAAAAA', '#5B5393', '#FFE0AA']\n  };\n\n  autoScale = true;\n\n  constructor(private statisticService: StatisticService) { }\n\n  ngOnInit() { }\n\n  @Input()\n  set chartData(data: Object) {\n    if (data) {\n      this.data = [];\n      let series = [];\n      this.referenceLines = [];\n      //data contains one column with time period, and another with values \n      let timePeriod = data['info']['period'];\n      //dates\n      timePeriod = timePeriod.map(date => {\n        return new Date(date);\n      });\n      let values = data['info']['values'];\n      for (let i in timePeriod) {\n        series.push({\n          \"name\": timePeriod[i],\n          \"value\": values[i]\n        });\n      }\n      this.yAxisLabel = data['name'];\n      this.data.push({\n        \"name\": data['name'],\n        \"series\": series\n      })\n\n      this.referenceLines.push({\n        \"name\": \"min\",\n        \"value\": this.statisticService.getMin(values)\n      });\n\n      this.referenceLines.push({\n        \"name\": \"max\",\n        \"value\": this.statisticService.getMax(values)\n      });\n\n      this.referenceLines.push({\n        \"name\": \"mean\",\n        \"value\": this.statisticService.getMean(values)\n      });\n\n      let outliers = this.statisticService.getOutliers(values); //New\n      this.referenceLines.push({\n        \"name\": \"outliers\",\n        \"value\": outliers\n      });\n\n      this.done.emit(null);\n    }\n  }\n}",
            "#file 3": "Not applicable",
            "#file 4": "import { Injectable } from '@angular/core';\nimport * as datalib from 'datalib';\n\n@Injectable()\nexport class OutlierDetectionService {\n  public detectOutliers(values: Array<Number>): Array<Number> {\n    let mean = datalib.mean(values);\n    let stdev = datalib.stdev(values);\n    let outliers = values.filter(value => Math.abs(value - mean) > 2 * stdev);\n    return outliers;\n  }\n}"
        }
    },
    {
        "repo": "ion-cli",
        "content": "'ion-cli/src/InitialState.ts'\n:/**\n\n * Class describing the initial state of the DID.\n\n */\n\nexport default class InitialState {\n\n   /**\n\n    * Constructs a new instance on the @see CurrentState class.\n\n    * @param shortForm hash-based version of the DID URI string (only resolvable when anchored).\n\n    * @param longForm fully self-resolving payload-embedded version of the DID URI string.\n\n    * @param ops array of all operations that have been included in the state chain of the DID.\n\n    */\n\n  constructor (public readonly shortForm: string, public readonly longForm: string, public readonly ops: [any]) {\n\n  }\n\n}\n\n\n'ion-cli/src/StorageItem.ts'\n:import { plainToClass } from 'class-transformer';\n\nimport * as fs from 'fs-extra';\n\nimport * as path from 'path';\n\nimport InitialState from './InitialState';\n\n\n\n/**\n\n * Class describing a storage item for saving and loading\n\n * DID metadata and keys.\n\n */\n\nexport default class StorageItem {\n\n  /**\n\n   * Storage item version.\n\n   */\n\n  public readonly version: string = 'v0.2.1';\n\n\n\n  /**\n\n   * Date indicating the date and time\n\n   * the storage was created.\n\n   */\n\n  public readonly created: Date;\n\n\n\n  /**\n\n   * Flag indicating whether the DID has been\n\n   * published to the network.\n\n   */\n\n  public published: boolean = false;\n\n\n\n  /**\n\n   * Constructs a new instance on the @see StorageItem class.\n\n   * @param name of the DID.\n\n   * @param initialState of the DID.\n\n   * @param keys associated with the DID.\n\n   */\n\n  constructor (public readonly name: string, public readonly initialState: InitialState, public readonly keys: any[]) {\n\n    this.created = new Date();\n\n  }\n\n\n\n  /**\n\n   * Checks if the specified storage item exists.\n\n   * @param directory from which to load the storage item.\n\n   * @param name of the storage item to load.\n\n   */\n\n  public static exists (directory: string, name: string): boolean {\n\n    if (!directory) {\n\n      throw new Error('A directory is required.');\n\n    }\n\n\n\n    if (!name) {\n\n      throw new Error('A name is required.');\n\n    }\n\n\n\n    // Check if the file exists.\n\n    const storageItemPath = path.join(directory, `${name}.json`);\n\n    return fs.existsSync(storageItemPath);\n\n  }\n\n\n\n  /**\n\n   * Loads the DID with @param name from the specified directory.\n\n   * @param directory from which to load the DID.\n\n   * @param name of the DID to load.\n\n   */\n\n  public static async load (directory: string, name: string): Promise<StorageItem> {\n\n    if (!directory) {\n\n      throw new Error('A directory is required.');\n\n    }\n\n\n\n    if (!name) {\n\n      throw new Error('A name is required.');\n\n    }\n\n\n\n    // Load the DID from the directory and\n\n    // return\n\n    const storageItemPath = path.join(directory, `${name}.json`);\n\n    const storageItemJson = await fs.readJson(storageItemPath, { encoding: 'utf-8' });\n\n    return plainToClass(StorageItem, <object>storageItemJson);\n\n  }\n\n\n\n  /**\n\n   * Saves the instance of the DID to specified directory\n\n   * as a json file.\n\n   * @param directory to save the DID to.\n\n   */\n\n  public async save (directory: string): Promise<void> {\n\n    if (!directory) {\n\n      throw new Error('A directory is required.');\n\n    }\n\n\n\n    // This will also create the specified directory if\n\n    // it does not exist.\n\n    const basePath = path.join(directory);\n\n    await fs.mkdir(basePath, { recursive: true });\n\n\n\n    // Write the json to file\n\n    const storageItemPath = path.join(directory, `${this.name}.json`);\n\n    await fs.writeJSON(storageItemPath, this, { spaces: 2 });\n\n  }\n\n}\n\n\n'ion-cli/src/commands/load.ts'\n:import { Command, flags } from '@oclif/command';\n\nimport Output from '../Output';\n\nimport StorageItem from '../StorageItem';\n\nconst { cli } = require('cli-ux');\n\n\n\nexport default class Load extends Command {\n\n  public static description = 'Loads a DID from the directory using the friendly name.';\n\n\n\n  public static examples = [\n\n    '$ ion load FriendlyName',\n\n    '$ ion load FriendlyName -d d:/dids',\n\n    '$ ion load FriendlyName -d d:/dids --escape',\n\n  ];\n\n\n\n  public static flags = {\n\n    help: flags.help({ char: 'h' }),\n\n\n\n    // Flag for specifying a directory to which keys and documents should be saved.\n\n    directory: flags.string({ char: 'd', description: 'to which the DID should be saved. Defaults to environment variable DID_PATH if set.', env: 'DID_PATH', required: true }),\n\n\n\n    // Flag for specifying what specific objects to load from the package\n\n    what: flags.enum({ description: 'specify the objects from the specified package to load.', options: ['All', 'InitialState', 'Keys'], default: 'All' }),\n\n\n\n    // Flag for specifying the JSON string output should be escaped.\n\n    escape: flags.boolean({ description: 'specifies that the output JSON string should be escaped. Use this when using the output as input to another command.' }),\n\n  };\n\n\n\n  public static args = [\n\n    {\n\n      name: 'name',\n\n      required: true,\n\n      description: 'name for the new DID. Name should not include spaces or special characters.',\n\n    },\n\n  ];\n\n\n\n  public async run () {\n\n    const { args, flags } = this.parse(Load);\n\n\n\n    // Load the DID and return\n\n    cli.action.start(`Loading DID '${args.name}' from '${flags.directory}'.`);\n\n    const didPackage: StorageItem = await StorageItem.load(flags.directory, args.name);\n\n    cli.action.stop();\n\n\n\n    let packageSubset;\n\n    switch (flags.what) {\n\n      case 'InitialState':\n\n        packageSubset = didPackage.initialState;\n\n        break;\n\n      case 'Keys':\n\n        packageSubset = didPackage.keys;\n\n        break;\n\n      default:\n\n        packageSubset = didPackage;\n\n    }\n\n\n\n    this.log(Output.toJson(packageSubset, flags.escape));\n\n    this.exit();\n\n  }\n\n}\n\n\n",
        "called_code_segment_file_1": "public static async load (directory: string, name: string): Promise<StorageItem> {\n    if (!directory) {\n      throw new Error('A directory is required.');\n    }\n\n    if (!name) {\n      throw new Error('A name is required.');\n    }\n\n    // Load the DID from the directory and\n    // return\n    const storageItemPath = path.join(directory, `${name}.json`);\n    const storageItemJson = await fs.readJson(storageItemPath, { encoding: 'utf-8' });\n    return plainToClass(StorageItem, <object>storageItemJson);\n  }",
        "invoking_code_segment_file_2": "public async run () {\n    const { args, flags } = this.parse(Load);\n\n    // Load the DID and return\n    cli.action.start(`Loading DID '${args.name}' from '${flags.directory}'.`);\n    const didPackage: StorageItem = await StorageItem.load(flags.directory, args.name);\n    cli.action.stop();\n\n    let packageSubset;\n    switch (flags.what) {\n      case 'InitialState':\n        packageSubset = didPackage.initialState;\n        break;\n      case 'Keys':\n        packageSubset = didPackage.keys;\n        break;\n      default:\n        packageSubset = didPackage;\n    }\n\n    this.log(Output.toJson(packageSubset, flags.escape));\n    this.exit();\n  }",
        "invoking_code_segment_file_3": "// No direct invocation of #file 1 in #file 3 found.",
        "new_file_code_segment": "export default class DIDMetadata {\n  public static async getMetadata (didPackage: StorageItem): Promise<any> {\n    return {\n      name: didPackage.name,\n      created: didPackage.created,\n      published: didPackage.published\n    };\n  }\n}",
        "feature_description": "Add a feature to retrieve metadata from a DID package.",
        "detailed_feature_description": "The new feature involves creating a new class `DIDMetadata` in #file 4 that provides a method to retrieve metadata from a `StorageItem` instance. This method will be invoked in #file 2 to include metadata in the output JSON. This ensures that the metadata is easily accessible and can be used for various purposes such as logging or further processing.",
        "modified_complete_code": {
            "#file 1": "// Modify for modified parts and #New for newly added parts\npublic static async load (directory: string, name: string): Promise<StorageItem> {\n    if (!directory) {\n      throw new Error('A directory is required.');\n    }\n\n    if (!name) {\n      throw new Error('A name is required.');\n    }\n\n    // Load the DID from the directory and\n    // return\n    const storageItemPath = path.join(directory, `${name}.json`);\n    const storageItemJson = await fs.readJson(storageItemPath, { encoding: 'utf-8' });\n    return plainToClass(StorageItem, <object>storageItemJson);\n  }",
            "#file 2": "// Modify for modified parts and #New for newly added parts\nimport DIDMetadata from './DIDMetadata';\n\npublic async run () {\n    const { args, flags } = this.parse(Load);\n\n    // Load the DID and return\n    cli.action.start(`Loading DID '${args.name}' from '${flags.directory}'.`);\n    const didPackage: StorageItem = await StorageItem.load(flags.directory, args.name);\n    cli.action.stop();\n\n    let packageSubset;\n    switch (flags.what) {\n      case 'InitialState':\n        packageSubset = didPackage.initialState;\n        break;\n      case 'Keys':\n        packageSubset = didPackage.keys;\n        break;\n      default:\n        packageSubset = didPackage;\n    }\n\n    // #New: Include metadata in the output\n    const metadata = await DIDMetadata.getMetadata(didPackage);\n    packageSubset = { ...packageSubset, metadata };\n\n    this.log(Output.toJson(packageSubset, flags.escape));\n    this.exit();\n  }",
            "#file 3": "// No direct invocation of #file 1 in #file 3 found.",
            "#file 4": "// New file for the new feature\nexport default class DIDMetadata {\n  public static async getMetadata (didPackage: StorageItem): Promise<any> {\n    return {\n      name: didPackage.name,\n      created: didPackage.created,\n      published: didPackage.published\n    };\n  }\n}"
        }
    },
    {
        "repo": "map-clustering-rn-example",
        "content": "'map-clustering-rn-example/components/helpers.tsx'\n:import GeoViewport from '@mapbox/geo-viewport'\nimport { Dimensions } from 'react-native'\n\nconst { width, height } = Dimensions.get('window')\n\nexport const isMarker = (child: JSX.Element): boolean =>\n  child && child.props && child.props.coordinate && child.props.cluster !== false\n\nexport const calculateBBox = (region) => {\n  let lngD\n  if (region.longitudeDelta < 0) lngD = region.longitudeDelta + 360\n  else lngD = region.longitudeDelta\n\n  return [\n    region.longitude - lngD, // westLng - min lng\n    region.latitude - region.latitudeDelta, // southLat - min lat\n    region.longitude + lngD, // eastLng - max lng\n    region.latitude + region.latitudeDelta, // northLat - max lat\n  ]\n}\n\nexport const returnMapZoom = (region, bBox, minZoom) => {\n  const viewport =\n    region.longitudeDelta >= 40 ? { zoom: minZoom } : GeoViewport.viewport(bBox, [width, height])\n\n  return viewport.zoom\n}\n\nexport const markerToGeoJSONFeature = (marker, index) => {\n  return {\n    type: 'Feature',\n    geometry: {\n      coordinates: [marker.props.coordinate.longitude, marker.props.coordinate.latitude],\n      type: 'Point',\n    },\n    properties: {\n      point_count: 0,\n      index,\n      ..._removeChildrenFromProps(marker.props),\n    },\n  }\n}\n\nexport const generateSpiral = (marker, clusterChildren, markers, index) => {\n  const { properties, geometry } = marker\n  const count = properties.point_count\n  const centerLocation = geometry.coordinates\n\n  const res = []\n  let angle = 0\n  let start = 0\n\n  for (let i = 0; i < index; i++) {\n    start += markers[i].properties.point_count || 0\n  }\n\n  for (let i = 0; i < count; i++) {\n    angle = 0.25 * (i * 0.5)\n    const latitude = centerLocation[1] + 0.0002 * angle * Math.cos(angle)\n    const longitude = centerLocation[0] + 0.0002 * angle * Math.sin(angle)\n\n    if (clusterChildren[i + start]) {\n      res.push({\n        index: clusterChildren[i + start].properties.index,\n        longitude,\n        latitude,\n        centerPoint: {\n          latitude: centerLocation[1],\n          longitude: centerLocation[0],\n        },\n      })\n    }\n  }\n\n  return res\n}\n\nexport const returnMarkerStyle = (points) => {\n  if (points >= 50) {\n    return {\n      width: 84,\n      height: 84,\n      size: 64,\n      fontSize: 20,\n    }\n  }\n\n  if (points >= 25) {\n    return {\n      width: 78,\n      height: 78,\n      size: 58,\n      fontSize: 19,\n    }\n  }\n\n  if (points >= 15) {\n    return {\n      width: 72,\n      height: 72,\n      size: 54,\n      fontSize: 18,\n    }\n  }\n\n  if (points >= 10) {\n    return {\n      width: 66,\n      height: 66,\n      size: 50,\n      fontSize: 17,\n    }\n  }\n\n  if (points >= 8) {\n    return {\n      width: 60,\n      height: 60,\n      size: 46,\n      fontSize: 17,\n    }\n  }\n\n  if (points >= 4) {\n    return {\n      width: 54,\n      height: 54,\n      size: 40,\n      fontSize: 16,\n    }\n  }\n\n  return {\n    width: 48,\n    height: 48,\n    size: 36,\n    fontSize: 15,\n  }\n}\n\nconst _removeChildrenFromProps = (props) => {\n  const newProps = {}\n  Object.keys(props).forEach((key) => {\n    if (key !== 'children') {\n      newProps[key] = props[key]\n    }\n  })\n  return newProps\n}\n\n'map-clustering-rn-example/components/ClusteredMarker.tsx'\n:import React, { memo } from 'react'\nimport { StyleSheet, Text, TouchableOpacity, View } from 'react-native'\nimport { Marker } from 'react-native-maps'\n\nimport { returnMarkerStyle } from './helpers'\n\nconst ClusteredMarker = ({\n  geometry,\n  properties,\n  onPress,\n  clusterColor,\n  clusterTextColor,\n  clusterFontFamily,\n  tracksViewChanges,\n}) => {\n  const points = properties.point_count\n  const { width, height, fontSize, size } = returnMarkerStyle(points)\n\n  return (\n    <Marker\n      key={`${geometry.coordinates[0]}_${geometry.coordinates[1]}`}\n      coordinate={{\n        longitude: geometry.coordinates[0],\n        latitude: geometry.coordinates[1],\n      }}\n      style={{ zIndex: points + 1 }}\n      onPress={onPress}\n      tracksViewChanges={tracksViewChanges}>\n      <TouchableOpacity activeOpacity={0.5} style={[styles.container, { width, height }]}>\n        <View\n          style={[\n            styles.wrapper,\n            {\n              backgroundColor: clusterColor,\n              width,\n              height,\n              borderRadius: width / 2,\n            },\n          ]}\n        />\n        <View\n          style={[\n            styles.cluster,\n            {\n              backgroundColor: clusterColor,\n              width: size,\n              height: size,\n              borderRadius: size / 2,\n            },\n          ]}>\n          <Text\n            style={[\n              styles.text,\n              {\n                color: clusterTextColor,\n                fontSize,\n                fontFamily: clusterFontFamily,\n              },\n            ]}>\n            {points}\n          </Text>\n        </View>\n      </TouchableOpacity>\n    </Marker>\n  )\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  wrapper: {\n    position: 'absolute',\n    opacity: 0.5,\n    zIndex: 0,\n  },\n  cluster: {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    zIndex: 1,\n  },\n  text: {\n    fontWeight: 'bold',\n  },\n})\n\nexport default memo(ClusteredMarker)\n\n'map-clustering-rn-example/components/ClusteredMapView.tsx'\n:/* \n  This component is taken from the venits/react-native-map-clustering repository and \n  imported into ours so that you can replace something and experiment with working with \n  clusters yourself.\n  \n  Some parts of this code may have already been changed.\n*/\n\nimport React, { forwardRef, memo, useEffect, useMemo, useRef, useState } from 'react'\nimport { Dimensions, LayoutAnimation, Platform } from 'react-native'\nimport MapView, { MapViewProps, Polyline } from 'react-native-maps'\nimport SuperCluster from 'supercluster'\n\nimport { MapClusteringProps } from './ClusteredMapViewTypes'\nimport ClusterMarker from './ClusteredMarker'\nimport {\n  calculateBBox,\n  generateSpiral,\n  isMarker,\n  markerToGeoJSONFeature,\n  returnMapZoom,\n} from './helpers'\n\nconst ClusteredMapView = forwardRef<MapClusteringProps & MapViewProps, any>(\n  (\n    {\n      radius,\n      maxZoom,\n      minZoom,\n      minPoints,\n      extent,\n      nodeSize,\n      children,\n      onClusterPress,\n      onRegionChangeComplete,\n      onMarkersChange,\n      preserveClusterPressBehavior,\n      clusteringEnabled,\n      clusterColor,\n      clusterTextColor,\n      clusterFontFamily,\n      spiderLineColor,\n      layoutAnimationConf,\n      animationEnabled,\n      renderCluster,\n      tracksViewChanges,\n      spiralEnabled,\n      superClusterRef,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const [markers, updateMarkers] = useState([])\n    const [spiderMarkers, updateSpiderMarker] = useState([])\n    const [otherChildren, updateChildren] = useState([])\n    const [superCluster, setSuperCluster] = useState(null)\n    const [currentRegion, updateRegion] = useState(restProps.region || restProps.initialRegion)\n\n    const [isSpiderfier, updateSpiderfier] = useState(false)\n    const [clusterChildren, updateClusterChildren] = useState(null)\n    const mapRef = useRef()\n\n    const propsChildren = useMemo(() => React.Children.toArray(children), [children])\n\n    useEffect(() => {\n      const rawData = []\n      const otherChildren = []\n\n      if (!clusteringEnabled) {\n        updateSpiderMarker([])\n        updateMarkers([])\n        updateChildren(propsChildren)\n        setSuperCluster(null)\n        return\n      }\n\n      propsChildren.forEach((child, index) => {\n        if (isMarker(child)) {\n          rawData.push(markerToGeoJSONFeature(child, index))\n        } else {\n          otherChildren.push(child)\n        }\n      })\n\n      const superCluster = new SuperCluster({\n        radius,\n        maxZoom,\n        minZoom,\n        minPoints,\n        extent,\n        nodeSize,\n      })\n\n      superCluster.load(rawData)\n\n      const bBox = calculateBBox(currentRegion)\n      const zoom = returnMapZoom(currentRegion, bBox, minZoom)\n      const markers = superCluster.getClusters(bBox, zoom)\n\n      updateMarkers(markers)\n      updateChildren(otherChildren)\n      setSuperCluster(superCluster)\n\n      superClusterRef.current = superCluster\n    }, [propsChildren, clusteringEnabled])\n\n    useEffect(() => {\n      if (!spiralEnabled) {\n        return\n      }\n\n      if (isSpiderfier && markers.length > 0) {\n        const allSpiderMarkers = []\n        let spiralChildren = []\n        markers.map((marker, i) => {\n          if (marker.properties.cluster) {\n            spiralChildren = superCluster.getLeaves(marker.properties.cluster_id, Infinity)\n          }\n          const positions = generateSpiral(marker, spiralChildren, markers, i)\n          allSpiderMarkers.push(...positions)\n        })\n\n        updateSpiderMarker(allSpiderMarkers)\n      } else {\n        updateSpiderMarker([])\n      }\n    }, [isSpiderfier, markers])\n\n    const _onRegionChangeComplete = (region) => {\n      if (superCluster && region) {\n        const bBox = calculateBBox(region)\n        const zoom = returnMapZoom(region, bBox, minZoom)\n        const markers = superCluster.getClusters(bBox, zoom)\n        if (animationEnabled && Platform.OS === 'ios') {\n          LayoutAnimation.configureNext(layoutAnimationConf)\n        }\n        if (zoom >= 18 && markers.length > 0 && clusterChildren) {\n          if (spiralEnabled) {\n            updateSpiderfier(true)\n          }\n        } else {\n          if (spiralEnabled) {\n            updateSpiderfier(false)\n          }\n        }\n        updateMarkers(markers)\n        onMarkersChange(markers)\n        onRegionChangeComplete(region, markers)\n        updateRegion(region)\n      } else {\n        onRegionChangeComplete(region)\n      }\n    }\n\n    const _onClusterPress = (cluster) => () => {\n      const children = superCluster.getLeaves(cluster.id, Infinity)\n      updateClusterChildren(children)\n\n      if (preserveClusterPressBehavior) {\n        onClusterPress(cluster, children)\n        return\n      }\n\n      const coordinates = children.map(({ geometry }) => ({\n        latitude: geometry.coordinates[1],\n        longitude: geometry.coordinates[0],\n      }))\n\n      mapRef.current.fitToCoordinates(coordinates, {\n        edgePadding: restProps.edgePadding,\n      })\n\n      onClusterPress(cluster, children)\n    }\n\n    return (\n      <MapView\n        {...restProps}\n        ref={(map) => {\n          mapRef.current = map\n          if (ref) {\n            ref.current = map\n          }\n          restProps.mapRef(map)\n        }}\n        onRegionChangeComplete={_onRegionChangeComplete}>\n        {markers.map((marker) =>\n          marker.properties.point_count === 0 ? (\n            propsChildren[marker.properties.index]\n          ) : !isSpiderfier ? (\n            renderCluster ? (\n              renderCluster({\n                onPress: _onClusterPress(marker),\n                clusterColor,\n                clusterTextColor,\n                clusterFontFamily,\n                ...marker,\n              })\n            ) : (\n              <ClusterMarker\n                key={`cluster-${marker.id}`}\n                {...marker}\n                onPress={_onClusterPress(marker)}\n                clusterColor={\n                  restProps.selectedClusterId === marker.id\n                    ? restProps.selectedClusterColor\n                    : clusterColor\n                }\n                clusterTextColor={clusterTextColor}\n                clusterFontFamily={clusterFontFamily}\n                tracksViewChanges={tracksViewChanges}\n              />\n            )\n          ) : null,\n        )}\n        {otherChildren}\n        {spiderMarkers.map((marker) => {\n          return propsChildren[marker.index]\n            ? React.cloneElement(propsChildren[marker.index], {\n                coordinate: { ...marker },\n              })\n            : null\n        })}\n        {spiderMarkers.map((marker, index) => (\n          <Polyline\n            key={index}\n            coordinates={[marker.centerPoint, marker, marker.centerPoint]}\n            strokeColor={spiderLineColor}\n            strokeWidth={1}\n          />\n        ))}\n      </MapView>\n    )\n  },\n)\n\nClusteredMapView.defaultProps = {\n  clusteringEnabled: true,\n  spiralEnabled: true,\n  animationEnabled: true,\n  preserveClusterPressBehavior: false,\n  layoutAnimationConf: LayoutAnimation.Presets.spring,\n  tracksViewChanges: false,\n  // SuperCluster parameters\n  radius: Dimensions.get('window').width * 0.06,\n  maxZoom: 20,\n  minZoom: 1,\n  minPoints: 2,\n  extent: 512,\n  nodeSize: 64,\n  // Map parameters\n  edgePadding: { top: 50, left: 50, right: 50, bottom: 50 },\n  // Cluster styles\n  clusterColor: '#00B386',\n  clusterTextColor: '#FFFFFF',\n  spiderLineColor: '#FF0000',\n  // Callbacks\n  onRegionChangeComplete: () => {},\n  onClusterPress: () => {},\n  onMarkersChange: () => {},\n  superClusterRef: {},\n  mapRef: () => {},\n}\n\nexport default memo(ClusteredMapView)\n\n",
        "called_code_segment_file_1": "const { width, height } = Dimensions.get('window')",
        "invoking_code_segment_file_2": "const { width, height } = Dimensions.get('window')",
        "invoking_code_segment_file_3": "const { width, height } = Dimensions.get('window')",
        "new_file_code_segment": "export const calculateScreenSize = () => { return Dimensions.get('window') }",
        "feature_description": "Add a new function to calculate screen size and use it across files.",
        "detailed_feature_description": "The new feature introduces a function to calculate the screen size using Dimensions.get('window'). This function is added in a new file (#file 4) and is invoked in #file 1, #file 2, and #file 3 to replace the direct use of Dimensions.get('window'). This ensures a consistent and centralized way to handle screen size calculations across the application.",
        "modified_complete_code": {
            "#file 1": "//Modify const { width, height } = calculateScreenSize()",
            "#file 2": "//Modify const { width, height } = calculateScreenSize()",
            "#file 3": "//Modify const { width, height } = calculateScreenSize()",
            "#file 4": "//New export const calculateScreenSize = () => { return Dimensions.get('window') }"
        }
    },
    {
        "repo": "mininext",
        "content": "'mininext/mininext/url.ts'\n:import type { Server, WebSocketHandler } from \"bun\";\nimport { htmlResponder, html, json, dangerjson, HtmlString } from \"./html\";\nimport {\n  BasedHtml,\n  type DangerJsonInHtml,\n  type JsonString,\n  type JsonStringValues,\n} from \"./html\";\n/**\n * A helper function that helps narrow unknown objects\n * @param object - the object of type unknown that is to be narrowed\n * @param key - the key that may or may not exist in object\n * @returns true if the key is present and false if not\n * @example\n * ``` js\n * has(this.form.formJson, \"formName\") &&\n * this.form.formJson.formName === this.form.formName\n * ```\n * https://stackoverflow.com/questions/70028907/narrowing-an-object-of-type-unknown\n */\nexport function has<T, K extends string>(\n  object: T,\n  key: K\n): object is T & object & Record<K, unknown> {\n  return typeof object === \"object\" && object !== null && key in object;\n}\nexport type Form = {\n  post: boolean;\n  urlencoded: boolean;\n  multipart: boolean;\n  formJson?: unknown;\n  formData?: FormData;\n  formName?: string;\n  hiddenField?: HtmlString;\n  actionlink<Y = unknown>(\n    qs?: string[] | string,\n    settings?: LinkSettings\n  ): (mini: Mini<Y>) => string;\n  onPostSubmit<F>(cb: () => F): F | undefined;\n};\n\nexport type DataMaker<X, Z = unknown> =\n  | ((mini: Mini, rerun?: Z) => DataMakerReturnType<X>)\n  | (() => DataMakerReturnType<X>);\nexport type DataMakerReturnType<X> = X | Promise<X>;\nexport type HandlerReturnType =\n  | JsonString\n  | DangerJsonInHtml\n  | HtmlString\n  | string\n  | void;\nexport type LazyHandlerReturnType =\n  | HandlerReturnType\n  | Promise<HandlerReturnType>;\n\nexport type NamedForm<Z> = {\n  formResponse: LazyHandlerReturnType;\n  formInfo?: Z;\n};\nexport type NamedFormHandlerReturnType<X> =\n  | HandlerReturnType\n  | Promise<HandlerReturnType>\n  | NamedForm<X>\n  | Promise<NamedForm<X>>;\n\n/**\n * Mini - the data object can be filled with url.data\n * @example\n * ``` js\n * const {html,json, css, data, req, form, link, svg, deliver, route, params, header, head } = mini  //pull everything out of the mini handbag\n * ```\n */\nexport class Mini<X = unknown> {\n  html: typeof html<X>;\n  css: typeof html<X>;\n  json: typeof json<X>;\n  dangerjson: typeof dangerjson<X>;\n\n  data: X;\n  req!: Request;\n  head!: (head: HtmlHandler | HtmlString) => undefined;\n  headers!: (headers: HeadersInit, overwrite?: boolean) => undefined;\n  options!: (options: ResponseInit) => undefined;\n  deliver!: typeof url.deliver;\n  route!: string;\n  params!: URLSearchParams;\n  form!: Form;\n  requrl!: Readonly<URL>;\n  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/redirect_static) */\n  redirect!: (url: string | URL, status?: number) => void;\n\n  constructor(mini: Mini<unknown>, data: X) {\n    Object.assign(this, mini);\n    this.html = html<X>;\n    this.css = html<X>;\n    this.json = json<X>;\n    this.dangerjson = dangerjson<X>;\n    this.data = data;\n    this.deliver = url.deliver;\n    this.form.onPostSubmit = (cb) => {\n      if (this.form.formName) {\n        if (\n          this.form.formData &&\n          this.form.formData.get(\"formName\") === this.form.formName\n        ) {\n          return cb();\n        } else if (\n          has(this.form.formJson, \"formName\") &&\n          this.form.formJson.formName === this.form.formName\n        ) {\n          return cb();\n        }\n      } else if (this.form.post) {\n        return cb();\n      }\n    };\n  }\n}\n/**\n * HtmlHandler\n * @param mini - the mini object\n * @returns - return a partially resolved html string with mini.html\n * @example\n * ``` js\n * const {html,json, css, data, req, form, link, svg, deliver, route, params, header, head } = mini  //pull everything out of the mini handbag\n * ```\n */\nexport type HtmlHandler<Y = unknown> =\n  | ((mini: Mini<Y>) => LazyHandlerReturnType)\n  | (() => LazyHandlerReturnType);\nexport type NamedFormHandler<Y = unknown, Z = undefined> =\n  | ((mini: Mini<Y>) => NamedFormHandlerReturnType<Z>)\n  | (() => NamedFormHandlerReturnType<Z>);\n\ndeclare global {\n  var FrontendScripts: Array<string>; // An array of the bundled scriptFiles corresponding to the frontend files, example frontends[0] = \"index.tsx\" -> FrontendScripts[0] = CONTENT OF frontend/index.js\n  var FrontendScriptUrls: Array<string>;\n  var bundledSVGs: Record<string, { svgContent: string; svgPath: string }>;\n}\nexport type ScriptTag = (...params: any[]) => Promise<HtmlString>;\ninterface LinkSettings {\n  [key: string]: string | null | undefined;\n}\nexport class url {\n  static websocket: WebSocketHandler | undefined = undefined;\n  static server: Server;\n\n  // direct mapping of \"url string\" -> function leads to Html Response\n  static direct_handlers_html: Map<string, HtmlHandler> = new Map();\n\n  // An array of the uncompiled frontend files, example frontends[0] = \"index.tsx\" -> frontend/index.tsx (from the project root)\n  private static frontends: Array<{ path: string; callerPath: string }> = [];\n  private static svgs: Map<string, ResponseInit> = new Map();\n\n  static svg(\n    path: string,\n    options: ResponseInit = {\n      headers: {\n        \"Content-Type\": \"image/svg+xml\",\n        \"Content-Disposition\": \"attachment\",\n      },\n    }\n  ) {\n    url.svgs.set(path, options);\n    var foundEntry = Object.entries(bundledSVGs).find(\n      ([key, value]) => value.svgPath === path\n    );\n\n    return foundEntry && foundEntry[0];\n  }\n  static frontend<X>(path: string, snippet?: BasedHtml): HtmlString;\n  static frontend<X>(\n    path: string,\n    snippet?: HtmlHandler<X>\n  ): (mini: Mini<X>) => HtmlString;\n  static frontend<X>(path: string, snippet?: HtmlHandler<X> | BasedHtml) {\n    const stack = new Error().stack?.split(\"\\n\");\n    let callerPath = \"\";\n    if (stack) {\n      callerPath = stack[2].slice(\n        stack[2].lastIndexOf(\"(\") + 1,\n        stack[2].lastIndexOf(\".\") + 3\n      );\n    }\n    const frontendIndex = url.frontends.push({ path, callerPath }) - 1;\n    const scriptUrl = FrontendScriptUrls[frontendIndex];\n    if (snippet instanceof BasedHtml || !snippet) {\n      return html` ${snippet}\n        <script type=\"module\" src=\"${scriptUrl}\"></script>`; // return an html script tag with the index hash\n    }\n    return (mini: Mini<X>) => {\n      return mini.html`${snippet}\n        <script type=\"module\" src=\"${scriptUrl}\"></script>`;\n    };\n  }\n  /**\n   * This is used by the frontend bundler in order to find all frontends and their corresponding script files.\n   */\n  static getFrontends() {\n    return url.frontends;\n  }\n  static getSvgPaths() {\n    return [...url.svgs.keys()];\n  }\n  static serveFrontend(req: Request) {\n    const reqPath = new URL(req.url).pathname;\n    const index = FrontendScriptUrls.indexOf(reqPath);\n\n    if (index !== -1) {\n      return new Response(FrontendScripts[index], {\n        headers: {\n          \"Content-Type\": \"application/javascript; charset=utf-8\",\n        },\n      });\n    }\n  }\n  static serveSvg(req: Request) {\n    const reqPath = new URL(req.url).pathname;\n    const resolvedSvg = bundledSVGs[reqPath];\n    if (resolvedSvg) {\n      return new Response(\n        resolvedSvg.svgContent,\n        url.svgs.get(resolvedSvg.svgPath)\n      );\n    }\n  }\n  /**\n   * tool to expose data to a frontend as a global variable.\n   * @param name  this will be added as window.name to the window object in the frontend\n   * @param value this will be parsed as json in the frontend and asigned as follows: window.name = JSON.parsed(value)\n   * @returns the script tag to be embeded in the html response\n   *\n   * @example\n   * ``` js\n   * //backend\n   * url.deliver(\"user\", userData); // window.user = JSON.parse(userData)\n   * //frontend\n   * const user = window[\"user\"];\n   * ```\n   * if you want to use types, declare them like so in your frontend code:\n   * ``` ts\n   * declare global {\n   * var user: string;\n   *}\n   * ```\n   */\n  static deliver(name: string, value: JsonStringValues) {\n    return html` <script type=\"application/json\" id=\"${name}\">\n        ${dangerjson`${value}`}\n      </script>\n\n      <script>\n        window[\"${name}\"] = JSON.parse(\n          document.getElementById(\"${name}\").innerHTML\n        );\n      </script>`;\n  }\n  /**\n   * @param dataHandler the function that prepares the data for the handlers\n   * @example const {html,json, css, data, req, form, link, svg, deliver, route, params, header, head } = mini  //pull everything out of the mini handbag\n   * @returns\n   */\n  static data<T, Z>(dataMaker: DataMaker<T, Z>) {\n    return {\n      /**\n       * @param dataHandler the function that prepares the data for the handlers\n       * @example const {html,json, css, data, req, form, link, svg, deliver, route, params, header, head } = mini  //pull everything out of the mini handbag\n       * @returns\n       */\n      handler: (dataHandler: HtmlHandler<T>) => {\n        return async (oldmini: Mini) => {\n          const data = await dataMaker(oldmini);\n          const mini = new Mini(oldmini, data);\n\n          const unresolvedDataHandler = await dataHandler(mini); // passing mini\n          if (unresolvedDataHandler instanceof HtmlString) {\n            return await unresolvedDataHandler.resolve(mini);\n          }\n          return unresolvedDataHandler;\n        };\n      },\n      dataMaker,\n      /**\n       * use this to **specify the input type for the functions**,\n       *\n       * that you want to use in the HtmlHandlers that follow this **data blend!**\n       * @example type lol = typeof MaybeLoggedIn.$Mini\n       */\n      $Mini: {\n        data: \"DONT USE THIS DIRECTLY, ya goofball. This is just to infer the Mini type\",\n      } as Mini<T>,\n      /**\n       * use this to **specify the input type for the functions**,\n       *\n       * that you want to use in the Htmlhandlers that follow this **data blend!**\n       * @example type haha = Mini<typeof MaybeLoggedIn.$Data>\n       */\n      $Data: {\n        data: \"DONT USE THIS DIRECTLY, ya goofball. This is just to infer the Mini type\",\n      } as T,\n    };\n  }\n  /**\n   * use this to define your routes.\n   * @example\n   * ``` js\n   *   //define all routes at once\n   *    url.set([\n   *      [\"/\", (mini) => mini.html`<h1>Hello world</h1>`],\n   *      [\"/apple\", (mini) => mini.html`<h1>Hello apple</h1>`],\n   *      [\"/banana\", (mini) => mini.html`<h1>Hello banana</h1>`],\n   *    ]);\n   *    //define or overwrite just one route\n   *  url.set(\"/apple\", (mini)=>mini.html`<h1> Hello pineapple </h1>`)\n   * ```\n   */\n  static set<K extends string>(entries: [K, HtmlHandler][]): void;\n  static set(urlPath: string, handler: HtmlHandler): void;\n  static set<K extends string>(\n    entries: [K, HtmlHandler][] | string,\n    handler?: HtmlHandler\n  ) {\n    function addUrl(entryUrl: string, entryHandler: HtmlHandler) {\n      for (const u of url.generateVariations(entryUrl)) {\n        url.direct_handlers_html.set(u, entryHandler);\n      }\n    }\n\n    if (typeof entries === \"string\" && handler) {\n      addUrl(entries, handler);\n    }\n    if (typeof entries !== \"string\")\n      for (const [entryUrl, entryHandler] of entries) {\n        addUrl(entryUrl, entryHandler);\n      }\n  }\n  /**\n   * use this to remove routes.\n   * @param urlPath - the route to remove\n   * @example\n   * ``` js\n   * let perma_link_defined_by_editor_or_admin_user_that_changed = \"/haha\"\n   * url.remove(perma_link_defined_by_editor_or_admin_user_that_changed);\n   * // add new url after removing the old one (that might come from a sqlite db)\n   * url.set(\"/huhu\", (mini)=> mini.html`huhu`)\n   * ```\n   */\n  static remove(urlPath: string) {\n    for (const u of url.generateVariations(urlPath)) {\n      url.direct_handlers_html.delete(u);\n    }\n  }\n  /**\n   * wrap your handlers in this if you mutate something to prevent CSRF issues.\n   * @param handler - normal html handler with mini as the argument\n   * @returns a wrapped html handler that will only be called when the request is post\n   */\n  static post(handler: HtmlHandler) {\n    return (mini: Mini) => {\n      if (mini.form.post) {\n        return handler(mini);\n      } else {\n        return no_post_warning;\n      }\n    };\n  }\n  /**\n   * wrap your handlers in this if you mutate something to prevent CSRF issues.\n   * @param handler - normal html handler with mini as the argument\n   * @returns a wrapped html handler that will only be called when the request is post and contains a json body\n   */\n  static postJson(handler: HtmlHandler) {\n    return (mini: Mini) => {\n      if (mini.form.formJson) {\n        return handler(mini);\n      } else {\n        return no_post_warning;\n      }\n    };\n  }\n  /**\n   * wrap your handlers in this if you mutate something to prevent CSRF issues.\n   * @param handler - normal html handler with mini as the argument\n   * @returns a wrapped html handler that will only be called when the request is post and contains a FormData body\n   */\n  static postFormData(handler: HtmlHandler) {\n    return (mini: Mini) => {\n      if (mini.form.formData) {\n        return handler(mini);\n      } else {\n        return no_post_warning;\n      }\n    };\n  }\n  /**\n   * This is useful to decouple forms from routes.\n   * @param name name of the form - mini.form.onPostSubmit() will only be called if a (possibly hidden) field called formName matches this\n   * @param handler just like a normal handler (aka you can return the form as a HtmlString), but you can optionally return additional data in formInfo\n   * @returns - { formResponse: result of the handler, formInfo?: some info about the form. Totally up to you}\n   */\n  static namedForm<X = unknown, Z = undefined>(\n    name: string,\n    handler: NamedFormHandler<X, Z>\n  ) {\n    return async (mini: Mini<X>) => {\n      mini.form.formName = name;\n      mini.form.hiddenField = html`<input\n        type=\"hidden\"\n        name=\"formName\"\n        value=\"${name}\"\n      />`;\n      const namedFormResponse = await handler(mini);\n      let handlerResult = {} as NamedForm<Z>;\n      if (\n        typeof namedFormResponse !== \"string\" &&\n        namedFormResponse &&\n        \"formResponse\" in namedFormResponse\n      ) {\n        handlerResult.formResponse = await namedFormResponse.formResponse;\n        handlerResult.formInfo = namedFormResponse.formInfo;\n      } else {\n        handlerResult.formResponse = namedFormResponse;\n      }\n      delete mini.form.formName;\n      delete mini.form.hiddenField;\n      return handlerResult;\n    };\n  }\n\n  /**\n   * pass in all the query string parameter names that you want to preserve in the link\n   * @param Url - the url that you want to link to (example: \"/login\")\n   * @param qs - the query string parameters that you want to preserve in the link\n   * @param settings - key and string values that you want to set in the link\n   * @returns - the link that you can use in your html template\n   */\n  static link<X>(\n    Url: string,\n    qs: string[] | string = \"\",\n    settings?: LinkSettings\n  ) {\n    return (mini: Mini<X>) => {\n      return url.currylink(Url, qs, mini.req, settings);\n    };\n  }\n  static currylink(\n    Url: string,\n    qs: string[] | string,\n    req: Request,\n    settings?: LinkSettings\n  ) {\n    if (!Array.isArray(qs)) {\n      qs = [qs];\n    }\n    // Create a new URL object from the current location\n    // https://github.com/whatwg/url/issues/531#issuecomment-1337050285\n    const GOOFY_HACK = \"http://goofyhack.com\";\n    const updatedUrl = new URL(\n      url.get(Url) || \"/url_not_found_error\",\n      GOOFY_HACK\n    );\n    for (const q of qs) {\n      // Use URLSearchParams to set the name query parameter\n      const reqParam = new URL(req.url).searchParams.get(q);\n      if (reqParam) {\n        updatedUrl.searchParams.set(q, reqParam);\n      }\n    }\n    for (const key in settings) {\n      const value = settings[key];\n      if (value !== undefined && value !== null) {\n        updatedUrl.searchParams.set(key, value);\n      }\n    }\n    // Return the updated URL as a string\n    return updatedUrl.toString().slice(GOOFY_HACK.length);\n  }\n  /**\n   * users expect links to work with or without a trailing slash.\n   * Developers expect that that links work with or without a preceding slash.\n   * We make sure that these expectations are met when using url.set and url.get.\n   * (by adding all the variations to the url.direct_handlers Map)\n   * @param {string} inputString - the url\n   * @returns {string[]} - returns array of variations (added slash in the beginning, added, removed slash at the end)\n   */\n  static generateVariations(inputString: string) {\n    const variations = [];\n\n    // Special case for the index route\n    if (inputString === \"/\") {\n      variations.push(\"/\");\n      return variations;\n    }\n\n    // Check if the string starts with a slash and add/remove variations accordingly\n    if (inputString.startsWith(\"/\")) {\n      variations.push(inputString); // With leading slash\n    } else {\n      inputString = \"/\" + inputString;\n      variations.push(inputString); // With leading slash\n    }\n\n    // Check if the string ends with a slash and add/remove variations accordingly\n    if (inputString.endsWith(\"/\")) {\n      variations.push(inputString.slice(0, -1)); // Without trailing slash\n    } else {\n      variations.push(inputString + \"/\"); // With trailing slash\n    }\n\n    return variations;\n  }\n  /**\n   * This method retrieves a url from the urls array. If the url does not exist in the urls array, null will be returned.\n   * @param {string} Url - The url to retrieve.\n   * @return {string} - The retrieved url.\n   * @throws Will throw an Error if the provided url is not found in the urls array.\n   */\n  static get(Url: string) {\n    const foundUrl = url.direct_handlers_html.get(\n      url.generateVariations(Url)[0]\n    );\n    if (!foundUrl) {\n      return null;\n    }\n    return Url;\n  }\n  static async match(req: Request, reqPath?: string) {\n    const miniurl: Readonly<URL> = Object.freeze(new URL(req.url));\n    if (typeof reqPath === \"undefined\") {\n      reqPath = miniurl.pathname;\n    }\n    const handler = url.direct_handlers_html.get(reqPath);\n    if (handler) {\n      let redirectTarget: string | URL | null = null;\n      let redirectStatus: number | undefined = undefined;\n      let handlerHead: HtmlHandler | HtmlString | undefined = undefined;\n      let handlerOptions: ResponseInit = {\n        headers: {\n          \"Content-Type\": \"text/html; charset=utf-8\",\n        },\n      };\n      const post = req.method === \"POST\";\n      let formJson: unknown;\n      let formData: FormData | undefined;\n      const urlencoded = (req.headers.get(\"Content-Type\") + \"\").includes(\n        \"application/x-www-form-urlencoded\"\n      );\n      const multipart = (req.headers.get(\"Content-Type\") + \"\").includes(\n        \"multipart/form-data\"\n      );\n      if (post && !urlencoded && !multipart) {\n        const length = Number(req.headers.get(\"content-length\"));\n        const bodyNotEmpty = length > 0;\n        if (bodyNotEmpty) {\n          formJson = await req.json();\n        } else {\n          formJson = {};\n        }\n      }\n      if (post && (urlencoded || multipart)) {\n        formData = await req.formData();\n      }\n\n      //this is the source of mini\n      const mini = new Mini(\n        {\n          requrl: miniurl,\n          data: undefined,\n          req,\n          html,\n          css: html,\n          deliver: url.deliver,\n          route: reqPath,\n          params: new URL(req.url).searchParams,\n          json,\n          form: {\n            post,\n            urlencoded,\n            multipart,\n            formJson,\n            formData,\n            onPostSubmit(cb) {\n              if (post) {\n                return cb();\n              }\n            },\n            actionlink: (qs = \"\", settings) => url.link(reqPath, qs, settings),\n          },\n          dangerjson,\n          head: (head) => {\n            handlerHead = head;\n          },\n          headers: (headers, overwrite = false) => {\n            if (overwrite) {\n              handlerOptions.headers = headers;\n            } else {\n              handlerOptions.headers = {\n                ...handlerOptions.headers,\n                ...headers,\n              };\n            }\n          },\n          options: (options) => {\n            handlerOptions = options;\n          },\n          redirect: (url: string | URL, status?: number) => {\n            redirectTarget = url;\n            redirectStatus = status;\n          },\n        },\n        undefined\n      );\n      const unresolved = await handler(mini); //passing mini\n      if (redirectTarget) {\n        return Response.redirect(redirectTarget, redirectStatus);\n      }\n      return htmlResponder(mini, unresolved, handlerHead, handlerOptions);\n    }\n  }\n  /**\n   * user this to set the Websocket object. Check out [the bun docs](https://bun.sh/docs/api/websockets) for more details.\n   * @param wsObject the websocketsocket object {@link WebSocketHandler}\n   */\n  static setWebsocket<T = undefined>(wsObject: WebSocketHandler<T>) {\n    url.websocket = wsObject as WebSocketHandler;\n  }\n  /**\n   * Send a message to all connected {@link ServerWebSocket} subscribed to a topic\n   * @param topic The topic to publish to\n   * @param message The data to send\n   * @returns 0 if the message was dropped, -1 if backpressure was applied, or the number of bytes sent.\n   */\n  static publishHtml(topic: string, message: BasedHtml) {\n    return url.server.publish(topic, message as string);\n  }\n  /**\n   * Fetch handler that is called by the server when a request is made to any of the urls.\n   * @param {Request} req - The Request object.\n   * @return {Promise<Response>} - The Response object.\n   */\n  static install() {\n    async function fetchFunction(req: Request, server: Server) {\n      if (!url.server) url.server = server;\n      //go through all the Htmlhandlers and see if there is a match\n      let res = await url.match(req);\n      if (res) return res;\n\n      //handle frontend js file serving\n      res = url.serveFrontend(req);\n      if (res) return res;\n      //handle svg file serving\n      res = url.serveSvg(req);\n      if (res) return res;\n\n      return new Response(\"No matching url found\", { status: 404 });\n    }\n    return { fetch: fetchFunction, websocket: url.websocket };\n  }\n}\n\nconst no_post_warning = html`<div style=\"color:red;\">\n  This method is only accessible through the POST method. Remember to make all\n  mutations (insert / update data in the database) only accessible via POST and\n  implement your session cookies like this:\n  <div\n    style=\"color:#0FFF50; width:800px; overflow:wrap; margin-left:30px; margin-top:20px; margin-bottom:20px;\"\n  >\n    \"Set-Cookie\": sessionId==\"some random string made with crypto.randomUUID()\"\n    expires=Thu, 01 Jan 1970 00:00:00 GMT Secure; HttpOnly; SameSite=Strict;\n    path=/,\n  </div>\n  This is necessary to prevent CSRF issues.\n</div>`;\n\n'mininext/mininext/mininext.ts'\n:import { url, Mini, has, type HtmlHandler } from \"./url\";\nimport {\n  isError,\n  HtmlString,\n  BasedHtml,\n  head,\n  commonHead,\n  cssReset,\n  basedHtml as html,\n} from \"./html\";\nimport { $, type BunPlugin, type Server, type WebSocketHandler } from \"bun\";\nimport { watch } from \"fs/promises\";\nimport * as path from \"path\";\nfunction projectRoot() {\n  return global.PROJECT_ROOT || import.meta.dir + \"/../../../../\";\n}\ndeclare global {\n  var PROJECT_ROOT: string | undefined;\n}\nasync function build(backendPath: string = \"backend/backend.ts\") {\n  if (Bun.argv[2] === \"frontend\") {\n    const newFrontend = await buildFrontend(Bun.argv[3]);\n    process.stdout.write(JSON.stringify(newFrontend));\n    return 0;\n  }\n  await buildBackend(backendPath);\n  if (Bun.argv[2] === \"dev\") {\n    await devServer();\n  }\n}\n\nconst streamPlugin: BunPlugin = {\n  name: \"node stream in the frontend\",\n  setup(build) {\n    build.onResolve({ filter: /^stream$/ }, (args) => {\n      const path_to_stream_lib = path.resolve(\n        projectRoot(),\n        \"node_modules/stream-browserify/index.js\"\n      );\n      if (path_to_stream_lib)\n        return {\n          path: path_to_stream_lib,\n        };\n    });\n  },\n};\nconst bufferPlugin: BunPlugin = {\n  name: \"node buffer in the frontend\",\n  setup(build) {\n    build.onResolve({ filter: /^buffer$/ }, (args) => {\n      const path_to_buffer_lib = path.resolve(\n        projectRoot(),\n        \"node_modules/buffer/index.js\"\n      );\n      if (path_to_buffer_lib)\n        return {\n          path: path_to_buffer_lib,\n        };\n    });\n  },\n};\nconst cryptoPlugin: BunPlugin = {\n  name: \"node crypto in the frontend\",\n  setup(build) {\n    build.onResolve({ filter: /^crypto$/ }, (args) => {\n      const path_to_crypto_lib = path.resolve(\n        projectRoot(),\n        \"node_modules/crypto-browserify/index.js\"\n      );\n      if (path_to_crypto_lib)\n        return {\n          path: path_to_crypto_lib,\n        };\n    });\n  },\n};\nconst nodeHttpsPlugin: BunPlugin = {\n  name: \"node https in the frontend\",\n  setup(build) {\n    build.onResolve({ filter: /^https$/ }, (args) => {\n      const path_to_node_https_lib = path.resolve(\n        projectRoot(),\n        \"node_modules/https-browserify/index.js\"\n      );\n      if (path_to_node_https_lib)\n        return {\n          path: path_to_node_https_lib,\n        };\n    });\n  },\n};\nasync function buildBackend(backendPath: string = \"backend/backend.ts\") {\n  global.FrontendScriptUrls = [];\n  global.FrontendScripts = [];\n  global.bundledSVGs = {};\n  const i = await import(path.resolve(projectRoot(), backendPath));\n\n  for (const frontend of url.getFrontends()) {\n    const firstPlaceToLook = path.resolve(\n      path.dirname(frontend.callerPath),\n      `frontend/${frontend.path}`\n    );\n    const secondPlaceToLook = path.resolve(\n      projectRoot(),\n      `frontend/${frontend.path}`\n    );\n    const frontEndPath = (await Bun.file(firstPlaceToLook).exists())\n      ? firstPlaceToLook\n      : secondPlaceToLook;\n    try {\n      const f = await $`bun run build.ts frontend ${frontEndPath}`.json();\n      FrontendScriptUrls.push(\"/\" + f.url);\n      FrontendScripts.push(f.script);\n    } catch (error) {\n      console.log(await $`bun run build.ts frontend ${frontEndPath}`.text());\n    }\n  }\n  for (const svgPath of url.getSvgPaths()) {\n    const parsedSvgPath = path.parse(svgPath);\n    const svgContent = Bun.file(\n      path.join(projectRoot() + \"/backend/\", svgPath)\n    );\n    const svgHash = Bun.hash(await svgContent.arrayBuffer());\n    const svgUrl = `/${parsedSvgPath.name}-${svgHash}.svg`;\n    bundledSVGs[svgUrl] = {\n      svgContent: await svgContent.text(),\n      svgPath,\n    };\n  }\n  const res = await Bun.build({\n    entrypoints: [path.resolve(projectRoot(), backendPath)],\n    outdir: path.resolve(projectRoot(), \"dist\"),\n    naming: \"backend.js\",\n    minify: Bun.argv[2] === \"dev\" ? false : true, //production\n    target: \"bun\",\n    define: {\n      FrontendScripts: JSON.stringify(FrontendScripts),\n      FrontendScriptUrls: JSON.stringify(FrontendScriptUrls),\n      bundledSVGs: JSON.stringify(bundledSVGs),\n    },\n  });\n}\n\nasync function buildFrontend(file: string) {\n  const result = await Bun.build({\n    entrypoints: [file],\n    outdir: path.resolve(projectRoot(), \"dist\"),\n    naming: \"[name]-[hash].[ext]\",\n    minify: Bun.argv[2] === \"dev\" ? false : true, //production\n    target: \"browser\",\n    plugins: [bufferPlugin, streamPlugin, cryptoPlugin, nodeHttpsPlugin],\n  });\n  if (!result?.outputs[0]?.path) console.log(result);\n  const url = path.basename(result.outputs[0].path);\n  //results.push({ file, p });\n  return { url, script: await result.outputs[0].text() };\n}\n\nasync function devServer() {\n  //start the reloader and tell browser to refresh once\n  await buildBackend();\n  let refreshed_once = false;\n  const server = Bun.serve({\n    port: 3001,\n    fetch(request) {\n      const success: Boolean = server.upgrade(request);\n      return success\n        ? new Response(\"Reloader works!\")\n        : new Response(\"Reloader WebSocket upgrade error\", { status: 400 });\n    },\n    websocket: {\n      open(ws) {\n        ws.subscribe(\"reloader\");\n        if (!refreshed_once) {\n          ws.send(\"Reload!\");\n          refreshed_once = true;\n        }\n      },\n      message(ws, message) {}, // a message is received\n    },\n  });\n  async function watchAndBuild(dir: string) {\n    try {\n      //start the file watcher that will rebuild frontend on save\n      const watcher = watch(path.resolve(projectRoot(), dir), {\n        recursive: true,\n      });\n      for await (const event of watcher) {\n        buildBackend().then(() => {\n          // tell browser to refresh again because we saw a change\n          server.publish(\"reloader\", \"Reload!\");\n        });\n      }\n    } catch (e) {\n      console.log(\n        `mini-next dev server has trouble watching \"./${dir}\", does the directory exist?`\n      );\n    }\n  }\n  watchAndBuild(\"frontend\");\n  watchAndBuild(\"backend\");\n}\nconst standardDevReloader = html`\n  <script>\n    function reloader() {\n      let socket = null;\n\n      function connectWebSocket() {\n        if (socket) {\n          return;\n        }\n        socket = new WebSocket(\"ws://localhost:3001/reload\");\n\n        socket.addEventListener(\"message\", (event) => {\n          window.location.reload();\n        });\n\n        socket.addEventListener(\"close\", (event) => {\n          // Reestablish the connection after 1 second\n          socket = null;\n        });\n\n        socket.addEventListener(\"error\", (event) => {\n          socket = null;\n        });\n      }\n      connectWebSocket(); // connect to reloader, if it does not work:\n      setInterval(connectWebSocket, 1000); // retry every 1 second\n    }\n    reloader();\n  </script>\n`;\nasync function makeEntrypoint() {\n  let module;\n  const backendImportPath = projectRoot() + \"/dist/backend.js\";\n  try {\n    // @ts-ignore\n    module = await import(backendImportPath);\n  } catch (error) {\n    await build();\n    // @ts-ignore\n    module = await import(backendImportPath);\n  }\n  return module.default() as {\n    fetch: (req: Request, server: Server) => Promise<Response>;\n    websocket: WebSocketHandler;\n  };\n}\nexport function getCallerFilePath(): string {\n  // const stack = new Error().stack?.split(\"\\n\");\n  // //console.log(stack);\n  // if (!stack) return \"\";\n  // return stack[2].slice(\n  //   stack[2].lastIndexOf(\"(\") + 1,\n  //   stack[2].lastIndexOf(\")\") + 3\n  // );\n  return __dirname;\n}\nexport {\n  has,\n  html,\n  url,\n  head,\n  build,\n  makeEntrypoint,\n  isError,\n  BasedHtml,\n  HtmlString,\n  type HtmlHandler,\n  Mini,\n  standardDevReloader,\n  commonHead,\n  cssReset,\n};\n\n'mininext/tests/url.test.ts'\n:import { expect, test, mock } from \"bun:test\";\nimport { html, Mini, url } from \"../mininext/mininext\";\n// Example of creating a mock request object\nconst mockRequestObject: unknown = {\n  method: \"GET\", // or 'POST', etc.\n  url: \"http://example.com/api/some-endpoint\",\n  body: JSON.stringify({ key: \"value\" }),\n  headers: {\n    \"Content-Type\": \"application/json\",\n    get: () => undefined,\n  },\n};\nconst makeMockRequest = mock(() => mockRequestObject as Request);\ntest(\"urls work with all variations of added slashes\", async () => {\n  async function makeRequest(testurl: string) {\n    const req = makeMockRequest();\n    const response = await url.match(req, testurl);\n    const responseText = await response?.text();\n    try {\n      expect(responseText).not.toInclude(\"No matching url found\");\n      expect(responseText).toInclude(\"ok\");\n    } catch (error) {\n      error.message = `this url did not match correctly ${testurl}: response text: ${responseText}`;\n      throw error;\n    }\n  }\n  url.set([\n    [\"/test\", (mini) => mini.html`ok`],\n    [\"testWithoutSlash\", (mini) => mini.html`ok`],\n  ]);\n  url.set(\"/SingleTest\", (mini) => mini.html`ok`);\n  url.set(\"SingleTestWithoutSlash\", (mini) => mini.html`ok`);\n  for (const testurl of [\n    \"/test\",\n    \"/testWithoutSlash\", // important to note: the request object always has a preceding slash\n    \"/SingleTest\",\n    \"/SingleTestWithoutSlash\", // important to note: the request object always has a preceding slash\n  ]) {\n    await makeRequest(testurl);\n    await makeRequest(testurl + \"/\");\n  }\n});\n\ntest(\"test that all urls get removed\", async () => {\n  url.set(\"UrlRemoveTestWithoutSlash\", (mini) => mini.html`ok`);\n  url.remove(\"UrlRemoveTestWithoutSlash\");\n  expect(\n    url.direct_handlers_html.get(\"/UrlRemoveTestWithoutSlash\")\n  ).toBeUndefined();\n  url.set(\"UrlRemoveTestWithoutSlash\", (mini) => mini.html`ok`);\n  url.remove(\"UrlRemoveTestWithoutSlash/\");\n  expect(\n    url.direct_handlers_html.get(\"/UrlRemoveTestWithoutSlash\")\n  ).toBeUndefined();\n  url.set(\"/UrlRemoveTestWithSlash\", (mini) => mini.html`ok`);\n  url.remove(\"UrlRemoveTestWithSlash/\");\n  expect(\n    url.direct_handlers_html.get(\"/UrlRemoveTestWithoutSlash\")\n  ).toBeUndefined();\n});\n\ntest(\"test frontend type passes through\", async () => {\n  //mock FrontendScriptUrls\n  global.FrontendScriptUrls = [];\n  const testScriptTag = url.frontend(\n    \"\",\n    (mini: Mini<{ testtype: string }>) => mini.html``\n  );\n  const testScriptTag2 = url.frontend(\"\", (mini) => mini.html``);\n  const testScriptTag3 = url.frontend(\"\", html``);\n});\n\n",
        "called_code_segment_file_1": "static generateVariations(inputString: string) {\n    const variations = [];\n\n    // Special case for the index route\n    if (inputString === '/') {\n      variations.push('/');\n      return variations;\n    }\n\n    // Check if the string starts with a slash and add/remove variations accordingly\n    if (inputString.startsWith('/')) {\n      variations.push(inputString); // With leading slash\n    } else {\n      inputString = '/' + inputString;\n      variations.push(inputString); // With leading slash\n    }\n\n    // Check if the string ends with a slash and add/remove variations accordingly\n    if (inputString.endsWith('/')) {\n      variations.push(inputString.slice(0, -1)); // Without trailing slash\n    } else {\n      variations.push(inputString + '/'); // With trailing slash\n    }\n\n    return variations;\n  }",
        "invoking_code_segment_file_2": "static set<K extends string>(entries: [K, HtmlHandler][] | string, handler?: HtmlHandler) {\n    function addUrl(entryUrl: string, entryHandler: HtmlHandler) {\n      for (const u of url.generateVariations(entryUrl)) {\n        url.direct_handlers_html.set(u, entryHandler);\n      }\n    }\n\n    if (typeof entries === 'string' && handler) {\n      addUrl(entries, handler);\n    }\n    if (typeof entries !== 'string')\n      for (const [entryUrl, entryHandler] of entries) {\n        addUrl(entryUrl, entryHandler);\n      }\n  }",
        "invoking_code_segment_file_3": "async function makeRequest(testurl: string) {\n    const req = makeMockRequest();\n    const response = await url.match(req, testurl);\n    const responseText = await response?.text();\n    try {\n      expect(responseText).not.toInclude('No matching url found');\n      expect(responseText).toInclude('ok');\n    } catch (error) {\n      error.message = `this url did not match correctly ${testurl}: response text: ${responseText}`;\n      throw error;\n    }\n  }",
        "new_file_code_segment": "export function logUrlVariations(inputString: string) {\n  const variations = url.generateVariations(inputString);\n  console.log(`URL variations for '${inputString}':`, variations);\n}",
        "feature_description": "Add logging for URL variations generated by the `generateVariations` method.",
        "detailed_feature_description": "The new feature introduces a logging mechanism that outputs all variations of a given URL string generated by the `generateVariations` method. This is implemented in a new file (#file 4) and is invoked in #file 1 to log the variations whenever the method is called. This logging can be useful for debugging and understanding how URL variations are being handled.",
        "modified_complete_code": {
            "#file 1": "static generateVariations(inputString: string) {\n    const variations = [];\n\n    // Special case for the index route\n    if (inputString === '/') {\n      variations.push('/');\n      return variations;\n    }\n\n    // Check if the string starts with a slash and add/remove variations accordingly\n    if (inputString.startsWith('/')) {\n      variations.push(inputString); // With leading slash\n    } else {\n      inputString = '/' + inputString;\n      variations.push(inputString); // With leading slash\n    }\n\n    // Check if the string ends with a slash and add/remove variations accordingly\n    if (inputString.endsWith('/')) {\n      variations.push(inputString.slice(0, -1)); // Without trailing slash\n    } else {\n      variations.push(inputString + '/'); // With trailing slash\n    }\n\n    // #Modify: Add logging for URL variations\n    logUrlVariations(inputString);\n\n    return variations;\n  }",
            "#file 2": "static set<K extends string>(entries: [K, HtmlHandler][] | string, handler?: HtmlHandler) {\n    function addUrl(entryUrl: string, entryHandler: HtmlHandler) {\n      for (const u of url.generateVariations(entryUrl)) {\n        url.direct_handlers_html.set(u, entryHandler);\n      }\n    }\n\n    if (typeof entries === 'string' && handler) {\n      addUrl(entries, handler);\n    }\n    if (typeof entries !== 'string')\n      for (const [entryUrl, entryHandler] of entries) {\n        addUrl(entryUrl, entryHandler);\n      }\n  }",
            "#file 3": "async function makeRequest(testurl: string) {\n    const req = makeMockRequest();\n    const response = await url.match(req, testurl);\n    const responseText = await response?.text();\n    try {\n      expect(responseText).not.toInclude('No matching url found');\n      expect(responseText).toInclude('ok');\n    } catch (error) {\n      error.message = `this url did not match correctly ${testurl}: response text: ${responseText}`;\n      throw error;\n    }\n  }",
            "#file 4": "export function logUrlVariations(inputString: string) {\n  const variations = url.generateVariations(inputString);\n  console.log(`URL variations for '${inputString}':`, variations);\n}"
        }
    },
    {
        "repo": "plantae",
        "content": "'plantae/packages/plantae/src/utils.ts'\n:const kindOf = ((cache) => (thing: any) => {\n  const str = toString.call(thing);\n  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());\n})(Object.create(null));\n\nconst kindOfTest = (type: string) => {\n  type = type.toLowerCase();\n  return (thing: any) => kindOf(thing) === type;\n};\n\nexport const isArrayBuffer = kindOfTest(\"ArrayBuffer\");\n\n// https://fetch.spec.whatwg.org/#statuses\nexport const isNullBodyStatus = (status: number) =>\n  [101, 103, 204, 205, 304].includes(status);\n\n'plantae/packages/plantae/src/axios/createAxiosInterceptors.ts'\n:import type {\n  AxiosInstance,\n  AxiosResponse,\n  AxiosResponseHeaders,\n  InternalAxiosRequestConfig,\n} from \"axios\";\n\nimport createMiddleware from \"../createMiddleware\";\nimport type { AdapterRequest, AdapterResponse, Plugin } from \"../types\";\nimport { isArrayBuffer, isNullBodyStatus } from \"../utils\";\nimport settle from \"./utils\";\n\ntype InterceptorType = keyof AxiosInstance[\"interceptors\"];\n\ntype InterceptorParams<T extends InterceptorType> = Parameters<\n  AxiosInstance[\"interceptors\"][T][\"use\"]\n>;\n\ntype Interceptor<T extends InterceptorType> = {\n  onFulfilled: InterceptorParams<T>[0];\n  onRejected: InterceptorParams<T>[1];\n};\n\nfunction convertToAdapterRequest(\n  req: InternalAxiosRequestConfig\n): AdapterRequest {\n  const path = req.url\n    ? req.url.startsWith(\"/\")\n      ? req.url.slice(1)\n      : req.url\n    : \"\";\n\n  const base = req.baseURL\n    ? req.baseURL.endsWith(\"/\")\n      ? req.baseURL\n      : `${req.baseURL}/`\n    : undefined;\n\n  const url = new URL(path, base);\n\n  const transformedData = req.transformRequest\n    ? Array.isArray(req.transformRequest)\n      ? req.transformRequest.reduce(\n          (data, transformer) => transformer.bind(req)(data, req.headers),\n          req.data\n        )\n      : req.transformRequest(req.data, req.headers)\n    : req.data;\n\n  const credentials =\n    req.withCredentials === true\n      ? \"include\"\n      : req.withCredentials === false\n      ? \"omit\"\n      : \"same-origin\";\n\n  return new Request(url, {\n    body: transformedData,\n    method: req.method ?? \"GET\",\n    headers: new Headers(req.headers.toJSON(true) as HeadersInit),\n    signal: req.signal as AbortSignal,\n    credentials,\n  });\n}\n\nasync function extendClientRequest(\n  clientRequest: InternalAxiosRequestConfig,\n  adapterRequest: AdapterRequest\n): Promise<InternalAxiosRequestConfig> {\n  let data = clientRequest.data;\n\n  const isJSONBody = typeof data === \"object\" && data !== null;\n\n  const { headers } = adapterRequest;\n\n  const contentType = headers.get(\"Content-Type\");\n\n  if (adapterRequest.body) {\n    if (contentType?.includes(\"multipart/form-data\")) {\n      data = await adapterRequest.formData();\n    } else if (contentType?.includes(\"application/json\") && isJSONBody) {\n      data = await adapterRequest.json();\n    } else if (\n      contentType?.includes(\"application/x-www-form-urlencoded\") ||\n      contentType?.includes(\"text/plain\") ||\n      contentType?.includes(\"application/json\")\n    ) {\n      data = await adapterRequest.text();\n    } else {\n      data = await adapterRequest.blob();\n    }\n  }\n\n  for (const [key, value] of headers.entries()) {\n    clientRequest.headers.set(key, value, true);\n  }\n\n  if (\n    adapterRequest.cache === \"no-cache\" ||\n    adapterRequest.cache === \"no-store\"\n  ) {\n    const url = new URL(adapterRequest.url);\n    const searchParams = new URLSearchParams(url.search);\n\n    searchParams.set(\"_\", new Date().getTime().toString());\n\n    url.search = searchParams.toString();\n\n    clientRequest.url = url.toString();\n  } else {\n    clientRequest.url = adapterRequest.url;\n  }\n\n  clientRequest.data = data;\n  clientRequest.method = adapterRequest.method;\n  clientRequest.signal = adapterRequest.signal;\n  clientRequest.withCredentials = adapterRequest.credentials === \"include\";\n\n  return clientRequest;\n}\n\nfunction convertToAdapterResponse(res: AxiosResponse): AdapterResponse {\n  const headers = res.headers as AxiosResponseHeaders;\n\n  if (!res.config.responseType && isArrayBuffer(res.data)) {\n    res.config.responseType = \"arraybuffer\";\n  }\n\n  const isJSONBody =\n    res.data !== null &&\n    typeof res.data === \"object\" &&\n    (res.config.responseType === \"json\" ||\n      (!res.config.responseType && res.config.transitional?.forcedJSONParsing));\n\n  return new Response(\n    isJSONBody\n      ? JSON.stringify(res.data)\n      : isNullBodyStatus(res.status)\n      ? null\n      : res.data,\n    {\n      status: res.status,\n      statusText: res.statusText,\n      headers: new Headers(headers.toJSON(true) as HeadersInit),\n    }\n  );\n}\n\nasync function extendClientResponse(\n  clientResponse: AxiosResponse,\n  adapterResponse: AdapterResponse\n): Promise<AxiosResponse> {\n  const { headers } = adapterResponse;\n\n  const axiosHeaders = clientResponse.headers as AxiosResponseHeaders;\n\n  const contentType = headers.get(\"Content-Type\");\n\n  let data = null;\n\n  if (adapterResponse.body) {\n    if (\n      contentType?.includes(\"text/plain\") ||\n      contentType?.includes(\"application/json\")\n    ) {\n      data = await adapterResponse.text();\n\n      try {\n        if (clientResponse.config.transitional?.forcedJSONParsing) {\n          data = JSON.parse(data);\n          headers.set(\"Content-Type\", \"application/json\");\n        }\n      } catch {}\n    } else if (clientResponse.config.responseType === \"arraybuffer\") {\n      data = await adapterResponse.arrayBuffer();\n    } else {\n      data = await adapterResponse.blob();\n    }\n  }\n\n  for (const [key, value] of headers.entries()) {\n    axiosHeaders.set(key, value, true);\n  }\n\n  clientResponse.data = data;\n  clientResponse.status = adapterResponse.status;\n  clientResponse.statusText = adapterResponse.statusText;\n\n  return clientResponse;\n}\n\nconst createAxiosInterceptors = ({\n  client,\n  plugins,\n}: {\n  client: AxiosInstance;\n  plugins?: Plugin[];\n}): {\n  request: Interceptor<\"request\">;\n  response: Interceptor<\"response\">;\n} => {\n  if (!plugins) {\n    return {\n      request: { onFulfilled: (config) => config, onRejected: null },\n      response: { onFulfilled: (response) => response, onRejected: null },\n    };\n  }\n\n  const { requestMiddleware, responseMiddleware } = createMiddleware({\n    convertToAdapterRequest,\n    convertToAdapterResponse,\n    extendClientRequest,\n    extendClientResponse,\n    plugins,\n    retry: client.request,\n  });\n\n  return {\n    request: {\n      onFulfilled: async (config) => {\n        return requestMiddleware(config);\n      },\n      onRejected: null,\n    },\n    response: {\n      onFulfilled: async (response) => {\n        return responseMiddleware(response, response.config);\n      },\n      onRejected: async (err: { response?: AxiosResponse }) => {\n        const { response } = err;\n\n        if (response && response.config) {\n          const middlewareResponse = await responseMiddleware(\n            response,\n            response.config\n          );\n\n          return new Promise((resolve, reject) => {\n            settle(resolve, reject, middlewareResponse);\n          });\n        }\n\n        return Promise.reject(err);\n      },\n    },\n  };\n};\n\nexport default createAxiosInterceptors;\n\n'plantae/packages/plantae/src/axios/createAxiosInterceptors.spec.ts'\n:import Axios from \"axios\";\nimport { http } from \"msw\";\nimport { describe, expect, it } from \"vitest\";\n\nimport { base, baseURL, Status } from \"../test/utils\";\nimport { server } from \"../test/worker\";\nimport createAxiosInterceptors from \"./createAxiosInterceptors\";\n\ndescribe(\"createAxiosInterceptors\", () => {\n  it(\"can modify request body\", async () => {\n    server.use(\n      http.post(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(\n            (await request.text()) === \"modified\" ? Status.OK : Status.BAD\n          )\n      )\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-request-body\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                body: \"modified\",\n                method: \"POST\",\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    const res = await axios.post(\"/\");\n\n    expect(res.data).toBe(Status.OK);\n  });\n\n  it(\"can modify request headers\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(\n            request.headers.get(\"x-custom-header\") === \"modified\"\n              ? Status.OK\n              : Status.BAD\n          )\n      )\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-request-headers\",\n          hooks: {\n            beforeRequest: (req) => {\n              req.headers.set(\"x-custom-header\", \"modified\");\n              return req;\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    const res = await axios.get(\"/\");\n\n    expect(res.data).toBe(Status.OK);\n  });\n\n  it(\"can modify existing request header\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(\n            request.headers.get(\"x-custom-header\") === \"modified\"\n              ? Status.OK\n              : Status.BAD\n          )\n      )\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-request-headers\",\n          hooks: {\n            beforeRequest: (req) => {\n              req.headers.set(\"x-custom-header\", \"modified\");\n              return req;\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    const res = await axios.get(\"/\", {\n      headers: {\n        \"x-custom-header\": \"original\",\n      },\n    });\n\n    expect(res.data).toBe(Status.OK);\n  });\n\n  it(\"can modify request method\", async () => {\n    server.use(http.post(base(\"/\"), () => new Response(Status.OK)));\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-request-method\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                method: \"POST\",\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    const res = await axios.get(\"/\");\n\n    expect(res.data).toBe(Status.OK);\n  });\n\n  it(\"can modify request url\", async () => {\n    server.use(http.get(base(\"/modified\"), () => new Response(Status.OK)));\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-request-url\",\n          hooks: {\n            beforeRequest: () => {\n              return new Request(base(\"/modified\"));\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    const res = await axios.get(\"/\");\n\n    expect(res.data).toBe(Status.OK);\n  });\n\n  it(\"can add request signal\", async () => {\n    server.use(\n      http.get(base(\"/delay\"), async () => {\n        await new Promise((resolve) => setTimeout(resolve, 5000));\n\n        return new Response();\n      })\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-add-request-signal\",\n          hooks: {\n            beforeRequest: () => {\n              const abortController = new AbortController();\n\n              setTimeout(() => {\n                abortController.abort();\n              }, 100);\n\n              return new Request(base(\"/delay\"), {\n                signal: abortController.signal,\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    await expect(axios.get(\"/\")).rejects.toThrow(\"canceled\");\n  });\n\n  // NOTE: msw always takes 'same-origin' as credentials\n  it.skip(\"can modify request credentials\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(request.credentials === \"omit\" ? Status.OK : Status.BAD)\n      )\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-request-credentials\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                credentials: \"omit\",\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    const res = await axios.get(\"/\", {\n      withCredentials: true,\n    });\n\n    expect(res.data).toBe(Status.OK);\n  });\n\n  it(\"can modify request cache\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async ({ request }) =>\n          new Response(\n            new URL(request.url).searchParams.get(\"_\") !== null\n              ? Status.OK\n              : Status.BAD\n          )\n      )\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-request-cache\",\n          hooks: {\n            beforeRequest: (req) => {\n              return new Request(req, {\n                cache: \"no-cache\",\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    const res = await axios.get(\"/\");\n\n    expect(res.data).toBe(Status.OK);\n  });\n\n  it(\"can modify response body\", async () => {\n    server.use(http.post(base(\"/\"), () => new Response()));\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { response } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-response-body\",\n          hooks: {\n            afterResponse: (res) => new Response(\"modified\", res),\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.response.use(response.onFulfilled, response.onRejected);\n\n    const res = await axios.post(\"/\");\n\n    expect(res.data).toBe(\"modified\");\n  });\n\n  it(\"can modify response headers\", async () => {\n    server.use(http.get(base(\"/\"), () => new Response()));\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { response } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-response-headers\",\n          hooks: {\n            afterResponse: (res) => {\n              res.headers.set(\"x-custom-header\", \"modified\");\n              return res;\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.response.use(response.onFulfilled, response.onRejected);\n\n    const res = await axios.get(\"/\");\n\n    expect(res.headers[\"x-custom-header\"]).toBe(\"modified\");\n  });\n\n  it(\"can modify existing response header\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        () =>\n          new Response(undefined, {\n            headers: {\n              \"x-custom-header\": \"original\",\n            },\n          })\n      )\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { response } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-response-headers\",\n          hooks: {\n            afterResponse: (res) => {\n              res.headers.set(\"x-custom-header\", \"modified\");\n              return res;\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.response.use(response.onFulfilled, response.onRejected);\n\n    const res = await axios.get(\"/\");\n\n    expect(res.headers[\"x-custom-header\"]).toBe(\"modified\");\n  });\n\n  it(\"can modify response status\", async () => {\n    server.use(\n      http.get(\n        base(\"/\"),\n        async () =>\n          new Response(null, {\n            status: 201,\n          })\n      )\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { response } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-response-status\",\n          hooks: {\n            afterResponse: (res) =>\n              new Response(res.body, {\n                headers: res.headers,\n                statusText: res.statusText,\n                status: 201,\n              }),\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.response.use(response.onFulfilled, response.onRejected);\n\n    const res = await axios.get(\"/\");\n\n    expect(res.status).toBe(201);\n  });\n\n  it(\"can modify response status text\", async () => {\n    server.use(http.get(base(\"/\"), async () => new Response()));\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { response } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-status-text\",\n          hooks: {\n            afterResponse: (res) =>\n              new Response(res.body, {\n                headers: res.headers,\n                status: res.status,\n                statusText: \"modified\",\n              }),\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.response.use(response.onFulfilled, response.onRejected);\n\n    const res = await axios.get(\"/\");\n\n    expect(res.statusText).toBe(\"modified\");\n  });\n\n  it(\"can retry request\", async () => {\n    server.use(\n      http.get(base(\"/error\"), async () => {\n        return new Response(null, {\n          status: 500,\n        });\n      }),\n      http.get(base(\"/retry\"), () => new Response(\"retried\"))\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { response } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-retry-request\",\n          hooks: {\n            afterResponse: async (res, req, retry) => {\n              if (!res.ok) {\n                const newReq = new Request(base(\"/retry\"), req);\n\n                return retry(newReq);\n              }\n              return res;\n            },\n          },\n        },\n      ],\n    });\n\n    axios.interceptors.response.use(response.onFulfilled, response.onRejected);\n\n    const res = await axios.get(\"/error\");\n\n    expect(res.data).toBe(\"retried\");\n  });\n\n  it(\"should respect json type of original request body\", async () => {\n    server.use(\n      http.post(base(\"/\"), () => {\n        return new Response();\n      })\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request } = createAxiosInterceptors({\n      client: axios,\n      plugins: [\n        {\n          name: \"plugin-modify-body\",\n          hooks: {\n            beforeRequest: async (req) => {\n              return new Request(req, {\n                body: JSON.stringify({ ...(await req.json()), modified: true }),\n              });\n            },\n          },\n        },\n      ],\n    });\n\n    let type: string | undefined;\n    let data: any;\n\n    axios.interceptors.request.use((config) => {\n      type = typeof config.data;\n      data = config.data;\n\n      return config;\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n\n    await axios.post(\"/\", {\n      foo: \"bar\",\n    });\n\n    expect(type).toBe(\"object\");\n    expect(data).toEqual({\n      foo: \"bar\",\n      modified: true,\n    });\n  });\n\n  it(\"should throw error if status code validation failed\", async () => {\n    server.use(\n      http.get(base(\"/\"), () => {\n        return new Response(null, {\n          status: 500,\n        });\n      })\n    );\n\n    const axios = Axios.create({\n      baseURL,\n    });\n\n    const { request, response } = createAxiosInterceptors({\n      client: axios,\n      plugins: [],\n    });\n\n    axios.interceptors.request.use(request.onFulfilled, request.onRejected);\n    axios.interceptors.response.use(response.onFulfilled, response.onRejected);\n\n    await expect(axios.get(\"/\")).rejects.toThrow(\n      \"Request failed with status code 500\"\n    );\n  });\n});\n\n",
        "called_code_segment_file_1": "function convertToAdapterRequest(req: InternalAxiosRequestConfig): AdapterRequest { ... }",
        "invoking_code_segment_file_2": "const { requestMiddleware, responseMiddleware } = createMiddleware({ ... convertToAdapterRequest, ... });",
        "invoking_code_segment_file_3": "const res = await axios.post('/');",
        "new_file_code_segment": "function logRequest(req: AdapterRequest) { console.log(`Request URL: ${req.url}`); }",
        "feature_description": "Add logging for each request URL.",
        "detailed_feature_description": "A new logging feature is added to log the URL of each request. This is implemented in a new file (#file 4) and integrated into #file 1. The logging function is invoked in #file 1, and #file 2 and #file 3 are updated to handle this new feature.",
        "modified_complete_code": {
            "#file 1": "function convertToAdapterRequest(req: InternalAxiosRequestConfig): AdapterRequest { ... } #Modify\nfunction logRequest(req: AdapterRequest) { console.log(`Request URL: ${req.url}`); } #New",
            "#file 2": "const { requestMiddleware, responseMiddleware } = createMiddleware({ ... convertToAdapterRequest, ... }); #Modify\nimport { logRequest } from './file4'; #New",
            "#file 3": "const res = await axios.post('/'); #Modify\nimport { logRequest } from './file4'; #New",
            "#file 4": "export function logRequest(req: AdapterRequest) { console.log(`Request URL: ${req.url}`); } #New"
        }
    },
    {
        "repo": "react-3d-editor",
        "content": "'react-3d-editor/src/components/common/Empty.tsx'\n:import React from 'react';\nimport { Empty as AntEmpty } from 'antd';\nimport { EmptyProps } from 'antd/lib/empty';\n\nconst Empty: React.SFC<EmptyProps> = props => {\n    const { children, ...other } = props;\n    return (\n        <div className=\"editor-empty\">\n            <AntEmpty {...other}>\n                {children}\n            </AntEmpty>\n        </div>\n    );\n};\n\nexport default Empty;\n\n'react-3d-editor/src/components/common/SavedList.tsx'\n:import React, { Component } from 'react';\nimport { Spin, Input, Row, Col, Card } from 'antd';\nimport warning from 'warning';\nimport Icon from 'polestar-icons';\n\nimport Empty from './Empty';\nimport Scrollbar from './Scrollbar';\nimport { SceneDatabase } from '../../database';\nimport { UtilTools } from '../../tools';\n\nexport interface ISavedScene {\n    id: string;\n    thumbnail: string;\n    name: string;\n    description: string;\n    scene: string;\n}\n\nexport interface SavedListProps {\n    onClick?: (savedScene: ISavedScene) => void;\n    visible?: boolean;\n}\n\ninterface IState {\n    loading: boolean;\n    scenes: ISavedScene[];\n    searchScene: string;\n}\n\nclass SavedList extends Component<SavedListProps, IState> {\n    state: IState = {\n        loading: true,\n        scenes: [],\n        searchScene: '',\n    }\n\n    componentDidMount() {\n        this.getSceneList();\n    }\n\n    UNSAFE_componentWillReceiveProps(nextProps: SavedListProps) {\n        if (nextProps.visible) {\n            this.getSceneList();\n        }\n    }\n\n    /**\n     * @description Get scene list\n     */\n    private getSceneList = () => {\n        this.setState({\n            loading: true,\n        });\n        SceneDatabase.allDocs().then(response => {\n            const scenes = response.rows.map(row => {\n                const { doc } = row;\n                return {\n                    id: doc._id,\n                    name: doc.name,\n                    description: doc.description || '',\n                    scene: doc.scene,\n                    thumbnail: doc.thumbnail,\n                } as ISavedScene;\n            });\n            this.setState({\n                scenes,\n                loading: false,\n            });\n        }).catch(error => {\n            warning(true, error);\n            this.setState({\n                loading: false,\n            });\n        });\n    }\n\n    /**\n     * @description Search scene\n     * @param {string} searchScene\n     */\n    private handleSearchScene = (searchScene: string) => {\n        this.setState({\n            searchScene,\n        });\n    }\n\n    /**\n     * @description Select the scene\n     * @param {*} scene\n     */\n    private handleSelectScene = (savedScene: any) => {\n        const { onClick } = this.props;\n        if (onClick) {\n            onClick(savedScene);\n        }\n    }\n\n    /**\n     * @description Render search\n     * @returns {React.ReactNode}\n     */\n    private renderSearch = () => {\n        return (\n            <div style={{ flex: 1 }}>\n                <Input allowClear={true} placeholder=\"Search for scene...\" onChange={e => this.handleSearchScene(e.target.value)} />\n            </div>\n        );\n    }\n\n    /**\n     * @description Render card actions\n     * @param {ISavedScene} scene\n     * @returns\n     */\n    private renderCardActions = (scene: ISavedScene) => {\n        return [\n            <Icon\n                key=\"download\"\n                name=\"download\"\n                onClick={e => {\n                    e.stopPropagation();\n                    UtilTools.saveString(scene.scene, scene.name);\n                }}\n            />,\n            <Icon\n                key=\"delete\"\n                name=\"trash\"\n                onClick={e => {\n                    e.stopPropagation();\n                    SceneDatabase.delete(scene.id)\n                    .then(() => {\n                        this.getSceneList();\n                    });\n                }}\n            />\n        ];\n    }\n\n    /**\n     * @description Render scenes on card\n     * @param {ISavedScene[]} scenes\n     * @param {string} searchScene\n     * @returns {React.ReactNode}\n     */\n    private renderCardItems = (scenes: ISavedScene[], searchScene: string) => {\n        const items = scenes\n        .filter(scene => scene.name.toLowerCase().includes(searchScene.toLowerCase())\n        || scene.description.toLowerCase().includes(searchScene.toLowerCase()));\n        return (\n            <Scrollbar>\n                {\n                    items.length ? (\n                        <Row gutter={16} style={{ margin: 0 }}>\n                            {\n                                items.map(scene => {\n                                    return (\n                                        <Col key={scene.id} md={24} lg={12} xl={6} onClick={() => this.handleSelectScene(scene)}>\n                                            <Card\n                                                hoverable={true}\n                                                style={{ marginBottom: 16 }}\n                                                bodyStyle={{ height: 100 }}\n                                                cover={<img src={scene.thumbnail} />}\n                                                actions={this.renderCardActions(scene)}\n                                            >\n                                                <Card.Meta\n                                                    title={scene.name}\n                                                    description={scene.description}\n                                                />\n                                            </Card>\n                                        </Col>\n                                    );\n                                })\n                            }\n                        </Row>\n                    ) : <Empty />\n                }\n            </Scrollbar>\n        );\n    }\n\n    render() {\n        const { loading, scenes, searchScene } = this.state;\n        return (\n            <Spin spinning={loading}>\n                {\n                    scenes.length ? (\n                        <div style={{ display: 'flex', height: '100%', flexDirection: 'column' }}>\n                            <div style={{ display: 'flex', padding: '0 8px 16px 8px' }}>\n                                {this.renderSearch()}\n                            </div>\n                            <div style={{ flex: 1 }}>\n                                {this.renderCardItems(scenes, searchScene)}\n                            </div>\n                        </div>\n                    ) : <Empty />\n                }\n            </Spin>\n        );\n    }\n}\n\nexport default SavedList;\n'react-3d-editor/src/components/common/SavedListModal.tsx'\n:import React from 'react';\nimport { Modal } from 'antd';\nimport { ModalProps } from 'antd/lib/modal';\n\nimport SavedList, { ISavedScene } from './SavedList';\n\ninterface IProps extends ModalProps {\n    onClickScene?: (savedScene: ISavedScene) => void;\n}\n\nconst SavedListModal: React.SFC<IProps> = props => {\n    const { onClickScene, visible, ...other } = props;\n    return (\n        <Modal visible={visible} {...other}>\n            <SavedList visible={visible} onClick={onClickScene} />\n        </Modal>\n    );\n};\n\nexport default SavedListModal;\n\n",
        "called_code_segment_file_1": "private handleSelectScene = (savedScene: any) => {\n        const { onClick } = this.props;\n        if (onClick) {\n            onClick(savedScene);\n        }\n    }",
        "invoking_code_segment_file_2": "<SavedList visible={visible} onClick={onClickScene} />",
        "invoking_code_segment_file_3": "const { onClickScene, visible, ...other } = props;\n    return (\n        <Modal visible={visible} {...other}>\n            <SavedList visible={visible} onClick={onClickScene} />\n        </Modal>\n    );",
        "new_file_code_segment": "const handleDownloadScene = (scene: ISavedScene) => {\n    UtilTools.saveString(scene.scene, scene.name);\n};\n\nexport default handleDownloadScene;",
        "feature_description": "Add a download button to each saved scene card to allow users to download the scene JSON.",
        "detailed_feature_description": "The new feature involves adding a download button to each saved scene card in the SavedList component. This button will allow users to download the scene JSON file. The handleDownloadScene function, implemented in a new file (#file 4), will be invoked when the download button is clicked. This function will use the UtilTools.saveString method to save the scene JSON to the user's device.",
        "modified_complete_code": {
            "#file 1": "//Modify\nprivate handleSelectScene = (savedScene: any) => {\n        const { onClick } = this.props;\n        if (onClick) {\n            onClick(savedScene);\n        }\n    }\n\n//New\nprivate renderCardActions = (scene: ISavedScene) => {\n    return [\n        <Icon\n            key=\"download\"\n            name=\"download\"\n            onClick={e => {\n                e.stopPropagation();\n                handleDownloadScene(scene);\n            }}\n        />,\n        <Icon\n            key=\"delete\"\n            name=\"trash\"\n            onClick={e => {\n                e.stopPropagation();\n                SceneDatabase.delete(scene.id)\n                .then(() => {\n                    this.getSceneList();\n                });\n            }}\n        />\n    ];\n}",
            "#file 2": "<SavedList visible={visible} onClick={onClickScene} />",
            "#file 3": "const { onClickScene, visible, ...other } = props;\n    return (\n        <Modal visible={visible} {...other}>\n            <SavedList visible={visible} onClick={onClickScene} />\n        </Modal>\n    );",
            "#file 4": "const handleDownloadScene = (scene: ISavedScene) => {\n    UtilTools.saveString(scene.scene, scene.name);\n};\n\nexport default handleDownloadScene;"
        }
    },
    {
        "repo": "rules",
        "content": "'rules/apps/doc-app/src/app/services/anchor-scroll.service.ts'\n:import { Injectable, Inject } from '@angular/core';\nimport { DOCUMENT, Location } from '@angular/common';\nimport { PageScrollService } from 'ngx-page-scroll-core';\nimport { Router } from '@angular/router';\nimport { log } from 'util';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AnchorScrollService {\n\n  constructor(\n    private pageScrollService: PageScrollService,\n    private router: Router,\n    @Inject(DOCUMENT) private document: any\n  ) { }\n\n  scrollToTarget(targetId: string): void {\n    const parentView = this.document.getElementById('mat-content');\n\n    if (targetId) {\n      this.pageScrollService.scroll({\n        document: this.document,\n        scrollTarget: '#' + targetId,\n        scrollViews: [\n          parentView\n        ],\n        scrollOffset: 20,\n        duration: 250\n      });\n    }\n\n    if (!targetId) {\n      parentView.scroll(0, 0);\n    }\n  }\n}\n\n'rules/apps/doc-app/src/app/layout/sidebar/sidebar.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { HeadingsListService } from '../../services/headings-list.service';\nimport { NavigationEnd, Route, Router, RouterEvent, Routes } from '@angular/router';\n\nimport { routes } from '../../app.routing';\nimport { filter } from 'rxjs/operators';\nimport { AnchorScrollService } from '../../services/anchor-scroll.service';\n\n@Component({\n  selector: 'app-sidebar',\n  templateUrl: './sidebar.component.html',\n  styleUrls: ['./sidebar.component.scss']\n})\nexport class SidebarComponent implements OnInit {\n  navItems: HTMLElement[];\n  menuList: Routes;\n  activeRoute: string;\n  activeFragment: string;\n\n  constructor(\n    private router: Router,\n    private headingsListService: HeadingsListService,\n  ) {\n    this.router.events.pipe(\n        filter((event: RouterEvent) => event instanceof NavigationEnd)\n      )\n      .subscribe(() => {\n        this.activeRoute = this.router.url.split('#')[0].replace('/', '');\n        this.activeFragment = this.router.url.split('#')[1];\n      });\n\n    this.menuList = routes.filter((route: Route) => {\n      return route.path; // exclude empty route\n    });\n  }\n\n  ngOnInit(): void {\n    this.headingsListService.navList\n      .subscribe((data: HTMLElement[]) => {\n        this.navItems = data;\n      });\n  }\n}\n\n'rules/apps/doc-app/src/app/app.component.spec.ts'\n:import { TestBed, waitForAsync } from '@angular/core/testing';\nimport {RouterTestingModule} from '@angular/router/testing';\nimport {AppComponent} from './app.component';\nimport {HeaderComponent} from './layout/header/header.component';\nimport {SidebarComponent} from './layout/sidebar/sidebar.component';\nimport {AsideNavComponent} from './layout/aside-nav/aside-nav.component';\nimport {FooterComponent} from './layout/footer/footer.component';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatListModule } from '@angular/material/list';\nimport { MatSidenavModule } from '@angular/material/sidenav';\nimport { MatToolbarModule } from '@angular/material/toolbar';\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\n\ndescribe('AppComponent', () => {\n  beforeEach(waitForAsync(() => {\n    TestBed.configureTestingModule({\n      imports: [\n        RouterTestingModule,\n        MatIconModule,\n        MatSidenavModule,\n        MatListModule,\n        BrowserAnimationsModule\n      ],\n      declarations: [\n        AppComponent,\n        HeaderComponent,\n        SidebarComponent,\n        AsideNavComponent,\n        FooterComponent,\n        MatToolbarModule\n      ]\n    }).compileComponents();\n  }));\n\n  it('should create the app', () => {\n    const fixture = TestBed.createComponent(AppComponent);\n    const app = fixture.debugElement.componentInstance;\n    expect(app).toBeTruthy();\n  });\n});\n\n",
        "called_code_segment_file_1": "scrollToTarget(targetId: string): void { const parentView = this.document.getElementById('mat-content'); if (targetId) { this.pageScrollService.scroll({ document: this.document, scrollTarget: '#' + targetId, scrollViews: [ parentView ], scrollOffset: 20, duration: 250 }); } if (!targetId) { parentView.scroll(0, 0); } }",
        "invoking_code_segment_file_2": "ngOnInit(): void { this.headingsListService.navList .subscribe((data: HTMLElement[]) => { this.navItems = data; }); }",
        "invoking_code_segment_file_3": "this.router.events.pipe( filter((event: RouterEvent) => event instanceof NavigationEnd) ) .subscribe(() => { this.activeRoute = this.router.url.split('#')[0].replace('/', ''); this.activeFragment = this.router.url.split('#')[1]; });",
        "new_file_code_segment": "export class ScrollHistoryService { private scrollHistory: string[] = []; addScrollTarget(targetId: string): void { this.scrollHistory.push(targetId); } getScrollHistory(): string[] { return this.scrollHistory; } }",
        "feature_description": "Add a scroll history feature to track and manage the scroll targets visited by the user.",
        "detailed_feature_description": "The new feature involves creating a ScrollHistoryService in a new file (#file 4) to keep track of the scroll targets the user has visited. This service will be integrated into the existing AnchorScrollService (#file 1) to update the scroll history whenever a new target is scrolled to. The SidebarComponent (#file 2) will be updated to use this service to display the scroll history, and the AppComponent (#file 3) will be updated to initialize and use this service.",
        "modified_complete_code": {
            "file_1": "import { Injectable, Inject } from '@angular/core'; import { DOCUMENT, Location } from '@angular/common'; import { PageScrollService } from 'ngx-page-scroll-core'; import { Router } from '@angular/router'; import { log } from 'util'; import { ScrollHistoryService } from './scroll-history.service'; #Modify @Injectable({ providedIn: 'root' }) export class AnchorScrollService { constructor( private pageScrollService: PageScrollService, private router: Router, @Inject(DOCUMENT) private document: any, private scrollHistoryService: ScrollHistoryService #Modify ) { } scrollToTarget(targetId: string): void { const parentView = this.document.getElementById('mat-content'); if (targetId) { this.pageScrollService.scroll({ document: this.document, scrollTarget: '#' + targetId, scrollViews: [ parentView ], scrollOffset: 20, duration: 250 }); this.scrollHistoryService.addScrollTarget(targetId); #Modify } if (!targetId) { parentView.scroll(0, 0); } } }",
            "file_2": "import { Component, OnInit } from '@angular/core'; import { HeadingsListService } from '../../services/headings-list.service'; import { NavigationEnd, Route, Router, RouterEvent, Routes } from '@angular/router'; import { routes } from '../../app.routing'; import { filter } from 'rxjs/operators'; import { AnchorScrollService } from '../../services/anchor-scroll.service'; import { ScrollHistoryService } from '../../services/scroll-history.service'; #Modify @Component({ selector: 'app-sidebar', templateUrl: './sidebar.component.html', styleUrls: ['./sidebar.component.scss'] }) export class SidebarComponent implements OnInit { navItems: HTMLElement[]; menuList: Routes; activeRoute: string; activeFragment: string; constructor( private router: Router, private headingsListService: HeadingsListService, private scrollHistoryService: ScrollHistoryService #Modify ) { this.router.events.pipe( filter((event: RouterEvent) => event instanceof NavigationEnd) ) .subscribe(() => { this.activeRoute = this.router.url.split('#')[0].replace('/', ''); this.activeFragment = this.router.url.split('#')[1]; }); this.menuList = routes.filter((route: Route) => { return route.path; // exclude empty route }); } ngOnInit(): void { this.headingsListService.navList .subscribe((data: HTMLElement[]) => { this.navItems = data; }); } getScrollHistory(): string[] { return this.scrollHistoryService.getScrollHistory(); #Modify } }",
            "file_3": "import { Component, OnInit } from '@angular/core'; import { Router } from '@angular/router'; import { ScrollHistoryService } from './services/scroll-history.service'; #Modify @Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent implements OnInit { constructor(private router: Router, private scrollHistoryService: ScrollHistoryService #Modify) {} ngOnInit(): void { // Initialize scroll history service this.scrollHistoryService.addScrollTarget('initial'); #Modify } }",
            "file_4": "import { Injectable } from '@angular/core'; #New @Injectable({ providedIn: 'root' }) export class ScrollHistoryService { private scrollHistory: string[] = []; addScrollTarget(targetId: string): void { this.scrollHistory.push(targetId); } getScrollHistory(): string[] { return this.scrollHistory; } }"
        }
    },
    {
        "repo": "template-three",
        "content": "'template-three/src/Scene.tsx'\n:import { staticFile } from \"remotion\";\nimport { getVideoMetadata, VideoMetadata } from \"@remotion/media-utils\";\nimport { ThreeCanvas, useVideoTexture } from \"@remotion/three\";\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { AbsoluteFill, useVideoConfig, Video } from \"remotion\";\nimport { Phone } from \"./Phone\";\nimport { z } from \"zod\";\nimport { zColor } from \"@remotion/zod-types\";\n\nconst container: React.CSSProperties = {\n  backgroundColor: \"white\",\n};\n\nconst videoStyle: React.CSSProperties = {\n  position: \"absolute\",\n  opacity: 0,\n};\n\nexport const myCompSchema = z.object({\n  phoneColor: zColor(),\n  deviceType: z.enum([\"phone\", \"tablet\"]),\n});\n\ntype MyCompSchemaType = z.infer<typeof myCompSchema>;\n\nexport const Scene: React.FC<\n  {\n    baseScale: number;\n  } & MyCompSchemaType\n> = ({ baseScale, phoneColor, deviceType }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const { width, height } = useVideoConfig();\n  const [videoData, setVideoData] = useState<VideoMetadata | null>(null);\n\n  const videoSrc =\n    deviceType === \"phone\" ? staticFile(\"phone.mp4\") : staticFile(\"tablet.mp4\");\n\n  useEffect(() => {\n    getVideoMetadata(videoSrc)\n      .then((data) => setVideoData(data))\n      .catch((err) => console.log(err));\n  }, [videoSrc]);\n\n  const texture = useVideoTexture(videoRef);\n  return (\n    <AbsoluteFill style={container}>\n      <Video ref={videoRef} src={videoSrc} style={videoStyle} />\n      {videoData ? (\n        <ThreeCanvas linear width={width} height={height}>\n          <ambientLight intensity={1.5} color={0xffffff} />\n          <pointLight position={[10, 10, 0]} />\n          <Phone\n            phoneColor={phoneColor}\n            baseScale={baseScale}\n            videoTexture={texture}\n            aspectRatio={videoData.aspectRatio}\n          />\n        </ThreeCanvas>\n      ) : null}\n    </AbsoluteFill>\n  );\n};\n\n'template-three/src/Root.tsx'\n:import { Composition } from \"remotion\";\nimport { Scene, myCompSchema } from \"./Scene\";\n\n// Welcome to the Remotion Three Starter Kit!\n// Two compositions have been created, showing how to use\n// the `ThreeCanvas` component and the `useVideoTexture` hook.\n\n// You can play around with the example or delete everything inside the canvas.\n\n// Remotion Docs:\n// https://remotion.dev/docs\n\n// @remotion/three Docs:\n// https://remotion.dev/docs/three\n\n// React Three Fiber Docs:\n// https://docs.pmnd.rs/react-three-fiber/getting-started/introduction\n\nexport const RemotionRoot: React.FC = () => {\n  return (\n    <>\n      <Composition\n        id=\"Scene\"\n        component={Scene}\n        durationInFrames={300}\n        fps={30}\n        width={1280}\n        height={720}\n        schema={myCompSchema}\n        defaultProps={{\n          deviceType: \"phone\",\n          phoneColor: \"rgba(110, 152, 191, 0.00)\" as const,\n          baseScale: 1,\n        }}\n      />\n    </>\n  );\n};\n\n'template-three/src/index.ts'\n:import { registerRoot } from \"remotion\";\nimport { RemotionRoot } from \"./Root\";\n\nregisterRoot(RemotionRoot);\n\n",
        "called_code_segment_file_1": "export const Scene: React.FC<{ baseScale: number } & MyCompSchemaType> = ({ baseScale, phoneColor, deviceType }) => { ... }",
        "invoking_code_segment_file_2": "<Composition id=\"Scene\" component={Scene} durationInFrames={300} fps={30} width={1280} height={720} schema={myCompSchema} defaultProps={{ deviceType: \"phone\", phoneColor: \"rgba(110, 152, 191, 0.00)\" as const, baseScale: 1, }} />",
        "invoking_code_segment_file_3": "import { registerRoot } from \"remotion\"; import { RemotionRoot } from \"./Root\"; registerRoot(RemotionRoot);",
        "new_file_code_segment": "export const CustomDevice: React.FC<{ deviceType: 'phone' | 'tablet', baseScale: number, phoneColor: string }> = ({ deviceType, baseScale, phoneColor }) => { ... }",
        "feature_description": "Add a new feature to support custom device rendering based on device type and color.",
        "detailed_feature_description": "The new feature involves creating a new component `CustomDevice` in a new file (#file 4) that handles the rendering of different devices based on the provided type and color. This component will be invoked from the `Scene` component in #file 1, which will be modified to use `CustomDevice` instead of directly handling the device rendering. The `Composition` component in #file 2 will remain unchanged as it only needs to pass the props to the `Scene` component. The `registerRoot` function in #file 3 will also remain unchanged as it only registers the root component.",
        "modified_complete_code": {
            "#file 1": "import { staticFile } from \"remotion\"; import { getVideoMetadata, VideoMetadata } from \"@remotion/media-utils\"; import { ThreeCanvas, useVideoTexture } from \"@remotion/three\"; import React, { useEffect, useRef, useState } from \"react\"; import { AbsoluteFill, useVideoConfig, Video } from \"remotion\"; import { Phone } from \"./Phone\"; import { z } from \"zod\"; import { zColor } from \"@remotion/zod-types\"; import { CustomDevice } from \"./CustomDevice\"; //New\n\nconst container: React.CSSProperties = { backgroundColor: \"white\", };\n\nconst videoStyle: React.CSSProperties = { position: \"absolute\", opacity: 0, };\n\nexport const myCompSchema = z.object({ phoneColor: zColor(), deviceType: z.enum([\"phone\", \"tablet\"]), });\n\ntype MyCompSchemaType = z.infer<typeof myCompSchema>;\n\nexport const Scene: React.FC<{ baseScale: number } & MyCompSchemaType> = ({ baseScale, phoneColor, deviceType }) => { const videoRef = useRef<HTMLVideoElement>(null); const { width, height } = useVideoConfig(); const [videoData, setVideoData] = useState<VideoMetadata | null>(null);\n\nconst videoSrc = deviceType === \"phone\" ? staticFile(\"phone.mp4\") : staticFile(\"tablet.mp4\");\n\nuseEffect(() => { getVideoMetadata(videoSrc) .then((data) => setVideoData(data)) .catch((err) => console.log(err)); }, [videoSrc]);\n\nconst texture = useVideoTexture(videoRef); return ( <AbsoluteFill style={container}> <Video ref={videoRef} src={videoSrc} style={videoStyle} /> {videoData ? ( <ThreeCanvas linear width={width} height={height}> <ambientLight intensity={1.5} color={0xffffff} /> <pointLight position={[10, 10, 0]} /> <CustomDevice deviceType={deviceType} baseScale={baseScale} phoneColor={phoneColor} /> //Modify </ThreeCanvas> ) : null} </AbsoluteFill> ); };",
            "#file 2": "import { Composition } from \"remotion\"; import { Scene, myCompSchema } from \"./Scene\";\n\n// Welcome to the Remotion Three Starter Kit!\n// Two compositions have been created, showing how to use\n// the `ThreeCanvas` component and the `useVideoTexture` hook.\n\n// You can play around with the example or delete everything inside the canvas.\n\n// Remotion Docs:\n// https://remotion.dev/docs\n\n// @remotion/three Docs:\n// https://remotion.dev/docs/three\n\n// React Three Fiber Docs:\n// https://docs.pmnd.rs/react-three-fiber/getting-started/introduction\n\nexport const RemotionRoot: React.FC = () => { return ( <> <Composition id=\"Scene\" component={Scene} durationInFrames={300} fps={30} width={1280} height={720} schema={myCompSchema} defaultProps={{ deviceType: \"phone\", phoneColor: \"rgba(110, 152, 191, 0.00)\" as const, baseScale: 1, }} /> </> ); };",
            "#file 3": "import { registerRoot } from \"remotion\"; import { RemotionRoot } from \"./Root\";\n\nregisterRoot(RemotionRoot);",
            "#file 4": "import React from \"react\"; import { Phone } from \"./Phone\";\n\nexport const CustomDevice: React.FC<{ deviceType: 'phone' | 'tablet', baseScale: number, phoneColor: string }> = ({ deviceType, baseScale, phoneColor }) => { return ( <Phone phoneColor={phoneColor} baseScale={baseScale} videoTexture={null} aspectRatio={1} /> ); };"
        }
    },
    {
        "repo": "Approvals.NodeJS",
        "content": "'Approvals.NodeJS/lib/AUtils.ts'\n:import * as fs from \"fs\";\nimport * as path from \"path\";\nimport * as shell from \"shelljs\";\nimport * as osTools from \"./osTools\";\n\ninterface CachedProgramLookups {\n  [programName: string]: string | null;\n}\n\nconst _cachedProgramLookups: CachedProgramLookups = {};\n\nconst createEmptyFileIfNotExists = (file: string): void => {\n  if (!fs.existsSync(file)) {\n    const ext = (path.extname(file) || \"\").toLowerCase();\n    if (ext === \".png\") {\n      fs.writeFileSync(\n        file,\n        fs.readFileSync(\n          path.join(__dirname, \"DummyApprovedFiles\", \"UnapprovedImage.png\"),\n        ),\n      );\n    } else {\n      fs.writeFileSync(file, \"\");\n    }\n  }\n};\n\nconst assertFileExists = (file: string): void => {\n  if (!fs.existsSync(file)) {\n    throw new Error(\"File not found: \" + file);\n  }\n};\n\nconst hasCommandLineArgument = (arg: string): boolean => {\n  return process.argv.some((val) => (val || \"\").toLowerCase() === arg);\n};\n\nconst isBinaryFile = (buffer: Buffer | String): boolean => {\n  const contentStartUTF8 = buffer.toString(\"utf8\", 0, 24);\n  for (let i = 0, _ref = contentStartUTF8.length; i < _ref; i++) {\n    const charCode = contentStartUTF8.charCodeAt(i);\n    if (charCode === 65533 || charCode <= 8) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst trimExtension = (filePath: string): string => {\n  if (!filePath) return filePath;\n  const i = filePath.lastIndexOf(\".\");\n  const ext = i < 0 ? \"\" : filePath.substr(i);\n  return ext ? filePath.substring(0, filePath.length - ext.length) : filePath;\n};\n\nconst findProgramOnPath = (programName: string): string | null => {\n  if (_cachedProgramLookups.hasOwnProperty(programName)) {\n    return _cachedProgramLookups[programName];\n  }\n  const output = shell.exec(\n    `${osTools.findProgramPathCommand} ${programName}`,\n    { silent: true },\n  );\n  let result: string | null = null;\n  if (output.stdout) {\n    const file = output.stdout.split(\"\\n\")[0].trim();\n    const fixedFile = fixFilePathSlashes(file);\n    if (fs.existsSync(fixedFile)) {\n      result = fixedFile;\n    }\n  }\n  if (!result) {\n    const pathMinusExtension = trimExtension(programName);\n    if (pathMinusExtension !== programName) {\n      result = findProgramOnPath(pathMinusExtension);\n    }\n  }\n  _cachedProgramLookups[programName] = result;\n  return result;\n};\n\nconst searchForExecutable = (\n  folderInProgramInFiles?: string,\n  fileName?: string,\n): string => {\n  if (!fileName) {\n    fileName = folderInProgramInFiles;\n    folderInProgramInFiles = undefined;\n  }\n  const programOnPath = findProgramOnPath(fileName!);\n  if (programOnPath) {\n    return programOnPath;\n  }\n  const lookInProgramFiles = (fileName_: string): string | null => {\n    if (osTools.platform.isWindows) {\n      let tryVar = findInPath(\n        \"C:/Program Files\",\n        folderInProgramInFiles || \"\",\n        fileName_,\n      );\n      if (tryVar) {\n        return tryVar;\n      }\n      tryVar = findInPath(\n        \"C:/Program Files (x86)\",\n        folderInProgramInFiles || \"\",\n        fileName_,\n      );\n      if (tryVar) {\n        return tryVar;\n      }\n    }\n    return null;\n  };\n  const findInPath = (\n    root: string,\n    dir: string,\n    file: string,\n  ): string | null => {\n    const fullPath = path.join(root, dir, file);\n    const fixedFullPath = fixFilePathSlashes(fullPath);\n    if (fs.existsSync(fixedFullPath)) {\n      return fixedFullPath;\n    }\n    return null;\n  };\n  let fileFound = lookInProgramFiles(fileName!);\n  if (fileFound) {\n    return fileFound;\n  }\n  const suffix = \".exe\";\n  if (!fileName!.endsWith(suffix)) {\n    fileFound = lookInProgramFiles(fileName! + suffix);\n    if (fileFound) {\n      return fileFound;\n    }\n  }\n  return \"\";\n};\n\nconst fixFilePathSlashes = (path_: string): string => {\n  return path_.replace(/\\\\/g, \"/\");\n};\n\nconst recursivelyOrderKeys = (unordered: any): any => {\n  if (unordered === null) {\n    return null;\n  }\n  if (Array.isArray(unordered)) {\n    return unordered.map(recursivelyOrderKeys);\n  }\n  if (typeof unordered === \"object\" && unordered !== null) {\n    const ordered: { [key: string]: any } = {};\n    Object.keys(unordered)\n      .sort()\n      .forEach((key) => {\n        ordered[key] = recursivelyOrderKeys(unordered[key]);\n      });\n    return ordered;\n  }\n  return unordered;\n};\n\nconst stringifyKeysInOrder = (data: any): string => {\n  const sortedData = recursivelyOrderKeys(data);\n  return JSON.stringify(sortedData, null, \"  \");\n};\n\nexport {\n  createEmptyFileIfNotExists,\n  assertFileExists,\n  hasCommandLineArgument,\n  isBinaryFile,\n  findProgramOnPath,\n  searchForExecutable,\n  fixFilePathSlashes,\n  stringifyKeysInOrder,\n};\n\n'Approvals.NodeJS/lib/Approvals.ts'\n:/*jshint freeze:false */\n\n/**\n * Approvals module.\n * @module approvals\n */\n\nimport callsite from \"callsite\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport * as cfg from \"./config\";\nimport { BinaryWriter } from \"./Writers/BinaryWriter\";\nimport { FileApprover } from \"./FileApprover\";\nimport { FinalMessages } from \"./FinalMessages\";\nimport { ManualNamer } from \"./ManualNamer\";\nimport { Namer } from \"./Core/Namer\";\nimport { ReporterFactory, ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { Scrubber, Scrubbers } from \"./Scrubbers/Scrubbers\";\nimport { StringWriter } from \"./StringWriter\";\nimport { Writer } from \"./Core/Writer\";\nimport { postRunCleanup } from \"./postRunCleanup\";\nimport { stringifyKeysInOrder } from \"./AUtils\";\n\n// if someone tries to call 'require(\"approvals\")...' without calling \".mocha(...) or\n// they won't get a helpful error. So we put this in there - just in case\"\nimport { MochaNamer } from \"./Providers/Mocha/MochaNamer\";\n\nimport { beforeEachVerifierBase } from \"./Providers/BeforeEachVerifierBase\";\n\n/**\n * Contains some helpful and util scrubbers that can be used for scrubbing data before saving to a received file.\n */\nexport { Scrubbers as scrubbers };\n\nif (typeof beforeEach === \"function\") {\n  beforeEach(function (): void {\n    if (!this) {\n      return;\n    }\n    this.verify = function () {\n      throw new Error(\"You must call either .mocha()\");\n    };\n  });\n}\n\n// keep track of approved files we run into with tests\nconst listOfApprovedFiles: string[] = [];\nprocess.on(\"approvalFileApproved\", function (fileName): void {\n  if (listOfApprovedFiles.indexOf(fileName) === -1) {\n    listOfApprovedFiles.push(fileName);\n  }\n});\n\nprocess.on(\"exit\", function (): void {\n  const options = cfg.currentConfig();\n  postRunCleanup(options, listOfApprovedFiles);\n  const finalMessages = FinalMessages.getMessages();\n  if (finalMessages.length) {\n    console.log(\"******************************\");\n    console.log(\"* Approvals Report: WARNING!\");\n    finalMessages.forEach((message: string) => {\n      console.log(`*  - ${message}`);\n    });\n    console.log(\"******************************\");\n  }\n});\n\n/**\n * Allows you to provide overrides to the default configuration.\n *\n * @example\n * const approvals = require('approvals');\n * approvals.configure({\n *   reporters: ['p4merge']\n * });\n *\n * @param {*} overrideOptions\n */\nexport function configure(overrideOptions: cfg.Config): typeof module.exports {\n  cfg.configure(overrideOptions);\n  return module.exports;\n}\n\n/**\n * Allows the creation of an approvals configuration object using any passed in options to override the defaults.\n * @param {Object} overrideOptions\n * @returns {Object} approvals config object with any options overridden.\n */\nexport function getConfig(overrideOptions?: cfg.Config): cfg.Config {\n  return cfg.getConfig(overrideOptions);\n}\n\n/**\n * Configure approvals to hook into Mocha tests.\n * @param {*} optionalBaseDir - An optional folder to save approval files to.\n */\n\nexport function mocha(optionalBaseDir?: string): typeof module.exports {\n  // if not providing a base dir, fallback to the current calling code's directory\n  if (!optionalBaseDir) {\n      let fileName = callsite()[1].getFileName();\n      if (fileName.startsWith(\"file://\")) {\n          fileName = fileURLToPath(fileName);\n      }\n      optionalBaseDir = path.dirname(fileName);\n  }\n  beforeEachVerifierBase(\n    MochaNamer,\n    \"require('Approvals').mocha();\",\n    optionalBaseDir,\n  );\n\n  return module.exports;\n}\n\nfunction jasmineExport(): void {\n  throw new Error(\n    \"Aww shucks.\\n\\nApprovals support of Jasmine has been completely yanked out (don't shoot). \\n\\n Jasmine has grown quite complicated (behind our back) and we haven't had enough time to figure out a solid integration pattern... for now it's support has been removed.\\n\\n Check out the docs for manual usage of approval tests to work around the missing Jasmine integration (it should be a straightforward change for you, really).\\n\\n We'll consider bringing it back if we can get someone with interest in submitting a pull request that can bring it back...\",\n  );\n}\n\n/**\n * `reporters` gives access to the `MultiReporter`\n *\n * @example\n * const MultiReporter = approvals.reporters.MultiReporter\n */\n\nexport const reporters: { MultiReporter: any } = {\n  /**\n   * This allows access to the MultiReporter constructor.\n   * You can use this to run multiple reporters at the same time.\n   *\n   * @example\n   * approvals.verify(__dirname, \"multi-reporter-example\", \"some data\", {\n   *   reporters: [\n   *     new MultiReporter('p4merge', 'copycommand')\n   *   ]\n   * });\n   */\n  MultiReporter: require(\"./Reporting/Reporters/multiReporter\").default,\n};\n\n/**\n * Use this to apply the scrubber function to any data before running verify.\n *\n * @example\n * // basic approval test with a custom scrubber\n * const approvals = require('approvals');\n * const scrubber = approvals.scrubbers.multiScrubber([\n *    function (data) {\n *      return (data || '').replace(\"some text\", \"some other text\");\n *    },\n *    approvals.scrubbers.guidScrubber // to remove guids from the received data\n * });\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', \"some text to verify\", scrubber);\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - Either the string to save as a text file or a Buffer that represents an image\n * @param {*} scrubber - A function that takes a string and returns a string. Approvals will call this if it exists to scrub the \"data\" before writing to any files.\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\nfunction verifyAndScrub(\n  dirName: string,\n  testName: string,\n  data: BinaryWriter | string,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  scrubber = scrubber || Scrubbers.noScrubber;\n\n  // backwards compatible option\n  if (Array.isArray(optionsOverride)) {\n    optionsOverride = {\n      reporters: optionsOverride,\n    };\n    const stringReporters = JSON.stringify(optionsOverride.reporters);\n    console.error(\n      'For the last arg of the approvals.verify(...) function, if you passed in an array of reporters, something like [\"opendiff\",\"nodediff\"], this has been deprecated and replaced by passing in a config object. Please re-evaluate if you can remove this parameter alltogether and use individual user configs in ~/.approvalConfig, if not then replace this: ' +\n        stringReporters +\n        \" with this { reporters: \" +\n        stringReporters +\n        \"}.\",\n    );\n  }\n\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const namer = new ManualNamer(dirName, testName);\n\n  let writer: Writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data as string);\n\n    writer = new StringWriter(newOptions, data as string);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}\n/**\n *\n * @example\n * // basic approval test\n * const approvals = require('approvals');\n * approvals.verify(__dirname, 'sample-approval-test', \"some text to verify\");\n *\n * @example\n * // basic approval test providing an option to override configuration\n * const approvals = require('approvals');\n * approvals.verify(__dirname, 'sample-approval-test', \"some text to verify\", { normalizeLineEndingsTo: true });\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name save string to call the file associated with this test.\n * @param {(string|Buffer)} data - Either the string to save as a text file or a Buffer that represents an image\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\n\nexport function verify(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride?: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * You can pass as \"data\" any javascript object to be JSON.stringified and run verify against.\n *\n * @example\n * const approvals = require('approvals');\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', { a: \"some text in an object\" });\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - This can be any JavaScript object/array that will be JSON.stringified before running verify\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\nexport function verifyAsJSON(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride: any,\n) {\n  return verifyAsJSONAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * You can pass as \"data\" any javascript object to be JSON.stringified. Before we run verify the scrubber will be run against the complete string before running verify against it.\n\n * @example\n * // basic approval test with a custom scrubber\n * const approvals = require('approvals');\n * const scrubber = approvals.scrubbers.multiScrubber([\n *    function (data) {\n *      return (data || '').replace(\"some text\", \"some other text\");\n *    },\n *    approvals.scrubbers.guidScrubber // to remove guids from the received data\n * });\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', { a: \"some text in an object\" }, scrubber);\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - This can be any JavaScript object/array that will be JSON.stringified before running verify\n * @param {*} scrubber - A function that takes a string and returns a string. Approvals will call this if it exists to scrub the \"data\" before writing to any files.\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\n\nexport function verifyAsJSONAndScrub(\n  dirName: string,\n  testName: string,\n  data: any,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    stringifyKeysInOrder(data),\n    scrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * This allows you to take full control of naming and writing files before verifying.\n *\n * For an example that we use to generate the docs within the readme, check out the [test/readmeTests.js](test/readmeTests.js) in this project.\n *\n * @param {Object} namer\n * @param {Object} writer\n * @param {Function} [reporterFactory]\n * @param {Object} [optionsOverride]\n */\n\nexport function verifyWithControl(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory?: ReporterLoader | null,\n  optionsOverride?: Partial<cfg.Config>,\n) {\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const loader =\n    (reporterFactory as ReporterLoader) ||\n    function () {\n      return [ReporterFactory.loadReporter(newOptions.reporters)];\n    };\n\n  FileApprover.verify(namer, writer, loader, newOptions);\n}\n\n'Approvals.NodeJS/bin/index.ts'\n:#!/usr/bin/env ts-node\nimport es from \"event-stream\";\nimport * as autils from \"../lib/AUtils\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport marked from \"marked\";\nimport TerminalRenderer from \"marked-terminal\";\nimport minimist from \"minimist\";\nimport { configure, verify } from \"../lib/Approvals\";\nimport { redText } from \"../lib/Utilities/ConsoleUtils\";\n\nconst verbose = process.argv.includes(\"--verbose\");\nconst printHelp = process.argv.includes(\"--help\");\n\nfunction printHelpMessage() {\n  if (verbose) {\n    console.log(\"printing help...\");\n  }\n\n  const helpFile = fs.readFileSync(path.join(__dirname, \"help.md\"), \"utf8\");\n  marked.setOptions({\n    renderer: new TerminalRenderer(),\n  });\n  let output = marked.parse(helpFile) as string;\n\n  output = output.replace(/&nbsp;/g, \" \");\n  console.log(output);\n}\n\nfunction errAndExit(msg: string): void {\n  printHelpMessage();\n  console.log(redText(msg));\n  process.exit(1);\n}\n\nif (printHelp) {\n  printHelpMessage();\n  process.exit();\n}\n\nif (verbose) {\n  console.log(\"process.argv: \", process.argv);\n}\n\nconst argv = minimist(process.argv.slice(2), {\n  alias: {\n    reporters: [\"r\"],\n  },\n  boolean: [\"verbose\"],\n});\n\nif (verbose) {\n  console.log(\"parsed args: \", argv);\n}\n\nlet reporters = argv.reporter as string | string[];\nif (typeof reporters === \"string\") {\n  reporters = [reporters];\n}\n\nconst testname = argv._[0];\nif (!testname) {\n  errAndExit(\n    'Missing parameter: supply a test name ex: echo \"hello\" | approvals myFirstTest. This will become the file name myFirstTest.approved.txt in the current directory',\n  );\n}\n\nconst outdir = argv.outdir || process.cwd();\nif (!fs.existsSync(outdir)) {\n  errAndExit(\"Directory not found: \" + outdir);\n}\n\nconst errorOnStaleApprovedFiles = argv.errorOnStaleApprovedFiles === \"true\";\n\nif (verbose) {\n  console.log(\"outdir: \", outdir);\n  console.log(\"errorOnStaleApprovedFiles: \", errorOnStaleApprovedFiles);\n  console.log(\"testname: \", testname);\n  console.log(\n    \"reporters: \",\n    reporters ||\n      \"undefined (but will fallback to approvals preconfigure defaults)\",\n  );\n}\n\nconst opts: any = {};\nif (reporters) {\n  opts.reporters = reporters;\n}\nopts.errorOnStaleApprovedFiles = errorOnStaleApprovedFiles;\n\nif (verbose) {\n  console.log(\"approval opts: \", opts);\n}\n\nopts.forceApproveAll =\n  autils.hasCommandLineArgument(\"--forceapproveall\") ||\n  autils.hasCommandLineArgument(\"-f\");\n\nprocess.stdin.pipe(\n  es.mapSync((data: Buffer) => {\n    const dataToVerify = data.toString();\n    configure(opts);\n    verify(outdir, testname, dataToVerify);\n  }),\n);\n\n",
        "called_code_segment_file_1": "function verifyAndScrub(dirName, testName, data, scrubber, optionsOverride) {\n  scrubber = scrubber || Scrubbers.noScrubber;\n  const newOptions = cfg.getConfig(optionsOverride);\n  const namer = new ManualNamer(dirName, testName);\n  let writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data);\n    writer = new StringWriter(newOptions, data);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}",
        "invoking_code_segment_file_2": "function verify(dirName, testName, data, optionsOverride) {\n  return verifyAndScrub(dirName, testName, data, Scrubbers.noScrubber, optionsOverride);\n}",
        "invoking_code_segment_file_3": "process.stdin.pipe(\n  es.mapSync((data) => {\n    const dataToVerify = data.toString();\n    configure(opts);\n    verify(outdir, testname, dataToVerify);\n  })\n);",
        "new_file_code_segment": "function logVerificationDetails(dirName, testName, data, scrubber, optionsOverride) {\n  console.log(`Verifying data in directory: ${dirName}`);\n  console.log(`Test name: ${testName}`);\n  console.log(`Data to verify: ${data}`);\n  console.log(`Scrubber used: ${scrubber.name}`);\n  console.log(`Options override:`, optionsOverride);\n}",
        "feature_description": "Add logging for verification details to improve debugging and transparency.",
        "detailed_feature_description": "The new feature introduces logging of verification details before the actual verification process. This includes logging the directory, test name, data to verify, scrubber used, and any options overrides. This logging is implemented in a new file (#file 4) and is invoked from #file 1 to provide detailed information about the verification process.",
        "modified_complete_code": {
            "#file 1": "function verifyAndScrub(dirName, testName, data, scrubber, optionsOverride) {\n  scrubber = scrubber || Scrubbers.noScrubber;\n  const newOptions = cfg.getConfig(optionsOverride);\n  const namer = new ManualNamer(dirName, testName);\n  let writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data);\n    writer = new StringWriter(newOptions, data);\n  }\n  #Modify logVerificationDetails(dirName, testName, data, scrubber, optionsOverride);\n  verifyWithControl(namer, writer, null, newOptions);\n}",
            "#file 2": "function verify(dirName, testName, data, optionsOverride) {\n  return verifyAndScrub(dirName, testName, data, Scrubbers.noScrubber, optionsOverride);\n}",
            "#file 3": "process.stdin.pipe(\n  es.mapSync((data) => {\n    const dataToVerify = data.toString();\n    configure(opts);\n    verify(outdir, testname, dataToVerify);\n  })\n);",
            "#file 4": "#New function logVerificationDetails(dirName, testName, data, scrubber, optionsOverride) {\n  console.log(`Verifying data in directory: ${dirName}`);\n  console.log(`Test name: ${testName}`);\n  console.log(`Data to verify: ${data}`);\n  console.log(`Scrubber used: ${scrubber.name}`);\n  console.log(`Options override:`, optionsOverride);\n}"
        }
    },
    {
        "repo": "Day59-Angular-Practice",
        "content": "'Day59-Angular-Practice/app/task.ts'\n:export class Task {\n  public done: boolean = false;\n  public points: number = 0;\n  constructor(public description: string, public id: number) {\n\n  }\n\n}\n\nexport function capitalize(task: Task) {\n  task.description = task.description.toUpperCase();\n}\n\n'Day59-Angular-Practice/app/task-list.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {DeleteTaskComponent} from './delete-task.component';\nimport {AppComponent} from './app.component';\nimport {EditTaskComponent} from './edit-task.component'\nimport {PointsComponent} from './points.component'\n\n@Component({\n  selector: 'task-list',\n  inputs: ['newtasks'],\n  directives: [DeleteTaskComponent, NewTaskComponent, EditTaskComponent, PointsComponent],\n  template: `\n    <new-task\n      (emitTasks)=\"concatArrays($event)\">\n    </new-task>\n    <h3\n      *ngFor=\"#task of newtasks\"\n      (click)=\"selectTask(task)\">\n      <h1>\n      {{task.description}}\n      </h1>\n      <points [task] = \"task\" [fakeList] = \"newtasks\"></points>\n      <delete-task\n        (click) =\"delete(task)\">\n      </delete-task>\n    </h3>\n    <edit-task *ngIf = \"selectedTask\" [task] = \"selectedTask\">\n    </edit-task>\n  `\n})\n\nexport class TaskListComponent {\n  public newtasks: Task[] = [];\n  public selectedTask: Task;\n  constructor() {\n    this.newtasks = [\n      new Task(\"New\", 0),\n      new Task(\"Learn Kung Fu\", 1),\n      new Task(\"Learn Kung Fu\", 2),\n      new Task(\"Create To-Do List app.\", 3)\n    ]\n  }\n  concatArrays(newTasks: Task[]): void {\n    this.newtasks = this.newtasks.concat(newTasks);\n    console.log(this.newtasks);\n  }\n  taskDeleted(taskSelected) {\n    function callBack(value, index, array) {\n      if (taskSelected !== value) {\n        return taskSelected;\n      };\n    };\n    this.newtasks = this.newtasks.filter(callBack);\n  }\n  selectTask(clicked: Task): void {\n    this.selectedTask = clicked;\n    console.log(\"got it\");\n    console.log(\"selected task: \" + this.selectedTask.description);\n  }\n\n  delete(beerSelected: Task) {\n    // var num = this.newtasks.length;\n    // console.log(num);\n    for (var i =0; i<this.newtasks.length; i++){\n      if(beerSelected.id === this.newtasks[i].id){\n        this.newtasks.splice(i, 1);\n        return true;\n      }\n    }\n  }\n}\n\n'Day59-Angular-Practice/app/app.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {TaskListComponent} from './task-list.component';\n\n\n@Component({\n  selector: 'my-app',\n  directives: [NewTaskComponent, TaskListComponent],\n  template: `\n  <h1>hi</h1>\n  <task-list></task-list>\n\n  `\n})\n\nexport class AppComponent {\n\n}\n\n",
        "called_code_segment_file_1": "public done: boolean = false;\npublic points: number = 0;\nconstructor(public description: string, public id: number) {\n\n}",
        "invoking_code_segment_file_2": "public newtasks: Task[] = [];\nconstructor() {\n  this.newtasks = [\n    new Task(\"New\", 0),\n    new Task(\"Learn Kung Fu\", 1),\n    new Task(\"Learn Kung Fu\", 2),\n    new Task(\"Create To-Do List app.\", 3)\n  ]\n}",
        "invoking_code_segment_file_3": "public selectedTask: Task;\nselectTask(clicked: Task): void {\n  this.selectedTask = clicked;\n  console.log(\"got it\");\n  console.log(\"selected task: \" + this.selectedTask.description);\n}",
        "new_file_code_segment": "export class TaskPriority {\n  constructor(public priority: number) {}\n}",
        "feature_description": "Add a priority feature to tasks.",
        "detailed_feature_description": "The new feature introduces a priority level for each task. This priority will be managed through a new class `TaskPriority` in a new file (#file 4). The `Task` class in #file 1 will be updated to include a priority property. The `TaskListComponent` in #file 2 will be modified to handle tasks with priorities, and the `EditTaskComponent` in #file 3 will be updated to allow editing of task priorities.",
        "modified_complete_code": {
            "file_1": "export class Task {\n  public done: boolean = false;\n  public points: number = 0;\n  public priority: TaskPriority;\n  constructor(public description: string, public id: number, priority: number) {\n    this.priority = new TaskPriority(priority);\n  }\n}\n\nexport function capitalize(task: Task) {\n  task.description = task.description.toUpperCase();\n}",
            "file_2": "import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {DeleteTaskComponent} from './delete-task.component';\nimport {AppComponent} from './app.component';\nimport {EditTaskComponent} from './edit-task.component'\nimport {PointsComponent} from './points.component'\nimport {TaskPriority} from './task-priority';\n\n@Component({\n  selector: 'task-list',\n  inputs: ['newtasks'],\n  directives: [DeleteTaskComponent, NewTaskComponent, EditTaskComponent, PointsComponent],\n  template: `\n    <new-task\n      (emitTasks)=\"concatArrays($event)\">\n    </new-task>\n    <h3\n      *ngFor=\"#task of newtasks\"\n      (click)=\"selectTask(task)\">\n      <h1>\n      {{task.description}}\n      </h1>\n      <points [task] = \"task\" [fakeList] = \"newtasks\"></points>\n      <delete-task\n        (click) =\"delete(task)\">\n      </delete-task>\n    </h3>\n    <edit-task *ngIf = \"selectedTask\" [task] = \"selectedTask\">\n    </edit-task>\n  `\n})\nexport class TaskListComponent {\n  public newtasks: Task[] = [];\n  public selectedTask: Task;\n  constructor() {\n    this.newtasks = [\n      new Task(\"New\", 0, 1),\n      new Task(\"Learn Kung Fu\", 1, 2),\n      new Task(\"Learn Kung Fu\", 2, 3),\n      new Task(\"Create To-Do List app.\", 3, 1)\n    ]\n  }\n  concatArrays(newTasks: Task[]): void {\n    this.newtasks = this.newtasks.concat(newTasks);\n    console.log(this.newtasks);\n  }\n  taskDeleted(taskSelected) {\n    function callBack(value, index, array) {\n      if (taskSelected !== value) {\n        return taskSelected;\n      };\n    };\n    this.newtasks = this.newtasks.filter(callBack);\n  }\n  selectTask(clicked: Task): void {\n    this.selectedTask = clicked;\n    console.log(\"got it\");\n    console.log(\"selected task: \" + this.selectedTask.description);\n  }\n\n  delete(beerSelected: Task) {\n    for (var i =0; i<this.newtasks.length; i++){\n      if(beerSelected.id === this.newtasks[i].id){\n        this.newtasks.splice(i, 1);\n        return true;\n      }\n    }\n  }\n}",
            "file_3": "import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {TaskPriority} from './task-priority';\n\n@Component({\n  selector: 'edit-task',\n  inputs: ['task'],\n  template: `\n    <div>\n      <input [(ngModel)]=\"task.description\" placeholder=\"Description\">\n      <input [(ngModel)]=\"task.priority.priority\" type=\"number\" placeholder=\"Priority\">\n    </div>\n  `\n})\nexport class EditTaskComponent {\n  public task: Task;\n}",
            "file_4": "export class TaskPriority {\n  constructor(public priority: number) {}\n}"
        }
    },
    {
        "repo": "ERC1238-token",
        "content": "'ERC1238-token/test/utils/interfaces.ts'\n:export const IERC1238 = [\n  \"balanceOf(address,uint256)\",\n  \"balanceOfBatch(address,uint256[])\",\n  \"balanceOfBundle(address[],uint256[][])\",\n];\n\nexport const IERC1238Receiver = [\n  \"onERC1238Mint(address,uint256,uint256,bytes)\",\n  \"onERC1238BatchMint(address,uint256[],uint256[],bytes)\",\n];\n\nexport const IERC1238Collection = [\"balanceFromBaseId(address,uint48)\", \"getConstructedTokenID(uint48,address,uint48)\"];\n\nexport const IERC1238URIStorage = [\"tokenURI(uint256)\"];\n\nexport const IERC165 = [\"supportsInterface(bytes4)\"];\n\n'ERC1238-token/test/utils/test-utils.ts'\n:import { BigNumberish, utils } from \"ethers\";\nimport { ethers } from \"hardhat\";\nimport * as interfaces from \"./interfaces\";\n\nexport const ZERO_ADDRESS = \"0x0000000000000000000000000000000000000000\";\nexport const TOKEN_ID_ZERO = 0;\nexport const invalidSignatureV = 26;\nexport const invalidSignatureS = \"0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A1\";\n\nexport const toBN = (units: string, decimalPlaces: number = 18) => ethers.utils.parseUnits(units, decimalPlaces);\nexport const formatBN = (amount: BigNumberish, decimalPlaces: number = 18) =>\n  ethers.utils.formatUnits(amount, decimalPlaces);\n\n// Taken from OpenZeppeling test-helpers\n// https://github.com/OpenZeppelin/openzeppelin-test-helpers/blob/a7c3af4192fd0ad2a61a4ebac66097f5b5934e92/src/makeInterfaceId.js\nexport const getERC165InterfaceId = (functionSignatures: string[] = []) => {\n  const INTERFACE_ID_LENGTH = 4;\n\n  const interfaceIdBuffer = functionSignatures\n    .map(signature => utils.keccak256(utils.toUtf8Bytes(signature)))\n    .map(\n      h => Buffer.from(h.substring(2), \"hex\").slice(0, 4), // bytes4()\n    )\n    .reduce((memo, bytes) => {\n      for (let i = 0; i < INTERFACE_ID_LENGTH; i++) {\n        memo[i] = memo[i] ^ bytes[i]; // xor\n      }\n      return memo;\n    }, Buffer.alloc(INTERFACE_ID_LENGTH));\n\n  return `0x${interfaceIdBuffer.toString(\"hex\")}`;\n};\n\nconst checkInterfaceId = async (contract: any, interfaceName: keyof typeof interfaces) => {\n  const interfaceId = getERC165InterfaceId(interfaces[interfaceName]);\n\n  const isInterfaceSupported = await contract.supportsInterface(interfaceId);\n\n  if (!isInterfaceSupported) throw new Error(`Unsupported interfaceId`);\n\n  return isInterfaceSupported;\n};\n\nexport const shouldSupportInterfaces = async (contract: any, interfaceNames: (keyof typeof interfaces)[]) => {\n  try {\n    const res = await Promise.all(interfaceNames.map(interfaceName => checkInterfaceId(contract, interfaceName)));\n\n    if (res.find(p => p.status === \"rejected\") !== undefined) return false;\n\n    return true;\n  } catch (err) {\n    console.error(err);\n    return false;\n  }\n};\n\n'ERC1238-token/test/ERC1238/extensions/ERC1238URIStorage.ts'\n:// import type { SignerWithAddress } from \"@nomiclabs/hardhat-ethers/dist/src/signer-with-address\";\n// import { expect } from \"chai\";\n// import { artifacts, ethers, waffle } from \"hardhat\";\n// import type { Artifact } from \"hardhat/types\";\n// import type { ERC1238URIStorageMock } from \"../../../src/types/ERC1238URIStorageMock\";\n// import { toBN, ZERO_ADDRESS } from \"../../utils/test-utils\";\n\nconst BASE_URI = \"https://token-cdn-domain/{id}.json\";\nconst EMPTY_URI = \"\";\n\n// TODO: Update tests\n\n// describe(\"ERC1238URIStorage\", function () {\n//   let erc1238UriMock: ERC1238URIStorageMock;\n//   let admin: SignerWithAddress;\n//   let tokenRecipient: SignerWithAddress;\n//   let tokenBatchRecipient: SignerWithAddress;\n\n//   before(async function () {\n//     const signers: SignerWithAddress[] = await ethers.getSigners();\n//     admin = signers[0];\n//     tokenRecipient = signers[1];\n//     tokenBatchRecipient = signers[2];\n//   });\n\n//   beforeEach(async function () {\n//     const ERC1238UriMockArtifact: Artifact = await artifacts.readArtifact(\"ERC1238URIStorageMock\");\n//     erc1238UriMock = <ERC1238URIStorageMock>await waffle.deployContract(admin, ERC1238UriMockArtifact, [BASE_URI]);\n//   });\n\n// describe(\"ERC165\", () => {\n//   it(\"should support the right interfaces\", async () => {\n//     const supported = await shouldSupportInterfaces(erc1238Collection, [\"IERC165\", \"IERC1238\", \"IERC1238URIStorage\"]);\n\n//     expect(supported).to.eq(true);\n//   });\n// });\n\n//   describe(\"internal functions\", () => {\n//     const data = \"0x12345678\";\n//     const tokenId = toBN(\"11223344\");\n//     const tokenURI = \"https://token-cdn-domain/event/exclusive-pass/69\";\n//     const mintAmount = toBN(\"58319\");\n//     const burnAmount = toBN(\"987\");\n\n//     const tokenBatchIds = [toBN(\"2000\"), toBN(\"2010\"), toBN(\"2020\")];\n//     const tokenBatchURIs = [\n//       \"https://ipfs.io/ipfs/Qme7ss3ARVgxv6rXqVPiikMJ8u2NLgmgszg13pYrDKEoiu\",\n//       \"https://ipfs.io/ipfs/Qme7ss3ARVgxv6rXqVPiikMJ8u2NLgmgszg13pYrDKEoiv\",\n//       \"https://ipfs.io/ipfs/Qme7ss3ARVgxv6rXqVPiikMJ8u2NLgmgszg13pYrDKEoiw\",\n//     ];\n//     const mintBatchAmounts = [toBN(\"5000\"), toBN(\"10000\"), toBN(\"42195\")];\n//     const burnBatchAmounts = [toBN(\"5000\"), toBN(\"9001\"), toBN(\"195\")];\n\n//     /*\n//      * URI\n//      */\n//     describe(\"URIs\", () => {\n//       describe(\"_setTokenURI\", () => {\n//         it(\"should set a token URI\", async () => {\n//           const tokenId = 0;\n//           const tokenURI = \"https://token-cdn-domain/special-collection/pass/0\";\n\n//           await erc1238UriMock.setTokenURI(tokenId, tokenURI);\n\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);\n//         });\n\n//         it(\"should emit an event\", async () => {\n//           const tokenId = 1;\n//           const tokenURI = \"https://token-cdn-domain/special-collection/pass/1\";\n\n//           await expect(erc1238UriMock.setTokenURI(tokenId, tokenURI))\n//             .to.emit(erc1238UriMock, \"URI\")\n//             .withArgs(tokenId, tokenURI);\n//         });\n//       });\n\n//       describe(\"tokenURI\", () => {\n//         it(\"should return the right token URI if one is set\", async () => {\n//           const tokenId = 2;\n//           const tokenURI = \"https://token-cdn-domain/special-collection/pass/2\";\n\n//           await erc1238UriMock.setTokenURI(tokenId, tokenURI);\n\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);\n//         });\n\n//         it(\"should return the base URI by default\", async () => {\n//           const unknownTokenId = 99999;\n\n//           expect(await erc1238UriMock.tokenURI(unknownTokenId)).to.eq(BASE_URI);\n//         });\n//       });\n\n//       describe(\"_deleteTokenURI\", () => {\n//         it(\"should delete the token URI if it has been set\", async () => {\n//           const tokenId = 3;\n//           const tokenURI = \"https://token-cdn-domain/special-collection/pass/3\";\n\n//           // Set URI\n//           await erc1238UriMock.setTokenURI(tokenId, tokenURI);\n\n//           // Delete URI\n//           await erc1238UriMock.deleteTokenURI(tokenId);\n\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(BASE_URI);\n//         });\n\n//         it(\"should do nothing if the token URI was not set\", async () => {\n//           const tokenId = 4;\n\n//           await erc1238UriMock.deleteTokenURI(tokenId);\n\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(BASE_URI);\n//         });\n//       });\n//     });\n\n//     /*\n//      * MINTING\n//      */\n\n//     describe(\"_mintWithURI\", () => {\n//       it(\"should revert with the zero address as recipient\", async () => {\n//         await expect(\n//           erc1238UriMock.connect(admin).mintWithURI(ZERO_ADDRESS, tokenId, mintAmount, tokenURI, data),\n//         ).to.be.revertedWith(\"ERC1238: mint to the zero address\");\n//       });\n\n//       it(\"should credit the amount of tokens\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\n//         const balance = await erc1238UriMock.balanceOf(tokenRecipient.address, tokenId);\n\n//         expect(balance).to.eq(mintAmount);\n//       });\n\n//       it(\"should set the right URI when minting\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\n//         expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);\n//       });\n\n//       it(\"should emit a MintSingle event\", async () => {\n//         await expect(erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data))\n//           .to.emit(erc1238UriMock, \"MintSingle\")\n//           .withArgs(admin.address, tokenRecipient.address, tokenId, mintAmount);\n//       });\n\n//       it(\"should emit an URI event\", async () => {\n//         await expect(erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data))\n//           .to.emit(erc1238UriMock, \"URI\")\n//           .withArgs(tokenId, tokenURI);\n//       });\n//     });\n\n//     describe(\"_mintBatchWithURI\", () => {\n//       it(\"should revert with the zero address\", async () => {\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(ZERO_ADDRESS, tokenBatchIds, mintBatchAmounts, tokenBatchURIs, data),\n//         ).to.be.revertedWith(\"ERC1238: mint to the zero address\");\n//       });\n\n//       it(\"should revert if the length of ids and amounts do not match\", async () => {\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(\n//               tokenBatchRecipient.address,\n//               tokenBatchIds.slice(1),\n//               mintBatchAmounts,\n//               tokenBatchURIs,\n//               data,\n//             ),\n//         ).to.be.revertedWith(\"ERC1238: ids and amounts length mismatch\");\n\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(\n//               tokenBatchRecipient.address,\n//               tokenBatchIds,\n//               mintBatchAmounts.slice(1),\n//               tokenBatchURIs,\n//               data,\n//             ),\n//         ).to.be.revertedWith(\"ERC1238: ids and amounts length mismatch\");\n//       });\n\n//       it(\"should revert if the length of ids and uris do not match\", async () => {\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(\n//               tokenBatchRecipient.address,\n//               tokenBatchIds,\n//               mintBatchAmounts,\n//               tokenBatchURIs.slice(1),\n//               data,\n//             ),\n//         ).to.be.revertedWith(\"ERC1238: ids and URIs length mismatch\");\n\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .mintBatchWithURI(\n//               tokenBatchRecipient.address,\n//               tokenBatchIds.slice(1),\n//               mintBatchAmounts.slice(1),\n//               tokenBatchURIs,\n//               data,\n//             ),\n//         ).to.be.revertedWith(\"ERC1238: ids and URIs length mismatch\");\n//       });\n\n//       it(\"should credit the minted tokens\", async () => {\n//         await erc1238UriMock\n//           .connect(admin)\n//           .mintBatchWithURI(tokenBatchRecipient.address, tokenBatchIds, mintBatchAmounts, tokenBatchURIs, data);\n\n//         tokenBatchIds.forEach(async (tokenId, index) =>\n//           expect(await erc1238UriMock.balanceOf(tokenBatchRecipient.address, tokenId)).to.eq(mintBatchAmounts[index]),\n//         );\n//       });\n\n//       it(\"should set the right token URIs\", async () => {\n//         await erc1238UriMock\n//           .connect(admin)\n//           .mintBatchWithURI(tokenBatchRecipient.address, tokenBatchIds, mintBatchAmounts, tokenBatchURIs, data);\n\n//         tokenBatchIds.forEach(async (tokenId, index) =>\n//           expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenBatchURIs[index]),\n//         );\n//       });\n\n//       it(\"should emit a MintBatch event\", async () => {\n//         await expect(\n//           erc1238UriMock.mintBatchWithURI(\n//             tokenRecipient.address,\n//             tokenBatchIds,\n//             mintBatchAmounts,\n//             tokenBatchURIs,\n//             data,\n//           ),\n//         )\n//           .to.emit(erc1238UriMock, \"MintBatch\")\n//           .withArgs(admin.address, tokenRecipient.address, tokenBatchIds, mintBatchAmounts);\n//       });\n\n//       it(\"should emit URI events\", async () => {\n//         const tx = erc1238UriMock.mintBatchWithURI(\n//           tokenRecipient.address,\n//           tokenBatchIds,\n//           mintBatchAmounts,\n//           tokenBatchURIs,\n//           data,\n//         );\n\n//         tokenBatchIds.forEach(\n//           async (tokenId, index) =>\n//             await expect(tx).to.emit(erc1238UriMock, \"URI\").withArgs(tokenId, tokenBatchURIs[index]),\n//         );\n//       });\n//     });\n\n//     /*\n//      * BURNING\n//      */\n\n//     describe(\"_burnAndDeleteURI\", () => {\n//       it(\"should revert when burning the zero account's token\", async () => {\n//         await expect(\n//           erc1238UriMock.connect(admin).burnAndDeleteURI(ZERO_ADDRESS, tokenId, burnAmount),\n//         ).to.be.revertedWith(\"ERC1238: burn from the zero address\");\n//       });\n\n//       it(\"should revert when burning a non-existent token id\", async () => {\n//         await expect(\n//           erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, burnAmount),\n//         ).to.be.revertedWith(\"ERC1238: burn amount exceeds balance\");\n//       });\n\n//       it(\"should revert when burning more than available balance\", async () => {\n//         const amountToMint = burnAmount.sub(1);\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, amountToMint, tokenURI, data);\n//         await expect(\n//           erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, burnAmount),\n//         ).to.be.revertedWith(\"ERC1238: burn amount exceeds balance\");\n//       });\n\n//       it(\"should burn the right amount of tokens\", async () => {\n//         const amountToMint = burnAmount.add(1);\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, amountToMint, tokenURI, data);\n//         await erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, burnAmount);\n//         expect(await erc1238UriMock.balanceOf(tokenRecipient.address, tokenId)).to.eq(1);\n//       });\n\n//       it(\"should emit a BurnSingle event\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, burnAmount, tokenURI, data);\n//         await expect(erc1238UriMock.burnAndDeleteURI(tokenRecipient.address, tokenId, burnAmount))\n//           .to.emit(erc1238UriMock, \"BurnSingle\")\n//           .withArgs(admin.address, tokenRecipient.address, tokenId, burnAmount);\n//       });\n\n//       it(\"should delete any token URI set\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\n//         await erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, mintAmount);\n\n//         expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(BASE_URI);\n//       });\n\n//       it(\"should do nothing if the a token URI was not set\", async () => {\n//         await erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, EMPTY_URI, data);\n\n//         await erc1238UriMock.connect(admin).burnAndDeleteURI(tokenRecipient.address, tokenId, mintAmount);\n\n//         expect(await erc1238UriMock.tokenURI(tokenId)).to.eq(BASE_URI);\n//       });\n//     });\n\n//     describe(\"_burnBatchAndDeleteURIs\", () => {\n//       it(\"should revert when burning the zero account's token\", async () => {\n//         await expect(\n//           erc1238UriMock.connect(admin).burnBatchAndDeleteURIs(ZERO_ADDRESS, tokenBatchIds, burnBatchAmounts),\n//         ).to.be.revertedWith(\"ERC1238: burn from the zero address\");\n//       });\n\n//       it(\"should revert if the length of inputs do not match\", async () => {\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .burnBatchAndDeleteURIs(tokenBatchRecipient.address, tokenBatchIds.slice(1), burnBatchAmounts),\n//         ).to.be.revertedWith(\"ERC1238: ids and amounts length mismatch\");\n\n//         await expect(\n//           erc1238UriMock\n//             .connect(admin)\n//             .burnBatchAndDeleteURIs(tokenBatchRecipient.address, tokenBatchIds, burnBatchAmounts.slice(1)),\n//         ).to.be.revertedWith(\"ERC1238: ids and amounts length mismatch\");\n//       });\n\n//       it(\"should revert when burning a non-existent token id\", async () => {\n//         await erc1238UriMock\n//           .connect(admin)\n//           .mintBatchWithURI(\n//             tokenRecipient.address,\n//             tokenBatchIds.slice(1),\n//             burnBatchAmounts.slice(1),\n//             tokenBatchURIs.slice(1),\n//             data,\n//           );\n\n//         await expect(\n//           erc1238UriMock.connect(admin).burnBatchAndDeleteURIs(tokenRecipient.address, tokenBatchIds, burnBatchAmounts),\n//         ).to.be.revertedWith(\"ERC1238: burn amount exceeds balance\");\n//       });\n\n//       it(\"should properly burn tokens\", async () => {\n//         await erc1238UriMock\n//           .connect(admin)\n//           .mintBatchWithURI(tokenRecipient.address, tokenBatchIds, mintBatchAmounts, tokenBatchURIs, data);\n\n//         await erc1238UriMock\n//           .connect(admin)\n//           .burnBatchAndDeleteURIs(tokenRecipient.address, tokenBatchIds, burnBatchAmounts);\n\n//         tokenBatchIds.forEach(async (tokenId, i) =>\n//           expect(await erc1238UriMock.balanceOf(tokenRecipient.address, tokenId)).to.eq(\n//             mintBatchAmounts[i].sub(burnBatchAmounts[i]),\n//           ),\n//         );\n//       });\n\n//       it(\"should emit a BurnBatch event\", async () => {\n//         await erc1238UriMock.mintBatchWithURI(\n//           tokenRecipient.address,\n//           tokenBatchIds,\n//           mintBatchAmounts,\n//           tokenBatchURIs,\n//           data,\n//         );\n\n//         await expect(erc1238UriMock.burnBatchAndDeleteURIs(tokenRecipient.address, tokenBatchIds, burnBatchAmounts))\n//           .to.emit(erc1238UriMock, \"BurnBatch\")\n//           .withArgs(admin.address, tokenRecipient.address, tokenBatchIds, burnBatchAmounts);\n//       });\n\n//       it(\"should delete all token URIs\", async () => {\n//         await erc1238UriMock.mintBatchWithURI(\n//           tokenRecipient.address,\n//           tokenBatchIds,\n//           mintBatchAmounts,\n//           tokenBatchURIs,\n//           data,\n//         );\n\n//         await erc1238UriMock\n//           .connect(admin)\n//           .burnBatchAndDeleteURIs(tokenRecipient.address, tokenBatchIds, burnBatchAmounts);\n\n//         tokenBatchIds.forEach(async id => {\n//           expect(await erc1238UriMock.tokenURI(id)).to.eq(BASE_URI);\n//         });\n//       });\n//     });\n//   });\n// });\n\n",
        "called_code_segment_file_1": "export const IERC1238URIStorage = [\"tokenURI(uint256)\"];",
        "invoking_code_segment_file_2": "const supported = await shouldSupportInterfaces(erc1238Collection, [\"IERC165\", \"IERC1238\", \"IERC1238URIStorage\"]);\n\nexpect(supported).to.eq(true);",
        "invoking_code_segment_file_3": "const tokenURI = \"https://token-cdn-domain/event/exclusive-pass/69\";\nconst mintAmount = toBN(\"58319\");\nconst burnAmount = toBN(\"987\");\n\nawait erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\nexpect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);",
        "new_file_code_segment": "export const IERC1238URIStorageExtended = [\"tokenURIExtended(uint256)\"];\n\nexport const getExtendedTokenURI = async (contract, tokenId) => {\n  return await contract.tokenURIExtended(tokenId);\n};",
        "feature_description": "Add an extended token URI function to support additional metadata.",
        "detailed_feature_description": "The new feature extends the existing token URI functionality by adding a new function `tokenURIExtended` that can handle additional metadata. This function is implemented in a new file (#file 4) and is invoked from #file 1. #file 2 and #file 3 are updated to handle this new functionality, ensuring compatibility across all interactions.",
        "modified_complete_code": {
            "#file 1": "export const IERC1238URIStorage = [\"tokenURI(uint256)\"];\n#Modify export const IERC1238URIStorageExtended = [\"tokenURIExtended(uint256)\"];",
            "#file 2": "const supported = await shouldSupportInterfaces(erc1238Collection, [\"IERC165\", \"IERC1238\", \"IERC1238URIStorage\", \"IERC1238URIStorageExtended\"]);\n\nexpect(supported).to.eq(true);",
            "#file 3": "const tokenURI = \"https://token-cdn-domain/event/exclusive-pass/69\";\nconst mintAmount = toBN(\"58319\");\nconst burnAmount = toBN(\"987\");\n\nawait erc1238UriMock.mintWithURI(tokenRecipient.address, tokenId, mintAmount, tokenURI, data);\n\nexpect(await erc1238UriMock.tokenURI(tokenId)).to.eq(tokenURI);\n#Modify expect(await erc1238UriMock.tokenURIExtended(tokenId)).to.eq(tokenURI + \"-extended\");",
            "#file 4": "export const IERC1238URIStorageExtended = [\"tokenURIExtended(uint256)\"];\n\nexport const getExtendedTokenURI = async (contract, tokenId) => {\n  return await contract.tokenURIExtended(tokenId);\n};"
        }
    },
    {
        "repo": "Share-IITK2",
        "content": "'Share-IITK2/src/app/search.service.ts'\n:import {Http} from '@angular/http';\nimport {Observable} from 'rxjs/Rx';\nimport {Injectable, Input} from '@angular/core';\n@Injectable()\n\nexport class SearchService {\n    @Input() _searchurl;\n\n    constructor(private _http: Http) {\n        console.log(new Observable);\n    }\n\n    getSearchResult() {\n        return this._http.get(this._searchurl)\n            .map(res => res.json());\n    }\n    \n}\n'Share-IITK2/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule,ReactiveFormsModule } from '@angular/forms';\nimport { HttpModule } from '@angular/http';\nimport { FavoriteComponent } from './favorite.component';\n\nimport { AppComponent } from './app.component';\nimport { CoursesService} from './courses.service';\nimport { SearchComponent} from './search.component';\nimport { SearchService } from './search.service';\nimport {UploadComponent} from './upload.component';\nimport { FileSelectDirective, FileDropDirective} from 'ng2-file-upload';\n\nimport {DashboardComponent} from './dashboard.component';\n\n\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    SearchComponent,\n    UploadComponent,\n    FileSelectDirective,\n    FileDropDirective,\n    DashboardComponent,\n    FavoriteComponent\n    \n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    ReactiveFormsModule,\n    HttpModule\n],\n  providers: [CoursesService,SearchService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'Share-IITK2/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n",
        "called_code_segment_file_1": "getSearchResult() {\n        return this._http.get(this._searchurl)\n            .map(res => res.json());\n    }",
        "invoking_code_segment_file_2": "this._searchService.getSearchResult().subscribe(result => {\n            this.searchResult = result;\n        });",
        "invoking_code_segment_file_3": "// No direct invocation of #file 1 in #file 3",
        "new_file_code_segment": "export class AdvancedSearchService {\n    constructor(private _http: Http) {}\n\n    getAdvancedSearchResult(query: string) {\n        return this._http.get(`/api/advanced-search?query=${query}`)\n            .map(res => res.json());\n    }\n}",
        "feature_description": "Add an advanced search feature that allows users to perform more complex queries.",
        "detailed_feature_description": "The new feature introduces an AdvancedSearchService in #file 4, which provides a method to perform advanced search queries. This service is integrated into the existing SearchService in #file 1, and the SearchComponent in #file 2 is updated to use this new functionality. The DashboardComponent in #file 3 remains unchanged as it does not directly interact with the search functionality.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport {Http} from '@angular/http';\nimport {Observable} from 'rxjs/Rx';\nimport {Injectable, Input} from '@angular/core';\nimport {AdvancedSearchService} from './advanced-search.service';\n\n@Injectable()\nexport class SearchService {\n    @Input() _searchurl;\n\n    constructor(private _http: Http, private _advancedSearchService: AdvancedSearchService) {\n        console.log(new Observable);\n    }\n\n    getSearchResult() {\n        return this._http.get(this._searchurl)\n            .map(res => res.json());\n    }\n\n    //New\n    getAdvancedSearchResult(query: string) {\n        return this._advancedSearchService.getAdvancedSearchResult(query);\n    }\n}",
            "#file 2": "//Modify\nimport { Component, OnInit } from '@angular/core';\nimport { SearchService } from './search.service';\n\n@Component({\n    selector: 'search',\n    template: `<div *ngIf=\"searchResult\">\n                <h2>Search Result</h2>\n                <p>{{ searchResult | json }}</p>\n              </div>`\n})\nexport class SearchComponent implements OnInit {\n    searchResult;\n\n    constructor(private _searchService: SearchService) {}\n\n    ngOnInit() {\n        this._searchService.getSearchResult().subscribe(result => {\n            this.searchResult = result;\n        });\n\n        //New\n        this._searchService.getAdvancedSearchResult('advanced query').subscribe(result => {\n            console.log('Advanced Search Result:', result);\n        });\n    }\n}",
            "#file 3": "// No changes needed as it does not interact with the search functionality",
            "#file 4": "//New\nimport {Http} from '@angular/http';\nimport {Observable} from 'rxjs/Rx';\nimport {Injectable} from '@angular/core';\n\n@Injectable()\nexport class AdvancedSearchService {\n    constructor(private _http: Http) {}\n\n    getAdvancedSearchResult(query: string) {\n        return this._http.get(`/api/advanced-search?query=${query}`)\n            .map(res => res.json());\n    }\n}"
        }
    },
    {
        "repo": "angular-2-navbar",
        "content": "'angular-2-navbar/navbar.service.ts'\n:import { Injectable, Injector } from '@angular/core';\n\nexport interface NavbarItem {\n  route: string;\n  label: string;\n  weight?: number;\n  canDisplay?: Function[];\n}\n\nexport type NavbarItems = NavbarItem[];\n\n@Injectable()\nexport class NavbarService {\n\n  constructor(private items: NavbarItems, private injector: Injector) {\n    this.items = this.items.map((item) => {\n      if (item.weight === undefined) {\n        item.weight = 0;\n      }\n      return item;\n    });\n  }\n\n  getNavbarItems() {\n    const canDisplay = (item) => {\n      if (!item.canDisplay || !item.canDisplay.length) {\n        return true;\n      }\n      return item.canDisplay.filter((guard) => this.injector.get(guard).canActivate(item)).length;\n    };\n    return this.items\n      .filter((item) => canDisplay(item))\n      .sort((a: NavbarItem, b: NavbarItem) => {\n        if (a.weight === b.weight) {\n          return 0;\n        }\n        if (a.weight < b.weight) {\n          return -1;\n        }\n        return 1;\n      });\n  }\n\n}\n\n\n'angular-2-navbar/navbar.component.ts'\n:import { Component, OnInit, ContentChild, ViewChild, ViewContainerRef, TemplateRef, DoCheck } from '@angular/core';\nimport { NavbarService, NavbarItems } from './navbar.service';\n\n@Component({\n  selector: 'app-navbar',\n  templateUrl: './navbar.component.html',\n  styleUrls: ['./navbar.component.scss']\n})\nexport class NavbarComponent implements OnInit, DoCheck {\n\n  private items: NavbarItems;\n\n  @ContentChild(TemplateRef) customTemplate: TemplateRef<Object>;\n  @ViewChild(TemplateRef) defaultTemplate: TemplateRef<Object>;\n\n  constructor(private viewContainer: ViewContainerRef,\n              private navbarService: NavbarService) {\n   }\n\n  ngOnInit() {\n    this.items = this.navbarService.getNavbarItems();\n  }\n\n  ngDoCheck() {\n\n    if (!this.defaultTemplate && !this.customTemplate) {\n      return;\n    }\n\n    this.viewContainer.clear();\n\n    if (this.customTemplate) {\n      this.viewContainer.createEmbeddedView.call(this.viewContainer, this.customTemplate, {\n        items: this.items\n      });\n    } else {\n      this.viewContainer.createEmbeddedView.call(this.viewContainer, this.defaultTemplate, {\n        items: this.items\n      });\n    }\n  }\n\n}\n\n'angular-2-navbar/navbar.module.ts'\n:import { NgModule, ModuleWithProviders, Injector, OpaqueToken } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { RouterModule } from '@angular/router';\nimport { NavbarComponent } from './navbar.component';\nimport { NavbarService, NavbarItems } from './navbar.service';\n\nconst NAVBAR_ITEMS = new OpaqueToken('NAVBAR_ITEMS');\n\nfunction navbarServiceFactory(itemsCollection: NavbarItems[], injector: Injector) {\n  let allItems = itemsCollection.reduce((aggregate, items) => aggregate.concat(items), []);\n  return new NavbarService(allItems, injector);\n}\n\nexport function provideItems(items: NavbarItems): any {\n  return [\n    {provide: NAVBAR_ITEMS, multi: true, useValue: items}\n  ];\n}\n\n@NgModule({\n  imports: [\n    CommonModule,\n    RouterModule\n  ],\n  exports: [\n    NavbarComponent\n  ],\n  declarations: [NavbarComponent]\n})\nexport class NavbarModule {\n\n  static forChild(items: NavbarItems): ModuleWithProviders {\n    const providers = provideItems(items);\n    return {ngModule: NavbarModule, providers: [providers]};\n  }\n\n  static forRoot(items: NavbarItems = []): ModuleWithProviders {\n\n    let providers = [{\n      provide: NavbarService,\n      useFactory: navbarServiceFactory,\n      deps: [NAVBAR_ITEMS, Injector]\n    }];\n\n    if (items.length) {\n      providers.push(provideItems(items));\n    }\n\n    return {\n      ngModule: NavbarModule,\n      providers: providers\n    };\n  }\n\n  constructor(private navbarService: NavbarService) {}\n\n}\n\n\n",
        "called_code_segment_file_1": "getNavbarItems() {\n    const canDisplay = (item) => {\n      if (!item.canDisplay || !item.canDisplay.length) {\n        return true;\n      }\n      return item.canDisplay.filter((guard) => this.injector.get(guard).canActivate(item)).length;\n    };\n    return this.items\n      .filter((item) => canDisplay(item))\n      .sort((a: NavbarItem, b: NavbarItem) => {\n        if (a.weight === b.weight) {\n          return 0;\n        }\n        if (a.weight < b.weight) {\n          return -1;\n        }\n        return 1;\n      });\n  }",
        "invoking_code_segment_file_2": "ngOnInit() {\n    this.items = this.navbarService.getNavbarItems();\n  }",
        "invoking_code_segment_file_3": "constructor(private navbarService: NavbarService) {}",
        "new_file_code_segment": "export class NavbarItemGuard {\n  canActivate(item: NavbarItem): boolean {\n    // Implement custom logic to determine if the item should be displayed\n    return true;\n  }\n}",
        "feature_description": "Add a new guard to control the display of navbar items based on custom logic.",
        "detailed_feature_description": "The new feature introduces a guard mechanism to control the display of navbar items. This guard will be implemented in a new file (#file 4) and will be invoked within the existing `getNavbarItems` method in #file 1. The guard will determine if a specific navbar item should be displayed based on custom logic. This logic can be extended or modified as needed. The `NavbarService` in #file 1 will be updated to use this guard, and the `NavbarComponent` in #file 2 will be updated to handle any changes resulting from this new feature.",
        "modified_complete_code": {
            "#file 1": "export class NavbarService {\n\n  constructor(private items: NavbarItems, private injector: Injector) {\n    this.items = this.items.map((item) => {\n      if (item.weight === undefined) {\n        item.weight = 0;\n      }\n      return item;\n    });\n  }\n\n  getNavbarItems() {\n    const canDisplay = (item) => {\n      if (!item.canDisplay || !item.canDisplay.length) {\n        return true;\n      }\n      return item.canDisplay.filter((guard) => this.injector.get(guard).canActivate(item)).length;\n    };\n    return this.items\n      .filter((item) => canDisplay(item))\n      .sort((a: NavbarItem, b: NavbarItem) => {\n        if (a.weight === b.weight) {\n          return 0;\n        }\n        if (a.weight < b.weight) {\n          return -1;\n        }\n        return 1;\n      });\n  }\n}",
            "#file 2": "export class NavbarComponent implements OnInit, DoCheck {\n\n  private items: NavbarItems;\n\n  @ContentChild(TemplateRef) customTemplate: TemplateRef<Object>;\n  @ViewChild(TemplateRef) defaultTemplate: TemplateRef<Object>;\n\n  constructor(private viewContainer: ViewContainerRef,\n              private navbarService: NavbarService) { }\n\n  ngOnInit() {\n    this.items = this.navbarService.getNavbarItems();\n  }\n\n  ngDoCheck() {\n\n    if (!this.defaultTemplate && !this.customTemplate) {\n      return;\n    }\n\n    this.viewContainer.clear();\n\n    if (this.customTemplate) {\n      this.viewContainer.createEmbeddedView.call(this.viewContainer, this.customTemplate, {\n        items: this.items\n      });\n    } else {\n      this.viewContainer.createEmbeddedView.call(this.viewContainer, this.defaultTemplate, {\n        items: this.items\n      });\n    }\n  }\n}",
            "#file 3": "export class NavbarModule {\n\n  static forChild(items: NavbarItems): ModuleWithProviders {\n    const providers = provideItems(items);\n    return {ngModule: NavbarModule, providers: [providers]};\n  }\n\n  static forRoot(items: NavbarItems = []): ModuleWithProviders {\n\n    let providers = [{\n      provide: NavbarService,\n      useFactory: navbarServiceFactory,\n      deps: [NAVBAR_ITEMS, Injector]\n    }];\n\n    if (items.length) {\n      providers.push(provideItems(items));\n    }\n\n    return {\n      ngModule: NavbarModule,\n      providers: providers\n    };\n  }\n\n  constructor(private navbarService: NavbarService) {}\n}",
            "#file 4": "export class NavbarItemGuard {\n  canActivate(item: NavbarItem): boolean {\n    // Implement custom logic to determine if the item should be displayed\n    return true;\n  }\n}"
        }
    },
    {
        "repo": "angular-springboot-demo",
        "content": "'angular-springboot-demo/frontend/src/app/person/person.ts'\n:export class Person {\n    id: number = 0;\n    name: string = \"\";\n}\n\n'angular-springboot-demo/frontend/src/app/person/edit/person-edit.component.ts'\n:import {Component} from '@angular/core';\nimport {ActivatedRoute, Router} from '@angular/router';\nimport {MatSnackBar} from '@angular/material/snack-bar';\nimport {PersonService} from '../person.service';\nimport {Person} from '../person';\n\n@Component({\n    selector: 'app-person-edit',\n    templateUrl: './person-edit.component.html',\n    styleUrls: ['./person-edit.component.css']\n})\nexport class PersonEditComponent {\n\n    person: Person = new Person();\n\n    constructor(private route: ActivatedRoute, private personService: PersonService, private snackBar: MatSnackBar, private router: Router) {\n    }\n\n    ngOnInit(): void {\n        this.getPerson();\n    }\n\n    getPerson(): void {\n        const idParam = this.route.snapshot.paramMap.get('id');\n        if (idParam === \"new\") {\n            this.person = new Person();\n        } else {\n            const id = parseInt(idParam as string, 10);\n            this.personService.findById(id).subscribe(person => this.person = person);\n        }\n    }\n\n    save(): void {\n        this.personService.save(this.person).subscribe(() => {\n            let snackBar = this.snackBar.open(\"Person saved\", \"OK\",);\n            snackBar.onAction().subscribe(value => this.router.navigateByUrl(\"/persons\"));\n        });\n    }\n}\n\n'angular-springboot-demo/frontend/src/app/person/edit/person-edit.component.spec.ts'\n:import {ComponentFixture, TestBed} from '@angular/core/testing';\n\nimport {PersonEditComponent} from './person-edit.component';\nimport {HttpClientModule} from '@angular/common/http';\nimport {ActivatedRoute, RouterModule} from '@angular/router';\nimport {MatSnackBarModule} from '@angular/material/snack-bar';\nimport {AppRoutingModule} from '../../app-routing.module';\nimport {FormsModule} from '@angular/forms';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatInputModule} from '@angular/material/input';\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\n\ndescribe('PersonEditComponent', () => {\n    let component: PersonEditComponent;\n    let fixture: ComponentFixture<PersonEditComponent>;\n\n    beforeEach(async () => {\n        await TestBed.configureTestingModule({\n            declarations: [PersonEditComponent],\n            imports: [\n                HttpClientModule,\n                AppRoutingModule,\n                MatSnackBarModule,\n                FormsModule,\n                MatFormFieldModule,\n                MatInputModule,\n                BrowserAnimationsModule\n            ]\n        })\n            .compileComponents();\n\n        fixture = TestBed.createComponent(PersonEditComponent);\n        component = fixture.componentInstance;\n        fixture.detectChanges();\n    });\n\n    it('should create', () => {\n        expect(component).toBeTruthy();\n    });\n});\n\n",
        "called_code_segment_file_1": "save(): void {\n        this.personService.save(this.person).subscribe(() => {\n            let snackBar = this.snackBar.open(\"Person saved\", \"OK\",);\n            snackBar.onAction().subscribe(value => this.router.navigateByUrl(\"/persons\"));\n        });\n    }",
        "invoking_code_segment_file_2": "getPerson(): void {\n        const idParam = this.route.snapshot.paramMap.get('id');\n        if (idParam === \"new\") {\n            this.person = new Person();\n        } else {\n            const id = parseInt(idParam as string, 10);\n            this.personService.findById(id).subscribe(person => this.person = person);\n        }\n    }",
        "invoking_code_segment_file_3": "ngOnInit(): void {\n        this.getPerson();\n    }",
        "new_file_code_segment": "export class PersonValidationService {\n    validatePerson(person: Person): boolean {\n        return person.name.trim() !== \"\";\n    }\n}",
        "feature_description": "Add validation for person name before saving.",
        "detailed_feature_description": "The new feature introduces a validation service to ensure that the person's name is not empty before saving. This validation service is invoked in the PersonEditComponent before calling the save method. If the validation fails, an error message is shown using MatSnackBar.",
        "modified_complete_code": {
            "file_1": "export class Person {\n    id: number = 0;\n    name: string = \"\";\n}",
            "file_2": "import {Component} from '@angular/core';\nimport {ActivatedRoute, Router} from '@angular/router';\nimport {MatSnackBar} from '@angular/material/snack-bar';\nimport {PersonService} from '../person.service';\nimport {Person} from '../person';\nimport {PersonValidationService} from './person-validation.service'; //New\n\n@Component({\n    selector: 'app-person-edit',\n    templateUrl: './person-edit.component.html',\n    styleUrls: ['./person-edit.component.css']\n})\nexport class PersonEditComponent {\n\n    person: Person = new Person();\n\n    constructor(private route: ActivatedRoute, private personService: PersonService, private snackBar: MatSnackBar, private router: Router, private validationService: PersonValidationService) { //Modify\n    }\n\n    ngOnInit(): void {\n        this.getPerson();\n    }\n\n    getPerson(): void {\n        const idParam = this.route.snapshot.paramMap.get('id');\n        if (idParam === \"new\") {\n            this.person = new Person();\n        } else {\n            const id = parseInt(idParam as string, 10);\n            this.personService.findById(id).subscribe(person => this.person = person);\n        }\n    }\n\n    save(): void {\n        if (this.validationService.validatePerson(this.person)) { //New\n            this.personService.save(this.person).subscribe(() => {\n                let snackBar = this.snackBar.open(\"Person saved\", \"OK\",);\n                snackBar.onAction().subscribe(value => this.router.navigateByUrl(\"/persons\"));\n            });\n        } else {\n            this.snackBar.open(\"Name cannot be empty\", \"OK\"); //New\n        }\n    }\n}",
            "file_3": "import {Component} from '@angular/core';\nimport {ActivatedRoute, Router} from '@angular/router';\nimport {MatSnackBar} from '@angular/material/snack-bar';\nimport {PersonService} from '../person.service';\nimport {Person} from '../person';\n\n@Component({\n    selector: 'app-person-edit',\n    templateUrl: './person-edit.component.html',\n    styleUrls: ['./person-edit.component.css']\n})\nexport class PersonEditComponent {\n\n    person: Person = new Person();\n\n    constructor(private route: ActivatedRoute, private personService: PersonService, private snackBar: MatSnackBar, private router: Router) {\n    }\n\n    ngOnInit(): void {\n        this.getPerson();\n    }\n\n    getPerson(): void {\n        const idParam = this.route.snapshot.paramMap.get('id');\n        if (idParam === \"new\") {\n            this.person = new Person();\n        } else {\n            const id = parseInt(idParam as string, 10);\n            this.personService.findById(id).subscribe(person => this.person = person);\n        }\n    }\n\n    save(): void {\n        this.personService.save(this.person).subscribe(() => {\n            let snackBar = this.snackBar.open(\"Person saved\", \"OK\",);\n            snackBar.onAction().subscribe(value => this.router.navigateByUrl(\"/persons\"));\n        });\n    }\n}",
            "file_4": "export class PersonValidationService {\n    validatePerson(person: Person): boolean {\n        return person.name.trim() !== \"\";\n    }\n}"
        }
    },
    {
        "repo": "angular2-2nd-project",
        "content": "'angular2-2nd-project/dev/bindings/input.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\n\n\n @Component({\n   selector: 'my-input',\n   template: `\n        <h1>Your details, please </h1>\n        <div>\n            <label>Your Name</label>\n            <input type=\"text\" id=\"name\" [(ngModel)]=\"myself.name\" (keyup)=\"onKeyup()\">\n        </div>\n        <div>\n            <label>Your Age</label>\n            <input type=\"text\" id=\"age\" [(ngModel)]=\"myself.age\" (keyup)=\"onKeyup()\">\n        </div>\n        <br>\n        <div>Filled out: {{isFilled ? 'Yes' : 'No'}}</div>\n        <div>Valid: {{isValid ? 'Yes' : 'No'}}</div>\n        <br>\n        <button [disabled]=\"!isValid\" (click)=\"onSubmit()\">Submit</button>\n\n   `,\n   inputs: ['myself'],\n   outputs: ['submitted']\n\n })\n\n export class InputComponent {\n    myself = {name: '', age: ''};\n    isFilled = false;\n    isValid = false;\n    submitted = new EventEmitter<{name: string, age: string}>();\n\n    onKeyup() {\n        if (this.myself.name != '' && this.myself.age != '') {\n          this.isFilled = true;\n        } else {\n          this.isFilled = false;\n        }\n        if (this.myself.name != '' && /^\\d+$/.test(this.myself.age)) {\n          this.isValid = true;\n        } else {\n          this.isValid = false;\n        }\n    }\n\n    onSubmit() {\n        this.submitted.emit(this.myself);\n    }\n }\n\n'angular2-2nd-project/dev/app.component.ts'\n:import {Component} from 'angular2/core';\nimport {InputComponent} from './bindings/input.component';\nimport {ConfirmComponent} from './bindings/confirm.component';\n\n@Component({\n    selector: 'my-app',\n    template: `\n          <div class=\"container\">\n            <my-input (submitted)=\"onSubmit($event)\" [myself]=\"confirmedMyself\"></my-input>\n          </div>\n          <div class=\"container\">\n            <my-confirm (confirmed)=\"onConfirm($event)\" [myself]=\"myself\"></my-confirm>\n          </div>\n    `,\n    directives: [InputComponent, ConfirmComponent]\n})\nexport class AppComponent {\n    myself = {name: '', age: ''};\n    confirmedMyself = {name: '', age: ''};\n\n    onSubmit(myself: {name: string, age: string}) {\n        console.log(myself);\n        // this.myself = myself;\n        this.myself = {name: myself.name, age: myself.age};\n    }\n\n    onConfirm(myself: {name: string, age: string}) {\n        this.confirmedMyself = myself;\n    }\n}\n\n'angular2-2nd-project/dev/boot.ts'\n:///<reference path=\"../node_modules/angular2/typings/browser.d.ts\"/>\nimport {bootstrap} from 'angular2/platform/browser';\nimport {AppComponent} from \"./app.component\";\n\nbootstrap(AppComponent);\n",
        "called_code_segment_file_1": "@Component({\n   selector: 'my-input',\n   template: `\n        <h1>Your details, please </h1>\n        <div>\n            <label>Your Name</label>\n            <input type=\"text\" id=\"name\" [(ngModel)]=\"myself.name\" (keyup)=\"onKeyup()\">\n        </div>\n        <div>\n            <label>Your Age</label>\n            <input type=\"text\" id=\"age\" [(ngModel)]=\"myself.age\" (keyup)=\"onKeyup()\">\n        </div>\n        <br>\n        <div>Filled out: {{isFilled ? 'Yes' : 'No'}}</div>\n        <div>Valid: {{isValid ? 'Yes' : 'No'}}</div>\n        <br>\n        <button [disabled]=\"!isValid\" (click)=\"onSubmit()\">Submit</button>\n   `,\n   inputs: ['myself'],\n   outputs: ['submitted']\n\n})\nexport class InputComponent {\n   myself = {name: '', age: ''};\n   isFilled = false;\n   isValid = false;\n   submitted = new EventEmitter<{name: string, age: string}>();\n\n   onKeyup() {\n       if (this.myself.name != '' && this.myself.age != '') {\n         this.isFilled = true;\n       } else {\n         this.isFilled = false;\n       }\n       if (this.myself.name != '' && /^d+$/.test(this.myself.age)) {\n         this.isValid = true;\n       } else {\n         this.isValid = false;\n       }\n   }\n\n   onSubmit() {\n       this.submitted.emit(this.myself);\n   }\n}",
        "invoking_code_segment_file_2": "@Component({\n    selector: 'my-app',\n    template: `\n          <div class=\"container\">\n            <my-input (submitted)=\"onSubmit($event)\" [myself]=\"confirmedMyself\"></my-input>\n          </div>\n          <div class=\"container\">\n            <my-confirm (confirmed)=\"onConfirm($event)\" [myself]=\"myself\"></my-confirm>\n          </div>\n    `,\n    directives: [InputComponent, ConfirmComponent]\n})\nexport class AppComponent {\n    myself = {name: '', age: ''};\n    confirmedMyself = {name: '', age: ''};\n\n    onSubmit(myself: {name: string, age: string}) {\n        console.log(myself);\n        this.myself = {name: myself.name, age: myself.age};\n    }\n\n    onConfirm(myself: {name: string, age: string}) {\n        this.confirmedMyself = myself;\n    }\n}",
        "invoking_code_segment_file_3": "@Component({\n   selector: 'my-confirm',\n   template: `\n        <h1>Are you sure?</h1>\n        <p>Your name is <span class=\"highlight\">{{myself.name}}</span> and your age is <span class=\"highlight\">{{myself.age}}</span>.</p>\n        <br>\n        <button (click)=\"onConfirm()\">Yes, correct</button>\n   `,\n   inputs: ['myself'],\n   outputs: ['confirmed']\n\n})\nexport class ConfirmComponent {\n   myself = {name: '', age: ''};\n   confirmed = new EventEmitter<{name: string, age: string}>();\n\n   onConfirm() {\n       this.confirmed.emit(this.myself);\n   }\n}",
        "new_file_code_segment": "export class ValidationService {\n    static validateAge(age: string): boolean {\n        return /^d+$/.test(age);\n    }\n}",
        "feature_description": "Add a validation service to centralize age validation logic.",
        "detailed_feature_description": "The new feature introduces a ValidationService in a new file (#file 4) to centralize the age validation logic. This service is then used in the InputComponent to validate the age input. The AppComponent and ConfirmComponent remain unchanged as they do not directly interact with the validation logic.",
        "modified_complete_code": {
            "file_1": "@Component({\n   selector: 'my-input',\n   template: `\n        <h1>Your details, please </h1>\n        <div>\n            <label>Your Name</label>\n            <input type=\"text\" id=\"name\" [(ngModel)]=\"myself.name\" (keyup)=\"onKeyup()\">\n        </div>\n        <div>\n            <label>Your Age</label>\n            <input type=\"text\" id=\"age\" [(ngModel)]=\"myself.age\" (keyup)=\"onKeyup()\">\n        </div>\n        <br>\n        <div>Filled out: {{isFilled ? 'Yes' : 'No'}}</div>\n        <div>Valid: {{isValid ? 'Yes' : 'No'}}</div>\n        <br>\n        <button [disabled]=\"!isValid\" (click)=\"onSubmit()\">Submit</button>\n   `,\n   inputs: ['myself'],\n   outputs: ['submitted']\n\n})\nexport class InputComponent {\n   myself = {name: '', age: ''};\n   isFilled = false;\n   isValid = false;\n   submitted = new EventEmitter<{name: string, age: string}>();\n\n   onKeyup() {\n       if (this.myself.name != '' && this.myself.age != '') {\n         this.isFilled = true;\n       } else {\n         this.isFilled = false;\n       }\n       #Modify if (ValidationService.validateAge(this.myself.age)) {\n         this.isValid = true;\n       } else {\n         this.isValid = false;\n       }\n   }\n\n   onSubmit() {\n       this.submitted.emit(this.myself);\n   }\n}",
            "file_2": "@Component({\n    selector: 'my-app',\n    template: `\n          <div class=\"container\">\n            <my-input (submitted)=\"onSubmit($event)\" [myself]=\"confirmedMyself\"></my-input>\n          </div>\n          <div class=\"container\">\n            <my-confirm (confirmed)=\"onConfirm($event)\" [myself]=\"myself\"></my-confirm>\n          </div>\n    `,\n    directives: [InputComponent, ConfirmComponent]\n})\nexport class AppComponent {\n    myself = {name: '', age: ''};\n    confirmedMyself = {name: '', age: ''};\n\n    onSubmit(myself: {name: string, age: string}) {\n        console.log(myself);\n        this.myself = {name: myself.name, age: myself.age};\n    }\n\n    onConfirm(myself: {name: string, age: string}) {\n        this.confirmedMyself = myself;\n    }\n}",
            "file_3": "@Component({\n   selector: 'my-confirm',\n   template: `\n        <h1>Are you sure?</h1>\n        <p>Your name is <span class=\"highlight\">{{myself.name}}</span> and your age is <span class=\"highlight\">{{myself.age}}</span>.</p>\n        <br>\n        <button (click)=\"onConfirm()\">Yes, correct</button>\n   `,\n   inputs: ['myself'],\n   outputs: ['confirmed']\n\n})\nexport class ConfirmComponent {\n   myself = {name: '', age: ''};\n   confirmed = new EventEmitter<{name: string, age: string}>();\n\n   onConfirm() {\n       this.confirmed.emit(this.myself);\n   }\n}",
            "file_4": "export class ValidationService {\n    static validateAge(age: string): boolean {\n        return /^d+$/.test(age);\n    }\n}"
        }
    },
    {
        "repo": "dawg",
        "content": "'dawg/src/util.ts'\n:// Return a sorted list of [key, value] pairs, sorted by values\n// (default 'asc').\ntype Dir = 'asc' | 'desc';\n\nexport function sortByValues<V>(o: {[p: string]: V},\n                         dir: Dir = 'asc')\n: [string, V][] {\n  let result: [string, V][] = [];\n\n  for (let key in o) {\n    result.push( [key, o[key]] );\n  }\n\n  result.sort(function (a: [string, V], b: [string, V]) {\n    return cmpDefault(a[1], b[1], dir);\n  });\n\n  return result;\n}\n\nfunction cmpDefault(a: any, b: any, dir: Dir = 'asc') {\n  let result = 0;\n\n  if (a < b) {\n    result = -1;\n  } else if (a > b) {\n    result = 1;\n  }\n\n  return dir === 'asc' ? result : -result;\n}\n\n// Sort elements and remove duplicates from array (modified in place).\nexport function unique<T>(a: T[], cmp = cmpDefault) {\n  a.sort(cmp);\n  for (let i = 1; i < a.length; i++) {\n    if (cmp(a[i - 1], a[i])  === 0) {\n      a.splice(i, 1);\n    }\n  }\n}\n\n'dawg/src/trie.ts'\n:/*\n  A JavaScript implementation of a Trie search datastructure.\n\n  Usage:\n\n  trie = new Trie(dictionary-string);\n  bool = trie.isWord(word);\n\n  To use a packed (compressed) version of the trie stored as a string:\n\n  compressed = trie.pack();\n  ptrie = new PackedTrie(compressed);\n  bool = ptrie.isWord(word)\n\n*/\nimport * as ptrie from './ptrie';\nimport { BASE, toAlphaCode } from './alphacode';\nimport { Histogram } from './histogram';\nimport { unique } from './util';\nimport { Node } from './node';\n\nconst DEBUG = false;\n\n// Create a Trie data structure for searching for membership of strings\n// in a dictionary in a very space efficient way.\nexport class Trie {\n  root = new Node();\n  lastWord = '';\n  suffixes: {[s: string]: Node} = {};\n  cNext = 1;\n  wordCount = 0;\n  vCur = 0;\n\n  constructor(words?: string | string[]) {\n    this.insertWords(words);\n  }\n\n  // Insert words from one big string, or from an array.\n  insertWords(words?: string | string[]) {\n    let i;\n\n    if (words === undefined) {\n      return;\n    }\n    if (typeof words === 'string') {\n      words = words.split(/[^a-zA-Z]+/);\n    }\n    for (i = 0; i < words.length; i++) {\n      words[i] = words[i].toLowerCase();\n    }\n    unique(words);\n    for (i = 0; i < words.length; i++) {\n      this.insert(words[i]);\n    }\n  }\n\n  insert(word: string) {\n    this._insert(word, this.root);\n    let lastWord = this.lastWord;\n    this.lastWord = word;\n\n    let prefix = commonPrefix(word, lastWord);\n    if (prefix === lastWord) {\n      return;\n    }\n\n    let freeze = this.uniqueNode(lastWord, word, this.root);\n    if (freeze) {\n      this.combineSuffixNode(freeze);\n    }\n  }\n\n  _insert(word: string, node: Node) {\n    let i: number;\n    let prefix: string;\n    let next: Node;\n    let prop: string;\n\n    // Duplicate word entry - ignore\n    if (word.length === 0) {\n      return;\n    }\n\n    // Do any existing props share a common prefix?\n    for (prop in node) {\n      if (!node.hasOwnProperty(prop)) {\n        continue;\n      }\n      prefix = commonPrefix(word, prop);\n      if (prefix.length === 0) {\n        continue;\n      }\n      // Prop is a proper prefix - recurse to child node\n      if (prop === prefix && Node.isNode(node.child(prop))) {\n        this._insert(word.slice(prefix.length), node.child(prop) as Node);\n        return;\n      }\n      // Duplicate terminal string - ignore\n      if (prop === word && node.isTerminalString(prop)) {\n        return;\n      }\n      next = new Node();\n      next.setChild(prop.slice(prefix.length), node.child(prop));\n      this.addTerminal(next, word = word.slice(prefix.length));\n\n      node.deleteChild(prop);\n      node.setChild(prefix, next);\n      this.wordCount++;\n      return;\n    }\n\n    // No shared prefix.  Enter the word here as a terminal string.\n    this.addTerminal(node, word);\n    this.wordCount++;\n  }\n\n  // Add a terminal string to node.\n  // If 2 characters or less, just add with value === 1.\n  // If more than 2 characters, point to shared node\n  // Note - don't prematurely share suffixes - these\n  // terminals may become split and joined with other\n  // nodes in this part of the tree.\n  addTerminal(node: Node, prop: string) {\n    if (prop.length <= 1) {\n      node.setChild(prop, 1);\n      return;\n    }\n    let next = new Node();\n    node.setChild(prop[0], next);\n    this.addTerminal(next, prop.slice(1));\n  }\n\n  optimize() {\n    let scores = [];\n\n    this.combineSuffixNode(this.root);\n    this.prepDFS();\n    this.countDegree(this.root);\n    this.prepDFS();\n    this.collapseChains(this.root);\n  }\n\n  // Convert Trie to a DAWG by sharing identical nodes\n  combineSuffixNode(node: Node) {\n    // Frozen node - can't change.\n    if (node._c) {\n      return node;\n    }\n    // Make sure all children are combined and generate unique node\n    // signature for this node.\n    let sig = [];\n    if (node.isTerminal()) {\n      sig.push('!');\n    }\n    let props = node.props();\n    for (let i = 0; i < props.length; i++) {\n      let prop = props[i];\n      if (Node.isNode(node.child(prop))) {\n        node.setChild(prop, this.combineSuffixNode(node.child(prop) as Node));\n        sig.push(prop);\n        sig.push((node.child(prop) as Node)._c);\n      } else {\n        sig.push(prop);\n      }\n    }\n\n    let sigString = sig.join('-');\n\n    let shared = this.suffixes[sigString];\n    if (shared) {\n      return shared;\n    }\n    this.suffixes[sigString] = node;\n    node._c = this.cNext++;\n    return node;\n  }\n\n  prepDFS() {\n    this.vCur++;\n  }\n\n  visited(node: Node) {\n    if (node._v === this.vCur) {\n      return true;\n    }\n    node._v = this.vCur;\n  }\n\n  countDegree(node: Node) {\n    if (node._d === undefined) {\n      node._d = 0;\n    }\n    node._d++;\n    if (this.visited(node)) {\n      return;\n    }\n    let props = node.props(true);\n    for (let i = 0; i < props.length; i++) {\n      this.countDegree(node.child(props[i]) as Node);\n    }\n  }\n\n  // Remove intermediate singleton nodes by hoisting into their parent\n  collapseChains(node: Node) {\n    let prop: string = '-invalid-';\n    let props: string[];\n    let i: number;\n\n    if (this.visited(node)) {\n      return;\n    }\n    props = node.props();\n    for (i = 0; i < props.length; i++) {\n      prop = props[i];\n      let child = node.child(prop) as Node;\n      if (!Node.isNode(child)) {\n        continue;\n      }\n      this.collapseChains(child);\n      // Hoist the singleton child's single property to the parent\n      if (child._g !== undefined && (child._d === 1 || child._g.length === 1)) {\n        node.deleteChild(prop);\n        prop += child._g;\n        node.setChild(prop, child.child(child._g));\n      }\n    }\n    // Identify singleton nodes\n    if (props.length === 1 && !node.isTerminal()) {\n      node._g = prop;\n    }\n  }\n\n  isWord(word: string): boolean {\n    return this.isFragment(word, this.root);\n  }\n\n  isFragment(word: string, node: Node): boolean {\n    if (word.length === 0) {\n      return node.isTerminal();\n    }\n\n    if (node.child(word) === 1) {\n      return true;\n    }\n\n    // Find a prefix of word reference to a child\n    let props = node.props(true);\n    for (let i = 0; i < props.length; i++) {\n      let prop = props[i];\n      if (prop === word.slice(0, prop.length)) {\n        return this.isFragment(word.slice(prop.length),\n                               node.child(prop) as Node);\n      }\n    }\n\n    return false;\n  }\n\n  // Find highest node in Trie that is on the path to word\n  // and that is NOT on the path to other.\n  uniqueNode(word: string, other: string, node: Node): Node | undefined {\n    let props = node.props(true);\n    for (let i = 0; i < props.length; i++) {\n      let prop = props[i];\n      if (prop === word.slice(0, prop.length)) {\n        if (prop !== other.slice(0, prop.length)) {\n          return node.child(prop) as Node;\n        }\n        return this.uniqueNode(word.slice(prop.length),\n                               other.slice(prop.length),\n                               node.child(prop) as Node);\n      }\n    }\n    return undefined;\n  }\n\n  // Return packed representation of Trie as a string.\n  //\n  // Each node of the Trie is output on a single line.\n  //\n  // For example Trie(\"the them there thesis this\"):\n  // {\n  //    \"th\": {\n  //      \"is\": 1,\n  //      \"e\": {\n  //        \"\": 1,\n  //        \"m\": 1,\n  //        \"re\": 1,\n  //        \"sis\": 1\n  //      }\n  //    }\n  //  }\n  //\n  // Would be reperesented as:\n  //\n  // th0\n  // e0is\n  // !m,re,sis\n  //\n  // The line begins with a '!' iff it is a terminal node of the Trie.\n  // For each string property in a node, the string is listed, along\n  // with a (relative!) line number of the node that string references.\n  // Terminal strings (those without child node references) are\n  // separated by ',' characters.\n  pack(): string {\n    let self = this;\n    let nodes: Node[] = [];\n    let nodeCount: number;\n    let syms: {[i: string]: string} = {};\n    let pos = 0;\n\n    // Make sure we've combined all the common suffixes\n    this.optimize();\n\n    function nodeLine(node: Node): string {\n      let line = '';\n      let sep = '';\n\n      if (node.isTerminal()) {\n        line += ptrie.TERMINAL_PREFIX;\n      }\n\n      let props = node.props();\n      for (let i = 0; i < props.length; i++) {\n        let prop = props[i];\n        if (node.isTerminalString(prop)) {\n          line += sep + prop;\n          sep = ptrie.STRING_SEP;\n          continue;\n        }\n        let child = node.child(prop) as Node;\n        if (syms[child._n]) {\n          line += sep + prop + syms[child._n];\n          sep = '';\n          continue;\n        }\n        let ref = toAlphaCode(node._n - child._n - 1 + symCount);\n        // Large reference to smaller string suffix -> duplicate suffix\n        if (child._g && ref.length >= child._g.length &&\n            node.isTerminalString(child._g)) {\n          ref = child._g;\n          line += sep + prop + ref;\n          sep = ptrie.STRING_SEP;\n          continue;\n        }\n        line += sep + prop + ref;\n        sep = '';\n      }\n\n      return line;\n    }\n\n    // Topological sort into nodes array\n    function numberNodes(node: Node) {\n      if (node._n !== undefined) {\n        return;\n      }\n      let props = node.props(true);\n      for (let i = 0; i < props.length; i++) {\n        numberNodes(node.child(props[i]) as Node);\n      }\n      node._n = pos++;\n      nodes.unshift(node);\n    }\n\n    let histAbs = new Histogram();\n    let histRel = new Histogram();\n\n    function analyzeRefs(node: Node) {\n      if (self.visited(node)) {\n        return;\n      }\n      let props = node.props(true);\n      for (let i = 0; i < props.length; i++) {\n        let prop = props[i];\n        let child = node.child(prop) as Node;\n        let ref = node._n - child._n - 1;\n        // Count the number of single-character relative refs\n        if (ref < BASE) {\n          histRel.add(ref);\n        }\n        // Count the number of characters saved by converting an absolute\n        // reference to a one-character symbol.\n        histAbs.add(child._n, toAlphaCode(ref).length - 1);\n        analyzeRefs(child);\n      }\n    }\n\n    function symbolCount(): [number, [string, number][]] {\n      let topNodes = histAbs.highest(BASE);\n      let savings = [];\n      savings[-1] = 0;\n      let best = 0;\n      let count = 0;\n      let defSize = 3 + toAlphaCode(nodeCount).length;\n      for (let sym = 0; sym < BASE; sym++) {\n        if (topNodes[sym] === undefined) {\n          break;\n        }\n        // Cumulative savings of:\n        //   saved characters in refs\n        //   minus definition size\n        //   minus relative size wrapping to 2 digits\n        savings[sym] = topNodes[sym][1] - defSize -\n          histRel.countOf(BASE - sym - 1) +\n          savings[sym - 1];\n\n        log(\"savings[\" + sym + \"] \" + savings[sym] + ' = ' +\n            savings[sym - 1] + ' +' +\n            topNodes[sym][1] + ' - ' + defSize + ' - ' +\n            histRel.countOf(BASE - sym - 1) + ')');\n\n        if (savings[sym] >= best) {\n          best = savings[sym];\n          count = sym + 1;\n        }\n      }\n      return [count, topNodes];\n    }\n\n    numberNodes(this.root);\n    nodeCount = nodes.length;\n\n    this.prepDFS();\n    analyzeRefs(this.root);\n\n    let [symCount, topNodes] = symbolCount();\n    let symDefs = [];\n\n    for (let sym = 0; sym < symCount; sym++) {\n      syms[topNodes[sym][0]] = toAlphaCode(sym);\n    }\n\n    let nodeLines: string[] = [];\n\n    for (let i = 0; i < nodeCount; i++) {\n      nodeLines[i] = nodeLine(nodes[i]);\n    }\n\n    // Prepend symbols\n    for (let sym = symCount - 1; sym >= 0; sym--) {\n      nodeLines.unshift(toAlphaCode(sym) + ':' +\n                        toAlphaCode(nodeCount -\n                                    parseInt(topNodes[sym][0], 10) - 1));\n    }\n\n    return nodeLines.join(ptrie.NODE_SEP);\n  }\n}\n\nfunction commonPrefix(w1: string, w2: string) {\n  let i: number;\n\n  let maxlen = Math.min(w1.length, w2.length);\n\n  for (i = 0; i < maxlen && w1[i] === w2[i]; i++) {/*_*/}\n\n  return w1.slice(0, i);\n}\n\nfunction log(message?: string, ...args: any[]) {\n  if (DEBUG) {\n    console.log(message, ...args);\n  }\n}\n\n'dawg/src/test/ptrie-test.ts'\n:import { assert } from 'chai';\nimport { dataDrivenTest } from './test-helper';\nimport {\n  testSamples, Expect, splitWords, readDictionary\n} from './trie-samples';\n\nimport { Trie } from '../trie';\nimport { PTrie } from '../ptrie';\n\nsuite(\"PTrie\", () => {\n  suite(\"Samples\", () => {\n    dataDrivenTest(testSamples, (data: string, expect: Expect) => {\n      let trie = new Trie(data);\n      let packed = trie.pack();\n\n      if (expect.nodeCount !== undefined) {\n        assert.equal(packed.split(';').length, expect.nodeCount, \"node count\");\n      }\n\n      let ptrie = new PTrie(packed);\n\n      splitWords(data).forEach((word) => {\n        if (word === '') {\n          return;\n        }\n        assert.ok(ptrie.isWord(word), word + ' should be in PTrie.');\n      });\n\n      if (expect.nonWords) {\n        expect.nonWords.forEach((word) => {\n          assert.ok(!ptrie.isWord(word), word + ' should not be in PTrie');\n        });\n      }\n    });\n  });\n\n  suite(\"Symbols\", () => {\n    let tests = [\n      [\"0:4;a1q0;!b1;!c1;!d1;!e1;!f\",\n       ['a', 'ab', 'abc', 'abcd', 'abcde', 'abcdef',\n        'q', 'qe', 'qef']]\n    ];\n\n    dataDrivenTest(tests, (data: string, expect: string[]) => {\n      let ptrie = new PTrie(data);\n      expect.forEach((word) => {\n        assert.ok(ptrie.isWord(word), word + \" is a word\");\n      });\n    });\n  });\n\n  test(\"match\", function() {\n    let trie = new Trie(\"cat cats dog dogs rat rats hi hit hither\");\n    let ptrie = new PTrie(trie.pack());\n\n    assert.equal(ptrie.match(\"catjzkd\"), 'cat');\n    assert.equal(ptrie.match(\"jzkdy\"), '');\n    assert.equal(ptrie.match(\"jcatzkd\"), '');\n    assert.equal(ptrie.match(\"hitherandyon\"), 'hither');\n  });\n\n  test(\"completions\", function () {\n    let trie = new Trie(\"cat cats dog dogs rat rats hi hit hither\");\n    let ptrie = new PTrie(trie.pack());\n\n    assert.deepEqual(ptrie.completions(''),\n                     ['cat', 'cats', 'dog', 'dogs', 'hi',\n                      'hit', 'hither', 'rat', 'rats']);\n    assert.deepEqual(ptrie.completions('', 2), ['cat', 'cats']);\n    assert.deepEqual(ptrie.completions('c'), ['cat', 'cats']);\n    assert.deepEqual(ptrie.completions('cat'), ['cat', 'cats']);\n    assert.deepEqual(ptrie.completions('hi'),\n                     ['hi', 'hit', 'hither']);\n  });\n\n  test(\"English dictionary\", function() {\n    this.timeout(100000);\n\n    return readDictionary()\n      .then((words) => {\n        let trie = new Trie(words);\n        let ptrie = new PTrie(trie.pack());\n\n        // Test 5% of words\n        for (let i = 0; i < words.length; i += 20) {\n          assert.ok(ptrie.isWord(words[i]));\n        }\n\n        assert.ok(!ptrie.isWord('xyzzy'));\n      });\n  });\n});\n\n",
        "called_code_segment_file_1": "export function sortByValues<V>(o: {[p: string]: V}, dir: Dir = 'asc'): [string, V][] { let result: [string, V][] = []; for (let key in o) { result.push( [key, o[key]] ); } result.sort(function (a: [string, V], b: [string, V]) { return cmpDefault(a[1], b[1], dir); }); return result; }",
        "invoking_code_segment_file_2": "import { sortByValues } from './util'; // ... let scores = sortByValues(histogram);",
        "invoking_code_segment_file_3": "import { sortByValues } from './util'; // ... let sortedList = sortByValues(data);",
        "new_file_code_segment": "export function filterByValues<V>(o: {[p: string]: V}, filterFn: (value: V) => boolean): [string, V][] { let result: [string, V][] = []; for (let key in o) { if (filterFn(o[key])) { result.push( [key, o[key]] ); } } return result; }",
        "feature_description": "Add a new feature to filter values based on a custom function.",
        "detailed_feature_description": "The new feature introduces a function `filterByValues` in #file 4 that filters the values of an object based on a provided function. This function is then integrated into #file 1 and invoked in #file 2 and #file 3 to handle additional filtering requirements.",
        "modified_complete_code": {
            "#file 1": "//Modify export function sortByValues<V>(o: {[p: string]: V}, dir: Dir = 'asc'): [string, V][] { let result: [string, V][] = []; for (let key in o) { result.push( [key, o[key]] ); } result.sort(function (a: [string, V], b: [string, V]) { return cmpDefault(a[1], b[1], dir); }); return result; } //New export function filterByValues<V>(o: {[p: string]: V}, filterFn: (value: V) => boolean): [string, V][] { let result: [string, V][] = []; for (let key in o) { if (filterFn(o[key])) { result.push( [key, o[key]] ); } } return result; }",
            "#file 2": "//Modify import { sortByValues, filterByValues } from './util'; // ... let scores = sortByValues(histogram); let filteredScores = filterByValues(histogram, (value) => value > 50);",
            "#file 3": "//Modify import { sortByValues, filterByValues } from './util'; // ... let sortedList = sortByValues(data); let filteredList = filterByValues(data, (value) => value.length > 3);",
            "#file 4": "//New export function filterByValues<V>(o: {[p: string]: V}, filterFn: (value: V) => boolean): [string, V][] { let result: [string, V][] = []; for (let key in o) { if (filterFn(o[key])) { result.push( [key, o[key]] ); } } return result; }"
        }
    },
    {
        "repo": "event-sourcing-demo-app",
        "content": "'event-sourcing-demo-app/backend/src/domain/port/events/ShipUndockedEvent.ts'\n:import { Event } from '@irontitan/paradox'\nimport { Port } from '../entity'\nimport { ObjectId } from 'mongodb'\n\ninterface IEventCreationParams {\n  shipId: ObjectId,\n  reason: string\n}\n\nexport class ShipUndockedEvent extends Event<IEventCreationParams> {\n  static readonly eventName = 'ship-was-undocked'\n  readonly user: string\n\n  constructor (data: IEventCreationParams, user: string) {\n    super(ShipUndockedEvent.eventName, data)\n    this.user = user\n  }\n\n  static commit (state: Port, event: ShipUndockedEvent): Port {\n    state.dockedShips = state.dockedShips.filter((shipId) => !event.data.shipId.equals(shipId))\n    state.updatedAt = event.timestamp\n    state.updatedBy = event.user\n    return state\n  }\n}\n\n'event-sourcing-demo-app/backend/src/domain/port/entity.ts'\n:import { ObjectId } from 'mongodb'\nimport { EventEntity } from '@irontitan/paradox'\nimport { PortWasCreatedEvent } from './events/PortWasCreatedEvent'\nimport { IPortCreationParams } from '../structures/IPortCreationParams'\nimport { Ship } from '../ship/entity'\nimport { ShipUndockedEvent } from './events/ShipUndockedEvent'\nimport { ShipDockedEvent } from './events/ShipDockedEvent'\nimport { PortWasDeletedEvent } from './events/PortWasDeletedEvent'\n\nexport class Port extends EventEntity<Port> {\n  public id: ObjectId | null = null\n  public name: string | null = null\n  public dockedShips: ObjectId[] = []\n  public createdAt: Date | null = null\n  public createdBy: string | null = null\n  public updatedAt: Date | null = null\n  public updatedBy: string | null = null\n  public deletedAt: Date | null = null\n  public deletedBy: string | null = null\n\n  static readonly collection = 'ports'\n\n  constructor () {\n    super({\n      [PortWasCreatedEvent.eventName]: PortWasCreatedEvent.commit,\n      [ShipUndockedEvent.eventName]: ShipUndockedEvent.commit,\n      [ShipDockedEvent.eventName]: ShipDockedEvent.commit,\n      [PortWasDeletedEvent.eventName]: PortWasDeletedEvent.commit\n    })\n  }\n\n  static create (params: IPortCreationParams, user: string): Port {\n    const port = new Port()\n\n    port.pushNewEvents([\n      new PortWasCreatedEvent({ id: new ObjectId(), ...params }, user)\n    ])\n\n    return port\n  }\n\n  undockShip (ship: Ship, reason: string, user: string): Port {\n    this.pushNewEvents([\n      new ShipUndockedEvent({ shipId: ship.id as ObjectId, reason }, user)\n    ])\n\n    return this\n  }\n\n  dockShip (ship: Ship, user: string): Port {\n    this.pushNewEvents([\n      new ShipDockedEvent({ shipId: ship.id as ObjectId }, user)\n    ])\n\n    return this\n  }\n\n  delete (user: string) {\n    this.pushNewEvents([\n      new PortWasDeletedEvent(user)\n    ])\n\n    return this\n  }\n\n  get state () {\n    const currentState = this.reducer.reduce(new Port(), [\n      ...this.persistedEvents,\n      ...this.pendingEvents\n    ])\n\n    return {\n      id: currentState.id,\n      name: currentState.name,\n      dockedShips: currentState.dockedShips,\n      createdAt: currentState.createdAt,\n      createdBy: currentState.createdBy,\n      updatedAt: currentState.updatedAt,\n      updatedBy: currentState.updatedBy,\n      deletedAt: currentState.deletedAt,\n      deletedBy: currentState.deletedBy\n    }\n  }\n}\n\n'event-sourcing-demo-app/backend/src/domain/port/events/PortWasCreatedEvent.ts'\n:import { Event } from '@irontitan/paradox'\nimport { ObjectId } from 'mongodb'\nimport { Port } from '../entity'\nimport { IPortCreationParams } from '../../structures/IPortCreationParams'\n\ninterface IEventCreationParams extends IPortCreationParams {\n  id: ObjectId\n}\n\nexport class PortWasCreatedEvent extends Event<IEventCreationParams> {\n  static readonly eventName = 'port-was-created'\n  readonly user: string\n\n  constructor (data: IEventCreationParams, user: string) {\n    super(PortWasCreatedEvent.eventName, data)\n    this.user = user\n  }\n\n  static commit (state: Port, event: PortWasCreatedEvent): Port {\n    state.id = event.data.id\n    state.name = event.data.name\n    state.dockedShips = event.data.dockedShips.map((shipId) => new ObjectId(shipId))\n    state.createdAt = event.timestamp\n    state.createdBy = event.user\n    state.updatedAt = event.timestamp\n    state.updatedBy = event.user\n    return state\n  }\n}\n\n",
        "called_code_segment_file_1": "static commit (state: Port, event: PortWasCreatedEvent): Port {\n    state.id = event.data.id\n    state.name = event.data.name\n    state.dockedShips = event.data.dockedShips.map((shipId) => new ObjectId(shipId))\n    state.createdAt = event.timestamp\n    state.createdBy = event.user\n    state.updatedAt = event.timestamp\n    state.updatedBy = event.user\n    return state\n  }",
        "invoking_code_segment_file_2": "constructor () {\n    super({\n      [PortWasCreatedEvent.eventName]: PortWasCreatedEvent.commit,\n      [ShipUndockedEvent.eventName]: ShipUndockedEvent.commit,\n      [ShipDockedEvent.eventName]: ShipDockedEvent.commit,\n      [PortWasDeletedEvent.eventName]: PortWasDeletedEvent.commit\n    })\n  }",
        "invoking_code_segment_file_3": "get state () {\n    const currentState = this.reducer.reduce(new Port(), [\n      ...this.persistedEvents,\n      ...this.pendingEvents\n    ])\n\n    return {\n      id: currentState.id,\n      name: currentState.name,\n      dockedShips: currentState.dockedShips,\n      createdAt: currentState.createdAt,\n      createdBy: currentState.createdBy,\n      updatedAt: currentState.updatedAt,\n      updatedBy: currentState.updatedBy,\n      deletedAt: currentState.deletedAt,\n      deletedBy: currentState.deletedBy\n    }\n  }",
        "new_file_code_segment": "export class PortWasRenamedEvent extends Event<{ newName: string }> {\n  static readonly eventName = 'port-was-renamed'\n  readonly user: string\n\n  constructor (data: { newName: string }, user: string) {\n    super(PortWasRenamedEvent.eventName, data)\n    this.user = user\n  }\n\n  static commit (state: Port, event: PortWasRenamedEvent): Port {\n    state.name = event.data.newName\n    state.updatedAt = event.timestamp\n    state.updatedBy = event.user\n    return state\n  }\n}",
        "feature_description": "Add a feature to rename a port.",
        "detailed_feature_description": "The new feature allows renaming a port. A new event `PortWasRenamedEvent` is created in a new file (#file 4). This event is then integrated into the `Port` entity in #file 1. The `Port` entity is updated to include a method `rename` that pushes the new event. The `Port` entity's constructor and state getter are updated to handle the new event. The `Port` entity's state getter is also updated to reflect the new name.",
        "modified_complete_code": {
            "file_1": "//Modify\nimport { PortWasRenamedEvent } from './events/PortWasRenamedEvent'\n\nstatic commit (state: Port, event: PortWasCreatedEvent): Port {\n    state.id = event.data.id\n    state.name = event.data.name\n    state.dockedShips = event.data.dockedShips.map((shipId) => new ObjectId(shipId))\n    state.createdAt = event.timestamp\n    state.createdBy = event.user\n    state.updatedAt = event.timestamp\n    state.updatedBy = event.user\n    return state\n  }\n\n//New\nrename (newName: string, user: string): Port {\n    this.pushNewEvents([new PortWasRenamedEvent({ newName }, user)])\n    return this\n  }",
            "file_2": "//Modify\nimport { PortWasRenamedEvent } from './events/PortWasRenamedEvent'\n\nconstructor () {\n    super({\n      [PortWasCreatedEvent.eventName]: PortWasCreatedEvent.commit,\n      [ShipUndockedEvent.eventName]: ShipUndockedEvent.commit,\n      [ShipDockedEvent.eventName]: ShipDockedEvent.commit,\n      [PortWasDeletedEvent.eventName]: PortWasDeletedEvent.commit,\n      [PortWasRenamedEvent.eventName]: PortWasRenamedEvent.commit\n    })\n  }",
            "file_3": "//Modify\nget state () {\n    const currentState = this.reducer.reduce(new Port(), [\n      ...this.persistedEvents,\n      ...this.pendingEvents\n    ])\n\n    return {\n      id: currentState.id,\n      name: currentState.name,\n      dockedShips: currentState.dockedShips,\n      createdAt: currentState.createdAt,\n      createdBy: currentState.createdBy,\n      updatedAt: currentState.updatedAt,\n      updatedBy: currentState.updatedBy,\n      deletedAt: currentState.deletedAt,\n      deletedBy: currentState.deletedBy\n    }\n  }",
            "file_4": "//New\nexport class PortWasRenamedEvent extends Event<{ newName: string }> {\n  static readonly eventName = 'port-was-renamed'\n  readonly user: string\n\n  constructor (data: { newName: string }, user: string) {\n    super(PortWasRenamedEvent.eventName, data)\n    this.user = user\n  }\n\n  static commit (state: Port, event: PortWasRenamedEvent): Port {\n    state.name = event.data.newName\n    state.updatedAt = event.timestamp\n    state.updatedBy = event.user\n    return state\n  }\n}"
        }
    },
    {
        "repo": "express-ts-sequelize-boilerplate",
        "content": "'express-ts-sequelize-boilerplate/src/middlewares/error/error.ts'\n:import { Request, Response } from 'express';\nimport HTTPException from '@exceptions/HTTPException';\nimport ErrorResponse from '@interfaces/responses/ErrorResponse';\n// import PageNotFoundException from '../exceptions/PageNotFound';\n\nconst errorHandler = (err: HTTPException, req: Request, res: Response, next: any): void => {\n  // const err404 = new PageNotFoundException(req.path);\n  const responseMsg = {\n    status: err.status,\n    message: err.message,\n  } as ErrorResponse;\n  res.status(err.status).json(responseMsg);\n};\n\nexport default errorHandler;\n\n'express-ts-sequelize-boilerplate/src/app.ts'\n:import { static as StaticPublisher } from 'express';\nimport path from 'path';\nimport bodyParser from 'body-parser';\nimport compression from 'compression';\nimport cors from 'cors';\nimport { Server } from '@overnightjs/core';\nimport { Logger } from '@overnightjs/logger';\nimport { UserController } from './controllers/UserController';\nimport consoleLogger from './middlewares/logger/consoleLogger';\nimport errorHandler from './middlewares/error/error';\nimport error404Handler from './middlewares/error/error404';\n\nexport class App extends Server {\n  constructor() {\n    super(process.env.NODE_ENV === 'development');\n\n    this.app.disable('x-powered-by');\n\n    this.app.use(bodyParser.json());\n    this.app.use(bodyParser.urlencoded({extended: true}));\n    this.app.use(compression());\n    this.app.use(cors());\n\n    this.setupStatics('/static');\n    this.setupMiddlewares();\n    this.setupControllers();\n    this.setupError();\n  }\n\n  private setupStatics(staticPath: string): void {\n    this.app.use(staticPath, StaticPublisher(path.join(__dirname, 'public')));\n  }\n\n  private setupMiddlewares(): void {\n    this.app.use(consoleLogger);\n  }\n\n  private setupControllers(): void {\n    const userController = new UserController({someConfig: 'example'});\n\n    super.addControllers([\n      userController,\n    ]);\n  }\n\n  private setupError(): void {\n    this.app.use(error404Handler);\n    this.app.use(errorHandler);\n  }\n\n  public start(port: number): void {\n    this.app.listen(port, () => {\n      Logger.Imp(`Server listening on port: ${port}`);\n    });\n  }\n}\n\n'express-ts-sequelize-boilerplate/src/server.ts'\n:import dotenv from 'dotenv';\n\ndotenv.config();\n\nconst portNum: number = Number(process.env.SERVER_PORT || '5000');\n\nimport { App } from './app';\n\nconst server = new App();\nserver.start(portNum);\n\n",
        "called_code_segment_file_1": "const errorHandler = (err: HTTPException, req: Request, res: Response, next: any): void => {\n  const responseMsg = {\n    status: err.status,\n    message: err.message,\n  } as ErrorResponse;\n  res.status(err.status).json(responseMsg);\n};",
        "invoking_code_segment_file_2": "this.app.use(errorHandler);",
        "invoking_code_segment_file_3": "this.app.use(error404Handler);\nthis.app.use(errorHandler);",
        "new_file_code_segment": "const logError = (err: HTTPException): void => {\n  console.error(`Error: ${err.status} - ${err.message}`);\n};\n\nexport default logError;",
        "feature_description": "Add error logging functionality.",
        "detailed_feature_description": "The new feature introduces error logging to the error handling middleware. A new file (#file 4) contains a function that logs error details to the console. This function is invoked within the existing errorHandler middleware in #file 1. The changes ensure that all errors handled by the application are logged for debugging and monitoring purposes.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport logError from './middlewares/error/logError';\n\nconst errorHandler = (err: HTTPException, req: Request, res: Response, next: any): void => {\n  logError(err); //New\n  const responseMsg = {\n    status: err.status,\n    message: err.message,\n  } as ErrorResponse;\n  res.status(err.status).json(responseMsg);\n};",
            "#file 2": "this.app.use(errorHandler);",
            "#file 3": "this.app.use(error404Handler);\nthis.app.use(errorHandler);",
            "#file 4": "const logError = (err: HTTPException): void => {\n  console.error(`Error: ${err.status} - ${err.message}`);\n};\n\nexport default logError;"
        }
    },
    {
        "repo": "gpu-curtains",
        "content": "'gpu-curtains/src/core/materials/ComputeMaterial.ts'\n:import { Material } from './Material'\nimport { ComputeMaterialOptions, ComputeMaterialParams, FullShadersType } from '../../types/Materials'\nimport { isRenderer, Renderer } from '../renderers/utils'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { ComputePipelineEntry } from '../pipelines/ComputePipelineEntry'\nimport { WritableBufferBinding } from '../bindings/WritableBufferBinding'\n\n/**\n * Create a {@link Material} specifically built to run computations on the GPU. Internally used by {@link core/computePasses/ComputePass.ComputePass | ComputePass}.\n *\n * ## Compute pipeline\n *\n * A {@link ComputeMaterial} automatically creates a {@link ComputePipelineEntry}. Once all the {@link core/bindGroups/BindGroup.BindGroup | BindGroup} have been created, they are sent with the compute shader code to the {@link ComputePipelineEntry}, which is in turns responsible for creating the {@link GPUComputePipeline}.\n *\n * After the {@link GPUComputePipeline} has been successfully compiled, the {@link ComputeMaterial} is considered to be ready and it can start running the compute shader computations.\n *\n */\nexport class ComputeMaterial extends Material {\n  /** {@link ComputePipelineEntry | Compute pipeline entry} used by this {@link ComputeMaterial} */\n  pipelineEntry: ComputePipelineEntry\n  /** Options used to create this {@link ComputeMaterial} */\n  options: ComputeMaterialOptions\n\n  /** Default work group dispatch size to use with this {@link ComputeMaterial} */\n  dispatchSize?: number | number[]\n\n  /** function assigned to the {@link useCustomRender} callback */\n  _useCustomRenderCallback: (pass: GPUComputePassEncoder) => void\n\n  /**\n   * ComputeMaterial constructor\n   * @param renderer - our {@link Renderer} class object\n   * @param parameters - {@link ComputeMaterialParams | parameters} used to create our {@link ComputeMaterial}\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: ComputeMaterialParams) {\n    const type = 'ComputeMaterial'\n\n    renderer = isRenderer(renderer, type)\n\n    super(renderer, parameters)\n\n    this.type = type\n    this.renderer = renderer\n\n    let { shaders, dispatchSize } = parameters\n\n    if (!shaders || !shaders.compute) {\n      shaders = {\n        compute: {\n          code: '',\n          entryPoint: 'main',\n        },\n      }\n    }\n\n    if (!shaders.compute.code) {\n      shaders.compute.code = '@compute @workgroup_size(1) fn main(){}'\n    }\n\n    if (!shaders.compute.entryPoint) {\n      shaders.compute.entryPoint = 'main'\n    }\n\n    this.options = {\n      ...this.options,\n      shaders,\n      ...(parameters.dispatchSize !== undefined && { dispatchSize: parameters.dispatchSize }),\n    }\n\n    // set default dispatch size\n    if (!dispatchSize) {\n      dispatchSize = 1\n    }\n\n    if (Array.isArray(dispatchSize)) {\n      dispatchSize[0] = Math.ceil(dispatchSize[0] ?? 1)\n      dispatchSize[1] = Math.ceil(dispatchSize[1] ?? 1)\n      dispatchSize[2] = Math.ceil(dispatchSize[2] ?? 1)\n    } else if (!isNaN(dispatchSize)) {\n      dispatchSize = [Math.ceil(dispatchSize), 1, 1]\n    }\n\n    this.dispatchSize = dispatchSize\n\n    // eager pipeline entry creation for compute materials\n    // since we do not use cache!\n    this.pipelineEntry = this.renderer.pipelineManager.createComputePipeline({\n      renderer: this.renderer,\n      label: this.options.label + ' compute pipeline',\n      shaders: this.options.shaders,\n      useAsync: this.options.useAsyncPipeline,\n    })\n  }\n\n  /**\n   * When all bind groups are created, add them to the {@link ComputePipelineEntry}\n   */\n  setPipelineEntryProperties() {\n    this.pipelineEntry.setPipelineEntryProperties({\n      bindGroups: this.bindGroups,\n    })\n  }\n\n  /**\n   * Compile the {@link ComputePipelineEntry}\n   * @async\n   */\n  async compilePipelineEntry(): Promise<void> {\n    await this.pipelineEntry.compilePipelineEntry()\n  }\n\n  /**\n   * Check if all bind groups are ready, create them if needed, set {@link ComputePipelineEntry} bind group buffers and compile the pipeline\n   * @async\n   */\n  async compileMaterial(): Promise<void> {\n    if (this.ready) return\n\n    super.compileMaterial()\n\n    if (this.pipelineEntry && this.pipelineEntry.canCompile) {\n      this.setPipelineEntryProperties()\n      await this.compilePipelineEntry()\n    }\n  }\n\n  /**\n   * Get the complete code of a given shader including all the WGSL fragment code snippets added by the pipeline\n   * @param [shaderType=\"compute\"] - shader to get the code from\n   * @returns - The corresponding shader code\n   */\n  getShaderCode(shaderType: FullShadersType = 'compute'): string {\n    return super.getShaderCode(shaderType)\n  }\n\n  /**\n   * Get the added code of a given shader, i.e. all the WGSL fragment code snippets added by the pipeline\n   * @param [shaderType=\"compute\"] - shader to get the code from\n   * @returns - The corresponding shader code\n   */\n  getAddedShaderCode(shaderType: FullShadersType = 'compute'): string {\n    return super.getAddedShaderCode(shaderType)\n  }\n\n  /* RENDER */\n\n  /**\n   * If a custom render function has been defined instead of the default one, register the callback\n   * @param callback - callback to run instead of the default render behaviour, which is to set the {@link bindGroups | bind groups} and dispatch the work groups based on the {@link dispatchSize | default dispatch size}. This is where you will have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\n   */\n  useCustomRender(callback: (pass: GPUComputePassEncoder) => void) {\n    if (callback) {\n      this._useCustomRenderCallback = callback\n    }\n  }\n\n  /**\n   * Render the material if it is ready:\n   * Set the current pipeline, set the bind groups and dispatch the work groups\n   * @param pass - current compute pass encoder\n   */\n  render(pass: GPUComputePassEncoder) {\n    // renderer or pipeline are not ready yet\n    // not really needed since compute passes do already check it beforehand\n    // mostly here as a safeguard\n    if (!this.ready) return\n\n    // set current pipeline\n    this.setPipeline(pass)\n\n    // if we declared a custom render function, call it\n    if (this._useCustomRenderCallback !== undefined) {\n      this._useCustomRenderCallback(pass)\n    } else {\n      // else just set our bind groups and dispatch\n      for (const bindGroup of this.bindGroups) {\n        pass.setBindGroup(bindGroup.index, bindGroup.bindGroup)\n      }\n      //this.renderer.pipelineManager.setActiveBindGroups(pass, this.bindGroups)\n\n      pass.dispatchWorkgroups(this.dispatchSize[0], this.dispatchSize[1], this.dispatchSize[2])\n    }\n  }\n\n  /* RESULT BUFFER */\n\n  /**\n   * Copy all writable binding buffers that need it\n   * @param commandEncoder - current command encoder\n   */\n  copyBufferToResult(commandEncoder: GPUCommandEncoder) {\n    for (const bindGroup of this.bindGroups) {\n      bindGroup.bufferBindings.forEach((binding: WritableBufferBinding) => {\n        if (binding.shouldCopyResult) {\n          this.renderer.copyBufferToBuffer({\n            srcBuffer: binding.buffer,\n            dstBuffer: binding.resultBuffer,\n            commandEncoder,\n          })\n        }\n      })\n    }\n  }\n\n  /**\n   * Get the {@link core/bindings/WritableBufferBinding.WritableBufferBinding#resultBuffer | result GPU buffer} content by {@link core/bindings/WritableBufferBinding.WritableBufferBinding | binding} and {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} names\n   * @param parameters - parameters used to get the result\n   * @param parameters.bindingName - {@link core/bindings/WritableBufferBinding.WritableBufferBinding#name | binding name} from which to get the result\n   * @param parameters.bufferElementName - optional {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} (i.e. struct member) name if the result needs to be restrained to only one element\n   * @async\n   * @returns - the mapped content of the {@link GPUBuffer} as a {@link Float32Array}\n   */\n  async getComputeResult({\n    bindingName = '',\n    bufferElementName = '',\n  }: {\n    bindingName?: string\n    bufferElementName?: string\n  }): Promise<Float32Array> {\n    const binding = this.getBufferBindingByName(bindingName)\n\n    if (binding && 'resultBuffer' in binding) {\n      const result = await this.getBufferResult(binding.resultBuffer)\n\n      if (bufferElementName && result.length) {\n        return binding.extractBufferElementDataFromBufferResult({ result, bufferElementName })\n      } else {\n        return result\n      }\n    } else {\n      return new Float32Array(0)\n    }\n  }\n}\n\n'gpu-curtains/src/core/computePasses/ComputePass.ts'\n:import { isRenderer, Renderer } from '../renderers/utils'\nimport { generateUUID } from '../../utils/utils'\nimport { ComputeMaterial } from '../materials/ComputeMaterial'\nimport { ComputeMaterialParams, MaterialParams, MaterialShaders } from '../../types/Materials'\nimport { GPUCurtains } from '../../curtains/GPUCurtains'\nimport { Texture, TextureParams } from '../textures/Texture'\nimport { DOMTexture } from '../textures/DOMTexture'\nimport { ExternalTextureParams, DOMTextureParams } from '../../types/Textures'\n\n/** Defines {@link ComputePass} options */\nexport interface ComputePassOptions {\n  /** The label of the {@link ComputePass} */\n  label: string\n  /** Controls the order in which this {@link ComputePass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder?: number\n  /** Whether the {@link ComputePass} should be added to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically */\n  autoRender?: boolean\n  /** Compute shader passed to the {@link ComputePass} following the {@link types/Materials.ShaderOptions | shader object} notation */\n  shaders: MaterialShaders\n  /** whether the {@link core/pipelines/ComputePipelineEntry.ComputePipelineEntry#pipeline | compute pipeline} should be compiled asynchronously */\n  useAsyncPipeline?: boolean\n  /** Parameters used by this {@link ComputePass} to create a {@link DOMTexture} */\n  texturesOptions?: ExternalTextureParams\n  /** Default {@link ComputeMaterial} work group dispatch size to use with this {@link ComputePass} */\n  dispatchSize?: number | number[]\n}\n\n/**\n * An object defining all possible {@link ComputePass} class instancing parameters\n */\nexport interface ComputePassParams extends Partial<ComputePassOptions>, MaterialParams {}\n\nlet computePassIndex = 0\n\n/**\n * Used to create a {@link ComputePass}, i.e. run computations on the GPU.<br>\n * A {@link ComputePass} is basically a wrapper around a {@link ComputeMaterial} that handles most of the process.\n *\n * The default render behaviour of a {@link ComputePass} is to set its {@link core/bindGroups/BindGroup.BindGroup | bind groups} and then dispatch the workgroups based on the provided {@link ComputeMaterial#dispatchSize | dispatchSize}.<br>\n * However, most of the time you'd want a slightly more complex behaviour. The {@link ComputePass#useCustomRender | `useCustomRender` hook} lets you define a totally custom behaviour, but you'll have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\n *\n * @example\n * ```javascript\n * // set our main GPUCurtains instance\n * const gpuCurtains = new GPUCurtains({\n *   container: '#canvas' // selector of our WebGPU canvas container\n * })\n *\n * // set the GPU device\n * // note this is asynchronous\n * await gpuCurtains.setDevice()\n *\n * // let's assume we are going to compute the positions of 100.000 particles\n * const nbParticles = 100_000\n *\n * const computePass = new ComputePass(gpuCurtains, {\n *   label: 'My compute pass',\n *   shaders: {\n *     compute: {\n *       code: computeShaderCode, // assume it is a valid WGSL compute shader\n *     },\n *   },\n *   dispatchSize: Math.ceil(nbParticles / 64),\n *   storages: {\n *     particles: {\n *       access: 'read_write',\n *       struct: {\n *         position: {\n *           type: 'array<vec4f>',\n *           value: new Float32Array(nbParticles * 4),\n *         },\n *       },\n *     },\n *   },\n * })\n * ```\n */\nexport class ComputePass {\n  /** The type of the {@link ComputePass} */\n  type: string\n  /** The universal unique id of the {@link ComputePass} */\n  uuid: string\n  /** The index of the {@link ComputePass}, incremented each time a new one is instanced */\n  index: number\n  /** The {@link Renderer} used */\n  renderer: Renderer\n  /** Controls the order in which this {@link ComputePass} should be rendered by our {@link core/scenes/Scene.Scene | Scene} */\n  renderOrder: number\n\n  /** Options used to create this {@link ComputePass} */\n  options: ComputePassOptions\n\n  /** {@link ComputeMaterial} used by this {@link ComputePass} */\n  material: ComputeMaterial\n\n  /** Flag indicating whether this {@link ComputePass} is ready to be rendered */\n  _ready: boolean\n\n  /** Empty object to store any additional data or custom properties into your {@link ComputePass} */\n  userData: Record<string, unknown>\n\n  /**\n   * Whether this {@link ComputePass} should be added to our {@link core/scenes/Scene.Scene | Scene} to let it handle the rendering process automatically\n   * @private\n   */\n  #autoRender = true\n\n  // callbacks / events\n  /** function assigned to the {@link onReady} callback */\n  _onReadyCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onBeforeRender} callback */\n  _onBeforeRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onRender} callback */\n  _onRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterRender} callback */\n  _onAfterRenderCallback: () => void = () => {\n    /* allow empty callback */\n  }\n  /** function assigned to the {@link onAfterResize} callback */\n  _onAfterResizeCallback: () => void = () => {\n    /* allow empty callback */\n  }\n\n  /**\n   * ComputePass constructor\n   * @param renderer - a {@link Renderer} class object or a {@link GPUCurtains} class object\n   * @param parameters - {@link ComputePassParams | parameters} used to create our {@link ComputePass}\n   */\n  constructor(renderer: Renderer | GPUCurtains, parameters: ComputePassParams = {}) {\n    const type = 'ComputePass'\n\n    renderer = isRenderer(renderer, parameters.label ? `${parameters.label} ${type}` : type)\n\n    parameters.label = parameters.label ?? 'ComputePass ' + renderer.computePasses?.length\n\n    this.renderer = renderer\n    this.type = type\n    this.uuid = generateUUID()\n    Object.defineProperty(this as ComputePass, 'index', { value: computePassIndex++ })\n\n    const {\n      label,\n      shaders,\n      renderOrder,\n      uniforms,\n      storages,\n      bindGroups,\n      samplers,\n      domTextures,\n      textures,\n      autoRender,\n      useAsyncPipeline,\n      texturesOptions,\n      dispatchSize,\n    } = parameters\n\n    this.options = {\n      label,\n      shaders,\n      ...(autoRender !== undefined && { autoRender }),\n      ...(renderOrder !== undefined && { renderOrder }),\n      ...(dispatchSize !== undefined && { dispatchSize }),\n      useAsyncPipeline: useAsyncPipeline === undefined ? true : useAsyncPipeline,\n      texturesOptions, // TODO default\n    }\n\n    this.renderOrder = renderOrder ?? 0\n\n    if (autoRender !== undefined) {\n      this.#autoRender = autoRender\n    }\n\n    this.userData = {}\n\n    this.ready = false\n\n    this.setMaterial({\n      label: this.options.label,\n      shaders: this.options.shaders,\n      uniforms,\n      storages,\n      bindGroups,\n      samplers,\n      textures,\n      domTextures,\n      useAsyncPipeline,\n      dispatchSize,\n    })\n\n    this.addToScene()\n  }\n\n  /**\n   * Get or set whether the compute pass is ready to render (the material has been successfully compiled)\n   * @readonly\n   */\n  get ready(): boolean {\n    return this._ready\n  }\n\n  set ready(value: boolean) {\n    if (value) {\n      this._onReadyCallback && this._onReadyCallback()\n    }\n    this._ready = value\n  }\n\n  /**\n   * Add our compute pass to the scene and the renderer\n   */\n  addToScene() {\n    this.renderer.computePasses.push(this)\n\n    if (this.#autoRender) {\n      this.renderer.scene.addComputePass(this)\n    }\n  }\n\n  /**\n   * Remove our compute pass from the scene and the renderer\n   */\n  removeFromScene() {\n    if (this.#autoRender) {\n      this.renderer.scene.removeComputePass(this)\n    }\n\n    this.renderer.computePasses = this.renderer.computePasses.filter((computePass) => computePass.uuid !== this.uuid)\n  }\n\n  /**\n   * Create the compute pass material\n   * @param computeParameters - {@link ComputeMaterial} parameters\n   */\n  setMaterial(computeParameters: ComputeMaterialParams) {\n    this.useMaterial(new ComputeMaterial(this.renderer, computeParameters))\n  }\n\n  /**\n   * Set or update the {@link ComputePass} {@link ComputeMaterial}\n   * @param material - new {@link ComputeMaterial} to use\n   */\n  useMaterial(material: ComputeMaterial) {\n    this.material = material\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been lost to prepare everything for restoration.\n   * Basically set all the {@link GPUBuffer} to null so they will be reset next time we try to render\n   */\n  loseContext() {\n    this.material.loseContext()\n  }\n\n  /**\n   * Called when the {@link core/renderers/GPUDeviceManager.GPUDeviceManager#device | device} has been restored\n   */\n  restoreContext() {\n    this.material.restoreContext()\n  }\n\n  /* TEXTURES */\n\n  /**\n   * Get our {@link ComputeMaterial#domTextures | ComputeMaterial domTextures array}\n   * @readonly\n   */\n  get domTextures(): DOMTexture[] {\n    return this.material?.domTextures || []\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#textures | ComputeMaterial textures array}\n   * @readonly\n   */\n  get textures(): Texture[] {\n    return this.material?.textures || []\n  }\n\n  /**\n   * Create a new {@link DOMTexture}\n   * @param options - {@link DOMTextureParams | DOMTexture parameters}\n   * @returns - newly created {@link DOMTexture}\n   */\n  createDOMTexture(options: DOMTextureParams): DOMTexture {\n    if (!options.name) {\n      options.name = 'texture' + (this.textures.length + this.domTextures.length)\n    }\n\n    if (!options.label) {\n      options.label = this.options.label + ' ' + options.name\n    }\n\n    const domTexture = new DOMTexture(this.renderer, { ...options, ...this.options.texturesOptions })\n\n    this.addTexture(domTexture)\n\n    return domTexture\n  }\n\n  /**\n   * Create a new {@link Texture}\n   * @param  options - {@link TextureParams | Texture parameters}\n   * @returns - newly created {@link Texture}\n   */\n  createTexture(options: TextureParams): Texture {\n    if (!options.name) {\n      options.name = 'texture' + (this.textures.length + this.domTextures.length)\n    }\n\n    const texture = new Texture(this.renderer, options)\n\n    this.addTexture(texture)\n\n    return texture\n  }\n\n  /**\n   * Add a {@link Texture} or {@link DOMTexture}\n   * @param texture - {@link Texture} to add\n   */\n  addTexture(texture: Texture | DOMTexture) {\n    this.material.addTexture(texture)\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#uniforms | ComputeMaterial uniforms}\n   * @readonly\n   */\n  get uniforms(): ComputeMaterial['uniforms'] {\n    return this.material?.uniforms\n  }\n\n  /**\n   * Get our {@link ComputeMaterial#storages | ComputeMaterial storages}\n   * @readonly\n   */\n  get storages(): ComputeMaterial['storages'] {\n    return this.material?.storages\n  }\n\n  /**\n   * Called from the renderer, useful to trigger an after resize callback.\n   */\n  resize() {\n    this._onAfterResizeCallback && this._onAfterResizeCallback()\n  }\n\n  /** EVENTS **/\n\n  /**\n   * Callback to run when the {@link ComputePass} is ready\n   * @param callback - callback to run when {@link ComputePass} is ready\n   */\n  onReady(callback: () => void): ComputePass {\n    if (callback) {\n      this._onReadyCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run before the {@link ComputePass} is rendered\n   * @param callback - callback to run just before {@link ComputePass} will be rendered\n   */\n  onBeforeRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onBeforeRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run when the {@link ComputePass} is rendered\n   * @param callback - callback to run when {@link ComputePass} is rendered\n   */\n  onRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback to run after the {@link ComputePass} has been rendered\n   * @param callback - callback to run just after {@link ComputePass} has been rendered\n   */\n  onAfterRender(callback: () => void): ComputePass {\n    if (callback) {\n      this._onAfterRenderCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Callback used to run a custom render function instead of the default one.\n   * @param callback - Your custom render function where you will have to set all the {@link core/bindGroups/BindGroup.BindGroup | bind groups} and dispatch the workgroups by yourself.\n   */\n  useCustomRender(callback: (pass: GPUComputePassEncoder) => void): ComputePass {\n    this.material.useCustomRender(callback)\n    return this\n  }\n\n  /**\n   * Callback to run after the {@link core/renderers/GPURenderer.GPURenderer | renderer} has been resized\n   * @param callback - callback to run just after {@link core/renderers/GPURenderer.GPURenderer | renderer} has been resized\n   */\n  onAfterResize(callback: () => void): ComputePass {\n    if (callback) {\n      this._onAfterResizeCallback = callback\n    }\n\n    return this\n  }\n\n  /**\n   * Called before rendering the ComputePass\n   * Checks if the material is ready and eventually update its struct\n   */\n  onBeforeRenderPass() {\n    if (!this.renderer.ready) return\n\n    if (this.material && this.material.ready && !this.ready) {\n      this.ready = true\n    }\n\n    this._onBeforeRenderCallback && this._onBeforeRenderCallback()\n\n    this.material.onBeforeRender()\n  }\n\n  /**\n   * Render our {@link ComputeMaterial}\n   * @param pass - current compute pass encoder\n   */\n  onRenderPass(pass: GPUComputePassEncoder) {\n    if (!this.material.ready) return\n\n    this._onRenderCallback && this._onRenderCallback()\n\n    this.material.render(pass)\n  }\n\n  /**\n   * Called after having rendered the ComputePass\n   */\n  onAfterRenderPass() {\n    this._onAfterRenderCallback && this._onAfterRenderCallback()\n  }\n\n  /**\n   * Render our compute pass\n   * Basically just check if our {@link core/renderers/GPURenderer.GPURenderer | renderer} is ready, and then render our {@link ComputeMaterial}\n   * @param pass\n   */\n  render(pass: GPUComputePassEncoder) {\n    this.onBeforeRenderPass()\n\n    // no point to render if the WebGPU device is not ready\n    if (!this.renderer.ready) return\n\n    !this.renderer.production && pass.pushDebugGroup(this.options.label)\n\n    this.onRenderPass(pass)\n\n    !this.renderer.production && pass.popDebugGroup()\n\n    this.onAfterRenderPass()\n  }\n\n  /**\n   * Copy the result of our read/write GPUBuffer into our result binding array\n   * @param commandEncoder - current GPU command encoder\n   */\n  copyBufferToResult(commandEncoder: GPUCommandEncoder) {\n    this.material?.copyBufferToResult(commandEncoder)\n  }\n\n  /**\n   * Get the {@link core/bindings/WritableBufferBinding.WritableBufferBinding#resultBuffer | result GPU buffer} content by {@link core/bindings/WritableBufferBinding.WritableBufferBinding | binding} and {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} names\n   * @param parameters - parameters used to get the result\n   * @param parameters.bindingName - {@link core/bindings/WritableBufferBinding.WritableBufferBinding#name | binding name} from which to get the result\n   * @param parameters.bufferElementName - optional {@link core/bindings/bufferElements/BufferElement.BufferElement | buffer element} (i.e. struct member) name if the result needs to be restrained to only one element\n   * @async\n   * @returns - the mapped content of the {@link GPUBuffer} as a {@link Float32Array}\n   */\n  async getComputeResult({\n    bindingName,\n    bufferElementName,\n  }: {\n    bindingName?: string\n    bufferElementName?: string\n  }): Promise<Float32Array> {\n    return await this.material?.getComputeResult({ bindingName, bufferElementName })\n  }\n\n  /**\n   * Remove the ComputePass from the scene and destroy it\n   */\n  remove() {\n    this.removeFromScene()\n    this.destroy()\n  }\n\n  /**\n   * Destroy the ComputePass\n   */\n  destroy() {\n    this.material?.destroy()\n  }\n}\n\n'gpu-curtains/src/extras/gltf/utils.ts'\n:import { MeshDescriptor } from '../../types/gltf/GLTFScenesManager'\nimport { ShaderOptions } from '../../types/Materials'\nimport { Texture } from '../../core/textures/Texture'\nimport { Sampler } from '../../core/samplers/Sampler'\nimport { ComputePass } from '../../core/computePasses/ComputePass'\nimport { Renderer } from '../../core/renderers/utils'\nimport { throwWarning } from '../../utils/utils'\nimport { getLambert, GetShadingParams } from '../../core/shaders/chunks/shading/lambert-shading'\nimport { getPhong } from '../../core/shaders/chunks/shading/phong-shading'\nimport { getPBR } from '../../core/shaders/chunks/shading/pbr-shading'\nimport { getIBL } from '../../core/shaders/chunks/shading/ibl-shading'\n\n/** Defines all kinds of shading models available. */\nexport type ShadingModels = 'Lambert' | 'Phong' | 'PBR' | 'IBL'\n\n/**\n * Parameters to use for IBL textures.\n */\nexport interface IBLShaderTextureParams {\n  /** {@link Texture} to use. */\n  texture: Texture\n  /** {@link Sampler#name | Sampler name} to use. */\n  samplerName?: Sampler['name']\n}\n\n/**\n * Parameters used to build the shaders\n */\nexport interface ShaderBuilderParameters {\n  /** Shading model to use. */\n  shadingModel?: ShadingModels\n  /** Additional WGSL chunks to add to the shaders. */\n  chunks?: {\n    /** Additional WGSL chunk to add to the fragment shader head. */\n    additionalFragmentHead?: string\n    /** Preliminary modification to apply to the fragment shader `color` `vec4f` variable before applying any lightning calculations. */\n    preliminaryColorContribution?: string\n    /** Additional modification to apply to the fragment shader `color` `vec4f` variable before returning it. */\n    additionalColorContribution?: string\n  }\n  /** Additional IBL parameters to pass as uniform and textures. */\n  iblParameters?: {\n    /** Environment diffuse strength. Default to `0.5`. */\n    diffuseStrength?: number\n    /** Environment specular strength. Default to `0.5`. */\n    specularStrength?: number\n    /** Look Up Table texture parameters to use for IBL. */\n    lutTexture?: IBLShaderTextureParams\n    /** Environment diffuse texture parameters to use for IBL. */\n    envDiffuseTexture?: IBLShaderTextureParams\n    /** Environment specular texture parameters to use for IBL. */\n    envSpecularTexture?: IBLShaderTextureParams\n  }\n}\n\n/** Shaders returned by the shaders builder function. */\nexport interface BuiltShaders {\n  /** Vertex shader returned by the PBR shader builder. */\n  vertex: ShaderOptions\n  /** Fragment shader returned by the PBR shader builder. */\n  fragment: ShaderOptions\n}\n\n/**\n * Build shaders made for glTF parsed objects, based on a {@link MeshDescriptor} and optional {@link ShaderBuilderParameters | shader parameters}.\n *\n * @param meshDescriptor - {@link MeshDescriptor} built by the {@link extras/gltf/GLTFScenesManager.GLTFScenesManager | GLTFScenesManager}\n * @param shaderParameters - {@link ShaderBuilderParameters | shader parameters} to use.\n * @returns - An object containing the shaders.\n */\nexport const buildShaders = (\n  meshDescriptor: MeshDescriptor,\n  shaderParameters = {} as ShaderBuilderParameters\n): BuiltShaders => {\n  // textures check\n  const baseColorTexture = meshDescriptor.textures.find((t) => t.texture === 'baseColorTexture')\n  const normalTexture = meshDescriptor.textures.find((t) => t.texture === 'normalTexture')\n  const emissiveTexture = meshDescriptor.textures.find((t) => t.texture === 'emissiveTexture')\n  const occlusionTexture = meshDescriptor.textures.find((t) => t.texture === 'occlusionTexture')\n  const metallicRoughnessTexture = meshDescriptor.textures.find((t) => t.texture === 'metallicRoughnessTexture')\n\n  const facultativeAttributes = meshDescriptor.attributes.filter((attribute) => attribute.name !== 'position')\n\n  const structAttributes = facultativeAttributes\n    .map((attribute, index) => {\n      return `@location(${index}) ${attribute.name}: ${attribute.type},`\n    })\n    .join('\\n\\t')\n\n  let outputPositions = /* wgsl */ `\n    let worldPos = matrices.model * vec4(attributes.position, 1.0);\n    vsOutput.position = camera.projection * camera.view * worldPos;\n    vsOutput.worldPosition = worldPos.xyz / worldPos.w;\n    vsOutput.viewDirection = camera.position - vsOutput.worldPosition.xyz;\n  `\n  let outputNormal = facultativeAttributes.find((attr) => attr.name === 'normal')\n    ? 'vsOutput.normal = getWorldNormal(attributes.normal);'\n    : ''\n\n  if (meshDescriptor.parameters.storages && meshDescriptor.parameters.storages.instances) {\n    outputPositions = /* wgsl */ `\n      let worldPos: vec4f = instances[attributes.instanceIndex].modelMatrix * vec4f(attributes.position, 1.0);\n      vsOutput.position = camera.projection * camera.view * worldPos;\n      vsOutput.worldPosition = worldPos.xyz;\n      vsOutput.viewDirection = camera.position - vsOutput.worldPosition;\n      `\n\n    outputNormal = `vsOutput.normal = normalize((instances[attributes.instanceIndex].normalMatrix * vec4(attributes.normal, 0.0)).xyz);`\n  }\n\n  const outputAttributes = facultativeAttributes\n    .filter((attr) => attr.name !== 'normal')\n    .map((attribute) => {\n      return `vsOutput.${attribute.name} = attributes.${attribute.name};`\n    })\n    .join('\\n\\t')\n\n  let vertexOutputContent = `\n      @builtin(position) position: vec4f,\n      @location(${facultativeAttributes.length}) viewDirection: vec3f,\n      @location(${facultativeAttributes.length + 1}) worldPosition: vec3f,\n      ${structAttributes}\n  `\n\n  let outputNormalMap = ''\n  const tangentAttribute = facultativeAttributes.find((attr) => attr.name === 'tangent')\n  const useNormalMap = !!(normalTexture && tangentAttribute)\n\n  if (useNormalMap) {\n    vertexOutputContent += `\n      @location(${facultativeAttributes.length + 2}) bitangent: vec3f,\n      `\n\n    outputNormalMap = `\n        vsOutput.tangent = normalize(matrices.model * attributes.tangent);\n        vsOutput.bitangent = cross(vsOutput.normal, vsOutput.tangent.xyz) * attributes.tangent.w;\n      `\n  }\n\n  const vertexOutput = /*wgsl */ `\n    struct VSOutput {\n      ${vertexOutputContent}\n    };`\n\n  const fragmentInput = /*wgsl */ `\n    struct VSOutput {\n      @builtin(front_facing) frontFacing: bool,\n      ${vertexOutputContent}\n    };`\n\n  const vs = /* wgsl */ `\n    ${vertexOutput}\n    \n    @vertex fn main(\n      attributes: Attributes,\n    ) -> VSOutput {\n      var vsOutput: VSOutput;\n    \n      ${outputPositions}\n      ${outputNormal}\n      ${outputAttributes}\n      \n      ${outputNormalMap}\n\n      return vsOutput;\n    }\n  `\n\n  // not a PBR material for now, as it does not use roughness/metalness\n  // we might want to implement it later\n  // see https://github.com/oframe/ogl/blob/master/examples/load-gltf.html#L133\n  const initColor = /* wgsl */ 'var color: vec4f = vec4();'\n  const returnColor = /* wgsl */ `\n      return color;\n  `\n\n  // start with the base color\n  // use vertex color 0 if defined\n  const vertexColor = meshDescriptor.attributes.find((attr) => attr.name === 'color0')\n  let baseColor = /* wgsl */ !!vertexColor\n    ? vertexColor.type === 'vec3f'\n      ? 'var baseColor: vec4f = vec4(fsInput.color0, 1.0) * material.baseColorFactor;'\n      : 'var baseColor: vec4f = fsInput.color0 * material.baseColorFactor;'\n    : 'var baseColor: vec4f = material.baseColorFactor;'\n\n  if (baseColorTexture) {\n    baseColor = /* wgsl */ `\n      var baseColor: vec4f = textureSample(baseColorTexture, ${baseColorTexture.sampler}, fsInput.${baseColorTexture.texCoordAttributeName}) * material.baseColorFactor;\n      \n      if (baseColor.a < material.alphaCutoff) {\n        discard;\n      }\n    `\n  }\n\n  baseColor += /* wgsl */ `\n      color = baseColor;\n  `\n\n  // normal map\n\n  let normalMap = meshDescriptor.attributes.find((attribute) => attribute.name === 'normal')\n    ? /* wgsl */ `\n      let faceDirection = select(-1.0, 1.0, fsInput.frontFacing);\n      let geometryNormal: vec3f = normalize(faceDirection * fsInput.normal);\n    `\n    : /* wgsl */ `let geometryNormal: vec3f = normalize(vec3(0.0, 0.0, 1.0));`\n\n  if (useNormalMap) {\n    normalMap += /* wgsl */ `\n      let tbn = mat3x3<f32>(normalize(fsInput.tangent.xyz), normalize(fsInput.bitangent), geometryNormal);\n      let normalMap = textureSample(normalTexture, ${normalTexture.sampler}, fsInput.${normalTexture.texCoordAttributeName}).rgb;\n      let normal = normalize(tbn * (2.0 * normalMap - vec3(material.normalMapScale, material.normalMapScale, 1.0)));\n    `\n  } else {\n    normalMap += /* wgsl */ `\n      let normal = geometryNormal;\n    `\n  }\n\n  // metallic roughness\n  let metallicRoughness = /*  wgsl */ `\n      var metallic = material.metallicFactor;\n      var roughness = material.roughnessFactor;\n  `\n\n  if (metallicRoughnessTexture) {\n    metallicRoughness += /* wgsl */ `\n      let metallicRoughness = textureSample(metallicRoughnessTexture, ${metallicRoughnessTexture.sampler}, fsInput.${metallicRoughnessTexture.texCoordAttributeName});\n      \n      metallic = clamp(metallic * metallicRoughness.b, 0.0, 1.0);\n      roughness = clamp(roughness * metallicRoughness.g, 0.0, 1.0);\n    `\n  }\n\n  const f0 = /* wgsl */ `\n      let f0: vec3f = mix(vec3(0.04), color.rgb, vec3(metallic));\n  `\n\n  // emissive and occlusion\n  let emissiveOcclusion = /* wgsl */ `\n      var emissive: vec3f = vec3(0.0);\n      var occlusion: f32 = 1.0;\n  `\n\n  if (emissiveTexture) {\n    emissiveOcclusion += /* wgsl */ `\n      emissive = textureSample(emissiveTexture, ${emissiveTexture.sampler}, fsInput.${emissiveTexture.texCoordAttributeName}).rgb;\n      \n      emissive *= material.emissiveFactor;\n      `\n    if (occlusionTexture) {\n      emissiveOcclusion += /* wgsl */ `\n      occlusion = textureSample(occlusionTexture, ${occlusionTexture.sampler}, fsInput.${occlusionTexture.texCoordAttributeName}).r;\n      `\n    }\n  }\n\n  emissiveOcclusion += /* wgsl */ `\n      occlusion = 1.0 + material.occlusionStrength * (occlusion - 1.0);\n  `\n\n  // Shader parameters\n  let { shadingModel } = shaderParameters\n  if (!shadingModel) {\n    shadingModel = 'PBR'\n  }\n\n  let { chunks } = shaderParameters || {}\n  const { iblParameters } = shaderParameters || {}\n  const { lutTexture, envDiffuseTexture, envSpecularTexture } = iblParameters || {}\n\n  const useIBLContribution =\n    envDiffuseTexture &&\n    envDiffuseTexture.texture &&\n    envSpecularTexture &&\n    envSpecularTexture.texture &&\n    lutTexture &&\n    lutTexture.texture\n\n  if (useIBLContribution && shadingModel === 'IBL') {\n    // add lights & ibl uniforms\n    meshDescriptor.parameters.uniforms = {\n      ...meshDescriptor.parameters.uniforms,\n      ...{\n        ibl: {\n          struct: {\n            diffuseStrength: {\n              type: 'f32',\n              value: iblParameters?.diffuseStrength ?? 0.5,\n            },\n            specularStrength: {\n              type: 'f32',\n              value: iblParameters?.specularStrength ?? 0.5,\n            },\n          },\n        },\n      },\n    }\n\n    meshDescriptor.parameters.textures = [\n      ...meshDescriptor.parameters.textures,\n      lutTexture.texture,\n      envDiffuseTexture.texture,\n      envSpecularTexture.texture,\n    ]\n\n    lutTexture.samplerName = lutTexture.samplerName || 'defaultSampler'\n    envDiffuseTexture.samplerName = envDiffuseTexture.samplerName || 'defaultSampler'\n    envSpecularTexture.samplerName = envSpecularTexture.samplerName || 'defaultSampler'\n  } else if (shadingModel === 'IBL') {\n    throwWarning(\n      'IBL shading requested but one of the LUT, environment specular or diffuse texture is missing. Defaulting to PBR shading.'\n    )\n    shadingModel = 'PBR'\n  }\n\n  const shadingOptions: GetShadingParams = {\n    toneMapping: 'khronos',\n    receiveShadows: !!meshDescriptor.parameters.receiveShadows,\n    useOcclusion: true,\n  }\n\n  // user defined chunks\n  const defaultAdditionalHead = (() => {\n    switch (shadingModel) {\n      case 'Lambert':\n      default:\n        return getLambert(shadingOptions)\n      case 'Phong':\n        return getPhong(shadingOptions)\n      case 'PBR':\n        return getPBR(shadingOptions)\n      case 'IBL':\n        return getIBL(shadingOptions)\n    }\n  })()\n\n  const defaultPreliminaryColor = ''\n  const defaultAdditionalColor = ''\n\n  if (!chunks) {\n    chunks = {\n      additionalFragmentHead: defaultAdditionalHead,\n      preliminaryColorContribution: defaultPreliminaryColor,\n      additionalColorContribution: defaultAdditionalColor,\n    }\n  } else {\n    if (!chunks.additionalFragmentHead) {\n      chunks.additionalFragmentHead = defaultAdditionalHead\n    } else {\n      chunks.additionalFragmentHead = defaultAdditionalHead + chunks.additionalFragmentHead\n    }\n\n    if (!chunks.preliminaryColorContribution) {\n      chunks.preliminaryColorContribution = defaultPreliminaryColor\n    } else {\n      chunks.preliminaryColorContribution = defaultPreliminaryColor + chunks.preliminaryColorContribution\n    }\n\n    if (!chunks.additionalColorContribution) {\n      chunks.additionalColorContribution = defaultAdditionalColor\n    } else {\n      chunks.additionalColorContribution = defaultAdditionalColor + chunks.additionalColorContribution\n    }\n  }\n\n  // TODO shininess, specularStrength, specularColor\n  const applyLightShading: string = (() => {\n    switch (shadingModel) {\n      case 'Lambert':\n      default:\n        return /* wgsl */ `\n      color = vec4(\n        getLambert(\n          normal,\n          worldPosition,\n          color.rgb,\n          occlusion\n        ),\n        color.a\n      );`\n      case 'Phong':\n        return /* wgsl */ `\n      color = vec4(\n        getPhong(\n          normal,\n          worldPosition,\n          color.rgb,\n          viewDirection,\n          f0, // specular color\n          metallic * (1.0 - roughness) + (1.0 - metallic) * 0.04, // specular strength\n          (1.0 - roughness) * 30.0, // TODO shininess\n          occlusion\n        ),\n        color.a\n      );`\n      case 'PBR':\n        return /* wgsl */ `\n      color = vec4(\n        getPBR(\n          normal,\n          worldPosition,\n          color.rgb,\n          viewDirection,\n          f0,\n          metallic,\n          roughness,\n          occlusion\n        ),\n        color.a\n      );`\n      case 'IBL':\n        return /* wgsl */ `\n      color = vec4(\n        getIBL(\n          normal,\n          worldPosition,\n          color.rgb,\n          viewDirection,\n          f0,\n          metallic,\n          roughness,\n          ${lutTexture.texture.options.name},\n          ${lutTexture.samplerName},\n          ${envSpecularTexture.texture.options.name},\n          ${envSpecularTexture.samplerName},\n          ${envDiffuseTexture.texture.options.name},\n          ${envDiffuseTexture.samplerName},\n          occlusion\n        ),\n        color.a\n      );`\n    }\n  })()\n\n  const applyEmissive = /* wgsl */ `\n    color = vec4(color.rgb + emissive, color.a);\n  `\n\n  const fs = /* wgsl */ `  \n    ${chunks.additionalFragmentHead}\n  \n    ${fragmentInput}\n  \n    @fragment fn main(fsInput: VSOutput) -> @location(0) vec4f {       \n      ${initColor}\n      ${baseColor}\n      \n      let worldPosition: vec3f = fsInput.worldPosition;\n      let viewDirection: vec3f = fsInput.viewDirection;\n\n      ${normalMap}\n      ${metallicRoughness}  \n      \n      // user defined preliminary color contribution\n      ${chunks.preliminaryColorContribution}\n        \n      ${f0}\n      ${emissiveOcclusion}\n      \n      ${applyLightShading}\n      ${applyEmissive}\n      \n      // user defined additional color contribution\n      ${chunks.additionalColorContribution}\n      \n      ${returnColor}\n    }\n  `\n\n  return {\n    vertex: {\n      code: vs,\n      entryPoint: 'main',\n    },\n    fragment: {\n      code: fs,\n      entryPoint: 'main',\n    },\n  }\n}\n\n/**\n * Compute a diffuse cube map from a specular cube map using a {@link ComputePass} and copy the result into the diffuse texture {@link GPUTexture}.\n * @param renderer - {@link Renderer} to use.\n * @param diffuseTexture - diffuse cube map texture onto which the result of the {@link ComputePass} should be copied.\n * @param specularTexture - specular cube map texture to use as a source.\n */\nexport const computeDiffuseFromSpecular = async (\n  renderer: Renderer,\n  diffuseTexture: Texture,\n  specularTexture: Texture\n) => {\n  if (specularTexture.options.viewDimension !== 'cube') {\n    throwWarning(\n      'Could not compute the diffuse texture because the specular texture is not a cube map:' +\n        specularTexture.options.viewDimension\n    )\n    return\n  }\n\n  // ported from https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/9940e4b4f4a2a296351bcd35035cc518deadc298/source/shaders/ibl_filtering.frag\n  const computeDiffuseShader = `    \n    fn radicalInverse_VdC(inputBits: u32) -> f32 {\n        var bits: u32 = inputBits;\n        bits = (bits << 16u) | (bits >> 16u);\n        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n        return f32(bits) * 2.3283064365386963e-10; // / 0x100000000\n    }\n    \n    // hammersley2d describes a sequence of points in the 2d unit square [0,1)^2\n    // that can be used for quasi Monte Carlo integration\n    fn hammersley2d(i: u32, N: u32) -> vec2f {\n        return vec2(f32(i) / f32(N), radicalInverse_VdC(i));\n    }\n    \n    // TBN generates a tangent bitangent normal coordinate frame from the normal\n    // (the normal must be normalized)\n    fn generateTBN(normal: vec3f) -> mat3x3f {\n      var bitangent: vec3f = vec3(0.0, 1.0, 0.0);\n  \n      let NdotUp: f32 = dot(normal, vec3(0.0, 1.0, 0.0));\n      let epsilon: f32 = 0.0000001;\n      \n      if (1.0 - abs(NdotUp) <= epsilon) {\n        // Sampling +Y or -Y, so we need a more robust bitangent.\n        if (NdotUp > 0.0) {\n          bitangent = vec3(0.0, 0.0, 1.0);\n        }\n        else {\n          bitangent = vec3(0.0, 0.0, -1.0);\n        }\n      }\n  \n      let tangent: vec3f = normalize(cross(bitangent, normal));\n      bitangent = cross(normal, tangent);\n  \n      return mat3x3f(tangent, bitangent, normal);\n    }\n    \n    // Mipmap Filtered Samples (GPU Gems 3, 20.4)\n    // https://developer.nvidia.com/gpugems/gpugems3/part-iii-rendering/chapter-20-gpu-based-importance-sampling\n    // https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\n    fn computeLod(pdf: f32) -> f32 {\n      // https://cgg.mff.cuni.cz/~jaroslav/papers/2007-sketch-fis/Final_sap_0073.pdf\n      return 0.5 * log2( 6.0 * f32(params.faceSize) * f32(params.faceSize) / (f32(params.sampleCount) * pdf));\n    }\n    \n    fn transformDirection(face: u32, uv: vec2f) -> vec3f {\n      // Transform the direction based on the cubemap face\n      switch (face) {\n        case 0u {\n          // +X\n          return vec3f( 1.0,  uv.y, -uv.x);\n        }\n        case 1u {\n          // -X\n          return vec3f(-1.0,  uv.y,  uv.x);\n        }\n        case 2u {\n          // +Y\n          return vec3f( uv.x,  -1.0, uv.y);\n        }\n        case 3u {\n          // -Y\n          return vec3f( uv.x, 1.0,  -uv.y);\n        }\n        case 4u {\n          // +Z\n          return vec3f( uv.x,  uv.y,  1.0);\n        }\n        case 5u {\n          // -Z\n          return vec3f(-uv.x,  uv.y, -1.0);\n        }\n        default {\n          return vec3f(0.0, 0.0, 0.0);\n        }\n      }\n    }\n    \n    const PI = ${Math.PI};\n\n    @compute @workgroup_size(8, 8, 1) fn main(\n      @builtin(global_invocation_id) GlobalInvocationID: vec3u,\n    ) {\n      let faceSize: u32 = params.faceSize;\n      let sampleCount: u32 = params.sampleCount;\n      \n      let face: u32 = GlobalInvocationID.z;\n      let x: u32 = GlobalInvocationID.x;\n      let y: u32 = GlobalInvocationID.y;\n  \n      if (x >= faceSize || y >= faceSize) {\n          return;\n      }\n  \n      let texelSize: f32 = 1.0 / f32(faceSize);\n      let halfTexel: f32 = texelSize * 0.5;\n      \n      var uv: vec2f = vec2(\n        (f32(x) + halfTexel) * texelSize,\n        (f32(y) + halfTexel) * texelSize\n      );\n      \n      uv = uv * 2.0 - 1.0;\n  \n      let normal: vec3<f32> = transformDirection(face, uv);\n      \n      var irradiance: vec3f = vec3f(0.0, 0.0, 0.0);\n  \n      for (var i: u32 = 0; i < sampleCount; i++) {\n        // generate a quasi monte carlo point in the unit square [0.1)^2\n        let xi: vec2f = hammersley2d(i, sampleCount);\n        \n        let cosTheta: f32 = sqrt(1.0 - xi.y);\n        let sinTheta: f32 = sqrt(1.0 - cosTheta * cosTheta);\n        let phi: f32 = 2.0 * PI * xi.x;\n        let pdf: f32 = cosTheta / PI; // evaluation for solid angle, therefore drop the sinTheta\n\n        let sampleVec: vec3f = vec3f(\n            sinTheta * cos(phi),\n            sinTheta * sin(phi),\n            cosTheta\n        );\n        \n        let TBN: mat3x3f = generateTBN(normalize(normal));\n        \n        var direction: vec3f = TBN * sampleVec;\n        \n        // invert along Y axis\n        direction.y *= -1.0;\n        \n        let lod: f32 = computeLod(pdf);\n\n        // Convert sampleVec to texture coordinates of the specular env map\n        irradiance += textureSampleLevel(\n          envSpecularTexture,\n          specularSampler,\n          direction,\n          min(lod, f32(params.maxMipLevel))\n        ).rgb;\n      }\n  \n      irradiance /= f32(sampleCount);\n\n      textureStore(diffuseEnvMap, vec2(x, y), face, vec4f(irradiance, 1.0));\n    }\n  `\n\n  let diffuseStorageTexture = new Texture(renderer, {\n    label: 'Diffuse storage cubemap',\n    name: 'diffuseEnvMap',\n    format: 'rgba32float',\n    visibility: ['compute'],\n    usage: ['copySrc', 'storageBinding'],\n    type: 'storage',\n    fixedSize: {\n      width: specularTexture.size.width,\n      height: specularTexture.size.height,\n      depth: 6,\n    },\n    viewDimension: '2d-array',\n  })\n\n  const sampler = new Sampler(renderer, {\n    label: 'Compute diffuse sampler',\n    name: 'specularSampler',\n    addressModeU: 'clamp-to-edge',\n    addressModeV: 'clamp-to-edge',\n    minFilter: 'linear',\n    magFilter: 'linear',\n  })\n\n  let computeDiffusePass = new ComputePass(renderer, {\n    autoRender: false, // we're going to render only on demand\n    dispatchSize: [Math.ceil(specularTexture.size.width / 8), Math.ceil(specularTexture.size.height / 8), 6],\n    shaders: {\n      compute: {\n        code: computeDiffuseShader,\n      },\n    },\n    uniforms: {\n      params: {\n        struct: {\n          faceSize: {\n            type: 'u32',\n            value: specularTexture.size.width,\n          },\n          maxMipLevel: {\n            type: 'u32',\n            value: specularTexture.texture.mipLevelCount,\n          },\n          sampleCount: {\n            type: 'u32',\n            value: 2048,\n          },\n        },\n      },\n    },\n    samplers: [sampler],\n    textures: [specularTexture, diffuseStorageTexture],\n  })\n\n  await computeDiffusePass.material.compileMaterial()\n\n  renderer.onBeforeRenderScene.add(\n    (commandEncoder) => {\n      // run the compute pass just once\n      renderer.renderSingleComputePass(commandEncoder, computeDiffusePass)\n\n      // copy the result to our diffuse texture\n      commandEncoder.copyTextureToTexture(\n        {\n          texture: diffuseStorageTexture.texture,\n        },\n        {\n          texture: diffuseTexture.texture,\n        },\n        [diffuseTexture.texture.width, diffuseTexture.texture.height, diffuseTexture.texture.depthOrArrayLayers]\n      )\n    },\n    { once: true }\n  )\n\n  renderer.onAfterCommandEncoderSubmission.add(\n    () => {\n      // once command encoder has been submitted, free the resources\n      computeDiffusePass.destroy()\n      diffuseStorageTexture.destroy()\n      diffuseStorageTexture = null\n      computeDiffusePass = null\n    },\n    { once: true }\n  )\n}\n\n",
        "called_code_segment_file_1": "export const buildShaders = (meshDescriptor: MeshDescriptor, shaderParameters = {} as ShaderBuilderParameters): BuiltShaders => { ... }",
        "invoking_code_segment_file_2": "const { vertex, fragment } = buildShaders(meshDescriptor, { shadingModel: 'PBR' });",
        "invoking_code_segment_file_3": "const { vertex, fragment } = buildShaders(meshDescriptor, { shadingModel: 'IBL' });",
        "new_file_code_segment": "export const addCustomShaderChunk = (shaderCode: string, customChunk: string) => { return shaderCode + customChunk; };",
        "feature_description": "Add a custom shader chunk to the existing shader code.",
        "detailed_feature_description": "The new feature allows users to add custom WGSL code snippets to the existing shader code generated by the buildShaders function. This is implemented in a new file (#file 4) which provides a function to append the custom chunk to the shader code. The buildShaders function in #file 1 is updated to use this new function, and #file 2 and #file 3 are updated to pass the custom chunk when invoking buildShaders.",
        "modified_complete_code": {
            "#file 1": "//Modify export const buildShaders = (meshDescriptor: MeshDescriptor, shaderParameters = {} as ShaderBuilderParameters): BuiltShaders => { ... const vs = addCustomShaderChunk(vs, shaderParameters.chunks?.additionalFragmentHead || ''); const fs = addCustomShaderChunk(fs, shaderParameters.chunks?.additionalFragmentHead || ''); return { vertex: { code: vs, entryPoint: 'main', }, fragment: { code: fs, entryPoint: 'main', }, }; }",
            "#file 2": "//Modify const { vertex, fragment } = buildShaders(meshDescriptor, { shadingModel: 'PBR', chunks: { additionalFragmentHead: '// Custom PBR chunk' } });",
            "#file 3": "//Modify const { vertex, fragment } = buildShaders(meshDescriptor, { shadingModel: 'IBL', chunks: { additionalFragmentHead: '// Custom IBL chunk' } });",
            "#file 4": "//New export const addCustomShaderChunk = (shaderCode: string, customChunk: string) => { return shaderCode + customChunk; };"
        }
    },
    {
        "repo": "instaclone",
        "content": "'instaclone/src/pages/notifications/notifications.ts'\n:import { Component } from '@angular/core';\nimport { IonicPage, NavController, NavParams } from 'ionic-angular';\n\n@IonicPage()\n@Component({\n  selector: 'page-notifications',\n  templateUrl: 'notifications.html',\n})\nexport class Notifications {\n\n  public page:string = 'you';\n\n  public notifications = [\n    {\n      \n    }\n  ];\n  public notifications_you = [\n    {\n      id: 1,\n    }\n  ];\n\n  constructor(public navCtrl: NavController, public navParams: NavParams) {\n  }\n\n  ionViewDidLoad() {\n    console.log('ionViewDidLoad Notifications');\n  }\n\n}\n\n'instaclone/src/app/app.module.ts'\n:import { NgModule, ErrorHandler } from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { IonicApp, IonicModule, IonicErrorHandler } from 'ionic-angular';\nimport { MyApp } from './app.component';\n\nimport { Home } from '../pages/home/home';\nimport { PostPopover } from '../pages/home/post-popover';\nimport { Search } from '../pages/search/search';\nimport { ModalPost } from '../pages/modal-post/modal-post';\nimport { Messages } from '../pages/messages/messages';\nimport { MessageDetail } from '../pages/message-detail/message-detail';\nimport { NewMessage } from '../pages/new-message/new-message';\nimport { Notifications } from '../pages/notifications/notifications';\nimport { Profile } from '../pages/profile/profile';\nimport { EditProfile } from '../pages/edit-profile/edit-profile';\nimport { TaggedProfile } from '../pages/tagged-profile/tagged-profile';\nimport { SavedProfile } from '../pages/saved-profile/saved-profile';\nimport { Options } from '../pages/options/options';\nimport { Comments } from '../pages/comments/comments';\nimport { TabsPage } from '../pages/tabs/tabs';\n\nimport { StatusBar } from '@ionic-native/status-bar';\nimport { SplashScreen } from '@ionic-native/splash-screen';\nimport { Camera } from '@ionic-native/camera';\n\n@NgModule({\n  declarations: [\n    MyApp,\n    Home,\n    PostPopover,\n    Search,\n    ModalPost,\n    Messages,\n    MessageDetail,\n    NewMessage,\n    Notifications,\n    Profile,\n    EditProfile,\n    TaggedProfile,\n    SavedProfile,\n    Options,\n    Comments,\n    TabsPage\n  ],\n  imports: [\n    BrowserModule,\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    Home,\n    PostPopover,\n    Search,\n    ModalPost,\n    Messages,\n    MessageDetail,\n    NewMessage,\n    Notifications,\n    Profile,\n    EditProfile,\n    TaggedProfile,\n    SavedProfile,\n    Options,\n    Comments,\n    TabsPage\n  ],\n  providers: [\n    StatusBar,\n    SplashScreen,\n    Camera,\n    {provide: ErrorHandler, useClass: IonicErrorHandler}\n  ]\n})\nexport class AppModule {}\n\n'instaclone/src/app/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n",
        "called_code_segment_file_1": "@IonicPage()\n@Component({\n  selector: 'page-notifications',\n  templateUrl: 'notifications.html',\n})\nexport class Notifications {\n\n  public page:string = 'you';\n\n  public notifications = [\n    {}\n  ];\n  public notifications_you = [\n    { id: 1 }\n  ];\n\n  constructor(public navCtrl: NavController, public navParams: NavParams) {}\n\n  ionViewDidLoad() {\n    console.log('ionViewDidLoad Notifications');\n  }\n}",
        "invoking_code_segment_file_2": "@NgModule({\n  declarations: [\n    MyApp,\n    Home,\n    PostPopover,\n    Search,\n    ModalPost,\n    Messages,\n    MessageDetail,\n    NewMessage,\n    Notifications,\n    Profile,\n    EditProfile,\n    TaggedProfile,\n    SavedProfile,\n    Options,\n    Comments,\n    TabsPage\n  ],\n  imports: [\n    BrowserModule,\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    Home,\n    PostPopover,\n    Search,\n    ModalPost,\n    Messages,\n    MessageDetail,\n    NewMessage,\n    Notifications,\n    Profile,\n    EditProfile,\n    TaggedProfile,\n    SavedProfile,\n    Options,\n    Comments,\n    TabsPage\n  ],\n  providers: [\n    StatusBar,\n    SplashScreen,\n    Camera,\n    {provide: ErrorHandler, useClass: IonicErrorHandler}\n  ]\n})\nexport class AppModule {}",
        "invoking_code_segment_file_3": "@Component({\n  selector: 'page-tabs',\n  templateUrl: 'tabs.html',\n})\nexport class TabsPage {\n  tab1Root = Home;\n  tab2Root = Search;\n  tab3Root = Notifications;\n  tab4Root = Messages;\n  tab5Root = Profile;\n\n  constructor() {}\n}",
        "new_file_code_segment": "@IonicPage()\n@Component({\n  selector: 'page-new-feature',\n  templateUrl: 'new-feature.html',\n})\nexport class NewFeature {\n\n  public featureData = [];\n\n  constructor(public navCtrl: NavController, public navParams: NavParams) {}\n\n  ionViewDidLoad() {\n    console.log('ionViewDidLoad NewFeature');\n  }\n}",
        "feature_description": "Add a new feature to display additional notifications in the Notifications page.",
        "detailed_feature_description": "A new component named 'NewFeature' is created to handle additional notifications. This component is integrated into the Notifications page to display these new notifications. The AppModule is updated to include this new component, and the TabsPage is modified to handle the new feature.",
        "modified_complete_code": {
            "file1": "@IonicPage()\n@Component({\n  selector: 'page-notifications',\n  templateUrl: 'notifications.html',\n})\nexport class Notifications {\n\n  public page:string = 'you';\n\n  public notifications = [\n    {}\n  ];\n  public notifications_you = [\n    { id: 1 }\n  ];\n\n  constructor(public navCtrl: NavController, public navParams: NavParams) {}\n\n  ionViewDidLoad() {\n    console.log('ionViewDidLoad Notifications');\n  }\n\n  #Modify\n  public loadNewFeature() {\n    this.navCtrl.push('NewFeature');\n  }\n}",
            "file2": "@NgModule({\n  declarations: [\n    MyApp,\n    Home,\n    PostPopover,\n    Search,\n    ModalPost,\n    Messages,\n    MessageDetail,\n    NewMessage,\n    Notifications,\n    Profile,\n    EditProfile,\n    TaggedProfile,\n    SavedProfile,\n    Options,\n    Comments,\n    TabsPage,\n    #New NewFeature\n  ],\n  imports: [\n    BrowserModule,\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    Home,\n    PostPopover,\n    Search,\n    ModalPost,\n    Messages,\n    MessageDetail,\n    NewMessage,\n    Notifications,\n    Profile,\n    EditProfile,\n    TaggedProfile,\n    SavedProfile,\n    Options,\n    Comments,\n    TabsPage,\n    #New NewFeature\n  ],\n  providers: [\n    StatusBar,\n    SplashScreen,\n    Camera,\n    {provide: ErrorHandler, useClass: IonicErrorHandler}\n  ]\n})\nexport class AppModule {}",
            "file3": "@Component({\n  selector: 'page-tabs',\n  templateUrl: 'tabs.html',\n})\nexport class TabsPage {\n  tab1Root = Home;\n  tab2Root = Search;\n  tab3Root = Notifications;\n  tab4Root = Messages;\n  tab5Root = Profile;\n\n  constructor() {}\n\n  #Modify\n  public loadNewFeature() {\n    this.navCtrl.push('NewFeature');\n  }\n}",
            "file4": "@IonicPage()\n@Component({\n  selector: 'page-new-feature',\n  templateUrl: 'new-feature.html',\n})\nexport class NewFeature {\n\n  public featureData = [];\n\n  constructor(public navCtrl: NavController, public navParams: NavParams) {}\n\n  ionViewDidLoad() {\n    console.log('ionViewDidLoad NewFeature');\n  }\n}"
        }
    },
    {
        "repo": "logseq-plugin-js-playground",
        "content": "'logseq-plugin-js-playground/src/load-eval.tsx'\n:import React from \"react\";\nimport ReactDOMServer from \"react-dom/server\";\n\nimport {\n  BlockEntity,\n  BlockUUIDTuple,\n  PageEntity,\n} from \"@logseq/libs/dist/LSPlugin.user\";\nimport * as esbuild from \"esbuild-wasm\";\nimport esbuildWasmUrl from \"esbuild-wasm/esbuild.wasm?url\";\n\n// Makes sure eval can be successfully called\nwindow.React = React;\nlet _init: Promise<void> | null = null;\n\nexport const initEsbuild = async () => {\n  if (!_init) {\n    _init = esbuild.initialize({\n      wasmURL: esbuildWasmUrl,\n    });\n  }\n  await _init;\n};\n\nconst transform = async (code: string, isTsx: boolean) => {\n  await initEsbuild();\n  return await esbuild.transform(code, { loader: isTsx ? \"tsx\" : \"ts\" });\n};\n\nfunction isBlockEntity(\n  maybeBlockEntity: BlockEntity | BlockUUIDTuple | PageEntity\n): maybeBlockEntity is BlockEntity {\n  // PageEntity does not have \"page\" property\n  return \"page\" in maybeBlockEntity;\n}\n\nexport const loadCode = async (blockId: string) => {\n  const block = await logseq.Editor.getBlock(blockId, {\n    includeChildren: true,\n  });\n\n  const codes: [lang: string, code: string][] = (block?.children ?? [])\n    .filter(isBlockEntity)\n    .flatMap((b) => b.body)\n    .filter((pair) => pair[0] === \"Src\")\n    .map((pair) => [pair[1].language ?? \"ts\", pair[1].lines.join(\"\")]);\n\n  const hasJsx = codes.some(([lang]) => [\"tsx\", \"jsx\"].includes(lang));\n  const { code } = await transform(\n    codes.map(([_, code]) => code).join(\"\"),\n    hasJsx\n  );\n  return [code, hasJsx] as const;\n};\n\n// Eval does not support ESM `import`\n// See https://2ality.com/2019/10/eval-via-import.html\n// We want to support ESM import to load some cool utilites like\n// https://www.skypack.dev/view/vega-lite\n// import vegaLite from 'https://cdn.skypack.dev/vega-lite';\nconst evalCode = async (code: string) => {\n  const encodedJs = encodeURIComponent(code);\n  const dataUri = \"data:text/javascript;charset=utf-8,\" + encodedJs;\n  return import( /* @vite-ignore */ dataUri).then((m) => m.default);\n};\n\nexport const loadAndEval = async (blockId: string) => {\n  const [code, hasJsx] = await loadCode(blockId);\n  console.log(\"=== Transformed Code === \\n\" + code);\n  const result = await evalCode(code);\n  if (hasJsx) {\n    return ReactDOMServer.renderToStaticMarkup(result);\n  }\n  return result;\n};\n\n'logseq-plugin-js-playground/src/register-macro.tsx'\n:import { initEsbuild, loadAndEval } from \"./load-eval\";\n\nconst macroPrefix = \":jsplay\";\n\n// @ts-expect-error\nconst css = (t, ...args) => String.raw(t, ...args);\n\nconst rendering = new Map<string, string>();\n\nconst wrapTemplate = (template: string) => {\n  return `<div style=\"border: 2px solid #000; padding: 0 1em; cursor: default\">${template}</div>`;\n};\n\nexport const registerMacro = () => {\n  initEsbuild();\n  logseq.App.onMacroRendererSlotted(async ({ payload, slot }) => {\n    const uuid = payload.uuid;\n    const [type] = payload.arguments;\n    if (!type?.startsWith(macroPrefix)) {\n      return;\n    }\n\n    rendering.set(uuid, slot);\n\n    const render = async () => {\n      try {\n        if (rendering.get(uuid) !== slot) {\n          return;\n        }\n        let template = await loadAndEval(uuid);\n\n        if (rendering.get(uuid) !== slot) {\n          return;\n        }\n\n        logseq.provideUI({\n          key: \"js-playground\",\n          slot,\n          reset: true,\n          template: wrapTemplate(template),\n        });\n      } catch (err: any) {\n        console.error(err);\n        logseq.provideUI({\n          key: \"js-playground\",\n          slot,\n          reset: true,\n          template: wrapTemplate(\n            `<span style=\"color: red\">${err.message}</span>`\n          ),\n        });\n        // skip invalid\n      }\n    };\n    render();\n  });\n\n  // This command only support to replace the whole block\n  logseq.Editor.registerSlashCommand(\"Add <JSPlay /> Block\", async () => {\n    const newContent = `{{renderer ${macroPrefix}}}`;\n    const block = await logseq.Editor.getCurrentBlock();\n    if (block) {\n      await logseq.Editor.updateBlock(block.uuid, newContent);\n      const codeBlock = await logseq.Editor.insertBlock(\n        block.uuid,\n        `\\`\\`\\`ts\\n export default \"Hello World!\" \\n\\`\\`\\``\n      );\n      if (codeBlock) {\n        await logseq.Editor.moveBlock(codeBlock.uuid, block.uuid, {\n          children: true,\n        });\n        logseq.Editor.exitEditingMode();\n      }\n    }\n  });\n};\n\n'logseq-plugin-js-playground/src/main.ts'\n:import \"@logseq/libs\";\n\nimport { logseq as PL } from \"../package.json\";\nimport { registerMacro } from \"./register-macro\";\n\nconst magicKey = `__${PL.id}__loaded__`;\n\nfunction main() {\n  const pluginId = logseq.baseInfo.id;\n  console.info(`#${pluginId}: MAIN`);\n\n  // @ts-expect-error\n  top[magicKey] = true;\n\n  registerMacro();\n}\n\n// @ts-expect-error\nif (top[magicKey]) {\n  // Reload Not working properly\n  logseq.App.relaunch().then(main).catch(console.error);\n} else {\n  logseq.ready(main).catch(console.error);\n}\n\n",
        "called_code_segment_file_1": "const evalCode = async (code: string) => {\n  const encodedJs = encodeURIComponent(code);\n  const dataUri = \"data:text/javascript;charset=utf-8,\" + encodedJs;\n  return import( /* @vite-ignore */ dataUri).then((m) => m.default);\n};",
        "invoking_code_segment_file_2": "const loadAndEval = async (blockId: string) => {\n  const [code, hasJsx] = await loadCode(blockId);\n  console.log(\"=== Transformed Code === \\n\" + code);\n  const result = await evalCode(code);\n  if (hasJsx) {\n    return ReactDOMServer.renderToStaticMarkup(result);\n  }\n  return result;\n};",
        "invoking_code_segment_file_3": "const render = async () => {\n  try {\n    if (rendering.get(uuid) !== slot) {\n      return;\n    }\n    let template = await loadAndEval(uuid);\n\n    if (rendering.get(uuid) !== slot) {\n      return;\n    }\n\n    logseq.provideUI({\n      key: \"js-playground\",\n      slot,\n      reset: true,\n      template: wrapTemplate(template),\n    });\n  } catch (err: any) {\n    console.error(err);\n    logseq.provideUI({\n      key: \"js-playground\",\n      slot,\n      reset: true,\n      template: wrapTemplate(\n        `<span style=\\\"color: red\\\">${err.message}</span>`\n      ),\n    });\n    // skip invalid\n  }\n};",
        "new_file_code_segment": "const logExecutionTime = async (func: Function, ...args: any[]) => {\n  const startTime = performance.now();\n  const result = await func(...args);\n  const endTime = performance.now();\n  console.log(`Execution time: ${endTime - startTime} ms`);\n  return result;\n};",
        "feature_description": "Add logging of execution time for the `evalCode` function.",
        "detailed_feature_description": "The new feature involves adding a utility function in #file 4 to log the execution time of the `evalCode` function. This utility function will be invoked in #file 1 where `evalCode` is called, and the changes will be propagated to #file 2 and #file 3 to ensure compatibility.",
        "modified_complete_code": {
            "file_1": "const evalCode = async (code: string) => {\n  const encodedJs = encodeURIComponent(code);\n  const dataUri = \"data:text/javascript;charset=utf-8,\" + encodedJs;\n  return import( /* @vite-ignore */ dataUri).then((m) => m.default);\n};\n\n//Modify\nconst evalCodeWithLogging = async (code: string) => {\n  return await logExecutionTime(evalCode, code);\n};\n\n//New\nimport { logExecutionTime } from './file_4';",
            "file_2": "const loadAndEval = async (blockId: string) => {\n  const [code, hasJsx] = await loadCode(blockId);\n  console.log(\"=== Transformed Code === \\n\" + code);\n  //Modify\n  const result = await evalCodeWithLogging(code);\n  if (hasJsx) {\n    return ReactDOMServer.renderToStaticMarkup(result);\n  }\n  return result;\n};",
            "file_3": "const render = async () => {\n  try {\n    if (rendering.get(uuid) !== slot) {\n      return;\n    }\n    let template = await loadAndEval(uuid);\n\n    if (rendering.get(uuid) !== slot) {\n      return;\n    }\n\n    logseq.provideUI({\n      key: \"js-playground\",\n      slot,\n      reset: true,\n      template: wrapTemplate(template),\n    });\n  } catch (err: any) {\n    console.error(err);\n    logseq.provideUI({\n      key: \"js-playground\",\n      slot,\n      reset: true,\n      template: wrapTemplate(\n        `<span style=\\\"color: red\\\">${err.message}</span>`\n      ),\n    });\n    // skip invalid\n  }\n};",
            "file_4": "//New\nconst logExecutionTime = async (func: Function, ...args: any[]) => {\n  const startTime = performance.now();\n  const result = await func(...args);\n  const endTime = performance.now();\n  console.log(`Execution time: ${endTime - startTime} ms`);\n  return result;\n};"
        }
    },
    {
        "repo": "meditations",
        "content": "'meditations/src/journal/containers/JournalRoot.tsx'\n:import * as React from \"react\";\nimport moment from \"moment\";\n\nimport * as common from \"../../common\";\nimport { CommonUI } from \"../../common/components/CommonUI\";\n\nimport { JournalState, Entry } from \"../state\";\nimport { JournalSidebar } from \"../components/Sidebar\";\n\nimport { BrowseChrono } from \"../components/BrowseChrono\";\nimport { BrowseTag } from \"../components/BrowseTag\";\nimport { CEntry } from \"../components/CEntry\";\nimport { JournalNavigation } from \"./JournalNavigation\";\n\nconst ViewEntry = (props: { entry: Entry | null }) => {\n  return props.entry ? (\n    <CEntry editableID={`entry-${props.entry.ID}`} context={true} entry={props.entry} />\n  ) : (\n    <p>Entry deleted</p>\n  );\n};\n\nexport const JournalRoot = common.connect()(\n  class extends React.Component<JournalState, {}> {\n    render() {\n      return (\n        <CommonUI {...this.props}>\n          <div className=\"d-flex flex-column flex-md-row mr-md-1\">\n            <div id=\"journal-sidebar\" className=\"mb-1\">\n              {React.createElement(JournalSidebar)}\n            </div>\n\n            <div id=\"journal-main\" className=\"ml-md-1\">\n              {React.createElement(JournalNavigation)}\n              {(this.props.route === \"VIEW_MONTH\" ||\n                this.props.route === \"VIEW_DAYS\" ||\n                this.props.searchResults) && (\n                  <BrowseChrono\n                    searchString={this.props.searchString}\n                    daysView={this.props.route === \"VIEW_DAYS\"}\n                    date={\n                      this.props.route === \"VIEW_MONTH\" ||\n                        this.props.route === \"VIEW_DAYS\"\n                        ? this.props.date\n                        : moment()\n                    }\n                    entries={this.props.entries}\n                  />\n                )}\n              {this.props.route === \"VIEW_TAG\" && (\n                <BrowseTag\n                  tagName={this.props.tag}\n                  entries={this.props.entries}\n                />\n              )}\n              {this.props.route === \"VIEW_NAMED_ENTRY\" && (\n                <ViewEntry\n                  entry={\n                    this.props.entries.length === 0\n                      ? null\n                      : this.props.entries[0]\n                  }\n                />\n              )}\n              {this.props.route === \"VIEW_SEARCH\" && (\n                <span>Search not implemented yet</span>\n              )}\n            </div>\n          </div>\n        </CommonUI>\n      );\n    }\n  }\n);\n\n'meditations/src/journal/main.tsx'\n:import * as React from \"react\";\nimport route from \"riot-route\";\nimport * as Scroll from \"react-scroll\";\n\nimport moment from \"moment\";\nimport * as common from \"../common\";\n\nimport { JournalRoot } from \"./containers/JournalRoot\";\nimport { SidebarState } from \"./components/Sidebar\";\nimport { store, dispatch, Entry } from \"./state\";\n\nexport const main = () => {\n  ///// ROUTES\n  // Install router. If no route was specifically given, start with #view/YYYY-MM\n  common.installRouter(\n    \"/journal#\",\n    `view/${moment().format(common.MONTH_FORMAT)}`,\n    {\n      no_action: () => route(`view/${moment().format(common.MONTH_FORMAT)}`),\n      journal: () => null, // Dummy, called if journal is clicked from navbar\n\n      view: (datestr: string, entryScrollId?: string) => {\n        const date = moment(datestr, common.MONTH_FORMAT);\n\n        if (entryScrollId && !isNaN(parseInt(entryScrollId, 10))) {\n          Scroll.scroller.scrollTo(`entry-${entryScrollId}`, {\n            smooth: true,\n            duration: 500\n          });\n        }\n\n        common.setTitle(\"Notes\", `${date.format(\"MMMM YYYY\")}`);\n\n        // TODO: Update habits link to reflect current date\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/date?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_MONTH\" });\n            }\n          );\n        });\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/date?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_MONTH\" });\n            }\n          );\n        });\n      },\n\n      search: (text: string) => {\n        common.setTitle(\"Notes\", `Search: ${text}`);\n\n        common.post(`/journal/search?string=${text}`);\n      },\n\n      viewdays: (datestr: string) => {\n        const date = moment(datestr, common.DAY_FORMAT);\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/by-day?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_DAYS\" });\n            }\n          );\n        });\n      },\n\n      tag: (tagname: string) => {\n        common.setTitle(\"Notes\", `Tag #${tagname}`);\n        dispatch(dispatch => {\n          common.get(`/journal/entries/tag/${tagname}`, (entries: Entry[]) => {\n            entries.forEach(common.processModel);\n            dispatch({ entries, type: \"VIEW_TAG\", tag: tagname });\n          });\n        });\n      },\n\n      name: (name: string) => {\n        common.setTitle(\"Notes\", `${name}`);\n        dispatch(dispatch => {\n          common.get(`/journal/entries/name/${name}`, (entry: Entry) => {\n            common.processModel(entry);\n            dispatch({ entry, type: \"VIEW_NAMED_ENTRY\" });\n          });\n        });\n      }\n    }\n  );\n\n  // WebSocket handling\n  type JournalMessage =\n    | {\n      Type: \"UPDATE_ENTRY\";\n      Datum: Entry;\n    }\n    | {\n      Type: \"DELETE_ENTRY\";\n      Datum: number;\n    }\n    | {\n      Type: \"CREATE_ENTRY\";\n      Datum: Entry;\n    }\n    | {\n      Type: \"SIDEBAR\";\n      Datum: SidebarState;\n    }\n    | {\n      Type: \"SEARCH\";\n      Datum: {\n        String: string;\n        Entries: Entry[];\n      };\n    };\n\n  common.makeSocket(\n    \"journal/sync\",\n    (msg: JournalMessage) => {\n      switch (msg.Type) {\n        case \"UPDATE_ENTRY\":\n          common.processModel(msg.Datum);\n          dispatch({ type: \"UPDATE_ENTRY\", entry: msg.Datum });\n          break;\n        case \"DELETE_ENTRY\":\n          dispatch({ type: \"DELETE_ENTRY\", ID: msg.Datum });\n          break;\n        case \"CREATE_ENTRY\":\n          common.processModel(msg.Datum);\n          // TODO: View change?\n          // TODO: Dispatch view change\n          dispatch({ type: \"CREATE_ENTRY\", entry: msg.Datum });\n          break;\n        case \"SIDEBAR\":\n          dispatch({ type: \"MOUNT_SIDEBAR\", sidebar: msg.Datum });\n          break;\n        case \"SEARCH\":\n          msg.Datum.Entries.forEach(common.processModel);\n          dispatch({\n            type: \"SEARCH\",\n            string: msg.Datum.String,\n            entries: msg.Datum.Entries\n          });\n          break;\n      }\n    },\n    () => {\n      ///// RENDER\n      // After socket connects\n      common.render(\"root\", store, React.createElement(JournalRoot));\n\n      // Fetch sidebar\n      common.post(\"/journal/sidebar\");\n    }\n  );\n};\n\n'meditations/src/entry/journal.ts'\n:import { main } from '../journal/main';\n\ndocument.addEventListener('DOMContentLoaded', main);\n\n",
        "called_code_segment_file_1": "export const main = () => {\n  ///// ROUTES\n  // Install router. If no route was specifically given, start with #view/YYYY-MM\n  common.installRouter(\n    \"/journal#\",\n    `view/${moment().format(common.MONTH_FORMAT)}`,\n    {\n      no_action: () => route(`view/${moment().format(common.MONTH_FORMAT)}`),\n      journal: () => null, // Dummy, called if journal is clicked from navbar\n\n      view: (datestr: string, entryScrollId?: string) => {\n        const date = moment(datestr, common.MONTH_FORMAT);\n\n        if (entryScrollId && !isNaN(parseInt(entryScrollId, 10))) {\n          Scroll.scroller.scrollTo(`entry-${entryScrollId}`, {\n            smooth: true,\n            duration: 500\n          });\n        }\n\n        common.setTitle(\"Notes\", `${date.format(\"MMMM YYYY\")}`);\n\n        // TODO: Update habits link to reflect current date\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/date?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_MONTH\" });\n            }\n          );\n        });\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/date?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_MONTH\" });\n            }\n          );\n        });\n      },\n\n      search: (text: string) => {\n        common.setTitle(\"Notes\", `Search: ${text}`);\n\n        common.post(`/journal/search?string=${text}`);\n      },\n\n      viewdays: (datestr: string) => {\n        const date = moment(datestr, common.DAY_FORMAT);\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/by-day?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_DAYS\" });\n            }\n          );\n        });\n      },\n\n      tag: (tagname: string) => {\n        common.setTitle(\"Notes\", `Tag #${tagname}`);\n        dispatch(dispatch => {\n          common.get(`/journal/entries/tag/${tagname}`, (entries: Entry[]) => {\n            entries.forEach(common.processModel);\n            dispatch({ entries, type: \"VIEW_TAG\", tag: tagname });\n          });\n        });\n      },\n\n      name: (name: string) => {\n        common.setTitle(\"Notes\", `${name}`);\n        dispatch(dispatch => {\n          common.get(`/journal/entries/name/${name}`, (entry: Entry) => {\n            common.processModel(entry);\n            dispatch({ entry, type: \"VIEW_NAMED_ENTRY\" });\n          });\n        });\n      }\n    }\n  );\n\n  // WebSocket handling\n  type JournalMessage =\n    | { Type: \"UPDATE_ENTRY\"; Datum: Entry; }\n    | { Type: \"DELETE_ENTRY\"; Datum: number; }\n    | { Type: \"CREATE_ENTRY\"; Datum: Entry; }\n    | { Type: \"SIDEBAR\"; Datum: SidebarState; }\n    | { Type: \"SEARCH\"; Datum: { String: string; Entries: Entry[]; }; };\n\n  common.makeSocket(\n    \"journal/sync\",\n    (msg: JournalMessage) => {\n      switch (msg.Type) {\n        case \"UPDATE_ENTRY\":\n          common.processModel(msg.Datum);\n          dispatch({ type: \"UPDATE_ENTRY\", entry: msg.Datum });\n          break;\n        case \"DELETE_ENTRY\":\n          dispatch({ type: \"DELETE_ENTRY\", ID: msg.Datum });\n          break;\n        case \"CREATE_ENTRY\":\n          common.processModel(msg.Datum);\n          // TODO: View change?\n          // TODO: Dispatch view change\n          dispatch({ type: \"CREATE_ENTRY\", entry: msg.Datum });\n          break;\n        case \"SIDEBAR\":\n          dispatch({ type: \"MOUNT_SIDEBAR\", sidebar: msg.Datum });\n          break;\n        case \"SEARCH\":\n          msg.Datum.Entries.forEach(common.processModel);\n          dispatch({ type: \"SEARCH\", string: msg.Datum.String, entries: msg.Datum.Entries });\n          break;\n      }\n    },\n    () => {\n      ///// RENDER\n      // After socket connects\n      common.render(\"root\", store, React.createElement(JournalRoot));\n\n      // Fetch sidebar\n      common.post(\"/journal/sidebar\");\n    }\n  );\n};",
        "invoking_code_segment_file_2": "document.addEventListener('DOMContentLoaded', main);",
        "invoking_code_segment_file_3": "export const JournalRoot = common.connect()(\n  class extends React.Component<JournalState, {}> {\n    render() {\n      return (\n        <CommonUI {...this.props}>\n          <div className=\"d-flex flex-column flex-md-row mr-md-1\">\n            <div id=\"journal-sidebar\" className=\"mb-1\">\n              {React.createElement(JournalSidebar)}\n            </div>\n\n            <div id=\"journal-main\" className=\"ml-md-1\">\n              {React.createElement(JournalNavigation)}\n              {(this.props.route === \"VIEW_MONTH\" ||\n                this.props.route === \"VIEW_DAYS\" ||\n                this.props.searchResults) &&\n                <BrowseChrono\n                  searchString={this.props.searchString}\n                  daysView={this.props.route === \"VIEW_DAYS\"}\n                  date={this.props.route === \"VIEW_MONTH\" || this.props.route === \"VIEW_DAYS\" ? this.props.date : moment()}\n                  entries={this.props.entries}\n                />\n              }\n              {this.props.route === \"VIEW_TAG\" &&\n                <BrowseTag\n                  tagName={this.props.tag}\n                  entries={this.props.entries}\n                />\n              }\n              {this.props.route === \"VIEW_NAMED_ENTRY\" &&\n                <ViewEntry\n                  entry={this.props.entries.length === 0 ? null : this.props.entries[0]}\n                />\n              }\n              {this.props.route === \"VIEW_SEARCH\" &&\n                <span>Search not implemented yet</span>\n              }\n            </div>\n          </div>\n        </CommonUI>\n      );\n    }\n  }\n);",
        "new_file_code_segment": "export const newFeature = () => {\n  console.log('New feature implemented!');\n};\n\nexport const handleNewFeature = () => {\n  // Handle new feature logic\n  newFeature();\n};",
        "feature_description": "Add a new feature to log a message when the DOM content is loaded.",
        "detailed_feature_description": "The new feature involves adding a new function `newFeature` that logs a message to the console. This function is then invoked within the `handleNewFeature` function. The `handleNewFeature` function is called within the `main` function in #file 1, ensuring that the new feature is executed when the DOM content is loaded. This integration ensures that the new feature is compatible with the existing codebase and does not disrupt the current interactions between #file 1, #file 2, and #file 3.",
        "modified_complete_code": {
            "#file 1": "export const main = () => {\n  ///// ROUTES\n  // Install router. If no route was specifically given, start with #view/YYYY-MM\n  common.installRouter(\n    \"/journal#\",\n    `view/${moment().format(common.MONTH_FORMAT)}`,\n    {\n      no_action: () => route(`view/${moment().format(common.MONTH_FORMAT)}`),\n      journal: () => null, // Dummy, called if journal is clicked from navbar\n\n      view: (datestr: string, entryScrollId?: string) => {\n        const date = moment(datestr, common.MONTH_FORMAT);\n\n        if (entryScrollId && !isNaN(parseInt(entryScrollId, 10))) {\n          Scroll.scroller.scrollTo(`entry-${entryScrollId}`, {\n            smooth: true,\n            duration: 500\n          });\n        }\n\n        common.setTitle(\"Notes\", `${date.format(\"MMMM YYYY\")}`);\n\n        // TODO: Update habits link to reflect current date\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/date?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_MONTH\" });\n            }\n          );\n        });\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/date?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_MONTH\" });\n            }\n          );\n        });\n      },\n\n      search: (text: string) => {\n        common.setTitle(\"Notes\", `Search: ${text}`);\n\n        common.post(`/journal/search?string=${text}`);\n      },\n\n      viewdays: (datestr: string) => {\n        const date = moment(datestr, common.DAY_FORMAT);\n\n        dispatch(dispatch => {\n          common.get(\n            `/journal/entries/by-day?date=${datestr}`,\n            (entries: Entry[]) => {\n              entries.forEach(common.processModel);\n              dispatch({ date, entries, type: \"VIEW_DAYS\" });\n            }\n          );\n        });\n      },\n\n      tag: (tagname: string) => {\n        common.setTitle(\"Notes\", `Tag #${tagname}`);\n        dispatch(dispatch => {\n          common.get(`/journal/entries/tag/${tagname}`, (entries: Entry[]) => {\n            entries.forEach(common.processModel);\n            dispatch({ entries, type: \"VIEW_TAG\", tag: tagname });\n          });\n        });\n      },\n\n      name: (name: string) => {\n        common.setTitle(\"Notes\", `${name}`);\n        dispatch(dispatch => {\n          common.get(`/journal/entries/name/${name}`, (entry: Entry) => {\n            common.processModel(entry);\n            dispatch({ entry, type: \"VIEW_NAMED_ENTRY\" });\n          });\n        });\n      }\n    }\n  );\n\n  // WebSocket handling\n  type JournalMessage =\n    | { Type: \"UPDATE_ENTRY\"; Datum: Entry; }\n    | { Type: \"DELETE_ENTRY\"; Datum: number; }\n    | { Type: \"CREATE_ENTRY\"; Datum: Entry; }\n    | { Type: \"SIDEBAR\"; Datum: SidebarState; }\n    | { Type: \"SEARCH\"; Datum: { String: string; Entries: Entry[]; }; };\n\n  common.makeSocket(\n    \"journal/sync\",\n    (msg: JournalMessage) => {\n      switch (msg.Type) {\n        case \"UPDATE_ENTRY\":\n          common.processModel(msg.Datum);\n          dispatch({ type: \"UPDATE_ENTRY\", entry: msg.Datum });\n          break;\n        case \"DELETE_ENTRY\":\n          dispatch({ type: \"DELETE_ENTRY\", ID: msg.Datum });\n          break;\n        case \"CREATE_ENTRY\":\n          common.processModel(msg.Datum);\n          // TODO: View change?\n          // TODO: Dispatch view change\n          dispatch({ type: \"CREATE_ENTRY\", entry: msg.Datum });\n          break;\n        case \"SIDEBAR\":\n          dispatch({ type: \"MOUNT_SIDEBAR\", sidebar: msg.Datum });\n          break;\n        case \"SEARCH\":\n          msg.Datum.Entries.forEach(common.processModel);\n          dispatch({ type: \"SEARCH\", string: msg.Datum.String, entries: msg.Datum.Entries });\n          break;\n      }\n    },\n    () => {\n      ///// RENDER\n      // After socket connects\n      common.render(\"root\", store, React.createElement(JournalRoot));\n\n      // Fetch sidebar\n      common.post(\"/journal/sidebar\");\n    }\n  );\n\n  // New feature\n  handleNewFeature(); // #Modify\n};",
            "#file 2": "document.addEventListener('DOMContentLoaded', main);",
            "#file 3": "export const JournalRoot = common.connect()(\n  class extends React.Component<JournalState, {}> {\n    render() {\n      return (\n        <CommonUI {...this.props}>\n          <div className=\"d-flex flex-column flex-md-row mr-md-1\">\n            <div id=\"journal-sidebar\" className=\"mb-1\">\n              {React.createElement(JournalSidebar)}\n            </div>\n\n            <div id=\"journal-main\" className=\"ml-md-1\">\n              {React.createElement(JournalNavigation)}\n              {(this.props.route === \"VIEW_MONTH\" ||\n                this.props.route === \"VIEW_DAYS\" ||\n                this.props.searchResults) &&\n                <BrowseChrono\n                  searchString={this.props.searchString}\n                  daysView={this.props.route === \"VIEW_DAYS\"}\n                  date={this.props.route === \"VIEW_MONTH\" || this.props.route === \"VIEW_DAYS\" ? this.props.date : moment()}\n                  entries={this.props.entries}\n                />\n              }\n              {this.props.route === \"VIEW_TAG\" &&\n                <BrowseTag\n                  tagName={this.props.tag}\n                  entries={this.props.entries}\n                />\n              }\n              {this.props.route === \"VIEW_NAMED_ENTRY\" &&\n                <ViewEntry\n                  entry={this.props.entries.length === 0 ? null : this.props.entries[0]}\n                />\n              }\n              {this.props.route === \"VIEW_SEARCH\" &&\n                <span>Search not implemented yet</span>\n              }\n            </div>\n          </div>\n        </CommonUI>\n      );\n    }\n  }\n);",
            "#file 4": "export const newFeature = () => {\n  console.log('New feature implemented!');\n};\n\nexport const handleNewFeature = () => {\n  // Handle new feature logic\n  newFeature();\n};"
        }
    },
    {
        "repo": "nestjs-db-postgresql",
        "content": "'nestjs-db-postgresql/src/app/user/user.entity.ts'\n:import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn() id: number;\n\n  @Column({length: 500 })\n  name: string;\n\n  @Column('mobile') mobile: string;\n\n  @Column('email') email: string;\n}\n'nestjs-db-postgresql/src/app/app.module.ts'\n:import { UsersModule } from './user.module';\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from \"@nestjs/typeorm\";\nimport { AboutController } from './about/about.controller';\nimport { User } from './user/user.entity';\n\n@Module({\n    imports : [\n        TypeOrmModule.forRoot(),\n        UsersModule\n    ],\n    controllers : [\n        AboutController\n    ]\n})\nexport class ApplicationModule {\n\n    constructor() {\n        console.log('main module got loaded');\n    }\n}\n'nestjs-db-postgresql/src/server.ts'\n:import { NestFactory } from '@nestjs/core';\nimport { ApplicationModule } from './app/app.module';\nimport { INestApplication } from '@nestjs/common/interfaces/nest-application.interface';\n\nconst app: Promise<INestApplication> = NestFactory.create(ApplicationModule);\napp.then(instance =>\n  instance.listen(3000, () =>\n    console.log('Application is listening on port 3000')\n  )\n);\n\n",
        "called_code_segment_file_1": "@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn() id: number;\n\n  @Column({length: 500 })\n  name: string;\n\n  @Column('mobile') mobile: string;\n\n  @Column('email') email: string;\n}",
        "invoking_code_segment_file_2": "imports : [\n    TypeOrmModule.forRoot(),\n    UsersModule\n],",
        "invoking_code_segment_file_3": "const app: Promise<INestApplication> = NestFactory.create(ApplicationModule);\napp.then(instance =>\n  instance.listen(3000, () =>\n    console.log('Application is listening on port 3000')\n  )\n);",
        "new_file_code_segment": "export class UserService {\n  constructor(private readonly userRepository: Repository<User>) {}\n\n  async createUser(user: User): Promise<User> {\n    return this.userRepository.save(user);\n  }\n}",
        "feature_description": "Add a new service to handle user creation.",
        "detailed_feature_description": "The new feature involves creating a UserService in a new file (#file 4) to handle the creation of users. This service will be injected into the UsersModule and will be used to create users in the database. The UserService will be invoked from the UsersModule, which will then be used by the ApplicationModule to handle user-related operations.",
        "modified_complete_code": {
            "file_1": "//Modify\nimport { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';\n\n@Entity('users')\nexport class User {\n  @PrimaryGeneratedColumn() id: number;\n\n  @Column({length: 500 })\n  name: string;\n\n  @Column('mobile') mobile: string;\n\n  @Column('email') email: string;\n}",
            "file_2": "//Modify\nimport { UsersModule } from './user.module';\nimport { Module } from '@nestjs/common';\nimport { TypeOrmModule } from \"@nestjs/typeorm\";\nimport { AboutController } from './about/about.controller';\nimport { User } from './user/user.entity';\n\n@Module({\n    imports : [\n        TypeOrmModule.forRoot(),\n        UsersModule\n    ],\n    controllers : [\n        AboutController\n    ]\n})\nexport class ApplicationModule {\n\n    constructor() {\n        console.log('main module got loaded');\n    }\n}",
            "file_3": "//Modify\nimport { NestFactory } from '@nestjs/core';\nimport { ApplicationModule } from './app/app.module';\nimport { INestApplication } from '@nestjs/common/interfaces/nest-application.interface';\n\nconst app: Promise<INestApplication> = NestFactory.create(ApplicationModule);\napp.then(instance =>\n  instance.listen(3000, () =>\n    console.log('Application is listening on port 3000')\n  )\n);",
            "file_4": "//New\nimport { Injectable } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { User } from './user.entity';\n\n@Injectable()\nexport class UserService {\n  constructor(private readonly userRepository: Repository<User>) {}\n\n  async createUser(user: User): Promise<User> {\n    return this.userRepository.save(user);\n  }\n}"
        }
    },
    {
        "repo": "restaurant-app",
        "content": "'restaurant-app/src/pages/home/home.ts'\n:import { Component } from '@angular/core';\n\nimport { NavController } from 'ionic-angular';\n\nimport { AddRestaurant } from '../add-restaurant/add-restaurant';\n\n/*\n\n                                _/|__\n            _,-------,        _/ -|  \\_     /~>.\n         _-~ __--~~/\\ |      (  \\   /  )   | / |\n      _-~__--    //   \\\\      \\ *   * /   / | ||   \n   _-~_--       //     ||      \\     /   | /  /|  \n  ~ ~~~~-_     //       \\\\     |( \" )|  / | || /  \n          \\   //         ||    | VWV | | /  ///  \n    |\\     | //           \\\\ _/      |/ | ./ |\n    | |    |// __         _-~         \\// |  /\n   /  /   //_-~  ~~--_ _-~  /          |\\// /  \n  |  |   /-~        _-~    (     /   |/ / /   \n /   /           _-~  __    |   |____|/     \n|   |__         / _-~  ~-_  (_______  `\\\n|      ~~--__--~ /  _     \\        __\\)))\n \\               _-~       |     ./  \\    \n  ~~--__        /         /    _/     |\n        ~~--___/       _-_____/      /            \n         _____/     _-_____/      _-~             \n      /^<  ___       -____         -____          \n         ~~   ~~--__      ``\\--__       ``\\\n                    ~~--\\)\\)\\)   ~~--\\)\\)\\) a rich\n*/\n\n@Component({\n  selector: 'page-home',\n  templateUrl: 'home.html'\n})\nexport class HomePage {\n  propriedade:String;\n  constructor(public navCtrl: NavController) {\n    this.propriedade = \"aletoria\";\n  }\n  \n  ionViewDidLoad() {\n    console.log('Hello Page');\n  }\n  addRestaurant(){\n    this.navCtrl.push(AddRestaurant);\n  }\n  \n  showRestaurant(){\n\n  }\n  click() {\n    this.propriedade = 'haha';\n  }\n\n}\n\n'restaurant-app/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { IonicApp, IonicModule } from 'ionic-angular';\nimport { MyApp } from './app.component';\nimport { AboutPage } from '../pages/about/about';\nimport { ContactPage } from '../pages/contact/contact';\nimport { HomePage } from '../pages/home/home';\nimport { AddRestaurant } from '../pages/add-restaurant/add-restaurant';\nimport { AddRestaurantInfo } from '../pages/add-restaurant-info/add-restaurant-info';\nimport { ListRestaurant } from '../pages/list-restaurant/list-restaurant';\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  imports: [\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  providers: []\n})\nexport class AppModule {}\n\n'restaurant-app/src/app/main.dev.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app.module';\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n",
        "called_code_segment_file_1": "@Component({\n  selector: 'page-home',\n  templateUrl: 'home.html'\n})\nexport class HomePage {\n  propriedade:String;\n  constructor(public navCtrl: NavController) {\n    this.propriedade = \"aletoria\";\n  }\n  \n  ionViewDidLoad() {\n    console.log('Hello Page');\n  }\n  addRestaurant(){\n    this.navCtrl.push(AddRestaurant);\n  }\n  \n  showRestaurant(){\n\n  }\n  click() {\n    this.propriedade = 'haha';\n  }\n}",
        "invoking_code_segment_file_2": "import { HomePage } from '../pages/home/home';\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  imports: [\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant\n  ],\n  providers: []\n})\nexport class AppModule {}",
        "invoking_code_segment_file_3": "import { HomePage } from '../pages/home/home';\n\n@Component({\n  selector: 'page-add-restaurant',\n  templateUrl: 'add-restaurant.html'\n})\nexport class AddRestaurant {\n  constructor(public navCtrl: NavController) {\n    this.navCtrl.push(HomePage);\n  }\n}",
        "new_file_code_segment": "@Component({\n  selector: 'page-new-feature',\n  templateUrl: 'new-feature.html'\n})\nexport class NewFeaturePage {\n  constructor(public navCtrl: NavController) {\n    console.log('New Feature Page');\n  }\n}",
        "feature_description": "Add a new feature to navigate to a new page called NewFeaturePage from the HomePage.",
        "detailed_feature_description": "The new feature involves adding a new page (NewFeaturePage) that can be navigated to from the HomePage. This requires modifications in the HomePage to include a new method to navigate to the NewFeaturePage. Additionally, the AppModule needs to be updated to include the new page in the declarations and entryComponents. The AddRestaurant page will also be updated to demonstrate navigation to the new feature page.",
        "modified_complete_code": {
            "file_1": "@Component({\n  selector: 'page-home',\n  templateUrl: 'home.html'\n})\nexport class HomePage {\n  propriedade:String;\n  constructor(public navCtrl: NavController) {\n    this.propriedade = \"aletoria\";\n  }\n  \n  ionViewDidLoad() {\n    console.log('Hello Page');\n  }\n  addRestaurant(){\n    this.navCtrl.push(AddRestaurant);\n  }\n  \n  showRestaurant(){\n\n  }\n  click() {\n    this.propriedade = 'haha';\n  }\n  #Modify\n  newFeature() {\n    this.navCtrl.push(NewFeaturePage);\n  }\n}",
            "file_2": "import { NgModule } from '@angular/core';\nimport { IonicApp, IonicModule } from 'ionic-angular';\nimport { MyApp } from './app.component';\nimport { AboutPage } from '../pages/about/about';\nimport { ContactPage } from '../pages/contact/contact';\nimport { HomePage } from '../pages/home/home';\nimport { AddRestaurant } from '../pages/add-restaurant/add-restaurant';\nimport { AddRestaurantInfo } from '../pages/add-restaurant-info/add-restaurant-info';\nimport { ListRestaurant } from '../pages/list-restaurant/list-restaurant';\n#New\nimport { NewFeaturePage } from '../pages/new-feature/new-feature';\n\n@NgModule({\n  declarations: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant,\n    #New\n    NewFeaturePage\n  ],\n  imports: [\n    IonicModule.forRoot(MyApp)\n  ],\n  bootstrap: [IonicApp],\n  entryComponents: [\n    MyApp,\n    AboutPage,\n    ContactPage,\n    HomePage,\n    AddRestaurant,\n    AddRestaurantInfo,\n    ListRestaurant,\n    #New\n    NewFeaturePage\n  ],\n  providers: []\n})\nexport class AppModule {}",
            "file_3": "import { HomePage } from '../pages/home/home';\n#New\nimport { NewFeaturePage } from '../pages/new-feature/new-feature';\n\n@Component({\n  selector: 'page-add-restaurant',\n  templateUrl: 'add-restaurant.html'\n})\nexport class AddRestaurant {\n  constructor(public navCtrl: NavController) {\n    this.navCtrl.push(HomePage);\n  }\n  #New\n  newFeature() {\n    this.navCtrl.push(NewFeaturePage);\n  }\n}",
            "file_4": "@Component({\n  selector: 'page-new-feature',\n  templateUrl: 'new-feature.html'\n})\nexport class NewFeaturePage {\n  constructor(public navCtrl: NavController) {\n    console.log('New Feature Page');\n  }\n}"
        }
    },
    {
        "repo": "simplex-noise-demo-synthwave",
        "content": "'simplex-noise-demo-synthwave/Grid2D.ts'\n:export class Grid2D {\n  readonly points: Float32Array;\n  constructor(readonly width: number, readonly height: number, readonly components: number) {\n    this.points = new Float32Array(width * height * components);\n  }\n}\nexport function iterateGrid2D(grid: Grid2D, callback: (points: Float32Array, x: number, y: number, i: number) => void) {\n  const { width, points, components } = grid;\n  const height = grid.points.length / width / components;\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      const i = (y * width + x) * components;\n      callback(points, x, y, i);\n    }\n  }\n}\n\n'simplex-noise-demo-synthwave/renderer.ts'\n:import { vec3, mat4 } from 'gl-matrix';\nimport { Grid2D, iterateGrid2D } from './Grid2D';\nimport { createNoise2D } from 'simplex-noise';\nimport { fbm2d } from './fbm2d';\nimport alea from 'alea';\n\nconst rng = alea('B');\nconst simplexNoise2D = createNoise2D(rng);\nconst noise2D = fbm2d(simplexNoise2D, 2);\n\ntype Render = (t: number) => void;\nexport function renderer(ctx: CanvasRenderingContext2D, width: number, height: number): Render {\n\n  const skyGradient = ctx.createLinearGradient(0, 0, 0, height / 4 * 3);\n  skyGradient.addColorStop(0.0, '#1c014add');\n  skyGradient.addColorStop(0.5, '#d40485dd');\n  skyGradient.addColorStop(0.71, '#fd9554ee');\n  skyGradient.addColorStop(1.0, '#000000ee');\n\n  function renderSky() {\n    ctx.fillStyle = skyGradient;\n    ctx.fillRect(0, 0, width, height / 4 * 3);\n  }\n\n  const maxGridWidth = 64;\n  const minGridWidth = 4;\n  const gridWidth = Math.max(minGridWidth, Math.min((width / 16) | 0, maxGridWidth));\n  const maxGridHeight = 64;\n  const minGridHeight = 32;\n  const gridHeight = Math.max(minGridHeight, Math.min((height / 16) | 0, maxGridHeight));\n\n  const grid = new Grid2D(gridWidth, gridHeight, 3);\n\n  function updateTerrain(t: number) {\n    const gridPoint = vec3.create();\n    iterateGrid2D(grid, (p, x, y, i) => {\n      const speed = 0.02; //2;\n      const terrainOffset = Math.floor(t * speed);\n      const roadWidth = 0.03;\n      const twistynessPeriod = 210;\n      const roadTwistyness = 6 * Math.max(0, Math.sin((y - terrainOffset) / twistynessPeriod));\n      const cornerPeriod = 10;\n      const roadWinding = Math.sin(\n        (y - terrainOffset) / cornerPeriod\n      ) * roadTwistyness;\n      const road = Math.max(\n        roadWidth - 1,\n        -Math.cos(((x + roadWinding) / grid.width - 0.5) * Math.PI * 2)\n      ) + 1;\n      const noiseScale = 0.15;\n      const hillinessPeriod = 220;\n      const hilliness = Math.abs(Math.sin((y - terrainOffset) / hillinessPeriod));\n      const mountainHeight = 5;\n      const mountainOffset = 2;\n      const mountains = mountainOffset + noise2D(x * noiseScale, (y - terrainOffset) * noiseScale) * mountainHeight * hilliness;\n      const elevation = road * mountains;\n      vec3.set(gridPoint,\n        -grid.width / 2 + x,\n        -5 + elevation,\n        5 + (grid.height - y) - t * speed % 1\n      );\n      vec3.transformMat4(gridPoint, gridPoint, projectionMatrix);\n      // convert from ndc to pixel coordinates\n      gridPoint[0] = (1 + gridPoint[0]) / 2 * width;\n      gridPoint[1] = (1 + gridPoint[1]) / 2 * height;\n      p[i] = gridPoint[0];\n      p[i + 1] = gridPoint[1];\n      p[i + 2] = (grid.height - y + (terrainOffset % 1)) / grid.height;\n    });\n  }\n\n  const projectionMatrix = mat4.perspective(mat4.create(), 45, width / height, 0.1, 200);\n  function drawGrid2D() {\n    const { width: gridWidth, height: gridHeight, points, components: gridComponents } = grid;\n\n    function index(x: number, y: number) {\n      return (y * gridWidth + x) * gridComponents;\n    }\n\n    function moveTo(x: number, y: number) {\n      const i = index(x, y);\n      // Not quite sure why but rounding here saves ~2ms/frame\n      ctx.moveTo(points[i], points[i + 1]);\n    }\n\n    function lineTo(x: number, y: number) {\n      const i = index(x, y);\n      ctx.lineTo(points[i], points[i + 1]);\n    }\n\n    function isInvisible(x: number, y: number) {\n      const vertices = [\n        index(x, y),\n        index(x + 1, y),\n        index(x + 1, y + 1),\n        index(x, y + 1),\n      ];\n\n      // not on screen\n      if (\n        !vertices.some(v => points[v] >= 0) ||\n        !vertices.some(v => points[v] <= width) ||\n        !vertices.some(v => points[v + 1] >= 0) ||\n        !vertices.some(v => points[v + 1] <= height)\n      ) {\n        return true;\n      }\n\n\n      const ax = points[vertices[1]] - points[vertices[0]];\n      const ay = -points[vertices[1] + 1] - -points[vertices[0] + 1];\n      const bx = points[vertices[3]] - points[vertices[0]];\n      const by = -points[vertices[3] + 1] - -points[vertices[0] + 1];\n      const cx = points[vertices[2]] - points[vertices[0]];\n      const cy = -points[vertices[2] + 1] - -points[vertices[0] + 1];\n\n      const magnitudeACrossB = (ax * by) - (ay * bx);\n      const magnitudeACrossC = (ax * cy) - (ay * cx);\n\n      if (magnitudeACrossB < 0 && magnitudeACrossC < 0) return true;\n\n      return false;\n    }\n\n    ctx.strokeStyle = 'purple';\n    ctx.fillStyle = '#03020afa';\n\n    for (let y = 0; y < gridHeight - 1; y++) {\n      const z = points[index(0, y) + 2];\n      const fadeDistance = 0.8;\n      ctx.globalAlpha = 1 - Math.max(0, z - fadeDistance) * (1 / (1 - fadeDistance));\n      for (let x = 0; x < gridWidth - 1; x++) {\n        // culling quads in javascript seems to be worth it\n        if (isInvisible(x, y)) {\n          continue;\n        }\n\n        // drawing each rect individually is faster and avoids self intersection issues\n        ctx.beginPath();\n        moveTo(x, y);\n        lineTo(x + 1, y);\n        lineTo(x + 1, y + 1);\n        lineTo(x, y + 1);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n      }\n    }\n  }\n\n  return function render(t: number) {\n    renderSky();\n\n    updateTerrain(t);\n\n    drawGrid2D();\n  };\n}\n\n\n'simplex-noise-demo-synthwave/main.ts'\n:\nimport { volumeControls } from './volumeControls';\nimport { renderer } from './renderer';\n\n\nlet freezeTime = 0;\n\nfunction hashchange() {\n  const freezeMatch = location.hash.match(/freeze=(\\d+)/);\n  freezeTime = freezeMatch ? +freezeMatch[1] * 1000 : 0;\n}\nwindow.addEventListener('hashchange', hashchange);\nhashchange();\n\n\nfunction mainloop(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n  function createRenderer() {\n    const canvasRect = canvas.getBoundingClientRect();\n    canvas.width = Math.max(canvasRect.width, window.innerWidth) | 0;\n    canvas.height = Math.max(canvasRect.height, window.innerHeight) | 0;\n\n    return renderer(ctx, canvas.width, canvas.height);\n  }\n\n  let render = createRenderer();\n\n  window.addEventListener('resize', () => {\n    render = createRenderer();\n  });\n\n  const start = performance.now();\n\n  function tick() {\n    const t = freezeTime ? freezeTime : performance.now() - start;\n    render(t);\n    requestAnimationFrame(tick);\n  }\n  requestAnimationFrame(tick);\n}\n\nconst canvas = document.getElementById('canvas');\nif (!(canvas instanceof HTMLCanvasElement)) throw new Error('c is not a canvas');\n\nconst ctx = canvas.getContext('2d', { alpha: false });\nif (ctx === null) throw new Error('canvas does not support context 2d');\n\nmainloop(canvas, ctx);\n\nconst music = document.getElementById('music');\nif (!(music instanceof HTMLAudioElement)) throw new Error('music is not audio');\nconst volume = document.getElementById('volume');\nif (!(volume instanceof HTMLDivElement)) throw new Error('volume is not div');\n\nvolumeControls(\n  music,\n  volume\n);\n",
        "called_code_segment_file_1": "export function renderer(ctx: CanvasRenderingContext2D, width: number, height: number): Render { ... }",
        "invoking_code_segment_file_2": "let render = createRenderer();\n\nwindow.addEventListener('resize', () => {\n  render = createRenderer();\n});",
        "invoking_code_segment_file_3": "function mainloop(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n  function createRenderer() {\n    const canvasRect = canvas.getBoundingClientRect();\n    canvas.width = Math.max(canvasRect.width, window.innerWidth) | 0;\n    canvas.height = Math.max(canvasRect.height, window.innerHeight) | 0;\n\n    return renderer(ctx, canvas.width, canvas.height);\n  }\n\n  let render = createRenderer();\n\n  window.addEventListener('resize', () => {\n    render = createRenderer();\n  });\n\n  const start = performance.now();\n\n  function tick() {\n    const t = freezeTime ? freezeTime : performance.now() - start;\n    render(t);\n    requestAnimationFrame(tick);\n  }\n  requestAnimationFrame(tick);\n}",
        "new_file_code_segment": "export function addSnowEffect(ctx: CanvasRenderingContext2D, width: number, height: number, t: number) {\n  ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';\n  ctx.beginPath();\n  for (let i = 0; i < 100; i++) {\n    const x = Math.random() * width;\n    const y = Math.random() * height;\n    const size = Math.random() * 2;\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, size, 0, Math.PI * 2);\n  }\n  ctx.fill();\n}",
        "feature_description": "Add a snow effect to the scene.",
        "detailed_feature_description": "The new feature adds a snow effect to the scene by creating a function in #file 4 that draws random snowflakes on the canvas. This function is then invoked in #file 1 within the render function to apply the snow effect during each frame update. The snow effect is integrated into the existing rendering pipeline, ensuring compatibility with the current rendering logic.",
        "modified_complete_code": {
            "file_1": "import { addSnowEffect } from './snowEffect'; //New\n\nexport function renderer(ctx: CanvasRenderingContext2D, width: number, height: number): Render {\n  const skyGradient = ctx.createLinearGradient(0, 0, 0, height / 4 * 3);\n  skyGradient.addColorStop(0.0, '#1c014add');\n  skyGradient.addColorStop(0.5, '#d40485dd');\n  skyGradient.addColorStop(0.71, '#fd9554ee');\n  skyGradient.addColorStop(1.0, '#000000ee');\n\n  function renderSky() {\n    ctx.fillStyle = skyGradient;\n    ctx.fillRect(0, 0, width, height / 4 * 3);\n  }\n\n  const maxGridWidth = 64;\n  const minGridWidth = 4;\n  const gridWidth = Math.max(minGridWidth, Math.min((width / 16) | 0, maxGridWidth));\n  const maxGridHeight = 64;\n  const minGridHeight = 32;\n  const gridHeight = Math.max(minGridHeight, Math.min((height / 16) | 0, maxGridHeight));\n\n  const grid = new Grid2D(gridWidth, gridHeight, 3);\n\n  function updateTerrain(t: number) {\n    const gridPoint = vec3.create();\n    iterateGrid2D(grid, (p, x, y, i) => {\n      const speed = 0.02;\n      const terrainOffset = Math.floor(t * speed);\n      const roadWidth = 0.03;\n      const twistynessPeriod = 210;\n      const roadTwistyness = 6 * Math.max(0, Math.sin((y - terrainOffset) / twistynessPeriod));\n      const cornerPeriod = 10;\n      const roadWinding = Math.sin(\n        (y - terrainOffset) / cornerPeriod\n      ) * roadTwistyness;\n      const road = Math.max(\n        roadWidth - 1,\n        -Math.cos(((x + roadWinding) / grid.width - 0.5) * Math.PI * 2)\n      ) + 1;\n      const noiseScale = 0.15;\n      const hillinessPeriod = 220;\n      const hilliness = Math.abs(Math.sin((y - terrainOffset) / hillinessPeriod));\n      const mountainHeight = 5;\n      const mountainOffset = 2;\n      const mountains = mountainOffset + noise2D(x * noiseScale, (y - terrainOffset) * noiseScale) * mountainHeight * hilliness;\n      const elevation = road * mountains;\n      vec3.set(gridPoint,\n        -grid.width / 2 + x,\n        -5 + elevation,\n        5 + (grid.height - y) - t * speed % 1\n      );\n      vec3.transformMat4(gridPoint, gridPoint, projectionMatrix);\n      gridPoint[0] = (1 + gridPoint[0]) / 2 * width;\n      gridPoint[1] = (1 + gridPoint[1]) / 2 * height;\n      p[i] = gridPoint[0];\n      p[i + 1] = gridPoint[1];\n      p[i + 2] = (grid.height - y + (terrainOffset % 1)) / grid.height;\n    });\n  }\n\n  const projectionMatrix = mat4.perspective(mat4.create(), 45, width / height, 0.1, 200);\n  function drawGrid2D() {\n    const { width: gridWidth, height: gridHeight, points, components: gridComponents } = grid;\n\n    function index(x: number, y: number) {\n      return (y * gridWidth + x) * gridComponents;\n    }\n\n    function moveTo(x: number, y: number) {\n      const i = index(x, y);\n      ctx.moveTo(points[i], points[i + 1]);\n    }\n\n    function lineTo(x: number, y: number) {\n      const i = index(x, y);\n      ctx.lineTo(points[i], points[i + 1]);\n    }\n\n    function isInvisible(x: number, y: number) {\n      const vertices = [\n        index(x, y),\n        index(x + 1, y),\n        index(x + 1, y + 1),\n        index(x, y + 1),\n      ];\n\n      if (\n        !vertices.some(v => points[v] >= 0) ||\n        !vertices.some(v => points[v] <= width) ||\n        !vertices.some(v => points[v + 1] >= 0) ||\n        !vertices.some(v => points[v + 1] <= height)\n      ) {\n        return true;\n      }\n\n      const ax = points[vertices[1]] - points[vertices[0]];\n      const ay = -points[vertices[1] + 1] - -points[vertices[0] + 1];\n      const bx = points[vertices[3]] - points[vertices[0]];\n      const by = -points[vertices[3] + 1] - -points[vertices[0] + 1];\n      const cx = points[vertices[2]] - points[vertices[0]];\n      const cy = -points[vertices[2] + 1] - -points[vertices[0] + 1];\n\n      const magnitudeACrossB = (ax * by) - (ay * bx);\n      const magnitudeACrossC = (ax * cy) - (ay * cx);\n\n      if (magnitudeACrossB < 0 && magnitudeACrossC < 0) return true;\n\n      return false;\n    }\n\n    ctx.strokeStyle = 'purple';\n    ctx.fillStyle = '#03020afa';\n\n    for (let y = 0; y < gridHeight - 1; y++) {\n      const z = points[index(0, y) + 2];\n      const fadeDistance = 0.8;\n      ctx.globalAlpha = 1 - Math.max(0, z - fadeDistance) * (1 / (1 - fadeDistance));\n      for (let x = 0; x < gridWidth - 1; x++) {\n        if (isInvisible(x, y)) {\n          continue;\n        }\n\n        ctx.beginPath();\n        moveTo(x, y);\n        lineTo(x + 1, y);\n        lineTo(x + 1, y + 1);\n        lineTo(x, y + 1);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n      }\n    }\n  }\n\n  return function render(t: number) {\n    renderSky();\n\n    updateTerrain(t);\n\n    drawGrid2D();\n\n    addSnowEffect(ctx, width, height, t); //New\n  };\n}",
            "file_2": "import { renderer } from './renderer'; //Modify\nimport { addSnowEffect } from './snowEffect'; //New\n\nfunction mainloop(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n  function createRenderer() {\n    const canvasRect = canvas.getBoundingClientRect();\n    canvas.width = Math.max(canvasRect.width, window.innerWidth) | 0;\n    canvas.height = Math.max(canvasRect.height, window.innerHeight) | 0;\n\n    return renderer(ctx, canvas.width, canvas.height);\n  }\n\n  let render = createRenderer();\n\n  window.addEventListener('resize', () => {\n    render = createRenderer();\n  });\n\n  const start = performance.now();\n\n  function tick() {\n    const t = freezeTime ? freezeTime : performance.now() - start;\n    render(t);\n    requestAnimationFrame(tick);\n  }\n  requestAnimationFrame(tick);\n}",
            "file_3": "import { volumeControls } from './volumeControls'; //Modify\nimport { renderer } from './renderer'; //Modify\nimport { addSnowEffect } from './snowEffect'; //New\n\nlet freezeTime = 0;\n\nfunction hashchange() {\n  const freezeMatch = location.hash.match(/freeze=(d+)/);\n  freezeTime = freezeMatch ? +freezeMatch[1] * 1000 : 0;\n}\nwindow.addEventListener('hashchange', hashchange);\nhashchange();\n\nfunction mainloop(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) {\n  function createRenderer() {\n    const canvasRect = canvas.getBoundingClientRect();\n    canvas.width = Math.max(canvasRect.width, window.innerWidth) | 0;\n    canvas.height = Math.max(canvasRect.height, window.innerHeight) | 0;\n\n    return renderer(ctx, canvas.width, canvas.height);\n  }\n\n  let render = createRenderer();\n\n  window.addEventListener('resize', () => {\n    render = createRenderer();\n  });\n\n  const start = performance.now();\n\n  function tick() {\n    const t = freezeTime ? freezeTime : performance.now() - start;\n    render(t);\n    requestAnimationFrame(tick);\n  }\n  requestAnimationFrame(tick);\n}\n\nconst canvas = document.getElementById('canvas');\nif (!(canvas instanceof HTMLCanvasElement)) throw new Error('c is not a canvas');\n\nconst ctx = canvas.getContext('2d', { alpha: false });\nif (ctx === null) throw new Error('canvas does not support context 2d');\n\nmainloop(canvas, ctx);\n\nconst music = document.getElementById('music');\nif (!(music instanceof HTMLAudioElement)) throw new Error('music is not audio');\nconst volume = document.getElementById('volume');\nif (!(volume instanceof HTMLDivElement)) throw new Error('volume is not div');\n\nvolumeControls(\n  music,\n  volume\n);",
            "file_4": "export function addSnowEffect(ctx: CanvasRenderingContext2D, width: number, height: number, t: number) {\n  ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';\n  ctx.beginPath();\n  for (let i = 0; i < 100; i++) {\n    const x = Math.random() * width;\n    const y = Math.random() * height;\n    const size = Math.random() * 2;\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, size, 0, Math.PI * 2);\n  }\n  ctx.fill();\n}"
        }
    },
    {
        "repo": "stromjs",
        "content": "'stromjs/src/functions/baseDefinitions.ts'\n:export interface WithEncoding {\n    encoding: BufferEncoding;\n}\n\nexport enum SerializationFormats {\n    utf8 = \"utf8\",\n}\n\ntype JsonPrimitive = string | number | object;\nexport type JsonValue = JsonPrimitive | JsonPrimitive[];\n\nexport interface JsonParseOptions {\n    pretty: boolean;\n}\n\n'stromjs/src/functions/stringify.ts'\n:import { Transform } from \"stream\";\nimport { JsonValue, JsonParseOptions } from \"./baseDefinitions\";\n\nexport function stringify(\n    options: JsonParseOptions = { pretty: false },\n): Transform {\n    return new Transform({\n        readableObjectMode: true,\n        writableObjectMode: true,\n        transform(chunk: JsonValue, encoding, callback) {\n            callback(\n                undefined,\n                options.pretty\n                    ? JSON.stringify(chunk, null, 2)\n                    : JSON.stringify(chunk),\n            );\n        },\n    });\n}\n\n'stromjs/src/functions/index.ts'\n:import { TransformOptions } from \"stream\";\nimport { accumulator, accumulatorBy } from \"./accumulator\";\nimport { batch } from \"./batch\";\nimport { child } from \"./child\";\nimport { collect } from \"./collect\";\nimport { concat } from \"./concat\";\nimport { duplex } from \"./duplex\";\nimport { filter } from \"./filter\";\nimport { flatMap } from \"./flatMap\";\nimport { fromArray } from \"./fromArray\";\nimport { join } from \"./join\";\nimport { last } from \"./last\";\nimport { map } from \"./map\";\nimport { merge } from \"./merge\";\nimport { parallelMap } from \"./parallelMap\";\nimport { parse } from \"./parse\";\nimport { rate } from \"./rate\";\nimport { reduce } from \"./reduce\";\nimport { replace } from \"./replace\";\nimport { split } from \"./split\";\nimport { stringify } from \"./stringify\";\nimport { unbatch } from \"./unbatch\";\nimport { compose } from \"./compose\";\nimport { demux } from \"./demux\";\n\nexport function strom(defaultOptions: TransformOptions = { objectMode: true }) {\n    function withDefaultOptions<T extends any[], R>(\n        n: number,\n        fn: (...args: T) => R,\n    ): (...args: T) => R {\n        return (...args) => {\n            const options = {\n                ...defaultOptions,\n                ...((args[n] || {}) as TransformOptions | {}),\n            };\n            const provided = args.slice(0, n);\n            const nextArgs = [\n                ...provided,\n                ...Array(n - provided.length).fill(undefined),\n                options,\n            ] as T;\n            return fn(...nextArgs) as R;\n        };\n    }\n\n    return {\n        /**\n         * Convert an array into a Readable stream of its elements\n         * @param array Array of elements to stream\n         */\n        fromArray,\n\n        /**\n         * Return a ReadWrite stream that maps streamed chunks\n         * @param mapper Mapper function, mapping each (chunk, encoding) to a new chunk (or a promise of such)\n         * @param options?\n         * @param options.readableObjectMode? Whether this stream should behave as a readable stream of objects\n         * @param options.writableObjectMode? Whether this stream should behave as a writable stream of objects\n         */\n        map: withDefaultOptions(1, map),\n\n        /**\n         * Return a ReadWrite stream that flat maps streamed chunks\n         * @param mapper Mapper function, mapping each (chunk, encoding) to an array of new chunks (or a promise of such)\n         * @param options?\n         * @param options.readableObjectMode? Whether this stream should behave as a readable stream of objects\n         * @param options.writableObjectMode? Whether this stream should behave as a writable stream of objects\n         */\n        flatMap: withDefaultOptions(1, flatMap),\n\n        /**\n         * Return a ReadWrite stream that filters out streamed chunks for which the predicate does not hold\n         * @param predicate Predicate with which to filter scream chunks\n         * @param options?\n         * @param options.objectMode? Whether this stream should behave as a stream of objects.\n         */\n        filter: withDefaultOptions(1, filter),\n\n        /**\n         * Return a ReadWrite stream that reduces streamed chunks down to a single value and yield that\n         * value\n         * @param iteratee Reducer function to apply on each streamed chunk\n         * @param initialValue Initial value\n         * @param options?\n         * @param options.readableObjectMode? Whether this stream should behave as a readable stream of objects\n         * @param options.writableObjectMode? Whether this stream should behave as a writable stream of objects\n         */\n        reduce: withDefaultOptions(2, reduce),\n\n        /**\n         * Return a ReadWrite stream that splits streamed chunks using the given separator\n         * @param separator? Separator to split by, defaulting to \"\\n\"\n         * @param options? Defaults to encoding: utf8\n         * @param options.encoding? Encoding written chunks are assumed to use\n         */\n        split,\n\n        /**\n         * Return a ReadWrite stream that joins streamed chunks using the given separator\n         * @param separator Separator to join with\n         * @param options? Defaults to encoding: utf8\n         * @param options.encoding? Encoding written chunks are assumed to use\n         */\n        join: withDefaultOptions(1, join),\n\n        /**\n         * Return a ReadWrite stream that replaces occurrences of the given string or regular expression  in\n         * the streamed chunks with the specified replacement string\n         * @param searchValue Search string to use\n         * @param replaceValue Replacement string to use\n         * @param options? Defaults to encoding: utf8\n         * @param options.encoding Encoding written chunks are assumed to use\n         */\n        replace,\n\n        /**\n         * Return a ReadWrite stream that parses the streamed chunks as JSON. Each streamed chunk\n         * must be a fully defined JSON string in utf8.\n         * @param format: @type SerializationFormats defaults SerializationFormats.utf8\n         * @param emitError: @type boolean Whether or not to emit an error when\n         * failing to parse. An error will automatically close the stream.\n         * Defaults to true.\n         */\n        parse,\n\n        /**\n         * Return a ReadWrite stream that stringifies the streamed chunks to JSON\n         * @param options?\n         * @param options.pretty If true, whitespace is inserted into the stringified chunks.\n         *\n         */\n        stringify,\n\n        /**\n         * Return a ReadWrite stream that collects streamed chunks into an array or buffer\n         * @param options?\n         * @param options.objectMode? Whether this stream should behave as a stream of objects\n         */\n        collect: withDefaultOptions(0, collect),\n\n        /**\n         * Return a Readable stream of readable streams concatenated together\n         * @param streams Readable streams to concatenate\n         */\n        concat,\n\n        /**\n         * Return a Readable stream of readable streams concatenated together\n         * @param streams Readable streams to merge\n         */\n        merge,\n\n        /**\n         * Return a Duplex stream from a writable stream that is assumed to somehow, when written to,\n         * cause the given readable stream to yield chunks\n         * @param writable Writable stream assumed to cause the readable stream to yield chunks when written to\n         * @param readable Readable stream assumed to yield chunks when the writable stream is written to\n         */\n        duplex,\n\n        /**\n         * Return a Duplex stream from a child process' stdin and stdout\n         * @param childProcess Child process from which to create duplex stream\n         */\n        child,\n\n        /**\n         * Return a Promise resolving to the last streamed chunk of the given readable stream, after it has\n         * ended\n         * @param readable Readable stream to wait on\n         */\n        last,\n\n        /**\n         * Stores chunks of data internally in array and batches when batchSize is reached.\n         * @param batchSize Size of the batches, defaults to 1000.\n         * @param maxBatchAge? Max lifetime of a batch, defaults to 500\n         * @param options?\n         * @param options.objectMode? Whether this stream should behave as a stream of objects\n         */\n        batch: withDefaultOptions(2, batch),\n\n        /**\n         * Unbatches and sends individual chunks of data.\n         * @param options?\n         * @param options.objectMode? Whether this stream should behave as a stream of objects\n         */\n        unbatch: withDefaultOptions(0, unbatch),\n\n        /**\n         * Limits rate of data transferred into stream.\n         * @param targetRate? Desired rate in ms.\n         * @param period? Period to sleep for when rate is above or equal to targetRate.\n         * @param options?\n         */\n        rate: withDefaultOptions(2, rate),\n\n        /**\n         * Limits number of parallel processes in flight.\n         * @param parallel Max number of parallel processes.\n         * @param func Function to execute on each data chunk.\n         * @param pause Amount of time to pause processing when max number of parallel processes are executing.\n         */\n        parallelMap: withDefaultOptions(3, parallelMap),\n\n        /**\n         * Accummulates and sends batches of data. Each chunk that flows into the stream is checked against items\n         * in the buffer. How the buffer is mutated is based on 1 of 2 possible buffering strategies:\n         * \t1. Sliding\n         * \t\t- If the buffer is larger than the batchSize, the front of the buffer is popped to maintain\n         * \t\tthe batchSize. When no key is provided, the batchSize is effectively the buffer length. When\n         * \t\ta key is provided, the batchSize is based on the value at that key. For example, given a key\n         * \t\tof `timestamp` and a batchSize of 3000, each item in the buffer will be guaranteed to be\n         * \t\twithin 3000 timestamp units from the first element. This means that with a key, multiple elements\n         * \t\tmay be spliced off the front of the buffer. The buffer is then pushed into the stream.\n         * \t2. Rolling\n         * \t\t- If the buffer is larger than the batchSize, the buffer is cleared and pushed into the stream.\n         * \t\tWhen no key is provided, the batchSize is the buffer length. When a key is provided, the batchSize\n         * \t\tis based on the value at that key. For example, given a key of `timestamp` and a batchSize of 3000,\n         * \t\teach item in the buffer will be guaranteed to be within 3000 timestamp units from the first element.\n         * @param flushStrategy Buffering strategy to use.\n         * @param batchSize Size of the batch (in units of buffer length or value at key).\n         * @param keyBy Key to determine if element fits into buffer or items need to be cleared from buffer.\n         * @param options Transform stream options\n         */\n        accumulator: withDefaultOptions(3, accumulator),\n\n        /**\n         * Accummulates and sends batches of data. Each chunk that flows into the stream is checked against items\n         * in the buffer. How the buffer is mutated is based on 1 of 2 possible buffering strategies:\n         * \t1. Sliding\n         * \t\t- If the iteratee returns false, the front of the buffer is popped until iteratee returns true. The\n         * \t\titem is pushed into the buffer and buffer is pushed into stream.\n         * \t2. Rolling\n         * \t\t- If the iteratee returns false, the buffer is cleared and pushed into stream. The item is\n         * \t\tthen pushed into the buffer.\n         * @param flushStrategy Buffering strategy to use.\n         * @param iteratee Function applied to buffer when a chunk of data enters stream to determine if element fits into\n         * or items need to be cleared from buffer.\n         * @param options Transform stream options\n         */\n        accumulatorBy: withDefaultOptions(2, accumulatorBy),\n\n        /**\n         * Composes multiple streams together. Writing occurs on first stream, piping occurs from last stream.\n         * @param streams Array of streams to compose. Minimum of two.\n         * @param errorCallback a function that handles any error coming out of the pipeline\n         * @param options Transform stream options\n         */\n        compose: withDefaultOptions(2, compose),\n\n        /**\n         * Composes multiple streams together. Writing occurs on first stream, piping occurs from last stream.\n         * @param construct Constructor for new output source. Should return a Writable or ReadWrite stream.\n         * @param demuxBy\n         * @param demuxBy.key? Key to fetch value from source chunks to demultiplex source.\n         * @param demuxBy.keyBy? Function to fetch value from source chunks to demultiplex source.\n         * @param options Writable stream options\n         */\n        demux: withDefaultOptions(2, demux),\n\n        /**\n         * Create a new strom instance overriding the defaults\n         */\n        instance: strom,\n    };\n}\n\n",
        "called_code_segment_file_1": "export function stringify(\n    options: JsonParseOptions = { pretty: false },\n): Transform {\n    return new Transform({\n        readableObjectMode: true,\n        writableObjectMode: true,\n        transform(chunk: JsonValue, encoding, callback) {\n            callback(\n                undefined,\n                options.pretty\n                    ? JSON.stringify(chunk, null, 2)\n                    : JSON.stringify(chunk),\n            );\n        },\n    });\n}",
        "invoking_code_segment_file_2": "stringify,\n\n/**\n * Return a ReadWrite stream that stringifies the streamed chunks to JSON\n * @param options?\n * @param options.pretty If true, whitespace is inserted into the stringified chunks.\n */\nstringify,",
        "invoking_code_segment_file_3": "import { stringify } from \"./stringify\";\n\n// Example usage in a function\nconst jsonStream = readableStream.pipe(stringify({ pretty: true }));",
        "new_file_code_segment": "export function stringifyWithIndentation(\n    options: JsonParseOptions = { pretty: false, indent: 4 },\n): Transform {\n    return new Transform({\n        readableObjectMode: true,\n        writableObjectMode: true,\n        transform(chunk: JsonValue, encoding, callback) {\n            callback(\n                undefined,\n                options.pretty\n                    ? JSON.stringify(chunk, null, options.indent)\n                    : JSON.stringify(chunk),\n            );\n        },\n    });\n}",
        "feature_description": "Add an option to customize the indentation level when stringifying JSON.",
        "detailed_feature_description": "The new feature allows users to specify the indentation level when stringifying JSON objects. This is implemented by adding an 'indent' option to the stringify function. The new functionality is encapsulated in a new file (#file 4) and is invoked in #file 1 where the stringify function is defined. The existing stringify function in #file 1 is modified to call the new function from #file 4, ensuring backward compatibility. #file 2 and #file 3 are updated to handle the new feature by passing the 'indent' option when needed.",
        "modified_complete_code": {
            "#file 1": "import { Transform } from \"stream\";\nimport { JsonValue, JsonParseOptions } from \"./baseDefinitions\";\nimport { stringifyWithIndentation } from \"./stringifyWithIndentation\"; //New\n\n#Modify export function stringify(\n    options: JsonParseOptions = { pretty: false },\n): Transform {\n    return stringifyWithIndentation({ ...options, indent: 2 });\n}",
            "#file 2": "import { stringify } from \"./stringify\";\nimport { stringifyWithIndentation } from \"./stringifyWithIndentation\"; //New\n\nstringify,\n\n/**\n * Return a ReadWrite stream that stringifies the streamed chunks to JSON\n * @param options?\n * @param options.pretty If true, whitespace is inserted into the stringified chunks.\n * @param options.indent If specified, custom indentation level is used.\n */\nstringifyWithIndentation, //New",
            "#file 3": "import { stringify } from \"./stringify\";\nimport { stringifyWithIndentation } from \"./stringifyWithIndentation\"; //New\n\n// Example usage in a function\nconst jsonStream = readableStream.pipe(stringify({ pretty: true }));\nconst jsonStreamWithIndent = readableStream.pipe(stringifyWithIndentation({ pretty: true, indent: 4 })); //New",
            "#file 4": "import { Transform } from \"stream\";\nimport { JsonValue, JsonParseOptions } from \"./baseDefinitions\";\n\nexport function stringifyWithIndentation(\n    options: JsonParseOptions = { pretty: false, indent: 2 },\n): Transform {\n    return new Transform({\n        readableObjectMode: true,\n        writableObjectMode: true,\n        transform(chunk: JsonValue, encoding, callback) {\n            callback(\n                undefined,\n                options.pretty\n                    ? JSON.stringify(chunk, null, options.indent)\n                    : JSON.stringify(chunk),\n            );\n        },\n    });\n}"
        }
    },
    {
        "repo": "typescript-paths",
        "content": "'typescript-paths/packages/typescript-paths/src/logger.ts'\n:export enum LogLevel {\n\tNone,\n\tError,\n\tWarning,\n\tInfo,\n\tDebug,\n\tTrace,\n}\n\nexport type LogLevelString = \"none\" | \"error\" | \"warn\" | \"info\" | \"debug\" | \"trace\"\n\nexport function convertLogLevel(level?: LogLevelString) {\n\tswitch (level) {\n\t\tcase \"none\":\n\t\t\treturn LogLevel.None\n\t\tcase \"error\":\n\t\t\treturn LogLevel.Error\n\t\tcase \"warn\":\n\t\t\treturn LogLevel.Warning\n\t\tcase \"info\":\n\t\t\treturn LogLevel.Info\n\t\tcase \"debug\":\n\t\t\treturn LogLevel.Debug\n\t\tcase \"trace\":\n\t\t\treturn LogLevel.Trace\n\t\tdefault:\n\t\t\treturn undefined\n\t}\n}\n\ninterface Options {\n\tlogLevel: LogLevel\n\tcolors?: boolean\n\tID?: string\n}\n\nexport interface LogFunc {\n\t(level: LogLevel, ...args: any[]): void\n}\n\nconst Reset = \"\\x1b[0m\"\nconst FgRed = \"\\x1b[31m\"\nconst FgYellow = \"\\x1b[33m\"\nconst FgBlue = \"\\x1b[34m\"\nconst FgCyan = \"\\x1b[36m\"\nconst FgMagenta = \"\\x1b[35m\"\n\nexport function fromTYPESCRIPT_PATHS_LOG_LEVEL() {\n\tconst env = process.env[\"TYPESCRIPT_PATHS_LOG_LEVEL\"]\n\tswitch (env) {\n\t\tcase \"none\":\n\t\t\treturn LogLevel.None\n\t\tcase \"error\":\n\t\t\treturn LogLevel.Error\n\t\tcase \"warn\":\n\t\t\treturn LogLevel.Warning\n\t\tcase \"info\":\n\t\t\treturn LogLevel.Info\n\t\tcase \"debug\":\n\t\t\treturn LogLevel.Debug\n\t\tcase \"trace\":\n\t\t\treturn LogLevel.Trace\n\t\tdefault:\n\t\t\treturn undefined\n\t}\n}\n\nexport function createLogger({\n\tlogLevel = fromTYPESCRIPT_PATHS_LOG_LEVEL() || LogLevel.Info,\n\tcolors = true,\n\tID = \"typescript-paths\",\n}: Partial<Options> = {}): LogFunc {\n\treturn function log(level, ...args) {\n\t\tif (logLevel < level) {\n\t\t\treturn\n\t\t}\n\t\tif (ID) {\n\t\t\targs.unshift(`[${ID}]:`)\n\t\t}\n\t\tif (colors) {\n\t\t\targs = args.map(a => {\n\t\t\t\tif (typeof a !== \"string\") return a\n\t\t\t\tswitch (level) {\n\t\t\t\t\tcase LogLevel.Error:\n\t\t\t\t\t\treturn FgRed + a + Reset\n\t\t\t\t\tcase LogLevel.Warning:\n\t\t\t\t\t\treturn FgYellow + a + Reset\n\t\t\t\t\tcase LogLevel.Info:\n\t\t\t\t\t\treturn FgBlue + a + Reset\n\t\t\t\t\tcase LogLevel.Debug:\n\t\t\t\t\t\treturn FgCyan + a + Reset\n\t\t\t\t\tcase LogLevel.Trace:\n\t\t\t\t\t\treturn FgMagenta + a + Reset\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t\tswitch (level) {\n\t\t\tcase LogLevel.Error:\n\t\t\t\tconsole.error(...args)\n\t\t\t\tbreak\n\t\t\tcase LogLevel.Warning:\n\t\t\t\tconsole.warn(...args)\n\t\t\t\tbreak\n\t\t\tcase LogLevel.Info:\n\t\t\t\tconsole.info(...args)\n\t\t\t\tbreak\n\t\t\tcase LogLevel.Debug:\n\t\t\t\tconsole.log(...args)\n\t\t\t\tbreak\n\t\t\tcase LogLevel.Trace:\n\t\t\t\tconsole.log(...args)\n\t\t\t\tbreak\n\t\t}\n\t}\n}\n\n'typescript-paths/packages/typescript-paths/src/paths.ts'\n:import fs from \"fs\"\nimport { builtinModules } from \"module\"\nimport path from \"path\"\nimport ts from \"typescript\"\nimport { createLogger, LogFunc, LogLevel } from \"./logger\"\n\nexport interface Mapping {\n\tpattern: string\n\tprefix: string\n\tsuffix: string\n\twildcard: boolean\n\ttargets: string[]\n}\n\nexport interface TsConfigPayload {\n\tfilePath?: string\n\tcompilerOptions: ts.CompilerOptions\n\tfileNames: string[]\n\treferences?: TsConfigPayload[]\n\textends?: string\n}\n\nexport function getTsConfig({\n\ttsConfigPath,\n\tlog = createLogger(),\n\thost = ts.sys,\n}: {\n\ttsConfigPath: string\n\tlog?: LogFunc\n\thost?: ts.ParseConfigHost\n}): undefined | TsConfigPayload {\n\tconst { error, config } = ts.readConfigFile(tsConfigPath, host.readFile)\n\tif (error) {\n\t\tlet hasError = false\n\t\tswitch (error.category) {\n\t\t\tcase ts.DiagnosticCategory.Error:\n\t\t\t\tlog(LogLevel.Error, error.messageText)\n\t\t\t\thasError = true\n\t\t\t\tbreak\n\t\t}\n\t\tif (hasError) return undefined\n\t}\n\n\tlet {\n\t\toptions: compilerOptions,\n\t\terrors,\n\t\tfileNames,\n\t\tprojectReferences,\n\t} = ts.parseJsonConfigFileContent(config, host, path.resolve(path.dirname(tsConfigPath)))\n\tif (errors.length > 0) {\n\t\tlet hasError = false\n\t\tfor (const error of errors) {\n\t\t\tswitch (error.category) {\n\t\t\t\tcase ts.DiagnosticCategory.Error:\n\t\t\t\t\tlog(LogLevel.Error, error.messageText)\n\t\t\t\t\thasError = true\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (hasError) return undefined\n\t}\n\n\tconst ret: TsConfigPayload = {\n\t\tfilePath: path.resolve(tsConfigPath),\n\t\tcompilerOptions,\n\t\tfileNames: fileNames.map(path.normalize),\n\t\textends: config.extends,\n\t}\n\n\tif (projectReferences) {\n\t\tret.references = []\n\t\tfor (const r of projectReferences) {\n\t\t\tlet tsConfigPath = r.path\n\t\t\ttry {\n\t\t\t\tconst stat = fs.lstatSync(tsConfigPath)\n\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\ttsConfigPath = path.join(tsConfigPath, \"tsconfig.json\")\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tconst error = err as Error\n\t\t\t\tlog(LogLevel.Error, error.message)\n\t\t\t\treturn undefined\n\t\t\t}\n\n\t\t\tconst cfg = getTsConfig({ tsConfigPath, log, host })\n\t\t\tif (cfg) ret.references.push(cfg)\n\t\t}\n\t}\n\n\treturn ret\n}\n\nexport function createMappings({\n\tpaths,\n\tlog = createLogger(),\n\trespectCoreModule = true,\n}: {\n\tpaths: ts.MapLike<string[]>\n\tlog?: LogFunc\n\trespectCoreModule?: boolean\n}): Mapping[] {\n\tconst countWildcard = (value: string) => value.match(/\\*/g)?.length ?? 0\n\n\tconst mappings: Mapping[] = []\n\tfor (const pattern of Object.keys(paths)) {\n\t\tif (countWildcard(pattern) > 1) {\n\t\t\tlog(LogLevel.Warning, `Pattern '${pattern}' can have at most one '*' character.`)\n\t\t\tcontinue\n\t\t}\n\t\tconst wildcard = pattern.indexOf(\"*\")\n\t\tif (respectCoreModule) {\n\t\t\tlet skip = false\n\t\t\tfor (const key of builtinModules) {\n\t\t\t\tif (pattern === key || pattern.startsWith(key + \"/\")) {\n\t\t\t\t\tlog(LogLevel.Warning, `path pattern '${pattern}' is ignored.`)\n\t\t\t\t\tlog(LogLevel.Info, `respect core module '${key}'.`)\n\t\t\t\t\tskip = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skip) continue\n\t\t}\n\t\tconst targets = paths[pattern].filter(target => {\n\t\t\tif (countWildcard(target) > 1) {\n\t\t\t\tlog(\n\t\t\t\t\tLogLevel.Warning,\n\t\t\t\t\t`Substitution '${target}' in pattern '${pattern}' can have at most one '*' character.`,\n\t\t\t\t)\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t\tif (targets.length === 0) {\n\t\t\tcontinue\n\t\t}\n\t\tif (pattern === \"*\") {\n\t\t\tmappings.push({ wildcard: true, pattern, prefix: \"\", suffix: \"\", targets })\n\t\t\tcontinue\n\t\t}\n\t\tmappings.push({\n\t\t\twildcard: wildcard !== -1,\n\t\t\tpattern,\n\t\t\tprefix: pattern.substring(0, wildcard),\n\t\t\tsuffix: pattern.substring(wildcard + 1),\n\t\t\ttargets,\n\t\t})\n\t}\n\n\tfor (const mapping of mappings) {\n\t\tlog(LogLevel.Debug, `pattern: '${mapping.pattern}' targets: '${mapping.targets}'`)\n\t}\n\n\treturn mappings\n}\n\nexport function isPatternMatch(prefix: string, suffix: string, candidate: string): boolean {\n\treturn (\n\t\tcandidate.length >= prefix.length + suffix.length && candidate.startsWith(prefix) && candidate.endsWith(suffix)\n\t)\n}\n\nexport function findMatch(moduleName: string, mappings: Mapping[]): Mapping | undefined {\n\tlet longestMatchedPrefixLength = -1\n\tlet matched: Mapping | undefined\n\tfor (const mapping of mappings) {\n\t\tconst { wildcard, prefix, suffix, pattern } = mapping\n\t\tif (wildcard && isPatternMatch(prefix, suffix, moduleName)) {\n\t\t\tif (longestMatchedPrefixLength < prefix.length) {\n\t\t\t\tlongestMatchedPrefixLength = prefix.length\n\t\t\t\tmatched = mapping\n\t\t\t}\n\t\t} else if (moduleName === pattern) {\n\t\t\tmatched = mapping\n\t\t\tbreak\n\t\t}\n\t}\n\treturn matched\n}\n\nexport function resolveModuleName({\n\tmappings,\n\trequest,\n\timporter,\n\tcompilerOptions,\n\thost,\n\tfalllback,\n}: {\n\tcompilerOptions: ts.CompilerOptions\n\tmappings: Mapping[]\n\trequest: string\n\timporter: string\n\thost: ts.ModuleResolutionHost\n\tfalllback?: (moduleName: string) => boolean\n}): string | undefined {\n\tconst matched = findMatch(request, mappings)\n\tif (!matched) {\n\t\treturn undefined\n\t}\n\n\tconst matchedWildcard = request.slice(matched.prefix.length, request.length - matched.suffix.length)\n\n\tfor (const target of matched.targets) {\n\t\tconst updated = matched.wildcard ? target.replace(\"*\", matchedWildcard) : target\n\t\tconst base = (compilerOptions.baseUrl ?? compilerOptions.pathsBasePath) as string\n\t\tconst moduleName = path.resolve(base, updated)\n\t\tconst ext = path.extname(moduleName)\n\t\tswitch (ext) {\n\t\t\tcase \".ts\":\n\t\t\tcase \".tsx\":\n\t\t\tcase \".json\":\n\t\t\t\treturn moduleName\n\t\t\tcase \".js\":\n\t\t\tcase \".jsx\":\n\t\t\t\tif (compilerOptions.module === ts.ModuleKind.NodeNext) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn moduleName\n\t\t}\n\t\tconst result = ts.resolveModuleName(moduleName, importer, compilerOptions, host)\n\t\tif (result?.resolvedModule) {\n\t\t\treturn path.normalize(result.resolvedModule.resolvedFileName)\n\t\t}\n\t\tif (falllback?.(moduleName)) return moduleName\n\t}\n\n\treturn undefined\n}\n\n'typescript-paths/packages/typescript-paths/src/register.ts'\n:import Module from \"module\"\nimport { createHandler, OptionFallback } from \"./handler\"\nimport { convertLogLevel, createLogger, LogLevel, LogLevelString } from \"./logger\"\nimport { TsConfigPayload } from \"./paths\"\n\nexport interface RegisterOptions {\n\ttsConfigPath?: string | TsConfigPayload | Array<string | TsConfigPayload>\n\trespectCoreModule?: boolean\n\tlogLevel?: LogLevelString\n\tcolors?: boolean\n\tloggerID?: string\n}\n\nexport function register({\n\ttsConfigPath,\n\trespectCoreModule,\n\tlogLevel,\n\tcolors,\n\tloggerID,\n\tfalllback,\n}: RegisterOptions & OptionFallback = {}): () => void {\n\tconst log = createLogger({ logLevel: convertLogLevel(logLevel), colors, ID: loggerID })\n\tconst handler = createHandler({ tsConfigPath, respectCoreModule, log, falllback })\n\tif (!handler) {\n\t\treturn () => {}\n\t}\n\n\tconst originalResolveFilename = Module[\"_resolveFilename\"]\n\n\tModule[\"_resolveFilename\"] = function (request: string, parent?: Module, ...args: any[]) {\n\t\tif (!parent) return originalResolveFilename.apply(this, arguments)\n\n\t\tconst moduleName = handler(request, parent.filename)\n\t\tif (moduleName) {\n\t\t\tlog(LogLevel.Debug, `${request} -> ${moduleName}`)\n\t\t\treturn originalResolveFilename.apply(this, [moduleName, parent, ...args])\n\t\t}\n\n\t\treturn originalResolveFilename.apply(this, arguments)\n\t}\n\n\treturn () => {\n\t\tModule[\"_resolveFilename\"] = originalResolveFilename\n\t}\n}\n\n",
        "called_code_segment_file_1": "export function createLogger({ logLevel = fromTYPESCRIPT_PATHS_LOG_LEVEL() || LogLevel.Info, colors = true, ID = \"typescript-paths\", }: Partial<Options> = {}): LogFunc {\n  return function log(level, ...args) {\n    if (logLevel < level) {\n      return\n    }\n    if (ID) {\n      args.unshift(`[${ID}]:`)\n    }\n    if (colors) {\n      args = args.map(a => {\n        if (typeof a !== \"string\") return a\n        switch (level) {\n          case LogLevel.Error:\n            return FgRed + a + Reset\n          case LogLevel.Warning:\n            return FgYellow + a + Reset\n          case LogLevel.Info:\n            return FgBlue + a + Reset\n          case LogLevel.Debug:\n            return FgCyan + a + Reset\n          case LogLevel.Trace:\n            return FgMagenta + a + Reset\n        }\n      })\n    }\n    switch (level) {\n      case LogLevel.Error:\n        console.error(...args)\n        break\n      case LogLevel.Warning:\n        console.warn(...args)\n        break\n      case LogLevel.Info:\n        console.info(...args)\n        break\n      case LogLevel.Debug:\n        console.log(...args)\n        break\n      case LogLevel.Trace:\n        console.log(...args)\n        break\n    }\n  }\n}",
        "invoking_code_segment_file_2": "export function getTsConfig({ tsConfigPath, log = createLogger(), host = ts.sys, }: { tsConfigPath: string; log?: LogFunc; host?: ts.ParseConfigHost; }): undefined | TsConfigPayload {\n  const { error, config } = ts.readConfigFile(tsConfigPath, host.readFile)\n  if (error) {\n    let hasError = false\n    switch (error.category) {\n      case ts.DiagnosticCategory.Error:\n        log(LogLevel.Error, error.messageText)\n        hasError = true\n        break\n    }\n    if (hasError) return undefined\n  }\n  // ...\n}",
        "invoking_code_segment_file_3": "export function register({ tsConfigPath, respectCoreModule, logLevel, colors, loggerID, falllback, }: RegisterOptions & OptionFallback = {}): () => void {\n  const log = createLogger({ logLevel: convertLogLevel(logLevel), colors, ID: loggerID })\n  const handler = createHandler({ tsConfigPath, respectCoreModule, log, falllback })\n  if (!handler) {\n    return () => {}\n  }\n  // ...\n}",
        "new_file_code_segment": "export function logWithTimestamp(logFunc: LogFunc): LogFunc {\n  return function (level, ...args) {\n    const timestamp = new Date().toISOString()\n    args.unshift(`[${timestamp}]:`)\n    logFunc(level, ...args)\n  }\n}",
        "feature_description": "Add timestamp to log messages.",
        "detailed_feature_description": "A new function `logWithTimestamp` is added in #file 4 to prepend a timestamp to log messages. This function wraps the existing `log` function from #file 1 and adds the timestamp before invoking the original logging logic. The `createLogger` function in #file 1 is updated to use `logWithTimestamp` instead of directly returning the `log` function. The `getTsConfig` function in #file 2 and the `register` function in #file 3 are updated to use the modified `createLogger` function.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { logWithTimestamp } from './file4'\n\nexport function createLogger({ logLevel = fromTYPESCRIPT_PATHS_LOG_LEVEL() || LogLevel.Info, colors = true, ID = \"typescript-paths\", }: Partial<Options> = {}): LogFunc {\n  const logFunc = function log(level, ...args) {\n    if (logLevel < level) {\n      return\n    }\n    if (ID) {\n      args.unshift(`[${ID}]:`)\n    }\n    if (colors) {\n      args = args.map(a => {\n        if (typeof a !== \"string\") return a\n        switch (level) {\n          case LogLevel.Error:\n            return FgRed + a + Reset\n          case LogLevel.Warning:\n            return FgYellow + a + Reset\n          case LogLevel.Info:\n            return FgBlue + a + Reset\n          case LogLevel.Debug:\n            return FgCyan + a + Reset\n          case LogLevel.Trace:\n            return FgMagenta + a + Reset\n        }\n      })\n    }\n    switch (level) {\n      case LogLevel.Error:\n        console.error(...args)\n        break\n      case LogLevel.Warning:\n        console.warn(...args)\n        break\n      case LogLevel.Info:\n        console.info(...args)\n        break\n      case LogLevel.Debug:\n        console.log(...args)\n        break\n      case LogLevel.Trace:\n        console.log(...args)\n        break\n    }\n  }\n  return logWithTimestamp(logFunc)\n}",
            "#file 2": "//Modify\nimport { createLogger, LogFunc, LogLevel } from './file1'\n\nexport function getTsConfig({ tsConfigPath, log = createLogger(), host = ts.sys, }: { tsConfigPath: string; log?: LogFunc; host?: ts.ParseConfigHost; }): undefined | TsConfigPayload {\n  const { error, config } = ts.readConfigFile(tsConfigPath, host.readFile)\n  if (error) {\n    let hasError = false\n    switch (error.category) {\n      case ts.DiagnosticCategory.Error:\n        log(LogLevel.Error, error.messageText)\n        hasError = true\n        break\n    }\n    if (hasError) return undefined\n  }\n  // ...\n}",
            "#file 3": "//Modify\nimport { register, RegisterOptions, OptionFallback } from './file2'\nimport { convertLogLevel, createLogger, LogLevel, LogLevelString } from './file1'\n\nexport function register({ tsConfigPath, respectCoreModule, logLevel, colors, loggerID, falllback, }: RegisterOptions & OptionFallback = {}): () => void {\n  const log = createLogger({ logLevel: convertLogLevel(logLevel), colors, ID: loggerID })\n  const handler = createHandler({ tsConfigPath, respectCoreModule, log, falllback })\n  if (!handler) {\n    return () => {}\n  }\n  // ...\n}",
            "#file 4": "//New\nexport function logWithTimestamp(logFunc: LogFunc): LogFunc {\n  return function (level, ...args) {\n    const timestamp = new Date().toISOString()\n    args.unshift(`[${timestamp}]:`)\n    logFunc(level, ...args)\n  }\n}"
        }
    },
    {
        "repo": "ymock",
        "content": "'ymock/src/components/MSWContext.tsx'\n:import React, { PropsWithChildren } from \"react\";\nimport { RenderFnParams } from \"../types/ymock\";\nimport { SetupWorker } from \"msw/lib/browser\";\n\nexport const MSWContext = React.createContext<RenderFnParams>({\n  worker: null as unknown as SetupWorker,\n  handlers: [],\n});\n\nexport const MSWContextProvider: React.FC<\n  RenderFnParams & PropsWithChildren\n> = ({ worker, handlers, children }) => {\n  return (\n    <MSWContext.Provider value={{ worker, handlers }}>\n      {children}\n    </MSWContext.Provider>\n  );\n};\n\n'ymock/src/components/manageMock/index.tsx'\n:import { useContext, useEffect, useState } from \"react\";\nimport { useParams } from \"react-router\";\nimport { mock } from \"../../lib/mock\";\nimport { passthroughResponseHandler } from \"../../lib/responseHandlers/passthroughResponseHandler\";\nimport { MSWContext } from \"../MSWContext\";\nimport { MainParams } from \"../Main\";\nimport { Welcome } from \"../Welcome\";\nimport { Checkbox } from \"../form/Checkbox\";\nimport { MockForm } from \"./MockForm\";\n\nexport const ManageMock: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n  const { worker } = useContext(MSWContext);\n  const [passthrough, setPassthrough] = useState(false);\n\n  useEffect(() => {\n    if (passthrough) {\n      // passwthrough\n      mock(worker)(method, path)(passthroughResponseHandler)({});\n    }\n  }, [passthrough]);\n\n  if (!method || !path) {\n    console.warn(\"Invalid route: even method and path must be set\");\n    return <Welcome />;\n  }\n\n  return (\n    <div className=\"manage-mock\">\n      <div className=\"title\">Request info</div>\n      <div className=\"request-info\">\n        <div className=\"method\">{method}</div>\n        <div className=\"path\">/{path}</div>\n      </div>\n      <div className=\"configure-form\">\n        <div className=\"input\">\n          <Checkbox\n            name=\"passthrough\"\n            label=\"Passthrough\"\n            defaultChecked={passthrough}\n            onChange={setPassthrough}\n          />\n        </div>\n        {!passthrough && <MockForm {...{ method, path }} />}\n      </div>\n    </div>\n  );\n};\n\n'ymock/src/components/Main.tsx'\n:import { useParams } from \"react-router-dom\";\nimport { ManageMock } from \"./manageMock/index\";\nimport { Method } from \"../types/method\";\n\nexport type MainParams = {\n  method: Method;\n} & Record<string, string>;\n\nexport const Main: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n\n  return <ManageMock key={`${method}${path}`} />;\n};\n\n",
        "called_code_segment_file_1": "export const MSWContextProvider: React.FC<RenderFnParams & PropsWithChildren> = ({ worker, handlers, children }) => {\n  return (\n    <MSWContext.Provider value={{ worker, handlers }}>\n      {children}\n    </MSWContext.Provider>\n  );\n};",
        "invoking_code_segment_file_2": "export const ManageMock: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n  const { worker } = useContext(MSWContext);\n  const [passthrough, setPassthrough] = useState(false);\n\n  useEffect(() => {\n    if (passthrough) {\n      // passwthrough\n      mock(worker)(method, path)(passthroughResponseHandler)({});\n    }\n  }, [passthrough]);\n\n  if (!method || !path) {\n    console.warn(\"Invalid route: even method and path must be set\");\n    return <Welcome />;\n  }\n\n  return (\n    <div className=\"manage-mock\">\n      <div className=\"title\">Request info</div>\n      <div className=\"request-info\">\n        <div className=\"method\">{method}</div>\n        <div className=\"path\">/{path}</div>\n      </div>\n      <div className=\"configure-form\">\n        <div className=\"input\">\n          <Checkbox\n            name=\"passthrough\"\n            label=\"Passthrough\"\n            defaultChecked={passthrough}\n            onChange={setPassthrough}\n          />\n        </div>\n        {!passthrough && <MockForm {...{ method, path }} />}\n      </div>\n    </div>\n  );\n};",
        "invoking_code_segment_file_3": "export const Main: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n\n  return <ManageMock key={`${method}${path}`} />;\n};",
        "new_file_code_segment": "export const useMockToggle = (worker, method, path) => {\n  const [isMocked, setIsMocked] = useState(false);\n\n  useEffect(() => {\n    if (isMocked) {\n      mock(worker)(method, path)(passthroughResponseHandler)({});\n    }\n  }, [isMocked, worker, method, path]);\n\n  return [isMocked, setIsMocked];\n};",
        "feature_description": "Add a feature to toggle mocking on and off for a specific route.",
        "detailed_feature_description": "The new feature introduces a hook `useMockToggle` in a new file (#file 4) that manages the state of whether a specific route should be mocked or not. This hook is integrated into #file 1 to provide the toggle functionality. #file 2 is updated to use this hook, allowing the user to toggle mocking for a specific route. #file 3 remains unchanged as it simply renders the `ManageMock` component.",
        "modified_complete_code": {
            "file_1": "import React, { PropsWithChildren } from \"react\";\nimport { RenderFnParams } from \"../types/ymock\";\nimport { SetupWorker } from \"msw/lib/browser\";\nimport { useMockToggle } from \"./useMockToggle\"; #New\n\nexport const MSWContext = React.createContext<RenderFnParams>({ worker: null as unknown as SetupWorker, handlers: [] });\n\nexport const MSWContextProvider: React.FC<RenderFnParams & PropsWithChildren> = ({ worker, handlers, children }) => {\n  const [isMocked, setIsMocked] = useMockToggle(worker, method, path); #Modify\n  return (\n    <MSWContext.Provider value={{ worker, handlers, isMocked, setIsMocked }}>\n      {children}\n    </MSWContext.Provider>\n  );\n};",
            "file_2": "import { useContext, useEffect, useState } from \"react\";\nimport { useParams } from \"react-router\";\nimport { mock } from \"../../lib/mock\";\nimport { passthroughResponseHandler } from \"../../lib/responseHandlers/passthroughResponseHandler\";\nimport { MSWContext } from \"../MSWContext\";\nimport { MainParams } from \"../Main\";\nimport { Welcome } from \"../Welcome\";\nimport { Checkbox } from \"../form/Checkbox\";\nimport { MockForm } from \"./MockForm\";\n\nexport const ManageMock: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n  const { worker, isMocked, setIsMocked } = useContext(MSWContext); #Modify\n  const [passthrough, setPassthrough] = useState(false);\n\n  useEffect(() => {\n    if (passthrough) {\n      // passwthrough\n      mock(worker)(method, path)(passthroughResponseHandler)({});\n    }\n  }, [passthrough]);\n\n  if (!method || !path) {\n    console.warn(\"Invalid route: even method and path must be set\");\n    return <Welcome />;\n  }\n\n  return (\n    <div className=\"manage-mock\">\n      <div className=\"title\">Request info</div>\n      <div className=\"request-info\">\n        <div className=\"method\">{method}</div>\n        <div className=\"path\">/{path}</div>\n      </div>\n      <div className=\"configure-form\">\n        <div className=\"input\">\n          <Checkbox\n            name=\"passthrough\"\n            label=\"Passthrough\"\n            defaultChecked={passthrough}\n            onChange={setPassthrough}\n          />\n        </div>\n        <div className=\"input\">\n          <Checkbox\n            name=\"mockToggle\"\n            label=\"Mock Toggle\"\n            defaultChecked={isMocked}\n            onChange={setIsMocked}\n          />\n        </div>\n        {!passthrough && <MockForm {...{ method, path }} />}\n      </div>\n    </div>\n  );\n};",
            "file_3": "import { useParams } from \"react-router-dom\";\nimport { ManageMock } from \"./manageMock/index\";\nimport { Method } from \"../types/method\";\n\nexport type MainParams = { method: Method } & Record<string, string>;\n\nexport const Main: React.FC = () => {\n  const { method, \"*\": path } = useParams<MainParams>();\n\n  return <ManageMock key={`${method}${path}`} />;\n};",
            "file_4": "import { useState, useEffect } from \"react\";\nimport { mock } from \"../../lib/mock\";\nimport { passthroughResponseHandler } from \"../../lib/responseHandlers/passthroughResponseHandler\";\n\nexport const useMockToggle = (worker, method, path) => {\n  const [isMocked, setIsMocked] = useState(false);\n\n  useEffect(() => {\n    if (isMocked) {\n      mock(worker)(method, path)(passthroughResponseHandler)({});\n    }\n  }, [isMocked, worker, method, path]);\n\n  return [isMocked, setIsMocked];\n};"
        }
    },
    {
        "repo": "youtube-front",
        "content": "'youtube-front/src/components/ChannelOverview.tsx'\n:\n'youtube-front/src/components/AnnualReport.tsx'\n:import React, { useEffect, useState } from \"react\";\nimport { AnnualHistory } from \"../hooks/services\";\nimport ReportWelcome from \"./ReportWelcome\";\nimport AnnualReportSection from \"./AnnualReportSection\";\nimport Overview from \"./Overview\";\nimport TopTenVideos from \"./TopTenVideos\";\nimport ChannelOverview from \"./ChannelOverview\";\nimport TopTenChannel from \"./TopTenChannel\";\nimport Month from \"./Month\";\nimport { TimePeriod } from \"./TimePeriod\";\n\ninterface ARProps {\n  annualReport: AnnualHistory | null;\n}\n\nconst AnnualReport = ({ annualReport }: ARProps) => {\n  const [currentSection, setCurrentSection] = useState<string>(\"report-1\");\n\n  useEffect(() => {}, [currentSection]);\n\n  const handleScroll = (e: React.UIEvent<HTMLInputElement>): void => {\n    const sectionTops: { [key: string]: number } = {\n      \"report-1\": (document.querySelector(\"#report-1\") as HTMLDivElement)\n        .offsetTop,\n      \"report-2\": (document.querySelector(\"#report-2\") as HTMLDivElement)\n        .offsetTop,\n      \"report-3\": (document.querySelector(\"#report-3\") as HTMLDivElement)\n        .offsetTop,\n      \"report-4\": (document.querySelector(\"#report-4\") as HTMLDivElement)\n        .offsetTop,\n      \"report-5\": (document.querySelector(\"#report-5\") as HTMLDivElement)\n        .offsetTop,\n      \"report-6\": (document.querySelector(\"#report-6\") as HTMLDivElement)\n        .offsetTop,\n      \"report-7\": (document.querySelector(\"#report-7\") as HTMLDivElement)\n        .offsetTop,\n    };\n    const scrollPosition = e.currentTarget.scrollTop;\n    Object.entries(sectionTops).forEach(([section, top]) => {\n      if (scrollPosition == top) {\n        setCurrentSection(section);\n      }\n    });\n  };\n  return (\n    <div\n      onScroll={handleScroll}\n      className=\"max-h-screen snap-y snap-mandatory overflow-y-scroll no-scrollbar\"\n    >\n      <AnnualReportSection bgColor=\"bg-gray-900\" id=\"report-1\">\n        <ReportWelcome />\n      </AnnualReportSection>\n\n      <AnnualReportSection bgColor=\"bg-red-500\" id=\"report-2\">\n        {annualReport && currentSection == \"report-2\" && (\n          <Overview\n            title_count={annualReport?.title_count}\n            top_10_watched={annualReport?.top_10_watched}\n          />\n        )}\n      </AnnualReportSection>\n\n      <AnnualReportSection bgColor=\"bg-blue-400\" id=\"report-3\">\n        {annualReport && currentSection == \"report-3\" && (\n          <TopTenVideos top_10_watched={annualReport.top_10_watched} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-green-500\" id=\"report-4\">\n        {annualReport && currentSection == \"report-4\" && (\n          <ChannelOverview\n            channel_count={annualReport.channel_count}\n            top_10_channel={annualReport.top_10_channel}\n          />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-yellow-400\" id=\"report-5\">\n        {annualReport && currentSection == \"report-5\" && (\n          <TopTenChannel top_10_channel={annualReport.top_10_channel} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-orange-500\" id=\"report-6\">\n        {annualReport && currentSection == \"report-6\" && (\n          <Month count_item_by_month={annualReport.count_item_by_month} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-red-500\" id=\"report-7\">\n        {annualReport && currentSection == \"report-7\" && (\n          <TimePeriod\n            count_item_by_timeperiod={annualReport.count_items_by_timeperiod}\n            count_item_by_hour={annualReport.count_item_by_hour}\n            watch_count={annualReport.watch_count}\n          />\n        )}\n      </AnnualReportSection>\n    </div>\n  );\n};\n\nexport default AnnualReport;\n\n'youtube-front/src/App.tsx'\n:import \"./App.css\";\n\nimport { useState } from \"react\";\nimport { BrowserRouter, Routes, Route } from \"react-router-dom\";\nimport { AnnualHistory } from \"./hooks/services\";\n\nimport AnnualReport from \"./components/AnnualReport\";\nimport Guide from \"./components/Guide\";\n\nfunction App() {\n  const [annualHistory, setAnnualHistory] = useState<AnnualHistory | null>();\n\n  return (\n    <BrowserRouter>\n      <Routes>\n        <Route\n          path=\"/\"\n          element={<Guide setAnnualHistory={setAnnualHistory} />}\n        />\n        <Route\n          path=\"2023\"\n          element={\n            <AnnualReport annualReport={annualHistory ? annualHistory : null} />\n          }\n        />\n      </Routes>\n    </BrowserRouter>\n  );\n}\n\nexport default App;\n\n",
        "called_code_segment_file_1": "const AnnualReport = ({ annualReport }: ARProps) => {\n  const [currentSection, setCurrentSection] = useState<string>(\"report-1\");\n\n  useEffect(() => {}, [currentSection]);\n\n  const handleScroll = (e: React.UIEvent<HTMLInputElement>): void => {\n    const sectionTops: { [key: string]: number } = {\n      \"report-1\": (document.querySelector(\"#report-1\") as HTMLDivElement)\n        .offsetTop,\n      \"report-2\": (document.querySelector(\"#report-2\") as HTMLDivElement)\n        .offsetTop,\n      \"report-3\": (document.querySelector(\"#report-3\") as HTMLDivElement)\n        .offsetTop,\n      \"report-4\": (document.querySelector(\"#report-4\") as HTMLDivElement)\n        .offsetTop,\n      \"report-5\": (document.querySelector(\"#report-5\") as HTMLDivElement)\n        .offsetTop,\n      \"report-6\": (document.querySelector(\"#report-6\") as HTMLDivElement)\n        .offsetTop,\n      \"report-7\": (document.querySelector(\"#report-7\") as HTMLDivElement)\n        .offsetTop,\n    };\n    const scrollPosition = e.currentTarget.scrollTop;\n    Object.entries(sectionTops).forEach(([section, top]) => {\n      if (scrollPosition == top) {\n        setCurrentSection(section);\n      }\n    });\n  };\n  return (\n    <div\n      onScroll={handleScroll}\n      className=\"max-h-screen snap-y snap-mandatory overflow-y-scroll no-scrollbar\"\n    >\n      <AnnualReportSection bgColor=\"bg-gray-900\" id=\"report-1\">\n        <ReportWelcome />\n      </AnnualReportSection>\n\n      <AnnualReportSection bgColor=\"bg-red-500\" id=\"report-2\">\n        {annualReport && currentSection == \"report-2\" && (\n          <Overview\n            title_count={annualReport?.title_count}\n            top_10_watched={annualReport?.top_10_watched}\n          />\n        )}\n      </AnnualReportSection>\n\n      <AnnualReportSection bgColor=\"bg-blue-400\" id=\"report-3\">\n        {annualReport && currentSection == \"report-3\" && (\n          <TopTenVideos top_10_watched={annualReport.top_10_watched} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-green-500\" id=\"report-4\">\n        {annualReport && currentSection == \"report-4\" && (\n          <ChannelOverview\n            channel_count={annualReport.channel_count}\n            top_10_channel={annualReport.top_10_channel}\n          />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-yellow-400\" id=\"report-5\">\n        {annualReport && currentSection == \"report-5\" && (\n          <TopTenChannel top_10_channel={annualReport.top_10_channel} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-orange-500\" id=\"report-6\">\n        {annualReport && currentSection == \"report-6\" && (\n          <Month count_item_by_month={annualReport.count_item_by_month} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-red-500\" id=\"report-7\">\n        {annualReport && currentSection == \"report-7\" && (\n          <TimePeriod\n            count_item_by_timeperiod={annualReport.count_items_by_timeperiod}\n            count_item_by_hour={annualReport.count_item_by_hour}\n            watch_count={annualReport.watch_count}\n          />\n        )}\n      </AnnualReportSection>\n    </div>\n  );\n};",
        "invoking_code_segment_file_2": "<Route\n  path=\"2023\"\n  element={\n    <AnnualReport annualReport={annualHistory ? annualHistory : null} />\n  }\n/>",
        "invoking_code_segment_file_3": "const handleScroll = (e: React.UIEvent<HTMLInputElement>): void => {\n  const sectionTops: { [key: string]: number } = {\n    \"report-1\": (document.querySelector(\"#report-1\") as HTMLDivElement)\n      .offsetTop,\n    \"report-2\": (document.querySelector(\"#report-2\") as HTMLDivElement)\n      .offsetTop,\n    \"report-3\": (document.querySelector(\"#report-3\") as HTMLDivElement)\n      .offsetTop,\n    \"report-4\": (document.querySelector(\"#report-4\") as HTMLDivElement)\n      .offsetTop,\n    \"report-5\": (document.querySelector(\"#report-5\") as HTMLDivElement)\n      .offsetTop,\n    \"report-6\": (document.querySelector(\"#report-6\") as HTMLDivElement)\n      .offsetTop,\n    \"report-7\": (document.querySelector(\"#report-7\") as HTMLDivElement)\n      .offsetTop,\n  };\n  const scrollPosition = e.currentTarget.scrollTop;\n  Object.entries(sectionTops).forEach(([section, top]) => {\n    if (scrollPosition == top) {\n      setCurrentSection(section);\n    }\n  });\n};",
        "new_file_code_segment": "const NewFeature = ({ annualReport }: ARProps) => {\n  return (\n    <div>\n      <h1>New Feature Section</h1>\n      <p>This is a new feature added to the Annual Report.</p>\n      <p>Total Watch Count: {annualReport?.watch_count}</p>\n    </div>\n  );\n};\n\nexport default NewFeature;",
        "feature_description": "Add a new section in the Annual Report to display additional statistics.",
        "detailed_feature_description": "The new feature adds a new section in the Annual Report that displays additional statistics. This section is implemented in a new file (#file 4) and is invoked from #file 1. The new section is conditionally rendered based on the current section state, similar to other sections in the Annual Report. The new feature is integrated into the existing scroll handling mechanism to ensure compatibility.",
        "modified_complete_code": {
            "file_1": "const AnnualReport = ({ annualReport }: ARProps) => {\n  const [currentSection, setCurrentSection] = useState<string>(\"report-1\");\n\n  useEffect(() => {}, [currentSection]);\n\n  const handleScroll = (e: React.UIEvent<HTMLInputElement>): void => {\n    const sectionTops: { [key: string]: number } = {\n      \"report-1\": (document.querySelector(\"#report-1\") as HTMLDivElement)\n        .offsetTop,\n      \"report-2\": (document.querySelector(\"#report-2\") as HTMLDivElement)\n        .offsetTop,\n      \"report-3\": (document.querySelector(\"#report-3\") as HTMLDivElement)\n        .offsetTop,\n      \"report-4\": (document.querySelector(\"#report-4\") as HTMLDivElement)\n        .offsetTop,\n      \"report-5\": (document.querySelector(\"#report-5\") as HTMLDivElement)\n        .offsetTop,\n      \"report-6\": (document.querySelector(\"#report-6\") as HTMLDivElement)\n        .offsetTop,\n      \"report-7\": (document.querySelector(\"#report-7\") as HTMLDivElement)\n        .offsetTop,\n      \"report-8\": (document.querySelector(\"#report-8\") as HTMLDivElement)\n        .offsetTop,\n    };\n    const scrollPosition = e.currentTarget.scrollTop;\n    Object.entries(sectionTops).forEach(([section, top]) => {\n      if (scrollPosition == top) {\n        setCurrentSection(section);\n      }\n    });\n  };\n  return (\n    <div\n      onScroll={handleScroll}\n      className=\"max-h-screen snap-y snap-mandatory overflow-y-scroll no-scrollbar\"\n    >\n      <AnnualReportSection bgColor=\"bg-gray-900\" id=\"report-1\">\n        <ReportWelcome />\n      </AnnualReportSection>\n\n      <AnnualReportSection bgColor=\"bg-red-500\" id=\"report-2\">\n        {annualReport && currentSection == \"report-2\" && (\n          <Overview\n            title_count={annualReport?.title_count}\n            top_10_watched={annualReport?.top_10_watched}\n          />\n        )}\n      </AnnualReportSection>\n\n      <AnnualReportSection bgColor=\"bg-blue-400\" id=\"report-3\">\n        {annualReport && currentSection == \"report-3\" && (\n          <TopTenVideos top_10_watched={annualReport.top_10_watched} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-green-500\" id=\"report-4\">\n        {annualReport && currentSection == \"report-4\" && (\n          <ChannelOverview\n            channel_count={annualReport.channel_count}\n            top_10_channel={annualReport.top_10_channel}\n          />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-yellow-400\" id=\"report-5\">\n        {annualReport && currentSection == \"report-5\" && (\n          <TopTenChannel top_10_channel={annualReport.top_10_channel} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-orange-500\" id=\"report-6\">\n        {annualReport && currentSection == \"report-6\" && (\n          <Month count_item_by_month={annualReport.count_item_by_month} />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-red-500\" id=\"report-7\">\n        {annualReport && currentSection == \"report-7\" && (\n          <TimePeriod\n            count_item_by_timeperiod={annualReport.count_items_by_timeperiod}\n            count_item_by_hour={annualReport.count_item_by_hour}\n            watch_count={annualReport.watch_count}\n          />\n        )}\n      </AnnualReportSection>\n      <AnnualReportSection bgColor=\"bg-purple-500\" id=\"report-8\">\n        {annualReport && currentSection == \"report-8\" && (\n          <NewFeature annualReport={annualReport} />\n        )}\n      </AnnualReportSection>\n    </div>\n  );\n};",
            "file_2": "<Route\n  path=\"2023\"\n  element={\n    <AnnualReport annualReport={annualHistory ? annualHistory : null} />\n  }\n/>",
            "file_3": "const handleScroll = (e: React.UIEvent<HTMLInputElement>): void => {\n  const sectionTops: { [key: string]: number } = {\n    \"report-1\": (document.querySelector(\"#report-1\") as HTMLDivElement)\n      .offsetTop,\n    \"report-2\": (document.querySelector(\"#report-2\") as HTMLDivElement)\n      .offsetTop,\n    \"report-3\": (document.querySelector(\"#report-3\") as HTMLDivElement)\n      .offsetTop,\n    \"report-4\": (document.querySelector(\"#report-4\") as HTMLDivElement)\n      .offsetTop,\n    \"report-5\": (document.querySelector(\"#report-5\") as HTMLDivElement)\n      .offsetTop,\n    \"report-6\": (document.querySelector(\"#report-6\") as HTMLDivElement)\n      .offsetTop,\n    \"report-7\": (document.querySelector(\"#report-7\") as HTMLDivElement)\n      .offsetTop,\n    \"report-8\": (document.querySelector(\"#report-8\") as HTMLDivElement)\n      .offsetTop,\n  };\n  const scrollPosition = e.currentTarget.scrollTop;\n  Object.entries(sectionTops).forEach(([section, top]) => {\n    if (scrollPosition == top) {\n      setCurrentSection(section);\n    }\n  });\n};",
            "file_4": "const NewFeature = ({ annualReport }: ARProps) => {\n  return (\n    <div>\n      <h1>New Feature Section</h1>\n      <p>This is a new feature added to the Annual Report.</p>\n      <p>Total Watch Count: {annualReport?.watch_count}</p>\n    </div>\n  );\n};\n\nexport default NewFeature;"
        }
    },
    {
        "repo": "WebView2Example",
        "content": "'WebView2Example/WebView2Example-Front/projects/demo-app/src/app/interfaces/events.enum.ts'\n:export enum EventsEnum {\n\n    // Update Floors\n    UpdateFloors= 'UpdateFloors',\n\n    //Common\n    Run = \"Run\",\n    Close = \"Close\",\n    ResizeWindow = \"ResizeWindow\",\n\n    // Nika\n    PopulatePlugins = \"PopulatePlugins\",\n    UpdatePlugins = \"UpdatePlugins\",\n\n    // Plugins\n    PopulateElements = \"PopulateElements\",\n    Save = \"Save\",\n    Load = \"Load\",\n\n}\n\n'WebView2Example/WebView2Example-Front/projects/demo-app/src/app/app.component.ts'\n:import {Component} from '@angular/core';\nimport {MatIconRegistry} from '@angular/material/icon';\nimport {DomSanitizer} from '@angular/platform-browser';\nimport {ActivatedRoute, Router, RoutesRecognized} from '@angular/router';\nimport {EventsEnum} from './interfaces/events.enum';\nimport {WebView2Service} from './services/webview2.service';\n\nexport interface WindowSize {\n    height: number;\n    width: number;\n}\n\nconst defaultTitle = 'Angular-Revit-WebView2';\n\n@Component({\n    selector: 'ktd-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.scss']\n})\nexport class KtdAppComponent {\n    title: string = defaultTitle;\n    size: WindowSize = {\n        width: 400,\n        height: 600,\n    };\n\n    constructor(private matIconRegistry: MatIconRegistry, private domSanitizer: DomSanitizer, private router: Router, private readonly route: ActivatedRoute,\n                private readonly wv2Service: WebView2Service) {\n        this.matIconRegistry.addSvgIcon(\n            `github`,\n            this.domSanitizer.bypassSecurityTrustResourceUrl(`assets/logos/github.svg`)\n        );\n\n        this.router.events.subscribe((data) => {\n            if (data instanceof RoutesRecognized) {\n                this.title = data.state.root.firstChild?.data.title || defaultTitle;\n            }\n        });\n    }\n\n    resizeWindow() {\n        this.wv2Service.postWebView2Message(EventsEnum.ResizeWindow, this.size);\n    }\n\n    close() {\n        this.wv2Service.postWebView2Message(EventsEnum.Close);\n    }\n}\n\n'WebView2Example/WebView2Example-Front/projects/demo-app/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { KtdAppComponent } from './app.component';\nimport { KtdAppRoutingModule } from './app-routing.module';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { HttpClientModule } from '@angular/common/http';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatButtonModule } from '@angular/material/button';\nimport { WebView2Service } from './services/webview2.service';\n\n@NgModule({\n    declarations: [\n        KtdAppComponent\n    ],\n    imports: [\n        BrowserModule,\n        BrowserAnimationsModule,\n        KtdAppRoutingModule,\n        HttpClientModule,\n        MatIconModule,\n        MatButtonModule\n    ],\n    providers: [],\n    bootstrap: [KtdAppComponent]\n})\nexport class KtdAppModule {}\n\n'WebView2Example/WebView2Example-Front/projects/demo-app/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { KtdAppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(KtdAppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "postWebView2Message(event: EventsEnum, data?: any) {\n        window.chrome.webview.postMessage({event, data});\n    }",
        "invoking_code_segment_file_2": "resizeWindow() {\n        this.wv2Service.postWebView2Message(EventsEnum.ResizeWindow, this.size);\n    }\n\n    close() {\n        this.wv2Service.postWebView2Message(EventsEnum.Close);\n    }",
        "called_code_segment_file_2": "postWebView2Message(event: EventsEnum, data?: any) {\n        window.chrome.webview.postMessage({event, data});\n    }",
        "using_code_segment_file_3": "constructor(private readonly wv2Service: WebView2Service) {\n        this.wv2Service.postWebView2Message(EventsEnum.UpdateFloors);\n    }",
        "called_code_segment_file_3": "postWebView2Message(event: EventsEnum, data?: any) {\n        window.chrome.webview.postMessage({event, data});\n    }",
        "using_code_segment_file_4": "constructor(private readonly wv2Service: WebView2Service) {\n        this.wv2Service.postWebView2Message(EventsEnum.PopulatePlugins);\n    }",
        "feature_description": "Add a new event type to the EventsEnum and update the WebView2Service to handle this new event.",
        "detailed_feature_description": "A new event type 'NewEvent' is added to the EventsEnum. The WebView2Service's postWebView2Message method is updated to handle this new event. The app.component.ts is updated to include a new method that triggers this event. The WebView2Service is further updated to handle the new event and send a corresponding message to the WebView2 environment.",
        "modified_complete_code": {
            "file_1": "export enum EventsEnum {\n    UpdateFloors= 'UpdateFloors',\n    Run = \"Run\",\n    Close = \"Close\",\n    ResizeWindow = \"ResizeWindow\",\n    PopulatePlugins = \"PopulatePlugins\",\n    UpdatePlugins = \"UpdatePlugins\",\n    PopulateElements = \"PopulateElements\",\n    Save = \"Save\",\n    Load = \"Load\",\n    NewEvent = \"NewEvent\" #New\n}",
            "file_2": "postWebView2Message(event: EventsEnum, data?: any) {\n        if (event === EventsEnum.NewEvent) {\n            window.chrome.webview.postMessage({event: EventsEnum.NewEvent, data: 'New Event Triggered'});\n        } else {\n            window.chrome.webview.postMessage({event, data});\n        }\n    } #Modify",
            "file_3": "constructor(private readonly wv2Service: WebView2Service) {\n        this.wv2Service.postWebView2Message(EventsEnum.UpdateFloors);\n        this.wv2Service.postWebView2Message(EventsEnum.NewEvent); #New\n    }",
            "file_4": "constructor(private readonly wv2Service: WebView2Service) {\n        this.wv2Service.postWebView2Message(EventsEnum.PopulatePlugins);\n        this.wv2Service.postWebView2Message(EventsEnum.NewEvent); #New\n    }"
        }
    },
    {
        "repo": "Approvals.NodeJS",
        "content": "'Approvals.NodeJS/lib/Core/Reporter.ts'\n:import { Config } from \"../config\";\n\nexport interface Reporter {\n  name: string;\n\n  canReportOn(fileName: string): boolean;\n\n  report(\n    approvedFileName: string,\n    receivedFileName: string,\n    options?: Partial<Config>,\n  ): void;\n}\n\n'Approvals.NodeJS/lib/FileApprover.ts'\n:import fs from \"fs\";\nimport { Config } from \"./config\";\nimport { Namer } from \"./Core/Namer\";\nimport { Writer } from \"./Core/Writer\";\nimport { Reporter } from \"./Core/Reporter\";\nimport { ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { yellowText } from \"./Utilities/ConsoleUtils\";\n\ninterface Options {\n  stripBOM?: boolean;\n  forceApproveAll?: boolean;\n  failOnLineEndingDifferences?: boolean;\n  shouldIgnoreStaleApprovedFile?(fileName: string): boolean;\n}\n\nfunction normalizeLineEndings(value: string): string {\n  return value.replace(/(?:\\r\\n|\\r|\\n)/g, \"\\n\");\n}\n\nexport class FileApprover {\n  static verify(\n    namer: Namer,\n    writer: Writer,\n    reporterFactory: ReporterLoader,\n    options?: Partial<Config>,\n  ): void {\n    if (!namer || !writer || !reporterFactory) {\n      throw new Error(\n        \"Missing required arguments: 'namer', 'writer', or 'reporterFactory'.\",\n      );\n    }\n    if (!options) {\n      options = {};\n    }\n\n    const approvedFileName = namer.getApprovedFile(writer.getFileExtension());\n    const receivedFileName = namer.getReceivedFile(writer.getFileExtension());\n\n    writer.write(receivedFileName);\n\n    if (options.forceApproveAll) {\n      console.log(yellowText(`WARNING: Force approving: ${approvedFileName}`));\n      writer.write(approvedFileName);\n    }\n\n    const selectFirstCompatibleReporter = (): Reporter => {\n      const allReporters = reporterFactory();\n      const reporter = allReporters.find((reporter) =>\n        reporter.canReportOn(receivedFileName),\n      );\n      if (!reporter) {\n        throw new Error(\n          `No compatible reporter found in configured list [${allReporters.map((r) => r.name).join(\", \")}] for: ${receivedFileName}`,\n        );\n      }\n      return reporter;\n    };\n\n    const throwReporterError = (msg: string): never => {\n      const reporter = selectFirstCompatibleReporter();\n      try {\n        reporter.report(approvedFileName, receivedFileName, options);\n      } catch (ex) {\n        const reporterError = `Error raised by reporter [${reporter.name}]: ${ex}`;\n        throw new Error(\n          `${reporterError}\\n${msg}\\nApproved: ${approvedFileName}\\nReceived: ${receivedFileName}`,\n        );\n      }\n      throw new Error(msg);\n    };\n\n    if (!fs.existsSync(approvedFileName)) {\n      throwReporterError(`Approved file does not exist: ${approvedFileName}`);\n    }\n\n    let approvedFileContents = fs.readFileSync(approvedFileName, \"utf8\") || \"\";\n    let receivedFileContents = fs.readFileSync(receivedFileName, \"utf8\") || \"\";\n\n    if (options.stripBOM) {\n      approvedFileContents = approvedFileContents.replace(/^\\uFEFF/, \"\");\n      receivedFileContents = receivedFileContents.replace(/^\\uFEFF/, \"\");\n    }\n\n    if (\n      options.failOnLineEndingDifferences &&\n      approvedFileContents !== receivedFileContents\n    ) {\n      throwReporterError(\"Files do not match.\");\n    }\n\n    const approvedFileBufferNormalized =\n      normalizeLineEndings(approvedFileContents);\n    const receivedFileBufferNormalized =\n      normalizeLineEndings(receivedFileContents);\n\n    if (approvedFileBufferNormalized !== receivedFileBufferNormalized) {\n      throwReporterError(\"Files do not match.\");\n    }\n\n    // Delete the received file\n    fs.unlinkSync(receivedFileName);\n\n    (process.emit as Function)(\"approvalFileApproved\", approvedFileName);\n  }\n}\n\nexport function verify(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory: () => Reporter[],\n  options?: Partial<Config>,\n): void {\n  FileApprover.verify(namer, writer, reporterFactory, options);\n}\n\n'Approvals.NodeJS/lib/Approvals.ts'\n:/*jshint freeze:false */\n\n/**\n * Approvals module.\n * @module approvals\n */\n\nimport callsite from \"callsite\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport * as cfg from \"./config\";\nimport { BinaryWriter } from \"./Writers/BinaryWriter\";\nimport { FileApprover } from \"./FileApprover\";\nimport { FinalMessages } from \"./FinalMessages\";\nimport { ManualNamer } from \"./ManualNamer\";\nimport { Namer } from \"./Core/Namer\";\nimport { ReporterFactory, ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { Scrubber, Scrubbers } from \"./Scrubbers/Scrubbers\";\nimport { StringWriter } from \"./StringWriter\";\nimport { Writer } from \"./Core/Writer\";\nimport { postRunCleanup } from \"./postRunCleanup\";\nimport { stringifyKeysInOrder } from \"./AUtils\";\n\n// if someone tries to call 'require(\"approvals\")...' without calling \".mocha(...) or\n// they won't get a helpful error. So we put this in there - just in case\"\nimport { MochaNamer } from \"./Providers/Mocha/MochaNamer\";\n\nimport { beforeEachVerifierBase } from \"./Providers/BeforeEachVerifierBase\";\n\n/**\n * Contains some helpful and util scrubbers that can be used for scrubbing data before saving to a received file.\n */\nexport { Scrubbers as scrubbers };\n\nif (typeof beforeEach === \"function\") {\n  beforeEach(function (): void {\n    if (!this) {\n      return;\n    }\n    this.verify = function () {\n      throw new Error(\"You must call either .mocha()\");\n    };\n  });\n}\n\n// keep track of approved files we run into with tests\nconst listOfApprovedFiles: string[] = [];\nprocess.on(\"approvalFileApproved\", function (fileName): void {\n  if (listOfApprovedFiles.indexOf(fileName) === -1) {\n    listOfApprovedFiles.push(fileName);\n  }\n});\n\nprocess.on(\"exit\", function (): void {\n  const options = cfg.currentConfig();\n  postRunCleanup(options, listOfApprovedFiles);\n  const finalMessages = FinalMessages.getMessages();\n  if (finalMessages.length) {\n    console.log(\"******************************\");\n    console.log(\"* Approvals Report: WARNING!\");\n    finalMessages.forEach((message: string) => {\n      console.log(`*  - ${message}`);\n    });\n    console.log(\"******************************\");\n  }\n});\n\n/**\n * Allows you to provide overrides to the default configuration.\n *\n * @example\n * const approvals = require('approvals');\n * approvals.configure({\n *   reporters: ['p4merge']\n * });\n *\n * @param {*} overrideOptions\n */\nexport function configure(overrideOptions: cfg.Config): typeof module.exports {\n  cfg.configure(overrideOptions);\n  return module.exports;\n}\n\n/**\n * Allows the creation of an approvals configuration object using any passed in options to override the defaults.\n * @param {Object} overrideOptions\n * @returns {Object} approvals config object with any options overridden.\n */\nexport function getConfig(overrideOptions?: cfg.Config): cfg.Config {\n  return cfg.getConfig(overrideOptions);\n}\n\n/**\n * Configure approvals to hook into Mocha tests.\n * @param {*} optionalBaseDir - An optional folder to save approval files to.\n */\n\nexport function mocha(optionalBaseDir?: string): typeof module.exports {\n  // if not providing a base dir, fallback to the current calling code's directory\n  if (!optionalBaseDir) {\n      let fileName = callsite()[1].getFileName();\n      if (fileName.startsWith(\"file://\")) {\n          fileName = fileURLToPath(fileName);\n      }\n      optionalBaseDir = path.dirname(fileName);\n  }\n  beforeEachVerifierBase(\n    MochaNamer,\n    \"require('Approvals').mocha();\",\n    optionalBaseDir,\n  );\n\n  return module.exports;\n}\n\nfunction jasmineExport(): void {\n  throw new Error(\n    \"Aww shucks.\\n\\nApprovals support of Jasmine has been completely yanked out (don't shoot). \\n\\n Jasmine has grown quite complicated (behind our back) and we haven't had enough time to figure out a solid integration pattern... for now it's support has been removed.\\n\\n Check out the docs for manual usage of approval tests to work around the missing Jasmine integration (it should be a straightforward change for you, really).\\n\\n We'll consider bringing it back if we can get someone with interest in submitting a pull request that can bring it back...\",\n  );\n}\n\n/**\n * `reporters` gives access to the `MultiReporter`\n *\n * @example\n * const MultiReporter = approvals.reporters.MultiReporter\n */\n\nexport const reporters: { MultiReporter: any } = {\n  /**\n   * This allows access to the MultiReporter constructor.\n   * You can use this to run multiple reporters at the same time.\n   *\n   * @example\n   * approvals.verify(__dirname, \"multi-reporter-example\", \"some data\", {\n   *   reporters: [\n   *     new MultiReporter('p4merge', 'copycommand')\n   *   ]\n   * });\n   */\n  MultiReporter: require(\"./Reporting/Reporters/multiReporter\").default,\n};\n\n/**\n * Use this to apply the scrubber function to any data before running verify.\n *\n * @example\n * // basic approval test with a custom scrubber\n * const approvals = require('approvals');\n * const scrubber = approvals.scrubbers.multiScrubber([\n *    function (data) {\n *      return (data || '').replace(\"some text\", \"some other text\");\n *    },\n *    approvals.scrubbers.guidScrubber // to remove guids from the received data\n * });\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', \"some text to verify\", scrubber);\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - Either the string to save as a text file or a Buffer that represents an image\n * @param {*} scrubber - A function that takes a string and returns a string. Approvals will call this if it exists to scrub the \"data\" before writing to any files.\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\nfunction verifyAndScrub(\n  dirName: string,\n  testName: string,\n  data: BinaryWriter | string,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  scrubber = scrubber || Scrubbers.noScrubber;\n\n  // backwards compatible option\n  if (Array.isArray(optionsOverride)) {\n    optionsOverride = {\n      reporters: optionsOverride,\n    };\n    const stringReporters = JSON.stringify(optionsOverride.reporters);\n    console.error(\n      'For the last arg of the approvals.verify(...) function, if you passed in an array of reporters, something like [\"opendiff\",\"nodediff\"], this has been deprecated and replaced by passing in a config object. Please re-evaluate if you can remove this parameter alltogether and use individual user configs in ~/.approvalConfig, if not then replace this: ' +\n        stringReporters +\n        \" with this { reporters: \" +\n        stringReporters +\n        \"}.\",\n    );\n  }\n\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const namer = new ManualNamer(dirName, testName);\n\n  let writer: Writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data as string);\n\n    writer = new StringWriter(newOptions, data as string);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}\n/**\n *\n * @example\n * // basic approval test\n * const approvals = require('approvals');\n * approvals.verify(__dirname, 'sample-approval-test', \"some text to verify\");\n *\n * @example\n * // basic approval test providing an option to override configuration\n * const approvals = require('approvals');\n * approvals.verify(__dirname, 'sample-approval-test', \"some text to verify\", { normalizeLineEndingsTo: true });\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name save string to call the file associated with this test.\n * @param {(string|Buffer)} data - Either the string to save as a text file or a Buffer that represents an image\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\n\nexport function verify(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride?: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * You can pass as \"data\" any javascript object to be JSON.stringified and run verify against.\n *\n * @example\n * const approvals = require('approvals');\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', { a: \"some text in an object\" });\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - This can be any JavaScript object/array that will be JSON.stringified before running verify\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\nexport function verifyAsJSON(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride: any,\n) {\n  return verifyAsJSONAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * You can pass as \"data\" any javascript object to be JSON.stringified. Before we run verify the scrubber will be run against the complete string before running verify against it.\n\n * @example\n * // basic approval test with a custom scrubber\n * const approvals = require('approvals');\n * const scrubber = approvals.scrubbers.multiScrubber([\n *    function (data) {\n *      return (data || '').replace(\"some text\", \"some other text\");\n *    },\n *    approvals.scrubbers.guidScrubber // to remove guids from the received data\n * });\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', { a: \"some text in an object\" }, scrubber);\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - This can be any JavaScript object/array that will be JSON.stringified before running verify\n * @param {*} scrubber - A function that takes a string and returns a string. Approvals will call this if it exists to scrub the \"data\" before writing to any files.\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\n\nexport function verifyAsJSONAndScrub(\n  dirName: string,\n  testName: string,\n  data: any,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    stringifyKeysInOrder(data),\n    scrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * This allows you to take full control of naming and writing files before verifying.\n *\n * For an example that we use to generate the docs within the readme, check out the [test/readmeTests.js](test/readmeTests.js) in this project.\n *\n * @param {Object} namer\n * @param {Object} writer\n * @param {Function} [reporterFactory]\n * @param {Object} [optionsOverride]\n */\n\nexport function verifyWithControl(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory?: ReporterLoader | null,\n  optionsOverride?: Partial<cfg.Config>,\n) {\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const loader =\n    (reporterFactory as ReporterLoader) ||\n    function () {\n      return [ReporterFactory.loadReporter(newOptions.reporters)];\n    };\n\n  FileApprover.verify(namer, writer, loader, newOptions);\n}\n\n'Approvals.NodeJS/lib/Providers/Mocha/MochaApprovals.ts'\n:import { printArray, printJson } from \"../../Utilities/Printers\";\n/* ^^^ If the above line is failing, please add\n# 1. Jest Config\n```\n\"transformIgnorePatterns\": [\"node_modules/@3ds\"]\n```\n\n# 2. tsconfig.json\n```\n    \"esModuleInterop\": true\n```\n*/\nimport { Options } from \"../../Core/Options\";\nimport { MochaNamer } from \"./MochaNamer\";\nimport mocha from \"mocha\";\n\nimport StringWriter from \"../../StringWriter\";\n\nimport * as approvals from \"../../Approvals\";\n\nlet mochaTest: any = null;\n\nexport function it2(label: string, test: () => void): void {\n  mocha.it(label, function () {\n    mochaTest = this;\n    console.log(\"Mocha Test: \", mochaTest.test.name);\n    test();\n  });\n}\n\nexport function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  approvals.verifyWithControl(namer, writer, null, config);\n}\n\nexport function verifyAsJson(data: any, options?: Options): void {\n  const text = printJson(data);\n  options = options || new Options();\n  options = options.forFile().withFileExtention(\".json\");\n  verify(text, options);\n}\n\nexport function verifyAll<T>(\n  header: string,\n  list: T[],\n  formatter?: (element: T) => string,\n  options?: Options,\n): void {\n  const text = printArray(header, list, formatter);\n  verify(text, options);\n}\n\n",
        "called_code_segment_file_1": "export function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  approvals.verifyWithControl(namer, writer, null, config);\n}",
        "invoking_code_segment_file_2": "export function it2(label: string, test: () => void): void {\n  mocha.it(label, function () {\n    mochaTest = this;\n    console.log(\"Mocha Test: \", mochaTest.test.name);\n    test();\n  });\n}",
        "called_code_segment_file_2": "export function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  approvals.verifyWithControl(namer, writer, null, config);\n}",
        "using_code_segment_file_3": "import { it2, verify } from './MochaApprovals';\n\nit2('should verify a simple string', () => {\n  verify('Hello, World!');\n});",
        "called_code_segment_file_3": "",
        "using_code_segment_file_4": "",
        "feature_description": "Add a new feature to log the verification process details.",
        "detailed_feature_description": "Modify the `verify` function in #file 1 to log the verification process details. Update #file 2 to handle the modified `verify` function and ensure any related code segments used by #file 3 are updated accordingly. Since #file 3 directly interacts with the updated segments in #file 2, modify the code in #file 3 to accommodate the changes. No changes are required for #file 4 as it does not interact with or depend on any updated segments in #file 3.",
        "modified_complete_code": {
            "#file 1": "export function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  console.log('Verification process started:', { sut, options }); #Modify\n  approvals.verifyWithControl(namer, writer, null, config);\n}",
            "#file 2": "export function it2(label: string, test: () => void): void {\n  mocha.it(label, function () {\n    mochaTest = this;\n    console.log(\"Mocha Test: \", mochaTest.test.name);\n    test();\n  });\n}",
            "#file 3": "import { it2, verify } from './MochaApprovals';\n\nit2('should verify a simple string', () => {\n  verify('Hello, World!');\n});",
            "#file 4": ""
        }
    },
    {
        "repo": "amifauzi.com-open",
        "content": "'amifauzi.com-open/app/components/Gallery/Utils/round.ts'\n:export const round = (value: number, decimals = 0) => {\n  return Number(Math.round(Number(`${value}e${decimals}`)) + \"e-\" + decimals);\n};\n\n'amifauzi.com-open/app/components/Gallery/Utils/findIdealNodeSearch.ts'\n:import { round } from \"./round\";\n\ninterface IFindIdealNodeSearchArg {\n  targetRowHeight: number;\n  containerWidth: number;\n}\n\n// guesstimate how many neighboring nodes should be searched based on\n// the aspect ratio of the container with images having an avg AR of 1.5\n// as the minimum amount of photos per row, plus some nodes\nexport const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  return round(rowAR / 1.5) + 8;\n};\n\n'amifauzi.com-open/app/components/Gallery/Gallery.tsx'\n:/* \nAll of the code in this component are copied and modified from:\nhttps://github.com/neptunian/react-photo-gallery\n*/\n\nimport { useLayoutEffect, useRef, useState } from \"react\";\nimport { computeRowLayout } from \"./Utils/compute-layout\";\nimport { findIdealNodeSearch } from \"./Utils/findIdealNodeSearch\";\nimport { PhotoProvider, PhotoView } from \"react-photo-view\";\n\nexport interface IPhoto {\n  src: string;\n  width: number;\n  height: number;\n  alt: string;\n}\n\ninterface GalleryProps {\n  photos: IPhoto[];\n}\n\nconst Gallery = ({ photos }: GalleryProps) => {\n  const [containerWidth, setContainerWidth] = useState(0);\n  const galleryEl = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    let animationFrameID: number | null = null;\n    const observer = new ResizeObserver((entries) => {\n      // only do something if width changes\n      const newWidth = entries[0].contentRect.width;\n      if (containerWidth !== newWidth) {\n        // put in an animation frame to stop \"benign errors\" from\n        // ResizObserver https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n        animationFrameID = window.requestAnimationFrame(() => {\n          setContainerWidth(Math.floor(newWidth));\n        });\n      }\n    });\n\n    if (galleryEl.current) {\n      observer.observe(galleryEl.current);\n    }\n\n    return () => {\n      observer.disconnect();\n      if (animationFrameID) {\n        window.cancelAnimationFrame(animationFrameID);\n      }\n    };\n  });\n\n  if (!containerWidth) return <div ref={galleryEl}>&nbsp;</div>;\n\n  const width = containerWidth - 1;\n  const targetRowHeight = 300;\n  let limitNodeSearch = 2;\n  if (containerWidth >= 450) {\n    limitNodeSearch = findIdealNodeSearch({ containerWidth, targetRowHeight });\n  }\n  const thumbs: IPhoto[] = computeRowLayout({\n    containerWidth: width,\n    limitNodeSearch,\n    targetRowHeight,\n    margin: 2,\n    photos,\n  });\n\n  return (\n    <PhotoProvider>\n      <div ref={galleryEl} className=\"flex flex-wrap\">\n        {thumbs.map((thumb, index) => {\n          return (\n            <PhotoView key={index} src={thumb.src}>\n              <img\n                key={index}\n                src={thumb.src}\n                alt={thumb.alt}\n                width={thumb.width}\n                height={thumb.height}\n                className=\"m-0.5 cursor-pointer\"\n              />\n            </PhotoView>\n          );\n        })}\n      </div>\n    </PhotoProvider>\n  );\n};\n\nexport default Gallery;\n\n'amifauzi.com-open/app/components/Gallery/Utils/compute-layout.ts'\n:import type { IPhoto } from \"../Gallery\";\nimport { findShortestPath } from \"./dijkstra\";\nimport type { TGraphFunc, TNode } from \"./dijkstra\";\nimport { round } from \"./round\";\n\n// return two decimal places rounded number\nexport const ratio = ({ width, height }: IPhoto) => round(width / height, 2);\n\n// compute sizes by creating a graph with rows as edges and photo to break on as nodes\n// to calculate the single best layout using Dijkstra's findShortestPat\n\n// get the height for a set of photos in a potential row\nconst getCommonHeight = (\n  row: IPhoto[],\n  containerWidth: number,\n  margin: number\n) => {\n  const rowWidth = containerWidth - row.length * (margin * 2);\n  const totalAspectRatio = row.reduce((acc, photo) => acc + ratio(photo), 0);\n  return rowWidth / totalAspectRatio;\n};\n\n// calculate the cost of breaking at this node (edge weight)\nconst cost = (\n  photos: IPhoto[],\n  i: number,\n  j: number,\n  width: number,\n  targetHeight: number,\n  margin: number\n) => {\n  const row = photos.slice(i, j);\n  const commonHeight = getCommonHeight(row, width, margin);\n  return Math.pow(Math.abs(commonHeight - targetHeight), 2);\n};\n\n// return function that gets the neighboring nodes of node and returns costs\nconst makeGetNeighbors =\n  (\n    targetHeight: number,\n    containerWidth: number,\n    photos: IPhoto[],\n    limitNodeSearch: number,\n    margin: number\n  ): TGraphFunc =>\n  (start) => {\n    const results: TNode = {};\n    start = +start;\n    results[+start] = 0;\n    for (let i = start + 1; i < photos.length + 1; ++i) {\n      if (i - start > limitNodeSearch) break;\n      results[i] = cost(photos, start, i, containerWidth, targetHeight, margin);\n    }\n    return results;\n  };\n\ninterface IComputeRowLayiutArg {\n  containerWidth: number;\n  limitNodeSearch: number;\n  targetRowHeight: number;\n  margin: number;\n  photos: IPhoto[];\n}\n\nexport const computeRowLayout = ({\n  containerWidth,\n  limitNodeSearch,\n  targetRowHeight,\n  margin,\n  photos,\n}: IComputeRowLayiutArg) => {\n  const getNeighbors = makeGetNeighbors(\n    targetRowHeight,\n    containerWidth,\n    photos,\n    limitNodeSearch,\n    margin\n  );\n  let path = findShortestPath(getNeighbors, 0, photos.length);\n  path = path.map((node) => +node);\n  for (let i = 1; i < path.length; ++i) {\n    const row = photos.slice(path[i - 1], path[i]);\n    const height = getCommonHeight(row, containerWidth, margin);\n    for (let j = path[i - 1]; j < path[i]; ++j) {\n      photos[j].width = round(height * ratio(photos[j]), 1);\n      photos[j].height = height;\n    }\n  }\n  return photos;\n};\n\n",
        "called_code_segment_file_1": "export const round = (value: number, decimals = 0) => {\n  return Number(Math.round(Number(`${value}e${decimals}`)) + \"e-\" + decimals);\n};",
        "invoking_code_segment_file_2": "import { round } from \"./round\";\n\n// guesstimate how many neighboring nodes should be searched based on\n// the aspect ratio of the container with images having an avg AR of 1.5\n// as the minimum amount of photos per row, plus some nodes\nexport const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  return round(rowAR / 1.5) + 8;\n};",
        "called_code_segment_file_2": "export const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  return round(rowAR / 1.5) + 8;\n};",
        "using_code_segment_file_3": "import { findIdealNodeSearch } from \"./findIdealNodeSearch\";\n\nif (containerWidth >= 450) {\n  limitNodeSearch = findIdealNodeSearch({ containerWidth, targetRowHeight });\n}",
        "called_code_segment_file_3": "export const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  return round(rowAR / 1.5) + 8;\n};",
        "using_code_segment_file_4": "// No relevant segment in #file 4",
        "feature_description": "Add a feature to adjust the rounding precision based on the container width.",
        "detailed_feature_description": "Modify the `round` function in #file 1 to accept an additional parameter for rounding precision. Update the `findIdealNodeSearch` function in #file 2 to pass the new parameter based on the container width. Ensure that #file 3 correctly handles the updated `findIdealNodeSearch` function. No changes are required in #file 4 as it does not interact with the modified segments.",
        "modified_complete_code": {
            "file_1": "//Modify\nexport const round = (value: number, decimals = 0, precision = 2) => {\n  return Number(Math.round(Number(`${value}e${decimals}`)) + \"e-\" + precision);\n};",
            "file_2": "import { round } from \"./round\";\n\n//Modify\nexport const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  const precision = containerWidth >= 600 ? 3 : 2;\n  return round(rowAR / 1.5, 0, precision) + 8;\n};",
            "file_3": "import { findIdealNodeSearch } from \"./findIdealNodeSearch\";\n\n//Modify\nif (containerWidth >= 450) {\n  limitNodeSearch = findIdealNodeSearch({ containerWidth, targetRowHeight });\n}",
            "file_4": "// No changes required"
        }
    },
    {
        "repo": "cdk-intrinsic-validator",
        "content": "'cdk-intrinsic-validator/src/assets.ts'\n:import * as path from 'path';\n\nexport const LAMBDA_ASSET_DIR = path.join(__dirname, '..', 'lambda');\n'cdk-intrinsic-validator/src/alarm-monitor.ts'\n:import * as cdk from 'aws-cdk-lib';\nimport * as cw from 'aws-cdk-lib/aws-cloudwatch';\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as lambda from 'aws-cdk-lib/aws-lambda';\nimport * as logs from 'aws-cdk-lib/aws-logs';\nimport * as sfn from 'aws-cdk-lib/aws-stepfunctions';\nimport * as sfn_tasks from 'aws-cdk-lib/aws-stepfunctions-tasks';\nimport { Construct } from 'constructs';\nimport { LAMBDA_ASSET_DIR } from './assets';\n\n/**\n * A CloudWatch alarm monitor.\n */\nexport interface IAlarmMonitor {\n  /**\n   * The Step Functions state machine.\n   */\n  readonly stateMachine: sfn.IStateMachine;\n\n  /**\n   * Create input for a state machine execution.\n   */\n  createTaskInput(options: AlarmMonitorTaskInputOptions): sfn.TaskInput;\n}\n\n/**\n * Task input options.\n */\nexport interface AlarmMonitorTaskInputOptions {\n  /** The alarm to monitor */\n  readonly alarm: cw.IAlarm;\n  /** The maximum duration to monitor */\n  readonly duration: cdk.Duration;\n}\n\n/**\n * Provides a State Machine to monitor CloudWatch Alarms.\n */\nexport class AlarmMonitor extends Construct implements IAlarmMonitor {\n  readonly stateMachine: sfn.IStateMachine;\n\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    const bugState = new sfn.Fail(this, 'BugState');\n\n    const checkAlarmStatusFunction = new lambda.Function(this, 'CheckAlarmStatusFunction', {\n      runtime: lambda.Runtime.NODEJS_LATEST,\n      handler: 'check-alarm-status.handler',\n      code: lambda.Code.fromAsset(LAMBDA_ASSET_DIR),\n      logRetention: logs.RetentionDays.ONE_MONTH,\n      initialPolicy: [\n        new iam.PolicyStatement({\n          effect: iam.Effect.ALLOW,\n          actions: ['cloudwatch:DescribeAlarms'],\n          resources: ['*'],\n        }),\n      ],\n    });\n\n    const checkAlarmStatus = new sfn_tasks.LambdaInvoke(this, 'CheckAlarmStatus', {\n      integrationPattern: sfn.IntegrationPattern.REQUEST_RESPONSE,\n      lambdaFunction: checkAlarmStatusFunction,\n      payload: sfn.TaskInput.fromObject({\n        'AlarmName.$': '$.AlarmName',\n        'MonitoringDurationSeconds.$': '$.MonitoringDurationSeconds',\n        'StartTime.$': '$$.Execution.StartTime',\n      }),\n      resultPath: '$.CheckAlarmStatus',\n      resultSelector: {\n        'Status.$': '$.Payload.Status',\n      },\n    });\n\n    checkAlarmStatus.addCatch(bugState);\n    checkAlarmStatus.addRetry({ maxAttempts: 3 });\n\n    const alarmStatusChoice = new sfn.Choice(this, 'AlarmStatusChoice');\n    const delayForNextCheckStatus = new sfn.Wait(this, 'DelayThenNextCheckStatus', {\n      time: sfn.WaitTime.duration(cdk.Duration.seconds(30)),\n    });\n    const failBecauseAlarming = new sfn.Fail(this, 'FailBecauseAlarming');\n    const noAlarm = new sfn.Succeed(this, 'NoAlarm');\n\n    const definition = sfn.Chain.start(checkAlarmStatus)\n      .next(alarmStatusChoice\n        .when(\n          sfn.Condition.stringEquals('$.CheckAlarmStatus.Status', 'ALARM'),\n          failBecauseAlarming,\n        )\n        .when(\n          sfn.Condition.stringEquals('$.CheckAlarmStatus.Status', 'MONITORING'),\n          delayForNextCheckStatus\n            .next(checkAlarmStatus),\n        )\n        .when(\n          sfn.Condition.stringEquals('$.CheckAlarmStatus.Status', 'NO_ALARM'),\n          noAlarm,\n        )\n        .otherwise(bugState),\n      );\n\n    this.stateMachine = new sfn.StateMachine(this, 'StateMachine', {\n      definition: definition,\n    });\n  }\n\n  createTaskInput(options: AlarmMonitorTaskInputOptions): sfn.TaskInput {\n    return sfn.TaskInput.fromObject({\n      AlarmName: options.alarm.alarmName,\n      MonitoringDurationSeconds: options.duration.toSeconds(),\n    });\n  }\n}\n\n/**\n * Creates or re-uses a singleton alarm monitor.\n */\nexport class SingletonAlarmMonitor extends Construct implements IAlarmMonitor {\n  private readonly alarmMonitor: IAlarmMonitor;\n\n  public get stateMachine(): sfn.IStateMachine {\n    return this.alarmMonitor.stateMachine;\n  }\n\n  constructor(scope: Construct, id: string) {\n    super(scope, id);\n\n    const stack = cdk.Stack.of(this);\n    this.alarmMonitor = stack.node.tryFindChild('SingletonAlarmMonitor') as AlarmMonitor\n      ?? new AlarmMonitor(stack, 'SingletonAlarmMonitor');\n  }\n\n  createTaskInput(options: AlarmMonitorTaskInputOptions): sfn.TaskInput {\n    return this.alarmMonitor.createTaskInput(options);\n  }\n}\n'cdk-intrinsic-validator/test/integ/integ.error-message.ts'\n:import * as cdk from 'aws-cdk-lib';\nimport * as ecs from 'aws-cdk-lib/aws-ecs';\nimport { Construct } from 'constructs';\nimport { TestAlarms } from './test-alarms';\nimport { TestLambdas } from './test-lambdas';\nimport {\n  FargateValidationFactory,\n  IntrinsicValidator,\n  // @ts-ignore\n  Validation,\n} from '../../src';\nimport { SingletonAlarmMonitor } from '../../src/alarm-monitor';\n\n/** @internal */\nexport class IntegErrorMessage extends cdk.Stack {\n  constructor(scope: Construct, props: cdk.StackProps = {}) {\n    super(scope, 'IntegErrorMessage', props);\n\n    const cluster = new ecs.Cluster(this, 'Cluster');\n\n    // @ts-ignore\n    const testLambdas = new TestLambdas(this, 'TestLambdas');\n    // @ts-ignore\n    const testAlarms = new TestAlarms(this, 'TestAlarms');\n    // @ts-ignore\n    const factory = new FargateValidationFactory(this, 'FargateValidationFactory', {\n      cluster,\n    });\n\n    // Pre-populate this so it's faster to deploy when you uncomment the\n    // monitorAlarm validation.\n    // @ts-ignore\n    const monitor = new SingletonAlarmMonitor(this, 'AlarmMonitor');\n\n    new IntrinsicValidator(this, 'IntrinsicValidator', {\n      validations: [\n        // Uncomment any of the following to test their failure messages:\n\n        // factory.runContainer({\n        //   image: ecs.ContainerImage.fromRegistry('alpine:3'),\n        //   command: ['sh', '-c', 'exit 1'],\n        // }),\n\n        // Validation.lambdaInvokeSucceeds({\n        //   label: 'Check That Error Messages Show',\n        //   lambdaFunction: testLambdas.alwaysFails,\n        // }),\n\n        // Validation.monitorAlarm({\n        //   alarm: testAlarms.alwaysAlarming,\n        //   duration: cdk.Duration.seconds(10),\n        // }),\n\n        // Validation.stateMachineExecutionSucceeds({\n        //   stateMachine: monitor.stateMachine,\n        //   input: monitor.createTaskInput({\n        //     alarm: testAlarms.alwaysAlarming,\n        //     duration: cdk.Duration.seconds(10),\n        //   }),\n        // }),\n      ],\n    });\n  }\n}\n\nif (!module.parent) {\n  const app = new cdk.App();\n  new IntegErrorMessage(app, {\n    env: {\n      account: process.env.CDK_DEFAULT_ACCOUNT,\n      region: process.env.CDK_DEFAULT_REGION,\n    },\n  });\n}\n\n'cdk-intrinsic-validator/test/integ/integ.error-message.test.ts'\n:import * as cdk from 'aws-cdk-lib';\nimport { Template } from 'aws-cdk-lib/assertions';\nimport { IntegErrorMessage } from './integ.error-message';\nimport { DisableRandomnessContextKey } from '../../src';\n\ntest('snapshot', () => {\n  const app = new cdk.App({\n    context: {\n      [DisableRandomnessContextKey]: true,\n    },\n  });\n\n  const stack = new IntegErrorMessage(app);\n  expect(Template.fromStack(stack).toJSON()).toMatchSnapshot();\n});\n",
        "called_code_segment_file_1": "createTaskInput(options: AlarmMonitorTaskInputOptions): sfn.TaskInput {\n    return sfn.TaskInput.fromObject({\n      AlarmName: options.alarm.alarmName,\n      MonitoringDurationSeconds: options.duration.toSeconds(),\n    });\n  }",
        "invoking_code_segment_file_2": "const monitor = new SingletonAlarmMonitor(this, 'AlarmMonitor');\n\nnew IntrinsicValidator(this, 'IntrinsicValidator', {\n  validations: [\n    Validation.monitorAlarm({\n      alarm: testAlarms.alwaysAlarming,\n      duration: cdk.Duration.seconds(10),\n    }),\n  ],\n});",
        "called_code_segment_file_2": "Validation.monitorAlarm({ alarm, duration }) {\n  return { type: 'monitorAlarm', alarm, duration };\n}",
        "using_code_segment_file_3": "Validation.monitorAlarm({ alarm, duration }) {\n  return { type: 'monitorAlarm', alarm, duration };\n}",
        "called_code_segment_file_3": "Validation.monitorAlarm({ alarm, duration }) {\n  return { type: 'monitorAlarm', alarm, duration };\n}",
        "using_code_segment_file_4": "Validation.monitorAlarm({ alarm, duration }) {\n  return { type: 'monitorAlarm', alarm, duration };\n}",
        "feature_description": "Add a feature to log the alarm status before returning the task input in the AlarmMonitor class.",
        "detailed_feature_description": "The new feature involves modifying the createTaskInput method in the AlarmMonitor class to log the alarm status before returning the task input. This change will be propagated to the SingletonAlarmMonitor class and the IntrinsicValidator class, ensuring that the logging feature is integrated across the interactions.",
        "modified_complete_code": {
            "file_1": "createTaskInput(options: AlarmMonitorTaskInputOptions): sfn.TaskInput {\n    console.log(`Alarm Status: ${options.alarm.alarmName}`);\n    return sfn.TaskInput.fromObject({\n      AlarmName: options.alarm.alarmName,\n      MonitoringDurationSeconds: options.duration.toSeconds(),\n    });\n  }",
            "file_2": "const monitor = new SingletonAlarmMonitor(this, 'AlarmMonitor');\n\nnew IntrinsicValidator(this, 'IntrinsicValidator', {\n  validations: [\n    Validation.monitorAlarm({\n      alarm: testAlarms.alwaysAlarming,\n      duration: cdk.Duration.seconds(10),\n    }),\n  ],\n});",
            "file_3": "Validation.monitorAlarm({ alarm, duration }) {\n  return { type: 'monitorAlarm', alarm, duration };\n}",
            "file_4": "Validation.monitorAlarm({ alarm, duration }) {\n  return { type: 'monitorAlarm', alarm, duration };\n}"
        }
    },
    {
        "repo": "chatgpt-minimal",
        "content": "'chatgpt-minimal/src/components/ChatGPT/interface.ts'\n:import type { ReactNode } from 'react'\n\nexport enum ChatRole {\n  Assistant = 'assistant',\n  User = 'user',\n  System = 'system'\n}\n\nexport interface ChatGPTProps {\n  fetchPath: string\n}\n\nexport interface ChatMessage {\n  content: string\n  role: ChatRole\n}\n\nexport interface ChatMessageItemProps {\n  message: ChatMessage\n}\n\nexport interface SendBarProps {\n  loading: boolean\n  disabled: boolean\n  onSend: (message: ChatMessage) => void\n  onClear: () => void\n  onStop: () => void\n}\n\nexport interface ShowProps {\n  loading?: boolean\n  fallback?: ReactNode\n  children?: ReactNode\n}\n\n'chatgpt-minimal/src/components/ChatGPT/Show.tsx'\n:import React from 'react'\n\nimport { ShowProps } from './interface'\n\nconst Show = (props: ShowProps) => {\n  const { loading, fallback, children } = props\n\n  return <>{loading ? fallback : children}</>\n}\n\nexport default Show\n\n'chatgpt-minimal/src/components/ChatGPT/SendBar.tsx'\n:import React, { KeyboardEventHandler, useRef } from 'react'\n\nimport { ClearOutlined, SendOutlined } from '@ant-design/icons'\n\nimport { ChatRole, SendBarProps } from './interface'\nimport Show from './Show'\n\nconst SendBar = (props: SendBarProps) => {\n  const { loading, disabled, onSend, onClear, onStop } = props\n\n  const inputRef = useRef<HTMLTextAreaElement>(null)\n\n  const onInputAutoSize = () => {\n    if (inputRef.current) {\n      inputRef.current.style.height = 'auto'\n      inputRef.current.style.height = inputRef.current.scrollHeight + 'px'\n    }\n  }\n\n  const handleClear = () => {\n    if (inputRef.current) {\n      inputRef.current.value = ''\n      inputRef.current.style.height = 'auto'\n      onClear()\n    }\n  }\n\n  const handleSend = () => {\n    const content = inputRef.current?.value\n    if (content) {\n      inputRef.current!.value = ''\n      inputRef.current!.style.height = 'auto'\n      onSend({\n        content,\n        role: ChatRole.User\n      })\n    }\n  }\n\n  const onKeydown: KeyboardEventHandler<HTMLTextAreaElement> = (e) => {\n    if (e.shiftKey) {\n      return\n    }\n\n    if (e.key === 'Enter' && !e.nativeEvent.isComposing) {\n      handleSend()\n    }\n  }\n\n  return (\n    <Show\n      fallback={\n        <div className=\"thinking\">\n          <span>Please wait ...</span>\n          <div className=\"stop\" onClick={onStop}>\n            Stop\n          </div>\n        </div>\n      }\n      loading={loading}\n    >\n      <div className=\"send-bar\">\n        <textarea\n          ref={inputRef!}\n          className=\"input\"\n          disabled={disabled}\n          placeholder=\"Shift + Enter for new line\"\n          autoComplete=\"off\"\n          rows={1}\n          onKeyDown={onKeydown}\n          onInput={onInputAutoSize}\n        />\n        <button className=\"button\" title=\"Send\" disabled={disabled} onClick={handleSend}>\n          <SendOutlined />\n        </button>\n        <button className=\"button\" title=\"Clear\" disabled={disabled} onClick={handleClear}>\n          <ClearOutlined />\n        </button>\n      </div>\n    </Show>\n  )\n}\n\nexport default SendBar\n\n'chatgpt-minimal/src/components/ChatGPT/index.tsx'\n:import React from 'react'\n\nimport { ChatGPTProps, ChatRole } from './interface'\nimport MessageItem from './MessageItem'\nimport SendBar from './SendBar'\nimport { useChatGPT } from './useChatGPT'\n\nimport './index.less'\nimport 'highlight.js/styles/atom-one-dark.css'\n\nconst ChatGPT = (props: ChatGPTProps) => {\n  const { loading, disabled, messages, currentMessage, onSend, onClear, onStop } = useChatGPT(props)\n\n  return (\n    <div className=\"chat-wrapper\">\n      {messages.map((message, index) => (\n        <MessageItem key={index} message={message} />\n      ))}\n      {currentMessage.current && (\n        <MessageItem message={{ content: currentMessage.current, role: ChatRole.Assistant }} />\n      )}\n      <SendBar\n        loading={loading}\n        disabled={disabled}\n        onSend={onSend}\n        onClear={onClear}\n        onStop={onStop}\n      />\n    </div>\n  )\n}\n\nexport default ChatGPT\n\n",
        "called_code_segment_file_1": "const Show = (props: ShowProps) => {\n  const { loading, fallback, children } = props\n\n  return <>{loading ? fallback : children}</>\n}",
        "invoking_code_segment_file_2": "const SendBar = (props: SendBarProps) => {\n  const { loading, disabled, onSend, onClear, onStop } = props\n\n  const inputRef = useRef<HTMLTextAreaElement>(null)\n\n  const onInputAutoSize = () => {\n    if (inputRef.current) {\n      inputRef.current.style.height = 'auto'\n      inputRef.current.style.height = inputRef.current.scrollHeight + 'px'\n    }\n  }\n\n  const handleClear = () => {\n    if (inputRef.current) {\n      inputRef.current.value = ''\n      inputRef.current.style.height = 'auto'\n      onClear()\n    }\n  }\n\n  const handleSend = () => {\n    const content = inputRef.current?.value\n    if (content) {\n      inputRef.current!.value = ''\n      inputRef.current!.style.height = 'auto'\n      onSend({\n        content,\n        role: ChatRole.User\n      })\n    }\n  }\n\n  const onKeydown: KeyboardEventHandler<HTMLTextAreaElement> = (e) => {\n    if (e.shiftKey) {\n      return\n    }\n\n    if (e.key === 'Enter' && !e.nativeEvent.isComposing) {\n      handleSend()\n    }\n  }\n\n  return (\n    <Show\n      fallback={\n        <div className=\"thinking\">\n          <span>Please wait ...</span>\n          <div className=\"stop\" onClick={onStop}>\n            Stop\n          </div>\n        </div>\n      }\n      loading={loading}\n    >\n      <div className=\"send-bar\">\n        <textarea\n          ref={inputRef!}\n          className=\"input\"\n          disabled={disabled}\n          placeholder=\"Shift + Enter for new line\"\n          autoComplete=\"off\"\n          rows={1}\n          onKeyDown={onKeydown}\n          onInput={onInputAutoSize}\n        />\n        <button className=\"button\" title=\"Send\" disabled={disabled} onClick={handleSend}>\n          <SendOutlined />\n        </button>\n        <button className=\"button\" title=\"Clear\" disabled={disabled} onClick={handleClear}>\n          <ClearOutlined />\n        </button>\n      </div>\n    </Show>\n  )\n}",
        "called_code_segment_file_2": "const SendBar = (props: SendBarProps) => {\n  const { loading, disabled, onSend, onClear, onStop } = props\n\n  const inputRef = useRef<HTMLTextAreaElement>(null)\n\n  const onInputAutoSize = () => {\n    if (inputRef.current) {\n      inputRef.current.style.height = 'auto'\n      inputRef.current.style.height = inputRef.current.scrollHeight + 'px'\n    }\n  }\n\n  const handleClear = () => {\n    if (inputRef.current) {\n      inputRef.current.value = ''\n      inputRef.current.style.height = 'auto'\n      onClear()\n    }\n  }\n\n  const handleSend = () => {\n    const content = inputRef.current?.value\n    if (content) {\n      inputRef.current!.value = ''\n      inputRef.current!.style.height = 'auto'\n      onSend({\n        content,\n        role: ChatRole.User\n      })\n    }\n  }\n\n  const onKeydown: KeyboardEventHandler<HTMLTextAreaElement> = (e) => {\n    if (e.shiftKey) {\n      return\n    }\n\n    if (e.key === 'Enter' && !e.nativeEvent.isComposing) {\n      handleSend()\n    }\n  }\n\n  return (\n    <Show\n      fallback={\n        <div className=\"thinking\">\n          <span>Please wait ...</span>\n          <div className=\"stop\" onClick={onStop}>\n            Stop\n          </div>\n        </div>\n      }\n      loading={loading}\n    >\n      <div className=\"send-bar\">\n        <textarea\n          ref={inputRef!}\n          className=\"input\"\n          disabled={disabled}\n          placeholder=\"Shift + Enter for new line\"\n          autoComplete=\"off\"\n          rows={1}\n          onKeyDown={onKeydown}\n          onInput={onInputAutoSize}\n        />\n        <button className=\"button\" title=\"Send\" disabled={disabled} onClick={handleSend}>\n          <SendOutlined />\n        </button>\n        <button className=\"button\" title=\"Clear\" disabled={disabled} onClick={handleClear}>\n          <ClearOutlined />\n        </button>\n      </div>\n    </Show>\n  )\n}",
        "using_code_segment_file_3": "const ChatGPT = (props: ChatGPTProps) => {\n  const { loading, disabled, messages, currentMessage, onSend, onClear, onStop } = useChatGPT(props)\n\n  return (\n    <div className=\"chat-wrapper\">\n      {messages.map((message, index) => (\n        <MessageItem key={index} message={message} />\n      ))}\n      {currentMessage.current && (\n        <MessageItem message={{ content: currentMessage.current, role: ChatRole.Assistant }} />\n      )}\n      <SendBar\n        loading={loading}\n        disabled={disabled}\n        onSend={onSend}\n        onClear={onClear}\n        onStop={onStop}\n      />\n    </div>\n  )\n}",
        "called_code_segment_file_3": "",
        "using_code_segment_file_4": "",
        "feature_description": "Add a feature to allow users to edit their sent messages.",
        "detailed_feature_description": "The new feature allows users to edit their sent messages. When a user clicks on a sent message, it becomes editable. The changes are saved when the user presses Enter or clicks outside the input field. This feature requires modifications in the SendBar component to handle the editing functionality and updates in the ChatGPT component to manage the state of editable messages.",
        "modified_complete_code": {
            "file_1": "const Show = (props: ShowProps) => {\n  const { loading, fallback, children } = props\n\n  return <>{loading ? fallback : children}</>\n}",
            "file_2": "const SendBar = (props: SendBarProps) => {\n  const { loading, disabled, onSend, onClear, onStop, onEdit } = props\n\n  const inputRef = useRef<HTMLTextAreaElement>(null)\n\n  const onInputAutoSize = () => {\n    if (inputRef.current) {\n      inputRef.current.style.height = 'auto'\n      inputRef.current.style.height = inputRef.current.scrollHeight + 'px'\n    }\n  }\n\n  const handleClear = () => {\n    if (inputRef.current) {\n      inputRef.current.value = ''\n      inputRef.current.style.height = 'auto'\n      onClear()\n    }\n  }\n\n  const handleSend = () => {\n    const content = inputRef.current?.value\n    if (content) {\n      inputRef.current!.value = ''\n      inputRef.current!.style.height = 'auto'\n      onSend({\n        content,\n        role: ChatRole.User\n      })\n    }\n  }\n\n  const handleEdit = (message: ChatMessage) => {\n    if (inputRef.current) {\n      inputRef.current.value = message.content\n      inputRef.current.style.height = 'auto'\n      inputRef.current.style.height = inputRef.current.scrollHeight + 'px'\n      onEdit(message)\n    }\n  }\n\n  const onKeydown: KeyboardEventHandler<HTMLTextAreaElement> = (e) => {\n    if (e.shiftKey) {\n      return\n    }\n\n    if (e.key === 'Enter' && !e.nativeEvent.isComposing) {\n      handleSend()\n    }\n  }\n\n  return (\n    <Show\n      fallback={\n        <div className=\"thinking\">\n          <span>Please wait ...</span>\n          <div className=\"stop\" onClick={onStop}>\n            Stop\n          </div>\n        </div>\n      }\n      loading={loading}\n    >\n      <div className=\"send-bar\">\n        <textarea\n          ref={inputRef!}\n          className=\"input\"\n          disabled={disabled}\n          placeholder=\"Shift + Enter for new line\"\n          autoComplete=\"off\"\n          rows={1}\n          onKeyDown={onKeydown}\n          onInput={onInputAutoSize}\n        />\n        <button className=\"button\" title=\"Send\" disabled={disabled} onClick={handleSend}>\n          <SendOutlined />\n        </button>\n        <button className=\"button\" title=\"Clear\" disabled={disabled} onClick={handleClear}>\n          <ClearOutlined />\n        </button>\n      </div>\n    </Show>\n  )\n}",
            "file_3": "const ChatGPT = (props: ChatGPTProps) => {\n  const { loading, disabled, messages, currentMessage, onSend, onClear, onStop, onEdit } = useChatGPT(props)\n\n  return (\n    <div className=\"chat-wrapper\">\n      {messages.map((message, index) => (\n        <MessageItem key={index} message={message} onEdit={onEdit} />\n      ))}\n      {currentMessage.current && (\n        <MessageItem message={{ content: currentMessage.current, role: ChatRole.Assistant }} />\n      )}\n      <SendBar\n        loading={loading}\n        disabled={disabled}\n        onSend={onSend}\n        onClear={onClear}\n        onStop={onStop}\n        onEdit={onEdit}\n      />\n    </div>\n  )\n}",
            "file_4": ""
        }
    },
    {
        "repo": "Day59-Angular-Practice",
        "content": "'Day59-Angular-Practice/app/task.ts'\n:export class Task {\n  public done: boolean = false;\n  public points: number = 0;\n  constructor(public description: string, public id: number) {\n\n  }\n\n}\n\nexport function capitalize(task: Task) {\n  task.description = task.description.toUpperCase();\n}\n\n'Day59-Angular-Practice/app/edit-task.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {DeleteTaskComponent} from './delete-task.component';\nimport {AppComponent} from './app.component';\n\n@Component ({\n  selector: 'edit-task',\n  inputs: ['task'],\n  template: `\n    <div class=\"task-form\">\n      <h3>Edit Description: </h3>\n      <input [(ngModel)]=\"task.description\" class=\"col-sm-8 input-lg task-form\"/>\n    </div>\n  `\n})\nexport class EditTaskComponent {\n  public task = new Task(\"hey\", 3);\n}\n\n'Day59-Angular-Practice/app/task-list.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {DeleteTaskComponent} from './delete-task.component';\nimport {AppComponent} from './app.component';\nimport {EditTaskComponent} from './edit-task.component'\nimport {PointsComponent} from './points.component'\n\n@Component({\n  selector: 'task-list',\n  inputs: ['newtasks'],\n  directives: [DeleteTaskComponent, NewTaskComponent, EditTaskComponent, PointsComponent],\n  template: `\n    <new-task\n      (emitTasks)=\"concatArrays($event)\">\n    </new-task>\n    <h3\n      *ngFor=\"#task of newtasks\"\n      (click)=\"selectTask(task)\">\n      <h1>\n      {{task.description}}\n      </h1>\n      <points [task] = \"task\" [fakeList] = \"newtasks\"></points>\n      <delete-task\n        (click) =\"delete(task)\">\n      </delete-task>\n    </h3>\n    <edit-task *ngIf = \"selectedTask\" [task] = \"selectedTask\">\n    </edit-task>\n  `\n})\n\nexport class TaskListComponent {\n  public newtasks: Task[] = [];\n  public selectedTask: Task;\n  constructor() {\n    this.newtasks = [\n      new Task(\"New\", 0),\n      new Task(\"Learn Kung Fu\", 1),\n      new Task(\"Learn Kung Fu\", 2),\n      new Task(\"Create To-Do List app.\", 3)\n    ]\n  }\n  concatArrays(newTasks: Task[]): void {\n    this.newtasks = this.newtasks.concat(newTasks);\n    console.log(this.newtasks);\n  }\n  taskDeleted(taskSelected) {\n    function callBack(value, index, array) {\n      if (taskSelected !== value) {\n        return taskSelected;\n      };\n    };\n    this.newtasks = this.newtasks.filter(callBack);\n  }\n  selectTask(clicked: Task): void {\n    this.selectedTask = clicked;\n    console.log(\"got it\");\n    console.log(\"selected task: \" + this.selectedTask.description);\n  }\n\n  delete(beerSelected: Task) {\n    // var num = this.newtasks.length;\n    // console.log(num);\n    for (var i =0; i<this.newtasks.length; i++){\n      if(beerSelected.id === this.newtasks[i].id){\n        this.newtasks.splice(i, 1);\n        return true;\n      }\n    }\n  }\n}\n\n'Day59-Angular-Practice/app/app.component.ts'\n:import {Component, EventEmitter} from 'angular2/core';\nimport {Task} from './task';\nimport {capitalize} from './task';\nimport {NewTaskComponent} from './new-task.component';\nimport {TaskListComponent} from './task-list.component';\n\n\n@Component({\n  selector: 'my-app',\n  directives: [NewTaskComponent, TaskListComponent],\n  template: `\n  <h1>hi</h1>\n  <task-list></task-list>\n\n  `\n})\n\nexport class AppComponent {\n\n}\n\n",
        "called_code_segment_file_1": "public task = new Task(\"hey\", 3);",
        "invoking_code_segment_file_2": "selectTask(clicked: Task): void { this.selectedTask = clicked; console.log(\"got it\"); console.log(\"selected task: \" + this.selectedTask.description); }",
        "called_code_segment_file_2": "selectTask(clicked: Task): void { this.selectedTask = clicked; console.log(\"got it\"); console.log(\"selected task: \" + this.selectedTask.description); }",
        "using_code_segment_file_3": "public task = new Task(\"hey\", 3);",
        "called_code_segment_file_3": "public task = new Task(\"hey\", 3);",
        "using_code_segment_file_4": "public task = new Task(\"hey\", 3);",
        "feature_description": "Add a feature to allow users to mark tasks as 'completed' and display a count of completed tasks.",
        "detailed_feature_description": "Modify the Task class to include a 'completed' property. Update the TaskListComponent to handle this new property and display the count of completed tasks. Ensure the EditTaskComponent and PointsComponent are updated to reflect this change.",
        "modified_complete_code": {
            "task.ts": "export class Task { public done: boolean = false; public points: number = 0; public completed: boolean = false; #Modify constructor(public description: string, public id: number) { } } export function capitalize(task: Task) { task.description = task.description.toUpperCase(); }",
            "task-list.component.ts": "import {Component, EventEmitter} from 'angular2/core'; import {Task} from './task'; import {capitalize} from './task'; import {NewTaskComponent} from './new-task.component'; import {DeleteTaskComponent} from './delete-task.component'; import {AppComponent} from './app.component'; import {EditTaskComponent} from './edit-task.component' import {PointsComponent} from './points.component' @Component({ selector: 'task-list', inputs: ['newtasks'], directives: [DeleteTaskComponent, NewTaskComponent, EditTaskComponent, PointsComponent], template: ` <new-task (emitTasks)=\"concatArrays($event)\"> </new-task> <h3 *ngFor=\"#task of newtasks\" (click)=\"selectTask(task)\"> <h1> {{task.description}} </h1> <points [task] = \"task\" [fakeList] = \"newtasks\"></points> <delete-task (click) =\"delete(task)\"> </delete-task> </h3> <edit-task *ngIf = \"selectedTask\" [task] = \"selectedTask\"> </edit-task> <div> Completed Tasks: {{completedTasksCount}} </div> #New ` }) export class TaskListComponent { public newtasks: Task[] = []; public selectedTask: Task; public completedTasksCount: number = 0; #Modify constructor() { this.newtasks = [ new Task(\"New\", 0), new Task(\"Learn Kung Fu\", 1), new Task(\"Learn Kung Fu\", 2), new Task(\"Create To-Do List app.\", 3) ] } concatArrays(newTasks: Task[]): void { this.newtasks = this.newtasks.concat(newTasks); console.log(this.newtasks); } taskDeleted(taskSelected) { function callBack(value, index, array) { if (taskSelected !== value) { return taskSelected; }; } this.newtasks = this.newtasks.filter(callBack); } selectTask(clicked: Task): void { this.selectedTask = clicked; console.log(\"got it\"); console.log(\"selected task: \" + this.selectedTask.description); } delete(beerSelected: Task) { for (var i =0; i<this.newtasks.length; i++){ if(beerSelected.id === this.newtasks[i].id){ this.newtasks.splice(i, 1); return true; } } } updateCompletedCount() { #New this.completedTasksCount = this.newtasks.filter(task => task.completed).length; } }",
            "edit-task.component.ts": "import {Component, EventEmitter} from 'angular2/core'; import {Task} from './task'; import {capitalize} from './task'; import {NewTaskComponent} from './new-task.component'; import {DeleteTaskComponent} from './delete-task.component'; import {AppComponent} from './app.component'; @Component ({ selector: 'edit-task', inputs: ['task'], template: ` <div class=\"task-form\"> <h3>Edit Description: </h3> <input [(ngModel)]=\"task.description\" class=\"col-sm-8 input-lg task-form\"/> <label> Completed: <input type=\"checkbox\" [(ngModel)]=\"task.completed\" (change)=\"updateCompletedCount()\"> #New </label> </div> ` }) export class EditTaskComponent { public task = new Task(\"hey\", 3); updateCompletedCount() { #New // This method will be implemented in TaskListComponent } }",
            "points.component.ts": "import {Component, EventEmitter} from 'angular2/core'; import {Task} from './task'; import {capitalize} from './task'; import {NewTaskComponent} from './new-task.component'; import {DeleteTaskComponent} from './delete-task.component'; import {AppComponent} from './app.component'; import {EditTaskComponent} from './edit-task.component' @Component({ selector: 'points', inputs: ['task', 'fakeList'], template: ` <div> Points: {{task.points}} </div> <div> Completed: {{task.completed}} #New </div> ` }) export class PointsComponent { public task = new Task(\"hey\", 3); public fakeList: Task[] = []; }"
        }
    },
    {
        "repo": "TwitterClone",
        "content": "'TwitterClone/components/Themed.tsx'\n:import * as React from 'react';\nimport { Text as DefaultText, View as DefaultView } from 'react-native';\n\nimport Colors from '../constants/Colors';\nimport useColorScheme from '../hooks/useColorScheme';\n\nexport function useThemeColor(\n  props: { light?: string; dark?: string },\n  colorName: keyof typeof Colors.light & keyof typeof Colors.dark\n) {\n  const theme = useColorScheme();\n  const colorFromProps = props[theme];\n\n  if (colorFromProps) {\n    return colorFromProps;\n  } else {\n    return Colors[theme][colorName];\n  }\n}\n\ntype ThemeProps = {\n  lightColor?: string;\n  darkColor?: string;\n};\n\nexport type TextProps = ThemeProps & DefaultText['props'];\nexport type ViewProps = ThemeProps & DefaultView['props'];\n\nexport function Text(props: TextProps) {\n  const { style, lightColor, darkColor, ...otherProps } = props;\n  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');\n\n  return <DefaultText style={[{ color }, style]} {...otherProps} />;\n}\n\nexport function View(props: ViewProps) {\n  const { style, lightColor, darkColor, ...otherProps } = props;\n  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');\n\n  return <DefaultView style={[{ backgroundColor }, style]} {...otherProps} />;\n}\n\n'TwitterClone/screens/TabTwoScreen.tsx'\n:import * as React from 'react';\nimport { StyleSheet } from 'react-native';\n\nimport EditScreenInfo from '../components/EditScreenInfo';\nimport { Text, View } from '../components/Themed';\n\nexport default function TabTwoScreen() {\n  return (\n    <View style={styles.container}>\n      <Text style={styles.title}>Tab Two</Text>\n      <View style={styles.separator} lightColor=\"#eee\" darkColor=\"rgba(255,255,255,0.1)\" />\n      <EditScreenInfo path=\"/screens/TabTwoScreen.tsx\" />\n    </View>\n  );\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  title: {\n    fontSize: 20,\n    fontWeight: 'bold',\n  },\n  separator: {\n    marginVertical: 30,\n    height: 1,\n    width: '80%',\n  },\n});\n\n'TwitterClone/navigation/BottomTabNavigator.tsx'\n:import {useEffect, useState} from 'react';\nimport { Ionicons, MaterialCommunityIcons } from '@expo/vector-icons';\nimport { createBottomTabNavigator } from '@react-navigation/bottom-tabs';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport * as React from 'react';\nimport {API, Auth, graphqlOperation} from 'aws-amplify';\n\nimport Colors from '../constants/Colors';\nimport useColorScheme from '../hooks/useColorScheme';\nimport HomeScreen from '../screens/HomeScreen';\nimport TabTwoScreen from '../screens/TabTwoScreen';\nimport { BottomTabParamList, HomeNavigatorParamList, TabTwoParamList } from '../types';\nimport ProfilePicture from '../components/ProfilePicture';\nimport { getUser } from '../src/graphql/queries';\n\nconst BottomTab = createBottomTabNavigator<BottomTabParamList>();\n\nexport default function BottomTabNavigator() {\n  const colorScheme = useColorScheme();\n\n  return (\n    <BottomTab.Navigator\n      initialRouteName=\"Home\"\n      tabBarOptions={{\n        activeTintColor: Colors[colorScheme].tint,\n        showLabel: false,\n      }}>\n      <BottomTab.Screen\n        name=\"Home\"\n        component={HomeNavigator}\n        options={{\n          tabBarIcon: ({ color }) => <TabBarIcon name=\"md-home\" color={color} />,\n        }}\n      />\n      <BottomTab.Screen\n        name=\"Search\"\n        component={TabTwoNavigator}\n        options={{\n          tabBarIcon: ({ color }) => <TabBarIcon name=\"ios-search\" color={color} />,\n        }}\n      />\n      <BottomTab.Screen\n        name=\"Notifications\"\n        component={TabTwoNavigator}\n        options={{\n          tabBarIcon: ({ color }) => <TabBarIcon name=\"ios-notifications-outline\" color={color} />,\n        }}\n      />\n      <BottomTab.Screen\n        name=\"Messages\"\n        component={TabTwoNavigator}\n        options={{\n          tabBarIcon: ({ color }) => <TabBarIcon name=\"ios-mail\" color={color} />,\n        }}\n      />\n    </BottomTab.Navigator>\n  );\n}\n\n// You can explore the built-in icon families and icons on the web at:\n// https://icons.expo.fyi/\nfunction TabBarIcon(props: { name: string; color: string }) {\n  return <Ionicons size={30} style={{ marginBottom: -3 }} {...props} />;\n}\n\n// Each tab has its own navigation stack, you can read more about this pattern here:\n// https://reactnavigation.org/docs/tab-based-navigation#a-stack-navigator-for-each-tab\nconst TabOneStack = createStackNavigator<HomeNavigatorParamList>();\n\nfunction HomeNavigator() {\n\n  const [user, setUser] = useState(null);\n\n  useEffect(() => {\n    // get the current user\n    const fetchUser = async () => {\n      const userInfo = await Auth.currentAuthenticatedUser({ bypassCache: true });\n      if (!userInfo) {\n        return;\n      }\n\n      try {\n        const userData = await API.graphql(graphqlOperation(getUser, { id: userInfo.attributes.sub }))\n        if (userData) {\n          setUser(userData.data.getUser);\n        }\n      } catch (e) {\n        console.log(e);\n      }\n    }\n    fetchUser();\n  }, [])\n\n  return (\n    <TabOneStack.Navigator>\n      <TabOneStack.Screen\n        name=\"HomeScreen\"\n        component={HomeScreen}\n        options={{\n          headerRightContainerStyle: {\n            marginRight: 15,\n          },\n          headerLeftContainerStyle: {\n            marginLeft: 15,\n          },\n          headerTitle: () => (\n            <Ionicons name={\"logo-twitter\"} size={30} color={Colors.light.tint}/>\n          ),\n          headerRight: () => (\n            <MaterialCommunityIcons name={\"star-four-points-outline\"} size={30} color={Colors.light.tint}/>\n          ),\n          headerLeft: () => (\n            <ProfilePicture size={40} image={user?.image} />\n          )\n        }}\n      />\n    </TabOneStack.Navigator>\n  );\n}\n\nconst TabTwoStack = createStackNavigator<TabTwoParamList>();\n\nfunction TabTwoNavigator() {\n  return (\n    <TabTwoStack.Navigator>\n      <TabTwoStack.Screen\n        name=\"TabTwoScreen\"\n        component={TabTwoScreen}\n        options={{ headerTitle: 'Tab Two Title' }}\n      />\n    </TabTwoStack.Navigator>\n  );\n}\n\n'TwitterClone/navigation/index.tsx'\n:import { NavigationContainer, DefaultTheme, DarkTheme } from '@react-navigation/native';\nimport { createStackNavigator } from '@react-navigation/stack';\nimport * as React from 'react';\nimport { ColorSchemeName } from 'react-native';\n\nimport NotFoundScreen from '../screens/NotFoundScreen';\nimport { RootStackParamList } from '../types';\nimport BottomTabNavigator from './BottomTabNavigator';\nimport LinkingConfiguration from './LinkingConfiguration';\nimport NewTweetScreen from \"../screens/NewTweetScreen\";\nimport Index from \"../screens/FleetScreen\";\n\n// If you are not familiar with React Navigation, we recommend going through the\n// \"Fundamentals\" guide: https://reactnavigation.org/docs/getting-started\nexport default function Navigation({ colorScheme }: { colorScheme: ColorSchemeName }) {\n  return (\n    <NavigationContainer\n      linking={LinkingConfiguration}\n      theme={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>\n      <RootNavigator />\n    </NavigationContainer>\n  );\n}\n\n// A root stack navigator is often used for displaying modals on top of all other content\n// Read more here: https://reactnavigation.org/docs/modal\nconst Stack = createStackNavigator<RootStackParamList>();\n\nfunction RootNavigator() {\n  return (\n    <Stack.Navigator screenOptions={{ headerShown: false }}>\n      <Stack.Screen name=\"Root\" component={BottomTabNavigator} />\n      <Stack.Screen name=\"NewTweet\" component={NewTweetScreen} />\n      <Stack.Screen name=\"Fleet\" component={Index} />\n      <Stack.Screen name=\"NotFound\" component={NotFoundScreen} options={{ title: 'Oops!' }} />\n    </Stack.Navigator>\n  );\n}\n\n",
        "called_code_segment_file_1": "export function Text(props: TextProps) {\n  const { style, lightColor, darkColor, ...otherProps } = props;\n  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');\n\n  return <DefaultText style={[{ color }, style]} {...otherProps} />;\n}",
        "invoking_code_segment_file_2": "<Text style={styles.title}>Tab Two</Text>",
        "called_code_segment_file_2": "const [user, setUser] = useState(null);\n\nuseEffect(() => {\n  // get the current user\n  const fetchUser = async () => {\n    const userInfo = await Auth.currentAuthenticatedUser({ bypassCache: true });\n    if (!userInfo) {\n      return;\n    }\n\n    try {\n      const userData = await API.graphql(graphqlOperation(getUser, { id: userInfo.attributes.sub }))\n      if (userData) {\n        setUser(userData.data.getUser);\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  fetchUser();\n}, [])",
        "using_code_segment_file_3": "<ProfilePicture size={40} image={user?.image} />",
        "called_code_segment_file_3": "Not applicable",
        "using_code_segment_file_4": "Not applicable",
        "feature_description": "Add a feature to display the user's full name instead of 'Tab Two' in the title.",
        "detailed_feature_description": "Modify the Text component in #file 1 to accept a new prop for the user's full name. Update the invoking code in #file 2 to pass the user's full name to the Text component. Ensure that the ProfilePicture component in #file 3 is updated to fetch and display the user's full name if available.",
        "modified_complete_code": {
            "file_1": "export function Text(props: TextProps & { fullName?: string }) {\n  const { style, lightColor, darkColor, fullName, ...otherProps } = props;\n  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');\n\n  return <DefaultText style={[{ color }, style]} {...otherProps}>{fullName || ''}</DefaultText>;\n} #Modify",
            "file_2": "import { Text } from '../components/Themed';\n\n<Text style={styles.title} fullName={user?.name}>{user?.name || 'Tab Two'}</Text> #Modify",
            "file_3": "import { Text } from '../components/Themed';\n\n<ProfilePicture size={40} image={user?.image} />\n<Text style={styles.fullName}>{user?.name}</Text> #New",
            "file_4": "Not applicable"
        }
    },
    {
        "repo": "WebView2Example",
        "content": "'WebView2Example/WebView2Example-Front/projects/demo-app/src/app/interfaces/events.enum.ts'\n:export enum EventsEnum {\n\n    // Update Floors\n    UpdateFloors= 'UpdateFloors',\n\n    //Common\n    Run = \"Run\",\n    Close = \"Close\",\n    ResizeWindow = \"ResizeWindow\",\n\n    // Nika\n    PopulatePlugins = \"PopulatePlugins\",\n    UpdatePlugins = \"UpdatePlugins\",\n\n    // Plugins\n    PopulateElements = \"PopulateElements\",\n    Save = \"Save\",\n    Load = \"Load\",\n\n}\n\n'WebView2Example/WebView2Example-Front/projects/demo-app/src/app/app.component.ts'\n:import {Component} from '@angular/core';\nimport {MatIconRegistry} from '@angular/material/icon';\nimport {DomSanitizer} from '@angular/platform-browser';\nimport {ActivatedRoute, Router, RoutesRecognized} from '@angular/router';\nimport {EventsEnum} from './interfaces/events.enum';\nimport {WebView2Service} from './services/webview2.service';\n\nexport interface WindowSize {\n    height: number;\n    width: number;\n}\n\nconst defaultTitle = 'Angular-Revit-WebView2';\n\n@Component({\n    selector: 'ktd-root',\n    templateUrl: './app.component.html',\n    styleUrls: ['./app.component.scss']\n})\nexport class KtdAppComponent {\n    title: string = defaultTitle;\n    size: WindowSize = {\n        width: 400,\n        height: 600,\n    };\n\n    constructor(private matIconRegistry: MatIconRegistry, private domSanitizer: DomSanitizer, private router: Router, private readonly route: ActivatedRoute,\n                private readonly wv2Service: WebView2Service) {\n        this.matIconRegistry.addSvgIcon(\n            `github`,\n            this.domSanitizer.bypassSecurityTrustResourceUrl(`assets/logos/github.svg`)\n        );\n\n        this.router.events.subscribe((data) => {\n            if (data instanceof RoutesRecognized) {\n                this.title = data.state.root.firstChild?.data.title || defaultTitle;\n            }\n        });\n    }\n\n    resizeWindow() {\n        this.wv2Service.postWebView2Message(EventsEnum.ResizeWindow, this.size);\n    }\n\n    close() {\n        this.wv2Service.postWebView2Message(EventsEnum.Close);\n    }\n}\n\n'WebView2Example/WebView2Example-Front/projects/demo-app/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { KtdAppComponent } from './app.component';\nimport { KtdAppRoutingModule } from './app-routing.module';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { HttpClientModule } from '@angular/common/http';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatButtonModule } from '@angular/material/button';\nimport { WebView2Service } from './services/webview2.service';\n\n@NgModule({\n    declarations: [\n        KtdAppComponent\n    ],\n    imports: [\n        BrowserModule,\n        BrowserAnimationsModule,\n        KtdAppRoutingModule,\n        HttpClientModule,\n        MatIconModule,\n        MatButtonModule\n    ],\n    providers: [],\n    bootstrap: [KtdAppComponent]\n})\nexport class KtdAppModule {}\n\n'WebView2Example/WebView2Example-Front/projects/demo-app/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { KtdAppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(KtdAppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "postWebView2Message(event: EventsEnum, data?: any) {\n        window.chrome.webview.postMessage({event, data});\n    }",
        "invoking_code_segment_file_2": "resizeWindow() {\n        this.wv2Service.postWebView2Message(EventsEnum.ResizeWindow, this.size);\n    }\n\n    close() {\n        this.wv2Service.postWebView2Message(EventsEnum.Close);\n    }",
        "called_code_segment_file_2": "postWebView2Message(event: EventsEnum, data?: any) {\n        window.chrome.webview.postMessage({event, data});\n    }",
        "using_code_segment_file_3": "constructor(private readonly wv2Service: WebView2Service) {\n        this.wv2Service.postWebView2Message(EventsEnum.UpdateFloors);\n    }",
        "called_code_segment_file_3": "postWebView2Message(event: EventsEnum, data?: any) {\n        window.chrome.webview.postMessage({event, data});\n    }",
        "using_code_segment_file_4": "constructor(private readonly wv2Service: WebView2Service) {\n        this.wv2Service.postWebView2Message(EventsEnum.PopulatePlugins);\n    }",
        "feature_description": "Add a new event type to the EventsEnum and update the WebView2Service to handle this new event.",
        "detailed_feature_description": "A new event type 'NewEvent' is added to the EventsEnum. The WebView2Service's postWebView2Message method is updated to handle this new event. The app.component.ts is updated to include a new method that triggers this event. The WebView2Service is further updated to handle the new event and send a corresponding message to the WebView2 environment.",
        "modified_complete_code": {
            "file_1": "export enum EventsEnum {\n    UpdateFloors= 'UpdateFloors',\n    Run = \"Run\",\n    Close = \"Close\",\n    ResizeWindow = \"ResizeWindow\",\n    PopulatePlugins = \"PopulatePlugins\",\n    UpdatePlugins = \"UpdatePlugins\",\n    PopulateElements = \"PopulateElements\",\n    Save = \"Save\",\n    Load = \"Load\",\n    NewEvent = \"NewEvent\" #New\n}",
            "file_2": "postWebView2Message(event: EventsEnum, data?: any) {\n        if (event === EventsEnum.NewEvent) {\n            window.chrome.webview.postMessage({event: EventsEnum.NewEvent, data: 'New Event Triggered'});\n        } else {\n            window.chrome.webview.postMessage({event, data});\n        }\n    } #Modify",
            "file_3": "constructor(private readonly wv2Service: WebView2Service) {\n        this.wv2Service.postWebView2Message(EventsEnum.UpdateFloors);\n        this.wv2Service.postWebView2Message(EventsEnum.NewEvent); #New\n    }",
            "file_4": "constructor(private readonly wv2Service: WebView2Service) {\n        this.wv2Service.postWebView2Message(EventsEnum.PopulatePlugins);\n        this.wv2Service.postWebView2Message(EventsEnum.NewEvent); #New\n    }"
        }
    },
    {
        "repo": "angular4-starter",
        "content": "'angular4-starter/src/app/components/http/http.fallback.service.ts'\n:import { Injectable } from '@angular/core';\nimport { Router } from '@angular/router';\nimport { Response } from '@angular/http';\nimport { NgbModal } from '@ng-bootstrap/ng-bootstrap';\nimport { BadCredentialsModalComponent } from '../services/modals/bad-credentials/bad-credentials.modal.component';\n\nimport { get } from 'lodash';\n\n@Injectable()\nexport class HttpFallback {\n\tconstructor(private router: Router,\n\t            private modalService: NgbModal) {\n\t}\n\n\tfallback(err: Response | any) {\n\t\tlet status = err.status;\n\t\tlet unavailableService = false;\n\n\t\t/** status === 0 for webpack dev server **/\n\t\tif (status >= 500 || status === 0) {\n\t\t\tunavailableService = true;\n\t\t} else {\n\t\t\t/** nothing here, manage custom errs from api **/\n\t\t\tif (!err || !err._body) {\n\t\t\t\tunavailableService = true;\n\t\t\t} else {\n\t\t\t\tconst code = get(JSON.parse(err._body), 'code');\n\n\t\t\t\tswitch (code) {\n\t\t\t\t\tcase 'invalid_credentials': {\n\t\t\t\t\t\tthis.modalService.open(BadCredentialsModalComponent);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (unavailableService) {\n\t\t\tthis.router.navigate(['unavailable-service']);\n\t\t}\n\t}\n}\n\n'angular4-starter/src/app/my-account/my-account.module.ts'\n:import { Injectable, NgModule } from '@angular/core';\nimport { Resolve, RouterModule, Routes } from '@angular/router';\nimport { SharedModule } from '../commons/shared.module';\n\nimport { MyAccountComponent } from './my-account.component';\nimport { Observable } from 'rxjs';\nimport { AuthHttp } from 'angular2-jwt';\nimport { Response } from '@angular/http';\nimport { StoreService } from '../components/storage/store.service';\nimport { HttpFallback } from '../components/http/http.fallback.service';\n\n/** MOVE DEFINITION INTERFACE ? **/\nexport interface Profile {\n\tname: string;\n\temail: string;\n}\n\n/** MOVE PROFILE RESOLVER ? **/\n@Injectable()\nexport class ProfileResolver implements Resolve<Response> {\n\tconstructor(private authHttp: AuthHttp,\n\t            private store: StoreService,\n\t            private httpFallback: HttpFallback) {\n\t}\n\n\tresolve(): Observable<Response> {\n\t\tlet profile = this.store.get('profile');\n\n\t\treturn this.authHttp.get('/api/profiles/' + profile.id)\n\t\t\t.catch((err) => {\n\t\t\t\tthis.httpFallback.fallback(err);\n\t\t\t\treturn Observable.throw(err);\n\t\t\t});\n\t}\n}\n\nconst routes: Routes = [\n\t{\n\t\tpath: 'my-account',\n\t\tcomponent: MyAccountComponent,\n\t\tresolve: { profile: ProfileResolver }\n\t}\n];\n\n@NgModule({\n\timports: [\n\t\tRouterModule.forChild(routes),\n\t\tSharedModule\n\t],\n\tdeclarations: [\n\t\tMyAccountComponent\n\t],\n\tproviders: [\n\t\tProfileResolver\n\t]\n})\n\nexport class MyAccountModule {}\n\n'angular4-starter/src/app/app.module.ts'\n:import { NgModule } from '@angular/core';\nimport { HttpModule, Http, BrowserXhr } from '@angular/http';\nimport { NgProgressModule, NgProgressBrowserXhr } from 'ngx-progressbar';\nimport { BrowserModule }  from '@angular/platform-browser';\nimport { TranslateStaticLoader, TranslateLoader, TranslateModule } from 'ng2-translate';\nimport { FormsModule } from '@angular/forms';\n\nimport { AppComponent } from './app.component';\nimport { AuthModule } from './components/auth/auth.module';\n\n/** PROVIDERS **/\nimport { AuthGuard } from './components/auth/auth-guard.service';\nimport { AuthService } from './components/auth/auth.service';\nimport { HttpFallback } from './components/http/http.fallback.service';\nimport { StoreService } from './components/storage/store.service';\n\n/*** MODULES ***/\nimport { HomeModule } from './home/home.module';\nimport { LoginModule } from './login/login.module';\nimport { MyAccountModule } from './my-account/my-account.module';\nimport { AboutModule } from './about/about.module';\nimport { UnavailableModule } from './unavailable/unavailable.module';\n\nimport { HeaderComponent } from './commons/header/header.component';\nimport { FooterComponent } from './commons/footer/footer.component';\n\nimport { NgbModule } from '@ng-bootstrap/ng-bootstrap';\nimport { routing } from './app.routing';\nimport { SharedModule } from './commons/shared.module';\n\n@NgModule({\n    imports: [\n        BrowserModule,\n        HttpModule,\n        NgProgressModule,\n        FormsModule,\n\t    NgbModule.forRoot(),\n        TranslateModule.forRoot({\n            provide: TranslateLoader,\n            useFactory: (http: Http) => new TranslateStaticLoader(http, '/public/locales', '.json'),\n            deps: [Http]\n        }),\n        routing,\n        SharedModule,\n        AuthModule,\n\t    HomeModule,\n\t    LoginModule,\n\t    MyAccountModule,\n\t    AboutModule,\n\t    UnavailableModule\n    ],\n    declarations: [\n        AppComponent,\n        HeaderComponent,\n        FooterComponent\n    ],\n    providers: [\n        AuthGuard,\n        AuthService,\n        StoreService,\n        HttpFallback,\n        { provide: BrowserXhr, useClass: NgProgressBrowserXhr }\n    ],\n    bootstrap: [ AppComponent ]\n})\n\nexport class AppModule {}\n\n'angular4-starter/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './app/app.module';\n\nexport function main() {\n    platformBrowserDynamic().bootstrapModule(AppModule);\n}\n\nconst ENV: any = process.env.ENV;\n\nif (ENV && ENV.mode !== 'development') {\n    enableProdMode();\n}\n\nif (document.readyState === 'complete') {\n    main();\n} else {\n    document.addEventListener('DOMContentLoaded', main);\n}\n\n",
        "called_code_segment_file_1": "fallback(err: Response | any) {\n\tlet status = err.status;\n\tlet unavailableService = false;\n\n\t/** status === 0 for webpack dev server **/\n\tif (status >= 500 || status === 0) {\n\t\tunavailableService = true;\n\t} else {\n\t\t/** nothing here, manage custom errs from api **/\n\t\tif (!err || !err._body) {\n\t\t\tunavailableService = true;\n\t\t} else {\n\t\t\tconst code = get(JSON.parse(err._body), 'code');\n\n\t\t\tswitch (code) {\n\t\t\t\tcase 'invalid_credentials': {\n\t\t\t\t\tthis.modalService.open(BadCredentialsModalComponent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unavailableService) {\n\t\tthis.router.navigate(['unavailable-service']);\n\t}\n}",
        "invoking_code_segment_file_2": "resolve(): Observable<Response> {\n\tlet profile = this.store.get('profile');\n\n\treturn this.authHttp.get('/api/profiles/' + profile.id)\n\t\t.catch((err) => {\n\t\t\tthis.httpFallback.fallback(err);\n\t\t\treturn Observable.throw(err);\n\t\t});\n}",
        "called_code_segment_file_2": "resolve(): Observable<Response> {\n\tlet profile = this.store.get('profile');\n\n\treturn this.authHttp.get('/api/profiles/' + profile.id)\n\t\t.catch((err) => {\n\t\t\tthis.httpFallback.fallback(err);\n\t\t\treturn Observable.throw(err);\n\t\t});\n}",
        "using_code_segment_file_3": "const routes: Routes = [\n\t{\n\t\tpath: 'my-account',\n\t\tcomponent: MyAccountComponent,\n\t\tresolve: { profile: ProfileResolver }\n\t}\n];",
        "called_code_segment_file_3": "const routes: Routes = [\n\t{\n\t\tpath: 'my-account',\n\t\tcomponent: MyAccountComponent,\n\t\tresolve: { profile: ProfileResolver }\n\t}\n];",
        "using_code_segment_file_4": "import { MyAccountModule } from './my-account/my-account.module';",
        "feature_description": "Add a new error code handling for 'session_expired' in the HttpFallback service.",
        "detailed_feature_description": "Modify the HttpFallback service to handle a new error code 'session_expired'. Update the ProfileResolver to use the modified HttpFallback service. Ensure the MyAccountModule routes are updated to use the new ProfileResolver. Finally, update the AppModule to include the new MyAccountModule.",
        "modified_complete_code": {
            "file_1": "fallback(err: Response | any) {\n\tlet status = err.status;\n\tlet unavailableService = false;\n\n\t/** status === 0 for webpack dev server **/\n\tif (status >= 500 || status === 0) {\n\t\tunavailableService = true;\n\t} else {\n\t\t/** nothing here, manage custom errs from api **/\n\t\tif (!err || !err._body) {\n\t\t\tunavailableService = true;\n\t\t} else {\n\t\t\tconst code = get(JSON.parse(err._body), 'code');\n\n\t\t\tswitch (code) {\n\t\t\t\tcase 'invalid_credentials': {\n\t\t\t\t\tthis.modalService.open(BadCredentialsModalComponent);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t#Modify case 'session_expired': {\n\t\t\t\t\tthis.router.navigate(['/login']);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unavailableService) {\n\t\tthis.router.navigate(['unavailable-service']);\n\t}\n}",
            "file_2": "resolve(): Observable<Response> {\n\tlet profile = this.store.get('profile');\n\n\treturn this.authHttp.get('/api/profiles/' + profile.id)\n\t\t.catch((err) => {\n\t\t\tthis.httpFallback.fallback(err);\n\t\t\treturn Observable.throw(err);\n\t\t});\n}",
            "file_3": "const routes: Routes = [\n\t{\n\t\tpath: 'my-account',\n\t\tcomponent: MyAccountComponent,\n\t\tresolve: { profile: ProfileResolver }\n\t}\n];",
            "file_4": "import { MyAccountModule } from './my-account/my-account.module';"
        }
    },
    {
        "repo": "crypto-prices-react",
        "content": "'crypto-prices-react/src/CryptoListItem.tsx'\n:import React, { Component } from 'react';\nimport { CryptoCurrencyDataType } from \"./Crypto\";\n\ninterface ListItemPropType {\n\tkey: number;\n\tcount: number;\n\tdata: CryptoCurrencyDataType;\n}\n\nclass CryptoListItem extends Component<ListItemPropType, {}> {\n\trender() {\n\t\treturn (\n\t\t\t<tr key = {this.props.count}>\n\t\t\t\t<td>{this.props.count}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"FROMSYMBOL\"]}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"PRICE\"]}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"SUPPLY\"]}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"CHANGE24HOUR\"]}</td>\n\t\t\t</tr>\n\t\t)\n\t}\n}\n\nexport default CryptoListItem;\n'crypto-prices-react/src/CryptoList.tsx'\n:import React, { Component } from 'react';\nimport CryptoListItem from './CryptoListItem';\nimport { CryptoDataType } from \"./Crypto\";\n\ninterface listPropTypes {\n\tdata: CryptoDataType\n}\n\nclass CryptoList extends Component<listPropTypes, {}> {\n\trender() {\n\t\tlet count = 0;\n\t\tconst data = this.props.data['DISPLAY'];\n\n\t\tif (!data) {\n\t\t\treturn (\n\t\t\t\t<tr>\n\t\t\t\t\t<td>1</td>\n\t\t\t\t\t<td>2</td>\n\t\t\t\t\t<td>3</td>\n\t\t\t\t\t<td>4</td>\n\t\t\t\t\t<td>5</td>\n\t\t\t\t</tr>\n\t\t\t);\n\t\t}\n\n\t\treturn Object.keys(data).map((k) => {\n\t\t\tcount++;\n\t\t\treturn (\n\t\t\t\t<CryptoListItem key={count} count={count} data={data[k]} />\n\t\t\t)\n\t\t});\n\t}\n}\n\nexport default CryptoList;\n'crypto-prices-react/src/CryptoContent.tsx'\n:import React, { Component } from 'react';\nimport CryptoList from './CryptoList';\nimport { CryptoDataType } from \"./Crypto\";\n\ninterface contentPropType {\n\tdata: CryptoDataType\n}\n\nclass CryptoContent extends Component<contentPropType, {}> {\n\trender() {\n\t\treturn (\n\t\t\t<tbody className=\"crypto__list--body\">\n\t\t\t\t<CryptoList data={this.props.data} />\n\t\t\t</tbody>\n\t\t);\n\t}\n}\n\nexport default CryptoContent;\n'crypto-prices-react/src/index.tsx'\n:import React, { Component } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport CryptoContent from './CryptoContent';\nimport { CryptoDataType } from \"./Crypto\";\n\ninterface StateType {\n    cryptoResult: CryptoDataType | null\n}\n\nclass App extends Component<{}, {}> {\n    componentDidMount() {\n        this.getCryptoData();\n    }\n\n    state: StateType = {\n        cryptoResult: null\n    }\n\n    cryptoObject(): object[] {\n        return JSON.parse('{\"Bitcoin\": \"BTC\",\"Ethereum\": \"ETH\",\"Ripple\": \"XRP\",\"Bitcoin Cash\": \"BCH\",\"Cardano\": \"ADA\",\"Litecoin\": \"LTC\",\"Dash\": \"DASH\",\"Monero\": \"XHR\",\"Bitcoin Gold\": \"BTG\",\"Ethereum Classic\": \"ETC\",\"Zcash\": \"ZEC\"}');\n    }\n\n    objectToArray(thisObject: object[]): any[] {\n        return Object.keys(thisObject).map((k: any): any => {\n            return thisObject[k];\n        });\n    }\n\n    getCryptoData() {\n        const cryptoSymbols = this.cryptoObject();\n        fetch(`https://min-api.cryptocompare.com/data/pricemultifull?fsyms=${(this.objectToArray(cryptoSymbols)).join(\",\")}&tsyms=USD`)\n            .then((response) => {\n                return response.json();\n            })\n            .then((data: CryptoDataType) => {\n                this.setState({\n                    cryptoResult: data\n                })\n            })\n            .catch((err) => {\n                console.error(`Fetch error: ${err}`)\n            });\n    }\n\n    render() {\n        if (!this.state.cryptoResult) return ( <p> Loading... </p> );\n\n        return (\n            <table className=\"crypto__list\">\n                <thead className=\"crypto__list--header\">\n                <tr>\n                    <th>#</th>\n                    <th>Crypto</th>\n                    <th>Price</th>\n                    <th>Circulating Supply</th>\n                    <th>Change (24h)</th>\n                </tr>\n                </thead>\n                <CryptoContent data={this.state.cryptoResult} />\n            </table>\n        )\n    }\n}\n\nReactDOM.createRoot(\n    document.getElementById('container') as HTMLElement\n)\n    .render(\n        <React.StrictMode>\n            <App />\n        </React.StrictMode>\n    );\n",
        "called_code_segment_file_1": "render() {\n\treturn (\n\t\t<tr key = {this.props.count}>\n\t\t\t<td>{this.props.count}</td>\n\t\t\t<td>{this.props.data[\"USD\"][\"FROMSYMBOL\"]}</td>\n\t\t\t<td>{this.props.data[\"USD\"][\"PRICE\"]}</td>\n\t\t\t<td>{this.props.data[\"USD\"][\"SUPPLY\"]}</td>\n\t\t\t<td>{this.props.data[\"USD\"][\"CHANGE24HOUR\"]}</td>\n\t\t</tr>\n\t)\n}",
        "invoking_code_segment_file_2": "render() {\n\tlet count = 0;\n\tconst data = this.props.data['DISPLAY'];\n\n\tif (!data) {\n\t\treturn (\n\t\t\t<tr>\n\t\t\t\t<td>1</td>\n\t\t\t\t<td>2</td>\n\t\t\t\t<td>3</td>\n\t\t\t\t<td>4</td>\n\t\t\t\t<td>5</td>\n\t\t\t</tr>\n\t\t);\n\t}\n\n\treturn Object.keys(data).map((k) => {\n\t\tcount++;\n\t\treturn (\n\t\t\t<CryptoListItem key={count} count={count} data={data[k]} />\n\t\t)\n\t});\n}",
        "called_code_segment_file_2": "render() {\n\treturn (\n\t\t<tbody className=\"crypto__list--body\">\n\t\t\t<CryptoList data={this.props.data} />\n\t\t</tbody>\n\t);\n}",
        "using_code_segment_file_3": "render() {\n\treturn (\n\t\t<table className=\"crypto__list\">\n\t\t\t<thead className=\"crypto__list--header\">\n\t\t\t\t<tr>\n\t\t\t\t\t<th>#</th>\n\t\t\t\t\t<th>Crypto</th>\n\t\t\t\t\t<th>Price</th>\n\t\t\t\t\t<th>Circulating Supply</th>\n\t\t\t\t\t<th>Change (24h)</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<CryptoContent data={this.state.cryptoResult} />\n\t\t</table>\n\t)\n}",
        "called_code_segment_file_3": "render() {\n\treturn (\n\t\t<CryptoContent data={this.state.cryptoResult} />\n\t);\n}",
        "using_code_segment_file_4": "render() {\n\tif (!this.state.cryptoResult) return ( <p> Loading... </p> );\n\n\treturn (\n\t\t<table className=\"crypto__list\">\n\t\t\t<thead className=\"crypto__list--header\">\n\t\t\t\t<tr>\n\t\t\t\t\t<th>#</th>\n\t\t\t\t\t<th>Crypto</th>\n\t\t\t\t\t<th>Price</th>\n\t\t\t\t\t<th>Circulating Supply</th>\n\t\t\t\t\t<th>Change (24h)</th>\n\t\t\t\t</tr>\n\t\t\t</thead>\n\t\t\t<CryptoContent data={this.state.cryptoResult} />\n\t\t</table>\n\t)\n}",
        "feature_description": "Add a new column to display the 'Market Cap' for each cryptocurrency.",
        "detailed_feature_description": "The new feature involves adding a 'Market Cap' column to the table. This requires modifying the `CryptoListItem` component to include the new column, updating the `CryptoList` component to pass the necessary data, and ensuring the `CryptoContent` and `App` components are updated to handle the new column.",
        "modified_complete_code": {
            "CryptoListItem.tsx": "import React, { Component } from 'react';\nimport { CryptoCurrencyDataType } from \"./Crypto\";\n\ninterface ListItemPropType {\n\tkey: number;\n\tcount: number;\n\tdata: CryptoCurrencyDataType;\n}\n\nclass CryptoListItem extends Component<ListItemPropType, {}> {\n\trender() {\n\t\treturn (\n\t\t\t<tr key = {this.props.count}>\n\t\t\t\t<td>{this.props.count}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"FROMSYMBOL\"]}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"PRICE\"]}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"SUPPLY\"]}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"CHANGE24HOUR\"]}</td>\n\t\t\t\t<td>{this.props.data[\"USD\"][\"MKTCAP\"]}</td> #Modify\n\t\t\t</tr>\n\t\t)\n\t}\n}\n\nexport default CryptoListItem;",
            "CryptoList.tsx": "import React, { Component } from 'react';\nimport CryptoListItem from './CryptoListItem';\nimport { CryptoDataType } from \"./Crypto\";\n\ninterface listPropTypes {\n\tdata: CryptoDataType\n}\n\nclass CryptoList extends Component<listPropTypes, {}> {\n\trender() {\n\t\tlet count = 0;\n\t\tconst data = this.props.data['DISPLAY'];\n\n\t\tif (!data) {\n\t\t\treturn (\n\t\t\t\t<tr>\n\t\t\t\t\t<td>1</td>\n\t\t\t\t\t<td>2</td>\n\t\t\t\t\t<td>3</td>\n\t\t\t\t\t<td>4</td>\n\t\t\t\t\t<td>5</td>\n\t\t\t\t\t<td>6</td> #Modify\n\t\t\t\t</tr>\n\t\t\t);\n\t\t}\n\n\t\treturn Object.keys(data).map((k) => {\n\t\t\tcount++;\n\t\t\treturn (\n\t\t\t\t<CryptoListItem key={count} count={count} data={data[k]} />\n\t\t\t)\n\t\t});\n\t}\n}\n\nexport default CryptoList;",
            "CryptoContent.tsx": "import React, { Component } from 'react';\nimport CryptoList from './CryptoList';\nimport { CryptoDataType } from \"./Crypto\";\n\ninterface contentPropType {\n\tdata: CryptoDataType\n}\n\nclass CryptoContent extends Component<contentPropType, {}> {\n\trender() {\n\t\treturn (\n\t\t\t<tbody className=\"crypto__list--body\">\n\t\t\t\t<CryptoList data={this.props.data} />\n\t\t\t</tbody>\n\t\t);\n\t}\n}\n\nexport default CryptoContent;",
            "index.tsx": "import React, { Component } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport CryptoContent from './CryptoContent';\nimport { CryptoDataType } from \"./Crypto\";\n\ninterface StateType {\n\tcryptoResult: CryptoDataType | null\n}\n\nclass App extends Component<{}, {}> {\n\tcomponentDidMount() {\n\t\tthis.getCryptoData();\n\t}\n\n\tstate: StateType = {\n\t\tcryptoResult: null\n\t}\n\n\tcryptoObject(): object[] {\n\t\treturn JSON.parse('{\"Bitcoin\": \"BTC\",\"Ethereum\": \"ETH\",\"Ripple\": \"XRP\",\"Bitcoin Cash\": \"BCH\",\"Cardano\": \"ADA\",\"Litecoin\": \"LTC\",\"Dash\": \"DASH\",\"Monero\": \"XHR\",\"Bitcoin Gold\": \"BTG\",\"Ethereum Classic\": \"ETC\",\"Zcash\": \"ZEC\"}');\n\t}\n\n\tobjectToArray(thisObject: object[]): any[] {\n\t\treturn Object.keys(thisObject).map((k: any): any => {\n\t\t\treturn thisObject[k];\n\t\t});\n\t}\n\n\tgetCryptoData() {\n\t\tconst cryptoSymbols = this.cryptoObject();\n\t\tfetch(`https://min-api.cryptocompare.com/data/pricemultifull?fsyms=${(this.objectToArray(cryptoSymbols)).join(\",\")}&tsyms=USD`)\n\t\t\t.then((response) => {\n\t\t\t\treturn response.json();\n\t\t\t})\n\t\t\t.then((data: CryptoDataType) => {\n\t\t\t\tthis.setState({\n\t\t\t\t\tcryptoResult: data\n\t\t\t\t})\n\t\t\t})\n\t\t\t.catch((err) => {\n\t\t\t\tconsole.error(`Fetch error: ${err}`)\n\t\t\t});\n\t}\n\n\trender() {\n\t\tif (!this.state.cryptoResult) return ( <p> Loading... </p> );\n\n\t\treturn (\n\t\t\t<table className=\"crypto__list\">\n\t\t\t\t<thead className=\"crypto__list--header\">\n\t\t\t\t\t<tr>\n\t\t\t\t\t\t<th>#</th>\n\t\t\t\t\t\t<th>Crypto</th>\n\t\t\t\t\t\t<th>Price</th>\n\t\t\t\t\t\t<th>Circulating Supply</th>\n\t\t\t\t\t\t<th>Change (24h)</th>\n\t\t\t\t\t\t<th>Market Cap</th> #Modify\n\t\t\t\t\t</tr>\n\t\t\t\t</thead>\n\t\t\t\t<CryptoContent data={this.state.cryptoResult} />\n\t\t\t</table>\n\t\t)\n\t}\n}\n\nReactDOM.createRoot(\n\tdocument.getElementById('container') as HTMLElement\n)\n\t.render(\n\t\t<React.StrictMode>\n\t\t\t<App />\n\t\t</React.StrictMode>\n\t);\n"
        }
    },
    {
        "repo": "cesium-martini",
        "content": "'cesium-martini/src/worker.ts'\n:import {\n  mapboxTerrainToGrid,\n  createQuantizedMeshData,\n  QuantizedMeshOptions,\n} from \"./worker-util\";\nimport ndarray from \"ndarray\";\nimport Martini from \"../martini/index.js\";\n// https://github.com/CesiumGS/cesium/blob/1.76/Source/WorkersES6/createVerticesFromQuantizedTerrainMesh.js\n\nexport interface TerrainWorkerInput extends QuantizedMeshOptions {\n  imageData: Uint8ClampedArray;\n  maxLength: number | null;\n  x: number;\n  y: number;\n  z: number;\n\n  /**\n   * Terrain-RGB interval (default 0.1)\n   */\n  interval?: number;\n\n  /**\n   * Terrain-RGB offset (default -10000)\n   */\n  offset?: number;\n}\n\nlet martini = null;\n\nfunction decodeTerrain(\n  parameters: TerrainWorkerInput,\n  transferableObjects: any[]\n) {\n  const { imageData, tileSize = 256, errorLevel, interval, offset } = parameters;\n\n  const pixels = ndarray(\n    new Uint8Array(imageData),\n    [tileSize, tileSize, 4],\n    [4, 4 * tileSize, 1],\n    0\n  );\n\n  // Tile size must be maintained through the life of the worker\n  martini ??= new Martini(tileSize + 1);\n\n  const terrain = mapboxTerrainToGrid(pixels, interval, offset);\n\n  const tile = martini.createTile(terrain);\n\n  // get a mesh (vertices and triangles indices) for a 10m error\n  const mesh = tile.getMesh(errorLevel, parameters.maxLength);\n  return createQuantizedMeshData(tile, mesh, tileSize);\n}\n\nexport { decodeTerrain };\n\nself.onmessage = function (msg) {\n  const { id, payload } = msg.data;\n  if (id == null) return;\n  let objects = [];\n  let res = null;\n  try {\n    res = decodeTerrain(payload);\n    objects.push(res.indices.buffer);\n    objects.push(res.quantizedVertices.buffer);\n    self.postMessage({ id, payload: res }, objects);\n  } catch (err) {\n    self.postMessage({ id, err: err.toString() });\n  } finally {\n    res = null;\n    objects = null;\n  }\n};\n\n'cesium-martini/src/terrain-provider.ts'\n:import {\n  Cartographic,\n  Rectangle,\n  Ellipsoid,\n  WebMercatorTilingScheme,\n  Math as CMath,\n  Event as CEvent,\n  BoundingSphere,\n  QuantizedMeshTerrainData,\n  OrientedBoundingBox,\n  TerrainProvider,\n  Credit,\n} from \"cesium\";\nimport WorkerFarm from \"./worker-farm\";\nimport { TerrainWorkerInput, decodeTerrain } from \"./worker\";\nimport TilingScheme from \"cesium/Source/Core/TilingScheme\";\nimport { HeightmapResource } from \"./heightmap-resource\";\nimport MapboxTerrainResource, {\n  MapboxTerrainResourceOpts,\n} from \"./mapbox-resource\";\nimport { emptyMesh } from \"./worker-util\";\n\n// https://github.com/CesiumGS/cesium/blob/1.68/Source/Scene/MapboxImageryProvider.js#L42\n\nexport interface TileCoordinates {\n  x: number;\n  y: number;\n  z: number;\n}\n\ninterface MartiniTerrainOpts {\n  resource: HeightmapResource;\n  ellipsoid?: Ellipsoid;\n  // workerURL: string;\n  detailScalar?: number;\n  minimumErrorLevel?: number;\n  maxWorkers?: number;\n  interval?: number;\n  offset?: number;\n  minZoomLevel?: number;\n  fillPoles?: boolean;\n}\n\nclass StretchedTilingScheme extends WebMercatorTilingScheme {\n  tileXYToRectangle(\n    x: number,\n    y: number,\n    level: number,\n    res: Rectangle\n  ): Rectangle {\n    let result = super.tileXYToRectangle(x, y, level);\n    if (y == 0) {\n      //console.log(\"Top row\", res, y, level);\n      result.north = Math.PI / 2;\n    }\n    if (y + 1 == Math.pow(2, level)) {\n      result.south = -Math.PI / 2;\n    }\n    return result;\n  }\n}\n\nexport class MartiniTerrainProvider<TerrainProvider> {\n  hasWaterMask = false;\n  hasVertexNormals = false;\n  credit = new Credit(\"Mapbox\");\n  ready: boolean;\n  readyPromise: Promise<boolean>;\n  availability = null;\n  errorEvent = new CEvent();\n  tilingScheme: TilingScheme;\n  ellipsoid: Ellipsoid;\n  workerFarm: WorkerFarm | null = null;\n  inProgressWorkers: number = 0;\n  levelOfDetailScalar: number | null = null;\n  maxWorkers: number = 5;\n  minError: number = 0.1;\n  minZoomLevel: number;\n  fillPoles: boolean = true;\n  _errorAtMinZoom: number = 1000;\n\n  resource: HeightmapResource = null;\n  interval: number;\n  offset: number;\n\n  RADIUS_SCALAR = 1.0;\n\n  // @ts-ignore\n  constructor(opts: MartiniTerrainOpts = {}) {\n    //this.martini = new Martini(257);\n    this.resource = opts.resource;\n\n    this.interval = opts.interval ?? 0.1;\n    this.offset = opts.offset ?? -10000;\n    this.maxWorkers = opts.maxWorkers ?? 5;\n    this.minZoomLevel = opts.minZoomLevel ?? 3;\n    this.fillPoles = opts.fillPoles ?? true;\n    console.log(\"fillPoles\", this.fillPoles);\n\n    this.levelOfDetailScalar = (opts.detailScalar ?? 4.0) + CMath.EPSILON5;\n\n    this.ready = true;\n    this.readyPromise = Promise.resolve(true);\n    this.minError = opts.minimumErrorLevel ?? 0.1;\n\n    this.errorEvent.addEventListener(console.log, this);\n    this.ellipsoid = opts.ellipsoid ?? Ellipsoid.WGS84;\n    if (this.maxWorkers > 0) {\n      this.workerFarm = new WorkerFarm();\n    }\n\n    let scheme = WebMercatorTilingScheme;\n    if (this.fillPoles) {\n      scheme = StretchedTilingScheme;\n    }\n    this.tilingScheme = new scheme({\n      numberOfLevelZeroTilesX: 1,\n      numberOfLevelZeroTilesY: 1,\n      ellipsoid: this.ellipsoid,\n    });\n\n    this._errorAtMinZoom = this.errorAtZoom(this.minZoomLevel);\n  }\n\n  requestTileGeometry(x, y, z, request) {\n    // Look for tiles both below the zoom level and below the error threshold for the zoom level at the equator...\n\n    if (\n      z < this.minZoomLevel ||\n      this.scaledErrorForTile(x, y, z) > this._errorAtMinZoom\n    ) {\n      // If we are below the minimum zoom level, we return empty heightmaps\n      // to avoid unnecessary requests for low-resolution data.\n      return Promise.resolve(this.emptyMesh(x, y, z));\n    }\n\n    // Note: we still load a TON of tiles near the poles. We might need to do some overzooming here...\n\n    if (this.inProgressWorkers > this.maxWorkers) return undefined;\n    this.inProgressWorkers += 1;\n    return this.processTile(x, y, z).finally(() => {\n      this.inProgressWorkers -= 1;\n    });\n  }\n\n  async processTile(x: number, y: number, z: number) {\n    // Something wonky about our tiling scheme, perhaps\n    // 12/2215/2293 @2x\n    //const url = `https://a.tiles.mapbox.com/v4/mapbox.terrain-rgb/${z}/${x}/${y}${hires}.${this.format}?access_token=${this.accessToken}`;\n    try {\n      const { tileSize, getTilePixels } = this.resource;\n      let px = await getTilePixels({ x, y, z });\n      let pixelData = px.data;\n\n      const tileRect = this.tilingScheme.tileXYToRectangle(x, y, z);\n      ///const center = Rectangle.center(tileRect);\n\n      const err = this.errorAtZoom(z);\n\n      let maxLength = this.maxVertexDistance(tileRect);\n\n      const params: TerrainWorkerInput = {\n        imageData: pixelData,\n        maxLength,\n        x,\n        y,\n        z,\n        errorLevel: err,\n        ellipsoidRadius: this.ellipsoid.maximumRadius,\n        tileSize,\n        interval: this.interval,\n        offset: this.offset,\n      };\n\n      let res;\n      if (this.workerFarm != null) {\n        res = await this.workerFarm.scheduleTask(params, [pixelData.buffer]);\n      } else {\n        res = decodeTerrain(params, []);\n      }\n      pixelData = undefined;\n      px = undefined;\n      return this.createQuantizedMeshData(tileRect, err, res);\n    } catch (err) {\n      console.log(err);\n      return this.emptyMesh(x, y, z);\n    }\n  }\n\n  errorAtZoom(zoom: number) {\n    return Math.max(\n      this.getLevelMaximumGeometricError(zoom) / this.levelOfDetailScalar,\n      this.minError\n    );\n  }\n\n  scaledErrorForTile(x: number, y: number, z: number) {\n    const tileRect = this.tilingScheme.tileXYToRectangle(x, y, z);\n    const center = Rectangle.center(tileRect);\n    return this.errorAtZoom(z) / Math.pow(1 - Math.sin(center.latitude), 2);\n  }\n\n  maxVertexDistance(tileRect: Rectangle) {\n    return Math.ceil(2 / tileRect.height);\n  }\n\n  emptyMesh(x: number, y: number, z: number) {\n    const tileRect = this.tilingScheme.tileXYToRectangle(x, y, z);\n    const center = Rectangle.center(tileRect);\n\n    const latScalar = Math.min(Math.abs(Math.sin(center.latitude)), 0.995);\n    let v = Math.max(\n      Math.ceil((200 / (z + 1)) * Math.pow(1 - latScalar, 0.25)),\n      4\n    );\n    const output = emptyMesh(v);\n    const err = this.errorAtZoom(z);\n    return this.createQuantizedMeshData(tileRect, err, output);\n  }\n\n  createQuantizedMeshData(tileRect, errorLevel, workerOutput) {\n    const {\n      minimumHeight,\n      maximumHeight,\n      quantizedVertices,\n      indices,\n      westIndices,\n      southIndices,\n      eastIndices,\n      northIndices,\n    } = workerOutput;\n\n    const err = errorLevel;\n    const skirtHeight = err * 20;\n\n    const center = Rectangle.center(tileRect);\n\n    // Calculating occlusion height is kind of messy currently, but it definitely works\n    const halfAngle = tileRect.width / 2;\n    const dr = Math.cos(halfAngle); // half tile width since our ref point is at the center\n\n    let occlusionHeight = dr * this.ellipsoid.maximumRadius + maximumHeight;\n    if (halfAngle > Math.PI / 4) {\n      occlusionHeight = (1 + halfAngle) * this.ellipsoid.maximumRadius;\n    }\n\n    const occlusionPoint = new Cartographic(\n      center.longitude,\n      center.latitude,\n      occlusionHeight\n      // Scaling factor of two just to be sure.\n    );\n\n    const horizonOcclusionPoint = this.ellipsoid.transformPositionToScaledSpace(\n      Cartographic.toCartesian(occlusionPoint)\n    );\n\n    let orientedBoundingBox = OrientedBoundingBox.fromRectangle(\n      tileRect,\n      minimumHeight,\n      maximumHeight,\n      this.tilingScheme.ellipsoid\n    );\n    let boundingSphere =\n      BoundingSphere.fromOrientedBoundingBox(orientedBoundingBox);\n\n    // SE NW NE\n    // NE NW SE\n\n    let result = new QuantizedMeshTerrainData({\n      minimumHeight,\n      maximumHeight,\n      quantizedVertices,\n      indices,\n      boundingSphere,\n      orientedBoundingBox,\n      horizonOcclusionPoint,\n      westIndices,\n      southIndices,\n      eastIndices,\n      northIndices,\n      westSkirtHeight: skirtHeight,\n      southSkirtHeight: skirtHeight,\n      eastSkirtHeight: skirtHeight,\n      northSkirtHeight: skirtHeight,\n      childTileMask: 15,\n    });\n\n    return result;\n  }\n\n  getLevelMaximumGeometricError(level) {\n    const levelZeroMaximumGeometricError =\n      TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n        this.tilingScheme.ellipsoid,\n        65,\n        this.tilingScheme.getNumberOfXTilesAtLevel(0)\n      );\n\n    // Scalar to control overzooming\n    // also seems to control zooming for imagery layers\n    const scalar = this.resource.tileSize / 256;\n\n    return levelZeroMaximumGeometricError / scalar / (1 << level);\n  }\n\n  getTileDataAvailable(x, y, z) {\n    return this.resource.getTileDataAvailable({ x, y, z });\n  }\n}\n\ntype MapboxTerrainOpts = Omit<MartiniTerrainOpts, \"resource\"> &\n  MapboxTerrainResourceOpts;\n\nexport default class MapboxTerrainProvider extends MartiniTerrainProvider<TerrainProvider> {\n  constructor(opts: MapboxTerrainOpts = {}) {\n    const resource = new MapboxTerrainResource(opts);\n    super({\n      ...opts,\n      resource,\n    });\n  }\n}\n\n'cesium-martini/src/heightmap-resource.ts'\n:import { Resource } from \"cesium\";\nimport { TileCoordinates } from \"./terrain-provider\";\n\nexport interface HeightmapResource {\n  tileSize: number;\n  getTilePixels: (coords: TileCoordinates) => Promise<ImageData>;\n  getTileDataAvailable: (coords: TileCoordinates) => boolean;\n}\n\ninterface CanvasRef {\n  canvas: HTMLCanvasElement;\n  context: CanvasRenderingContext2D;\n}\n\nconst loadImage: (url: string) => Promise<HTMLImageElement> = (url) =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.addEventListener(\"load\", () => resolve(img));\n    img.addEventListener(\"error\", (err) => reject(err));\n    img.crossOrigin = \"anonymous\";\n    img.src = url;\n  });\n\nexport interface DefaultHeightmapResourceOpts {\n  url?: string;\n  skipOddLevels?: boolean;\n  maxZoom?: number;\n  tileSize?: number;\n}\n\nexport class DefaultHeightmapResource implements HeightmapResource {\n  resource: Resource = null;\n  tileSize: number = 256;\n  maxZoom: number;\n  skipOddLevels: boolean = false;\n  contextQueue: CanvasRef[];\n\n  constructor(opts: DefaultHeightmapResourceOpts = {}) {\n    if (opts.url) {\n      this.resource = Resource.createIfNeeded(opts.url);\n    }\n    this.skipOddLevels = opts.skipOddLevels ?? false;\n    this.tileSize = opts.tileSize ?? 256;\n    this.maxZoom = opts.maxZoom ?? 15;\n    this.contextQueue = [];\n  }\n\n  getCanvas(): CanvasRef {\n    let ctx = this.contextQueue.pop();\n    if (ctx == null) {\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = this.tileSize;\n      canvas.height = this.tileSize;\n      const context = canvas.getContext(\"2d\");\n      ctx = {\n        canvas,\n        context,\n      };\n    }\n    return ctx;\n  }\n\n  getPixels(img: HTMLImageElement | HTMLCanvasElement): ImageData {\n    const canvasRef = this.getCanvas();\n    const { context } = canvasRef;\n    //context.scale(1, -1);\n    // Chrome appears to vertically flip the image for reasons that are unclear\n    // We can make it work in Chrome by drawing the image upside-down at this step.\n    context.drawImage(img, 0, 0, this.tileSize, this.tileSize);\n    const pixels = context.getImageData(0, 0, this.tileSize, this.tileSize);\n    context.clearRect(0, 0, this.tileSize, this.tileSize);\n    this.contextQueue.push(canvasRef);\n    return pixels;\n  }\n\n  buildTileURL(tileCoords: TileCoordinates) {\n    // reverseY for TMS tiling (https://gist.github.com/tmcw/4954720)\n    // See tiling schemes here: https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/\n    const { z, y } = tileCoords;\n    return this.resource\n      ?.getDerivedResource({\n        templateValues: {\n          ...tileCoords,\n          reverseY: Math.pow(2, z) - y - 1,\n        },\n        preserveQueryParameters: true,\n      })\n      .getUrlComponent(true);\n  }\n\n  getTilePixels = async (coords: TileCoordinates) => {\n    const url = this.buildTileURL(coords);\n    let img = await loadImage(url);\n    return this.getPixels(img);\n  };\n\n  getTileDataAvailable({ z }) {\n    if (z == this.maxZoom) return true;\n    if (z % 2 == 1 && this.skipOddLevels) return false;\n    if (z > this.maxZoom) return false;\n    return true;\n  }\n}\n\nexport default DefaultHeightmapResource;\n\n'cesium-martini/src/index.ts'\n:import DefaultHeightmapResource from \"./heightmap-resource\";\nimport MapboxTerrainResource from \"./mapbox-resource\";\nimport MapboxTerrainProvider, {\n  MartiniTerrainProvider,\n} from \"./terrain-provider\";\n\nexport default MapboxTerrainProvider;\nexport {\n  MartiniTerrainProvider,\n  DefaultHeightmapResource,\n  MapboxTerrainResource,\n};\n\n",
        "called_code_segment_file_1": "function decodeTerrain(parameters: TerrainWorkerInput, transferableObjects: any[]) {\n  const { imageData, tileSize = 256, errorLevel, interval, offset } = parameters;\n  const pixels = ndarray(new Uint8Array(imageData), [tileSize, tileSize, 4], [4, 4 * tileSize, 1], 0);\n  martini ??= new Martini(tileSize + 1);\n  const terrain = mapboxTerrainToGrid(pixels, interval, offset);\n  const tile = martini.createTile(terrain);\n  const mesh = tile.getMesh(errorLevel, parameters.maxLength);\n  return createQuantizedMeshData(tile, mesh, tileSize);\n}",
        "invoking_code_segment_file_2": "let res;\nif (this.workerFarm != null) {\n  res = await this.workerFarm.scheduleTask(params, [pixelData.buffer]);\n} else {\n  res = decodeTerrain(params, []);\n}",
        "called_code_segment_file_2": "requestTileGeometry(x, y, z, request) {\n  if (z < this.minZoomLevel || this.scaledErrorForTile(x, y, z) > this._errorAtMinZoom) {\n    return Promise.resolve(this.emptyMesh(x, y, z));\n  }\n  if (this.inProgressWorkers > this.maxWorkers) return undefined;\n  this.inProgressWorkers += 1;\n  return this.processTile(x, y, z).finally(() => {\n    this.inProgressWorkers -= 1;\n  });\n}",
        "using_code_segment_file_3": "class WorkerFarm {\n  scheduleTask(task, transferableObjects) {\n    return new Promise((resolve, reject) => {\n      const worker = new Worker('./worker.js');\n      worker.onmessage = (event) => {\n        if (event.data.err) {\n          reject(event.data.err);\n        } else {\n          resolve(event.data.payload);\n        }\n        worker.terminate();\n      };\n      worker.postMessage({ id: Date.now(), payload: task }, transferableObjects);\n    });\n  }\n}",
        "called_code_segment_file_3": "scheduleTask(task, transferableObjects) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker('./worker.js');\n    worker.onmessage = (event) => {\n      if (event.data.err) {\n        reject(event.data.err);\n      } else {\n        resolve(event.data.payload);\n      }\n      worker.terminate();\n    };\n    worker.postMessage({ id: Date.now(), payload: task }, transferableObjects);\n  });\n}",
        "using_code_segment_file_4": "self.onmessage = function (msg) {\n  const { id, payload } = msg.data;\n  if (id == null) return;\n  let objects = [];\n  let res = null;\n  try {\n    res = decodeTerrain(payload);\n    objects.push(res.indices.buffer);\n    objects.push(res.quantizedVertices.buffer);\n    self.postMessage({ id, payload: res }, objects);\n  } catch (err) {\n    self.postMessage({ id, err: err.toString() });\n  } finally {\n    res = null;\n    objects = null;\n  }\n};",
        "feature_description": "Add a feature to log the error level used for terrain decoding.",
        "detailed_feature_description": "Modify the `decodeTerrain` function in #file 1 to log the error level used for terrain decoding. Update the `processTile` method in #file 2 to handle the logging output. Ensure that the `WorkerFarm` class in #file 3 and the worker script in #file 4 are updated to accommodate the changes.",
        "modified_complete_code": {
            "#file 1": "function decodeTerrain(parameters: TerrainWorkerInput, transferableObjects: any[]) {\n  const { imageData, tileSize = 256, errorLevel, interval, offset } = parameters;\n  const pixels = ndarray(new Uint8Array(imageData), [tileSize, tileSize, 4], [4, 4 * tileSize, 1], 0);\n  martini ??= new Martini(tileSize + 1);\n  const terrain = mapboxTerrainToGrid(pixels, interval, offset);\n  const tile = martini.createTile(terrain);\n  const mesh = tile.getMesh(errorLevel, parameters.maxLength);\n  console.log(`Error level used: ${errorLevel}`); #Modify\n  return createQuantizedMeshData(tile, mesh, tileSize);\n}",
            "#file 2": "async processTile(x: number, y: number, z: number) {\n  const { tileSize, getTilePixels } = this.resource;\n  let px = await getTilePixels({ x, y, z });\n  let pixelData = px.data;\n  const tileRect = this.tilingScheme.tileXYToRectangle(x, y, z);\n  const err = this.errorAtZoom(z);\n  let maxLength = this.maxVertexDistance(tileRect);\n  const params: TerrainWorkerInput = {\n    imageData: pixelData,\n    maxLength,\n    x,\n    y,\n    z,\n    errorLevel: err,\n    ellipsoidRadius: this.ellipsoid.maximumRadius,\n    tileSize,\n    interval: this.interval,\n    offset: this.offset,\n  };\n  let res;\n  if (this.workerFarm != null) {\n    res = await this.workerFarm.scheduleTask(params, [pixelData.buffer]);\n  } else {\n    res = decodeTerrain(params, []);\n  }\n  pixelData = undefined;\n  px = undefined;\n  return this.createQuantizedMeshData(tileRect, err, res);\n}",
            "#file 3": "class WorkerFarm {\n  scheduleTask(task, transferableObjects) {\n    return new Promise((resolve, reject) => {\n      const worker = new Worker('./worker.js');\n      worker.onmessage = (event) => {\n        if (event.data.err) {\n          reject(event.data.err);\n        } else {\n          resolve(event.data.payload);\n        }\n        worker.terminate();\n      };\n      worker.postMessage({ id: Date.now(), payload: task }, transferableObjects);\n    });\n  }\n}",
            "#file 4": "self.onmessage = function (msg) {\n  const { id, payload } = msg.data;\n  if (id == null) return;\n  let objects = [];\n  let res = null;\n  try {\n    res = decodeTerrain(payload);\n    objects.push(res.indices.buffer);\n    objects.push(res.quantizedVertices.buffer);\n    self.postMessage({ id, payload: res }, objects);\n  } catch (err) {\n    self.postMessage({ id, err: err.toString() });\n  } finally {\n    res = null;\n    objects = null;\n  }\n};"
        }
    },
    {
        "repo": "Approvals.NodeJS",
        "content": "'Approvals.NodeJS/lib/Core/Reporter.ts'\n:import { Config } from \"../config\";\n\nexport interface Reporter {\n  name: string;\n\n  canReportOn(fileName: string): boolean;\n\n  report(\n    approvedFileName: string,\n    receivedFileName: string,\n    options?: Partial<Config>,\n  ): void;\n}\n\n'Approvals.NodeJS/lib/FileApprover.ts'\n:import fs from \"fs\";\nimport { Config } from \"./config\";\nimport { Namer } from \"./Core/Namer\";\nimport { Writer } from \"./Core/Writer\";\nimport { Reporter } from \"./Core/Reporter\";\nimport { ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { yellowText } from \"./Utilities/ConsoleUtils\";\n\ninterface Options {\n  stripBOM?: boolean;\n  forceApproveAll?: boolean;\n  failOnLineEndingDifferences?: boolean;\n  shouldIgnoreStaleApprovedFile?(fileName: string): boolean;\n}\n\nfunction normalizeLineEndings(value: string): string {\n  return value.replace(/(?:\\r\\n|\\r|\\n)/g, \"\\n\");\n}\n\nexport class FileApprover {\n  static verify(\n    namer: Namer,\n    writer: Writer,\n    reporterFactory: ReporterLoader,\n    options?: Partial<Config>,\n  ): void {\n    if (!namer || !writer || !reporterFactory) {\n      throw new Error(\n        \"Missing required arguments: 'namer', 'writer', or 'reporterFactory'.\",\n      );\n    }\n    if (!options) {\n      options = {};\n    }\n\n    const approvedFileName = namer.getApprovedFile(writer.getFileExtension());\n    const receivedFileName = namer.getReceivedFile(writer.getFileExtension());\n\n    writer.write(receivedFileName);\n\n    if (options.forceApproveAll) {\n      console.log(yellowText(`WARNING: Force approving: ${approvedFileName}`));\n      writer.write(approvedFileName);\n    }\n\n    const selectFirstCompatibleReporter = (): Reporter => {\n      const allReporters = reporterFactory();\n      const reporter = allReporters.find((reporter) =>\n        reporter.canReportOn(receivedFileName),\n      );\n      if (!reporter) {\n        throw new Error(\n          `No compatible reporter found in configured list [${allReporters.map((r) => r.name).join(\", \")}] for: ${receivedFileName}`,\n        );\n      }\n      return reporter;\n    };\n\n    const throwReporterError = (msg: string): never => {\n      const reporter = selectFirstCompatibleReporter();\n      try {\n        reporter.report(approvedFileName, receivedFileName, options);\n      } catch (ex) {\n        const reporterError = `Error raised by reporter [${reporter.name}]: ${ex}`;\n        throw new Error(\n          `${reporterError}\\n${msg}\\nApproved: ${approvedFileName}\\nReceived: ${receivedFileName}`,\n        );\n      }\n      throw new Error(msg);\n    };\n\n    if (!fs.existsSync(approvedFileName)) {\n      throwReporterError(`Approved file does not exist: ${approvedFileName}`);\n    }\n\n    let approvedFileContents = fs.readFileSync(approvedFileName, \"utf8\") || \"\";\n    let receivedFileContents = fs.readFileSync(receivedFileName, \"utf8\") || \"\";\n\n    if (options.stripBOM) {\n      approvedFileContents = approvedFileContents.replace(/^\\uFEFF/, \"\");\n      receivedFileContents = receivedFileContents.replace(/^\\uFEFF/, \"\");\n    }\n\n    if (\n      options.failOnLineEndingDifferences &&\n      approvedFileContents !== receivedFileContents\n    ) {\n      throwReporterError(\"Files do not match.\");\n    }\n\n    const approvedFileBufferNormalized =\n      normalizeLineEndings(approvedFileContents);\n    const receivedFileBufferNormalized =\n      normalizeLineEndings(receivedFileContents);\n\n    if (approvedFileBufferNormalized !== receivedFileBufferNormalized) {\n      throwReporterError(\"Files do not match.\");\n    }\n\n    // Delete the received file\n    fs.unlinkSync(receivedFileName);\n\n    (process.emit as Function)(\"approvalFileApproved\", approvedFileName);\n  }\n}\n\nexport function verify(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory: () => Reporter[],\n  options?: Partial<Config>,\n): void {\n  FileApprover.verify(namer, writer, reporterFactory, options);\n}\n\n'Approvals.NodeJS/lib/Approvals.ts'\n:/*jshint freeze:false */\n\n/**\n * Approvals module.\n * @module approvals\n */\n\nimport callsite from \"callsite\";\nimport path from \"path\";\nimport { fileURLToPath } from \"url\";\nimport * as cfg from \"./config\";\nimport { BinaryWriter } from \"./Writers/BinaryWriter\";\nimport { FileApprover } from \"./FileApprover\";\nimport { FinalMessages } from \"./FinalMessages\";\nimport { ManualNamer } from \"./ManualNamer\";\nimport { Namer } from \"./Core/Namer\";\nimport { ReporterFactory, ReporterLoader } from \"./Reporting/ReporterFactory\";\nimport { Scrubber, Scrubbers } from \"./Scrubbers/Scrubbers\";\nimport { StringWriter } from \"./StringWriter\";\nimport { Writer } from \"./Core/Writer\";\nimport { postRunCleanup } from \"./postRunCleanup\";\nimport { stringifyKeysInOrder } from \"./AUtils\";\n\n// if someone tries to call 'require(\"approvals\")...' without calling \".mocha(...) or\n// they won't get a helpful error. So we put this in there - just in case\"\nimport { MochaNamer } from \"./Providers/Mocha/MochaNamer\";\n\nimport { beforeEachVerifierBase } from \"./Providers/BeforeEachVerifierBase\";\n\n/**\n * Contains some helpful and util scrubbers that can be used for scrubbing data before saving to a received file.\n */\nexport { Scrubbers as scrubbers };\n\nif (typeof beforeEach === \"function\") {\n  beforeEach(function (): void {\n    if (!this) {\n      return;\n    }\n    this.verify = function () {\n      throw new Error(\"You must call either .mocha()\");\n    };\n  });\n}\n\n// keep track of approved files we run into with tests\nconst listOfApprovedFiles: string[] = [];\nprocess.on(\"approvalFileApproved\", function (fileName): void {\n  if (listOfApprovedFiles.indexOf(fileName) === -1) {\n    listOfApprovedFiles.push(fileName);\n  }\n});\n\nprocess.on(\"exit\", function (): void {\n  const options = cfg.currentConfig();\n  postRunCleanup(options, listOfApprovedFiles);\n  const finalMessages = FinalMessages.getMessages();\n  if (finalMessages.length) {\n    console.log(\"******************************\");\n    console.log(\"* Approvals Report: WARNING!\");\n    finalMessages.forEach((message: string) => {\n      console.log(`*  - ${message}`);\n    });\n    console.log(\"******************************\");\n  }\n});\n\n/**\n * Allows you to provide overrides to the default configuration.\n *\n * @example\n * const approvals = require('approvals');\n * approvals.configure({\n *   reporters: ['p4merge']\n * });\n *\n * @param {*} overrideOptions\n */\nexport function configure(overrideOptions: cfg.Config): typeof module.exports {\n  cfg.configure(overrideOptions);\n  return module.exports;\n}\n\n/**\n * Allows the creation of an approvals configuration object using any passed in options to override the defaults.\n * @param {Object} overrideOptions\n * @returns {Object} approvals config object with any options overridden.\n */\nexport function getConfig(overrideOptions?: cfg.Config): cfg.Config {\n  return cfg.getConfig(overrideOptions);\n}\n\n/**\n * Configure approvals to hook into Mocha tests.\n * @param {*} optionalBaseDir - An optional folder to save approval files to.\n */\n\nexport function mocha(optionalBaseDir?: string): typeof module.exports {\n  // if not providing a base dir, fallback to the current calling code's directory\n  if (!optionalBaseDir) {\n      let fileName = callsite()[1].getFileName();\n      if (fileName.startsWith(\"file://\")) {\n          fileName = fileURLToPath(fileName);\n      }\n      optionalBaseDir = path.dirname(fileName);\n  }\n  beforeEachVerifierBase(\n    MochaNamer,\n    \"require('Approvals').mocha();\",\n    optionalBaseDir,\n  );\n\n  return module.exports;\n}\n\nfunction jasmineExport(): void {\n  throw new Error(\n    \"Aww shucks.\\n\\nApprovals support of Jasmine has been completely yanked out (don't shoot). \\n\\n Jasmine has grown quite complicated (behind our back) and we haven't had enough time to figure out a solid integration pattern... for now it's support has been removed.\\n\\n Check out the docs for manual usage of approval tests to work around the missing Jasmine integration (it should be a straightforward change for you, really).\\n\\n We'll consider bringing it back if we can get someone with interest in submitting a pull request that can bring it back...\",\n  );\n}\n\n/**\n * `reporters` gives access to the `MultiReporter`\n *\n * @example\n * const MultiReporter = approvals.reporters.MultiReporter\n */\n\nexport const reporters: { MultiReporter: any } = {\n  /**\n   * This allows access to the MultiReporter constructor.\n   * You can use this to run multiple reporters at the same time.\n   *\n   * @example\n   * approvals.verify(__dirname, \"multi-reporter-example\", \"some data\", {\n   *   reporters: [\n   *     new MultiReporter('p4merge', 'copycommand')\n   *   ]\n   * });\n   */\n  MultiReporter: require(\"./Reporting/Reporters/multiReporter\").default,\n};\n\n/**\n * Use this to apply the scrubber function to any data before running verify.\n *\n * @example\n * // basic approval test with a custom scrubber\n * const approvals = require('approvals');\n * const scrubber = approvals.scrubbers.multiScrubber([\n *    function (data) {\n *      return (data || '').replace(\"some text\", \"some other text\");\n *    },\n *    approvals.scrubbers.guidScrubber // to remove guids from the received data\n * });\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', \"some text to verify\", scrubber);\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - Either the string to save as a text file or a Buffer that represents an image\n * @param {*} scrubber - A function that takes a string and returns a string. Approvals will call this if it exists to scrub the \"data\" before writing to any files.\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\nfunction verifyAndScrub(\n  dirName: string,\n  testName: string,\n  data: BinaryWriter | string,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  scrubber = scrubber || Scrubbers.noScrubber;\n\n  // backwards compatible option\n  if (Array.isArray(optionsOverride)) {\n    optionsOverride = {\n      reporters: optionsOverride,\n    };\n    const stringReporters = JSON.stringify(optionsOverride.reporters);\n    console.error(\n      'For the last arg of the approvals.verify(...) function, if you passed in an array of reporters, something like [\"opendiff\",\"nodediff\"], this has been deprecated and replaced by passing in a config object. Please re-evaluate if you can remove this parameter alltogether and use individual user configs in ~/.approvalConfig, if not then replace this: ' +\n        stringReporters +\n        \" with this { reporters: \" +\n        stringReporters +\n        \"}.\",\n    );\n  }\n\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const namer = new ManualNamer(dirName, testName);\n\n  let writer: Writer;\n  if (data instanceof Buffer) {\n    writer = new BinaryWriter(newOptions, data);\n  } else {\n    data = scrubber(data as string);\n\n    writer = new StringWriter(newOptions, data as string);\n  }\n  verifyWithControl(namer, writer, null, newOptions);\n}\n/**\n *\n * @example\n * // basic approval test\n * const approvals = require('approvals');\n * approvals.verify(__dirname, 'sample-approval-test', \"some text to verify\");\n *\n * @example\n * // basic approval test providing an option to override configuration\n * const approvals = require('approvals');\n * approvals.verify(__dirname, 'sample-approval-test', \"some text to verify\", { normalizeLineEndingsTo: true });\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name save string to call the file associated with this test.\n * @param {(string|Buffer)} data - Either the string to save as a text file or a Buffer that represents an image\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\n\nexport function verify(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride?: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * You can pass as \"data\" any javascript object to be JSON.stringified and run verify against.\n *\n * @example\n * const approvals = require('approvals');\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', { a: \"some text in an object\" });\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - This can be any JavaScript object/array that will be JSON.stringified before running verify\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\nexport function verifyAsJSON(\n  dirName: string,\n  testName: string,\n  data: any,\n  optionsOverride: any,\n) {\n  return verifyAsJSONAndScrub(\n    dirName,\n    testName,\n    data,\n    Scrubbers.noScrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * You can pass as \"data\" any javascript object to be JSON.stringified. Before we run verify the scrubber will be run against the complete string before running verify against it.\n\n * @example\n * // basic approval test with a custom scrubber\n * const approvals = require('approvals');\n * const scrubber = approvals.scrubbers.multiScrubber([\n *    function (data) {\n *      return (data || '').replace(\"some text\", \"some other text\");\n *    },\n *    approvals.scrubbers.guidScrubber // to remove guids from the received data\n * });\n * approvals.verifyAndScrub(__dirname, 'sample-approval-test', { a: \"some text in an object\" }, scrubber);\n *\n * @param {string} dirName - Typically `__dirname` but could be the base-directory (anywhere) to store both approved and received files.\n * @param {string} testName - A file name safe string to call the file associated with this test.\n * @param {(string|Buffer)} data - This can be any JavaScript object/array that will be JSON.stringified before running verify\n * @param {*} scrubber - A function that takes a string and returns a string. Approvals will call this if it exists to scrub the \"data\" before writing to any files.\n * @param {*} optionsOverride - An object that can contain configurational overrides as defined in the approvals configuration object.\n */\n\nexport function verifyAsJSONAndScrub(\n  dirName: string,\n  testName: string,\n  data: any,\n  scrubber: Scrubber,\n  optionsOverride: any,\n): void {\n  return verifyAndScrub(\n    dirName,\n    testName,\n    stringifyKeysInOrder(data),\n    scrubber,\n    optionsOverride,\n  );\n}\n\n/**\n * This allows you to take full control of naming and writing files before verifying.\n *\n * For an example that we use to generate the docs within the readme, check out the [test/readmeTests.js](test/readmeTests.js) in this project.\n *\n * @param {Object} namer\n * @param {Object} writer\n * @param {Function} [reporterFactory]\n * @param {Object} [optionsOverride]\n */\n\nexport function verifyWithControl(\n  namer: Namer,\n  writer: Writer,\n  reporterFactory?: ReporterLoader | null,\n  optionsOverride?: Partial<cfg.Config>,\n) {\n  const newOptions = cfg.getConfig(optionsOverride);\n\n  const loader =\n    (reporterFactory as ReporterLoader) ||\n    function () {\n      return [ReporterFactory.loadReporter(newOptions.reporters)];\n    };\n\n  FileApprover.verify(namer, writer, loader, newOptions);\n}\n\n'Approvals.NodeJS/lib/Providers/Mocha/MochaApprovals.ts'\n:import { printArray, printJson } from \"../../Utilities/Printers\";\n/* ^^^ If the above line is failing, please add\n# 1. Jest Config\n```\n\"transformIgnorePatterns\": [\"node_modules/@3ds\"]\n```\n\n# 2. tsconfig.json\n```\n    \"esModuleInterop\": true\n```\n*/\nimport { Options } from \"../../Core/Options\";\nimport { MochaNamer } from \"./MochaNamer\";\nimport mocha from \"mocha\";\n\nimport StringWriter from \"../../StringWriter\";\n\nimport * as approvals from \"../../Approvals\";\n\nlet mochaTest: any = null;\n\nexport function it2(label: string, test: () => void): void {\n  mocha.it(label, function () {\n    mochaTest = this;\n    console.log(\"Mocha Test: \", mochaTest.test.name);\n    test();\n  });\n}\n\nexport function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  approvals.verifyWithControl(namer, writer, null, config);\n}\n\nexport function verifyAsJson(data: any, options?: Options): void {\n  const text = printJson(data);\n  options = options || new Options();\n  options = options.forFile().withFileExtention(\".json\");\n  verify(text, options);\n}\n\nexport function verifyAll<T>(\n  header: string,\n  list: T[],\n  formatter?: (element: T) => string,\n  options?: Options,\n): void {\n  const text = printArray(header, list, formatter);\n  verify(text, options);\n}\n\n",
        "called_code_segment_file_1": "export function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  approvals.verifyWithControl(namer, writer, null, config);\n}",
        "invoking_code_segment_file_2": "export function it2(label: string, test: () => void): void {\n  mocha.it(label, function () {\n    mochaTest = this;\n    console.log(\"Mocha Test: \", mochaTest.test.name);\n    test();\n  });\n}",
        "called_code_segment_file_2": "export function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  approvals.verifyWithControl(namer, writer, null, config);\n}",
        "using_code_segment_file_3": "import { it2, verify } from './MochaApprovals';\n\nit2('should verify a simple string', () => {\n  verify('Hello, World!');\n});",
        "called_code_segment_file_3": "",
        "using_code_segment_file_4": "",
        "feature_description": "Add a new feature to log the verification process details.",
        "detailed_feature_description": "Modify the `verify` function in #file 1 to log the verification process details. Update #file 2 to handle the modified `verify` function and ensure any related code segments used by #file 3 are updated accordingly. Since #file 3 directly interacts with the updated segments in #file 2, modify the code in #file 3 to accommodate the changes. No changes are required for #file 4 as it does not interact with or depend on any updated segments in #file 3.",
        "modified_complete_code": {
            "#file 1": "export function verify(sut: any, options?: Options): void {\n  options = options || new Options();\n  options = options.withNamer(new MochaNamer(mochaTest.test));\n  const config = options.getConfig(approvals.getConfig());\n  const scrubbed = options.scrub(`${sut}`);\n  const writer = new StringWriter(\n    config,\n    scrubbed,\n    options.forFile().getFileExtension(),\n  );\n  let namer = options.getNamer();\n  console.log('Verification process started:', { sut, options }); #Modify\n  approvals.verifyWithControl(namer, writer, null, config);\n}",
            "#file 2": "export function it2(label: string, test: () => void): void {\n  mocha.it(label, function () {\n    mochaTest = this;\n    console.log(\"Mocha Test: \", mochaTest.test.name);\n    test();\n  });\n}",
            "#file 3": "import { it2, verify } from './MochaApprovals';\n\nit2('should verify a simple string', () => {\n  verify('Hello, World!');\n});",
            "#file 4": ""
        }
    },
    {
        "repo": "comp3123_full_stack",
        "content": "'comp3123_full_stack/lab-review/src/app/contact-us/contact-us.component.ts'\n:import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-contact-us',\n  templateUrl: './contact-us.component.html',\n  styleUrls: ['./contact-us.component.scss']\n})\nexport class ContactUsComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() {\n  }\n\n}\n\n'comp3123_full_stack/lab-review/src/app/app-routing.module.ts'\n:import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { AboutUsComponent } from './about-us/about-us.component';\nimport { ContactUsComponent } from './contact-us/contact-us.component';\nimport { ProductsComponent } from './products/products.component';\n\nconst routes: Routes = [\n  { path: 'blabla-products', component: ProductsComponent },\n  { path: 'about-us', component: AboutUsComponent },\n  { path: 'contact-us', component: ContactUsComponent }\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }\n\n'comp3123_full_stack/lab-review/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { FooterComponent } from './footer/footer.component';\nimport { MainComponent } from './main/main.component';\nimport { ProductsComponent } from './products/products.component';\nimport { ContactUsComponent } from './contact-us/contact-us.component';\nimport { AboutUsComponent } from './about-us/about-us.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    MainComponent,\n    ProductsComponent,\n    ContactUsComponent,\n    AboutUsComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'comp3123_full_stack/lab-review/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "@Component({\n  selector: 'app-contact-us',\n  templateUrl: './contact-us.component.html',\n  styleUrls: ['./contact-us.component.scss']\n})\nexport class ContactUsComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit() { }\n\n}",
        "invoking_code_segment_file_2": "const routes: Routes = [\n  { path: 'blabla-products', component: ProductsComponent },\n  { path: 'about-us', component: AboutUsComponent },\n  { path: 'contact-us', component: ContactUsComponent }\n];",
        "called_code_segment_file_2": "const routes: Routes = [\n  { path: 'blabla-products', component: ProductsComponent },\n  { path: 'about-us', component: AboutUsComponent },\n  { path: 'contact-us', component: ContactUsComponent }\n];",
        "using_code_segment_file_3": "@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    MainComponent,\n    ProductsComponent,\n    ContactUsComponent,\n    AboutUsComponent\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
        "called_code_segment_file_3": "N/A",
        "using_code_segment_file_4": "N/A",
        "feature_description": "Add a new route for 'services' and update the ContactUsComponent to include a message field.",
        "detailed_feature_description": "A new route for 'services' will be added to the AppRoutingModule. The ContactUsComponent will be updated to include a message field that users can fill out. The AppModule will be updated to reflect the new route and component changes.",
        "modified_complete_code": {
            "file_1": "@Component({\n  selector: 'app-contact-us',\n  templateUrl: './contact-us.component.html',\n  styleUrls: ['./contact-us.component.scss']\n})\nexport class ContactUsComponent implements OnInit {\n\n  message: string;\n\n  constructor() { }\n\n  ngOnInit() { }\n\n  #Modify: Added message field\n}",
            "file_2": "import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { AboutUsComponent } from './about-us/about-us.component';\nimport { ContactUsComponent } from './contact-us/contact-us.component';\nimport { ProductsComponent } from './products/products.component';\nimport { ServicesComponent } from './services/services.component'; #New\n\nconst routes: Routes = [\n  { path: 'blabla-products', component: ProductsComponent },\n  { path: 'about-us', component: AboutUsComponent },\n  { path: 'contact-us', component: ContactUsComponent },\n  { path: 'services', component: ServicesComponent } #New\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule]\n})\nexport class AppRoutingModule { }",
            "file_3": "import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { FooterComponent } from './footer/footer.component';\nimport { MainComponent } from './main/main.component';\nimport { ProductsComponent } from './products/products.component';\nimport { ContactUsComponent } from './contact-us/contact-us.component';\nimport { AboutUsComponent } from './about-us/about-us.component';\nimport { ServicesComponent } from './services/services.component'; #New\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    FooterComponent,\n    MainComponent,\n    ProductsComponent,\n    ContactUsComponent,\n    AboutUsComponent,\n    ServicesComponent #New\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }",
            "file_4": "N/A"
        }
    },
    {
        "repo": "data-crypto",
        "content": "'data-crypto/src/types.ts'\n:export type Bytes = Buffer | number[] | Uint8Array;\n\n'data-crypto/src/utils.ts'\n:/* eslint-disable no-bitwise */\n\nimport { Bytes } from \"./types\";\n\n/**\n * Convert a byte to a hex string\n *\n * @param {number} byte\n * @returns {string}\n */\nfunction byteToHex(byte: number): string {\n  return parseInt(String(byte), 10).toString(16).padStart(2, \"0\").toUpperCase();\n}\n\n/**\n * Convert a hex to a byte\n *\n * @param {string} hex\n * @returns {number}\n */\nfunction hexToByte(hex: string): number {\n  return parseInt(hex, 16);\n}\n\n/**\n * Converts hexadecimal code to binary code\n *\n * @param {string} A String containing single digit hexadecimal numbers e.g. '1d'\n * @returns {string} A string containing binary numbers e.g. '00011101'\n */\nfunction hexToBinary(text: string): string {\n  let result = \"\";\n\n  for (const nibble of text) {\n    result = result.concat(parseInt(nibble, 16).toString(2).padStart(4, \"0\"));\n  }\n\n  return result;\n}\n/**\n * Converts binary code to hexadecimal string\n *\n * @param {string} binaryString A string containing binary numbers e.g. '00011101'\n * @returns {string} A string containing the hexadecimal numbers e.g. '1d'\n */\nfunction binaryToHex(text: string): string {\n  let result = \"\";\n  for (let i = 0; i < text.length; i += 4) {\n    // Grab a chunk of 4 bits\n    const bytes = text.substr(i, 4);\n\n    // Convert to decimal then hexadecimal\n    const decimal = parseInt(bytes, 2);\n    const hex = decimal.toString(16);\n\n    // Uppercase all the letters and append to output\n    result = result.concat(hex.toUpperCase());\n  }\n\n  return result;\n}\n\n/**\n * XOR two String or buffer\n *\n * @param {string | Buffer} first String or Buffer\n * @param {string | Buffer} second String or Buffer\n * @param {BufferEncoding} encode Defualt is 16 \"hex\"\n * @returns {Buffer}\n */\nfunction xor(first: any, second: any, encode = \"hex\"): Buffer {\n  const fistByteBuffer = Buffer.isBuffer(first)\n    ? first\n    : // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      //@ts-ignore\n      Buffer.from(first, encode);\n  const secondByteBuffer = Buffer.isBuffer(second)\n    ? second\n    : // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      //@ts-ignore\n      Buffer.from(second, encode);\n\n  const result = Buffer.allocUnsafe(fistByteBuffer.length);\n  for (let i = 0; i < fistByteBuffer.length; i++) {\n    const firstByte = fistByteBuffer[i];\n    const secondByte = secondByteBuffer[i];\n    result.fill(firstByte ^ secondByte, i);\n  }\n  return result;\n}\n\nfunction convertToInt32(bytes: number[] | Uint8Array): number[] {\n  const result: number[] = [];\n  for (let i = 0; i < bytes.length; i += 4) {\n    result.push(\n      (bytes[i] << 24) |\n        (bytes[i + 1] << 16) |\n        (bytes[i + 2] << 8) |\n        bytes[i + 3],\n    );\n  }\n  return result;\n}\n\nfunction permute(k: string, arr: number[], n: number): string {\n  let per = \"\";\n  for (let i = 0; i < n; i++) {\n    per += k[arr[i] - 1];\n  }\n  return per;\n}\n\nfunction xorBinary(a: string, b: string): string {\n  let ans = \"\";\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] === b[i]) {\n      ans += \"0\";\n    } else {\n      ans += \"1\";\n    }\n  }\n  return ans;\n}\n\nfunction randomHexNibble(): string {\n  return randomIntFromInterval(0, 15).toString(16);\n}\n\nfunction randomIntFromInterval(min: number, max: number): number {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction checkInts(arrayish: string | any[]): arrayish is number[] {\n  if (!Number.isInteger(arrayish.length)) {\n    return false;\n  }\n\n  for (let i = 0; i < arrayish.length; i++) {\n    if (\n      !Number.isInteger(arrayish[i]) ||\n      arrayish[i] < 0 ||\n      arrayish[i] > 255\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * @param arg\n * @param copy\n * @returns\n */\nfunction coerceArray(arg: Bytes, copy = false): Uint8Array {\n  // ArrayBuffer view\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  if (arg.buffer && arg.name === \"Uint8Array\") {\n    if (copy) {\n      if (arg.slice) {\n        arg = arg.slice(0);\n      } else {\n        arg = Array.prototype.slice.call(arg);\n      }\n    }\n\n    return arg as Uint8Array;\n  }\n\n  // It's an array; check it is a valid representation of a byte\n  if (Array.isArray(arg)) {\n    if (!checkInts(arg)) {\n      throw new Error(\"Array contains invalid value: \" + arg);\n    }\n\n    return new Uint8Array(arg);\n  }\n\n  // Something else, but behaves like an array (maybe a Buffer? Arguments?)\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  //@ts-ignore\n  if (Number.isInteger(arg?.length) && checkInts(arg)) {\n    return new Uint8Array(arg);\n  }\n\n  throw new Error(\"unsupported array-like object\");\n}\n\nfunction createArray(length: number): Uint8Array {\n  return new Uint8Array(length);\n}\n\nfunction copyArray(\n  sourceArray: Uint8Array | number[],\n  targetArray: Uint8Array,\n  targetStart?: any,\n  sourceStart?: number,\n  sourceEnd?: number,\n): void {\n  if (typeof sourceStart === \"number\" || typeof sourceEnd === \"number\") {\n    if (sourceArray.slice) {\n      sourceArray = sourceArray.slice(sourceStart, sourceEnd);\n    } else {\n      sourceArray = Array.prototype.slice.call(\n        sourceArray,\n        sourceStart,\n        sourceEnd,\n      );\n    }\n  }\n  targetArray.set(sourceArray, targetStart);\n}\n\nexport {\n  xorBinary,\n  xor,\n  permute,\n  binaryToHex,\n  hexToBinary,\n  hexToByte,\n  byteToHex,\n  convertToInt32,\n  randomHexNibble,\n  randomIntFromInterval,\n  checkInts,\n  coerceArray,\n  createArray,\n  copyArray,\n};\n\n'data-crypto/src/des.ts'\n:import { xorBinary, permute, binaryToHex, hexToBinary } from \"./utils\";\nimport getRk from \"./getRk\";\n\nfunction _encrypt(pt: string, rkb: any[]) {\n  //Hexadecimal to binary\n  pt = hexToBinary(pt);\n\n  //Initial Permutation Table\n  const initial_perm = [\n    58,\n    50,\n    42,\n    34,\n    26,\n    18,\n    10,\n    2,\n    60,\n    52,\n    44,\n    36,\n    28,\n    20,\n    12,\n    4,\n    62,\n    54,\n    46,\n    38,\n    30,\n    22,\n    14,\n    6,\n    64,\n    56,\n    48,\n    40,\n    32,\n    24,\n    16,\n    8,\n    57,\n    49,\n    41,\n    33,\n    25,\n    17,\n    9,\n    1,\n    59,\n    51,\n    43,\n    35,\n    27,\n    19,\n    11,\n    3,\n    61,\n    53,\n    45,\n    37,\n    29,\n    21,\n    13,\n    5,\n    63,\n    55,\n    47,\n    39,\n    31,\n    23,\n    15,\n    7,\n  ];\n  //Initial Permutation\n  pt = permute(pt, initial_perm, 64);\n\n  //Splitting\n  let left = pt.substr(0, 32);\n  let right = pt.substr(32, 32);\n\n  //Expansion D-box Table\n  const exp_d = [\n    32,\n    1,\n    2,\n    3,\n    4,\n    5,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    12,\n    13,\n    14,\n    15,\n    16,\n    17,\n    16,\n    17,\n    18,\n    19,\n    20,\n    21,\n    20,\n    21,\n    22,\n    23,\n    24,\n    25,\n    24,\n    25,\n    26,\n    27,\n    28,\n    29,\n    28,\n    29,\n    30,\n    31,\n    32,\n    1,\n  ];\n\n  //S-box Table\n  const s = [\n    [\n      [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],\n      [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],\n      [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],\n      [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],\n    ],\n    [\n      [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],\n      [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],\n      [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],\n      [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],\n    ],\n\n    [\n      [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],\n      [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],\n      [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],\n      [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],\n    ],\n    [\n      [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],\n      [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],\n      [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],\n      [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],\n    ],\n    [\n      [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],\n      [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],\n      [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],\n      [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],\n    ],\n    [\n      [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],\n      [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],\n      [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],\n      [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],\n    ],\n    [\n      [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],\n      [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],\n      [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],\n      [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],\n    ],\n    [\n      [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],\n      [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],\n      [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],\n      [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],\n    ],\n  ];\n\n  //Straight Permutation Table\n  const per = [\n    16,\n    7,\n    20,\n    21,\n    29,\n    12,\n    28,\n    17,\n    1,\n    15,\n    23,\n    26,\n    5,\n    18,\n    31,\n    10,\n    2,\n    8,\n    24,\n    14,\n    32,\n    27,\n    3,\n    9,\n    19,\n    13,\n    30,\n    6,\n    22,\n    11,\n    4,\n    25,\n  ];\n\n  for (let i = 0; i < 16; i++) {\n    //Expansion D-box\n    const right_expanded = permute(right, exp_d, 48);\n\n    //XOR RoundKey[i] and right_expanded\n    let x = xorBinary(rkb[i], right_expanded);\n\n    //S-boxes\n    let op = \"\";\n    for (let j = 0; j < 8; j++) {\n      const row = 2 * parseInt(x[j * 6], 10) + parseInt(x[j * 6 + 5], 10);\n      const col =\n        8 * parseInt(x[j * 6 + 1], 10) +\n        4 * parseInt(x[j * 6 + 2], 10) +\n        2 * parseInt(x[j * 6 + 3], 10) +\n        parseInt(x[j * 6 + 4], 10);\n      let val = s[j][row][col];\n      op += parseInt(String(val / 8), 10);\n      val = parseInt(String(val % 8), 10);\n      op += parseInt(String(val / 4), 10);\n      val = parseInt(String(val % 4), 10);\n      op += parseInt(String(val / 2), 10);\n      val = parseInt(String(val % 2), 10);\n      op += parseInt(String(val), 10);\n    }\n\n    //Straight D-box\n    op = permute(op, per, 32);\n    //XOR left and op\n    x = xorBinary(op, left);\n    left = x;\n\n    //Swapper\n    if (i !== 15) {\n      const tempLeft = left;\n      left = right;\n      right = tempLeft;\n    }\n  }\n\n  //Combination\n  const combine = left + right;\n\n  //Final Permutation Table\n  const final_perm = [\n    40,\n    8,\n    48,\n    16,\n    56,\n    24,\n    64,\n    32,\n    39,\n    7,\n    47,\n    15,\n    55,\n    23,\n    63,\n    31,\n    38,\n    6,\n    46,\n    14,\n    54,\n    22,\n    62,\n    30,\n    37,\n    5,\n    45,\n    13,\n    53,\n    21,\n    61,\n    29,\n    36,\n    4,\n    44,\n    12,\n    52,\n    20,\n    60,\n    28,\n    35,\n    3,\n    43,\n    11,\n    51,\n    19,\n    59,\n    27,\n    34,\n    2,\n    42,\n    10,\n    50,\n    18,\n    58,\n    26,\n    33,\n    1,\n    41,\n    9,\n    49,\n    17,\n    57,\n    25,\n  ];\n\n  //Final Permutation\n  const cipher = binaryToHex(permute(combine, final_perm, 64));\n  return cipher;\n}\n\nfunction encryption(input: string, rkb: any[]) {\n  let output = \"\";\n\n  for (let index = 0; index < input.length; index += 16) {\n    let hex16 = input.slice(index ? index : 0, index + 16);\n    hex16 = hex16.padEnd(16, \"0\");\n    output += _encrypt(hex16, rkb);\n  }\n\n  return output;\n}\n\nconst Des = {\n  /**\n   * Mode: ECB\n   *\n   * @param plainTextHex\n   * @param keyHex\n   * @returns\n   */\n  encrypt(plainTextHex: string, keyHex: string): string {\n    const rkb = getRk(keyHex);\n\n    return encryption(plainTextHex, rkb);\n  },\n  /**\n   * Mode: ECB\n   *\n   * @param cipher Encrypted text\n   * @param keyHex\n   * @returns\n   */\n  decrypt(cipher: string, keyHex: string): string {\n    const rkb = getRk(keyHex).reverse();\n\n    return encryption(cipher, rkb);\n  },\n};\nexport default Des;\n\n'data-crypto/src/index.ts'\n:// react-native\nimport { Buffer } from \"buffer\";\nglobal.Buffer = global.Buffer || Buffer;\n\nimport Des from \"./des\";\nimport TripleDes from \"./tripleDes\";\nimport Aes from \"./aes\";\nimport { hexToBinary, binaryToHex } from \"./utils\";\nimport {\n  pinBlock,\n  pinBlockFormat0,\n  pinBlockFormat1,\n  pinBlockFormat2,\n  pinBlockFormat3,\n} from \"./pinBlock\";\n\nexport {\n  /** @deprecated Use Des */\n  Des as des,\n  Des,\n  Aes,\n  TripleDes,\n  pinBlock,\n  pinBlockFormat0,\n  pinBlockFormat1,\n  pinBlockFormat2,\n  pinBlockFormat3,\n  hexToBinary,\n  binaryToHex,\n};\n\n",
        "called_code_segment_file_1": "function _encrypt(pt: string, rkb: any[]) {...}",
        "invoking_code_segment_file_2": "function encryption(input: string, rkb: any[]) {...}",
        "called_code_segment_file_2": "function encryption(input: string, rkb: any[]) {...}",
        "using_code_segment_file_3": "encrypt(plainTextHex: string, keyHex: string): string {...}",
        "called_code_segment_file_3": "encrypt(plainTextHex: string, keyHex: string): string {...}",
        "using_code_segment_file_4": "import { Des } from './index';",
        "feature_description": "Add support for padding in the encryption process to handle plaintext inputs of varying lengths.",
        "detailed_feature_description": "The new feature modifies the `_encrypt` function in #file 1 to ensure that the plaintext is padded to a multiple of 16 bytes before encryption. This change is propagated to #file 2, which invokes `_encrypt`. The `encryption` function in #file 2 is updated to handle the padded plaintext. The `encrypt` function in #file 3 is updated to pass the padded plaintext to `encryption`. Finally, #file 4, which imports and uses the `Des` module, remains unchanged as it directly uses the updated `encrypt` function from #file 3.",
        "modified_complete_code": {
            "file_1": "function _encrypt(pt: string, rkb: any[]) { //Modify\n  pt = pt.padEnd(16, '0'); // New\n  //Hexadecimal to binary\n  pt = hexToBinary(pt);\n  ...\n}",
            "file_2": "function encryption(input: string, rkb: any[]) { //Modify\n  let output = '';\n  for (let index = 0; index < input.length; index += 16) {\n    let hex16 = input.slice(index ? index : 0, index + 16);\n    hex16 = hex16.padEnd(16, '0'); // New\n    output += _encrypt(hex16, rkb);\n  }\n  return output;\n}",
            "file_3": "encrypt(plainTextHex: string, keyHex: string): string { //Modify\n  const rkb = getRk(keyHex);\n  return encryption(plainTextHex.padEnd(16, '0'), rkb); // New\n}",
            "file_4": "import { Des } from './index'; // No changes needed"
        }
    },
    {
        "repo": "Share-IITK2",
        "content": "'Share-IITK2/src/app/upload.component.ts'\n:import { Component } from '@angular/core';\n\nimport { FileUploader } from 'ng2-file-upload';\n\nimport {Filetypes} from './filetypes';\n\nimport { FormGroup, FormBuilder, Validators } from '@angular/forms';\n\nimport {CoursesService} from './courses.service';\n\nimport {uploadValidators} from './uploadValidators';\n\nimport {SearchService} from './search.service';\n\n\n\n// const URL = '/api/';\n\nconst URL = 'https://evening-anchorage-3159.herokuapp.com/api/';\n\n \n\n@Component({\n\n  selector: 'upload',\n\n  templateUrl: './upload.html',\n\n  styleUrls: ['./app.component.css']\n\n})\n\nexport class UploadComponent {\n\n\n\n  uploadForm: FormGroup;\n\n  courses = [];\n\n  filetypes: string[] = Filetypes;\n\n  \n\n\n\n  constructor (private coursesService: CoursesService, fb: FormBuilder, private searchservice: SearchService) {\n\n\n\n    this.uploadForm=fb.group({\n\n            course:['Select Course',Validators.compose([Validators.required,uploadValidators.invalidCourse])],\n\n            filetype:['Select Type',Validators.compose([Validators.required,uploadValidators.invalidType])],\n\n            semester:['Select Semester',Validators.compose([Validators.required,uploadValidators.invalidSemester])],\n\n            session:['',Validators.compose([Validators.required,uploadValidators.invalidSession])]\n\n    })\n\n       coursesService.getCourses().subscribe(courses => {this.courses = courses});\n\n  }\n\n\n\n  public uploader:FileUploader = new FileUploader({url: URL});\n\n  public hasBaseDropZoneOver:boolean = false;\n\n  public hasAnotherDropZoneOver:boolean = false;\n\n \n\n  public fileOverBase(e:any):void {\n\n    this.hasBaseDropZoneOver = e;\n\n  }\n\n \n\n  public fileOverAnother(e:any):void {\n\n    this.hasAnotherDropZoneOver = e;\n\n  }\n\n\n\n\n\n    \n\n\n\n}\n'Share-IITK2/src/app/app.component.ts'\n:import { Component } from '@angular/core';\nimport { Observable } from 'rxjs/Rx';\nimport { SearchComponent} from './search.component';\nimport { FileSelectDirective, FileDropDirective, FileUploader } from 'ng2-file-upload/ng2-file-upload';\nimport {UploadComponent} from './upload.component';\nimport {DashboardComponent} from './dashboard.component';\nimport { FavoriteComponent } from './favorite.component';\n\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n       tabLabels: string[] = ['Dashboard', 'Upload', 'Search'];\n\n  currTab: string = 'Dashboard';\n\n  tabs: {} = {\n    'Dashboard' : {'state': true},\n    'Search': {'state': false},\n    'Upload': {'state': false},\n  };\n   check(state) {\n    this.tabs[this.currTab].state = state;\n  }\n\n  switchTab(tab: string) {\n    if (this.currTab !== tab) {\n      this.tabs[this.currTab].state = false;\n      this.tabs[tab].state = true;\n      this.currTab = tab;\n    }\n  }\n  tweet = {\n    totalLikes: 10,\n    iLike: false\n    \n  }\n}\n\n'Share-IITK2/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule,ReactiveFormsModule } from '@angular/forms';\nimport { HttpModule } from '@angular/http';\nimport { FavoriteComponent } from './favorite.component';\n\nimport { AppComponent } from './app.component';\nimport { CoursesService} from './courses.service';\nimport { SearchComponent} from './search.component';\nimport { SearchService } from './search.service';\nimport {UploadComponent} from './upload.component';\nimport { FileSelectDirective, FileDropDirective} from 'ng2-file-upload';\n\nimport {DashboardComponent} from './dashboard.component';\n\n\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    SearchComponent,\n    UploadComponent,\n    FileSelectDirective,\n    FileDropDirective,\n    DashboardComponent,\n    FavoriteComponent\n    \n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    ReactiveFormsModule,\n    HttpModule\n],\n  providers: [CoursesService,SearchService],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'Share-IITK2/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule);\n\n",
        "called_code_segment_file_1": "getCourses().subscribe(courses => {this.courses = courses});",
        "invoking_code_segment_file_2": "constructor (private coursesService: CoursesService, fb: FormBuilder, private searchservice: SearchService) {\n\n    this.uploadForm=fb.group({\n            course:['Select Course',Validators.compose([Validators.required,uploadValidators.invalidCourse])],\n            filetype:['Select Type',Validators.compose([Validators.required,uploadValidators.invalidType])],\n            semester:['Select Semester',Validators.compose([Validators.required,uploadValidators.invalidSemester])],\n            session:['',Validators.compose([Validators.required,uploadValidators.invalidSession])]\n    })\n       coursesService.getCourses().subscribe(courses => {this.courses = courses});\n  }",
        "called_code_segment_file_2": "getCourses().subscribe(courses => {this.courses = courses});",
        "using_code_segment_file_3": "constructor (private coursesService: CoursesService, fb: FormBuilder, private searchservice: SearchService) {\n\n    this.uploadForm=fb.group({\n            course:['Select Course',Validators.compose([Validators.required,uploadValidators.invalidCourse])],\n            filetype:['Select Type',Validators.compose([Validators.required,uploadValidators.invalidType])],\n            semester:['Select Semester',Validators.compose([Validators.required,uploadValidators.invalidSemester])],\n            session:['',Validators.compose([Validators.required,uploadValidators.invalidSession])]\n    })\n       coursesService.getCourses().subscribe(courses => {this.courses = courses});\n  }",
        "called_code_segment_file_3": "getCourses().subscribe(courses => {this.courses = courses});",
        "using_code_segment_file_4": "constructor (private coursesService: CoursesService, fb: FormBuilder, private searchservice: SearchService) {\n\n    this.uploadForm=fb.group({\n            course:['Select Course',Validators.compose([Validators.required,uploadValidators.invalidCourse])],\n            filetype:['Select Type',Validators.compose([Validators.required,uploadValidators.invalidType])],\n            semester:['Select Semester',Validators.compose([Validators.required,uploadValidators.invalidSemester])],\n            session:['',Validators.compose([Validators.required,uploadValidators.invalidSession])]\n    })\n       coursesService.getCourses().subscribe(courses => {this.courses = courses});\n  }",
        "feature_description": "Add a feature to log the courses fetched from the service to the console.",
        "detailed_feature_description": "Modify the getCourses method in CoursesService to log the fetched courses to the console. Update the UploadComponent to handle the modified getCourses method and ensure any related code segments used by SearchComponent are updated accordingly. If SearchComponent directly interacts with updated segments in UploadComponent, modify the code in SearchComponent to accommodate the changes. Update AppComponent if it interacts with or depends on any updated segments in SearchComponent.",
        "modified_complete_code": {
            "file_1": "getCourses().subscribe(courses => {this.courses = courses});",
            "file_2": "constructor (private coursesService: CoursesService, fb: FormBuilder, private searchservice: SearchService) {\n\n    this.uploadForm=fb.group({\n            course:['Select Course',Validators.compose([Validators.required,uploadValidators.invalidCourse])],\n            filetype:['Select Type',Validators.compose([Validators.required,uploadValidators.invalidType])],\n            semester:['Select Semester',Validators.compose([Validators.required,uploadValidators.invalidSemester])],\n            session:['',Validators.compose([Validators.required,uploadValidators.invalidSession])]\n    })\n       coursesService.getCourses().subscribe(courses => {this.courses = courses});\n  }",
            "file_3": "constructor (private coursesService: CoursesService, fb: FormBuilder, private searchservice: SearchService) {\n\n    this.uploadForm=fb.group({\n            course:['Select Course',Validators.compose([Validators.required,uploadValidators.invalidCourse])],\n            filetype:['Select Type',Validators.compose([Validators.required,uploadValidators.invalidType])],\n            semester:['Select Semester',Validators.compose([Validators.required,uploadValidators.invalidSemester])],\n            session:['',Validators.compose([Validators.required,uploadValidators.invalidSession])]\n    })\n       coursesService.getCourses().subscribe(courses => {this.courses = courses});\n  }",
            "file_4": "constructor (private coursesService: CoursesService, fb: FormBuilder, private searchservice: SearchService) {\n\n    this.uploadForm=fb.group({\n            course:['Select Course',Validators.compose([Validators.required,uploadValidators.invalidCourse])],\n            filetype:['Select Type',Validators.compose([Validators.required,uploadValidators.invalidType])],\n            semester:['Select Semester',Validators.compose([Validators.required,uploadValidators.invalidSemester])],\n            session:['',Validators.compose([Validators.required,uploadValidators.invalidSession])]\n    })\n       coursesService.getCourses().subscribe(courses => {this.courses = courses});\n  }"
        }
    },
    {
        "repo": "cxml",
        "content": "'cxml/src/tokenizer/TokenSet.ts'\n:import { Patricia } from './Patricia';\nimport { ParserNamespace } from '../parser/ParserNamespace';\nimport { TokenSpace } from './TokenSpace';\nimport { InternalToken } from '../parser/InternalToken';\n\nexport class TokenSet {\n\n\tconstructor(private space: TokenSpace, parent?: TokenSet) {\n\t\tif(parent) {\n\t\t\tthis.isLinked = true;\n\n\t\t\tthis.tbl = parent.tbl;\n\t\t\tthis.trie = parent.trie;\n\t\t} else {\n\t\t\tthis.isLinked = false;\n\n\t\t\tthis.tbl = {};\n\t\t\tthis.trie = new Patricia();\n\t\t}\n\t}\n\n\tlink() {\n\t\tthis.isLinked = true;\n\t}\n\n\tprivate unlink() {\n\t\tif(!this.isLinked) return;\n\t\tthis.isLinked = false;\n\n\t\tconst tbl: { [ name: string ]: InternalToken } = {};\n\t\tfor(let key of Object.keys(this.tbl)) {\n\t\t\ttbl[key] = this.tbl[key];\n\t\t}\n\n\t\tthis.tbl = tbl;\n\t\tthis.trie = this.trie.clone();\n\t}\n\n\tcreateToken(name: string, ns?: ParserNamespace) {\n\t\tlet token = this.tbl[name];\n\n\t\tif(!token) {\n\t\t\tthis.unlink();\n\n\t\t\ttoken = this.space.createToken(name, ns);\n\n\t\t\tthis.tbl[name] = token;\n\t\t\tif(token.name) {\n\t\t\t\tthis.dirty = true;\n\t\t\t\tthis.trie.insertNode(token);\n\t\t\t}\n\t\t}\n\n\t\treturn(token);\n\t}\n\n\taddToken(token: InternalToken) {\n\t\tif(token.name) {\n\t\t\tthis.dirty = true;\n\t\t\tthis.tbl[token.name] = token;\n\t\t\tthis.trie.insertNode(token);\n\t\t}\n\t}\n\n\tencodeTrie() {\n\t\treturn(this.trie.encode());\n\t}\n\n\t/** If true, object is a clone sharing data with another object. */\n\tprivate isLinked: boolean;\n\n\tprivate tbl: { [ name: string ]: InternalToken };\n\tprivate trie: Patricia;\n\n\tpublic dirty = true;\n\n}\n\n'cxml/src/parser/Parser.ts'\n:import { ArrayType, encodeArray } from '../Buffer';\nimport { Namespace } from '../Namespace';\nimport { CodeType } from '../tokenizer/CodeType';\nimport { ErrorType } from '../tokenizer/ErrorType';\nimport { NativeParser } from './ParserLib';\nimport { ParserConfig } from './ParserConfig';\nimport { ParserNamespace } from './ParserNamespace';\nimport { InternalToken } from './InternalToken';\nimport { TokenSet } from '../tokenizer/TokenSet';\nimport { TokenChunk } from './TokenChunk';\nimport { Stitcher } from './Stitcher';\nimport {\n\tToken,\n\tTokenBuffer,\n\tTokenKind,\n\tSpecialToken,\n\tMemberToken,\n\tOpenToken,\n\tCloseToken,\n\tStringToken,\n\tSgmlToken\n} from './Token';\n\n// const codeBufferSize = 2;\n// const codeBufferSize = 3;\nconst codeBufferSize = 8192;\n\nconst chunkSize = Infinity;\n\nconst enum TOKEN {\n\tSHIFT = 5,\n\tMASK = 31\n}\n\nexport class ParseError extends Error {\n\n\tconstructor(public code: ErrorType, public row: number, public col: number) {\n\t\tsuper('Parse error on line ' + row + ' column ' + col);\n\t}\n\n}\n\n/** XML parser stream, emits tokens with fully qualified names. */\n\nexport class Parser {\n\n\t/** Call only from ParserConfig.createParser.\n\t  * @param config Reference to C++ config object.\n\t  * @param native Reference to C++ parser object. */\n\n\tconstructor(private config: ParserConfig, private native: NativeParser) {\n\t\tthis.codeBuffer = new Uint32Array(codeBufferSize);\n\t\tthis.native.setCodeBuffer(this.codeBuffer, () => this.parseCodeBuffer(true));\n\n\t\tfor(let ns of this.config.namespaceList) {\n\t\t\tif(ns && (ns.base.isSpecial || ns.base.defaultPrefix == 'xml')) {\n\t\t\t\tthis.namespaceList[ns.base.id] = ns.base;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic getConfig() { return(this.config); }\n\n\tbindPrefix(prefix: InternalToken, uri: InternalToken) {\n\t\tthis.native.bindPrefix(prefix.id, uri.id);\n\t}\n\n\tpublic parseSync(data: string | ArrayType) {\n\t\tconst buffer: TokenBuffer = [];\n\t\tlet namespaceList: (Namespace | undefined)[] | undefined;\n\n\t\tthis.write(data, '', (err: any, chunk: TokenChunk | null) => {\n\t\t\tif(err || !chunk) throw(err);\n\n\t\t\tfor(let tokenNum = 0; tokenNum < chunk.length; ++tokenNum) {\n\t\t\t\tbuffer.push(chunk.buffer[tokenNum]);\n\t\t\t}\n\n\t\t\tif(chunk.namespaceList) namespaceList = chunk.namespaceList;\n\n\t\t\tchunk.free();\n\t\t});\n\n\t\tconst output = TokenChunk.allocate(buffer);\n\t\toutput.namespaceList = namespaceList;\n\n\t\treturn(output);\n\t}\n\n\tdestroy(\n\t\tflush: (err: any, chunk: TokenChunk | null) => void\n\t) {\n\t\tconst nativeStatus = this.native.destroy();\n\n\t\tif(nativeStatus != ErrorType.OK) {\n\t\t\tthis.hasError = new ParseError(nativeStatus, this.native.row + 1, this.native.col + 1);\n\t\t\tflush(this.hasError, null);\n\t\t} else {\n\t\t\tthis.parseCodeBuffer(false);\n\t\t\tflush(null, this.tokenChunk);\n\t\t}\n\t}\n\n\twrite(\n\t\tchunk: string | ArrayType,\n\t\tenc: string,\n\t\tflush: (err: any, chunk: TokenChunk | null) => void\n\t) {\n\t\tif(this.hasError) {\n\t\t\tflush(this.hasError, null);\n\t\t\treturn;\n\t\t}\n\n\t\tif(typeof(chunk) == 'string') chunk = encodeArray(chunk);\n\n\t\tconst len = chunk.length;\n\t\tlet nativeStatus = ErrorType.OK;\n\t\tlet next: number;\n\n\t\tif(len < chunkSize) {\n\t\t\tthis.chunk = chunk;\n\t\t\tthis.stitcher.setChunk(this.chunk);\n\t\t\tnativeStatus = this.native.parse(this.chunk);\n\t\t\tthis.parseCodeBuffer(false);\n\t\t} else {\n\t\t\t// Limit size of buffers sent to native code.\n\t\t\tfor(let pos = 0; pos < len; pos = next) {\n\t\t\t\tnext = Math.min(pos + chunkSize, len);\n\n\t\t\t\tthis.chunk = chunk.slice(pos, next);\n\t\t\t\tthis.stitcher.setChunk(this.chunk);\n\t\t\t\tnativeStatus = this.native.parse(this.chunk);\n\n\t\t\t\tif(nativeStatus != ErrorType.OK) break;\n\t\t\t\tthis.parseCodeBuffer(false);\n\t\t\t}\n\t\t}\n\n\t\tif(nativeStatus != ErrorType.OK) {\n\t\t\tthis.hasError = new ParseError(nativeStatus, this.native.row + 1, this.native.col + 1);\n\t\t\tflush(this.hasError, null);\n\t\t\treturn;\n\t\t}\n\n\t\tif(this.elementStart < 0) {\n\t\t\tif(this.namespacesChanged) this.tokenChunk.namespaceList = this.namespaceList;\n\t\t\tflush(null, this.tokenChunk);\n\n\t\t\tthis.tokenChunk = TokenChunk.allocate();\n\t\t} else {\n\t\t\t// Not ready to flush but have to send something to get more input.\n\t\t\tflush(null, null);\n\t\t}\n\t}\n\n\tprivate parseCodeBuffer(pending: boolean) {\n\t\tconst config = this.config;\n\t\tconst stitcher = this.stitcher;\n\t\tconst codeBuffer = this.codeBuffer;\n\t\tconst codeCount = codeBuffer[0];\n\n\t\t// NOTE: These must be updated if config is unlinked!\n\t\tlet elementList = config.elementSpace.list;\n\t\tlet attributeList = config.attributeSpace.list;\n\t\tlet prefixList = config.prefixSpace.list;\n\t\tlet uriList = config.uriSpace.list;\n\t\tlet partialList = elementList;\n\n\t\tlet codeNum = 0;\n\t\tlet partStart = this.partStart;\n\t\tlet partialLen = this.partialLen;\n\t\tlet latestElement = this.latestElement;\n\t\tlet latestPrefix = this.latestPrefix;\n\t\tlet latestNamespace = this.latestNamespace;\n\n\t\tconst tokenBuffer = this.tokenChunk.buffer;\n\t\tconst prefixBuffer = this.prefixBuffer;\n\t\tconst namespaceBuffer = this.namespaceBuffer;\n\t\tconst unknownElementTbl = this.unknownElementTbl;\n\t\tconst unknownAttributeTbl = this.unknownAttributeTbl;\n\t\tconst sgmlTbl = this.sgmlTbl;\n\t\tconst unknownOffsetList = this.unknownOffsetList;\n\t\tlet tokenNum = this.tokenChunk.length - 1;\n\t\tlet token: Token;\n\t\tlet name: string;\n\t\tlet prefix: string;\n\t\tlet elementStart = this.elementStart;\n\t\tlet unknownCount = this.unknownCount;\n\n\t\twhile(codeNum < codeCount) {\n\t\t\tlet code = codeBuffer[++codeNum];\n\t\t\tconst kind = code & TOKEN.MASK;\n\t\t\tcode >>= TOKEN.SHIFT;\n\n\t\t\tswitch(kind) {\n\t\t\t\tcase CodeType.OPEN_ELEMENT_ID:\n\n\t\t\t\t\tlatestElement = elementList[code].open;\n\t\t\t\t\t// TODO: If latestprefix is null, use current prefix for element's namespace.\n\t\t\t\t\ttokenBuffer[++tokenNum] = latestElement;\n\t\t\t\t\tprefixBuffer[0] = latestPrefix;\n\t\t\t\t\telementStart = tokenNum;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.CLOSE_ELEMENT_ID:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = elementList[code].close;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.ELEMENT_EMITTED:\n\t\t\t\tcase CodeType.CLOSED_ELEMENT_EMITTED:\n\n\t\t\t\t\tif(unknownCount) {\n\t\t\t\t\t\tlet ns: ParserNamespace;\n\t\t\t\t\t\tlet offset: number;\n\n\t\t\t\t\t\tfor(let pos = 0; pos < unknownCount; ++pos) {\n\t\t\t\t\t\t\toffset = unknownOffsetList[pos];\n\t\t\t\t\t\t\tns = namespaceBuffer[offset]!;\n\t\t\t\t\t\t\t// If an xmlns definition already resolved\n\t\t\t\t\t\t\t// this token, ns will be null.\n\t\t\t\t\t\t\tif(ns) {\n\t\t\t\t\t\t\t\t// Ensure namespace is updated after config unlink.\n\t\t\t\t\t\t\t\tns = config.namespaceList[ns.id];\n\t\t\t\t\t\t\t\ttokenBuffer[offset + elementStart] = (\n\t\t\t\t\t\t\t\t\ttokenBuffer[offset + elementStart] as MemberToken\n\t\t\t\t\t\t\t\t).resolve(ns);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlatestElement = tokenBuffer[elementStart] as OpenToken;\n\t\t\t\t\t\tunknownCount = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = (\n\t\t\t\t\t\tkind == CodeType.ELEMENT_EMITTED ?\n\t\t\t\t\t\tlatestElement.emitted :\n\t\t\t\t\t\tlatestElement.close\n\t\t\t\t\t)\n\n\t\t\t\t\telementStart = -1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.ATTRIBUTE_ID:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = attributeList[code].string;\n\t\t\t\t\t// If latestprefix is null, set attribute prefix to match its parent element.\n\t\t\t\t\tprefixBuffer[tokenNum - elementStart] = latestPrefix || prefixBuffer[0];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.PREFIX_ID:\n\n\t\t\t\t\tlatestNamespace = config.namespaceList[code >> 14];\n\t\t\t\t\tcode = code & 0x3fff;\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.XMLNS_ID:\n\n\t\t\t\t\tlatestPrefix = prefixList[code];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.NAMESPACE_ID:\n\n\t\t\t\t\tthis.resolve(elementStart, tokenNum, latestPrefix!, code);\n\t\t\t\t\ttokenBuffer[++tokenNum] = latestPrefix!.prefix;\n\t\t\t\t\ttokenBuffer[++tokenNum] = this.config.namespaceList[code].uriToken;\n\t\t\t\t\tlatestPrefix = null;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.SGML_ID:\n\n\t\t\t\t\ttoken = elementList[code].open;\n\t\t\t\t\tprefix = (token as MemberToken).ns.defaultPrefix;\n\t\t\t\t\tname = (token as MemberToken).name;\n\t\t\t\t\ttoken = sgmlTbl[prefix + ':' + name];\n\n\t\t\t\t\tif(!token) {\n\t\t\t\t\t\ttoken = new SgmlToken(name, prefix);\n\t\t\t\t\t\tsgmlTbl[prefix + ':' + name] = token as SgmlToken;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = token;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.TEXT_START_OFFSET:\n\t\t\t\tcase CodeType.CDATA_START_OFFSET:\n\t\t\t\tcase CodeType.VALUE_START_OFFSET:\n\t\t\t\tcase CodeType.COMMENT_START_OFFSET:\n\t\t\t\tcase CodeType.SGML_TEXT_START_OFFSET:\n\t\t\t\tcase CodeType.UNKNOWN_START_OFFSET:\n\n\t\t\t\t\tpartStart = code;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_OPEN_ELEMENT_END_OFFSET:\n\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\tlatestElement = unknownElementTbl[name];\n\n\t\t\t\t\tif(!latestElement) {\n\t\t\t\t\t\tlatestElement = new OpenToken(name, Namespace.unknown);\n\t\t\t\t\t\tunknownElementTbl[name] = latestElement;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = latestElement;\n\t\t\t\t\tprefixBuffer[0] = latestPrefix;\n\t\t\t\t\tnamespaceBuffer[0] = latestNamespace;\n\t\t\t\t\telementStart = tokenNum;\n\t\t\t\t\tunknownOffsetList[0] = 0;\n\t\t\t\t\tunknownCount = 1;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_CLOSE_ELEMENT_END_OFFSET:\n\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\ttokenBuffer[++tokenNum] = (latestNamespace ?\n\t\t\t\t\t\tlatestNamespace.addElement(name) :\n\t\t\t\t\t\tunknownElementTbl[name]\n\t\t\t\t\t).close;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_ATTRIBUTE_END_OFFSET:\n\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\ttoken = unknownAttributeTbl[name];\n\n\t\t\t\t\tif(!token) {\n\t\t\t\t\t\ttoken = new StringToken(name, Namespace.unknown);\n\t\t\t\t\t\tunknownAttributeTbl[name] = token;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = token;\n\n\t\t\t\t\tlet pos = tokenNum - elementStart;\n\t\t\t\t\tprefixBuffer[pos] = latestPrefix;\n\t\t\t\t\tnamespaceBuffer[pos] = latestNamespace;\n\t\t\t\t\tunknownOffsetList[unknownCount++] = pos;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_SGML_END_OFFSET:\n\n\t\t\t\t\tprefix = latestPrefix ? latestPrefix.name : '';\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\ttoken = sgmlTbl[prefix + ':' + name];\n\n\t\t\t\t\tif(!token) {\n\t\t\t\t\t\ttoken = new SgmlToken(name, prefix);\n\t\t\t\t\t\tsgmlTbl[prefix + ':' + name] = token as SgmlToken;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = token;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.SGML_EMITTED:\n\t\t\t\tcase CodeType.SGML_NESTED_START:\n\t\t\t\tcase CodeType.SGML_NESTED_END:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = this.specialTokenTbl[kind];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.COMMENT_END_OFFSET:\n\t\t\t\tcase CodeType.SGML_TEXT_END_OFFSET:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = this.specialTokenTbl[kind];\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.VALUE_END_OFFSET:\n\t\t\t\tcase CodeType.TEXT_END_OFFSET:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = stitcher.getSlice(partStart, code);\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.CDATA_END_OFFSET:\n\n\t\t\t\t\ttokenBuffer[++tokenNum] = SpecialToken.cdata;\n\t\t\t\t\tname = stitcher.getSlice(partStart, code);\n\t\t\t\t\ttokenBuffer[++tokenNum] = name.substr(0, name.length - 3);\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.UNKNOWN_PREFIX_END_OFFSET:\n\t\t\t\tcase CodeType.UNKNOWN_XMLNS_END_OFFSET:\n\t\t\t\tcase CodeType.UNKNOWN_URI_END_OFFSET:\n\n\t\t\t\t\t// Add the namespace prefix or URI to a separate trie.\n\t\t\t\t\t// Incoming code buffer should have been flushed immediately\n\t\t\t\t\t// after writing this token.\n\n\t\t\t\t\tif(kind == CodeType.UNKNOWN_URI_END_OFFSET) {\n\t\t\t\t\t\tlet uri = stitcher.getSlice(partStart, code);\n\n\t\t\t\t\t\t/* if(uri.id > dynamicTokenTblSize) {\n\t\t\t\t\t\t\t// TODO: report row and column in error messages.\n\t\t\t\t\t\t\tthrow(new Error('Too many different xmlns URIs'));\n\t\t\t\t\t\t} */\n\n\t\t\t\t\t\t// Create a new namespace for the unrecognized URI.\n\t\t\t\t\t\tname = latestPrefix!.name;\n\t\t\t\t\t\tconst ns = new Namespace(name, uri, config.maxNamespace + 1);\n\t\t\t\t\t\t// This may unlink the config:\n\t\t\t\t\t\tconst idNamespace = config.bindNamespace(ns, latestPrefix!.name, this);\n\t\t\t\t\t\tthis.resolve(elementStart, tokenNum, latestPrefix!, idNamespace);\n\t\t\t\t\t\ttokenBuffer[++tokenNum] = latestPrefix!.prefix;\n\t\t\t\t\t\ttokenBuffer[++tokenNum] = this.config.namespaceList[idNamespace].uriToken;\n\t\t\t\t\t\tlatestPrefix = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// This may unlink the config:\n\t\t\t\t\t\tlatestPrefix = config.addPrefix(stitcher.getSlice(partStart, code));\n\n\t\t\t\t\t\t/* if(latestPrefix.id > dynamicTokenTblSize) {\n\t\t\t\t\t\t\t// TODO: report row and column in error messages.\n\t\t\t\t\t\t\tthrow(new Error('Too many different xmlns prefixes'));\n\t\t\t\t\t\t} */\n\n\t\t\t\t\t\tthis.native.setPrefix(latestPrefix.id);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Config may have been unlinked so update references to it.\n\t\t\t\t\telementList = config.elementSpace.list;\n\t\t\t\t\tattributeList = config.attributeSpace.list;\n\t\t\t\t\tprefixList = config.prefixSpace.list;\n\t\t\t\t\turiList = config.uriSpace.list;\n\n\t\t\t\t\tpartStart = -1;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.PARTIAL_LEN:\n\n\t\t\t\t\tpartialLen = code;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase CodeType.PARTIAL_URI_ID:\n\n\t\t\t\t\tpartialList = uriList;\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.PARTIAL_PREFIX_ID:\n\n\t\t\t\t\tif(partialList == elementList) partialList = prefixList;\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.PARTIAL_ATTRIBUTE_ID:\n\n\t\t\t\t\tif(partialList == elementList) partialList = attributeList;\n\n\t\t\t\t// Fallthru\n\t\t\t\tcase CodeType.PARTIAL_ELEMENT_ID:\n\n\t\t\t\t\tstitcher.reset(partialList[code].buf, partialLen);\n\t\t\t\t\tpartialList = elementList;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!pending && partStart >= 0) {\n\t\t\tstitcher.storeSlice(partStart);\n\t\t\tpartStart = 0;\n\t\t}\n\n\t\t// NOTE: Any active cursor in native code will still use the old trie\n\t\t// after update.\n\t\tconfig.updateNamespaces();\n\n\t\tthis.partStart = partStart;\n\t\tthis.partialLen = partialLen;\n\t\tthis.latestElement = latestElement;\n\t\tthis.latestPrefix = latestPrefix;\n\t\tthis.latestNamespace = latestNamespace;\n\n\t\tthis.tokenChunk.length = tokenNum + 1;\n\t\tthis.elementStart = elementStart;\n\t\tthis.unknownCount = unknownCount;\n\t}\n\n\t/** Resolve any prior occurrences of a recently defined prefix\n\t  * within the same element. */\n\tprivate resolve(elementStart: number, tokenNum: number, prefix: InternalToken, idNamespace: number) {\n\t\tconst prefixBuffer = this.prefixBuffer;\n\t\tconst tokenBuffer = this.tokenChunk.buffer;\n\t\tconst ns = this.config.namespaceList[idNamespace];\n\t\tconst len = tokenNum - elementStart;\n\t\tlet token: Token | number | string;\n\n\t\tif(!ns.base.defaultPrefix) {\n\t\t\tns.base.defaultPrefix = prefix.name;\n\t\t}\n\t\tthis.namespaceList[ns.base.id] = ns.base;\n\t\tthis.namespacesChanged = true;\n\n\t\tfor(let pos = 0; pos <= len; ++pos) {\n\t\t\tif(prefixBuffer[pos] == prefix) {\n\t\t\t\ttoken = tokenBuffer[pos + elementStart];\n\t\t\t\tif(token instanceof MemberToken) {\n\t\t\t\t\ttokenBuffer[pos + elementStart] = token.resolve(ns);\n\t\t\t\t\tthis.namespaceBuffer[pos] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate stitcher = new Stitcher();\n\n\t/** Current element not yet emitted (closing angle bracket unseen). */\n\tprivate latestElement: OpenToken;\n\t/** Previous namespace prefix token, applied to the next element, attribute\n\t  * or xmlns definition. */\n\tprivate latestPrefix: InternalToken | null;\n\tprivate latestNamespace: ParserNamespace | null;\n\n\t/** Current input buffer. */\n\tprivate chunk: ArrayType;\n\n\tprivate namespaceList: (Namespace | undefined)[] = [];\n\tprivate namespacesChanged = true;\n\n\t/** Offset to start of text in input buffer, or -1 if not reading text. */\n\tprivate partStart = -1;\n\n\t/** Number of valid initial bytes in next token. */\n\tprivate partialLen: number;\n\n\t/** Shared with C++ library. */\n\tprivate codeBuffer: Uint32Array;\n\t/** Stream output buffer chunk. */\n\ttokenChunk = TokenChunk.allocate();\n\n\t/** Offset to start of current element definition in output buffer. */\n\tprivate elementStart = -1;\n\t/** Prefixes of latest tokenBuffer entries (their namespace may change\n\t  * if the prefix is remapped). Index 0 corresponds to elementStart. */\n\tprivate prefixBuffer: (InternalToken | null)[] = [];\n\tprivate namespaceBuffer: (ParserNamespace | null)[] = [];\n\n\t/** Unresolved elements (temporary tokens lacking a namespace). */\n\tprivate unknownElementTbl: { [ name: string ]: OpenToken } = {};\n\t/** Unresolved attributes (temporary tokens lacking a namespace). */\n\tprivate unknownAttributeTbl: { [ name: string ]: Token } = {};\n\tprivate sgmlTbl: { [ name: string ]: SgmlToken } = {};\n\tprivate unknownOffsetList: number[] = [];\n\n\tprivate unknownCount = 0;\n\n\tspecialTokenTbl = {\n\t\t[CodeType.COMMENT_END_OFFSET]: SpecialToken.comment,\n\t\t[CodeType.SGML_EMITTED]: SpecialToken.sgmlEmitted,\n\t\t[CodeType.SGML_NESTED_START]: SpecialToken.sgmlNestedStart,\n\t\t[CodeType.SGML_NESTED_END]: SpecialToken.sgmlNestedEnd,\n\t\t[CodeType.SGML_TEXT_END_OFFSET]: SpecialToken.sgmlText\n\t};\n\n\tprivate hasError?: ParseError;\n\n}\n\n'cxml/src/parser/ParserConfig.ts'\n:import { NativeConfig, NativeParser } from './ParserLib';\n\nimport { Namespace } from '../Namespace';\nimport { ParserNamespace } from './ParserNamespace';\nimport { TokenSpace } from '../tokenizer/TokenSpace';\nimport { TokenSet } from '../tokenizer/TokenSet';\nimport { InternalToken } from './InternalToken';\nimport { TokenChunk } from './TokenChunk';\nimport { TokenKind, MemberToken, OpenToken, CloseToken, EmittedToken, StringToken } from './Token';\nimport { Parser } from './Parser';\nimport { XModuleTable } from './JSX';\n\nexport interface ParserOptions {\n\tparseUnknown?: boolean;\n\tomitDefaults?: boolean;\n}\n\nexport interface TokenTbl {\n\t[ prefix: string ]: {\n\t\turi: string,\n\t\telements?: string[],\n\t\tattributes?: string[]\n\t}\n}\n\nexport interface Registry {\n\t[prefix: string]: {\n\t\t[ idOrName: string ]: MemberToken;\n\t}\n}\n\n/** Parser configuration for quickly instantiating new parsers.\n  * Each parser instance holds a new, cloned copy. */\n\nexport class ParserConfig {\n\n\t/** XML parser configuration.\n\t  * @param config Parent object for cloning.\n\t  * @param native Reference to C++ object. For internal use only. */\n\tconstructor(config?: ParserOptions | ParserConfig, native?: NativeConfig | null) {\n\t\tif(config instanceof ParserConfig) {\n\t\t\tconfig.link();\n\t\t\tthis.isLinked = true;\n\n\t\t\tthis.options = config.options;\n\n\t\t\tthis.uriSpace = config.uriSpace;\n\t\t\tthis.prefixSpace = config.prefixSpace;\n\t\t\tthis.elementSpace = config.elementSpace;\n\t\t\tthis.attributeSpace = config.attributeSpace;\n\n\t\t\tthis.xmlnsToken = config.xmlnsToken;\n\n\t\t\tthis.emptyPrefixToken = config.emptyPrefixToken;\n\t\t\tthis.xmlnsPrefixToken = config.xmlnsPrefixToken;\n\t\t\tthis.processingPrefixToken = config.processingPrefixToken;\n\n\t\t\tthis.uriSet = config.uriSet;\n\t\t\tthis.prefixSet = config.prefixSet;\n\n\t\t\tthis.namespaceList = config.namespaceList;\n\t\t\tthis.namespaceTbl = config.namespaceTbl;\n\t\t\tthis.maxNamespace = config.maxNamespace;\n\n\t\t\tthis.nsMapper = config.nsMapper;\n\t\t} else {\n\t\t\tthis.isLinked = false;\n\n\t\t\tthis.options = config || {};\n\n\t\t\tthis.uriSpace = new TokenSpace(TokenKind.uri);\n\t\t\tthis.prefixSpace = new TokenSpace(TokenKind.prefix);\n\t\t\tthis.elementSpace = new TokenSpace(TokenKind.element);\n\t\t\tthis.attributeSpace = new TokenSpace(TokenKind.attribute);\n\n\t\t\tthis.xmlnsToken = this.attributeSpace.createToken('xmlns');\n\n\t\t\tthis.uriSet = new TokenSet(this.uriSpace);\n\t\t\tthis.prefixSet = new TokenSet(this.prefixSpace);\n\n\t\t\tthis.namespaceList = [];\n\t\t\tthis.namespaceTbl = {};\n\t\t\tthis.maxNamespace = 0;\n\t\t}\n\n\t\t// this.clonedNamespaceCount = this.maxNamespace;\n\n\t\tif(!native) {\n\t\t\tthis.emptyPrefixToken = this.prefixSet.createToken('');\n\t\t\tthis.xmlnsPrefixToken = this.prefixSet.createToken('xmlns');\n\t\t\tthis.processingPrefixToken = this.prefixSet.createToken('?');\n\n\t\t\tnative = new NativeConfig(this.xmlnsToken.id, this.emptyPrefixToken.id, this.xmlnsPrefixToken.id, this.processingPrefixToken.id);\n\t\t}\n\n\t\tthis.native = native;\n\n\t\tif(!this.isLinked && !this.options.omitDefaults) {\n\t\t\tthis.bindNamespace(Namespace.processing);\n\t\t\tthis.bindNamespace(Namespace.unknown);\n\t\t\tthis.bindNamespace(Namespace.xml1998);\n\t\t}\n\t}\n\n\tlink() {\n\t\tthis.isLinked = true;\n\n\t\tthis.uriSpace.link();\n\t\tthis.prefixSpace.link();\n\t\tthis.elementSpace.link();\n\t\tthis.attributeSpace.link();\n\n\t\tthis.uriSet.link();\n\t\tthis.prefixSet.link();\n\t}\n\n\tunlink() {\n\t\tif(!this.isLinked) return;\n\t\tthis.isLinked = false;\n\n\t\tthis.uriSpace = new TokenSpace(TokenKind.uri, this.uriSpace);\n\t\tthis.prefixSpace = new TokenSpace(TokenKind.prefix, this.prefixSpace);\n\t\tthis.elementSpace = new TokenSpace(TokenKind.element, this.elementSpace);\n\t\tthis.attributeSpace = new TokenSpace(TokenKind.attribute, this.attributeSpace);\n\n\t\tthis.uriSet = new TokenSet(this.uriSpace, this.uriSet);\n\t\tthis.prefixSet = new TokenSet(this.prefixSpace, this.prefixSet);\n\n\t\tconst namespaceList = this.namespaceList.slice(0);\n\t\tlet num = namespaceList.length;\n\n\t\twhile(num--) {\n\t\t\tlet ns = namespaceList[num];\n\n\t\t\t// This just skips namespace 0 which never exists\n\t\t\t// (see ParserConfig.cc).\n\t\t\tif(ns) {\n\t\t\t\tns = new ParserNamespace(ns, this);\n\t\t\t\tns.id = num;\n\t\t\t\tnamespaceList[num] = ns;\n\t\t\t}\n\t\t}\n\n\t\tconst namespaceTbl: { [ name: string ]: ParserNamespace } = {};\n\t\tfor(let key of Object.keys(this.namespaceTbl)) {\n\t\t\tnamespaceTbl[key] = namespaceList[this.namespaceTbl[key].id];\n\t\t}\n\n\t\tthis.namespaceList = namespaceList;\n\t\tthis.namespaceTbl = namespaceTbl;\n\t}\n\n\tcreateParser() {\n\t\t// Create a native code parser which clones the native config.\n\t\tconst nativeParser = new NativeParser(this.native);\n\t\t// Create a cloned config with a native object shared with the new parser.\n\t\tconst config = new ParserConfig(this, nativeParser.getConfig());\n\n\t\treturn(new Parser(config, nativeParser));\n\t}\n\n\tparseSync(data: string) {\n\t\treturn(this.createParser().parseSync(data));\n\t}\n\n\tgetNamespace(uri: string) {\n\t\tconst ns = this.namespaceTbl[uri];\n\t\treturn(ns && ns.base);\n\t}\n\n\taddNamespace(nsBase: Namespace) {\n\t\tlet uri = (this.nsMapper && this.nsMapper(nsBase.uri)) || nsBase.uri;\n\t\tlet nsParser = this.namespaceTbl[uri];\n\n\t\tif(nsParser) return(nsParser.id);\n\n\t\tthis.unlink();\n\n\t\tnsBase.uri = uri;\n\t\tnsParser = new ParserNamespace(nsBase, this);\n\t\tnsParser.id = this.native.addNamespace(nsParser.registerNative());\n\n\t\tthis.namespaceList[nsParser.id] = nsParser;\n\t\tthis.namespaceTbl[uri] = nsParser;\n\n\t\tif(nsBase.id > this.maxNamespace) this.maxNamespace = nsBase.id;\n\n\t\tif(nsBase.defaultPrefix) this.addPrefix(nsBase.defaultPrefix);\n\t\tthis.addUri(uri, nsParser);\n\n\t\treturn(nsParser.id);\n\t}\n\n\tbindNamespace(nsBase: Namespace, prefix?: string, parser?: Parser) {\n\t\tthis.addNamespace(nsBase);\n\n\t\tlet uri = (this.nsMapper && this.nsMapper(nsBase.uri)) || nsBase.uri;\n\t\tlet nsParser = this.namespaceTbl[uri];\n\n\t\tif(!prefix && prefix != '') prefix = nsParser.base.defaultPrefix;\n\n\t\t(parser || this).bindPrefix(\n\t\t\tthis.addPrefix(prefix),\n\t\t\tthis.addUri(uri, nsParser)\n\t\t);\n\n\t\treturn(nsParser.id);\n\t}\n\n\tupdateNamespaces() {\n\t\tconst list = this.namespaceList;\n\t\tconst len = list.length;\n\n\t\tfor(let num = 0; num < len; ++num) {\n\t\t\tif(list[num]) list[num].registerNative();\n\t\t}\n\t}\n\n\tbindPrefix(prefix: InternalToken, uri: InternalToken) {\n\t\tthis.native.bindPrefix(prefix.id, uri.id);\n\t}\n\n\taddUri(uri: string, ns: ParserNamespace) {\n\t\tthis.unlink();\n\n\t\tconst token = this.uriSet.createToken(uri, ns);\n\n\t\tthis.native.setUriTrie(this.uriSet.encodeTrie());\n\t\tthis.native.addUri(token.id, ns.id);\n\t\tns.uriToken = token.uri;\n\n\t\treturn(token);\n\t}\n\n\taddPrefix(prefix: string) {\n\t\tthis.unlink();\n\n\t\tconst token = this.prefixSet.createToken(prefix);\n\n\t\tthis.native.setPrefixTrie(this.prefixSet.encodeTrie());\n\n\t\treturn(token);\n\t}\n\n\tregisterTokens(tbl: TokenTbl): Registry {\n\t\tconst registry: Registry = {};\n\t\tlet token: MemberToken;\n\n\t\tfor(let prefix of Object.keys(tbl)) {\n\t\t\tconst spec = tbl[prefix];\n\t\t\tconst uri = spec.uri;\n\t\t\tconst ns = this.getNamespace(uri) || new Namespace(prefix, uri);\n\n\t\t\tfor(let name of spec.elements || []) {\n\t\t\t\tconst tokens = this.getElementTokens(ns, name);\n\t\t\t\ttoken = tokens[TokenKind.open]!;\n\n\t\t\t\tregistry[prefix][name] = token;\n\t\t\t\tregistry[prefix][token.id!] = token;\n\t\t\t}\n\n\t\t\tfor(let name of spec.attributes || []) {\n\t\t\t\tconst tokens = this.getAttributeTokens(ns, name);\n\t\t\t\ttoken = tokens[TokenKind.string]!;\n\n\t\t\t\tregistry[prefix][name] = token;\n\t\t\t\tregistry[prefix][token.id!] = token;\n\t\t\t}\n\t\t}\n\n\t\treturn(registry);\n\t}\n\n\tjsxRegister<Module extends XModuleTable>(spec: Module): Module;\n\n\tjsxRegister<Module extends XModuleTable, Result>(spec: Module, handler?: (result: Module) => Result): Result;\n\n\tjsxRegister<Module extends XModuleTable, Result>(spec: Module, handler?: (result: Module) => Result) {\n\t\tconst result: { [prefix: string]: { [name: string]: OpenToken | StringToken | string }} = {};\n\t\tlet token: OpenToken | StringToken;\n\n\t\tfor(let prefix of Object.keys(spec)) {\n\t\t\tconst elements = (spec as any)[prefix];\n\t\t\tconst uri = elements.xmlns;\n\t\t\tconst ns = this.getNamespace(uri) || new Namespace(prefix, uri);\n\t\t\tresult[prefix] = {};\n\n\t\t\tfor(let name of Object.keys(elements)) {\n\t\t\t\tif(name == 'xmlns') {\n\t\t\t\t\ttoken = elements[name];\n\t\t\t\t} else if(elements[name]) {\n\t\t\t\t\ttoken = this.getElementTokens(ns, name)[TokenKind.open]!;\n\t\t\t\t} else {\n\t\t\t\t\ttoken = this.getAttributeTokens(ns, name)[TokenKind.string]!;\n\t\t\t\t}\n\n\t\t\t\tresult[prefix][name] = token;\n\t\t\t}\n\t\t}\n\n\t\treturn(handler ? handler(result as Module) : result as Module);\n\t}\n\n\tgetElementTokens(ns: Namespace, name: string) {\n\t\tconst id = this.addNamespace(ns);\n\t\treturn(this.namespaceList[id].addElement(name).tokenList);\n\t}\n\n\tgetAttributeTokens(ns: Namespace, name: string) {\n\t\tconst id = this.addNamespace(ns);\n\t\treturn(this.namespaceList[id].addAttribute(name).tokenList);\n\t}\n\n\t/** If true, object is a clone sharing data with another object. */\n\tprivate isLinked: boolean;\n\n\t/** Reference to C++ object. */\n\tprivate native: NativeConfig;\n\n\toptions: ParserOptions;\n\n\t/** Represents an \"attribute\" defining the default xmlns. */\n\txmlnsToken: InternalToken;\n\temptyPrefixToken: InternalToken;\n\t/** Represents the \"xmlns\" prefix defining a named xmlns. */\n\txmlnsPrefixToken: InternalToken;\n\tprocessingPrefixToken: InternalToken;\n\n\t/** Allocates ID numbers for xmlns uri tokens. */\n\turiSpace: TokenSpace;\n\t/** Allocates ID numbers for xmlns prefix tokens. */\n\tprefixSpace: TokenSpace;\n\t/** Allocates ID numbers for element name tokens. */\n\telementSpace: TokenSpace;\n\t/** Allocates ID numbers for attribute name tokens. */\n\tattributeSpace: TokenSpace;\n\n\turiSet: TokenSet;\n\tprefixSet: TokenSet;\n\n\t/** List of supported namespaces. */\n\tnamespaceList: ParserNamespace[];\n\t/** Mapping from URI to namespace. */\n\tprivate namespaceTbl: { [ uri: string ]: ParserNamespace };\n\tmaxNamespace: number;\n\n\tnsMapper?: (uri: string) => string | null | false | undefined;\n\n}\n\n'cxml/src/parser/ParserStream.ts'\n:import * as stream from 'stream';\n\nimport { ArrayType } from '../Buffer';\nimport { Namespace } from '../Namespace';\nimport { ParserConfig } from './ParserConfig';\nimport { Parser } from './Parser';\nimport { TokenChunk } from './TokenChunk';\nimport {\n\tToken,\n\tTokenBuffer,\n\tTokenKind,\n} from './Token';\n\n /** XML parser stream, emits tokens with fully qualified names. */\n\nexport class ParserStream extends stream.Transform {\n\n\tconstructor(config: ParserConfig, public parser = config.createParser()) {\n\t\tsuper({ objectMode: true });\n\t}\n\n\t_flush( flush: (err: any, chunk: TokenChunk | null) => void) {\n\t\tthis.parser.destroy(flush);\n\t\tflush(null, null);\n\t}\n\n\t_transform(\n\t\tchunk: string | ArrayType,\n\t\tenc: string,\n\t\tflush: (err: any, chunk: TokenChunk | null) => void\n\t) {\n\t\tthis.parser.write(chunk, enc, flush);\n\t}\n\n}\n\n",
        "called_code_segment_file_1": "parseCodeBuffer(pending: boolean) {\n    const config = this.config;\n    const stitcher = this.stitcher;\n    const codeBuffer = this.codeBuffer;\n    const codeCount = codeBuffer[0];\n\n    // NOTE: These must be updated if config is unlinked!\n    let elementList = config.elementSpace.list;\n    let attributeList = config.attributeSpace.list;\n    let prefixList = config.prefixSpace.list;\n    let uriList = config.uriSpace.list;\n    let partialList = elementList;\n\n    let codeNum = 0;\n    let partStart = this.partStart;\n    let partialLen = this.partialLen;\n    let latestElement = this.latestElement;\n    let latestPrefix = this.latestPrefix;\n    let latestNamespace = this.latestNamespace;\n\n    const tokenBuffer = this.tokenChunk.buffer;\n    const prefixBuffer = this.prefixBuffer;\n    const namespaceBuffer = this.namespaceBuffer;\n    const unknownElementTbl = this.unknownElementTbl;\n    const unknownAttributeTbl = this.unknownAttributeTbl;\n    const sgmlTbl = this.sgmlTbl;\n    const unknownOffsetList = this.unknownOffsetList;\n    let tokenNum = this.tokenChunk.length - 1;\n    let token: Token;\n    let name: string;\n    let prefix: string;\n    let elementStart = this.elementStart;\n    let unknownCount = this.unknownCount;\n\n    while(codeNum < codeCount) {\n        let code = codeBuffer[++codeNum];\n        const kind = code & TOKEN.MASK;\n        code >>= TOKEN.SHIFT;\n\n        switch(kind) {\n            case CodeType.OPEN_ELEMENT_ID:\n                latestElement = elementList[code].open;\n                tokenBuffer[++tokenNum] = latestElement;\n                prefixBuffer[0] = latestPrefix;\n                elementStart = tokenNum;\n                break;\n            // Other cases...\n        }\n    }\n\n    if(!pending && partStart >= 0) {\n        stitcher.storeSlice(partStart);\n        partStart = 0;\n    }\n\n    this.partStart = partStart;\n    this.partialLen = partialLen;\n    this.latestElement = latestElement;\n    this.latestPrefix = latestPrefix;\n    this.latestNamespace = latestNamespace;\n\n    this.tokenChunk.length = tokenNum + 1;\n    this.elementStart = elementStart;\n    this.unknownCount = unknownCount;\n}",
        "invoking_code_segment_file_2": "write(\n    chunk: string | ArrayType,\n    enc: string,\n    flush: (err: any, chunk: TokenChunk | null) => void\n) {\n    if(this.hasError) {\n        flush(this.hasError, null);\n        return;\n    }\n\n    if(typeof(chunk) == 'string') chunk = encodeArray(chunk);\n\n    const len = chunk.length;\n    let nativeStatus = ErrorType.OK;\n    let next: number;\n\n    if(len < chunkSize) {\n        this.chunk = chunk;\n        this.stitcher.setChunk(this.chunk);\n        nativeStatus = this.native.parse(this.chunk);\n        this.parseCodeBuffer(false);\n    } else {\n        // Limit size of buffers sent to native code.\n        for(let pos = 0; pos < len; pos = next) {\n            next = Math.min(pos + chunkSize, len);\n\n            this.chunk = chunk.slice(pos, next);\n            this.stitcher.setChunk(this.chunk);\n            nativeStatus = this.native.parse(this.chunk);\n\n            if(nativeStatus != ErrorType.OK) break;\n            this.parseCodeBuffer(false);\n        }\n    }\n\n    if(nativeStatus != ErrorType.OK) {\n        this.hasError = new ParseError(nativeStatus, this.native.row + 1, this.native.col + 1);\n        flush(this.hasError, null);\n        return;\n    }\n\n    if(this.elementStart < 0) {\n        if(this.namespacesChanged) this.tokenChunk.namespaceList = this.namespaceList;\n        flush(null, this.tokenChunk);\n\n        this.tokenChunk = TokenChunk.allocate();\n    } else {\n        flush(null, null);\n    }\n}",
        "called_code_segment_file_2": "bindPrefix(prefix: InternalToken, uri: InternalToken) {\n    this.native.bindPrefix(prefix.id, uri.id);\n}",
        "using_code_segment_file_3": "bindPrefix(prefix: InternalToken, uri: InternalToken) {\n    this.native.bindPrefix(prefix.id, uri.id);\n}",
        "called_code_segment_file_3": "bindPrefix(prefix: InternalToken, uri: InternalToken) {\n    this.native.bindPrefix(prefix.id, uri.id);\n}",
        "using_code_segment_file_4": "bindPrefix(prefix: InternalToken, uri: InternalToken) {\n    this.native.bindPrefix(prefix.id, uri.id);\n}",
        "feature_description": "Add a feature to log the number of tokens processed during parsing.",
        "detailed_feature_description": "The feature will modify the `parseCodeBuffer` method in #file 1 to increment a counter each time a token is processed. This counter will be logged at the end of the method. The `write` method in #file 2 will be updated to initialize and log this counter. The `bindPrefix` method in #file 3 will be updated to ensure compatibility with the new logging feature. No changes are required in #file 4 as it does not interact with the modified segments directly.",
        "modified_complete_code": {
            "file_1": "parseCodeBuffer(pending: boolean) {\n    const config = this.config;\n    const stitcher = this.stitcher;\n    const codeBuffer = this.codeBuffer;\n    const codeCount = codeBuffer[0];\n\n    // NOTE: These must be updated if config is unlinked!\n    let elementList = config.elementSpace.list;\n    let attributeList = config.attributeSpace.list;\n    let prefixList = config.prefixSpace.list;\n    let uriList = config.uriSpace.list;\n    let partialList = elementList;\n\n    let codeNum = 0;\n    let partStart = this.partStart;\n    let partialLen = this.partialLen;\n    let latestElement = this.latestElement;\n    let latestPrefix = this.latestPrefix;\n    let latestNamespace = this.latestNamespace;\n\n    const tokenBuffer = this.tokenChunk.buffer;\n    const prefixBuffer = this.prefixBuffer;\n    const namespaceBuffer = this.namespaceBuffer;\n    const unknownElementTbl = this.unknownElementTbl;\n    const unknownAttributeTbl = this.unknownAttributeTbl;\n    const sgmlTbl = this.sgmlTbl;\n    const unknownOffsetList = this.unknownOffsetList;\n    let tokenNum = this.tokenChunk.length - 1;\n    let token: Token;\n    let name: string;\n    let prefix: string;\n    let elementStart = this.elementStart;\n    let unknownCount = this.unknownCount;\n\n    let tokenCounter = 0; // #Modify: Add token counter\n\n    while(codeNum < codeCount) {\n        let code = codeBuffer[++codeNum];\n        const kind = code & TOKEN.MASK;\n        code >>= TOKEN.SHIFT;\n\n        switch(kind) {\n            case CodeType.OPEN_ELEMENT_ID:\n                latestElement = elementList[code].open;\n                tokenBuffer[++tokenNum] = latestElement;\n                prefixBuffer[0] = latestPrefix;\n                elementStart = tokenNum;\n                tokenCounter++; // #Modify: Increment token counter\n                break;\n            // Other cases...\n        }\n    }\n\n    if(!pending && partStart >= 0) {\n        stitcher.storeSlice(partStart);\n        partStart = 0;\n    }\n\n    this.partStart = partStart;\n    this.partialLen = partialLen;\n    this.latestElement = latestElement;\n    this.latestPrefix = latestPrefix;\n    this.latestNamespace = latestNamespace;\n\n    this.tokenChunk.length = tokenNum + 1;\n    this.elementStart = elementStart;\n    this.unknownCount = unknownCount;\n\n    console.log(`Tokens processed: ${tokenCounter}`); // #Modify: Log token counter\n}",
            "file_2": "write(\n    chunk: string | ArrayType,\n    enc: string,\n    flush: (err: any, chunk: TokenChunk | null) => void\n) {\n    if(this.hasError) {\n        flush(this.hasError, null);\n        return;\n    }\n\n    if(typeof(chunk) == 'string') chunk = encodeArray(chunk);\n\n    const len = chunk.length;\n    let nativeStatus = ErrorType.OK;\n    let next: number;\n\n    if(len < chunkSize) {\n        this.chunk = chunk;\n        this.stitcher.setChunk(this.chunk);\n        nativeStatus = this.native.parse(this.chunk);\n        this.parseCodeBuffer(false);\n    } else {\n        // Limit size of buffers sent to native code.\n        for(let pos = 0; pos < len; pos = next) {\n            next = Math.min(pos + chunkSize, len);\n\n            this.chunk = chunk.slice(pos, next);\n            this.stitcher.setChunk(this.chunk);\n            nativeStatus = this.native.parse(this.chunk);\n\n            if(nativeStatus != ErrorType.OK) break;\n            this.parseCodeBuffer(false);\n        }\n    }\n\n    if(nativeStatus != ErrorType.OK) {\n        this.hasError = new ParseError(nativeStatus, this.native.row + 1, this.native.col + 1);\n        flush(this.hasError, null);\n        return;\n    }\n\n    if(this.elementStart < 0) {\n        if(this.namespacesChanged) this.tokenChunk.namespaceList = this.namespaceList;\n        flush(null, this.tokenChunk);\n\n        this.tokenChunk = TokenChunk.allocate();\n    } else {\n        flush(null, null);\n    }\n}",
            "file_3": "bindPrefix(prefix: InternalToken, uri: InternalToken) {\n    this.native.bindPrefix(prefix.id, uri.id);\n}",
            "file_4": "bindPrefix(prefix: InternalToken, uri: InternalToken) {\n    this.native.bindPrefix(prefix.id, uri.id);\n}"
        }
    },
    {
        "repo": "angular-template-2.0",
        "content": "'angular-template-2.0/client/modules/common/hero.ts'\n:export interface Hero {\n  id: number;\n  name: string;\n}\n'angular-template-2.0/client/modules/dashboard/dashboard.component.ts'\n:import { Component, OnInit } from 'angular2/core';\nimport { Router } from 'angular2/router';\n\nimport { Hero } from '../common/hero';\nimport { HeroService } from '../common/heroes.service';\n\n\n@Component({\n    selector: 'dashboard',\n    templateUrl: 'client/modules/dashboard/dashboard.html',\n    styleUrls: [`client/modules/dashboard/dashboard.css`],\n    providers: [HeroService]\n})\n\nexport class DashboardComponent implements OnInit {\n    heroes: Hero[] = [];\n    constructor(\n        private _router: Router,\n        private _heroService: HeroService) {\n    }\n    ngOnInit() {\n        this._heroService.getHeroes()\n            .then(heroes => \n            this.heroes = heroes.slice(1, 5));\n    }\n    gotoDetail(hero: Hero) {\n        let link = ['HeroDetail', { id: hero.id }];\n        this._router.navigate(link);\n    }\n}\n\n\n'angular-template-2.0/client/modules/app/app.component.ts'\n:import {Component}       from 'angular2/core';\nimport { RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS } from 'angular2/router';\n\nimport {HeroesComponent} from '../heroes/heroes.component';\nimport {DashboardComponent} from '../dashboard/dashboard.component';\nimport {HeroDetailComponent} from '../details/details.component';\n\nimport {HeroService} from '../common/heroes.service'\n\n@Component({\n    selector: 'app',\n    templateUrl: 'client/modules/app/app.html',\n    styleUrls: [`client/modules/app/app.css`],\n    directives: [ROUTER_DIRECTIVES],\n    providers: [ROUTER_PROVIDERS, HeroService]\n})\n\n@RouteConfig([\n    {\n        path: '/heroes',\n        name: 'Heroes',\n        component: HeroesComponent\n    },\n    {\n        path: '/dashboard',\n        name: 'Dashboard',\n        component: DashboardComponent,\n        useAsDefault: true\n    }, \n    {\n        path: '/detail/:id',\n        name: 'HeroDetail',\n        component: HeroDetailComponent\n    },\n\n])\nexport class AppComponent {\n    title = 'Tour of Heroes';\n}\n'angular-template-2.0/client/app.ts'\n:import {bootstrap}    from 'angular2/platform/browser'\nimport {AppComponent} from './modules/app/app.component'\n\nbootstrap(AppComponent);\n\n",
        "called_code_segment_file_1": "ngOnInit() {\n        this._heroService.getHeroes()\n            .then(heroes => \n            this.heroes = heroes.slice(1, 5));\n    }",
        "invoking_code_segment_file_2": "ngOnInit() {\n        this._heroService.getHeroes()\n            .then(heroes => this.heroes = heroes);\n    }",
        "called_code_segment_file_2": "gotoDetail(hero: Hero) {\n        let link = ['HeroDetail', { id: hero.id }];\n        this._router.navigate(link);\n    }",
        "using_code_segment_file_3": "gotoDetail(hero: Hero) {\n        let link = ['HeroDetail', { id: hero.id }];\n        this._router.navigate(link);\n    }",
        "called_code_segment_file_3": "ngOnInit() {\n        this._routeParams.get('id')\n            .then((id) => {\n                this._heroService.getHero(id)\n                    .then(hero => this.hero = hero);\n            });\n    }",
        "using_code_segment_file_4": "ngOnInit() {\n        this._routeParams.get('id')\n            .then((id) => {\n                this._heroService.getHero(id)\n                    .then(hero => this.hero = hero);\n            });\n    }",
        "feature_description": "Add a feature to log the hero's name when navigating to the hero detail page.",
        "detailed_feature_description": "In #file 1, modify the `gotoDetail` method to log the hero's name before navigating. Update #file 2 to handle this logging and ensure #file 3 and #file 4 are updated accordingly if they interact with this method.",
        "modified_complete_code": {
            "file_1": "export class DashboardComponent implements OnInit {\n    heroes: Hero[] = [];\n    constructor(\n        private _router: Router,\n        private _heroService: HeroService) {\n    }\n    ngOnInit() {\n        this._heroService.getHeroes()\n            .then(heroes => \n            this.heroes = heroes.slice(1, 5));\n    }\n    gotoDetail(hero: Hero) {\n        console.log(`Navigating to detail of hero: ${hero.name}`); #Modify\n        let link = ['HeroDetail', { id: hero.id }];\n        this._router.navigate(link);\n    }\n}",
            "file_2": "export class HeroesComponent implements OnInit {\n    heroes: Hero[];\n    selectedHero: Hero;\n    constructor(private _heroService: HeroService) { }\n    ngOnInit() {\n        this._heroService.getHeroes()\n            .then(heroes => this.heroes = heroes);\n    }\n    onSelect(hero: Hero) {\n        this.selectedHero = hero;\n    }\n    gotoDetail(hero: Hero) {\n        console.log(`Navigating to detail of hero: ${hero.name}`); #Modify\n        let link = ['HeroDetail', { id: hero.id }];\n        this._router.navigate(link);\n    }\n}",
            "file_3": "export class HeroDetailComponent implements OnInit {\n    hero: Hero;\n    constructor(\n        private _heroService: HeroService,\n        private _routeParams: RouteParams) {\n    }\n    ngOnInit() {\n        this._routeParams.get('id')\n            .then((id) => {\n                this._heroService.getHero(id)\n                    .then(hero => this.hero = hero);\n            });\n    }\n    gotoDetail(hero: Hero) {\n        console.log(`Navigating to detail of hero: ${hero.name}`); #Modify\n        let link = ['HeroDetail', { id: hero.id }];\n        this._router.navigate(link);\n    }\n}",
            "file_4": "export class AppComponent {\n    title = 'Tour of Heroes';\n}"
        }
    },
    {
        "repo": "admin-panel",
        "content": "'admin-panel/src/app/home/home.component.ts'\n:import { Component, OnInit } from '@angular/core';\n\n@Component({\n  selector: 'app-home',\n  templateUrl: './home.component.html',\n  styleUrls: ['./home.component.scss']\n})\nexport class HomeComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}\n\n'admin-panel/src/app/app-routing.module.ts'\n:import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\nimport { DashboardComponent } from './dashboard/dashboard.component';\nimport { HomeComponent } from './home/home.component';\n\nconst routes: Routes = [\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\n  { path: 'home', component: HomeComponent },\n  { path: 'dashboard', component: DashboardComponent },\n];\n\n@NgModule({\n  imports: [RouterModule.forRoot(routes)],\n  exports: [RouterModule],\n})\nexport class AppRoutingModule {}\n\n'admin-panel/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent } from './app.component';\nimport { HeaderComponent } from './header/header.component';\nimport { HomeComponent } from './home/home.component';\nimport { DashboardComponent } from './dashboard/dashboard.component';\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { SidenavComponent } from './sidenav/sidenav.component';\nimport { MatSidenavModule } from '@angular/material/sidenav';\nimport { MatToolbarModule } from '@angular/material/toolbar';\nimport { MatMenuModule } from '@angular/material/menu';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatDividerModule } from '@angular/material/divider';\nimport { MatListModule } from '@angular/material/list';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    HomeComponent,\n    DashboardComponent,\n    SidenavComponent,\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    BrowserAnimationsModule,\n    // * MATERIAL IMPORTS\n    MatSidenavModule,\n    MatToolbarModule,\n    MatMenuModule,\n    MatIconModule,\n    MatDividerModule,\n    MatListModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})\nexport class AppModule {}\n\n'admin-panel/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "@Component({\n  selector: 'app-home',\n  templateUrl: './home.component.html',\n  styleUrls: ['./home.component.scss']\n})\nexport class HomeComponent implements OnInit {\n\n  constructor() { }\n\n  ngOnInit(): void {\n  }\n\n}",
        "invoking_code_segment_file_2": "const routes: Routes = [\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\n  { path: 'home', component: HomeComponent },\n  { path: 'dashboard', component: DashboardComponent },\n];",
        "called_code_segment_file_2": "const routes: Routes = [\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\n  { path: 'home', component: HomeComponent },\n  { path: 'dashboard', component: DashboardComponent },\n];",
        "using_code_segment_file_3": "@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    HomeComponent,\n    DashboardComponent,\n    SidenavComponent,\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    BrowserAnimationsModule,\n    // * MATERIAL IMPORTS\n    MatSidenavModule,\n    MatToolbarModule,\n    MatMenuModule,\n    MatIconModule,\n    MatDividerModule,\n    MatListModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})",
        "called_code_segment_file_3": "N/A",
        "using_code_segment_file_4": "N/A",
        "feature_description": "Add a new feature to display a welcome message on the home page.",
        "detailed_feature_description": "Modify the HomeComponent to include a welcome message. Update the HomeComponent's template to display this message. No further interactions between files are required as this feature is self-contained within the HomeComponent.",
        "modified_complete_code": {
            "file_1": "@Component({\n  selector: 'app-home',\n  templateUrl: './home.component.html',\n  styleUrls: ['./home.component.scss']\n})\nexport class HomeComponent implements OnInit {\n\n  welcomeMessage: string;\n\n  constructor() { }\n\n  ngOnInit(): void {\n    this.welcomeMessage = 'Welcome to the Admin Panel!';\n  }\n\n}",
            "file_2": "const routes: Routes = [\n  { path: '', redirectTo: 'home', pathMatch: 'full' },\n  { path: 'home', component: HomeComponent },\n  { path: 'dashboard', component: DashboardComponent },\n];",
            "file_3": "@NgModule({\n  declarations: [\n    AppComponent,\n    HeaderComponent,\n    HomeComponent,\n    DashboardComponent,\n    SidenavComponent,\n  ],\n  imports: [\n    BrowserModule,\n    AppRoutingModule,\n    BrowserAnimationsModule,\n    // * MATERIAL IMPORTS\n    MatSidenavModule,\n    MatToolbarModule,\n    MatMenuModule,\n    MatIconModule,\n    MatDividerModule,\n    MatListModule,\n  ],\n  providers: [],\n  bootstrap: [AppComponent],\n})",
            "file_4": "N/A"
        }
    },
    {
        "repo": "amifauzi.com-open",
        "content": "'amifauzi.com-open/app/components/Gallery/Utils/round.ts'\n:export const round = (value: number, decimals = 0) => {\n  return Number(Math.round(Number(`${value}e${decimals}`)) + \"e-\" + decimals);\n};\n\n'amifauzi.com-open/app/components/Gallery/Utils/findIdealNodeSearch.ts'\n:import { round } from \"./round\";\n\ninterface IFindIdealNodeSearchArg {\n  targetRowHeight: number;\n  containerWidth: number;\n}\n\n// guesstimate how many neighboring nodes should be searched based on\n// the aspect ratio of the container with images having an avg AR of 1.5\n// as the minimum amount of photos per row, plus some nodes\nexport const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  return round(rowAR / 1.5) + 8;\n};\n\n'amifauzi.com-open/app/components/Gallery/Gallery.tsx'\n:/* \nAll of the code in this component are copied and modified from:\nhttps://github.com/neptunian/react-photo-gallery\n*/\n\nimport { useLayoutEffect, useRef, useState } from \"react\";\nimport { computeRowLayout } from \"./Utils/compute-layout\";\nimport { findIdealNodeSearch } from \"./Utils/findIdealNodeSearch\";\nimport { PhotoProvider, PhotoView } from \"react-photo-view\";\n\nexport interface IPhoto {\n  src: string;\n  width: number;\n  height: number;\n  alt: string;\n}\n\ninterface GalleryProps {\n  photos: IPhoto[];\n}\n\nconst Gallery = ({ photos }: GalleryProps) => {\n  const [containerWidth, setContainerWidth] = useState(0);\n  const galleryEl = useRef<HTMLDivElement | null>(null);\n\n  useLayoutEffect(() => {\n    let animationFrameID: number | null = null;\n    const observer = new ResizeObserver((entries) => {\n      // only do something if width changes\n      const newWidth = entries[0].contentRect.width;\n      if (containerWidth !== newWidth) {\n        // put in an animation frame to stop \"benign errors\" from\n        // ResizObserver https://stackoverflow.com/questions/49384120/resizeobserver-loop-limit-exceeded\n        animationFrameID = window.requestAnimationFrame(() => {\n          setContainerWidth(Math.floor(newWidth));\n        });\n      }\n    });\n\n    if (galleryEl.current) {\n      observer.observe(galleryEl.current);\n    }\n\n    return () => {\n      observer.disconnect();\n      if (animationFrameID) {\n        window.cancelAnimationFrame(animationFrameID);\n      }\n    };\n  });\n\n  if (!containerWidth) return <div ref={galleryEl}>&nbsp;</div>;\n\n  const width = containerWidth - 1;\n  const targetRowHeight = 300;\n  let limitNodeSearch = 2;\n  if (containerWidth >= 450) {\n    limitNodeSearch = findIdealNodeSearch({ containerWidth, targetRowHeight });\n  }\n  const thumbs: IPhoto[] = computeRowLayout({\n    containerWidth: width,\n    limitNodeSearch,\n    targetRowHeight,\n    margin: 2,\n    photos,\n  });\n\n  return (\n    <PhotoProvider>\n      <div ref={galleryEl} className=\"flex flex-wrap\">\n        {thumbs.map((thumb, index) => {\n          return (\n            <PhotoView key={index} src={thumb.src}>\n              <img\n                key={index}\n                src={thumb.src}\n                alt={thumb.alt}\n                width={thumb.width}\n                height={thumb.height}\n                className=\"m-0.5 cursor-pointer\"\n              />\n            </PhotoView>\n          );\n        })}\n      </div>\n    </PhotoProvider>\n  );\n};\n\nexport default Gallery;\n\n'amifauzi.com-open/app/components/Gallery/Utils/compute-layout.ts'\n:import type { IPhoto } from \"../Gallery\";\nimport { findShortestPath } from \"./dijkstra\";\nimport type { TGraphFunc, TNode } from \"./dijkstra\";\nimport { round } from \"./round\";\n\n// return two decimal places rounded number\nexport const ratio = ({ width, height }: IPhoto) => round(width / height, 2);\n\n// compute sizes by creating a graph with rows as edges and photo to break on as nodes\n// to calculate the single best layout using Dijkstra's findShortestPat\n\n// get the height for a set of photos in a potential row\nconst getCommonHeight = (\n  row: IPhoto[],\n  containerWidth: number,\n  margin: number\n) => {\n  const rowWidth = containerWidth - row.length * (margin * 2);\n  const totalAspectRatio = row.reduce((acc, photo) => acc + ratio(photo), 0);\n  return rowWidth / totalAspectRatio;\n};\n\n// calculate the cost of breaking at this node (edge weight)\nconst cost = (\n  photos: IPhoto[],\n  i: number,\n  j: number,\n  width: number,\n  targetHeight: number,\n  margin: number\n) => {\n  const row = photos.slice(i, j);\n  const commonHeight = getCommonHeight(row, width, margin);\n  return Math.pow(Math.abs(commonHeight - targetHeight), 2);\n};\n\n// return function that gets the neighboring nodes of node and returns costs\nconst makeGetNeighbors =\n  (\n    targetHeight: number,\n    containerWidth: number,\n    photos: IPhoto[],\n    limitNodeSearch: number,\n    margin: number\n  ): TGraphFunc =>\n  (start) => {\n    const results: TNode = {};\n    start = +start;\n    results[+start] = 0;\n    for (let i = start + 1; i < photos.length + 1; ++i) {\n      if (i - start > limitNodeSearch) break;\n      results[i] = cost(photos, start, i, containerWidth, targetHeight, margin);\n    }\n    return results;\n  };\n\ninterface IComputeRowLayiutArg {\n  containerWidth: number;\n  limitNodeSearch: number;\n  targetRowHeight: number;\n  margin: number;\n  photos: IPhoto[];\n}\n\nexport const computeRowLayout = ({\n  containerWidth,\n  limitNodeSearch,\n  targetRowHeight,\n  margin,\n  photos,\n}: IComputeRowLayiutArg) => {\n  const getNeighbors = makeGetNeighbors(\n    targetRowHeight,\n    containerWidth,\n    photos,\n    limitNodeSearch,\n    margin\n  );\n  let path = findShortestPath(getNeighbors, 0, photos.length);\n  path = path.map((node) => +node);\n  for (let i = 1; i < path.length; ++i) {\n    const row = photos.slice(path[i - 1], path[i]);\n    const height = getCommonHeight(row, containerWidth, margin);\n    for (let j = path[i - 1]; j < path[i]; ++j) {\n      photos[j].width = round(height * ratio(photos[j]), 1);\n      photos[j].height = height;\n    }\n  }\n  return photos;\n};\n\n",
        "called_code_segment_file_1": "export const round = (value: number, decimals = 0) => {\n  return Number(Math.round(Number(`${value}e${decimals}`)) + \"e-\" + decimals);\n};",
        "invoking_code_segment_file_2": "import { round } from \"./round\";\n\n// guesstimate how many neighboring nodes should be searched based on\n// the aspect ratio of the container with images having an avg AR of 1.5\n// as the minimum amount of photos per row, plus some nodes\nexport const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  return round(rowAR / 1.5) + 8;\n};",
        "called_code_segment_file_2": "export const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  return round(rowAR / 1.5) + 8;\n};",
        "using_code_segment_file_3": "import { findIdealNodeSearch } from \"./findIdealNodeSearch\";\n\nif (containerWidth >= 450) {\n  limitNodeSearch = findIdealNodeSearch({ containerWidth, targetRowHeight });\n}",
        "called_code_segment_file_3": "export const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  return round(rowAR / 1.5) + 8;\n};",
        "using_code_segment_file_4": "// No relevant segment in #file 4",
        "feature_description": "Add a feature to adjust the rounding precision based on the container width.",
        "detailed_feature_description": "Modify the `round` function in #file 1 to accept an additional parameter for rounding precision. Update the `findIdealNodeSearch` function in #file 2 to pass the new parameter based on the container width. Ensure that #file 3 correctly handles the updated `findIdealNodeSearch` function. No changes are required in #file 4 as it does not interact with the modified segments.",
        "modified_complete_code": {
            "file_1": "//Modify\nexport const round = (value: number, decimals = 0, precision = 2) => {\n  return Number(Math.round(Number(`${value}e${decimals}`)) + \"e-\" + precision);\n};",
            "file_2": "import { round } from \"./round\";\n\n//Modify\nexport const findIdealNodeSearch = ({\n  targetRowHeight,\n  containerWidth,\n}: IFindIdealNodeSearchArg) => {\n  const rowAR = containerWidth / targetRowHeight;\n  const precision = containerWidth >= 600 ? 3 : 2;\n  return round(rowAR / 1.5, 0, precision) + 8;\n};",
            "file_3": "import { findIdealNodeSearch } from \"./findIdealNodeSearch\";\n\n//Modify\nif (containerWidth >= 450) {\n  limitNodeSearch = findIdealNodeSearch({ containerWidth, targetRowHeight });\n}",
            "file_4": "// No changes required"
        }
    },
    {
        "repo": "among-us-stats",
        "content": "'among-us-stats/src/utils/mathUtils.ts'\n:export function percentIt(number: number): string {\n  if (number < 0) return 'n/a';\n  return `${Math.round(number * 100)}%`;\n}\n\n'among-us-stats/src/components/shared/PlayerStatsItem.tsx'\n:import { makeStyles } from '@material-ui/core/styles';\nimport Grid from '@material-ui/core/Grid';\nimport { Avatar, Box, Typography } from '@material-ui/core';\nimport React, { memo } from 'react';\nimport Divider from '@material-ui/core/Divider';\nimport Tooltip from '@material-ui/core/Tooltip/Tooltip';\nimport { WarningOutlined } from '@material-ui/icons';\n\nimport { textOverflow } from '../../utils/stringUtils';\nimport { percentIt } from '../../utils/mathUtils';\nimport { EnhancedPlayer } from '../../store/stats/statsRedux';\n\nimport CrewAvatar from './avatar/CrewAvatar';\n\nconst useStyles = makeStyles({\n  subtitle: {\n    display: 'inline-flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n});\n\ninterface Props {\n  player: EnhancedPlayer;\n  placement: number;\n}\n\nfunction PlayerStatsItem({ player, placement }: Props): JSX.Element {\n  const classes = useStyles();\n\n  return (\n    <Grid container item xs={12} md={6}>\n      <Grid item xs={2}>\n        <Box height=\"100%\" display=\"flex\" justifyContent=\"center\" alignItems=\"center\" mr={1}>\n          <Avatar>{ordinalSuffix(placement)}</Avatar>\n        </Box>\n      </Grid>\n      <Grid container item xs={10}>\n        <Grid item xs={12}>\n          <Typography variant=\"subtitle1\">\n            <Box display=\"inline-flex\" alignItems=\"center\">\n              {player.name === 'Unknown player' && (\n                <Tooltip title=\"Some data has been corrupted, please send a bug report!\">\n                  <WarningOutlined color=\"secondary\" />\n                </Tooltip>\n              )}\n            </Box>{' '}\n            {textOverflow(player.name, 10)},{' '}\n            <Box display=\"inline\" fontWeight=\"bold\">\n              {percentIt(player.winRates.total)}\n            </Box>{' '}\n            of games won\n          </Typography>\n        </Grid>\n        <Grid item xs={8}>\n          <Tooltip title=\"Win rate as specific role\">\n            <Typography variant=\"subtitle2\" className={classes.subtitle}>\n              <CrewAvatar type=\"impostor\" inline />\n              {percentIt(player.winRates.impostor)}\n              <CrewAvatar type=\"crew\" inline />\n              {percentIt(player.winRates.crew)}\n            </Typography>\n          </Tooltip>\n        </Grid>\n        <Grid item xs={4}>\n          <Tooltip title=\"Percent of rounds player was impostor\">\n            <Typography variant=\"caption\">{percentIt(player.impostorRate)} impostor</Typography>\n          </Tooltip>\n        </Grid>\n      </Grid>\n      <Grid item xs={12}>\n        <Box mt={0.5}>\n          <Divider />\n        </Box>\n      </Grid>\n    </Grid>\n  );\n}\n\nfunction ordinalSuffix(i: number): string {\n  const j = i % 10;\n  const k = i % 100;\n\n  if (j == 1 && k != 11) {\n    return i + 'st';\n  } else if (j == 2 && k != 12) {\n    return i + 'nd';\n  } else if (j == 3 && k != 13) {\n    return i + 'rd';\n  }\n  return i + 'th';\n}\n\nexport default memo(PlayerStatsItem);\n\n'among-us-stats/src/components/shared/SummaryCard.tsx'\n:import React, { useRef, Suspense } from 'react';\nimport GamepadIcon from '@material-ui/icons/Gamepad';\nimport Paper from '@material-ui/core/Paper';\nimport WarningIcon from '@material-ui/icons/Warning';\nimport Grid from '@material-ui/core/Grid';\nimport { makeStyles } from '@material-ui/core/styles';\nimport Box from '@material-ui/core/Box';\nimport Typography from '@material-ui/core/Typography';\nimport Tooltip from '@material-ui/core/Tooltip';\nimport { useSelector } from 'react-redux';\n\nimport { EnhancedPlayer, Session } from '../../store/stats/statsRedux';\nimport { formatDistanceToNow, parseIso } from '../../utils/dateUtils';\nimport { RootState } from '../../store/redux';\n\nimport PlayerStatsItem from './PlayerStatsItem';\nimport IconInfoText from './IconInfoText';\nimport Scoreboard from './Scoreboard';\nimport EditableTitle from './EditableTitle';\n\nconst LazyDiscordShareButton = React.lazy(() => import('./DiscordShareButton'));\n\nconst useStyles = makeStyles((theme) => ({\n  rootBox: {\n    position: 'relative',\n  },\n  gamepadIcon: {\n    marginRight: theme.spacing(1),\n  },\n  autoPad: {\n    flex: '1 1 auto',\n  },\n  optionalActions: {\n    marginRight: theme.spacing(2),\n    '& > button': {\n      marginLeft: theme.spacing(2),\n    },\n  },\n  shareButtonPlaceholder: {\n    minWidth: theme.spacing(12),\n  },\n  gamesPlayed: {\n    position: 'absolute',\n    bottom: 0,\n    left: 0,\n  },\n  timestamp: {\n    position: 'absolute',\n    bottom: 0,\n    right: 0,\n  },\n}));\n\ninterface Props {\n  session: Session<EnhancedPlayer>;\n  extraActions?: JSX.Element | JSX.Element[];\n  noTimestamp?: boolean;\n}\n\nfunction SummaryCard({ session, extraActions, noTimestamp = false }: Props): JSX.Element {\n  const classes = useStyles();\n  const summaryCardRef = useRef<HTMLDivElement>(null);\n  const settings = useSelector((state: RootState) => state.settings);\n  const showDiscordShareButton = settings.discordShareWebhook && !extraActions;\n\n  const playersByWinRate = [...session.players].sort((a, b) => b.winRates.total - a.winRates.total);\n  const unfinishedGames = session.games.filter((it) => it.winner == null).length;\n\n  return (\n    <div>\n      <div ref={summaryCardRef}>\n        <Box className={classes.rootBox}>\n          <Box pt={1} pl={2} display=\"flex\" alignItems=\"center\">\n            <GamepadIcon className={classes.gamepadIcon} />\n            <EditableTitle session={session} />\n            <Box className={classes.autoPad} />\n            <Box className={classes.optionalActions}>{extraActions}</Box>\n            {showDiscordShareButton && <Box className={classes.shareButtonPlaceholder} />}\n          </Box>\n          {unfinishedGames > 0 && (\n            <Box m={2}>\n              <Paper elevation={6} variant=\"outlined\">\n                <Box>\n                  <IconInfoText\n                    text={`There are ${unfinishedGames} unfinished games. Statistics will be incomplete.`}\n                    icon={<WarningIcon />}\n                    opacity={1}\n                  />\n                </Box>\n              </Paper>\n            </Box>\n          )}\n          <Box m={1}>\n            <Grid container spacing={1}>\n              {playersByWinRate.map((it, index) => (\n                <PlayerStatsItem key={it.playerId} player={it} placement={index + 1} />\n              ))}\n            </Grid>\n          </Box>\n          <Box display=\"flex\" justifyContent=\"center\" pb={4}>\n            <Scoreboard session={session} />\n          </Box>\n          <Box m={2} className={classes.gamesPlayed}>\n            <Typography variant=\"subtitle2\">{session.games.length} games played</Typography>\n          </Box>\n          {!noTimestamp && (\n            <Box m={2} className={classes.timestamp}>\n              <Tooltip interactive title={session.lastGamePlayed}>\n                <Typography variant=\"subtitle2\">{formatDistanceToNow(parseIso(session.lastGamePlayed))} ago</Typography>\n              </Tooltip>\n            </Box>\n          )}\n        </Box>\n      </div>\n      <Suspense fallback={null}>\n        {showDiscordShareButton && <LazyDiscordShareButton shareBoxRef={summaryCardRef} />}\n      </Suspense>\n    </div>\n  );\n}\n\nexport default SummaryCard;\n\n'among-us-stats/src/components/shared/SummaryCard.test.tsx'\n:import userEvent from '@testing-library/user-event';\nimport React from 'react';\n\nimport { providerRender, screen, waitFor } from '../../test/testUtils';\nimport { initialStatsState } from '../../store/stats/statsRedux';\nimport { testPlayers } from '../../test/testData';\n\nimport SummaryCard from './SummaryCard';\n\ndescribe('SummaryCard', () => {\n  it('clicking the title should enable user to edit session name', () => {\n    const testSession = {\n      sessionId: 'test-session',\n      name: 'My test session',\n      games: [],\n      players: [],\n      lastGamePlayed: new Date().toISOString(),\n    };\n    const [, store] = providerRender(<SummaryCard session={testSession} />, {\n      initialState: {\n        stats: {\n          ...initialStatsState,\n          players: testPlayers,\n          session: testSession,\n          previousSessions: [],\n        },\n      },\n    });\n\n    userEvent.click(screen.getByRole('heading', { name: 'My test session' }));\n    userEvent.type(screen.getByTestId('edit-session-name'), 'My new session name');\n    userEvent.tab();\n\n    waitFor(() => expect(store.getState().stats.session.name).toEqual('My new session name'));\n    expect(screen.queryByRole('edit-session-name')).not.toBeInTheDocument();\n  });\n});\n\n",
        "called_code_segment_file_1": "function percentIt(number: number): string {\n  if (number < 0) return 'n/a';\n  return `${Math.round(number * 100)}%`;\n}",
        "invoking_code_segment_file_2": "function PlayerStatsItem({ player, placement }: Props): JSX.Element {\n  const classes = useStyles();\n\n  return (\n    <Grid container item xs={12} md={6}>\n      <Grid item xs={2}>\n        <Box height=\"100%\" display=\"flex\" justifyContent=\"center\" alignItems=\"center\" mr={1}>\n          <Avatar>{ordinalSuffix(placement)}</Avatar>\n        </Box>\n      </Grid>\n      <Grid container item xs={10}>\n        <Grid item xs={12}>\n          <Typography variant=\"subtitle1\">\n            <Box display=\"inline-flex\" alignItems=\"center\">\n              {player.name === 'Unknown player' && (\n                <Tooltip title=\"Some data has been corrupted, please send a bug report!\">\n                  <WarningOutlined color=\"secondary\" />\n                </Tooltip>\n              )}\n            </Box>{' '}\n            {textOverflow(player.name, 10)},{' '}\n            <Box display=\"inline\" fontWeight=\"bold\">\n              {percentIt(player.winRates.total)}\n            </Box>{' '}\n            of games won\n          </Typography>\n        </Grid>\n        <Grid item xs={8}>\n          <Tooltip title=\"Win rate as specific role\">\n            <Typography variant=\"subtitle2\" className={classes.subtitle}>\n              <CrewAvatar type=\"impostor\" inline />\n              {percentIt(player.winRates.impostor)}\n              <CrewAvatar type=\"crew\" inline />\n              {percentIt(player.winRates.crew)}\n            </Typography>\n          </Tooltip>\n        </Grid>\n        <Grid item xs={4}>\n          <Tooltip title=\"Percent of rounds player was impostor\">\n            <Typography variant=\"caption\">{percentIt(player.impostorRate)} impostor</Typography>\n          </Tooltip>\n        </Grid>\n      </Grid>\n      <Grid item xs={12}>\n        <Box mt={0.5}>\n          <Divider />\n        </Box>\n      </Grid>\n    </Grid>\n  );\n}",
        "called_code_segment_file_2": "function PlayerStatsItem({ player, placement }: Props): JSX.Element {\n  const classes = useStyles();\n\n  return (\n    <Grid container item xs={12} md={6}>\n      <Grid item xs={2}>\n        <Box height=\"100%\" display=\"flex\" justifyContent=\"center\" alignItems=\"center\" mr={1}>\n          <Avatar>{ordinalSuffix(placement)}</Avatar>\n        </Box>\n      </Grid>\n      <Grid container item xs={10}>\n        <Grid item xs={12}>\n          <Typography variant=\"subtitle1\">\n            <Box display=\"inline-flex\" alignItems=\"center\">\n              {player.name === 'Unknown player' && (\n                <Tooltip title=\"Some data has been corrupted, please send a bug report!\">\n                  <WarningOutlined color=\"secondary\" />\n                </Tooltip>\n              )}\n            </Box>{' '}\n            {textOverflow(player.name, 10)},{' '}\n            <Box display=\"inline\" fontWeight=\"bold\">\n              {percentIt(player.winRates.total)}\n            </Box>{' '}\n            of games won\n          </Typography>\n        </Grid>\n        <Grid item xs={8}>\n          <Tooltip title=\"Win rate as specific role\">\n            <Typography variant=\"subtitle2\" className={classes.subtitle}>\n              <CrewAvatar type=\"impostor\" inline />\n              {percentIt(player.winRates.impostor)}\n              <CrewAvatar type=\"crew\" inline />\n              {percentIt(player.winRates.crew)}\n            </Typography>\n          </Tooltip>\n        </Grid>\n        <Grid item xs={4}>\n          <Tooltip title=\"Percent of rounds player was impostor\">\n            <Typography variant=\"caption\">{percentIt(player.impostorRate)} impostor</Typography>\n          </Tooltip>\n        </Grid>\n      </Grid>\n      <Grid item xs={12}>\n        <Box mt={0.5}>\n          <Divider />\n        </Box>\n      </Grid>\n    </Grid>\n  );\n}",
        "using_code_segment_file_3": "function SummaryCard({ session, extraActions, noTimestamp = false }: Props): JSX.Element {\n  const classes = useStyles();\n  const summaryCardRef = useRef<HTMLDivElement>(null);\n  const settings = useSelector((state: RootState) => state.settings);\n  const showDiscordShareButton = settings.discordShareWebhook && !extraActions;\n\n  const playersByWinRate = [...session.players].sort((a, b) => b.winRates.total - a.winRates.total);\n  const unfinishedGames = session.games.filter((it) => it.winner == null).length;\n\n  return (\n    <div>\n      <div ref={summaryCardRef}>\n        <Box className={classes.rootBox}>\n          <Box pt={1} pl={2} display=\"flex\" alignItems=\"center\">\n            <GamepadIcon className={classes.gamepadIcon} />\n            <EditableTitle session={session} />\n            <Box className={classes.autoPad} />\n            <Box className={classes.optionalActions}>{extraActions}</Box>\n            {showDiscordShareButton && <Box className={classes.shareButtonPlaceholder} />}\n          </Box>\n          {unfinishedGames > 0 && (\n            <Box m={2}>\n              <Paper elevation={6} variant=\"outlined\">\n                <Box>\n                  <IconInfoText\n                    text={`There are ${unfinishedGames} unfinished games. Statistics will be incomplete.`}\n                    icon={<WarningIcon />}\n                    opacity={1}\n                  />\n                </Box>\n              </Paper>\n            </Box>\n          )}\n          <Box m={1}>\n            <Grid container spacing={1}>\n              {playersByWinRate.map((it, index) => (\n                <PlayerStatsItem key={it.playerId} player={it} placement={index + 1} />\n              ))}\n            </Grid>\n          </Box>\n          <Box display=\"flex\" justifyContent=\"center\" pb={4}>\n            <Scoreboard session={session} />\n          </Box>\n          <Box m={2} className={classes.gamesPlayed}>\n            <Typography variant=\"subtitle2\">{session.games.length} games played</Typography>\n          </Box>\n          {!noTimestamp && (\n            <Box m={2} className={classes.timestamp}>\n              <Tooltip interactive title={session.lastGamePlayed}>\n                <Typography variant=\"subtitle2\">{formatDistanceToNow(parseIso(session.lastGamePlayed))} ago</Typography>\n              </Tooltip>\n            </Box>\n          )}\n        </Box>\n      </div>\n      <Suspense fallback={null}>\n        {showDiscordShareButton && <LazyDiscordShareButton shareBoxRef={summaryCardRef} />}\n      </Suspense>\n    </div>\n  );\n}",
        "called_code_segment_file_3": "",
        "using_code_segment_file_4": "",
        "feature_description": "Add a feature to display the win rate with a precision of two decimal places instead of rounding to the nearest integer.",
        "detailed_feature_description": "The `percentIt` function in #file 1 will be modified to return the win rate with two decimal places. This change will affect the `PlayerStatsItem` component in #file 2, which will then display the win rate with the new precision. The `SummaryCard` component in #file 3 will continue to use the `PlayerStatsItem` component, ensuring that the updated win rate display is propagated throughout the application. No changes are required in #file 4 as it does not interact with the updated segments.",
        "modified_complete_code": {
            "file_1": "//Modify\nfunction percentIt(number: number): string {\n  if (number < 0) return 'n/a';\n  return `${(number * 100).toFixed(2)}%`;\n}",
            "file_2": "//Modify\nfunction PlayerStatsItem({ player, placement }: Props): JSX.Element {\n  const classes = useStyles();\n\n  return (\n    <Grid container item xs={12} md={6}>\n      <Grid item xs={2}>\n        <Box height=\"100%\" display=\"flex\" justifyContent=\"center\" alignItems=\"center\" mr={1}>\n          <Avatar>{ordinalSuffix(placement)}</Avatar>\n        </Box>\n      </Grid>\n      <Grid container item xs={10}>\n        <Grid item xs={12}>\n          <Typography variant=\"subtitle1\">\n            <Box display=\"inline-flex\" alignItems=\"center\">\n              {player.name === 'Unknown player' && (\n                <Tooltip title=\"Some data has been corrupted, please send a bug report!\">\n                  <WarningOutlined color=\"secondary\" />\n                </Tooltip>\n              )}\n            </Box>{' '}\n            {textOverflow(player.name, 10)},{' '}\n            <Box display=\"inline\" fontWeight=\"bold\">\n              {percentIt(player.winRates.total)}\n            </Box>{' '}\n            of games won\n          </Typography>\n        </Grid>\n        <Grid item xs={8}>\n          <Tooltip title=\"Win rate as specific role\">\n            <Typography variant=\"subtitle2\" className={classes.subtitle}>\n              <CrewAvatar type=\"impostor\" inline />\n              {percentIt(player.winRates.impostor)}\n              <CrewAvatar type=\"crew\" inline />\n              {percentIt(player.winRates.crew)}\n            </Typography>\n          </Tooltip>\n        </Grid>\n        <Grid item xs={4}>\n          <Tooltip title=\"Percent of rounds player was impostor\">\n            <Typography variant=\"caption\">{percentIt(player.impostorRate)} impostor</Typography>\n          </Tooltip>\n        </Grid>\n      </Grid>\n      <Grid item xs={12}>\n        <Box mt={0.5}>\n          <Divider />\n        </Box>\n      </Grid>\n    </Grid>\n  );\n}",
            "file_3": "//Modify\nfunction SummaryCard({ session, extraActions, noTimestamp = false }: Props): JSX.Element {\n  const classes = useStyles();\n  const summaryCardRef = useRef<HTMLDivElement>(null);\n  const settings = useSelector((state: RootState) => state.settings);\n  const showDiscordShareButton = settings.discordShareWebhook && !extraActions;\n\n  const playersByWinRate = [...session.players].sort((a, b) => b.winRates.total - a.winRates.total);\n  const unfinishedGames = session.games.filter((it) => it.winner == null).length;\n\n  return (\n    <div>\n      <div ref={summaryCardRef}>\n        <Box className={classes.rootBox}>\n          <Box pt={1} pl={2} display=\"flex\" alignItems=\"center\">\n            <GamepadIcon className={classes.gamepadIcon} />\n            <EditableTitle session={session} />\n            <Box className={classes.autoPad} />\n            <Box className={classes.optionalActions}>{extraActions}</Box>\n            {showDiscordShareButton && <Box className={classes.shareButtonPlaceholder} />}\n          </Box>\n          {unfinishedGames > 0 && (\n            <Box m={2}>\n              <Paper elevation={6} variant=\"outlined\">\n                <Box>\n                  <IconInfoText\n                    text={`There are ${unfinishedGames} unfinished games. Statistics will be incomplete.`}\n                    icon={<WarningIcon />}\n                    opacity={1}\n                  />\n                </Box>\n              </Paper>\n            </Box>\n          )}\n          <Box m={1}>\n            <Grid container spacing={1}>\n              {playersByWinRate.map((it, index) => (\n                <PlayerStatsItem key={it.playerId} player={it} placement={index + 1} />\n              ))}\n            </Grid>\n          </Box>\n          <Box display=\"flex\" justifyContent=\"center\" pb={4}>\n            <Scoreboard session={session} />\n          </Box>\n          <Box m={2} className={classes.gamesPlayed}>\n            <Typography variant=\"subtitle2\">{session.games.length} games played</Typography>\n          </Box>\n          {!noTimestamp && (\n            <Box m={2} className={classes.timestamp}>\n              <Tooltip interactive title={session.lastGamePlayed}>\n                <Typography variant=\"subtitle2\">{formatDistanceToNow(parseIso(session.lastGamePlayed))} ago</Typography>\n              </Tooltip>\n            </Box>\n          )}\n        </Box>\n      </div>\n      <Suspense fallback={null}>\n        {showDiscordShareButton && <LazyDiscordShareButton shareBoxRef={summaryCardRef} />}\n      </Suspense>\n    </div>\n  );\n}",
            "file_4": ""
        }
    },
    {
        "repo": "appstart",
        "content": "'appstart/app/component/dashboard.component.ts'\n:import { Component, OnInit } from '@angular/core';\n\nimport { Hero } from '../class/hero';\nimport { HeroService } from '../service/hero.service';\n\n@Component ({\n  moduleId: module.id,\n  selector: 'my-dashboard',\n  templateUrl: './assets/html/dashboard.component.html',\n  styleUrls: [ './assets/css/dashboard.component.css' ]\n})\nexport class DashboardComponent implements OnInit {\n  heroes: Hero[] = [];\n\n  constructor(private heroService: HeroService) { }\n\n  ngOnInit(): void {\n    this.heroService.getHeroes()\n      .then(heroes => this.heroes = heroes.slice(1, 5));\n  }\n}\n\n'appstart/app/module/app-routing.module.ts'\n:import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nimport { DashboardComponent } from '../component/dashboard.component';\nimport { HeroesComponent } from '../component/heroes.component';\nimport { HeroDetailComponent } from '../component/hero-detail.component';\n\nconst routes: Routes = [\n  { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n  { path: 'dashboard', component: DashboardComponent },\n  { path: 'detail/:id', component: HeroDetailComponent },\n  { path: 'heroes', component: HeroesComponent }\n]\n\n@NgModule ({\n  imports: [ RouterModule.forRoot(routes)],\n  exports: [ RouterModule ]\n})\nexport class AppRoutingModule {}\n\n'appstart/app/module/app.module.ts'\n:import '../class/rxjs-extensions';\n\nimport { NgModule }      from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { FormsModule }   from '@angular/forms';\nimport { HttpModule }    from '@angular/http';\n\n\nimport { AppComponent }   from '../component/app.component';\nimport { DashboardComponent } from '../component/dashboard.component';\nimport { HeroDetailComponent } from '../component/hero-detail.component';\nimport { HeroesComponent } from '../component/heroes.component';\nimport { HeroService } from '../service/hero.service';\nimport { HeroSearchComponent }  from '../component/hero-search.component';\n\nimport { AppRoutingModule }     from '../module/app-routing.module';\n\nimport { InMemoryWebApiModule } from 'angular-in-memory-web-api';\nimport { InMemoryDataService } from '../service/in-memory-data.service';\n\n@NgModule({\n  imports:      [\n    BrowserModule,\n    FormsModule,\n    HttpModule,\n    AppRoutingModule,\n    InMemoryWebApiModule.forRoot(InMemoryDataService)\n  ],\n  declarations: [\n    AppComponent,\n    DashboardComponent,\n    HeroDetailComponent,\n    HeroesComponent,\n    HeroSearchComponent\n  ],\n  providers: [\n    HeroService\n  ],\n  bootstrap: [\n    AppComponent\n  ]\n})\nexport class AppModule { }\n\n'appstart/app/main.ts'\n:import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\nimport { AppModule } from './module/app.module';\n\nconst platform = platformBrowserDynamic();\nplatform.bootstrapModule(AppModule);\n\n",
        "called_code_segment_file_1": "ngOnInit(): void {\n    this.heroService.getHeroes()\n      .then(heroes => this.heroes = heroes.slice(1, 5));\n  }",
        "invoking_code_segment_file_2": "constructor(private heroService: HeroService) { }",
        "called_code_segment_file_2": "getHeroes(): Promise<Hero[]> {\n    return this.http.get(this.heroesUrl)\n               .toPromise()\n               .then(response => response.json().data as Hero[])\n               .catch(this.handleError);\n  }",
        "using_code_segment_file_3": "import { HeroService } from '../service/hero.service';",
        "called_code_segment_file_3": "Not applicable",
        "using_code_segment_file_4": "Not applicable",
        "feature_description": "Add a new feature to log the number of heroes fetched from the server.",
        "detailed_feature_description": "Modify the `getHeroes` method in `HeroService` to log the number of heroes fetched. Update the `DashboardComponent` to handle the modified `getHeroes` method. Since `HeroService` is directly used by `DashboardComponent`, no further changes are required in other files.",
        "modified_complete_code": {
            "appstart/app/component/dashboard.component.ts": "import { Component, OnInit } from '@angular/core';\n\nimport { Hero } from '../class/hero';\nimport { HeroService } from '../service/hero.service';\n\n@Component ({\n  moduleId: module.id,\n  selector: 'my-dashboard',\n  templateUrl: './assets/html/dashboard.component.html',\n  styleUrls: [ './assets/css/dashboard.component.css' ]\n})\nexport class DashboardComponent implements OnInit {\n  heroes: Hero[] = [];\n\n  constructor(private heroService: HeroService) { }\n\n  ngOnInit(): void {\n    this.heroService.getHeroes()\n      .then(heroes => this.heroes = heroes.slice(1, 5));\n  }\n}",
            "appstart/app/service/hero.service.ts": "import { Injectable } from '@angular/core';\nimport { Headers, Http } from '@angular/http';\n\nimport 'rxjs/add/operator/toPromise';\n\nimport { Hero } from '../class/hero';\n\n@Injectable()\nexport class HeroService {\n  private heroesUrl = 'api/heroes';  // URL to web api\n\n  constructor(private http: Http) { }\n\n  getHeroes(): Promise<Hero[]> {\n    return this.http.get(this.heroesUrl)\n               .toPromise()\n               .then(response => {\n                 const heroes = response.json().data as Hero[];\n                 console.log(`Fetched ${heroes.length} heroes`);\n                 return heroes;\n               })\n               .catch(this.handleError);\n  }\n\n  private handleError(error: any): Promise<any> {\n    console.error('An error occurred', error); // for demo purposes only\n    return Promise.reject(error.message || error);\n  }\n}",
            "appstart/app/module/app-routing.module.ts": "import { NgModule } from '@angular/core';\nimport { RouterModule, Routes } from '@angular/router';\n\nimport { DashboardComponent } from '../component/dashboard.component';\nimport { HeroesComponent } from '../component/heroes.component';\nimport { HeroDetailComponent } from '../component/hero-detail.component';\n\nconst routes: Routes = [\n  { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n  { path: 'dashboard', component: DashboardComponent },\n  { path: 'detail/:id', component: HeroDetailComponent },\n  { path: 'heroes', component: HeroesComponent }\n]\n\n@NgModule ({\n  imports: [ RouterModule.forRoot(routes)],\n  exports: [ RouterModule ]\n})\nexport class AppRoutingModule {}",
            "appstart/app/module/app.module.ts": "import '../class/rxjs-extensions';\n\nimport { NgModule }      from '@angular/core';\nimport { BrowserModule } from '@angular/platform-browser';\nimport { FormsModule }   from '@angular/forms';\nimport { HttpModule }    from '@angular/http';\n\nimport { AppComponent }   from '../component/app.component';\nimport { DashboardComponent } from '../component/dashboard.component';\nimport { HeroDetailComponent } from '../component/hero-detail.component';\nimport { HeroesComponent } from '../component/heroes.component';\nimport { HeroService } from '../service/hero.service';\nimport { HeroSearchComponent }  from '../component/hero-search.component';\n\nimport { AppRoutingModule }     from '../module/app-routing.module';\n\nimport { InMemoryWebApiModule } from 'angular-in-memory-web-api';\nimport { InMemoryDataService } from '../service/in-memory-data.service';\n\n@NgModule({\n  imports:      [\n    BrowserModule,\n    FormsModule,\n    HttpModule,\n    AppRoutingModule,\n    InMemoryWebApiModule.forRoot(InMemoryDataService)\n  ],\n  declarations: [\n    AppComponent,\n    DashboardComponent,\n    HeroDetailComponent,\n    HeroesComponent,\n    HeroSearchComponent\n  ],\n  providers: [\n    HeroService\n  ],\n  bootstrap: [\n    AppComponent\n  ]\n})\nexport class AppModule { }"
        }
    },
    {
        "repo": "RecipeApp",
        "content": "'RecipeApp/src/app/shopping-list/shopping-list.service.ts'\n:import { Ingredient } from '../shared/ingredient.model';\nimport { Subject } from 'rxjs/Subject';\n\nexport class ShoppingListService {\n    ingredientsChanged = new Subject<Ingredient[]>();\n    startedEditing = new Subject<number>();\n\n    private ingredients: Ingredient[] = [\n        new Ingredient('Apples', 5),\n        new Ingredient('Tomatoes', 10)\n    ];\n\n    getIngredients() {\n        return this.ingredients.slice();\n    }\n\n    getIngredient(index: number) {\n        return this.ingredients[index];\n    }\n\n    updateIngredient(index: number, newIngredient: Ingredient) {\n        this.ingredients[index] = newIngredient;\n        this.ingredientsChanged.next(this.ingredients.slice());\n    }\n\n    addIngredient(ingredient: Ingredient) {\n        this.ingredients.push(ingredient);\n        this.ingredientsChanged.next(this.ingredients.slice());\n    }\n\n    addIngredients(ingredients: Ingredient[]) {\n        this.ingredients.push(...ingredients);\n        this.ingredientsChanged.next(this.ingredients.slice());\n    }\n\n    deleteIngredient(index: number) {\n        this.ingredients.splice(index, 1);\n        this.ingredientsChanged.next(this.ingredients.slice());\n    }\n}\n'RecipeApp/src/app/recipes/recipe.service.ts'\n:import { Injectable } from '@angular/core';\nimport { Recipe } from './recipe.model';\nimport { Ingredient } from '../shared/ingredient.model';\nimport { ShoppingListService } from '../shopping-list/shopping-list.service';\nimport { Subject } from 'rxjs';\n\n@Injectable()\nexport class RecipeService {\n\n    recipesChanged = new Subject<Recipe[]>();\n    \n    private recipes: Recipe[] = [\n        new Recipe(\n            'Egg with meat', \n            'What else you want to say? Best protien combination.',\n            'http://saltandwind.com/media/_versions/recipes/150316_mashed-potato-pancakes-recipe_v_medium.jpg',\n             [\n                 new Ingredient('Egg',2),\n                 new Ingredient('Meat',1)\n             ]),\n        new Recipe(\n            'Inside Out French Toast Sandwich', \n            'Best breakfast recipe which is easy and fast to cook',\n            'https://img.taste.com.au/khB7s7_i/w643-h428-cfill-q90/taste/2017/04/strawberry-hazelnut-french-toast-sandwich_1980x1320-125523-1.jpg',\n            [\n                new Ingredient('Bread',2),\n                new Ingredient('Peanut Butter',1)\n            ])\n    ];\n\n    constructor(private slService: ShoppingListService) { }\n\n    setRecipes(recipes: Recipe[]) {\n        this.recipes = recipes;\n        this.recipesChanged.next(this.recipes.slice());\n    }\n\n    getRecipes() {\n        return this.recipes.slice();\n    }\n\n    getRecipe(index: number) {\n        return this.recipes[index];\n    }\n\n    addIngredietsToShoppingList(ingredients: Ingredient[]) {\n        this.slService.addIngredients(ingredients);\n    }\n\n    addRecipe(recipe: Recipe) {\n        this.recipes.push(recipe);\n        this.recipesChanged.next(this.recipes.slice());\n    }\n\n    updateRecipe(index: number, newRecipe: Recipe) {\n        this.recipes[index] = newRecipe;\n        this.recipesChanged.next(this.recipes.slice());\n    }\n\n    deleteRecipe(index: number) {\n        this.recipes.splice(index, 1);\n        this.recipesChanged.next(this.recipes.slice());\n    }\n}\n'RecipeApp/src/app/recipes/recipe-detail/recipe-detail.component.ts'\n:import { Component, OnInit} from '@angular/core';\nimport { Recipe } from '../recipe.model';\nimport { RecipeService } from '../recipe.service';\nimport { ActivatedRoute, Params, Router } from '@angular/router';\nimport { AuthService } from '../../auth/auth.service';\n\n@Component({\n  selector: 'app-recipe-detail',\n  templateUrl: './recipe-detail.component.html',\n  styleUrls: ['./recipe-detail.component.css']\n})\nexport class RecipeDetailComponent implements OnInit {\n  recipe: Recipe;\n  id: number;\n  constructor(private recipeService: RecipeService,\n              private router: Router,\n              private route: ActivatedRoute,\n              private authService: AuthService) { }\n\n  ngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params['id'];\n          this.recipe = this.recipeService.getRecipe(this.id);\n        }\n      );\n  }\n\n  onEditRecipe() {\n    if (!this.authService.isAuthenticated()) {\n      alert(\"Please login to continue!\");\n    }\n    this.router.navigate(['edit'], { relativeTo: this.route });\n  }\n\n  onAddToShoppingList() {\n    this.recipeService.addIngredietsToShoppingList(this.recipe.ingredients);\n  }\n\n  onDeleteRecipe() {\n    if (this.authService.isAuthenticated()) {\n      this.recipeService.deleteRecipe(this.id);\n      this.router.navigate(['/recipes']);\n    }\n    else {        \n      alert(\"Please login to continue!\");\n    }\n  }\n}\n\n'RecipeApp/src/app/recipes/recipes.module.ts'\n:import { NgModule } from \"@angular/core\";\nimport { ReactiveFormsModule } from \"@angular/forms\";\nimport { CommonModule } from \"@angular/common\";\n\nimport { RecipesComponent } from \"./recipes.component\";\nimport { RecipeDetailComponent } from \"./recipe-detail/recipe-detail.component\";\nimport { RecipeItemComponent } from \"./recipe-item/recipe-item.component\";\nimport { RecipeListComponent } from \"./recipe-list/recipe-list.component\";\nimport { RecipeStartComponent } from \"./recipe-start/recipe-start.component\";\nimport { RecipeEditComponent } from \"./recipe-edit/recipe-edit.component\";\nimport { RecipesRoutingModule } from \"./recipes-routing.module\";\nimport { SharedModule } from \"../shared/shared.module\";\n\n@NgModule({\n    declarations: [\n        RecipesComponent,\n        RecipeDetailComponent,\n        RecipeItemComponent,\n        RecipeListComponent,\n        RecipeStartComponent,\n        RecipeEditComponent\n    ],\n    imports: [\n        ReactiveFormsModule,\n        CommonModule,\n        RecipesRoutingModule,\n        SharedModule\n    ]\n})\n\nexport class RecipesModule {}\n",
        "called_code_segment_file_1": "getRecipe(index: number) {\n        return this.recipes[index];\n    }",
        "invoking_code_segment_file_2": "ngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params['id'];\n          this.recipe = this.recipeService.getRecipe(this.id);\n        }\n      );\n  }",
        "called_code_segment_file_2": "addIngredietsToShoppingList(ingredients: Ingredient[]) {\n        this.slService.addIngredients(ingredients);\n    }",
        "using_code_segment_file_3": "onAddToShoppingList() {\n    this.recipeService.addIngredietsToShoppingList(this.recipe.ingredients);\n  }",
        "called_code_segment_file_3": "deleteIngredient(index: number) {\n        this.ingredients.splice(index, 1);\n        this.ingredientsChanged.next(this.ingredients.slice());\n    }",
        "using_code_segment_file_4": "deleteIngredient(index: number) {\n        this.slService.deleteIngredient(index);\n        this.router.navigate(['../'], { relativeTo: this.route });\n    }",
        "feature_description": "Add a feature to log the recipe details when a recipe is fetched.",
        "detailed_feature_description": "Modify the `getRecipe` method in `RecipeService` to log the recipe details to the console. Update the `RecipeDetailComponent` to handle any potential changes in the `getRecipe` method. Ensure the `ShoppingListService` and `ShoppingListComponent` are updated if they interact with the modified segments.",
        "modified_complete_code": {
            "RecipeService.ts": "getRecipe(index: number) {\n        const recipe = this.recipes[index];\n        console.log('Fetched Recipe:', recipe);\n        return recipe;\n    } #Modify",
            "RecipeDetailComponent.ts": "ngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params['id'];\n          this.recipe = this.recipeService.getRecipe(this.id);\n        }\n      );\n  }",
            "ShoppingListService.ts": "addIngredients(ingredients: Ingredient[]) {\n        this.ingredients.push(...ingredients);\n        this.ingredientsChanged.next(this.ingredients.slice());\n    }",
            "ShoppingListComponent.ts": "deleteIngredient(index: number) {\n        this.slService.deleteIngredient(index);\n        this.router.navigate(['../'], { relativeTo: this.route });\n    }"
        }
    },
    {
        "repo": "angular-the-complete-guide-2023",
        "content": "'angular-the-complete-guide-2023/making-http-requests/src/app/post.model.ts'\n:export interface Post {\n\n  title: string;\n\n  content: string;\n\n  id?: string;\n\n}\n\n\n'angular-the-complete-guide-2023/making-http-requests/src/app/app.component.ts'\n:import { Component, OnInit, OnDestroy } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\nimport { Post } from './post.model';\nimport { PostsService } from './posts.service';\n\nimport { Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css'],\n})\nexport class AppComponent implements OnInit, OnDestroy {\n  loadedPosts: Post[] = [];\n  isFetching: boolean = false;\n  error = null;\n  private errorSub: Subscription\n\n  constructor(\n    private http: HttpClient,\n    private postService: PostsService\n  ) { }\n\n  ngOnInit() {\n    this.onFetchPosts();\n  }\n\n  ngOnDestroy(): void {\n    this.errorSub.unsubscribe();\n  }\n\n  onCreatePost(postData: Post) {\n    // Send Http request\n    this.postService.createAndStorePost(postData.title, postData.content);\n  }\n\n  onFetchPosts() {\n    this.errorSub = this.postService.error\n      .subscribe(errorMessage => {\n        this.error = errorMessage;\n      });\n\n    this.isFetching = true;\n    this.postService.fetchPosts()\n      .subscribe(posts => {\n        this.isFetching = false;\n        this.loadedPosts = posts;\n      }, error => {\n        this.isFetching = false;\n        this.error = error.message;\n      });\n  }\n\n  onClearPosts() {\n    // Send Http request\n    this.postService.deletePosts()\n      .subscribe(() => {\n        this.loadedPosts = [];\n      });\n  }\n\n  onHandleError(): void {\n    this.error = null;\n  }\n}\n\n'angular-the-complete-guide-2023/making-http-requests/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { AuthInterceptorService } from './auth-interceptor.service';\nimport { LoggingInterceptorService } from './logging-interceptor.service';\n\n@NgModule({\n  declarations: [AppComponent],\n  imports: [BrowserModule, FormsModule, HttpClientModule],\n  providers: [\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: AuthInterceptorService,\n      multi: true\n    },\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: LoggingInterceptorService,\n      multi: true\n    }\n  ],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n\n'angular-the-complete-guide-2023/making-http-requests/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "onCreatePost(postData: Post) {\n    // Send Http request\n    this.postService.createAndStorePost(postData.title, postData.content);\n  }",
        "invoking_code_segment_file_2": "createAndStorePost(title: string, content: string) {\n    const postData: Post = { title: title, content: content };\n    this.http\n      .post<{ name: string }>(\n        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json',\n        postData\n      )\n      .subscribe(responseData => {\n        console.log(responseData);\n      });\n  }",
        "called_code_segment_file_2": "fetchPosts() {\n    return this.http\n      .get<{ [key: string]: Post }>(\n        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json'\n      )\n      .pipe(\n        map(responseData => {\n          const postsArray: Post[] = [];\n          for (const key in responseData) {\n            if (responseData.hasOwnProperty(key)) {\n              postsArray.push({ ...responseData[key], id: key });\n            }\n          }\n          return postsArray;\n        })\n      );\n  }",
        "using_code_segment_file_3": "onFetchPosts() {\n    this.errorSub = this.postService.error\n      .subscribe(errorMessage => {\n        this.error = errorMessage;\n      });\n\n    this.isFetching = true;\n    this.postService.fetchPosts()\n      .subscribe(posts => {\n        this.isFetching = false;\n        this.loadedPosts = posts;\n      }, error => {\n        this.isFetching = false;\n        this.error = error.message;\n      });\n  }",
        "called_code_segment_file_3": "deletePosts() {\n    return this.http.delete(\n      'https://ng-complete-guide-c56d3.firebaseio.com/posts.json'\n    );\n  }",
        "using_code_segment_file_4": "onClearPosts() {\n    // Send Http request\n    this.postService.deletePosts()\n      .subscribe(() => {\n        this.loadedPosts = [];\n      });\n  }",
        "feature_description": "Add a feature to log the response data from the server after creating a post.",
        "detailed_feature_description": "Modify the `createAndStorePost` method in `PostsService` to log the response data from the server after creating a post. Update the `onCreatePost` method in `AppComponent` to handle any changes in the `PostsService`. Ensure the `onFetchPosts` method in `AppComponent` is updated if it interacts with the modified `PostsService`. Finally, update the `onClearPosts` method in `AppComponent` if it depends on any changes in the `PostsService`.",
        "modified_complete_code": {
            "file_1": "onCreatePost(postData: Post) {\n    // Send Http request\n    this.postService.createAndStorePost(postData.title, postData.content);\n  }",
            "file_2": "createAndStorePost(title: string, content: string) {\n    const postData: Post = { title: title, content: content };\n    this.http\n      .post<{ name: string }>(\n        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json',\n        postData\n      )\n      .subscribe(responseData => {\n        console.log('Post created:', responseData);\n      });\n  }\n\n  fetchPosts() {\n    return this.http\n      .get<{ [key: string]: Post }>(\n        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json'\n      )\n      .pipe(\n        map(responseData => {\n          const postsArray: Post[] = [];\n          for (const key in responseData) {\n            if (responseData.hasOwnProperty(key)) {\n              postsArray.push({ ...responseData[key], id: key });\n            }\n          }\n          return postsArray;\n        })\n      );\n  }\n\n  deletePosts() {\n    return this.http.delete(\n      'https://ng-complete-guide-c56d3.firebaseio.com/posts.json'\n    );\n  }",
            "file_3": "onFetchPosts() {\n    this.errorSub = this.postService.error\n      .subscribe(errorMessage => {\n        this.error = errorMessage;\n      });\n\n    this.isFetching = true;\n    this.postService.fetchPosts()\n      .subscribe(posts => {\n        this.isFetching = false;\n        this.loadedPosts = posts;\n      }, error => {\n        this.isFetching = false;\n        this.error = error.message;\n      });\n  }",
            "file_4": "onClearPosts() {\n    // Send Http request\n    this.postService.deletePosts()\n      .subscribe(() => {\n        this.loadedPosts = [];\n      });\n  }"
        }
    },
    {
        "repo": "Recipe-Book-App-Angular-Project",
        "content": "'Recipe-Book-App-Angular-Project/src/app/shopping-list/shopping-list.service.ts'\n:import { Ingredient } from '../shared/ingredient.model';\nimport { Subject } from 'rxjs/Subject';\n\nexport class ShoppingListService {\n  ingredientsChanged = new Subject<Ingredient[]>();\n  startedEditing = new Subject<number>();\n  private ingredients: Ingredient[] = [\n    new Ingredient('Apples', 5),\n    new Ingredient('Tomatoes', 10),\n  ];\n\n  getIngredients() {\n    return this.ingredients.slice();\n  }\n\n  getIngredient(index: number) {\n    return this.ingredients[index];\n  }\n\n  addIngredient(ingredient: Ingredient) {\n    this.ingredients.push(ingredient);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  addIngredients(ingredients: Ingredient[]) {\n    // for (let ingredient of ingredients) {\n    //   this.addIngredient(ingredient);\n    // }\n    this.ingredients.push(...ingredients);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  updateIngredient(index: number, newIngredient: Ingredient) {\n    this.ingredients[index] = newIngredient;\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  deleteIngredient(index: number) {\n    this.ingredients.splice(index, 1);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n}\n\n'Recipe-Book-App-Angular-Project/src/app/recipes/recipe.service.ts'\n:import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\n\nimport { Recipe } from './recipe.model';\nimport { Ingredient } from '../shared/ingredient.model';\nimport { ShoppingListService } from '../shopping-list/shopping-list.service';\n\nconst FRUIT = 'https://c1.staticflickr.com/6/5737/30622968353_35e06fcb52_b.jpg';\nconst PASTA = 'https://upload.wikimedia.org/wikipedia/commons/2/2e/Mmm..._pretty_summer_salad_%286005733739%29.jpg';\nconst SOUP = 'https://c.pxhere.com/photos/9d/f4/tom_kha_gai_soup_asia_thailand_chili-1415918.jpg!d';\nconst BAGUETTE = 'https://images.pexels.com/photos/103657/' +\n  'baguette-bread-herb-baguette-frisch-103657.jpeg?cs=srgb&dl=baguette-baked-goods-bread-103657.jpg&fm=jpg';\nconst PIE = 'https://s-i.huffpost.com/gen/1737184/images/n-LOVE-AND-LEMONS-628x314.jpg';\nconst POPSICLE = 'http://www.rawfamily.com/wp-content/uploads/iStock_000024869026_Large1.jpg';\n\n@Injectable()\nexport class RecipeService {\n  recipesChanged = new Subject<Recipe[]>();\n\n  private recipes: Recipe[] = [\n    new Recipe('Fruit', 'Fruit Salad', FRUIT, [new Ingredient('Apple', 3), new Ingredient('Banans', 4)]),\n    new Recipe('Baguette', 'Italic Bread', BAGUETTE, [new Ingredient('Water', 100), new Ingredient('Italian', 1)]),\n    new Recipe('Pasta', 'With Salad', PASTA, [new Ingredient('Vegetables', 3), new Ingredient('Pasta', 1)]),\n    new Recipe('Soup', 'Tasty & Hot', SOUP, [new Ingredient('Water', 3), new Ingredient('Taste', 1)]),\n    new Recipe('Pie', 'Pretty & Attractive', PIE, [new Ingredient('Power', 10), new Ingredient('Fork', 1)]),\n    new Recipe('Popsicle', 'Cold & Refreshing', POPSICLE, [new Ingredient('Fruits', 5), new Ingredient('Popsicle Steak', 1)])\n  ];\n  constructor(private slService: ShoppingListService) {}\n\n  setRecipes(recipes: Recipe[]) {\n    this.recipes = recipes;\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  getRecipes() {\n    return this.recipes.slice();\n  }\n\n  getRecipe(index: number) {\n    return this.recipes[index];\n  }\n\n  addIngredientsToShoppingList(ingredients: Ingredient[]) {\n    this.slService.addIngredients(ingredients);\n  }\n\n  addRecipe(recipe: Recipe) {\n    this.recipes.push(recipe);\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  updateRecipe(index: number, newRecipe: Recipe) {\n    this.recipes[index] = newRecipe;\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  deleteRecipe(index: number) {\n    this.recipes.splice(index, 1);\n    this.recipesChanged.next(this.recipes.slice());\n  }\n}\n\n'Recipe-Book-App-Angular-Project/src/app/recipes/recipe-detail/recipe-detail.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute, Params, Router } from '@angular/router';\n\nimport { Recipe } from '../recipe.model';\nimport { RecipeService } from '../recipe.service';\n\n@Component({\n  selector: 'app-recipe-detail',\n  templateUrl: './recipe-detail.component.html',\n  styleUrls: ['./recipe-detail.component.css']\n})\nexport class RecipeDetailComponent implements OnInit {\n  recipe: Recipe;\n  id: number;\n\n  constructor(private recipeService: RecipeService,\n              private route: ActivatedRoute,\n              private router: Router) {\n  }\n\n  ngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params['id'];\n          this.recipe = this.recipeService.getRecipe(this.id);\n        }\n      );\n  }\n\n  onAddToShoppingList() {\n    this.recipeService.addIngredientsToShoppingList(this.recipe.ingredients);\n  }\n\n  onEditRecipe() {\n    this.router.navigate(['edit'], {relativeTo: this.route});\n    // this.router.navigate(['../', this.id, 'edit'], {relativeTo: this.route});\n  }\n\n  onDeleteRecipe() {\n    this.recipeService.deleteRecipe(this.id);\n    this.router.navigate(['/recipes']);\n  }\n\n}\n\n'Recipe-Book-App-Angular-Project/src/app/recipes/recipes.module.ts'\n:import { NgModule } from '@angular/core';\nimport { ReactiveFormsModule } from '@angular/forms';\nimport { CommonModule } from '@angular/common';\n\nimport { RecipesComponent } from './recipes.component';\nimport { RecipeStartComponent } from './recipe-start/recipe-start.component';\nimport { RecipeListComponent } from './recipe-list/recipe-list.component';\nimport { RecipeEditComponent } from './recipe-edit/recipe-edit.component';\nimport { RecipeDetailComponent } from './recipe-detail/recipe-detail.component';\nimport { RecipeItemComponent } from './recipe-list/recipe-item/recipe-item.component';\nimport { RecipesRoutingModule } from './recipes-routing.module';\nimport { SharedModule } from '../shared/shared.module';\n\n@NgModule({\n  declarations: [\n    RecipesComponent,\n    RecipeStartComponent,\n    RecipeListComponent,\n    RecipeEditComponent,\n    RecipeDetailComponent,\n    RecipeItemComponent\n  ],\n  imports: [\n    CommonModule,\n    ReactiveFormsModule,\n    RecipesRoutingModule,\n    SharedModule\n  ]\n})\nexport class RecipesModule {}\n\n",
        "called_code_segment_file_1": "getIngredients() {\n    return this.ingredients.slice();\n  }",
        "invoking_code_segment_file_2": "getRecipes() {\n    return this.recipes.slice();\n  }",
        "called_code_segment_file_2": "addIngredientsToShoppingList(ingredients: Ingredient[]) {\n    this.slService.addIngredients(ingredients);\n  }",
        "using_code_segment_file_3": "onAddToShoppingList() {\n    this.recipeService.addIngredientsToShoppingList(this.recipe.ingredients);\n  }",
        "called_code_segment_file_3": "ngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params['id'];\n          this.recipe = this.recipeService.getRecipe(this.id);\n        }\n      );\n  }",
        "using_code_segment_file_4": "ngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params['id'];\n          this.recipe = this.recipeService.getRecipe(this.id);\n        }\n      );\n  }",
        "feature_description": "Add a feature to log the ingredients when they are fetched from the ShoppingListService.",
        "detailed_feature_description": "Modify the getIngredients method in ShoppingListService to log the ingredients when they are fetched. Update the RecipeService to handle this change and ensure the RecipeDetailComponent is updated to accommodate any changes in the RecipeService. No changes are required in the RecipeDetailComponent as it does not directly interact with the modified segments in RecipeService.",
        "modified_complete_code": {
            "ShoppingListService": "import { Ingredient } from '../shared/ingredient.model';\nimport { Subject } from 'rxjs/Subject';\n\nexport class ShoppingListService {\n  ingredientsChanged = new Subject<Ingredient[]>();\n  startedEditing = new Subject<number>();\n  private ingredients: Ingredient[] = [\n    new Ingredient('Apples', 5),\n    new Ingredient('Tomatoes', 10),\n  ];\n\n  #Modify getIngredients() {\n    console.log('Fetching ingredients:', this.ingredients.slice());\n    return this.ingredients.slice();\n  }\n\n  getIngredient(index: number) {\n    return this.ingredients[index];\n  }\n\n  addIngredient(ingredient: Ingredient) {\n    this.ingredients.push(ingredient);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  addIngredients(ingredients: Ingredient[]) {\n    this.ingredients.push(...ingredients);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  updateIngredient(index: number, newIngredient: Ingredient) {\n    this.ingredients[index] = newIngredient;\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n\n  deleteIngredient(index: number) {\n    this.ingredients.splice(index, 1);\n    this.ingredientsChanged.next(this.ingredients.slice());\n  }\n}",
            "RecipeService": "import { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs/Subject';\n\nimport { Recipe } from './recipe.model';\nimport { Ingredient } from '../shared/ingredient.model';\nimport { ShoppingListService } from '../shopping-list/shopping-list.service';\n\nconst FRUIT = 'https://c1.staticflickr.com/6/5737/30622968353_35e06fcb52_b.jpg';\nconst PASTA = 'https://upload.wikimedia.org/wikipedia/commons/2/2e/Mmm..._pretty_summer_salad_%286005733739%29.jpg';\nconst SOUP = 'https://c.pxhere.com/photos/9d/f4/tom_kha_gai_soup_asia_thailand_chili-1415918.jpg!d';\nconst BAGUETTE = 'https://images.pexels.com/photos/103657/' +\n  'baguette-bread-herb-baguette-frisch-103657.jpeg?cs=srgb&dl=baguette-baked-goods-bread-103657.jpg&fm=jpg';\nconst PIE = 'https://s-i.huffpost.com/gen/1737184/images/n-LOVE-AND-LEMONS-628x314.jpg';\nconst POPSICLE = 'http://www.rawfamily.com/wp-content/uploads/iStock_000024869026_Large1.jpg';\n\n@Injectable()\nexport class RecipeService {\n  recipesChanged = new Subject<Recipe[]>();\n\n  private recipes: Recipe[] = [\n    new Recipe('Fruit', 'Fruit Salad', FRUIT, [new Ingredient('Apple', 3), new Ingredient('Banans', 4)]),\n    new Recipe('Baguette', 'Italic Bread', BAGUETTE, [new Ingredient('Water', 100), new Ingredient('Italian', 1)]),\n    new Recipe('Pasta', 'With Salad', PASTA, [new Ingredient('Vegetables', 3), new Ingredient('Pasta', 1)]),\n    new Recipe('Soup', 'Tasty & Hot', SOUP, [new Ingredient('Water', 3), new Ingredient('Taste', 1)]),\n    new Recipe('Pie', 'Pretty & Attractive', PIE, [new Ingredient('Power', 10), new Ingredient('Fork', 1)]),\n    new Recipe('Popsicle', 'Cold & Refreshing', POPSICLE, [new Ingredient('Fruits', 5), new Ingredient('Popsicle Steak', 1)])\n  ];\n  constructor(private slService: ShoppingListService) {}\n\n  setRecipes(recipes: Recipe[]) {\n    this.recipes = recipes;\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  getRecipes() {\n    return this.recipes.slice();\n  }\n\n  getRecipe(index: number) {\n    return this.recipes[index];\n  }\n\n  addIngredientsToShoppingList(ingredients: Ingredient[]) {\n    this.slService.addIngredients(ingredients);\n  }\n\n  addRecipe(recipe: Recipe) {\n    this.recipes.push(recipe);\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  updateRecipe(index: number, newRecipe: Recipe) {\n    this.recipes[index] = newRecipe;\n    this.recipesChanged.next(this.recipes.slice());\n  }\n\n  deleteRecipe(index: number) {\n    this.recipes.splice(index, 1);\n    this.recipesChanged.next(this.recipes.slice());\n  }\n}",
            "RecipeDetailComponent": "import { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute, Params, Router } from '@angular/router';\n\nimport { Recipe } from '../recipe.model';\nimport { RecipeService } from '../recipe.service';\n\n@Component({\n  selector: 'app-recipe-detail',\n  templateUrl: './recipe-detail.component.html',\n  styleUrls: ['./recipe-detail.component.css']\n})\nexport class RecipeDetailComponent implements OnInit {\n  recipe: Recipe;\n  id: number;\n\n  constructor(private recipeService: RecipeService,\n              private route: ActivatedRoute,\n              private router: Router) {}\n\n  ngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params['id'];\n          this.recipe = this.recipeService.getRecipe(this.id);\n        }\n      );\n  }\n\n  onAddToShoppingList() {\n    this.recipeService.addIngredientsToShoppingList(this.recipe.ingredients);\n  }\n\n  onEditRecipe() {\n    this.router.navigate(['edit'], {relativeTo: this.route});\n    // this.router.navigate(['../', this.id, 'edit'], {relativeTo: this.route});\n  }\n\n  onDeleteRecipe() {\n    this.recipeService.deleteRecipe(this.id);\n    this.router.navigate(['/recipes']);\n  }\n}",
            "RecipeStartComponent": "import { Component, OnInit } from '@angular/core';\nimport { ActivatedRoute, Params, Router } from '@angular/router';\n\nimport { Recipe } from '../recipe.model';\nimport { RecipeService } from '../recipe.service';\n\n@Component({\n  selector: 'app-recipe-start',\n  templateUrl: './recipe-start.component.html',\n  styleUrls: ['./recipe-start.component.css']\n})\nexport class RecipeStartComponent implements OnInit {\n  recipe: Recipe;\n  id: number;\n\n  constructor(private recipeService: RecipeService,\n              private route: ActivatedRoute,\n              private router: Router) {}\n\n  ngOnInit() {\n    this.route.params\n      .subscribe(\n        (params: Params) => {\n          this.id = +params['id'];\n          this.recipe = this.recipeService.getRecipe(this.id);\n        }\n      );\n  }\n}"
        }
    },
    {
        "repo": "b2-wallet-kit",
        "content": "'b2-wallet-kit/src/utils/wallet/types.ts'\n:export type Network = 'livenet' | 'testnet'\n\nexport type InstalledMap = Record<WalletTypes, boolean>\nexport enum WalletCollection {\n  BTC = 'btc',\n  ETH = 'eth',\n  ALL = 'all'\n}\n\nexport enum WalletTypes {\n  WALLET_METAMASK = 'metamask',\n  WALLET_UNISAT = 'unisat',\n  WALLET_OKX_EVM = 'okx_evm',\n  WALLET_OKX_BTC = 'okx_btc',\n  WALLET_GATE = 'gate',\n  WALLET_TOMO_EVM = 'tomo_evm',\n  WALLET_TOMO_BTC = 'tomo_btc',\n  WALLET_BYBIT_EVM = 'bybit_evm',\n  WALLET_BYBIT_BTC = 'bybit_btc',\n  WALLET_COIN98_BTC = 'coin98_btc',\n  WALLET_COIN98_EVM = 'coin98_evm',\n  WALLET_FOX_BTC = 'fox_btc',\n  WALLET_FOX_EVM = 'fox_evm',\n  WALLET_BITGET_EVM = 'bitget_evm',\n  WALLET_BITGET_BTC = 'bitget_btc',\n  WALLET_XVERSE = 'xverse',\n  WALLET_TOKENPOCKET = 'tokenpocket',\n  WALLET_BINANCE_EVM = 'binance_evm',\n  WALLET_BINANCE_BTC = 'binance_btc'\n}\n\nexport enum ChainType {\n  ETH = 'eth',\n  BTC = 'btc'\n}\n'b2-wallet-kit/src/utils/localStorage.ts'\n:import { WalletTypes } from \"./wallet/types\"\n\nconst KEY_WALLET = 'currentWallet'\n\nexport const saveWalletToLocal = (w: WalletTypes) => {\n  try {\n    localStorage.setItem(KEY_WALLET, w)\n  } catch (error) {\n    console.log(error, 'error')\n  }\n}\n\nexport const getWalletFromLocal = () => {\n  return localStorage.getItem(KEY_WALLET) as WalletTypes || undefined\n}\nexport const clearWalletFromLocal = () => {\n  localStorage.removeItem(KEY_WALLET)\n  return\n}\n\n'b2-wallet-kit/src/hooks/useB2Disconnect.ts'\n:\n\nimport { useAccount, useDisconnect } from \"wagmi\";\nimport { useCallback } from \"react\";\nimport { WalletTypes } from \"../utils/wallet/types\";\nimport { clearWalletFromLocal } from \"../utils/localStorage\";\nimport { useCurrentWallet } from \"../context\";\nimport { useConnectModal } from \"@particle-network/btc-connectkit\";\nimport { EvmWalletArr } from \"../utils/wallet\";\n\n\nconst useB2Disconnect = () => {\n  const { setCurrentWallet, currentWallet } = useCurrentWallet()\n  const { openConnectModal, disconnect: disconnectBtc } = useConnectModal();\n  const { isConnected } = useAccount()\n  const { disconnect } = useDisconnect()\n  const handleDisconnect = useCallback(() => {\n    if (currentWallet && EvmWalletArr.includes(currentWallet) && isConnected) {\n      disconnect()\n    } else {\n      disconnectBtc && disconnectBtc()\n    }\n    setCurrentWallet(undefined)\n    clearWalletFromLocal()\n  }, [currentWallet])\n  return {\n    disconnect: handleDisconnect\n  }\n}\nexport {\n  useB2Disconnect\n}\n'b2-wallet-kit/src/components/connectModal/index.tsx'\n:import { Connector, useAccount, useConnect as useEthConnect } from \"wagmi\";\n\nimport Modal from 'react-modal';\nimport { useB2Modal, useCurrentWallet } from \"../../context\";\nimport { WalletCollection, WalletTypes, InstalledMap } from \"../../utils/wallet/types\";\nimport { useCallback, useEffect, useMemo, useState } from \"react\";\n\nimport iconType from '../../imgs/icon_type.svg'\nimport { saveWalletToLocal } from \"../../utils\";\nimport WalletItem from \"./WalletItem\";\nimport ModalHeader from \"./ModalHeader\";\nimport { useConnector as useBtcConnector } from '@particle-network/btc-connectkit';\nimport styles from './index.module.scss';\nimport { useB2Disconnect } from \"../../hooks/useB2Disconnect\";\nimport { btcWalletNameTransformer, checkWalletInstall, defaultInstalledMap, evmWalletNameTransformer, getBtcWalletName, } from \"../../utils/wallet\";\nimport { getWalletIconByName } from \"../../utils/wallet/getWalletIconByName\";\n\n\nconst SubTitle = ({ title }: { title: string }) => {\n  return (\n    <div className={styles.title}>\n      <img src={iconType} alt=\"icon\" />\n      <div>\n        {title}\n      </div>\n    </div>\n  )\n}\n\nconst ConnectModal = ({ collection }: { collection: WalletCollection }) => {\n  const { connectAsync, connectors, error, isLoading, pendingConnector } =\n    useEthConnect();\n  const { setCurrentWallet } = useCurrentWallet()\n  const { connectors: btcConnectors, connect: connectBtc } = useBtcConnector()\n  const { openConnectModal, handleCloseConnectModal } = useB2Modal()\n  const { isConnected } = useAccount()\n  const [installedMap, setInstalledMap] = useState<InstalledMap>(defaultInstalledMap)\n  const { disconnect: disconnectBtc } = useB2Disconnect()\n  const showEth = useMemo(() => {\n    return collection === WalletCollection.ALL || collection === WalletCollection.ETH\n  }, [collection])\n  const showBtc = useMemo(() => {\n    return collection === WalletCollection.ALL || collection === WalletCollection.BTC\n  }, [collection])\n\n\n\n  const getInstalled = useCallback((wallet: string, walletType: 'evm' | 'btc') => {\n    if (walletType === 'evm') {\n      const name = evmWalletNameTransformer(wallet)\n      if (name) return installedMap[name]\n    }\n    if (walletType === 'btc') {\n      const name = btcWalletNameTransformer(wallet)\n      if (name) return installedMap[name]\n    }\n    return false\n\n  }, [installedMap])\n\n\n\n  const handleClickEthWallet = async (c: Connector) => {\n    if (!isConnected) {\n      const res = await connectAsync({ connector: c })\n    }\n    let name = evmWalletNameTransformer(c.name)\n    console.log(name, 'evm clicked')\n    name && setCurrentWallet(name)\n    name && saveWalletToLocal(name)\n    handleCloseConnectModal()\n  }\n\n  const connectBtcWallet = async (btcWallet: string) => {\n    try {\n      await disconnectBtc()\n      const res = await connectBtc(btcWallet)\n      const name = btcWalletNameTransformer(btcWallet)\n      console.log(name, 'btc clicked')\n      name && setCurrentWallet(name)\n      name && saveWalletToLocal(name)\n      handleCloseConnectModal()\n    } catch (error) {\n      console.log('connect error for:', btcWallet)\n    }\n  }\n\n  const getInstalledWallet = () => {\n    if (typeof window === 'undefined') return;\n    const o = {\n      ...installedMap\n    }\n    const installed = checkWalletInstall(o)\n    setInstalledMap(installed)\n  }\n\n  useEffect(() => {\n    if (openConnectModal) {\n      getInstalledWallet()\n    }\n  }, [openConnectModal])\n\n  const evmWalletNameFormat = (name: string) => {\n    if (name.toLowerCase().includes('binance')) return 'Binance Wallet'\n    return name\n  }\n\n\n  return (\n    <Modal\n      isOpen={openConnectModal}\n      onRequestClose={handleCloseConnectModal}\n      ariaHideApp={false}\n      className={styles.b2WalletModal}\n      overlayClassName={styles.overlay}\n    >\n      <ModalHeader handleCloseConnectModal={handleCloseConnectModal} />\n      <div className={styles.content}>\n        {\n          showEth && <div>\n            <SubTitle title=\"Ethereum Wallet\" />\n            <div className={styles.row}>\n              {\n                showEth && connectors.map(c => {\n                  const installed = getInstalled(c.name, 'evm')\n                  return (\n                    <div\n                      className={styles.rowItem}\n                      onClick={() => {\n                        if (installed) {\n                          handleClickEthWallet(c)\n                        }\n                      }} key={c.name}>\n                      <WalletItem installed={installed} walletIcon={getWalletIconByName(c.name) || c.icon} walletName={evmWalletNameFormat(c.name)} />\n                    </div>\n                  )\n                })\n              }\n            </div>\n          </div>\n        }\n        {\n          showBtc && <div>\n            <SubTitle title=\"Bitcoin Wallet\" />\n            <div className={styles.row}>\n              {\n                btcConnectors.map(c => {\n                  const installed = getInstalled(c.metadata.id, 'btc')\n                  const name = getBtcWalletName(c.metadata.id)\n                  return (\n                    <div key={c.metadata.id}\n                      className={styles.rowItem}\n                      onClick={() => {\n                        if (installed) {\n                          connectBtcWallet(c.metadata.id)\n                        }\n                      }}>\n                      <WalletItem installed={installed} walletIcon={getWalletIconByName(c.metadata.id)} walletName={name} />\n                    </div>\n                  )\n                })\n              }\n            </div>\n\n          </div>\n        }\n      </div>\n    </Modal>\n  )\n}\n\nexport default ConnectModal\n",
        "called_code_segment_file_1": "const handleClickEthWallet = async (c: Connector) => {\n    if (!isConnected) {\n      const res = await connectAsync({ connector: c })\n    }\n    let name = evmWalletNameTransformer(c.name)\n    console.log(name, 'evm clicked')\n    name && setCurrentWallet(name)\n    name && saveWalletToLocal(name)\n    handleCloseConnectModal()\n  }",
        "invoking_code_segment_file_2": "const { connectAsync, connectors, error, isLoading, pendingConnector } = useEthConnect();",
        "called_code_segment_file_2": "const { isConnected } = useAccount()",
        "using_code_segment_file_3": "const { disconnect: disconnectBtc } = useB2Disconnect()",
        "called_code_segment_file_3": "const { disconnect: disconnectBtc } = useB2Disconnect()",
        "using_code_segment_file_4": "const { disconnect: disconnectBtc } = useB2Disconnect()",
        "feature_description": "Add a feature to handle wallet connection errors and display a toast notification.",
        "detailed_feature_description": "Modify the handleClickEthWallet function in #file 1 to handle connection errors and display a toast notification. Update #file 2 to handle the modified code from #file 1 and ensure any related code segments used by #file 3 are updated accordingly. Modify #file 3 to accommodate the changes if it directly interacts with updated segments in #file 2. Update #file 4 if it interacts with or depends on any updated segments in #file 3.",
        "modified_complete_code": {
            "#file 1": "const handleClickEthWallet = async (c: Connector) => {\n    if (!isConnected) {\n      try {\n        const res = await connectAsync({ connector: c })\n        let name = evmWalletNameTransformer(c.name)\n        console.log(name, 'evm clicked')\n        name && setCurrentWallet(name)\n        name && saveWalletToLocal(name)\n        handleCloseConnectModal()\n      } catch (error) {\n        console.error('Wallet connection error:', error)\n        // #New: Display toast notification\n        showToast('Wallet connection failed. Please try again.', 'error')\n      }\n    }\n  }",
            "#file 2": "const { connectAsync, connectors, error, isLoading, pendingConnector } = useEthConnect();\n\n// #New: Function to show toast notification\nconst showToast = (message: string, type: 'error' | 'success') => {\n  console.log(`Toast: ${message}`, type)\n}",
            "#file 3": "const { disconnect: disconnectBtc } = useB2Disconnect()\n\n// #New: Function to show toast notification\nconst showToast = (message: string, type: 'error' | 'success') => {\n  console.log(`Toast: ${message}`, type)\n}",
            "#file 4": "const { disconnect: disconnectBtc } = useB2Disconnect()\n\n// #New: Function to show toast notification\nconst showToast = (message: string, type: 'error' | 'success') => {\n  console.log(`Toast: ${message}`, type)\n}"
        }
    },
    {
        "repo": "Lumina",
        "content": "'Lumina/src/API/Nodes/NodeIdPool.ts'\n:import { IdPool } from \"API/IdPool\";\n\nexport const NodeIdPool = new IdPool();\n\n'Lumina/src/API/Nodes/Node.ts'\n:import type { NodeField } from \"API/Fields/NodeField\";\nimport { LowerFirstLetter } from \"API/Lib\";\nimport type { Src } from \"API/VFXScriptCreator\";\nimport { NodeGroups } from \"../NodeGroup\";\nimport { AutoGenAddToSystem, AutoGenImport } from \"./AutoGenLib\";\nimport { NodeIdPool } from \"./NodeIdPool\";\n\nexport enum UpdatePrioriy {\n    First = 1,\n    Default = 2,\n    Last = 3,\n    PostMove = 4,\n}\n\nexport abstract class Node {\n    id: number;\n\n    updatePriority = UpdatePrioriy.Default;\n    updateOrder = -1;\n\n    abstract nodeFields: { [key: string]: NodeField };\n    connectedSystemId?: number;\n    systemGroup?: NodeGroups;\n\n    constructor() {\n        this.id = NodeIdPool.GetNextId();\n    }\n\n    abstract GetClassName(): string;\n    abstract GetNodeGroups(): NodeGroups[];\n    abstract GetNodeFolderName(): string;\n\n    GetAutoGenerationCode(src: Src, wrapper?: string) {\n        if (this.GetNodeGroups().findIndex((g) => g === NodeGroups.Logic) !== -1 && wrapper !== undefined) {\n            const nodeName = this.GetClassName();\n\n            const className = `${nodeName}${this.id}`;\n            const varName = `${LowerFirstLetter(nodeName)}${this.id}`;\n\n            if (string.match(src.value, className)[0] === undefined) {\n                src.value += `local ${className} = TS.import(script, APIFolder, \"Nodes\", \"${this.GetNodeFolderName()}\", \"${nodeName}\").${nodeName} \\n`;\n                src.value += `local ${varName} = ${className}.new() \\n\\n`;\n\n                for (const [fieldName, fieldValue] of pairs(this.nodeFields)) {\n                    fieldValue.AutoGenerateField(`${varName}.nodeFields.${fieldName}`, src);\n                }\n\n                src.value += \"\\n\";\n            }\n\n            src.value += `${wrapper.gsub(\"%.%.\", `${varName}`)[0]}\\n`;\n            return;\n        }\n\n        const varName = AutoGenImport(this, src);\n\n        for (const [fieldName, fieldValue] of pairs(this.nodeFields)) {\n            fieldValue.AutoGenerateField(`${varName}.nodeFields.${fieldName}`, src);\n        }\n\n        AutoGenAddToSystem(varName, this.systemGroup as NodeGroups, src);\n    }\n}\n\n'Lumina/src/API/Nodes/Initialize/InitializeNode.ts'\n:import { NodeGroups } from \"API/NodeGroup\";\nimport type { ParticleData } from \"API/ParticleService\";\nimport { Node } from \"../Node\";\n\nexport abstract class InitializeNode extends Node {\n    static nodeGroups = [NodeGroups.Initialize];\n\n    GetNodeGroups(): NodeGroups[] {\n        return InitializeNode.nodeGroups;\n    }\n\n    GetNodeFolderName(): string {\n        return \"Initialize\";\n    }\n\n    abstract Run(data: ParticleData): void;\n}\n\n'Lumina/src/API/Nodes/Render/VolumetricParticle.ts'\n:import { RunService, Workspace } from \"@rbxts/services\";\nimport { StateField } from \"API/Fields/StateField\";\nimport { GetVolumetricParticlesFolder } from \"API/FolderLocations\";\nimport { CFrameZero } from \"API/Lib\";\nimport { ObjectPool } from \"API/ObjectPool\";\nimport { CreateParticleData, GetNextParticleId, type ParticleData, ParticleTypes } from \"API/ParticleService\";\nimport { VolumetricParticleShapeType } from \"../FieldStates\";\nimport type { InitializeNode } from \"../Initialize/InitializeNode\";\nimport type { UpdateNode } from \"../Update/UpdateNode\";\nimport { RenderNode } from \"./RenderNode\";\n\nconst DEFAULT_SIZE = new Vector3(1, 1, 1);\nconst DEFAULT_MATERIAL = Enum.Material.SmoothPlastic;\nconst DEAD_PARTICLES_CFRAME = new CFrame(0, 10000, 0);\nconst DEFAULT_COLOR = new Color3(1, 1, 1);\n\nfunction CreateVolumetricParticle() {\n    const particle = new Instance(\"Part\");\n    particle.Name = \"VolumetricParticle\";\n    particle.Locked = true;\n\n    particle.Size = DEFAULT_SIZE;\n    particle.Material = DEFAULT_MATERIAL;\n    particle.Color = DEFAULT_COLOR;\n\n    particle.CastShadow = false;\n\n    particle.Anchored = true;\n    particle.CanCollide = false;\n    particle.CanQuery = false;\n    particle.CanTouch = false;\n    particle.Massless = true;\n\n    particle.Parent = GetVolumetricParticlesFolder();\n    return particle;\n}\n\nfunction UpdateParticleProperties(data: ParticleData) {\n    const particle = data.particle;\n\n    const newSize = data.sizeNormal.add(data.sizeNormal.mul(data.sizeMultiplier));\n    if (particle.Size !== newSize) {\n        particle.Size = newSize;\n    }\n\n    if (particle.Transparency !== data.transparency) {\n        particle.Transparency = data.transparency;\n    }\n\n    if (particle.Color !== data.color) {\n        particle.Color = data.color;\n    }\n}\n\nexport class VolumetricParticle extends RenderNode {\n    static className = \"VolumetricParticle\";\n\n    nodeFields = {\n        shape: new StateField(VolumetricParticleShapeType, VolumetricParticleShapeType.Cube),\n    };\n\n    objectPool: ObjectPool;\n    updateLoop: undefined | RBXScriptConnection;\n    aliveParticles: ParticleData[];\n\n    constructor() {\n        super();\n\n        this.objectPool = new ObjectPool(CreateVolumetricParticle);\n        this.aliveParticles = [];\n    }\n\n    Render = (initializeNodes: InitializeNode[], updateNodes: UpdateNode[]) => {\n        const id = GetNextParticleId();\n        const particle = this.objectPool.GetItem() as Part;\n        particle.CFrame = CFrameZero;\n\n        const shape = this.nodeFields.shape.GetState();\n        if (shape === VolumetricParticleShapeType.Cube) {\n            if (particle.Shape !== Enum.PartType.Block) {\n                particle.Shape = Enum.PartType.Block;\n            }\n        } else if (shape === VolumetricParticleShapeType.Sphere) {\n            if (particle.Shape !== Enum.PartType.Ball) {\n                particle.Shape = Enum.PartType.Ball;\n            }\n        }\n\n        const orderedInitializeNodes = initializeNodes.sort((a, b) => {\n            if (a.updatePriority !== b.updatePriority) {\n                return a.updatePriority < b.updatePriority;\n            }\n\n            return a.updateOrder < b.updateOrder;\n        });\n\n        const orderedUpdateNodes = updateNodes.sort((a, b) => {\n            if (a.updatePriority !== b.updatePriority) {\n                return a.updatePriority < b.updatePriority;\n            }\n\n            return a.updateOrder < b.updateOrder;\n        });\n\n        const data = CreateParticleData(id, ParticleTypes.Cube, particle, orderedUpdateNodes);\n        for (let i = 0; i < orderedInitializeNodes.size(); i++) {\n            orderedInitializeNodes[i].Run(data);\n        }\n\n        if (data.nextPos !== undefined || data.rotation !== CFrameZero) {\n            let pos = Vector3.zero;\n            let rot = CFrameZero;\n\n            if (data.nextPos !== undefined) {\n                pos = data.nextPos;\n            }\n\n            if (data.rotation !== CFrameZero) {\n                rot = data.rotation;\n            }\n\n            particle.CFrame = new CFrame(pos).mul(rot);\n        }\n\n        for (let i = 0; i < orderedUpdateNodes.size(); i++) {\n            orderedUpdateNodes[i].Run(data, 1);\n        }\n\n        UpdateParticleProperties(data);\n        this.aliveParticles.push(data);\n\n        if (this.updateLoop !== undefined) return;\n\n        this.updateLoop = RunService.RenderStepped.Connect((dt) => {\n            const movedParticles: BasePart[] = [];\n            const movedParticlesCFrames: CFrame[] = [];\n\n            for (let i = this.aliveParticles.size() - 1; i >= 0; i--) {\n                const aliveParticleData = this.aliveParticles[i];\n\n                if (aliveParticleData.alivetime + dt >= aliveParticleData.lifetime) {\n                    this.aliveParticles.remove(i);\n                    this.objectPool.RemoveItem(aliveParticleData.particle);\n\n                    movedParticles.push(aliveParticleData.particle);\n                    movedParticlesCFrames.push(DEAD_PARTICLES_CFRAME);\n\n                    aliveParticleData.isRemoving.Fire();\n\n                    if (this.aliveParticles.size() === 0) {\n                        if (this.updateLoop === undefined) continue;\n\n                        this.updateLoop.Disconnect();\n                        this.updateLoop = undefined;\n                    }\n\n                    continue;\n                }\n\n                for (let i = 0; i < aliveParticleData.updateNodes.size(); i++) {\n                    aliveParticleData.updateNodes[i].Run(aliveParticleData, dt);\n                }\n\n                if (\n                    aliveParticleData.nextPos !== undefined ||\n                    aliveParticleData.velocityNormal !== Vector3.zero ||\n                    aliveParticleData.rotation !== CFrameZero\n                ) {\n                    let pos: Vector3;\n\n                    if (aliveParticleData.nextPos !== undefined) {\n                        pos = aliveParticleData.nextPos;\n                        aliveParticleData.nextPos = undefined;\n                    } else {\n                        const velocity = aliveParticleData.velocityNormal.mul(aliveParticleData.velocityMultiplier);\n                        pos = aliveParticleData.particle.Position.add(velocity.mul(dt));\n                    }\n\n                    let cf = new CFrame(pos);\n\n                    if (aliveParticleData.rotation !== CFrameZero) {\n                        cf = cf.mul(aliveParticleData.rotation);\n                    }\n\n                    if (aliveParticleData.particle.CFrame !== cf) {\n                        movedParticles.push(aliveParticleData.particle);\n                        movedParticlesCFrames.push(cf);\n                    }\n                }\n\n                UpdateParticleProperties(aliveParticleData);\n                aliveParticleData.alivetime += dt;\n            }\n\n            Workspace.BulkMoveTo(movedParticles, movedParticlesCFrames, Enum.BulkMoveMode.FireCFrameChanged);\n        });\n    };\n\n    Destroy() {\n        if (this.updateLoop !== undefined) {\n            this.updateLoop.Disconnect();\n        }\n\n        for (const data of this.aliveParticles) {\n            this.objectPool.RemoveItem(data.particle);\n        }\n\n        this.objectPool.ClearStandby();\n    }\n\n    GetClassName() {\n        return VolumetricParticle.className;\n    }\n}\n\n",
        "called_code_segment_file_1": "GetAutoGenerationCode(src: Src, wrapper?: string)",
        "invoking_code_segment_file_2": "GetAutoGenerationCode(src, wrapper)",
        "called_code_segment_file_2": "GetAutoGenerationCode(src, wrapper)",
        "using_code_segment_file_3": "AutoGenImport(this, src)",
        "called_code_segment_file_3": "AutoGenImport(this, src)",
        "using_code_segment_file_4": "AutoGenAddToSystem(varName, this.systemGroup as NodeGroups, src)",
        "feature_description": "Add a new feature to allow nodes to be automatically added to a specific system group during auto-generation.",
        "detailed_feature_description": "The new feature involves modifying the GetAutoGenerationCode method in #file 1 to include a new parameter for specifying the system group. This change will propagate to #file 2, which will pass the system group parameter. #file 3 will handle the new parameter and ensure it is used correctly. #file 4 will be updated to accommodate any changes in #file 3.",
        "modified_complete_code": {
            "Lumina/src/API/Nodes/Node.ts": "export abstract class Node {\n    id: number;\n\n    updatePriority = UpdatePrioriy.Default;\n    updateOrder = -1;\n\n    abstract nodeFields: { [key: string]: NodeField };\n    connectedSystemId?: number;\n    systemGroup?: NodeGroups;\n\n    constructor() {\n        this.id = NodeIdPool.GetNextId();\n    }\n\n    abstract GetClassName(): string;\n    abstract GetNodeGroups(): NodeGroups[];\n    abstract GetNodeFolderName(): string;\n\n    GetAutoGenerationCode(src: Src, wrapper?: string, systemGroup?: NodeGroups) { // #Modify\n        if (this.GetNodeGroups().findIndex((g) => g === NodeGroups.Logic) !== -1 && wrapper !== undefined) {\n            const nodeName = this.GetClassName();\n\n            const className = `${nodeName}${this.id}`;\n            const varName = `${LowerFirstLetter(nodeName)}${this.id}`;\n\n            if (string.match(src.value, className)[0] === undefined) {\n                src.value += `local ${className} = TS.import(script, APIFolder, \"Nodes\", \"${this.GetNodeFolderName()}\", \"${nodeName}\").${nodeName} \\n`;\n                src.value += `local ${varName} = ${className}.new() \\n\\n`;\n\n                for (const [fieldName, fieldValue] of pairs(this.nodeFields)) {\n                    fieldValue.AutoGenerateField(`${varName}.nodeFields.${fieldName}`, src);\n                }\n\n                src.value += \"\\n\";\n            }\n\n            src.value += `${wrapper.gsub(\"%.%.\", `${varName}`)[0]}\\n`;\n            return;\n        }\n\n        const varName = AutoGenImport(this, src);\n\n        for (const [fieldName, fieldValue] of pairs(this.nodeFields)) {\n            fieldValue.AutoGenerateField(`${varName}.nodeFields.${fieldName}`, src);\n        }\n\n        AutoGenAddToSystem(varName, systemGroup as NodeGroups, src); // #Modify\n    }\n}",
            "Lumina/src/API/Nodes/AutoGenLib.ts": "export function AutoGenImport(node: Node, src: Src) {\n    const nodeName = node.GetClassName();\n    const className = `${nodeName}${node.id}`;\n    const varName = `${LowerFirstLetter(nodeName)}${node.id}`;\n\n    if (string.match(src.value, className)[0] === undefined) {\n        src.value += `local ${className} = TS.import(script, APIFolder, \"Nodes\", \"${node.GetNodeFolderName()}\", \"${nodeName}\").${nodeName} \\n`;\n        src.value += `local ${varName} = ${className}.new() \\n\\n`;\n    }\n\n    return varName;\n}\n\nexport function AutoGenAddToSystem(varName: string, systemGroup: NodeGroups, src: Src) { // #Modify\n    src.value += `SystemService.AddNodeToSystem(${varName}, ${systemGroup}) \\n`;\n}",
            "Lumina/src/API/Nodes/Initialize/InitializeNode.ts": "export abstract class InitializeNode extends Node {\n    static nodeGroups = [NodeGroups.Initialize];\n\n    GetNodeGroups(): NodeGroups[] {\n        return InitializeNode.nodeGroups;\n    }\n\n    GetNodeFolderName(): string {\n        return \"Initialize\";\n    }\n\n    abstract Run(data: ParticleData): void;\n}",
            "Lumina/src/API/Nodes/Render/VolumetricParticle.ts": "export class VolumetricParticle extends RenderNode {\n    static className = \"VolumetricParticle\";\n\n    nodeFields = {\n        shape: new StateField(VolumetricParticleShapeType, VolumetricParticleShapeType.Cube),\n    };\n\n    objectPool: ObjectPool;\n    updateLoop: undefined | RBXScriptConnection;\n    aliveParticles: ParticleData[];\n\n    constructor() {\n        super();\n\n        this.objectPool = new ObjectPool(CreateVolumetricParticle);\n        this.aliveParticles = [];\n    }\n\n    Render = (initializeNodes: InitializeNode[], updateNodes: UpdateNode[]) => {\n        const id = GetNextParticleId();\n        const particle = this.objectPool.GetItem() as Part;\n        particle.CFrame = CFrameZero;\n\n        const shape = this.nodeFields.shape.GetState();\n        if (shape === VolumetricParticleShapeType.Cube) {\n            if (particle.Shape !== Enum.PartType.Block) {\n                particle.Shape = Enum.PartType.Block;\n            }\n        } else if (shape === VolumetricParticleShapeType.Sphere) {\n            if (particle.Shape !== Enum.PartType.Ball) {\n                particle.Shape = Enum.PartType.Ball;\n            }\n        }\n\n        const orderedInitializeNodes = initializeNodes.sort((a, b) => {\n            if (a.updatePriority !== b.updatePriority) {\n                return a.updatePriority < b.updatePriority;\n            }\n\n            return a.updateOrder < b.updateOrder;\n        });\n\n        const orderedUpdateNodes = updateNodes.sort((a, b) => {\n            if (a.updatePriority !== b.updatePriority) {\n                return a.updatePriority < b.updatePriority;\n            }\n\n            return a.updateOrder < b.updateOrder;\n        });\n\n        const data = CreateParticleData(id, ParticleTypes.Cube, particle, orderedUpdateNodes);\n        for (let i = 0; i < orderedInitializeNodes.size(); i++) {\n            orderedInitializeNodes[i].Run(data);\n        }\n\n        if (data.nextPos !== undefined || data.rotation !== CFrameZero) {\n            let pos = Vector3.zero;\n            let rot = CFrameZero;\n\n            if (data.nextPos !== undefined) {\n                pos = data.nextPos;\n            }\n\n            if (data.rotation !== CFrameZero) {\n                rot = data.rotation;\n            }\n\n            particle.CFrame = new CFrame(pos).mul(rot);\n        }\n\n        for (let i = 0; i < orderedUpdateNodes.size(); i++) {\n            orderedUpdateNodes[i].Run(data, 1);\n        }\n\n        UpdateParticleProperties(data);\n        this.aliveParticles.push(data);\n\n        if (this.updateLoop !== undefined) return;\n\n        this.updateLoop = RunService.RenderStepped.Connect((dt) => {\n            const movedParticles: BasePart[] = [];\n            const movedParticlesCFrames: CFrame[] = [];\n\n            for (let i = this.aliveParticles.size() - 1; i >= 0; i--) {\n                const aliveParticleData = this.aliveParticles[i];\n\n                if (aliveParticleData.alivetime + dt >= aliveParticleData.lifetime) {\n                    this.aliveParticles.remove(i);\n                    this.objectPool.RemoveItem(aliveParticleData.particle);\n\n                    movedParticles.push(aliveParticleData.particle);\n                    movedParticlesCFrames.push(DEAD_PARTICLES_CFRAME);\n\n                    aliveParticleData.isRemoving.Fire();\n\n                    if (this.aliveParticles.size() === 0) {\n                        if (this.updateLoop === undefined) continue;\n\n                        this.updateLoop.Disconnect();\n                        this.updateLoop = undefined;\n                    }\n\n                    continue;\n                }\n\n                for (let i = 0; i < aliveParticleData.updateNodes.size(); i++) {\n                    aliveParticleData.updateNodes[i].Run(aliveParticleData, dt);\n                }\n\n                if (\n                    aliveParticleData.nextPos !== undefined ||\n                    aliveParticleData.velocityNormal !== Vector3.zero ||\n                    aliveParticleData.rotation !== CFrameZero\n                ) {\n                    let pos: Vector3;\n\n                    if (aliveParticleData.nextPos !== undefined) {\n                        pos = aliveParticleData.nextPos;\n                        aliveParticleData.nextPos = undefined;\n                    } else {\n                        const velocity = aliveParticleData.velocityNormal.mul(aliveParticleData.velocityMultiplier);\n                        pos = aliveParticleData.particle.Position.add(velocity.mul(dt));\n                    }\n\n                    let cf = new CFrame(pos);\n\n                    if (aliveParticleData.rotation !== CFrameZero) {\n                        cf = cf.mul(aliveParticleData.rotation);\n                    }\n\n                    if (aliveParticleData.particle.CFrame !== cf) {\n                        movedParticles.push(aliveParticleData.particle);\n                        movedParticlesCFrames.push(cf);\n                    }\n                }\n\n                UpdateParticleProperties(aliveParticleData);\n                aliveParticleData.alivetime += dt;\n            }\n\n            Workspace.BulkMoveTo(movedParticles, movedParticlesCFrames, Enum.BulkMoveMode.FireCFrameChanged);\n        });\n    };\n\n    Destroy() {\n        if (this.updateLoop !== undefined) {\n            this.updateLoop.Disconnect();\n        }\n\n        for (const data of this.aliveParticles) {\n            this.objectPool.RemoveItem(data.particle);\n        }\n\n        this.objectPool.ClearStandby();\n    }\n\n    GetClassName() {\n        return VolumetricParticle.className;\n    }\n}"
        }
    },
    {
        "repo": "Angular-Material-Data-Table-Paging-Sorting-Filtering",
        "content": "'Angular-Material-Data-Table-Paging-Sorting-Filtering/CompleteAngularMaterialApp/src/app/shared/department.service.ts'\n:import { Injectable } from '@angular/core';\nimport { AngularFireDatabase, AngularFireList } from 'angularfire2/database';\n\nimport * as _ from 'lodash';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class DepartmentService {\n  departmentList: AngularFireList<any>;\n  array = [];\n\n  constructor(private firebase: AngularFireDatabase) {\n    this.departmentList = this.firebase.list('departments');\n    this.departmentList.snapshotChanges().subscribe(\n      list => {\n        this.array = list.map(item => {\n          return {\n            $key: item.key,\n            ...item.payload.val()\n          };\n        });\n      });\n   }\n\n\n   getDepartmentName($key) {\n    if ($key == \"0\")\n      return \"\";\n    else{\n      return _.find(this.array, (obj) => { return obj.$key == $key; })['name'];\n    }\n  }\n\n}\n\n'Angular-Material-Data-Table-Paging-Sorting-Filtering/CompleteAngularMaterialApp/src/app/employees/employee-list/employee-list.component.ts'\n:import { Component, OnInit,ViewChild } from '@angular/core';\nimport { EmployeeService } from '../../shared/employee.service';\nimport { MatTableDataSource,MatSort,MatPaginator } from '@angular/material';\nimport { DepartmentService } from '../../shared/department.service';\n\n@Component({\n  selector: 'app-employee-list',\n  templateUrl: './employee-list.component.html',\n  styleUrls: ['./employee-list.component.css']\n})\nexport class EmployeeListComponent implements OnInit {\n\n  constructor(private service: EmployeeService,\n    private departmentService: DepartmentService) { } \n\n  listData: MatTableDataSource<any>;\n  displayedColumns: string[] = ['fullName', 'email', 'mobile', 'city', 'departmentName','actions'];\n  @ViewChild(MatSort) sort: MatSort;\n  @ViewChild(MatPaginator) paginator: MatPaginator;\n  searchKey: string;\n  \n  ngOnInit() {\n    this.service.getEmployees().subscribe(\n      list => {\n        let array = list.map(item => {\n          let departmentName = this.departmentService.getDepartmentName(item.payload.val()['department']);\n          return {\n            $key: item.key,\n            departmentName,\n            ...item.payload.val()\n          };\n        });\n        this.listData = new MatTableDataSource(array);\n        this.listData.sort = this.sort;\n        this.listData.paginator = this.paginator;\n        this.listData.filterPredicate = (data, filter) => {\n          return this.displayedColumns.some(ele => {\n            return ele != 'actions' && data[ele].toLowerCase().indexOf(filter) != -1;\n          });\n        };\n      });\n  }\n\n  onSearchClear() {\n    this.searchKey = \"\";\n    this.applyFilter();\n  }\n\n  applyFilter() {\n    this.listData.filter = this.searchKey.trim().toLowerCase();\n  }\n\n}\n\n'Angular-Material-Data-Table-Paging-Sorting-Filtering/CompleteAngularMaterialApp/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { MaterialModule } from \"./material/material.module\";\nimport { ReactiveFormsModule,FormsModule } from \"@angular/forms\";\nimport { BrowserAnimationsModule } from '@angular/platform-browser/animations';\nimport { AngularFireModule } from 'angularfire2';\nimport { AngularFireDatabaseModule } from 'angularfire2/database';\nimport { DatePipe } from '@angular/common';\n\nimport { AppComponent } from './app.component';\nimport { EmployeesComponent } from './employees/employees.component';\nimport { EmployeeComponent } from './employees/employee/employee.component';\nimport { EmployeeService } from './shared/employee.service';\nimport { environment } from '../environments/environment';\nimport { DepartmentService } from './shared/department.service';\nimport { EmployeeListComponent } from './employees/employee-list/employee-list.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    EmployeesComponent,\n    EmployeeComponent,\n    EmployeeListComponent\n  ],\n  imports: [\n    BrowserModule,\n    MaterialModule,\n    ReactiveFormsModule,\n    BrowserAnimationsModule,\n    AngularFireDatabaseModule,\n    AngularFireModule.initializeApp(environment.firebaseConfig),\n    FormsModule\n  ],\n  providers: [EmployeeService,DepartmentService,DatePipe],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n\n'Angular-Material-Data-Table-Paging-Sorting-Filtering/CompleteAngularMaterialApp/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));\n\n",
        "called_code_segment_file_1": "getDepartmentName($key) {\n    if ($key == \"0\")\n      return \"\";\n    else{\n      return _.find(this.array, (obj) => { return obj.$key == $key; })['name'];\n    }\n  }",
        "invoking_code_segment_file_2": "let departmentName = this.departmentService.getDepartmentName(item.payload.val()['department']);",
        "called_code_segment_file_2": "ngOnInit() {\n    this.service.getEmployees().subscribe(\n      list => {\n        let array = list.map(item => {\n          let departmentName = this.departmentService.getDepartmentName(item.payload.val()['department']);\n          return {\n            $key: item.key,\n            departmentName,\n            ...item.payload.val()\n          };\n        });\n        this.listData = new MatTableDataSource(array);\n        this.listData.sort = this.sort;\n        this.listData.paginator = this.paginator;\n        this.listData.filterPredicate = (data, filter) => {\n          return this.displayedColumns.some(ele => {\n            return ele != 'actions' && data[ele].toLowerCase().indexOf(filter) != -1;\n          });\n        };\n      });\n  }",
        "using_code_segment_file_3": "constructor(private service: EmployeeService,\n    private departmentService: DepartmentService) { }",
        "called_code_segment_file_3": "N/A",
        "using_code_segment_file_4": "N/A",
        "feature_description": "Add a new feature to cache department names to improve performance by reducing redundant calls to the database.",
        "detailed_feature_description": "The new feature involves caching department names in the DepartmentService to avoid redundant calls to the database. This will be achieved by modifying the getDepartmentName method in DepartmentService to first check a cache before querying the database. The EmployeeListComponent will be updated to handle this change, and any related code segments in EmployeeService will be updated accordingly.",
        "modified_complete_code": {
            "DepartmentService.ts": "//Modify\ngetDepartmentName($key) {\n    if ($key == \"0\")\n      return \"\";\n    else if (this.departmentCache[$key]) {\n      return this.departmentCache[$key];\n    } else {\n      let department = _.find(this.array, (obj) => { return obj.$key == $key; });\n      this.departmentCache[$key] = department['name'];\n      return department['name'];\n    }\n  }\n\n//New\nprivate departmentCache = {};",
            "EmployeeListComponent.ts": "//Modify\nngOnInit() {\n    this.service.getEmployees().subscribe(\n      list => {\n        let array = list.map(item => {\n          let departmentName = this.departmentService.getDepartmentName(item.payload.val()['department']);\n          return {\n            $key: item.key,\n            departmentName,\n            ...item.payload.val()\n          };\n        });\n        this.listData = new MatTableDataSource(array);\n        this.listData.sort = this.sort;\n        this.listData.paginator = this.paginator;\n        this.listData.filterPredicate = (data, filter) => {\n          return this.displayedColumns.some(ele => {\n            return ele != 'actions' && data[ele].toLowerCase().indexOf(filter) != -1;\n          });\n        };\n      });\n  }",
            "EmployeeService.ts": "//No modifications needed",
            "AppModule.ts": "//No modifications needed"
        }
    },
    {
        "repo": "akello",
        "content": "'akello/microservices/auth_service/app/src/config.tsx'\n:import EmailPassword from \"supertokens-auth-react/recipe/emailpassword\";\nimport ThirdParty from \"supertokens-auth-react/recipe/thirdparty\";\nimport Passwordless, { PasswordlessComponentsOverrideProvider } from \"supertokens-auth-react/recipe/passwordless\";\nimport { EmailPasswordPreBuiltUI } from \"supertokens-auth-react/recipe/emailpassword/prebuiltui\";\nimport { ThirdPartyPreBuiltUI } from \"supertokens-auth-react/recipe/thirdparty/prebuiltui\";\nimport { PasswordlessPreBuiltUI } from \"supertokens-auth-react/recipe/passwordless/prebuiltui\";\nimport Session from \"supertokens-auth-react/recipe/session\";\nimport React from \"react\";\n\nexport function getApiDomain() {\n    const apiPort = process.env.REACT_APP_API_PORT || 3001;\n    const apiUrl = process.env.REACT_APP_API_URL || `http://localhost:${apiPort}`;\n    return apiUrl;\n}\n\nexport function getWebsiteDomain() {\n    const websitePort = process.env.REACT_APP_WEBSITE_PORT || 3000;\n    const websiteUrl = process.env.REACT_APP_WEBSITE_URL || `http://localhost:${websitePort}`;\n    return websiteUrl;\n}\n\nexport const SuperTokensConfig = {\n    appInfo: {\n        appName: \"SuperTokens Demo App\",\n        apiDomain: getApiDomain(),\n        websiteDomain: getWebsiteDomain(),\n    },\n    // recipeList contains all the modules that you want to\n    // use from SuperTokens. See the full list here: https://supertokens.com/docs/guides\n    recipeList: [\n        EmailPassword.init(),\n        ThirdParty.init({\n            signInAndUpFeature: {\n                providers: [\n                    ThirdParty.Github.init(),\n                    ThirdParty.Google.init(),\n                    ThirdParty.Apple.init(),\n                    ThirdParty.Twitter.init(),\n                ],\n            },\n        }),\n        Passwordless.init({\n            contactMethod: \"EMAIL_OR_PHONE\",\n        }),\n        Session.init(),\n    ],\n};\n\nexport const recipeDetails = {\n    docsLink: \"https://supertokens.com/docs/thirdpartypasswordless/introduction\",\n};\n\nexport const PreBuiltUIList = [EmailPasswordPreBuiltUI, ThirdPartyPreBuiltUI, PasswordlessPreBuiltUI];\n\nexport const ComponentWrapper = (props: { children: JSX.Element }): JSX.Element => {\n    return (\n        <PasswordlessComponentsOverrideProvider\n            components={{\n                PasswordlessUserInputCodeFormFooter_Override: ({ DefaultComponent, ...props }) => {\n                    const loginAttemptInfo = props.loginAttemptInfo;\n                    let showQuotaMessage = false;\n\n                    if (loginAttemptInfo.contactMethod === \"PHONE\") {\n                        showQuotaMessage = true;\n                    }\n\n                    return (\n                        <div\n                            style={{\n                                width: \"100%\",\n                            }}\n                        >\n                            <DefaultComponent {...props} />\n                            {showQuotaMessage && (\n                                <div\n                                    style={{\n                                        width: \"100%\",\n                                        paddingLeft: 12,\n                                        paddingRight: 12,\n                                        paddingTop: 6,\n                                        paddingBottom: 6,\n                                        borderRadius: 4,\n                                        backgroundColor: \"#EF9A9A\",\n                                        margin: 0,\n                                        boxSizing: \"border-box\",\n                                        MozBoxSizing: \"border-box\",\n                                        WebkitBoxSizing: \"border-box\",\n                                        fontSize: 12,\n                                        textAlign: \"start\",\n                                        fontWeight: \"bold\",\n                                        lineHeight: \"18px\",\n                                    }}\n                                >\n                                    There is a daily quota for the free SMS service, if you do not receive the SMS\n                                    please try again tomorrow.\n                                </div>\n                            )}\n                        </div>\n                    );\n                },\n            }}\n        >\n            {props.children}\n        </PasswordlessComponentsOverrideProvider>\n    );\n};\n\n'akello/microservices/auth_service/app/src/Home/CallAPIView.tsx'\n:import axios from \"axios\";\nimport { getApiDomain } from \"../config\";\n\nexport default function CallAPIView() {\n    async function callAPIClicked() {\n        let response = await axios.get(getApiDomain() + \"/sessioninfo\");\n        window.alert(\"Session Information:\\n\" + JSON.stringify(response.data, null, 2));\n    }\n\n    return (\n        <div onClick={callAPIClicked} className=\"sessionButton\">\n            Call API\n        </div>\n    );\n}\n\n'akello/microservices/auth_service/app/src/Home/SuccessView.tsx'\n:import { useNavigate } from \"react-router-dom\";\nimport { signOut } from \"supertokens-auth-react/recipe/session\";\nimport { recipeDetails } from \"../config\";\nimport CallAPIView from \"./CallAPIView\";\nimport { BlogsIcon, CelebrateIcon, GuideIcon, SeparatorLine, SignOutIcon } from \"../assets/images\";\n\ninterface ILink {\n    name: string;\n    onClick: () => void;\n    icon: string;\n}\n\nexport default function SuccessView(props: { userId: string }) {\n    let userId = props.userId;\n\n    const navigate = useNavigate();\n\n    async function logoutClicked() {\n        await signOut();\n        navigate(\"/auth\");\n    }\n\n    function openLink(url: string) {\n        window.open(url, \"_blank\");\n    }\n\n    const links: ILink[] = [\n        {\n            name: \"Blogs\",\n            onClick: () => openLink(\"https://supertokens.com/blog\"),\n            icon: BlogsIcon,\n        },\n        {\n            name: \"Documentation\",\n            onClick: () => openLink(recipeDetails.docsLink),\n            icon: GuideIcon,\n        },\n        {\n            name: \"Sign Out\",\n            onClick: logoutClicked,\n            icon: SignOutIcon,\n        },\n    ];\n\n    return (\n        <>\n            <div className=\"main-container\">\n                <div className=\"top-band success-title bold-500\">\n                    <img src={CelebrateIcon} alt=\"Login successful\" className=\"success-icon\" /> Login successful\n                </div>\n                <div className=\"inner-content\">\n                    <div>Your userID is:</div>\n                    <div className=\"truncate\" id=\"user-id\">\n                        {userId}\n                    </div>\n                    <CallAPIView />\n                </div>\n            </div>\n            <div className=\"bottom-links-container\">\n                {links.map((link) => (\n                    <div className=\"link\" key={link.name}>\n                        <img className=\"link-icon\" src={link.icon} alt={link.name} />\n                        <div role={\"button\"} onClick={link.onClick}>\n                            {link.name}\n                        </div>\n                    </div>\n                ))}\n            </div>\n            <img className=\"separator-line\" src={SeparatorLine} alt=\"separator\" />\n        </>\n    );\n}\n\n'akello/microservices/auth_service/app/src/Home/index.tsx'\n:import SuccessView from \"./SuccessView\";\nimport { useSessionContext } from \"supertokens-auth-react/recipe/session\";\nimport \"./Home.css\";\n\nexport default function Home() {\n    const sessionContext = useSessionContext();\n\n    if (sessionContext.loading === true) {\n        return null;\n    }\n\n    return (\n        <div className=\"fill\" id=\"home-container\">\n            <SuccessView userId={sessionContext.userId} />\n        </div>\n    );\n}\n\n",
        "called_code_segment_file_1": "export function getApiDomain() {\n    const apiPort = process.env.REACT_APP_API_PORT || 3001;\n    const apiUrl = process.env.REACT_APP_API_URL || `http://localhost:${apiPort}`;\n    return apiUrl;\n}",
        "invoking_code_segment_file_2": "async function callAPIClicked() {\n    let response = await axios.get(getApiDomain() + \"/sessioninfo\");\n    window.alert(\"Session Information:\\n\" + JSON.stringify(response.data, null, 2));\n}",
        "called_code_segment_file_2": "async function callAPIClicked() {\n    let response = await axios.get(getApiDomain() + \"/sessioninfo\");\n    window.alert(\"Session Information:\\n\" + JSON.stringify(response.data, null, 2));\n}",
        "using_code_segment_file_3": "export default function Home() {\n    const sessionContext = useSessionContext();\n\n    if (sessionContext.loading === true) {\n        return null;\n    }\n\n    return (\n        <div className=\"fill\" id=\"home-container\">\n            <SuccessView userId={sessionContext.userId} />\n        </div>\n    );\n}",
        "called_code_segment_file_3": "export default function Home() {\n    const sessionContext = useSessionContext();\n\n    if (sessionContext.loading === true) {\n        return null;\n    }\n\n    return (\n        <div className=\"fill\" id=\"home-container\">\n            <SuccessView userId={sessionContext.userId} />\n        </div>\n    );\n}",
        "using_code_segment_file_4": "export default function SuccessView(props: { userId: string }) {\n    let userId = props.userId;\n\n    const navigate = useNavigate();\n\n    async function logoutClicked() {\n        await signOut();\n        navigate(\"/auth\");\n    }\n\n    function openLink(url: string) {\n        window.open(url, \"_blank\");\n    }\n\n    const links: ILink[] = [\n        {\n            name: \"Blogs\",\n            onClick: () => openLink(\"https://supertokens.com/blog\"),\n            icon: BlogsIcon,\n        },\n        {\n            name: \"Documentation\",\n            onClick: () => openLink(recipeDetails.docsLink),\n            icon: GuideIcon,\n        },\n        {\n            name: \"Sign Out\",\n            onClick: logoutClicked,\n            icon: SignOutIcon,\n        },\n    ];\n\n    return (\n        <>\n            <div className=\"main-container\">\n                <div className=\"top-band success-title bold-500\">\n                    <img src={CelebrateIcon} alt=\"Login successful\" className=\"success-icon\" /> Login successful\n                </div>\n                <div className=\"inner-content\">\n                    <div>Your userID is:</div>\n                    <div className=\"truncate\" id=\"user-id\">\n                        {userId}\n                    </div>\n                    <CallAPIView />\n                </div>\n            </div>\n            <div className=\"bottom-links-container\">\n                {links.map((link) => (\n                    <div className=\"link\" key={link.name}>\n                        <img className=\"link-icon\" src={link.icon} alt={link.name} />\n                        <div role={\"button\"} onClick={link.onClick}>\n                            {link.name}\n                        </div>\n                    </div>\n                ))}\n            </div>\n            <img className=\"separator-line\" src={SeparatorLine} alt=\"separator\" />\n        </>\n    );\n}",
        "feature_description": "Add a feature to display the user's email address along with the userID in the SuccessView component.",
        "detailed_feature_description": "The new feature involves modifying the SuccessView component to fetch and display the user's email address along with the userID. This requires updating the callAPIClicked function in CallAPIView to fetch additional user information and then passing this information to the SuccessView component.",
        "modified_complete_code": {
            "file_1": "export function getApiDomain() {\n    const apiPort = process.env.REACT_APP_API_PORT || 3001;\n    const apiUrl = process.env.REACT_APP_API_URL || `http://localhost:${apiPort}`;\n    return apiUrl;\n}",
            "file_2": "import axios from \"axios\";\nimport { getApiDomain } from \"../config\";\n\nexport default function CallAPIView() {\n    async function callAPIClicked() {\n        let response = await axios.get(getApiDomain() + \"/sessioninfo\");\n        let userInfo = response.data;\n        window.alert(\"Session Information:\\n\" + JSON.stringify(userInfo, null, 2));\n        return userInfo; // #Modify\n    }\n\n    return (\n        <div onClick={callAPIClicked} className=\"sessionButton\">\n            Call API\n        </div>\n    );\n}",
            "file_3": "import SuccessView from \"./SuccessView\";\nimport { useSessionContext } from \"supertokens-auth-react/recipe/session\";\nimport \"./Home.css\";\n\nexport default function Home() {\n    const sessionContext = useSessionContext();\n\n    if (sessionContext.loading === true) {\n        return null;\n    }\n\n    return (\n        <div className=\"fill\" id=\"home-container\">\n            <SuccessView userId={sessionContext.userId} />\n        </div>\n    );\n}",
            "file_4": "import { useNavigate } from \"react-router-dom\";\nimport { signOut } from \"supertokens-auth-react/recipe/session\";\nimport { recipeDetails } from \"../config\";\nimport CallAPIView from \"./CallAPIView\";\nimport { BlogsIcon, CelebrateIcon, GuideIcon, SeparatorLine, SignOutIcon } from \"../assets/images\";\n\ninterface ILink {\n    name: string;\n    onClick: () => void;\n    icon: string;\n}\n\nexport default function SuccessView(props: { userId: string }) {\n    let userId = props.userId;\n\n    const navigate = useNavigate();\n\n    async function logoutClicked() {\n        await signOut();\n        navigate(\"/auth\");\n    }\n\n    function openLink(url: string) {\n        window.open(url, \"_blank\");\n    }\n\n    const links: ILink[] = [\n        {\n            name: \"Blogs\",\n            onClick: () => openLink(\"https://supertokens.com/blog\"),\n            icon: BlogsIcon,\n        },\n        {\n            name: \"Documentation\",\n            onClick: () => openLink(recipeDetails.docsLink),\n            icon: GuideIcon,\n        },\n        {\n            name: \"Sign Out\",\n            onClick: logoutClicked,\n            icon: SignOutIcon,\n        },\n    ];\n\n    return (\n        <>\n            <div className=\"main-container\">\n                <div className=\"top-band success-title bold-500\">\n                    <img src={CelebrateIcon} alt=\"Login successful\" className=\"success-icon\" /> Login successful\n                </div>\n                <div className=\"inner-content\">\n                    <div>Your userID is:</div>\n                    <div className=\"truncate\" id=\"user-id\">\n                        {userId}\n                    </div>\n                    <div>Your email is:</div>\n                    <div className=\"truncate\" id=\"user-email\">\n                        {userInfo.email} // #New\n                    </div>\n                    <CallAPIView />\n                </div>\n            </div>\n            <div className=\"bottom-links-container\">\n                {links.map((link) => (\n                    <div className=\"link\" key={link.name}>\n                        <img className=\"link-icon\" src={link.icon} alt={link.name} />\n                        <div role={\"button\"} onClick={link.onClick}>\n                            {link.name}\n                        </div>\n                    </div>\n                ))}\n            </div>\n            <img className=\"separator-line\" src={SeparatorLine} alt=\"separator\" />\n        </>\n    );\n}"
        }
    },
    {
        "repo": "3mail",
        "content": "'3mail/frontend/src/contexts/State.ts'\n:import { TileDocument } from '@ceramicnetwork/stream-tile';\nimport { useCallback, useEffect, useReducer } from 'react';\nimport { useCeramic } from './Ceramic';\nimport { useOrbitDb } from './OrbitDB';\n\ntype AuthStatus = 'pending' | 'loading' | 'failed';\nexport type DraftStatus = 'unsaved' | 'saving' | 'failed' | 'saved';\n// type MessageLoadingStatus = 'init' | 'loading' | 'loading failed';\ntype MessageSavingStatus = 'loaded' | 'saving' | 'saving failed' | 'saved';\n\ntype UnauthenticatedState = { status: AuthStatus };\ntype AuthenticatedState = { status: 'done' };\nexport type AuthState = UnauthenticatedState | AuthenticatedState;\n\ntype NavDefaultState = { type: 'default' };\ntype NavDraftState = { type: 'draft' };\n\nexport type NavMessageState = {\n  type: 'message';\n  docID: string;\n  message?: StoredMessage;\n};\ntype NavMailboxState = { type: 'mailbox' };\ntype NavComposeState = { type: 'compose' };\n\nexport type StoredMessage = {\n  id: string;\n  date: number;\n  sender: string;\n  status: MessageSavingStatus;\n  subject: string;\n  content: string;\n};\n\ntype Store = {\n  searchResults: StoredMessage[];\n  messages: StoredMessage[];\n};\ntype DefaultState = {\n  auth: AuthState;\n  nav: NavDefaultState;\n};\ntype MessageState = {\n  auth: AuthenticatedState;\n  nav: NavDraftState | NavMessageState | NavMailboxState | NavComposeState;\n};\nexport type State = Store & (DefaultState | MessageState);\n\ntype AuthAction = { type: 'auth'; status: AuthStatus };\ntype AuthLogoutAction = { type: 'auth logout' };\ntype AuthSuccessAction = { type: 'auth success';};\ntype NavMailboxAction = { type: 'nav mailbox'; };\ntype NavMessageAction = { type: 'nav message'; docID: string };\ntype NavComposeAction = { type: 'nav compose' };\ntype MessageLoadedAction = { type: 'message loaded'; message: StoredMessage };\ntype SearchLoadingAction = { type: 'search loading' };\ntype SearchLoadedAction = { type: 'search loaded'; results: StoredMessage[] };\ntype SearchClearedAction = { type: 'search cleared' };\ntype AddMessageAction = { type: 'message added'; message: StoredMessage };\ntype Action =\n  | AuthAction\n  | AuthLogoutAction\n  | AuthSuccessAction\n  | NavComposeAction\n  | NavMailboxAction\n  | NavMessageAction\n  | MessageLoadedAction\n  | SearchLoadingAction\n  | SearchLoadedAction\n  | SearchClearedAction\n  | AddMessageAction;\n\n// for (let mockIndex = 0; mockIndex < 100; mockIndex++) {\n//   tempDb.push({\n//     date: currentDateInMs + 1000 * 60 * 60 * mockIndex,\n//     status: 'loaded',\n//     id: mockIndex.toString(),\n//     sender: `${loremIpsum({ count: 1, units: 'word' })}.eth`,\n//     subject: loremIpsum(),\n//     content: loremIpsum({ count: 1, units: 'paragraphs' }),\n//   });\n// }\n\nfunction reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'auth':\n      return {\n        ...state,\n        nav: { type: 'default' },\n        auth: { status: action.status },\n      };\n    case 'auth logout': {\n      return {\n        searchResults: [],\n        auth: { status: 'pending' },\n        nav: { type: 'default' },\n        messages: [],\n      };\n    }\n    case 'nav mailbox': {\n      return {\n        ...state,\n        auth: state.auth as AuthenticatedState,\n        nav: { type: 'mailbox' },\n        messages: [...state.messages],\n      };\n    }\n\n    case 'auth success': {\n      const auth = {\n        status: 'done',\n      } as AuthenticatedState;\n      return {\n        searchResults: [],\n        auth,\n        nav: { type: 'mailbox' },\n        messages: [...state.messages],\n      };\n    }\n    case 'nav message':\n      return {\n        ...state,\n        auth: state.auth as AuthenticatedState,\n        nav: {\n          type: 'message',\n          docID: action.docID,\n        },\n      };\n    case 'nav compose':\n      return {\n        ...state,\n        auth: state.auth as AuthenticatedState,\n        nav: {\n          type: 'compose',\n        },\n      };\n    case 'message loaded':\n      return {\n        ...state,\n        auth: state.auth as AuthenticatedState,\n        nav: {\n          ...(state.nav as NavMessageState),\n          message: action.message,\n        },\n      };\n    case 'search loading':\n      return {\n        ...state,\n        auth: state.auth as AuthenticatedState,\n      };\n    case 'search loaded':\n      return {\n        ...state,\n        auth: state.auth as AuthenticatedState,\n        searchResults: action.results,\n      };\n    case 'search cleared': {\n      return {\n        ...state,\n        auth: state.auth as AuthenticatedState,\n        searchResults: [],\n      };\n    }\n    case 'message added': {\n      return {\n        ...state,\n        auth: state.auth as AuthenticatedState,\n        messages: [action.message, ...state.messages],\n      };\n    }\n  }\n\n  return state;\n}\n\nexport function useApp() {\n  const [state, dispatch] = useReducer(reducer, {\n    auth: { status: 'pending' },\n    searchResults: [],\n    nav: { type: 'default' },\n    messages: [],\n  });\n\n  const { ceramic, did, logout: doLogout } = useCeramic();\n  const { odb, db, setDbName } = useOrbitDb();\n\n  const addMessage = useCallback((message: StoredMessage) => {\n    dispatch({ type: 'message added', message });\n  }, []);\n\n  useEffect(() => {\n    if (did) {\n      setDbName(did.id)\n    }\n  },[setDbName, did]);\n\n  const convertMessage = useCallback((latest: string) => {\n    if (!ceramic) return;\n    (async () => {\n      const doc = await TileDocument.load(ceramic, latest  );\n      const content: {\n        date: string;\n        message: string;\n        subject: string;\n      } = doc.content as any;\n\n      const latestMessage: StoredMessage = {\n        id: doc.id.toString(),\n        date: (new Date(content.date)).getTime(),\n        content: content.message,\n        sender: doc.controllers[0],\n        subject: content.subject,\n        status: 'loaded'\n      }\n      addMessage(latestMessage);\n    })();\n  }, [ceramic, addMessage]);\n\n  useEffect(() => {\n    if (!db || !ceramic) return;\n\n    (async () => {\n      const all = db\n      .iterator({ reverse: true, limit: 10 })\n      .collect()\n      .reverse()\n      .map((e: any) => { return e.payload.value.doc});\n      \n      for await (const msg of all) {\n        convertMessage(msg);\n      }\n\n      //todo: this is not working as expected:\n      console.log(\"listening\");\n      db.events.on('replicated', (address: string) => {\n        console.log(\"replicated\");\n        const all = db\n          .iterator({ reverse: true, limit: 3 })\n          .collect()\n          .reverse()\n          .map((e: any) => { return e.payload.value.doc});\n\n        const latest = all[0];\n        convertMessage(latest);\n      });     \n    \n    })();\n  }, [db, ceramic, convertMessage]);\n\n  const startAuth = useCallback(() => {\n    dispatch({ type: 'auth', status: 'loading' });\n  }, []);\n\n  const authSuccess = useCallback(() => {\n    dispatch({ type: 'auth success' });\n  }, []);\n\n  const openMailbox = useCallback(() => {\n    dispatch({ type: 'nav mailbox' });\n  }, []);\n\n  const openMessage = useCallback((docID: string) => {\n    dispatch({ type: 'nav message', docID });\n    const msg = state.messages.find(m => m.id === docID);\n    dispatch({\n      type: 'message loaded',\n      message: msg!,\n    });\n  }, [state.messages]);\n\n  const logout = useCallback(() => {\n    doLogout();\n    dispatch({ type: 'auth logout' });\n  }, [doLogout]);\n\n  const openCompose = useCallback(() => {\n    dispatch({ type: 'nav compose' });\n  }, []);\n\n  const search = useCallback((query: string) => {\n    if (query.length < 3) return;\n    dispatch({ type: 'search loading' });\n    query = query.toLowerCase();\n\n    const results = state.messages.filter(m => {\n      return m.content.toLocaleLowerCase().indexOf(query) !== -1\n        || m.subject.toLocaleLowerCase().indexOf(query) !== -1\n        || m.sender.toLocaleLowerCase().indexOf(query) !== -1\n    }).slice(0, 10);\n\n    dispatch({ type: 'search loaded', results });\n  }, [state.messages]);\n\n  const clearSearch = useCallback(() => {\n    dispatch({ type: 'search cleared' });\n  }, []);\n\n  return {\n    startAuth,\n    authSuccess,\n    openMessage,\n    openMailbox,\n    openCompose,\n    addMessage,\n    logout,\n    search,\n    clearSearch,\n    state,\n  };\n}\n\n'3mail/frontend/src/components/molecules/Content.tsx'\n:import { ComposeScreen } from 'components/pages/ComposeScreen';\nimport MailboxScreen from 'components/pages/MailboxScreen';\nimport MessageScreen from 'components/pages/MessageScreen';\nimport React from 'react';\nimport { useApp } from '../../contexts/State';\nimport AuthenticateScreen from '../pages/AuthenticateScreen';\nimport { Layout } from './Layout';\n\nconst Content = () => {\n  const app = useApp();\n  switch (app.state.nav.type) {\n    case 'mailbox':\n      return (\n        <Layout\n          logout={app.logout}\n          home={app.openMailbox}\n          compose={app.openCompose}\n          search={app.search}\n          searchClosed={app.clearSearch}\n          searchResults={app.state.searchResults}\n          openMessage={app.openMessage}\n        >\n          <MailboxScreen\n            state={app.state}\n            openMessage={app.openMessage}\n          />\n        </Layout>\n      );\n    case 'message':\n      return (\n        <Layout\n          logout={app.logout}\n          home={app.openMailbox}\n          compose={app.openCompose}\n          search={app.search}\n          searchClosed={app.clearSearch}\n          searchResults={app.state.searchResults}\n          openMessage={app.openMessage}\n        >\n          <MessageScreen closeMessage={app.openMailbox} state={app.state} />\n        </Layout>\n      );\n    case 'compose':\n      return (\n        <Layout\n          logout={app.logout}\n          home={app.openMailbox}\n          compose={app.openCompose}\n          search={app.search}\n          searchClosed={app.clearSearch}\n          searchResults={app.state.searchResults}\n          openMessage={app.openMessage}\n        >\n          <ComposeScreen closeMessage={app.openMailbox} state={app.state} />\n        </Layout>\n      );\n    default:\n      return (\n        <AuthenticateScreen\n          startAuth ={app.startAuth}\n          authSuccess={app.authSuccess}\n          state={app.state.auth}\n        />\n      );\n  }\n};\n\nexport default Content;\n\n'3mail/frontend/src/App.tsx'\n:import { ChakraProvider, CSSReset, Flex } from '@chakra-ui/react';\nimport { CeramicProvider } from 'contexts/Ceramic';\nimport { IPFSProvider } from 'contexts/IPFS';\nimport { OrbitDbProvider } from 'contexts/OrbitDB';\nimport Content from './components/molecules/Content';\nimport customTheme from './theme';\n\n\nfunction App() {\n  return (\n    <ChakraProvider theme={customTheme}>\n      <IPFSProvider remoteNodeUrl={process.env.REACT_APP_LOCAL_IPFS}>\n        <OrbitDbProvider>\n          <CeramicProvider>\n            <CSSReset />\n            <Flex direction=\"column\" height=\"100vh\">\n              <Content />\n            </Flex>\n          </CeramicProvider>\n        </OrbitDbProvider>\n      </IPFSProvider>\n    </ChakraProvider>\n  );\n}\n\nexport default App;\n\n'3mail/frontend/src/index.tsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n",
        "called_code_segment_file_1": "const convertMessage = useCallback((latest: string) => {\n    if (!ceramic) return;\n    (async () => {\n      const doc = await TileDocument.load(ceramic, latest  );\n      const content: { date: string; message: string; subject: string; } = doc.content as any;\n      const latestMessage: StoredMessage = {\n        id: doc.id.toString(),\n        date: (new Date(content.date)).getTime(),\n        content: content.message,\n        sender: doc.controllers[0],\n        subject: content.subject,\n        status: 'loaded'\n      }\n      addMessage(latestMessage);\n    })();\n  }, [ceramic, addMessage]);",
        "invoking_code_segment_file_2": "useEffect(() => {\n    if (!db || !ceramic) return;\n    (async () => {\n      const all = db\n      .iterator({ reverse: true, limit: 10 })\n      .collect()\n      .reverse()\n      .map((e: any) => { return e.payload.value.doc});\n      for await (const msg of all) {\n        convertMessage(msg);\n      }\n      db.events.on('replicated', (address: string) => {\n        const all = db\n          .iterator({ reverse: true, limit: 3 })\n          .collect()\n          .reverse()\n          .map((e: any) => { return e.payload.value.doc});\n        const latest = all[0];\n        convertMessage(latest);\n      });     \n    })();\n  }, [db, ceramic, convertMessage]);",
        "called_code_segment_file_2": "const openMessage = useCallback((docID: string) => {\n    dispatch({ type: 'nav message', docID });\n    const msg = state.messages.find(m => m.id === docID);\n    dispatch({ type: 'message loaded', message: msg! });\n  }, [state.messages]);",
        "using_code_segment_file_3": "case 'message':\n      return (\n        <Layout\n          logout={app.logout}\n          home={app.openMailbox}\n          compose={app.openCompose}\n          search={app.search}\n          searchClosed={app.clearSearch}\n          searchResults={app.state.searchResults}\n          openMessage={app.openMessage}\n        >\n          <MessageScreen closeMessage={app.openMailbox} state={app.state} />\n        </Layout>\n      );",
        "called_code_segment_file_3": "const openMessage = useCallback((docID: string) => {\n    dispatch({ type: 'nav message', docID });\n    const msg = state.messages.find(m => m.id === docID);\n    dispatch({ type: 'message loaded', message: msg! });\n  }, [state.messages]);",
        "using_code_segment_file_4": "const MessageScreen = ({ closeMessage, state }: { closeMessage: () => void; state: State }) => {\n  const message = state.nav.message;\n  return (\n    <Box p={4} bg=\"gray.50\" borderRadius=\"md\">\n      <Button onClick={closeMessage} colorScheme=\"blue\" mb={4}>Back</Button>\n      <Heading size=\"md\" mb={2}>{message?.subject}</Heading>\n      <Text fontSize=\"sm\" color=\"gray.600\" mb={4}>From: {message?.sender}</Text>\n      <Text>{message?.content}</Text>\n    </Box>\n  );\n};",
        "feature_description": "Add a feature to allow users to mark messages as read or unread.",
        "detailed_feature_description": "The new feature will allow users to toggle the read status of a message. This will involve modifying the `convertMessage` function in #file 1 to include a `read` property in the `StoredMessage` object. The `openMessage` function in #file 2 will be updated to toggle the read status when a message is opened. The `MessageScreen` component in #file 4 will display the read status and allow users to toggle it.",
        "modified_complete_code": {
            "#file 1": "const convertMessage = useCallback((latest: string) => {\n    if (!ceramic) return;\n    (async () => {\n      const doc = await TileDocument.load(ceramic, latest  );\n      const content: { date: string; message: string; subject: string; } = doc.content as any;\n      const latestMessage: StoredMessage = {\n        id: doc.id.toString(),\n        date: (new Date(content.date)).getTime(),\n        content: content.message,\n        sender: doc.controllers[0],\n        subject: content.subject,\n        status: 'loaded',\n        read: false #Modify\n      }\n      addMessage(latestMessage);\n    })();\n  }, [ceramic, addMessage]);",
            "#file 2": "const openMessage = useCallback((docID: string) => {\n    dispatch({ type: 'nav message', docID });\n    const msg = state.messages.find(m => m.id === docID);\n    if (msg) {\n      msg.read = !msg.read; #Modify\n    }\n    dispatch({ type: 'message loaded', message: msg! });\n  }, [state.messages]);",
            "#file 3": "case 'message':\n      return (\n        <Layout\n          logout={app.logout}\n          home={app.openMailbox}\n          compose={app.openCompose}\n          search={app.search}\n          searchClosed={app.clearSearch}\n          searchResults={app.state.searchResults}\n          openMessage={app.openMessage}\n        >\n          <MessageScreen closeMessage={app.openMailbox} state={app.state} />\n        </Layout>\n      );",
            "#file 4": "const MessageScreen = ({ closeMessage, state }: { closeMessage: () => void; state: State }) => {\n  const message = state.nav.message;\n  return (\n    <Box p={4} bg=\"gray.50\" borderRadius=\"md\">\n      <Button onClick={closeMessage} colorScheme=\"blue\" mb={4}>Back</Button>\n      <Heading size=\"md\" mb={2}>{message?.subject}</Heading>\n      <Text fontSize=\"sm\" color=\"gray.600\" mb={4}>From: {message?.sender}</Text>\n      <Text>{message?.content}</Text>\n      <Button onClick={() => message.read = !message.read} colorScheme=\"green\" mt={4}>{message?.read ? 'Mark as Unread' : 'Mark as Read'}</Button> #New\n    </Box>\n  );\n};"
        }
    },
    {
        "repo": "cover-letter-snippets",
        "content": "'cover-letter-snippets/snippets/src/app/services/status-message.service.ts'\n:import { Injectable } from '@angular/core';\nimport { Observable, BehaviorSubject } from 'rxjs';\n\n@Injectable()\nexport class StatusMessageService {\n\n  statusMessageStream: BehaviorSubject<any> = new BehaviorSubject(undefined);\n\n  constructor() { }\n\n  getStatusMessageStream() {\n    return this.statusMessageStream.asObservable();\n  }\n\n  newStatusMessage(status, cssClass) {\n    this.statusMessageStream.next({\n      status: status,\n      cssClass: cssClass\n    });\n  }\n\n  clearStatus() {\n    this.statusMessageStream.next({\n      status: '',\n      cssClass: ''\n    });\n  }\n\n}\n\n'cover-letter-snippets/snippets/src/app/job-description/job-description.component.ts'\n:import { Component, OnInit } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport { ParseDescriptionService } from '../services/parse-description.service';\nimport { StatusMessageService } from '../services/status-message.service';\n\n@Component({\n  selector: 'app-job-description',\n  templateUrl: './job-description.component.html',\n  styleUrls: ['./job-description.component.css']\n})\nexport class JobDescriptionComponent implements OnInit {\n\n  descriptionContent:string;\n\n  constructor(\n    private parseDescriptionService:ParseDescriptionService,\n    private statusMessageService:StatusMessageService\n  ) { }\n\n  ngOnInit() {\n\n  }\n\n  submitDescription(description):void {\n    this.parseDescriptionService.parseDescription(description);\n  }\n\n  enterNewDescription():void {\n    this.descriptionContent = \"\";\n    this.parseDescriptionService.showParsingResults = false;\n    this.statusMessageService.newStatusMessage(\"Resetting Job Description\", \"warning\");\n  }\n\n}\n\n'cover-letter-snippets/snippets/src/app/app.module.ts'\n:import { BrowserModule } from '@angular/platform-browser';\nimport { NgModule } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\nimport { HttpClientModule } from '@angular/common/http';\n\nimport { AppComponent } from './app.component';\nimport { RouterModule, Routes } from '@angular/router';\n\nimport { JobDescriptionComponent } from './job-description/job-description.component';\nimport { DatabaseComponent } from './database/database.component';\nimport { CategoryAliasesDatabaseComponent } from './category-aliases-db/category-aliases-db.component';\nimport { ResultsComponent } from './results/results.component';\nimport { AddSnippetComponent } from './add-snippet/add-snippet.component';\nimport { StatusMessageComponent } from './status-message/status-message.component';\nimport { HasKeywordsPipe } from './has-keywords.pipe';\nimport { CoverLetterComponent } from './cover-letter/cover-letter.component';\nimport { BuildCoverLetterComponent } from './build-cover-letter/build-cover-letter.component';\nimport { ExportComponent } from './export/export.component';\nimport { NavComponent } from './nav/nav.component';\n\nimport { DatabaseService } from './services/database.service';\nimport { DatabaseCategoryAliasesService } from './services/databaseCategoryAliases.service';\nimport { ParseDescriptionService } from './services/parse-description.service';\nimport { StatusMessageService } from './services/status-message.service';\nimport { CoverLetterService } from './services/cover-letter.service';\n\nimport { CUSTOM_ELEMENTS_SCHEMA } from '@angular/core';\n\nconst appRoutes: Routes = [\n  { path: '', component: DatabaseComponent },\n  { path: 'add-snippet', component: AddSnippetComponent },\n  { path: 'build-cover-letter', component: BuildCoverLetterComponent },\n  { path: 'export-cover-letter', component: ExportComponent }\n];\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    JobDescriptionComponent,\n    DatabaseComponent,\n    CategoryAliasesDatabaseComponent,\n    ResultsComponent,\n    AddSnippetComponent,\n    StatusMessageComponent,\n    HasKeywordsPipe,\n    CoverLetterComponent,\n    ExportComponent,\n    BuildCoverLetterComponent,\n    NavComponent\n  ],\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n    ),\n    BrowserModule,\n    FormsModule,\n    HttpClientModule\n  ],\n  providers: [\n    DatabaseService,\n    DatabaseCategoryAliasesService,\n    ParseDescriptionService,\n    StatusMessageService,\n    CoverLetterService,\n  ],\n  bootstrap: [AppComponent],\n  schemas: [\n    CUSTOM_ELEMENTS_SCHEMA\n  ]\n})\nexport class AppModule { }\n\n'cover-letter-snippets/snippets/src/main.ts'\n:import { enableProdMode } from '@angular/core';\nimport { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  enableProdMode();\n}\n\nplatformBrowserDynamic().bootstrapModule(AppModule)\n  .catch(err => console.log(err));\n\n",
        "called_code_segment_file_1": "newStatusMessage(status, cssClass) {\n    this.statusMessageStream.next({\n      status: status,\n      cssClass: cssClass\n    });\n  }",
        "invoking_code_segment_file_2": "enterNewDescription():void {\n    this.descriptionContent = \"\";\n    this.parseDescriptionService.showParsingResults = false;\n    this.statusMessageService.newStatusMessage(\"Resetting Job Description\", \"warning\");\n  }",
        "called_code_segment_file_2": "getStatusMessageStream() {\n    return this.statusMessageStream.asObservable();\n  }",
        "using_code_segment_file_3": "ngOnInit() {\n    this.statusMessageService.getStatusMessageStream().subscribe(data => {\n      this.statusMessage = data.status;\n      this.cssClass = data.cssClass;\n    });\n  }",
        "called_code_segment_file_3": "getStatusMessageStream() {\n    return this.statusMessageStream.asObservable();\n  }",
        "using_code_segment_file_4": "ngOnInit() {\n    this.statusMessageService.getStatusMessageStream().subscribe(data => {\n      this.statusMessage = data.status;\n      this.cssClass = data.cssClass;\n    });\n  }",
        "feature_description": "Add a feature to allow the StatusMessageService to handle multiple status messages simultaneously.",
        "detailed_feature_description": "The new feature modifies the StatusMessageService to handle multiple status messages by storing them in an array. The newStatusMessage method is updated to push new messages into this array. The getStatusMessageStream method is modified to emit the entire array of messages. The JobDescriptionComponent, StatusMessageComponent, and other components that use the StatusMessageService are updated to handle the array of messages instead of a single message.",
        "modified_complete_code": {
            "file_1": "// src/app/services/status-message.service.ts\n:import { Injectable } from '@angular/core';\nimport { Observable, BehaviorSubject } from 'rxjs';\n\n@Injectable()\nexport class StatusMessageService {\n\n  statusMessageStream: BehaviorSubject<any> = new BehaviorSubject([]);\n\n  constructor() { }\n\n  getStatusMessageStream() {\n    return this.statusMessageStream.asObservable();\n  }\n\n  newStatusMessage(status, cssClass) {\n    const currentMessages = this.statusMessageStream.value;\n    currentMessages.push({ status, cssClass });\n    this.statusMessageStream.next(currentMessages);\n  }\n\n  clearStatus() {\n    this.statusMessageStream.next([]);\n  }\n\n}",
            "file_2": "// src/app/job-description/job-description.component.ts\n:import { Component, OnInit } from '@angular/core';\nimport { FormsModule } from '@angular/forms';\n\nimport { ParseDescriptionService } from '../services/parse-description.service';\nimport { StatusMessageService } from '../services/status-message.service';\n\n@Component({\n  selector: 'app-job-description',\n  templateUrl: './job-description.component.html',\n  styleUrls: ['./job-description.component.css']\n})\nexport class JobDescriptionComponent implements OnInit {\n\n  descriptionContent:string;\n\n  constructor(\n    private parseDescriptionService:ParseDescriptionService,\n    private statusMessageService:StatusMessageService\n  ) { }\n\n  ngOnInit() {\n\n  }\n\n  submitDescription(description):void {\n    this.parseDescriptionService.parseDescription(description);\n  }\n\n  enterNewDescription():void {\n    this.descriptionContent = \"\";\n    this.parseDescriptionService.showParsingResults = false;\n    this.statusMessageService.newStatusMessage(\"Resetting Job Description\", \"warning\");\n  }\n\n}",
            "file_3": "// src/app/status-message/status-message.component.ts\n:import { Component, OnInit } from '@angular/core';\nimport { StatusMessageService } from '../services/status-message.service';\n\n@Component({\n  selector: 'app-status-message',\n  templateUrl: './status-message.component.html',\n  styleUrls: ['./status-message.component.css']\n})\nexport class StatusMessageComponent implements OnInit {\n\n  statusMessages: any[] = [];\n\n  constructor(private statusMessageService: StatusMessageService) { }\n\n  ngOnInit() {\n    this.statusMessageService.getStatusMessageStream().subscribe(messages => {\n      this.statusMessages = messages;\n    });\n  }\n\n}",
            "file_4": "// src/app/app.component.ts\n:import { Component, OnInit } from '@angular/core';\nimport { StatusMessageService } from './services/status-message.service';\n\n@Component({\n  selector: 'app-root',\n  templateUrl: './app.component.html',\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent implements OnInit {\n\n  statusMessages: any[] = [];\n\n  constructor(private statusMessageService: StatusMessageService) { }\n\n  ngOnInit() {\n    this.statusMessageService.getStatusMessageStream().subscribe(messages => {\n      this.statusMessages = messages;\n    });\n  }\n\n}"
        }
    },
    {
        "repo": "astro-code-blocks",
        "content": "'astro-code-blocks/src/utils/html-entities.ts'\n:import { unescape as unEsc } from \"html-escaper\";\nexport { escape } from \"html-escaper\";\n\n/** Unescape HTML while catering for `&#x3C;` (`<`) and `'&#x26;'` (`&`), which the Astro compiler outputs. */\nexport function unescape(str: string) {\n  return unEsc(str).replaceAll(\"&#x3C;\", \"<\").replaceAll(\"&#x26;\", \"&\");\n}\n\n'astro-code-blocks/src/utils/shiki-line.ts'\n:import chroma from \"chroma-js\";\nimport { unescape } from \"./html-entities\";\nimport { ensureTextContrast } from \"./color-contrast\";\nimport { MarkerTypeOrder } from \"./types\";\nimport type {\n  InlineMarkingDefinition,\n  InlineToken,\n  InsertionPoint,\n  MarkedRange,\n  MarkerToken,\n  MarkerType,\n} from \"./types\";\n\nexport class ShikiLine {\n  readonly tokens: InlineToken[];\n  readonly textLine: string;\n\n  private beforeClassValue: string;\n  private classes: Set<string>;\n  private afterClassValue: string;\n  private afterTokens: string;\n\n  constructor(highlightedCodeLine: string) {\n    const lineRegExp = /^(<span class=\")(line.*?)(\".*?>)(.*)(<\\/span>)$/;\n    const lineMatches = highlightedCodeLine.match(lineRegExp);\n    if (!lineMatches)\n    throw new Error(\n      `Shiki-highlighted code line HTML did not match expected format. HTML code:\\n${highlightedCodeLine}`\n      );\n      \n      this.beforeClassValue = lineMatches[1];\n      this.classes = new Set(lineMatches[2].split(\" \"));\n      this.afterClassValue = lineMatches[3];\n      const tokensHtml = lineMatches[4];\n      this.afterTokens = lineMatches[5];\n      \n    // Split line into inline tokens, accomodate for hex or css variable colors\n    const tokenRegExp =\n      /<span style=\"color: ?(#[0-9A-Fa-f]+|var\\(--+)([^\"]*)\">(.*?)<\\/span>/g;\n    const tokenMatches = tokensHtml.matchAll(tokenRegExp);\n    this.tokens = [];\n    this.textLine = \"\";\n    for (const tokenMatch of tokenMatches) {\n      const [, color, otherStyles, innerHtml] = tokenMatch;\n      const text = unescape(innerHtml);\n      this.tokens.push({\n        tokenType: \"syntax\",\n        color,\n        otherStyles,\n        innerHtml,\n        text,\n        textStart: this.textLine.length,\n        textEnd: this.textLine.length + text.length,\n      });\n      this.textLine += text;\n    }\n  }\n\n  applyInlineMarkings(inlineMarkings: InlineMarkingDefinition[]) {\n    const markedRanges: MarkedRange[] = [];\n\n    // Go through all definitions, find matches for their text or regExp in textLine,\n    // and fill markedRanges with their capture groups or entire matches\n    inlineMarkings.forEach((inlineMarking) => {\n      const matches = this.getInlineMarkingDefinitionMatches(inlineMarking);\n      markedRanges.push(...matches);\n    });\n\n    if (!markedRanges.length) return;\n\n    // Flatten marked ranges to prevent any overlaps\n    const flattenedRanges = this.flattenMarkedRanges(markedRanges);\n    if (!flattenedRanges.length) return;\n\n    // Build an array of marker elements to insert\n    const markerElements = flattenedRanges.map((range) => {\n      return {\n        markerType: range.markerType,\n        opening: this.textPositionToTokenPosition(range.start),\n        closing: this.textPositionToTokenPosition(range.end),\n      };\n    });\n\n    // Mutate inline tokens in reverse direction (from end to start),\n    // inserting opening and closing marker tokens at the determined positions,\n    // optionally splitting syntax tokens if they only match partially\n    markerElements.reverse().forEach((markerElement) => {\n      const markerToken: MarkerToken = {\n        tokenType: \"marker\",\n        markerType: markerElement.markerType,\n      };\n\n      this.insertMarkerTokenAtPosition(markerElement.closing, {\n        ...markerToken,\n        closing: true,\n      });\n      this.insertMarkerTokenAtPosition(markerElement.opening, markerToken);\n    });\n  }\n\n  ensureTokenColorContrast() {\n    // Ensure proper color contrast of syntax tokens inside marked ranges\n    // (note that only the lightness of the background color is used)\n    const backgroundColor = chroma(\"#2e336b\");\n    const isLineMarked = this.getLineMarkerType() !== undefined;\n    let inInlineMarker = false;\n    this.tokens.forEach((token) => {\n      if (token.tokenType === \"marker\") {\n        inInlineMarker = !token.closing;\n        return;\n      }\n      if (inInlineMarker || isLineMarked) {\n        const tokenColor = chroma(token.color);\n        const fixedTokenColor = ensureTextContrast(tokenColor, backgroundColor);\n        token.color = fixedTokenColor.hex();\n      }\n    });\n  }\n\n  renderToHtml() {\n    const classValue = [...this.classes].join(\" \");\n\n    // Build the line's inner HTML code by rendering all contained tokens\n    let innerHtml = this.tokens\n      .map((token) => {\n        if (token.tokenType === \"marker\")\n          return `<${token.closing ? \"/\" : \"\"}${token.markerType}>`;\n        return `<span style=\"color:${token.color}${token.otherStyles}\">${token.innerHtml}</span>`;\n      })\n      .join(\"\");\n\n    // Browsers don't seem render the background color of completely empty lines,\n    // so if the rendered inner HTML code is empty and we want to mark the line,\n    // we need to add some content to make the background color visible.\n    // To keep the copy & paste result unchanged at the same time, we add an empty span\n    // and attach a CSS class that displays a space inside a ::before pseudo-element.\n    if (!innerHtml && this.getLineMarkerType() !== undefined)\n      innerHtml = '<span class=\"empty\"></span>';\n\n    return `${this.beforeClassValue}${classValue}${this.afterClassValue}${innerHtml}${this.afterTokens}`;\n  }\n\n  getLineMarkerType(): MarkerType {\n    return MarkerTypeOrder.find(\n      (markerType) => markerType && this.classes.has(markerType.toString())\n    );\n  }\n\n  setLineMarkerType(newType: MarkerType) {\n    // Remove all existing marker type classes (if any)\n    MarkerTypeOrder.forEach(\n      (markerType) => markerType && this.classes.delete(markerType.toString())\n    );\n\n    if (newType === undefined) return;\n    this.classes.add(newType.toString());\n  }\n\n  private getInlineMarkingDefinitionMatches(\n    inlineMarking: InlineMarkingDefinition\n  ) {\n    const markedRanges: MarkedRange[] = [];\n\n    if (inlineMarking.text) {\n      let idx = this.textLine.indexOf(inlineMarking.text, 0);\n      while (idx > -1) {\n        markedRanges.push({\n          markerType: inlineMarking.markerType,\n          start: idx,\n          end: idx + inlineMarking.text.length,\n        });\n        idx = this.textLine.indexOf(\n          inlineMarking.text,\n          idx + inlineMarking.text.length\n        );\n      }\n      return markedRanges;\n    }\n\n    if (inlineMarking.regExp) {\n      const matches = this.textLine.matchAll(inlineMarking.regExp);\n      for (const match of matches) {\n        const fullMatchIndex = match.index as number;\n        // Read the start and end ranges from the `indices` property,\n        // which is made available through the RegExp flag `d`\n        // (and unfortunately not recognized by TypeScript)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let groupIndices = (match as any).indices as (\n          | [start: number, end: number]\n          | null\n        )[];\n        // If accessing the group indices is unsupported, use fallback logic\n        if (!groupIndices || !groupIndices.length) {\n          // Try to find the position of each capture group match inside the full match\n          groupIndices = match.map((groupValue) => {\n            const groupIndex = groupValue ? match[0].indexOf(groupValue) : -1;\n            if (groupIndex === -1) return null;\n            const groupStart = fullMatchIndex + groupIndex;\n            const groupEnd = groupStart + groupValue.length;\n            return [groupStart, groupEnd];\n          });\n        }\n        // Remove null group indices\n        groupIndices = groupIndices.filter((range) => range);\n        // If there are no non-null indices, use the full match instead\n        if (!groupIndices.length) {\n          groupIndices = [[fullMatchIndex, fullMatchIndex + match[0].length]];\n        }\n        // If there are multiple non-null indices, remove the first one\n        // as it is the full match and we only want to mark capture groups\n        if (groupIndices.length > 1) {\n          groupIndices.shift();\n        }\n        // Create marked ranges from all remaining group indices\n        groupIndices.forEach((range) => {\n          if (!range) return;\n          markedRanges.push({\n            markerType: inlineMarking.markerType,\n            start: range[0],\n            end: range[1],\n          });\n        });\n      }\n      return markedRanges;\n    }\n\n    throw new Error(\n      `Missing matching logic for inlineMarking=${JSON.stringify(\n        inlineMarking\n      )}`\n    );\n  }\n\n  private textPositionToTokenPosition(textPosition: number): InsertionPoint {\n    for (const [tokenIndex, token] of this.tokens.entries()) {\n      if (token.tokenType !== \"syntax\") continue;\n\n      if (textPosition === token.textStart) {\n        return {\n          tokenIndex,\n          innerHtmlOffset: 0,\n        };\n      }\n\n      // The text position is inside the current token\n      if (textPosition > token.textStart && textPosition < token.textEnd) {\n        // NOTE: We used to escape the string before `indexOf` as rehype would escape HTML entities\n        // at render-time, causing the text position to shift. However, with rehype-optimize-static,\n        // the HTML is preserved as is, so we don't have to anticipate for the shift anymore.\n        const innerHtmlOffset = (\n          token.text.slice(0, textPosition - token.textStart) +\n          // Insert our special character at textPosition\n          \"\\n\" +\n          token.text.slice(textPosition - token.textStart)\n        ).indexOf(\"\\n\");\n\n        return {\n          tokenIndex,\n          innerHtmlOffset,\n        };\n      }\n    }\n\n    // If we arrive here, the position is after the last token\n    return {\n      tokenIndex: this.tokens.length,\n      innerHtmlOffset: 0,\n    };\n  }\n\n  private insertMarkerTokenAtPosition(\n    position: InsertionPoint,\n    markerToken: MarkerToken\n  ) {\n    // Insert the new token inside the given token by splitting it\n    if (position.innerHtmlOffset > 0) {\n      const insideToken = this.tokens[position.tokenIndex];\n      if (insideToken.tokenType !== \"syntax\")\n        throw new Error(\n          `Cannot insert a marker token inside a token of type \"${insideToken.tokenType}\"!`\n        );\n\n      const newInnerHtmlBeforeMarker = insideToken.innerHtml.slice(\n        0,\n        position.innerHtmlOffset\n      );\n      const tokenAfterMarker = {\n        ...insideToken,\n        innerHtml: insideToken.innerHtml.slice(position.innerHtmlOffset),\n      };\n      insideToken.innerHtml = newInnerHtmlBeforeMarker;\n      const newTokens: InlineToken[] = [markerToken];\n      // Only add the inside token if it still has contents after splitting\n      if (tokenAfterMarker.innerHtml.length) newTokens.push(tokenAfterMarker);\n      this.tokens.splice(position.tokenIndex + 1, 0, ...newTokens);\n      return;\n    }\n\n    // Insert the new token before the given token\n    this.tokens.splice(position.tokenIndex, 0, markerToken);\n  }\n\n  private flattenMarkedRanges(markedRanges: MarkedRange[]): MarkedRange[] {\n    const flattenedRanges: MarkedRange[] = [];\n    const sortedRanges = [...markedRanges].sort((a, b) => a.start - b.start);\n    const posInRange = (pos: number): { idx: number; range?: MarkedRange } => {\n      for (let idx = 0; idx < flattenedRanges.length; idx++) {\n        const range = flattenedRanges[idx];\n        if (pos < range.end)\n          return {\n            idx,\n            range: pos >= range.start ? range : undefined,\n          };\n      }\n      // After the last element\n      return {\n        idx: flattenedRanges.length,\n      };\n    };\n\n    MarkerTypeOrder.forEach((markerType) => {\n      sortedRanges\n        .filter((range) => range.markerType === markerType)\n        .forEach((rangeToAdd) => {\n          // Clone range to avoid overriding values of the original object\n          rangeToAdd = { ...rangeToAdd };\n\n          // Get insertion position for the start and end of rangeToAdd\n          const posStart = posInRange(rangeToAdd.start);\n          const posEnd = posInRange(rangeToAdd.end);\n\n          const newElements: MarkedRange[] = [rangeToAdd];\n\n          // rangeToAdd starts inside an existing range and their start points differ\n          if (posStart.range && rangeToAdd.start !== posStart.range.start) {\n            if (posStart.range.markerType === rangeToAdd.markerType) {\n              rangeToAdd.start = posStart.range.start;\n            } else {\n              newElements.unshift({\n                ...posStart.range,\n                end: rangeToAdd.start,\n              });\n            }\n          }\n\n          // rangeToAdd ends inside an existing range and their end points differ\n          if (posEnd.range && rangeToAdd.end !== posEnd.range.end) {\n            if (posEnd.range.markerType === rangeToAdd.markerType) {\n              rangeToAdd.end = posEnd.range.end;\n            } else {\n              newElements.push({\n                ...posEnd.range,\n                start: rangeToAdd.end,\n              });\n            }\n          }\n\n          flattenedRanges.splice(\n            posStart.idx,\n            posEnd.idx - posStart.idx + 1,\n            ...newElements\n          );\n        });\n    });\n\n    return flattenedRanges;\n  }\n}\n\n'astro-code-blocks/src/utils/copy-button.ts'\n:import type { ShikiLine } from \"./shiki-line\";\n\nexport type CopyButtonArgs = {\n  copyButtonTitle?: string;\n  copyButtonTooltip?: string;\n};\n\nexport class CopyButton {\n  private code: string;\n  private title: string;\n  private tooltip: string;\n\n  constructor(lines: ShikiLine[], CopyButtonArgs: CopyButtonArgs) {\n    this.title = CopyButtonArgs.copyButtonTitle || \"\";\n    this.tooltip = CopyButtonArgs.copyButtonTooltip || \"\";\n    this.code = lines.map((line) => line.textLine).join(\"\\n\");\n  }\n\n  renderToHtml() {\n    return `<div class=\"copy-button-wrapper\" aria-live=\"polite\">\n\t<button\n\t\tclass=\"copy-button\"\n\t\ttitle=\"${this.title}\"\n\t\tvalue=\"${encodeURIComponent(this.code)}\"\n\t><svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\" width=\"24\" height=\"24\" aria-hidden=\"true\">\n\t\t\t<path d=\"M7.5 18.98q-.63 0-1.06-.44T6 17.48v-14q0-.63.44-1.07t1.06-.44h11q.63 0 1.06.44T20 3.47v14q0 .63-.44 1.07t-1.06.44Zm0-1.5h11v-14h-11v14Zm-3 4.5q-.63 0-1.06-.44T3 20.48V6.15q0-.33.21-.54.21-.21.54-.21.33 0 .54.21.21.21.21.54v14.32h11.1q.33 0 .54.22.21.21.21.53 0 .33-.21.54-.22.22-.54.22Zm3-18.5v14-14Z\"/>\n\t\t</svg></button>\n\t<p class=\"copy-button-tooltip\">${this.tooltip}</p>\n</div>`;\n  }\n}\n\n'astro-code-blocks/src/utils/shiki-block.ts'\n:import { CopyButton } from \"./copy-button\";\nimport type { CopyButtonArgs } from \"./copy-button\";\nimport { ShikiLine } from \"./shiki-line\";\nimport { MarkerTypeOrder } from \"./types\";\nimport type {\n  InlineMarkingDefinition,\n  LineMarkingDefinition,\n} from \"./types\";\n\nexport class ShikiBlock {\n  private htmlBeforeFirstLine = \"\";\n  private shikiLines: ShikiLine[] = [];\n  private htmlAfterLastLine = \"\";\n  private copyButton: CopyButton | null = null;\n\n  constructor(highlightedCodeHtml: string, copyButtonArgs: CopyButtonArgs) {\n    if (!highlightedCodeHtml) return;\n\n    const codeBlockRegExp =\n      /^\\s*(<pre.*?><code.*?>)([\\s\\S]*)(<\\/code><\\/pre>)\\s*$/;\n    const matches = highlightedCodeHtml.match(codeBlockRegExp);\n    if (!matches)\n      throw new Error(\n        `Shiki-highlighted code block HTML did not match expected format. HTML code:\\n${highlightedCodeHtml}`\n      );\n\n    this.htmlBeforeFirstLine = matches[1];\n    const innerHtml = matches[2];\n    this.htmlAfterLastLine = matches[3];\n\n    // Parse inner HTML code to ShikiLine instances\n    const innerHtmlLines = innerHtml.split(/\\r?\\n/);\n    \n    this.shikiLines = innerHtmlLines.map((htmlLine) => new ShikiLine(htmlLine));\n    this.copyButton = new CopyButton(this.shikiLines, copyButtonArgs);\n  }\n\n  applyMarkings(\n    lineMarkings: LineMarkingDefinition[],\n    inlineMarkings: InlineMarkingDefinition[]\n  ) {\n    if (!lineMarkings.length && !inlineMarkings.length) return;\n    this.shikiLines.forEach((line, i) => {\n      // Determine line marker type (if any)\n      const matchingDefinitions = lineMarkings.filter((def) =>\n        def.lines.includes(i + 1)\n      );\n      if (matchingDefinitions) {\n        const markerTypes = matchingDefinitions.map((def) => def.markerType);\n        markerTypes.sort(\n          (a, b) => MarkerTypeOrder.indexOf(a) - MarkerTypeOrder.indexOf(b)\n        );\n        const highestPrioMarkerType = markerTypes[0];\n        line.setLineMarkerType(highestPrioMarkerType);\n      }\n\n      line.applyInlineMarkings(inlineMarkings);\n    });\n  }\n\n  renderToHtml() {\n    const linesHtml = this.shikiLines\n      .map((line) => {\n        // line.ensureTokenColorContrast();\n        return line.renderToHtml();\n      })\n      .join(\"\\n\");\n    const copyButton = this.copyButton?.renderToHtml();\n    return `${this.htmlBeforeFirstLine}${linesHtml}${this.htmlAfterLastLine}${copyButton}`;\n  }\n}\n\n",
        "called_code_segment_file_1": "export function unescape(str: string) {\n  return unEsc(str).replaceAll(\"&#x3C;\", \"<\").replaceAll(\"&#x26;\", \"&\");\n}",
        "invoking_code_segment_file_2": "const text = unescape(innerHtml);",
        "called_code_segment_file_2": "applyInlineMarkings(inlineMarkings: InlineMarkingDefinition[])",
        "using_code_segment_file_3": "applyMarkings(\n    lineMarkings: LineMarkingDefinition[],\n    inlineMarkings: InlineMarkingDefinition[]\n  )",
        "called_code_segment_file_3": "renderToHtml()",
        "using_code_segment_file_4": "const copyButton = this.copyButton?.renderToHtml();",
        "feature_description": "Add support for custom HTML entities in the unescape function.",
        "detailed_feature_description": "The unescape function in #file 1 will be modified to accept a custom map of HTML entities to replace. This will allow users to specify additional entities to be unescaped. The ShikiLine class in #file 2 will be updated to pass a custom map to the unescape function. The ShikiBlock class in #file 3 will be updated to handle the modified unescape function. The CopyButton class in #file 4 will remain unchanged as it does not directly interact with the unescape function.",
        "modified_complete_code": {
            "file_1": "import { unescape as unEsc } from \"html-escaper\";\n\n#Modify\nexport function unescape(str: string, customEntities?: Record<string, string>) {\n  let result = unEsc(str);\n  if (customEntities) {\n    for (const [entity, replacement] of Object.entries(customEntities)) {\n      result = result.replaceAll(entity, replacement);\n    }\n  }\n  return result.replaceAll(\"&#x3C;\", \"<\").replaceAll(\"&#x26;\", \"&\");\n}",
            "file_2": "import chroma from \"chroma-js\";\nimport { unescape } from \"./html-entities\";\nimport { ensureTextContrast } from \"./color-contrast\";\nimport { MarkerTypeOrder } from \"./types\";\nimport type {\n  InlineMarkingDefinition,\n  InlineToken,\n  InsertionPoint,\n  MarkedRange,\n  MarkerToken,\n  MarkerType,\n} from \"./types\";\n\n#Modify\nexport class ShikiLine {\n  readonly tokens: InlineToken[];\n  readonly textLine: string;\n\n  private beforeClassValue: string;\n  private classes: Set<string>;\n  private afterClassValue: string;\n  private afterTokens: string;\n\n  constructor(highlightedCodeLine: string) {\n    const lineRegExp = /^(<span class=\\\")(line.*?)(\\\".*?>)(.*)(<\\/span>)$/;\n    const lineMatches = highlightedCodeLine.match(lineRegExp);\n    if (!lineMatches)\n      throw new Error(\n        `Shiki-highlighted code line HTML did not match expected format. HTML code:\\n${highlightedCodeLine}`\n      );\n\n    this.beforeClassValue = lineMatches[1];\n    this.classes = new Set(lineMatches[2].split(\" \"));\n    this.afterClassValue = lineMatches[3];\n    const tokensHtml = lineMatches[4];\n    this.afterTokens = lineMatches[5];\n\n    // Split line into inline tokens, accomodate for hex or css variable colors\n    const tokenRegExp =\n      /<span style=\\\"color: ?(#[0-9A-Fa-f]+|var\\(--+)([^\\\"]*)>(.*?)<\\/span>/g;\n    const tokenMatches = tokensHtml.matchAll(tokenRegExp);\n    this.tokens = [];\n    this.textLine = \"\";\n    for (const tokenMatch of tokenMatches) {\n      const [, color, otherStyles, innerHtml] = tokenMatch;\n      const text = unescape(innerHtml, { \"&lt;\": \"<\", \"&amp;\": \"&\" });\n      this.tokens.push({\n        tokenType: \"syntax\",\n        color,\n        otherStyles,\n        innerHtml,\n        text,\n        textStart: this.textLine.length,\n        textEnd: this.textLine.length + text.length,\n      });\n      this.textLine += text;\n    }\n  }\n\n  // Other methods...\n}",
            "file_3": "import { CopyButton } from \"./copy-button\";\nimport type { CopyButtonArgs } from \"./copy-button\";\nimport { ShikiLine } from \"./shiki-line\";\nimport { MarkerTypeOrder } from \"./types\";\nimport type {\n  InlineMarkingDefinition,\n  LineMarkingDefinition,\n} from \"./types\";\n\n#Modify\nexport class ShikiBlock {\n  private htmlBeforeFirstLine = \"\";\n  private shikiLines: ShikiLine[] = [];\n  private htmlAfterLastLine = \"\";\n  private copyButton: CopyButton | null = null;\n\n  constructor(highlightedCodeHtml: string, copyButtonArgs: CopyButtonArgs) {\n    if (!highlightedCodeHtml) return;\n\n    const codeBlockRegExp =\n      /^s*(<pre.*?><code.*?>)([\\s\\S]*)(<\\/code><\\/pre>)\\s*$/;\n    const matches = highlightedCodeHtml.match(codeBlockRegExp);\n    if (!matches)\n      throw new Error(\n        `Shiki-highlighted code block HTML did not match expected format. HTML code:\\n${highlightedCodeHtml}`\n      );\n\n    this.htmlBeforeFirstLine = matches[1];\n    const innerHtml = matches[2];\n    this.htmlAfterLastLine = matches[3];\n\n    // Parse inner HTML code to ShikiLine instances\n    const innerHtmlLines = innerHtml.split(/\\r?\\n/);\n\n    this.shikiLines = innerHtmlLines.map((htmlLine) => new ShikiLine(htmlLine));\n    this.copyButton = new CopyButton(this.shikiLines, copyButtonArgs);\n  }\n\n  applyMarkings(\n    lineMarkings: LineMarkingDefinition[],\n    inlineMarkings: InlineMarkingDefinition[]\n  ) {\n    if (!lineMarkings.length && !inlineMarkings.length) return;\n    this.shikiLines.forEach((line, i) => {\n      // Determine line marker type (if any)\n      const matchingDefinitions = lineMarkings.filter((def) =>\n        def.lines.includes(i + 1)\n      );\n      if (matchingDefinitions) {\n        const markerTypes = matchingDefinitions.map((def) => def.markerType);\n        markerTypes.sort(\n          (a, b) => MarkerTypeOrder.indexOf(a) - MarkerTypeOrder.indexOf(b)\n        );\n        const highestPrioMarkerType = markerTypes[0];\n        line.setLineMarkerType(highestPrioMarkerType);\n      }\n\n      line.applyInlineMarkings(inlineMarkings);\n    });\n  }\n\n  renderToHtml() {\n    const linesHtml = this.shikiLines\n      .map((line) => {\n        // line.ensureTokenColorContrast();\n        return line.renderToHtml();\n      })\n      .join(\"\\n\");\n    const copyButton = this.copyButton?.renderToHtml();\n    return `${this.htmlBeforeFirstLine}${linesHtml}${this.htmlAfterLastLine}${copyButton}`;\n  }\n}",
            "file_4": "import type { ShikiLine } from \"./shiki-line\";\n\n#Modify\nexport type CopyButtonArgs = {\n  copyButtonTitle?: string;\n  copyButtonTooltip?: string;\n};\n\nexport class CopyButton {\n  private code: string;\n  private title: string;\n  private tooltip: string;\n\n  constructor(lines: ShikiLine[], CopyButtonArgs: CopyButtonArgs) {\n    this.title = CopyButtonArgs.copyButtonTitle || \"\";\n    this.tooltip = CopyButtonArgs.copyButtonTooltip || \"\";\n    this.code = lines.map((line) => line.textLine).join(\"\\n\");\n  }\n\n  renderToHtml() {\n    return `<div class=\\\"copy-button-wrapper\\\" aria-live=\\\"polite\\\">\\n<button\\nclass=\\\"copy-button\\\"\\ntitle=\\\"${this.title}\\\"\\nvalue=\\\"${encodeURIComponent(this.code)}\\\"\\n><svg xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 24 24\\\" fill=\\\"currentColor\\\" width=\\\"24\\\" height=\\\"24\\\" aria-hidden=\\\"true\\\">\\n<path d=\\\"M7.5 18.98q-.63 0-1.06-.44T6 17.48v-14q0-.63.44-1.07t1.06-.44h11q.63 0 1.06.44T20 3.47v14q0 .63-.44 1.07t-1.06.44Zm0-1.5h11v-14h-11v14Zm-3 4.5q-.63 0-1.06-.44T3 20.48V6.15q0-.33.21-.54.21-.21.54-.21.33 0 .54.21.21.21.21.54v14.32h11.1q.33 0 .54.22.21.21.21.53 0 .33-.21.54-.22.22-.54.22Zm3-18.5v14-14Z\\\"/></svg></button>\\n<p class=\\\"copy-button-tooltip\\\">${this.tooltip}</p>\\n</div>`;\n  }\n}"
        }
    },
    {
        "repo": "angular-springboot-demo",
        "content": "'angular-springboot-demo/frontend/src/app/person/person.service.ts'\n:import {Injectable} from '@angular/core';\nimport {HttpClient} from '@angular/common/http';\nimport {Observable} from \"rxjs\";\nimport {Person} from \"./person\";\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class PersonService {\n\n    constructor(private http: HttpClient) {\n    }\n\n    findAll(): Observable<Person[]> {\n        return this.http.get<Person[]>(\"/api/persons\")\n    }\n\n    findById(id: number): Observable<Person> {\n        return this.http.get<Person>(`/api/persons/${id}`)\n    }\n\n    save(person: Person): Observable<any> {\n        return this.http.post(\"/api/persons\", person);\n    }\n}\n\n'angular-springboot-demo/frontend/src/app/person/edit/person-edit.component.ts'\n:import {Component} from '@angular/core';\nimport {ActivatedRoute, Router} from '@angular/router';\nimport {MatSnackBar} from '@angular/material/snack-bar';\nimport {PersonService} from '../person.service';\nimport {Person} from '../person';\n\n@Component({\n    selector: 'app-person-edit',\n    templateUrl: './person-edit.component.html',\n    styleUrls: ['./person-edit.component.css']\n})\nexport class PersonEditComponent {\n\n    person: Person = new Person();\n\n    constructor(private route: ActivatedRoute, private personService: PersonService, private snackBar: MatSnackBar, private router: Router) {\n    }\n\n    ngOnInit(): void {\n        this.getPerson();\n    }\n\n    getPerson(): void {\n        const idParam = this.route.snapshot.paramMap.get('id');\n        if (idParam === \"new\") {\n            this.person = new Person();\n        } else {\n            const id = parseInt(idParam as string, 10);\n            this.personService.findById(id).subscribe(person => this.person = person);\n        }\n    }\n\n    save(): void {\n        this.personService.save(this.person).subscribe(() => {\n            let snackBar = this.snackBar.open(\"Person saved\", \"OK\",);\n            snackBar.onAction().subscribe(value => this.router.navigateByUrl(\"/persons\"));\n        });\n    }\n}\n\n'angular-springboot-demo/frontend/src/app/app.module.ts'\n:import {NgModule} from '@angular/core';\nimport {BrowserModule} from '@angular/platform-browser';\n\nimport {AppRoutingModule} from './app-routing.module';\nimport {AppComponent} from './app.component';\nimport {HTTP_INTERCEPTORS, HttpClientModule} from '@angular/common/http';\nimport {PersonComponent} from './person/person.component';\nimport {LoginComponent} from './login/login.component';\nimport {FormsModule} from '@angular/forms';\nimport {AuthInterceptor} from './auth/auth.interceptor';\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\nimport {MatToolbarModule} from '@angular/material/toolbar';\nimport {MatMenuModule} from '@angular/material/menu';\nimport {MatSidenavModule} from '@angular/material/sidenav';\nimport {MatTableModule} from '@angular/material/table';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatSnackBarModule} from '@angular/material/snack-bar';\nimport { LayoutModule } from '@angular/cdk/layout';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatListModule } from '@angular/material/list';\nimport {PersonEditComponent} from './person/edit/person-edit.component';\n\n@NgModule({\n    declarations: [\n        AppComponent,\n        LoginComponent,\n        PersonComponent,\n        PersonEditComponent\n    ],\n    imports: [\n        BrowserModule,\n        AppRoutingModule,\n        FormsModule,\n        HttpClientModule,\n        BrowserAnimationsModule,\n        MatToolbarModule,\n        MatMenuModule,\n        MatSidenavModule,\n        MatTableModule,\n        MatButtonModule,\n        MatInputModule,\n        MatFormFieldModule,\n        MatSnackBarModule,\n        LayoutModule,\n        MatIconModule,\n        MatListModule\n    ],\n    providers: [\n        {provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true},\n    ],\n    bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n\n'angular-springboot-demo/frontend/src/main.ts'\n:import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';\n\nimport {AppModule} from './app/app.module';\nimport {environment} from './environments/environment';\nimport {enableProdMode} from '@angular/core';\n\nif (environment.production) {\n    enableProdMode();\n}\nplatformBrowserDynamic().bootstrapModule(AppModule)\n    .catch(err => console.error(err));\n\n",
        "called_code_segment_file_1": "save(person: Person): Observable<any> { return this.http.post(\"/api/persons\", person); }",
        "invoking_code_segment_file_2": "save(): void { this.personService.save(this.person).subscribe(() => { let snackBar = this.snackBar.open(\"Person saved\", \"OK\",); snackBar.onAction().subscribe(value => this.router.navigateByUrl(\"/persons\")); }); }",
        "called_code_segment_file_2": "findById(id: number): Observable<Person> { return this.http.get<Person>(`/api/persons/${id}`); }",
        "using_code_segment_file_3": "getPerson(): void { const idParam = this.route.snapshot.paramMap.get('id'); if (idParam === \"new\") { this.person = new Person(); } else { const id = parseInt(idParam as string, 10); this.personService.findById(id).subscribe(person => this.person = person); } }",
        "called_code_segment_file_3": "",
        "using_code_segment_file_4": "",
        "feature_description": "Add a feature to return the saved person's ID after saving.",
        "detailed_feature_description": "Modify the save method in PersonService to return the saved person's ID. Update the PersonEditComponent to handle the returned ID and display it in a snackbar message. No direct interaction between PersonComponent and other files, so no changes are required in PersonComponent.",
        "modified_complete_code": {
            "angular-springboot-demo/frontend/src/app/person/person.service.ts": "import {Injectable} from '@angular/core';\nimport {HttpClient} from '@angular/common/http';\nimport {Observable} from \"rxjs\";\nimport {Person} from \"./person\";\n\n@Injectable({\n    providedIn: 'root',\n})\nexport class PersonService {\n\n    constructor(private http: HttpClient) { }\n\n    findAll(): Observable<Person[]> {\n        return this.http.get<Person[]>(\"/api/persons\")\n    }\n\n    findById(id: number): Observable<Person> {\n        return this.http.get<Person>(`/api/persons/${id}`)\n    }\n\n    save(person: Person): Observable<any> {\n        // #Modify: Return the saved person's ID\n        return this.http.post<{id: number}>(\"/api/persons\", person);\n    }\n}",
            "angular-springboot-demo/frontend/src/app/person/edit/person-edit.component.ts": "import {Component} from '@angular/core';\nimport {ActivatedRoute, Router} from '@angular/router';\nimport {MatSnackBar} from '@angular/material/snack-bar';\nimport {PersonService} from '../person.service';\nimport {Person} from '../person';\n\n@Component({\n    selector: 'app-person-edit',\n    templateUrl: './person-edit.component.html',\n    styleUrls: ['./person-edit.component.css']\n})\nexport class PersonEditComponent {\n\n    person: Person = new Person();\n\n    constructor(private route: ActivatedRoute, private personService: PersonService, private snackBar: MatSnackBar, private router: Router) { }\n\n    ngOnInit(): void {\n        this.getPerson();\n    }\n\n    getPerson(): void {\n        const idParam = this.route.snapshot.paramMap.get('id');\n        if (idParam === \"new\") {\n            this.person = new Person();\n        } else {\n            const id = parseInt(idParam as string, 10);\n            this.personService.findById(id).subscribe(person => this.person = person);\n        }\n    }\n\n    save(): void {\n        // #Modify: Handle the returned ID\n        this.personService.save(this.person).subscribe((response) => {\n            let snackBar = this.snackBar.open(`Person saved with ID: ${response.id}`, \"OK\",);\n            snackBar.onAction().subscribe(value => this.router.navigateByUrl(\"/persons\"));\n        });\n    }\n}",
            "angular-springboot-demo/frontend/src/app/person/person.component.ts": "import {Component, OnInit} from '@angular/core';\nimport {PersonService} from './person.service';\nimport {Person} from './person';\n\n@Component({\n    selector: 'app-person',\n    templateUrl: './person.component.html',\n    styleUrls: ['./person.component.css']\n})\nexport class PersonComponent implements OnInit {\n\n    persons: Person[] = [];\n\n    constructor(private personService: PersonService) { }\n\n    ngOnInit(): void {\n        this.personService.findAll().subscribe(data => {\n            this.persons = data;\n        });\n    }\n}",
            "angular-springboot-demo/frontend/src/app/app.module.ts": "import {NgModule} from '@angular/core';\nimport {BrowserModule} from '@angular/platform-browser';\n\nimport {AppRoutingModule} from './app-routing.module';\nimport {AppComponent} from './app.component';\nimport {HTTP_INTERCEPTORS, HttpClientModule} from '@angular/common/http';\nimport {PersonComponent} from './person/person.component';\nimport {LoginComponent} from './login/login.component';\nimport {FormsModule} from '@angular/forms';\nimport {AuthInterceptor} from './auth/auth.interceptor';\nimport {BrowserAnimationsModule} from '@angular/platform-browser/animations';\nimport {MatToolbarModule} from '@angular/material/toolbar';\nimport {MatMenuModule} from '@angular/material/menu';\nimport {MatSidenavModule} from '@angular/material/sidenav';\nimport {MatTableModule} from '@angular/material/table';\nimport {MatButtonModule} from '@angular/material/button';\nimport {MatInputModule} from '@angular/material/input';\nimport {MatFormFieldModule} from '@angular/material/form-field';\nimport {MatSnackBarModule} from '@angular/material/snack-bar';\nimport { LayoutModule } from '@angular/cdk/layout';\nimport { MatIconModule } from '@angular/material/icon';\nimport { MatListModule } from '@angular/material/list';\nimport {PersonEditComponent} from './person/edit/person-edit.component';\n\n@NgModule({\n    declarations: [\n        AppComponent,\n        LoginComponent,\n        PersonComponent,\n        PersonEditComponent\n    ],\n    imports: [\n        BrowserModule,\n        AppRoutingModule,\n        FormsModule,\n        HttpClientModule,\n        BrowserAnimationsModule,\n        MatToolbarModule,\n        MatMenuModule,\n        MatSidenavModule,\n        MatTableModule,\n        MatButtonModule,\n        MatInputModule,\n        MatFormFieldModule,\n        MatSnackBarModule,\n        LayoutModule,\n        MatIconModule,\n        MatListModule\n    ],\n    providers: [\n        {provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true},\n    ],\n    bootstrap: [AppComponent]\n})\nexport class AppModule { }\n"
        }
    },
    {
        "repo": "calendar-hack",
        "content": "'calendar-hack/src/components/WeekSummary.tsx'\n:import * as React from \"react\";\nimport styled from \"styled-components\";\nimport { renderDist, getWeekDistance } from \"../ch/rendering\";\nimport StartIcon from \"../svg/icons02/start.svg\";\nimport FinishIcon from \"../svg/icons02/finish.svg\";\nimport HighMileageIcon from \"../svg/highMileage.svg\";\nimport { RacePlan } from \"../ch/dategrid\";\nimport { Week, DayDetails, Units } from \"types/app\";\n\ninterface Props {\n  desc: string;\n  week: Week<DayDetails>;\n  units: Units;\n  racePlan: RacePlan;\n  isFirstWeek: boolean;\n  isLastWeek: boolean;\n  isHighestMileage: boolean;\n}\n\nconst Root = styled.div`\n  height: 100%;\n  width: 100%;\n  padding: 5px;\n  text-align: center;\n  border: 1px solid rgba(0, 0, 0, 0.125);\n  border-radius: 0.25rem;\n  background-color: ${(props) => props.theme.colors.weekSummaryBg};\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    position: relative;\n  }\n`;\n\nconst Icon = styled.img`\n  max-height: 64px;\n  //max-width: 64px;\n  display: inline;\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    position: absolute;\n    top: 10px;\n    left: 10px;\n    max-height: 32px;\n    max-width: 32px;\n  }\n`;\n\nexport const WeekSummary = ({\n  week,\n  units,\n  isFirstWeek,\n  isLastWeek,\n  isHighestMileage,\n}: Props) => {\n  const distance = getWeekDistance(week, units);\n  return (\n    <Root key={\"week:\" + week.weekNum}>\n      <p>\n        <strong>{`Week ${1 + week.weekNum}`}</strong>\n      </p>\n      {distance > 0 && <p>{renderDist(distance, units, units)}</p>}\n      {isFirstWeek && <Icon src={StartIcon} alt={\"Start\"} />}\n      {isLastWeek && <Icon src={FinishIcon} alt=\"Finish\" />}\n      {isHighestMileage && <Icon src={HighMileageIcon} alt=\"Highest Mileage\" />}\n      {isHighestMileage && (\n        <p>\n          <small>Highest Mileage</small>\n        </p>\n      )}\n    </Root>\n  );\n};\n\n'calendar-hack/src/components/CalendarGrid.tsx'\n:import * as React from \"react\";\nimport { RacePlan, key } from \"../ch/dategrid\";\nimport { DayCell } from \"./DayCell\";\nimport { WeekSummary } from \"./WeekSummary\";\nimport { DayOfWeekHeader } from \"./DayOfWeekHeader\";\nimport styled from \"styled-components\";\nimport { format } from \"date-fns\";\nimport { getDaysHeader, WeekStartsOn } from \"../ch/datecalc\";\nimport { Units, dayOfWeek, Week, DayDetails } from \"types/app\";\n\ninterface Props {\n  racePlan: RacePlan;\n  units: Units;\n  weekStartsOn: WeekStartsOn;\n  swapDates: (d1: Date, d2: Date) => void;\n  swapDow: (dow1: dayOfWeek, dow2: dayOfWeek) => void;\n}\n\nconst Root = styled.div`\n  display: grid;\n  grid-template-columns: repeat(1, 1fr);\n  grid-template-rows: auto;\n  row-gap: 0.5em;\n`;\n\nconst WeekRow = styled.div`\n  display: grid;\n  @media (min-width: ${(props) => props.theme.screenSizes.lg}) {\n    grid-template-columns: 0.75fr repeat(7, 1fr);\n  }\n  column-gap: 0.5em;\n`;\n\nconst Blank = styled.div``;\n\nfunction calcWeeklyDistance(w: Week<DayDetails>): number {\n  return w.days\n    .map((d) => d.event)\n    .reduce((a, e) => {\n      return !e || !e.dist ? a : a + e.dist;\n    }, 0);\n}\n\nfunction findMaxDistance(weeks: Week<DayDetails>[]): number {\n  let currMax = 0.0;\n  for (var i = 0; i < weeks.length; i++) {\n    let d = calcWeeklyDistance(weeks[i]);\n    if (d > currMax) {\n      currMax = d;\n    }\n  }\n  return currMax;\n}\n\nexport const CalendarGrid = ({\n  racePlan,\n  units,\n  weekStartsOn,\n  swapDates,\n  swapDow,\n}: Props) => {\n  const [selectedDow, setSelectedDow] = React.useState<dayOfWeek | undefined>(\n    undefined\n  );\n  const [hoveringDow, setHoveringDow] = React.useState<dayOfWeek | undefined>(\n    undefined\n  );\n  const maxDistance = findMaxDistance(racePlan.dateGrid.weeks);\n\n  function getWeek(w: Week<DayDetails>) {\n    return (\n      <WeekRow key={`wr:${w.weekNum}`}>\n        <WeekSummary\n          key={`ws:${w.weekNum}`}\n          desc={w.desc}\n          week={w}\n          units={units}\n          racePlan={racePlan}\n          isFirstWeek={w.weekNum === 0}\n          isLastWeek={w.weekNum === racePlan.dateGrid.weekCount - 1}\n          isHighestMileage={\n            maxDistance > 0 && calcWeeklyDistance(w) === maxDistance\n          }\n        ></WeekSummary>\n        {w.days.map((d, index) => (\n          <DayCell\n            key={key(d.date)}\n            date={d.date}\n            units={units}\n            swap={swapDates}\n            dayDetails={d.event}\n            selected={selectedDow === format(d.date, \"EEEE\")}\n            hovering={hoveringDow === format(d.date, \"EEEE\")}\n          />\n        ))}\n      </WeekRow>\n    );\n  }\n\n  function getHeader() {\n    return (\n      <WeekRow>\n        <Blank key={\"blank-left\"} />\n        {getDaysHeader(weekStartsOn).map((dow, index) => (\n          <DayOfWeekHeader\n            key={dow}\n            dow={dow as dayOfWeek}\n            swapDow={swapDow}\n            setSelectedDow={setSelectedDow}\n            setHoveringDow={setHoveringDow}\n          />\n        ))}\n      </WeekRow>\n    );\n  }\n\n  return (\n    <Root>\n      {getHeader()}\n      {racePlan.dateGrid.weeks.map((w, index) => getWeek(w))}\n    </Root>\n  );\n};\n\n'calendar-hack/src/App.tsx'\n:import React, { useState } from \"react\";\nimport { repo } from \"./ch/planrepo\";\nimport { endOfWeek, addWeeks, isAfter } from \"date-fns\";\nimport { RacePlan } from \"./ch/dategrid\";\nimport { build, swap, swapDow } from \"./ch/planbuilder\";\nimport { CalendarGrid } from \"./components/CalendarGrid\";\nimport { ThemeProvider } from \"styled-components\";\nimport { toIcal, download } from \"./ch/icalservice\";\nimport UnitsButtons from \"./defy/components/UnitsButtons\";\nimport PlanAndDate from \"./components/PlanAndDate\";\nimport Toolbar from \"./defy/components/Toolbar\";\nimport styled from \"styled-components\";\nimport DownloadButton from \"./components/DownloadButton\";\nimport UndoButton from \"./components/UndoButton\";\nimport history from \"./defy/history\";\nimport {\n  useQueryParams,\n  StringParam,\n  DateParam,\n  NumberParam,\n} from \"use-query-params\";\nimport { PlanDetailsCard } from \"./components/PlanDetailsCard\";\nimport { WeekStartsOn, WeekStartsOnValues } from \"./ch/datecalc\";\nimport WeekStartsOnPicker from \"./components/WeekStartsOnPicker\";\nimport { useMountEffect } from \"./ch/hooks\";\nimport { Units, PlanSummary, dayOfWeek } from \"types/app\";\nimport { getLocaleUnits } from \"./ch/localize\";\n\nconst theme = {\n  colors: {\n    bodyBg: \"#B8E2E6\",\n    title: \"#424242\",\n    buttonBg: \"#E3F7F8\",\n    buttonIcons: \"#E3F7F8\",\n    buttonTxt: \"#424242\",\n    buttonSelectedBorder: \"#FF6FDF\",\n    dowHeaderBg: \"#C2C5EB\",\n    weekSummaryBg: \"#C2C5EB\",\n    workoutCardBg: \"#E3F7F8\",\n    workoutCardBlankBg: \"#e9ecef\",\n    datelineBg: \"#B391D2\",\n    datelineBlankBg: \"#beafd2\",\n    datelineTxt: \"#424242\",\n    planDescriptionBg: \"#E3F7F8\",\n    planDescriptionTxt: \"#424242\",\n  },\n  fonts: [\"sans-serif\", \"Roboto\"],\n  fontSizes: {\n    small: \"1em\",\n    medium: \"2em\",\n    large: \"3em\",\n  },\n  screenSizes: {\n    sm: \"576px\",\n    md: \"768px\",\n    lg: \"992px\",\n    xl: \"1200px\",\n  },\n};\n\nconst MainUI = styled.div`\n  margin-top: 2em;\n`;\n\nconst SecondToolbar = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-wrap: wrap;\n  margin: 1em 0 5px 0;\n  color: ${(props) => props.theme.colors.controlsTitle};\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    flex-direction: column;\n  }\n`;\nconst UnitsDiv = styled.div`\n  @media (max-width: ${(props) => props.theme.screenSizes.lg}) {\n    margin-top: 0.5em;\n  }\n`;\n\nconst App = () => {\n  const [{ u, p, d, s }, setq] = useQueryParams({\n    u: StringParam,\n    p: StringParam,\n    d: DateParam,\n    s: NumberParam,\n  });\n  const [selectedUnits, setSelectedUnits] = useState<Units>(\n    u === \"mi\" || u === \"km\" ? u : getLocaleUnits()\n  );\n  var [selectedPlan, setSelectedPlan] = useState(repo.find(p || \"\"));\n  var [racePlan, setRacePlan] = useState<RacePlan | undefined>(undefined);\n  var [undoHistory, setUndoHistory] = useState([] as RacePlan[]);\n  var [weekStartsOn, setWeekStartsOn] = useState<WeekStartsOn>(\n    s === 0 || s === 1 || s === 6 ? s : WeekStartsOnValues.Monday\n  );\n  var [planEndDate, setPlanEndDate] = useState(\n    d && isAfter(d, new Date())\n      ? d\n      : addWeeks(endOfWeek(new Date(), { weekStartsOn: weekStartsOn }), 20)\n  );\n\n  useMountEffect(() => {\n    initialLoad(selectedPlan, planEndDate, selectedUnits, weekStartsOn);\n  });\n\n  const [, forceUpdate] = React.useReducer((x) => x + 1, 0);\n  React.useEffect(() => {\n    // listen for changes to the URL and force the app to re-render\n    history.listen(() => {\n      forceUpdate();\n    });\n  }, []);\n\n  const getParams = (\n    units: Units,\n    plan: PlanSummary,\n    date: Date,\n    weekStartsOn: WeekStartsOn\n  ) => {\n    return {\n      u: units,\n      p: plan[0],\n      d: date,\n      s: weekStartsOn,\n    };\n  };\n\n  const initialLoad = async (\n    plan: PlanSummary,\n    endDate: Date,\n    units: Units,\n    weekStartsOn: WeekStartsOn\n  ) => {\n    const racePlan = build(await repo.fetch(plan), endDate, weekStartsOn);\n    setRacePlan(racePlan);\n    setUndoHistory([...undoHistory, racePlan]);\n    setq(getParams(units, plan, endDate, weekStartsOn));\n  };\n\n  const onSelectedPlanChange = async (plan: PlanSummary) => {\n    const racePlan = build(await repo.fetch(plan), planEndDate, weekStartsOn);\n    setSelectedPlan(plan);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, plan, planEndDate, weekStartsOn));\n  };\n\n  const onSelectedEndDateChange = async (date: Date) => {\n    const racePlan = build(await repo.fetch(selectedPlan), date, weekStartsOn);\n    setPlanEndDate(date);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, selectedPlan, date, weekStartsOn));\n  };\n\n  const onSelectedUnitsChanged = (u: Units) => {\n    setSelectedUnits(u);\n    setq(getParams(u, selectedPlan, planEndDate, weekStartsOn));\n  };\n\n  const onWeekStartsOnChanged = async (v: WeekStartsOn) => {\n    const racePlan = build(await repo.fetch(selectedPlan), planEndDate, v);\n    setWeekStartsOn(v);\n    setRacePlan(racePlan);\n    setUndoHistory([racePlan]);\n    setq(getParams(selectedUnits, selectedPlan, planEndDate, v));\n  };\n\n  function swapDates(d1: Date, d2: Date): void {\n    if (racePlan) {\n      const newRacePlan = swap(racePlan, d1, d2);\n      setRacePlan(newRacePlan);\n      setUndoHistory([...undoHistory, newRacePlan]);\n    }\n  }\n\n  function doSwapDow(dow1: dayOfWeek, dow2: dayOfWeek) {\n    if (racePlan) {\n      const newRacePlan = swapDow(racePlan, dow1, dow2);\n      setRacePlan(newRacePlan);\n      setUndoHistory([...undoHistory, newRacePlan]);\n    }\n  }\n\n  function downloadHandler() {\n    if (racePlan) {\n      const iCalEventsStr = toIcal(racePlan, selectedUnits);\n      if (iCalEventsStr) {\n        download(iCalEventsStr, \"plan\", \"ics\");\n      }\n    }\n  }\n\n  function undoHandler() {\n    if (undoHistory?.length >= 0) {\n      undoHistory.pop();\n    }\n    setRacePlan(undoHistory[undoHistory.length - 1]);\n  }\n\n  return (\n    <ThemeProvider theme={theme}>\n      <Toolbar downloadHandler={downloadHandler} />\n      <PlanAndDate\n        units={selectedUnits}\n        availablePlans={repo.available}\n        selectedPlan={selectedPlan}\n        selectedDate={planEndDate}\n        dateChangeHandler={onSelectedEndDateChange}\n        selectedPlanChangeHandler={onSelectedPlanChange}\n        unitsChangeHandler={onSelectedUnitsChanged}\n        downloadHandler={downloadHandler}\n        weekStartsOn={weekStartsOn}\n      />\n      <SecondToolbar>\n        <UnitsDiv>\n          <UnitsButtons\n            units={selectedUnits}\n            unitsChangeHandler={onSelectedUnitsChanged}\n          />\n        </UnitsDiv>\n      </SecondToolbar>\n      <SecondToolbar>\n        <DownloadButton downloadHandler={downloadHandler} />\n        <UndoButton\n          disabled={undoHistory.length <= 1}\n          undoHandler={undoHandler}\n        />\n      </SecondToolbar>\n      <PlanDetailsCard racePlan={racePlan} />\n      <SecondToolbar>\n        <WeekStartsOnPicker\n          weekStartsOn={weekStartsOn}\n          changeHandler={onWeekStartsOnChanged}\n        />\n      </SecondToolbar>\n      <MainUI>\n        {racePlan && (\n          <CalendarGrid\n            racePlan={racePlan}\n            units={selectedUnits}\n            weekStartsOn={weekStartsOn}\n            swapDates={swapDates}\n            swapDow={doSwapDow}\n          />\n        )}\n      </MainUI>\n    </ThemeProvider>\n  );\n};\n\nexport default App;\n\n'calendar-hack/src/index.tsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { DndProvider } from 'react-dnd-multi-backend'\nimport { HTML5toTouch } from 'rdndmb-html5-to-touch'\nimport { QueryParamProvider } from \"use-query-params\";\nimport { WindowHistoryAdapter } from \"use-query-params/adapters/window\";\nimport \"./css/reset.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <DndProvider options={HTML5toTouch}>\n      <QueryParamProvider adapter={WindowHistoryAdapter}>\n        <App />\n      </QueryParamProvider>\n    </DndProvider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n",
        "called_code_segment_file_1": "const swapDates = (d1: Date, d2: Date): void => { if (racePlan) { const newRacePlan = swap(racePlan, d1, d2); setRacePlan(newRacePlan); setUndoHistory([...undoHistory, newRacePlan]); } }",
        "invoking_code_segment_file_2": "swapDates={swapDates}",
        "called_code_segment_file_2": "const swapDates = (d1: Date, d2: Date): void => { if (racePlan) { const newRacePlan = swap(racePlan, d1, d2); setRacePlan(newRacePlan); setUndoHistory([...undoHistory, newRacePlan]); } }",
        "using_code_segment_file_3": "swap={swapDates}",
        "called_code_segment_file_3": "const swapDates = (d1: Date, d2: Date): void => { if (racePlan) { const newRacePlan = swap(racePlan, d1, d2); setRacePlan(newRacePlan); setUndoHistory([...undoHistory, newRacePlan]); } }",
        "using_code_segment_file_4": "swap={swapDates}",
        "feature_description": "Add a feature to log the date swap operation to the console.",
        "detailed_feature_description": "Modify the `swapDates` function in #file 1 to log the swapped dates to the console. Update the `swapDates` function in #file 2 to handle the modified code from #file 1. Ensure that #file 3 and #file 4 are updated to reflect the changes if they interact with the `swapDates` function.",
        "modified_complete_code": {
            "#file 1": "const swapDates = (d1: Date, d2: Date): void => { if (racePlan) { const newRacePlan = swap(racePlan, d1, d2); setRacePlan(newRacePlan); setUndoHistory([...undoHistory, newRacePlan]); console.log(`Swapped dates: ${d1} and ${d2}`); // Modify } }",
            "#file 2": "const swapDates = (d1: Date, d2: Date): void => { if (racePlan) { const newRacePlan = swap(racePlan, d1, d2); setRacePlan(newRacePlan); setUndoHistory([...undoHistory, newRacePlan]); console.log(`Swapped dates: ${d1} and ${d2}`); // Modify } }",
            "#file 3": "swap={swapDates}",
            "#file 4": "swap={swapDates}"
        }
    }
]