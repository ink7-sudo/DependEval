[
    {
        "repo": "Ahoy",
        "content": "'Ahoy/__tests__/enzyme.js'\n:import React from 'react';\nimport { configure, shallow } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\nimport LocalChart from '../src/components/LocalChart';\nimport InstalledChart from '../src/components/InstalledChart';\n\nconfigure({ adapter: new Adapter() });\n\ndescribe('All enzyme tests', () => {\n  let wrapper;\n\n  describe('Local Chart Button Tests', () => {\n    // let wrapper;\n    const props = {\n      chart: {},\n      id: 'id',\n      key: 'keyString1',\n      dirPath: jest.fn(),\n      getDeployedCharts: jest.fn(),\n      handleOpenChartClick: jest.fn(),\n      installHelmChart: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<LocalChart {...props} />);\n    });\n\n    describe('Install Button', () => {\n      it('Should render an install button', () => {\n        expect(wrapper.find('#installBtn')).toHaveLength(1);\n      });\n    });\n    describe('Open Folder Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#openChartBtn').simulate('click');\n        expect(props.handleOpenChartClick).toHaveBeenCalled();\n      });\n    });\n  });\n\n  describe('Installed Chart Button Tests', () => {\n    let wrapper2;\n    const props = {\n      key: {},\n      id: 'id',\n      chart: {},\n      history: {},\n      getDeployedCharts: jest.fn(),\n      toggleHistory: jest.fn(),\n      doHelmChartRollBack: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<InstalledChart {...props} />);\n    });\n\n    describe('Uninstall Popup Button', () => {\n      it('Renders a popup when pressed', () => {\n        wrapper.find('Popup').simulate('click');\n        expect(wrapper.find('#confirm').exists()).toEqual(true);\n      });\n    });\n    describe('History Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#historyBtn').simulate('click');\n        expect(props.toggleHistory).toHaveBeenCalled();\n      });\n    });\n  });\n});\n\n'Ahoy/__tests__/enzyme.test.jsx'\n:import React from 'react';\nimport { configure, shallow } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\n\nimport Version from '../src/components/Version';\n\nconfigure({ adapter: new Adapter() });\n\ndescribe('React unit tests', () => {\n  describe('Version', () => {\n    let wrapper;\n\n    const details = {\n      revision: 7,\n      updated: '2021-05-01T15:37:58.109638-05:00',\n      status: '',\n      chart: 'wordpress-10.10.1',\n      app_version: '5.7.0',\n      description: 'Upgrade complete',\n    };\n    const release = 'chartVersion';\n    const doHelmChartRollBack = jest.fn();\n\n    beforeAll(() => {\n      wrapper = shallow(<Version\n        key={1}\n        details={details}\n        release={release}\n        doHelmChartRollBack={doHelmChartRollBack}\n      />);\n    });\n\n    it('Generates a Semantic UI Table Row', () => {\n      expect(wrapper.find('[data-testid=\"VersionRow\"]')).toHaveLength(1);\n    });\n\n    it('Generates a single cell in the table', () => {\n      expect(wrapper.find('[data-testid=\"tableCell\"]')).toHaveLength(1);\n    });\n\n    it('Generates a primary list', () => {\n      expect(wrapper.find('[data-testid=\"mainList\"]')).toHaveLength(1);\n    });\n\n    describe('Rollback icon', () => {\n      it('Renders a rollback icon if status does not equal \"deployed\"', () => {\n        expect(wrapper.find('[name=\"undo\"]')).toHaveLength(1);\n      });\n\n      it('Calls function when clicked', () => {\n        wrapper.find('[name=\"undo\"]').simulate('click');\n        expect(doHelmChartRollBack).toHaveBeenCalled();\n      });\n    });\n\n    describe('Details list', () => {\n      it('Renders a list with 6 items', () => {\n        const subList = wrapper.find('[data-testid=\"subList\"]');\n        expect(subList).toHaveLength(1);\n        expect(subList.children()).toHaveLength(6);\n      });\n    });\n  });\n});\n\n",
        "called_code_segment": "describe('Local Chart Button Tests', () => {\n    // let wrapper;\n    const props = {\n      chart: {},\n      id: 'id',\n      key: 'keyString1',\n      dirPath: jest.fn(),\n      getDeployedCharts: jest.fn(),\n      handleOpenChartClick: jest.fn(),\n      installHelmChart: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<LocalChart {...props} />);\n    });\n\n    describe('Install Button', () => {\n      it('Should render an install button', () => {\n        expect(wrapper.find('#installBtn')).toHaveLength(1);\n      });\n    });\n    describe('Open Folder Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#openChartBtn').simulate('click');\n        expect(props.handleOpenChartClick).toHaveBeenCalled();\n      });\n    });\n  });",
        "invoking_code_segment": "describe('All enzyme tests', () => {\n  let wrapper;\n\n  describe('Local Chart Button Tests', () => {\n    // let wrapper;\n    const props = {\n      chart: {},\n      id: 'id',\n      key: 'keyString1',\n      dirPath: jest.fn(),\n      getDeployedCharts: jest.fn(),\n      handleOpenChartClick: jest.fn(),\n      installHelmChart: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<LocalChart {...props} />);\n    });\n\n    describe('Install Button', () => {\n      it('Should render an install button', () => {\n        expect(wrapper.find('#installBtn')).toHaveLength(1);\n      });\n    });\n    describe('Open Folder Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#openChartBtn').simulate('click');\n        expect(props.handleOpenChartClick).toHaveBeenCalled();\n      });\n    });\n  });",
        "feature_description": "Add a new feature to display a confirmation dialog before uninstalling a chart.",
        "detailed_feature_description": "When the uninstall button is clicked, a confirmation dialog will appear asking the user if they are sure they want to uninstall the chart. If the user confirms, the uninstall action will proceed; otherwise, it will be canceled.",
        "modified_complete_code": {
            "enzyme.js": "describe('All enzyme tests', () => {\n  let wrapper;\n\n  describe('Local Chart Button Tests', () => {\n    // let wrapper;\n    const props = {\n      chart: {},\n      id: 'id',\n      key: 'keyString1',\n      dirPath: jest.fn(),\n      getDeployedCharts: jest.fn(),\n      handleOpenChartClick: jest.fn(),\n      installHelmChart: jest.fn(),\n      showConfirmationDialog: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<LocalChart {...props} />);\n    });\n\n    describe('Install Button', () => {\n      it('Should render an install button', () => {\n        expect(wrapper.find('#installBtn')).toHaveLength(1);\n      });\n    });\n    describe('Open Folder Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#openChartBtn').simulate('click');\n        expect(props.handleOpenChartClick).toHaveBeenCalled();\n      });\n    });\n    describe('Uninstall Button', () => {\n      it('Should show a confirmation dialog when clicked', () => {\n        wrapper.find('#uninstallBtn').simulate('click');\n        expect(props.showConfirmationDialog).toHaveBeenCalled();\n      });\n    });\n  });",
            "enzyme.test.jsx": "describe('React unit tests', () => {\n  describe('Version', () => {\n    let wrapper;\n\n    const details = {\n      revision: 7,\n      updated: '2021-05-01T15:37:58.109638-05:00',\n      status: '',\n      chart: 'wordpress-10.10.1',\n      app_version: '5.7.0',\n      description: 'Upgrade complete',\n    };\n    const release = 'chartVersion';\n    const doHelmChartRollBack = jest.fn();\n    const showConfirmationDialog = jest.fn();\n\n    beforeAll(() => {\n      wrapper = shallow(<Version\n        key={1}\n        details={details}\n        release={release}\n        doHelmChartRollBack={doHelmChartRollBack}\n        showConfirmationDialog={showConfirmationDialog}\n      />);\n    });\n\n    it('Generates a Semantic UI Table Row', () => {\n      expect(wrapper.find('[data-testid=\"VersionRow\"]')).toHaveLength(1);\n    });\n\n    it('Generates a single cell in the table', () => {\n      expect(wrapper.find('[data-testid=\"tableCell\"]')).toHaveLength(1);\n    });\n\n    it('Generates a primary list', () => {\n      expect(wrapper.find('[data-testid=\"mainList\"]')).toHaveLength(1);\n    });\n\n    describe('Rollback icon', () => {\n      it('Renders a rollback icon if status does not equal \"deployed\"', () => {\n        expect(wrapper.find('[name=\"undo\"]')).toHaveLength(1);\n      });\n\n      it('Calls function when clicked', () => {\n        wrapper.find('[name=\"undo\"]').simulate('click');\n        expect(doHelmChartRollBack).toHaveBeenCalled();\n      });\n    });\n\n    describe('Details list', () => {\n      it('Renders a list with 6 items', () => {\n        const subList = wrapper.find('[data-testid=\"subList\"]');\n        expect(subList).toHaveLength(1);\n        expect(subList.children()).toHaveLength(6);\n      });\n    });\n\n    describe('Uninstall Button', () => {\n      it('Should show a confirmation dialog when clicked', () => {\n        wrapper.find('#uninstallBtn').simulate('click');\n        expect(showConfirmationDialog).toHaveBeenCalled();\n      });\n    });\n  });\n});"
        }
    },
    {
        "repo": "tabs",
        "content": "'tabs/example/src/accordion.js'\n:import React from 'react'\nimport { Tabs, useTabState, usePanelState } from '@bumaga/tabs'\nimport { motion } from 'framer-motion'\n\nimport './accordion.css'\n\nconst cn = (...args) => args.filter(Boolean).join(' ')\n\nconst Tab = ({ children }) => {\n  const { isActive, onClick } = useTabState()\n\n  return (\n    <button\n      className={cn('accordion-tab', isActive && 'active')}\n      onClick={onClick}\n    >\n      {children}\n    </button>\n  )\n}\n\nconst panel = {\n  hidden: { height: 0 },\n  visible: { height: 'auto' }\n}\n\nconst Panel = ({ children }) => {\n  const isActive = usePanelState()\n\n  return (\n    <motion.div\n      className='accordion-panel'\n      animate={isActive ? 'visible' : 'hidden'}\n      variants={panel}\n    >\n      {children}\n    </motion.div>\n  )\n}\n\nexport default () => {\n  return (\n    <Tabs>\n      <div className='accordion'>\n        <Tab>Tab 1</Tab>\n        <Panel>\n          <p>\n            Creates a MotionValue that, when set, will use a spring animation to\n            animate to its new state.\n          </p>\n        </Panel>\n\n        <Tab>Tab 2</Tab>\n        <Panel>\n          <p>\n            In sociology, anthropology, and linguistics, structuralism is the\n            methodology that implies elements of human culture must be\n            understood by way of their relationship to a broader, overarching\n            system or structure. It works to uncover the structures that\n            underlie all the things that humans do, think, perceive, and feel.\n            Alternatively, as summarized by philosopher Simon Blackburn,\n            structuralism is \"the belief that phenomena of human life are not\n            intelligible except through their interrelations. These relations\n            constitute a structure, and behind local variations in the surface\n            phenomena there are constant laws of abstract structure\".\n          </p>\n        </Panel>\n\n        <Tab>Tab 3</Tab>\n        <Panel>\n          <p>\n            The input range must be a linear series of numbers. The output range\n            can be any value type supported by Framer Motion: numbers, colors,\n            shadows, etc.\n          </p>\n        </Panel>\n      </div>\n    </Tabs>\n  )\n}\n\n'tabs/example/src/App.js'\n:import React from 'react'\nimport './app.css'\nimport './tabs.css'\n\nimport SimpleTabs from './simple-tabs'\nimport AnimatedTabs from './animated-tabs'\nimport AutoplayedTabs from './autoplayed-tabs'\nimport HeightTabs from './height-tabs'\nimport Accordion from './accordion'\n\nexport default () => {\n  return (\n    <>\n      <SimpleTabs />\n      <HeightTabs />\n      <AnimatedTabs />\n      <AutoplayedTabs />\n      <Accordion />\n    </>\n  )\n}\n\n",
        "called_code_segment": "export default () => {\n  return (\n    <Tabs>\n      <div className='accordion'>\n        <Tab>Tab 1</Tab>\n        <Panel>\n          <p>\n            Creates a MotionValue that, when set, will use a spring animation to\n            animate to its new state.\n          </p>\n        </Panel>\n\n        <Tab>Tab 2</Tab>\n        <Panel>\n          <p>\n            In sociology, anthropology, and linguistics, structuralism is the\n            methodology that implies elements of human culture must be\n            understood by way of their relationship to a broader, overarching\n            system or structure. It works to uncover the structures that\n            underlie all the things that humans do, think, perceive, and feel.\n            Alternatively, as summarized by philosopher Simon Blackburn,\n            structuralism is \"the belief that phenomena of human life are not\n            intelligible except through their interrelations. These relations\n            constitute a structure, and behind local variations in the surface\n            phenomena there are constant laws of abstract structure\".\n          </p>\n        </Panel>\n\n        <Tab>Tab 3</Tab>\n        <Panel>\n          <p>\n            The input range must be a linear series of numbers. The output range\n            can be any value type supported by Framer Motion: numbers, colors,\n            shadows, etc.\n          </p>\n        </Panel>\n      </div>\n    </Tabs>\n  )\n}",
        "invoking_code_segment": "<Accordion />",
        "feature_description": "Add a feature to allow users to close all tabs by clicking a 'Close All' button.",
        "detailed_feature_description": "Add a 'Close All' button in the Accordion component that, when clicked, will close all tabs by setting the active tab to null. Update the Tabs component to handle this new functionality.",
        "modified_complete_code": {
            "accordion.js": "import React from 'react'\nimport { Tabs, useTabState, usePanelState } from '@bumaga/tabs'\nimport { motion } from 'framer-motion'\n\nimport './accordion.css'\n\nconst cn = (...args) => args.filter(Boolean).join(' ')\n\nconst Tab = ({ children }) => {\n  const { isActive, onClick } = useTabState()\n\n  return (\n    <button\n      className={cn('accordion-tab', isActive && 'active')}\n      onClick={onClick}\n    >\n      {children}\n    </button>\n  )\n}\n\nconst panel = {\n  hidden: { height: 0 },\n  visible: { height: 'auto' }\n}\n\nconst Panel = ({ children }) => {\n  const isActive = usePanelState()\n\n  return (\n    <motion.div\n      className='accordion-panel'\n      animate={isActive ? 'visible' : 'hidden'}\n      variants={panel}\n    >\n      {children}\n    </motion.div>\n  )\n}\n\n#Modify\nexport default () => {\n  return (\n    <Tabs>\n      <div className='accordion'>\n        <button onClick={() => Tabs.setActive(null)}>Close All</button> #New\n        <Tab>Tab 1</Tab>\n        <Panel>\n          <p>\n            Creates a MotionValue that, when set, will use a spring animation to\n            animate to its new state.\n          </p>\n        </Panel>\n\n        <Tab>Tab 2</Tab>\n        <Panel>\n          <p>\n            In sociology, anthropology, and linguistics, structuralism is the\n            methodology that implies elements of human culture must be\n            understood by way of their relationship to a broader, overarching\n            system or structure. It works to uncover the structures that\n            underlie all the things that humans do, think, perceive, and feel.\n            Alternatively, as summarized by philosopher Simon Blackburn,\n            structuralism is \"the belief that phenomena of human life are not\n            intelligible except through their interrelations. These relations\n            constitute a structure, and behind local variations in the surface\n            phenomena there are constant laws of abstract structure\".\n          </p>\n        </Panel>\n\n        <Tab>Tab 3</Tab>\n        <Panel>\n          <p>\n            The input range must be a linear series of numbers. The output range\n            can be any value type supported by Framer Motion: numbers, colors,\n            shadows, etc.\n          </p>\n        </Panel>\n      </div>\n    </Tabs>\n  )\n}",
            "App.js": "import React from 'react'\nimport './app.css'\nimport './tabs.css'\n\nimport SimpleTabs from './simple-tabs'\nimport AnimatedTabs from './animated-tabs'\nimport AutoplayedTabs from './autoplayed-tabs'\nimport HeightTabs from './height-tabs'\nimport Accordion from './accordion'\n\n#Modify\nexport default () => {\n  return (\n    <>\n      <SimpleTabs />\n      <HeightTabs />\n      <AnimatedTabs />\n      <AutoplayedTabs />\n      <Accordion />\n    </>\n  )\n}"
        }
    },
    {
        "repo": "FitnessApp",
        "content": "'FitnessApp/src/components/Card.js'\n:import React from 'react'\nimport circlesImg from '../images/circles.png'\nimport emptyImg from '../images/empty.png'\nimport './styles/Card.css'\n\nconst Card = ({ title, description, img, leftColor, rightColor }) => (\n    \n    <div className=\"card mx-auto Fitness-Card\"\n    style={{\n        backgroundImage: `url(${circlesImg}), linear-gradient(to right, ${leftColor || '#56CCF2'}  , ${rightColor|| '#2F80ED'}) `\n    }}\n    >\n        <div className=\"card-body\">\n            <div className=\"row center\">\n                <div className=\"col-6\">\n                    <img src={img || emptyImg} className=\"float-right\" alt=\"exercise\"/>\n                </div> \n                <div className=\"col-6 Fitness-Card-Info\">\n                    <h1>{title}</h1>\n                    <p>{description}</p>\n                </div>\n            </div>\n        </div>\n    </div>\n)\n\nexport default Card\n'FitnessApp/src/components/ExerciseList.js'\n:import React, { Fragment } from 'react'\nimport Card from './Card'\n\nconst ExerciseList = ({exercises}) => (\n    <Fragment>\n        { exercises.map((exercise) => (\n            <Card \n                key={exercise.id}\n                {...exercise}\n            />\n        ))}\n    </Fragment>    \n)\n\n\nexport default ExerciseList\n",
        "called_code_segment": "const Card = ({ title, description, img, leftColor, rightColor }) => (\n    <div className=\"card mx-auto Fitness-Card\"\n    style={{ backgroundImage: `url(${circlesImg}), linear-gradient(to right, ${leftColor || '#56CCF2'}  , ${rightColor|| '#2F80ED'}) ` }}\n    >\n        <div className=\"card-body\">\n            <div className=\"row center\">\n                <div className=\"col-6\">\n                    <img src={img || emptyImg} className=\"float-right\" alt=\"exercise\"/>\n                </div> \n                <div className=\"col-6 Fitness-Card-Info\">\n                    <h1>{title}</h1>\n                    <p>{description}</p>\n                </div>\n            </div>\n        </div>\n    </div>\n)\n\nexport default Card",
        "invoking_code_segment": "<Fragment>\n    { exercises.map((exercise) => (\n        <Card \n            key={exercise.id}\n            {...exercise}\n        />\n    ))}\n</Fragment>",
        "feature_description": "Add a new feature to toggle the visibility of the exercise description.",
        "detailed_feature_description": "Introduce a new prop 'showDescription' to the Card component. If 'showDescription' is true, the description will be visible; otherwise, it will be hidden. Modify the ExerciseList component to pass this new prop based on a user action or state.",
        "modified_complete_code": {
            "Card.js": "import React from 'react'\nimport circlesImg from '../images/circles.png'\nimport emptyImg from '../images/empty.png'\nimport './styles/Card.css'\n\nconst Card = ({ title, description, img, leftColor, rightColor, showDescription }) => (\n    <div className=\"card mx-auto Fitness-Card\"\n    style={{ backgroundImage: `url(${circlesImg}), linear-gradient(to right, ${leftColor || '#56CCF2'}  , ${rightColor|| '#2F80ED'}) ` }}\n    >\n        <div className=\"card-body\">\n            <div className=\"row center\">\n                <div className=\"col-6\">\n                    <img src={img || emptyImg} className=\"float-right\" alt=\"exercise\"/>\n                </div> \n                <div className=\"col-6 Fitness-Card-Info\">\n                    <h1>{title}</h1>\n                    {showDescription && <p>{description}</p>}\n                </div>\n            </div>\n        </div>\n    </div>\n)\n\nexport default Card",
            "ExerciseList.js": "import React, { Fragment, useState } from 'react'\nimport Card from './Card'\n\nconst ExerciseList = ({exercises}) => {\n    const [showDescriptions, setShowDescriptions] = useState(false);\n\n    return (\n        <Fragment>\n            <button onClick={() => setShowDescriptions(!showDescriptions)}>\n                {showDescriptions ? 'Hide Descriptions' : 'Show Descriptions'}\n            </button>\n            { exercises.map((exercise) => (\n                <Card \n                    key={exercise.id}\n                    {...exercise}\n                    showDescription={showDescriptions}\n                />\n            ))}\n        </Fragment>\n    )\n}\n\nexport default ExerciseList"
        }
    },
    {
        "repo": "Instagram",
        "content": "'Instagram/components/PhotoGridItem.js'\n:import { Ionicons } from '@expo/vector-icons';\nimport React from 'react';\nimport { Image, TouchableOpacity } from 'react-native';\n\nimport Square from './Square';\nimport NavigationService from '../navigation/NavigationService';\n\nexport default class PhotoGridItem extends React.PureComponent {\n  render() {\n    const { hasMulti } = this.props;\n    return (\n      <Square\n        style={{\n          aspectRatio: 1,\n          flex: 0.333,\n          marginRight: 1,\n        }}\n      >\n        <TouchableOpacity\n          onPress={() =>\n            NavigationService.navigate('Profile_Details', { item: this.props })\n          }\n          activeOpacity={0.6}\n          style={{ flex: 1 }}\n        >\n          <Image\n            style={{\n              resizeMode: 'cover',\n              flex: 1,\n            }}\n            source={this.props.source}\n          />\n        </TouchableOpacity>\n\n        {hasMulti && (\n          <Ionicons\n            style={{\n              transform: [{ scaleX: -1 }],\n              position: 'absolute',\n              top: 8,\n              right: 8,\n            }}\n            name={'md-copy'}\n            size={26}\n            color={'white'}\n          />\n        )}\n      </Square>\n    );\n  }\n}\n\n'Instagram/components/PhotoGrid.js'\n:import React from 'react';\nimport { FlatList } from 'react-native';\n\nimport PhotoGridItem from './PhotoGridItem';\n\nexport default class PhotoGrid extends React.Component {\n  render() {\n    const { onPressFooter, ...props } = this.props;\n    return (\n      <FlatList\n        numColumns={3}\n        columnWrapperStyle={{\n          marginHorizontal: -1,\n          marginBottom: 1,\n          justifyContent: 'space-between',\n        }}\n        contentContainerStyle={{ marginBottom: 64 }}\n        renderItem={({ item }) => <PhotoGridItem {...item} />}\n        keyExtractor={(item, index) => item.key + ' ' + index}\n        {...props}\n      />\n    );\n  }\n}\n\n",
        "called_code_segment": "export default class PhotoGridItem extends React.PureComponent {\n  render() {\n    const { hasMulti } = this.props;\n    return (\n      <Square\n        style={{\n          aspectRatio: 1,\n          flex: 0.333,\n          marginRight: 1,\n        }}\n      >\n        <TouchableOpacity\n          onPress={() =>\n            NavigationService.navigate('Profile_Details', { item: this.props })\n          }\n          activeOpacity={0.6}\n          style={{ flex: 1 }}\n        >\n          <Image\n            style={{\n              resizeMode: 'cover',\n              flex: 1,\n            }}\n            source={this.props.source}\n          />\n        </TouchableOpacity>\n\n        {hasMulti &&\n          <Ionicons\n            style={{\n              transform: [{ scaleX: -1 }],\n              position: 'absolute',\n              top: 8,\n              right: 8,\n            }}\n            name={'md-copy'}\n            size={26}\n            color={'white'}\n          />\n        }\n      </Square>\n    );\n  }\n}",
        "invoking_code_segment": "renderItem={({ item }) => <PhotoGridItem {...item} />}",
        "feature_description": "Add a feature to allow users to long press on a photo to view a larger preview.",
        "detailed_feature_description": "Modify the PhotoGridItem component to include a long press handler that navigates to a new screen displaying a larger version of the photo. Update the PhotoGrid component to pass a longPress handler to the PhotoGridItem component.",
        "modified_complete_code": {
            "PhotoGridItem.js": "import { Ionicons } from '@expo/vector-icons';\nimport React from 'react';\nimport { Image, TouchableOpacity, TouchableWithoutFeedback } from 'react-native';\n\nimport Square from './Square';\nimport NavigationService from '../navigation/NavigationService';\n\nexport default class PhotoGridItem extends React.PureComponent {\n  render() {\n    const { hasMulti, onLongPress } = this.props;\n    return (\n      <Square\n        style={{\n          aspectRatio: 1,\n          flex: 0.333,\n          marginRight: 1,\n        }}\n      >\n        <TouchableWithoutFeedback\n          onPress={() =>\n            NavigationService.navigate('Profile_Details', { item: this.props })\n          }\n          onLongPress={onLongPress}\n          activeOpacity={0.6}\n          style={{ flex: 1 }}\n        >\n          <Image\n            style={{\n              resizeMode: 'cover',\n              flex: 1,\n            }}\n            source={this.props.source}\n          />\n        </TouchableWithoutFeedback>\n\n        {hasMulti &&\n          <Ionicons\n            style={{\n              transform: [{ scaleX: -1 }],\n              position: 'absolute',\n              top: 8,\n              right: 8,\n            }}\n            name={'md-copy'}\n            size={26}\n            color={'white'}\n          />\n        }\n      </Square>\n    );\n  }\n}",
            "PhotoGrid.js": "import React from 'react';\nimport { FlatList } from 'react-native';\n\nimport PhotoGridItem from './PhotoGridItem';\n\nexport default class PhotoGrid extends React.Component {\n  handleLongPress = (item) => {\n    NavigationService.navigate('Photo_Preview', { item });\n  };\n\n  render() {\n    const { onPressFooter, ...props } = this.props;\n    return (\n      <FlatList\n        numColumns={3}\n        columnWrapperStyle={{\n          marginHorizontal: -1,\n          marginBottom: 1,\n          justifyContent: 'space-between',\n        }}\n        contentContainerStyle={{ marginBottom: 64 }}\n        renderItem={({ item }) => (\n          <PhotoGridItem\n            {...item}\n            onLongPress={() => this.handleLongPress(item)}\n          />\n        )}\n        keyExtractor={(item, index) => item.key + ' ' + index}\n        {...props}\n      />\n    );\n  }\n}"
        }
    },
    {
        "repo": "Laravel-Media-Manager",
        "content": "'Laravel-Media-Manager/src/resources/assets/js/modules/icons.js'\n:import 'vue-awesome/icons/shopping-basket'\nimport 'vue-awesome/icons/map'\nimport 'vue-awesome/icons/regular/map'\nimport 'vue-awesome/icons/folder'\nimport 'vue-awesome/icons/regular/folder-open'\nimport 'vue-awesome/icons/sync'\nimport 'vue-awesome/icons/share'\nimport 'vue-awesome/icons/terminal'\nimport 'vue-awesome/icons/regular/trash-alt'\nimport 'vue-awesome/icons/minus'\nimport 'vue-awesome/icons/plus'\nimport 'vue-awesome/icons/puzzle-piece'\nimport 'vue-awesome/icons/image'\nimport 'vue-awesome/icons/music'\nimport 'vue-awesome/icons/times'\nimport 'vue-awesome/icons/search'\nimport 'vue-awesome/icons/globe-americas'\nimport 'vue-awesome/icons/angle-double-right'\nimport 'vue-awesome/icons/angle-double-left'\nimport 'vue-awesome/icons/bars'\nimport 'vue-awesome/icons/regular/clone'\nimport 'vue-awesome/icons/regular/file-pdf'\nimport 'vue-awesome/icons/power-off'\nimport 'vue-awesome/icons/regular/file-alt'\nimport 'vue-awesome/icons/download'\nimport 'vue-awesome/icons/exclamation-triangle'\nimport 'vue-awesome/icons/archive'\nimport 'vue-awesome/icons/lock-open'\nimport 'vue-awesome/icons/lock'\nimport 'vue-awesome/icons/eye'\nimport 'vue-awesome/icons/eye-slash'\nimport 'vue-awesome/icons/film'\nimport 'vue-awesome/icons/regular/object-ungroup'\nimport 'vue-awesome/icons/circle'\nimport 'vue-awesome/icons/link'\nimport 'vue-awesome/icons/spinner'\nimport 'vue-awesome/icons/key'\nimport 'vue-awesome/icons/cogs'\nimport 'vue-awesome/icons/cog'\nimport 'vue-awesome/icons/regular/clock'\nimport 'vue-awesome/icons/regular/file-archive'\nimport 'vue-awesome/icons/chevron-down'\nimport 'vue-awesome/icons/angle-down'\nimport 'vue-awesome/icons/cloud-upload-alt'\nimport 'vue-awesome/icons/shopping-cart'\nimport 'vue-awesome/icons/cart-plus'\nimport 'vue-awesome/icons/microphone'\n// cropperjs\nimport 'vue-awesome/icons/crop'\nimport 'vue-awesome/icons/ban'\nimport 'vue-awesome/icons/check'\nimport 'vue-awesome/icons/arrows-alt'\nimport 'vue-awesome/icons/search-plus'\nimport 'vue-awesome/icons/search-minus'\nimport 'vue-awesome/icons/undo'\nimport 'vue-awesome/icons/redo'\nimport 'vue-awesome/icons/arrows-alt-h'\nimport 'vue-awesome/icons/arrows-alt-v'\nimport 'vue-awesome/icons/code'\nimport 'vue-awesome/icons/arrow-left'\nimport 'vue-awesome/icons/arrow-right'\n// filters\nimport 'vue-awesome/icons/regular/sun'\nimport 'vue-awesome/icons/adjust'\nimport 'vue-awesome/icons/bolt'\nimport 'vue-awesome/icons/thermometer-half'\nimport 'vue-awesome/icons/eye-dropper'\nimport 'vue-awesome/icons/regular/lemon'\nimport 'vue-awesome/icons/flask'\nimport 'vue-awesome/icons/regular/dot-circle'\nimport 'vue-awesome/icons/cut'\nimport 'vue-awesome/icons/regular/gem'\nimport 'vue-awesome/icons/glass-martini'\nimport 'vue-awesome/icons/cube'\nimport 'vue-awesome/icons/shield-alt'\nimport 'vue-awesome/icons/low-vision'\n\n// custom\nimport Icon from 'vue-awesome/components/Icon'\nIcon.register({\n    pill: {\n        width  : 21,\n        height : 27,\n        d      : 'M3.500, 25.187 C0.152, 23.254 -0.995, 18.973 0.938, 15.625 C0.938, 15.625 7.938, 3.500 7.938, 3.500 C9.871, 0.152 14.152, -0.995 17.500, 0.938 C20.848, 2.871 21.995, 7.152 20.062, 10.500 C20.062, 10.500 13.062, 22.625 13.062, 22.625 C11.129, 25.973 6.848, 27.120 3.500, 25.187 ZM15.201, 1.920 C13.527, 0.954 11.386, 1.527 10.420, 3.201 C9.903, 4.097 9.839, 5.123 10.136, 6.034 C10.225, 5.681 10.345, 5.332 10.536, 5.000 C11.640, 3.087 14.087, 2.432 16.000, 3.536 C16.331, 3.727 16.610, 3.970 16.863, 4.232 C16.665, 3.294 16.097, 2.437 15.201, 1.920 ZM14.830, 15.562 C14.830, 15.562 6.170, 10.563 6.170, 10.563 C6.170, 10.563 2.670, 16.625 2.670, 16.625 C1.289, 19.016 2.109, 22.074 4.500, 23.455 C6.891, 24.835 9.949, 24.016 11.330, 21.625 C11.330, 21.625 14.830, 15.562 14.830, 15.562 ZM5.866, 23.089 C5.090, 22.641 4.601, 21.895 4.437, 21.081 C4.505, 21.126 4.562, 21.181 4.634, 21.223 C6.547, 22.327 8.994, 21.672 10.098, 19.759 C10.139, 19.687 10.161, 19.610 10.198, 19.537 C10.463, 20.325 10.412, 21.214 9.964, 21.991 C9.136, 23.426 7.301, 23.917 5.866, 23.089 Z'\n    },\n    pref: {\n        height : 26,\n        width  : 26,\n        d      : 'M25.567, 14.005 C25.567, 14.005 22.847, 16.726 22.847, 16.726 C22.283, 17.289 21.370, 17.289 20.806, 16.726 C20.243, 16.162 20.243, 15.249 20.806, 14.685 C20.806, 14.685 22.507, 12.985 22.507, 12.985 C22.507, 12.985 20.806, 11.285 20.806, 11.285 C20.243, 10.721 20.243, 9.808 20.806, 9.244 C21.370, 8.681 22.283, 8.681 22.847, 9.244 C22.847, 9.244 25.567, 11.965 25.567, 11.965 C26.131, 12.528 26.131, 13.442 25.567, 14.005 ZM13.000, 18.000 C10.238, 18.000 8.000, 15.761 8.000, 13.000 C8.000, 10.238 10.238, 8.000 13.000, 8.000 C15.761, 8.000 18.000, 10.238 18.000, 13.000 C18.000, 15.761 15.761, 18.000 13.000, 18.000 ZM13.000, 11.000 C11.895, 11.000 11.000, 11.895 11.000, 13.000 C11.000, 14.104 11.895, 15.000 13.000, 15.000 C14.104, 15.000 15.000, 14.104 15.000, 13.000 C15.000, 11.895 14.104, 11.000 13.000, 11.000 ZM14.685, 5.163 C14.685, 5.163 12.985, 3.463 12.985, 3.463 C12.985, 3.463 11.285, 5.163 11.285, 5.163 C10.721, 5.727 9.807, 5.727 9.244, 5.163 C8.681, 4.600 8.681, 3.686 9.244, 3.123 C9.244, 3.123 11.965, 0.402 11.965, 0.402 C12.528, -0.161 13.441, -0.161 14.005, 0.402 C14.005, 0.402 16.726, 3.123 16.726, 3.123 C17.289, 3.686 17.289, 4.600 16.726, 5.163 C16.162, 5.727 15.249, 5.727 14.685, 5.163 ZM5.163, 16.726 C4.600, 17.289 3.686, 17.289 3.123, 16.726 C3.123, 16.726 0.402, 14.005 0.402, 14.005 C-0.161, 13.442 -0.161, 12.528 0.402, 11.965 C0.402, 11.965 3.123, 9.244 3.123, 9.244 C3.686, 8.681 4.600, 8.681 5.163, 9.244 C5.727, 9.808 5.727, 10.721 5.163, 11.285 C5.163, 11.285 3.463, 12.985 3.463, 12.985 C3.463, 12.985 5.163, 14.685 5.163, 14.685 C5.727, 15.249 5.727, 16.162 5.163, 16.726 ZM11.285, 20.806 C11.285, 20.806 12.985, 22.507 12.985, 22.507 C12.985, 22.507 14.685, 20.806 14.685, 20.806 C15.249, 20.243 16.162, 20.243 16.726, 20.806 C17.289, 21.370 17.289, 22.283 16.726, 22.847 C16.726, 22.847 14.005, 25.567 14.005, 25.567 C13.441, 26.131 12.528, 26.131 11.965, 25.567 C11.965, 25.567 9.244, 22.847 9.244, 22.847 C8.681, 22.283 8.681, 21.370 9.244, 20.806 C9.807, 20.243 10.721, 20.243 11.285, 20.806 Z'\n    },\n    desktop: {\n        height : 72,\n        width  : 90,\n        paths  : [\n            {\n                d: 'm84.68.56h-79.36c-2.93977172.00551553-5.32000517 2.39022311-5.32 5.33v46.69c.00550306 2.9358724 2.38412759 5.3144969 5.32 5.32h31.46v4.5c.0014433.8471475-.2722874 1.6718489-.78 2.35l-3.28 4.36c-.3274215.4412156-.3794159 1.0288913-.1345469 1.5207401.2448689.4918488.7451344.8045797 1.2945469.8092599h22.25c.5494125-.0046802 1.049678-.3174111 1.2945469-.8092599.244869-.4918488.1928746-1.0795245-.1345469-1.5207401l-3.29-4.36c-.5112826-.6768965-.7885602-1.5017096-.79-2.35v-4.5h31.47c2.9358724-.0055031 5.3144969-2.3841276 5.32-5.32v-46.69c.0000052-2.93977689-2.3802283-5.32448447-5.32-5.33zm-33 65.94 1.53 2h-16.43l1.53-2c.8885236-1.1822932 1.3692791-2.6210508 1.37-4.1v-4.5h10.64v4.5c.0007209 1.4789492.4814764 2.9177068 1.37 4.1zm35.42-13.92c-.0054795 1.3342528-1.0857472 2.4145205-2.42 2.42h-79.36c-1.3342528-.0054795-2.41452045-1.0857472-2.42-2.42v-46.69c0-1.33652909 1.08347091-2.42 2.42-2.42h79.36c1.3365291 0 2.42 1.08347091 2.42 2.42z'\n            },\n            {\n                d: 'm39.15 29.86 5.17-5.16c.5660919-.5688533.5638533-1.4889081-.005-2.055s-1.4889081-.5638533-2.055.005l-5.16 5.16c-.4051413.4143886-.5268327 1.0291737-.3101061 1.5666557s.7308368.8958954 1.3101061.9133443c.3947724.010028.775658-.1459537 1.05-.43z'\n            },\n            {\n                d: 'm50.85 31.23-5.17 5.16c-.4483316.3472666-.6530725.9240252-.5240456 1.4762456.1290268.5522205.5681383.9785423 1.1239303 1.0911945.5557921.1126523 1.1262486-.1090425 1.4601153-.5674401l5.16-5.16c.4678285-.3306951.6970816-.9058431.5850161-1.467683-.1120654-.5618399-.5444358-1.0050195-1.1033378-1.1309213-.558902-.1259017-1.1395345.0890825-1.4816783.5486043z'\n            },\n            {\n                d: 'm51.65 23.89c-.5619995-.5283108-1.4380005-.5283108-2 0l-11.3 11.25c-.4148987.4109913-.5427446 1.0307734-.3243475 1.5723982s.7404066.8993684 1.3243475.9076018c.3753331-.0043166.7341463-.1550182 1-.42l11.3-11.2c.2905669-.2739656.4552764-.6556427.4552764-1.055s-.1647095-.7810344-.4552764-1.055z'\n            },\n            {\n                d: 'm45 9.78c.8560414 0 1.55-.69395864 1.55-1.55s-.6939586-1.55-1.55-1.55-1.55.69395864-1.55 1.55c-.0026835.41190235.1597577.807712.4510229 1.09897712.2912651.29126513.6870747.45370637 1.0989771.45102288z'\n            }\n        ]\n    },\n    laptop: {\n        height : 60,\n        width  : 90,\n        paths  : [\n            {\n                d: 'm39.63 28.56 4.81-4.81c.425074-.5836248.3559972-1.3910642-.1620329-1.8940061-.5180302-.5029419-1.3271582-.5481285-1.8979671-.1059939l-4.8 4.8c-.4148987.4109913-.5427446 1.0307734-.3243475 1.5723982s.7404066.8993684 1.3243475.9076018c.400097-.003987.7804967-.1742611 1.05-.47z'\n            },\n            {\n                d: 'm50.37 29.68-4.81 4.81c-.5283108.5619995-.5283108 1.4380005 0 2 .5718434.5615882 1.4881566.5615882 2.06 0l4.8-4.8c.5688533-.5660919.5710919-1.4861467.005-2.055s-1.4861467-.5710919-2.055-.005z'\n            },\n            {\n                d: 'm51.26 22.86c-.557935-.5384711-1.442065-.5384711-2 0l-10.52 10.46c-.2748116.2723004-.4294119.6431294-.4294119 1.03s.1546003.7576996.4294119 1.03c.2681757.2614984.6255286.4115866 1 .42.3753331-.0043166.7341463-.1550182 1-.42l10.52-10.47c.2742158-.2705834.4285777-.6397602.4285777-1.025s-.1543619-.7544166-.4285777-1.025z'\n            },\n            {\n                d: 'm45 8.76c.79529 0 1.44-.64470996 1.44-1.44s-.64471-1.44-1.44-1.44-1.44.64470996-1.44 1.44c-.0026859.38272882.1481653.7505611.4188021 1.02119791s.6384691.42148801 1.0211979.41880209z'\n            },\n            {\n                d: 'm87 50.72v-45.31c-.0055155-2.93977172-2.3902231-5.32000517-5.33-5.32h-73.3c-1.41879014-.0106503-2.78327325.54482311-3.79121915 1.54338405-1.00794591.99856094-1.57615885 2.35778826-1.57878085 3.77661595v45.31h-3v4.74c0 2.4576671 1.99233286 4.45 4.45 4.45h81.1c2.4576671 0 4.45-1.9923329 4.45-4.45v-4.74zm-81-45.31c.00514697-1.31335366 1.0569164-2.38287447 2.37-2.41h73.26c1.3365291 0 2.42 1.08347091 2.42 2.42v45.3h-78.05zm81.1 50.05c-.0054977.8521335-.6978487 1.5400177-1.55 1.54h-81.1c-.85215128.0000177-1.54450225-.6878665-1.55-1.54v-1.84h84.2z'\n            },\n            {\n                d: 'm39.63 28.56 4.81-4.81c.425074-.5836248.3559972-1.3910642-.1620329-1.8940061-.5180302-.5029419-1.3271582-.5481285-1.8979671-.1059939l-4.8 4.8c-.4148987.4109913-.5427446 1.0307734-.3243475 1.5723982s.7404066.8993684 1.3243475.9076018c.400097-.003987.7804967-.1742611 1.05-.47z'\n            },\n            {\n                d: 'm50.37 29.68-4.81 4.81c-.5283108.5619995-.5283108 1.4380005 0 2 .5718434.5615882 1.4881566.5615882 2.06 0l4.8-4.8c.5688533-.5660919.5710919-1.4861467.005-2.055s-1.4861467-.5710919-2.055-.005z'\n            },\n            {\n                d: 'm51.26 22.86c-.557935-.5384711-1.442065-.5384711-2 0l-10.52 10.46c-.2748116.2723004-.4294119.6431294-.4294119 1.03s.1546003.7576996.4294119 1.03c.2681757.2614984.6255286.4115866 1 .42.3753331-.0043166.7341463-.1550182 1-.42l10.52-10.47c.2742158-.2705834.4285777-.6397602.4285777-1.025s-.1543619-.7544166-.4285777-1.025z'\n            },\n            {\n                d: 'm45 8.76c.79529 0 1.44-.64470996 1.44-1.44s-.64471-1.44-1.44-1.44-1.44.64470996-1.44 1.44c-.0026859.38272882.1481653.7505611.4188021 1.02119791s.6384691.42148801 1.0211979.41880209z'\n            },\n            {\n                d: 'm87 50.72v-45.31c-.0055155-2.93977172-2.3902231-5.32000517-5.33-5.32h-73.3c-1.41879014-.0106503-2.78327325.54482311-3.79121915 1.54338405-1.00794591.99856094-1.57615885 2.35778826-1.57878085 3.77661595v45.31h-3v4.74c0 2.4576671 1.99233286 4.45 4.45 4.45h81.1c2.4576671 0 4.45-1.9923329 4.45-4.45v-4.74zm-81-45.31c.00514697-1.31335366 1.0569164-2.38287447 2.37-2.41h73.26c1.3365291 0 2.42 1.08347091 2.42 2.42v45.3h-78.05zm81.1 50.05c-.0054977.8521335-.6978487 1.5400177-1.55 1.54h-81.1c-.85215128.0000177-1.54450225-.6878665-1.55-1.54v-1.84h84.2z'\n            }\n        ]\n    },\n    mobile: {\n        height : 90,\n        width  : 52,\n        paths  : [\n            {\n                d: 'm19.87 9.34h12.26c.8008129 0 1.45-.64918711 1.45-1.45s-.6491871-1.45-1.45-1.45h-12.26c-.8008129 0-1.45.64918711-1.45 1.45s.6491871 1.45 1.45 1.45z'\n            },\n            {\n                d: 'm46.65 0h-41.3c-1.41533474-.00531333-2.77466719.55251955-3.77827694 1.55050158-1.00360974.99798202-1.5690776 2.35415618-1.57172306 3.76949842v79.36c.00264546 1.4153422.56811332 2.7715164 1.57172306 3.7694984 1.00360975.9979821 2.3629422 1.5558149 3.77827694 1.5505016h41.3c1.4153347.0053133 2.7746672-.5525195 3.7782769-1.5505016 1.0036098-.997982 1.5690776-2.3541562 1.5717231-3.7694984v-79.36c-.0026455-1.41534224-.5681133-2.7715164-1.5717231-3.76949842-1.0036097-.99798203-2.3629422-1.55581491-3.7782769-1.55050158zm2.42 84.68c0 1.3365291-1.0834709 2.42-2.42 2.42h-41.3c-1.33652909 0-2.42-1.0834709-2.42-2.42v-79.36c0-1.33652909 1.08347091-2.42 2.42-2.42h41.3c1.3365291 0 2.42 1.08347091 2.42 2.42z'\n            },\n            {\n                d: 'm18.88 45.49c-.5384711.557935-.5384711 1.442065 0 2l4.58 4.58c.557935.5384711 1.442065.5384711 2 0 .5384711-.557935.5384711-1.442065 0-2l-4.58-4.58c-.557935-.5384711-1.442065-.5384711-2 0z'\n            },\n            {\n                d: 'm33.12 42.46-4.58-4.58c-.5729852-.3614446-1.3198825-.2779579-1.7989202.2010798s-.5625244 1.225935-.2010798 1.7989202l4.58 4.58c.2660282.2660158.6239234.4199107 1 .43.5792693-.0174489 1.0933795-.3758623 1.3101061-.9133443s.0950352-1.1522671-.3101061-1.5666557z'\n            },\n            {\n                d: 'm31 51.44c.5667986-.0228216 1.0682394-.3740655 1.2833569-.8989521.2151174-.5248866.1044025-1.127014-.2833569-1.5410479l-10-10c-.5737076-.339465-1.3044921-.2472295-1.7758608.2241392s-.5636042 1.2021532-.2241392 1.7758608l10 10c.2650197.2688332.6227504.4262348 1 .44z'\n            },\n            {\n                d: 'm31.9 77.4h-11.8c-1.83521-.0000083-3.3244889 1.4847982-3.33 3.32v.37c.0054913 1.8368288 1.4931712 3.3245087 3.33 3.33h11.8c1.8368288-.0054913 3.3245087-1.4931712 3.33-3.33v-.37c-.0055111-1.8352018-1.49479-3.3200083-3.33-3.32zm.42 3.69c.0026939.1131133-.0403638.2225291-.1194229.3034706-.0790592.0809415-.1874317.1265615-.3005771.1265294h-11.8c-.1131454.0000321-.2215179-.0455879-.3005771-.1265294-.0790591-.0809415-.1221168-.1903573-.1194229-.3034706v-.37c0-.1113909.0442499-.2182196.1230152-.2969848.0787652-.0787653.1855939-.1230152.2969848-.1230152h11.8c.2319596 0 .42.1880404.42.42z'\n            }\n        ]\n    }\n})\n\n'Laravel-Media-Manager/src/resources/assets/js/manager.js'\n:import Vue from 'vue'\n/*                Libs                */\nimport VueClipboard from 'vue-clipboard2'\nimport Vue2Filters  from 'vue2-filters'\n\nVue.use(Vue2Filters)\nVue.use(VueClipboard)\nVue.use(require('vue-ls'))\nwindow.EventHub = require('vuemit')\nwindow.keycode  = require('keycode')\nwindow.Fuse     = require('fuse.js')\n\n// vue-tippy\nVue.use(require('vue-tippy').default, {\n    popperOptions: {\n        modifiers: {\n            hide: {enabled: false}\n        }\n    }\n})\n\n// v-touch\nlet VueTouch = require('vue-touch')\nVueTouch.registerCustomEvent('dbltap', {type: 'tap', taps: 2})\nVueTouch.registerCustomEvent('hold', {type: 'press', time: 500})\nVue.use(VueTouch)\n\n// axios\nwindow.axios                  = require('axios').default\naxios.defaults.headers.common = {\n    'X-CSRF-TOKEN'     : document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content'),\n    'X-Requested-With' : 'XMLHttpRequest'\n}\naxios.interceptors.response.use(\n    (response) => response,\n    (error) => Promise.reject(error.response)\n)\n\n// Echo\n// import EchoLib from 'laravel-echo'\n// window.Echo = new EchoLib({\n//     broadcaster: 'pusher',\n//     key: 'your-pusher-key'\n// });\n\n// vue-awesome\nrequire('./modules/icons')\nVue.component('Icon', require('vue-awesome/components/Icon').default)\nVue.component('IconTypes', require('./components/utils/icon-types.vue').default)\n\n/*                Components                */\nVue.component('MediaManager', require('./components/manager.vue').default)\nVue.component('MyNotification', require('vue-notif').default)\nVue.component('MyDropdown', require('./components/utils/dropdown.vue').default)\n\n/*                Events                */\nif ('connection' in navigator) {\n    if (!navigator.connection.saveData) {\n        require('./modules/events')\n    }\n}\n\n",
        "called_code_segment": "Vue.component('MediaManager', require('./components/manager.vue').default)",
        "invoking_code_segment": "Vue.component('MediaManager', require('./components/manager.vue').default)",
        "feature_description": "Add a new prop to the MediaManager component to allow dynamic title customization.",
        "detailed_feature_description": "Introduce a new prop named 'title' in the MediaManager component. This prop will allow the parent component to dynamically set the title of the MediaManager. Update the invoking code in #file 2 to pass a custom title to the MediaManager component.",
        "modified_complete_code": {
            "#file 1": "// manager.js\n:import Vue from 'vue'\n/*                Libs                */\nimport VueClipboard from 'vue-clipboard2'\nimport Vue2Filters  from 'vue2-filters'\n\nVue.use(Vue2Filters)\nVue.use(VueClipboard)\nVue.use(require('vue-ls'))\nwindow.EventHub = require('vuemit')\nwindow.keycode  = require('keycode')\nwindow.Fuse     = require('fuse.js')\n\n// vue-tippy\nVue.use(require('vue-tippy').default, {\n    popperOptions: {\n        modifiers: {\n            hide: {enabled: false}\n        }\n    }\n})\n\n// v-touch\nlet VueTouch = require('vue-touch')\nVueTouch.registerCustomEvent('dbltap', {type: 'tap', taps: 2})\nVueTouch.registerCustomEvent('hold', {type: 'press', time: 500})\nVue.use(VueTouch)\n\n// axios\nwindow.axios                  = require('axios').default\naxios.defaults.headers.common = {\n    'X-CSRF-TOKEN'     : document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content'),\n    'X-Requested-With' : 'XMLHttpRequest'\n}\naxios.interceptors.response.use(\n    (response) => response,\n    (error) => Promise.reject(error.response)\n)\n\n// Echo\n// import EchoLib from 'laravel-echo'\n// window.Echo = new EchoLib({\n//     broadcaster: 'pusher',\n//     key: 'your-pusher-key'\n// });\n\n// vue-awesome\nrequire('./modules/icons')\nVue.component('Icon', require('vue-awesome/components/Icon').default)\nVue.component('IconTypes', require('./components/utils/icon-types.vue').default)\n\n/*                Components                */\nVue.component('MediaManager', {\n    props: ['title'],\n    template: '<div>{{ title }}</div>'\n})\nVue.component('MyNotification', require('vue-notif').default)\nVue.component('MyDropdown', require('./components/utils/dropdown.vue').default)\n\n/*                Events                */\nif ('connection' in navigator) {\n    if (!navigator.connection.saveData) {\n        require('./modules/events')\n    }\n}",
            "#file 2": "// main.js\nnew Vue({\n    el: '#app',\n    data: {\n        managerTitle: 'Custom Media Manager Title'\n    },\n    components: {\n        MediaManager: require('./components/manager.vue').default\n    },\n    template: '<MediaManager :title=\"managerTitle\" />'\n})"
        }
    },
    {
        "repo": "Next-GraphQL-Blog",
        "content": "'Next-GraphQL-Blog/server/resolvers/mutations/auth/signup.js'\n:import bcrypt from 'bcryptjs'\nimport jwt from 'jsonwebtoken'\n\nexport default async (_, { email, password, name }, ctx) => {\n  try {\n    const userModel = ctx.db.model('user')\n\n    let user = await userModel.findOne({ email }).lean()\n\n    if (user) {\n      throw new Error('Email is already taken')\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10)\n    user = await userModel.create({\n      email,\n      password: hashedPassword,\n      name\n    })\n\n    const token = jwt.sign({ userId: user._id }, process.env.AUTH_SECRET)\n\n    return { token, user }\n  } catch (err) {\n    throw new Error(err)\n  }\n}\n\n'Next-GraphQL-Blog/server/resolvers/mutations/auth/index.js'\n:import login from './login'\nimport signup from './signup'\n\nexport default {\n  login,\n  signup\n}\n\n",
        "called_code_segment": "export default async (_, { email, password, name }, ctx) => {\n  try {\n    const userModel = ctx.db.model('user')\n\n    let user = await userModel.findOne({ email }).lean()\n\n    if (user) {\n      throw new Error('Email is already taken')\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10)\n    user = await userModel.create({\n      email,\n      password: hashedPassword,\n      name\n    })\n\n    const token = jwt.sign({ userId: user._id }, process.env.AUTH_SECRET)\n\n    return { token, user }\n  } catch (err) {\n    throw new Error(err)\n  }\n}",
        "invoking_code_segment": "import signup from './signup'\n\nexport default {\n  login,\n  signup\n}",
        "feature_description": "Add email verification during signup",
        "detailed_feature_description": "During the signup process, an email verification step will be added. A verification token will be generated and sent to the user's email. The user will need to verify their email before they can log in.",
        "modified_complete_code": {
            "signup.js": "import bcrypt from 'bcryptjs'\nimport jwt from 'jsonwebtoken'\nimport nodemailer from 'nodemailer'\n\nexport default async (_, { email, password, name }, ctx) => {\n  try {\n    const userModel = ctx.db.model('user')\n\n    let user = await userModel.findOne({ email }).lean()\n\n    if (user) {\n      throw new Error('Email is already taken')\n    }\n\n    const hashedPassword = await bcrypt.hash(password, 10)\n    const verificationToken = jwt.sign({ email }, process.env.AUTH_SECRET, { expiresIn: '1d' })\n    user = await userModel.create({\n      email,\n      password: hashedPassword,\n      name,\n      verificationToken\n    })\n\n    const transporter = nodemailer.createTransport({\n      service: 'gmail',\n      auth: {\n        user: process.env.EMAIL_USER,\n        pass: process.env.EMAIL_PASS\n      }\n    })\n\n    const mailOptions = {\n      from: process.env.EMAIL_USER,\n      to: email,\n      subject: 'Verify Your Email',\n      text: `Please verify your email by clicking on the following link: http://yourdomain.com/verify?token=${verificationToken}`\n    }\n\n    await transporter.sendMail(mailOptions)\n\n    return { message: 'Verification email sent' }\n  } catch (err) {\n    throw new Error(err)\n  }\n}",
            "index.js": "import login from './login'\nimport signup from './signup'\n\nexport default {\n  login,\n  signup\n}"
        }
    },
    {
        "repo": "type-to-reducer",
        "content": "'type-to-reducer/src/index.js'\n:// internal state\nlet typeDelimiter = '_'\n\n// change the string separating action types when reducerMap is nested\nexport const setTypeDelimiter = customTypeDelimiter => typeDelimiter = customTypeDelimiter\n\n// function to concatenate any nested types\nconst _makeType = (prefix, type) => prefix.concat(type).join(typeDelimiter)\n\n// iterator function that will read the reducerMap and return a flattened object\nconst _flattenReducerMap = (reducers, initial={}, prefix=[]) => {\n  const reducerTypes = Object.keys(reducers || {})\n  return reducerTypes.reduce((acc, type) => {\n    const reducer = reducers[type]\n    return typeof(reducer) === 'function'\n      ? { ...acc, [_makeType(prefix, type)]: reducer }\n      : _flattenReducerMap(reducer, acc, [ _makeType(prefix, type) ])\n  }, initial)\n}\n\nexport default function typeToReducer(reducerMap, initialState) {\n  const flattened = _flattenReducerMap(reducerMap)\n\n  return (state=initialState, action) => {\n    const reducer = flattened[action.type]\n    return reducer ? reducer(state, action) : state\n  }\n}\n\n'type-to-reducer/test/index.test.js'\n:import chai, { expect } from 'chai'\nimport sinon from 'sinon'\nimport typeToReducer, { setTypeDelimiter } from '../src/index'\n\nchai.use(require('sinon-chai'))\n\ndescribe('Handle Actions', function() {\n  const fooAction = { type: 'FOO' }\n\n  it('returns a reducer function', ()=> {\n    const state = { test: 'state' }\n    const reducer = typeToReducer()\n    expect(reducer(state, fooAction)).to.eql(state)\n  })\n\n  it('accepts an initialState for the reducer', ()=> {\n    const initialState = { initial: 'state' }\n    const reducer = typeToReducer({}, initialState)\n    expect(reducer(undefined, fooAction)).to.eql(initialState)\n  })\n\n  context('Given A Flat Reducer Config', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: sinon.spy(() => ({ state: 'foo' })),\n        BAR: sinon.spy(() => ({ state: 'bar' })),\n      }\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('ignores reducers when no matching type', ()=> {\n      const differentAction = { type: 'DIFFERENT' }\n      const newState = this.reducer(undefined, differentAction)\n      expect(newState).to.eql(initialState)\n      expect(this.reducerConfig.FOO).to.have.callCount(0)\n      expect(this.reducerConfig.BAR).to.have.callCount(0)\n    })\n\n    it('calls the reducer mapped to the action type', ()=> {\n      const state = { given: 'state' }\n      this.reducer(state, fooAction)\n      expect(this.reducerConfig.FOO).to.have.callCount(1)\n      expect(this.reducerConfig.FOO).to.have.been.calledWith(\n        state, fooAction\n      )\n      expect(this.reducerConfig.BAR).to.have.callCount(0)\n    })\n\n    it('returns the value from the called reducer', ()=> {\n      const actual = this.reducer({}, fooAction)\n      const expected = this.reducerConfig.FOO()\n      expect(actual).to.eql(expected)\n    })\n  })\n\n  context('Given A Nested Reducer', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: {\n          'HERP': sinon.spy(() => ({ state: 'foo_herp' })),\n          'DERP': {\n            'BAR': sinon.spy(() => ({ state: 'foo_derp_bar' })),\n          },\n        },\n      }\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('calls nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooHerpAction = { type: 'FOO_HERP' }\n      this.reducer(state, fooHerpAction)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.HERP).to.have.been.calledWith(\n        state, fooHerpAction\n      )\n    })\n\n    it('calls deeply nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooDerpBarAction = { type: 'FOO_DERP_BAR' }\n      this.reducer(state, fooDerpBarAction)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.been.calledWith(\n        state, fooDerpBarAction\n      )\n    })\n  })\n\n  context('Given A Custom Type Delimiter Nested Reducer', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: {\n          'HERP': sinon.spy(() => ({ state: 'foo_herp' })),\n          'DERP': {\n            'BAR': sinon.spy(() => ({ state: 'foo_derp_bar' })),\n          },\n        },\n      }\n      setTypeDelimiter('|')\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('calls deeply nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooDerpBarAction = { type: 'FOO|DERP|BAR' }\n      this.reducer(state, fooDerpBarAction)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.been.calledWith(\n        state, fooDerpBarAction\n      )\n    })\n  })\n})\n\n",
        "called_code_segment": "const _flattenReducerMap = (reducers, initial={}, prefix=[]) => {\n  const reducerTypes = Object.keys(reducers || {})\n  return reducerTypes.reduce((acc, type) => {\n    const reducer = reducers[type]\n    return typeof(reducer) === 'function'\n      ? { ...acc, [_makeType(prefix, type)]: reducer }\n      : _flattenReducerMap(reducer, acc, [ _makeType(prefix, type) ])\n  }, initial)\n}",
        "invoking_code_segment": "export default function typeToReducer(reducerMap, initialState) {\n  const flattened = _flattenReducerMap(reducerMap)\n\n  return (state=initialState, action) => {\n    const reducer = flattened[action.type]\n    return reducer ? reducer(state, action) : state\n  }\n}",
        "feature_description": "Add support for custom initial state per action type.",
        "detailed_feature_description": "Modify the `_flattenReducerMap` function to accept an optional initial state for each action type. Update the `typeToReducer` function to handle this new feature by merging the custom initial state with the global initial state if provided.",
        "modified_complete_code": {
            "type-to-reducer/src/index.js": "// internal state\nlet typeDelimiter = '_'\n\n// change the string separating action types when reducerMap is nested\nexport const setTypeDelimiter = customTypeDelimiter => typeDelimiter = customTypeDelimiter\n\n// function to concatenate any nested types\nconst _makeType = (prefix, type) => prefix.concat(type).join(typeDelimiter)\n\n// iterator function that will read the reducerMap and return a flattened object\nconst _flattenReducerMap = (reducers, initial={}, prefix=[], customInitialState=null) => {\n  const reducerTypes = Object.keys(reducers || {})\n  return reducerTypes.reduce((acc, type) => {\n    const reducer = reducers[type]\n    const newInitial = customInitialState && customInitialState[type] ? customInitialState[type] : initial\n    return typeof(reducer) === 'function'\n      ? { ...acc, [_makeType(prefix, type)]: (state=newInitial, action) => reducer(state, action) }\n      : _flattenReducerMap(reducer, acc, [ _makeType(prefix, type) ], customInitialState)\n  }, initial)\n}\n\nexport default function typeToReducer(reducerMap, initialState, customInitialState=null) {\n  const flattened = _flattenReducerMap(reducerMap, initialState, [], customInitialState)\n\n  return (state=initialState, action) => {\n    const reducer = flattened[action.type]\n    return reducer ? reducer(state, action) : state\n  }\n}",
            "type-to-reducer/test/index.test.js": "describe('Handle Actions', function() {\n  const fooAction = { type: 'FOO' }\n\n  it('returns a reducer function', ()=> {\n    const state = { test: 'state' }\n    const reducer = typeToReducer()\n    expect(reducer(state, fooAction)).to.eql(state)\n  })\n\n  it('accepts an initialState for the reducer', ()=> {\n    const initialState = { initial: 'state' }\n    const reducer = typeToReducer({}, initialState)\n    expect(reducer(undefined, fooAction)).to.eql(initialState)\n  })\n\n  context('Given A Flat Reducer Config', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: sinon.spy(() => ({ state: 'foo' })),\n        BAR: sinon.spy(() => ({ state: 'bar' })),\n      }\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('ignores reducers when no matching type', ()=> {\n      const differentAction = { type: 'DIFFERENT' }\n      const newState = this.reducer(undefined, differentAction)\n      expect(newState).to.eql(initialState)\n      expect(this.reducerConfig.FOO).to.have.callCount(0)\n      expect(this.reducerConfig.BAR).to.have.callCount(0)\n    })\n\n    it('calls the reducer mapped to the action type', ()=> {\n      const state = { given: 'state' }\n      this.reducer(state, fooAction)\n      expect(this.reducerConfig.FOO).to.have.callCount(1)\n      expect(this.reducerConfig.FOO).to.have.been.calledWith(\n        state, fooAction\n      )\n      expect(this.reducerConfig.BAR).to.have.callCount(0)\n    })\n\n    it('returns the value from the called reducer', ()=> {\n      const actual = this.reducer({}, fooAction)\n      const expected = this.reducerConfig.FOO()\n      expect(actual).to.eql(expected)\n    })\n  })\n\n  context('Given A Nested Reducer', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: {\n          'HERP': sinon.spy(() => ({ state: 'foo_herp' })),\n          'DERP': {\n            'BAR': sinon.spy(() => ({ state: 'foo_derp_bar' })),\n          },\n        },\n      }\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('calls nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooHerpAction = { type: 'FOO_HERP' }\n      this.reducer(state, fooHerpAction)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.HERP).to.have.been.calledWith(\n        state, fooHerpAction\n      )\n    })\n\n    it('calls deeply nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooDerpBarAction = { type: 'FOO_DERP_BAR' }\n      this.reducer(state, fooDerpBarAction)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.been.calledWith(\n        state, fooDerpBarAction\n      )\n    })\n  })\n\n  context('Given A Custom Type Delimiter Nested Reducer', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: {\n          'HERP': sinon.spy(() => ({ state: 'foo_herp' })),\n          'DERP': {\n            'BAR': sinon.spy(() => ({ state: 'foo_derp_bar' })),\n          },\n        },\n      }\n      setTypeDelimiter('|')\n      this.reducer = typeToReducer(this.reducerConfig, initialState)\n    })\n\n    it('calls deeply nested reducers with matching prefixed_type', ()=> {\n      const state = { given: 'state' }\n      const fooDerpBarAction = { type: 'FOO|DERP|BAR' }\n      this.reducer(state, fooDerpBarAction)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.callCount(1)\n      expect(this.reducerConfig.FOO.HERP).to.have.callCount(0)\n      expect(this.reducerConfig.FOO.DERP.BAR).to.have.been.calledWith(\n        state, fooDerpBarAction\n      )\n    })\n  })\n\n  context('Given Custom Initial State Per Action Type', ()=> {\n    const initialState = { initial: 'state' }\n    beforeEach(()=> {\n      this.reducerConfig = {\n        FOO: sinon.spy(() => ({ state: 'foo' })),\n        BAR: sinon.spy(() => ({ state: 'bar' })),\n      }\n      this.customInitialState = {\n        FOO: { custom: 'foo' },\n        BAR: { custom: 'bar' },\n      }\n      this.reducer = typeToReducer(this.reducerConfig, initialState, this.customInitialState)\n    })\n\n    it('uses custom initial state for FOO action', ()=> {\n      const actual = this.reducer(undefined, fooAction)\n      const expected = this.reducerConfig.FOO(this.customInitialState.FOO, fooAction)\n      expect(actual).to.eql(expected)\n    })\n\n    it('uses custom initial state for BAR action', ()=> {\n      const barAction = { type: 'BAR' }\n      const actual = this.reducer(undefined, barAction)\n      const expected = this.reducerConfig.BAR(this.customInitialState.BAR, barAction)\n      expect(actual).to.eql(expected)\n    })\n  })\n}"
        }
    },
    {
        "repo": "unirest-nodejs",
        "content": "'unirest-nodejs/index.js'\n:/**\n * Unirest for Node.js\n *\n * @author Nijko Yonskai\n * @copyright 2013-2015\n * @license MIT\n */\n\n/**\n * Module Dependencies\n */\n\nvar StringDecoder = require('string_decoder').StringDecoder\nvar QueryString = require('querystring')\nvar FormData = require('form-data')\nvar Stream = require('stream')\nvar mime = require('mime')\nvar zlib = require('zlib')\nvar path = require('path')\nvar URL = require('url')\nvar fs = require('fs')\n\n/**\n * Define form mime type\n */\nmime.define({\n  'application/x-www-form-urlencoded': ['form', 'urlencoded', 'form-data']\n})\n\n/**\n * Initialize our Rest Container\n *\n * @type {Object}\n */\nvar Unirest = function (method, uri, headers, body, callback) {\n  var unirest = function (uri, headers, body, callback) {\n    var $this = {\n      /**\n       * Stream Multipart form-data request\n       *\n       * @type {Boolean}\n       */\n      _stream: false,\n\n      /**\n       * Container to hold multipart form data for processing upon request.\n       *\n       * @type {Array}\n       * @private\n       */\n      _multipart: [],\n\n      /**\n       * Container to hold form data for processing upon request.\n       *\n       * @type {Array}\n       * @private\n       */\n      _form: [],\n\n      /**\n       * Request option container for details about the request.\n       *\n       * @type {Object}\n       */\n      options: {\n        /**\n         * Url obtained from request method arguments.\n         *\n         * @type {String}\n         */\n        url: uri,\n\n        /**\n         * Method obtained from request method arguments.\n         *\n         * @type {String}\n         */\n        method: method,\n\n        /**\n         * List of headers with case-sensitive fields.\n         *\n         * @type {Object}\n         */\n        headers: {}\n      },\n\n      hasHeader: function (name) {\n        var headers\n        var lowercaseHeaders\n\n        name = name.toLowerCase()\n        headers = Object.keys($this.options.headers)\n        lowercaseHeaders = headers.map(function (header) {\n          return header.toLowerCase()\n        })\n\n        for (var i = 0; i < lowercaseHeaders.length; i++) {\n          if (lowercaseHeaders[i] === name) {\n            return headers[i]\n          }\n        }\n\n        return false\n      },\n\n      /**\n       * Turn on multipart-form streaming\n       *\n       * @return {Object}\n       */\n      stream: function () {\n        $this._stream = true\n        return this\n      },\n\n      /**\n       * Attaches a field to the multipart-form request, with pre-processing.\n       *\n       * @param  {String} name\n       * @param  {String} value\n       * @return {Object}\n       */\n      field: function (name, value, options) {\n        return handleField(name, value, options)\n      },\n\n      /**\n       * Attaches a file to the multipart-form request.\n       *\n       * @param  {String} name\n       * @param  {String|Object} path\n       * @return {Object}\n       */\n      attach: function (name, path, options) {\n        options = options || {}\n        options.attachment = true\n        return handleField(name, path, options)\n      },\n\n      /**\n       * Attaches field to the multipart-form request, with no pre-processing.\n       *\n       * @param  {String} name\n       * @param  {String|Object} path\n       * @param  {Object} options\n       * @return {Object}\n       */\n      rawField: function (name, value, options) {\n        $this._multipart.push({\n          name: name,\n          value: value,\n          options: options,\n          attachment: options.attachment || false\n        })\n      },\n\n      /**\n       * Basic Header Authentication Method\n       *\n       * Supports user being an Object to reflect Request\n       * Supports user, password to reflect SuperAgent\n       *\n       * @param  {String|Object} user\n       * @param  {String} password\n       * @param  {Boolean} sendImmediately\n       * @return {Object}\n       */\n      auth: function (user, password, sendImmediately) {\n        $this.options.auth = (is(user).a(Object)) ? user : {\n          user: user,\n          password: password,\n          sendImmediately: sendImmediately\n        }\n\n        return $this\n      },\n\n      /**\n       * Sets header field to value\n       *\n       * @param  {String} field Header field\n       * @param  {String} value Header field value\n       * @return {Object}\n       */\n      header: function (field, value) {\n        if (is(field).a(Object)) {\n          for (var key in field) {\n            if (Object.prototype.hasOwnProperty.call(field, key)) {\n              $this.header(key, field[key])\n            }\n          }\n\n          return $this\n        }\n\n        var existingHeaderName = $this.hasHeader(field)\n        $this.options.headers[existingHeaderName || field] = value\n\n        return $this\n      },\n\n      /**\n       * Serialize value as querystring representation, and append or set on `Request.options.url`\n       *\n       * @param  {String|Object} value\n       * @return {Object}\n       */\n      query: function (value) {\n        if (is(value).a(Object)) value = Unirest.serializers.form(value)\n        if (!value.length) return $this\n        $this.options.url += (does($this.options.url).contain('?') ? '&' : '?') + value\n        return $this\n      },\n\n      /**\n       * Set _content-type_ header with type passed through `mime.getType()` when necessary.\n       *\n       * @param  {String} type\n       * @return {Object}\n       */\n      type: function (type) {\n        $this.header('Content-Type', does(type).contain('/')\n          ? type\n          : mime.getType(type))\n        return $this\n      },\n\n      /**\n       * Data marshalling for HTTP request body data\n       *\n       * Determines whether type is `form` or `json`.\n       * For irregular mime-types the `.type()` method is used to infer the `content-type` header.\n       *\n       * When mime-type is `application/x-www-form-urlencoded` data is appended rather than overwritten.\n       *\n       * @param  {Mixed} data\n       * @return {Object}\n       */\n      send: function (data) {\n        var type = $this.options.headers[$this.hasHeader('content-type')]\n\n        if ((is(data).a(Object) || is(data).a(Array)) && !Buffer.isBuffer(data)) {\n          if (!type) {\n            $this.type('form')\n            type = $this.options.headers[$this.hasHeader('content-type')]\n            $this.options.body = Unirest.serializers.form(data)\n          } else if (~type.indexOf('json')) {\n            $this.options.json = true\n\n            if ($this.options.body && is($this.options.body).a(Object)) {\n              for (var key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                  $this.options.body[key] = data[key]\n                }\n              }\n            } else {\n              $this.options.body = data\n            }\n          } else {\n            $this.options.body = Unirest.Request.serialize(data, type)\n          }\n        } else if (is(data).a(String)) {\n          if (!type) {\n            $this.type('form')\n            type = $this.options.headers[$this.hasHeader('content-type')]\n          }\n\n          if (type === 'application/x-www-form-urlencoded') {\n            $this.options.body = $this.options.body\n              ? $this.options.body + '&' + data\n              : data\n          } else {\n            $this.options.body = ($this.options.body || '') + data\n          }\n        } else {\n          $this.options.body = data\n        }\n\n        return $this\n      },\n\n      /**\n       * Takes multipart options and places them on `options.multipart` array.\n       * Transforms body when an `Object` or _content-type_ is present.\n       *\n       * Example:\n       *\n       *      Unirest.get('http://google.com').part({\n       *        'content-type': 'application/json',\n       *        body: {\n       *          phrase: 'Hello'\n       *        }\n       *      }).part({\n       *        'content-type': 'application/json',\n       *        body: {\n       *          phrase: 'World'\n       *        }\n       *      }).end(function (response) {})\n       *\n       * @param  {Object|String} options When an Object, headers should be placed directly on the object,\n       *                                 not under a child property.\n       * @return {Object}\n       */\n      part: function (options) {\n        if (!$this._multipart) {\n          $this.options.multipart = []\n        }\n\n        if (is(options).a(Object)) {\n          if (options['content-type']) {\n            var type = Unirest.type(options['content-type'], true)\n            if (type) options.body = Unirest.Response.parse(options.body)\n          } else {\n            if (is(options.body).a(Object)) {\n              options.body = Unirest.serializers.json(options.body)\n            }\n          }\n\n          $this.options.multipart.push(options)\n        } else {\n          $this.options.multipart.push({\n            body: options\n          })\n        }\n\n        return $this\n      },\n\n      /**\n       * Instructs the Request to be retried if specified error status codes (4xx, 5xx, ETIMEDOUT) are returned.\n       * Retries are delayed with an exponential backoff.\n       *\n       * @param {(err: Error) => boolean} [callback] - Invoked on response error. Return false to stop next request.\n       * @param {Object} [options] - Optional retry configuration to override defaults.\n       * @param {number} [options.attempts=3] - The number of retry attempts.\n       * @param {number} [options.delayInMs=250] - The delay in milliseconds (delayInMs *= delayMulti)\n       * @param {number} [options.delayMulti=2] - The multiplier of delayInMs after each attempt.\n       * @param {Array<string|number>} [options.statusCodes=[\"ETIMEDOUT\", \"5xx\"]] - The status codes to retry on.\n       * @return {Object}\n       */\n      retry: function (callback, options) {\n\n        $this.options.retry = {\n          callback: typeof callback === \"function\" ? callback : null,\n          attempts: options && +options.attempts || 3,\n          delayInMs: options && +options.delayInMs || 250,\n          delayMulti: options && +options.delayMulti || 2,\n          statusCodes: (options && options.statusCodes || [\"ETIMEDOUT\", \"5xx\"]).slice(0)\n        };\n\n        return $this\n      },\n\n      /**\n       * Proxies the call to end. This adds support for using promises as well as async/await.\n       *\n       * @param  {Function} callback\n       * @return {Promise}\n       **/\n      then: function (callback) {\n        return new Promise((resolve, reject) => {\n          this.end(result => {\n            try {\n              resolve(callback(result))\n            } catch (err) {\n              reject(err)\n            }\n          })\n        })\n      },\n\n      /**\n       * Sends HTTP Request and awaits Response finalization. Request compression and Response decompression occurs here.\n       * Upon HTTP Response post-processing occurs and invokes `callback` with a single argument, the `[Response](#response)` object.\n       *\n       * @param  {Function} callback\n       * @return {Object}\n       */\n      end: function (callback) {\n        var self = this\n        var Request\n        var header\n        var parts\n        var form\n\n        function handleRetriableRequestResponse (result) {\n\n          // If retries is not defined or all attempts tried, return true to invoke end's callback.\n          if ($this.options.retry === undefined || $this.options.retry.attempts === 0) {\n            return true\n          }\n\n          // If status code is not listed, abort with return true to invoke end's callback.\n          var isStatusCodeDefined = (function (code, codes) {\n\n            if (codes.indexOf(code) !== -1) {\n              return true\n            }\n\n            return codes.reduce(function (p, c) {\n                return p || String(code).split(\"\").every(function (ch, i) {\n                  return ch === \"x\" || ch === c[i]\n                })\n              }, false)\n\n          }(result.code || result.error && result.error.code, $this.options.retry.statusCodes))\n\n          if (!isStatusCodeDefined) {\n            return true\n          }\n\n          if ($this.options.retry.callback) {\n            var isContinue = $this.options.retry.callback(result)\n            // If retry callback returns false, stop retries and invoke end's callback.\n            if (isContinue === false) {\n              return true;\n            }\n          }\n\n          setTimeout(function () {\n            self.end(callback)\n          }, $this.options.retry.delayInMs)\n\n          $this.options.retry.attempts--\n          $this.options.retry.delayInMs *= $this.options.retry.delayMulti\n\n          // Return false to not invoke end's callback.\n          return false\n        }\n\n        function handleRequestResponse (error, response, body) {\n          var result = {}\n          var status\n          var data\n          var type\n\n          // Handle pure error\n          if (error && !response) {\n            result.error = error\n\n            if (handleRetriableRequestResponse(result) && callback) {\n              callback(result)\n            }\n\n            return\n          }\n\n          // Handle No Response...\n          // This is weird.\n          if (!response) {\n            console.log('This is odd, report this action / request to: http://github.com/mashape/unirest-nodejs')\n\n            result.error = {\n              message: 'No response found.'\n            }\n\n            if (handleRetriableRequestResponse(result) && callback) {\n              callback(result)\n            }\n\n            return\n          }\n\n          // Create response reference\n          result = response\n\n          // Create response status reference\n          status = response.statusCode\n\n          // Normalize MSIE response to HTTP 204\n          status = (status === 1223 ? 204 : status)\n\n          // Obtain status range typecode (1, 2, 3, 4, 5, etc.)\n          type = status / 100 | 0\n\n          // Generate sugar helper properties for status information\n          result.code = status\n          result.status = status\n          result.statusType = type\n          result.info = type === 1\n          result.ok = type === 2\n          result.clientError = type === 4\n          result.serverError = type === 5\n          result.error = (type === 4 || type === 5) ? (function generateErrorMessage () {\n            var msg = 'got ' + result.status + ' response'\n            var err = new Error(msg)\n            err.status = result.status\n            return err\n          })() : false\n\n          // Iterate over Response Status Codes and generate more sugar\n          for (var name in Unirest.Response.statusCodes) {\n            result[name] = Unirest.Response.statusCodes[name] === status\n          }\n\n          // Cookie Holder\n          result.cookies = {}\n\n          // Cookie Sugar Method\n          result.cookie = function (name) {\n            return result.cookies[name]\n          }\n\n          function setCookie (cookie) {\n            var crumbs = Unirest.trim(cookie).split('=')\n            var key = Unirest.trim(crumbs[0])\n            var value = Unirest.trim(crumbs.slice(1).join('='))\n\n            if (crumbs[0] && crumbs[0] !== '') {\n              result.cookies[key] = value === '' ? true : value\n            }\n          }\n\n          if (response.cookies && is(response.cookies).a(Object) && Object.keys(response.cookies).length > 0) {\n            result.cookies = response.cookies\n          } else {\n            // Handle cookies to be set\n            var cookies = response.headers['set-cookie']\n            if (cookies && is(cookies).a(Array)) {\n              for (var index = 0; index < cookies.length; index++) {\n                var entry = cookies[index]\n\n                if (is(entry).a(String) && does(entry).contain(';')) {\n                  entry.split(';').forEach(setCookie)\n                }\n              }\n            }\n\n            // Handle cookies that have been set\n            cookies = response.headers.cookie\n            if (cookies && is(cookies).a(String)) {\n              cookies.split(';').forEach(setCookie)\n            }\n          }\n\n          // Obtain response body\n          body = body || response.body\n          result.raw_body = body\n          result.headers = response.headers\n\n          // Handle Response Body\n          if (body) {\n            type = Unirest.type(result.headers['content-type'], true)\n            if (type) data = Unirest.Response.parse(body, type)\n            else data = body\n          }\n\n          result.body = data\n\n          ;(handleRetriableRequestResponse(result)) && (callback) && callback(result)\n        }\n\n        function handleGZIPResponse (response) {\n          if (/^(deflate|gzip)$/.test(response.headers['content-encoding'])) {\n            var unzip = zlib.createUnzip()\n            var stream = new Stream()\n            var _on = response.on\n            var decoder\n\n            // Keeping node happy\n            stream.req = response.req\n\n            // Make sure we emit prior to processing\n            unzip.on('error', function (error) {\n              // Catch the parser error when there is no content\n              if (error.errno === zlib.Z_BUF_ERROR || error.errno === zlib.Z_DATA_ERROR) {\n                stream.emit('end')\n                return\n              }\n\n              stream.emit('error', error)\n            })\n\n            // Start the processing\n            response.pipe(unzip)\n\n            // Ensure encoding is captured\n            response.setEncoding = function (type) {\n              decoder = new StringDecoder(type)\n            }\n\n            // Capture decompression and decode with captured encoding\n            unzip.on('data', function (buffer) {\n              if (!decoder) return stream.emit('data', buffer)\n              var string = decoder.write(buffer)\n              if (string.length) stream.emit('data', string)\n            })\n\n            // Emit yoself\n            unzip.on('end', function () {\n              stream.emit('end')\n            })\n\n            response.on = function (type, next) {\n              if (type === 'data' || type === 'end') {\n                stream.on(type, next)\n              } else if (type === 'error') {\n                _on.call(response, type, next)\n              } else {\n                _on.call(response, type, next)\n              }\n            }\n          }\n        }\n\n        function handleFormData (form) {\n          for (var i = 0; i < $this._multipart.length; i++) {\n            var item = $this._multipart[i]\n\n            if (item.attachment && is(item.value).a(String)) {\n              if (does(item.value).contain('http://') || does(item.value).contain('https://')) {\n                item.value = Unirest.request(item.value)\n              } else {\n                item.value = fs.createReadStream(path.resolve(item.value))\n              }\n            }\n\n            form.append(item.name, item.value, item.options)\n          }\n\n          return form\n        }\n\n        if ($this._multipart.length && !$this._stream) {\n          header = $this.options.headers[$this.hasHeader('content-type')]\n          parts = URL.parse($this.options.url)\n          form = new FormData()\n\n          if (header) {\n            $this.options.headers['content-type'] = header.split(';')[0] + '; boundary=' + form.getBoundary()\n          } else {\n            $this.options.headers['content-type'] = 'multipart/form-data; boundary=' + form.getBoundary()\n          }\n\n          function authn(auth) {\n              if (!auth) return null;\n              if (typeof auth === 'string') return auth;\n              if (auth.user && auth.pass) return auth.user + ':' + auth.pass;\n              return auth;\n          }\n\n          return handleFormData(form).submit({\n            protocol: parts.protocol,\n            port: parts.port,\n            // Formdata doesn't expect port to be included with host\n            // so we use hostname rather than host\n            host: parts.hostname,\n            path: parts.path,\n            method: $this.options.method,\n            headers: $this.options.headers,\n            auth: authn($this.options.auth || parts.auth)\n          }, function (error, response) {\n            var decoder = new StringDecoder('utf8')\n\n            if (error) {\n              return handleRequestResponse(error, response)\n            }\n\n            if (!response.body) {\n              response.body = ''\n            }\n\n            // Node 10+\n            response.resume()\n\n            // GZIP, Feel me?\n            handleGZIPResponse(response)\n\n            // Fallback\n            response.on('data', function (chunk) {\n              if (typeof chunk === 'string') response.body += chunk\n              else response.body += decoder.write(chunk)\n            })\n\n            // After all, we end up here\n            response.on('end', function () {\n              return handleRequestResponse(error, response)\n            })\n          })\n        }\n\n        Request = Unirest.request($this.options, handleRequestResponse)\n        Request.on('response', handleGZIPResponse)\n\n        if ($this._multipart.length && $this._stream) {\n          handleFormData(Request.form())\n        }\n\n        return Request\n      }\n    }\n\n    /**\n     * Alias for _.header_\n     * @type {Function}\n     */\n    $this.headers = $this.header\n\n    /**\n     * Alias for _.header_\n     *\n     * @type {Function}\n     */\n    $this.set = $this.header\n\n    /**\n     * Alias for _.end_\n     *\n     * @type {Function}\n     */\n    $this.complete = $this.end\n\n    /**\n     * Aliases for _.end_\n     *\n     * @type {Object}\n     */\n\n    $this.as = {\n      json: $this.end,\n      binary: $this.end,\n      string: $this.end\n    }\n\n    /**\n     * Handles Multipart Field Processing\n     *\n     * @param {String} name\n     * @param {Mixed} value\n     * @param {Object} options\n     */\n    function handleField (name, value, options) {\n      var serialized\n      var length\n      var key\n      var i\n\n      options = options || { attachment: false }\n\n      if (is(name).a(Object)) {\n        for (key in name) {\n          if (Object.prototype.hasOwnProperty.call(name, key)) {\n            handleField(key, name[key], options)\n          }\n        }\n      } else {\n        if (is(value).a(Array)) {\n          for (i = 0, length = value.length; i < length; i++) {\n            serialized = handleFieldValue(value[i])\n            if (serialized) {\n              $this.rawField(name, serialized, options)\n            }\n          }\n        } else if (value != null) {\n          $this.rawField(name, handleFieldValue(value), options)\n        }\n      }\n\n      return $this\n    }\n\n    /**\n     * Handles Multipart Value Processing\n     *\n     * @param {Mixed} value\n     */\n    function handleFieldValue (value) {\n      if (!(value instanceof Buffer || typeof value === 'string')) {\n        if (is(value).a(Object)) {\n          if (value instanceof fs.FileReadStream) {\n            return value\n          } else {\n            return Unirest.serializers.json(value)\n          }\n        } else {\n          return value.toString()\n        }\n      } else return value\n    }\n\n    function setupOption (name, ref) {\n      $this[name] = function (arg) {\n        $this.options[ref || name] = arg\n        return $this\n      }\n    }\n\n    // Iterates over a list of option methods to generate the chaining\n    // style of use you see in Superagent and jQuery.\n    for (var x in Unirest.enum.options) {\n      if (Object.prototype.hasOwnProperty.call(Unirest.enum.options, x)) {\n        var option = Unirest.enum.options[x]\n        var reference = null\n\n        if (option.indexOf(':') > -1) {\n          option = option.split(':')\n          reference = option[1]\n          option = option[0]\n        }\n\n        setupOption(option, reference)\n      }\n    }\n\n    if (headers && typeof headers === 'function') {\n      callback = headers\n      headers = null\n    } else if (body && typeof body === 'function') {\n      callback = body\n      body = null\n    }\n\n    if (headers) $this.set(headers)\n    if (body) $this.send(body)\n\n    return callback ? $this.end(callback) : $this\n  }\n\n  return uri ? unirest(uri, headers, body, callback) : unirest\n}\n\n/**\n * Expose the underlying layer.\n */\nUnirest.request = require('request')\nUnirest.cookie = Unirest.request.cookie\nUnirest.pipe = Unirest.request.pipe\n\n/**\n * Mime-type lookup / parser.\n *\n * @param  {String} type\n * @param  {Boolean} parse Should we parse?\n * @return {String}\n */\nUnirest.type = function (type, parse) {\n  if (typeof type !== 'string') return false\n  return parse ? type.split(/ *; */).shift() : (Unirest.types[type] || type)\n}\n\n/**\n * Utility method to trim strings.\n *\n * @type {String}\n */\nUnirest.trim = ''.trim\n  ? function (s) { return s.trim() }\n  : function (s) { return s.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '') }\n\n/**\n * Parser methods for different data types.\n *\n * @type {Object}\n */\nUnirest.parsers = {\n  string: function (data) {\n    var obj = {}\n    var pairs = data.split('&')\n    var parts\n    var pair\n\n    for (var i = 0, len = pairs.length; i < len; ++i) {\n      pair = pairs[i]\n      parts = pair.split('=')\n      obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1])\n    }\n\n    return obj\n  },\n\n  json: function (data) {\n    try {\n      data = JSON.parse(data)\n    } catch (e) {}\n\n    return data\n  }\n}\n\n/**\n * Serialization methods for different data types.\n *\n * @type {Object}\n */\nUnirest.serializers = {\n  form: function (obj) {\n    return QueryString.stringify(obj)\n  },\n\n  json: function (obj) {\n    return JSON.stringify(obj)\n  }\n}\n\n/**\n * Unirest Request Utility Methods\n *\n * @type {Object}\n */\nUnirest.Request = {\n  serialize: function (string, type) {\n    var serializer = Unirest.firstMatch(type, Unirest.enum.serialize)\n    return serializer ? serializer(string) : string\n  },\n\n  uid: function (len) {\n    var output = ''\n    var chars = 'abcdefghijklmnopqrstuvwxyz123456789'\n    var nchars = chars.length\n    while (len--) output += chars[Math.random() * nchars | 0]\n    return output\n  }\n}\n\n/**\n * Unirest Response Utility Methods\n *\n * @type {Object}\n */\nUnirest.Response = {\n  parse: function (string, type) {\n    var parser = Unirest.firstMatch(type, Unirest.enum.parse)\n    return parser ? parser(string) : string\n  },\n\n  parseHeader: function (str) {\n    var lines = str.split(/\\r?\\n/)\n    var fields = {}\n    var index\n    var line\n    var field\n    var val\n\n    // Trailing CRLF\n    lines.pop()\n\n    for (var i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i]\n      index = line.indexOf(':')\n      field = line.slice(0, index).toLowerCase()\n      val = Unirest.trim(line.slice(index + 1))\n      fields[field] = val\n    }\n\n    return fields\n  },\n\n  statusCodes: {\n    'created': 201,\n    'accepted': 202,\n    'nonAuthoritativeInformation': 203,\n    'noContent': 204,\n    'resetContent': 205,\n    'partialContent': 206,\n    'multiStatus': 207,\n    'alreadyReported': 208,\n    'imUsed': 226,\n    'multipleChoices': 300,\n    'movedPermanently': 301,\n    'found': 302,\n    'seeOther': 303,\n    'notModified': 304,\n    'useProxy': 305,\n    'temporaryRedirect': 307,\n    'permanentRedirect': 308,\n    'badRequest': 400,\n    'unauthorized': 401,\n    'paymentRequired': 402,\n    'forbidden': 403,\n    'notFound': 404,\n    'methodNotAllowed': 405,\n    'notAcceptable': 406,\n    'proxyAuthenticationRequired': 407,\n    'requestTimeout': 408,\n    'conflict': 409,\n    'gone': 410,\n    'lengthRequired': 411,\n    'preconditionFailed': 412,\n    'requestEntityTooLarge': 413,\n    'uriTooLong': 414,\n    'unsupportedMediaType': 415,\n    'rangeNotSatisfiable': 416,\n    'expectationFailed': 417,\n    'misdirectedRequest': 421,\n    'unprocessableEntity': 422,\n    'locked': 423,\n    'failedDependency': 424,\n    'upgradeRequired': 426,\n    'preconditionRequired': 428,\n    'tooManyRequests': 429,\n    'requestHeaderFieldsTooLarge': 431,\n    'internalServerError': 500,\n    'notImplemented': 501,\n    'badGateway': 502,\n    'serviceUnavailable': 503,\n    'gatewayTimeout': 504,\n    'httpVersionNotSupported': 505,\n    'variantAlsoNegotiates': 506,\n    'insufficientStorage': 507,\n    'loopDetected': 508,\n    'notExtended': 510\n  }\n}\n\n/**\n * Expose cookie store (tough-cookie)\n *\n * @return {Function} Cookie Store\n */\nUnirest.jar = function (options) {\n  var jar = Unirest.request.jar()\n  options = options || {}\n\n  // Because Requests aliases toughcookie rather than returning.\n  if (options.store) {\n    jar._jar.store = options.store\n  }\n\n  if (options.rejectPublicSuffixes) {\n    jar._jar.rejectPublicSuffixes = options.rejectPublicSuffixes\n  }\n\n  // Alias helper methods\n  jar.add = jar.setCookie\n  jar.toString = jar.getCookieString\n\n  // Export\n  return jar\n}\n\n/**\n * Enum Structures\n *\n * @type {Object}\n */\nUnirest.enum = {\n  serialize: {\n    'application/x-www-form-urlencoded': Unirest.serializers.form,\n    'application/json': Unirest.serializers.json,\n    '+json': Unirest.serializers.json\n  },\n\n  parse: {\n    'application/x-www-form-urlencoded': Unirest.parsers.string,\n    'application/json': Unirest.parsers.json,\n    '+json': Unirest.parsers.json\n  },\n\n  methods: [\n    'GET',\n    'HEAD',\n    'PUT',\n    'POST',\n    'PATCH',\n    'DELETE',\n    'OPTIONS'\n  ],\n\n  options: [\n    'uri:url', 'redirects:maxRedirects', 'redirect:followRedirect', 'url', 'method', 'qs', 'form', 'json', 'multipart',\n    'followRedirect', 'followAllRedirects', 'maxRedirects', 'encoding', 'pool', 'timeout', 'proxy', 'oauth', 'hawk', 'time',\n    'ssl:strictSSL', 'strictSSL', 'jar', 'cookies:jar', 'aws', 'httpSignature', 'localAddress', 'ip:localAddress', 'secureProtocol', 'forever'\n  ]\n}\n\n/**\n * Returns a list of values obtained by checking the specified string\n * whether it contains array value or object key, when true the value\n * is appended to the list to be returned.\n *\n * @param  {String} string String to be tested\n * @param  {Object|Array} map    Values / Keys to test against string.\n * @return {Array} List of values truthfully matched against string.\n */\nUnirest.matches = function matches (string, map) {\n  var results = []\n\n  for (var key in map) {\n    if (typeof map.length !== 'undefined') {\n      key = map[key]\n    }\n\n    if (string.indexOf(key) !== -1) {\n      results.push(map[key])\n    }\n  }\n\n  return results\n}\n\n/**\n * Returns the first value obtained through #matches\n *\n * @see #matches\n * @param  {String} string String to be tested\n * @param  {Object|Array} map Values / Keys to test against string.\n * @return {Mixed} First match value\n */\nUnirest.firstMatch = function firstMatch (string, map) {\n  return Unirest.matches(string, map)[0]\n}\n\n/**\n * Generate sugar for request library.\n *\n * This allows us to mock super-agent chaining style while using request library under the hood.\n */\nfunction setupMethod (method) {\n  Unirest[method] = Unirest(method)\n}\n\nfor (var i = 0; i < Unirest.enum.methods.length; i++) {\n  var method = Unirest.enum.methods[i].toLowerCase()\n  setupMethod(method)\n}\n\n/**\n * Simple Utility Methods for checking information about a value.\n *\n * @param  {Mixed}  value  Could be anything.\n * @return {Object}\n */\nfunction is (value) {\n  return {\n    a: function (check) {\n      if (check.prototype) check = check.prototype.constructor.name\n      var type = Object.prototype.toString.call(value).slice(8, -1).toLowerCase()\n      return value != null && type === check.toLowerCase()\n    }\n  }\n}\n\n/**\n * Simple Utility Methods for checking information about a value.\n *\n * @param  {Mixed}  value  Could be anything.\n * @return {Object}\n */\nfunction does (value) {\n  var arrayIndexOf = (Array.indexOf ? function (arr, obj, from) {\n    return arr.indexOf(obj, from)\n  } : function (arr, obj, from) {\n    var l = arr.length\n    var i = from ? parseInt((1 * from) + (from < 0 ? l : 0), 10) : 0\n    i = i < 0 ? 0 : i\n    for (; i < l; i++) if (i in arr && arr[i] === obj) return i\n    return -1\n  })\n\n  return {\n    startWith: function (string) {\n      if (is(value).a(String)) return value.slice(0, string.length) === string\n      if (is(value).a(Array)) return value[0] === string\n      return false\n    },\n\n    endWith: function (string) {\n      if (is(value).a(String)) return value.slice(-string.length) === string\n      if (is(value).a(Array)) return value[value.length - 1] === string\n      return false\n    },\n\n    contain: function (field) {\n      if (is(value).a(String)) return value.indexOf(field) > -1\n      if (is(value).a(Object)) return Object.prototype.hasOwnProperty.call(value, field)\n      if (is(value).a(Array)) return !!~arrayIndexOf(value, field)\n      return false\n    }\n  }\n}\n\n/**\n * Expose the Unirest Container\n */\n\nmodule.exports = exports = Unirest\n\n'unirest-nodejs/tests/promises.js'\n:var fs = require('fs')\nvar unirest = require('../index')\nvar express = require('express')\nvar bodyParser = require('body-parser')\n\n// Mock Server\nvar app = express()\nvar server\n\ndescribe('Unirest Promises', function () {\n  describe('GET', function () {\n    var host, port, url\n    var fixture = {\n      message: 'some message under a json object'\n    }\n\n    before(function(done) {\n      app.use(bodyParser.json({\n        type: 'application/vnd.api+json'\n      }))\n\n      app.get('/', function handleRoot(req, res) {\n        res.set('content-type', 'application/vnd.api+json')\n        res.send(fixture)\n      })\n\n      server = app.listen(3000, function liftServer () {\n        host = server.address().address\n        port = server.address().port\n        url = 'http://localhost:3000'\n        done()\n      })\n    })\n\n    after(function afterAll (done) {\n      server.close(function closeCallback () {\n        done()\n      })\n    })\n\n    it('supports async, and await', async function () {\n      let response = await unirest.get(url).type('json')\n      return response.body.should.eql(fixture)\n    })\n\n    it('support chaining', function jsonTest (done) {\n      unirest\n        .get(url)\n        .type('json')\n        .then(function (response) {\n          return response\n        })\n        .then((response) => {\n          response.body.should.eql(fixture)\n          done()\n        })\n    })\n  })\n})\n\n",
        "called_code_segment": "function handleRetriableRequestResponse (result) {\n\n  // If retries is not defined or all attempts tried, return true to invoke end's callback.\n  if ($this.options.retry === undefined || $this.options.retry.attempts === 0) {\n    return true\n  }\n\n  // If status code is not listed, abort with return true to invoke end's callback.\n  var isStatusCodeDefined = (function (code, codes) {\n\n    if (codes.indexOf(code) !== -1) {\n      return true\n    }\n\n    return codes.reduce(function (p, c) {\n        return p || String(code).split(\"\\\"\").every(function (ch, i) {\n          return ch === \"x\" || ch === c[i]\n        })\n      }, false)\n\n  }(result.code || result.error && result.error.code, $this.options.retry.statusCodes))\n\n  if (!isStatusCodeDefined) {\n    return true\n  }\n\n  if ($this.options.retry.callback) {\n    var isContinue = $this.options.retry.callback(result)\n    // If retry callback returns false, stop retries and invoke end's callback.\n    if (isContinue === false) {\n      return true;\n    }\n  }\n\n  setTimeout(function () {\n    self.end(callback)\n  }, $this.options.retry.delayInMs)\n\n  $this.options.retry.attempts--\n  $this.options.retry.delayInMs *= $this.options.retry.delayMulti\n\n  // Return false to not invoke end's callback.\n  return false\n}",
        "invoking_code_segment": "function handleRequestResponse (error, response, body) {\n  var result = {}\n  var status\n  var data\n  var type\n\n  // Handle pure error\n  if (error && !response) {\n    result.error = error\n\n    if (handleRetriableRequestResponse(result) && callback) {\n      callback(result)\n    }\n\n    return\n  }\n\n  // Handle No Response...\n  // This is weird.\n  if (!response) {\n    console.log('This is odd, report this action / request to: http://github.com/mashape/unirest-nodejs')\n\n    result.error = {\n      message: 'No response found.'\n    }\n\n    if (handleRetriableRequestResponse(result) && callback) {\n      callback(result)\n    }\n\n    return\n  }\n\n  // Create response reference\n  result = response\n\n  // Create response status reference\n  status = response.statusCode\n\n  // Normalize MSIE response to HTTP 204\n  status = (status === 1223 ? 204 : status)\n\n  // Obtain status range typecode (1, 2, 3, 4, 5, etc.)\n  type = status / 100 | 0\n\n  // Generate sugar helper properties for status information\n  result.code = status\n  result.status = status\n  result.statusType = type\n  result.info = type === 1\n  result.ok = type === 2\n  result.clientError = type === 4\n  result.serverError = type === 5\n  result.error = (type === 4 || type === 5) ? (function generateErrorMessage () {\n    var msg = 'got ' + result.status + ' response'\n    var err = new Error(msg)\n    err.status = result.status\n    return err\n  })() : false\n\n  // Iterate over Response Status Codes and generate more sugar\n  for (var name in Unirest.Response.statusCodes) {\n    result[name] = Unirest.Response.statusCodes[name] === status\n  }\n\n  // Cookie Holder\n  result.cookies = {}\n\n  // Cookie Sugar Method\n  result.cookie = function (name) {\n    return result.cookies[name]\n  }\n\n  function setCookie (cookie) {\n    var crumbs = Unirest.trim(cookie).split('=')\n    var key = Unirest.trim(crumbs[0])\n    var value = Unirest.trim(crumbs.slice(1).join('='))\n\n    if (crumbs[0] && crumbs[0] !== '') {\n      result.cookies[key] = value === '' ? true : value\n    }\n  }\n\n  if (response.cookies && is(response.cookies).a(Object) && Object.keys(response.cookies).length > 0) {\n    result.cookies = response.cookies\n  } else {\n    // Handle cookies to be set\n    var cookies = response.headers['set-cookie']\n    if (cookies && is(cookies).a(Array)) {\n      for (var index = 0; index < cookies.length; index++) {\n        var entry = cookies[index]\n\n        if (is(entry).a(String) && does(entry).contain(';')) {\n          entry.split(';').forEach(setCookie)\n        }\n      }\n    }\n\n    // Handle cookies that have been set\n    cookies = response.headers.cookie\n    if (cookies && is(cookies).a(String)) {\n      cookies.split(';').forEach(setCookie)\n    }\n  }\n\n  // Obtain response body\n  body = body || response.body\n  result.raw_body = body\n  result.headers = response.headers\n\n  // Handle Response Body\n  if (body) {\n    type = Unirest.type(result.headers['content-type'], true)\n    if (type) data = Unirest.Response.parse(body, type)\n    else data = body\n  }\n\n  result.body = data\n\n  ;(handleRetriableRequestResponse(result)) && (callback) && callback(result)\n}",
        "feature_description": "Add a feature to log the retry attempts.",
        "detailed_feature_description": "Modify the `handleRetriableRequestResponse` function to log each retry attempt. Update the `handleRequestResponse` function to handle the logging changes.",
        "modified_complete_code": {
            "file1": "function handleRetriableRequestResponse (result) {\n\n  // If retries is not defined or all attempts tried, return true to invoke end's callback.\n  if ($this.options.retry === undefined || $this.options.retry.attempts === 0) {\n    return true\n  }\n\n  // If status code is not listed, abort with return true to invoke end's callback.\n  var isStatusCodeDefined = (function (code, codes) {\n\n    if (codes.indexOf(code) !== -1) {\n      return true\n    }\n\n    return codes.reduce(function (p, c) {\n        return p || String(code).split(\"\\\"\").every(function (ch, i) {\n          return ch === \"x\" || ch === c[i]\n        })\n      }, false)\n\n  }(result.code || result.error && result.error.code, $this.options.retry.statusCodes))\n\n  if (!isStatusCodeDefined) {\n    return true\n  }\n\n  if ($this.options.retry.callback) {\n    var isContinue = $this.options.retry.callback(result)\n    // If retry callback returns false, stop retries and invoke end's callback.\n    if (isContinue === false) {\n      return true;\n    }\n  }\n\n  // #Modify: Log the retry attempt\n  console.log('Retrying request. Attempts left:', $this.options.retry.attempts);\n\n  setTimeout(function () {\n    self.end(callback)\n  }, $this.options.retry.delayInMs)\n\n  $this.options.retry.attempts--\n  $this.options.retry.delayInMs *= $this.options.retry.delayMulti\n\n  // Return false to not invoke end's callback.\n  return false\n}",
            "file2": "function handleRequestResponse (error, response, body) {\n  var result = {}\n  var status\n  var data\n  var type\n\n  // Handle pure error\n  if (error && !response) {\n    result.error = error\n\n    if (handleRetriableRequestResponse(result) && callback) {\n      callback(result)\n    }\n\n    return\n  }\n\n  // Handle No Response...\n  // This is weird.\n  if (!response) {\n    console.log('This is odd, report this action / request to: http://github.com/mashape/unirest-nodejs')\n\n    result.error = {\n      message: 'No response found.'\n    }\n\n    if (handleRetriableRequestResponse(result) && callback) {\n      callback(result)\n    }\n\n    return\n  }\n\n  // Create response reference\n  result = response\n\n  // Create response status reference\n  status = response.statusCode\n\n  // Normalize MSIE response to HTTP 204\n  status = (status === 1223 ? 204 : status)\n\n  // Obtain status range typecode (1, 2, 3, 4, 5, etc.)\n  type = status / 100 | 0\n\n  // Generate sugar helper properties for status information\n  result.code = status\n  result.status = status\n  result.statusType = type\n  result.info = type === 1\n  result.ok = type === 2\n  result.clientError = type === 4\n  result.serverError = type === 5\n  result.error = (type === 4 || type === 5) ? (function generateErrorMessage () {\n    var msg = 'got ' + result.status + ' response'\n    var err = new Error(msg)\n    err.status = result.status\n    return err\n  })() : false\n\n  // Iterate over Response Status Codes and generate more sugar\n  for (var name in Unirest.Response.statusCodes) {\n    result[name] = Unirest.Response.statusCodes[name] === status\n  }\n\n  // Cookie Holder\n  result.cookies = {}\n\n  // Cookie Sugar Method\n  result.cookie = function (name) {\n    return result.cookies[name]\n  }\n\n  function setCookie (cookie) {\n    var crumbs = Unirest.trim(cookie).split('=')\n    var key = Unirest.trim(crumbs[0])\n    var value = Unirest.trim(crumbs.slice(1).join('='))\n\n    if (crumbs[0] && crumbs[0] !== '') {\n      result.cookies[key] = value === '' ? true : value\n    }\n  }\n\n  if (response.cookies && is(response.cookies).a(Object) && Object.keys(response.cookies).length > 0) {\n    result.cookies = response.cookies\n  } else {\n    // Handle cookies to be set\n    var cookies = response.headers['set-cookie']\n    if (cookies && is(cookies).a(Array)) {\n      for (var index = 0; index < cookies.length; index++) {\n        var entry = cookies[index]\n\n        if (is(entry).a(String) && does(entry).contain(';')) {\n          entry.split(';').forEach(setCookie)\n        }\n      }\n    }\n\n    // Handle cookies that have been set\n    cookies = response.headers.cookie\n    if (cookies && is(cookies).a(String)) {\n      cookies.split(';').forEach(setCookie)\n    }\n  }\n\n  // Obtain response body\n  body = body || response.body\n  result.raw_body = body\n  result.headers = response.headers\n\n  // Handle Response Body\n  if (body) {\n    type = Unirest.type(result.headers['content-type'], true)\n    if (type) data = Unirest.Response.parse(body, type)\n    else data = body\n  }\n\n  result.body = data\n\n  ;(handleRetriableRequestResponse(result)) && (callback) && callback(result)\n}"
        }
    },
    {
        "repo": "virtual-scroll",
        "content": "'virtual-scroll/src/keycodes.js'\n:export const keyCodes = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    SPACE: 32\n}\n\n'virtual-scroll/src/index.js'\n:import Emitter from 'tiny-emitter'\nimport { getSupport } from './support'\nimport { keyCodes } from './keycodes'\n\nconst EVT_ID = 'virtualscroll'\nvar support\n\nexport default class VirtualScroll {\n    #options\n    #el\n    #emitter\n    #event\n    #touchStart\n    #bodyTouchAction\n\n    constructor(options) {\n        this.#el = window\n        if (options && options.el) {\n            this.#el = options.el\n            delete options.el\n        }\n        \n        if (!support) support = getSupport()\n\n        this.#options = Object.assign(\n            {\n                mouseMultiplier: 1,\n                touchMultiplier: 2,\n                firefoxMultiplier: 15,\n                keyStep: 120,\n                preventTouch: false,\n                unpreventTouchClass: 'vs-touchmove-allowed',\n                useKeyboard: true,\n                useTouch: true\n            },\n            options\n        )\n\n        this.#emitter = new Emitter()\n        this.#event = {\n            y: 0,\n            x: 0,\n            deltaX: 0,\n            deltaY: 0\n        }\n        this.#touchStart = {\n            x: null,\n            y: null\n        }\n        this.#bodyTouchAction = null\n\n        if (this.#options.passive !== undefined) {\n            this.listenerOptions = { passive: this.#options.passive }\n        }\n    }\n\n    _notify(e) {\n        var evt = this.#event\n        evt.x += evt.deltaX\n        evt.y += evt.deltaY\n\n        this.#emitter.emit(EVT_ID, {\n            x: evt.x,\n            y: evt.y,\n            deltaX: evt.deltaX,\n            deltaY: evt.deltaY,\n            originalEvent: e\n        })\n    }\n\n    _onWheel = (e) => {\n        var options = this.#options\n        var evt = this.#event\n\n        // In Chrome and in Firefox (at least the new one)\n        evt.deltaX = e.wheelDeltaX || e.deltaX * -1\n        evt.deltaY = e.wheelDeltaY || e.deltaY * -1\n\n        // for our purpose deltamode = 1 means user is on a wheel mouse, not touch pad\n        // real meaning: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent#Delta_modes\n        if (support.isFirefox && e.deltaMode === 1) {\n            evt.deltaX *= options.firefoxMultiplier\n            evt.deltaY *= options.firefoxMultiplier\n        }\n\n        evt.deltaX *= options.mouseMultiplier\n        evt.deltaY *= options.mouseMultiplier\n\n        this._notify(e)\n    }\n\n    _onMouseWheel = (e) => {\n        var evt = this.#event\n\n        // In Safari, IE and in Chrome if 'wheel' isn't defined\n        evt.deltaX = e.wheelDeltaX ? e.wheelDeltaX : 0\n        evt.deltaY = e.wheelDeltaY ? e.wheelDeltaY : e.wheelDelta\n\n        this._notify(e)\n    }\n\n    _onTouchStart = (e) => {\n        var t = e.targetTouches ? e.targetTouches[0] : e\n        this.#touchStart.x = t.pageX\n        this.#touchStart.y = t.pageY\n    }\n\n    _onTouchMove = (e) => {\n        var options = this.#options\n        if (\n            options.preventTouch &&\n            !e.target.classList.contains(options.unpreventTouchClass)\n        ) {\n            e.preventDefault()\n        }\n\n        var evt = this.#event\n\n        var t = e.targetTouches ? e.targetTouches[0] : e\n\n        evt.deltaX = (t.pageX - this.#touchStart.x) * options.touchMultiplier\n        evt.deltaY = (t.pageY - this.#touchStart.y) * options.touchMultiplier\n\n        this.#touchStart.x = t.pageX\n        this.#touchStart.y = t.pageY\n\n        this._notify(e)\n    }\n\n    _onKeyDown = (e) => {\n        var evt = this.#event\n        evt.deltaX = evt.deltaY = 0\n        var windowHeight = window.innerHeight - 40\n\n        switch (e.keyCode) {\n            case keyCodes.LEFT:\n            case keyCodes.UP:\n                evt.deltaY = this.#options.keyStep\n                break\n\n            case keyCodes.RIGHT:\n            case keyCodes.DOWN:\n                evt.deltaY = -this.#options.keyStep\n                break\n            case keyCodes.SPACE:\n                evt.deltaY = windowHeight * (e.shiftKey ? 1 : -1)\n                break\n            default:\n                return\n        }\n\n        this._notify(e)\n    }\n\n    _bind() {\n        if (support.hasWheelEvent) {\n            this.#el.addEventListener(\n                'wheel',\n                this._onWheel,\n                this.listenerOptions\n            )\n        }\n\n        if (support.hasMouseWheelEvent) {\n            this.#el.addEventListener(\n                'mousewheel',\n                this._onMouseWheel,\n                this.listenerOptions\n            )\n        }\n\n        if (support.hasTouch && this.#options.useTouch) {\n            this.#el.addEventListener(\n                'touchstart',\n                this._onTouchStart,\n                this.listenerOptions\n            )\n            this.#el.addEventListener(\n                'touchmove',\n                this._onTouchMove,\n                this.listenerOptions\n            )\n        }\n\n        if (support.hasPointer && support.hasTouchWin) {\n            this.#bodyTouchAction = document.body.style.msTouchAction\n            document.body.style.msTouchAction = 'none'\n            this.#el.addEventListener('MSPointerDown', this._onTouchStart, true)\n            this.#el.addEventListener('MSPointerMove', this._onTouchMove, true)\n        }\n\n        if (support.hasKeyDown && this.#options.useKeyboard) {\n            document.addEventListener('keydown', this._onKeyDown)\n        }\n    }\n\n    _unbind() {\n        if (support.hasWheelEvent) {\n            this.#el.removeEventListener('wheel', this._onWheel)\n        }\n\n        if (support.hasMouseWheelEvent) {\n            this.#el.removeEventListener('mousewheel', this._onMouseWheel)\n        }\n\n        if (support.hasTouch) {\n            this.#el.removeEventListener('touchstart', this._onTouchStart)\n            this.#el.removeEventListener('touchmove', this._onTouchMove)\n        }\n\n        if (support.hasPointer && support.hasTouchWin) {\n            document.body.style.msTouchAction = this.#bodyTouchAction\n            this.#el.removeEventListener(\n                'MSPointerDown',\n                this._onTouchStart,\n                true\n            )\n            this.#el.removeEventListener(\n                'MSPointerMove',\n                this._onTouchMove,\n                true\n            )\n        }\n\n        if (support.hasKeyDown && this.#options.useKeyboard) {\n            document.removeEventListener('keydown', this._onKeyDown)\n        }\n    }\n\n    on(cb, ctx) {\n        this.#emitter.on(EVT_ID, cb, ctx)\n\n        var events = this.#emitter.e\n        if (events && events[EVT_ID] && events[EVT_ID].length === 1)\n            this._bind()\n    }\n\n    off(cb, ctx) {\n        this.#emitter.off(EVT_ID, cb, ctx)\n\n        var events = this.#emitter.e\n        if (!events[EVT_ID] || events[EVT_ID].length <= 0) this._unbind()\n    }\n\n    destroy() {\n        this.#emitter.off()\n        this._unbind()\n    }\n}\n",
        "called_code_segment": "this.#emitter.on(EVT_ID, cb, ctx);",
        "invoking_code_segment": "virtualScroll.on((e) => { console.log(e); });",
        "feature_description": "Add a feature to allow users to specify a custom event ID when subscribing to events.",
        "detailed_feature_description": "Modify the `on` method in #file 1 to accept an optional custom event ID. Update the corresponding code in #file 2 to pass the custom event ID when subscribing to events.",
        "modified_complete_code": {
            "file1": "virtual-scroll/src/index.js",
            "code": "export const keyCodes = {\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    SPACE: 32\n}\n\n// New code snippet in #file 2\nconst customEventId = 'customVirtualScroll';\nvirtualScroll.on((e) => { console.log(e); }, null, customEventId); // #New\n",
            "file2": "virtual-scroll/src/keycodes.js"
        }
    },
    {
        "repo": "React_Redux_Tutorial",
        "content": "'React_Redux_Tutorial/src/redux/store.js'\n:import { createStore } from \"redux\";\n\nimport reducers from \"./reducers/index\";\n\nconst store = createStore(\n  reducers,\n  {},\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n);\n\nexport default store;\n\n'React_Redux_Tutorial/src/index.js'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport store from \"./redux/store\";\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n",
        "called_code_segment": "const store = createStore(\n  reducers,\n  {},\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n);",
        "invoking_code_segment": "<Provider store={store}>\n      <App />\n    </Provider>",
        "feature_description": "Add middleware to the Redux store for logging actions and state changes.",
        "detailed_feature_description": "To implement this feature, we will use the Redux middleware 'redux-logger'. This middleware will log every action dispatched to the store and the state changes resulting from those actions. We will modify the store creation in #file 1 to include this middleware, and ensure that #file 2 still correctly initializes the store.",
        "modified_complete_code": {
            "file1": "import { createStore, applyMiddleware } from \"redux\";\nimport { createLogger } from \"redux-logger\";\nimport reducers from \"./reducers/index\";\n\nconst logger = createLogger();\nconst store = createStore(\n  reducers,\n  {},\n  applyMiddleware(logger),\n  window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__()\n);\n\nexport default store;",
            "file2": "import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport store from \"./redux/store\";\nimport { Provider } from \"react-redux\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <App />\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);"
        }
    },
    {
        "repo": "vue-form-json-schema",
        "content": "'vue-form-json-schema/webpack.config.common.js'\n:const path = require('path');\nconst LodashModuleReplacementPlugin = require('lodash-webpack-plugin');\n\nmodule.exports = {\n  context: path.resolve(__dirname, './src'),\n  module: {\n    rules: [{\n      test: /\\.js$/,\n      exclude: /node_modules/,\n      loader: 'babel-loader',\n    }],\n  },\n  plugins: [\n    new LodashModuleReplacementPlugin({\n      cloning: true,\n      caching: true,\n      paths: true,\n    }),\n  ],\n};\n\n'vue-form-json-schema/webpack.config.prod.js'\n:const path = require('path');\nconst merge = require('webpack-merge');\nconst nodeExternals = require('webpack-node-externals');\nconst common = require('./webpack.config.common');\n\nconst production = {\n  entry: path.resolve(__dirname, './src/index.js'),\n  devtool: 'source-map',\n  mode: 'production',\n  optimization: {\n    minimize: true,\n  },\n};\n\nmodule.exports = [\n  merge(common, production, {\n    externals: [\n      {\n        vue: 'Vue',\n      },\n      nodeExternals({\n        whitelist: [\n          /^lodash/,\n          'ajv',\n          // ajv dependencies\n          'fast-deep-equal',\n          'fast-json-stable-stringify',\n          'json-schema-traverse',\n          'uri-js',\n        ],\n      }),\n    ],\n    output: {\n      path: path.resolve(__dirname, './dist'),\n      filename: 'vue-form-json-schema.umd.js',\n      libraryTarget: 'umd',\n      library: 'VueFormJsonSchema',\n      umdNamedDefine: true,\n    },\n  }),\n  merge(common, production, {\n    externals: [nodeExternals()],\n    output: {\n      path: path.resolve(__dirname, './dist'),\n      filename: 'vue-form-json-schema.esm.js',\n      libraryTarget: 'commonjs2',\n      library: 'VueFormJsonSchema',\n    },\n  }),\n];\n\n",
        "called_code_segment": "module.exports = { context: path.resolve(__dirname, './src'), module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', }], }, plugins: [ new LodashModuleReplacementPlugin({ cloning: true, caching: true, paths: true, }), ], };",
        "invoking_code_segment": "const common = require('./webpack.config.common'); const production = { entry: path.resolve(__dirname, './src/index.js'), devtool: 'source-map', mode: 'production', optimization: { minimize: true, }, }; module.exports = [ merge(common, production, { externals: [ { vue: 'Vue', }, nodeExternals({ whitelist: [ /^lodash/, 'ajv', 'fast-deep-equal', 'fast-json-stable-stringify', 'json-schema-traverse', 'uri-js', ], }), ], output: { path: path.resolve(__dirname, './dist'), filename: 'vue-form-json-schema.umd.js', libraryTarget: 'umd', library: 'VueFormJsonSchema', umdNamedDefine: true, }, }), merge(common, production, { externals: [nodeExternals()], output: { path: path.resolve(__dirname, './dist'), filename: 'vue-form-json-schema.esm.js', libraryTarget: 'commonjs2', library: 'VueFormJsonSchema', }, }), ];",
        "feature_description": "Add a new plugin to the common Webpack configuration to optimize bundle size further.",
        "detailed_feature_description": "Introduce the `TerserPlugin` to the common Webpack configuration to minify and optimize the JavaScript code. Update the production configuration to handle the new plugin.",
        "modified_complete_code": {
            "webpack.config.common.js": "const path = require('path'); const LodashModuleReplacementPlugin = require('lodash-webpack-plugin'); const TerserPlugin = require('terser-webpack-plugin'); #Modify module.exports = { context: path.resolve(__dirname, './src'), module: { rules: [{ test: /\\.js$/, exclude: /node_modules/, loader: 'babel-loader', }], }, plugins: [ new LodashModuleReplacementPlugin({ cloning: true, caching: true, paths: true, }), #New new TerserPlugin({ terserOptions: { compress: { drop_console: true, }, }, }), ], };",
            "webpack.config.prod.js": "const path = require('path'); const merge = require('webpack-merge'); const nodeExternals = require('webpack-node-externals'); const common = require('./webpack.config.common'); const production = { entry: path.resolve(__dirname, './src/index.js'), devtool: 'source-map', mode: 'production', optimization: { minimize: true, }, }; module.exports = [ merge(common, production, { externals: [ { vue: 'Vue', }, nodeExternals({ whitelist: [ /^lodash/, 'ajv', 'fast-deep-equal', 'fast-json-stable-stringify', 'json-schema-traverse', 'uri-js', ], }), ], output: { path: path.resolve(__dirname, './dist'), filename: 'vue-form-json-schema.umd.js', libraryTarget: 'umd', library: 'VueFormJsonSchema', umdNamedDefine: true, }, }), merge(common, production, { externals: [nodeExternals()], output: { path: path.resolve(__dirname, './dist'), filename: 'vue-form-json-schema.esm.js', libraryTarget: 'commonjs2', library: 'VueFormJsonSchema', }, }), ];"
        }
    },
    {
        "repo": "SimpleStateManager",
        "content": "'SimpleStateManager/src/state.js'\n:import {\n    fireAllMethodsInArray,\n    makeID,\n} from './utils';\n\nconst configOptions = [];\nlet stateChangeMethod = () => { };\n\nexport default class State {\n    constructor(options) {\n        this.id = options.id || makeID();\n        this.query = options.query || 'all';\n\n        const defaultOptions = {\n            onEnter: [],\n            onLeave: [],\n            onResize: [],\n            onFirstRun: [],\n        };\n\n        // Merge options with defaults to make the state\n        this.options = Object.assign({}, defaultOptions, options);\n\n        // Migrate methods into an array, this is to enable future functionality of adding extra methods to an existing state\n        if (typeof this.options.onEnter === 'function') {\n            this.options.onEnter = [this.options.onEnter];\n        }\n\n        if (typeof this.options.onLeave === 'function') {\n            this.options.onLeave = [this.options.onLeave];\n        }\n\n        if (typeof this.options.onResize === 'function') {\n            this.options.onResize = [this.options.onResize];\n        }\n\n        if (typeof this.options.onFirstRun === 'function') {\n            this.options.onFirstRun = [this.options.onFirstRun];\n        }\n\n        // Test the one time tests first, if the test is invalid we wont create the config option\n        if (this.testConfigOptions('once') === false) {\n            this.valid = false;\n            return false;\n        }\n\n        this.valid = true;\n        this.active = false;\n        this.init();\n    }\n\n    init() {\n        this.test = window.matchMedia(this.query);\n\n        if (this.test.matches && this.testConfigOptions('match')) {\n            this.enterState();\n        }\n\n        this.listener = (test) => {\n            let changed = false;\n\n            if (test.matches) {\n                if (this.testConfigOptions('match')) {\n                    this.enterState();\n                    changed = true;\n                }\n            } else {\n                this.leaveState();\n                changed = true;\n            }\n\n            if (changed) {\n                stateChangeMethod();\n            }\n        };\n\n        this.test.addListener(this.listener);\n    }\n\n    // Handle entering a state\n    enterState() {\n        fireAllMethodsInArray(this.options.onFirstRun, this.eventData('firstRun'));\n        fireAllMethodsInArray(this.options.onEnter, this.eventData('enter'));\n        this.options.onFirstRun = [];\n        this.active = true;\n    }\n\n    // Handle leaving a state\n    leaveState() {\n        fireAllMethodsInArray(this.options.onLeave, this.eventData('leave'));\n        this.active = false;\n    }\n\n    // Handle the user resizing the browser\n    resizeState() {\n        if (this.testConfigOptions('resize')) {\n            fireAllMethodsInArray(this.options.onResize, this.eventData('resize'));\n        }\n    }\n\n    // When the StateManager removes a state we want to remove the event listener\n    destroy() {\n        this.test.removeListener(this.listener);\n    }\n\n    attachCallback(type, callback, runIfActive) {\n        switch (type) {\n        case 'enter':\n            this.options.onEnter.push(callback);\n            break;\n        case 'leave':\n            this.options.onLeave.push(callback);\n            break;\n        case 'resize':\n            this.options.onResize.push(callback);\n            break;\n        default:\n            break;\n        }\n\n        if (type === 'enter' && runIfActive && this.active) {\n            callback(this.eventData(type));\n        }\n    }\n\n    testConfigOptions(when) {\n        let test = true;\n\n        configOptions.forEach((configOption) => {\n            if (typeof this.options[configOption.name] !== 'undefined') {\n                if (configOption.when === when && configOption.test.bind(this)() === false) {\n                    test = false;\n                }\n            }\n        });\n\n        return test;\n    }\n\n    eventData(eventType) {\n        return {\n            eventType,\n            state: this,\n        };\n    }\n\n    static addConfigOption(configOption) {\n        configOptions.push(configOption);\n    }\n\n    static getConfigOptions() {\n        return configOptions;\n    }\n\n    static removeConfigOption(name) {\n        configOptions.forEach((item, index) => {\n            if (item.name === name) {\n                configOptions.splice(index, 1);\n            }\n        });\n    }\n\n    static setStateChangeMethod(func) {\n        if (typeof func === 'function') {\n            stateChangeMethod = func;\n        } else {\n            throw new Error('Not a function');\n        }\n    }\n}\n\n'SimpleStateManager/src/ssm.js'\n:import State from './state';\nimport {\n    debounce,\n    filterStates,\n} from './utils';\n\n// State Manager Constructor\nclass StateManager {\n    constructor() {\n        this.states = [];\n        this.resizeTimer = null;\n        this.configOptions = [];\n\n        window.addEventListener('resize', debounce(this.resizeBrowser.bind(this), 25), true);\n    }\n\n    addState(options) {\n        const newState = new State(options);\n\n        if (newState.valid) {\n            this.states.push(newState);\n        }\n\n        return newState;\n    }\n\n    addStates(statesArray) {\n        statesArray.forEach(state => this.addState(state));\n    }\n\n    getState(id) {\n        const selectedState = this.states.filter(state => state.id === id);\n\n        return selectedState[0] || false;\n    }\n\n    isActive(id) {\n        const selectedState = this.getState(id) || {};\n\n        return selectedState.active || false;\n    }\n\n    getStates(idArr) {\n        if (typeof (idArr) === 'undefined') {\n            return this.states;\n        }\n\n        return idArr.map(id => this.getState(id));\n    }\n\n    removeState(id) {\n        this.states.forEach((state, index) => {\n            if (state.id === id) {\n                state.destroy();\n                this.states.splice(index, 1);\n            }\n        });\n    }\n\n    removeStates(idArray) {\n        idArray.forEach(id => this.removeState(id));\n    }\n\n    removeAllStates() {\n        this.states.forEach(state => state.destroy());\n        this.states = [];\n    }\n\n    addConfigOption({\n        name = '', // name, this is used to apply to a state\n        test = null, // function which will perform the test\n        when = 'resize', // resize or match (match will mean that resize will never fire either), or once (which will test once, then delete state if test doesnt pass)\n    }) {\n        if (name !== '' && test !== null) {\n            State.addConfigOption({\n                name,\n                test,\n                when,\n            });\n        }\n    }\n\n    removeConfigOption(name) {\n        State.removeConfigOption(name);\n    }\n\n    getConfigOptions(name) {\n        const configOptions = State.getConfigOptions();\n\n        if (typeof name === 'string') {\n            return configOptions.filter(configOption => configOption.name === name);\n        }\n\n        return configOptions;\n    }\n\n    resizeBrowser() {\n        const activeStates = filterStates(this.states, 'active', true);\n\n        activeStates.forEach((state) => {\n            state.resizeState();\n        });\n    }\n\n    stateChange(func) {\n        State.setStateChangeMethod(func);\n    }\n}\n\nexport default new StateManager();\n\n",
        "called_code_segment": "enterState() {\n    fireAllMethodsInArray(this.options.onFirstRun, this.eventData('firstRun'));\n    fireAllMethodsInArray(this.options.onEnter, this.eventData('enter'));\n    this.options.onFirstRun = [];\n    this.active = true;\n}",
        "invoking_code_segment": "if (test.matches) {\n    if (this.testConfigOptions('match')) {\n        this.enterState();\n        changed = true;\n    }\n}",
        "feature_description": "Add a feature to log the state transitions.",
        "detailed_feature_description": "Modify the `enterState` method in #file 1 to log when a state is entered. Also, modify the invocation in #file 2 to include a log message when the state is about to be entered.",
        "modified_complete_code": {
            "#file 1": "enterState() {\n    console.log(`Entering state: ${this.id}`);\n    fireAllMethodsInArray(this.options.onFirstRun, this.eventData('firstRun'));\n    fireAllMethodsInArray(this.options.onEnter, this.eventData('enter'));\n    this.options.onFirstRun = [];\n    this.active = true;\n}",
            "#file 2": "if (test.matches) {\n    console.log(`About to enter state: ${this.id}`);\n    if (this.testConfigOptions('match')) {\n        this.enterState();\n        changed = true;\n    }\n}"
        }
    },
    {
        "repo": "vue-trello-clone",
        "content": "'vue-trello-clone/build/utils.js'\n:'use strict'\nconst path = require('path')\nconst config = require('../config')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst packageConfig = require('../package.json')\n\nexports.assetsPath = function (_path) {\n  const assetsSubDirectory = process.env.NODE_ENV === 'production'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  return path.posix.join(assetsSubDirectory, _path)\n}\n\nexports.cssLoaders = function (options) {\n  options = options || {}\n\n  const cssLoader = {\n    loader: 'css-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  const postcssLoader = {\n    loader: 'postcss-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  // generate loader string to be used with extract text plugin\n  function generateLoaders (loader, loaderOptions) {\n    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n\n    if (loader) {\n      loaders.push({\n        loader: loader + '-loader',\n        options: Object.assign({}, loaderOptions, {\n          sourceMap: options.sourceMap\n        })\n      })\n    }\n\n    // Extract CSS when that option is specified\n    // (which is the case during production build)\n    if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader'\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }\n  }\n\n  // https://vue-loader.vuejs.org/en/configurations/extract-css.html\n  return {\n    css: generateLoaders(),\n    postcss: generateLoaders(),\n    less: generateLoaders('less'),\n    sass: generateLoaders('sass', { indentedSyntax: true }),\n    scss: generateLoaders('sass'),\n    stylus: generateLoaders('stylus'),\n    styl: generateLoaders('stylus')\n  }\n}\n\n// Generate loaders for standalone style files (outside of .vue)\nexports.styleLoaders = function (options) {\n  const output = []\n  const loaders = exports.cssLoaders(options)\n\n  for (const extension in loaders) {\n    const loader = loaders[extension]\n    output.push({\n      test: new RegExp('\\\\.' + extension + '$'),\n      use: loader\n    })\n  }\n\n  return output\n}\n\nexports.createNotifierCallback = () => {\n  const notifier = require('node-notifier')\n\n  return (severity, errors) => {\n    if (severity !== 'error') return\n\n    const error = errors[0]\n    const filename = error.file && error.file.split('!').pop()\n\n    notifier.notify({\n      title: packageConfig.name,\n      message: severity + ': ' + error.name,\n      subtitle: filename || '',\n      icon: path.join(__dirname, 'logo.png')\n    })\n  }\n}\n\n'vue-trello-clone/build/webpack.dev.conf.js'\n:'use strict'\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst path = require('path')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')\nconst portfinder = require('portfinder')\n\nconst HOST = process.env.HOST\nconst PORT = process.env.PORT && Number(process.env.PORT)\n\nconst devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  // cheap-module-eval-source-map is faster for development\n  devtool: config.dev.devtool,\n\n  // these devServer options should be customized in /config/index.js\n  devServer: {\n    clientLogLevel: 'warning',\n    historyApiFallback: {\n      rewrites: [\n        { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },\n      ],\n    },\n    hot: true,\n    contentBase: false, // since we use CopyWebpackPlugin.\n    compress: true,\n    host: HOST || config.dev.host,\n    port: PORT || config.dev.port,\n    open: config.dev.autoOpenBrowser,\n    overlay: config.dev.errorOverlay\n      ? { warnings: false, errors: true }\n      : false,\n    publicPath: config.dev.assetsPublicPath,\n    proxy: config.dev.proxyTable,\n    quiet: true, // necessary for FriendlyErrorsPlugin\n    watchOptions: {\n      poll: config.dev.poll,\n    }\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env': require('../config/dev.env')\n    }),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n    new webpack.NoEmitOnErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: 'index.html',\n      inject: true\n    }),\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.dev.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nmodule.exports = new Promise((resolve, reject) => {\n  portfinder.basePort = process.env.PORT || config.dev.port\n  portfinder.getPort((err, port) => {\n    if (err) {\n      reject(err)\n    } else {\n      // publish the new Port, necessary for e2e tests\n      process.env.PORT = port\n      // add port to devServer config\n      devWebpackConfig.devServer.port = port\n\n      // Add FriendlyErrorsPlugin\n      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({\n        compilationSuccessInfo: {\n          messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],\n        },\n        onErrors: config.dev.notifyOnErrors\n        ? utils.createNotifierCallback()\n        : undefined\n      }))\n\n      resolve(devWebpackConfig)\n    }\n  })\n})\n\n",
        "called_code_segment": "exports.cssLoaders = function (options) {\n  options = options || {}\n\n  const cssLoader = {\n    loader: 'css-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  const postcssLoader = {\n    loader: 'postcss-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  function generateLoaders (loader, loaderOptions) {\n    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n\n    if (loader) {\n      loaders.push({\n        loader: loader + '-loader',\n        options: Object.assign({}, loaderOptions, {\n          sourceMap: options.sourceMap\n        })\n      })\n    }\n\n    if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader'\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }\n  }\n\n  return {\n    css: generateLoaders(),\n    postcss: generateLoaders(),\n    less: generateLoaders('less'),\n    sass: generateLoaders('sass', { indentedSyntax: true }),\n    scss: generateLoaders('sass'),\n    stylus: generateLoaders('stylus'),\n    styl: generateLoaders('stylus')\n  }\n}",
        "invoking_code_segment": "const devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  devtool: config.dev.devtool,\n  devServer: {\n    clientLogLevel: 'warning',\n    historyApiFallback: {\n      rewrites: [\n        { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },\n      ],\n    },\n    hot: true,\n    contentBase: false, // since we use CopyWebpackPlugin.\n    compress: true,\n    host: HOST || config.dev.host,\n    port: PORT || config.dev.port,\n    open: config.dev.autoOpenBrowser,\n    overlay: config.dev.errorOverlay\n      ? { warnings: false, errors: true }\n      : false,\n    publicPath: config.dev.assetsPublicPath,\n    proxy: config.dev.proxyTable,\n    quiet: true, // necessary for FriendlyErrorsPlugin\n    watchOptions: {\n      poll: config.dev.poll,\n    }\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env': require('../config/dev.env')\n    }),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n    new webpack.NoEmitOnErrorsPlugin(),\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: 'index.html',\n      inject: true\n    }),\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.dev.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})",
        "feature_description": "Add support for Tailwind CSS in the development environment.",
        "detailed_feature_description": "To add support for Tailwind CSS, we need to modify the cssLoaders function in utils.js to include a loader for Tailwind CSS. Then, update the devWebpackConfig in webpack.dev.conf.js to use the new cssLoaders configuration.",
        "modified_complete_code": {
            "utils.js": "exports.cssLoaders = function (options) {\n  options = options || {}\n\n  const cssLoader = {\n    loader: 'css-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  const postcssLoader = {\n    loader: 'postcss-loader',\n    options: {\n      sourceMap: options.sourceMap,\n      #Modify: Add Tailwind CSS configuration\n      plugins: [require('tailwindcss'), require('autoprefixer')]\n    }\n  }\n\n  function generateLoaders (loader, loaderOptions) {\n    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n\n    if (loader) {\n      loaders.push({\n        loader: loader + '-loader',\n        options: Object.assign({}, loaderOptions, {\n          sourceMap: options.sourceMap\n        })\n      })\n    }\n\n    if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader'\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }\n  }\n\n  return {\n    css: generateLoaders(),\n    postcss: generateLoaders(),\n    less: generateLoaders('less'),\n    sass: generateLoaders('sass', { indentedSyntax: true }),\n    scss: generateLoaders('sass'),\n    stylus: generateLoaders('stylus'),\n    styl: generateLoaders('stylus')\n  }\n}",
            "webpack.dev.conf.js": "const devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  devtool: config.dev.devtool,\n  devServer: {\n    clientLogLevel: 'warning',\n    historyApiFallback: {\n      rewrites: [\n        { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },\n      ],\n    },\n    hot: true,\n    contentBase: false, // since we use CopyWebpackPlugin.\n    compress: true,\n    host: HOST || config.dev.host,\n    port: PORT || config.dev.port,\n    open: config.dev.autoOpenBrowser,\n    overlay: config.dev.errorOverlay\n      ? { warnings: false, errors: true }\n      : false,\n    publicPath: config.dev.assetsPublicPath,\n    proxy: config.dev.proxyTable,\n    quiet: true, // necessary for FriendlyErrorsPlugin\n    watchOptions: {\n      poll: config.dev.poll,\n    }\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env': require('../config/dev.env')\n    }),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n    new webpack.NoEmitOnErrorsPlugin(),\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: 'index.html',\n      inject: true\n    }),\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.dev.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})"
        }
    },
    {
        "repo": "web-ifc-three",
        "content": "'web-ifc-three/example/src/ifc-manager.js'\n:import {Matrix4} from 'three';\nimport {IFCLoader} from 'web-ifc-three/dist/IFCLoader';\nimport {acceleratedRaycast, computeBoundsTree, disposeBoundsTree} from 'three-mesh-bvh';\nimport {IFCWALLSTANDARDCASE, IFCSLAB, IFCWINDOW, IFCSPACE, IFCOPENINGELEMENT} from 'web-ifc';\nimport {downloadZip} from \"client-zip\";\n\nexport class IfcManager {\n    constructor(scene, ifcModels) {\n        this.scene = scene;\n        this.ifcModels = ifcModels;\n        this.ifcLoader = new IFCLoader();\n        this.setupIfcLoader();\n        this.setupFileOpener();\n    }\n\n    remove = false;\n\n    async editSubset(type) {\n        const ids = await this.ifcLoader.ifcManager.getAllItemsOfType(0, type, false);\n        if (this.remove) this.ifcLoader.ifcManager.removeFromSubset(0, ids);\n        else this.ifcLoader.ifcManager.createSubset({modelID: 0, ids, applyBVH: false, removePrevious: false})\n    }\n\n    setupThreeMeshBVH() {\n        this.ifcLoader.ifcManager.setupThreeMeshBVH(\n            computeBoundsTree,\n            disposeBoundsTree,\n            acceleratedRaycast\n        );\n    }\n\n    async setupIfcLoader() {\n\n        await this.ifcLoader.ifcManager.parser.setupOptionalCategories({\n            [IFCSPACE]: false,\n            [IFCOPENINGELEMENT]: false\n        });\n\n        // await this.ifcLoader.ifcManager.useWebWorkers(true, 'IFCWorker.js');\n        this.setupThreeMeshBVH();\n    }\n\n    setupFileOpener() {\n        const input = document.querySelector('input[type=\"file\"]');\n        if (!input) return;\n        input.addEventListener(\n            'change',\n            async (changed) => {\n                await this.loadIFC(changed);\n            },\n            false\n        );\n    }\n\n    async dispose() {\n        this.ifcModels.length = 0;\n        await this.ifcLoader.ifcManager.dispose();\n        this.ifcLoader = null;\n        this.ifcLoader = new IFCLoader();\n        await this.setupIfcLoader();\n    }\n\n    subset = {};\n\n    async loadIFC(changed) {\n\n        const start = window.performance.now()\n\n        const ifcURL = URL.createObjectURL(changed.target.files[0]);\n        this.ifcLoader.ifcManager.setOnProgress((event) => console.log(event));\n\n        const firstModel = Boolean(this.ifcModels.length === 0);\n\n        await this.ifcLoader.ifcManager.applyWebIfcConfig({\n            COORDINATE_TO_ORIGIN: firstModel,\n            USE_FAST_BOOLS: true\n        });\n\n        const ifcModel = await this.ifcLoader.loadAsync(ifcURL);\n\n        if (firstModel) {\n            const matrixArr = await this.ifcLoader.ifcManager.ifcAPI.GetCoordinationMatrix(ifcModel.modelID);\n            const matrix = new Matrix4().fromArray(matrixArr);\n            this.ifcLoader.ifcManager.setupCoordinationMatrix(matrix);\n        }\n\n        this.ifcModels.push(ifcModel);\n        this.scene.add(ifcModel);\n\n        const stop = window.performance.now()\n\n        console.log(`Time Taken to load = ${(stop - start) / 1000} seconds`);\n    }\n\n    async downloadFragment(model) {\n\n        const files = [];\n        for (const frag of model.fragments) {\n            const file = await frag.export();\n            files.push(file.geometry, file.data);\n        }\n\n        const serializer = this.ifcLoader.ifcManager.properties.serializer;\n        const propertyBlob = await serializer.serializeAllProperties(model.modelID);\n        const propertyFile = new File(propertyBlob, \"properties.json\");\n\n        files.push(new File([JSON.stringify(model.levelRelationships)], 'levels-relationship.json'));\n        files.push(new File([JSON.stringify(model.itemTypes)], 'model-types.json'));\n        files.push(new File([JSON.stringify(model.allTypes)], 'all-types.json'));\n        files.push(new File([JSON.stringify(model.floorsProperties)], 'levels-properties.json'));\n\n        const blob = await downloadZip(files).blob();\n        const link = document.createElement(\"a\");\n\n        link.href = URL.createObjectURL(blob);\n        link.download = \"test.zip\";\n        link.click();\n\n        link.href = URL.createObjectURL(propertyFile);\n        link.download = \"properties.json\";\n        link.click();\n\n        link.remove();\n    }\n}\n'web-ifc-three/example/src/main.js'\n:import { ThreeScene } from './scene';\nimport { IfcManager } from './ifc-manager';\n\nconst ifcModels = [];\nconst baseScene = new ThreeScene();\nconst loader = new IfcManager(baseScene.scene, ifcModels);\n",
        "called_code_segment": "async loadIFC(changed) {\n\n        const start = window.performance.now()\n\n        const ifcURL = URL.createObjectURL(changed.target.files[0]);\n        this.ifcLoader.ifcManager.setOnProgress((event) => console.log(event));\n\n        const firstModel = Boolean(this.ifcModels.length === 0);\n\n        await this.ifcLoader.ifcManager.applyWebIfcConfig({\n            COORDINATE_TO_ORIGIN: firstModel,\n            USE_FAST_BOOLS: true\n        });\n\n        const ifcModel = await this.ifcLoader.loadAsync(ifcURL);\n\n        if (firstModel) {\n            const matrixArr = await this.ifcLoader.ifcManager.ifcAPI.GetCoordinationMatrix(ifcModel.modelID);\n            const matrix = new Matrix4().fromArray(matrixArr);\n            this.ifcLoader.ifcManager.setupCoordinationMatrix(matrix);\n        }\n\n        this.ifcModels.push(ifcModel);\n        this.scene.add(ifcModel);\n\n        const stop = window.performance.now()\n\n        console.log(`Time Taken to load = ${(stop - start) / 1000} seconds`);\n    }",
        "invoking_code_segment": "setupFileOpener() {\n        const input = document.querySelector('input[type=\"file\"]');\n        if (!input) return;\n        input.addEventListener(\n            'change',\n            async (changed) => {\n                await this.loadIFC(changed);\n            },\n            false\n        );\n    }",
        "feature_description": "Add a progress bar to show the loading progress of the IFC file.",
        "detailed_feature_description": "Modify the `loadIFC` method in `ifc-manager.js` to update a progress bar as the file loads. Update the `setupFileOpener` method in `ifc-manager.js` to initialize the progress bar and handle its updates.",
        "modified_complete_code": {
            "ifc-manager.js": "async loadIFC(changed) {\n\n        const start = window.performance.now()\n\n        const ifcURL = URL.createObjectURL(changed.target.files[0]);\n        this.ifcLoader.ifcManager.setOnProgress((event) => {\n            const progress = (event.loaded / event.total) * 100;\n            this.updateProgressBar(progress);\n        });\n\n        const firstModel = Boolean(this.ifcModels.length === 0);\n\n        await this.ifcLoader.ifcManager.applyWebIfcConfig({\n            COORDINATE_TO_ORIGIN: firstModel,\n            USE_FAST_BOOLS: true\n        });\n\n        const ifcModel = await this.ifcLoader.loadAsync(ifcURL);\n\n        if (firstModel) {\n            const matrixArr = await this.ifcLoader.ifcManager.ifcAPI.GetCoordinationMatrix(ifcModel.modelID);\n            const matrix = new Matrix4().fromArray(matrixArr);\n            this.ifcLoader.ifcManager.setupCoordinationMatrix(matrix);\n        }\n\n        this.ifcModels.push(ifcModel);\n        this.scene.add(ifcModel);\n\n        const stop = window.performance.now()\n\n        console.log(`Time Taken to load = ${(stop - start) / 1000} seconds`);\n    }\n\n    #Modify\n    updateProgressBar(progress) {\n        const progressBar = document.getElementById('progress-bar');\n        if (progressBar) {\n            progressBar.style.width = progress + '%';\n            progressBar.innerText = progress + '%';\n        }\n    }\n\n    #New\n    setupProgressBar() {\n        const progressBarContainer = document.createElement('div');\n        progressBarContainer.style.width = '100%';\n        progressBarContainer.style.backgroundColor = '#f3f3f3';\n        progressBarContainer.style.position = 'fixed';\n        progressBarContainer.style.top = '0';\n        progressBarContainer.style.left = '0';\n        progressBarContainer.style.zIndex = '1000';\n\n        const progressBar = document.createElement('div');\n        progressBar.id = 'progress-bar';\n        progressBar.style.width = '0%';\n        progressBar.style.height = '30px';\n        progressBar.style.backgroundColor = '#4CAF50';\n        progressBar.style.textAlign = 'center';\n        progressBar.style.lineHeight = '30px';\n        progressBar.style.color = 'white';\n\n        progressBarContainer.appendChild(progressBar);\n        document.body.appendChild(progressBarContainer);\n    }",
            "main.js": "const ifcModels = [];\nconst baseScene = new ThreeScene();\nconst loader = new IfcManager(baseScene.scene, ifcModels);\n\n#Modify\nloader.setupProgressBar();"
        }
    },
    {
        "repo": "LogicPull",
        "content": "'LogicPull/lib/sockets.js'\n:/*  Copyright 2015 Chris Zieba <zieba.chris@gmail.com>\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU\n  Affero General Public License as published by the Free Software Foundation, either version 3 of the\n  License, or (at your option) any later version.\n  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE. See the GNU Affero General Public License for more details. You should have received a\n  copy of the GNU Affero General Public License along with this program. If not, see\n  <http://www.gnu.org/licenses/>.\n*/\n\nvar graphviz = require('graphviz'),\n  fs = require('fs'),\n  utils = require('./utils'),\n  sanitizor = require('../lib/validation/sanitizor'),\n  validator = require('../lib/validation/validator'),\n  interview = require('./interviews/interview'),\n  process = require('./interviews/process'),\n  helpers = require('./helpers'),\n  models = require('../models/models'),\n  // stores all the information about the client, including the variables in the interview, and sockets (1 or 2 depending if editing)\n  connected_clients = {};\n\n// the app parameter is used for retrieving vars via app.get()\nexports.listen = function (server, sessionStore, app) {\n  \"use strict\";\n\n  // Session middleware\n  var getSession = function(cookie, done) {\n    var parsed = utils.parseCookie(cookie);\n\n    if (!parsed) {\n      return done(new Error('Could not parse cookie'));\n    }\n\n    if (!parsed.hasOwnProperty('connect.sid')) {\n      return done(new Error('Missing cookie'));\n    }\n\n    var sessionID = parsed['connect.sid'].split('.')[0].substring(2);\n\n    sessionStore.get(sessionID, function (err, session) {\n      if (err || !session) {\n        return done(new Error('Session was not found'));\n      }\n\n      return done(null, session);\n    });\n  };\n\n  var opts = {\n    \"close timeout\": app.get('socket_close_timeout'),\n    \"log level\":  app.get('socket_log_level'),\n    \"match origin protocol\": app.get('socket_match_origin_protocol'),\n    \"sync disconnect on unload\": app.get('socket_sync_disconnect_on_unload'),\n    \"transports\": app.get('socket_transports'),\n    \"flash policy port\": app.get('socket_flash_policy_port')\n  };\n\n  if (app.get('socket_browser_client_minification')) {\n    opts['browser client minification'] = true;\n  }\n\n  if (app.get('socket_browser_client_etag')) {\n    opts['browser client etag'] = true; \n  }\n\n  if (app.get('socket_browser_client_gzip')) {\n    opts['browser client gzip'] = true;\n  }\n\n\n  var io = require('socket.io').listen(server);\n\n  // This is what runs on an incoming socket request\n  // If there is already a session established, accept the socket, otherwise deny it\n  io.set('authorization', function (data, accept) {\n    // Check if the person connecting is logged in. \n    // If they are, store there user is and check it again when they are trying to save the interview\n    if (data.headers.cookie) {\n      data.cookie = utils.parseCookie(data.headers.cookie);\n\n      if (data.cookie) {\n        if (data.cookie['connect.sid']) {\n          data.sessionID = data.cookie['connect.sid'].split('.')[0].substring(2);\n          // Create a new connection to the LogicPul database, so we can compare the _id field to the cookie sid field\n          // these must match in order for a connection to go through\n          sessionStore.get(data.sessionID, function (err, session) {\n            // these are urls we don't need to authorize a logged in user for the /interviews\n            var no_auth_required = new RegExp(app.get('base_url') + '/interviews/', 'g');\n\n            if (err || !session) {\n              // Don't accept the socket request if the user is not logged in\n              if (!no_auth_required.test(data.headers.referer)) {\n                // If we get here the URL is from inside the manager\n                return accept('Session not found in database', false);\n              }\n\n              console.log('   debug - ' + 'no socket authorization needed');\n              return accept(null, true);\n            }\n\n            // save the session data and accept the connection if the user is logged in\n            if (session.user && session.user.authenticated) {\n              data.session = session;\n              data.session.url = data.headers.referer;\n              return accept(null, true);\n            }\n\n            if (!no_auth_required.test(data.headers.referer)) {\n              return accept('User is not authenticated', false);\n            }\n\n            console.log('   debug - ' + 'no socket authorization needed');\n            return accept(null, true);                  \n          });                     \n        } else {\n          return accept('No cookie transmitted.', false);\n        }               \n      } else {\n        return accept('No cookie transmitted.', false);\n      }\n    } else {\n      return accept('No cookie transmitted.', false);\n    }\n  });\n\n  // Client is the socket\n  io.sockets.on('connection', function (client) {\n    // Keep track of all the connected_clients\n    var id = client.id;\n\n    // @type {string} kind of message..i.e question, error...\n    function emitData (id, type, data) {\n      connected_clients[id].socket.emit(type, data);\n\n      // if this socket has an editor id set, than check if any other socket shares that id, and send the data to that socket as well\n      if (connected_clients[id].editor) {\n        // go through each socket to see if we can get the editor socket\n        for (var socket_id in connected_clients) {\n          if (connected_clients.hasOwnProperty(socket_id)) {\n            // check that we are not checking the same socket\n            if (socket_id !== id) {\n              if (connected_clients[socket_id].editor) {\n                // check if they match\n                if (connected_clients[socket_id].editor === connected_clients[id].editor) {\n                  connected_clients[socket_id].socket.emit(type, data);\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // if the session is NOT already open, create the new object\n    if (!connected_clients.hasOwnProperty(client.id)) {\n      connected_clients[id] = {\n        editor:null,\n        socket: client,\n        data: {\n          interview: {},\n          //progress: [],\n          // this is a map of what each question is in terms of distance from the end\n          distance: {},\n          // master will now contain the variables from each question \n          master: {},\n          deliverables: {},\n          client: null\n        }\n      };\n    } \n\n    // after the editor client connects, send an id\n    client.on('editor_id', function (editor_id) {\n      connected_clients[id].editor = editor_id;\n    }); \n\n    // When the viewer starts\n    client.on('start', function (data) {\n      var run;\n      var progress;\n      var send_data;\n      var preview = data.preview;\n      var start = data.start;\n\n      getSession(client.handshake.headers.cookie, function(err, session) {\n        if (err) {\n          console.log(err);\n          throw err;\n        }\n\n        models.Interviews.findOne({id: data.interview_id}, function (err, doc) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n          \n          if (!doc) {\n            emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n            return;\n          }\n\n          var qid = doc.start;\n\n          models.Counters.findOne({}, function (err, counter) {\n            // Get the current count from the database and increment by to get the next interview\n            var tmp_count = counter.tmp_count + 1;\n            var state_id = counter.state_count + 1 + '-' + tmp_count;\n            var tmp_progress = [];\n            var tmp_history = [];\n            var tmp = new models.Tmps();\n            var state = new models.States();\n\n            // update the counter right away\n            models.Counters.update({\n              tmp_count: tmp_count,\n              state_count: counter.state_count + 1\n            }, function (err) {\n              if (err) {\n                console.log(err);\n                throw err;\n              } \n\n              // check if a value was passed as the start (preview)\n              if (start) {\n                // check to make sure the start passed is actually used in the interview\n                if (doc.data[start]) {\n                  qid = start;\n                }\n              }\n              \n              // initialize the progress\n              tmp_progress.push(state_id);\n\n              var startInterview = function(graph) {\n                // In case the window is closed while the graph is being generated\n                if (typeof connected_clients[id] === 'undefined' || !connected_clients[id].hasOwnProperty('data')) {\n                  return;\n                }\n\n                // Now we can use the distance object mapping to find how many questions are in front of the current one\n                var fraction = graph[qid] || '';\n\n                // Turn the start question of the interview, completing any before logic in the question\n                run = interview.start(qid, doc.data[qid], doc.data, {}, [], state_id); \n\n                // Build the history for the drop down menu\n                progress = interview.progress(run.progress); \n\n                // cache the graph data \n                connected_clients[id].data.distance = graph;\n\n                // the first question does not run helpers.merge, which adds the fields\n                connected_clients[id].data.master.fields = [];\n\n                // we don't need to rerun the helpers.merge function because any vars that are set at the beginning will be returned with run\n                // this is the master vars after all the logic is run, including the before logic of the question we are showing\n                connected_clients[id].data.master.vars = run.master;\n\n                connected_clients[id].data.interview = {\n                  id: doc.id,\n                  name: doc.name,\n                  description: doc.description\n                };\n\n                send_data = {\n                  // send the id (count) that corresponds to the database record of the tmp record, which corresponds to the save_id if we save\n                  id: tmp_count,\n                  qid: run.qid,\n                  data: {\n                    question: run.question, \n                    progress: progress,\n                    debug: run.debug,\n                    fraction: fraction\n                  },\n                  valid: true\n                };\n\n                // create the new database record for the interview being worked on\n                tmp.id = tmp_count;\n                // a reference to where the last state is\n                tmp.current = state_id;\n                tmp.history = run.progress;\n                tmp.created = new Date();\n                tmp.last_modified = new Date();\n                // the progress will record the state id after each question\n                tmp.progress = tmp_progress;\n\n                tmp.save(function(err) {\n                  if (err) {\n                    console.log(err);\n                    throw err;\n                  } \n\n                  // create a new state record \n                  state.id = state_id;\n                  state.tmp_id = tmp_count,\n                  state.created = new Date();\n                  state.last_modified = new Date();\n                  state.data = connected_clients[id].data;\n\n                  state.save(function(err) {\n                    if (err) {\n                      console.log(err);\n                      throw err;\n                    }\n\n                    // update the interview in the database to cache the distance graph, if NOT in preview mode\n                    if (!preview && doc.distance.update) {\n                      doc.distance = {\n                        update: false,\n                        graph: graph\n                      };\n\n                      doc.save(function () {\n                        if (err) {\n                          console.log(err);\n                          throw err;\n                        }\n                        emitData(id, 'question', send_data);\n                      });\n                    } else {\n                      emitData(id, 'question', send_data);\n                    }\n                  });\n\n                });\n              };\n\n              // check if grahpviz progress is disabled\n              if (app.get('disable_graphviz_progress')) {\n                startInterview({});\n              } else {\n                // we might not need to update the progress fraction if the interview has been modified\n                if (doc.distance.update) {\n                  interview.distance(doc.data, qid, startInterview);\n                } else {\n                  startInterview(doc.distance.graph);\n                }\n              }\n            });\n          });\n        });\n      });\n    });\n\n    // When the continue button on the viewer is clicked, or when back is clicked, or when the progress dropdown is changed\n    client.on('question', function (data) {\n      getSession(client.handshake.headers.cookie, function (err, session) {\n        if (!session) {\n          console.log(err);\n          throw err;\n        }\n\n        var loop;\n        var query;\n        var validate;\n        var send_data;\n        var run;\n        var next;\n        var progress;\n        var fraction;\n        var qid = data.qid;\n        var loop_index = null;\n        // this is the array of objects with the answers\n        var fields = data.fields;\n        var destination = data.destination;\n\n        //TODO: sanitize the inputs, not dry, don't query the database every time for this interview ... store the variable\n        models.Interviews.findOne({id: data.interview}, function (err, doc) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (!doc) {\n            emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n            return;\n          }\n\n          models.Tmps.findOne({id: data.id}, function (err, tmp) {\n            if (err) {\n              console.log(err);\n              throw err;\n            } \n\n            // look up the current state using the current id\n            models.States.findOne({id: tmp.current}, function (err, state) {\n              if (err) {\n                console.log(err);\n                throw err;\n              }\n\n              models.Counters.findOne({}, function (err, counter) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                } \n\n                var tmp_progress = tmp.progress;\n                var new_state = new models.States();\n                var new_state_id = counter.state_count + 1 + '-' + tmp.id;\n\n                // update the counter in the database\n                models.Counters.update({ state_count: counter.state_count + 1 }, function (err) {\n                  if (err) {\n                    console.log(err);\n                    throw err;\n                  } \n\n                  // Save the database interview information to the clients socket object\n                  connected_clients[id].data = state.data;\n\n                  // The validate function will evaluate the answers sent when the user clicks next.\n                  // Pass the answers, and the fields for this question...so we can compare to the validation object.\n                  // Validation will return either true, or false and an error message.\n                  validate = interview.validate(fields, doc.data[qid], connected_clients[id].data.master.vars, doc.data);\n\n                  // check all the fields for their validation \n                  if (validate.error) {\n                    // prepare the error data for the client\n                    send_data = {\n                      id: tmp.id,\n                      qid: null,\n                      // this is an object with the error message, name of the field that caused the error and a truth value\n                      data: validate,\n                      valid: false\n                    };\n\n                    emitData(id, 'question', send_data);\n                  } else {\n\n                    if (err) {\n                      console.log(err);\n                      throw err;\n                    } \n\n                    // This tests to see of the loop variable is set in the question, activating the loop.\n                    // When a question is in a loop, its answers are stored differently.\n                    loop = (doc.data[qid].loop1 !== null && typeof doc.data[qid].loop1 !== 'undefined' && doc.data[qid].loop1 !== '') ? true : false;\n\n                    connected_clients[id].data.master.fields = fields;\n\n                    // We need to get the loop_index before the fields are merged into the master set\n                    if (loop) {\n                      for (var prop1 in connected_clients[id].data.master.vars) {\n                        if (connected_clients[id].data.master.vars.hasOwnProperty(prop1)) {\n                          if (connected_clients[id].data.master.vars[prop1].loop) {\n                            if (connected_clients[id].data.master.vars[prop1].qid === qid) {\n                              if (Array.isArray(connected_clients[id].data.master.vars[prop1].values[prop1])) {\n                                loop_index = connected_clients[id].data.master.vars[prop1].values[prop1].length;\n                                break;\n                              }\n                            }\n                          }\n                        }\n                      }\n                      // set the loop index to 0 if it wasnt set since its in a loop\n                      if (loop_index === null) {\n                        loop_index = 0;\n                      }\n                    }\n\n                    // merge the variables into the master set\n                    connected_clients[id].data.master.vars = helpers.merge(connected_clients[id].data.master.vars, fields, loop, doc.data[qid]);\n\n                    // get the before_logic\n                    next = interview.next(qid, doc.data[qid], doc.data, connected_clients[id].data.master.vars, fields, tmp.history, new_state_id, destination);\n\n                    // check if the next question is in a loop\n                    var next_loop = (doc.data[next.qid].loop1 !== null && typeof doc.data[next.qid].loop1 !== 'undefined' && doc.data[next.qid].loop1 !== '') ? true : false;\n\n                    // we need to get the loop length so\n                    // we can get the correct state based on the loop index, which will\n                    // be incremented and saved in the state when it's saved\n                    if (next_loop) {\n                      var next_loop_index = null;\n                      for (var prop2 in connected_clients[id].data.master.vars) {\n                        if (connected_clients[id].data.master.vars.hasOwnProperty(prop2)) {\n                          if (connected_clients[id].data.master.vars[prop2].loop) {\n                            if (connected_clients[id].data.master.vars[prop2].qid === next.qid) {\n                              if (Array.isArray(connected_clients[id].data.master.vars[prop2].values[prop2])) {\n                                next_loop_index = connected_clients[id].data.master.vars[prop2].values[prop2].length;\n                                break;\n                              }\n                            }\n                          }\n                        }\n                      }\n\n                      // set the loop index to 0 if it wasnt set since its in a loop\n                      if (next_loop_index === null) {\n                        next_loop_index = 0;\n                      }\n                    \n                      query = {\n                        tmp_id: tmp.id, \n                        base_qid: next.qid,\n                        loop_id: next_loop_index\n                      };\n                    } else {\n                      query = {\n                        tmp_id: tmp.id, \n                        base_qid: next.qid\n                      };\n                    }\n\n                    // Look for any states that have run this question already\n                    models.States.find(query).sort({created: 1}).exec(function (err, states) {\n                      // Build the queston using any previously answered questions\n                      run = interview.build(next, doc.data, fields, tmp.history, new_state_id, states);\n\n                      // build the history for the progress bar\n                      progress = interview.progress(run.progress); \n\n                      // find out the fractional progress of the interview\n                      fraction = (connected_clients[id].data.distance && connected_clients[id].data.distance.hasOwnProperty(run.qid)) ? connected_clients[id].data.distance[run.qid] : '';\n\n                      // update master vars list, since new answers could be created in the logic\n                      connected_clients[id].data.master.vars = run.master; \n\n                      // This is the data that gets sent back to the client. \n                      // It involves the HTML of the question to show the user,\n                      // and debug info for the editor (if edit mode)\n                      send_data = {\n                        id: tmp.id,\n                        qid: run.qid,\n                        data: {\n                          question: run.question, \n                          progress: progress,\n                          debug: run.debug,\n                          fraction: fraction\n                        },\n                        valid: true\n                      };  \n\n                      // create a new state record \n                      new_state.id = new_state_id;\n                      new_state.tmp_id = tmp.id;\n                      new_state.loop_id = loop_index;\n                      new_state.base_qid = qid;\n                      new_state.created = new Date();\n                      new_state.last_modified = new Date();\n                      new_state.data = connected_clients[id].data;\n                      \n                      new_state.save(function(err) {\n                        if (err) {\n                          console.log(err);\n                          throw err;\n                        } \n\n                        tmp_progress.push(new_state_id);\n\n                        // update the interview data in the database corresponding the socket ID\n                        models.Tmps.update({id:tmp.id}, {current: new_state_id, progress: tmp_progress, history: run.progress, last_modified: new Date().getTime()}, function (err) {\n                          if (err) {\n                            console.log(err);\n                            throw err;\n                          } \n\n                          // send the data back to the client\n                          emitData(id, 'question', send_data);\n                        }); \n                      });\n                    });\n                  }\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n\n    // When back is clicked, or when the progress dropdown is changed\n    client.on('back', function (data) {\n      getSession(client.handshake.headers.cookie, function (err, session) {\n        if (!session) {\n          console.log(err);\n          throw err;\n        }\n\n        models.Interviews.findOne({ id: data.interview }, function (err, doc) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (!doc) {\n            emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n            return;\n          }\n\n          var send_data, back, history, fraction;\n\n          // Look up the data for the users interview from the database\n          models.Tmps.findOne({ id: data.id }, function (err, tmp) {\n            if (err) {\n              console.log(err);\n              throw err;\n            }\n\n            if (!tmp) {\n              emitData(id, 'srv_error', { id: null, error: interview.error(\"A record could not be found for this interview.\").error.content, valid: false });\n              return;\n            }\n\n            var tmp_progress = tmp.progress;\n            var tmp_history = tmp.history;\n\n            // get the updated history and the id of the state we want to load\n            history = interview.history(tmp_progress, tmp_history, data.backid, data.previd);\n\n            tmp_progress = history.progress;\n            tmp_history = history.history;\n\n            // We need two states since the latest has the fields to repopulate, and the second has the state we want to revert to\n            models.States.find({id: { $in: [history.new_current_state, history.removed_state]} }).sort({id: -1}).exec(function (err, states) {\n              if (err) {\n                console.log(err);\n                throw err;\n              } \n              // this will be set to the current state\n              var new_current_state = states[1];\n\n              // use the fields from this state to repopulate\n              var removed_state = states[0];\n\n              back = interview.back(doc.data, new_current_state.data.master.vars, removed_state.data.master.fields, history.qid);\n\n              // find out the fractional progress of the interview      \n              fraction = (connected_clients[id].data.distance && connected_clients[id].data.distance.hasOwnProperty(back.qid)) ? connected_clients[id].data.distance[back.qid] : '';\n\n              send_data = {\n                id: tmp.id,\n                qid: back.qid,\n                data: {\n                  question: back.question, \n                  progress: interview.progress(tmp_history),\n                  debug: back.debug,\n                  fraction: fraction\n                },\n                valid: true\n              };    \n\n              //update the interview data in the database corresponding the socket ID\n              models.Tmps.update({id:tmp.id}, {current: new_current_state.id, progress: tmp_progress, history: tmp_history, last_modified: new Date().getTime()}, function (err) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                } \n                // send the data back to the client\n                emitData(id, 'question', send_data);\n              }); \n            });\n          });\n        });\n      });\n    });\n\n    // This is for the editor..not the viewer\n    client.on('save', function (data) {\n      getSession(client.handshake.headers.cookie, function (err, session) {\n        if (err || !session) {\n          console.log(err);\n          throw err;\n        }\n\n        var save = false;\n\n        // If theres a session here (not null) than the user is logged in while connecting to a socket\n        if (session.user) {\n          if (session.user.privledges.editor_save) {\n            save = true;\n          }\n        }\n\n        // only save to the database if the user has privledges\n        if (save) {\n          //TODO: sanitize the inputs\n          models.Interviews.findOne({ id: data.id }, function (err, doc) {\n            if (err) {\n              console.log(err);\n              throw err;\n            } \n\n            if (!doc) {\n              emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n              return;\n            }\n\n            doc.description = data.settings.description;\n            doc.steps = data.settings.steps;\n            doc.start = data.settings.start;\n            doc.data = data.data;\n            doc.distance = {\n              update: true,\n              graph: {}\n            };\n            doc.save();\n            connected_clients[id].socket.emit('saved', true);\n            \n          });\n        } else {\n          connected_clients[id].socket.emit('saved', false);\n        }\n      });\n    });\n\n    // when a client clicks the button to reorder the graph this fires\n    // TODO send this only to the client that is the editor\n    client.on('graph', function (data) {\n      if (app.get('disable_graphviz_tidy')) {\n        emitData(id, 'graph', {});\n      } else {\n        var g = graphviz.digraph(\"G\");\n        var options = {\n          type: \"dot\",\n          G: {\n            splines: false,\n            rankdir: \"BT\",\n            nodesep: \"0.2\"\n          }\n        };\n\n        // this creates the initial dot file to be rendered\n        for (var prop in data.nodes) {\n          if (data.nodes.hasOwnProperty(prop)) {\n            g.addNode(prop);\n            if (data.nodes[prop]) {\n              for (var i = 0; i < data.nodes[prop].length; i+=1) {\n                g.addEdge(prop, data.nodes[prop][i]);\n              }                   \n            }                   \n          }\n        }\n\n        // this takes the dote graph generated above and creates a dot file with all the postions\n        g.output(options, function (out) { \n          var dot = out.toString('utf-8');\n          var regex = /(q\\d+)\\s\\[pos=\"(\\d+),(\\d+)\",/gmi;\n          var graph = {};\n          var match;\n\n          while ((match = regex.exec(dot)) !== null) {\n            graph[match[1].toString()] = {\n              x: parseInt(match[2],10),\n              y: parseInt(match[3],10)\n            };\n          }\n\n          emitData(id, 'graph', graph);               \n        });\n      }\n    });\n\n    // This gets called when the save button in the viewer is clicked. \n    // We need the name and note (if any) to populate the text area on the save pop up\n    client.on('get_saved_note', function (data) {\n      //sanitize all the data sent over\n      var clean_id = sanitizor.clean(data.id.toString());\n\n      // look to see if there is already a saved interview with the same ID being sent from the client\n      models.Saves.findOne({ id: clean_id }).exec(function (err, doc) {\n        if (err) {\n          console.log(err);\n          throw err;\n        } \n\n        // Set the defaults\n        var name = \"\";\n        var note = \"\";\n\n        if (doc) {\n          name = doc.name;\n          note = doc.note;\n        } \n\n        // Let the user know there was an error\n        emitData(id, 'insert_saved_note', { name: name, note: note }); \n      });\n    });\n\n    // When the client clicks the save button.\n    // If we get here that mean the user is logged in (this is checked via Ajax in viewer.js)\n    client.on('save_progress', function (data) {\n      // Sanitize all the data sent over\n      var clean_id = sanitizor.clean(data.id.toString());\n      var clean_qid = sanitizor.clean(data.qid);\n      var clean_name = sanitizor.clean(data.name).substring(0,100);\n      var clean_note = sanitizor.clean(data.note).substring(0,500);\n      var clean_interview = sanitizor.clean(data.interview);\n\n      // The fields are used to prepopulate the question the interview was saved on\n      var fields = data.fields; \n\n      // Check if a user is logged in , there will be a sessionID from the database saved form them\n      if (client.handshake.headers.cookie) {\n        // revalidates that the user is still logged in, since we only checked when the socket connected\n        getSession(client.handshake.headers.cookie, function (err, session) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (session && session.user) {\n            // look up the data for the users interview from the database\n            models.Tmps.findOne({ id: clean_id }, function (err, tmp) {\n              if (err) {\n                console.log(err);\n                throw err;\n              }\n\n              // Look up the current state\n              models.States.findOne({id: tmp.current }, function (err, state) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                } \n\n                // if we get here the user is still logged in and we can get all their saved interviews\n                // look to see if there is already a saved interview with the same ID being sent from the client\n                models.Saves.findOne({ id: clean_id }, function (err, doc) {\n                  if (err) {\n                    // let the user know there was an error\n                    emitData(id, 'saved_progress', { valid:false }); \n                    return;\n                  }\n\n                  // If doc is not empty than there is already a record saved for that interview\n                  if (doc) {\n                    // update\n                    models.Saves.update({ id:clean_id }, {\n                      data: {\n                        current: tmp.current,\n                        history: tmp.history,\n                        progress: tmp.progress,\n                        state: state.data,\n                        fields: fields\n                      }, \n                      qid: clean_qid,\n                      name: clean_name,\n                      note: clean_note,\n                      last_modified: new Date()\n                    }, function (err) {\n                      if (err) {\n                        console.log(err);\n                        throw err;\n                      } \n                      emitData(id, 'saved_progress', {valid:true}); \n                    }); \n                  } else {\n                    var save = new models.Saves();\n                    // The tmp id gets incremented every time an interview is started so we don't have to worry about collisions\n                    save.id = tmp.id;\n                    save.user_id = session.user.id;\n                    save.interview_id = clean_interview;\n                    save.qid = clean_qid;\n                    save.socket_id = id;\n                    save.name = clean_name;\n                    save.note = clean_note;\n                    save.interview = connected_clients[id].data.interview;\n                    save.created = new Date();\n                    save.last_modified = new Date();\n                    save.data = {\n                      current: tmp.current,\n                      history: tmp.history,\n                      progress: tmp.progress,\n                      state: state.data,\n                      fields: fields\n                    };\n\n                    save.save(function(err) {\n                      if (err) {\n                        console.log(err);\n                        throw err;\n                      } \n\n                      emitData(id, 'saved_progress', {valid:true}); \n                    });\n                  }\n                });\n              });\n            });\n          } else {\n            emitData(id, 'saved_progress', {valid:false}); \n          }\n        });\n      } else {\n        // the user is not logged in and we can ask them to login first\n        emitData(id, 'saved_progress', {valid:false}); \n      }\n    }); \n\n    // when the client clicks the open button on the viewer\n    client.on('open_saves', function (data) {\n      // check if a user is logged in ,there will be a sessionID from the database saved for them\n      if (client.handshake.headers.cookie) {\n        // revalidate that the user is still logged in, since we only checked when the socket connected\n        getSession(client.handshake.headers.cookie, function (err, session) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (session && session.user) {\n            // if we get here the user is still logged in and we can get all their saved interviews\n            // look up the saved progress and attach the user name to the database record\n            // now we can add the users name to the record in the database for later retrieval\n            models.Saves.find({}).where('user_id').equals(session.user.id).where('interview_id').equals(data.interview).sort('-created').exec(function(err, saves) {\n              if (err) {\n                console.log(err);\n                throw err;\n              }\n\n              var admin = session.user.privledges && session.user.privledges.view_saved_interviews;\n\n              // send back all the saved interviews for the particular interview, corresponding to that user\n              emitData(id, 'open_saved', {\n                valid: true,\n                data: interview.saves(saves, admin)\n              });\n            });\n          } else {\n            emitData(id, 'open_saved', { valid:false }); \n          }\n        });\n      } else {\n        // the user is not logged in and we can ask them to login first\n        emitData(id, 'open_saved', { valid:false }); \n      }\n    }); \n\n    // When the client clicks the open button on the viewer\n    client.on('load_saved', function (data) {\n      // First, we need to get the id from the data which is sent in the format \"partial-55\"\n      var full_partial_id = data.partial_id;\n      var partial_id = full_partial_id.split('-')[1];\n\n      // Now we have the id of the partial interview we want to load into the viewer\n      models.Saves.findOne({}).where('id').equals(partial_id).exec(function(err, partial) {\n        if (err) {\n          console.log(err);\n          throw err;\n        } \n\n        if (partial) {\n          // Get the interview \n          models.Interviews.findOne({id: partial.interview_id}, function (err, doc) {\n            if (err) {\n              console.log(err);\n              throw err;\n            } \n\n            models.Counters.findOne({}, function (err, counter) {\n              var tmp = new models.Tmps();\n              var tmp_count = counter.tmp_count + 1;\n\n              // update the counter in the database\n              models.Counters.update({tmp_count: tmp_count}, function (err) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                } \n\n                var run = interview.load(doc.data[partial.qid], doc.data, partial.data.state.master.vars); \n                var send_data = {\n                  // send the id (count) that corresponds to the database record of the tmp record, which corresponds to the save_id if we save\n                  id: tmp_count,\n                  qid: partial.qid,\n                  data: {\n                    question: run.question, \n                    progress: interview.progress(partial.data.history),\n                    // there is no debug info...you cant load a partial interview when in preview mode, i.e. the editor\n                    debug: null,\n                    fraction: (partial.data.state.distance.hasOwnProperty(partial.qid)) ? partial.data.state.distance[partial.qid] : '',\n                    fields: (partial.data.hasOwnProperty('fields')) ? partial.data.fields : null\n                  },\n                  valid: true,\n                  partial:true\n                };\n\n                // Create the new database record for the interview being worked on\n                tmp.id = tmp_count;\n                tmp.history = [];\n                tmp.created = new Date();\n                tmp.last_modified = new Date();\n                // the progress will record the state id after each question\n                tmp.progress = [];\n\n                // Load in new states for answer pre-population\n                models.States.find({id: {$in: partial.data.progress }}, function (err, states) {\n                  if (err) {\n                    console.log(err);\n                    throw err;\n                  }\n\n                  var state_map = {};\n\n                  // Create new duplicate states with the new tmp_id\n                  for (var i = 0; i < states.length; i+=1) {\n                    var state = new models.States();\n                    state.id = counter.state_count + i + 1 + '-' + tmp.id;\n                    state.tmp_id = tmp.id;\n                    state.loop_id = states[i].loop_id;\n                    state.base_qid = states[i].base_qid;\n                    state.created = new Date();\n                    state.last_modified = new Date();\n                    state.data = states[i].data;\n                    state.save();\n\n                    if (states[i].id === partial.data.current) {\n                      tmp.current = state.id;\n                    }\n\n                    // record the new state as the progress\n                    tmp.progress.push(state.id);\n\n                    state_map[states[i].id] = state.id;\n                  }\n\n                  for (var j = 0; j < partial.data.history.length; j+=1) {\n                    partial.data.history[j].state = state_map[partial.data.history[j].state];\n                    tmp.history.push(partial.data.history[j]);\n                  }\n\n                  tmp.save(function (err) {\n                    if (err) {\n                      console.log(err);\n                      throw err;\n                    }\n\n                    var state_count = counter.state_count + states.length + 1;\n\n                    // update the counter in the database\n                    models.Counters.update({state_count: state_count}, function (err) {\n                      if (err) {\n                        console.log(err);\n                        throw err;\n                      }\n                      emitData(id, 'question', send_data);\n                    });\n                  });\n                });\n              });\n            });\n          });\n        } else {\n          // for some reason we could not find the partial interview we are trying to load\n          console.log('The saved record was not found when trying to load a saved interview.');\n          throw err;\n        }\n      });\n    }); \n\n    // When the client clicks the open button on the viewer\n    client.on('process_saved', function (data) {\n      if (client.handshake.headers.cookie) {\n        // revalidate that the user is still logged in, since we only checked when the socket connected\n        getSession(client.handshake.headers.cookie, function (err, session) {\n          if (err) {\n            console.log(err);\n            throw err;\n          }\n\n          var full_partial_id = data.partial_id;\n          var partial_id = full_partial_id.split('-')[2];\n\n          models.Saves.findOne({}).where('id').equals(partial_id).exec(function(err, save) {\n            if (err) {\n              return console.log(err);\n            } \n\n            if (!save) {\n              console.log('The saved record was not found when trying to load a saved interview.');\n              return;\n            }\n\n            // Get the interview \n            models.Interviews.findOne({id: save.interview_id}, function (err, doc) {\n              if (err) {\n                console.log(err);\n                return;\n              } \n\n              if (!doc) {\n                console.log('The interview could not be found.');\n                return;\n              }\n\n              // Process the saved interview as if it were completed\n              process.output(doc, save.data.state.master.vars, save.data.history, app.get('base_location'), app, session.user.id, function (err, data) {\n                if (err) {\n                  console.log(err);\n                  emitData(id, 'process_saved', { valid: false });\n                } else {\n                  var client = {\n                    full: session.user.name\n                  };\n\n                  process.email(null, doc.name, app.get('base_location'), doc, doc.on_complete, doc.deliverables, client, app, function (err, response) {\n                    if (err) {\n                      console.log(err);\n                      emitData(id, 'process_saved', { valid: false });\n                    } else {\n                      emitData(id, 'process_saved', { valid: true });\n                    }\n                  });\n                }\n              });\n            });\n          });\n        });\n      }\n    }); \n\n    // when a finish button is clicked in the interview\n    client.on('finish', function (data) {\n      var validate, emit, deliverables, run, progress, on_complete, send_data;\n      var base_location = app.get('base_location');\n      // this is the array of objects with the answers\n      var fields = data.fields;\n      var qid = data.qid;\n\n      //TODO: sanitize the inputs, not dry, don't query the database every time for this interview ... store the variable\n      models.Interviews.findOne({ id: data.interview }, function (err, doc) {\n        if (err) {\n          console.log(err);\n          throw err;\n        } \n\n        if (!doc) {\n          emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n          return;\n        }\n\n        models.Tmps.findOne({ id: data.id }, function (err, tmp) {\n          if (err) {\n            console.log(err);\n            throw err;\n          }\n\n          // look up the current state using the current id\n          models.States.findOne({id: tmp.current }, function (err, state) {\n            if (err) {\n              console.log(err);\n              throw err;\n            } \n\n            models.Counters.findOne({}, function (err, counter) {\n              if (err) {\n                console.log(err);\n                throw err;\n              } \n\n              // update the counter in the database\n              models.Counters.update({state_count: counter.state_count + 1}, function (err) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                }\n\n                var tmp_progress = tmp.progress;\n                var tmp_history = tmp.history;\n                var new_state = new models.States();\n                var new_state_id = counter.state_count + 1 + '-' + tmp.id;\n\n                // save the database interview information to the clients socket object\n                connected_clients[id].data = state.data;\n\n                // the validate function will evaluate the answers sent when the user clicks next\n                // pass the answers, and the fields for this question...so we can compare to the validation object\n                // validate will return either true, or false and an error message\n                validate = interview.validate(fields, doc.data[qid], connected_clients[id].data.master.vars, doc.data);\n\n                // check all the fields for their validation \n                if (validate.error) {\n                  // send the error back to the client\n                  send_data = {\n                    id: tmp.id,\n                    qid: null,\n                    data: validate,\n                    valid: false\n                  };\n                  // inform the client of whats happening\n                  emitData(id, 'question', send_data);\n\n                } else {\n                  var loop = (doc.data[qid].loop1 !== null && typeof doc.data[qid].loop1 !== 'undefined' && doc.data[qid].loop1 !== '') ? true : false;\n\n                  connected_clients[id].data.master.fields = fields;\n                  connected_clients[id].data.master.vars = helpers.merge(connected_clients[id].data.master.vars, fields, loop, doc.data[qid]);\n\n                  // this has all the info for what to do when the finish button is completed\n                  on_complete = doc.on_complete;\n                  deliverables = doc.deliverables;\n\n                  // handle all the deliverables, if there are any\n                  // TODO add a default deliverable! NOTHING HAPPENS WHEN there are no deliverables\n                  if (deliverables.length !== 0) {\n\n                    // This callback gets fired when all the deliverables have been created. It is passed into the process,output function\n                    var callback = function (err, data) {\n                      if (err) {\n                        // if any stylesheet was not procure send back some error to the client\n                        console.log(err);\n                        send_data = {\n                          id: tmp.id,\n                          error: interview.error(err).error.content,\n                          valid: false\n                        };  \n\n                        emitData(id, 'srv_error', send_data);   \n                      } else {\n                        // now we have the folder where all the stores deliverables \n                        connected_clients[id].data.deliverables = data.dir;\n                        // store the client info onto the master object\n                        connected_clients[id].data.client = data.client;\n\n                        // check to see if we want to allow the client to receive the deliverables via email\n                        // if this is true we send a question to the client asking for an email\n                        if (on_complete.email_deliverables_to_client) {\n\n                          // create the final question of the interview, asking for an email\n                          run = interview.final(qid, doc.data[qid], doc.data, connected_clients[id].data.master.vars, fields, tmp_progress, deliverables);\n\n                          // build the history \n                          progress = interview.progress(tmp_history); \n                          // update master vars list\n                          connected_clients[id].data.master.vars = run.master; \n                          connected_clients[id].data.progress = run.progress;\n\n                          // this is the data that gets sent back to the client. It involves the HTML of the question to \n                          // show the user, and debug info for the editor (if edit mode)\n                          send_data = {\n                            id: tmp.id,\n                            qid: run.qid,\n                            data: {\n                              question: run.question, \n                              progress: progress,\n                              debug: run.debug\n                            },\n                            valid: true\n                          };\n\n                          emitData(id, 'question', send_data);\n                        } else {\n                          // just handle the emails and output the done question\n                          // base_location - this is the server base so we can find out where to put the zip\n                          // on_complete - this is the settings for what to do at the end\n                          // the first null is the email of the client\n                          process.email(null, doc.name, base_location, connected_clients[id].data, on_complete, deliverables, data.client, app, function (err, response) {\n                            if (err) {\n                              // if there was any problems with emails, or zipping folders\n                              console.log(err);\n                              emit = 'srv_error';\n                              send_data = {\n                                id: null,\n                                error: interview.error(err).error.content,\n                                valid: false\n                              };  \n                              emitData(id, emit, send_data);   \n                            } else {\n                              // this will put together the final success question after everything is done\n                              run = interview.done();\n                              emit = 'question';\n                              send_data = {\n                                id: null,\n                                qid: null,\n                                data: {\n                                  question: run.question, \n                                  progress: run.progress,\n                                  debug: run.debug\n                                },\n                                valid: true\n                              };                                                  \n\n                              // create a new state record \n                              new_state.id = new_state_id;\n                              new_state.created = new Date();\n                              new_state.last_modified = new Date();\n                              new_state.data = connected_clients[id].data;\n\n                              new_state.save(function(err) {\n                                if (err) {\n                                  console.log(err);\n                                  throw err;\n                                } \n\n                                tmp_progress.push(new_state_id);\n\n                                // Update the interview data\n                                models.Tmps.update({id:tmp.id}, {current: new_state_id, progress: tmp_progress, history: run.progress, last_modified: new Date().getTime()}, function (err) {\n                                  if (err) {\n                                    console.log(err);\n                                    throw err;\n                                  } \n                                  // inform the client of whats happening...either the docs were produced or there was an error\n                                  emitData(id, emit, send_data);\n                                }); \n                              });\n                            }\n                          });\n                        }\n                      }\n                    };\n\n                    if (client.handshake.sessionID) {\n                      // check if the user is logged in\n                      sessionStore.get(client.handshake.sessionID, function (err, session) {\n                        if (err) {\n                          console.log(err);\n                          throw err;\n                        } \n\n                        if (session && session.user) {\n                          process.output(doc, connected_clients[id].data.master.vars, tmp_history, base_location, app, session.user.id, callback);\n                        }\n                      });\n                    } else {\n                      // An unregistered user is completing the interview\n                      process.output(doc, connected_clients[id].data.master.vars, tmp_history, base_location, app, null, callback);\n                    }\n                  } else {\n                    send_data = {\n                      id: null,\n                      error: interview.error(\"The interview does not have any deliverables.\").error.content,\n                      valid: false\n                    };  \n                    emitData(id, 'srv_error', send_data);\n                  }\n                }\n              });\n            });\n          });\n        });\n      });\n    });\n\n    // When the user clicks the send button at the very end, this is the very last button\n    client.on('send', function (data) { \n      var email = sanitizor.clean(data.email); \n      var base_location = app.get('base_location');\n      var path = connected_clients[id].data.deliverables;\n      var send_data;\n\n      // If no email is entered or the format is not an email send them back\n      if (validator.check(email, ['required','email']) ) {\n        //If the email is valid we can email the user the deliverables\n        models.Interviews.findOne({ id: data.interview }, function (err, doc) {\n          var emit, run;\n          var on_complete = doc.on_complete;\n          var deliverables = doc.deliverables;\n\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (!doc) {\n            emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n            return;\n          }\n\n          // Send out all the emails and finish up\n          process.email(email, doc.name, base_location, connected_clients[id].data, on_complete, deliverables, connected_clients[id].data.client, app, function (err, response) {\n            if (err) {\n              // If there was any problems with emails, or zipping folders\n              console.log(err);\n              emit = 'srv_error';\n              send_data = {\n                id: null,\n                error: interview.error(err).error.content,\n                valid: false\n              };  \n            } else {\n              // This will put together the final success question after everything is done\n              run = interview.done();\n              emit = 'question';\n\n              send_data = {\n                id: null,\n                qid: null,\n                data: {\n                  question: run.question, \n                  progress: run.progress,\n                  debug: run.debug\n                },\n                valid: true\n              };                                                  \n            }\n            // Inform the client of whats happening. Either the docs were produced or there was an error.\n            emitData(id, emit, send_data);\n          });\n        });\n      } else {\n        send_data = {\n          id: null,\n          qid: null,\n          data: { \n            error: true, \n            message: 'The email is required and must be valid.', \n            name: 'q-final'\n          },\n          valid: false\n        };                 \n        emitData(id, 'question', send_data);            \n      }\n    });\n\n    // When a client disconnects from the viewer, or editor\n    client.on('disconnect', function () {\n      if (connected_clients[id]) {\n        delete connected_clients[id];\n        console.log('   debug - ' + 'client ' + client.id + 'is disconnected');\n        console.log('   debug - ' + 'total number of connected clients is ' + Object.keys(connected_clients).length);               \n      }\n    });\n  });\n\n  return io;\n};\n'LogicPull/LogicPull.js'\n:/*  Copyright 2015 Chris Zieba\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU\n  Affero General Public License as published by the Free Software Foundation, either version 3 of the\n  License, or (at your option) any later version.\n  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE. See the GNU Affero General Public License for more details. You should have received a\n  copy of the GNU Affero General Public License along with this program. If not, see\n  <http://www.gnu.org/licenses/>.\n*/\n\nvar express = require('express'),\n  app = module.exports = express(),\n  MongoStore = require('connect-mongo')(express),\n  server = require('http').createServer(app),\n  fs = require('fs'),\n  socket = require('./lib/sockets'),\n  flash = require('./middleware/flash'),\n  version = require('./package.json').version,\n  config = require('./config');\n\n\n// Set the development variables\napp.configure('development', function () {\n  app.use(express.errorHandler({ dumpExceptions: true, showStack: true })); \n\n  // Add in all the config settings\n  for(var setting in config.development) {\n    app.set(setting, config.development[setting]);\n  }\n});\n\n// Set the production variables\napp.configure('production', function () {\n  app.use(express.errorHandler()); \n\n  for(var setting in config.production) {\n    app.set(setting, config.production[setting]);\n  }\n});\n\n// set up the sessions to use the mongo database\nvar sessionStore = new MongoStore({\n  url: 'mongodb://' + app.get('mongo_host') + ':' + app.get('mongo_port') + '/' + app.get('mongo_db'),\n  autoReconnect: true\n});\n\n// these settings are common to both environments\napp.configure(function () {\n  app.use(express.favicon(__dirname + '/public/favicon.ico'));\n  app.engine('.html', require('ejs').__express);\n  app.set('views', __dirname + '/views/site');\n  // Without this you would need to supply the extension to res.render()\n  app.set('view engine', 'ejs');\n  // used in CSS and JavaScript as query string\n  app.set('version', version);\n\n  app.use(express.cookieParser());\n  app.use(express.bodyParser());\n  app.use(express.methodOverride());\n  \n  // This attaches the session to the req object\n  app.use(express.session({\n    store: sessionStore,\n    secret: app.get('session_secret'),\n    cookie: {  \n      path: app.get('cookie_path'),  \n      httpOnly: app.get('cookie_http_only'),  \n      maxAge: app.get('cookie_max_age'),\n      secure: app.get('cookie_secure'),\n      domain: app.get('base_vhost')\n    }\n  }));\n  \n  app.use(express.csrf());\n\n  // Generate a token for the form...the form input must be created\n  app.use(function(req, res, next) {\n    res.locals.token = req.csrfToken();\n    next();\n  });\n\n\n  app.use(flash());\n  app.use(app.router);\n  app.use(express.vhost(app.get('base_vhost'), require('./subdomains/LogicPull')));\n\n});\n\n// run the server with websockets\nserver.listen(app.get('server_port'));\nsocket.listen(server, sessionStore, app);\n",
        "called_code_segment": "client.on('save', function (data) {\n  getSession(client.handshake.headers.cookie, function (err, session) {\n    if (err || !session) {\n      console.log(err);\n      throw err;\n    }\n\n    var save = false;\n\n    // If theres a session here (not null) than the user is logged in while connecting to a socket\n    if (session.user) {\n      if (session.user.privledges.editor_save) {\n        save = true;\n      }\n    }\n\n    // only save to the database if the user has privledges\n    if (save) {\n      //TODO: sanitize the inputs\n      models.Interviews.findOne({ id: data.id }, function (err, doc) {\n        if (err) {\n          console.log(err);\n          throw err;\n        } \n\n        if (!doc) {\n          emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n          return;\n        }\n\n        doc.description = data.settings.description;\n        doc.steps = data.settings.steps;\n        doc.start = data.settings.start;\n        doc.data = data.data;\n        doc.distance = {\n          update: true,\n          graph: {}\n        };\n        doc.save();\n        connected_clients[id].socket.emit('saved', true);\n        \n      });\n    } else {\n      connected_clients[id].socket.emit('saved', false);\n    }\n  });\n});",
        "invoking_code_segment": "var io = require('socket.io').listen(server);\n\n// This is what runs on an incoming socket request\n// If there is already a session established, accept the socket, otherwise deny it\nio.set('authorization', function (data, accept) {\n  // Check if the person connecting is logged in. \n  // If they are, store there user is and check it again when they are trying to save the interview\n  if (data.headers.cookie) {\n    data.cookie = utils.parseCookie(data.headers.cookie);\n\n    if (data.cookie) {\n      if (data.cookie['connect.sid']) {\n        data.sessionID = data.cookie['connect.sid'].split('.')[0].substring(2);\n        // Create a new connection to the LogicPul database, so we can compare the _id field to the cookie sid field\n        // these must match in order for a connection to go through\n        sessionStore.get(data.sessionID, function (err, session) {\n          // these are urls we don't need to authorize a logged in user for the /interviews\n          var no_auth_required = new RegExp(app.get('base_url') + '/interviews/', 'g');\n\n          if (err || !session) {\n            // Don't accept the socket request if the user is not logged in\n            if (!no_auth_required.test(data.headers.referer)) {\n              // If we get here the URL is from inside the manager\n              return accept('Session not found in database', false);\n            }\n\n            console.log('   debug - ' + 'no socket authorization needed');\n            return accept(null, true);\n          }\n\n          // save the session data and accept the connection if the user is logged in\n          if (session.user && session.user.authenticated) {\n            data.session = session;\n            data.session.url = data.headers.referer;\n            return accept(null, true);\n          }\n\n          if (!no_auth_required.test(data.headers.referer)) {\n            return accept('User is not authenticated', false);\n          }\n\n          console.log('   debug - ' + 'no socket authorization needed');\n          return accept(null, true);                  \n        });                     \n      } else {\n        return accept('No cookie transmitted.', false);\n      }               \n    } else {\n      return accept('No cookie transmitted.', false);\n    }\n  } else {\n    return accept('No cookie transmitted.', false);\n  }\n});",
        "feature_description": "Add a feature to log the time when an interview is saved.",
        "detailed_feature_description": "When an interview is saved, log the current timestamp along with the user who saved it. This information will be stored in the database and can be used for auditing purposes.",
        "modified_complete_code": {
            "file1": "client.on('save', function (data) {\n  getSession(client.handshake.headers.cookie, function (err, session) {\n    if (err || !session) {\n      console.log(err);\n      throw err;\n    }\n\n    var save = false;\n\n    // If theres a session here (not null) than the user is logged in while connecting to a socket\n    if (session.user) {\n      if (session.user.privledges.editor_save) {\n        save = true;\n      }\n    }\n\n    // only save to the database if the user has privledges\n    if (save) {\n      //TODO: sanitize the inputs\n      models.Interviews.findOne({ id: data.id }, function (err, doc) {\n        if (err) {\n          console.log(err);\n          throw err;\n        } \n\n        if (!doc) {\n          emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n          return;\n        }\n\n        doc.description = data.settings.description;\n        doc.steps = data.settings.steps;\n        doc.start = data.settings.start;\n        doc.data = data.data;\n        doc.distance = {\n          update: true,\n          graph: {}\n        };\n        #Modify doc.last_saved_by = session.user.id;\n        #Modify doc.last_saved_at = new Date();\n        doc.save();\n        connected_clients[id].socket.emit('saved', true);\n        \n      });\n    } else {\n      connected_clients[id].socket.emit('saved', false);\n    }\n  });\n});",
            "file2": "var io = require('socket.io').listen(server);\n\n// This is what runs on an incoming socket request\n// If there is already a session established, accept the socket, otherwise deny it\nio.set('authorization', function (data, accept) {\n  // Check if the person connecting is logged in. \n  // If they are, store there user is and check it again when they are trying to save the interview\n  if (data.headers.cookie) {\n    data.cookie = utils.parseCookie(data.headers.cookie);\n\n    if (data.cookie) {\n      if (data.cookie['connect.sid']) {\n        data.sessionID = data.cookie['connect.sid'].split('.')[0].substring(2);\n        // Create a new connection to the LogicPul database, so we can compare the _id field to the cookie sid field\n        // these must match in order for a connection to go through\n        sessionStore.get(data.sessionID, function (err, session) {\n          // these are urls we don't need to authorize a logged in user for the /interviews\n          var no_auth_required = new RegExp(app.get('base_url') + '/interviews/', 'g');\n\n          if (err || !session) {\n            // Don't accept the socket request if the user is not logged in\n            if (!no_auth_required.test(data.headers.referer)) {\n              // If we get here the URL is from inside the manager\n              return accept('Session not found in database', false);\n            }\n\n            console.log('   debug - ' + 'no socket authorization needed');\n            return accept(null, true);\n          }\n\n          // save the session data and accept the connection if the user is logged in\n          if (session.user && session.user.authenticated) {\n            data.session = session;\n            data.session.url = data.headers.referer;\n            return accept(null, true);\n          }\n\n          if (!no_auth_required.test(data.headers.referer)) {\n            return accept('User is not authenticated', false);\n          }\n\n          console.log('   debug - ' + 'no socket authorization needed');\n          return accept(null, true);                  \n        });                     \n      } else {\n        return accept('No cookie transmitted.', false);\n      }               \n    } else {\n      return accept('No cookie transmitted.', false);\n    }\n  } else {\n    return accept('No cookie transmitted.', false);\n  }\n});"
        }
    },
    {
        "repo": "winston-logstash",
        "content": "'winston-logstash/lib/winston-logstash.js'\n:\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Logstash = void 0;\nvar _winston = require(\"winston\");\nvar _manager = require(\"./manager\");\nvar _connection = require(\"./connection\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nconst common = require('winston/lib/winston/common');\nclass Logstash extends _winston.Transport {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"node_name\", void 0);\n    _defineProperty(this, \"json\", true);\n    _defineProperty(this, \"label\", void 0);\n    _defineProperty(this, \"meta_defaults\", void 0);\n    _defineProperty(this, \"manager\", void 0);\n    _defineProperty(this, \"connection\", void 0);\n    this.name = 'logstash';\n    this.node_name = options.node_name || process.title;\n\n    // Miscellaneous options\n    this.label = options.label || this.node_name;\n    this.meta_defaults = Object.assign({}, options.meta);\n    this.connection = options.ssl_enable ? new _connection.SecureConnection(options) : new _connection.PlainConnection(options);\n    this.manager = new _manager.Manager(options, this.connection);\n    this.manager.on('error', this.onError.bind(this));\n    this.manager.start();\n  }\n  log(level, msg, meta, callback) {\n    if (this.silent) {\n      return callback(null, true);\n    }\n    const logEntry = this.defaultTransform(level, msg, Object.assign({}, meta, this.meta_defaults));\n    this.manager.log(logEntry, () => {\n      callback(null, true);\n    });\n    this.emit('logged');\n  }\n  onError(error) {\n    this.silent = true;\n    this.emit('error', error);\n  }\n  close() {\n    this.manager.close();\n  }\n  defaultTransform(level, msg, meta) {\n    return common.log({\n      level: level,\n      message: msg,\n      meta: meta,\n      json: this.json,\n      label: this.label,\n      humanReadableUnhandledException: this.humanReadableUnhandledException\n    });\n  }\n}\nexports.Logstash = Logstash;\n'winston-logstash/test-bench/winston-2x/test/on_error_test.js'\n:\nconst winston = require('winston');\nconst transports = require('../../../lib/winston-logstash');\n\ndescribe('Ensure error is handled correctly', () => {\n  it('add error eventhandler for logger', (done) => {\n    const logstashTransport = new transports.Logstash({\n      max_connect_retries: 2,\n      port: 7878,\n      node_name: 'my node name',\n      host: 'localhost',\n      ssl_enable: true,\n      ca: __dirname + '/../../../test/support/ssl/ca.cert',\n      ssl_key: __dirname + '/../../../test/support/ssl/client.key',\n      ssl_cert: __dirname + '/../../../test/support/ssl/client.cert',\n    });\n    const logger = new (winston.Logger)({\n      transports: [\n        logstashTransport,\n      ],\n    });\n\n    logstashTransport.on('error', (error) => {\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message)\n          .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n      done();\n    });\n    logger.log('info', 'random message');\n  });\n});\n\n",
        "called_code_segment": "log(level, msg, meta, callback) {\n    if (this.silent) {\n      return callback(null, true);\n    }\n    const logEntry = this.defaultTransform(level, msg, Object.assign({}, meta, this.meta_defaults));\n    this.manager.log(logEntry, () => {\n      callback(null, true);\n    });\n    this.emit('logged');\n  }",
        "invoking_code_segment": "logstashTransport.on('error', (error) => {\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message)\n          .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n      done();\n    });\n    logger.log('info', 'random message');",
        "feature_description": "Add a retry mechanism for logging when an error occurs.",
        "detailed_feature_description": "When an error occurs during logging, the logger will attempt to retry logging the message a specified number of times before giving up. This feature will be implemented by adding a retry counter and a retry limit to the log method in #file 1. The corresponding test in #file 2 will be updated to handle the new retry mechanism.",
        "modified_complete_code": {
            "winston-logstash/lib/winston-logstash.js": "//Modify\nlog(level, msg, meta, callback) {\n    if (this.silent) {\n      return callback(null, true);\n    }\n    const logEntry = this.defaultTransform(level, msg, Object.assign({}, meta, this.meta_defaults));\n    let retryCount = 0;\n    const retryLimit = 3; // #New: Define retry limit\n    const retryLog = () => {\n      this.manager.log(logEntry, (err) => {\n        if (err && retryCount < retryLimit) {\n          retryCount++;\n          retryLog();\n        } else {\n          callback(err, true);\n        }\n      });\n    };\n    retryLog();\n    this.emit('logged');\n  }",
            "winston-logstash/test-bench/winston-2x/test/on_error_test.js": "//Modify\nlogstashTransport.on('error', (error) => {\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message)\n          .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n      done();\n    });\n    logger.log('info', 'random message', {}, (err) => {\n      expect(err).toBeInstanceOf(Error);\n      expect(err.message).toMatch('Max retries reached');\n      done();\n    });\n    // #New: Add a timeout to ensure the test does not hang indefinitely\n    setTimeout(() => {\n      done(new Error('Test timed out'));\n    }, 5000);"
        }
    },
    {
        "repo": "evil-icons",
        "content": "'evil-icons/evil-icons.js'\n:var fs          = require('fs');\nvar spritePath  = __dirname + '/assets/sprite.svg';\nvar sprite      = fs.readFileSync(spritePath).toString();\nvar icon        = require('./icon');;\n\nfunction buildParamsFromString(string) {\n  var match, attr, value;\n  var params = {};\n  var attrsRegexp = /(\\S+)=[\"']?((?:.(?![\"']?\\s+(?:\\S+)=|[>\"']))+.)[\"']?/gi;\n\n  while (match = attrsRegexp.exec(string)) {\n    attr  = match[1];\n    value = match[2].replace(/'|\"/, '');\n    params[attr] = value;\n  }\n\n  return params;\n}\n\nfunction replaceIconTags(src) {\n  var match, tag, params, name;\n  var html = src.toString();\n  var iconRegexp = /<icon\\s+([-=\\w\\d'\"\\s]+)\\s*\\/?>(<\\/icon>)?/gi;\n\n  while (match = iconRegexp.exec(html)) {\n    tag     = match[0];\n    params  = buildParamsFromString(match[1]);\n    name    = params.name;\n\n    delete params.name;\n\n    html = html.replace(tag, icon(name, params));\n  }\n\n  return html;\n}\n\nfunction iconizeHtml(src) {\n  var html = src.toString();\n\n  if (html.indexOf(sprite) == -1) {\n    html = html.replace(/<body.*?>/, function(match) { return match + sprite });\n  }\n\n  return replaceIconTags(html);\n}\n\nmodule.exports = {\n  iconizeHtml:  iconizeHtml,\n  sprite:       sprite,\n  icon:         icon\n};\n\n'evil-icons/test/evil-icons.js'\n:var assert  = require('assert');\nvar libxml  = require('libxmljs');\nvar icons   = require('../evil-icons');\n\ndescribe('Evil Icons', function() {\n\n  describe('icon', function() {\n\n    function svg(icon) {\n      var svg = '<svg class=\"icon__cnt\">' +\n                  '<use xlink:href=\"#ei-' + icon + '-icon\" />' +\n                '</svg>';\n      return svg;\n    }\n\n    it('renders', function() {\n      var actual    = icons.icon('ei-search');\n      var expected  = '<div class=\"icon icon--ei-search\">' +\n                        svg('search') +\n                      '</div>';\n\n      assert.equal(actual, expected);\n    });\n\n    it('accepts size', function() {\n      var actual    = icons.icon('ei-search', {size: 'l'});\n      var expected  = '<div class=\"icon icon--ei-search icon--l\">' +\n                        svg('search') +\n                      '</div>';\n\n      assert.equal(actual, expected);\n    });\n\n    it('accepts single class', function() {\n      var actual    = icons.icon('ei-search', {class: 'foo'});\n      var expected  = '<div class=\"icon icon--ei-search foo\">' +\n                        svg('search') +\n                      '</div>';\n\n      assert.equal(actual, expected);\n    });\n\n    it('accepts multiple classes', function() {\n      var actual    = icons.icon('ei-search', {class: 'foo bar'});\n      var expected  = '<div class=\"icon icon--ei-search foo bar\">' +\n                        svg('search') +\n                      '</div>';\n\n      assert.equal(actual, expected);\n    });\n\n    it('wraps spinners', function() {\n      var actual    = icons.icon('ei-spinner');\n      var expected  = '<div class=\"icon icon--ei-spinner\">' +\n                        '<div class=\"icon__spinner\">' +\n                          svg('spinner') +\n                        '</div>' +\n                      '</div>';\n\n      assert.equal(actual, expected);\n    });\n\n  });\n\n  describe('iconizeHtml', function() {\n\n    function doc(html) {\n      var html    = html || '';\n      var result  = '<!DOCTYPE html><html>' +\n                    '<head><title>Evil Icons</title></head>' +\n                    html + '</html>';\n      return result;\n    }\n\n    function find(html, xpath) {\n      var parsedHtml = libxml.parseHtmlString(html);\n      return parsedHtml.find(xpath);\n    }\n\n    it('keeps doctype', function() {\n      var html = icons.iconizeHtml(doc('<body></body>'));\n      assert(html.indexOf('<!DOCTYPE html>') > -1);\n    });\n\n    it('renders sprite', function() {\n      var html    = icons.iconizeHtml(doc('<body></body>'));\n      var sprite  = find(html, '//svg[@id=\"ei-sprite\"]');\n\n      assert(sprite.length == 1);\n\n      html    = icons.iconizeHtml(doc('<body class=red data-attr=\"a\">\\n</body>'));\n      sprite  = find(html, '//svg[@id=\"ei-sprite\"]');\n\n      assert(sprite.length == 1);\n    });\n\n    it('doesn\\'t render sprite twice', function() {\n      var html    = icons.iconizeHtml(doc('<body> </body>'));\n      html        = icons.iconizeHtml(html);\n      var sprite  = find(html, '//svg[@id=\"ei-sprite\"]');\n\n      assert(sprite.length == 1);\n    });\n\n    it('replaces single icon tag', function() {\n      var html  = doc('<body> <icon name=\"ei-archive\" /> </body>');\n      html      = icons.iconizeHtml(html);\n      var icon  = find(html, '//div[@class=\"icon icon--ei-archive\"]');\n\n      assert(icon.length == 1);\n    });\n\n    it('replaces multiple icon tags', function() {\n      var html = doc(\n        '<body>' +\n        '<p>Some&nbsp;entities</p>\\n' +\n        '<icon name=\"ei-archive\" />\\n' +\n        '<a href=\"http://evil-icons.io\">Evil Icons</a>\\n' +\n        '<icon name=\"ei-search\" />\\n' +\n        '</body>'\n      );\n\n      html        = icons.iconizeHtml(html);\n      var first   = find(html, '//div[@class=\"icon icon--ei-archive\"]');\n      var second  = find(html, '//div[@class=\"icon icon--ei-search\"]');\n\n      assert(first.length == 1, 'First icon failed');\n      assert(second.length == 1, 'Second icon failed');\n    });\n\n    it('respects icon size attr', function() {\n      var html  = doc('<body> <icon name=\"ei-archive\" size=\"l\" /> </body>');\n      html      = icons.iconizeHtml(html);\n      var icon  = find(html, '//div[@class=\"icon icon--ei-archive icon--l\"]');\n\n      assert(icon.length == 1);\n    });\n\n    it('respects classes', function() {\n      var html = doc(\n        '<body>' +\n        '<icon name=\"ei-archive\" class=\"foo\" />' +\n        '<icon name=\"ei-archive\" class=\"foo bar\" />' +\n        '</body>'\n      );\n\n      html        = icons.iconizeHtml(html);\n      var foo     = find(html, '//div[@class=\"icon icon--ei-archive foo\"]');\n      var foobar  = find(html, '//div[@class=\"icon icon--ei-archive foo bar\"]');\n\n      assert(foo.length == 1, 'Single class failed');\n      assert(foobar.length == 1, 'Multiple classes failed');\n    });\n\n  });\n\n});\n\n",
        "called_code_segment": "function iconizeHtml(src) {\n  var html = src.toString();\n\n  if (html.indexOf(sprite) == -1) {\n    html = html.replace(/<body.*?>/, function(match) { return match + sprite });\n  }\n\n  return replaceIconTags(html);\n}",
        "invoking_code_segment": "var actual    = icons.iconizeHtml(doc('<body></body>'));",
        "feature_description": "Add support for custom attributes in icon tags.",
        "detailed_feature_description": "Modify the `iconizeHtml` function in #file 1 to allow custom attributes in the `<icon>` tags. Update the `buildParamsFromString` function to handle these attributes and pass them to the `icon` function. In #file 2, ensure that the `icon` function can accept and render these custom attributes.",
        "modified_complete_code": {
            "file1": "function buildParamsFromString(string) {\n  var match, attr, value;\n  var params = {};\n  var attrsRegexp = /(\\S+)=[\"']?((?:.(?![\"']?\\s+(?:\\S+)=|[>\"']))+.)[\"']?/gi;\n\n  while (match = attrsRegexp.exec(string)) {\n    attr  = match[1];\n    value = match[2].replace(/'|\"/, '');\n    params[attr] = value;\n  }\n\n  return params;\n}\n\nfunction replaceIconTags(src) {\n  var match, tag, params, name;\n  var html = src.toString();\n  var iconRegexp = /<icon\\s+([-=\\w\\d'\"\\s]+)\\s*\\/?>(</icon>)?/gi;\n\n  while (match = iconRegexp.exec(html)) {\n    tag     = match[0];\n    params  = buildParamsFromString(match[1]);\n    name    = params.name;\n\n    delete params.name;\n\n    html = html.replace(tag, icon(name, params));\n  }\n\n  return html;\n}\n\nfunction iconizeHtml(src) {\n  var html = src.toString();\n\n  if (html.indexOf(sprite) == -1) {\n    html = html.replace(/<body.*?>/, function(match) { return match + sprite });\n  }\n\n  return replaceIconTags(html);\n}",
            "file2": "function icon(name, params) {\n  var size    = params.size || 'm';\n  var classes = params.class ? ' ' + params.class : '';\n  var attrs   = '';\n\n  // Modify: Include custom attributes\n  for (var attr in params) {\n    if (params.hasOwnProperty(attr) && attr !== 'size' && attr !== 'class') {\n      attrs += ' ' + attr + '=\"' + params[attr] + '\"';\n    }\n  }\n\n  var svg = '<svg class=\"icon__cnt\">' +\n              '<use xlink:href=\"#ei-' + name.replace('ei-', '') + '-icon\" />' +\n            '</svg>';\n\n  var result = '<div class=\"icon icon--' + name + ' icon--' + size + classes + '\"' + attrs + '>' +\n                 svg +\n               '</div>';\n\n  return result;\n}"
        }
    },
    {
        "repo": "fifa-worldcup-2018",
        "content": "'fifa-worldcup-2018/test/group.js'\n:const checker = require('./propertyCheck');\n\nfunction validateGroupnames(data, errors) {\n    const groupnames = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    groupnames.forEach((groupkey) => {\n        if (! data.hasOwnProperty(groupkey)) {\n            errors.push(`Group ${groupkey} not set`);\n        }\n    });\n}\n\nfunction validateGroup(groupname, group, errors) {\n    if (! group.hasOwnProperty('winner')) {\n        errors.push(`Group ${groupname} missing \"winner\"`);\n    } else {\n        if (! (typeof group.winner === 'number' || group.winner === null)) {\n            errors.push(`Group ${groupname} \"winner\" expected type \"object|number\" got ${typeof group.winner}`);\n        }\n    }\n\n    if (! group.hasOwnProperty('runnerup')) {\n        errors.push(`Group ${groupname} missing \"runnerup\"`);\n    } else {\n        if (! (typeof group.runnerup === 'number' || group.runnerup === null)) {\n            errors.push(`Group ${groupname} \"runnerup\" expected type \"object|number\" got ${typeof group.winner}`);\n        }\n    }\n\n    const properties = {\n        \"name\": \"number\",\n        \"type\": \"string\",\n        \"home_team\": \"number\",\n        \"away_team\": \"number\",\n        \"home_result\": \"null|number\",\n        \"away_result\": \"null|number\",\n        \"date\": \"datetime\",\n        \"stadium\": \"number\",\n        \"channels\": \"array\",\n        \"finished\": \"boolean\",\n        \"matchday\": \"number\",\n    };\n    checker(group, errors, 'matches', 6, `Group ${groupname} - Matches`, properties);\n}\n\nmodule.exports = function(data, errors) {\n    if (! data.hasOwnProperty('groups')) {\n        errors.push('Groups not set');\n    } else {\n        validateGroupnames(data.groups, errors);\n        const groups = data.groups;\n        Object.keys(groups).forEach((groupname) => {\n            validateGroup(groupname, groups[groupname], errors);\n        });\n    }\n};\n'fifa-worldcup-2018/test/index.js'\n:const data = require('./../data');\nconst Stadium = require('./stadium');\nconst Tvchannel = require('./tvchannels');\nconst Team = require('./teams');\nconst Group = require('./group');\nconst Knockout = require('./knockout');\n\nlet errors = [];\n\nStadium(data, errors);\nTvchannel(data, errors);\nTeam(data, errors);\nGroup(data, errors);\nKnockout(data, errors);\n\nif (errors.length > 0) {\n    console.log(errors);\n    throw new Error();\n}\n\nconsole.log('No errors');\n\n",
        "called_code_segment": "module.exports = function(data, errors) {\n    if (! data.hasOwnProperty('groups')) {\n        errors.push('Groups not set');\n    } else {\n        validateGroupnames(data.groups, errors);\n        const groups = data.groups;\n        Object.keys(groups).forEach((groupname) => {\n            validateGroup(groupname, groups[groupname], errors);\n        });\n    }\n};",
        "invoking_code_segment": "const Group = require('./group');\n\nlet errors = [];\n\nGroup(data, errors);",
        "feature_description": "Add a new validation for the 'matches' property in each group to ensure that all matches have a 'winner' property.",
        "detailed_feature_description": "The new feature involves adding a validation check within the 'validateGroup' function in the 'group.js' file to ensure that each match in the 'matches' array has a 'winner' property. This will require modifying the 'validateGroup' function and updating the call in the 'index.js' file to handle any new errors that might be added.",
        "modified_complete_code": {
            "group.js": "const checker = require('./propertyCheck');\n\nfunction validateGroupnames(data, errors) {\n    const groupnames = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];\n    groupnames.forEach((groupkey) => {\n        if (! data.hasOwnProperty(groupkey)) {\n            errors.push(`Group ${groupkey} not set`);\n        }\n    });\n}\n\nfunction validateGroup(groupname, group, errors) {\n    if (! group.hasOwnProperty('winner')) {\n        errors.push(`Group ${groupname} missing \"winner\"`);\n    } else {\n        if (! (typeof group.winner === 'number' || group.winner === null)) {\n            errors.push(`Group ${groupname} \"winner\" expected type \"object|number\" got ${typeof group.winner}`);\n        }\n    }\n\n    if (! group.hasOwnProperty('runnerup')) {\n        errors.push(`Group ${groupname} missing \"runnerup\"`);\n    } else {\n        if (! (typeof group.runnerup === 'number' || group.runnerup === null)) {\n            errors.push(`Group ${groupname} \"runnerup\" expected type \"object|number\" got ${typeof group.winner}`);\n        }\n    }\n\n    const properties = {\n        \"name\": \"number\",\n        \"type\": \"string\",\n        \"home_team\": \"number\",\n        \"away_team\": \"number\",\n        \"home_result\": \"null|number\",\n        \"away_result\": \"null|number\",\n        \"date\": \"datetime\",\n        \"stadium\": \"number\",\n        \"channels\": \"array\",\n        \"finished\": \"boolean\",\n        \"matchday\": \"number\",\n    };\n    checker(group, errors, 'matches', 6, `Group ${groupname} - Matches`, properties);\n\n    #Modify: Add new validation for 'winner' property in each match\n    group.matches.forEach((match, index) => {\n        if (!match.hasOwnProperty('winner')) {\n            errors.push(`Group ${groupname} - Match ${index} missing \"winner\"`);\n        }\n    });\n}\n\nmodule.exports = function(data, errors) {\n    if (! data.hasOwnProperty('groups')) {\n        errors.push('Groups not set');\n    } else {\n        validateGroupnames(data.groups, errors);\n        const groups = data.groups;\n        Object.keys(groups).forEach((groupname) => {\n            validateGroup(groupname, groups[groupname], errors);\n        });\n    }\n};",
            "index.js": "const data = require('./../data');\nconst Stadium = require('./stadium');\nconst Tvchannel = require('./tvchannels');\nconst Team = require('./teams');\nconst Group = require('./group');\nconst Knockout = require('./knockout');\n\nlet errors = [];\n\nStadium(data, errors);\nTvchannel(data, errors);\nTeam(data, errors);\nGroup(data, errors);\nKnockout(data, errors);\n\nif (errors.length > 0) {\n    console.log(errors);\n    throw new Error();\n}\n\nconsole.log('No errors');\n"
        }
    },
    {
        "repo": "bleach",
        "content": "'bleach/lib/bleach.js'\n:/*\n * bleach\n * a minimal html sanitizer\n * cam@onswipe.com\n */\n\nvar fs = require('fs'),\n    he = require('he');\n\nvar bleach = {\n\n  matcher: /<\\/?([a-zA-Z0-9]+)*(.*?)\\/?>/igm,\n\n  whitelist: [\n    'a',\n    'b',\n    'p',\n    'em',\n    'strong'\n  ],\n\n  analyze: function(html) {\n    html = String(html) || '';\n\n    var matches = [],\n        match;\n\n    // extract all tags\n    while ((match = bleach.matcher.exec(html)) != null) {\n      var attrr = match[2].split(' '),\n          attrs = [];\n\n      // extract attributes from the tag\n      attrr.shift();\n      attrr.forEach(function(attr){\n        attr = attr.split('=');\n        var attr_name = attr[0],\n            attr_val = attr.length > 1 ? attr.slice(1).join('=') : null;\n        // remove quotes from attributes\n        if (attr_val && attr_val.charAt(0).match(/'|\"/)) attr_val = attr_val.slice(1);\n        if (attr_val && attr_val.charAt(attr_val.length-1).match(/'|\"/)) attr_val = attr_val.slice(0, -1);\n        attr = {\n          name: attr_name,\n          value: attr_val\n        };\n        if (!attr.value) delete attr.value;\n        if (attr.name) attrs.push(attr);\n      });\n\n      var tag = {\n        full: match[0],\n        name: match[1],\n        attr: attrs\n      };\n\n      matches.push(tag);\n    }\n\n    return matches;\n  },\n\n  sanitize: function(html, options) {\n    html = String(html) || '';\n    options = options || {};\n\n    var mode = options.mode || 'white',\n        list = options.list || bleach.whitelist;\n\n    var matches = bleach.analyze(html);\n\n    if ((mode == 'white' && list.indexOf('script') == -1)\n     || (mode == 'black' && list.indexOf('script') != -1)) {\n      html = html.replace(/<script(.*?)>(.*?[\\r\\n])*?(.*?)(.*?[\\r\\n])*?<\\/script>/gim, '');\n    }\n\n\n    if ((mode == 'white' && list.indexOf('style') == -1)\n     || (mode == 'black' && list.indexOf('style') != -1)) {\n      html = html.replace(/<style(.*?)>(.*?[\\r\\n])*?(.*?)(.*?[\\r\\n])*?<\\/style>/gim, '');\n    }\n\n    matches.forEach(function(tag){\n      if (mode == 'white') {\n        if (list.indexOf(tag.name) == -1) {\n          html = html.replace(tag.full, '');\n        }\n      } else if (mode == 'black') {\n        if (list.indexOf(tag.name) != -1) {\n          html = html.replace(tag.full, '');\n        }\n      } else {\n        throw new Error('Unknown sanitization mode \"' + mode + '\"');\n      }\n    });\n\n    if ( options.encode_entities ) html = he.encode( html );\n\n    return html;\n  },\n\n  filterSync: function(html, filters) {\n    html = String(html) || '';\n\n    if (!filters) return;\n\n    var available = fs.readdirSync(__dirname + '/../filters');\n\n    if (Array.isArray(filters)) {\n      for (var i in filters) {\n        if (typeof filters[i] == 'function') {\n          html = filters[i](html);\n        } else {\n          var file = filters[i] + '.js';\n          for (var j in available) {\n            if (file == available[j]) {\n              html = require('../filters/' + file)(html);\n            }\n          }\n        }\n      }\n      return html;\n    } else if (typeof filters == 'string') {\n      var file = filters + '.js';\n      for (var i in available) {\n        if (file == available[i]) {\n          html = require('../filters/' + file)(html);\n          return html;\n        }\n      }\n      } else if (typeof filters == 'function') {\n        html = filters(html);\n        return html;\n      } else return html;\n  },\n\n  filter: function(html, filters, callback) {\n    if (typeof(callback) != 'function') {\n      return bleach.filterSync(html, filters);\n    }\n\n    html = String(html) || '';\n\n    if (!filters) callback('no filters provided', undefined);\n\n    var available = fs.readdir(__dirname + '/../filters', function() {\n      if (Array.isArray(filters)) {\n        for (var i in filters) {\n          if (typeof filters[i] == 'function') {\n            html = filters[i](html);\n          } else {\n            var file = filters[i] + '.js';\n            for (var j in available) {\n              if (file == available[j]) {\n                html = require('../filters/' + file)(html);\n              }\n            }\n          }\n        }\n        return html;\n      } else if (typeof filters == 'string') {\n        var file = filters + '.js';\n        for (var i in available) {\n          if (file == available[i]) {\n            html = require('../filters/' + file)(html);\n            callback(undefined, html);\n          }\n        }\n        } else if (typeof filters == 'function') {\n          html = filters(undefined, html);\n          callback(undefined, html);\n        } else callback(undefined, html);\n    });\n  }\n\n};\n\nmodule.exports = bleach;\n\n'bleach/test/analyze.js'\n:var vows   = require('vows'),\n    assert = require('assert');\n    bleach = require('../lib/bleach');\n\nvows.describe('bleach').addBatch({\n\n  'bleach.analyze(html)': {\n    topic: function(){ return bleach.analyze; },\n    'is a function': function(analyze) {\n      assert.equal(typeof analyze, 'function');\n    },\n    'returns blank array on invalid or missing input': function(analyze) {\n      assert.deepEqual(analyze({}), []);\n      assert.deepEqual(analyze([]), []);\n      assert.deepEqual(analyze(''), []);\n    },\n    'finds self-closing tags': function(analyze){\n      assert.ok(analyze('<input type=\"text\" />').length > 0);\n    },\n    'returns an array': function(analyze) {\n      assert.isArray(analyze(' '));\n    },\n    'extracts attributes': function(analyze){\n      assert.equal(analyze('<input type=\"text\"></input>')[0].attr[0], { name: 'type', value: '\"text\"' }.toString());\n    }\n  },\n\n  'bleach.sanitize(html, options)': {\n    topic: function(){ return bleach.sanitize; },\n    'is a function': function(sanitize) {\n      assert.equal(typeof sanitize, 'function');\n    },\n    'does not require options to be passed in': function(sanitize){\n      assert.doesNotThrow(function(){\n        sanitize(' ');\n      }, Error);\n    },\n    'returns a string': function(sanitize) {\n      assert.isString(sanitize(' '));\n    },\n    'returns blank string on invalid or missing input': function(analyze) {\n      assert.isString(analyze({}));\n      assert.isString(analyze([]));\n      assert.isString(analyze(''));\n    },\n    'whitelist is respected': function(sanitize){\n      var whitelist = ['br'],\n          input     = '<html><body><p>hello<br />world!</p></body></html><script type=\"text/javascript\" />',\n          output    = 'hello<br />world!',\n          outcome   = sanitize(input, { list: whitelist });\n\n      assert.equal(output, outcome);\n    },\n    'blacklist is respected': function(sanitize){\n      var blacklist = ['html', 'body'],\n          input     = '<html><body><p>hello<br />world!</p></body></html>',\n          output    = '<p>hello<br />world!</p>',\n          options   = {\n            mode: 'black',\n            list: blacklist\n          },\n          outcome = sanitize(input, options);\n\n      assert.equal(output, outcome);\n    },\n\n  },\n\n  'bleach.filter(html)': {\n    topic: function(){ return bleach.filter; },\n    'is a function': function(filter) {\n      assert.equal(typeof filter, 'function');\n    },\n    'allows array or string to be passed in': function(filter){\n      assert.doesNotThrow(function(){\n        filter([]);\n        filter('');\n      }, Error);\n    },\n    'returns a string': function(filter) {\n      assert.isString(filter(' ', 'youtube'));\n    },\n    'allow function to be passed in': function(filter){\n      var nyanFilter = function(html){\n        return 'nyan';\n      }\n      assert.equal(filter('nyannyannyan', nyanFilter), 'nyan');\n    },\n    'allow array of functions to be passed in': function(filter){\n      var filters = [\n        function(html){\n          return 'nyan';\n        },\n        function(html){\n          return html + html;\n        }\n      ];\n      assert.equal(filter('nyannyannyan', filters), 'nyannyan');\n    },\n  },\n\n  'included youtube filter': {\n    topic: function(){ return bleach.filter; },\n    'converts a youtube flash object to an iframe': function(filter){\n      var input = '<object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" width=\"420\" height=\"315\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\"><param name=\"allowFullScreen\" value=\"true\"><param name=\"allowscriptaccess\" value=\"always\"><param name=\"src\" value=\"http://www.youtube.com/v/aU079Mdkenw?version=3&amp;hl=en_US\"><param name=\"allowfullscreen\" value=\"true\"><embed type=\"application/x-shockwave-flash\" width=\"420\" height=\"315\" src=\"http://www.youtube.com/v/aU079Mdkenw?version=3&amp;hl=en_US\" allowscriptaccess=\"always\" allowfullscreen=\"true\" id=\"s_media_1_0\" name=\"s_media_1_0\"></object>',\n          output = '<iframe type=\"text/html\" frameborder=\"0\" scrolling=\"no\" allowfullscreen src=\"http://youtube.com/embed/aU079Mdkenw\"></iframe>';\n\n      assert.equal(filter(input, 'youtube'), output);\n    },\n    'ignores non-youtube flash objects': function(filter){\n      var input = '<object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" width=\"420\" height=\"315\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\"><param name=\"allowFullScreen\" value=\"true\"><param name=\"allowscriptaccess\" value=\"always\"><param name=\"src\" value=\"http://www.youtube.com/v/aU079Mdkenw?version=3&amp;hl=en_US\"><param name=\"allowfullscreen\" value=\"true\"><embed type=\"application/x-shockwave-flash\" width=\"420\" height=\"315\" src=\"http://google.com/asdf\" allowscriptaccess=\"always\" allowfullscreen=\"true\" id=\"s_media_1_0\" name=\"s_media_1_0\"></object>';\n\n      assert.equal(filter(input, 'youtube'), input);\n    },\n  }\n\n}).export(module);\n\n",
        "called_code_segment": "sanitize: function(html, options) { html = String(html) || ''; options = options || {}; var mode = options.mode || 'white', list = options.list || bleach.whitelist; var matches = bleach.analyze(html); if ((mode == 'white' && list.indexOf('script') == -1) || (mode == 'black' && list.indexOf('script') != -1)) { html = html.replace(/<script(.*?)>(.*?[\\r\\n])*?(.*?)(.*?[\\r\\n])*?<\\/script>/gim, ''); } if ((mode == 'white' && list.indexOf('style') == -1) || (mode == 'black' && list.indexOf('style') != -1)) { html = html.replace(/<style(.*?)>(.*?[\\r\\n])*?(.*?)(.*?[\\r\\n])*?<\\/style>/gim, ''); } matches.forEach(function(tag){ if (mode == 'white') { if (list.indexOf(tag.name) == -1) { html = html.replace(tag.full, ''); } } else if (mode == 'black') { if (list.indexOf(tag.name) != -1) { html = html.replace(tag.full, ''); } } else { throw new Error('Unknown sanitization mode \"' + mode + '\"'); } }); if ( options.encode_entities ) html = he.encode( html ); return html; }",
        "invoking_code_segment": "var outcome = sanitize(input, { list: whitelist }); assert.equal(output, outcome);",
        "feature_description": "Add support for custom attribute filtering during sanitization.",
        "detailed_feature_description": "Modify the `sanitize` function to accept an additional option `attributeFilter` which is a function that can filter or modify attributes of tags. Update the `sanitize` function to apply this filter to each attribute before returning the sanitized HTML.",
        "modified_complete_code": {
            "bleach/lib/bleach.js": "/*\n * bleach\n * a minimal html sanitizer\n * cam@onswipe.com\n */\n\nvar fs = require('fs'),\n    he = require('he');\n\nvar bleach = {\n\n  matcher: /<\\/?([a-zA-Z0-9]+)*(.*?)\\/?>/igm,\n\n  whitelist: [\n    'a',\n    'b',\n    'p',\n    'em',\n    'strong'\n  ],\n\n  analyze: function(html) {\n    html = String(html) || '';\n\n    var matches = [],\n        match;\n\n    // extract all tags\n    while ((match = bleach.matcher.exec(html)) != null) {\n      var attrr = match[2].split(' '),\n          attrs = [];\n\n      // extract attributes from the tag\n      attrr.shift();\n      attrr.forEach(function(attr){\n        attr = attr.split('=');\n        var attr_name = attr[0],\n            attr_val = attr.length > 1 ? attr.slice(1).join('=') : null;\n        // remove quotes from attributes\n        if (attr_val && attr_val.charAt(0).match(/'|\\\"/)) attr_val = attr_val.slice(1);\n        if (attr_val && attr_val.charAt(attr_val.length-1).match(/'|\\\"/)) attr_val = attr_val.slice(0, -1);\n        attr = {\n          name: attr_name,\n          value: attr_val\n        };\n        if (!attr.value) delete attr.value;\n        if (attr.name) attrs.push(attr);\n      });\n\n      var tag = {\n        full: match[0],\n        name: match[1],\n        attr: attrs\n      };\n\n      matches.push(tag);\n    }\n\n    return matches;\n  },\n\n  sanitize: function(html, options) {\n    html = String(html) || '';\n    options = options || {};\n\n    var mode = options.mode || 'white',\n        list = options.list || bleach.whitelist,\n        attributeFilter = options.attributeFilter || function(attr) { return attr; }; // #Modify\n\n    var matches = bleach.analyze(html);\n\n    if ((mode == 'white' && list.indexOf('script') == -1)\n     || (mode == 'black' && list.indexOf('script') != -1)) {\n      html = html.replace(/<script(.*?)>(.*?[\\r\\n])*?(.*?)(.*?[\\r\\n])*?<\\/script>/gim, '');\n    }\n\n    if ((mode == 'white' && list.indexOf('style') == -1)\n     || (mode == 'black' && list.indexOf('style') != -1)) {\n      html = html.replace(/<style(.*?)>(.*?[\\r\\n])*?(.*?)(.*?[\\r\\n])*?<\\/style>/gim, '');\n    }\n\n    matches.forEach(function(tag){\n      if (mode == 'white') {\n        if (list.indexOf(tag.name) == -1) {\n          html = html.replace(tag.full, '');\n        }\n      } else if (mode == 'black') {\n        if (list.indexOf(tag.name) != -1) {\n          html = html.replace(tag.full, '');\n        }\n      } else {\n        throw new Error('Unknown sanitization mode \"' + mode + '\"');\n      }\n\n      // #Modify: Apply attribute filter\n      tag.attr = tag.attr.map(attributeFilter).filter(Boolean);\n      var newTag = '<' + tag.name + ' ' + tag.attr.map(function(attr) { return attr.name + '=\"' + attr.value + '\"'; }).join(' ') + '>';\n      html = html.replace(tag.full, newTag);\n    });\n\n    if ( options.encode_entities ) html = he.encode( html );\n\n    return html;\n  },\n\n  filterSync: function(html, filters) {\n    html = String(html) || '';\n\n    if (!filters) return;\n\n    var available = fs.readdirSync(__dirname + '/../filters');\n\n    if (Array.isArray(filters)) {\n      for (var i in filters) {\n        if (typeof filters[i] == 'function') {\n          html = filters[i](html);\n        } else {\n          var file = filters[i] + '.js';\n          for (var j in available) {\n            if (file == available[j]) {\n              html = require('../filters/' + file)(html);\n            }\n          }\n        }\n      }\n      return html;\n    } else if (typeof filters == 'string') {\n      var file = filters + '.js';\n      for (var i in available) {\n        if (file == available[i]) {\n          html = require('../filters/' + file)(html);\n          return html;\n        }\n      }\n      } else if (typeof filters == 'function') {\n        html = filters(html);\n        return html;\n      } else return html;\n  },\n\n  filter: function(html, filters, callback) {\n    if (typeof(callback) != 'function') {\n      return bleach.filterSync(html, filters);\n    }\n\n    html = String(html) || '';\n\n    if (!filters) callback('no filters provided', undefined);\n\n    var available = fs.readdir(__dirname + '/../filters', function() {\n      if (Array.isArray(filters)) {\n        for (var i in filters) {\n          if (typeof filters[i] == 'function') {\n            html = filters[i](html);\n          } else {\n            var file = filters[i] + '.js';\n            for (var j in available) {\n              if (file == available[j]) {\n                html = require('../filters/' + file)(html);\n              }\n            }\n          }\n        }\n        return html;\n      } else if (typeof filters == 'string') {\n        var file = filters + '.js';\n        for (var i in available) {\n          if (file == available[i]) {\n            html = require('../filters/' + file)(html);\n            callback(undefined, html);\n          }\n        }\n        } else if (typeof filters == 'function') {\n          html = filters(undefined, html);\n          callback(undefined, html);\n        } else callback(undefined, html);\n    });\n  }\n\n};\n\nmodule.exports = bleach;",
            "bleach/test/analyze.js": "var vows   = require('vows'),\n    assert = require('assert');\n    bleach = require('../lib/bleach');\n\nvows.describe('bleach').addBatch({\n\n  'bleach.analyze(html)': {\n    topic: function(){ return bleach.analyze; },\n    'is a function': function(analyze) {\n      assert.equal(typeof analyze, 'function');\n    },\n    'returns blank array on invalid or missing input': function(analyze) {\n      assert.deepEqual(analyze({}), []);\n      assert.deepEqual(analyze([]), []);\n      assert.deepEqual(analyze(''), []);\n    },\n    'finds self-closing tags': function(analyze){\n      assert.ok(analyze('<input type=\"text\" />').length > 0);\n    },\n    'returns an array': function(analyze) {\n      assert.isArray(analyze(' '));\n    },\n    'extracts attributes': function(analyze){\n      assert.equal(analyze('<input type=\"text\"></input>')[0].attr[0], { name: 'type', value: '\"text\"' }.toString());\n    }\n  },\n\n  'bleach.sanitize(html, options)': {\n    topic: function(){ return bleach.sanitize; },\n    'is a function': function(sanitize) {\n      assert.equal(typeof sanitize, 'function');\n    },\n    'does not require options to be passed in': function(sanitize){\n      assert.doesNotThrow(function(){\n        sanitize(' ');\n      }, Error);\n    },\n    'returns a string': function(sanitize) {\n      assert.isString(sanitize(' '));\n    },\n    'returns blank string on invalid or missing input': function(analyze) {\n      assert.isString(analyze({}));\n      assert.isString(analyze([]));\n      assert.isString(analyze(''));\n    },\n    'whitelist is respected': function(sanitize){\n      var whitelist = ['br'],\n          input     = '<html><body><p>hello<br />world!</p></body></html><script type=\"text/javascript\" />',\n          output    = 'hello<br />world!',\n          outcome   = sanitize(input, { list: whitelist });\n\n      assert.equal(output, outcome);\n    },\n    'blacklist is respected': function(sanitize){\n      var blacklist = ['html', 'body'],\n          input     = '<html><body><p>hello<br />world!</p></body></html>',\n          output    = '<p>hello<br />world!</p>',\n          options   = {\n            mode: 'black',\n            list: blacklist\n          },\n          outcome = sanitize(input, options);\n\n      assert.equal(output, outcome);\n    },\n    'custom attribute filter is applied': function(sanitize){\n      var input = '<div class=\"test\" data-custom=\"value\"></div>',\n          output = '<div class=\"test\"></div>',\n          options = {\n            attributeFilter: function(attr) {\n              if (attr.name === 'data-custom') return null;\n              return attr;\n            }\n          },\n          outcome = sanitize(input, options);\n\n      assert.equal(output, outcome);\n    }\n  },\n\n  'bleach.filter(html)': {\n    topic: function(){ return bleach.filter; },\n    'is a function': function(filter) {\n      assert.equal(typeof filter, 'function');\n    },\n    'allows array or string to be passed in': function(filter){\n      assert.doesNotThrow(function(){\n        filter([]);\n        filter('');\n      }, Error);\n    },\n    'returns a string': function(filter) {\n      assert.isString(filter(' ', 'youtube'));\n    },\n    'allow function to be passed in': function(filter){\n      var nyanFilter = function(html){\n        return 'nyan';\n      }\n      assert.equal(filter('nyannyannyan', nyanFilter), 'nyan');\n    },\n    'allow array of functions to be passed in': function(filter){\n      var filters = [\n        function(html){\n          return 'nyan';\n        },\n        function(html){\n          return html + html;\n        }\n      ];\n      assert.equal(filter('nyannyannyan', filters), 'nyannyan');\n    },\n  },\n\n  'included youtube filter': {\n    topic: function(){ return bleach.filter; },\n    'converts a youtube flash object to an iframe': function(filter){\n      var input = '<object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" width=\"420\" height=\"315\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\"><param name=\"allowFullScreen\" value=\"true\"><param name=\"allowscriptaccess\" value=\"always\"><param name=\"src\" value=\"http://www.youtube.com/v/aU079Mdkenw?version=3&amp;hl=en_US\"><param name=\"allowfullscreen\" value=\"true\"><embed type=\"application/x-shockwave-flash\" width=\"420\" height=\"315\" src=\"http://www.youtube.com/v/aU079Mdkenw?version=3&amp;hl=en_US\" allowscriptaccess=\"always\" allowfullscreen=\"true\" id=\"s_media_1_0\" name=\"s_media_1_0\"></object>',\n          output = '<iframe type=\"text/html\" frameborder=\"0\" scrolling=\"no\" allowfullscreen src=\"http://youtube.com/embed/aU079Mdkenw\"></iframe>';\n\n      assert.equal(filter(input, 'youtube'), output);\n    },\n    'ignores non-youtube flash objects': function(filter){\n      var input = '<object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" width=\"420\" height=\"315\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\"><param name=\"allowFullScreen\" value=\"true\"><param name=\"allowscriptaccess\" value=\"always\"><param name=\"src\" value=\"http://www.youtube.com/v/aU079Mdkenw?version=3&amp;hl=en_US\"><param name=\"allowfullscreen\" value=\"true\"><embed type=\"application/x-shockwave-flash\" width=\"420\" height=\"315\" src=\"http://google.com/asdf\" allowscriptaccess=\"always\" allowfullscreen=\"true\" id=\"s_media_1_0\" name=\"s_media_1_0\"></object>';\n\n      assert.equal(filter(input, 'youtube'), input);\n    },\n  }\n\n}).export(module);\n"
        }
    },
    {
        "repo": "howtocenterincss",
        "content": "'howtocenterincss/js/tests/selenium.js'\n:/* @flow */\n\nvar Options = require('../how/Options');\n\nclass SeleniumBrowser {\n  browserName: string;\n  platform: ?string;\n  version: ?string;\n  cropBoundary: {\n    addX: number;\n    addY: number;\n    cropX: number;\n    cropY: number;\n  };\n\n  constructor(browserName: string, platform: ?string, version: ?string) {\n    this.browserName = browserName;\n    this.platform = platform;\n    this.version = version;\n    this.cropBoundary = {\n      addX: 0,\n      addY: 0,\n      cropX: 0,\n      cropY: 0,\n    };\n  }\n\n  hasCropBoundary(): bool {\n    return (\n      this.cropBoundary.addX !== 0 ||\n      this.cropBoundary.addY !== 0 ||\n      this.cropBoundary.cropX !== 0 ||\n      this.cropBoundary.cropY !== 0\n    );\n  }\n\n  // Purposely mixed type. It should be opaque to the caller.\n  toSeleniumJSON(): mixed {\n    return {\n      browserName: this.browserName,\n      platform: this.platform,\n      version: this.version,\n    }\n  }\n\n  getDisplayName(): string {\n    var name = this.browserName;\n    if (this.version) {\n      name += ' ' + this.version;\n    }\n    if (this.platform) {\n      name += ' on ' + this.platform;\n    }\n    return name;\n  }\n\n  static ie11OnWindows7: SeleniumBrowser;\n  static ie10OnWindows7: SeleniumBrowser;\n  static ie9OnWindows7: SeleniumBrowser;\n  static ie8OnWindowsXP: SeleniumBrowser;\n  static ie7OnWindowsXP: SeleniumBrowser;\n  static ie6OnWindowsXP: SeleniumBrowser;\n  static chromeOnWindows8: SeleniumBrowser;\n  static firefoxOnWindows8: SeleniumBrowser;\n  static chrome: SeleniumBrowser;\n  static firefox: SeleniumBrowser;\n}\n\nSeleniumBrowser.ie11OnWindows7 = new SeleniumBrowser('internet explorer', 'Windows 7', '11');\nSeleniumBrowser.ie10OnWindows7 = new SeleniumBrowser('internet explorer', 'Windows 7', '10');\nSeleniumBrowser.ie9OnWindows7 = new SeleniumBrowser('internet explorer', 'Windows 7', '9');\nSeleniumBrowser.ie8OnWindowsXP = new SeleniumBrowser('internet explorer', 'Windows XP', '8');\nSeleniumBrowser.ie7OnWindowsXP = new SeleniumBrowser('internet explorer', 'Windows XP', '7');\nSeleniumBrowser.ie6OnWindowsXP = new SeleniumBrowser('internet explorer', 'Windows XP', '6');\nSeleniumBrowser.chromeOnWindows8 = new SeleniumBrowser('chrome', 'Windows 8', null);\nSeleniumBrowser.firefoxOnWindows8 = new SeleniumBrowser('firefox', 'Windows 8', null);\nSeleniumBrowser.chrome = new SeleniumBrowser('chrome', null, null);\nSeleniumBrowser.firefox = new SeleniumBrowser('firefox', null, null);\n\n// Piece of junk IE adds a 3D border around body that cannot be removed unless\n// the HTML has a doctype as such:\n// http://stackoverflow.com/questions/3923075/how-to-remove-3d-border-in-ie8-with-doctype-xhtml\n// JS can't modify the doctype at runtime, and selenium can't open a page with\n// specified HTML. We have to have to crop the screenshot at runtime.\n// But it's also buggy how screenshots are taken vs how many pixels of border\n// are added, because the x-axis doesn't add up. Somehow, they need twice as\n// many pixels to pad. :|\nvar ieCropBoundary = {\n  addX: 8,\n  addY: 4,\n  cropX: 2,\n  cropY: 2,\n};\n[\n  SeleniumBrowser.ie8OnWindowsXP,\n  SeleniumBrowser.ie7OnWindowsXP,\n  SeleniumBrowser.ie6OnWindowsXP,\n].forEach(browser => browser.cropBoundary = ieCropBoundary);\n\nclass SeleniumBrowserMapping {\n  browser: ?Options.Browser;\n  seleniumBrowsers: Array<SeleniumBrowser>;\n\n  constructor(\n    browser: ?Options.Browser,\n    seleniumBrowsers: Array<SeleniumBrowser>\n  ) {\n    this.browser = browser;\n    this.seleniumBrowsers = seleniumBrowsers;\n  }\n\n  getSeleniumBrowsersForBrowserSupport(\n    browserSupport: Options.BrowserSupport\n  ): Array<SeleniumBrowser> {\n    return this.seleniumBrowsers.filter(seleniumBrowser => {\n      // Run tests on browsers if it's not possible to specify support for it\n      if (!this.browser) {\n        return true;\n      }\n\n      var seleniumBrowserVersion = seleniumBrowser.version;\n      if (!seleniumBrowserVersion) {\n        return true;\n      }\n\n      var browserVersion = new Options.BrowserVersionRequired(\n        this.browser,\n        seleniumBrowserVersion\n      );\n      return browserSupport.requiresBrowserVersion(browserVersion);\n    });\n  }\n};\n\nvar sauceLabsBrowserMappings: Array<SeleniumBrowserMapping> = [\n  new SeleniumBrowserMapping(\n    Options.Browser.IE,\n    [\n      SeleniumBrowser.ie11OnWindows7,\n      SeleniumBrowser.ie10OnWindows7,\n      SeleniumBrowser.ie9OnWindows7,\n      SeleniumBrowser.ie8OnWindowsXP,\n      SeleniumBrowser.ie7OnWindowsXP,\n      SeleniumBrowser.ie6OnWindowsXP,\n    ]\n  ),\n  new SeleniumBrowserMapping(\n    null,\n    [\n      SeleniumBrowser.chromeOnWindows8,\n      SeleniumBrowser.firefoxOnWindows8,\n    ]\n  ),\n];\n\nvar localBrowserMappings: Array<SeleniumBrowserMapping> = [\n  new SeleniumBrowserMapping(\n    null,\n    [\n      SeleniumBrowser.firefox,\n    ]\n  ),\n];\n\n\nmodule.exports = {\n  SeleniumBrowserMapping: SeleniumBrowserMapping,\n  SeleniumBrowser: SeleniumBrowser,\n  sauceLabsBrowserMappings: sauceLabsBrowserMappings,\n  localBrowserMappings: localBrowserMappings,\n};\n\n'howtocenterincss/js/tests/snapshot.js'\n:/* @flow */\n\nrequire('colors');\nvar _ = require('underscore');\nvar fs = require('fs');\nvar wd = require('wd');\nvar BlinkDiff = require('blink-diff');\nvar PNGImage = require('pngjs-image');\nvar jsStringEscape = require('js-string-escape')\nvar chai = require('chai');\nvar invariant = require('invariant');\nvar tmp = require('tmp');\nvar Q = require('q');\nvar chaiAsPromised = require('chai-as-promised');\nvar findMethod = require('../how/findMethod');\n\nchai.use(chaiAsPromised);\nchai.should();\nchaiAsPromised.transferPromiseness = wd.transferPromiseness;\n\nvar testMatrix = require('./testMatrix');\nvar selenium = require('./selenium');\n\nfunction getReferenceFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getSnapshotName(test) + '.png';\n}\n\nfunction getReferenceTestHTMLFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getTestName(test) + '_test.html';\n}\n\nfunction getReferenceCodeFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getTestName(test) + '.txt';\n}\n\nwd.configureHttp({\n  timeout: 60000,\n  retryDelay: 15000,\n  retries: 5\n});\n\nvar remoteConfig = undefined;\nvar browserMappings;\nif (process.env.SAUCE_USERNAME && process.env.SAUCE_ACCESS_KEY) {\n  remoteConfig = {\n    hostname: 'ondemand.saucelabs.com',\n    port: 80,\n    username: process.env.SAUCE_USERNAME,\n    accessKey: process.env.SAUCE_ACCESS_KEY,\n  };\n  browserMappings = selenium.sauceLabsBrowserMappings;\n} else {\n  browserMappings = selenium.localBrowserMappings;\n}\n\nvar isCreatingSnapshots = !!process.env.CREATE_SNAPSHOTS;\nvar allTests = testMatrix.generateTestsForSeleniumBrowsers(\n  browserMappings\n);\n\n// browser text rendering variances\nvar SCREENSHOT_TOLERANCE = 0.000003;\n\nvar WINDOW_WIDTH = 400;\nvar WINDOW_HEIGHT = 400;\n\nvar css =\n'body, html { margin: 0; padding: 0; overflow: hidden; border: 0; }' +\n'body { font-family: arial; }' +\n// The container sizing will get overridden if the options specify it.\n'#content { background: #f00; width: 25px; height: 25px; }' +\n'#container { background: #0ff; width: 300px; height: 300px; }';\n\nvar fontSizeCSS =\n'body { font-size: ' + testMatrix.fontSize + 'px; }' +\n// By default, the browser has a 1.1-1.2em of line-height. This makes\n// calculating vertical centering different across methods.\n// TODO - this needs to be exposed as a notice to the user, or baked into the\n// code the method generates.\n'#content, #container { line-height: 1em; }' +\n'#content { background: 0 !important; }' +\n// The content sizing will get overridden if the method specifies it.\n'#content { width: auto; height: auto; }';\n\nfunction getOuterDivCSS(width, height) {\n  // For some reason, IE screenshots disregard the height of the body if there is\n  // nothing in it. We need a div to be opaquely white.\n  return '#testOuterDiv { background: white; width: ' + width + 'px; height: ' + height + 'px;}';\n}\n\n// http://www.phpied.com/dynamic-script-and-style-elements-in-ie/\nfunction getJStoInjectCSS(css: string) {\n  return (\n    'var ss1 = document.createElement(\"style\");' +\n    'var def = \"' + jsStringEscape(css) + '\";' +\n    'ss1.setAttribute(\"type\", \"text/css\");' +\n    'var hh1 = document.getElementsByTagName(\"head\")[0];' +\n    'hh1.appendChild(ss1);' +\n    'if (ss1.styleSheet) {' /*IE*/ +\n    '  ss1.styleSheet.cssText = def;' +\n    '} else {' /* errbody else */ +\n    '  var tt1 = document.createTextNode(def);' +\n    '  ss1.appendChild(tt1);' +\n    '}'\n  );\n}\n\nvar useBrowser = isCreatingSnapshots || remoteConfig;\n\nallTests.forEach(seleniumTests => {\n\n  var browser = seleniumTests.seleniumBrowser;\n  var tests = seleniumTests.tests;\n\n  global.suite('using ' + browser.getDisplayName(), () => {\n    var b;\n    var allPassed = true;\n    var windowWidth = WINDOW_WIDTH + browser.cropBoundary.addX;\n    var windowHeight = WINDOW_HEIGHT + browser.cropBoundary.addY;\n\n    global.suiteSetup(done => {\n      if (!useBrowser) {\n        done();\n        return;\n      }\n\n      b = wd.promiseChainRemote(remoteConfig);\n\n      if (process.env.SNAPSHOT_DEBUG) {\n        b.on('status', function(info) {\n            console.log(info.cyan);\n        });\n        b.on('command', function(eventType, command, response) {\n            console.log(' > ' + eventType.cyan, command, (response || '').grey);\n        });\n        b.on('http', function(meth, path, data) {\n            console.log(' > ' + meth.magenta, path, (data || '').grey);\n        });\n      }\n\n      b\n        .init(browser.toSeleniumJSON())\n        .setWindowSize(windowWidth, windowHeight)\n        .elementByTagName('html')\n        .getSize()\n        .then(size => {\n          invariant(b, 'flow');\n          // Browser titles/bars short change you, so set it so the document's\n          // 400x400.\n          return b.setWindowSize(windowWidth + (windowWidth - size.width), windowHeight + (windowHeight - size.height));\n        })\n        .nodeify(done);\n    });\n\n    global.suiteTeardown(done => {\n      if (!b) {\n        done();\n        return;\n      }\n\n      b\n        .quit()\n        .nodeify(done);\n    });\n\n    global.setup(done => {\n      if (!b) {\n        done();\n        return;\n      }\n      b\n        // Get all the browsers to render in as much standards mode as possible.\n        .get('http://dump.oliverzheng.com/doctype_html5.html')\n        .nodeify(done);\n    });\n\n    tests.forEach(t => {\n      var testName = testMatrix.getTestName(t);\n      var mochaTestName =\n        (isCreatingSnapshots ? 'Snapshot ' : 'Compare snapshot ') + testName;\n\n      global.test(mochaTestName, (done) => {\n        var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n        invariant(method, 'flow');\n        method.addIDs();\n        method.setIsTest();\n        var html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n        var canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n\n        var codeGenerated = canonicalCode.html;\n        if (canonicalCode.parentCSS) {\n          codeGenerated += '\\n\\n#parent {\\n' + canonicalCode.parentCSS + '\\n}';\n        }\n        if (canonicalCode.middleCSS) {\n          codeGenerated += '\\n\\n#middle {\\n' + canonicalCode.middleCSS + '\\n}';\n        }\n        if (canonicalCode.childCSS) {\n          codeGenerated += '\\n\\n#child {\\n' + canonicalCode.childCSS + '\\n}';\n        }\n\n        if (!useBrowser) {\n          // We only don't use the browser if we are comparing generated code\n          var referenceCode = fs.readFileSync(getReferenceCodeFilename(t), 'utf8');\n          if (referenceCode !== codeGenerated) {\n            done('Reference code not equal to code generated: ' + codeGenerated);\n          } else {\n            done();\n          }\n          return;\n        }\n\n        var cssToInject = css;\n        if (t.content.text) {\n          cssToInject += fontSizeCSS;\n        }\n\n        cssToInject += getOuterDivCSS(windowWidth, windowHeight);\n        if (isCreatingSnapshots) {\n          fs.writeFileSync(getReferenceCodeFilename(t), codeGenerated);\n        }\n        fs.writeFileSync(getReferenceTestHTMLFilename(t), '<style>' + cssToInject + '</style>' + html);\n\n        invariant(b, 'flow');\n        var insertJS =\n          'document.body.innerHTML = \"' + jsStringEscape('<div id=\"testOuterDiv\">' + html + '</div>') + '\";';\n        // In quirksmode, IE's box model stretches the height to fit the\n        // font-size. We could set 'overflow:hidden' to it, but it could mess\n        // with the actual generated code. So let's conditionally add font size\n        // when we need it.\n        var res =\n          b.execute(getJStoInjectCSS(cssToInject) + insertJS);\n\n        var referenceFilename = getReferenceFilename(t);\n        if (isCreatingSnapshots && !fs.existsSync(referenceFilename)) {\n          // Write the image for the first, compare all the ones after it to\n          // this.\n          res = res.saveScreenshot(referenceFilename);\n        } else {\n          var tmpFilename = tmp.tmpNameSync({\n            // for finding it easier in Finder\n            prefix: 'screenshot-' + Date.now() + '-' + testName + '-',\n            postfix: '.png',\n          });\n          res = res\n            .saveScreenshot(tmpFilename)\n            .then(() => {\n              tmpFilename\n              var blinkDiffOptions = {};\n              blinkDiffOptions.imageAPath = referenceFilename;\n              blinkDiffOptions.thresholdType = BlinkDiff.THRESHOLD_PERCENT;\n              if (browser.hasCropBoundary()) {\n                var image = PNGImage.readImageSync(tmpFilename);\n                image.clip(\n                  browser.cropBoundary.cropX,\n                  browser.cropBoundary.cropY,\n                  WINDOW_WIDTH,\n                  WINDOW_HEIGHT\n                );\n                blinkDiffOptions.imageB = image;\n              } else {\n                blinkDiffOptions.imageBPath = tmpFilename;\n              }\n              var blinkDiff = new BlinkDiff(blinkDiffOptions);\n              return Q.ninvoke(blinkDiff, 'run');\n            })\n            .then(result => {\n              var diff = result.differences / result.dimension;\n              var pass = diff < SCREENSHOT_TOLERANCE;\n              var deferred = Q.defer();\n              if (pass) {\n                fs.unlinkSync(tmpFilename);\n                deferred.resolve(diff);\n              } else {\n                deferred.reject(\n                  tmpFilename +\n                  ' is not equal to reference ' +\n                  referenceFilename +\n                  ', diff: ' + diff +\n                  ', tolerance: ' + SCREENSHOT_TOLERANCE\n                );\n              }\n              return deferred.promise;\n            });\n        }\n        res.nodeify(done);\n      });\n    });\n  });\n});\n\n",
        "called_code_segment": "function getReferenceFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getSnapshotName(test) + '.png';\n}",
        "invoking_code_segment": "var referenceFilename = getReferenceFilename(t);",
        "feature_description": "Add a timestamp to the reference filename to prevent overwriting during snapshot creation.",
        "detailed_feature_description": "The modification involves adding a timestamp to the reference filename when creating snapshots. This ensures that multiple snapshots do not overwrite each other. The timestamp is generated using `Date.now()` and appended to the filename. The corresponding code in #file 2 is updated to handle the new filename format.",
        "modified_complete_code": {
            "#file 1": "function getReferenceFilename(test, timestamp) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  var filename = testMatrix.getSnapshotName(test);\n  if (timestamp) {\n    filename += '_' + timestamp;\n  }\n  return SCREENSHOTS_DIR + '/' + filename + '.png';\n} #Modify",
            "#file 2": "var referenceFilename = getReferenceFilename(t, isCreatingSnapshots ? Date.now() : null); #Modify\n\nif (isCreatingSnapshots && !fs.existsSync(referenceFilename)) {\n  // Write the image for the first, compare all the ones after it to\n  // this.\n  res = res.saveScreenshot(referenceFilename);\n} else {\n  var tmpFilename = tmp.tmpNameSync({\n    // for finding it easier in Finder\n    prefix: 'screenshot-' + Date.now() + '-' + testName + '-',\n    postfix: '.png',\n  });\n  res = res\n    .saveScreenshot(tmpFilename)\n    .then(() => {\n      tmpFilename\n      var blinkDiffOptions = {};\n      blinkDiffOptions.imageAPath = referenceFilename;\n      blinkDiffOptions.thresholdType = BlinkDiff.THRESHOLD_PERCENT;\n      if (browser.hasCropBoundary()) {\n        var image = PNGImage.readImageSync(tmpFilename);\n        image.clip(\n          browser.cropBoundary.cropX,\n          browser.cropBoundary.cropY,\n          WINDOW_WIDTH,\n          WINDOW_HEIGHT\n        );\n        blinkDiffOptions.imageB = image;\n      } else {\n        blinkDiffOptions.imageBPath = tmpFilename;\n      }\n      var blinkDiff = new BlinkDiff(blinkDiffOptions);\n      return Q.ninvoke(blinkDiff, 'run');\n    })\n    .then(result => {\n      var diff = result.differences / result.dimension;\n      var pass = diff < SCREENSHOT_TOLERANCE;\n      var deferred = Q.defer();\n      if (pass) {\n        fs.unlinkSync(tmpFilename);\n        deferred.resolve(diff);\n      } else {\n        deferred.reject(\n          tmpFilename +\n          ' is not equal to reference ' +\n          referenceFilename +\n          ', diff: ' + diff +\n          ', tolerance: ' + SCREENSHOT_TOLERANCE\n        );\n      }\n      return deferred.promise;\n    });\n}"
        }
    },
    {
        "repo": "jsUri",
        "content": "'jsUri/Uri.js'\n:/*!\n * jsUri\n * https://github.com/derek-watson/jsUri\n *\n * Copyright 2013, Derek Watson\n * Released under the MIT license.\n *\n * Includes parseUri regular expressions\n * http://blog.stevenlevithan.com/archives/parseuri\n * Copyright 2007, Steven Levithan\n * Released under the MIT license.\n */\n\n /*globals define, module */\n\n(function(global) {\n\n  var re = {\n    starts_with_slashes: /^\\/+/,\n    ends_with_slashes: /\\/+$/,\n    pluses: /\\+/g,\n    query_separator: /[&;]/,\n    uri_parser: /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*)(?::([^:@\\/]*))?)?@)?(\\[[0-9a-fA-F:.]+\\]|[^:\\/?#]*)(?::(\\d+|(?=:)))?(:)?)((((?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  };\n\n  /**\n   * Define forEach for older js environments\n   * @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/forEach#Compatibility\n   */\n  if (!Array.prototype.forEach) {\n    Array.prototype.forEach = function(callback, thisArg) {\n      var T, k;\n\n      if (this == null) {\n        throw new TypeError(' this is null or not defined');\n      }\n\n      var O = Object(this);\n      var len = O.length >>> 0;\n\n      if (typeof callback !== \"function\") {\n        throw new TypeError(callback + ' is not a function');\n      }\n\n      if (arguments.length > 1) {\n        T = thisArg;\n      }\n\n      k = 0;\n\n      while (k < len) {\n        var kValue;\n        if (k in O) {\n          kValue = O[k];\n          callback.call(T, kValue, k, O);\n        }\n        k++;\n      }\n    };\n  }\n\n  /**\n   * unescape a query param value\n   * @param  {string} s encoded value\n   * @return {string}   decoded value\n   */\n  function decode(s) {\n    if (s) {\n        s = s.toString().replace(re.pluses, '%20');\n        s = decodeURIComponent(s);\n    }\n    return s;\n  }\n\n  /**\n   * Breaks a uri string down into its individual parts\n   * @param  {string} str uri\n   * @return {object}     parts\n   */\n  function parseUri(str) {\n    var parser = re.uri_parser;\n    var parserKeys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\", \"host\", \"port\", \"isColonUri\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n    var m = parser.exec(str || '');\n    var parts = {};\n\n    parserKeys.forEach(function(key, i) {\n      parts[key] = m[i] || '';\n    });\n\n    return parts;\n  }\n\n  /**\n   * Breaks a query string down into an array of key/value pairs\n   * @param  {string} str query\n   * @return {array}      array of arrays (key/value pairs)\n   */\n  function parseQuery(str) {\n    var i, ps, p, n, k, v, l;\n    var pairs = [];\n\n    if (typeof(str) === 'undefined' || str === null || str === '') {\n      return pairs;\n    }\n\n    if (str.indexOf('?') === 0) {\n      str = str.substring(1);\n    }\n\n    ps = str.toString().split(re.query_separator);\n\n    for (i = 0, l = ps.length; i < l; i++) {\n      p = ps[i];\n      n = p.indexOf('=');\n\n      if (n !== 0) {\n        k = decode(p.substring(0, n));\n        v = decode(p.substring(n + 1));\n        pairs.push(n === -1 ? [p, null] : [k, v]);\n      }\n\n    }\n    return pairs;\n  }\n\n  /**\n   * Creates a new Uri object\n   * @constructor\n   * @param {string} str\n   */\n  function Uri(str) {\n    this.uriParts = parseUri(str);\n    this.queryPairs = parseQuery(this.uriParts.query);\n    this.hasAuthorityPrefixUserPref = null;\n  }\n\n  /**\n   * Define getter/setter methods\n   */\n  ['protocol', 'userInfo', 'host', 'port', 'path', 'anchor'].forEach(function(key) {\n    Uri.prototype[key] = function(val) {\n      if (typeof val !== 'undefined') {\n        this.uriParts[key] = val;\n      }\n      return this.uriParts[key];\n    };\n  });\n\n  /**\n   * if there is no protocol, the leading // can be enabled or disabled\n   * @param  {Boolean}  val\n   * @return {Boolean}\n   */\n  Uri.prototype.hasAuthorityPrefix = function(val) {\n    if (typeof val !== 'undefined') {\n      this.hasAuthorityPrefixUserPref = val;\n    }\n\n    if (this.hasAuthorityPrefixUserPref === null) {\n      return (this.uriParts.source.indexOf('//') !== -1);\n    } else {\n      return this.hasAuthorityPrefixUserPref;\n    }\n  };\n\n  Uri.prototype.isColonUri = function (val) {\n    if (typeof val !== 'undefined') {\n      this.uriParts.isColonUri = !!val;\n    } else {\n      return !!this.uriParts.isColonUri;\n    }\n  };\n\n  /**\n   * Serializes the internal state of the query pairs\n   * @param  {string} [val]   set a new query string\n   * @return {string}         query string\n   */\n  Uri.prototype.query = function(val) {\n    var s = '', i, param, l;\n\n    if (typeof val !== 'undefined') {\n      this.queryPairs = parseQuery(val);\n    }\n\n    for (i = 0, l = this.queryPairs.length; i < l; i++) {\n      param = this.queryPairs[i];\n      if (s.length > 0) {\n        s += '&';\n      }\n      if (param[1] === null) {\n        s += param[0];\n      } else {\n        s += param[0];\n        s += '=';\n        if (typeof param[1] !== 'undefined') {\n          s += encodeURIComponent(param[1]);\n        }\n      }\n    }\n    return s.length > 0 ? '?' + s : s;\n  };\n\n  /**\n   * returns the first query param value found for the key\n   * @param  {string} key query key\n   * @return {string}     first value found for key\n   */\n  Uri.prototype.getQueryParamValue = function (key) {\n    var param, i, l;\n    for (i = 0, l = this.queryPairs.length; i < l; i++) {\n      param = this.queryPairs[i];\n      if (key === param[0]) {\n        return param[1];\n      }\n    }\n  };\n\n  /**\n   * returns an array of query param values for the key\n   * @param  {string} key query key\n   * @return {array}      array of values\n   */\n  Uri.prototype.getQueryParamValues = function (key) {\n    var arr = [], i, param, l;\n    for (i = 0, l = this.queryPairs.length; i < l; i++) {\n      param = this.queryPairs[i];\n      if (key === param[0]) {\n        arr.push(param[1]);\n      }\n    }\n    return arr;\n  };\n\n  /**\n   * removes query parameters\n   * @param  {string} key     remove values for key\n   * @param  {val}    [val]   remove a specific value, otherwise removes all\n   * @return {Uri}            returns self for fluent chaining\n   */\n  Uri.prototype.deleteQueryParam = function (key, val) {\n    var arr = [], i, param, keyMatchesFilter, valMatchesFilter, l;\n\n    for (i = 0, l = this.queryPairs.length; i < l; i++) {\n\n      param = this.queryPairs[i];\n      keyMatchesFilter = decode(param[0]) === decode(key);\n      valMatchesFilter = param[1] === val;\n\n      if ((arguments.length === 1 && !keyMatchesFilter) || (arguments.length === 2 && (!keyMatchesFilter || !valMatchesFilter))) {\n        arr.push(param);\n      }\n    }\n\n    this.queryPairs = arr;\n\n    return this;\n  };\n\n  /**\n   * adds a query parameter\n   * @param  {string}  key        add values for key\n   * @param  {string}  val        value to add\n   * @param  {integer} [index]    specific index to add the value at\n   * @return {Uri}                returns self for fluent chaining\n   */\n  Uri.prototype.addQueryParam = function (key, val, index) {\n    if (arguments.length === 3 && index !== -1) {\n      index = Math.min(index, this.queryPairs.length);\n      this.queryPairs.splice(index, 0, [key, val]);\n    } else if (arguments.length > 0) {\n      this.queryPairs.push([key, val]);\n    }\n    return this;\n  };\n\n  /**\n   * test for the existence of a query parameter\n   * @param  {string}  key        check values for key\n   * @return {Boolean}            true if key exists, otherwise false\n   */\n  Uri.prototype.hasQueryParam = function (key) {\n    var i, len = this.queryPairs.length;\n    for (i = 0; i < len; i++) {\n      if (this.queryPairs[i][0] == key)\n        return true;\n    }\n    return false;\n  };\n\n  /**\n   * replaces query param values\n   * @param  {string} key         key to replace value for\n   * @param  {string} newVal      new value\n   * @param  {string} [oldVal]    replace only one specific value (otherwise replaces all)\n   * @return {Uri}                returns self for fluent chaining\n   */\n  Uri.prototype.replaceQueryParam = function (key, newVal, oldVal) {\n    var index = -1, len = this.queryPairs.length, i, param;\n\n    if (arguments.length === 3) {\n      for (i = 0; i < len; i++) {\n        param = this.queryPairs[i];\n        if (decode(param[0]) === decode(key) && decodeURIComponent(param[1]) === decode(oldVal)) {\n          index = i;\n          break;\n        }\n      }\n      if (index >= 0) {\n        this.deleteQueryParam(key, decode(oldVal)).addQueryParam(key, newVal, index);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        param = this.queryPairs[i];\n        if (decode(param[0]) === decode(key)) {\n          index = i;\n          break;\n        }\n      }\n      this.deleteQueryParam(key);\n      this.addQueryParam(key, newVal, index);\n    }\n    return this;\n  };\n\n  /**\n   * Define fluent setter methods (setProtocol, setHasAuthorityPrefix, etc)\n   */\n  ['protocol', 'hasAuthorityPrefix', 'isColonUri', 'userInfo', 'host', 'port', 'path', 'query', 'anchor'].forEach(function(key) {\n    var method = 'set' + key.charAt(0).toUpperCase() + key.slice(1);\n    Uri.prototype[method] = function(val) {\n      this[key](val);\n      return this;\n    };\n  });\n\n  /**\n   * Scheme name, colon and doubleslash, as required\n   * @return {string} http:// or possibly just //\n   */\n  Uri.prototype.scheme = function() {\n    var s = '';\n\n    if (this.protocol()) {\n      s += this.protocol();\n      if (this.protocol().indexOf(':') !== this.protocol().length - 1) {\n        s += ':';\n      }\n      s += '//';\n    } else {\n      if (this.hasAuthorityPrefix() && this.host()) {\n        s += '//';\n      }\n    }\n\n    return s;\n  };\n\n  /**\n   * Same as Mozilla nsIURI.prePath\n   * @return {string} scheme://user:password@host:port\n   * @see  https://developer.mozilla.org/en/nsIURI\n   */\n  Uri.prototype.origin = function() {\n    var s = this.scheme();\n\n    if (this.userInfo() && this.host()) {\n      s += this.userInfo();\n      if (this.userInfo().indexOf('@') !== this.userInfo().length - 1) {\n        s += '@';\n      }\n    }\n\n    if (this.host()) {\n      s += this.host();\n      if (this.port() || (this.path() && this.path().substr(0, 1).match(/[0-9]/))) {\n        s += ':' + this.port();\n      }\n    }\n\n    return s;\n  };\n\n  /**\n   * Adds a trailing slash to the path\n   */\n  Uri.prototype.addTrailingSlash = function() {\n    var path = this.path() || '';\n\n    if (path.substr(-1) !== '/') {\n      this.path(path + '/');\n    }\n\n    return this;\n  };\n\n  /**\n   * Serializes the internal state of the Uri object\n   * @return {string}\n   */\n  Uri.prototype.toString = function() {\n    var path, s = this.origin();\n\n    if (this.isColonUri()) {\n      if (this.path()) {\n        s += ':'+this.path();\n      }\n    } else if (this.path()) {\n      path = this.path();\n      if (!(re.ends_with_slashes.test(s) || re.starts_with_slashes.test(path))) {\n        s += '/';\n      } else {\n        if (s) {\n          s.replace(re.ends_with_slashes, '/');\n        }\n        path = path.replace(re.starts_with_slashes, '/');\n      }\n      s += path;\n    } else {\n      if (this.host() && (this.query().toString() || this.anchor())) {\n        s += '/';\n      }\n    }\n    if (this.query().toString()) {\n      s += this.query().toString();\n    }\n\n    if (this.anchor()) {\n      if (this.anchor().indexOf('#') !== 0) {\n        s += '#';\n      }\n      s += this.anchor();\n    }\n\n    return s;\n  };\n\n  /**\n   * Clone a Uri object\n   * @return {Uri} duplicate copy of the Uri\n   */\n  Uri.prototype.clone = function() {\n    return new Uri(this.toString());\n  };\n\n  /**\n   * export via AMD or CommonJS, otherwise leak a global\n   */\n  if (typeof define === 'function' && define.amd) {\n    define(function() {\n      return Uri;\n    });\n  } else if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n    module.exports = Uri;\n  } else {\n    global.Uri = Uri;\n  }\n}(this));\n\n'jsUri/test/uri/query.js'\n:var assert = require('assert');\n\nvar Uri = (typeof(require) === 'function') ? require('../../Uri') : window.Uri\n\ndescribe('Uri', function() {\n  describe('query', function() {\n\n    it('correctly parses query param expressions with multiple = separators', function() {\n      var back = new Uri('?back=path/to/list?page=1').getQueryParamValue('back')\n      assert.equal(back, 'path/to/list?page=1')\n    })\n\n    describe('construction', function() {\n      var q\n\n      it('should decode entities when parsing', function(){\n        q = new Uri('?email=user%40example.com')\n        assert.equal(q.getQueryParamValue('email'), 'user@example.com')\n      })\n\n      it('should include an equal sign if there was one present without a query value', function() {\n        q = new Uri('?11=')\n        assert.equal(q.toString(), '?11=')\n      })\n\n      it('should not include an equal sign if one was not present originally', function() {\n        q = new Uri('?11')\n        assert.equal(q.toString(), '?11')\n      })\n\n      it('should preserve missing equals signs across many keys', function() {\n        q = new Uri('?11&12&13&14')\n        assert.equal(q.toString(), '?11&12&13&14')\n      })\n\n      it('should preserve missing equals signs in a mixed scenario', function() {\n        q = new Uri('?11=eleven&12=&13&14=fourteen')\n        assert.equal(q.toString(), '?11=eleven&12=&13&14=fourteen')\n      })\n\n      it('should correctly parse the uri if an @ sign is present after the host part of the url', function(){\n        q = new Uri('http://github.com/username?email=user@example.com&11=eleven')\n        assert.equal(q.host(), 'github.com')\n        assert.equal(q.path(), '/username')\n        assert.equal(q.getQueryParamValue('email'), 'user@example.com')\n        assert.equal(q.getQueryParamValue('11'), 'eleven')\n      })\n    })\n\n    describe('manipulation', function() {\n      var q\n\n      it('should return the first value for each query param', function() {\n        q = new Uri('?a=1&a=2&b=3&b=4&c=567')\n        assert.equal(q.getQueryParamValue('a'), '1')\n        assert.equal(q.getQueryParamValue('b'), '3')\n        assert.equal(q.getQueryParamValue('c'), '567')\n      })\n\n      it('should return arrays for multi-valued query params', function() {\n        q = new Uri('?a=1&a=2&b=3&b=4&c=567')\n        assert.equal(q.getQueryParamValues('a')[0], '1')\n        assert.equal(q.getQueryParamValues('a')[1], '2')\n        assert.equal(q.getQueryParamValues('b')[0], '3')\n        assert.equal(q.getQueryParamValues('b')[1], '4')\n        assert.equal(q.getQueryParamValues('c')[0], '567')\n      })\n\n      it('should be able to add a new query param to a blank url', function() {\n        q = new Uri('').addQueryParam('q', 'books')\n        assert.equal(q.toString(), '?q=books')\n      })\n\n      it('can add a query param with a value of zero', function() {\n        q = new Uri('').addQueryParam('pg', 0)\n        assert.equal(q.toString(), '?pg=0')\n      })\n\n      it('should be able to delete a query param', function() {\n        q = new Uri('?a=1&b=2&c=3&a=eh').deleteQueryParam('b')\n        assert.equal(q.toString(), '?a=1&c=3&a=eh')\n      })\n\n      it('should be able to delete a query param by value', function() {\n        q = new Uri('?a=1&b=2&c=3&a=eh').deleteQueryParam('a', 'eh')\n        assert.equal(q.toString(), '?a=1&b=2&c=3')\n      })\n\n      it('should be able to add a null valued param', function() {\n        q = new Uri('?a=1&b=2&c=3').addQueryParam('f', null)\n        assert.equal(q.toString(), '?a=1&b=2&c=3&f')\n      })\n\n      it('should be able to add an empty string valued param', function() {\n        q = new Uri('?a=1&b=2&c=3').addQueryParam('e', '')\n        assert.equal(q.toString(), '?a=1&b=2&c=3&e=')\n      })\n\n      it('should be able to add a undefined valued param as if an empty string', function() {\n        q = new Uri('?a=1&b=2&c=3').addQueryParam('d')\n        assert.equal(q.toString(), '?a=1&b=2&c=3&d=')\n      })\n\n      it('should be a noop to add an undefined-key param', function() {\n        q = new Uri('?a=1&b=2&c=3').addQueryParam()\n        assert.equal(q.toString(), '?a=1&b=2&c=3')\n      })\n\n      it('should be able to add a key and a value', function() {\n        q = new Uri('?a=1&b=2&c=3').addQueryParam('d', '4')\n        assert.equal(q.toString(), '?a=1&b=2&c=3&d=4')\n      })\n\n      it('should be able to prepend a key and a value', function() {\n        q = new Uri('?a=1&b=2&c=3').addQueryParam('d', '4', 0)\n        assert.equal(q.toString(), '?d=4&a=1&b=2&c=3')\n      })\n\n      it('should return query param values correctly', function() {\n        q = new Uri('').addQueryParam('k', 'value@example.com')\n        assert.equal(q.getQueryParamValue('k'), 'value@example.com')\n      })\n\n      it('should escape param values correctly', function() {\n        q = new Uri('http://example.com').addQueryParam('k', 'user@example.org')\n        assert.equal(q.toString(), 'http://example.com/?k=user%40example.org')\n      })\n\n      it('should be able to delete and replace a query param', function() {\n        q = new Uri('?a=1&b=2&c=3').deleteQueryParam('a').addQueryParam('a', 'eh')\n        assert.equal(q.toString(), '?b=2&c=3&a=eh')\n      })\n\n      it('should not do anything if passed no params', function() {\n        q = new Uri('?a=1&b=2&c=3').addQueryParam()\n        assert.equal(q.toString(), '?a=1&b=2&c=3')\n      })\n\n      it('should be able to directly replace a query param', function() {\n        q = new Uri('?a=1&b=2&c=3').replaceQueryParam('a', 'eh')\n        assert.equal(q.toString(), '?a=eh&b=2&c=3')\n      })\n\n      it('should remove an extra question mark', function() {\n        q = new Uri('??a=1&b=2&c=3').replaceQueryParam('a', 4)\n        assert.equal(q.toString(), '?a=4&b=2&c=3')\n      })\n\n      it('should remove a param without a key', function() {\n        q = new Uri('?=1&b=2&c=3').replaceQueryParam('a', 4)\n        assert.equal(q.toString(), '?b=2&c=3&a=4')\n      })\n\n      it('should be able to replace a query param value that does not exist', function() {\n        q = new Uri().replaceQueryParam('page', 2)\n        assert.equal(q.toString(), '?page=2')\n      })\n\n      it('should be able to replace a nonexistent query param value when others exist', function() {\n        q = new Uri('?a=1').replaceQueryParam('page', 2)\n        assert.equal(q.toString(), '?a=1&page=2')\n      })\n\n      it('should be able to replace only a query param value with a specified value', function() {\n        q = new Uri('?page=1&page=2').replaceQueryParam('page', 3, 1)\n        assert.equal(q.toString(), '?page=3&page=2')\n      })\n\n      it('should be able to replace only a query param value with a specified string value', function() {\n        q = new Uri('?a=one&a=two').replaceQueryParam('a', 'three', 'one')\n        assert.equal(q.toString(), '?a=three&a=two')\n      })\n\n      it('should be able to replace a param value with a specified value that does not exist', function() {\n        q = new Uri('?page=4&page=2').replaceQueryParam('page', 3, 1)\n        assert.equal(q.toString(), '?page=4&page=2')\n      })\n\n      it('should replace a param value with an empty value if not provided a value', function() {\n        q = new Uri('?page=4&page=2').replaceQueryParam('page')\n        assert.equal(q.toString(), '?page=')\n      })\n\n      it('should be able to handle multiple values for the same key', function() {\n        q = new Uri().addQueryParam('a', 1)\n        assert.equal(q.toString(), '?a=1')\n        assert.equal(q.getQueryParamValues('a').length, 1)\n        q.addQueryParam('a', 2)\n        assert.equal(q.toString(), '?a=1&a=2')\n        assert.equal(q.getQueryParamValues('a').length, 2)\n        q.addQueryParam('a', 3)\n        assert.equal(q.toString(), '?a=1&a=2&a=3')\n        assert.equal(q.getQueryParamValues('a').length, 3)\n        q.deleteQueryParam('a', 2)\n        assert.equal(q.toString(), '?a=1&a=3')\n        assert.equal(q.getQueryParamValues('a').length, 2)\n        q.deleteQueryParam('a')\n        assert.equal(q.toString(), '')\n        assert.equal(q.getQueryParamValues('a').length, 0)\n      })\n\n      it('should not add a trailing slash if one is already present', function () {\n        q = new Uri('stuff/').addTrailingSlash();\n        assert.equal(q.toString(), 'stuff/')\n      })\n\n      it('should add a trailing slash to an empty uri', function () {\n        q = new Uri().addTrailingSlash();\n        assert.equal(q.toString(), '/')\n      })\n    })\n\n    describe('semicolon as query param separator', function() {\n      var q\n\n      it('should replace semicolons with ampersands', function() {\n        q = new Uri('?one=1;two=2;three=3')\n        assert.equal(q.toString(), '?one=1&two=2&three=3')\n      })\n\n      it('should replace semicolons with ampersands, delete the first param and add another', function() {\n        q = new Uri('?one=1;two=2;three=3&four=4').deleteQueryParam('one').addQueryParam('test', 'val', 1)\n        assert.equal(q.toString(), '?two=2&test=val&three=3&four=4')\n      })\n    })\n\n    describe('comparing encoded vs. non or partially encoded query param keys and values', function() {\n      var q\n\n      it('is able to find the value of an encoded multiword key from a non encoded search', function() {\n        q = new Uri('?a=1&this%20is%20a%20multiword%20key=value&c=3')\n        assert.equal(q.getQueryParamValue('this is a multiword key'), 'value')\n      })\n\n      it('is able to on the fly decode an encoded param value', function() {\n        q = new Uri('?a=1&b=this%20is%20a%20multiword%20val&c=3')\n        assert.equal(q.getQueryParamValue('b'), 'this is a multiword val')\n      })\n\n      it('is able to on the fly decode a space-encoded param value', function() {\n        q = new Uri('?a=1&b=this is a multiword value&c=3')\n        assert.equal(q.getQueryParamValue('b'), 'this is a multiword value')\n      })\n\n      it('is able to on the fly decode a double-encoded param value', function() {\n        q = new Uri('?a=1&b=this%2520is%2520a%2520multiword%2520value&c=3')\n        assert.equal(q.getQueryParamValue('b'), 'this%20is%20a%20multiword%20value')\n      })\n\n      it('is able to find all value s of an encoded multiword key from a non encoded search', function() {\n        q = new Uri('?a=1&this%20is%20a%20multiword%20key=value&c=3')\n        assert.equal(q.getQueryParamValues('this is a multiword key')[0], 'value')\n      })\n\n      it('is be able to delete a multiword encoded key', function() {\n        q = new Uri('?a=1&this%20is%20a%20multiword%20key=value&c=3').deleteQueryParam('this is a multiword key')\n        assert.equal(q.toString(), '?a=1&c=3')\n      })\n\n      it('is able to replace a multiword query param', function() {\n        q = new Uri('?this is a multiword key=1').replaceQueryParam('this%20is%20a%20multiword%20key', 2)\n        assert.equal(q.toString(), '?this%20is%20a%20multiword%20key=2')\n      })\n\n      it('should be able to search for a plus-separated word pair', function() {\n        q = new Uri('?multi+word+key=true').replaceQueryParam('multi word key', 2)\n        assert.equal(q.toString(), '?multi word key=2')\n      })\n    })\n\n    describe('comparing existing or partial query params and values', function() {\n      it('is able to find (or not find) query params', function() {\n        q = new Uri('?this=that')\n        assert(q.hasQueryParam('this'))\n        assert(!q.hasQueryParam('theother'))\n      })\n\n      it('is able to test for existence of params with missing values', function() {\n        q = new Uri('?aa&bb=')\n        assert(q.hasQueryParam('aa'))\n        assert(q.hasQueryParam('bb'))\n        assert(!q.hasQueryParam('cc'))\n      })\n\n      it('should get null value for a param with no value (without \"=\")', function() {\n        q = new Uri('?aa')\n        assert.strictEqual(q.getQueryParamValue('aa'), null)\n      })\n\n      it('should get empty string value for a missing param value (with a dangling \"=\")', function() {\n        q = new Uri('?aa=')\n        assert.strictEqual(q.getQueryParamValue('aa'), '')\n      })\n\n      it('should get undefined value for a nonexistant param', function() {\n        q = new Uri('?aa=')\n        assert.strictEqual(q.getQueryParamValue('bb'), undefined)\n      })\n    })\n  })\n})\n\n",
        "called_code_segment": "function parseQuery(str) {\n  var i, ps, p, n, k, v, l;\n  var pairs = [];\n\n  if (typeof(str) === 'undefined' || str === null || str === '') {\n    return pairs;\n  }\n\n  if (str.indexOf('?') === 0) {\n    str = str.substring(1);\n  }\n\n  ps = str.toString().split(re.query_separator);\n\n  for (i = 0, l = ps.length; i < l; i++) {\n    p = ps[i];\n    n = p.indexOf('=');\n\n    if (n !== 0) {\n      k = decode(p.substring(0, n));\n      v = decode(p.substring(n + 1));\n      pairs.push(n === -1 ? [p, null] : [k, v]);\n    }\n  }\n  return pairs;\n}",
        "invoking_code_segment": "Uri.prototype.query = function(val) {\n  var s = '', i, param, l;\n\n  if (typeof val !== 'undefined') {\n    this.queryPairs = parseQuery(val);\n  }\n\n  for (i = 0, l = this.queryPairs.length; i < l; i++) {\n    param = this.queryPairs[i];\n    if (s.length > 0) {\n      s += '&';\n    }\n    if (param[1] === null) {\n      s += param[0];\n    } else {\n      s += param[0];\n      s += '=';\n      if (typeof param[1] !== 'undefined') {\n        s += encodeURIComponent(param[1]);\n      }\n    }\n  }\n  return s.length > 0 ? '?' + s : s;\n};",
        "feature_description": "Add support for sorting query parameters alphabetically.",
        "detailed_feature_description": "Modify the `parseQuery` function to sort the query parameters alphabetically before returning the `pairs` array. Update the `Uri.prototype.query` method to handle the sorted query parameters.",
        "modified_complete_code": {
            "file1": "function parseQuery(str) {\n  var i, ps, p, n, k, v, l;\n  var pairs = [];\n\n  if (typeof(str) === 'undefined' || str === null || str === '') {\n    return pairs;\n  }\n\n  if (str.indexOf('?') === 0) {\n    str = str.substring(1);\n  }\n\n  ps = str.toString().split(re.query_separator);\n\n  for (i = 0, l = ps.length; i < l; i++) {\n    p = ps[i];\n    n = p.indexOf('=');\n\n    if (n !== 0) {\n      k = decode(p.substring(0, n));\n      v = decode(p.substring(n + 1));\n      pairs.push(n === -1 ? [p, null] : [k, v]);\n    }\n  }\n\n  #Modify: Sort the pairs array alphabetically by key\n  pairs.sort(function(a, b) {\n    return a[0].localeCompare(b[0]);\n  });\n\n  return pairs;\n}",
            "file2": "Uri.prototype.query = function(val) {\n  var s = '', i, param, l;\n\n  if (typeof val !== 'undefined') {\n    this.queryPairs = parseQuery(val);\n  }\n\n  for (i = 0, l = this.queryPairs.length; i < l; i++) {\n    param = this.queryPairs[i];\n    if (s.length > 0) {\n      s += '&';\n    }\n    if (param[1] === null) {\n      s += param[0];\n    } else {\n      s += param[0];\n      s += '=';\n      if (typeof param[1] !== 'undefined') {\n        s += encodeURIComponent(param[1]);\n      }\n    }\n  }\n  return s.length > 0 ? '?' + s : s;\n};"
        }
    },
    {
        "repo": "koa-react-full-example",
        "content": "'koa-react-full-example/webpack/strategies/development.js'\n:import _ from \"lodash\";\n\nexport default (config, options) => {\n  if (options.development) {\n    config = _.extend({}, config, {\n      devtool: \"cheap-module-eval-source-map\",\n    });\n\n    return config;\n  }\n\n  return config;\n};\n\n'koa-react-full-example/webpack/strategies/index.js'\n:import development from \"./development\";\nimport version from \"./version\";\nimport optimize from \"./optimize\";\nimport style from \"./style\";\n\nexport default [\n  development,\n  optimize,\n  version,\n  style,\n];\n\n",
        "called_code_segment": "export default (config, options) => {\n  if (options.development) {\n    config = _.extend({}, config, {\n      devtool: \"cheap-module-eval-source-map\",\n    });\n\n    return config;\n  }\n\n  return config;\n};",
        "invoking_code_segment": "import development from \"./development\";\nimport version from \"./version\";\nimport optimize from \"./optimize\";\nimport style from \"./style\";\n\nexport default [\n  development,\n  optimize,\n  version,\n  style,\n];",
        "feature_description": "Add a new feature to enable hot module replacement in development mode.",
        "detailed_feature_description": "Modify the development strategy to include hot module replacement (HMR) for faster development. Update the invoking code to pass an additional option to enable HMR.",
        "modified_complete_code": {
            "file1": "export default (config, options) => {\n  if (options.development) {\n    config = _.extend({}, config, {\n      devtool: \"cheap-module-eval-source-map\",\n    });\n\n    #Modify: Add HMR configuration\n    if (options.hot) {\n      config.entry.app.push('webpack/hot/only-dev-server');\n      config.plugins.push(new webpack.HotModuleReplacementPlugin());\n    }\n\n    return config;\n  }\n\n  return config;\n};",
            "file2": "import development from \"./development\";\nimport version from \"./version\";\nimport optimize from \"./optimize\";\nimport style from \"./style\";\n\n#New: Add hot option\nconst options = {\n  development: true,\n  hot: true\n};\n\nexport default [\n  (config) => development(config, options),\n  optimize,\n  version,\n  style,\n];"
        }
    },
    {
        "repo": "cajon",
        "content": "'cajon/demo/js/view.js'\n:var model = require('./model'),\n    helper = require('./util/helper'),\n    $ = require('jquery');\n\nconsole.log('__dirname: ' + __dirname);\nconsole.log('__filename: ' + __filename);\n\nmodule.exports = {\n    render: function () {\n        return 'view.render() works';\n    },\n    model: model,\n    helper: helper,\n    $: $\n};\n\n'cajon/demo/js/lib.js'\n://Define the lib by aggregating its parts.\n\nmodule.exports = {\n    template: require('./template'),\n    model: require('./model'),\n    controller: require('./controller'),\n    view: require('./view')\n};\n\n",
        "called_code_segment": "module.exports = { render: function () { return 'view.render() works'; }, model: model, helper: helper, $: $ };",
        "invoking_code_segment": "var view = require('./view'); console.log(view.render());",
        "feature_description": "Add a new method to the view module that returns a formatted string using the model data.",
        "detailed_feature_description": "Modify the view module to include a new method called 'renderWithModel' that takes the model data and returns a formatted string. Update the invoking code in the lib module to call this new method and log the result.",
        "modified_complete_code": {
            "cajon/demo/js/view.js": "//Modify module.exports = { render: function () { return 'view.render() works'; }, renderWithModel: function (modelData) { return 'Formatted: ' + modelData.getData(); }, model: model, helper: helper, $: $ };",
            "cajon/demo/js/lib.js": "//Modify var view = require('./view'); console.log(view.render()); console.log(view.renderWithModel(view.model));"
        }
    },
    {
        "repo": "puppeteer-page-proxy",
        "content": "'puppeteer-page-proxy/src/core/proxy.js'\n:const got = require(\"got\");\nconst CookieHandler = require(\"../lib/cookies\");\nconst {setHeaders, setAgent} = require(\"../lib/options\");\nconst type = require(\"../util/types\");\n\n// Responsible for applying proxy\nconst requestHandler = async (request, proxy, overrides = {}) => {\n    // Reject non http(s) URI schemes\n    if (!request.url().startsWith(\"http\") && !request.url().startsWith(\"https\")) {\n        request.continue(); return;\n    }\n    const cookieHandler = new CookieHandler(request);\n    // Request options for GOT accounting for overrides\n    const options = {\n        cookieJar: await cookieHandler.getCookies(),\n        method: overrides.method || request.method(),\n        body: overrides.postData || request.postData(),\n        headers: overrides.headers || setHeaders(request),\n        agent: setAgent(proxy),\n        responseType: \"buffer\",\n        maxRedirects: 15,\n        throwHttpErrors: false,\n        ignoreInvalidCookies: true,\n        followRedirect: false\n    };\n    try {\n        const response = await got(overrides.url || request.url(), options);\n        // Set cookies manually because \"set-cookie\" doesn't set all cookies (?)\n        // Perhaps related to https://github.com/puppeteer/puppeteer/issues/5364\n        const setCookieHeader = response.headers[\"set-cookie\"];\n        if (setCookieHeader) {\n            await cookieHandler.setCookies(setCookieHeader);\n            response.headers[\"set-cookie\"] = undefined;\n        }\n        await request.respond({\n            status: response.statusCode,\n            headers: response.headers,\n            body: response.body\n        });\n    } catch (error) {\n        await request.abort();\n    }\n};\n\n// For reassigning proxy of page\nconst removeRequestListener = (page, listenerName) => {\n    const eventName = \"request\";\n    const listeners = page.eventsMap.get(eventName);\n    if (listeners) {\n        const i = listeners.findIndex((listener) => {\n            return listener.name === listenerName\n        });\n        listeners.splice(i, 1);\n        if (!listeners.length) {\n            page.eventsMap.delete(eventName);\n        }\n    }\n};\n\nconst useProxyPer = {\n    // Call this if request object passed\n    HTTPRequest: async (request, data) => {\n        let proxy, overrides;\n        // Separate proxy and overrides\n        if (type(data) === \"object\") {\n            if (Object.keys(data).length !== 0) {\n                proxy = data.proxy;\n                delete data.proxy;\n                overrides = data;\n            }\n        } else {proxy = data}\n        // Skip request if proxy omitted\n        if (proxy) {await requestHandler(request, proxy, overrides)}\n        else {request.continue(overrides)}\n    },\n\n    // Call this if page object passed\n    CDPPage: async (page, proxy) => {\n        await page.setRequestInterception(true);\n        const listener = \"$ppp_requestListener\";\n        removeRequestListener(page, listener);\n        const f = {[listener]: async (request) => {\n            await requestHandler(request, proxy);\n        }};\n        if (proxy) {page.on(\"request\", f[listener])}\n        else {await page.setRequestInterception(false)}\n    }\n}\n\n// Main function\nconst useProxy = async (target, data) => {\n    useProxyPer[target.constructor.name](target, data);\n};\n\nmodule.exports = useProxy;\n'puppeteer-page-proxy/src/index.js'\n:module.exports = require(\"./core/proxy\");\nmodule.exports.lookup = require(\"./core/lookup\");\n",
        "called_code_segment": "const requestHandler = async (request, proxy, overrides = {}) => {\n    // Reject non http(s) URI schemes\n    if (!request.url().startsWith(\"http\") && !request.url().startsWith(\"https\")) {\n        request.continue(); return;\n    }\n    const cookieHandler = new CookieHandler(request);\n    // Request options for GOT accounting for overrides\n    const options = {\n        cookieJar: await cookieHandler.getCookies(),\n        method: overrides.method || request.method(),\n        body: overrides.postData || request.postData(),\n        headers: overrides.headers || setHeaders(request),\n        agent: setAgent(proxy),\n        responseType: \"buffer\",\n        maxRedirects: 15,\n        throwHttpErrors: false,\n        ignoreInvalidCookies: true,\n        followRedirect: false\n    };\n    try {\n        const response = await got(overrides.url || request.url(), options);\n        // Set cookies manually because \"set-cookie\" doesn't set all cookies (?)\n        // Perhaps related to https://github.com/puppeteer/puppeteer/issues/5364\n        const setCookieHeader = response.headers[\"set-cookie\"];\n        if (setCookieHeader) {\n            await cookieHandler.setCookies(setCookieHeader);\n            response.headers[\"set-cookie\"] = undefined;\n        }\n        await request.respond({\n            status: response.statusCode,\n            headers: response.headers,\n            body: response.body\n        });\n    } catch (error) {\n        await request.abort();\n    }\n};",
        "invoking_code_segment": "const useProxyPer = {\n    // Call this if request object passed\n    HTTPRequest: async (request, data) => {\n        let proxy, overrides;\n        // Separate proxy and overrides\n        if (type(data) === \"object\") {\n            if (Object.keys(data).length !== 0) {\n                proxy = data.proxy;\n                delete data.proxy;\n                overrides = data;\n            }\n        } else {proxy = data}\n        // Skip request if proxy omitted\n        if (proxy) {await requestHandler(request, proxy, overrides)}\n        else {request.continue(overrides)}\n    },\n\n    // Call this if page object passed\n    CDPPage: async (page, proxy) => {\n        await page.setRequestInterception(true);\n        const listener = \"$ppp_requestListener\";\n        removeRequestListener(page, listener);\n        const f = {[listener]: async (request) => {\n            await requestHandler(request, proxy);\n        }};\n        if (proxy) {page.on(\"request\", f[listener])}\n        else {await page.setRequestInterception(false)}\n    }\n}",
        "feature_description": "Add support for custom error handling in the request handler.",
        "detailed_feature_description": "Modify the requestHandler function to accept an optional errorHandler function. If provided, this function will be called when an error occurs during the request. Update the invoking code to pass an errorHandler function if provided in the overrides.",
        "modified_complete_code": {
            "file1": "const requestHandler = async (request, proxy, overrides = {}) => {\n    // Reject non http(s) URI schemes\n    if (!request.url().startsWith(\"http\") && !request.url().startsWith(\"https\")) {\n        request.continue(); return;\n    }\n    const cookieHandler = new CookieHandler(request);\n    // Request options for GOT accounting for overrides\n    const options = {\n        cookieJar: await cookieHandler.getCookies(),\n        method: overrides.method || request.method(),\n        body: overrides.postData || request.postData(),\n        headers: overrides.headers || setHeaders(request),\n        agent: setAgent(proxy),\n        responseType: \"buffer\",\n        maxRedirects: 15,\n        throwHttpErrors: false,\n        ignoreInvalidCookies: true,\n        followRedirect: false\n    };\n    try {\n        const response = await got(overrides.url || request.url(), options);\n        // Set cookies manually because \"set-cookie\" doesn't set all cookies (?)\n        // Perhaps related to https://github.com/puppeteer/puppeteer/issues/5364\n        const setCookieHeader = response.headers[\"set-cookie\"];\n        if (setCookieHeader) {\n            await cookieHandler.setCookies(setCookieHeader);\n            response.headers[\"set-cookie\"] = undefined;\n        }\n        await request.respond({\n            status: response.statusCode,\n            headers: response.headers,\n            body: response.body\n        });\n    } catch (error) {\n        if (overrides.errorHandler) {\n            #Modify\n            await overrides.errorHandler(error, request);\n        } else {\n            await request.abort();\n        }\n    }\n};",
            "file2": "const useProxyPer = {\n    // Call this if request object passed\n    HTTPRequest: async (request, data) => {\n        let proxy, overrides;\n        // Separate proxy and overrides\n        if (type(data) === \"object\") {\n            if (Object.keys(data).length !== 0) {\n                proxy = data.proxy;\n                delete data.proxy;\n                overrides = data;\n            }\n        } else {proxy = data}\n        // Skip request if proxy omitted\n        if (proxy) {await requestHandler(request, proxy, overrides)}\n        else {request.continue(overrides)}\n    },\n\n    // Call this if page object passed\n    CDPPage: async (page, proxy) => {\n        await page.setRequestInterception(true);\n        const listener = \"$ppp_requestListener\";\n        removeRequestListener(page, listener);\n        const f = {[listener]: async (request) => {\n            await requestHandler(request, proxy);\n        }};\n        if (proxy) {page.on(\"request\", f[listener])}\n        else {await page.setRequestInterception(false)}\n    }\n}"
        }
    },
    {
        "repo": "ui5-ecosystem-showcase",
        "content": "'ui5-ecosystem-showcase/packages/cds-plugin-ui5/lib/applyUI5Middleware.js'\n:const path = require(\"path\");\nconst fs = require(\"fs\");\n\n/**\n * @typedef UI5AppInfo\n * @type {object}\n * @property {Array<string>} pages root path of the module\n */\n\n/**\n * @typedef applyUI5MiddlewareOptions\n * @type {object}\n * @property {string} [cwd] cwd to resolve relative config files to, e.g. \"./ui5.yaml\" or \"./ui5-workspace.yaml\" (defaults to `process.cwd()`)\n * @property {string} [basePath] base path of the UI5 application (defaults to `process.cwd()`)\n * @property {string} [configFile] name of the config file (defaults to \"ui5.yaml\")\n * @property {string} [configPath] /!\\ RESTRICTED /!\\ - path to the ui5.yaml (defaults to \"${basePath}/${configFile}\")\n * @property {string} [workspaceName] name of the workspace (defaults to \"default\" when the file at workspaceConfigPath exists)\n * @property {string} [workspaceConfigFile] name of the workspace config file (defaults to \"ui5-workspace.yaml\")\n * @property {string} [workspaceConfigPath] /!\\ RESTRICTED /!\\ - path to the ui5-workspace.yaml (defaults to \"${basePath}/${workspaceConfigFile}\")\n * @property {string} [versionOverride] Framework version to use instead of the one defined in the root project\n * @property {string} [cacheMode] /!\\ RESTRICTED /!\\ - Cache mode to use when consuming SNAPSHOT versions of a framework (one of: Default|False|Off)\n * @property {string} [log] the logger (defaults to console)\n */\n\n// inspired by https://github.com/SAP/karma-ui5/blob/main/lib/framework.js#L466-L522\n/**\n * Applies the middlewares for the UI5 application located in the given\n * root directory to the given router.\n * @param {import(\"express\").Router} router Express Router instance\n * @param {applyUI5MiddlewareOptions} options configuration options\n * @returns {UI5AppInfo} UI5 application information object\n */\nmodule.exports = async function applyUI5Middleware(router, options) {\n\tconst { graphFromPackageDependencies } = await import(\"@ui5/project/graph\");\n\tconst { createReaderCollection } = await import(\"@ui5/fs/resourceFactory\");\n\n\toptions.cwd = options.cwd || process.cwd();\n\toptions.basePath = options.basePath || process.cwd();\n\n\tconst log = options.log || console;\n\n\tconst configPath = options.configPath || options.basePath;\n\tconst configFile = options.configFile || \"ui5.yaml\";\n\tconst workspaceConfigPath = options.workspaceConfigPath || options.basePath;\n\tconst workspaceConfigFile = options.workspaceConfigFile || \"ui5-workspace.yaml\";\n\n\tconst determineConfigPath = function (configPath, configFile) {\n\t\t// ensure that the config path is absolute\n\t\tif (!path.isAbsolute(configPath)) {\n\t\t\tconfigPath = path.resolve(options.basePath, configPath);\n\t\t}\n\t\t// if the config path is a file, then we assume that this is the\n\t\t// configuration which should be used for the UI5 server middlewares\n\t\tif (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {\n\t\t\treturn configPath;\n\t\t}\n\t\t// if the configuration file is starting with ./ or ../ then we\n\t\t// resolve the configuration relative to the current working dir\n\t\t// otherwise we are resolving it relative to the config path\n\t\t// which is typically the directory of the UI5 application\n\t\tconfigPath = path.resolve(/^\\.\\.?\\//.test(configFile) ? options.cwd : configPath, configFile);\n\t\tif (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {\n\t\t\treturn configPath;\n\t\t}\n\t\t// nothing matched => no config\n\t\treturn undefined;\n\t};\n\n\tconst graph = await graphFromPackageDependencies({\n\t\tcwd: options.basePath,\n\t\trootConfigPath: determineConfigPath(configPath, configFile),\n\t\tworkspaceName: process.env[\"ui5-workspace\"] || options.workspaceName || \"default\",\n\t\tworkspaceConfigPath: determineConfigPath(workspaceConfigPath, workspaceConfigFile),\n\t\tversionOverride: options.versionOverride,\n\t\tcacheMode: options.cacheMode,\n\t});\n\n\tconst rootProject = graph.getRoot();\n\n\tconst readers = [];\n\tawait graph.traverseBreadthFirst(async function ({ project: dep }) {\n\t\tif (dep.getName() === rootProject.getName()) {\n\t\t\t// Ignore root project\n\t\t\treturn;\n\t\t}\n\t\treaders.push(dep.getReader({ style: \"runtime\" }));\n\t});\n\n\tconst dependencies = createReaderCollection({\n\t\tname: `Dependency reader collection for project ${rootProject.getName()}`,\n\t\treaders,\n\t});\n\n\tconst rootReader = rootProject.getReader({ style: \"runtime\" });\n\n\t// TODO change to ReaderCollection once duplicates are sorted out\n\tconst combo = createReaderCollection({\n\t\tname: \"server - prioritize workspace over dependencies\",\n\t\treaders: [rootReader, dependencies],\n\t});\n\tconst resources = {\n\t\trootProject: rootReader,\n\t\tdependencies: dependencies,\n\t\tall: combo,\n\t};\n\n\t// TODO: rework ui5-server API and make public\n\tconst { default: MiddlewareManager } = await import(\"@ui5/server/internal/MiddlewareManager\");\n\tconst middlewareManager = new MiddlewareManager({\n\t\tgraph,\n\t\trootProject,\n\t\tresources,\n\t\toptions: {\n\t\t\t//sendSAPTargetCSP,\n\t\t\t//serveCSPReports,\n\t\t\t//simpleIndex: true\n\t\t},\n\t});\n\tawait middlewareManager.applyMiddleware(router);\n\n\t// for Fiori elements based applications we need to invalidate the view cache\n\tconst isFioriElementsBased = rootProject.getFrameworkDependencies().find((lib) => lib.name.startsWith(\"sap.fe\"));\n\n\t// collect app pages from workspace (glob testing: https://globster.xyz/ and https://codepen.io/mrmlnc/pen/OXQjMe)\n\t//   -> but exclude the HTML fragments from the list of app pages!\n\tconst pages = (await rootReader.byGlob(\"**/!(*.fragment).{html,htm}\")).map((resource) => `${resource.getPath()}${isFioriElementsBased ? \"?sap-ui-xx-viewCache=false\" : \"\"}`);\n\n\t// collect app pages from middlewares implementing the getAppPages\n\tmiddlewareManager.middlewareExecutionOrder?.map((name) => {\n\t\tconst { middleware } = middlewareManager.middleware?.[name] || {};\n\t\tif (typeof middleware?.getAppPages === \"function\") {\n\t\t\tconst customAppPages = middleware.getAppPages();\n\t\t\tif (Array.isArray(customAppPages)) {\n\t\t\t\tpages.push(...customAppPages);\n\t\t\t} else {\n\t\t\t\tif (customAppPages) {\n\t\t\t\t\tlog.warn(`The middleware ${name} returns an unexpected value for \"getAppPages\". The value must be either undefined or string[]! Ignoring app pages from middleware!`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\tpages,\n\t};\n};\n\n'ui5-ecosystem-showcase/packages/cds-plugin-ui5/cds-plugin.js'\n:// >> IMPORTANT <<\n//\n// JEST has issues with dynamic imports and will fail when they are used,\n// e.g. in the findUI5Modules the UI5 tooling is used which is implemented\n// using ES modules. To avoid issues when running JEST tests, the plugin\n// will be disabled by default but it can be enforced with CDS_PLUGIN_UI5_ACTIVE=true\n// since JEST supports ES modules when using Node.js 21 and the experimental\n// support for VM modules via:\n//\n//   > NODE_OPTIONS=--experimental-vm-modules jest\n//\n// Details can be found in the following issue:\n//   - https://github.com/ui5-community/ui5-ecosystem-showcase/issues/901\n//\n// To disable JEST we rely on env variables (see https://jestjs.io/docs/environment-variables)\nlet skip = false;\nif (process.env.NODE_ENV === \"test\" && process.env.JEST_WORKER_ID && process.env.CDS_PLUGIN_UI5_ACTIVE !== \"true\") {\n\tconsole.log(\n\t\tprocess.env.NO_COLOR ? \"[%s] %s\" : \"\\x1b[36m[%s]\\x1b[0m \\x1b[31m%s\\x1b[0m\",\n\t\t\"cds-plugin-ui5\",\n\t\t\"Skip execution because JEST is running tests! To force the execution of the plugin set env var CDS_PLUGIN_UI5_ACTIVE=true...\",\n\t);\n\tskip = true;\n}\nif (process.env.CDS_PLUGIN_UI5_ACTIVE === \"false\") {\n\tconsole.log(process.env.NO_COLOR ? \"[%s] %s\" : \"\\x1b[36m[%s]\\x1b[0m \\x1b[31m%s\\x1b[0m\", \"cds-plugin-ui5\", \"Skip execution because it has been disabled by env var CDS_PLUGIN_UI5_ACTIVE!\");\n\tskip = true;\n}\n\n// only execute the plugin if it should not be skipped\nif (!skip) {\n\t// @sap/cds/lib/index.js#138: global.cds = cds // REVISIT: using global.cds seems wrong\n\tconst cds = global.cds || require(\"@sap/cds\"); // reuse already loaded cds!\n\n\t// add color support to the logger\n\tif (!(process.env.NO_COLOR || process.env.CDS_PLUGIN_UI5_NO_CUSTOM_LOGGER)) {\n\t\tconst LOG_COLORS = {\n\t\t\tTRACE: \"\\x1b[0m\", // default\n\t\t\tDEBUG: \"\\x1b[34m\", // blue\n\t\t\tINFO: \"\\x1b[32m\", // green\n\t\t\tWARN: \"\\x1b[33m\", // yellow\n\t\t\tERROR: \"\\x1b[31m\", // red\n\t\t};\n\t\tconst LOG_LEVEL_TO_COLOR = Object.fromEntries(Object.keys(LOG_COLORS).map((level) => [cds.log.levels[level], LOG_COLORS[level]]));\n\t\tconst LOG_LEVEL_TO_TEXT = Object.fromEntries(Object.keys(LOG_COLORS).map((level) => [cds.log.levels[level], level]));\n\t\tcds.log.format = (label, level, ...args) => {\n\t\t\treturn [\"\\x1b[36m[%s]\\x1b[0m %s[%s]\\x1b[0m %s\", label, LOG_LEVEL_TO_COLOR[level], LOG_LEVEL_TO_TEXT[level], ...args];\n\t\t};\n\t}\n\n\t// create a logger for the cds-plugin-ui5\n\tconst LOG = cds.log(\"cds-plugin-ui5\");\n\n\tconst findUI5Modules = require(\"./lib/findUI5Modules\");\n\tconst createPatchedRouter = require(\"./lib/createPatchedRouter\");\n\tconst applyUI5Middleware = require(\"./lib/applyUI5Middleware\");\n\tconst rewriteHTML = require(\"./lib/rewriteHTML\");\n\n\t// identify whether the execution should be skipped\n\tif (process.env[\"ui5-middleware-cap\"]) {\n\t\tLOG.info(\"Skip execution of plugin because is has been started via ui5-middleware-cap!\");\n\t\tskip = true;\n\t} else if (process.env[\"dev-approuter\"]) {\n\t\tLOG.info(\"Skip execution of plugin because is has been started via dev-approuter!\");\n\t\tskip = true;\n\t}\n\n\t// only hook into lifecycle if the plugin should not be skipped\n\tif (!skip) {\n\t\t// marker that the cds-plugin-ui5 plugin is running\n\t\t// to disable the ui5-middleware-cap if used in apps\n\t\tprocess.env[\"cds-plugin-ui5\"] = true;\n\n\t\tconst { dirname, join, resolve } = require(\"path\");\n\t\tconst { readFileSync, existsSync, realpathSync } = require(\"fs\");\n\t\tconst { execSync } = require(\"child_process\");\n\n\t\tconst { version: cdsPluginUI5Version } = require(`${__dirname}/package.json`);\n\n\t\t// function to resolve a module with the given paths without throwing an error\n\t\tconst resolveModule = function resolveModule(moduleName, paths) {\n\t\t\ttry {\n\t\t\t\treturn require.resolve(moduleName, { paths });\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t} catch (err) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\t// helper to find the package.json in the current dir or upwards\n\t\tconst findPackageJson = function findPackageJson(dir) {\n\t\t\tlet currentDir = dir;\n\t\t\twhile (currentDir !== resolve(currentDir, \"..\")) {\n\t\t\t\tconst packageJsonPath = join(currentDir, \"package.json\");\n\t\t\t\tif (existsSync(packageJsonPath)) {\n\t\t\t\t\treturn packageJsonPath;\n\t\t\t\t}\n\t\t\t\tcurrentDir = resolve(currentDir, \"..\");\n\t\t\t}\n\t\t\treturn undefined;\n\t\t};\n\n\t\t// find out the CDS-DK version to control the behavior of the plugin\n\t\tconst getCDSDKVersion = function getCDSDKVersion() {\n\t\t\tlet cdsDkPath = process.argv[1];\n\t\t\ttry {\n\t\t\t\tcdsDkPath = realpathSync(cdsDkPath);\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t} catch (err) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\tconst cdsDkDir = dirname(cdsDkPath);\n\t\t\tconst packageJsonPath = findPackageJson(cdsDkDir);\n\t\t\tif (packageJsonPath) {\n\t\t\t\tconst packageJson = JSON.parse(readFileSync(packageJsonPath, { encoding: \"utf-8\" }));\n\t\t\t\treturn packageJson.version;\n\t\t\t} else {\n\t\t\t\tconst moduleName = \"@sap/cds-dk\";\n\t\t\t\tlet resolvedPath = resolveModule(`${moduleName}/package.json`);\n\t\t\t\tif (!resolvedPath) {\n\t\t\t\t\tconst globalModulesPath = execSync(\"npm root -g\").toString().trim();\n\t\t\t\t\tresolvedPath = resolveModule(`${moduleName}/package.json`, [globalModulesPath]);\n\t\t\t\t}\n\t\t\t\tif (resolvedPath) {\n\t\t\t\t\tconst packageJson = JSON.parse(readFileSync(resolvedPath, { encoding: \"utf-8\" }));\n\t\t\t\t\treturn packageJson.version;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t};\n\n\t\t// get the CDS-DK version to control the behavior of the plugin\n\t\tconst cdsdkVersion = getCDSDKVersion();\n\t\tconst logVersion = function () {\n\t\t\t// logging the version of the cds-plugin-ui5\n\t\t\tLOG.info(`Running cds-plugin-ui5@${cdsPluginUI5Version} (@sap/cds-dk@${cdsdkVersion}, @sap/cds@${cds.version})`);\n\t\t\tif (global.__cds_loaded_from?.size > 1) {\n\t\t\t\tLOG.warn(\"  !! Multiple versions of @sap/cds loaded !!\");\n\t\t\t\tglobal.__cds_loaded_from.forEach((cdsPath) => {\n\t\t\t\t\tLOG.warn(`    => ${cdsPath}`);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// promise to await the bootstrap and lock the\n\t\t// served event to delay the startup a bit\n\t\tlet bootstrapped;\n\t\tconst bootstrapCompleted = new Promise((r) => {\n\t\t\tbootstrapped = r;\n\t\t});\n\n\t\t// hook into the \"served\" event to delay the startup of the\n\t\t// CDS server until the bootstrap is completed and the UI5\n\t\t// middlewares for the UI5 applications are properly available\n\t\tcds.on(\"served\", async function served(/* cdsServices */) {\n\t\t\tLOG.debug(\"served\");\n\t\t\tawait bootstrapCompleted;\n\t\t});\n\n\t\t// hook into the \"bootstrap\" event to startup the UI5 middlewares\n\t\t// for the available UI5 applications in the CDS server and its deps\n\t\tcds.on(\"bootstrap\", async function bootstrap(app) {\n\t\t\tLOG.debug(\"bootstrap\");\n\n\t\t\t// only for cds serve or serving all services the cds-plugin-ui5 is active\n\t\t\tif (cds.cli?.command === \"serve\" || cds.options?.service === \"all\") {\n\t\t\t\tconst cwd = cds.env?._home || process.cwd();\n\t\t\t\tconst ui5Modules = await findUI5Modules({ cwd, cds, LOG });\n\t\t\t\tconst { localApps, config } = ui5Modules;\n\n\t\t\t\tconst links = [];\n\n\t\t\t\t// log the version of the cds-plugin-ui5\n\t\t\t\tlogVersion();\n\n\t\t\t\t// register the UI5 modules via their own router/middlewares\n\t\t\t\tfor await (const ui5Module of ui5Modules) {\n\t\t\t\t\tconst { moduleId, mountPath, modulePath } = ui5Module;\n\n\t\t\t\t\t// mounting the Router for the UI5 application to the CDS server\n\t\t\t\t\tLOG.info(`Mounting ${mountPath} to UI5 app ${modulePath} (id=${moduleId})${config[moduleId] ? ` using config=${JSON.stringify(config[moduleId])}` : \"\"}`);\n\n\t\t\t\t\t// create a patched router\n\t\t\t\t\tconst router = await createPatchedRouter();\n\n\t\t\t\t\t// apply the UI5 middlewares to the router and\n\t\t\t\t\t// retrieve the available HTML pages\n\t\t\t\t\tconst appInfo = await applyUI5Middleware(router, {\n\t\t\t\t\t\tcwd,\n\t\t\t\t\t\tbasePath: modulePath,\n\t\t\t\t\t\t...(config[moduleId] || {}),\n\t\t\t\t\t\tLOG,\n\t\t\t\t\t});\n\n\t\t\t\t\t// register the router to the specified mount path\n\t\t\t\t\tapp.use(mountPath, router);\n\n\t\t\t\t\t// append the HTML pages to the links\n\t\t\t\t\tappInfo.pages.forEach((page) => {\n\t\t\t\t\t\tconst prefix = mountPath !== \"/\" ? mountPath : \"\";\n\t\t\t\t\t\tlinks.push(`${prefix}${page}`);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// identify whether the welcome page should be rewritten\n\t\t\t\tlet rewrite = links.length > 0;\n\n\t\t\t\t// rewrite the welcome page\n\t\t\t\tif (rewrite) {\n\t\t\t\t\t// register the custom middleware (similar like in @sap/cds/server.js)\n\t\t\t\t\tapp.get(\"/\", function appendLinksToIndex(req, res, next) {\n\t\t\t\t\t\treq._cds_plugin_ui5 = true; // marker for patched router to ignore\n\t\t\t\t\t\trewriteHTML(\n\t\t\t\t\t\t\treq,\n\t\t\t\t\t\t\tres,\n\t\t\t\t\t\t\t() => true,\n\t\t\t\t\t\t\t(doc) => {\n\t\t\t\t\t\t\t\t// the first <ul> element contains the links to the\n\t\t\t\t\t\t\t\t// application pages which is fully under control of\n\t\t\t\t\t\t\t\t// our plugin now and we keep all links to static\n\t\t\t\t\t\t\t\t// pages to ensure coop with classic apps\n\t\t\t\t\t\t\t\tconst head = doc.getElementsByTagName(\"head\")?.[0];\n\t\t\t\t\t\t\t\thead?.insertAdjacentHTML(\n\t\t\t\t\t\t\t\t\t\"beforeend\",\n\t\t\t\t\t\t\t\t\t`<style>\n\t\t\t\t\t\t\t\ta.ui5:after {\n\t\t\t\t\t\t\t\t\tcontent: \"UI5\";\n\t\t\t\t\t\t\t\t\tfont-weight: bold;\n\t\t\t\t\t\t\t\t\tfont-size: 0.5rem;\n\t\t\t\t\t\t\t\t\tvertical-align: super;\n\t\t\t\t\t\t\t\t\tmargin: 0.25rem;\n\t\t\t\t\t\t\t\t\tcolor: #1873B4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t@media (prefers-color-scheme: dark) {\n\t\t\t\t\t\t\t\t\ta.ui5:after {\n\t\t\t\t\t\t\t\t\t\tcolor: #FF5A37;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t</style>`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst ul = doc.getElementsByTagName(\"ul\")?.[0];\n\t\t\t\t\t\t\t\tif (ul) {\n\t\t\t\t\t\t\t\t\tconst newLis = [];\n\t\t\t\t\t\t\t\t\tconst lis = ul.getElementsByTagName(\"li\");\n\t\t\t\t\t\t\t\t\tlis?.forEach((li) => {\n\t\t\t\t\t\t\t\t\t\tconst appDir = li.firstChild?.text?.split(\"/\")?.[1];\n\t\t\t\t\t\t\t\t\t\tif (localApps.has(appDir)) {\n\t\t\t\t\t\t\t\t\t\t\tnewLis.push(li.toString());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tnewLis.push(\n\t\t\t\t\t\t\t\t\t\t...links.sort().map((link) => {\n\t\t\t\t\t\t\t\t\t\t\t// we remove the query parameters from the link text\n\t\t\t\t\t\t\t\t\t\t\tconst linkText = link.indexOf(\"?\") === -1 ? link : link.substr(0, link.indexOf(\"?\"));\n\t\t\t\t\t\t\t\t\t\t\t// renders a UI5 link ;-)\n\t\t\t\t\t\t\t\t\t\t\treturn `<li><a class=\"ui5\" href=\"${link}\">${linkText}</a></li>`;\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tul.innerHTML = newLis.join(\"\\n\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tLOG.warn(`Failed to inject application links into CDS index page!`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\n\t\t\t\t\t// move our middleware before the CDS index serve middleware to\n\t\t\t\t\t// allow that we can intercept the response and modify it to\n\t\t\t\t\t// inject our application pages an remove the exitsing ones\n\t\t\t\t\tconst middlewareStack = app?._router?.stack;\n\t\t\t\t\tif (Array.isArray(middlewareStack)) {\n\t\t\t\t\t\tconst cmw = middlewareStack.pop();\n\t\t\t\t\t\tconst idxOfServeStatic = middlewareStack.findIndex((layer) => layer.name === \"serveStatic\");\n\t\t\t\t\t\tif (idxOfServeStatic !== -1) {\n\t\t\t\t\t\t\tmiddlewareStack.splice(idxOfServeStatic, 0, cmw);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOG.error(`Failed to determine welcome page middleware! The links of the application pages may not work properly!`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.error(`Failed to inject application pages to welcome page! The links of the application pages may not work properly!`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG.info(\"Skip execution of plugin! The plugin is only active for 'cds serve'!\");\n\t\t\t}\n\n\t\t\t// bootstrap completed, unlock the \"served\" event\n\t\t\tbootstrapped();\n\t\t});\n\n\t\t// check if the register function for build tasks is available at the cds object\n\t\t// and if the Plugin class is available to register the cds build task to cover\n\t\t// the tracks of the cds-plugin-ui5 workspace configuration and dependencies\n\t\tconst { minVersion, satisfies } = require(\"semver\");\n\t\tif (typeof cds.build?.register === \"function\" && typeof cds.build?.Plugin?.constructor === \"function\") {\n\t\t\tconst { readFile, writeFile } = require(\"fs\").promises;\n\t\t\tconst { existsSync } = require(\"fs\");\n\t\t\tconst { join } = require(\"path\");\n\t\t\tconst util = require(\"util\");\n\t\t\tconst exec = util.promisify(require(\"child_process\").exec);\n\n\t\t\t// log the version of the cds-plugin-ui5\n\t\t\tlogVersion();\n\n\t\t\t// helper to check whether a semantic version is valid\n\t\t\tconst valid = (version) => {\n\t\t\t\ttry {\n\t\t\t\t\treturn minVersion(version) !== null;\n\t\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\t} catch (err) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// register the cds build task to sanitize the package.json and update the package-lock.json\n\t\t\tcds.build.register(\n\t\t\t\t\"ui5\",\n\t\t\t\t/**\n\t\t\t\t * CDS Build Plugin to ensure that the workspace configuration and the workspace dev\n\t\t\t\t * dependencies are removed and finally runs the npm install --package-lock-only to\n\t\t\t\t * update the package-lock.json\n\t\t\t\t */\n\t\t\t\tclass UI5Plugin extends cds.build.Plugin {\n\t\t\t\t\tstatic taskDefaults = { src: cds.env.folders.srv };\n\t\t\t\t\tstatic hasTask() {\n\t\t\t\t\t\treturn true; // plugin is a cds build task\n\t\t\t\t\t}\n\t\t\t\t\tinit() {}\n\t\t\t\t\tclean() {\n\t\t\t\t\t\tif (!satisfies(cdsdkVersion, \">=8\")) {\n\t\t\t\t\t\t\tthis._priority = -1; // hack to ensure that the task is executed last!\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tget priority() {\n\t\t\t\t\t\tif (!satisfies(cdsdkVersion, \">=8\")) {\n\t\t\t\t\t\t\treturn this._priority || 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tasync build() {\n\t\t\t\t\t\t// determine the namespace from the model\n\t\t\t\t\t\tconst model = await this.model();\n\t\t\t\t\t\tif (!model) return;\n\t\t\t\t\t\tconst namespace = model.namespace || \"<unknown>\";\n\t\t\t\t\t\t// sanitize the package.json if it exists\n\t\t\t\t\t\tconst packageJsonPath = join(this.task.dest, \"package.json\");\n\t\t\t\t\t\tif (existsSync(packageJsonPath)) {\n\t\t\t\t\t\t\tLOG.info(`Sanitizing the package.json for \"${namespace}\"...`);\n\t\t\t\t\t\t\tconst packageJson = JSON.parse(await readFile(packageJsonPath), \"utf-8\");\n\t\t\t\t\t\t\tlet modified = false;\n\t\t\t\t\t\t\t// remove the workspace configuration\n\t\t\t\t\t\t\tif (packageJson.workspaces) {\n\t\t\t\t\t\t\t\tdelete packageJson.workspaces;\n\t\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// remove the workspace dev dependencies and the cds-plugin-ui5\n\t\t\t\t\t\t\tif (packageJson.devDependencies) {\n\t\t\t\t\t\t\t\tpackageJson.devDependencies = Object.entries(packageJson.devDependencies).reduce((acc, [dep, version]) => {\n\t\t\t\t\t\t\t\t\tif (valid(version) && dep !== \"cds-plugin-ui5\") {\n\t\t\t\t\t\t\t\t\t\tacc[dep] = version;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t\t\t}, {});\n\t\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// overwrite the package.json if it was modified only\n\t\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\t\tawait writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), \"utf-8\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// update the package-lock.json if it exists\n\t\t\t\t\t\tif (existsSync(join(this.task.dest, \"package-lock.json\"))) {\n\t\t\t\t\t\t\tLOG.info(`Updating the package-lock.json for \"${namespace}\"...`);\n\t\t\t\t\t\t\t// run the npm install --package-lock-only to only update the package-lock.json\n\t\t\t\t\t\t\t// without installing the dependencies to node_modules\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t/* const { stdout, stderr } = */ await exec(\"npm install --package-lock-only\", { cwd: this.task.dest });\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tLOG.error(`Failed to update the package-lock.json for \"${namespace}\"! Error: ${e.code} - ${e.message}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\t\t} else {\n\t\t\tif (!satisfies(cdsdkVersion, \">=7.5.0\")) {\n\t\t\t\t// TODO: add error message to inform the user that the cds build task is not available\n\t\t\t\t//       and that the @sap/cds-dk version is too old to support the cds build task\n\t\t\t\tLOG.warn(\"The cds build task requires @sap/cds-dk version >= 7.5.0! Skipping execution as your @sap/cds-dk version is too old...\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
        "called_code_segment": "module.exports = async function applyUI5Middleware(router, options) {\n  const { graphFromPackageDependencies } = await import(\"@ui5/project/graph\");\n  const { createReaderCollection } = await import(\"@ui5/fs/resourceFactory\");\n  options.cwd = options.cwd || process.cwd();\n  options.basePath = options.basePath || process.cwd();\n  const log = options.log || console;\n  const configPath = options.configPath || options.basePath;\n  const configFile = options.configFile || \"ui5.yaml\";\n  const workspaceConfigPath = options.workspaceConfigPath || options.basePath;\n  const workspaceConfigFile = options.workspaceConfigFile || \"ui5-workspace.yaml\";\n  const determineConfigPath = function (configPath, configFile) {\n    if (!path.isAbsolute(configPath)) {\n      configPath = path.resolve(options.basePath, configPath);\n    }\n    if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {\n      return configPath;\n    }\n    configPath = path.resolve(/^\\.\\.?\\//.test(configFile) ? options.cwd : configPath, configFile);\n    if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {\n      return configPath;\n    }\n    return undefined;\n  };\n  const graph = await graphFromPackageDependencies({\n    cwd: options.basePath,\n    rootConfigPath: determineConfigPath(configPath, configFile),\n    workspaceName: process.env[\"ui5-workspace\"] || options.workspaceName || \"default\",\n    workspaceConfigPath: determineConfigPath(workspaceConfigPath, workspaceConfigFile),\n    versionOverride: options.versionOverride,\n    cacheMode: options.cacheMode,\n  });\n  const rootProject = graph.getRoot();\n  const readers = [];\n  await graph.traverseBreadthFirst(async function ({ project: dep }) {\n    if (dep.getName() === rootProject.getName()) {\n      return;\n    }\n    readers.push(dep.getReader({ style: \"runtime\" }));\n  });\n  const dependencies = createReaderCollection({\n    name: `Dependency reader collection for project ${rootProject.getName()}`,\n    readers,\n  });\n  const rootReader = rootProject.getReader({ style: \"runtime\" });\n  const combo = createReaderCollection({\n    name: \"server - prioritize workspace over dependencies\",\n    readers: [rootReader, dependencies],\n  });\n  const resources = {\n    rootProject: rootReader,\n    dependencies: dependencies,\n    all: combo,\n  };\n  const { default: MiddlewareManager } = await import(\"@ui5/server/internal/MiddlewareManager\");\n  const middlewareManager = new MiddlewareManager({\n    graph,\n    rootProject,\n    resources,\n    options: {\n    },\n  });\n  await middlewareManager.applyMiddleware(router);\n  const isFioriElementsBased = rootProject.getFrameworkDependencies().find((lib) => lib.name.startsWith(\"sap.fe\"));\n  const pages = (await rootReader.byGlob(\"**/!(*.fragment).{html,htm}\")).map((resource) => `${resource.getPath()}${isFioriElementsBased ? \"?sap-ui-xx-viewCache=false\" : \"\"}`);\n  middlewareManager.middlewareExecutionOrder?.map((name) => {\n    const { middleware } = middlewareManager.middleware?.[name] || {};\n    if (typeof middleware?.getAppPages === \"function\") {\n      const customAppPages = middleware.getAppPages();\n      if (Array.isArray(customAppPages)) {\n        pages.push(...customAppPages);\n      } else {\n        if (customAppPages) {\n          log.warn(`The middleware ${name} returns an unexpected value for \\\"getAppPages\\\". The value must be either undefined or string[]! Ignoring app pages from middleware!`);\n        }\n      }\n    }\n  });\n  return {\n    pages,\n  };\n};",
        "invoking_code_segment": "const applyUI5Middleware = require(\"./lib/applyUI5Middleware\");\nconst appInfo = await applyUI5Middleware(router, {\n  cwd,\n  basePath: modulePath,\n  ...(config[moduleId] || {}),\n  LOG,\n});",
        "feature_description": "Add support for custom middleware configurations.",
        "detailed_feature_description": "Modify the `applyUI5Middleware` function to accept an additional `middlewareConfig` parameter. This parameter will allow users to pass custom configurations for specific middlewares. Update the invoking code to pass the new parameter when calling `applyUI5Middleware`.",
        "modified_complete_code": {
            "file1": "module.exports = async function applyUI5Middleware(router, options, middlewareConfig) { #Modify\n  const { graphFromPackageDependencies } = await import(\"@ui5/project/graph\");\n  const { createReaderCollection } = await import(\"@ui5/fs/resourceFactory\");\n  options.cwd = options.cwd || process.cwd();\n  options.basePath = options.basePath || process.cwd();\n  const log = options.log || console;\n  const configPath = options.configPath || options.basePath;\n  const configFile = options.configFile || \"ui5.yaml\");\n  const workspaceConfigPath = options.workspaceConfigPath || options.basePath;\n  const workspaceConfigFile = options.workspaceConfigFile || \"ui5-workspace.yaml\");\n  const determineConfigPath = function (configPath, configFile) {\n    if (!path.isAbsolute(configPath)) {\n      configPath = path.resolve(options.basePath, configPath);\n    }\n    if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {\n      return configPath;\n    }\n    configPath = path.resolve(/^\\.\\.?\\//.test(configFile) ? options.cwd : configPath, configFile);\n    if (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {\n      return configPath;\n    }\n    return undefined;\n  };\n  const graph = await graphFromPackageDependencies({\n    cwd: options.basePath,\n    rootConfigPath: determineConfigPath(configPath, configFile),\n    workspaceName: process.env[\"ui5-workspace\"] || options.workspaceName || \"default\",\n    workspaceConfigPath: determineConfigPath(workspaceConfigPath, workspaceConfigFile),\n    versionOverride: options.versionOverride,\n    cacheMode: options.cacheMode,\n  });\n  const rootProject = graph.getRoot();\n  const readers = [];\n  await graph.traverseBreadthFirst(async function ({ project: dep }) {\n    if (dep.getName() === rootProject.getName()) {\n      return;\n    }\n    readers.push(dep.getReader({ style: \"runtime\" }));\n  });\n  const dependencies = createReaderCollection({\n    name: `Dependency reader collection for project ${rootProject.getName()}`,\n    readers,\n  });\n  const rootReader = rootProject.getReader({ style: \"runtime\" });\n  const combo = createReaderCollection({\n    name: \"server - prioritize workspace over dependencies\",\n    readers: [rootReader, dependencies],\n  });\n  const resources = {\n    rootProject: rootReader,\n    dependencies: dependencies,\n    all: combo,\n  };\n  const { default: MiddlewareManager } = await import(\"@ui5/server/internal/MiddlewareManager\");\n  const middlewareManager = new MiddlewareManager({\n    graph,\n    rootProject,\n    resources,\n    options: {\n    },\n  });\n  await middlewareManager.applyMiddleware(router);\n  if (middlewareConfig) { #New\n    middlewareManager.applyMiddlewareConfig(middlewareConfig); #New\n  }\n  const isFioriElementsBased = rootProject.getFrameworkDependencies().find((lib) => lib.name.startsWith(\"sap.fe\"));\n  const pages = (await rootReader.byGlob(\"**/!(*.fragment).{html,htm}\")).map((resource) => `${resource.getPath()}${isFioriElementsBased ? \"?sap-ui-xx-viewCache=false\" : \"\"}`);\n  middlewareManager.middlewareExecutionOrder?.map((name) => {\n    const { middleware } = middlewareManager.middleware?.[name] || {};\n    if (typeof middleware?.getAppPages === \"function\") {\n      const customAppPages = middleware.getAppPages();\n      if (Array.isArray(customAppPages)) {\n        pages.push(...customAppPages);\n      } else {\n        if (customAppPages) {\n          log.warn(`The middleware ${name} returns an unexpected value for \\\"getAppPages\\\". The value must be either undefined or string[]! Ignoring app pages from middleware!`);\n        }\n      }\n    }\n  });\n  return {\n    pages,\n  };\n};",
            "file2": "const applyUI5Middleware = require(\"./lib/applyUI5Middleware\");\nconst appInfo = await applyUI5Middleware(router, {\n  cwd,\n  basePath: modulePath,\n  ...(config[moduleId] || {}),\n  LOG,\n}, middlewareConfig); #Modify"
        }
    },
    {
        "repo": "cls-rtracer",
        "content": "'cls-rtracer/index.js'\n:'use strict'\n\nconst {\n  expressMiddleware,\n  fastifyPlugin,\n  fastifyMiddleware,\n  koaMiddleware,\n  koaV1Middleware,\n  hapiPlugin,\n  runWithId,\n  id\n} = require('./src/rtracer')\n\nmodule.exports = {\n  expressMiddleware,\n  fastifyPlugin,\n  fastifyMiddleware,\n  koaMiddleware,\n  koaV1Middleware,\n  hapiPlugin,\n  runWithId,\n  id\n}\n\n'cls-rtracer/samples/express.winston.js'\n:'use strict'\n\nconst rTracer = require('../index')\n\n// first - configure winston logger\n\nconst { createLogger, format, transports } = require('winston')\nconst { combine, timestamp, printf } = format\n\n// a custom format that outputs request id\nconst rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  return rid\n    ? `${info.timestamp} [request-id:${rid}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})\n\nconst logger = createLogger({\n  format: combine(\n    timestamp(),\n    rTracerFormat\n  ),\n  transports: [new transports.Console()]\n})\n\n// next - configure and start Express app\n\nconst express = require('express')\n\nconst app = express()\napp.use(rTracer.expressMiddleware())\n\napp.get('/', function (req, res) {\n  logger.info('Starting request handling')\n  fakeDbAccess()\n    .then((result) => res.json(result))\n})\n\nasync function fakeDbAccess () {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      logger.info('Logs from fakeDbAccess')\n      resolve({ message: 'Hello from cls-rtracer Express example' })\n    }, 0)\n  })\n}\n\napp.listen(3000, (err) => {\n  if (err) {\n    logger.err('The app could not start')\n  }\n  logger.info('The app is listening on 3000')\n})\n\n",
        "called_code_segment": "const rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  return rid\n    ? `${info.timestamp} [request-id:${rid}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})",
        "invoking_code_segment": "app.get('/', function (req, res) {\n  logger.info('Starting request handling')\n  fakeDbAccess()\n    .then((result) => res.json(result))\n})",
        "feature_description": "Add a new feature to log the request method and URL along with the request ID.",
        "detailed_feature_description": "Modify the rTracerFormat function to include the request method and URL in the log message. Update the logger.info call in the Express app to pass the request method and URL as part of the log message.",
        "modified_complete_code": {
            "#file 1": "const rTracer = require('../index')\n\n// first - configure winston logger\n\nconst { createLogger, format, transports } = require('winston')\nconst { combine, timestamp, printf } = format\n\n// a custom format that outputs request id, request method, and URL\n#Modify const rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  const { method, url } = info.meta || {}\n  return rid\n    ? `${info.timestamp} [request-id:${rid}] [${method} ${url}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})\n\nconst logger = createLogger({\n  format: combine(\n    timestamp(),\n    rTracerFormat\n  ),\n  transports: [new transports.Console()]\n})",
            "#file 2": "const express = require('express')\n\nconst app = express()\napp.use(rTracer.expressMiddleware())\n\napp.get('/', function (req, res) {\n  #Modify logger.info('Starting request handling', { method: req.method, url: req.originalUrl })\n  fakeDbAccess()\n    .then((result) => res.json(result))\n})\n\nasync function fakeDbAccess () {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      #Modify logger.info('Logs from fakeDbAccess', { method: 'GET', url: '/' })\n      resolve({ message: 'Hello from cls-rtracer Express example' })\n    }, 0)\n  })\n}\n\napp.listen(3000, (err) => {\n  if (err) {\n    logger.err('The app could not start')\n  }\n  logger.info('The app is listening on 3000')\n})"
        }
    },
    {
        "repo": "comments-api",
        "content": "'comments-api/src/use-cases/list-comments.js'\n:export default function makeListComments ({ commentsDb }) {\n  return async function listComments ({ postId } = {}) {\n    if (!postId) {\n      throw new Error('You must supply a post id.')\n    }\n    const comments = await commentsDb.findByPostId({\n      postId,\n      omitReplies: false\n    })\n    const nestedComments = nest(comments)\n    return nestedComments\n\n    // If this gets slow introduce caching.\n    function nest (comments) {\n      if (comments.length === 0) {\n        return comments\n      }\n      return comments.reduce((nested, comment) => {\n        comment.replies = comments.filter(\n          reply => reply.replyToId === comment.id\n        )\n        nest(comment.replies)\n        if (comment.replyToId == null) {\n          nested.push(comment)\n        }\n        return nested\n      }, [])\n    }\n  }\n}\n\n'comments-api/src/use-cases/index.js'\n:import makeAddComment from './add-comment'\nimport makeEditComment from './edit-comment'\nimport makeRemoveComment from './remove-comment'\nimport makeListComments from './list-comments'\nimport makeHandleModeration from './handle-moderation'\nimport commentsDb from '../data-access'\nimport isQuestionable from '../is-questionable'\n\nconst handleModeration = makeHandleModeration({\n  isQuestionable,\n  initiateReview: async () => {} // TODO: Make real initiate review function.\n})\nconst addComment = makeAddComment({ commentsDb, handleModeration })\nconst editComment = makeEditComment({ commentsDb, handleModeration })\nconst listComments = makeListComments({ commentsDb })\nconst removeComment = makeRemoveComment({ commentsDb })\n\nconst commentService = Object.freeze({\n  addComment,\n  editComment,\n  handleModeration,\n  listComments,\n  removeComment\n})\n\nexport default commentService\nexport { addComment, editComment, listComments, removeComment }\n\n",
        "called_code_segment": "return async function listComments ({ postId } = {}) { if (!postId) { throw new Error('You must supply a post id.') } const comments = await commentsDb.findByPostId({ postId, omitReplies: false }) const nestedComments = nest(comments) return nestedComments function nest (comments) { if (comments.length === 0) { return comments } return comments.reduce((nested, comment) => { comment.replies = comments.filter( reply => reply.replyToId === comment.id ) nest(comment.replies) if (comment.replyToId == null) { nested.push(comment) } return nested }, []) } }",
        "invoking_code_segment": "const listComments = makeListComments({ commentsDb })",
        "feature_description": "Add a feature to filter comments based on a user's role.",
        "detailed_feature_description": "Modify the listComments function to accept an additional parameter 'userRole'. If the userRole is 'admin', return all comments including those marked as 'hidden'. If the userRole is 'user', return only comments that are not marked as 'hidden'.",
        "modified_complete_code": {
            "file1": "export default function makeListComments ({ commentsDb }) { return async function listComments ({ postId, userRole } = {}) { #Modify if (!postId) { throw new Error('You must supply a post id.') } const filter = { postId, omitReplies: false } #Modify if (userRole === 'user') { filter.hidden = false } const comments = await commentsDb.findByPostId(filter) const nestedComments = nest(comments) return nestedComments function nest (comments) { if (comments.length === 0) { return comments } return comments.reduce((nested, comment) => { comment.replies = comments.filter( reply => reply.replyToId === comment.id ) nest(comment.replies) if (comment.replyToId == null) { nested.push(comment) } return nested }, []) } } }",
            "file2": "import makeAddComment from './add-comment' import makeEditComment from './edit-comment' import makeRemoveComment from './remove-comment' import makeListComments from './list-comments' import makeHandleModeration from './handle-moderation' import commentsDb from '../data-access' import isQuestionable from '../is-questionable' const handleModeration = makeHandleModeration({ isQuestionable, initiateReview: async () => {} // TODO: Make real initiate review function. }) const addComment = makeAddComment({ commentsDb, handleModeration }) const editComment = makeEditComment({ commentsDb, handleModeration }) #Modify const listComments = makeListComments({ commentsDb }) const removeComment = makeRemoveComment({ commentsDb }) const commentService = Object.freeze({ addComment, editComment, handleModeration, listComments, removeComment }) export default commentService export { addComment, editComment, listComments, removeComment } #New // Example usage of listComments with userRole const getCommentsForPost = async (postId, userRole) => { return await listComments({ postId, userRole }) }"
        }
    },
    {
        "repo": "community-edition",
        "content": "'community-edition/scripts/gatlight.js'\n:/**\n * File ops. Common. No jsPlumb specific stuff.\n */\nconst fs = require('fs');\nconst path = require('path');\n\nconst ANYTHING_PATTERN = \"**/*\";\n\nfunction PatternFilter(pattern, isDirectory) {\n\n    return (candidate) => {\n        //console.log(pattern, candidate)\n        return true;\n    }\n}\n\nfunction ExtensionFilter(extension) {\n    return (candidate) => candidate.endsWith(\".\" + extension)\n}\n\nfunction isDirectory(path) {\n    return fs.lstatSync(path).isDirectory()\n}\n\nfunction createFilter(options) {\n    options = options || {};\n    return options.filter || (options.extension ? new ExtensionFilter(options.extension) : new PatternFilter(options.pattern || ANYTHING_PATTERN));\n}\n\n/**\n * clean files from a directory, by default recursing into (and removing) subdirectories.\n * @param directory\n * @param options\n */\nfunction clean (directory, options) {\n\n    if (fs.existsSync(directory)) {\n\n        options = options || {};\n        //let filter = options.filter || new PatternFilter(options.pattern || ANYTHING_PATTERN);\n        let filter = createFilter(options);\n        let recurse = options.recurse !== false;\n\n        let _one = (dirPath, alsoRemoveDirectory) => {\n\n            fs.readdirSync(dirPath).forEach(file => {\n                let p = path.join(dirPath, file);\n\n                if (isDirectory(p)) {\n                    if (recurse && filter(file, true)) {\n                        _one(p, true);\n                    }\n                } else {\n                    if (filter(file, false)) {\n                        fs.unlinkSync(p);\n                    }\n                }\n            });\n\n            if (alsoRemoveDirectory) {\n                fs.rmdirSync(dirPath)\n            }\n        };\n\n        _one(directory);\n\n        if (options.andRemove) {\n            fs.rmdirSync(directory);\n        }\n    }\n\n}\n\nfunction rmdir(directory) {\n    clean(directory, {andRemove:true});\n}\n\nfunction exists(file) {\n    return fs.existsSync(file);\n}\n\nfunction copyDirectory (input, output, options) {\n\n    options = options || {};\n    let recurse = options.recurse !== false;\n    let includeHidden = options.hidden === true;\n\n    if (fs.existsSync(output)) {\n        clean(output, { andRemove:true });\n    }\n\n    let filter = createFilter(options);\n\n    let _one = (inputDir, outputDir) => {\n\n        fs.mkdirSync(outputDir);\n\n        fs.readdirSync(inputDir).forEach(file => {\n\n            if (filter(file)) {\n\n                let inputPath = path.join(inputDir, file);\n                if (isDirectory(inputPath)) {\n                    if (recurse) {\n                        _one(inputPath, path.join(outputDir, file));\n                    }\n                } else {\n                    if (includeHidden === true || file.indexOf(\".\") !== 0) {\n                        let outputPath = path.join(outputDir, file);\n                        console.log(\"gatlight: copying : \" + inputPath + \" to \" + outputPath);\n                        try {\n                            fs.copyFileSync(inputPath, outputPath);\n                        } catch (e) {\n                            console.log(e)\n                        }\n                    } else {\n                        console.log(\"gatlight: excluding \" + inputPath + \" due to a dot\")\n                    }\n                }\n            } else {\n                console.log(\"Filtered \" + file + \" from copy\");\n            }\n\n        });\n    };\n\n    _one(input, output);\n\n\n}\n\nfunction copy (source, target, options) {\n\n    options = options || {};\n    let filter = createFilter(options);\n\n    // for now this is just a straight single file copy\n    console.log(\"gatlight: copying : \" + source + \" to \" + target);\n    fs.copyFileSync(source, target);\n}\n\nfunction mkdir(target, silently) {\n\n    if (Array.isArray(target)) {\n        target = target.join(\"/\");\n    }\n\n    try {\n        fs.mkdirSync(target);\n    }\n    catch (e) {\n        if (!silently) {\n            console.log(\"Could not make directory `\" + target + \"` - perhaps it exists already. Not failing.\")\n        }\n    }\n}\n\nfunction mkdirs(target) {\n    const components = target.split(\"/\");\n    const stub = components.slice(0,1);\n    mkdir(stub, true);\n    for (let i = 1; i < components.length; i++) {\n        stub.push(components[i]);\n        mkdir(stub.join(\"/\"), true);\n    }\n}\n\n/**\n * Make a directory and then clean it - because if it existed already it could have stuff in it.\n * @param target\n */\nfunction mkdirClean(target) {\n    mkdir(target);\n    clean(target);\n\n}\n\nfunction ls(directory, options) {\n\n    options = options || {};\n    let filter = createFilter(options);\n\n    return fs.readdirSync(directory).filter(filter);\n}\n\nfunction lsAll(directories, options) {\n\n    options = options || {};\n    let filter = createFilter(options);\n    let out = [];\n    for (let i = 0; i < directories.length; i++) {\n        out.push.apply(out, fs.readdirSync(directories[i]).filter(filter).map(f => [f,directories[i]]));\n    }\n\n    return out;\n\n}\n\nfunction read(fileName, options) {\n    return fs.readFileSync(fileName, options);\n}\n\nfunction readString(fileName, encoding) {\n    return read(fileName, encoding || \"UTF-8\");\n}\n\nfunction write(fileName, content) {\n    fs.writeFileSync(fileName, content);\n}\n\nfunction remove(fileName, failOnError) {\n    try {\n        fs.unlinkSync(fileName);\n    }\n    catch (e) {\n        if (failOnError) {\n            throw e;\n        }\n    }\n}\n\nfunction markup(s) {\n\n    return s.replace(/\\!\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, \"<img src=\\\"$2\\\" alt=\\\"$1\\\">\")\n        .replace(/\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, \"<a href=\\\"$2\\\">$1</a>\")\n        .replace(/^######[\\s]*(.*)[\\n]*/mg, \"<h6>$1</h6>\\n\" )\n        .replace(/^#####[\\s]*(.*)[\\n]*/mg, \"<h5>$1</h5>\\n\" )\n        .replace(/^####[\\s]*(.*)[\\n]*/mg, \"<h4>$1</h4>\\n\" )\n        .replace(/^###[\\s]*(.*)[\\n]*/mg, \"<h3>$1</h3>\\n\" )\n        .replace(/^##[\\s]*(.*)[\\n]*/mg, \"<h2>$1</h2>\\n\" )\n        .replace(/^#[\\s]*(.*)[\\n]*/mg, \"<h1>$1</h1>\\n\" )\n        .replace(/```\\n([^```]*)```/mg, \"<pre>\\n$1</pre>\\n\")\n        .replace(/`([^`]*)`/mg, \"<strong>$1</strong>\")\n        .replace(/(^|\\s)_([^_]*)_(?=\\s|$)/g, \"$1<em>$2</em>\" )\n        .replace(/(^|\\s)\\*([^\\*]*)\\*(?=\\s|$)/g, \"$1<strong>$2</strong>\" )\n        .replace(/\\n---\\n/g, \"\\n<hr />\\n\")\n        .replace(/^[\\s]*-[\\s]*(.*)$/gm, \"<li>$1</li>\")\n        .replace(/(<li>.*<\\/li>)/gm, \"<ul>$1</ul>\").replace(/<\\/ul>\\n<ul>/gm, \"\").replace(/<\\/ul>/gm, \"</ul>\\n\");\n}\n\nfunction uuid() {\n    return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        let r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    }));\n}\n\nexports.copyDirectory = copyDirectory;\nexports.clean = clean;\nexports.copy = copy;\nexports.mkdir = mkdir;\nexports.mkdirs = mkdirs;\nexports.mkdirClean = mkdirClean;\nexports.rmdir = rmdir;\nexports.ls = ls;\nexports.lsAll = lsAll;\nexports.suffixFilter = function(suffix) { return function(file) { return file.endsWith(\".\" + suffix); } }\nexports.read = read;\nexports.readString = readString;\nexports.write = write;\nexports.markup = markup;\nexports.remove = remove;\nexports.rm = remove;\nexports.uuid = uuid;\nexports.exists = exists;\n\n'community-edition/scripts/copy-package-json.js'\n:const g = require(\"./gatlight\")\nconst p = require(\"../package.json\").packages\nconst v = require(\"../package.json\").version\n\nconst target = `dist/browser-ui/package.json`\ng.copy(`ts/package.json`, target)\nconst pp = JSON.parse(g.readString(target))\npp.version = v\n\ng.write(target, JSON.stringify(pp, 2, 2))\n\n\n",
        "called_code_segment": "function copyDirectory (input, output, options) {\n\n    options = options || {};\n    let recurse = options.recurse !== false;\n    let includeHidden = options.hidden === true;\n\n    if (fs.existsSync(output)) {\n        clean(output, { andRemove:true });\n    }\n\n    let filter = createFilter(options);\n\n    let _one = (inputDir, outputDir) => {\n\n        fs.mkdirSync(outputDir);\n\n        fs.readdirSync(inputDir).forEach(file => {\n\n            if (filter(file)) {\n\n                let inputPath = path.join(inputDir, file);\n                if (isDirectory(inputPath)) {\n                    if (recurse) {\n                        _one(inputPath, path.join(outputDir, file));\n                    }\n                } else {\n                    if (includeHidden === true || file.indexOf(\".\") !== 0) {\n                        let outputPath = path.join(outputDir, file);\n                        console.log(\"gatlight: copying : \" + inputPath + \" to \" + outputPath);\n                        try {\n                            fs.copyFileSync(inputPath, outputPath);\n                        } catch (e) {\n                            console.log(e)\n                        }\n                    } else {\n                        console.log(\"gatlight: excluding \" + inputPath + \" due to a dot\")\n                    }\n                }\n            } else {\n                console.log(\"Filtered \" + file + \" from copy\");\n            }\n\n        });\n    };\n\n    _one(input, output);\n}",
        "invoking_code_segment": "const target = `dist/browser-ui/package.json`\ng.copy(`ts/package.json`, target)\nconst pp = JSON.parse(g.readString(target))\npp.version = v\n\ng.write(target, JSON.stringify(pp, 2, 2))",
        "feature_description": "Add a timestamp to the copied package.json file.",
        "detailed_feature_description": "When the package.json file is copied, a timestamp will be added to the file to indicate when it was last copied. This will be done by adding a new field 'copiedAt' with the current date and time.",
        "modified_complete_code": {
            "file1": "function copyDirectory (input, output, options) {\n\n    options = options || {};\n    let recurse = options.recurse !== false;\n    let includeHidden = options.hidden === true;\n\n    if (fs.existsSync(output)) {\n        clean(output, { andRemove:true });\n    }\n\n    let filter = createFilter(options);\n\n    let _one = (inputDir, outputDir) => {\n\n        fs.mkdirSync(outputDir);\n\n        fs.readdirSync(inputDir).forEach(file => {\n\n            if (filter(file)) {\n\n                let inputPath = path.join(inputDir, file);\n                if (isDirectory(inputPath)) {\n                    if (recurse) {\n                        _one(inputPath, path.join(outputDir, file));\n                    }\n                } else {\n                    if (includeHidden === true || file.indexOf(\".\") !== 0) {\n                        let outputPath = path.join(outputDir, file);\n                        console.log(\"gatlight: copying : \" + inputPath + \" to \" + outputPath);\n                        try {\n                            fs.copyFileSync(inputPath, outputPath);\n                            #Modify if (file === 'package.json') {\n                                const pp = JSON.parse(fs.readFileSync(outputPath, 'utf8'));\n                                pp.copiedAt = new Date().toISOString();\n                                fs.writeFileSync(outputPath, JSON.stringify(pp, null, 2));\n                            }\n                        } catch (e) {\n                            console.log(e)\n                        }\n                    } else {\n                        console.log(\"gatlight: excluding \" + inputPath + \" due to a dot\")\n                    }\n                }\n            } else {\n                console.log(\"Filtered \" + file + \" from copy\");\n            }\n\n        });\n    };\n\n    _one(input, output);\n}",
            "file2": "const g = require(\"./gatlight\")\nconst p = require(\"../package.json\").packages\nconst v = require(\"../package.json\").version\n\nconst target = `dist/browser-ui/package.json`\ng.copy(`ts/package.json`, target)\nconst pp = JSON.parse(g.readString(target))\npp.version = v\n\ng.write(target, JSON.stringify(pp, 2, 2))"
        }
    },
    {
        "repo": "create-torrent",
        "content": "'create-torrent/test/fs.js'\n:import fixtures from 'webtorrent-fixtures'\nimport parseTorrent from 'parse-torrent'\nimport path from 'path'\nimport { hash } from 'uint8-util'\nimport test from 'tape'\nimport createTorrent from '../index.js'\n\ntest('create single file torrent', t => {\n  t.plan(11)\n\n  const startTime = Date.now()\n  createTorrent(fixtures.leaves.contentPath, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'Leaves of Grass by Walt Whitman.epub')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.equals(path.normalize(parsedTorrent.files[0].path), path.normalize('Leaves of Grass by Walt Whitman.epub'))\n    t.equals(parsedTorrent.files[0].length, 362017)\n\n    t.equal(parsedTorrent.length, 362017)\n    t.equal(parsedTorrent.pieceLength, 16384)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '1f9c3f59beec079715ec53324bde8569e4a0b4eb',\n      'ec42307d4ce5557b5d3964c5ef55d354cf4a6ecc',\n      '7bf1bcaf79d11fa5e0be06593c8faafc0c2ba2cf',\n      '76d71c5b01526b23007f9e9929beafc5151e6511',\n      '0931a1b44c21bf1e68b9138f90495e690dbc55f5',\n      '72e4c2944cbacf26e6b3ae8a7229d88aafa05f61',\n      'eaae6abf3f07cb6db9677cc6aded4dd3985e4586',\n      '27567fa7639f065f71b18954304aca6366729e0b',\n      '4773d77ae80caa96a524804dfe4b9bd3deaef999',\n      'c9dd51027467519d5eb2561ae2cc01467de5f643',\n      '0a60bcba24797692efa8770d23df0a830d91cb35',\n      'b3407a88baa0590dc8c9aa6a120f274367dcd867',\n      'e88e8338c572a06e3c801b29f519df532b3e76f6',\n      '70cf6aee53107f3d39378483f69cf80fa568b1ea',\n      'c53b506159e988d8bc16922d125d77d803d652c3',\n      'ca3070c16eed9172ab506d20e522ea3f1ab674b3',\n      'f923d76fe8f44ff32e372c3b376564c6fb5f0dbe',\n      '52164f03629fd1322636babb2c014b7dae582da4',\n      '1363965261e6ce12b43701f0a8c9ed1520a70eba',\n      '004400a267765f6d3dd5c7beb5bd3c75f3df2a54',\n      '560a61801147fa4ec7cf568e703acb04e5610a4d',\n      '56dcc242d03293e9446cf5e457d8eb3d9588fd90',\n      'c698de9b0dad92980906c026d8c1408fa08fe4ec'\n    ])\n\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36')\n    })\n  })\n})\n\ntest('create single file torrent from buffer', t => {\n  t.plan(1)\n\n  createTorrent(Buffer.from('blah'), { name: 'blah.txt' }, async (err, torrent) => {\n    t.error(err)\n    try {\n      await parseTorrent(torrent)\n    } catch (err) {\n      t.fail(`failed to parse created torrent: ${err.message}`)\n    }\n  })\n})\n\ntest('create multi file torrent', t => {\n  t.plan(16)\n\n  const startTime = Date.now()\n  createTorrent(fixtures.numbers.contentPath, {\n    // force piece length to 32KB so info-hash will\n    // match what transmission generated, since we use\n    // a different algo for picking piece length\n    pieceLength: 32768,\n\n    private: false // also force `private: false` to match transmission\n\n  }, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'numbers')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.deepEquals(path.normalize(parsedTorrent.files[0].path), path.normalize('numbers/1.txt'))\n    t.deepEquals(parsedTorrent.files[0].length, 1)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[1].path), path.normalize('numbers/2.txt'))\n    t.deepEquals(parsedTorrent.files[1].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[2].path), path.normalize('numbers/3.txt'))\n    t.deepEquals(parsedTorrent.files[2].length, 3)\n\n    t.equal(parsedTorrent.length, 6)\n    t.equal(parsedTorrent.info.pieces.length, 20)\n    t.equal(parsedTorrent.pieceLength, 32768)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '1f74648e50a6a6708ec54ab327a163d5536b7ced'\n    ])\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, '80562f38656b385ea78959010e51a2cc9db41ea0')\n    })\n  })\n})\n\ntest('create multi file torrent with nested directories', t => {\n  t.plan(21)\n\n  const startTime = Date.now()\n  createTorrent(fixtures.lotsOfNumbers.contentPath, {\n    // force piece length to 32KB so info-hash will\n    // match what transmission generated, since we use\n    // a different algo for picking piece length\n    pieceLength: 32768,\n\n    private: false // also force `private: false` to match transmission\n\n  }, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'lots-of-numbers')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.deepEquals(path.normalize(parsedTorrent.files[0].path), path.normalize('lots-of-numbers/big numbers/10.txt'))\n    t.deepEquals(parsedTorrent.files[0].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[1].path), path.normalize('lots-of-numbers/big numbers/11.txt'))\n    t.deepEquals(parsedTorrent.files[1].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[2].path), path.normalize('lots-of-numbers/big numbers/12.txt'))\n    t.deepEquals(parsedTorrent.files[2].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[3].path), path.normalize('lots-of-numbers/small numbers/1.txt'))\n    t.deepEquals(parsedTorrent.files[3].length, 1)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[4].path), path.normalize('lots-of-numbers/small numbers/2.txt'))\n    t.deepEquals(parsedTorrent.files[4].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[5].path), path.normalize('lots-of-numbers/small numbers/3.txt'))\n    t.deepEquals(parsedTorrent.files[5].length, 3)\n\n    t.equal(parsedTorrent.length, 12)\n    t.equal(parsedTorrent.pieceLength, 32768)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '47972f2befaee58b6f3860cd39bd56cb33a488f0'\n    ])\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, '427887e9c03e123f9c8458b1947090edf1c75baa')\n    })\n  })\n})\n\ntest('create multi file torrent with array of paths', t => {\n  t.plan(20)\n\n  const number10Path = path.join(fixtures.lotsOfNumbers.contentPath, 'big numbers', '10.txt')\n  const number11Path = path.join(fixtures.lotsOfNumbers.contentPath, 'big numbers', '11.txt')\n  const numbersPath = fixtures.numbers.contentPath\n\n  const input = [number10Path, number11Path, numbersPath]\n\n  const startTime = Date.now()\n  createTorrent(input, {\n    name: 'multi',\n\n    // force piece length to 32KB so info-hash will\n    // match what transmission generated, since we use\n    // a different algo for picking piece length\n    pieceLength: 32768,\n\n    private: false // also force `private: false` to match transmission\n\n  }, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'multi')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.deepEquals(path.normalize(parsedTorrent.files[0].path), path.normalize('multi/10.txt'))\n    t.deepEquals(parsedTorrent.files[0].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[1].path), path.normalize('multi/11.txt'))\n    t.deepEquals(parsedTorrent.files[1].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[2].path), path.normalize('multi/numbers/1.txt'))\n    t.deepEquals(parsedTorrent.files[2].length, 1)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[3].path), path.normalize('multi/numbers/2.txt'))\n    t.deepEquals(parsedTorrent.files[3].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[4].path), path.normalize('multi/numbers/3.txt'))\n    t.deepEquals(parsedTorrent.files[4].length, 3)\n\n    t.equal(parsedTorrent.length, 10)\n    t.equal(parsedTorrent.info.pieces.length, 20)\n    t.equal(parsedTorrent.pieceLength, 32768)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '1c4e1ba6da4d771ff82025d7cf76e8c368c6c3dd'\n    ])\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, 'df25a2959378892f6ddaf4a2d7e75174e09878bb')\n    })\n  })\n})\n\n'create-torrent/test/stream.js'\n:import fixtures from 'webtorrent-fixtures'\nimport fs from 'fs'\nimport parseTorrent from 'parse-torrent'\nimport path from 'path'\nimport { hash } from 'uint8-util'\nimport test from 'tape'\nimport createTorrent from '../index.js'\n\ntest('create single file torrent from a stream', t => {\n  t.plan(11)\n\n  const stream = fs.createReadStream(fixtures.leaves.contentPath)\n  stream.name = 'Leaves of Grass by Walt Whitman.epub'\n\n  const startTime = Date.now()\n  createTorrent(stream, { pieceLength: 16384 }, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'Leaves of Grass by Walt Whitman.epub')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.equals(path.normalize(parsedTorrent.files[0].path), path.normalize('Leaves of Grass by Walt Whitman.epub'))\n    t.equals(parsedTorrent.files[0].length, 362017)\n\n    t.equal(parsedTorrent.length, 362017)\n    t.equal(parsedTorrent.pieceLength, 16384)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '1f9c3f59beec079715ec53324bde8569e4a0b4eb',\n      'ec42307d4ce5557b5d3964c5ef55d354cf4a6ecc',\n      '7bf1bcaf79d11fa5e0be06593c8faafc0c2ba2cf',\n      '76d71c5b01526b23007f9e9929beafc5151e6511',\n      '0931a1b44c21bf1e68b9138f90495e690dbc55f5',\n      '72e4c2944cbacf26e6b3ae8a7229d88aafa05f61',\n      'eaae6abf3f07cb6db9677cc6aded4dd3985e4586',\n      '27567fa7639f065f71b18954304aca6366729e0b',\n      '4773d77ae80caa96a524804dfe4b9bd3deaef999',\n      'c9dd51027467519d5eb2561ae2cc01467de5f643',\n      '0a60bcba24797692efa8770d23df0a830d91cb35',\n      'b3407a88baa0590dc8c9aa6a120f274367dcd867',\n      'e88e8338c572a06e3c801b29f519df532b3e76f6',\n      '70cf6aee53107f3d39378483f69cf80fa568b1ea',\n      'c53b506159e988d8bc16922d125d77d803d652c3',\n      'ca3070c16eed9172ab506d20e522ea3f1ab674b3',\n      'f923d76fe8f44ff32e372c3b376564c6fb5f0dbe',\n      '52164f03629fd1322636babb2c014b7dae582da4',\n      '1363965261e6ce12b43701f0a8c9ed1520a70eba',\n      '004400a267765f6d3dd5c7beb5bd3c75f3df2a54',\n      '560a61801147fa4ec7cf568e703acb04e5610a4d',\n      '56dcc242d03293e9446cf5e457d8eb3d9588fd90',\n      'c698de9b0dad92980906c026d8c1408fa08fe4ec'\n    ])\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36')\n    })\n  })\n})\n\ntest('create multi file torrent with streams', t => {\n  t.plan(16)\n\n  const files = fs.readdirSync(fixtures.numbers.contentPath).map(file => {\n    const stream = fs.createReadStream(`${fixtures.numbers.contentPath}/${file}`)\n    stream.name = file\n    return stream\n  })\n\n  const startTime = Date.now()\n  createTorrent(files, {\n    // force piece length to 32KB so info-hash will\n    // match what transmission generated, since we use\n    // a different algo for picking piece length\n    pieceLength: 32768,\n\n    private: false, // also force `private: false` to match transmission\n\n    name: 'numbers'\n\n  }, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'numbers')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.deepEquals(path.normalize(parsedTorrent.files[0].path), path.normalize('numbers/1.txt'))\n    t.deepEquals(parsedTorrent.files[0].length, 1)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[1].path), path.normalize('numbers/2.txt'))\n    t.deepEquals(parsedTorrent.files[1].length, 2)\n\n    t.deepEquals(path.normalize(parsedTorrent.files[2].path), path.normalize('numbers/3.txt'))\n    t.deepEquals(parsedTorrent.files[2].length, 3)\n\n    t.equal(parsedTorrent.length, 6)\n    t.equal(parsedTorrent.info.pieces.length, 20)\n    t.equal(parsedTorrent.pieceLength, 32768)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '1f74648e50a6a6708ec54ab327a163d5536b7ced'\n    ])\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, '80562f38656b385ea78959010e51a2cc9db41ea0')\n    })\n  })\n})\n\ntest('implicit name and pieceLength for stream', t => {\n  t.plan(6)\n\n  const stream = fs.createReadStream(fixtures.leaves.contentPath)\n\n  createTorrent(stream, async (err, torrent) => {\n    t.error(err)\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.ok(parsedTorrent.name.includes('Unnamed Torrent'))\n    t.equal(parsedTorrent.pieceLength, 16384)\n\n    t.equal(parsedTorrent.files.length, 1)\n    t.ok(parsedTorrent.files[0].name.includes('Unnamed Torrent'))\n    t.ok(parsedTorrent.files[0].path.includes('Unnamed Torrent'))\n  })\n})\n\n",
        "called_code_segment": "createTorrent(fixtures.leaves.contentPath, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'Leaves of Grass by Walt Whitman.epub')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.equals(path.normalize(parsedTorrent.files[0].path), path.normalize('Leaves of Grass by Walt Whitman.epub'))\n    t.equals(parsedTorrent.files[0].length, 362017)\n\n    t.equal(parsedTorrent.length, 362017)\n    t.equal(parsedTorrent.pieceLength, 16384)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '1f9c3f59beec079715ec53324bde8569e4a0b4eb',\n      'ec42307d4ce5557b5d3964c5ef55d354cf4a6ecc',\n      '7bf1bcaf79d11fa5e0be06593c8faafc0c2ba2cf',\n      '76d71c5b01526b23007f9e9929beafc5151e6511',\n      '0931a1b44c21bf1e68b9138f90495e690dbc55f5',\n      '72e4c2944cbacf26e6b3ae8a7229d88aafa05f61',\n      'eaae6abf3f07cb6db9677cc6aded4dd3985e4586',\n      '27567fa7639f065f71b18954304aca6366729e0b',\n      '4773d77ae80caa96a524804dfe4b9bd3deaef999',\n      'c9dd51027467519d5eb2561ae2cc01467de5f643',\n      '0a60bcba24797692efa8770d23df0a830d91cb35',\n      'b3407a88baa0590dc8c9aa6a120f274367dcd867',\n      'e88e8338c572a06e3c801b29f519df532b3e76f6',\n      '70cf6aee53107f3d39378483f69cf80fa568b1ea',\n      'c53b506159e988d8bc16922d125d77d803d652c3',\n      'ca3070c16eed9172ab506d20e522ea3f1ab674b3',\n      'f923d76fe8f44ff32e372c3b376564c6fb5f0dbe',\n      '52164f03629fd1322636babb2c014b7dae582da4',\n      '1363965261e6ce12b43701f0a8c9ed1520a70eba',\n      '004400a267765f6d3dd5c7beb5bd3c75f3df2a54',\n      '560a61801147fa4ec7cf568e703acb04e5610a4d',\n      '56dcc242d03293e9446cf5e457d8eb3d9588fd90',\n      'c698de9b0dad92980906c026d8c1408fa08fe4ec'\n    ])\n\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36')\n    })\n  })",
        "invoking_code_segment": "test('create single file torrent', t => {\n  t.plan(11)\n\n  const startTime = Date.now()\n  createTorrent(fixtures.leaves.contentPath, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'Leaves of Grass by Walt Whitman.epub')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.equals(path.normalize(parsedTorrent.files[0].path), path.normalize('Leaves of Grass by Walt Whitman.epub'))\n    t.equals(parsedTorrent.files[0].length, 362017)\n\n    t.equal(parsedTorrent.length, 362017)\n    t.equal(parsedTorrent.pieceLength, 16384)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '1f9c3f59beec079715ec53324bde8569e4a0b4eb',\n      'ec42307d4ce5557b5d3964c5ef55d354cf4a6ecc',\n      '7bf1bcaf79d11fa5e0be06593c8faafc0c2ba2cf',\n      '76d71c5b01526b23007f9e9929beafc5151e6511',\n      '0931a1b44c21bf1e68b9138f90495e690dbc55f5',\n      '72e4c2944cbacf26e6b3ae8a7229d88aafa05f61',\n      'eaae6abf3f07cb6db9677cc6aded4dd3985e4586',\n      '27567fa7639f065f71b18954304aca6366729e0b',\n      '4773d77ae80caa96a524804dfe4b9bd3deaef999',\n      'c9dd51027467519d5eb2561ae2cc01467de5f643',\n      '0a60bcba24797692efa8770d23df0a830d91cb35',\n      'b3407a88baa0590dc8c9aa6a120f274367dcd867',\n      'e88e8338c572a06e3c801b29f519df532b3e76f6',\n      '70cf6aee53107f3d39378483f69cf80fa568b1ea',\n      'c53b506159e988d8bc16922d125d77d803d652c3',\n      'ca3070c16eed9172ab506d20e522ea3f1ab674b3',\n      'f923d76fe8f44ff32e372c3b376564c6fb5f0dbe',\n      '52164f03629fd1322636babb2c014b7dae582da4',\n      '1363965261e6ce12b43701f0a8c9ed1520a70eba',\n      '004400a267765f6d3dd5c7beb5bd3c75f3df2a54',\n      '560a61801147fa4ec7cf568e703acb04e5610a4d',\n      '56dcc242d03293e9446cf5e457d8eb3d9588fd90',\n      'c698de9b0dad92980906c026d8c1408fa08fe4ec'\n    ])\n\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36')\n    })\n  })\n})",
        "feature_description": "Add support for custom metadata in the torrent creation process.",
        "detailed_feature_description": "Modify the `createTorrent` function to accept an optional `metadata` parameter. This parameter will be used to add custom metadata to the torrent file. Update the corresponding test in `fs.js` to include this new parameter and verify that the custom metadata is correctly added to the torrent file.",
        "modified_complete_code": {
            "fs.js": "test('create single file torrent with custom metadata', t => {\n  t.plan(12)\n\n  const startTime = Date.now()\n  const customMetadata = {\n    'creator': 'Test Creator',\n    'comment': 'This is a test comment'\n  }\n  createTorrent(fixtures.leaves.contentPath, { metadata: customMetadata }, async (err, torrent) => {\n    t.error(err)\n\n    const parsedTorrent = await parseTorrent(torrent)\n\n    t.equals(parsedTorrent.name, 'Leaves of Grass by Walt Whitman.epub')\n\n    t.notOk(parsedTorrent.private)\n\n    t.ok(parsedTorrent.created.getTime() >= startTime, 'created time is after start time')\n\n    t.ok(Array.isArray(parsedTorrent.announce))\n\n    t.equals(path.normalize(parsedTorrent.files[0].path), path.normalize('Leaves of Grass by Walt Whitman.epub'))\n    t.equals(parsedTorrent.files[0].length, 362017)\n\n    t.equal(parsedTorrent.length, 362017)\n    t.equal(parsedTorrent.pieceLength, 16384)\n\n    t.deepEquals(parsedTorrent.pieces, [\n      '1f9c3f59beec079715ec53324bde8569e4a0b4eb',\n      'ec42307d4ce5557b5d3964c5ef55d354cf4a6ecc',\n      '7bf1bcaf79d11fa5e0be06593c8faafc0c2ba2cf',\n      '76d71c5b01526b23007f9e9929beafc5151e6511',\n      '0931a1b44c21bf1e68b9138f90495e690dbc55f5',\n      '72e4c2944cbacf26e6b3ae8a7229d88aafa05f61',\n      'eaae6abf3f07cb6db9677cc6aded4dd3985e4586',\n      '27567fa7639f065f71b18954304aca6366729e0b',\n      '4773d77ae80caa96a524804dfe4b9bd3deaef999',\n      'c9dd51027467519d5eb2561ae2cc01467de5f643',\n      '0a60bcba24797692efa8770d23df0a830d91cb35',\n      'b3407a88baa0590dc8c9aa6a120f274367dcd867',\n      'e88e8338c572a06e3c801b29f519df532b3e76f6',\n      '70cf6aee53107f3d39378483f69cf80fa568b1ea',\n      'c53b506159e988d8bc16922d125d77d803d652c3',\n      'ca3070c16eed9172ab506d20e522ea3f1ab674b3',\n      'f923d76fe8f44ff32e372c3b376564c6fb5f0dbe',\n      '52164f03629fd1322636babb2c014b7dae582da4',\n      '1363965261e6ce12b43701f0a8c9ed1520a70eba',\n      '004400a267765f6d3dd5c7beb5bd3c75f3df2a54',\n      '560a61801147fa4ec7cf568e703acb04e5610a4d',\n      '56dcc242d03293e9446cf5e457d8eb3d9588fd90',\n      'c698de9b0dad92980906c026d8c1408fa08fe4ec'\n    ])\n\n    t.deepEquals(parsedTorrent.metadata, customMetadata)\n\n    hash(parsedTorrent.infoBuffer, 'hex').then(hash => {\n      t.equals(hash, 'd2474e86c95b19b8bcfdb92bc12c9d44667cfa36')\n    })\n  })\n})",
            "create-torrent.js": "function createTorrent(input, options, callback) {\n  // Modify: Add support for custom metadata\n  const { metadata, ...otherOptions } = options || {}\n\n  // Existing code for creating the torrent\n  // ...\n\n  // New: Add custom metadata to the torrent\n  if (metadata) {\n    torrent.metadata = metadata\n  }\n\n  // Existing code for finalizing the torrent\n  // ...\n\n  callback(null, torrent)\n}"
        }
    },
    {
        "repo": "dnsjack",
        "content": "'dnsjack/index.js'\n:var EventEmitter = require('events').EventEmitter;\nvar dgram = require('dgram');\nvar net = require('net');\nvar dns = require('dns');\n\nvar bitSlice = function(b, offset, length) {\n\treturn (b >>> (7-(offset+length-1))) & ~(0xff << length);\n};\n\nvar numify = function(ip) {\n\tip = ip.split('.').map(function(n) {\n\t\treturn parseInt(n, 10);\n\t});\n\n\tvar result = 0;\n\tvar base = 1;\n\n\tfor (var i = ip.length-1; i >= 0; i--) {\n\t\tresult += ip[i]*base;\n\t\tbase *= 256;\n\t}\n\n\treturn result;\n};\n\nvar domainify = function(qname) {\n\tvar parts = [];\n\n\tfor (var i = 0; i < qname.length && qname[i];) {\n\t\tvar length = qname[i];\n\t\tvar offset = i+1;\n\n\t\tparts.push(qname.slice(offset,offset+length).toString());\n\n\t\ti = offset+length;\n\t}\n\n\treturn parts.join('.');\n};\n\nvar qnameify = function(domain) {\n\tvar qname = new Buffer(domain.length+2);\n\tvar offset = 0;\n\n\tdomain = domain.split('.');\n\n\tfor (var i = 0; i < domain.length; i++) {\n\t\tqname[offset] = domain[i].length;\n\t\tqname.write(domain[i], offset+1, domain[i].length, 'ascii');\n\t\toffset += qname[offset]+1;\n\t}\n\n\tqname[qname.length-1] = 0;\n\n\treturn qname;\n};\n\nvar functionify = function(val) {\n\treturn function(addr, callback) {\n\t\tcallback(null, val);\n\t};\n};\n\nvar parse = function(buf) {\n\tvar header = {};\n\tvar question = {};\n\tvar b = buf.slice(2,3).toString('binary', 0, 1).charCodeAt(0);\n\n\theader.id = buf.slice(0,2);\n\theader.qr = bitSlice(b,0,1);\n\theader.opcode = bitSlice(b,1,4);\n\theader.aa = bitSlice(b,5,1);\n\theader.tc = bitSlice(b,6,1);\n\theader.rd = bitSlice(b,7,1);\n\n\tb = buf.slice(3,4).toString('binary', 0, 1).charCodeAt(0);\n\n\theader.ra = bitSlice(b,0,1);\n\theader.z = bitSlice(b,1,3);\n\theader.rcode = bitSlice(b,4,4);\n\n\theader.qdcount = buf.slice(4,6);\n\theader.ancount = buf.slice(6,8);\n\theader.nscount = buf.slice(8,10);\n\theader.arcount = buf.slice(10, 12);\n\n\tquestion.qname = buf.slice(12, buf.length-4);\n\tquestion.qtype = buf.slice(buf.length-4, buf.length-2);\n\tquestion.qclass = buf.slice(buf.length-2, buf.length);\n\n\treturn {header:header, question:question};\n};\n\nvar responseBuffer = function(query) {\n\tvar question = query.question;\n\tvar header = query.header;\n\tvar qname = question.qname;\n\tvar offset = 16+qname.length;\n\tvar length = offset;\n\n    for (var i = 0; i < query.rr.length; i++) {\n\t\tlength += query.rr[i].qname.length+14;\n    }\n\n\tvar buf = new Buffer(length);\n\n\theader.id.copy(buf, 0, 0, 2);\n\n\tbuf[2] = 0x00 | header.qr << 7 | header.opcode << 3 | header.aa << 2 | header.tc << 1 | header.rd;\n\tbuf[3] = 0x00 | header.ra << 7 | header.z << 4 | header.rcode;\n\n\tbuf.writeUInt16BE(header.qdcount, 4);\n\tbuf.writeUInt16BE(header.ancount, 6);\n\tbuf.writeUInt16BE(header.nscount, 8);\n\tbuf.writeUInt16BE(header.arcount, 10);\n\n    qname.copy(buf, 12);\n\n\tquestion.qtype.copy(buf, 12+qname.length, question.qtype, 2);\n\tquestion.qclass.copy(buf, 12+qname.length+2, question.qclass, 2);\n\n\tfor (var i = 0; i < query.rr.length; i++) {\n\t\tvar rr = query.rr[i];\n\n\t\trr.qname.copy(buf, offset);\n\n\t\toffset += rr.qname.length;\n\n\t\tbuf.writeUInt16BE(rr.qtype, offset);\n\t\tbuf.writeUInt16BE(rr.qclass, offset+2);\n\t\tbuf.writeUInt32BE(rr.ttl, offset+4);\n\t\tbuf.writeUInt16BE(rr.rdlength, offset+8);\n\t\tbuf.writeUInt32BE(rr.rdata, offset+10);\n\n\t\toffset += 14;\n    }\n\n    return buf;\n};\n\nvar response = function(query, ttl, to) {\n\tvar response = {};\n\tvar header = response.header = {};\n\tvar question = response.question = {};\n\tvar rrs = resolve(query.question.qname, ttl, to);\n\n\theader.id = query.header.id;\n\theader.ancount = rrs.length;\n\n\theader.qr = 1;\n\theader.opcode = 0;\n\theader.aa = 0;\n\theader.tc = 0;\n\theader.rd = 1;\n\theader.ra = 0;\n\theader.z = 0;\n\theader.rcode = 0;\n\theader.qdcount = 1;\n\theader.nscount = 0;\n\theader.arcount = 0;\n\n\tquestion.qname = query.question.qname;\n\tquestion.qtype = query.question.qtype;\n\tquestion.qclass = query.question.qclass;\n\n\tresponse.rr = rrs;\n\n\treturn responseBuffer(response);\n};\n\nvar resolve = function(qname, ttl, to) {\n\tvar r = {};\n\n\tr.qname = qname;\n\tr.qtype = 1;\n\tr.qclass = 1;\n\tr.ttl = ttl;\n\tr.rdlength = 4;\n\tr.rdata = to;\n\n\treturn [r];\n};\n\nvar lookup = function(addr, callback) {\n\tif (net.isIP(addr)) return callback(null, addr);\n\tdns.lookup(addr, callback);\n};\n\nexports.createServer = function(proxy) {\n\tproxy = proxy || '8.8.8.8';\n\n\tvar that = new EventEmitter();\n\tvar server = dgram.createSocket('udp4');\n\tvar routes = [];\n\n\tserver.on('message', function (message, rinfo) {\n\t\tvar query = parse(message);\n\t\tvar domain = domainify(query.question.qname);\n\t\tvar route;\n\n\t\tvar routeData = {\n\t\t\tdomain: domain,\n\t\t\trinfo: rinfo\n\t\t};\n\n\t\tthat.emit('resolve', routeData);\n\n\t\tvar respond = function(buf) {\n\t\t\tserver.send(buf, 0, buf.length, rinfo.port, rinfo.address);\n\t\t};\n\n\t\tvar onerror = function(err) {\n\t\t\tthat.emit('error', err);\n\t\t};\n\n\t\tvar onproxy = function() {\n\t\t\tvar sock = dgram.createSocket('udp4');\n\n\t\t\tsock.send(message, 0, message.length, 53, proxy);\n\t\t\tsock.on('error', onerror);\n\t\t\tsock.on('message', function(response) {\n\t\t\t\trespond(response);\n\t\t\t\tsock.close();\n\t\t\t});\n\t\t};\n\n\t\tfor (var i = 0; i < routes.length; i++) {\n\t\t\tif (routes[i].pattern.test(domain)) {\n\t\t\t\troute = routes[i].route;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!route) return onproxy();\n\n\t\troute(routeData, function(err, to) {\n\t\t\tvar toIp;\n\t\t\tvar ttl;\n\n\t\t\tif (typeof to === 'string') {\n\t\t\t\ttoIp = to;\n\t\t\t\tttl = 1;\n\t\t\t}else{\n\t\t\t\ttoIp = to.ip;\n\t\t\t\tttl = to.ttl;\n\t\t\t}\n\n\t\t\tif (err) return onerror(err);\n\t\t\tif (!toIp) return onproxy();\n\n\t\t\tlookup(toIp, function(err, addr) {\n\t\t\t\tif (err) return onerror(err);\n\t\t\t\tthat.emit('route', domain, addr);\n\t\t\t\trespond(response(query, ttl, numify(addr)));\n\t\t\t});\n\t\t});\n\n\t});\n\n\tthat.route = function(pattern, route) {\n\t\tif (Array.isArray(pattern)) {\n\t\t\tpattern.forEach(function(item) {\n\t\t\t\tthat.route(item, route);\n\t\t\t});\n\t\t\treturn that;\n\t\t}\n\t\tif (typeof pattern === 'function') return that.route('*', pattern);\n\t\tif (typeof route === 'string') return that.route(pattern, functionify(route));\n\n\t\tpattern = pattern === '*' ? /.?/ : new RegExp('^'+pattern.replace(/\\./g, '\\\\.').replace(/\\*\\\\\\./g, '(.+)\\\\.')+'$', 'i');\n\t\troutes.push({pattern:pattern, route:route});\n\n\t\treturn that;\n\t};\n\n\tthat.listen = function(port) {\n\t\tserver.bind(port || 53);\n\t\treturn that;\n\t};\n\n\tthat.close = function(callback) {\n\t\tserver.close(callback);\n\t\treturn that;\n\t};\n\n\treturn that;\n};\n\n'dnsjack/examples/monitor.js'\n:var router = require('../index');\n\nvar dns = router.createServer();\n\ndns.route('example.com', '127.0.0.1');\n\ndns.on('resolve', function(domain) {\n\tconsole.log('wanna resolve ' + domain);\n});\n\ndns.listen();\n\n",
        "called_code_segment": "exports.createServer = function(proxy) {\n    proxy = proxy || '8.8.8.8';\n\n    var that = new EventEmitter();\n    var server = dgram.createSocket('udp4');\n    var routes = [];\n\n    server.on('message', function (message, rinfo) {\n        var query = parse(message);\n        var domain = domainify(query.question.qname);\n        var route;\n\n        var routeData = {\n            domain: domain,\n            rinfo: rinfo\n        };\n\n        that.emit('resolve', routeData);\n\n        var respond = function(buf) {\n            server.send(buf, 0, buf.length, rinfo.port, rinfo.address);\n        };\n\n        var onerror = function(err) {\n            that.emit('error', err);\n        };\n\n        var onproxy = function() {\n            var sock = dgram.createSocket('udp4');\n\n            sock.send(message, 0, message.length, 53, proxy);\n            sock.on('error', onerror);\n            sock.on('message', function(response) {\n                respond(response);\n                sock.close();\n            });\n        };\n\n        for (var i = 0; i < routes.length; i++) {\n            if (routes[i].pattern.test(domain)) {\n                route = routes[i].route;\n                break;\n            }\n        }\n\n        if (!route) return onproxy();\n\n        route(routeData, function(err, to) {\n            var toIp;\n            var ttl;\n\n            if (typeof to === 'string') {\n                toIp = to;\n                ttl = 1;\n            }else{\n                toIp = to.ip;\n                ttl = to.ttl;\n            }\n\n            if (err) return onerror(err);\n            if (!toIp) return onproxy();\n\n            lookup(toIp, function(err, addr) {\n                if (err) return onerror(err);\n                that.emit('route', domain, addr);\n                respond(response(query, ttl, numify(addr)));\n            });\n        });\n\n    });\n\n    that.route = function(pattern, route) {\n        if (Array.isArray(pattern)) {\n            pattern.forEach(function(item) {\n                that.route(item, route);\n            });\n            return that;\n        }\n        if (typeof pattern === 'function') return that.route('*', pattern);\n        if (typeof route === 'string') return that.route(pattern, functionify(route));\n\n        pattern = pattern === '*' ? /.?/ : new RegExp('^'+pattern.replace(/\\./g, '\\\\.').replace(/\\*\\\\\\./g, '(.+)\\\\.')+'$', 'i');\n        routes.push({pattern:pattern, route:route});\n\n        return that;\n    };\n\n    that.listen = function(port) {\n        server.bind(port || 53);\n        return that;\n    };\n\n    that.close = function(callback) {\n        server.close(callback);\n        return that;\n    };\n\n    return that;\n};",
        "invoking_code_segment": "var dns = router.createServer();\n\ndns.route('example.com', '127.0.0.1');\n\ndns.on('resolve', function(domain) {\n    console.log('wanna resolve ' + domain);\n});\n\ndns.listen();",
        "feature_description": "Add a feature to log the resolved IP address along with the domain name.",
        "detailed_feature_description": "Modify the 'route' event handler in #file 1 to log the resolved IP address along with the domain name. Update the corresponding code in #file 2 to include the new logging functionality.",
        "modified_complete_code": {
            "#file 1": "exports.createServer = function(proxy) {\n    proxy = proxy || '8.8.8.8';\n\n    var that = new EventEmitter();\n    var server = dgram.createSocket('udp4');\n    var routes = [];\n\n    server.on('message', function (message, rinfo) {\n        var query = parse(message);\n        var domain = domainify(query.question.qname);\n        var route;\n\n        var routeData = {\n            domain: domain,\n            rinfo: rinfo\n        };\n\n        that.emit('resolve', routeData);\n\n        var respond = function(buf) {\n            server.send(buf, 0, buf.length, rinfo.port, rinfo.address);\n        };\n\n        var onerror = function(err) {\n            that.emit('error', err);\n        };\n\n        var onproxy = function() {\n            var sock = dgram.createSocket('udp4');\n\n            sock.send(message, 0, message.length, 53, proxy);\n            sock.on('error', onerror);\n            sock.on('message', function(response) {\n                respond(response);\n                sock.close();\n            });\n        };\n\n        for (var i = 0; i < routes.length; i++) {\n            if (routes[i].pattern.test(domain)) {\n                route = routes[i].route;\n                break;\n            }\n        }\n\n        if (!route) return onproxy();\n\n        route(routeData, function(err, to) {\n            var toIp;\n            var ttl;\n\n            if (typeof to === 'string') {\n                toIp = to;\n                ttl = 1;\n            }else{\n                toIp = to.ip;\n                ttl = to.ttl;\n            }\n\n            if (err) return onerror(err);\n            if (!toIp) return onproxy();\n\n            lookup(toIp, function(err, addr) {\n                if (err) return onerror(err);\n                that.emit('route', domain, addr);\n                #Modify: Log the resolved IP address along with the domain name\n                console.log('Resolved ' + domain + ' to ' + addr);\n                respond(response(query, ttl, numify(addr)));\n            });\n        });\n\n    });\n\n    that.route = function(pattern, route) {\n        if (Array.isArray(pattern)) {\n            pattern.forEach(function(item) {\n                that.route(item, route);\n            });\n            return that;\n        }\n        if (typeof pattern === 'function') return that.route('*', pattern);\n        if (typeof route === 'string') return that.route(pattern, functionify(route));\n\n        pattern = pattern === '*' ? /.?/ : new RegExp('^'+pattern.replace(/\\./g, '\\\\.').replace(/\\*\\\\\\./g, '(.+)\\\\.')+'$', 'i');\n        routes.push({pattern:pattern, route:route});\n\n        return that;\n    };\n\n    that.listen = function(port) {\n        server.bind(port || 53);\n        return that;\n    };\n\n    that.close = function(callback) {\n        server.close(callback);\n        return that;\n    };\n\n    return that;\n};",
            "#file 2": "var dns = router.createServer();\n\ndns.route('example.com', '127.0.0.1');\n\ndns.on('resolve', function(domain) {\n    console.log('wanna resolve ' + domain);\n});\n\n#New: Add a new event handler to log the resolved IP address along with the domain name\ndns.on('route', function(domain, addr) {\n    console.log('Resolved ' + domain + ' to ' + addr);\n});\n\ndns.listen();"
        }
    },
    {
        "repo": "dumb-react",
        "content": "'dumb-react/src/components/Header/Header.js'\n:import React, { Component } from \"react\";\nimport PropTypes from 'prop-types';\nimport \"./Header.css\";\nimport { Logo } from \"../Logo/Logo\";\nimport { PrimaryNav } from \"../PrimaryNav/PrimaryNav\";\nimport { InlineForm } from \"../InlineForm/InlineForm\";\nimport logoImg from \"../../images/fpo-120x60.png\";\nimport globals from \"../../data/globals.json\";\n\nexport class Header extends Component {\n    render() {\n        return (\n            <header className=\"c-header\" {...this.props}>\n                <Logo\n                    href=\"#\"\n                    src={logoImg}\n                    alt={globals.company.name}\n                />\n\n                <PrimaryNav\n                    listItems={[\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 1\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item \"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 3\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 4\"\n                        }\n                    ]}\n                />\n\n                <InlineForm\n\t\t\t\t\tmethod=\"post\"\n\t\t\t\t\taction=\"#\"\n                    placeholder=\"Search the site\"\n                    cta=\"Search\"\n                    id=\"search-form\"\n                    label=\"Search the site\"\n                />\n                {this.props.children}\n            </header>\n        );\n    }\n}\n\nHeader.propTypes = {\n    children: PropTypes.node\n}\n'dumb-react/src/components/Header/Header.stories.js'\n:import React from 'react';\nimport { storiesOf } from '@storybook/react';\nimport { withKnobs } from '@storybook/addon-knobs/react';\nimport { withSmartKnobs } from 'storybook-addon-smart-knobs';\nimport { Header } from './Header';\n\nlet stories = storiesOf('Global/Header', module);\n\nstories.addDecorator(withSmartKnobs).addDecorator(withKnobs);\n\nstories.add('Default', () =>\n  <Header />\n);\n\n",
        "called_code_segment": "export class Header extends Component {\n    render() {\n        return (\n            <header className=\"c-header\" {...this.props}>\n                <Logo\n                    href=\"#\"\n                    src={logoImg}\n                    alt={globals.company.name}\n                />\n\n                <PrimaryNav\n                    listItems={[\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 1\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item \"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 3\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 4\"\n                        }\n                    ]}\n                />\n\n                <InlineForm\n\t\t\t\t\tmethod=\"post\"\n\t\t\t\t\taction=\"#\"\n                    placeholder=\"Search the site\"\n                    cta=\"Search\"\n                    id=\"search-form\"\n                    label=\"Search the site\"\n                />\n                {this.props.children}\n            </header>\n        );\n    }\n}\n\nHeader.propTypes = {\n    children: PropTypes.node\n}",
        "invoking_code_segment": "let stories = storiesOf('Global/Header', module);\n\nstories.addDecorator(withSmartKnobs).addDecorator(withKnobs);\n\nstories.add('Default', () =>\n  <Header />\n);",
        "feature_description": "Add a dropdown menu to the Header component.",
        "detailed_feature_description": "Introduce a new prop `dropdownItems` to the Header component, which will accept an array of dropdown menu items. Update the Header component to render a dropdown menu if `dropdownItems` prop is provided. Modify the story to include a dropdown menu in the Header component.",
        "modified_complete_code": {
            "Header.js": "import React, { Component } from \"react\";\nimport PropTypes from 'prop-types';\nimport \"./Header.css\";\nimport { Logo } from \"../Logo/Logo\";\nimport { PrimaryNav } from \"../PrimaryNav/PrimaryNav\";\nimport { InlineForm } from \"../InlineForm/InlineForm\";\nimport { DropdownMenu } from \"../DropdownMenu/DropdownMenu\"; // #New\nimport logoImg from \"../../images/fpo-120x60.png\";\nimport globals from \"../../data/globals.json\";\n\nexport class Header extends Component {\n    render() {\n        return (\n            <header className=\"c-header\" {...this.props}>\n                <Logo\n                    href=\"#\"\n                    src={logoImg}\n                    alt={globals.company.name}\n                />\n\n                <PrimaryNav\n                    listItems={[\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 1\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item \"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 3\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 4\"\n                        }\n                    ]}\n                />\n\n                {this.props.dropdownItems && (\n                    <DropdownMenu items={this.props.dropdownItems} />\n                )} // #Modify\n\n                <InlineForm\n\t\t\t\t\tmethod=\"post\"\n\t\t\t\t\taction=\"#\"\n                    placeholder=\"Search the site\"\n                    cta=\"Search\"\n                    id=\"search-form\"\n                    label=\"Search the site\"\n                />\n                {this.props.children}\n            </header>\n        );\n    }\n}\n\nHeader.propTypes = {\n    children: PropTypes.node,\n    dropdownItems: PropTypes.arrayOf(PropTypes.shape({\n        href: PropTypes.string.isRequired,\n        text: PropTypes.string.isRequired\n    })) // #Modify\n}",
            "Header.stories.js": "import React from 'react';\nimport { storiesOf } from '@storybook/react';\nimport { withKnobs } from '@storybook/addon-knobs/react';\nimport { withSmartKnobs } from 'storybook-addon-smart-knobs';\nimport { Header } from './Header';\n\nlet stories = storiesOf('Global/Header', module);\n\nstories.addDecorator(withSmartKnobs).addDecorator(withKnobs);\n\nstories.add('Default', () =>\n  <Header\n    dropdownItems={[\n      { href: \"#\", text: \"Dropdown Item 1\" },\n      { href: \"#\", text: \"Dropdown Item 2\" },\n      { href: \"#\", text: \"Dropdown Item 3\" }\n    ]} // #Modify\n  />\n);"
        }
    },
    {
        "repo": "electron-speech",
        "content": "'electron-speech/index.js'\n:var EventEmitter = require('events')\nvar util = require('util')\nvar defined = require('defined')\nvar Readable = require('readable-stream')\n\nmodule.exports = Speech\n\nutil.inherits(Speech, EventEmitter)\nutil.inherits(Speech, Readable)\n\nfunction Speech (opts) {\n  if (!(this instanceof Speech)) { return new Speech(opts) }\n  if (!('webkitSpeechRecognition' in window)) {\n    this.emit('error', 'no speech api support')\n    return\n  }\n\n  opts = defined(opts, {})\n\n  EventEmitter.call(this)\n  Readable.call(this)\n\n  this.recognition = new webkitSpeechRecognition()\n  this.recognition.lang = defined(opts.lang, 'en-US')\n  this.continuous = defined(opts.continuous, false)\n\n  this._read = function (size) {}\n}\n\nSpeech.prototype.listen = function () {\n  var done = false\n  var self = this\n  var recognition = this.recognition\n  recognition.continuous = this.continuous\n  recognition.interimResults = false\n  recognition.onstart = function () {\n    self.emit('ready')\n  }\n  recognition.onresult = function (event) {\n    if (done) {\n      return\n    }\n    for (var i = event.resultIndex; i < event.results.length; i++) {\n      var result = event.results[i]\n      if (result.isFinal) {\n        var alt = result[0]\n        result = alt.transcript.trim()\n        self.emit('text', result)\n        self.push(result + '\\n')\n\n        if (!self.continuous) {\n          recognition.stop()\n          done = true\n          self.push(null)\n        }\n      }\n    }\n  }\n  recognition.onerror = function (err) {\n    console.log('err', err.error)\n    self.emit('error', err.error)\n  }\n  recognition.onend = function () {\n    self.emit('end')\n  }\n\n  recognition.start()\n}\n\n'electron-speech/listen.js'\n:var speech = require('./index')\nvar argv = require('minimist')(process.argv.slice(2))\n\nvar continuous = argv.continuous || argv.c\nvar quiet = argv.quiet || argv.q\n\nvar c = speech({ language: 'en_US', continuous: continuous })\n\nc.listen()\n\nc.on('ready', function () {\n  if (!quiet) {\n    console.log('listening..')\n  }\n})\n\nc.on('text', function (text) {\n  console.log(text)\n\n  if (!continuous) {\n    process.exit(0)\n  }\n})\n\nc.on('error', function (err) {\n  console.error('error:', err)\n})\n\nc.on('end', function () {\n  console.log('done')\n  process.exit(0)\n})\n\n",
        "called_code_segment": "Speech.prototype.listen = function () {\n  var done = false\n  var self = this\n  var recognition = this.recognition\n  recognition.continuous = this.continuous\n  recognition.interimResults = false\n  recognition.onstart = function () {\n    self.emit('ready')\n  }\n  recognition.onresult = function (event) {\n    if (done) {\n      return\n    }\n    for (var i = event.resultIndex; i < event.results.length; i++) {\n      var result = event.results[i]\n      if (result.isFinal) {\n        var alt = result[0]\n        result = alt.transcript.trim()\n        self.emit('text', result)\n        self.push(result + '\\n')\n\n        if (!self.continuous) {\n          recognition.stop()\n          done = true\n          self.push(null)\n        }\n      }\n    }\n  }\n  recognition.onerror = function (err) {\n    console.log('err', err.error)\n    self.emit('error', err.error)\n  }\n  recognition.onend = function () {\n    self.emit('end')\n  }\n\n  recognition.start()\n}",
        "invoking_code_segment": "var c = speech({ language: 'en_US', continuous: continuous })\n\nc.listen()\n\nc.on('ready', function () {\n  if (!quiet) {\n    console.log('listening..')\n  }\n})\n\nc.on('text', function (text) {\n  console.log(text)\n\n  if (!continuous) {\n    process.exit(0)\n  }\n})\n\nc.on('error', function (err) {\n  console.error('error:', err)\n})\n\nc.on('end', function () {\n  console.log('done')\n  process.exit(0)\n})",
        "feature_description": "Add a feature to allow the user to specify a custom callback for handling recognized text.",
        "detailed_feature_description": "Modify the `listen` method in #file 1 to accept an optional callback function. This callback will be invoked with the recognized text instead of emitting the 'text' event. Update #file 2 to pass a custom callback to the `listen` method.",
        "modified_complete_code": {
            "file1": "var EventEmitter = require('events')\nvar util = require('util')\nvar defined = require('defined')\nvar Readable = require('readable-stream')\n\nmodule.exports = Speech\n\nutil.inherits(Speech, EventEmitter)\nutil.inherits(Speech, Readable)\n\nfunction Speech (opts) {\n  if (!(this instanceof Speech)) { return new Speech(opts) }\n  if (!('webkitSpeechRecognition' in window)) {\n    this.emit('error', 'no speech api support')\n    return\n  }\n\n  opts = defined(opts, {})\n\n  EventEmitter.call(this)\n  Readable.call(this)\n\n  this.recognition = new webkitSpeechRecognition()\n  this.recognition.lang = defined(opts.lang, 'en-US')\n  this.continuous = defined(opts.continuous, false)\n\n  this._read = function (size) {}\n}\n\n#Modify\nSpeech.prototype.listen = function (callback) {\n  var done = false\n  var self = this\n  var recognition = this.recognition\n  recognition.continuous = this.continuous\n  recognition.interimResults = false\n  recognition.onstart = function () {\n    self.emit('ready')\n  }\n  recognition.onresult = function (event) {\n    if (done) {\n      return\n    }\n    for (var i = event.resultIndex; i < event.results.length; i++) {\n      var result = event.results[i]\n      if (result.isFinal) {\n        var alt = result[0]\n        result = alt.transcript.trim()\n        if (callback) {\n          callback(result)\n        } else {\n          self.emit('text', result)\n          self.push(result + '\\n')\n        }\n\n        if (!self.continuous) {\n          recognition.stop()\n          done = true\n          self.push(null)\n        }\n      }\n    }\n  }\n  recognition.onerror = function (err) {\n    console.log('err', err.error)\n    self.emit('error', err.error)\n  }\n  recognition.onend = function () {\n    self.emit('end')\n  }\n\n  recognition.start()\n}",
            "file2": "var speech = require('./index')\nvar argv = require('minimist')(process.argv.slice(2))\n\nvar continuous = argv.continuous || argv.c\nvar quiet = argv.quiet || argv.q\n\nvar c = speech({ language: 'en_US', continuous: continuous })\n\n#Modify\nc.listen(function (text) {\n  console.log(text)\n\n  if (!continuous) {\n    process.exit(0)\n  }\n})\n\nc.on('ready', function () {\n  if (!quiet) {\n    console.log('listening..')\n  }\n})\n\n#New\n// c.on('text', function (text) {\n//   console.log(text)\n//\n//   if (!continuous) {\n//     process.exit(0)\n//   }\n// })\n\nc.on('error', function (err) {\n  console.error('error:', err)\n})\n\nc.on('end', function () {\n  console.log('done')\n  process.exit(0)\n})"
        }
    },
    {
        "repo": "expect-jsx",
        "content": "'expect-jsx/index.js'\n:import expect from 'expect';\nimport collapse from 'collapse-white-space';\n\nimport reactElementToJSXString from 'react-element-to-jsx-string';\n\nconst api = {\n  toEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toNotEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toNotEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toIncludeJSX(ReactElement) {\n    return expect(\n      collapse(reactElementToJSXString(this.actual))\n    ).toInclude(\n      collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n  toNotIncludeJSX(ReactElement) {\n    return expect(\n        collapse(reactElementToJSXString(this.actual))\n    ).toExclude(\n        collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n};\n\nexport default api;\n\n'expect-jsx/index-test.js'\n:/* eslint-env mocha */\n/* eslint react/prop-types:0 */\n\nimport React from 'react';\nimport expect from 'expect';\nimport expectJSX from './index';\n\nexpect.extend(expectJSX);\n\nclass TestComponent extends React.Component {\n  render() {\n    return <div>Hi! {this.props.name}</div>;\n  }\n}\n\ndescribe('expect(ReactElement).toEqualJSX(ReactElement)', () => {\n  context('api', () => {\n    it('has toEqualJSX', () => {\n      expect(expect().toEqualJSX).toBeA('function');\n    });\n\n    it('has toNotEqualJSX', () => {\n      expect(expect().toNotEqualJSX).toBeA('function');\n    });\n\n    it('has toIncludeJSX', () => {\n      expect(expect().toIncludeJSX).toBeA('function');\n    });\n  });\n\n  context('toEqualJSX', () => {\n    it('can diff React elements', () => {\n      expect(\n        <TestComponent />\n      ).toEqualJSX(\n        <TestComponent />\n      );\n    });\n\n    it('throws when elements are different', () => {\n      try {\n        expect(<TestComponent extra=\"neous\" />).toEqualJSX(<TestComponent />);\n      } catch (err) {\n        expect(err instanceof Error).toBe(true);\n        expect(err.message)\n          .toEqual('Expected \\'<TestComponent extra=\"neous\" />\\' to equal \\'<TestComponent />\\'');\n      }\n    });\n\n    it('does not care about function', () => {\n      const fns = {\n        one() { return 'one'; },\n        two() { return 'two'; },\n      };\n\n      expect(\n        <TestComponent fn={fns.one} />\n      ).toEqualJSX(\n        <TestComponent fn={fns.two} />\n      );\n    });\n\n    it('handle render method with interpolation', () => {\n      expect(\n        <TestComponent name=\"Jon\" />\n      ).toNotEqual(\n      <TestComponent name=\"Marry\" />\n      );\n    });\n  });\n\n  context('toNotEqualJSX', () => {\n    it('works', () => {\n      expect(<div />).toNotEqualJSX(<div Hello=\", world!\" />);\n    });\n\n    it('throws when elements are the same', () => {\n      try {\n        expect(<div />).toNotEqualJSX(<div />);\n      } catch (err) {\n        expect(err instanceof Error).toBe(true);\n        expect(err.message).toEqual('Expected \\'<div />\\' to not equal \\'<div />\\'');\n      }\n    });\n  });\n\n  context('toIncludeJSX', () => {\n    it('works', () => {\n      expect(<div><div><TestComponent Hello=\", world!\"/></div></div>)\n        .toIncludeJSX(<div><TestComponent Hello=\", world!\"/></div>);\n    });\n\n    it('throws when element is not included', () => {\n      try {\n        expect(<div />).toIncludeJSX(<div Hello=\", world!\" />);\n      } catch (err) {\n        expect(err instanceof Error).toBe(true);\n        expect(err.message).toEqual('Expected \\'<div />\\' to include \\'<div Hello=\", world!\" />\\'');\n      }\n    });\n  });\n\n  context('toNotIncludeJSX', () => {\n    it('works', () => {\n      expect(<div><div><TestComponent Hello=\", world!\"/></div></div>)\n        .toNotIncludeJSX(<div><TestComponent Jello=\", world!\"/></div>);\n    });\n\n    it('throws when element is included', () => {\n      try {\n        expect(<div Hello=\", world!\" />).toNotIncludeJSX(<div Hello=\", world!\" />);\n      } catch (err) {\n        expect(err instanceof Error).toBe(true);\n        const message = 'Expected \\'<div Hello=\", world!\" />\\' to exclude \\'<div Hello=\", world!\" />\\'';\n        expect(err.message).toEqual(message);\n      }\n    });\n  });\n});\n\n",
        "called_code_segment": "const api = {\n  toEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toNotEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toNotEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toIncludeJSX(ReactElement) {\n    return expect(\n      collapse(reactElementToJSXString(this.actual))\n    ).toInclude(\n      collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n  toNotIncludeJSX(ReactElement) {\n    return expect(\n        collapse(reactElementToJSXString(this.actual))\n    ).toExclude(\n        collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n};\n\nexport default api;",
        "invoking_code_segment": "expect.extend(expectJSX);",
        "feature_description": "Add a new method to the API to check if a React element is deeply equal to another React element, including all nested elements and their properties.",
        "detailed_feature_description": "The new method, `toDeepEqualJSX`, will recursively compare all nested elements and their properties to ensure they are deeply equal. This will involve modifying the existing `toEqualJSX` method to handle nested comparisons and adding a new method in the API.",
        "modified_complete_code": {
            "index.js": "const api = {\n  toEqualJSX(ReactElement) {\n    return this.toDeepEqualJSX(ReactElement, false);\n  },\n  toNotEqualJSX(ReactElement) {\n    return this.toDeepEqualJSX(ReactElement, true);\n  },\n  toIncludeJSX(ReactElement) {\n    return expect(\n      collapse(reactElementToJSXString(this.actual))\n    ).toInclude(\n      collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n  toNotIncludeJSX(ReactElement) {\n    return expect(\n        collapse(reactElementToJSXString(this.actual))\n    ).toExclude(\n        collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n  toDeepEqualJSX(ReactElement, shouldNotEqual) {\n    const isEqual = this.actual.type === ReactElement.type &&\n                   this.actual.props === ReactElement.props &&\n                   this.actual.children === ReactElement.children;\n    if (shouldNotEqual) {\n      return expect(isEqual).toBe(false);\n    } else {\n      return expect(isEqual).toBe(true);\n    }\n  }\n};\n\nexport default api;",
            "index-test.js": "expect.extend(expectJSX);\n\n// New test cases for toDeepEqualJSX\nit('can deeply diff React elements', () => {\n  expect(\n    <TestComponent>\n      <div>Nested</div>\n    </TestComponent>\n  ).toDeepEqualJSX(\n    <TestComponent>\n      <div>Nested</div>\n    </TestComponent>\n  );\n});\n\nit('throws when deeply different', () => {\n  try {\n    expect(\n      <TestComponent>\n        <div>Nested</div>\n      </TestComponent>\n    ).toDeepEqualJSX(\n      <TestComponent>\n        <div>Different</div>\n      </TestComponent>\n    );\n  } catch (err) {\n    expect(err instanceof Error).toBe(true);\n    expect(err.message)\n      .toEqual('Expected '<TestComponent><div>Nested</div></TestComponent>' to deeply equal '<TestComponent><div>Different</div></TestComponent>'');\n  }\n});"
        }
    },
    {
        "repo": "games-wabot",
        "content": "'games-wabot/lib/print.js'\n:\n'games-wabot/handler.js'\n:let util = require('util')\nlet simple = require('./lib/simple')\nlet { MessageType, Presence } = require('@adiwajshing/baileys')\n\nconst isNumber = x => typeof x === 'number' && !isNaN(x)\nconst delay = ms => isNumber(ms) && new Promise(resolve => setTimeout(resolve, ms))\nmodule.exports = {\n  async handler(chatUpdate) {\n    // console.log(chatUpdate)\n    if (!chatUpdate.hasNewMessage) return\n    if (!chatUpdate.messages && !chatUpdate.count) return\n    let m = chatUpdate.messages.all()[0]\n    try {\n      simple.smsg(this, m)\n      switch (m.mtype) {\n        case MessageType.image:\n        case MessageType.video:\n        case MessageType.audio:\n          if (!m.key.fromMe) await delay(1000)\n          if (!m.msg.url) await this.updateMediaMessage(m)\n          break\n      }\n      m.exp = 0\n      m.limit = false\n      try {\n        let user = global.DATABASE._data.users[m.sender]\n        if (typeof user !== 'object') global.DATABASE._data.users[m.sender] = {}\n        if (user) {\n            if (!isNumber(user.healt)) user.healt = 0\n            if (!isNumber(user.level)) user.level = 0\n            if (!isNumber(user.exp)) user.exp = 0\n            if (!isNumber(user.limit)) user.limit = 10\n            if (!isNumber(user.lastclaim)) user.lastclaim = 0\n            if (!isNumber(user.money)) user.money = 0\n            \n            if (!isNumber(user.diamond)) user.diamond = 0\n            if (!isNumber(user.iron)) user.iron = 0\n\n            if (!isNumber(user.common)) user.common = 0\n            if (!isNumber(user.uncommon)) user.uncommon = 0\n            if (!isNumber(user.mythic)) user.mythic = 0\n            if (!isNumber(user.legendary)) user.legendary = 0\n            if (!isNumber(user.pet)) user.pet = 0\n        \n            if (!isNumber(user.potion)) user.potion = 0\n            if (!isNumber(user.sampah)) user.sampah = 0\n            if (!isNumber(user.armor)) user.armor = 0\n            \n            if (!isNumber(user.kucing)) user.kucing = 0\n            if (!isNumber(user.kucinglastclaim)) user.kucinglastclaim = 0\n            if (!isNumber(user.kuda)) user.kuda = 0\n            if (!isNumber(user.kudalastclaim)) user.kudalastclaim = 0\n            if (!isNumber(user.rubah)) user.rubah = 0\n            if (!isNumber(user.rubahlastclaim)) user.rubahlastclaim = 0\n            if (!isNumber(user.anjing)) user.anjing = 0\n            if (!isNumber(user.anjinglastclaim)) user.anjinglastclaim = 0\n\n            if (!'banned' in user) user.banned = false\n            if (!'bannedReason' in user) user.bannedReason = ''\n            if (!isNumber(user.warn)) user.warn = 0\n\n            if (!isNumber(user.afk)) user.afk = -1\n            if (!'afkReason' in user) user.afkReason = ''\n        \n            if (!isNumber(user.anakkucing)) user.anakkucing = 0\n            if (!isNumber(user.anakkuda)) user.anakkuda = 0\n            if (!isNumber(user.anakrubah)) user.anakrubah = 0\n            if (!isNumber(user.anakanjing)) user.anakanjing = 0\n            if (!isNumber(user.makananpet)) user.makananpet = 0\n\n            if (!isNumber(user.antispam)) user.antispam = 0\n            if (!isNumber(user.antispamlastclaim)) user.antispamlastclaim = 0\n\n            if (!isNumber(user.kayu)) user.kayu = 0\n            if (!isNumber(user.batu)) user.batu = 0\n            if (!isNumber(user.string)) user.string = 0\n            if (!isNumber(user.sword)) user.sword = 0\n            if (!isNumber(user.sworddurability)) user.sworddurability = 0\n            if (!isNumber(user.pickaxe)) user.pickaxe = 0\n            if (!isNumber(user.pickaxedurability)) user.pickaxedurability = 0\n            if (!isNumber(user.fishingrod)) user.fishingrod = 0\n            if (!isNumber(user.fishingroddurability)) user.fishingroddurability = 0\n\n            if (!isNumber(user.lastadventure)) user.lastadventure = 0\n            if (!isNumber(user.lastfishing)) user.lastfishing = 0\n            if (!isNumber(user.lastdungeon)) user.lastdungeon = 0\n            if (!isNumber(user.lastduel)) user.lastduel = 0\n            if (!isNumber(user.lastmining)) user.lastmining = 0\n            if (!isNumber(user.lasthunt)) user.lasthunt = 0\n            if (!isNumber(user.lastweekly)) user.lastweekly = 0\n            if (!isNumber(user.lastmonthly)) user.lastmontly = 0\n            if (!('registered' in user)) user.registered = false\n            if (!user.registered) {\n                if (!('name' in user)) user.name = this.getName(m.sender)\n                if (!isNumber(user.age)) user.age = -1\n                if (!isNumber(user.regTime)) user.regTime = -1\n            }\n            if (!('autolevelup' in user)) user.autolevelup = true\n            if (!('ah' in user)) user.ah = []\n            if (!('mission' in user)) user.mission = {}\n        } else global.DATABASE._data.users[m.sender] = {\n            healt: 100,\n            level: 0,\n            exp: 0,\n            limit: 10,\n            lastclaim: 0,\n            money: 0,\n            diamond: 0,\n            iron: 0,\n            common: 0,\n            uncommon: 0,\n            mythic: 0,\n            legendary: 0,\n            pet: 0,\n            potion: 0,\n            sampah: 0,\n            armor: 0,\n            kucing: 0,\n            kucinglastclaim: 0,\n            kuda: 0,\n            kudalastclaim: 0,\n            rubah: 0,\n            rubahlastclaim: 0,\n            anjing: 0,\n            anjinglastclaim: 0,\n            Banneduser: false,\n            BannedReason: '',\n            warn: 0,\n            afk: -1,\n            afkReason: '',\n            anakkucing: 0,\n            anakkuda: 0,\n            anakrubah: 0,\n            anakanjing: 0,\n            makananpet: 0,\n            antispam: 0,\n            antispamlastclaim: 0,\n            kayu: 0,\n            batu: 0,\n            string: 0,\n            sword: 0,\n            sworddurability: 0,\n            pickaxe: 0,\n            pickaxedurability: 0,\n            fishingrod: 0,\n            fishingroddurability: 0,\n            lastadventure: 0,\n            lastfishing: 0,\n            lastdungeon: 0,\n            lastduel: 0,\n            lastmining: 0,\n            lasthunt: 0,\n            lastweekly: 0,\n            lastmonthly: 0,\n            registered: false,\n            name: this.getName(m.sender),\n            age: -1,\n            regTime: -1,\n            autolevelup: true,\n            ah: [],\n            mission: {},\n        }\n\n        let chat = global.DATABASE._data.chats[m.chat]\n        if (typeof chat !== 'object') global.DATABASE._data.chats[m.chat] = {}\n        if (chat) {\n          if (!('isBanned' in chat)) chat.isBanned = false\n          if (!('welcome' in chat)) chat.welcome = false\n          if (!('detect' in chat)) chat.detect = false\n          if (!('sWelcome' in chat)) chat.sWelcome = ''\n          if (!('sBye' in chat)) chat.sBye = ''\n          if (!('sPromote' in chat)) chat.sPromote = ''\n          if (!('sDemote' in chat)) chat.sDemote = ''\n          if (!('delete' in chat)) chat.delete = false\n          if (!('antiLink' in chat)) chat.antiLink = false\n          if (!'antiToxic' in chat) chat.antiToxic = false\n        } else global.DATABASE._data.chats[m.chat] = {\n          isBanned: false,\n          welcome: false,\n          detect: false,\n          sWelcome: '',\n          sBye: '',\n          sPromote: '',\n          sDemote: '',\n          delete: false,\n          antiLink: false,\n          antiToxic: false,\n        }\n      } catch (e) {\n        console.error(e)\n      }\n      if (opts['nyimak']) return\n      if (!m.fromMe && opts['self']) return\n      if (m.chat == 'status@broadcast') return\n      if (typeof m.text !== 'string') m.text = ''\n      for (let name in global.plugins) {\n        let plugin = global.plugins[name]\n        if (!plugin) continue\n        if (plugin.disabled) continue\n        if (!plugin.all) continue\n        if (typeof plugin.all !== 'function') continue\n        try {\n          await plugin.all.call(this, m, chatUpdate)\n        } catch (e) {\n          if (typeof e === 'string') continue\n          console.error(e)\n        }\n      }\n      if (m.isBaileys) return\n      m.exp += Math.ceil(Math.random() * 10)\n\n      let usedPrefix\n      let _user = global.DATABASE.data && global.DATABASE.data.users && global.DATABASE.data.users[m.sender]\n\n      let isROwner = [global.conn.user.jid, ...global.owner].map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)\n      let isOwner = isROwner || m.fromMe\n      let isMods = isOwner || global.mods.map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)\n      let isPrems = isROwner || global.prems.map(v => v.replace(/[^0-9]/g, '') + '@s.whatsapp.net').includes(m.sender)\n      let groupMetadata = m.isGroup ? this.chats.get(m.chat).metadata || await this.groupMetadata(m.chat) : {} || {}\n      let participants = m.isGroup ? groupMetadata.participants : [] || []\n      let user = m.isGroup ? participants.find(u => u.jid == m.sender) : {} // User Data\n      let bot = m.isGroup ? participants.find(u => u.jid == this.user.jid) : {} // Your Data\n      let isAdmin = user.isAdmin || user.isSuperAdmin || false // Is User Admin?\n      let isBotAdmin = bot.isAdmin || bot.isSuperAdmin || false // Are you Admin?\n      let DevMode = /true/i.test(global.DeveloperMode.toLowerCase())\n      for (let name in global.plugins) {\n        let plugin = global.plugins[name]\n        if (!plugin) continue\n        if (plugin.disabled) continue\n        if (!opts['restrict']) if (plugin.tags && plugin.tags.includes('admin')) continue\n        const str2Regex = str => str.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n        let _prefix = plugin.customPrefix ? plugin.customPrefix : conn.prefix ? conn.prefix : global.prefix\n        let match = (_prefix instanceof RegExp ? // RegExp Mode?\n          [[_prefix.exec(m.text), _prefix]] :\n          Array.isArray(_prefix) ? // Array?\n            _prefix.map(p => {\n              let re = p instanceof RegExp ? // RegExp in Array?\n                p :\n                new RegExp(str2Regex(p))\n              return [re.exec(m.text), re]\n            }) :\n            typeof _prefix === 'string' ? // String?\n              [[new RegExp(str2Regex(_prefix)).exec(m.text), new RegExp(str2Regex(_prefix))]] :\n              [[[], new RegExp]]\n        ).find(p => p[1])\n        if (typeof plugin.before === 'function') if (await plugin.before.call(this, m, {\n          match,\n          conn: this,\n          participants,\n          groupMetadata,\n          user,\n          bot,\n          isROwner,\n          isOwner,\n          isAdmin,\n          isBotAdmin,\n          isPrems,\n          chatUpdate,\n        })) continue\n        if (typeof plugin !== 'function') continue\n        if ((usedPrefix = (match[0] || '')[0])) {\n          let noPrefix = m.text.replace(usedPrefix, '')\n          let [command, ...args] = noPrefix.trim().split` `.filter(v => v)\n          args = args || []\n          let _args = noPrefix.trim().split` `.slice(1)\n          let text = _args.join` `\n          command = (command || '').toLowerCase()\n          let fail = plugin.fail || global.dfail // When failed\n          let isAccept = plugin.command instanceof RegExp ? // RegExp Mode?\n            plugin.command.test(command) :\n            Array.isArray(plugin.command) ? // Array?\n              plugin.command.some(cmd => cmd instanceof RegExp ? // RegExp in Array?\n                cmd.test(command) :\n                cmd === command\n              ) :\n              typeof plugin.command === 'string' ? // String?\n                plugin.command === command :\n                false\n\n          if (!isAccept) continue\n          m.plugin = name\n          if (m.chat in global.DATABASE._data.chats || m.sender in global.DATABASE._data.users) {\n            let chat = global.DATABASE._data.chats[m.chat]\n            let user = global.DATABASE._data.users[m.sender]\n            if (!['unbanchat.js', 'link.js', 'pengumuman.js', 'creator.js'].includes(name) && chat && chat.isBanned && !isROwner) return // Except this\n            if (!['unbanuser.js', 'inv.js', 'link.js', 'creator.js', 'profile.js'].includes(name) && user && user.banned && !isROwner) {\n              if (!opts['msgifbanned']) m.reply(`*ANDA TERBANNED* ${user.bannedReason ? `\\nKarena *${user.bannedReason}*` : ''}\n\nHubungi: \n${global.owner.map((v, i) => '*Owner ' + (i + 1) + ':* wa.me/' + v).join('\\n') + '\\n\\n' + global.mods.map((v, i) => '*Moderator ' + (i + 1) + ':* wa.me/' + v).join('\\n')}\n\nKuy join group Official *${conn.getName(this.user.jid)}*: \n${(global.linkGC).map((v, i) => '*Group ' + (i + 1) + '*\\n' + v).join`\\n\\n`}\n`.trim())\n              return\n            }\n          }\n          if (plugin.rowner && plugin.owner && !(isROwner || isOwner)) { // Both Owner\n            fail('owner', m, this)\n            continue\n          }\n          if (plugin.rowner && !isROwner) { // Real Owner\n            fail('rowner', m, this)\n            continue\n          }\n          if (plugin.owner && !isOwner) { // Number Owner\n            fail('owner', m, this)\n            continue\n          }\n          if (plugin.mods && !isMods) { // Moderator\n            fail('mods', m, this)\n            continue\n          }\n          if (plugin.premium && !isPrems) { // Premium\n            fail('premium', m, this)\n            continue\n          }\n          if (plugin.group && !m.isGroup) { // Group Only\n            fail('group', m, this)\n            continue\n          } else if (plugin.botAdmin && !isBotAdmin) { // You Admin\n            fail('botAdmin', m, this)\n            continue\n          } else if (plugin.admin && !isAdmin) { // User Admin\n            fail('admin', m, this)\n            continue\n          }\n          if (plugin.private && m.isGroup) { // Private Chat Only\n            fail('private', m, this)\n            continue\n          }\n          if (plugin.register == true && _user.registered == false) { // Butuh daftar?\n            fail('unreg', m, this)\n            continue\n          }\n\n          m.isCommand = true\n          let xp = 'exp' in plugin ? parseInt(plugin.exp) : 15 // XP Earning per command\n          if (xp > 99999999999) m.reply('Ngecit -_-') // Hehehe\n          else m.exp += xp\n          if (!isPrems && plugin.limit && global.DATABASE._data.users[m.sender].limit < plugin.limit * 1) {\n            this.reply(m.chat, `Limit anda habis, silahkan beli melalui *${usedPrefix}buy*`, m)\n            continue // Limit habis\n          }\n          let extra = {\n            match,\n            usedPrefix,\n            noPrefix,\n            _args,\n            args,\n            command,\n            text,\n            conn: this,\n            participants,\n            groupMetadata,\n            user,\n            bot,\n            isROwner,\n            isOwner,\n            isAdmin,\n            isBotAdmin,\n            isPrems,\n            chatUpdate,\n            DevMode,\n          }\n          try {\n            let presence = opts['presence']\n            if (presence in Presence) await this.updatePresence(m.chat, Presence[presence]).catch(console.error)\n            await plugin.call(this, m, extra)\n            if (!isPrems) m.limit = m.limit || plugin.limit || false\n          } catch (e) {\n            // Error occured\n            m.error = e\n            console.error(e)\n            if (e) {\n              let text = util.format(e)\n              for (let key of Object.values(global.APIKeys))\n                text = text.replace(new RegExp(key, 'g'), '#HIDDEN#')\n                if (DevMode && text.length > 100) {\n                  for (let jid of Object.entries(global.Owner).filter(v => v[1].isDev).map(v => v[0].replace(/[^0-9]/g, '') + '@s.whatsapp.net').filter(v => v != conn.user.jid)) m.reply(`*file:* ${m.plugin}\\n*Nomor:* ${m.sender}\\n*Text:* ${m.text}\\n\\n\\`\\`\\`${text}\\`\\`\\``, jid)\n                }\n                m.reply(text)\n            }\n          } finally {\n            // m.reply(util.format(_user))\n            if (typeof plugin.after === 'function') {\n              try {\n                await plugin.after.call(this, m, extra)\n              } catch (e) {\n                console.error(e)\n              }\n            }\n            if (m.limit) m.reply(+ m.limit + ' Limit terpakai')\n          }\n          break\n        }\n      }\n    } finally {\n      await this.updatePresence(m.chat, Presence.available).catch(console.error)\n      //console.log(global.DATABASE._data.users[m.sender])\n      let user, stats = global.DATABASE._data.stats\n      if (m) {\n        if (m.sender && (user = global.DATABASE._data.users[m.sender])) {\n          user.exp += m.exp\n          user.limit -= m.limit * 1\n        }\n\n        let stat\n        if (m.plugin) {\n          let now = + new Date\n          if (m.plugin in stats) {\n            stat = stats[m.plugin]\n            if (!isNumber(stat.total)) stat.total = 1\n            if (!isNumber(stat.success)) stat.success = m.error != null ? 0 : 1\n            if (!isNumber(stat.last)) stat.last = now\n            if (!isNumber(stat.lastSuccess)) stat.lastSuccess = m.error != null ? 0 : now\n          } else stat = stats[m.plugin] = {\n            total: 1,\n            success: m.error != null ? 0 : 1,\n            last: now,\n            lastSuccess: m.error != null ? 0 : now\n          }\n          stat.total += 1\n          stat.last = now\n          if (m.error == null) {\n            stat.success += 1\n            stat.lastSuccess = now\n          }\n        }\n      }\n\n      try {\n        require('./lib/print')(m, this)\n      } catch (e) {\n        console.log(m, m.quoted, e)\n      }\n      if (opts['autoread']) await this.chatRead(m.chat)\n    }\n  },\n  async participantsUpdate({ jid, participants, action }) {\n    let chat = global.DATABASE._data.chats[jid] || {}\n    let text = ''\n    switch (action) {\n      case 'add':\n      case 'remove':\n        if (chat.welcome) {\n          let groupMetadata = await this.groupMetadata(jid)\n          for (let user of participants) {\n            let pp = './src/avatar_contact.png'\n            try {\n              pp = await this.getProfilePicture(user)\n            } catch (e) {\n            } finally {\n              text = (action === 'add' ? (chat.sWelcome || this.welcome || conn.welcome || 'Welcome, @user!').replace('@subject', await this.getName(jid)).replace('@desc', groupMetadata.desc) :\n                (chat.sBye || this.bye || conn.bye || 'Bye, @user!')).replace('@user', '@' + user.split('@')[0])\n              this.sendFile(jid, pp, 'pp.jpg', text, null, false, {\n                contextInfo: {\n                  mentionedJid: [user]\n                }\n              })\n            }\n          }\n        }\n        break\n      case 'promote':\n        text = (chat.sPromote || this.spromote || conn.spromote || '@user ```is now Admin```')\n      case 'demote':\n        if (!text) text = (chat.sDemote || this.sdemote || conn.sdemote || '@user ```is no longer Admin```')\n        text = text.replace('@user', '@' + participants[0].split('@')[0])\n        if (chat.detect) this.sendMessage(jid, text, MessageType.extendedText, {\n          contextInfo: {\n            mentionedJid: this.parseMention(text)\n          }\n        })\n        break\n    }\n  },\n  async delete(m) {\n    if (m.key.remoteJid == 'status@broadcast') return\n    if (m.key.fromMe) return\n    let chat = global.DATABASE._data.chats[m.key.remoteJid]\n    if (chat.delete) return\n    await this.reply(m.key.remoteJid, `\nTerdeteksi @${m.participant.split`@`[0]} telah menghapus pesan\n\nUntuk mematikan fitur ini, ketik\n*.enable delete*\n`.trim(), m.message, {\n      contextInfo: {\n        mentionedJid: [m.participant]\n      }\n    })\n    this.copyNForward(m.key.remoteJid, m.message).catch(e => console.log(e, m))\n  },\n  async onCall(json) {\n    let { from } = json[2][0][1]\n    let ids = 'call-id' in json[2][0][2][0][1] ? Object.entries(json[2][0][2][0][1]) : []\n    let id = ids[0][1]\n    let isOffer = json[2][0][2][0][0] == 'offer' || false\n    let users = global.DATABASE.data.users\n    let user = users[from] || {}\n    if (user.whitelist) return\n    switch (this.callWhitelistMode) {\n      case 'mycontact':\n        if (from in this.contacts && 'short' in this.contacts[from])\n        return\n        break\n    }\n      \n    if (from && id && isOffer && json[2][0]) {\n      var tag = this.generateMessageTag()\n      var NodePayload = [\"action\", \"call\", [\"call\", {\n        \"from\": this.user.jid,\n        \"to\": from,\n        \"id\": tag\n      }, [[\"reject\", { \n        \"call-id\": id, \n        \"call-creator\": from, \n        \"count\": \"0\" \n      }, null]]]]\n      \n      await this.send(`${tag},${JSON.stringify(NodePayload)}`)\n    }\n    await this.sendMessage(from, 'Maaf, Tolong jangan telfon BOT!!', MessageType.extendedText)\n  }\n}\n\nglobal.dfail = (type, m, conn) => {\n  let msg = {\n    rowner: 'Perintah ini hanya dapat digunakan oleh _*OWWNER!1!1!*_',\n    owner: 'Perintah ini hanya dapat digunakan oleh _*Owner Bot*_!',\n    mods: 'Perintah ini hanya dapat digunakan oleh _*Moderator*_ !',\n    premium: 'Perintah ini hanya untuk member _*Premium*_ !',\n    group: 'Perintah ini hanya dapat digunakan di grup!',\n    private: 'Perintah ini hanya dapat digunakan di Chat Pribadi!',\n    admin: 'Perintah ini hanya untuk *Admin* grup!',\n    botAdmin: 'Jadikan bot sebagai *Admin* untuk menggunakan perintah ini!',\n    unreg: 'Silahkan daftar untuk menggunakan fitur ini dengan cara mengetik:\\n\\n*#daftar nama.umur*\\n\\nContoh: *#daftar Manusia.16*'\n  }[type]\n  if (msg) return m.reply(msg)\n}\n\nlet fs = require('fs')\nlet chalk = require('chalk')\nlet file = require.resolve(__filename)\nfs.watchFile(file, () => {\n  fs.unwatchFile(file)\n  console.log(chalk.redBright(\"Update 'handler.js'\"))\n  delete require.cache[file]\n  if (global.reloadHandler) console.log(global.reloadHandler())\n})\n\n",
        "called_code_segment": "module.exports = {\n  async handler(chatUpdate) {\n    // Existing code...\n    if (m.chat in global.DATABASE._data.chats || m.sender in global.DATABASE._data.users) {\n      let chat = global.DATABASE._data.chats[m.chat]\n      let user = global.DATABASE._data.users[m.sender]\n      if (!['unbanchat.js', 'link.js', 'pengumuman.js', 'creator.js'].includes(name) && chat && chat.isBanned && !isROwner) return // Except this\n      if (!['unbanuser.js', 'inv.js', 'link.js', 'creator.js', 'profile.js'].includes(name) && user && user.banned && !isROwner) {\n        if (!opts['msgifbanned']) m.reply(`*ANDA TERBANNED* ${user.bannedReason ? `\\nKarena *${user.bannedReason}*` : ''}\n\nHubungi: \n${global.owner.map((v, i) => '*Owner ' + (i + 1) + ':* wa.me/' + v).join('\\n') + '\\n\\n' + global.mods.map((v, i) => '*Moderator ' + (i + 1) + ':* wa.me/' + v).join('\\n')}\n\nKuy join group Official *${conn.getName(this.user.jid)}*: \n${(global.linkGC).map((v, i) => '*Group ' + (i + 1) + '*\\n' + v).join`\\n\\n`}\n`.trim())\n        return\n      }\n    }\n    // Existing code...\n  }\n}",
        "invoking_code_segment": "let simple = require('./lib/simple')\n\nconst isNumber = x => typeof x === 'number' && !isNaN(x)\nconst delay = ms => isNumber(ms) && new Promise(resolve => setTimeout(resolve, ms))\nmodule.exports = {\n  async handler(chatUpdate) {\n    // Existing code...\n    simple.smsg(this, m)\n    // Existing code...\n  }\n}",
        "feature_description": "Add a feature to log banned users' messages to a file.",
        "detailed_feature_description": "When a banned user sends a message, log the message content, sender's JID, and the reason for being banned to a file named 'banned_users_log.txt'. Update the handler in #file 1 to include this logging functionality and modify the invoking code in #file 2 to ensure the logging is triggered.",
        "modified_complete_code": {
            "#file 1": "module.exports = {\n  async handler(chatUpdate) {\n    // Existing code...\n    if (m.chat in global.DATABASE._data.chats || m.sender in global.DATABASE._data.users) {\n      let chat = global.DATABASE._data.chats[m.chat]\n      let user = global.DATABASE._data.users[m.sender]\n      if (!['unbanchat.js', 'link.js', 'pengumuman.js', 'creator.js'].includes(name) && chat && chat.isBanned && !isROwner) return // Except this\n      if (!['unbanuser.js', 'inv.js', 'link.js', 'creator.js', 'profile.js'].includes(name) && user && user.banned && !isROwner) {\n        if (!opts['msgifbanned']) m.reply(`*ANDA TERBANNED* ${user.bannedReason ? `\\nKarena *${user.bannedReason}*` : ''}\n\nHubungi: \n${global.owner.map((v, i) => '*Owner ' + (i + 1) + ':* wa.me/' + v).join('\\n') + '\\n\\n' + global.mods.map((v, i) => '*Moderator ' + (i + 1) + ':* wa.me/' + v).join('\\n')}\n\nKuy join group Official *${conn.getName(this.user.jid)}*: \n${(global.linkGC).map((v, i) => '*Group ' + (i + 1) + '*\\n' + v).join`\\n\\n`}\n`.trim())\n        // Modify\n        this.logBannedUser(m, user.bannedReason)\n        return\n      }\n    }\n    // Existing code...\n  },\n  // New\n  async logBannedUser(m, reason) {\n    const fs = require('fs')\n    const logEntry = `[${new Date().toISOString()}] Banned User: ${m.sender}, Message: ${m.text}, Reason: ${reason}\\n`\n    fs.appendFileSync('banned_users_log.txt', logEntry)\n  }\n}",
            "#file 2": "let simple = require('./lib/simple')\n\nconst isNumber = x => typeof x === 'number' && !isNaN(x)\nconst delay = ms => isNumber(ms) && new Promise(resolve => setTimeout(resolve, ms))\nmodule.exports = {\n  async handler(chatUpdate) {\n    // Existing code...\n    simple.smsg(this, m)\n    // Existing code...\n  }\n}"
        }
    },
    {
        "repo": "graphql-markdown",
        "content": "'graphql-markdown/src/renderSchema.js'\n:\n'graphql-markdown/src/index.js'\n:#!/usr/bin/env node\n'use strict'\nconst parseArgs = require('minimist')\nconst resolveFrom = require('resolve-from')\nconst { loadSchemaJSON, schemaToJSON } = require('./loadSchemaJSON')\nconst renderSchema = require('./renderSchema')\nconst updateSchema = require('./updateSchema')\nconst diffSchema = require('./diffSchema')\n\nfunction safeExit(code) {\n  process.on('exit', function () {\n    process.exit(code)\n  })\n}\n\nfunction printHelp(console) {\n  const name = require('../package.json').name\n  console.log(`\n  Usage: ${name} [options] <schema>\n\n  Output a Markdown document with rendered descriptions and links between types.\n  The schema may be specified as:\n\n    - a URL to the GraphQL endpoint (the introspection query will be run)\n    - a GraphQL document containing the schema (.graphql or .gql)\n    - a JSON document containing the schema (as returned by the introspection query)\n    - an importable module with the schema as its default export (either an instance\n      of GraphQLSchema or a JSON object)\n\n  Options:\n\n    --title <string>       Change the top heading title (default: 'Schema Types')\n    --no-title             Do not print a default title\n    --no-toc               Do not print table of contents\n    --toc-fields <list>    Expand the table of contents for the listed types\n                           (comma-separated) to link to fields within those types\n                           (e.g. --toc-fields \"Query,Mutation,Subscription\") or use\n                           the string \"*\" to link to fields for all types\n    --prologue <string>    Include custom Markdown after the title\n    --epilogue <string>    Include custom Markdown after everything else\n    --heading-level <num>  Heading level to begin at, useful if you are embedding the\n                           output in a document with other sections (default: 1)\n    --update-file <file>   Markdown document to update (between comment markers) or\n                           create (if the file does not exist)\n    --require <module>     If importing the schema from a module, require the specified\n                           module first (useful for e.g. babel-register)\n    --header <name=value>  Additional header(s) to use in GraphQL request\n                           e.g. --header \"Authorization=Bearer ey...\"\n    --version              Print version and exit\n`)\n}\n\nfunction run(\n  argv = process.argv.slice(2),\n  { console = global.console, exit = true } = {}\n) {\n  const args = parseArgs(argv)\n\n  if (args.help) {\n    printHelp(console)\n  } else if (args.version) {\n    console.log(require('../package.json').version)\n  } else if (args._.length === 1) {\n    if (args.require) {\n      const requirePath = resolveFrom('.', args.require)\n      if (requirePath) {\n        require(requirePath)\n      } else {\n        throw new Error(`Could not resolve --require module: ${args.require}`)\n      }\n    }\n    const schemaPath = args._[0]\n    const headers = [].concat(args.header || []).reduce((obj, header) => {\n      const [key, ...value] = String(header).split('=')\n      obj[key] = value.join('=')\n      return obj\n    }, {})\n    const tocFieldTypes = args['toc-fields']\n      ? args['toc-fields'].split(',')\n      : []\n    const loadOptions = { headers }\n    loadSchemaJSON(schemaPath, loadOptions).then((schema) => {\n      const options = {\n        title: args.title,\n        skipTitle: false,\n        prologue: args.prologue,\n        epilogue: args.epilogue,\n        skipTableOfContents: args.toc === false,\n        headingLevel: args['heading-level'],\n        tocFieldTypes,\n      }\n      if (options.title === false) {\n        options.title = ''\n        options.skipTitle = true\n      } else if (Array.isArray(options.title)) {\n        options.title.forEach((value) => {\n          if (typeof value === 'string') {\n            options.title = value\n          } else if (value === false) {\n            options.skipTitle = true\n          }\n        })\n      }\n      const updateFile = args['update-file']\n      if (updateFile) {\n        updateSchema(updateFile, schema, options)\n          .then(() => {\n            if (exit) {\n              safeExit(0)\n            }\n          })\n          .catch((err) => {\n            console.error(err)\n            if (exit) {\n              safeExit(1)\n            }\n          })\n      } else {\n        renderSchema(schema, options)\n        if (exit) {\n          safeExit(0)\n        }\n      }\n    })\n  } else {\n    printHelp(console)\n    if (exit) {\n      safeExit(1)\n    }\n  }\n}\n\nmodule.exports = {\n  run,\n  loadSchemaJSON,\n  schemaToJSON,\n  renderSchema,\n  updateSchema,\n  diffSchema,\n}\n\nif (require.main === module) {\n  run()\n}\n\n",
        "called_code_segment": "function run(argv = process.argv.slice(2), { console = global.console, exit = true } = {}) {\n  const args = parseArgs(argv)\n\n  if (args.help) {\n    printHelp(console)\n  } else if (args.version) {\n    console.log(require('../package.json').version)\n  } else if (args._.length === 1) {\n    if (args.require) {\n      const requirePath = resolveFrom('.', args.require)\n      if (requirePath) {\n        require(requirePath)\n      } else {\n        throw new Error(`Could not resolve --require module: ${args.require}`)\n      }\n    }\n    const schemaPath = args._[0]\n    const headers = [].concat(args.header || []).reduce((obj, header) => {\n      const [key, ...value] = String(header).split('=')\n      obj[key] = value.join('=')\n      return obj\n    }, {})\n    const tocFieldTypes = args['toc-fields']\n      ? args['toc-fields'].split(',')\n      : []\n    const loadOptions = { headers }\n    loadSchemaJSON(schemaPath, loadOptions).then((schema) => {\n      const options = {\n        title: args.title,\n        skipTitle: false,\n        prologue: args.prologue,\n        epilogue: args.epilogue,\n        skipTableOfContents: args.toc === false,\n        headingLevel: args['heading-level'],\n        tocFieldTypes,\n      }\n      if (options.title === false) {\n        options.title = ''\n        options.skipTitle = true\n      } else if (Array.isArray(options.title)) {\n        options.title.forEach((value) => {\n          if (typeof value === 'string') {\n            options.title = value\n          } else if (value === false) {\n            options.skipTitle = true\n          }\n        })\n      }\n      const updateFile = args['update-file']\n      if (updateFile) {\n        updateSchema(updateFile, schema, options)\n          .then(() => {\n            if (exit) {\n              safeExit(0)\n            }\n          })\n          .catch((err) => {\n            console.error(err)\n            if (exit) {\n              safeExit(1)\n            }\n          })\n      } else {\n        renderSchema(schema, options)\n        if (exit) {\n          safeExit(0)\n        }\n      }\n    })\n  } else {\n    printHelp(console)\n    if (exit) {\n      safeExit(1)\n    }\n  }\n}",
        "invoking_code_segment": "if (require.main === module) {\n  run()\n}",
        "feature_description": "Add support for customizing the output format of the Markdown document.",
        "detailed_feature_description": "The new feature allows users to specify a custom output format for the Markdown document. This is achieved by adding a new command-line argument `--output-format` that accepts values like 'default', 'compact', or 'verbose'. The `run` function in #file 1 is modified to handle this new argument, and the corresponding code in #file 2 is updated to pass this argument to the `run` function.",
        "modified_complete_code": {
            "#file 1": "function run(argv = process.argv.slice(2), { console = global.console, exit = true } = {}) {\n  const args = parseArgs(argv)\n\n  if (args.help) {\n    printHelp(console)\n  } else if (args.version) {\n    console.log(require('../package.json').version)\n  } else if (args._.length === 1) {\n    if (args.require) {\n      const requirePath = resolveFrom('.', args.require)\n      if (requirePath) {\n        require(requirePath)\n      } else {\n        throw new Error(`Could not resolve --require module: ${args.require}`)\n      }\n    }\n    const schemaPath = args._[0]\n    const headers = [].concat(args.header || []).reduce((obj, header) => {\n      const [key, ...value] = String(header).split('=')\n      obj[key] = value.join('=')\n      return obj\n    }, {})\n    const tocFieldTypes = args['toc-fields']\n      ? args['toc-fields'].split(',')\n      : []\n    const loadOptions = { headers }\n    loadSchemaJSON(schemaPath, loadOptions).then((schema) => {\n      const options = {\n        title: args.title,\n        skipTitle: false,\n        prologue: args.prologue,\n        epilogue: args.epilogue,\n        skipTableOfContents: args.toc === false,\n        headingLevel: args['heading-level'],\n        tocFieldTypes,\n        #Modify outputFormat: args['output-format'] || 'default' // New argument to handle output format\n      }\n      if (options.title === false) {\n        options.title = ''\n        options.skipTitle = true\n      } else if (Array.isArray(options.title)) {\n        options.title.forEach((value) => {\n          if (typeof value === 'string') {\n            options.title = value\n          } else if (value === false) {\n            options.skipTitle = true\n          }\n        })\n      }\n      const updateFile = args['update-file']\n      if (updateFile) {\n        updateSchema(updateFile, schema, options)\n          .then(() => {\n            if (exit) {\n              safeExit(0)\n            }\n          })\n          .catch((err) => {\n            console.error(err)\n            if (exit) {\n              safeExit(1)\n            }\n          })\n      } else {\n        renderSchema(schema, options)\n        if (exit) {\n          safeExit(0)\n        }\n      }\n    })\n  } else {\n    printHelp(console)\n    if (exit) {\n      safeExit(1)\n    }\n  }\n}",
            "#file 2": "if (require.main === module) {\n  run()\n}\n\n#New function printHelp(console) {\n  const name = require('../package.json').name\n  console.log(`\n  Usage: ${name} [options] <schema>\n\n  Output a Markdown document with rendered descriptions and links between types.\n  The schema may be specified as:\n\n    - a URL to the GraphQL endpoint (the introspection query will be run)\n    - a GraphQL document containing the schema (.graphql or .gql)\n    - a JSON document containing the schema (as returned by the introspection query)\n    - an importable module with the schema as its default export (either an instance\n      of GraphQLSchema or a JSON object)\n\n  Options:\n\n    --title <string>       Change the top heading title (default: 'Schema Types')\n    --no-title             Do not print a default title\n    --no-toc               Do not print table of contents\n    --toc-fields <list>    Expand the table of contents for the listed types\n                           (comma-separated) to link to fields within those types\n                           (e.g. --toc-fields \"Query,Mutation,Subscription\") or use\n                           the string \"*\" to link to fields for all types\n    --prologue <string>    Include custom Markdown after the title\n    --epilogue <string>    Include custom Markdown after everything else\n    --heading-level <num>  Heading level to begin at, useful if you are embedding the\n                           output in a document with other sections (default: 1)\n    --update-file <file>   Markdown document to update (between comment markers) or\n                           create (if the file does not exist)\n    --require <module>     If importing the schema from a module, require the specified\n                           module first (useful for e.g. babel-register)\n    --header <name=value>  Additional header(s) to use in GraphQL request\n                           e.g. --header \"Authorization=Bearer ey...\"\n    --version              Print version and exit\n    --output-format <format>  Specify the output format for the Markdown document\n                               (default: 'default', options: 'compact', 'verbose')\n`)\n}"
        }
    },
    {
        "repo": "js-yaml-front-matter",
        "content": "'js-yaml-front-matter/dist/yamlFront.js'\n:!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t(require(\"js-yaml\")):\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.yamlFront=t(require(\"js-yaml\")):e.yamlFront=t(e.jsyaml)}(this,(function(e){return function(e){var t={};function n(o){if(t[o])return t[o].exports;var r=t[o]={i:o,l:!1,exports:{}};return e[o].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var r in e)n.d(o,r,function(t){return e[t]}.bind(null,r));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=0)}([function(e,t,n){\"use strict\";function o(e){return(o=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}n.r(t),n.d(t,\"loadFront\",(function(){return f})),n.d(t,\"safeLoadFront\",(function(){return i}));var r=n(1);function u(e,t,n){var u,f=t&&\"string\"==typeof t?t:t&&t.contentKeyName?t.contentKeyName:\"__content\",i=t&&\"object\"===o(t)?t:void 0,c=/^(-{3}(?:\\n|\\r)([\\w\\W]+?)(?:\\n|\\r)-{3})?([\\w\\W]*)*/.exec(e),l={};return(u=c[2])&&(l=\"{\"===u.charAt(0)?JSON.parse(u):n?r.safeLoad(u,i):r.load(u,i)),l[f]=c[3]||\"\",l}function f(e,t){return u(e,t,!1)}function i(e,t){return u(e,t,!0)}},function(t,n){t.exports=e}])}));\n'js-yaml-front-matter/test/js-yaml-front.test.js'\n:var fs = require(\"fs\");\nvar path = require(\"path\");\nvar jsYaml = require(\"../dist/yamlFront\");\nvar should = require(\"should\");\n\ndescribe(\"js-yaml-front\", function() {\n  var results = null;\n  var testStr = null;\n  var testStrWithExtraDashes = null;\n  var testJsonStr = null;\n  var testSafeYamlStr = null;\n\n  var simpleYaml = fs.readFileSync(\n    path.resolve(__dirname, \"./fixtures/yaml.txt\"),\n    \"utf8\"\n  );\n  var yamlWithDashes = fs.readFileSync(\n    path.resolve(__dirname, \"./fixtures/yamlWithExtraDashes.txt\"),\n    \"utf8\"\n  );\n  var safeYaml = fs.readFileSync(\n    path.resolve(__dirname, \"./fixtures/safeYaml.txt\"),\n    \"utf8\"\n  );\n\n  var json = fs.readFileSync(\n    path.resolve(__dirname, \"./fixtures/json.txt\"),\n    \"utf8\"\n  );\n\n  //   var testJsonStr = '---\\n{\"post\": \"title one\",\\n\"anArray\": [\"one\",\"two\"],\\n\"subObject\":\\n';\n  //       testJsonStr += '{\"obj1\": \"cool\", \"obj2\": \"two\"}}\\n---\\ncontent\\nmore';\n\n  beforeEach(function() {\n    results = null;\n    testStr = simpleYaml;\n    testStrWithExtraDashes = yamlWithDashes;\n    testJsonStr = json;\n    testSafeYamlStr = safeYaml;\n  });\n\n  function testSimpleYaml(key) {\n    key = key || \"__content\";\n    results.should.have.property(\"post\", \"title one\");\n    results.should.have.property(\"anArray\");\n    results.anArray.should.containEql(\"one\");\n    results.anArray.should.containEql(\"two\");\n    results.should.have.property(\"subObject\");\n    results.subObject.should.have.property(\"obj1\", \"cool\");\n    results.subObject.should.have.property(\"obj2\", \"two\");\n    results.should.have.property(\"reg\");\n    results.reg.should.be.an.instanceOf(RegExp);\n    results.should.have.property(\"fun\");\n    results.fun.should.Function();\n    results.should.have.property(key);\n    results[key].should.match(/content\\r?\\nmore/);\n  }\n\n  function testYamlWithDashes(key) {\n    key = key || \"__content\";\n    results.subObject.should.have.property(\"obj2\", \"two ---\");\n    results.should.have.property(key);\n    results[key].should.match(/content\\r?\\nmore/);\n  }\n\n  function testSafeYaml(key) {\n    key = key || \"__content\";\n    results.should.not.have.property(\"reg\");\n    results.should.not.have.property(\"fun\");\n    results.should.have.property(key);\n    results[key].should.match(/content\\r?\\nmore/);\n  }\n\n  function testJson(key) {\n    key = key || \"__content\";\n    results.should.have.property(\"post\", \"title one\");\n    results.should.have.property(\"anArray\");\n    results.anArray.should.containEql(\"one\");\n    results.anArray.should.containEql(\"two\");\n    results.should.have.property(\"subObject\");\n    results.subObject.should.have.property(\"obj1\", \"cool\");\n    results.subObject.should.have.property(\"obj2\", \"two\");\n    results.should.have.property(key);\n    results[key].should.match(/content\\r?\\nmore/);\n  }\n\n  describe(\"loadFront\", function() {\n    describe(\"loading yaml\", function() {\n      it(\"should support loading yaml-front-matter\", function() {\n        results = jsYaml.loadFront(testStr);\n        testSimpleYaml();\n      });\n    });\n\n    describe(\"loading yaml with arbitrary dashes\", function() {\n      it(\"should support loading yaml-front-matter with dashes\", function() {\n        results = jsYaml.loadFront(testStrWithExtraDashes);\n        testYamlWithDashes();\n      });\n    });\n\n    describe(\"loading json\", function() {\n      it(\"should support loading json-front-matter\", function() {\n        results = jsYaml.loadFront(testJsonStr);\n        testJson();\n      });\n    });\n\n    describe(\"loading without yaml\", function() {\n      it(\"should support loading files without yaml-front-matter\", function() {\n        results = jsYaml.loadFront(\"Hello World\");\n        results.should.have.property(\"__content\", \"Hello World\");\n      });\n    });\n\n    describe(\"loading empty string\", function() {\n      it(\"should support loading no content\", function() {\n        results = jsYaml.loadFront(\"\");\n        results.should.have.property(\"__content\", \"\");\n      });\n    });\n\n    describe(\"loading with options\", function() {\n      it(\"should support changing content key name through options object\", function() {\n        results = jsYaml.loadFront(testStr, { contentKeyName: \"fileContents\" });\n        testSimpleYaml(\"fileContents\");\n      });\n    });\n\n    describe(\"loading with specifying content key name\", function() {\n      it(\"should support changing content key name with a string\", function() {\n        results = jsYaml.loadFront(testStr, \"fileContents\");\n        testSimpleYaml(\"fileContents\");\n      });\n    });\n  }); // End describe loadFront\n\n  describe(\"safeLoadFront\", function() {\n    describe(\"loading safe yaml\", function() {\n      it(\"should support loading yaml-front-matter without RegExp or functions\", function() {\n        results = jsYaml.safeLoadFront(testSafeYamlStr);\n        testSafeYaml();\n      });\n    });\n\n    describe(\"loading yaml\", function() {\n      it(\"should not support loading yaml-front-matter that contain RegExp or functions\", function() {\n        jsYaml.safeLoadFront.bind(this, testStr).should.throw();\n      });\n    });\n  }); // End describe safeLoadFront\n}); // End describe js-yaml-front\n\n",
        "called_code_segment": "function u(e,t,n){var u,f=t&&'string'==typeof t?t:t&&t.contentKeyName?t.contentKeyName:'__content',i=t&&'object'===o(t)?t:void 0,c=/^(-{3}(?:\n|\r)([wW]+?)(?:\n|\r)-{3})?([wW]*)*/.exec(e),l={};return(u=c[2])&&(l='{'===u.charAt(0)?JSON.parse(u):n?r.safeLoad(u,i):r.load(u,i)),l[f]=c[3]||'',l}",
        "invoking_code_segment": "results = jsYaml.loadFront(testStr, { contentKeyName: 'fileContents' });",
        "feature_description": "Add support for custom delimiters in YAML front matter.",
        "detailed_feature_description": "Modify the `u` function in #file 1 to accept an optional delimiter parameter. Update the invoking code in #file 2 to pass a custom delimiter when calling `loadFront`.",
        "modified_complete_code": {
            "file1": "function u(e,t,n,d){var u,f=t&&'string'==typeof t?t:t&&t.contentKeyName?t.contentKeyName:'__content',i=t&&'object'===o(t)?t:void 0,c=/^(' + (d || '-{3}') + '(?:\n|\r)([wW]+?)(?:\n|\r)' + (d || '-{3}') + ')?([wW]*)*/.exec(e),l={};return(u=c[2])&&(l='{'===u.charAt(0)?JSON.parse(u):n?r.safeLoad(u,i):r.load(u,i)),l[f]=c[3]||'',l} #Modify",
            "file2": "results = jsYaml.loadFront(testStr, { contentKeyName: 'fileContents', delimiter: '---' }); #Modify\n\n// New test case for custom delimiter\ndescribe('loading with custom delimiter', function() {\n  it('should support loading yaml-front-matter with custom delimiter', function() {\n    results = jsYaml.loadFront(testStr, { delimiter: '~~~' });\n    testSimpleYaml();\n  });\n}); #New"
        }
    },
    {
        "repo": "jscanify",
        "content": "'jscanify/src/jscanify-node.js'\n:/*! jscanify v1.2.0 | (c) ColonelParrot and other contributors | MIT License */\n\nconst { Canvas, createCanvas, Image, ImageData } = require(\"canvas\");\nconst { JSDOM } = require(\"jsdom\");\n\nfunction installDOM() {\n  const dom = new JSDOM();\n\n  global.document = dom.window.document;\n  global.Image = Image;\n  global.HTMLCanvasElement = Canvas;\n  global.ImageData = ImageData;\n  global.HTMLImageElement = Image;\n}\n\nlet cv;\n\n/**\n * Calculates distance between two points. Each point must have `x` and `y` property\n * @param {*} p1 point 1\n * @param {*} p2 point 2\n * @returns distance between two points\n */\nfunction distance(p1, p2) {\n  return Math.hypot(p1.x - p2.x, p1.y - p2.y);\n}\n\nclass jscanify {\n  constructor() {\n    installDOM();\n  }\n\n  loadOpenCV(callback) {\n    cv = require(\"./opencv\");\n    cv[\"onRuntimeInitialized\"] = () => {\n      callback(cv);\n    };\n  }\n\n  /**\n   * Finds the contour of the paper within the image\n   * @param {*} img image to process (cv.Mat)\n   * @returns the biggest contour inside the image\n   */\n  findPaperContour(img) {\n    const imgGray = new cv.Mat();\n    cv.cvtColor(img, imgGray, cv.COLOR_RGBA2GRAY);\n\n    const imgBlur = new cv.Mat();\n    cv.GaussianBlur(\n      imgGray,\n      imgBlur,\n      new cv.Size(5, 5),\n      0,\n      0,\n      cv.BORDER_DEFAULT\n    );\n\n    const imgThresh = new cv.Mat();\n    cv.threshold(imgBlur, imgThresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);\n\n    let contours = new cv.MatVector();\n    let hierarchy = new cv.Mat();\n\n    cv.findContours(\n      imgThresh,\n      contours,\n      hierarchy,\n      cv.RETR_CCOMP,\n      cv.CHAIN_APPROX_SIMPLE\n    );\n    let maxArea = 0;\n    let maxContourIndex = -1;\n    for (let i = 0; i < contours.size(); ++i) {\n      let contourArea = cv.contourArea(contours.get(i));\n      if (contourArea > maxArea) {\n        maxArea = contourArea;\n        maxContourIndex = i;\n      }\n    }\n\n    const maxContour = contours.get(maxContourIndex);\n\n    imgGray.delete();\n    imgBlur.delete();\n    imgThresh.delete();\n    contours.delete();\n    hierarchy.delete();\n    return maxContour;\n  }\n\n  /**\n   * Highlights the paper detected inside the image.\n   * @param {*} image image to process\n   * @param {*} options options for highlighting. Accepts `color` and `thickness` parameter\n   * @returns `HTMLCanvasElement` with original image and paper highlighted\n   */\n  highlightPaper(image, options) {\n    options = options || {};\n    options.color = options.color || \"orange\";\n    options.thickness = options.thickness || 10;\n    const canvas = createCanvas();\n    const ctx = canvas.getContext(\"2d\");\n    const img = cv.imread(image);\n\n    const maxContour = this.findPaperContour(img);\n    cv.imshow(canvas, img);\n    if (maxContour) {\n      const {\n        topLeftCorner,\n        topRightCorner,\n        bottomLeftCorner,\n        bottomRightCorner,\n      } = this.getCornerPoints(maxContour, img);\n\n      if (\n        topLeftCorner &&\n        topRightCorner &&\n        bottomLeftCorner &&\n        bottomRightCorner\n      ) {\n        ctx.strokeStyle = options.color;\n        ctx.lineWidth = options.thickness;\n        ctx.beginPath();\n        ctx.moveTo(...Object.values(topLeftCorner));\n        ctx.lineTo(...Object.values(topRightCorner));\n        ctx.lineTo(...Object.values(bottomRightCorner));\n        ctx.lineTo(...Object.values(bottomLeftCorner));\n        ctx.lineTo(...Object.values(topLeftCorner));\n        ctx.stroke();\n      }\n    }\n\n    img.delete();\n    return canvas;\n  }\n\n  /**\n   * Extracts and undistorts the image detected within the frame.\n   * @param {*} image image to process\n   * @param {*} resultWidth desired result paper width\n   * @param {*} resultHeight desired result paper height\n   * @param {*} cornerPoints optional custom corner points, in case automatic corner points are incorrect\n   * @returns `HTMLCanvasElement` containing undistorted image\n   */\n  extractPaper(image, resultWidth, resultHeight, cornerPoints) {\n    const canvas = createCanvas();\n    const img = cv.imread(image);\n    const maxContour = this.findPaperContour(img);\n    const {\n      topLeftCorner,\n      topRightCorner,\n      bottomLeftCorner,\n      bottomRightCorner,\n    } = cornerPoints || this.getCornerPoints(maxContour, img);\n    let warpedDst = new cv.Mat();\n    let dsize = new cv.Size(resultWidth, resultHeight);\n    let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [\n      topLeftCorner.x,\n      topLeftCorner.y,\n      topRightCorner.x,\n      topRightCorner.y,\n      bottomLeftCorner.x,\n      bottomLeftCorner.y,\n      bottomRightCorner.x,\n      bottomRightCorner.y,\n    ]);\n    let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [\n      0,\n      0,\n      resultWidth,\n      0,\n      0,\n      resultHeight,\n      resultWidth,\n      resultHeight,\n    ]);\n    let M = cv.getPerspectiveTransform(srcTri, dstTri);\n    cv.warpPerspective(\n      img,\n      warpedDst,\n      M,\n      dsize,\n      cv.INTER_LINEAR,\n      cv.BORDER_CONSTANT,\n      new cv.Scalar()\n    );\n\n    cv.imshow(canvas, warpedDst);\n\n    img.delete();\n    warpedDst.delete();\n    return canvas;\n  }\n\n  /**\n   * Calculates the corner points of a contour.\n   * @param {*} contour contour from {@link findPaperContour}\n   * @returns object with properties `topLeftCorner`, `topRightCorner`, `bottomLeftCorner`, `bottomRightCorner`, each with `x` and `y` property\n   */\n  getCornerPoints(contour) {\n    let rect = cv.minAreaRect(contour);\n    const center = rect.center;\n\n    let topLeftCorner;\n    let topLeftCornerDist = 0;\n\n    let topRightCorner;\n    let topRightCornerDist = 0;\n\n    let bottomLeftCorner;\n    let bottomLeftCornerDist = 0;\n\n    let bottomRightCorner;\n    let bottomRightCornerDist = 0;\n\n    for (let i = 0; i < contour.data32S.length; i += 2) {\n      const point = { x: contour.data32S[i], y: contour.data32S[i + 1] };\n      const dist = distance(point, center);\n      if (point.x < center.x && point.y < center.y) {\n        // top left\n        if (dist > topLeftCornerDist) {\n          topLeftCorner = point;\n          topLeftCornerDist = dist;\n        }\n      } else if (point.x > center.x && point.y < center.y) {\n        // top right\n        if (dist > topRightCornerDist) {\n          topRightCorner = point;\n          topRightCornerDist = dist;\n        }\n      } else if (point.x < center.x && point.y > center.y) {\n        // bottom left\n        if (dist > bottomLeftCornerDist) {\n          bottomLeftCorner = point;\n          bottomLeftCornerDist = dist;\n        }\n      } else if (point.x > center.x && point.y > center.y) {\n        // bottom right\n        if (dist > bottomRightCornerDist) {\n          bottomRightCorner = point;\n          bottomRightCornerDist = dist;\n        }\n      }\n    }\n\n    return {\n      topLeftCorner,\n      topRightCorner,\n      bottomLeftCorner,\n      bottomRightCorner,\n    };\n  }\n}\n\nmodule.exports = jscanify;\n\n'jscanify/test/tests.js'\n:/*\n  run tests with: npm test\n*/\n\nconsole.log(\"RUNNING JSCANIFY TESTS\");\nconsole.log(\"Warning: This may take a bit\");\n\nconst { loadImage, createCanvas } = require(\"canvas\");\nconst { mkdirSync, writeFileSync, unlinkSync, existsSync } = require(\"fs\");\nconst assert = require(\"assert\");\n\nconst jscanify = require(\"../src/jscanify-node\");\nconst path = require(\"path\");\n\nconst outputPaths = {\n  highlight: __dirname + \"/output/highlighted.jpg\",\n  extracted: __dirname + \"/output/extracted.jpg\",\n  cornerPoints: __dirname + \"/output/corner_points.jpg\",\n};\n\nconst baseFolder = __dirname.replaceAll(\"\\\\\", \"/\") + \"/output/\";\n\nconst TEST_IMAGE_PATH = path.join(\n  __dirname,\n  \"..\",\n  \"docs\",\n  \"images\",\n  \"test\",\n  \"test.png\"\n);\n\nfunction setup() {\n  console.log(\"=== setting up tests ===\");\n  console.log(\"Deleting previously generated images\");\n  Object.values(outputPaths).forEach((path) => {\n    if (existsSync(path)) {\n      unlinkSync(path);\n    }\n  });\n\n  if (!existsSync(baseFolder)) {\n    mkdirSync(baseFolder);\n  }\n}\n\nfunction test() {\n  const scanner = new jscanify();\n\n  console.log(\"=== beginning  tests ===\");\n  console.log(\"loading OpenCV.js...\");\n  scanner.loadOpenCV(function (cv) {\n    console.log(\"Finished loading OpenCV.js\");\n    console.log(\"Writing test images to: \" + baseFolder);\n    describe(\"feature tests\", function () {\n      it(\"should highlight paper\", function (done) {\n        const highlighted = scanner.highlightPaper(testImage);\n        writeFileSync(\n          outputPaths.highlight,\n          highlighted.toBuffer(\"image/jpeg\")\n        );\n\n        assert.ok(existsSync(outputPaths.highlight));\n        done();\n      });\n\n      it(\"should extract paper\", function (done) {\n        const extracted = scanner.extractPaper(testImage, 386, 500);\n        writeFileSync(\n          outputPaths.extracted,\n          extracted.toBuffer(\"image/jpeg\")\n        );\n\n        assert.ok(existsSync(outputPaths.extracted));\n        done();\n      });\n\n      it(\"should label corner points\", function (done) {\n        const parsedImage = cv.imread(testImage);\n        const paperContour = scanner.findPaperContour(parsedImage);\n        const {\n          topLeftCorner,\n          topRightCorner,\n          bottomLeftCorner,\n          bottomRightCorner,\n        } = scanner.getCornerPoints(paperContour, testImage);\n\n        const canvas = createCanvas();\n\n        cv.imshow(canvas, parsedImage);\n        const ctx = canvas.getContext(\"2d\");\n        const points = [\n          { p: topLeftCorner, text: \"top left corner\" },\n          { p: topRightCorner, text: \"top right corner\" },\n          { p: bottomLeftCorner, text: \"bottom left corner\" },\n          { p: bottomRightCorner, text: \"bottom right corner\" },\n        ];\n        ctx.fillStyle = \"cyan\";\n        ctx.font = \"25px serif\";\n        points.forEach(({ p: point, text }) => {\n          ctx.beginPath();\n          ctx.arc(point.x, point.y, 15, 0, 2 * Math.PI, false);\n          ctx.fillText(text, point.x + 30, point.y)\n          ctx.fill();\n        });\n\n        writeFileSync(outputPaths.cornerPoints, canvas.toBuffer(\"image/jpeg\"));\n\n        assert.ok(existsSync(outputPaths.cornerPoints));\n        done();\n      });\n    });\n  });\n}\n\nlet testImage;\nloadImage(TEST_IMAGE_PATH).then(function (image) {\n  testImage = image;\n  setup();\n  test();\n});\n\n",
        "called_code_segment": "function findPaperContour(img) {\n  const imgGray = new cv.Mat();\n  cv.cvtColor(img, imgGray, cv.COLOR_RGBA2GRAY);\n\n  const imgBlur = new cv.Mat();\n  cv.GaussianBlur(\n    imgGray,\n    imgBlur,\n    new cv.Size(5, 5),\n    0,\n    0,\n    cv.BORDER_DEFAULT\n  );\n\n  const imgThresh = new cv.Mat();\n  cv.threshold(imgBlur, imgThresh, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);\n\n  let contours = new cv.MatVector();\n  let hierarchy = new cv.Mat();\n\n  cv.findContours(\n    imgThresh,\n    contours,\n    hierarchy,\n    cv.RETR_CCOMP,\n    cv.CHAIN_APPROX_SIMPLE\n  );\n  let maxArea = 0;\n  let maxContourIndex = -1;\n  for (let i = 0; i < contours.size(); ++i) {\n    let contourArea = cv.contourArea(contours.get(i));\n    if (contourArea > maxArea) {\n      maxArea = contourArea;\n      maxContourIndex = i;\n    }\n  }\n\n  const maxContour = contours.get(maxContourIndex);\n\n  imgGray.delete();\n  imgBlur.delete();\n  imgThresh.delete();\n  contours.delete();\n  hierarchy.delete();\n  return maxContour;\n}",
        "invoking_code_segment": "const maxContour = this.findPaperContour(img);\n  cv.imshow(canvas, img);\n  if (maxContour) {\n    const { topLeftCorner, topRightCorner, bottomLeftCorner, bottomRightCorner } = this.getCornerPoints(maxContour, img);\n\n    if (topLeftCorner && topRightCorner && bottomLeftCorner && bottomRightCorner) {\n      ctx.strokeStyle = options.color;\n      ctx.lineWidth = options.thickness;\n      ctx.beginPath();\n      ctx.moveTo(...Object.values(topLeftCorner));\n      ctx.lineTo(...Object.values(topRightCorner));\n      ctx.lineTo(...Object.values(bottomRightCorner));\n      ctx.lineTo(...Object.values(bottomLeftCorner));\n      ctx.lineTo(...Object.values(topLeftCorner));\n      ctx.stroke();\n    }\n  }\n\n  img.delete();\n  return canvas;",
        "feature_description": "Add a feature to allow customizing the threshold value for contour detection.",
        "detailed_feature_description": "Modify the `findPaperContour` function to accept an optional threshold parameter. Update the `highlightPaper` method to pass this parameter when invoking `findPaperContour`.",
        "modified_complete_code": {
            "jscanify/src/jscanify-node.js": "function findPaperContour(img, threshold = 0) {\n  const imgGray = new cv.Mat();\n  cv.cvtColor(img, imgGray, cv.COLOR_RGBA2GRAY);\n\n  const imgBlur = new cv.Mat();\n  cv.GaussianBlur(\n    imgGray,\n    imgBlur,\n    new cv.Size(5, 5),\n    0,\n    0,\n    cv.BORDER_DEFAULT\n  );\n\n  const imgThresh = new cv.Mat();\n  cv.threshold(imgBlur, imgThresh, threshold, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);\n\n  let contours = new cv.MatVector();\n  let hierarchy = new cv.Mat();\n\n  cv.findContours(\n    imgThresh,\n    contours,\n    hierarchy,\n    cv.RETR_CCOMP,\n    cv.CHAIN_APPROX_SIMPLE\n  );\n  let maxArea = 0;\n  let maxContourIndex = -1;\n  for (let i = 0; i < contours.size(); ++i) {\n    let contourArea = cv.contourArea(contours.get(i));\n    if (contourArea > maxArea) {\n      maxArea = contourArea;\n      maxContourIndex = i;\n    }\n  }\n\n  const maxContour = contours.get(maxContourIndex);\n\n  imgGray.delete();\n  imgBlur.delete();\n  imgThresh.delete();\n  contours.delete();\n  hierarchy.delete();\n  return maxContour;\n}",
            "jscanify/test/tests.js": "const maxContour = this.findPaperContour(img, options.threshold);\n  cv.imshow(canvas, img);\n  if (maxContour) {\n    const { topLeftCorner, topRightCorner, bottomLeftCorner, bottomRightCorner } = this.getCornerPoints(maxContour, img);\n\n    if (topLeftCorner && topRightCorner && bottomLeftCorner && bottomRightCorner) {\n      ctx.strokeStyle = options.color;\n      ctx.lineWidth = options.thickness;\n      ctx.beginPath();\n      ctx.moveTo(...Object.values(topLeftCorner));\n      ctx.lineTo(...Object.values(topRightCorner));\n      ctx.lineTo(...Object.values(bottomRightCorner));\n      ctx.lineTo(...Object.values(bottomLeftCorner));\n      ctx.lineTo(...Object.values(topLeftCorner));\n      ctx.stroke();\n    }\n  }\n\n  img.delete();\n  return canvas;\n\n#New\noptions.threshold = options.threshold || 0;"
        }
    },
    {
        "repo": "mime-db",
        "content": "'mime-db/scripts/lib/write-db.js'\n:/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\nvar fs = require('fs')\n\nmodule.exports = function writeDatabaseSync (fileName, obj) {\n  var fd = fs.openSync(fileName, 'w')\n  var keys = Object.keys(obj).sort()\n\n  fs.writeSync(fd, '{\\n')\n\n  keys.forEach(function (key, i, arr) {\n    fs.writeSync(fd, '  ' + JSON.stringify(key) + ': {')\n\n    var end = endLine.apply(this, arguments)\n    var data = obj[key]\n    var keys = Object.keys(data).sort(sortDataKeys)\n\n    if (keys.length === 0) {\n      fs.writeSync(fd, '}' + end)\n      return\n    }\n\n    fs.writeSync(fd, '\\n')\n    keys.forEach(function (key, i, arr) {\n      var end = endLine.apply(this, arguments)\n      var val = data[key]\n\n      if (val !== undefined) {\n        var str = Array.isArray(val) && val.some(function (v) { return String(v).length > 15 })\n          ? JSON.stringify(val, null, 2).split('\\n').join('\\n    ')\n          : JSON.stringify(val)\n\n        fs.writeSync(fd, '    ' + JSON.stringify(key) + ': ' + str + end)\n      }\n    })\n\n    fs.writeSync(fd, '  }' + end)\n  })\n\n  fs.writeSync(fd, '}\\n')\n\n  fs.closeSync(fd)\n}\n\nfunction endLine (key, i, arr) {\n  var comma = i + 1 === arr.length\n    ? ''\n    : ','\n  return comma + '\\n'\n}\n\nfunction sortDataKeys (a, b) {\n  var cmp = a.localeCompare(b)\n\n  return cmp && (a === 'source' || b === 'source')\n    ? (a === 'source' ? -1 : 1)\n    : cmp\n}\n\n'mime-db/scripts/fetch-nginx.js'\n:/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2023 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Convert these text files to JSON for browser usage.\n */\n\nvar got = require('got')\nvar writedb = require('./lib/write-db')\n\n/**\n * Mime types and associated extensions are stored in the form:\n *\n *   <type> <ext> <ext> <ext>;\n */\nvar TYPE_LINE_REGEXP = /^\\s*([\\w-]+\\/[\\w+.-]+)((?:\\s+[\\w-]+)*);\\s*$/gm\n\n/**\n * URL for the mime.types file in the NGINX project source.\n *\n * This uses the Github.com mirror of the Mercurial repository\n * as the Mercurial web interface requires cookies.\n */\nvar URL = 'https://raw.githubusercontent.com/nginx/nginx/master/conf/mime.types'\n\n;(async function () {\n  const res = await got(URL)\n\n  var json = {}\n  var match = null\n\n  TYPE_LINE_REGEXP.index = 0\n\n  while ((match = TYPE_LINE_REGEXP.exec(res.body))) {\n    var mime = match[1]\n\n    // parse the extensions\n    var extensions = (match[2] || '')\n      .split(/\\s+/)\n      .filter(Boolean)\n    var data = json[mime] || (json[mime] = {})\n\n    // append the extensions\n    appendExtensions(data, extensions)\n  }\n\n  writedb('src/nginx-types.json', json)\n}())\n\n/**\n * Append an extension to an object.\n */\nfunction appendExtension (obj, extension) {\n  if (!obj.extensions) {\n    obj.extensions = []\n  }\n\n  if (obj.extensions.indexOf(extension) === -1) {\n    obj.extensions.push(extension)\n  }\n}\n\n/**\n * Append extensions to an object.\n */\nfunction appendExtensions (obj, extensions) {\n  if (extensions.length === 0) {\n    return\n  }\n\n  for (var i = 0; i < extensions.length; i++) {\n    var extension = extensions[i]\n\n    // add extension to the type entry\n    appendExtension(obj, extension)\n  }\n}\n\n",
        "called_code_segment": "module.exports = function writeDatabaseSync (fileName, obj) {\n  var fd = fs.openSync(fileName, 'w')\n  var keys = Object.keys(obj).sort()\n\n  fs.writeSync(fd, '{\\n')\n\n  keys.forEach(function (key, i, arr) {\n    fs.writeSync(fd, '  ' + JSON.stringify(key) + ': {')\n\n    var end = endLine.apply(this, arguments)\n    var data = obj[key]\n    var keys = Object.keys(data).sort(sortDataKeys)\n\n    if (keys.length === 0) {\n      fs.writeSync(fd, '}' + end)\n      return\n    }\n\n    fs.writeSync(fd, '\\n')\n    keys.forEach(function (key, i, arr) {\n      var end = endLine.apply(this, arguments)\n      var val = data[key]\n\n      if (val !== undefined) {\n        var str = Array.isArray(val) && val.some(function (v) { return String(v).length > 15 }) ? JSON.stringify(val, null, 2).split('\\n').join('\\n    ') : JSON.stringify(val)\n\n        fs.writeSync(fd, '    ' + JSON.stringify(key) + ': ' + str + end)\n      }\n    })\n\n    fs.writeSync(fd, '  }' + end)\n  })\n\n  fs.writeSync(fd, '}\\n')\n\n  fs.closeSync(fd)\n}",
        "invoking_code_segment": "var writedb = require('./lib/write-db')\n\n;(async function () {\n  const res = await got(URL)\n\n  var json = {}\n  var match = null\n\n  TYPE_LINE_REGEXP.index = 0\n\n  while ((match = TYPE_LINE_REGEXP.exec(res.body))) {\n    var mime = match[1]\n\n    // parse the extensions\n    var extensions = (match[2] || '').split(/\\s+/).filter(Boolean)\n    var data = json[mime] || (json[mime] = {})\n\n    // append the extensions\n    appendExtensions(data, extensions)\n  }\n\n  writedb('src/nginx-types.json', json)\n}())",
        "feature_description": "Add a timestamp to the JSON file generated by writeDatabaseSync.",
        "detailed_feature_description": "Modify the writeDatabaseSync function to include a timestamp in the JSON file. Update the invoking code to pass the current timestamp to the writeDatabaseSync function.",
        "modified_complete_code": {
            "file1": "module.exports = function writeDatabaseSync (fileName, obj, timestamp) {\n  var fd = fs.openSync(fileName, 'w')\n  var keys = Object.keys(obj).sort()\n\n  fs.writeSync(fd, '{\\n')\n\n  keys.forEach(function (key, i, arr) {\n    fs.writeSync(fd, '  ' + JSON.stringify(key) + ': {')\n\n    var end = endLine.apply(this, arguments)\n    var data = obj[key]\n    var keys = Object.keys(data).sort(sortDataKeys)\n\n    if (keys.length === 0) {\n      fs.writeSync(fd, '}' + end)\n      return\n    }\n\n    fs.writeSync(fd, '\\n')\n    keys.forEach(function (key, i, arr) {\n      var end = endLine.apply(this, arguments)\n      var val = data[key]\n\n      if (val !== undefined) {\n        var str = Array.isArray(val) && val.some(function (v) { return String(v).length > 15 }) ? JSON.stringify(val, null, 2).split('\\n').join('\\n    ') : JSON.stringify(val)\n\n        fs.writeSync(fd, '    ' + JSON.stringify(key) + ': ' + str + end)\n      }\n    })\n\n    fs.writeSync(fd, '  }' + end)\n  })\n\n  fs.writeSync(fd, '  \\\"timestamp\\\": ' + JSON.stringify(timestamp) + '\\n')\n  fs.writeSync(fd, '}\\n')\n\n  fs.closeSync(fd)\n}",
            "file2": "var writedb = require('./lib/write-db')\n\n;(async function () {\n  const res = await got(URL)\n\n  var json = {}\n  var match = null\n\n  TYPE_LINE_REGEXP.index = 0\n\n  while ((match = TYPE_LINE_REGEXP.exec(res.body))) {\n    var mime = match[1]\n\n    // parse the extensions\n    var extensions = (match[2] || '').split(/\\s+/).filter(Boolean)\n    var data = json[mime] || (json[mime] = {})\n\n    // append the extensions\n    appendExtensions(data, extensions)\n  }\n\n  var timestamp = new Date().toISOString()\n  writedb('src/nginx-types.json', json, timestamp)\n}())"
        }
    },
    {
        "repo": "modern-desktop-app-template",
        "content": "'modern-desktop-app-template/src/common/utils.js'\n:\nimport Cookies from 'js-cookie';\nimport localforage from 'localforage';\nimport { useEffect, useLayoutEffect, useState } from 'react';\nimport packageJson from '../../package.json';\nexport { localforage };\n\nexport const HEADER_TITLE = 'HEADER_TITLE goes here';\nexport const FOOTER = 'FOOTER goes here';\nexport const VERSION = packageJson.version;\n\nexport const IS_DEVELOPMENT = import.meta.env.MODE === 'development';\nexport const IS_PRODUCTION = !IS_DEVELOPMENT;\n\nexport function useCookie(key, defaultValue, { expires = 365000, sameSite = 'lax', path = '/' } = {}) {\n    // cookie expires in a millenia\n    // sameSite != 'strict' because the cookie is not read for sensitive actions\n    // synchronous\n    const cookieValue = Cookies.get(key);\n    const [state, setState] = useState(cookieValue || defaultValue);\n    useEffect(() => {\n        Cookies.set(key, state, { expires, sameSite, path });\n    }, [state]);\n    return [state, setState];\n}\n\nexport function trueTypeOf(obj) {\n    return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase()\n    /*\n        []              -> array\n        {}              -> object\n        ''              -> string\n        new Date()      -> date\n        1               -> number\n        function () {}  -> function\n        async function () {}  -> asyncfunction\n        /test/i         -> regexp\n        true            -> boolean\n        null            -> null\n        trueTypeOf()    -> undefined\n    */\n}\n\n// https://reactjs.org/docs/hooks-custom.html\nexport function useLocalForage(key, defaultValue) {\n    // only supports primitives, arrays, and {} objects\n    const [state, setState] = useState(defaultValue);\n    const [loading, setLoading] = useState(true);\n\n    // useLayoutEffect will be called before DOM paintings and before useEffect\n    useLayoutEffect(() => {\n        let allow = true;\n        localforage.getItem(key)\n            .then(value => {\n                if (value === null) throw '';\n                if (allow) setState(value);\n            }).catch(() => localforage.setItem(key, defaultValue))\n            .then(() => {\n                if (allow) setLoading(false);\n            });\n        return () => allow = false;\n    }, []);\n    // useLayoutEffect does not like Promise return values.\n    useEffect(() => {\n        // do not allow setState to be called before data has even been loaded!\n        // this prevents overwriting\n        if (!loading) localforage.setItem(key, state);\n    }, [state]);\n    return [state, setState, loading];\n}\n\n// show browser / native notification\nexport function notify(title, body) {\n    new Notification(title, { body: body || \"\", });\n}\n\nexport function sleep(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nexport function downloadFile(filename, content, contentType='text/plain') {\n    const element = document.createElement('a');\n    const file = new Blob([content], { type: contentType });\n    element.href = URL.createObjectURL(file);\n    element.download = filename;\n    document.body.appendChild(element); // Required for this to work in FireFox\n    element.click();\n}\n\nMath.clamp = (num, min, max) => Math.min(Math.max(num, min), max);\n\n\nexport function arraysEqual(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length !== b.length) return false;\n\n    // If you don't care about the order of the elements inside\n    // the array, you should sort both arrays here.\n    // Please note that calling sort on an array will modify that array.\n    // you might want to clone your array first.\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\n'modern-desktop-app-template/src/views/LoginView.jsx'\n:import { Box, Button, Center, Group, TextInput, Title } from '@mantine/core';\nimport { useForm } from '@mantine/form';\nimport { useTranslation } from 'react-i18next';\nimport { HEADER_TITLE } from '../common/utils';\n\nexport default function Login({ setLogin }) {\n    const { t } = useTranslation();\n    const form = useForm({\n        initialValues: {\n            account: '',\n            email: '',\n        },\n    });\n\n    const handleSubmit = values => {\n        console.log(values);\n    }\n\n    const accountProps = form.getInputProps('account');\n    let accountNumber = accountProps.value;\n    let accountError = (accountNumber === '' || !isNaN(accountNumber) && !isNaN(parseFloat(accountNumber))) ? undefined : t('accountInputError');\n\n    return <>\n        <Center style={{ height: '15vh', marginTop: '15vh' }}>\n            <Title>{HEADER_TITLE}</Title>\n        </Center>\n        {/* TODO show logo */}\n        <Center style={{ height: '50vh' }}>\n            <Box maw={400} mx='auto' w='30vw'>\n                <form onSubmit={form.onSubmit(handleSubmit)}>\n                    <TextInput required autoFocus label={t('Account Number')} placeholder='XXXXXXXXXXXXXXXXXXX' {...form.getInputProps('account')} error={accountError} />\n                    {/* <TextInput required mt='md' label='Email' placeholder='Email' {...form.getInputProps('email')} /> */}\n                    <Group justify='center' mt='xl'>\n                        <Button type='submit' variant='outline' w=\"100%\">{t('Login')}</Button>\n                    </Group>\n                </form>\n            </Box>\n        </Center>\n    </>;\n}\n\n",
        "called_code_segment": "export function useCookie(key, defaultValue, { expires = 365000, sameSite = 'lax', path = '/' } = {}) {\n    // cookie expires in a millenia\n    // sameSite != 'strict' because the cookie is not read for sensitive actions\n    // synchronous\n    const cookieValue = Cookies.get(key);\n    const [state, setState] = useState(cookieValue || defaultValue);\n    useEffect(() => {\n        Cookies.set(key, state, { expires, sameSite, path });\n    }, [state]);\n    return [state, setState];\n}",
        "invoking_code_segment": "const [language, setLanguage] = useCookie('language', 'en');",
        "feature_description": "Add a feature to allow users to set a custom expiration date for cookies.",
        "detailed_feature_description": "Modify the `useCookie` function to accept an optional `expires` parameter. Update the invoking code to handle the new parameter and set a custom expiration date.",
        "modified_complete_code": {
            "file1": "// modern-desktop-app-template/src/common/utils.js\nimport Cookies from 'js-cookie';\nimport localforage from 'localforage';\nimport { useEffect, useLayoutEffect, useState } from 'react';\nimport packageJson from '../../package.json';\nexport { localforage };\n\nexport const HEADER_TITLE = 'HEADER_TITLE goes here';\nexport const FOOTER = 'FOOTER goes here';\nexport const VERSION = packageJson.version;\n\nexport const IS_DEVELOPMENT = import.meta.env.MODE === 'development';\nexport const IS_PRODUCTION = !IS_DEVELOPMENT;\n\n#Modify\nexport function useCookie(key, defaultValue, { expires = 365000, sameSite = 'lax', path = '/' } = {}) {\n    // cookie expires in a millenia\n    // sameSite != 'strict' because the cookie is not read for sensitive actions\n    // synchronous\n    const cookieValue = Cookies.get(key);\n    const [state, setState] = useState(cookieValue || defaultValue);\n    useEffect(() => {\n        Cookies.set(key, state, { expires, sameSite, path });\n    }, [state]);\n    return [state, setState];\n}",
            "file2": "// modern-desktop-app-template/src/views/LoginView.jsx\nimport { Box, Button, Center, Group, TextInput, Title } from '@mantine/core';\nimport { useForm } from '@mantine/form';\nimport { useTranslation } from 'react-i18next';\nimport { HEADER_TITLE, useCookie } from '../common/utils';\n\nexport default function Login({ setLogin }) {\n    const { t } = useTranslation();\n    const form = useForm({\n        initialValues: {\n            account: '',\n            email: '',\n        },\n    });\n\n    const handleSubmit = values => {\n        console.log(values);\n    }\n\n    const accountProps = form.getInputProps('account');\n    let accountNumber = accountProps.value;\n    let accountError = (accountNumber === '' || !isNaN(accountNumber) && !isNaN(parseFloat(accountNumber))) ? undefined : t('accountInputError');\n\n    #Modify\n    const [language, setLanguage] = useCookie('language', 'en', { expires: 7 }); // Set custom expiration date to 7 days\n\n    return <>;\n        <Center style={{ height: '15vh', marginTop: '15vh' }}>\n            <Title>{HEADER_TITLE}</Title>\n        </Center>\n        {/* TODO show logo */}\n        <Center style={{ height: '50vh' }}>\n            <Box maw={400} mx='auto' w='30vw'>\n                <form onSubmit={form.onSubmit(handleSubmit)}>\n                    <TextInput required autoFocus label={t('Account Number')} placeholder='XXXXXXXXXXXXXXXXXXX' {...form.getInputProps('account')} error={accountError} />\n                    {/* <TextInput required mt='md' label='Email' placeholder='Email' {...form.getInputProps('email')} /> */}\n                    <Group justify='center' mt='xl'>\n                        <Button type='submit' variant='outline' w=\"100%\">{t('Login')}</Button>\n                    </Group>\n                </form>\n            </Box>\n        </Center>\n    </>;\n}"
        }
    },
    {
        "repo": "multiplayerSnake",
        "content": "'multiplayerSnake/server/utils.js'\n:module.exports = {\n  makeid,\n}\n\nfunction makeid(length) {\n   var result           = '';\n   var characters       = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n   var charactersLength = characters.length;\n   for ( var i = 0; i < length; i++ ) {\n      result += characters.charAt(Math.floor(Math.random() * charactersLength));\n   }\n   return result;\n}\n\n'multiplayerSnake/server/server.js'\n:const io = require('socket.io')();\nconst { initGame, gameLoop, getUpdatedVelocity } = require('./game');\nconst { FRAME_RATE } = require('./constants');\nconst { makeid } = require('./utils');\n\nconst state = {};\nconst clientRooms = {};\n\nio.on('connection', client => {\n\n  client.on('keydown', handleKeydown);\n  client.on('newGame', handleNewGame);\n  client.on('joinGame', handleJoinGame);\n\n  function handleJoinGame(roomName) {\n    const room = io.sockets.adapter.rooms[roomName];\n\n    let allUsers;\n    if (room) {\n      allUsers = room.sockets;\n    }\n\n    let numClients = 0;\n    if (allUsers) {\n      numClients = Object.keys(allUsers).length;\n    }\n\n    if (numClients === 0) {\n      client.emit('unknownCode');\n      return;\n    } else if (numClients > 1) {\n      client.emit('tooManyPlayers');\n      return;\n    }\n\n    clientRooms[client.id] = roomName;\n\n    client.join(roomName);\n    client.number = 2;\n    client.emit('init', 2);\n    \n    startGameInterval(roomName);\n  }\n\n  function handleNewGame() {\n    let roomName = makeid(5);\n    clientRooms[client.id] = roomName;\n    client.emit('gameCode', roomName);\n\n    state[roomName] = initGame();\n\n    client.join(roomName);\n    client.number = 1;\n    client.emit('init', 1);\n  }\n\n  function handleKeydown(keyCode) {\n    const roomName = clientRooms[client.id];\n    if (!roomName) {\n      return;\n    }\n    try {\n      keyCode = parseInt(keyCode);\n    } catch(e) {\n      console.error(e);\n      return;\n    }\n\n    const vel = getUpdatedVelocity(keyCode);\n\n    if (vel) {\n      state[roomName].players[client.number - 1].vel = vel;\n    }\n  }\n});\n\nfunction startGameInterval(roomName) {\n  const intervalId = setInterval(() => {\n    const winner = gameLoop(state[roomName]);\n    \n    if (!winner) {\n      emitGameState(roomName, state[roomName])\n    } else {\n      emitGameOver(roomName, winner);\n      state[roomName] = null;\n      clearInterval(intervalId);\n    }\n  }, 1000 / FRAME_RATE);\n}\n\nfunction emitGameState(room, gameState) {\n  // Send this event to everyone in the room.\n  io.sockets.in(room)\n    .emit('gameState', JSON.stringify(gameState));\n}\n\nfunction emitGameOver(room, winner) {\n  io.sockets.in(room)\n    .emit('gameOver', JSON.stringify({ winner }));\n}\n\nio.listen(process.env.PORT || 3000);\n\n",
        "called_code_segment": "function gameLoop(state) {\n   const { players, food } = state;\n   const score1 = players[0].pos.x + players[0].pos.y;\n   const score2 = players[1].pos.x + players[1].pos.y;\n   if (score1 === score2) {\n     return 0;\n   } else if (score1 > score2) {\n     return 1;\n   } else {\n     return 2;\n   }\n}",
        "invoking_code_segment": "function startGameInterval(roomName) {\n  const intervalId = setInterval(() => {\n    const winner = gameLoop(state[roomName]);\n    if (!winner) {\n      emitGameState(roomName, state[roomName])\n    } else {\n      emitGameOver(roomName, winner);\n      state[roomName] = null;\n      clearInterval(intervalId);\n    }\n  }, 1000 / FRAME_RATE);\n}",
        "feature_description": "Add a feature to display the scores of both players during the game.",
        "detailed_feature_description": "Modify the gameLoop function to calculate and return the scores of both players. Update the startGameInterval function to emit the scores along with the game state. The client-side will need to handle this new data structure to display the scores.",
        "modified_complete_code": {
            "server/game.js": "function gameLoop(state) {\n   const { players, food } = state;\n   const score1 = players[0].pos.x + players[0].pos.y;\n   const score2 = players[1].pos.x + players[1].pos.y;\n   #Modify\n   return {\n     winner: score1 === score2 ? 0 : score1 > score2 ? 1 : 2,\n     scores: [score1, score2]\n   };\n}",
            "server/server.js": "function startGameInterval(roomName) {\n  const intervalId = setInterval(() => {\n    const result = gameLoop(state[roomName]);\n    #Modify\n    if (!result.winner) {\n      emitGameState(roomName, state[roomName], result.scores)\n    } else {\n      emitGameOver(roomName, result.winner);\n      state[roomName] = null;\n      clearInterval(intervalId);\n    }\n  }, 1000 / FRAME_RATE);\n}\n\n#New\nfunction emitGameState(room, gameState, scores) {\n  // Send this event to everyone in the room.\n  io.sockets.in(room)\n    .emit('gameState', JSON.stringify({ ...gameState, scores }));\n}"
        }
    },
    {
        "repo": "nextjs-client-auth-architectures",
        "content": "'nextjs-client-auth-architectures/ssr/src/hocs/withAuth.js'\n:import { useIsAuthenticated } from '../providers/Auth';\nimport withConditionalRedirect from './withConditionalRedirect';\n\n/**\n * Require the user to be authenticated in order to render the component.\n * If the user isn't authenticated, forward to the given URL.\n */\nexport default function withAuth(WrappedComponent, location = '/login') {\n  return withConditionalRedirect({\n    WrappedComponent,\n    location,\n    clientCondition: function withAuthClientCondition() {\n      return !useIsAuthenticated();\n    },\n    serverCondition: function withAuthServerCondition(ctx) {\n      return !ctx.req?.cookies.session;\n    }\n  });\n}\n\n'nextjs-client-auth-architectures/ssr/src/pages/logout.js'\n:import { useEffect } from 'react';\nimport { useAuth } from '../providers/Auth';\nimport withAuth from '../hocs/withAuth';\n\nexport default withAuth(function Logout() {\n  const { setAuthenticated } = useAuth();\n  useEffect(() => {\n    async function doLogout() {\n      const response = await fetch('/api/logout');\n      if (response.status === 200) {\n        setAuthenticated(false);\n      } else {\n        console.error('Failed to logout', response);\n      }\n    }\n    doLogout();\n  }, [setAuthenticated]);\n  return <p>Logging out...</p>;\n}, '/');\n\n",
        "called_code_segment": "export default function withAuth(WrappedComponent, location = '/login') {\n  return withConditionalRedirect({\n    WrappedComponent,\n    location,\n    clientCondition: function withAuthClientCondition() {\n      return !useIsAuthenticated();\n    },\n    serverCondition: function withAuthServerCondition(ctx) {\n      return !ctx.req?.cookies.session;\n    }\n  });\n}",
        "invoking_code_segment": "export default withAuth(function Logout() {\n  const { setAuthenticated } = useAuth();\n  useEffect(() => {\n    async function doLogout() {\n      const response = await fetch('/api/logout');\n      if (response.status === 200) {\n        setAuthenticated(false);\n      } else {\n        console.error('Failed to logout', response);\n      }\n    }\n    doLogout();\n  }, [setAuthenticated]);\n  return <p>Logging out...</p>;\n}, '/');",
        "feature_description": "Add a feature to handle custom error messages during logout.",
        "detailed_feature_description": "Modify the `Logout` component to display a custom error message if the logout request fails. Update the `withAuth` HOC to accept an optional `errorMessage` parameter that can be used to display the custom error message.",
        "modified_complete_code": {
            "withAuth.js": "export default function withAuth(WrappedComponent, location = '/login', errorMessage = 'Authentication failed') {\n  return withConditionalRedirect({\n    WrappedComponent,\n    location,\n    clientCondition: function withAuthClientCondition() {\n      return !useIsAuthenticated();\n    },\n    serverCondition: function withAuthServerCondition(ctx) {\n      return !ctx.req?.cookies.session;\n    },\n    errorMessage\n  });\n}",
            "logout.js": "export default withAuth(function Logout() {\n  const { setAuthenticated } = useAuth();\n  useEffect(() => {\n    async function doLogout() {\n      const response = await fetch('/api/logout');\n      if (response.status === 200) {\n        setAuthenticated(false);\n      } else {\n        console.error('Failed to logout', response);\n        alert('Custom error message: Failed to logout'); #New\n      }\n    }\n    doLogout();\n  }, [setAuthenticated]);\n  return <p>Logging out...</p>;\n}, '/', 'Custom error message: Failed to logout'); #Modify"
        }
    },
    {
        "repo": "nightwatch-cucumber",
        "content": "'nightwatch-cucumber/lib/runner.js'\n:const fs = require('fs')\nconst path = require('path')\nconst tmp = require('tmp')\nconst glob = require('glob')\nconst mkdirp = require('mkdirp')\nconst pify = require('pify')\nconst dummyTestModulesFolder = tmp.dirSync({ unsafeCleanup: true }).name\nconst NightwatchApi = require('./nightwatch-api')\nconst CucumberApi = require('./cucumber-api')\n\ntmp.setGracefulCleanup()\n\nmodule.exports = class Runner {\n  constructor () {\n    this.originalFeaturePath = {}\n  }\n\n  getSourceFile (featureSource) {\n    if (featureSource.startsWith('@')) {\n      return featureSource.substr(1, featureSource.length - 1)\n    }\n    return featureSource\n  }\n\n  getFeatureFilesFromRerunFile (rerunFile) {\n    const data = fs.readFileSync(this.getSourceFile(rerunFile))\n    return data.toString()\n      .split('\\n')\n      .map(featurePath => featurePath.trim().replace(/(:\\d*)/g, ''))\n      // filter empty paths\n      .filter(featurePath => featurePath)\n  }\n\n  getFeatureDirectories () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n            .map(featurePath => path.dirname(featurePath))\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return featureSource\n        }\n        return path.dirname(featureSource)\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n  }\n\n  getFeatureFiles () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return glob.sync(path.join(featureSource, '**/*.feature'))\n        }\n        return [featureSource]\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n      // make unique list\n      .filter((featureFilePath, idx, paths) => paths.indexOf(featureFilePath === idx))\n  }\n\n  generateDummyTestModules () {\n    this.getFeatureFiles().forEach((featureFile) => {\n      const dummyTestModuleFile = this.featurePathToDummyPath(featureFile)\n      mkdirp.sync(path.dirname(dummyTestModuleFile))\n      fs.writeFileSync(dummyTestModuleFile, '')\n    })\n  }\n\n  getTags (tags) {\n    tags = tags || []\n\n    if (typeof tags === 'string') {\n      tags = tags.split(',')\n    }\n\n    if (Array.isArray(tags)) {\n      return tags.map((tag) => `@${tag}`)\n    } else {\n      throw new Error(`Expected tags to be Array or String.`)\n    }\n  }\n\n  featurePathToDummyPath (featureFile) {\n    const lineNumberMatch = featureFile.match(/:(\\d+)$/)\n    let lineNumber\n    if (lineNumberMatch) {\n      lineNumber = parseInt(lineNumberMatch[1])\n      featureFile = featureFile.replace(/:\\d+$/, '')\n    }\n    try {\n      fs.statSync(featureFile)\n    } catch (err) {\n      if (!featureFile.match(/\\.feature$/)) featureFile += '.feature'\n      try {\n        fs.statSync(featureFile)\n      } catch (err) {\n        throw new Error(`Feature file or folder ${featureFile} was not found!`)\n      }\n    }\n\n    const dummyPath = path.join(dummyTestModulesFolder, featureFile.replace(/\\.feature$/, '.js'))\n\n    this.originalFeaturePath[dummyPath] = lineNumber ? `${featureFile}:${lineNumber}` : featureFile\n\n    return dummyPath\n  }\n\n  dummyPathToFeaturePath (dummyPath) {\n    if (!dummyPath.match(/\\.js$/)) dummyPath += '.js'\n\n    return this.originalFeaturePath[dummyPath] || dummyPath\n  }\n\n  addIndexToFileName (fileName, index) {\n    const cutIndex = fileName.lastIndexOf('.')\n    const ext = fileName.slice(cutIndex)\n    const rest = fileName.slice(0, cutIndex)\n    return `${rest}-${index}${ext}`\n  }\n\n  * executeTestModules (dummyTestModules) {\n    const featureFiles = dummyTestModules.map((dummyTestModule) => this.dummyPathToFeaturePath(dummyTestModule))\n\n    if (this.nightwatchApi.isRunningInParallel()) {\n      const workerIndex = this.nightwatchApi.getWorkerIndex()\n      this.jsonReport = this.addIndexToFileName(this.jsonReport, workerIndex)\n    }\n\n    if (this.jsonReport) {\n      yield pify(mkdirp)(path.dirname(this.jsonReport))\n    }\n    const cucumberArgs = this.cucumberApi.getAdjustedArgs({\n      args: this.options.cucumberArgs,\n      featureFiles,\n      jsonReport: this.jsonReport,\n      tags: this.getTags(this.nightwatchApi.nightwatchArgv.tag),\n      skipTags: this.getTags(this.nightwatchApi.nightwatchArgv.skiptags)\n    })\n    return yield * this.cucumberApi.run(cucumberArgs)\n  }\n\n  areColorsEnabled () {\n    const formatOptionsIndex = this.options.cucumberArgs.indexOf('--format-options')\n    if (formatOptionsIndex < 0) return true\n    const formatOptions = JSON.parse(this.options.cucumberArgs[formatOptionsIndex + 1])\n    return typeof formatOptions.colorsEnabled === 'undefined' ? true : formatOptions.colorsEnabled\n  }\n\n  run (options) {\n    const self = this\n    this.options = options\n    this.nightwatchApi = new NightwatchApi(options, this.areColorsEnabled())\n    this.cucumberApi = new CucumberApi(options)\n    this.jsonReport = this.cucumberApi.getJSONReportName(options.cucumberArgs)\n    this.featureFiles = this.cucumberApi.getFeatureFiles(options.cucumberArgs)\n    this.featureFiles\n      .map(this.getSourceFile)\n      .forEach((featureSource) => {\n        try {\n          fs.statSync(featureSource)\n        } catch (err) {\n          throw new Error(`Feature source ${featureSource} doesn't exists`)\n        }\n      })\n\n    // enforce relative paths so path.join() works on Windows\n    this.featureFiles = this.featureFiles.map((currentPath) => {\n      return path.isAbsolute(currentPath) ? path.relative(process.cwd(), currentPath) : currentPath\n    })\n\n    const dummyPaths = this.getFeatureDirectories().map(srcPath => path.join(dummyTestModulesFolder, srcPath))\n\n    this.generateDummyTestModules()\n\n    this.cucumberApi.injectTimeoutHandler()\n    this.cucumberApi.addAttachmentProvider(this.nightwatchApi.takeScreenshot.bind(this.nightwatchApi))\n\n    this.nightwatchApi.addTestModulePaths(dummyPaths)\n    this.nightwatchApi.addPathConverter(this.featurePathToDummyPath.bind(this), this.dummyPathToFeaturePath.bind(this))\n    this.nightwatchApi.overrideOriginalStartTestWorkers()\n    this.nightwatchApi.addTestRunner(this.executeTestModules.bind(this))\n    this.nightwatchApi.addHookAfterChildProcesses(function * () {\n      const reports = yield pify(glob)(self.addIndexToFileName(self.jsonReport, '*'))\n      yield * self.cucumberApi.mergeCucumberJsonReports(reports, self.jsonReport)\n    })\n  }\n}\n\n'nightwatch-cucumber/lib/index.js'\n:let runner\n\nmodule.exports = function (providedOptions) {\n  const options = Object.assign({\n    cucumberArgs: [\n      '--require', 'features/step_definitions',\n      '--format', 'json:reports/cucumber.json',\n      'features'\n    ],\n    nightwatchOutput: true\n  }, providedOptions)\n\n  const Runner = require('./runner')\n  runner = new Runner()\n  runner.run(options)\n}\n\nfunction getPageProxy (subPages) {\n  return new Proxy(() => getClientProxy(subPages), {\n    get: (target, pageName) => getPageProxy(subPages.concat([pageName]))\n  })\n}\n\nfunction getClientProxy (subPages) {\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (name !== 'page') {\n        const api = runner.nightwatchApi.getClientApi()\n\n        if (!subPages.length) {\n          return api[name]\n        }\n\n        return subPages.reduce((api, pageName) => {\n          return api[pageName]\n        }, api.page)()[name]\n      }\n\n      return getPageProxy([])\n    }\n  })\n}\n\nmodule.exports.client = getClientProxy([])\n\nmodule.exports.Section = new Proxy(function () {}, {\n  construct (target, args) {\n    return new runner.nightwatchApi.Section(...args)\n  }\n})\n\n",
        "called_code_segment": "getFeatureFilesFromRerunFile (rerunFile) {\n    const data = fs.readFileSync(this.getSourceFile(rerunFile))\n    return data.toString()\n      .split('\\n')\n      .map(featurePath => featurePath.trim().replace(/(:\\d*)/g, ''))\n      // filter empty paths\n      .filter(featurePath => featurePath)\n  }",
        "invoking_code_segment": "getFeatureFiles () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return glob.sync(path.join(featureSource, '**/*.feature'))\n        }\n        return [featureSource]\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n      // make unique list\n      .filter((featureFilePath, idx, paths) => paths.indexOf(featureFilePath === idx))\n  }",
        "feature_description": "Add support for filtering feature files based on a specific tag in the rerun file.",
        "detailed_feature_description": "Modify the `getFeatureFilesFromRerunFile` method to accept an optional tag parameter. If provided, only feature files containing this tag will be returned. Update the `getFeatureFiles` method to pass the tag parameter if specified in the options.",
        "modified_complete_code": {
            "nightwatch-cucumber/lib/runner.js": "const fs = require('fs')\nconst path = require('path')\nconst tmp = require('tmp')\nconst glob = require('glob')\nconst mkdirp = require('mkdirp')\nconst pify = require('pify')\nconst dummyTestModulesFolder = tmp.dirSync({ unsafeCleanup: true }).name\nconst NightwatchApi = require('./nightwatch-api')\nconst CucumberApi = require('./cucumber-api')\n\ntmp.setGracefulCleanup()\n\nmodule.exports = class Runner {\n  constructor () {\n    this.originalFeaturePath = {}\n  }\n\n  getSourceFile (featureSource) {\n    if (featureSource.startsWith('@')) {\n      return featureSource.substr(1, featureSource.length - 1)\n    }\n    return featureSource\n  }\n\n  getFeatureFilesFromRerunFile (rerunFile, tag = null) {\n    const data = fs.readFileSync(this.getSourceFile(rerunFile))\n    return data.toString()\n      .split('\\n')\n      .map(featurePath => featurePath.trim().replace(/(:\\d*)/g, ''))\n      // filter empty paths\n      .filter(featurePath => featurePath)\n      // #Modify: Add tag filtering\n      .filter(featurePath => !tag || featurePath.includes(tag))\n  }\n\n  getFeatureDirectories () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n            .map(featurePath => path.dirname(featurePath))\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return featureSource\n        }\n        return path.dirname(featureSource)\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n  }\n\n  getFeatureFiles () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource, this.options.tag)\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return glob.sync(path.join(featureSource, '**/*.feature'))\n        }\n        return [featureSource]\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n      // make unique list\n      .filter((featureFilePath, idx, paths) => paths.indexOf(featureFilePath === idx))\n  }\n\n  generateDummyTestModules () {\n    this.getFeatureFiles().forEach((featureFile) => {\n      const dummyTestModuleFile = this.featurePathToDummyPath(featureFile)\n      mkdirp.sync(path.dirname(dummyTestModuleFile))\n      fs.writeFileSync(dummyTestModuleFile, '')\n    })\n  }\n\n  getTags (tags) {\n    tags = tags || []\n\n    if (typeof tags === 'string') {\n      tags = tags.split(',')\n    }\n\n    if (Array.isArray(tags)) {\n      return tags.map((tag) => `@${tag}`)\n    } else {\n      throw new Error(`Expected tags to be Array or String.`)\n    }\n  }\n\n  featurePathToDummyPath (featureFile) {\n    const lineNumberMatch = featureFile.match(/:(\\d+)$/)\n    let lineNumber\n    if (lineNumberMatch) {\n      lineNumber = parseInt(lineNumberMatch[1])\n      featureFile = featureFile.replace(/:\\d+$/, '')\n    }\n    try {\n      fs.statSync(featureFile)\n    } catch (err) {\n      if (!featureFile.match(/\\.feature$/)) featureFile += '.feature'\n      try {\n        fs.statSync(featureFile)\n      } catch (err) {\n        throw new Error(`Feature file or folder ${featureFile} was not found!`)\n      }\n    }\n\n    const dummyPath = path.join(dummyTestModulesFolder, featureFile.replace(/\\.feature$/, '.js'))\n\n    this.originalFeaturePath[dummyPath] = lineNumber ? `${featureFile}:${lineNumber}` : featureFile\n\n    return dummyPath\n  }\n\n  dummyPathToFeaturePath (dummyPath) {\n    if (!dummyPath.match(/\\.js$/)) dummyPath += '.js'\n\n    return this.originalFeaturePath[dummyPath] || dummyPath\n  }\n\n  addIndexToFileName (fileName, index) {\n    const cutIndex = fileName.lastIndexOf('.')\n    const ext = fileName.slice(cutIndex)\n    const rest = fileName.slice(0, cutIndex)\n    return `${rest}-${index}${ext}`\n  }\n\n  * executeTestModules (dummyTestModules) {\n    const featureFiles = dummyTestModules.map((dummyTestModule) => this.dummyPathToFeaturePath(dummyTestModule))\n\n    if (this.nightwatchApi.isRunningInParallel()) {\n      const workerIndex = this.nightwatchApi.getWorkerIndex()\n      this.jsonReport = this.addIndexToFileName(this.jsonReport, workerIndex)\n    }\n\n    if (this.jsonReport) {\n      yield pify(mkdirp)(path.dirname(this.jsonReport))\n    }\n    const cucumberArgs = this.cucumberApi.getAdjustedArgs({\n      args: this.options.cucumberArgs,\n      featureFiles,\n      jsonReport: this.jsonReport,\n      tags: this.getTags(this.nightwatchApi.nightwatchArgv.tag),\n      skipTags: this.getTags(this.nightwatchApi.nightwatchArgv.skiptags)\n    })\n    return yield * this.cucumberApi.run(cucumberArgs)\n  }\n\n  areColorsEnabled () {\n    const formatOptionsIndex = this.options.cucumberArgs.indexOf('--format-options')\n    if (formatOptionsIndex < 0) return true\n    const formatOptions = JSON.parse(this.options.cucumberArgs[formatOptionsIndex + 1])\n    return typeof formatOptions.colorsEnabled === 'undefined' ? true : formatOptions.colorsEnabled\n  }\n\n  run (options) {\n    const self = this\n    this.options = options\n    this.nightwatchApi = new NightwatchApi(options, this.areColorsEnabled())\n    this.cucumberApi = new CucumberApi(options)\n    this.jsonReport = this.cucumberApi.getJSONReportName(options.cucumberArgs)\n    this.featureFiles = this.cucumberApi.getFeatureFiles(options.cucumberArgs)\n    this.featureFiles\n      .map(this.getSourceFile)\n      .forEach((featureSource) => {\n        try {\n          fs.statSync(featureSource)\n        } catch (err) {\n          throw new Error(`Feature source ${featureSource} doesn't exists`)\n        }\n      })\n\n    // enforce relative paths so path.join() works on Windows\n    this.featureFiles = this.featureFiles.map((currentPath) => {\n      return path.isAbsolute(currentPath) ? path.relative(process.cwd(), currentPath) : currentPath\n    })\n\n    const dummyPaths = this.getFeatureDirectories().map(srcPath => path.join(dummyTestModulesFolder, srcPath))\n\n    this.generateDummyTestModules()\n\n    this.cucumberApi.injectTimeoutHandler()\n    this.cucumberApi.addAttachmentProvider(this.nightwatchApi.takeScreenshot.bind(this.nightwatchApi))\n\n    this.nightwatchApi.addTestModulePaths(dummyPaths)\n    this.nightwatchApi.addPathConverter(this.featurePathToDummyPath.bind(this), this.dummyPathToFeaturePath.bind(this))\n    this.nightwatchApi.overrideOriginalStartTestWorkers()\n    this.nightwatchApi.addTestRunner(this.executeTestModules.bind(this))\n    this.nightwatchApi.addHookAfterChildProcesses(function * () {\n      const reports = yield pify(glob)(self.addIndexToFileName(self.jsonReport, '*'))\n      yield * self.cucumberApi.mergeCucumberJsonReports(reports, self.jsonReport)\n    })\n  }\n}",
            "nightwatch-cucumber/lib/index.js": "let runner\n\nmodule.exports = function (providedOptions) {\n  const options = Object.assign({\n    cucumberArgs: [\n      '--require', 'features/step_definitions',\n      '--format', 'json:reports/cucumber.json',\n      'features'\n    ],\n    nightwatchOutput: true\n  }, providedOptions)\n\n  const Runner = require('./runner')\n  runner = new Runner()\n  runner.run(options)\n}\n\nfunction getPageProxy (subPages) {\n  return new Proxy(() => getClientProxy(subPages), {\n    get: (target, pageName) => getPageProxy(subPages.concat([pageName]))\n  })\n}\n\nfunction getClientProxy (subPages) {\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (name !== 'page') {\n        const api = runner.nightwatchApi.getClientApi()\n\n        if (!subPages.length) {\n          return api[name]\n        }\n\n        return subPages.reduce((api, pageName) => {\n          return api[pageName]\n        }, api.page)()[name]\n      }\n\n      return getPageProxy([])\n    }\n  })\n}\n\nmodule.exports.client = getClientProxy([])\n\nmodule.exports.Section = new Proxy(function () {}, {\n  construct (target, args) {\n    return new runner.nightwatchApi.Section(...args)\n  }\n})"
        }
    },
    {
        "repo": "node-ftp",
        "content": "'node-ftp/lib/parser.js'\n:var WritableStream = require('stream').Writable\n                     || require('readable-stream').Writable,\n    inherits = require('util').inherits,\n    inspect = require('util').inspect;\n\nvar XRegExp = require('xregexp').XRegExp;\n\nvar REX_LISTUNIX = XRegExp.cache('^(?<type>[\\\\-ld])(?<permission>([\\\\-r][\\\\-w][\\\\-xstT]){3})(?<acl>(\\\\+))?\\\\s+(?<inodes>\\\\d+)\\\\s+(?<owner>\\\\S+)\\\\s+(?<group>\\\\S+)\\\\s+(?<size>\\\\d+)\\\\s+(?<timestamp>((?<month1>\\\\w{3})\\\\s+(?<date1>\\\\d{1,2})\\\\s+(?<hour>\\\\d{1,2}):(?<minute>\\\\d{2}))|((?<month2>\\\\w{3})\\\\s+(?<date2>\\\\d{1,2})\\\\s+(?<year>\\\\d{4})))\\\\s+(?<name>.+)$'),\n    REX_LISTMSDOS = XRegExp.cache('^(?<month>\\\\d{2})(?:\\\\-|\\\\/)(?<date>\\\\d{2})(?:\\\\-|\\\\/)(?<year>\\\\d{2,4})\\\\s+(?<hour>\\\\d{2}):(?<minute>\\\\d{2})\\\\s{0,1}(?<ampm>[AaMmPp]{1,2})\\\\s+(?:(?<size>\\\\d+)|(?<isdir>\\\\<DIR\\\\>))\\\\s+(?<name>.+)$'),\n    RE_ENTRY_TOTAL = /^total/,\n    RE_RES_END = /(?:^|\\r?\\n)(\\d{3}) [^\\r\\n]*\\r?\\n/,\n    RE_EOL = /\\r?\\n/g,\n    RE_DASH = /\\-/g;\n\nvar MONTHS = {\n      jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6,\n      jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12\n    };\n\nfunction Parser(options) {\n  if (!(this instanceof Parser))\n    return new Parser(options);\n  WritableStream.call(this);\n\n  this._buffer = '';\n  this._debug = options.debug;\n}\ninherits(Parser, WritableStream);\n\nParser.prototype._write = function(chunk, encoding, cb) {\n  var m, code, reRmLeadCode, rest = '', debug = this._debug;\n\n  this._buffer += chunk.toString('binary');\n\n  while (m = RE_RES_END.exec(this._buffer)) {\n    // support multiple terminating responses in the buffer\n    rest = this._buffer.substring(m.index + m[0].length);\n    if (rest.length)\n      this._buffer = this._buffer.substring(0, m.index + m[0].length);\n\n    debug&&debug('[parser] < ' + inspect(this._buffer));\n\n    // we have a terminating response line\n    code = parseInt(m[1], 10);\n\n    // RFC 959 does not require each line in a multi-line response to begin\n    // with '<code>-', but many servers will do this.\n    //\n    // remove this leading '<code>-' (or '<code> ' from last line) from each\n    // line in the response ...\n    reRmLeadCode = '(^|\\\\r?\\\\n)';\n    reRmLeadCode += m[1];\n    reRmLeadCode += '(?: |\\\\-)';\n    reRmLeadCode = new RegExp(reRmLeadCode, 'g');\n    var text = this._buffer.replace(reRmLeadCode, '$1').trim();\n    this._buffer = rest;\n\n    debug&&debug('[parser] Response: code=' + code + ', buffer=' + inspect(text));\n    this.emit('response', code, text);\n  }\n\n  cb();\n};\n\nParser.parseFeat = function(text) {\n  var lines = text.split(RE_EOL);\n  lines.shift(); // initial response line\n  lines.pop(); // final response line\n\n  for (var i = 0, len = lines.length; i < len; ++i)\n    lines[i] = lines[i].trim();\n\n  // just return the raw lines for now\n  return lines;\n};\n\nParser.parseListEntry = function(line) {\n  var ret,\n      info,\n      month, day, year,\n      hour, mins;\n\n  if (ret = XRegExp.exec(line, REX_LISTUNIX)) {\n    info = {\n      type: ret.type,\n      name: undefined,\n      target: undefined,\n      sticky: false,\n      rights: {\n        user: ret.permission.substr(0, 3).replace(RE_DASH, ''),\n        group: ret.permission.substr(3, 3).replace(RE_DASH, ''),\n        other: ret.permission.substr(6, 3).replace(RE_DASH, '')\n      },\n      acl: (ret.acl === '+'),\n      owner: ret.owner,\n      group: ret.group,\n      size: parseInt(ret.size, 10),\n      date: undefined\n    };\n\n    // check for sticky bit\n    var lastbit = info.rights.other.slice(-1);\n    if (lastbit === 't') {\n      info.rights.other = info.rights.other.slice(0, -1) + 'x';\n      info.sticky = true;\n    } else if (lastbit === 'T') {\n      info.rights.other = info.rights.other.slice(0, -1);\n      info.sticky = true;\n    }\n\n    if (ret.month1 !== undefined) {\n      month = parseInt(MONTHS[ret.month1.toLowerCase()], 10);\n      day = parseInt(ret.date1, 10);\n      year = (new Date()).getFullYear();\n      hour = parseInt(ret.hour, 10);\n      mins = parseInt(ret.minute, 10);\n      if (month < 10)\n        month = '0' + month;\n      if (day < 10)\n        day = '0' + day;\n      if (hour < 10)\n        hour = '0' + hour;\n      if (mins < 10)\n        mins = '0' + mins;\n      info.date = new Date(year + '-'\n                           + month + '-'\n                           + day + 'T'\n                           + hour + ':'\n                           + mins);\n      // If the date is in the past but no more than 6 months old, year\n      // isn't displayed and doesn't have to be the current year.\n      // \n      // If the date is in the future (less than an hour from now), year\n      // isn't displayed and doesn't have to be the current year.\n      // That second case is much more rare than the first and less annoying.\n      // It's impossible to fix without knowing about the server's timezone,\n      // so we just don't do anything about it.\n      // \n      // If we're here with a time that is more than 28 hours into the\n      // future (1 hour + maximum timezone offset which is 27 hours),\n      // there is a problem -- we should be in the second conditional block\n      if (info.date.getTime() - Date.now() > 100800000) {\n        info.date = new Date((year - 1) + '-'\n                             + month + '-'\n                             + day + 'T'\n                             + hour + ':'\n                             + mins);\n      }\n\n      // If we're here with a time that is more than 6 months old, there's\n      // a problem as well.\n      // Maybe local & remote servers aren't on the same timezone (with remote\n      // ahead of local)\n      // For instance, remote is in 2014 while local is still in 2013. In\n      // this case, a date like 01/01/13 02:23 could be detected instead of\n      // 01/01/14 02:23 \n      // Our trigger point will be 3600*24*31*6 (since we already use 31\n      // as an upper bound, no need to add the 27 hours timezone offset)\n      if (Date.now() - info.date.getTime() > 16070400000) {\n        info.date = new Date((year + 1) + '-'\n                             + month + '-'\n                             + day + 'T'\n                             + hour + ':'\n                             + mins);\n      }\n    } else if (ret.month2 !== undefined) {\n      month = parseInt(MONTHS[ret.month2.toLowerCase()], 10);\n      day = parseInt(ret.date2, 10);\n      year = parseInt(ret.year, 10);\n      if (month < 10)\n        month = '0' + month;\n      if (day < 10)\n        day = '0' + day;\n      info.date = new Date(year + '-' + month + '-' + day);\n    }\n    if (ret.type === 'l') {\n      var pos = ret.name.indexOf(' -> ');\n      info.name = ret.name.substring(0, pos);\n      info.target = ret.name.substring(pos+4);\n    } else\n      info.name = ret.name;\n    ret = info;\n  } else if (ret = XRegExp.exec(line, REX_LISTMSDOS)) {\n    info = {\n      name: ret.name,\n      type: (ret.isdir ? 'd' : '-'),\n      size: (ret.isdir ? 0 : parseInt(ret.size, 10)),\n      date: undefined,\n    };\n    month = parseInt(ret.month, 10),\n    day = parseInt(ret.date, 10),\n    year = parseInt(ret.year, 10),\n    hour = parseInt(ret.hour, 10),\n    mins = parseInt(ret.minute, 10);\n\n    if (year < 70)\n      year += 2000;\n    else\n      year += 1900;\n\n    if (ret.ampm[0].toLowerCase() === 'p' && hour < 12)\n      hour += 12;\n    else if (ret.ampm[0].toLowerCase() === 'a' && hour === 12)\n      hour = 0;\n\n    info.date = new Date(year, month - 1, day, hour, mins);\n\n    ret = info;\n  } else if (!RE_ENTRY_TOTAL.test(line))\n    ret = line; // could not parse, so at least give the end user a chance to\n                // look at the raw listing themselves\n\n  return ret;\n};\n\nmodule.exports = Parser;\n\n'node-ftp/lib/connection.js'\n:var fs = require('fs'),\n    tls = require('tls'),\n    zlib = require('zlib'),\n    Socket = require('net').Socket,\n    EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    inspect = require('util').inspect,\n    StringDecoder = require('string_decoder').StringDecoder;\n\nvar Parser = require('./parser');\nvar XRegExp = require('xregexp').XRegExp;\n\nvar REX_TIMEVAL = XRegExp.cache('^(?<year>\\\\d{4})(?<month>\\\\d{2})(?<date>\\\\d{2})(?<hour>\\\\d{2})(?<minute>\\\\d{2})(?<second>\\\\d+)(?:.\\\\d+)?$'),\n    RE_PASV = /([\\d]+),([\\d]+),([\\d]+),([\\d]+),([-\\d]+),([-\\d]+)/,\n    RE_EOL = /\\r?\\n/g,\n    RE_WD = /\"(.+)\"(?: |$)/,\n    RE_SYST = /^([^ ]+)(?: |$)/;\n\nvar /*TYPE = {\n      SYNTAX: 0,\n      INFO: 1,\n      SOCKETS: 2,\n      AUTH: 3,\n      UNSPEC: 4,\n      FILESYS: 5\n    },*/\n    RETVAL = {\n      PRELIM: 1,\n      OK: 2,\n      WAITING: 3,\n      ERR_TEMP: 4,\n      ERR_PERM: 5\n    },\n    /*ERRORS = {\n      421: 'Service not available, closing control connection',\n      425: 'Can\\'t open data connection',\n      426: 'Connection closed; transfer aborted',\n      450: 'Requested file action not taken / File unavailable (e.g., file busy)',\n      451: 'Requested action aborted: local error in processing',\n      452: 'Requested action not taken / Insufficient storage space in system',\n      500: 'Syntax error / Command unrecognized',\n      501: 'Syntax error in parameters or arguments',\n      502: 'Command not implemented',\n      503: 'Bad sequence of commands',\n      504: 'Command not implemented for that parameter',\n      530: 'Not logged in',\n      532: 'Need account for storing files',\n      550: 'Requested action not taken / File unavailable (e.g., file not found, no access)',\n      551: 'Requested action aborted: page type unknown',\n      552: 'Requested file action aborted / Exceeded storage allocation (for current directory or dataset)',\n      553: 'Requested action not taken / File name not allowed'\n    },*/\n    bytesNOOP = new Buffer('NOOP\\r\\n');\n\nvar FTP = module.exports = function() {\n  if (!(this instanceof FTP))\n    return new FTP();\n\n  this._socket = undefined;\n  this._pasvSock = undefined;\n  this._feat = undefined;\n  this._curReq = undefined;\n  this._queue = [];\n  this._secstate = undefined;\n  this._debug = undefined;\n  this._keepalive = undefined;\n  this._ending = false;\n  this._parser = undefined;\n  this.options = {\n    host: undefined,\n    port: undefined,\n    user: undefined,\n    password: undefined,\n    secure: false,\n    secureOptions: undefined,\n    connTimeout: undefined,\n    pasvTimeout: undefined,\n    aliveTimeout: undefined\n  };\n  this.connected = false;\n};\ninherits(FTP, EventEmitter);\n\nFTP.prototype.connect = function(options) {\n  var self = this;\n  if (typeof options !== 'object')\n    options = {};\n  this.connected = false;\n  this.options.host = options.host || 'localhost';\n  this.options.port = options.port || 21;\n  this.options.user = options.user || 'anonymous';\n  this.options.password = options.password ||\n      options.password === '' ? options.password\n      : 'anonymous@';\n  this.options.secure = options.secure || false;\n  this.options.secureOptions = options.secureOptions;\n  this.options.connTimeout = options.connTimeout || 10000;\n  this.options.pasvTimeout = options.pasvTimeout || 10000;\n  this.options.aliveTimeout = options.keepalive || 10000;\n\n  if (typeof options.debug === 'function')\n    this._debug = options.debug;\n\n  var secureOptions,\n      debug = this._debug,\n      socket = new Socket();\n\n  socket.setTimeout(0);\n  socket.setKeepAlive(true);\n\n  this._parser = new Parser({ debug: debug });\n  this._parser.on('response', function(code, text) {\n    var retval = code / 100 >> 0;\n    if (retval === RETVAL.ERR_TEMP || retval === RETVAL.ERR_PERM) {\n      if (self._curReq)\n        self._curReq.cb(makeError(code, text), undefined, code);\n      else\n        self.emit('error', makeError(code, text));\n    } else if (self._curReq)\n      self._curReq.cb(undefined, text, code);\n\n    // a hack to signal we're waiting for a PASV data connection to complete\n    // first before executing any more queued requests ...\n    //\n    // also: don't forget our current request if we're expecting another\n    // terminating response ....\n    if (self._curReq && retval !== RETVAL.PRELIM) {\n      self._curReq = undefined;\n      self._send();\n    }\n\n    noopreq.cb();\n  });\n\n  if (this.options.secure) {\n    secureOptions = {};\n    secureOptions.host = this.options.host;\n    for (var k in this.options.secureOptions)\n      secureOptions[k] = this.options.secureOptions[k];\n    secureOptions.socket = socket;\n    this.options.secureOptions = secureOptions;\n  }\n\n  if (this.options.secure === 'implicit')\n    this._socket = tls.connect(secureOptions, onconnect);\n  else {\n    socket.once('connect', onconnect);\n    this._socket = socket;\n  }\n\n  var noopreq = {\n        cmd: 'NOOP',\n        cb: function() {\n          clearTimeout(self._keepalive);\n          self._keepalive = setTimeout(donoop, self.options.aliveTimeout);\n        }\n      };\n\n  function donoop() {\n    if (!self._socket || !self._socket.writable)\n      clearTimeout(self._keepalive);\n    else if (!self._curReq && self._queue.length === 0) {\n      self._curReq = noopreq;\n      debug&&debug('[connection] > NOOP');\n      self._socket.write(bytesNOOP);\n    } else\n      noopreq.cb();\n  }\n\n  function onconnect() {\n    clearTimeout(timer);\n    clearTimeout(self._keepalive);\n    self.connected = true;\n    self._socket = socket; // re-assign for implicit secure connections\n\n    var cmd;\n\n    if (self._secstate) {\n      if (self._secstate === 'upgraded-tls' && self.options.secure === true) {\n        cmd = 'PBSZ';\n        self._send('PBSZ 0', reentry, true);\n      } else {\n        cmd = 'USER';\n        self._send('USER ' + self.options.user, reentry, true);\n      }\n    } else {\n      self._curReq = {\n        cmd: '',\n        cb: reentry\n      };\n    }\n\n    function reentry(err, text, code) {\n      if (err && (!cmd || cmd === 'USER' || cmd === 'PASS' || cmd === 'TYPE')) {\n        self.emit('error', err);\n        return self._socket && self._socket.end();\n      }\n      if ((cmd === 'AUTH TLS' && code !== 234 && self.options.secure !== true)\n          || (cmd === 'AUTH SSL' && code !== 334)\n          || (cmd === 'PBSZ' && code !== 200)\n          || (cmd === 'PROT' && code !== 200)) {\n        self.emit('error', makeError(code, 'Unable to secure connection(s)'));\n        return self._socket && self._socket.end();\n      }\n\n      if (!cmd) {\n        // sometimes the initial greeting can contain useful information\n        // about authorized use, other limits, etc.\n        self.emit('greeting', text);\n\n        if (self.options.secure && self.options.secure !== 'implicit') {\n          cmd = 'AUTH TLS';\n          self._send(cmd, reentry, true);\n        } else {\n          cmd = 'USER';\n          self._send('USER ' + self.options.user, reentry, true);\n        }\n      } else if (cmd === 'USER') {\n        if (code !== 230) {\n          // password required\n          if (!self.options.password &&\n               self.options.password !== '') {\n            self.emit('error', makeError(code, 'Password required'));\n            return self._socket && self._socket.end();\n          }\n          cmd = 'PASS';\n          self._send('PASS ' + self.options.password, reentry, true);\n        } else {\n          // no password required\n          cmd = 'PASS';\n          reentry(undefined, text, code);\n        }\n      } else if (cmd === 'PASS') {\n        cmd = 'FEAT';\n        self._send(cmd, reentry, true);\n      } else if (cmd === 'FEAT') {\n        if (!err)\n          self._feat = Parser.parseFeat(text);\n        cmd = 'TYPE';\n        self._send('TYPE I', reentry, true);\n      } else if (cmd === 'TYPE')\n        self.emit('ready');\n      else if (cmd === 'PBSZ') {\n        cmd = 'PROT';\n        self._send('PROT P', reentry, true);\n      } else if (cmd === 'PROT') {\n        cmd = 'USER';\n        self._send('USER ' + self.options.user, reentry, true);\n      } else if (cmd.substr(0, 4) === 'AUTH') {\n        if (cmd === 'AUTH TLS' && code !== 234) {\n          cmd = 'AUTH SSL';\n          return self._send(cmd, reentry, true);\n        } else if (cmd === 'AUTH TLS')\n          self._secstate = 'upgraded-tls';\n        else if (cmd === 'AUTH SSL')\n          self._secstate = 'upgraded-ssl';\n        socket.removeAllListeners('data');\n        socket.removeAllListeners('error');\n        socket._decoder = null;\n        self._curReq = null; // prevent queue from being processed during\n                             // TLS/SSL negotiation\n        secureOptions.socket = self._socket;\n        secureOptions.session = undefined;\n        socket = tls.connect(secureOptions, onconnect);\n        socket.setEncoding('binary');\n        socket.on('data', ondata);\n        socket.once('end', onend);\n        socket.on('error', onerror);\n      }\n    }\n  }\n\n  socket.on('data', ondata);\n  function ondata(chunk) {\n    debug&&debug('[connection] < ' + inspect(chunk.toString('binary')));\n    if (self._parser)\n      self._parser.write(chunk);\n  }\n\n  socket.on('error', onerror);\n  function onerror(err) {\n    clearTimeout(timer);\n    clearTimeout(self._keepalive);\n    self.emit('error', err);\n  }\n\n  socket.once('end', onend);\n  function onend() {\n    ondone();\n    self.emit('end');\n  }\n\n  socket.once('close', function(had_err) {\n    ondone();\n    self.emit('close', had_err);\n  });\n\n  var hasReset = false;\n  function ondone() {\n    if (!hasReset) {\n      hasReset = true;\n      clearTimeout(timer);\n      self._reset();\n    }\n  }\n\n  var timer = setTimeout(function() {\n    self.emit('error', new Error('Timeout while connecting to server'));\n    self._socket && self._socket.destroy();\n    self._reset();\n  }, this.options.connTimeout);\n\n  this._socket.connect(this.options.port, this.options.host);\n};\n\nFTP.prototype.end = function() {\n  if (this._queue.length)\n    this._ending = true;\n  else\n    this._reset();\n};\n\nFTP.prototype.destroy = function() {\n  this._reset();\n};\n\n// \"Standard\" (RFC 959) commands\nFTP.prototype.ascii = function(cb) {\n  return this._send('TYPE A', cb);\n};\n\nFTP.prototype.binary = function(cb) {\n  return this._send('TYPE I', cb);\n};\n\nFTP.prototype.abort = function(immediate, cb) {\n  if (typeof immediate === 'function') {\n    cb = immediate;\n    immediate = true;\n  }\n  if (immediate)\n    this._send('ABOR', cb, true);\n  else\n    this._send('ABOR', cb);\n};\n\nFTP.prototype.cwd = function(path, cb, promote) {\n  this._send('CWD ' + path, function(err, text, code) {\n    if (err)\n      return cb(err);\n    var m = RE_WD.exec(text);\n    cb(undefined, m ? m[1] : undefined);\n  }, promote);\n};\n\nFTP.prototype.delete = function(path, cb) {\n  this._send('DELE ' + path, cb);\n};\n\nFTP.prototype.site = function(cmd, cb) {\n  this._send('SITE ' + cmd, cb);\n};\n\nFTP.prototype.status = function(cb) {\n  this._send('STAT', cb);\n};\n\nFTP.prototype.rename = function(from, to, cb) {\n  var self = this;\n  this._send('RNFR ' + from, function(err) {\n    if (err)\n      return cb(err);\n\n    self._send('RNTO ' + to, cb, true);\n  });\n};\n\nFTP.prototype.logout = function(cb) {\n  this._send('QUIT', cb);\n};\n\nFTP.prototype.listSafe = function(path, zcomp, cb) {\n  if (typeof path === 'string') {\n    var self = this;\n    // store current path\n    this.pwd(function(err, origpath) {\n      if (err) return cb(err);\n      // change to destination path\n      self.cwd(path, function(err) {\n        if (err) return cb(err);\n        // get dir listing\n        self.list(zcomp || false, function(err, list) {\n          // change back to original path\n          if (err) return self.cwd(origpath, cb);\n          self.cwd(origpath, function(err) {\n            if (err) return cb(err);\n            cb(err, list);\n          });\n        });\n      });\n    });\n  } else\n    this.list(path, zcomp, cb);\n};\n\nFTP.prototype.list = function(path, zcomp, cb) {\n  var self = this, cmd;\n\n  if (typeof path === 'function') {\n    // list(function() {})\n    cb = path;\n    path = undefined;\n    cmd = 'LIST';\n    zcomp = false;\n  } else if (typeof path === 'boolean') {\n    // list(true, function() {})\n    cb = zcomp;\n    zcomp = path;\n    path = undefined;\n    cmd = 'LIST';\n  } else if (typeof zcomp === 'function') {\n    // list('/foo', function() {})\n    cb = zcomp;\n    cmd = 'LIST ' + path;\n    zcomp = false;\n  } else\n    cmd = 'LIST ' + path;\n\n  this._pasv(function(err, sock) {\n    if (err)\n      return cb(err);\n\n    if (self._queue[0] && self._queue[0].cmd === 'ABOR') {\n      sock.destroy();\n      return cb();\n    }\n\n    var sockerr, done = false, replies = 0, entries, buffer = '', source = sock;\n    var decoder = new StringDecoder('utf8');\n\n    if (zcomp) {\n      source = zlib.createInflate();\n      sock.pipe(source);\n    }\n\n    source.on('data', function(chunk) {\n      buffer += decoder.write(chunk);\n    });\n    source.once('error', function(err) {\n      if (!sock.aborting)\n        sockerr = err;\n    });\n    source.once('end', ondone);\n    source.once('close', ondone);\n\n    function ondone() {\n      if (decoder) {\n        buffer += decoder.end();\n        decoder = null;\n      }\n      done = true;\n      final();\n    }\n    function final() {\n      if (done && replies === 2) {\n        replies = 3;\n        if (sockerr)\n          return cb(new Error('Unexpected data connection error: ' + sockerr));\n        if (sock.aborting)\n          return cb();\n\n        // process received data\n        entries = buffer.split(RE_EOL);\n        entries.pop(); // ending EOL\n        var parsed = [];\n        for (var i = 0, len = entries.length; i < len; ++i) {\n          var parsedVal = Parser.parseListEntry(entries[i]);\n          if (parsedVal !== null)\n            parsed.push(parsedVal);\n        }\n\n        if (zcomp) {\n          self._send('MODE S', function() {\n            cb(undefined, parsed);\n          }, true);\n        } else\n          cb(undefined, parsed);\n      }\n    }\n\n    if (zcomp) {\n      self._send('MODE Z', function(err, text, code) {\n        if (err) {\n          sock.destroy();\n          return cb(makeError(code, 'Compression not supported'));\n        }\n        sendList();\n      }, true);\n    } else\n      sendList();\n\n    function sendList() {\n      // this callback will be executed multiple times, the first is when server\n      // replies with 150 and then a final reply to indicate whether the\n      // transfer was actually a success or not\n      self._send(cmd, function(err, text, code) {\n        if (err) {\n          sock.destroy();\n          if (zcomp) {\n            self._send('MODE S', function() {\n              cb(err);\n            }, true);\n          } else\n            cb(err);\n          return;\n        }\n\n        // some servers may not open a data connection for empty directories\n        if (++replies === 1 && code === 226) {\n          replies = 2;\n          sock.destroy();\n          final();\n        } else if (replies === 2)\n          final();\n      }, true);\n    }\n  });\n};\n\nFTP.prototype.get = function(path, zcomp, cb) {\n  var self = this;\n  if (typeof zcomp === 'function') {\n    cb = zcomp;\n    zcomp = false;\n  }\n\n  this._pasv(function(err, sock) {\n    if (err)\n      return cb(err);\n\n    if (self._queue[0] && self._queue[0].cmd === 'ABOR') {\n      sock.destroy();\n      return cb();\n    }\n\n    // modify behavior of socket events so that we can emit 'error' once for\n    // either a TCP-level error OR an FTP-level error response that we get when\n    // the socket is closed (e.g. the server ran out of space).\n    var sockerr, started = false, lastreply = false, done = false,\n        source = sock;\n\n    if (zcomp) {\n      source = zlib.createInflate();\n      sock.pipe(source);\n      sock._emit = sock.emit;\n      sock.emit = function(ev, arg1) {\n        if (ev === 'error') {\n          if (!sockerr)\n            sockerr = arg1;\n          return;\n        }\n        sock._emit.apply(sock, Array.prototype.slice.call(arguments));\n      };\n    }\n\n    source._emit = source.emit;\n    source.emit = function(ev, arg1) {\n      if (ev === 'error') {\n        if (!sockerr)\n          sockerr = arg1;\n        return;\n      } else if (ev === 'end' || ev === 'close') {\n        if (!done) {\n          done = true;\n          ondone();\n        }\n        return;\n      }\n      source._emit.apply(source, Array.prototype.slice.call(arguments));\n    };\n\n    function ondone() {\n      if (done && lastreply) {\n        self._send('MODE S', function() {\n          source._emit('end');\n          source._emit('close');\n        }, true);\n      }\n    }\n\n    sock.pause();\n\n    if (zcomp) {\n      self._send('MODE Z', function(err, text, code) {\n        if (err) {\n          sock.destroy();\n          return cb(makeError(code, 'Compression not supported'));\n        }\n        sendRetr();\n      }, true);\n    } else\n      sendRetr();\n\n    function sendRetr() {\n      // this callback will be executed multiple times, the first is when server\n      // replies with 150, then a final reply after the data connection closes\n      // to indicate whether the transfer was actually a success or not\n      self._send('RETR ' + path, function(err, text, code) {\n        if (sockerr || err) {\n          sock.destroy();\n          if (!started) {\n            if (zcomp) {\n              self._send('MODE S', function() {\n                cb(sockerr || err);\n              }, true);\n            } else\n              cb(sockerr || err);\n          } else {\n            source._emit('error', sockerr || err);\n            source._emit('close', true);\n          }\n          return;\n        }\n        // server returns 125 when data connection is already open; we treat it\n        // just like a 150\n        if (code === 150 || code === 125) {\n          started = true;\n          cb(undefined, source);\n        } else {\n          lastreply = true;\n          ondone();\n        }\n      }, true);\n    }\n  });\n};\n\nFTP.prototype.put = function(input, path, zcomp, cb) {\n  this._store('STOR ' + path, input, zcomp, cb);\n};\n\nFTP.prototype.append = function(input, path, zcomp, cb) {\n  this._store('APPE ' + path, input, zcomp, cb);\n};\n\nFTP.prototype.pwd = function(cb) { // PWD is optional\n  var self = this;\n  this._send('PWD', function(err, text, code) {\n    if (code === 502) {\n      return self.cwd('.', function(cwderr, cwd) {\n        if (cwderr)\n          return cb(cwderr);\n        if (cwd === undefined)\n          cb(err);\n        else\n          cb(undefined, cwd);\n      }, true);\n    } else if (err)\n      return cb(err);\n    cb(undefined, RE_WD.exec(text)[1]);\n  });\n};\n\nFTP.prototype.cdup = function(cb) { // CDUP is optional\n  var self = this;\n  this._send('CDUP', function(err, text, code) {\n    if (code === 502)\n      self.cwd('..', cb, true);\n    else\n      cb(err);\n  });\n};\n\nFTP.prototype.mkdir = function(path, recursive, cb) { // MKD is optional\n  if (typeof recursive === 'function') {\n    cb = recursive;\n    recursive = false;\n  }\n  if (!recursive)\n    this._send('MKD ' + path, cb);\n  else {\n    var self = this, owd, abs, dirs, dirslen, i = -1, searching = true;\n\n    abs = (path[0] === '/');\n\n    var nextDir = function() {\n      if (++i === dirslen) {\n        // return to original working directory\n        return self._send('CWD ' + owd, cb, true);\n      }\n      if (searching) {\n        self._send('CWD ' + dirs[i], function(err, text, code) {\n          if (code === 550) {\n            searching = false;\n            --i;\n          } else if (err) {\n            // return to original working directory\n            return self._send('CWD ' + owd, function() {\n              cb(err);\n            }, true);\n          }\n          nextDir();\n        }, true);\n      } else {\n        self._send('MKD ' + dirs[i], function(err, text, code) {\n          if (err) {\n            // return to original working directory\n            return self._send('CWD ' + owd, function() {\n              cb(err);\n            }, true);\n          }\n          self._send('CWD ' + dirs[i], nextDir, true);\n        }, true);\n      }\n    };\n    this.pwd(function(err, cwd) {\n      if (err)\n        return cb(err);\n      owd = cwd;\n      if (abs)\n        path = path.substr(1);\n      if (path[path.length - 1] === '/')\n        path = path.substring(0, path.length - 1);\n      dirs = path.split('/');\n      dirslen = dirs.length;\n      if (abs)\n        self._send('CWD /', function(err) {\n          if (err)\n            return cb(err);\n          nextDir();\n        }, true);\n      else\n        nextDir();\n    });\n  }\n};\n\nFTP.prototype.rmdir = function(path, recursive, cb) { // RMD is optional\n  if (typeof recursive === 'function') {\n    cb = recursive;\n    recursive = false;\n  }\n  if (!recursive) {\n    return this._send('RMD ' + path, cb);\n  }\n  \n  var self = this;\n  this.list(path, function(err, list) {\n    if (err) return cb(err);\n    var idx = 0;\n    \n    // this function will be called once per listing entry\n    var deleteNextEntry;\n    deleteNextEntry = function(err) {\n      if (err) return cb(err);\n      if (idx >= list.length) {\n        if (list[0] && list[0].name === path) {\n          return cb(null);\n        } else {\n          return self.rmdir(path, cb);\n        }\n      }\n      \n      var entry = list[idx++];\n      \n      // get the path to the file\n      var subpath = null;\n      if (entry.name[0] === '/') {\n        // this will be the case when you call deleteRecursively() and pass\n        // the path to a plain file\n        subpath = entry.name;\n      } else {\n        if (path[path.length - 1] == '/') {\n          subpath = path + entry.name;\n        } else {\n          subpath = path + '/' + entry.name\n        }\n      }\n      \n      // delete the entry (recursively) according to its type\n      if (entry.type === 'd') {\n        if (entry.name === \".\" || entry.name === \"..\") {\n          return deleteNextEntry();\n        }\n        self.rmdir(subpath, true, deleteNextEntry);\n      } else {\n        self.delete(subpath, deleteNextEntry);\n      }\n    }\n    deleteNextEntry();\n  });\n};\n\nFTP.prototype.system = function(cb) { // SYST is optional\n  this._send('SYST', function(err, text) {\n    if (err)\n      return cb(err);\n    cb(undefined, RE_SYST.exec(text)[1]);\n  });\n};\n\n// \"Extended\" (RFC 3659) commands\nFTP.prototype.size = function(path, cb) {\n  var self = this;\n  this._send('SIZE ' + path, function(err, text, code) {\n    if (code === 502) {\n      // Note: this may cause a problem as list() is _appended_ to the queue\n      return self.list(path, function(err, list) {\n        if (err)\n          return cb(err);\n        if (list.length === 1)\n          cb(undefined, list[0].size);\n        else {\n          // path could have been a directory and we got a listing of its\n          // contents, but here we echo the behavior of the real SIZE and\n          // return 'File not found' for directories\n          cb(new Error('File not found'));\n        }\n      }, true);\n    } else if (err)\n      return cb(err);\n    cb(undefined, parseInt(text, 10));\n  });\n};\n\nFTP.prototype.lastMod = function(path, cb) {\n  var self = this;\n  this._send('MDTM ' + path, function(err, text, code) {\n    if (code === 502) {\n      return self.list(path, function(err, list) {\n        if (err)\n          return cb(err);\n        if (list.length === 1)\n          cb(undefined, list[0].date);\n        else\n          cb(new Error('File not found'));\n      }, true);\n    } else if (err)\n      return cb(err);\n    var val = XRegExp.exec(text, REX_TIMEVAL), ret;\n    if (!val)\n      return cb(new Error('Invalid date/time format from server'));\n    ret = new Date(val.year + '-' + val.month + '-' + val.date + 'T' + val.hour\n                   + ':' + val.minute + ':' + val.second);\n    cb(undefined, ret);\n  });\n};\n\nFTP.prototype.restart = function(offset, cb) {\n  this._send('REST ' + offset, cb);\n};\n\n\n\n// Private/Internal methods\nFTP.prototype._pasv = function(cb) {\n  var self = this, first = true, ip, port;\n  this._send('PASV', function reentry(err, text) {\n    if (err)\n      return cb(err);\n\n    self._curReq = undefined;\n\n    if (first) {\n      var m = RE_PASV.exec(text);\n      if (!m)\n        return cb(new Error('Unable to parse PASV server response'));\n      ip = m[1];\n      ip += '.';\n      ip += m[2];\n      ip += '.';\n      ip += m[3];\n      ip += '.';\n      ip += m[4];\n      port = (parseInt(m[5], 10) * 256) + parseInt(m[6], 10);\n\n      first = false;\n    }\n    self._pasvConnect(ip, port, function(err, sock) {\n      if (err) {\n        // try the IP of the control connection if the server was somehow\n        // misconfigured and gave for example a LAN IP instead of WAN IP over\n        // the Internet\n        if (self._socket && ip !== self._socket.remoteAddress) {\n          ip = self._socket.remoteAddress;\n          return reentry();\n        }\n\n        // automatically abort PASV mode\n        self._send('ABOR', function() {\n          cb(err);\n          self._send();\n        }, true);\n\n        return;\n      }\n      cb(undefined, sock);\n      self._send();\n    });\n  });\n};\n\nFTP.prototype._pasvConnect = function(ip, port, cb) {\n  var self = this,\n      socket = new Socket(),\n      sockerr,\n      timedOut = false,\n      timer = setTimeout(function() {\n        timedOut = true;\n        socket.destroy();\n        cb(new Error('Timed out while making data connection'));\n      }, this.options.pasvTimeout);\n\n  socket.setTimeout(0);\n\n  socket.once('connect', function() {\n    self._debug&&self._debug('[connection] PASV socket connected');\n    if (self.options.secure === true) {\n      self.options.secureOptions.socket = socket;\n      self.options.secureOptions.session = self._socket.getSession();\n      //socket.removeAllListeners('error');\n      socket = tls.connect(self.options.secureOptions);\n      //socket.once('error', onerror);\n      socket.setTimeout(0);\n    }\n    clearTimeout(timer);\n    self._pasvSocket = socket;\n    cb(undefined, socket);\n  });\n  socket.once('error', onerror);\n  function onerror(err) {\n    sockerr = err;\n  }\n  socket.once('end', function() {\n    clearTimeout(timer);\n  });\n  socket.once('close', function(had_err) {\n    clearTimeout(timer);\n    if (!self._pasvSocket && !timedOut) {\n      var errmsg = 'Unable to make data connection';\n      if (sockerr) {\n        errmsg += '( ' + sockerr + ')';\n        sockerr = undefined;\n      }\n      cb(new Error(errmsg));\n    }\n    self._pasvSocket = undefined;\n  });\n\n  socket.connect(port, ip);\n};\n\nFTP.prototype._store = function(cmd, input, zcomp, cb) {\n  var isBuffer = Buffer.isBuffer(input);\n\n  if (!isBuffer && input.pause !== undefined)\n    input.pause();\n\n  if (typeof zcomp === 'function') {\n    cb = zcomp;\n    zcomp = false;\n  }\n\n  var self = this;\n  this._pasv(function(err, sock) {\n    if (err)\n      return cb(err);\n\n    if (self._queue[0] && self._queue[0].cmd === 'ABOR') {\n      sock.destroy();\n      return cb();\n    }\n\n    var sockerr, dest = sock;\n    sock.once('error', function(err) {\n      sockerr = err;\n    });\n\n    if (zcomp) {\n      self._send('MODE Z', function(err, text, code) {\n        if (err) {\n          sock.destroy();\n          return cb(makeError(code, 'Compression not supported'));\n        }\n        // draft-preston-ftpext-deflate-04 says min of 8 should be supported\n        dest = zlib.createDeflate({ level: 8 });\n        dest.pipe(sock);\n        sendStore();\n      }, true);\n    } else\n      sendStore();\n\n    function sendStore() {\n      // this callback will be executed multiple times, the first is when server\n      // replies with 150, then a final reply after the data connection closes\n      // to indicate whether the transfer was actually a success or not\n      self._send(cmd, function(err, text, code) {\n        if (sockerr || err) {\n          if (zcomp) {\n            self._send('MODE S', function() {\n              cb(sockerr || err);\n            }, true);\n          } else\n            cb(sockerr || err);\n          return;\n        }\n\n        if (code === 150 || code === 125) {\n          if (isBuffer)\n            dest.end(input);\n          else if (typeof input === 'string') {\n            // check if input is a file path or just string data to store\n            fs.stat(input, function(err, stats) {\n              if (err)\n                dest.end(input);\n              else\n                fs.createReadStream(input).pipe(dest);\n            });\n          } else {\n            input.pipe(dest);\n            input.resume();\n          }\n        } else {\n          if (zcomp)\n            self._send('MODE S', cb, true);\n          else\n            cb();\n        }\n      }, true);\n    }\n  });\n};\n\nFTP.prototype._send = function(cmd, cb, promote) {\n  clearTimeout(this._keepalive);\n  if (cmd !== undefined) {\n    if (promote)\n      this._queue.unshift({ cmd: cmd, cb: cb });\n    else\n      this._queue.push({ cmd: cmd, cb: cb });\n  }\n  var queueLen = this._queue.length;\n  if (!this._curReq && queueLen && this._socket && this._socket.readable) {\n    this._curReq = this._queue.shift();\n    if (this._curReq.cmd === 'ABOR' && this._pasvSocket)\n      this._pasvSocket.aborting = true;\n    this._debug&&this._debug('[connection] > ' + inspect(this._curReq.cmd));\n    this._socket.write(this._curReq.cmd + '\\r\\n');\n  } else if (!this._curReq && !queueLen && this._ending)\n    this._reset();\n};\n\nFTP.prototype._reset = function() {\n  if (this._pasvSock && this._pasvSock.writable)\n    this._pasvSock.end();\n  if (this._socket && this._socket.writable)\n    this._socket.end();\n  this._socket = undefined;\n  this._pasvSock = undefined;\n  this._feat = undefined;\n  this._curReq = undefined;\n  this._secstate = undefined;\n  clearTimeout(this._keepalive);\n  this._keepalive = undefined;\n  this._queue = [];\n  this._ending = false;\n  this._parser = undefined;\n  this.options.host = this.options.port = this.options.user\n                    = this.options.password = this.options.secure\n                    = this.options.connTimeout = this.options.pasvTimeout\n                    = this.options.keepalive = this._debug = undefined;\n  this.connected = false;\n};\n\n// Utility functions\nfunction makeError(code, text) {\n  var err = new Error(text);\n  err.code = code;\n  return err;\n}\n\n",
        "called_code_segment": "FTP.prototype.list = function(path, zcomp, cb) {\n  var self = this, cmd;\n\n  if (typeof path === 'function') {\n    // list(function() {})\n    cb = path;\n    path = undefined;\n    cmd = 'LIST';\n    zcomp = false;\n  } else if (typeof path === 'boolean') {\n    // list(true, function() {})\n    cb = zcomp;\n    zcomp = path;\n    path = undefined;\n    cmd = 'LIST';\n  } else if (typeof zcomp === 'function') {\n    // list('/foo', function() {})\n    cb = zcomp;\n    cmd = 'LIST ' + path;\n    zcomp = false;\n  } else\n    cmd = 'LIST ' + path;\n\n  this._pasv(function(err, sock) {\n    if (err)\n      return cb(err);\n\n    if (self._queue[0] && self._queue[0].cmd === 'ABOR') {\n      sock.destroy();\n      return cb();\n    }\n\n    var sockerr, done = false, replies = 0, entries, buffer = '', source = sock;\n    var decoder = new StringDecoder('utf8');\n\n    if (zcomp) {\n      source = zlib.createInflate();\n      sock.pipe(source);\n    }\n\n    source.on('data', function(chunk) {\n      buffer += decoder.write(chunk);\n    });\n    source.once('error', function(err) {\n      if (!sock.aborting)\n        sockerr = err;\n    });\n    source.once('end', ondone);\n    source.once('close', ondone);\n\n    function ondone() {\n      if (decoder) {\n        buffer += decoder.end();\n        decoder = null;\n      }\n      done = true;\n      final();\n    }\n    function final() {\n      if (done && replies === 2) {\n        replies = 3;\n        if (sockerr)\n          return cb(new Error('Unexpected data connection error: ' + sockerr));\n        if (sock.aborting)\n          return cb();\n\n        // process received data\n        entries = buffer.split(RE_EOL);\n        entries.pop(); // ending EOL\n        var parsed = [];\n        for (var i = 0, len = entries.length; i < len; ++i) {\n          var parsedVal = Parser.parseListEntry(entries[i]);\n          if (parsedVal !== null)\n            parsed.push(parsedVal);\n        }\n\n        if (zcomp) {\n          self._send('MODE S', function() {\n            cb(undefined, parsed);\n          }, true);\n        } else\n          cb(undefined, parsed);\n      }\n    }\n\n    if (zcomp) {\n      self._send('MODE Z', function(err, text, code) {\n        if (err) {\n          sock.destroy();\n          return cb(makeError(code, 'Compression not supported'));\n        }\n        sendList();\n      }, true);\n    } else\n      sendList();\n\n    function sendList() {\n      // this callback will be executed multiple times, the first is when server\n      // replies with 150 and then a final reply to indicate whether the\n      // transfer was actually a success or not\n      self._send(cmd, function(err, text, code) {\n        if (err) {\n          sock.destroy();\n          if (zcomp) {\n            self._send('MODE S', function() {\n              cb(err);\n            }, true);\n          } else\n            cb(err);\n          return;\n        }\n\n        // some servers may not open a data connection for empty directories\n        if (++replies === 1 && code === 226) {\n          replies = 2;\n          sock.destroy();\n          final();\n        } else if (replies === 2)\n          final();\n      }, true);\n    }\n  });\n};",
        "invoking_code_segment": "FTP.prototype.listSafe = function(path, zcomp, cb) {\n  if (typeof path === 'string') {\n    var self = this;\n    // store current path\n    this.pwd(function(err, origpath) {\n      if (err) return cb(err);\n      // change to destination path\n      self.cwd(path, function(err) {\n        if (err) return cb(err);\n        // get dir listing\n        self.list(zcomp || false, function(err, list) {\n          // change back to original path\n          if (err) return self.cwd(origpath, cb);\n          self.cwd(origpath, function(err) {\n            if (err) return cb(err);\n            cb(err, list);\n          });\n        });\n      });\n    });\n  } else\n    this.list(path, zcomp, cb);\n};",
        "feature_description": "Add support for filtering directory listings based on file extensions.",
        "detailed_feature_description": "Modify the `list` method in #file 1 to accept an optional `filter` parameter. This parameter will be a function that takes a file name and returns a boolean indicating whether the file should be included in the listing. Update the `listSafe` method in #file 2 to pass this filter function to the `list` method if provided.",
        "modified_complete_code": {
            "#file 1": "FTP.prototype.list = function(path, zcomp, filter, cb) {\n  var self = this, cmd;\n\n  if (typeof path === 'function') {\n    // list(function() {})\n    cb = path;\n    path = undefined;\n    cmd = 'LIST';\n    zcomp = false;\n    filter = undefined;\n  } else if (typeof path === 'boolean') {\n    // list(true, function() {})\n    cb = zcomp;\n    zcomp = path;\n    path = undefined;\n    cmd = 'LIST';\n    filter = undefined;\n  } else if (typeof zcomp === 'function') {\n    // list('/foo', function() {})\n    cb = zcomp;\n    cmd = 'LIST ' + path;\n    zcomp = false;\n    filter = undefined;\n  } else if (typeof filter === 'function') {\n    // list('/foo', true, function() {})\n    cb = filter;\n    filter = zcomp;\n    zcomp = path;\n    path = undefined;\n    cmd = 'LIST';\n  } else\n    cmd = 'LIST ' + path;\n\n  this._pasv(function(err, sock) {\n    if (err)\n      return cb(err);\n\n    if (self._queue[0] && self._queue[0].cmd === 'ABOR') {\n      sock.destroy();\n      return cb();\n    }\n\n    var sockerr, done = false, replies = 0, entries, buffer = '', source = sock;\n    var decoder = new StringDecoder('utf8');\n\n    if (zcomp) {\n      source = zlib.createInflate();\n      sock.pipe(source);\n    }\n\n    source.on('data', function(chunk) {\n      buffer += decoder.write(chunk);\n    });\n    source.once('error', function(err) {\n      if (!sock.aborting)\n        sockerr = err;\n    });\n    source.once('end', ondone);\n    source.once('close', ondone);\n\n    function ondone() {\n      if (decoder) {\n        buffer += decoder.end();\n        decoder = null;\n      }\n      done = true;\n      final();\n    }\n    function final() {\n      if (done && replies === 2) {\n        replies = 3;\n        if (sockerr)\n          return cb(new Error('Unexpected data connection error: ' + sockerr));\n        if (sock.aborting)\n          return cb();\n\n        // process received data\n        entries = buffer.split(RE_EOL);\n        entries.pop(); // ending EOL\n        var parsed = [];\n        for (var i = 0, len = entries.length; i < len; ++i) {\n          var parsedVal = Parser.parseListEntry(entries[i]);\n          if (parsedVal !== null && (!filter || filter(parsedVal.name)))\n            parsed.push(parsedVal);\n        }\n\n        if (zcomp) {\n          self._send('MODE S', function() {\n            cb(undefined, parsed);\n          }, true);\n        } else\n          cb(undefined, parsed);\n      }\n    }\n\n    if (zcomp) {\n      self._send('MODE Z', function(err, text, code) {\n        if (err) {\n          sock.destroy();\n          return cb(makeError(code, 'Compression not supported'));\n        }\n        sendList();\n      }, true);\n    } else\n      sendList();\n\n    function sendList() {\n      // this callback will be executed multiple times, the first is when server\n      // replies with 150 and then a final reply to indicate whether the\n      // transfer was actually a success or not\n      self._send(cmd, function(err, text, code) {\n        if (err) {\n          sock.destroy();\n          if (zcomp) {\n            self._send('MODE S', function() {\n              cb(err);\n            }, true);\n          } else\n            cb(err);\n          return;\n        }\n\n        // some servers may not open a data connection for empty directories\n        if (++replies === 1 && code === 226) {\n          replies = 2;\n          sock.destroy();\n          final();\n        } else if (replies === 2)\n          final();\n      }, true);\n    }\n  });\n};",
            "#file 2": "FTP.prototype.listSafe = function(path, zcomp, filter, cb) {\n  if (typeof path === 'string') {\n    var self = this;\n    // store current path\n    this.pwd(function(err, origpath) {\n      if (err) return cb(err);\n      // change to destination path\n      self.cwd(path, function(err) {\n        if (err) return cb(err);\n        // get dir listing\n        self.list(zcomp || false, filter, function(err, list) {\n          // change back to original path\n          if (err) return self.cwd(origpath, cb);\n          self.cwd(origpath, function(err) {\n            if (err) return cb(err);\n            cb(err, list);\n          });\n        });\n      });\n    });\n  } else\n    this.list(path, zcomp, filter, cb);\n};"
        }
    },
    {
        "repo": "nodebb-plugin-write-api",
        "content": "'nodebb-plugin-write-api/lib/sockets.js'\n:'use strict';\n/* globals module */\n\nvar auth = require('./auth'),\n\n\tSockets = {};\n\nSockets.init = function() {\n\tvar Plugins = require.main.require('./src/socket.io/plugins').writeApi = {};\n\n\tPlugins.createToken = function(socket, uid, callback) {\n\t\tauth.generateToken(uid, callback);\n\t};\n\n\tPlugins.createMasterToken = function(socket, nothing, callback) {\n\t\tauth.generateMasterToken(callback);\n\t};\n\n\tPlugins.revokeToken = function(socket, data, callback) {\n\t\tauth.revokeToken(data.token, data.type, callback);\n\t};\n};\n\nmodule.exports = Sockets;\n'nodebb-plugin-write-api/index.js'\n:'use strict';\n\nvar\tpassport = require.main.require('passport');\nvar\twinston = require.main.require('winston');\nvar BearerStrategy = require('passport-http-bearer').Strategy;\n\nvar meta = require.main.require('./src/meta');\n\nvar auth = require('./lib/auth');\nvar sockets = require('./lib/sockets');\n\nvar API = {};\n\nAPI.init = function (data, callback) {\n\t// API Versions\n\tvar routes = require('./routes')(data.middleware);\n\tdata.router.use('/api/v1', routes.v1);\n\tdata.router.use('/api/v2', routes.v2);\n\n\t// Set up HTTP bearer authentication via Passport\n\tpassport.use(new BearerStrategy({}, function (token, done) {\n\t\t// Find the user by token.  If there is no user with the given token, set\n\t\t// the user to `false` to indicate failure.  Otherwise, return the\n\t\t// authenticated `user`.  Note that in a production-ready application, one\n\t\t// would want to validate the token for authenticity.\n\t\tauth.verifyToken(token, done);\n\t}));\n\n\trequire('./routes/admin')(data.router, data.middleware);\t// ACP\n\tsockets.init();\t// WebSocket listeners\n\n\tAPI.reloadSettings();\n\tcallback();\n};\n\nAPI.addMenuItem = function (custom_header, callback) {\n\tcustom_header.plugins.push({\n\t\troute: '/plugins/write-api',\n\t\ticon: 'fa-cogs',\n\t\tname: 'Write API',\n\t});\n\n\tcallback(null, custom_header);\n};\n\nAPI.authenticate = async (data) => {\n\tawait require('./routes/v2/middleware').requireUser(data.req, data.res, data.next);\n};\n\nAPI.associateUser = require('./routes/v2/middleware').associateUser;\n\nAPI.reloadSettings = function (hash) {\n\tif (!hash || hash === 'settings:writeapi') {\n\t\tmeta.settings.get('writeapi', function (err, settings) {\n\t\t\tif (err) {\n\t\t\t\twinston.warn('[plugins/write-api] Unable to reload settings');\n\t\t\t}\n\n\t\t\tAPI.settings = settings;\n\t\t});\n\t}\n};\n\nmodule.exports = API;\n\n",
        "called_code_segment": "auth.generateToken(uid, callback);",
        "invoking_code_segment": "Plugins.createToken = function(socket, uid, callback) {\n\t\tauth.generateToken(uid, callback);\n\t};",
        "feature_description": "Add an optional expiration time for generated tokens.",
        "detailed_feature_description": "Modify the `generateToken` function in #file 1 to accept an optional expiration time parameter. Update the `createToken` function in #file 2 to pass this optional parameter if provided.",
        "modified_complete_code": {
            "file1": "'use strict';\n/* globals module */\n\nvar auth = require('./auth'),\n\n\tSockets = {};\n\nSockets.init = function() {\n\tvar Plugins = require.main.require('./src/socket.io/plugins').writeApi = {};\n\n\tPlugins.createToken = function(socket, uid, callback, expiration) {\n\t\t//Modify: Pass the optional expiration parameter\n\t\tauth.generateToken(uid, callback, expiration);\n\t};\n\n\tPlugins.createMasterToken = function(socket, nothing, callback) {\n\t\tauth.generateMasterToken(callback);\n\t};\n\n\tPlugins.revokeToken = function(socket, data, callback) {\n\t\tauth.revokeToken(data.token, data.type, callback);\n\t};\n};\n\nmodule.exports = Sockets;",
            "file2": "'use strict';\n\nvar\tpassport = require.main.require('passport');\nvar\twinston = require.main.require('winston');\nvar BearerStrategy = require('passport-http-bearer').Strategy;\n\nvar meta = require.main.require('./src/meta');\n\nvar auth = require('./lib/auth');\nvar sockets = require('./lib/sockets');\n\nvar API = {};\n\nAPI.init = function (data, callback) {\n\t// API Versions\n\tvar routes = require('./routes')(data.middleware);\n\tdata.router.use('/api/v1', routes.v1);\n\tdata.router.use('/api/v2', routes.v2);\n\n\t// Set up HTTP bearer authentication via Passport\n\tpassport.use(new BearerStrategy({}, function (token, done) {\n\t\t// Find the user by token.  If there is no user with the given token, set\n\t\t// the user to `false` to indicate failure.  Otherwise, return the\n\t\t// authenticated `user`.  Note that in a production-ready application, one\n\t\t// would want to validate the token for authenticity.\n\t\tauth.verifyToken(token, done);\n\t}));\n\n\trequire('./routes/admin')(data.router, data.middleware); // ACP\n\tsockets.init(); // WebSocket listeners\n\n\tAPI.reloadSettings();\n\tcallback();\n};\n\nAPI.addMenuItem = function (custom_header, callback) {\n\tcustom_header.plugins.push({\n\t\troute: '/plugins/write-api',\n\t\ticon: 'fa-cogs',\n\t\tname: 'Write API',\n\t});\n\n\tcallback(null, custom_header);\n};\n\nAPI.authenticate = async (data) => {\n\tawait require('./routes/v2/middleware').requireUser(data.req, data.res, data.next);\n};\n\nAPI.associateUser = require('./routes/v2/middleware').associateUser;\n\nAPI.reloadSettings = function (hash) {\n\tif (!hash || hash === 'settings:writeapi') {\n\t\tmeta.settings.get('writeapi', function (err, settings) {\n\t\t\tif (err) {\n\t\t\t\twinston.warn('[plugins/write-api] Unable to reload settings');\n\t\t\t}\n\n\t\t\tAPI.settings = settings;\n\t\t});\n\t}\n};\n\nmodule.exports = API;\n\n//New: Add a function to generate tokens with optional expiration\nauth.generateToken = function(uid, callback, expiration) {\n\t// Implementation to generate token with optional expiration\n\tcallback(null, token);\n};"
        }
    },
    {
        "repo": "nodejs-pool",
        "content": "'nodejs-pool/lib/remote_comms.js'\n:\"use strict\";\nconst request = require('request');\nconst async = require('async');\n\nfunction Database() {\n\n    let thread_id='';\n\n    this.sendQueue = async.queue(function (task, callback) {\n        async.doUntil(\n            function (intCallback) {\n                request.post({url: global.config.general.shareHost, body: task.body, forever: true}, function (error, response, body) {\n                    if (!error) {\n                        return intCallback(null, response.statusCode);\n                    }\n                    return intCallback(null, 0);\n                });\n            },\n            function (data) {\n                return data === 200;\n            },\n            function () {\n                callback();\n            });\n    }, require('os').cpus().length*32);\n\n    this.storeShare = function (blockId, shareData) {\n        let wsData = global.protos.WSData.encode({\n            msgType: global.protos.MESSAGETYPE.SHARE,\n            key: global.config.api.authKey,\n            msg: shareData,\n            exInt: blockId\n        });\n        process.send({type: 'sendRemote', body: wsData.toString('hex')});\n    };\n\n    this.storeBlock = function (blockId, blockData) {\n        let wsData = global.protos.WSData.encode({\n            msgType: global.protos.MESSAGETYPE.BLOCK,\n            key: global.config.api.authKey,\n            msg: blockData,\n            exInt: blockId\n        });\n        process.send({type: 'sendRemote', body: wsData.toString('hex')});\n    };\n\n    this.storeInvalidShare = function (minerData) {\n        let wsData = global.protos.WSData.encode({\n            msgType: global.protos.MESSAGETYPE.INVALIDSHARE,\n            key: global.config.api.authKey,\n            msg: minerData,\n            exInt: 1\n        });\n        process.send({type: 'sendRemote', body: wsData.toString('hex')});\n    };\n\n    setInterval(function(queue_obj){\n        if (global.database.thread_id === '(Master) '){\n            console.log(global.database.thread_id + \"Queue debug state: \" + queue_obj.length() + \" items in the queue \" + queue_obj.running() + \" items being processed\");\n        }\n    }, 5000, this.sendQueue);\n\n\n    this.initEnv = function(){\n        this.data = null;\n    };\n}\n\nmodule.exports = Database;\n'nodejs-pool/debug_scripts/block_share_fix.js'\n:\"use strict\";\nlet mysql = require(\"promise-mysql\");\nlet fs = require(\"fs\");\nlet argv = require('minimist')(process.argv.slice(2));\nlet config = fs.readFileSync(\"../config.json\");\nlet coinConfig = fs.readFileSync(\"../coinConfig.json\");\nlet protobuf = require('protocol-buffers');\nconst request = require('request');\n\nglobal.support = require(\"../lib/support.js\")();\nglobal.config = JSON.parse(config);\nglobal.mysql = mysql.createPool(global.config.mysql);\nglobal.protos = protobuf(fs.readFileSync('../lib/data.proto'));\nlet comms;\nlet coinInc;\n\n\n// Config Table Layout\n// <module>.<item>\n\nglobal.mysql.query(\"SELECT * FROM config\").then(function (rows) {\n    rows.forEach(function (row){\n        if (!global.config.hasOwnProperty(row.module)){\n            global.config[row.module] = {};\n        }\n        if (global.config[row.module].hasOwnProperty(row.item)){\n            return;\n        }\n        switch(row.item_type){\n            case 'int':\n                global.config[row.module][row.item] = parseInt(row.item_value);\n                break;\n            case 'bool':\n                global.config[row.module][row.item] = (row.item_value === \"true\");\n                break;\n            case 'string':\n                global.config[row.module][row.item] = row.item_value;\n                break;\n            case 'float':\n                global.config[row.module][row.item] = parseFloat(row.item_value);\n                break;\n        }\n    });\n}).then(function(){\n    global.config['coin'] = JSON.parse(coinConfig)[global.config.coin];\n    coinInc = require(\".\" + global.config.coin.funcFile);\n    global.coinFuncs = new coinInc();\n    if (argv.module === 'pool'){\n        comms = require('../lib/remote_comms');\n    } else {\n        comms = require('../lib/local_comms');\n    }\n    global.database = new comms();\n    global.database.initEnv();\n    global.coinFuncs.blockedAddresses.push(global.config.pool.address);\n    global.coinFuncs.blockedAddresses.push(global.config.payout.feeAddress);\n}).then(function(){\n    global.database.fixBlockShares(1241110);\n});\n",
        "called_code_segment": "this.storeShare = function (blockId, shareData) {\n    let wsData = global.protos.WSData.encode({\n        msgType: global.protos.MESSAGETYPE.SHARE,\n        key: global.config.api.authKey,\n        msg: shareData,\n        exInt: blockId\n    });\n    process.send({type: 'sendRemote', body: wsData.toString('hex')});\n};",
        "invoking_code_segment": "global.database.storeShare(blockId, shareData);",
        "feature_description": "Add a timestamp to the share data before storing it.",
        "detailed_feature_description": "The new feature involves adding a timestamp to the share data before it is encoded and sent. This timestamp will be included in the share data object and will be used to track when the share was received. The corresponding code in #file 2 will need to handle this new timestamp field.",
        "modified_complete_code": {
            "#file 1": "this.storeShare = function (blockId, shareData) {\n    //Modify: Add timestamp to shareData\n    shareData.timestamp = Date.now();\n    let wsData = global.protos.WSData.encode({\n        msgType: global.protos.MESSAGETYPE.SHARE,\n        key: global.config.api.authKey,\n        msg: shareData,\n        exInt: blockId\n    });\n    process.send({type: 'sendRemote', body: wsData.toString('hex')});\n};",
            "#file 2": "global.database.storeShare(blockId, shareData);",
            "#file 1 (new)": "//New: Ensure shareData is an object and can accept new fields\nif (typeof shareData !== 'object') {\n    shareData = {};\n}"
        }
    },
    {
        "repo": "path-browserify",
        "content": "'path-browserify/test/test-path.js'\n:// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\nvar tape = require('tape');\nvar path = require('../');\n\n// Test thrown TypeErrors\nvar typeErrorTests = [true, false, 7, null, {}, undefined, [], NaN];\n\nfunction fail(t, fn) {\n  var args = [].slice.call(arguments, 1);\n\n  t.throws(function () {\n    fn.apply(null, args);\n  }, TypeError);\n}\n\ntape('path.posix TypeErrors', function (t) {\n  typeErrorTests.forEach(function (test) {\n    fail(t, path.posix.join, test);\n    fail(t, path.posix.resolve, test);\n    fail(t, path.posix.normalize, test);\n    fail(t, path.posix.isAbsolute, test);\n    fail(t, path.posix.relative, test, 'foo');\n    fail(t, path.posix.relative, 'foo', test);\n    fail(t, path.posix.parse, test);\n    fail(t, path.posix.dirname, test);\n    fail(t, path.posix.basename, test);\n    fail(t, path.posix.extname, test);\n\n    // undefined is a valid value as the second argument to basename\n    if (test !== undefined) {\n      fail(t, path.posix.basename, 'foo', test);\n    }\n  });\n  t.end();\n});\n\ntape('path.win32 TypeErrors', { skip: true }, function (t) {\n  typeErrorTests.forEach(function (test) {\n    fail(t, path.win32.join, test);\n    fail(t, path.win32.resolve, test);\n    fail(t, path.win32.normalize, test);\n    fail(t, path.win32.isAbsolute, test);\n    fail(t, path.win32.relative, test, 'foo');\n    fail(t, path.win32.relative, 'foo', test);\n    fail(t, path.win32.parse, test);\n    fail(t, path.win32.dirname, test);\n    fail(t, path.win32.basename, test);\n    fail(t, path.win32.extname, test);\n\n    // undefined is a valid value as the second argument to basename\n    if (test !== undefined) {\n      fail(t, path.win32.basename, 'foo', test);\n    }\n  });\n  t.end();\n});\n\n// path.sep tests\ntape('path.win32.sep', { skip: true }, function (t) {\n  // windows\n  t.strictEqual(path.win32.sep, '\\\\');\n  t.end();\n});\ntape('path.posix.sep', function (t) {\n  // posix\n  t.strictEqual(path.posix.sep, '/');\n  t.end();\n});\n\n// path.delimiter tests\ntape('path.win32.delimiter', { skip: true }, function (t) {\n  // windows\n  t.strictEqual(path.win32.delimiter, ';');\n  t.end();\n});\ntape('path.posix.delimiter', function (t) {\n  // posix\n  t.strictEqual(path.posix.delimiter, ':');\n  t.end();\n});\n\ntape('path', function (t) {\n  t.strictEqual(path, path.posix);\n  t.end();\n});\n\n\n'path-browserify/test/index.js'\n:require('./test-path');\nrequire('./test-path-basename');\nrequire('./test-path-dirname');\nrequire('./test-path-extname');\nrequire('./test-path-isabsolute');\nrequire('./test-path-join');\nrequire('./test-path-relative');\nrequire('./test-path-resolve');\nrequire('./test-path-zero-length-strings');\n\n",
        "called_code_segment": "function fail(t, fn) {\n  var args = [].slice.call(arguments, 1);\n\n  t.throws(function () {\n    fn.apply(null, args);\n  }, TypeError);\n}",
        "invoking_code_segment": "typeErrorTests.forEach(function (test) {\n  fail(t, path.posix.join, test);\n  fail(t, path.posix.resolve, test);\n  fail(t, path.posix.normalize, test);\n  fail(t, path.posix.isAbsolute, test);\n  fail(t, path.posix.relative, test, 'foo');\n  fail(t, path.posix.relative, 'foo', test);\n  fail(t, path.posix.parse, test);\n  fail(t, path.posix.dirname, test);\n  fail(t, path.posix.basename, test);\n  fail(t, path.posix.extname, test);\n\n  // undefined is a valid value as the second argument to basename\n  if (test !== undefined) {\n    fail(t, path.posix.basename, 'foo', test);\n  }\n});",
        "feature_description": "Add a feature to log the type of error being thrown.",
        "detailed_feature_description": "Modify the `fail` function in #file 1 to log the type of error being thrown. Update the invoking code in #file 2 to handle this logging by adding a new parameter to the `fail` function call.",
        "modified_complete_code": {
            "file1": "'use strict';\nvar tape = require('tape');\nvar path = require('../');\n\n// Test thrown TypeErrors\nvar typeErrorTests = [true, false, 7, null, {}, undefined, [], NaN];\n\nfunction fail(t, fn, logError) { // #Modify\n  var args = [].slice.call(arguments, 2);\n\n  t.throws(function () {\n    fn.apply(null, args);\n  }, TypeError, logError); // #Modify\n}",
            "file2": "tape('path.posix TypeErrors', function (t) {\n  typeErrorTests.forEach(function (test) {\n    fail(t, path.posix.join, 'join error', test); // #Modify\n    fail(t, path.posix.resolve, 'resolve error', test); // #Modify\n    fail(t, path.posix.normalize, 'normalize error', test); // #Modify\n    fail(t, path.posix.isAbsolute, 'isAbsolute error', test); // #Modify\n    fail(t, path.posix.relative, 'relative error', test, 'foo'); // #Modify\n    fail(t, path.posix.relative, 'relative error', 'foo', test); // #Modify\n    fail(t, path.posix.parse, 'parse error', test); // #Modify\n    fail(t, path.posix.dirname, 'dirname error', test); // #Modify\n    fail(t, path.posix.basename, 'basename error', test); // #Modify\n    fail(t, path.posix.extname, 'extname error', test); // #Modify\n\n    // undefined is a valid value as the second argument to basename\n    if (test !== undefined) {\n      fail(t, path.posix.basename, 'basename error', 'foo', test); // #Modify\n    }\n  });\n  t.end();\n});"
        }
    },
    {
        "repo": "pkglink",
        "content": "'pkglink/src/util/format.js'\n:import numeral from 'numeral';\nimport truncate from 'cli-truncate';\n\nexport function formatBytes(bytes) {\n  return numeral(bytes).format('0.[00]b');\n}\n\nexport function formatDevNameVersion(dev, name, version) {\n  // use name-version first since device is usually constant\n  return `${name}-${version}:${dev}`;\n}\n\nexport function sortObjKeys(obj) {\n  return Object.keys(obj)\n    .sort()\n    .reduce((acc, k) => {\n      acc[k] = obj[k];\n      return acc;\n    }, {});\n}\n\nexport function trunc(size, str) {\n  return truncate(str, size, { position: 'middle' });\n}\n\n'pkglink/src/cli.js'\n:#!/usr/bin/env node\nimport chalk from 'chalk';\nimport fs from 'fs-extra-promise';\nimport numeral from 'numeral';\nimport OS from 'os';\nimport Path from 'path';\nimport R from 'ramda';\nimport { Observable, ReplaySubject, Subject } from 'rxjs';\nimport SingleLineLog from 'single-line-log';\nimport stripAnsi from 'strip-ansi';\nimport { formatBytes, sortObjKeys } from './util/format';\nimport { outputFileStderrSync } from './util/file';\nimport defaultRTEnv from './run-env-defaults';\nimport { prune, scanAndLink } from './index';\nimport managed from './util/managed';\nimport { gatherOptionsConfig } from './cli-options';\n\nconst isTTY = process.stdout.isTTY; // truthy if in terminal\nconst singleLineLog = SingleLineLog.stderr;\n\nconst rtenv = {\n  // create our copy\n  ...defaultRTEnv\n};\n\nconst { argv, config } = gatherOptionsConfig(\n  process.argv.slice(2),\n  displayHelp\n);\n\n// should we be using terminal output\nconst isTermOut = isTTY && !argv['gen-ln-cmds'];\n\nif (argv.help || (!argv._.length && !argv.prune)) {\n  // display help\n  displayHelp();\n  process.exit(23);\n}\n\nfunction displayHelp() {\n  outputFileStderrSync(Path.join(__dirname, '..', 'usage.txt'));\n}\n\nfs.ensureFileSync(config.refsFile);\n\nconst startingDirs = argv._.map((x) => Path.resolve(x));\n\n// key=nameVersion value: array of ref tuples [modPath, packJsonInode, packJsonMTimeEpoch]\nrtenv.existingPackRefs =\n  fs.readJsonSync(config.refsFile, { throws: false }) || {};\n\nrtenv.cancelled$ = new ReplaySubject(1);\n\nconst singleLineLog$ = new Subject();\nsingleLineLog$\n  .filter((x) => isTermOut) // only if in terminal\n  .distinctUntilChanged()\n  .throttleTime(100)\n  .takeUntil(rtenv.cancelled$)\n  .subscribe({\n    next: (x) => singleLineLog(x),\n    complete: () => {\n      singleLineLog('');\n      singleLineLog.clear();\n    }\n  });\nconst log = singleLineLog$.next.bind(singleLineLog$);\nlog.clear = () => {\n  if (isTermOut) {\n    singleLineLog('');\n    singleLineLog.clear();\n  }\n};\nrtenv.log = log; // share this logger in the rtenv\n\nfunction out(str) {\n  const s = isTermOut ? str : stripAnsi(str);\n  process.stdout.write(s);\n  process.stdout.write(OS.EOL);\n}\nrtenv.out = out; // share this output fn in the rtenv\n\nconst cancel = R.once(() => {\n  rtenv.cancelled = true;\n  rtenv.cancelled$.next(true);\n  console.error('cancelling...');\n});\nconst finalTasks = R.once(() => {\n  singleLineLog$.complete();\n  if (argv.dryrun || argv['gen-ln-cmds']) {\n    out(\n      `# ${chalk.blue('pkgs:')} ${numeral(rtenv.packageCount).format(\n        '0,0'\n      )} ${chalk.yellow('would save:')} ${chalk.bold(\n        formatBytes(rtenv.savedByteCount)\n      )}`\n    );\n    managed.shutdown();\n    return;\n  }\n  if (argv.prune || Object.keys(rtenv.updatedPackRefs).length) {\n    const sortedExistingPackRefs = sortObjKeys(\n      R.merge(rtenv.existingPackRefs, rtenv.updatedPackRefs)\n    );\n    fs.outputJsonSync(config.refsFile, sortedExistingPackRefs);\n    // if pruned or if no savings, at least let them know refs updated\n    if (argv.prune || !rtenv.savedByteCount) {\n      out(`updated ${config.refsFile}`);\n    }\n  }\n  out(\n    `${chalk.blue('pkgs:')} ${numeral(rtenv.packageCount).format(\n      '0,0'\n    )} ${chalk.green('saved:')} ${chalk.bold(\n      formatBytes(rtenv.savedByteCount)\n    )}`\n  );\n  managed.shutdown();\n});\n\nmanaged.onInterrupt(cancel); // fires on SIGINT\nprocess.once('SIGTERM', cancel).once('EXIT', finalTasks);\n\nif (argv.verbose) {\n  console.log('argv', argv);\n  console.log('config', config);\n}\n\nout(''); // advance to full line\n\n// Main program start, create task$ and run\nconst arrTaskObs = [];\nif (argv.prune) {\n  arrTaskObs.push(\n    Observable.defer(() => {\n      log(`${chalk.bold('pruning...')}`);\n      return prune(config, rtenv.existingPackRefs);\n    }).do((newShares) => {\n      rtenv.existingPackRefs = newShares;\n    })\n  );\n}\nif (startingDirs.length) {\n  arrTaskObs.push(\n    Observable.defer(() => scanAndLink(config, rtenv, startingDirs))\n  );\n}\n\n// run all the task observables serially\nif (arrTaskObs.length) {\n  Observable.concat(...arrTaskObs).subscribe({\n    error: (err) => console.error(err),\n    complete: () => finalTasks()\n  });\n}\n\n",
        "called_code_segment": "export function formatBytes(bytes) {\n  return numeral(bytes).format('0.[00]b');\n}\n\nexport function formatDevNameVersion(dev, name, version) {\n  // use name-version first since device is usually constant\n  return `${name}-${version}:${dev}`;\n}\n\nexport function sortObjKeys(obj) {\n  return Object.keys(obj)\n    .sort()\n    .reduce((acc, k) => {\n      acc[k] = obj[k];\n      return acc;\n    }, {});\n}\n\nexport function trunc(size, str) {\n  return truncate(str, size, { position: 'middle' });\n}",
        "invoking_code_segment": "import { formatBytes, sortObjKeys } from './util/format';\n\n// ...\n\nconst sortedExistingPackRefs = sortObjKeys(\n  R.merge(rtenv.existingPackRefs, rtenv.updatedPackRefs)\n);\n\nfs.outputJsonSync(config.refsFile, sortedExistingPackRefs);\n\n// ...\n\nout(\n  `${chalk.blue('pkgs:')} ${numeral(rtenv.packageCount).format(\n    '0,0'\n  )} ${chalk.green('saved:')} ${chalk.bold(\n    formatBytes(rtenv.savedByteCount)\n  )}`\n);",
        "feature_description": "Add a new function to format a list of bytes into a human-readable format with a specified precision.",
        "detailed_feature_description": "The new function, `formatBytesList`, will take a list of byte values and a precision parameter, and return a list of formatted byte strings. This function will be invoked in the CLI file to format the saved byte counts for each package.",
        "modified_complete_code": {
            "pkglink/src/util/format.js": "export function formatBytes(bytes) {\n  return numeral(bytes).format('0.[00]b');\n}\n\n#Modify export function formatBytesList(bytesList, precision = 2) {\n  return bytesList.map(bytes => numeral(bytes).format(`0.${'[' + '0'.repeat(precision) + ']'}b`));\n}\n\nexport function formatDevNameVersion(dev, name, version) {\n  // use name-version first since device is usually constant\n  return `${name}-${version}:${dev}`;\n}\n\nexport function sortObjKeys(obj) {\n  return Object.keys(obj)\n    .sort()\n    .reduce((acc, k) => {\n      acc[k] = obj[k];\n      return acc;\n    }, {});\n}\n\nexport function trunc(size, str) {\n  return truncate(str, size, { position: 'middle' });\n}",
            "pkglink/src/cli.js": "import { formatBytes, formatBytesList, sortObjKeys } from './util/format';\n\n// ...\n\nconst sortedExistingPackRefs = sortObjKeys(\n  R.merge(rtenv.existingPackRefs, rtenv.updatedPackRefs)\n);\n\nfs.outputJsonSync(config.refsFile, sortedExistingPackRefs);\n\n// ...\n\n#Modify const formattedBytesList = formatBytesList(rtenv.savedByteCounts, 2);\nout(\n  `${chalk.blue('pkgs:')} ${numeral(rtenv.packageCount).format(\n    '0,0'\n  )} ${chalk.green('saved:')} ${chalk.bold(\n    formattedBytesList.join(', ')\n  )}`\n);"
        }
    },
    {
        "repo": "z",
        "content": "'z/src/utils.js'\n:// runtime type check for debugging purposes\nconst checkArray = xs => {\n  if (!Array.isArray(xs)) {\n    throw new Error('matchObject expects a list of strings')\n  }\n\n  return xs\n}\n\n// standard compose function\n\nconst compose = (...fns) => x => fns.reduceRight((v,f) => f(v) , x)\n\n// intended to take a single char and return true if it is a letter or number\nconst isChar = x => /[a-zA-Z0-9]/.test(x)\n\n// takes two lists and returns true if all of the elements in the first\n// list are present in the second list\nconst containsAll = (xs, ys) =>\n  xs.map(x => y => y.includes(x)).reduce((res, f) => f(ys) && res, true)\n\n// checks if a reflected list of arguments contains\n// object destructuring syntax\nconst hasDestructuredObjectArguments = xs =>\n  xs.some(x => /({|})/.test(x) && !/function/.test(x))\n\nmodule.exports = {\n  hasDestructuredObjectArguments,\n  checkArray,\n  containsAll,\n  compose,\n  isChar\n}\n\n'z/src/z.js'\n:const getMatchDetails = require('./getMatchDetails')\nconst match = require('./match')\nconst matchArray = require('./matchArray')\nconst { hasDestructuredObjectArguments } = require('./utils')\nconst { objectAndArgsDestructureMatches } = require('./matchObject')\n\nconst resolveMatchFunctions = (subjectToMatch, functions, scope) => {\n  for (let i = 0; i < functions.length; i++) {\n    const currentMatch = getMatchDetails.call(scope, functions[i])\n\n    const matchHasSingleArgument = currentMatch.args.length === 1\n    if (matchHasSingleArgument) {\n      const singleValueResolve = match(currentMatch, subjectToMatch)\n      if (singleValueResolve.hasValue) {\n        return currentMatch.func(singleValueResolve.value)\n      }\n    }\n\n    const matchHasMultipleArguments = currentMatch.args.length > 1\n    if (matchHasMultipleArguments && Array.isArray(subjectToMatch)) {\n      const multipleItemResolve = matchArray(currentMatch, subjectToMatch)\n      if (\n        multipleItemResolve.hasValue &&\n        Array.isArray(multipleItemResolve.value)\n      ) {\n        return currentMatch.func.apply(null, multipleItemResolve.value)\n      }\n\n      if (multipleItemResolve.hasValue) {\n        return currentMatch.func(multipleItemResolve.value)\n      }\n    }\n\n    if (\n      hasDestructuredObjectArguments(currentMatch.args) &&\n      objectAndArgsDestructureMatches(currentMatch.args, subjectToMatch)\n    ) {\n      return currentMatch.func(subjectToMatch)\n    }\n  }\n}\n\nconst matches = (subjectToMatch) => function (...functions) {\n  return resolveMatchFunctions(subjectToMatch, functions, this)\n}\n\nmodule.exports = { matches }\n\n",
        "called_code_segment": "const resolveMatchFunctions = (subjectToMatch, functions, scope) => { ... }",
        "invoking_code_segment": "const matches = (subjectToMatch) => function (...functions) { return resolveMatchFunctions(subjectToMatch, functions, this) }",
        "feature_description": "Add support for matching functions with default values in destructured object arguments.",
        "detailed_feature_description": "Modify the `resolveMatchFunctions` function in #file 1 to handle destructured object arguments with default values. Update the corresponding code in #file 2 to ensure that the new functionality is correctly invoked.",
        "modified_complete_code": {
            "z/src/z.js": "const getMatchDetails = require('./getMatchDetails')\nconst match = require('./match')\nconst matchArray = require('./matchArray')\nconst { hasDestructuredObjectArguments } = require('./utils')\nconst { objectAndArgsDestructureMatches, objectAndArgsDestructureMatchesWithDefaults } = require('./matchObject')\n\n#Modify const resolveMatchFunctions = (subjectToMatch, functions, scope) => {\n  for (let i = 0; i < functions.length; i++) {\n    const currentMatch = getMatchDetails.call(scope, functions[i])\n\n    const matchHasSingleArgument = currentMatch.args.length === 1\n    if (matchHasSingleArgument) {\n      const singleValueResolve = match(currentMatch, subjectToMatch)\n      if (singleValueResolve.hasValue) {\n        return currentMatch.func(singleValueResolve.value)\n      }\n    }\n\n    const matchHasMultipleArguments = currentMatch.args.length > 1\n    if (matchHasMultipleArguments && Array.isArray(subjectToMatch)) {\n      const multipleItemResolve = matchArray(currentMatch, subjectToMatch)\n      if (\n        multipleItemResolve.hasValue &&\n        Array.isArray(multipleItemResolve.value)\n      ) {\n        return currentMatch.func.apply(null, multipleItemResolve.value)\n      }\n\n      if (multipleItemResolve.hasValue) {\n        return currentMatch.func(multipleItemResolve.value)\n      }\n    }\n\n    if (\n      hasDestructuredObjectArguments(currentMatch.args) &&\n      objectAndArgsDestructureMatchesWithDefaults(currentMatch.args, subjectToMatch)\n    ) {\n      return currentMatch.func(subjectToMatch)\n    }\n  }\n}\n\nconst matches = (subjectToMatch) => function (...functions) {\n  return resolveMatchFunctions(subjectToMatch, functions, this)\n}\n\nmodule.exports = { matches }",
            "z/src/matchObject.js": "#New const objectAndArgsDestructureMatchesWithDefaults = (args, subject) => {\n  const defaultValues = args.reduce((acc, arg) => {\n    if (arg.includes('=')) {\n      const [key, value] = arg.split('=').map(s => s.trim())\n      acc[key] = value\n    }\n    return acc\n  }, {})\n\n  return Object.keys(subject).every(key => {\n    return subject[key] === defaultValues[key] || subject[key] === undefined\n  })\n}\n\nmodule.exports = {\n  objectAndArgsDestructureMatches,\n  objectAndArgsDestructureMatchesWithDefaults\n}"
        }
    },
    {
        "repo": "react-animated-tree",
        "content": "'react-animated-tree/src/icons.js'\n:import React from 'react'\n\nconst MinusSquareO = props => (\n  <svg {...props} viewBox=\"64 -65 897 897\">\n    <g>\n      <path\n        d=\"M888 760v0v0v-753v0h-752v0v753v0h752zM888 832h-752q-30 0 -51 -21t-21 -51v-753q0 -29 21 -50.5t51 -21.5h753q29 0 50.5 21.5t21.5 50.5v753q0 30 -21.5 51t-51.5 21v0zM732 347h-442q-14 0 -25 10.5t-11 25.5v0q0 15 11 25.5t25 10.5h442q14 0 25 -10.5t11 -25.5v0\n  q0 -15 -11 -25.5t-25 -10.5z\"\n      />\n    </g>\n  </svg>\n)\n\nconst PlusSquareO = props => (\n  <svg {...props} viewBox=\"64 -65 897 897\">\n    <g>\n      <path\n        d=\"M888 760v0v0v-753v0h-752v0v753v0h752zM888 832h-752q-30 0 -51 -21t-21 -51v-753q0 -29 21 -50.5t51 -21.5h753q29 0 50.5 21.5t21.5 50.5v753q0 30 -21.5 51t-51.5 21v0zM732 420h-184v183q0 15 -10.5 25.5t-25.5 10.5v0q-14 0 -25 -10.5t-11 -25.5v-183h-184\n  q-15 0 -25.5 -11t-10.5 -25v0q0 -15 10.5 -25.5t25.5 -10.5h184v-183q0 -15 11 -25.5t25 -10.5v0q15 0 25.5 10.5t10.5 25.5v183h184q15 0 25.5 10.5t10.5 25.5v0q0 14 -10.5 25t-25.5 11z\"\n      />\n    </g>\n  </svg>\n)\n\nconst EyeO = props => (\n  <svg {...props} viewBox=\"61 51 902 666\">\n    <g>\n      <path\n        d=\"M963 384q0 14 -21 62q-26 65 -61 109q-57 71 -139 112q-99 50 -230 50t-231 -50q-80 -41 -138 -112q-34 -43 -61 -109q-21 -48 -21 -62v0v0v0v0q0 -14 21 -62q27 -66 61 -109q57 -71 139 -112q100 -50 230 -50t230 50q81 41 139 112q35 44 62 109q20 48 20 62v0v0v0v0z\n  M889 384q-25 -77 -64 -126h-1q-46 -59 -114 -93q-85 -42 -198.5 -42t-198.5 42q-67 34 -114 93q-40 49 -65 126q25 77 65 126q47 59 114 93q85 43 199 43t198 -43q67 -33 114 -93q40 -49 65 -126zM512 558q-72 0 -122.5 -50.5t-50.5 -122.5t50.5 -122.5t122.5 -50.5\n  t122.5 50.5t50.5 122.5t-50.5 122.5t-122.5 50.5zM614 385q0 -42 -30 -72t-72 -30t-72 30t-30 72t30 72t72 30t72 -30t30 -72z\"\n      />\n    </g>\n  </svg>\n)\n\nconst CloseSquareO = props => (\n  <svg {...props} viewBox=\"64 -65 897 897\">\n    <g>\n      <path\n        d=\"M717.5 589.5q-10.5 10.5 -25.5 10.5t-26 -10l-154 -155l-154 155q-11 10 -26 10t-25.5 -10.5t-10.5 -25.5t11 -25l154 -155l-154 -155q-11 -10 -11 -25t10.5 -25.5t25.5 -10.5t26 10l154 155l154 -155q11 -10 26 -10t25.5 10.5t10.5 25t-11 25.5l-154 155l154 155\n  q11 10 11 25t-10.5 25.5zM888 760v0v0v-753v0h-752v0v753v0h752zM888 832h-752q-30 0 -51 -21t-21 -51v-753q0 -29 21 -50.5t51 -21.5h753q29 0 50.5 21.5t21.5 50.5v753q0 30 -21.5 51t-51.5 21v0z\"\n      />\n    </g>\n  </svg>\n)\n\nexport { PlusSquareO, MinusSquareO, CloseSquareO, EyeO }\n\n'react-animated-tree/src/index.js'\n:import React from 'react'\nimport PropTypes from 'prop-types'\nimport { Spring, config, animated } from 'react-spring'\nimport * as Icons from './icons'\n\nconst styles = {\n  tree: {\n    position: 'relative',\n    padding: '4px 0px 0px 0px',\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n    overflow: 'hidden',\n    verticalAlign: 'middle',\n  },\n  toggle: {\n    width: '1em',\n    height: '1em',\n    marginRight: 10,\n    cursor: 'pointer',\n    verticalAlign: 'middle',\n  },\n  type: {\n    textTransform: 'uppercase',\n    fontFamily: 'monospace',\n    fontSize: '0.6em',\n    verticalAlign: 'middle',\n  },\n  contents: {\n    willChange: 'transform, opacity, height',\n    marginLeft: 6,\n    padding: '4px 0px 0px 14px',\n    borderLeft: '1px dashed rgba(255,255,255,0.4)',\n  },\n}\n\nconst Contents = ({ children, ...style }) => (\n  <animated.div style={{ ...style, ...styles.contents }}>\n    {children}\n  </animated.div>\n)\n\nexport default class Tree extends React.PureComponent {\n  static defaultProps = { open: false, visible: true, canHide: false }\n  static propTypes = {\n    open: PropTypes.bool,\n    visible: PropTypes.bool,\n    canHide: PropTypes.bool,\n    content: PropTypes.node,\n    springConfig: PropTypes.func,\n  }\n\n  constructor(props) {\n    super()\n    this.state = { open: props.open, visible: props.visible, immediate: false }\n  }\n\n  toggle = () =>\n    this.props.children &&\n    this.setState(state => ({ open: !state.open, immediate: false }))\n\n  toggleVisibility = () => {\n    this.setState(\n      state => ({ visible: !state.visible, immediate: true }),\n      () => this.props.onClick && this.props.onClick(this.state.visible)\n    )\n  }\n\n  componentWillReceiveProps(props) {\n    this.setState(state => {\n      return ['open', 'visible'].reduce(\n        (acc, val) =>\n          this.props[val] !== props[val] ? { ...acc, [val]: props[val] } : acc,\n        {}\n      )\n    })\n  }\n\n  render() {\n    const { open, visible, immediate } = this.state\n    const { children, content, type, style, canHide, springConfig } = this.props\n    const Icon =\n      Icons[`${children ? (open ? 'Minus' : 'Plus') : 'Close'}SquareO`]\n    return (\n      <div style={{ ...styles.tree, ...style }} className=\"treeview\">\n        <Icon\n          className=\"toggle\"\n          style={{ ...styles.toggle, opacity: children ? 1 : 0.3 }}\n          onClick={this.toggle}\n        />\n        <span style={{ ...styles.type, marginRight: type ? 10 : 0 }}>\n          {type}\n        </span>\n        {canHide && (\n          <Icons.EyeO\n            className=\"toggle\"\n            style={{ ...styles.toggle, opacity: visible ? 1 : 0.4 }}\n            onClick={this.toggleVisibility}\n          />\n        )}\n        <span style={{ verticalAlign: 'middle' }}>{content}</span>\n        <Spring\n          native\n          immediate={immediate}\n          config={{\n            ...config.default,\n            restSpeedThreshold: 1,\n            restDisplacementThreshold: 0.01,\n          }}\n          from={{ height: 0, opacity: 0, transform: 'translate3d(20px,0,0)' }}\n          to={{\n            height: open ? 'auto' : 0,\n            opacity: open ? 1 : 0,\n            transform: open ? 'translate3d(0px,0,0)' : 'translate3d(20px,0,0)',\n          }}\n          {...springConfig && springConfig(open)}\n          render={Contents}>\n          {children}\n        </Spring>\n      </div>\n    )\n  }\n}\n\n",
        "called_code_segment": "const Contents = ({ children, ...style }) => (\n  <animated.div style={{ ...style, ...styles.contents }}>\n    {children}\n  </animated.div>\n)",
        "invoking_code_segment": "<Spring\n  native\n  immediate={immediate}\n  config={{ ...config.default, restSpeedThreshold: 1, restDisplacementThreshold: 0.01 }}\n  from={{ height: 0, opacity: 0, transform: 'translate3d(20px,0,0)' }}\n  to={{ height: open ? 'auto' : 0, opacity: open ? 1 : 0, transform: open ? 'translate3d(0px,0,0)' : 'translate3d(20px,0,0)' }}\n  {...springConfig && springConfig(open)}\n  render={Contents}>",
        "feature_description": "Add a hover effect to the tree nodes.",
        "detailed_feature_description": "When hovering over a tree node, the background color of the node will change to a light gray color. This effect will be applied to the `Contents` component in #file 1 and will be triggered by the `onMouseEnter` and `onMouseLeave` events in #file 2.",
        "modified_complete_code": {
            "#file 1": "const Contents = ({ children, ...style }) => (\n  <animated.div\n    style={{ ...style, ...styles.contents, backgroundColor: style.backgroundColor || 'transparent' }}\n    onMouseEnter={() => style.onMouseEnter && style.onMouseEnter()}\n    onMouseLeave={() => style.onMouseLeave && style.onMouseLeave()}\n  >\n    {children}\n  </animated.div>\n)",
            "#file 2": "class Tree extends React.PureComponent {\n  // ...\n  handleMouseEnter = () => {\n    this.setState({ hovered: true });\n  }\n\n  handleMouseLeave = () => {\n    this.setState({ hovered: false });\n  }\n\n  render() {\n    const { open, visible, immediate, hovered } = this.state;\n    const { children, content, type, style, canHide, springConfig } = this.props;\n    const Icon = Icons[`${children ? (open ? 'Minus' : 'Plus') : 'Close'}SquareO`];\n    return (\n      <div style={{ ...styles.tree, ...style }} className=\"treeview\">\n        <Icon\n          className=\"toggle\"\n          style={{ ...styles.toggle, opacity: children ? 1 : 0.3 }}\n          onClick={this.toggle}\n        />\n        <span style={{ ...styles.type, marginRight: type ? 10 : 0 }}>\n          {type}\n        </span>\n        {canHide && (\n          <Icons.EyeO\n            className=\"toggle\"\n            style={{ ...styles.toggle, opacity: visible ? 1 : 0.4 }}\n            onClick={this.toggleVisibility}\n          />\n        )}\n        <span style={{ verticalAlign: 'middle' }}>{content}</span>\n        <Spring\n          native\n          immediate={immediate}\n          config={{ ...config.default, restSpeedThreshold: 1, restDisplacementThreshold: 0.01 }}\n          from={{ height: 0, opacity: 0, transform: 'translate3d(20px,0,0)' }}\n          to={{ height: open ? 'auto' : 0, opacity: open ? 1 : 0, transform: open ? 'translate3d(0px,0,0)' : 'translate3d(20px,0,0)' }}\n          {...springConfig && springConfig(open)}\n          render={Contents}\n          onMouseEnter={this.handleMouseEnter}\n          onMouseLeave={this.handleMouseLeave}\n          backgroundColor={hovered ? '#f0f0f0' : 'transparent'}\n        >\n          {children}\n        </Spring>\n      </div>\n    );\n  }\n}"
        }
    },
    {
        "repo": "react-flask-app",
        "content": "'react-flask-app/src/serviceWorker.js'\n:// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n\n'react-flask-app/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n",
        "called_code_segment": "function registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              console.log('Content is cached for offline use.');\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}",
        "invoking_code_segment": "serviceWorker.unregister();",
        "feature_description": "Add a notification system to inform users when a new version of the app is available.",
        "detailed_feature_description": "Modify the `registerValidSW` function to display a notification to the user when a new version of the app is available. Update the `index.js` file to handle this notification by adding a new function `showUpdateNotification`.",
        "modified_complete_code": {
            "serviceWorker.js": "function registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n              // Modify\n              showUpdateNotification();\n            } else {\n              console.log('Content is cached for offline use.');\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\n// New\nfunction showUpdateNotification() {\n  alert('A new version of the app is available. Please refresh the page to update.');\n}",
            "index.js": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register({\n  onUpdate: registration => {\n    console.log('New content is available; please refresh.');\n  },\n  onSuccess: registration => {\n    console.log('Content is cached for offline use.');\n  }\n});\n\n// New\nfunction showUpdateNotification() {\n  alert('A new version of the app is available. Please refresh the page to update.');\n}"
        }
    },
    {
        "repo": "react-mixin",
        "content": "'react-mixin/toUnsafe.js'\n:var objectAssign = require('object-assign');\n\nfunction toUnsafe(mixin) {\n  var mixin2 = objectAssign({}, mixin);\n\n  if (mixin2.componentWillMount) {\n    mixin2.UNSAFE_componentWillMount = mixin2.componentWillMount;\n    delete mixin2.componentWillMount;\n  }\n\n  if (mixin2.componentWillReceiveProps) {\n    mixin2.UNSAFE_componentWillReceiveProps = mixin2.componentWillReceiveProps;\n    delete mixin2.componentWillReceiveProps;\n  }\n\n  if (mixin2.componentWillUpdate) {\n    mixin2.UNSAFE_componentWillUpdate = mixin2.componentWillUpdate;\n    delete mixin2.componentWillUpdate;\n  }\n\n  return mixin2;\n}\n\nmodule.exports = toUnsafe;\n\n'react-mixin/test/toUnsafe.test.js'\n:const toUnsafe = require('../toUnsafe');\nvar expect = require('expect.js');\n\nit(`works`, () => {\n  const a = () => {};\n  const b = () => {};\n  const c = () => {};\n\n  const m1 = { componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c};\n  const m2 = toUnsafe(m1);\n\n  console.log(m1)\n  expect(m1).to.eql({ componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c}, 'm1 not modified');\n  expect(m2).to.eql({ UNSAFE_componentWillMount: a, UNSAFE_componentWillReceiveProps: b, UNSAFE_componentWillUpdate: c});\n  expect(Object.keys(m2).sort()).to.eql(['UNSAFE_componentWillMount', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'])\n})\n\n",
        "called_code_segment": "function toUnsafe(mixin) {\n  var mixin2 = objectAssign({}, mixin);\n\n  if (mixin2.componentWillMount) {\n    mixin2.UNSAFE_componentWillMount = mixin2.componentWillMount;\n    delete mixin2.componentWillMount;\n  }\n\n  if (mixin2.componentWillReceiveProps) {\n    mixin2.UNSAFE_componentWillReceiveProps = mixin2.componentWillReceiveProps;\n    delete mixin2.componentWillReceiveProps;\n  }\n\n  if (mixin2.componentWillUpdate) {\n    mixin2.UNSAFE_componentWillUpdate = mixin2.componentWillUpdate;\n    delete mixin2.componentWillUpdate;\n  }\n\n  return mixin2;\n}",
        "invoking_code_segment": "const m1 = { componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c};\nconst m2 = toUnsafe(m1);",
        "feature_description": "Add support for renaming deprecated lifecycle methods in mixins to their UNSAFE_ counterparts.",
        "detailed_feature_description": "The `toUnsafe` function will now also handle renaming of `getDerivedStateFromProps` to `UNSAFE_getDerivedStateFromProps` and `getSnapshotBeforeUpdate` to `UNSAFE_getSnapshotBeforeUpdate`.",
        "modified_complete_code": {
            "react-mixin/toUnsafe.js": "var objectAssign = require('object-assign');\n\nfunction toUnsafe(mixin) {\n  var mixin2 = objectAssign({}, mixin);\n\n  if (mixin2.componentWillMount) {\n    mixin2.UNSAFE_componentWillMount = mixin2.componentWillMount;\n    delete mixin2.componentWillMount;\n  }\n\n  if (mixin2.componentWillReceiveProps) {\n    mixin2.UNSAFE_componentWillReceiveProps = mixin2.componentWillReceiveProps;\n    delete mixin2.componentWillReceiveProps;\n  }\n\n  if (mixin2.componentWillUpdate) {\n    mixin2.UNSAFE_componentWillUpdate = mixin2.componentWillUpdate;\n    delete mixin2.componentWillUpdate;\n  }\n\n  #Modify if (mixin2.getDerivedStateFromProps) {\n    mixin2.UNSAFE_getDerivedStateFromProps = mixin2.getDerivedStateFromProps;\n    delete mixin2.getDerivedStateFromProps;\n  }\n\n  #Modify if (mixin2.getSnapshotBeforeUpdate) {\n    mixin2.UNSAFE_getSnapshotBeforeUpdate = mixin2.getSnapshotBeforeUpdate;\n    delete mixin2.getSnapshotBeforeUpdate;\n  }\n\n  return mixin2;\n}\n\nmodule.exports = toUnsafe;",
            "react-mixin/test/toUnsafe.test.js": "const toUnsafe = require('../toUnsafe');\nvar expect = require('expect.js');\n\nit(`works`, () => {\n  const a = () => {};\n  const b = () => {};\n  const c = () => {};\n  const d = () => {};\n  const e = () => {};\n\n  const m1 = { componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c, getDerivedStateFromProps: d, getSnapshotBeforeUpdate: e};\n  const m2 = toUnsafe(m1);\n\n  console.log(m1)\n  expect(m1).to.eql({ componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c, getDerivedStateFromProps: d, getSnapshotBeforeUpdate: e}, 'm1 not modified');\n  expect(m2).to.eql({ UNSAFE_componentWillMount: a, UNSAFE_componentWillReceiveProps: b, UNSAFE_componentWillUpdate: c, UNSAFE_getDerivedStateFromProps: d, UNSAFE_getSnapshotBeforeUpdate: e});\n  expect(Object.keys(m2).sort()).to.eql(['UNSAFE_componentWillMount', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate', 'UNSAFE_getDerivedStateFromProps', 'UNSAFE_getSnapshotBeforeUpdate'])\n})"
        }
    },
    {
        "repo": "react-native-example",
        "content": "'react-native-example/src/App.jsx'\n:import React, { NavigatorIOS, StyleSheet } from 'react-native';\nimport { MediaList } from './views';\n\nexport default class App extends React.Component {\n\n  render() {\n    return (\n      <NavigatorIOS\n        style={styles.container}\n        initialRoute={{\n          component: MediaList,\n          title: 'Around Me'\n        }}\n      />\n    )\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  }\n});\n\n'react-native-example/src/main.js'\n:import React, { AppRegistry } from 'react-native';\nimport App from './App';\n\nAppRegistry.registerComponent('AroundMe', () => App);\n\n",
        "called_code_segment": "export default class App extends React.Component {\n  render() {\n    return (\n      <NavigatorIOS\n        style={styles.container}\n        initialRoute={{component: MediaList, title: 'Around Me'}}\n      />\n    )\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 }\n});",
        "invoking_code_segment": "AppRegistry.registerComponent('AroundMe', () => App);",
        "feature_description": "Add a loading indicator to the MediaList component.",
        "detailed_feature_description": "Modify the MediaList component to display a loading indicator while data is being fetched. Update the App component to handle the loading state and pass it as a prop to the MediaList component.",
        "modified_complete_code": "// #file 1: src/App.jsx\nimport React, { NavigatorIOS, StyleSheet } from 'react-native';\nimport { MediaList } from './views';\n\n#Modify export default class App extends React.Component {\n  state = {\n    loading: true\n  };\n\n  componentDidMount() {\n    // Simulate data fetching\n    setTimeout(() => {\n      this.setState({ loading: false });\n    }, 2000);\n  }\n\n  render() {\n    return (\n      <NavigatorIOS\n        style={styles.container}\n        initialRoute={{component: MediaList, title: 'Around Me', passProps: { loading: this.state.loading }}}\n      />\n    )\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: { flex: 1 }\n});\n\n// #file 2: src/main.js\nimport React, { AppRegistry } from 'react-native';\nimport App from './App';\n\nAppRegistry.registerComponent('AroundMe', () => App);\n\n// #New: src/views/MediaList.jsx\nimport React from 'react';\nimport { View, Text, ActivityIndicator, StyleSheet } from 'react-native';\n\nexport default class MediaList extends React.Component {\n  render() {\n    if (this.props.loading) {\n      return (\n        <View style={styles.loadingContainer}>\n          <ActivityIndicator size=\"large\" color=\"#0000ff\" />\n          <Text>Loading...</Text>\n        </View>\n      );\n    }\n\n    return (\n      <View>\n        <Text>Media List Content</Text>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center' }\n});"
    },
    {
        "repo": "react-native-gesture-recognizers",
        "content": "'react-native-gesture-recognizers/src/recognizers/swipeable.js'\n:'use strict';\n\nimport React, {Component, PropTypes} from 'react';\nimport { View, PanResponder, Animated } from 'react-native';\nimport isValidSwipe from '../utils/isValidSwipe';\n\nconst directions = {\n  SWIPE_UP: 'SWIPE_UP',\n  SWIPE_DOWN: 'SWIPE_DOWN',\n  SWIPE_LEFT: 'SWIPE_LEFT',\n  SWIPE_RIGHT: 'SWIPE_RIGHT'\n};\n\nconst propTypes = {\n  onSwipeBegin: PropTypes.func,\n  onSwipe: PropTypes.func,\n  onSwipeEnd: PropTypes.func,\n  swipeDecoratorStyle: PropTypes.object\n};\n\nconst swipeable = ({\n  horizontal = false,\n  vertical = false,\n  left = false,\n  right = false,\n  up = false,\n  down = false,\n  continuous = true,\n  initialVelocityThreshold = 0.7,\n  verticalThreshold = 10,\n  horizontalThreshold = 10,\n  setGestureState = true\n} = {}) => BaseComponent => {\n\n  const checkHorizontal = horizontal || (left || right);\n  const checkVertical = vertical || (up || down);\n\n  return class extends Component {\n\n    static propTypes = propTypes;\n\n    constructor(props, context) {\n      super(props, context);\n\n      this.state = {\n        swipe: {\n          direction: null,\n          distance: 0,\n          velocity: 0\n        }\n      };\n\n      this.swipeDetected = false;\n      this.velocityProp = null;\n      this.distanceProp = null;\n      this.swipeDirection = null;\n     }\n\n    componentWillMount() {\n      this.panResponder = PanResponder.create({\n\n        onStartShouldSetPanResponder: (evt) => {\n          return evt.nativeEvent.touches.length === 1;\n        },\n\n        onMoveShouldSetPanResponder: (evt) => {\n          return evt.nativeEvent.touches.length === 1;\n        },\n\n        onPanResponderMove: (evt, gestureState) => {\n          const {dx, dy, vx, vy} = gestureState;\n          const { onSwipeBegin, onSwipe } = this.props;\n\n          if (!continuous && this.swipeDetected) {\n            return;\n          }\n\n          let initialDetection = false;\n          let validHorizontal = false;\n          let validVertical = false;\n\n          if (!this.swipeDetected) {\n            initialDetection = true;\n\n            validHorizontal = checkHorizontal && isValidSwipe(\n              vx, dy, initialVelocityThreshold, verticalThreshold\n            );\n            validVertical = checkVertical && isValidSwipe(\n              vy, dx, initialVelocityThreshold, horizontalThreshold\n            );\n\n            if (validHorizontal) {\n              this.velocityProp = 'vx';\n              this.distanceProp = 'dx';\n\n              if ((horizontal || left) && dx < 0) {\n                this.swipeDirection = directions.SWIPE_LEFT;\n              } else if ((horizontal || right) && dx > 0) {\n                this.swipeDirection = directions.SWIPE_RIGHT;\n              }\n            } else if (validVertical) {\n              this.velocityProp = 'vy';\n              this.distanceProp = 'dy';\n\n              if ((vertical || up) && dy < 0) {\n                this.swipeDirection = directions.SWIPE_UP;\n              } else if ((vertical || down) && dy > 0) {\n                this.swipeDirection = directions.SWIPE_DOWN;\n              }\n            }\n\n            if (this.swipeDirection) {\n              this.swipeDetected = true;\n            }\n          }\n\n          if (this.swipeDetected) {\n            const distance = gestureState[this.distanceProp];\n            const velocity = gestureState[this.velocityProp];\n\n            const swipeState = {\n              direction: this.swipeDirection,\n              distance,\n              velocity\n            };\n\n            if (initialDetection) {\n              onSwipeBegin && onSwipeBegin(swipeState); // eslint-disable-line no-unused-expressions\n            } else {\n              onSwipe && onSwipe(swipeState); // eslint-disable-line no-unused-expressions\n            }\n\n            if (setGestureState) {\n              this.setState({\n                swipe: swipeState\n              });\n            }\n          }\n        },\n\n        onPanResponderTerminationRequest: () => true,\n        onPanResponderTerminate: this.handleTerminationAndRelease,\n        onPanResponderRelease: this.handleTerminationAndRelease\n      });\n    }\n\n    handleTerminationAndRelease = () => {\n      if (this.swipeDetected) {\n        const { onSwipeEnd } = this.props;\n        onSwipeEnd && onSwipeEnd({ // eslint-disable-line no-unused-expressions\n          direction: this.swipeDirection\n        });\n      }\n\n      this.swipeDetected = false;\n      this.velocityProp = null;\n      this.distanceProp = null;\n      this.swipeDirection = null;\n    }\n\n    render() {\n      const {\n        onSwipeBegin,\n        onSwipe,\n        onSwipeEnd,\n        swipeDecoratorStyle,\n        ...props\n      } = this.props;\n\n      const style = {\n        ...swipeDecoratorStyle,\n        alignSelf: 'flex-start'\n      };\n\n      const state = setGestureState ? this.state : null;\n\n      return (\n        <View {...this.panResponder.panHandlers} style={style}>\n          <BaseComponent {...props} {...state} />\n        </View>\n      );\n    }\n  };\n};\n\nswipeable.directions = directions;\n\nexport default swipeable;\n\n'react-native-gesture-recognizers/src/index.js'\n:'use strict';\n\nimport pannable from './recognizers/pannable';\nimport swipeable from './recognizers/swipeable';\n\nexport {\n    pannable,\n    swipeable\n}\n\n",
        "called_code_segment": "swipeable.directions = directions;",
        "invoking_code_segment": "import swipeable from './recognizers/swipeable';",
        "feature_description": "Add a new direction constant for diagonal swipes.",
        "detailed_feature_description": "Introduce a new direction constant SWIPE_DIAGONAL in the directions object within the swipeable recognizer. Update the swipeable function to handle this new direction and modify the invoking code to include this new direction in the swipe detection logic.",
        "modified_complete_code": {
            "#file 1": {
                "swipeable.js": "//Modify\nconst directions = {\n  SWIPE_UP: 'SWIPE_UP',\n  SWIPE_DOWN: 'SWIPE_DOWN',\n  SWIPE_LEFT: 'SWIPE_LEFT',\n  SWIPE_RIGHT: 'SWIPE_RIGHT',\n  SWIPE_DIAGONAL: 'SWIPE_DIAGONAL' //New\n};\n\n//Modify\nconst swipeable = ({\n  horizontal = false,\n  vertical = false,\n  left = false,\n  right = false,\n  up = false,\n  down = false,\n  diagonal = false, //New\n  continuous = true,\n  initialVelocityThreshold = 0.7,\n  verticalThreshold = 10,\n  horizontalThreshold = 10,\n  setGestureState = true\n} = {}) => BaseComponent => {\n\n  const checkHorizontal = horizontal || (left || right);\n  const checkVertical = vertical || (up || down);\n  const checkDiagonal = diagonal; //New\n\n  return class extends Component {\n\n    static propTypes = propTypes;\n\n    constructor(props, context) {\n      super(props, context);\n\n      this.state = {\n        swipe: {\n          direction: null,\n          distance: 0,\n          velocity: 0\n        }\n      };\n\n      this.swipeDetected = false;\n      this.velocityProp = null;\n      this.distanceProp = null;\n      this.swipeDirection = null;\n     }\n\n    componentWillMount() {\n      this.panResponder = PanResponder.create({\n\n        onStartShouldSetPanResponder: (evt) => {\n          return evt.nativeEvent.touches.length === 1;\n        },\n\n        onMoveShouldSetPanResponder: (evt) => {\n          return evt.nativeEvent.touches.length === 1;\n        },\n\n        onPanResponderMove: (evt, gestureState) => {\n          const {dx, dy, vx, vy} = gestureState;\n          const { onSwipeBegin, onSwipe } = this.props;\n\n          if (!continuous && this.swipeDetected) {\n            return;\n          }\n\n          let initialDetection = false;\n          let validHorizontal = false;\n          let validVertical = false;\n          let validDiagonal = false; //New\n\n          if (!this.swipeDetected) {\n            initialDetection = true;\n\n            validHorizontal = checkHorizontal && isValidSwipe(\n              vx, dy, initialVelocityThreshold, verticalThreshold\n            );\n            validVertical = checkVertical && isValidSwipe(\n              vy, dx, initialVelocityThreshold, horizontalThreshold\n            );\n            validDiagonal = checkDiagonal && isValidSwipe(\n              vx, vy, initialVelocityThreshold, verticalThreshold\n            ); //New\n\n            if (validHorizontal) {\n              this.velocityProp = 'vx';\n              this.distanceProp = 'dx';\n\n              if ((horizontal || left) && dx < 0) {\n                this.swipeDirection = directions.SWIPE_LEFT;\n              } else if ((horizontal || right) && dx > 0) {\n                this.swipeDirection = directions.SWIPE_RIGHT;\n              }\n            } else if (validVertical) {\n              this.velocityProp = 'vy';\n              this.distanceProp = 'dy';\n\n              if ((vertical || up) && dy < 0) {\n                this.swipeDirection = directions.SWIPE_UP;\n              } else if ((vertical || down) && dy > 0) {\n                this.swipeDirection = directions.SWIPE_DOWN;\n              }\n            } else if (validDiagonal) { //New\n              this.velocityProp = 'vx';\n              this.distanceProp = 'dx';\n              this.swipeDirection = directions.SWIPE_DIAGONAL;\n            }\n\n            if (this.swipeDirection) {\n              this.swipeDetected = true;\n            }\n          }\n\n          if (this.swipeDetected) {\n            const distance = gestureState[this.distanceProp];\n            const velocity = gestureState[this.velocityProp];\n\n            const swipeState = {\n              direction: this.swipeDirection,\n              distance,\n              velocity\n            };\n\n            if (initialDetection) {\n              onSwipeBegin && onSwipeBegin(swipeState); // eslint-disable-line no-unused-expressions\n            } else {\n              onSwipe && onSwipe(swipeState); // eslint-disable-line no-unused-expressions\n            }\n\n            if (setGestureState) {\n              this.setState({\n                swipe: swipeState\n              });\n            }\n          }\n        },\n\n        onPanResponderTerminationRequest: () => true,\n        onPanResponderTerminate: this.handleTerminationAndRelease,\n        onPanResponderRelease: this.handleTerminationAndRelease\n      });\n    }\n\n    handleTerminationAndRelease = () => {\n      if (this.swipeDetected) {\n        const { onSwipeEnd } = this.props;\n        onSwipeEnd && onSwipeEnd({ // eslint-disable-line no-unused-expressions\n          direction: this.swipeDirection\n        });\n      }\n\n      this.swipeDetected = false;\n      this.velocityProp = null;\n      this.distanceProp = null;\n      this.swipeDirection = null;\n    }\n\n    render() {\n      const {\n        onSwipeBegin,\n        onSwipe,\n        onSwipeEnd,\n        swipeDecoratorStyle,\n        ...props\n      } = this.props;\n\n      const style = {\n        ...swipeDecoratorStyle,\n        alignSelf: 'flex-start'\n      };\n\n      const state = setGestureState ? this.state : null;\n\n      return (\n        <View {...this.panResponder.panHandlers} style={style}>\n          <BaseComponent {...props} {...state} />\n        </View>\n      );\n    }\n  };\n};\n\nswipeable.directions = directions;"
            },
            "#file 2": {
                "index.js": "import pannable from './recognizers/pannable';\nimport swipeable from './recognizers/swipeable';\n\nexport {\n    pannable,\n    swipeable\n}"
            }
        }
    },
    {
        "repo": "react-native-vision",
        "content": "'react-native-vision/module.js'\n:import { NativeModules, NativeEventEmitter } from \"react-native\";\nconst RNVNative = NativeModules.RHDVisionModule;\n//#region Event Management\nvar cachedEmitter = null;\nconst getEmitter = () => {\n  if (!cachedEmitter) {\n    cachedEmitter = new NativeEventEmitter(RNVNative);\n  }\n  return cachedEmitter;\n};\nvar cachedListener = null;\nconst addListener = (region, key, cb) => {\n  const newKey = region + \"_\" + key;\n  if (!cachedListener) {\n    cachedListener = getEmitter().addListener(\"RNVision\", masterHandler);\n  }\n  cachedHandlers[newKey] = cb;\n};\nconst masterHandler = body => {\n  const region = String(body[\"region\"]);\n  const thisKey = String(body[\"key\"]);\n  const key = region + \"_\" + thisKey;\n  if (typeof cachedHandlers[key] == \"function\") {\n    cachedHandlers[key](body);\n  } else {\n    console.log(\"NO handler for \", key, region, thisKey);\n  }\n};\nvar cachedHandlers = {};\nconst removeListener = (region, key) => {\n  const newKey = String(region) + \"_\" + String(key);\n  delete cachedHandlers[newKey];\n};\n//#endregion\n//#region Lifecycle management\nconst start = async cameraFront => {\n  return await RNVNative.start(cameraFront);\n};\nconst stop = async () => {\n  cachedHandlers = {};\n  cachedListener.remove();\n  cachedEmitter = null;\n  return await RNVNative.stop();\n};\nconst attachCameraView = async () => {\n  return await RNVNative.attachCameraView();\n};\nconst isCameraFrame = async isTrue => {\n  return await RNVNative.isCameraView(isTrue);\n};\nconst getImageDimensions = async () => {\n  return await RNVNative.getImageDimensions();\n};\nvar ImageDimensionListener = null;\nconst setImageDimensionListener = cb => {\n  if (!cb) return removeImageDimensionListener();\n  if (typeof cb != \"function\")\n    throw new Error(\"Argument must be a function in setImageDimensionListener\");\n  if (ImageDimensionListener) removeImageDimensionListener;\n  ImageDimensionListener = getEmitter().addListener(\"RNVisionImageDim\", cb);\n  return true;\n};\nconst removeImageDimensionListener = () => {\n  if (ImageDimensionListener) ImageDimensionListener.remove();\n  ImageDimensionListener = null;\n  return true;\n};\n//#endregion\n//#region Save Frame\nconst saveFrame = async (region, disposition, callback) => {\n  //Add a listener\n  addListener(region, \"saveFrame\", callback);\n  return await RNVNative.saveFrame(disposition, region);\n};\nconst removeSaveFrame = async region => {\n  removeListener(region, \"saveFrame\");\n  return await RNVNative.removeSaveFrame(region);\n};\nconst saveFrameOnce = (region, disposition) => {\n  return new Promise((resolve, reject) => {\n    saveFrame(region, disposition, async body => {\n      await removeSaveFrame(region);\n\n      return body;\n    });\n  });\n};\n//#endregion\n//#region Face Detection\nconst detectFaces = async (region, handler) => {\n  const key = await RNVNative.detectFaces(region); // Key should be \"detectFaces\"\n  addListener(region, key, body => {\n    return handler(body.data);\n  });\n  return key;\n};\nconst removeDetectFaces = async region => {\n  removeListener(region, \"detectFaces\");\n  return await RNVNative.removeDetectFaces(region);\n};\nconst detectFacesOnce = region => {\n  return new Promise((resolve, reject) => {\n    detectFaces(region, body => {\n      removeDetectFaces(region);\n      resolve(body);\n    });\n  });\n};\n//#endregion\n//#region Object Tracking\nvar boxHandlers = {};\nvar boxListener = null;\nconst trackObject = async (region, name, boxDictionary, callback) => {\n  if ((await RNVNative.trackObject(name, region, boxDictionary)) !== null) {\n    addListener(region, name, callback);\n    return true;\n  } else return false;\n};\nconst removeTrackObject = async (region, name) => {\n  removeListener(region, name);\n  return await RNVNative.removeTrackObject(name, region);\n};\nconst removeTrackObjects = async region => {\n  const data = await RNVNative.removeTrackObjects(region);\n  if (data.removedKeys) {\n    data.removedKeys.forEach(removedKey => {\n      removeListener(removedKey);\n    });\n  }\n  return true;\n};\n//#endregion\n//#region Region Management\nconst setRegion = async (region, rectangle) => {\n  return await RNVNative.setRegion(region, rectangle);\n};\nconst removeRegion = async region => {\n  return await RNVNative.removeRegion(region);\n};\n//#endregion\n//#region Machine Learning Models\nconst applyMLClassifier = async (\n  region,\n  modelURL,\n  maxResults,\n  callback = null\n) => {\n  if (typeof maxResults == \"function\") {\n    callback = maxResults;\n    maxResults = 5;\n  }\n  const key = await RNVNative.applyMLClassifier(modelURL, region, maxResults);\n  if (key) {\n    addListener(region, key, body => {\n      callback(body.data);\n    });\n  }\n  return key;\n};\nconst applyMLClassifierOnce = (region, modelURL, maxResults) => {\n  return new Promise((resolve, reject) => {\n    applyMLClassifier(region, modelURL, maxResults, body => {\n      removeML(region, modelURL);\n      resolve(body);\n    });\n  });\n};\nconst applyMLGenerator = async (region, modelURL, handler, callback) => {\n  const key = await RNVNative.applyMLGenerator(modelURL, region, handler);\n  if (handler != \"view\" && typeof callback == \"function\") {\n    addListener(region, key, data => {\n      callback(data.data);\n    });\n  }\n  return key;\n};\nconst applyMLBottleneck = async modelURL => {\n  return await RNVNative.applyMLBottleneck(modelURL);\n};\nconst applyMLGeneric = async (region, modelURL, callback) => {\n  const key = await RNVNative.applyMLGeneric(modelURL, region);\n  if (key) {\n    addListener(region, key, body => {\n      callback(body.data);\n    });\n  }\n  return key;\n};\nconst applyMLGenericOnce = (region, modelURL) => {\n  return new Promise((resolve, reject) => {\n    applyMLGeneric(region, modelURL, body => {\n      removeML(region, modelURL);\n      resolve(body);\n    });\n  });\n};\nconst removeML = async (region, modelURL) => {\n  removeListener(region, modelURL);\n  return await RNVNative.removeML(modelURL, region);\n};\n//#endregion\n//#region ML Bottlenecks\nconst REGION_ALL = \"\";\nconst applyBottleneckClassifier = async (\n  modelURL,\n  region,\n  toModelURL,\n  maxResults,\n  callback = null\n) => {\n  if (typeof maxResults == \"function\") {\n    callback = maxResults;\n    maxResults = 5;\n  }\n  const key = await RNVNative.applyBottleneckClassifier(\n    modelURL,\n    region,\n    toModelURL,\n    maxResults\n  );\n  if (key) {\n    addListener(key, body => {\n      callback(body.data);\n    });\n  }\n};\nconst applyBottleneckGenerator = async (\n  modelURL,\n  region,\n  toModelURL,\n  handlerOrCallback\n) => {\n  const handler =\n    typeof handlerOrCallback == \"function\" ? \"sendEvent\" : handlerOrCallback;\n  const key = await RNVNative.applyBottleneckGenerator(\n    modelURL,\n    handler,\n    region,\n    toModelURL\n  );\n  if (key && handler == \"sendEvent\") addListener(key, handlerOrCallback);\n};\nconst applyBottleneckBottleneck = async (modelURL, region, toModelURL) => {\n  return await RNVNative.applyBottleneckBottleneck(modelURL, toModelURL);\n};\nconst applyBottleneckGeneric = async (\n  modelURL,\n  region,\n  toModelURL,\n  callback\n) => {\n  const key = await RNVNative.applyBottleneckGeneric(\n    modelURL,\n    region,\n    toModelURL\n  );\n  if (key) {\n    addListener(key, body => {\n      callback(body.data);\n    });\n  }\n};  \nconst removeBottleneck = async (modelURL, region, fromModelURL) => {\n  removeListener(modelURL);\n  return await RNVNative.removeBottleneck(modelURL, region, fromModelURL);\n};\nconst removeBottlenecks = async (region, fromModelURL) => {\n  const out = await RNVNative.removeBottlenecks(region, fromModelURL);\n  if (out) {\n    if (out.removedBottlenecks) {\n      out.removedBottlenecks.forEach(key => {\n        removeListener(key);\n      });\n    }\n  }\n};\n//#endregion\n//#region MultiArray access\n//Returns URL of saved file\nconst saveMultiArray = async name => {\n  return await RNVNative.saveMultiArray(name);\n};\n//#endregion\n//#region Metadata Capture\nvar MDListener = null;\nconst handleMetadata = async callback => {\n  removeMetadataListener();\n  MDListener = getEmitter().addListener(\"RNVisionMetaData\", callback);\n};\nconst removeMetadataListener = {\n  if(MDListener) {\n    MDListener.remove();\n  }\n};\n//#endregion\n//#region Exports\nexport {\n  REGION_ALL,\n  start,\n  stop,\n  attachCameraView,\n  isCameraFrame,\n  getImageDimensions,\n  setImageDimensionListener,\n  removeImageDimensionListener,\n  saveFrame,\n  saveFrameOnce,\n  removeSaveFrame,\n  detectFaces,\n  detectFacesOnce,\n  removeDetectFaces,\n  trackObject,\n  removeTrackObject,\n  setRegion,\n  removeRegion,\n  applyMLClassifier,\n  applyMLClassifierOnce,\n  applyMLGenerator,\n  applyMLBottleneck,\n  applyMLGeneric,\n  applyMLGenericOnce,\n  applyBottleneckClassifier,\n  applyBottleneckGenerator,\n  applyBottleneckBottleneck,\n  applyBottleneckGeneric,\n  removeML,\n  removeBottleneck,\n  removeBottlenecks,\n  handleMetadata,\n  removeMetadataListener\n};\n//#endregion\n\n'react-native-vision/index.js'\n:import { RNVCameraView, RNVCameraConsumer } from \"./view\";\nimport Delegate from \"./module\";\nimport RNVImageView from \"./imageview\";\nimport { RNVisionProvider, RNVisionConsumer } from \"./wrapper\";\nimport { RNVRegion, RNVDefaultRegion } from \"./region\";\nimport {\n  CameraRegion as RNVCameraRegion,\n  calculateRectangles\n} from \"./cameraregion\";\nimport {\n  FacesProvider,\n  FacesConsumer,\n  Face,\n  Faces,\n  FaceCamera\n} from \"./faceprovider\";\nimport { VisionCamera } from \"./visioncamera\";\nimport { StyleView } from \"./styleview\";\nexport {\n  RNVCameraView,\n  Delegate,\n  RNVisionProvider,\n  RNVisionConsumer,\n  RNVImageView,\n  RNVRegion,\n  RNVCameraRegion,\n  RNVCameraConsumer,\n  calculateRectangles,\n  RNVDefaultRegion,\n  FacesProvider,\n  FacesConsumer,\n  Face,\n  Faces,\n  FaceCamera,\n  VisionCamera,\n  StyleView as GeneratorView\n};\n\n",
        "called_code_segment": "const start = async cameraFront => {\n  return await RNVNative.start(cameraFront);\n};",
        "invoking_code_segment": "const startVision = async (cameraFront) => {\n  await Delegate.start(cameraFront);\n};",
        "feature_description": "Add a feature to log the camera status when starting the vision.",
        "detailed_feature_description": "Modify the `start` function in #file 1 to log the camera status (front or back) when starting the vision. Update the invoking code in #file 2 to handle the new logging feature.",
        "modified_complete_code": {
            "#file 1": "const start = async cameraFront => {\n  console.log(`Starting vision with ${cameraFront ? 'front' : 'back'} camera`);\n  return await RNVNative.start(cameraFront);\n}; #Modify",
            "#file 2": "const startVision = async (cameraFront) => {\n  await Delegate.start(cameraFront);\n};"
        }
    },
    {
        "repo": "react-navigation-auth-flow",
        "content": "'react-navigation-auth-flow/app/auth.js'\n:export const onSignIn = () => {\n  console.log(\"handle sign in\");\n};\n\nexport const onSignOut = () => {\n  console.log(\"handle sign out\");\n};\n\n'react-navigation-auth-flow/app/screens/Profile.js'\n:import React from \"react\";\nimport { View } from \"react-native\";\nimport { Card, Button, Text } from \"react-native-elements\";\nimport { onSignOut } from \"../auth\";\n\nexport default () => (\n  <View style={{ paddingVertical: 20 }}>\n    <Card title=\"John Doe\">\n      <View\n        style={{\n          backgroundColor: \"#bcbec1\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          width: 80,\n          height: 80,\n          borderRadius: 40,\n          alignSelf: \"center\",\n          marginBottom: 20\n        }}\n      >\n        <Text style={{ color: \"white\", fontSize: 28 }}>JD</Text>\n      </View>\n      <Button\n        backgroundColor=\"#03A9F4\"\n        title=\"SIGN OUT\"\n        onPress={() => onSignOut()}\n      />\n    </Card>\n  </View>\n);\n\n",
        "called_code_segment": "export const onSignOut = () => {\n  console.log(\"handle sign out\");\n};",
        "invoking_code_segment": "<Button\n  backgroundColor=\"#03A9F4\"\n  title=\"SIGN OUT\"\n  onPress={() => onSignOut()}\n/>",
        "feature_description": "Add a confirmation dialog before signing out.",
        "detailed_feature_description": "Before signing out, a confirmation dialog will be shown to the user. If the user confirms, the sign-out process will proceed; otherwise, it will be canceled.",
        "modified_complete_code": {
            "auth.js": "import { Alert } from 'react-native'; //New\n\nexport const onSignOut = () => {\n  Alert.alert(\n    'Confirm Sign Out',\n    'Are you sure you want to sign out?',\n    [\n      { text: 'Cancel', style: 'cancel' },\n      { text: 'Sign Out', onPress: () => console.log('handle sign out') },\n    ]\n  );\n}; //Modify",
            "Profile.js": "import React from \"react\";\nimport { View } from \"react-native\";\nimport { Card, Button, Text } from \"react-native-elements\";\nimport { onSignOut } from \"../auth\";\n\nexport default () => (\n  <View style={{ paddingVertical: 20 }}>\n    <Card title=\"John Doe\">\n      <View\n        style={{\n          backgroundColor: \"#bcbec1\",\n          alignItems: \"center\",\n          justifyContent: \"center\",\n          width: 80,\n          height: 80,\n          borderRadius: 40,\n          alignSelf: \"center\",\n          marginBottom: 20\n        }}\n      >\n        <Text style={{ color: \"white\", fontSize: 28 }}>JD</Text>\n      </View>\n      <Button\n        backgroundColor=\"#03A9F4\"\n        title=\"SIGN OUT\"\n        onPress={() => onSignOut()}\n      />\n    </Card>\n  </View>\n);"
        }
    },
    {
        "repo": "resourceful",
        "content": "'resourceful/test/engines/memory.js'\n:var engine = exports;\n\nengine.name = 'memory';\nengine.options = { uri: 'test' };\n\nengine.load = function (resourceful, data, callback) {\n  data = data.map(function (r) {\n    r = JSON.parse(JSON.stringify(r));\n    r.id = r._id;\n    delete r._id;\n    return r;\n  });\n\n  new(resourceful.engines.Memory)(engine.options).load(data);\n  callback();\n};\n\n'resourceful/test/memory-filter-test.js'\n:var assert = require('assert'),\n    events = require('events'),\n    cradle = require('cradle'),\n    vows = require('vows'),\n    resourceful = require('../lib/resourceful');\n\nvar Article;\n\nresourceful.env = 'test';\n\nvar memory = require('./engines/memory');\n\nvows.describe('resourceful/resource/view').addBatch({\n  \"A database containing articles and other resources\": {\n    topic: function () {\n      resourceful.use(memory.name, memory.options);\n      this.callback();\n    },\n    \"is created\": function () {},\n    \"A Resource definition with filters\": {\n      topic: function () {\n        Article = resourceful.define('Article', function () {\n          this.property('author');\n          this.property('title');\n          this.property('published', Boolean);\n\n          this.filter('all', {});\n          this.filter('published', { published: true });\n          this.filter('by', function (author) { return { author: author } });\n          this.filter('byTag', { map: function (doc) { if ( doc.resource == \"Article\" && doc.tags ) doc.tags.forEach(function(tag) { emit ( tag, doc );  }); } });\n        })\n\n        Article.register();\n        return Article;\n      },\n      \"is populated with articles and other resources\" : function (R) {\n        R.create({ _id: '1', resource: 'Article', title: 'The Great Gatsby', published: true,  author: 'fitzgerald', tags: ['classic'] });\n        R.create({ _id: '2', resource: 'Article', title: 'Finding vim',      published: false, author: 'cloudhead',  tags: ['hacking', 'vi'] });\n        R.create({ _id: '3', resource: 'Article', title: 'On Writing',       published: true,  author: 'cloudhead',  tags: ['writing'] });\n        R.create({ _id: '4', resource: 'Article', title: 'vi Zen',           published: false, author: 'cloudhead',  tags: ['vi', 'zen'] });\n        R.create({ _id: '5', resource: 'Article', title: 'Channeling force', published: true,  author: 'yoda',       tags: ['force', 'zen'] })\n      },\n      \"should respond to the filters\": function (R) {\n        assert.isFunction(R.published);\n        assert.isFunction(R.all);\n        assert.isFunction(R.by);\n       // assert.isFunction(R.byTag);\n      },\n      \"can be used to query the database:\": {\n        \"<published>\": {\n          topic: function (Article) {\n            this.Article = Article;\n            Article.published(this.callback);\n          },\n          \"should return an array of all published Articles\": function (e, res) {\n            var that = this;\n            assert.isArray(res);\n            assert.equal(res.length,3);\n            res.forEach(function (d) {\n              assert.isObject(d);\n              assert.instanceOf(d,that.Article);\n              assert.equal(d.constructor,that.Article);\n              assert.equal(d.resource,'Article');\n              assert.ok(d.published);\n            });\n          }\n        },\n        \"<all>\": {\n          topic: function (Article) {\n            Article.all(this.callback);\n          },\n          \"should return an array of all Article records\": function (e, res) {\n            assert.isArray(res);\n            assert.equal(res.length,5);\n          }\n        },\n        \"<by> 'cloudhead'\": {\n          topic: function (Article) {\n            Article.by('cloudhead', this.callback);\n          },\n          \"should return an array of Article records by 'cloudhead'\": function (e, res) {\n            assert.isArray(res);\n            assert.equal(res.length,3);\n            res.forEach(function (d) {\n              assert.isObject(d);\n              assert.equal(d.resource,'Article');\n              assert.equal(d.author,'cloudhead');\n            });\n          }\n        },\n        \"<by> 'yoda'\": {\n          topic: function (Article) {\n            Article.by('yoda', this.callback);\n          },\n          \"should return an array of Article records by 'yoda'\": function (e, res) {\n            assert.isArray(res);\n            assert.equal(res.length,1);\n            assert.equal(res[0].author,'yoda');\n          }\n        },\n        \"<by> ['yoda', 'fitzgerald']\": {\n          topic: function (Article) {\n            Article.by({\n              keys: ['yoda', 'fitzgerald']\n            }, this.callback);\n          },\n          \"should return an array of Article records by 'yoda' or 'fitzgerald'\": function (e, res) {\n            assert.isArray(res);\n            assert.equal(res.length, 2);\n            assert(\n              (res[0].author === 'yoda' && res[1].author === 'fitzgerald') ||\n              (res[0].author === 'fitzgerald' && res[1].author === 'yoda')\n            );\n          }\n        },\n        \"<byTag> 'classic'\": {\n          topic: function (Article) {\n            Article.byTag('classic', this.callback);\n          },\n          \"should return an array of Article records tagged 'classic'\": function (e, res) {\n            var that = this;\n            assert.isArray(res);\n            assert.equal(res.length,1);\n            assert.equal(res[0].tags[0], 'classic');\n            res.forEach(function (d) {\n                assert.isObject(d);\n                assert.instanceOf(d,Article);\n                assert.equal(d.constructor,Article);\n                assert.equal(d.resource,'Article');\n                assert.ok(d.published);\n              });\n          }\n        },\n        \"<byTag> ['classic', 'hacking']\": {\n          topic: function (Article) {\n            Article.byTag({\n              keys: ['classic', 'hacking']\n            }, this.callback);\n          },\n          \"should return an array of Article records tagged 'classic' or 'hacking'\": function (e, res) {\n            var that = this;\n            assert.isArray(res);\n            assert.equal(res.length, 2);\n            \n            assert(\n              (res[0].tags[0] === 'classic' && res[1].tags[0] === 'hacking') ||\n              (res[0].tags[0] === 'hacking' && res[1].tags[0] === 'classic')\n            );\n            \n            res.forEach(function (d) {\n                assert.isObject(d);\n                assert.instanceOf(d,Article);\n                assert.equal(d.constructor,Article);\n                assert.equal(d.resource,'Article');\n              });\n          }\n        }\n      }\n    }\n  }\n}).addBatch({\n  \"A second Resource definition with filters\": {\n    topic: function () {\n      return resourceful.define('Person', function () {\n        this.property('name');\n        this.property('position');\n        this.property('age', Number);\n\n        this.filter('all', {});\n        this.filter('at', function (position) { return { position: position } });\n        this.filter('age', function (age) { return { age: age } });\n      }).register();\n    },\n    \"should have no side effects on the first resource views\": function () {\n      var views = Object.keys(Article.views);\n      assert.isTrue(views.indexOf('at')===-1);\n      assert.isTrue(views.indexOf('age')===-1);\n    }\n  }\n}).export(module);\n\n",
        "called_code_segment": "engine.load = function (resourceful, data, callback) {\n  data = data.map(function (r) {\n    r = JSON.parse(JSON.stringify(r));\n    r.id = r._id;\n    delete r._id;\n    return r;\n  });\n\n  new(resourceful.engines.Memory)(engine.options).load(data);\n  callback();\n};",
        "invoking_code_segment": "resourceful.use(memory.name, memory.options);\nthis.callback();",
        "feature_description": "Add support for custom data transformation before loading into the memory engine.",
        "detailed_feature_description": "Modify the `engine.load` function in #file 1 to accept a custom transformation function. Update the invoking code in #file 2 to pass a transformation function that converts all titles to uppercase before loading the data into the memory engine.",
        "modified_complete_code": {
            "#file 1": "var engine = exports;\n\nengine.name = 'memory';\nengine.options = { uri: 'test' };\n\nengine.load = function (resourceful, data, callback, transform) { #Modify\n  if (transform) {\n    data = data.map(transform); #New\n  } else {\n    data = data.map(function (r) {\n      r = JSON.parse(JSON.stringify(r));\n      r.id = r._id;\n      delete r._id;\n      return r;\n    });\n  }\n\n  new(resourceful.engines.Memory)(engine.options).load(data);\n  callback();\n};",
            "#file 2": "var assert = require('assert'),\n    events = require('events'),\n    cradle = require('cradle'),\n    vows = require('vows'),\n    resourceful = require('../lib/resourceful');\n\nvar Article;\n\nresourceful.env = 'test';\n\nvar memory = require('./engines/memory');\n\nvows.describe('resourceful/resource/view').addBatch({\n  \"A database containing articles and other resources\": {\n    topic: function () {\n      var transform = function (r) { #New\n        r = JSON.parse(JSON.stringify(r));\n        r.id = r._id;\n        delete r._id;\n        if (r.title) r.title = r.title.toUpperCase();\n        return r;\n      };\n      resourceful.use(memory.name, memory.options, transform); #Modify\n      this.callback();\n    },\n    \"is created\": function () {},\n    \"A Resource definition with filters\": {\n      topic: function () {\n        Article = resourceful.define('Article', function () {\n          this.property('author');\n          this.property('title');\n          this.property('published', Boolean);\n\n          this.filter('all', {});\n          this.filter('published', { published: true });\n          this.filter('by', function (author) { return { author: author } });\n          this.filter('byTag', { map: function (doc) { if ( doc.resource == \"Article\" && doc.tags ) doc.tags.forEach(function(tag) { emit ( tag, doc );  }); } });\n        })\n\n        Article.register();\n        return Article;\n      },\n      \"is populated with articles and other resources\": function (R) {\n        R.create({ _id: '1', resource: 'Article', title: 'The Great Gatsby', published: true,  author: 'fitzgerald', tags: ['classic'] });\n        R.create({ _id: '2', resource: 'Article', title: 'Finding vim',      published: false, author: 'cloudhead',  tags: ['hacking', 'vi'] });\n        R.create({ _id: '3', resource: 'Article', title: 'On Writing',       published: true,  author: 'cloudhead',  tags: ['writing'] });\n        R.create({ _id: '4', resource: 'Article', title: 'vi Zen',           published: false, author: 'cloudhead',  tags: ['vi', 'zen'] });\n        R.create({ _id: '5', resource: 'Article', title: 'Channeling force', published: true,  author: 'yoda',       tags: ['force', 'zen'] })\n      },\n      \"should respond to the filters\": function (R) {\n        assert.isFunction(R.published);\n        assert.isFunction(R.all);\n        assert.isFunction(R.by);\n       // assert.isFunction(R.byTag);\n      },\n      \"can be used to query the database:\": {\n        \"<published>\": {\n          topic: function (Article) {\n            this.Article = Article;\n            Article.published(this.callback);\n          },\n          \"should return an array of all published Articles\": function (e, res) {\n            var that = this;\n            assert.isArray(res);\n            assert.equal(res.length,3);\n            res.forEach(function (d) {\n              assert.isObject(d);\n              assert.instanceOf(d,that.Article);\n              assert.equal(d.constructor,that.Article);\n              assert.equal(d.resource,'Article');\n              assert.ok(d.published);\n            });\n          }\n        },\n        \"<all>\": {\n          topic: function (Article) {\n            Article.all(this.callback);\n          },\n          \"should return an array of all Article records\": function (e, res) {\n            assert.isArray(res);\n            assert.equal(res.length,5);\n          }\n        },\n        \"<by> 'cloudhead'\": {\n          topic: function (Article) {\n            Article.by('cloudhead', this.callback);\n          },\n          \"should return an array of Article records by 'cloudhead'\": function (e, res) {\n            assert.isArray(res);\n            assert.equal(res.length,3);\n            res.forEach(function (d) {\n              assert.isObject(d);\n              assert.equal(d.resource,'Article');\n              assert.equal(d.author,'cloudhead');\n            });\n          }\n        },\n        \"<by> 'yoda'\": {\n          topic: function (Article) {\n            Article.by('yoda', this.callback);\n          },\n          \"should return an array of Article records by 'yoda'\": function (e, res) {\n            assert.isArray(res);\n            assert.equal(res.length,1);\n            assert.equal(res[0].author,'yoda');\n          }\n        },\n        \"<by> ['yoda', 'fitzgerald']\": {\n          topic: function (Article) {\n            Article.by({\n              keys: ['yoda', 'fitzgerald']\n            }, this.callback);\n          },\n          \"should return an array of Article records by 'yoda' or 'fitzgerald'\": function (e, res) {\n            assert.isArray(res);\n            assert.equal(res.length, 2);\n            assert(\n              (res[0].author === 'yoda' && res[1].author === 'fitzgerald') ||\n              (res[0].author === 'fitzgerald' && res[1].author === 'yoda')\n            );\n          }\n        },\n        \"<byTag> 'classic'\": {\n          topic: function (Article) {\n            Article.byTag('classic', this.callback);\n          },\n          \"should return an array of Article records tagged 'classic'\": function (e, res) {\n            var that = this;\n            assert.isArray(res);\n            assert.equal(res.length,1);\n            assert.equal(res[0].tags[0], 'classic');\n            res.forEach(function (d) {\n                assert.isObject(d);\n                assert.instanceOf(d,Article);\n                assert.equal(d.constructor,Article);\n                assert.equal(d.resource,'Article');\n                assert.ok(d.published);\n              });\n          }\n        },\n        \"<byTag> ['classic', 'hacking']\": {\n          topic: function (Article) {\n            Article.byTag({\n              keys: ['classic', 'hacking']\n            }, this.callback);\n          },\n          \"should return an array of Article records tagged 'classic' or 'hacking'\": function (e, res) {\n            var that = this;\n            assert.isArray(res);\n            assert.equal(res.length, 2);\n            \n            assert(\n              (res[0].tags[0] === 'classic' && res[1].tags[0] === 'hacking') ||\n              (res[0].tags[0] === 'hacking' && res[1].tags[0] === 'classic')\n            );\n            \n            res.forEach(function (d) {\n                assert.isObject(d);\n                assert.instanceOf(d,Article);\n                assert.equal(d.constructor,Article);\n                assert.equal(d.resource,'Article');\n              });\n          }\n        }\n      }\n    }\n  }\n}).addBatch({\n  \"A second Resource definition with filters\": {\n    topic: function () {\n      return resourceful.define('Person', function () {\n        this.property('name');\n        this.property('position');\n        this.property('age', Number);\n\n        this.filter('all', {});\n        this.filter('at', function (position) { return { position: position } });\n        this.filter('age', function (age) { return { age: age } });\n      }).register();\n    },\n    \"should have no side effects on the first resource views\": function () {\n      var views = Object.keys(Article.views);\n      assert.isTrue(views.indexOf('at')===-1);\n      assert.isTrue(views.indexOf('age')===-1);\n    }\n  }\n}).export(module);"
        }
    },
    {
        "repo": "securing-restful-apis-with-jwt",
        "content": "'securing-restful-apis-with-jwt/app.js'\n:var express = require('express');\nvar app = express();\nvar db = require('./db');\nglobal.__root   = __dirname + '/'; \n\napp.get('/api', function (req, res) {\n  res.status(200).send('API works.');\n});\n\nvar UserController = require(__root + 'user/UserController');\napp.use('/api/users', UserController);\n\nvar AuthController = require(__root + 'auth/AuthController');\napp.use('/api/auth', AuthController);\n\nmodule.exports = app;\n'securing-restful-apis-with-jwt/server.js'\n:var app = require('./app');\nvar port = process.env.PORT || 3000;\n\nvar server = app.listen(port, function() {\n  console.log('Express server listening on port ' + port);\n});\n",
        "called_code_segment": "app.get('/api', function (req, res) {\n  res.status(200).send('API works.');\n});",
        "invoking_code_segment": "var app = require('./app');\nvar port = process.env.PORT || 3000;\n\nvar server = app.listen(port, function() {\n  console.log('Express server listening on port ' + port);\n});",
        "feature_description": "Add a health check endpoint that returns the server status.",
        "detailed_feature_description": "Modify the existing '/api' endpoint in app.js to return a JSON object with the server status. Update the server.js to log the server status when the server starts.",
        "modified_complete_code": {
            "app.js": "var express = require('express');\nvar app = express();\nvar db = require('./db');\nglobal.__root   = __dirname + '/'; \n\n//Modify\napp.get('/api', function (req, res) {\n  res.status(200).json({ status: 'API works' });\n});\n\nvar UserController = require(__root + 'user/UserController');\napp.use('/api/users', UserController);\n\nvar AuthController = require(__root + 'auth/AuthController');\napp.use('/api/auth', AuthController);\n\nmodule.exports = app;",
            "server.js": "var app = require('./app');\nvar port = process.env.PORT || 3000;\n\n//Modify\nvar server = app.listen(port, function() {\n  console.log('Express server listening on port ' + port);\n  console.log('Server status: API works');\n});"
        }
    },
    {
        "repo": "stresser",
        "content": "'stresser/config.js'\n:'use strict';\nconst path = require('path');\nconst argv = require('minimist')(process.argv.slice(2));\nconst url = argv._[0];\n\nif (argv.h || argv.help || !url) {\n    console.log(\n        `\n    Usage: stresser <URL> [options]\n\n    Options:\n        -h | --help\n            Outputs this helpful information\n\n        -t | --timeout= <milliseconds> [10000]\n            Sets the time a request waits for response\n\n        -n | --count= <number> [10]\n            Sets the number of seconds\n\n        -c | --concurrent= <number> [100]\n            Sets the number of concurrent requests\n\n        -m | --method <GET|HEAD|POST|PUT|DELETE|*> [GET]\n            Sets the request method\n\n        -b | --body <body as string>\n            Sets body of the request (JSON)\n\n        -f | --force\n            Forces the stress test to stop at the requested time even if requests have not finished\n\n        -v | --verbose <e|b|c>\n            Sets verbosity\n                - e: Errors\n                - c: HTTP Status Codes\n                - b: HTTP body\n\n        --html=<path/to/report/file.html> [${path.join(__dirname, 'report', `report-${Date.now()}.html`)}]\n            Outputs an HTML report file to location\n            Set --html=false if you want to disable it\n\n        --threads=<number> [#cpus]\n            The number of cpus that will be used to stress test\n\n\n    Example: stresser http://example.com/page.html -c 10000 -n 10 -t 20000 --html=/home/reports/report-$(date +%s).html --threads=16 --force\n`\n    );\n\n    process.exit(1);\n}\n\nconst html = argv.html === false || argv.html === 'false' ? null : argv.html || path.join(path.dirname(process.argv[1]), 'report', `report-${Date.now()}.html`);\nconst timeout = argv.t || argv.timeout || 10000;\nconst count = argv.n || argv.count || 10;\nconst concurrent = argv.c || argv.concurrent || 100;\nconst method = argv.m || argv.method || 'get';\nconst body = argv.b || argv.body;\n\nconst _v = argv.v || argv.verbose || '';\nconst verbose = {\n    e: ~_v.indexOf('e'),\n    c: ~_v.indexOf('c'),\n    b: ~_v.indexOf('b')\n};\n\nconst CPUs = argv.threads || require('os').cpus().length;\nconst concurrentPerCPU = Math.max(Math.floor(concurrent / CPUs), 1);\nconst force = argv.f || argv.force;\n\nmodule.exports = {\n    url,\n    method,\n    body,\n    count,\n    concurrent,\n    timeout,\n    html,\n    verbose,\n    concurrentPerCPU,\n    CPUs,\n    force\n};\n\nhtml && console.error('Will output report file to', html);\n'stresser/index.js'\n:#!/usr/bin/env node\n'use strict';\nconst cluster = require('cluster');\n\nif (cluster.isMaster) {\n    const config = require('./config');\n\n    console.error('Booting up', config.CPUs, 'workers');\n    let online = 0;\n    for (let i = 0; i < config.CPUs; i++) {\n        const worker = cluster.fork();\n        worker.on('online', () => {\n            online++;\n\n            setTimeout(() => {\n                worker.send({ type: 'setup', data: config });\n\n                if (online === config.CPUs) {\n                    return setTimeout(() => require('./master'), 100);\n                }\n            }, 100);\n        });\n    }\n\n    return;\n}\n\nreturn require('./worker');\n",
        "called_code_segment": "if (cluster.isMaster) {\n    const config = require('./config');\n\n    console.error('Booting up', config.CPUs, 'workers');\n    let online = 0;\n    for (let i = 0; i < config.CPUs; i++) {\n        const worker = cluster.fork();\n        worker.on('online', () => {\n            online++;\n\n            setTimeout(() => {\n                worker.send({ type: 'setup', data: config });\n\n                if (online === config.CPUs) {\n                    return setTimeout(() => require('./master'), 100);\n                }\n            }, 100);\n        });\n    }\n\n    return;\n}",
        "invoking_code_segment": "if (cluster.isMaster) {\n    const config = require('./config');\n\n    console.error('Booting up', config.CPUs, 'workers');\n    let online = 0;\n    for (let i = 0; i < config.CPUs; i++) {\n        const worker = cluster.fork();\n        worker.on('online', () => {\n            online++;\n\n            setTimeout(() => {\n                worker.send({ type: 'setup', data: config });\n\n                if (online === config.CPUs) {\n                    return setTimeout(() => require('./master'), 100);\n                }\n            }, 100);\n        });\n    }\n\n    return;\n}",
        "feature_description": "Add a feature to log the start and end times of the stress test.",
        "detailed_feature_description": "Modify the master process to log the start and end times of the stress test. This will involve adding a timestamp at the beginning and the end of the stress test in the master process. Additionally, update the worker process to send a message back to the master when it finishes its tasks.",
        "modified_complete_code": {
            "index.js": "#!/usr/bin/env node\n'use strict';\nconst cluster = require('cluster');\n\nif (cluster.isMaster) {\n    const config = require('./config');\n\n    console.error('Booting up', config.CPUs, 'workers');\n    let online = 0;\n    let startTime = Date.now(); #Modify\n    for (let i = 0; i < config.CPUs; i++) {\n        const worker = cluster.fork();\n        worker.on('online', () => {\n            online++;\n\n            setTimeout(() => {\n                worker.send({ type: 'setup', data: config });\n\n                if (online === config.CPUs) {\n                    return setTimeout(() => require('./master'), 100);\n                }\n            }, 100);\n        });\n    }\n\n    cluster.on('message', (worker, message) => {\n        if (message.type === 'finish') {\n            console.error('Worker finished:', worker.id);\n            if (Object.keys(cluster.workers).every(id => cluster.workers[id].isDead())) {\n                let endTime = Date.now(); #Modify\n                console.error('Stress test completed in:', (endTime - startTime) / 1000, 'seconds');\n                process.exit(0);\n            }\n        }\n    });\n\n    return;\n}\n\nreturn require('./worker');",
            "worker.js": "'use strict';\nconst cluster = require('cluster');\nconst stressTest = require('./stressTest');\n\ncluster.worker.on('message', async (message) => {\n    if (message.type === 'setup') {\n        const config = message.data;\n        await stressTest(config);\n        cluster.worker.send({ type: 'finish' }); #Modify\n        process.exit(0);\n    }\n});"
        }
    },
    {
        "repo": "Chatire",
        "content": "'Chatire/chatire-frontend/build/webpack.prod.conf.js'\n:'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\n\nconst env = process.env.NODE_ENV === 'testing'\n  ? require('../config/test.env')\n  : require('../config/prod.env')\n\nconst webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  devtool: config.build.productionSourceMap ? config.build.devtool : false,\n  output: {\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath('js/[name].[chunkhash].js'),\n    chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')\n  },\n  plugins: [\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    new webpack.DefinePlugin({\n      'process.env': env\n    }),\n    new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          warnings: false\n        }\n      },\n      sourceMap: config.build.productionSourceMap,\n      parallel: true\n    }),\n    // extract css into its own file\n    new ExtractTextPlugin({\n      filename: utils.assetsPath('css/[name].[contenthash].css'),\n      // Setting the following option to `false` will not extract CSS from codesplit chunks.\n      // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.\n      // It's currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it's `false`, \n      // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110\n      allChunks: true,\n    }),\n    // Compress extracted CSS. We are using this plugin so that possible\n    // duplicated CSS from different components can be deduped.\n    new OptimizeCSSPlugin({\n      cssProcessorOptions: config.build.productionSourceMap\n        ? { safe: true, map: { inline: false } }\n        : { safe: true }\n    }),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: process.env.NODE_ENV === 'testing'\n        ? 'index.html'\n        : config.build.index,\n      template: 'index.html',\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      chunksSortMode: 'dependency'\n    }),\n    // keep module.id stable when vendor modules does not change\n    new webpack.HashedModuleIdsPlugin(),\n    // enable scope hoisting\n    new webpack.optimize.ModuleConcatenationPlugin(),\n    // split vendor js into its own file\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n      minChunks (module) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &&\n          /\\.js$/.test(module.resource) &&\n          module.resource.indexOf(\n            path.join(__dirname, '../node_modules')\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'manifest',\n      minChunks: Infinity\n    }),\n    // This instance extracts shared chunks from code splitted chunks and bundles them\n    // in a separate chunk, similar to the vendor chunk\n    // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'app',\n      async: 'vendor-async',\n      children: true,\n      minChunks: 3\n    }),\n\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.build.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nif (config.build.productionGzip) {\n  const CompressionWebpackPlugin = require('compression-webpack-plugin')\n\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      asset: '[path].gz[query]',\n      algorithm: 'gzip',\n      test: new RegExp(\n        '\\\\.(' +\n        config.build.productionGzipExtensions.join('|') +\n        ')$'\n      ),\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nif (config.build.bundleAnalyzerReport) {\n  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n  webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n\nmodule.exports = webpackConfig\n\n'Chatire/chatire-frontend/build/build.js'\n:'use strict'\nrequire('./check-versions')()\n\nprocess.env.NODE_ENV = 'production'\n\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n\nconst spinner = ora('building for production...')\nspinner.start()\n\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {\n  if (err) throw err\n  webpack(webpackConfig, (err, stats) => {\n    spinner.stop()\n    if (err) throw err\n    process.stdout.write(stats.toString({\n      colors: true,\n      modules: false,\n      children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build.\n      chunks: false,\n      chunkModules: false\n    }) + '\\n\\n')\n\n    if (stats.hasErrors()) {\n      console.log(chalk.red('  Build failed with errors.\\n'))\n      process.exit(1)\n    }\n\n    console.log(chalk.cyan('  Build complete.\\n'))\n    console.log(chalk.yellow(\n      '  Tip: built files are meant to be served over an HTTP server.\\n' +\n      '  Opening index.html over file:// won\\'t work.\\n'\n    ))\n  })\n})\n\n",
        "called_code_segment": "webpackConfig.plugins.push(new CompressionWebpackPlugin({ asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp('\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$'), threshold: 10240, minRatio: 0.8 }))",
        "invoking_code_segment": "if (config.build.productionGzip) { const CompressionWebpackPlugin = require('compression-webpack-plugin') webpackConfig.plugins.push(new CompressionWebpackPlugin({ asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp('\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$'), threshold: 10240, minRatio: 0.8 })) }",
        "new_file_code_segment": "function customCompression(options) { return new CompressionWebpackPlugin({ asset: options.asset, algorithm: options.algorithm, test: options.test, threshold: options.threshold, minRatio: options.minRatio }) }",
        "feature_description": "Add custom compression options",
        "detailed_feature_description": "The new feature allows for custom compression options to be passed dynamically. A new function `customCompression` is created in #file 3 to handle these options. This function is then invoked in #file 1 and #file 2 to replace the hardcoded compression settings, making the compression process more flexible and configurable.",
        "modified_complete_code": {
            "#file 1": "webpackConfig.plugins.push(customCompression({ asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp('\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$'), threshold: 10240, minRatio: 0.8 })) #Modify",
            "#file 2": "if (config.build.productionGzip) { const CompressionWebpackPlugin = require('compression-webpack-plugin') const customCompression = require('./customCompression') webpackConfig.plugins.push(customCompression({ asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp('\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$'), threshold: 10240, minRatio: 0.8 })) } #Modify",
            "#file 3": "function customCompression(options) { return new CompressionWebpackPlugin({ asset: options.asset, algorithm: options.algorithm, test: options.test, threshold: options.threshold, minRatio: options.minRatio }) } #New module.exports = { customCompression } #New"
        }
    },
    {
        "repo": "Registration-and-Login-using-MERN-stack",
        "content": "'Registration-and-Login-using-MERN-stack/api/server.js'\n:const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst PORT = 4000;\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst config = require('./DB.js');\nconst registrationRoutes = require('./route');\n\nmongoose.Promise = global.Promise;\nmongoose.connect(config.DB, { useNewUrlParser: true }).then(\n    () => { console.log('Database is connected') },\n    err => { console.log('Can not connect to the database' + err) }\n);\n\napp.use(cors());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(\"./schema/User\", registrationRoutes);\n\n\nmodule.exports = app\n'Registration-and-Login-using-MERN-stack/api/app.js'\n:var app = require(\"./server\");\nconst PORT = 4000;\n\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});\n",
        "called_code_segment": "app.use(cors());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(\"./schema/User\", registrationRoutes);",
        "invoking_code_segment": "var app = require(\"./server\");\nconst PORT = 4000;\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});",
        "new_file_code_segment": "const rateLimit = require('express-rate-limit');\n\nconst limiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100 // limit each IP to 100 requests per windowMs\n});\n\nmodule.exports = limiter;",
        "feature_description": "Implement rate limiting to prevent abuse of the API.",
        "detailed_feature_description": "The new feature introduces rate limiting to the API using the `express-rate-limit` middleware. This will limit the number of requests a client can make to the server within a specified time window. The rate limiter is configured to allow a maximum of 100 requests per IP address within a 15-minute window. The `limiter` middleware is added to the `app` in #file 1 to enforce this rate limit across all routes.",
        "modified_complete_code": {
            "#file 1": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst config = require('./DB.js');\nconst registrationRoutes = require('./route');\nconst limiter = require('./rateLimiter'); // #New\n\nmongoose.Promise = global.Promise;\nmongoose.connect(config.DB, { useNewUrlParser: true }).then(\n    () => { console.log('Database is connected') },\n    err => { console.log('Can not connect to the database' + err) }\n);\n\napp.use(cors());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(limiter); // #Modify\napp.use(\"./schema/User\", registrationRoutes);\n\nmodule.exports = app;",
            "#file 2": "var app = require(\"./server\");\nconst PORT = 4000;\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});",
            "#file 3": "const rateLimit = require('express-rate-limit');\n\nconst limiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100 // limit each IP to 100 requests per windowMs\n});\n\nmodule.exports = limiter;"
        }
    },
    {
        "repo": "SimpleStateManager",
        "content": "'SimpleStateManager/src/state.js'\n:import {\n    fireAllMethodsInArray,\n    makeID,\n} from './utils';\n\nconst configOptions = [];\nlet stateChangeMethod = () => { };\n\nexport default class State {\n    constructor(options) {\n        this.id = options.id || makeID();\n        this.query = options.query || 'all';\n\n        const defaultOptions = {\n            onEnter: [],\n            onLeave: [],\n            onResize: [],\n            onFirstRun: [],\n        };\n\n        // Merge options with defaults to make the state\n        this.options = Object.assign({}, defaultOptions, options);\n\n        // Migrate methods into an array, this is to enable future functionality of adding extra methods to an existing state\n        if (typeof this.options.onEnter === 'function') {\n            this.options.onEnter = [this.options.onEnter];\n        }\n\n        if (typeof this.options.onLeave === 'function') {\n            this.options.onLeave = [this.options.onLeave];\n        }\n\n        if (typeof this.options.onResize === 'function') {\n            this.options.onResize = [this.options.onResize];\n        }\n\n        if (typeof this.options.onFirstRun === 'function') {\n            this.options.onFirstRun = [this.options.onFirstRun];\n        }\n\n        // Test the one time tests first, if the test is invalid we wont create the config option\n        if (this.testConfigOptions('once') === false) {\n            this.valid = false;\n            return false;\n        }\n\n        this.valid = true;\n        this.active = false;\n        this.init();\n    }\n\n    init() {\n        this.test = window.matchMedia(this.query);\n\n        if (this.test.matches && this.testConfigOptions('match')) {\n            this.enterState();\n        }\n\n        this.listener = (test) => {\n            let changed = false;\n\n            if (test.matches) {\n                if (this.testConfigOptions('match')) {\n                    this.enterState();\n                    changed = true;\n                }\n            } else {\n                this.leaveState();\n                changed = true;\n            }\n\n            if (changed) {\n                stateChangeMethod();\n            }\n        };\n\n        this.test.addListener(this.listener);\n    }\n\n    // Handle entering a state\n    enterState() {\n        fireAllMethodsInArray(this.options.onFirstRun, this.eventData('firstRun'));\n        fireAllMethodsInArray(this.options.onEnter, this.eventData('enter'));\n        this.options.onFirstRun = [];\n        this.active = true;\n    }\n\n    // Handle leaving a state\n    leaveState() {\n        fireAllMethodsInArray(this.options.onLeave, this.eventData('leave'));\n        this.active = false;\n    }\n\n    // Handle the user resizing the browser\n    resizeState() {\n        if (this.testConfigOptions('resize')) {\n            fireAllMethodsInArray(this.options.onResize, this.eventData('resize'));\n        }\n    }\n\n    // When the StateManager removes a state we want to remove the event listener\n    destroy() {\n        this.test.removeListener(this.listener);\n    }\n\n    attachCallback(type, callback, runIfActive) {\n        switch (type) {\n        case 'enter':\n            this.options.onEnter.push(callback);\n            break;\n        case 'leave':\n            this.options.onLeave.push(callback);\n            break;\n        case 'resize':\n            this.options.onResize.push(callback);\n            break;\n        default:\n            break;\n        }\n\n        if (type === 'enter' && runIfActive && this.active) {\n            callback(this.eventData(type));\n        }\n    }\n\n    testConfigOptions(when) {\n        let test = true;\n\n        configOptions.forEach((configOption) => {\n            if (typeof this.options[configOption.name] !== 'undefined') {\n                if (configOption.when === when && configOption.test.bind(this)() === false) {\n                    test = false;\n                }\n            }\n        });\n\n        return test;\n    }\n\n    eventData(eventType) {\n        return {\n            eventType,\n            state: this,\n        };\n    }\n\n    static addConfigOption(configOption) {\n        configOptions.push(configOption);\n    }\n\n    static getConfigOptions() {\n        return configOptions;\n    }\n\n    static removeConfigOption(name) {\n        configOptions.forEach((item, index) => {\n            if (item.name === name) {\n                configOptions.splice(index, 1);\n            }\n        });\n    }\n\n    static setStateChangeMethod(func) {\n        if (typeof func === 'function') {\n            stateChangeMethod = func;\n        } else {\n            throw new Error('Not a function');\n        }\n    }\n}\n\n'SimpleStateManager/src/ssm.js'\n:import State from './state';\nimport {\n    debounce,\n    filterStates,\n} from './utils';\n\n// State Manager Constructor\nclass StateManager {\n    constructor() {\n        this.states = [];\n        this.resizeTimer = null;\n        this.configOptions = [];\n\n        window.addEventListener('resize', debounce(this.resizeBrowser.bind(this), 25), true);\n    }\n\n    addState(options) {\n        const newState = new State(options);\n\n        if (newState.valid) {\n            this.states.push(newState);\n        }\n\n        return newState;\n    }\n\n    addStates(statesArray) {\n        statesArray.forEach(state => this.addState(state));\n    }\n\n    getState(id) {\n        const selectedState = this.states.filter(state => state.id === id);\n\n        return selectedState[0] || false;\n    }\n\n    isActive(id) {\n        const selectedState = this.getState(id) || {};\n\n        return selectedState.active || false;\n    }\n\n    getStates(idArr) {\n        if (typeof (idArr) === 'undefined') {\n            return this.states;\n        }\n\n        return idArr.map(id => this.getState(id));\n    }\n\n    removeState(id) {\n        this.states.forEach((state, index) => {\n            if (state.id === id) {\n                state.destroy();\n                this.states.splice(index, 1);\n            }\n        });\n    }\n\n    removeStates(idArray) {\n        idArray.forEach(id => this.removeState(id));\n    }\n\n    removeAllStates() {\n        this.states.forEach(state => state.destroy());\n        this.states = [];\n    }\n\n    addConfigOption({\n        name = '', // name, this is used to apply to a state\n        test = null, // function which will perform the test\n        when = 'resize', // resize or match (match will mean that resize will never fire either), or once (which will test once, then delete state if test doesnt pass)\n    }) {\n        if (name !== '' && test !== null) {\n            State.addConfigOption({\n                name,\n                test,\n                when,\n            });\n        }\n    }\n\n    removeConfigOption(name) {\n        State.removeConfigOption(name);\n    }\n\n    getConfigOptions(name) {\n        const configOptions = State.getConfigOptions();\n\n        if (typeof name === 'string') {\n            return configOptions.filter(configOption => configOption.name === name);\n        }\n\n        return configOptions;\n    }\n\n    resizeBrowser() {\n        const activeStates = filterStates(this.states, 'active', true);\n\n        activeStates.forEach((state) => {\n            state.resizeState();\n        });\n    }\n\n    stateChange(func) {\n        State.setStateChangeMethod(func);\n    }\n}\n\nexport default new StateManager();\n\n",
        "called_code_segment": "enterState() {\n    fireAllMethodsInArray(this.options.onFirstRun, this.eventData('firstRun'));\n    fireAllMethodsInArray(this.options.onEnter, this.eventData('enter'));\n    this.options.onFirstRun = [];\n    this.active = true;\n}",
        "invoking_code_segment": "this.listener = (test) => {\n    let changed = false;\n\n    if (test.matches) {\n        if (this.testConfigOptions('match')) {\n            this.enterState();\n            changed = true;\n        }\n    } else {\n        this.leaveState();\n        changed = true;\n    }\n\n    if (changed) {\n        stateChangeMethod();\n    }\n};",
        "new_file_code_segment": "export function logStateChange(eventType, state) {\n    console.log(`State ${state.id} is now ${eventType}`);\n}",
        "feature_description": "Add logging for state changes.",
        "detailed_feature_description": "The new feature adds logging functionality to track when states are entered or left. This is achieved by creating a new file (#file 3) that exports a function to log state changes. The `enterState` method in #file 1 is modified to invoke this logging function. The `listener` in #file 2 is also updated to ensure the logging function is called when a state change occurs.",
        "modified_complete_code": {
            "#file 1": "//Modify enterState() {\n    fireAllMethodsInArray(this.options.onFirstRun, this.eventData('firstRun'));\n    fireAllMethodsInArray(this.options.onEnter, this.eventData('enter'));\n    this.options.onFirstRun = [];\n    this.active = true;\n    logStateChange('enter', this); //New\n}",
            "#file 2": "//Modify this.listener = (test) => {\n    let changed = false;\n\n    if (test.matches) {\n        if (this.testConfigOptions('match')) {\n            this.enterState();\n            changed = true;\n        }\n    } else {\n        this.leaveState();\n        changed = true;\n        logStateChange('leave', this); //New\n    }\n\n    if (changed) {\n        stateChangeMethod();\n    }\n};",
            "#file 3": "//New export function logStateChange(eventType, state) {\n    console.log(`State ${state.id} is now ${eventType}`);\n}"
        }
    },
    {
        "repo": "badginator",
        "content": "'badginator/lib/url_is_badge.js'\n:/// file: identify if a url is a badge\n\nconst request = require('superagent');\nconst mime = require('mime');\nconst svg2png = require('svg2png');\n\nconst is_badge = require('./is_badge');\n\n// cb(err, is_badge)\nmodule.exports = function(url, cb) {\n    request\n    .get(url)\n    .set('badginator-request', 'sup dog')\n    .end((err, res) => {\n        if (err) {\n            return cb(err);\n        }\n\n        if (res.status !== 200) {\n            return cb(null, false);\n        }\n\n        var type = res.headers['content-type'];\n        var ext = mime.extension(type);\n\n        // only support png and svg badges for now\n        if (ext !== 'svg' && ext !== 'png') {\n            return cb(null, false);\n        }\n\n        if (ext === 'svg') {\n            // convert to png first\n            svg2png(res.body)\n            .then((buffer) => {\n                is_badge(buffer, (err, badge) => {\n                    cb(err, badge);\n                });\n            })\n            .catch((err) => {\n                cb(err);\n            });\n\n            return;\n        }\n\n        is_badge(res.body, (err, badge) => {\n            cb(err, badge);\n        });\n    });\n};\n\n'badginator/index.js'\n:const express = require('express');\nconst async = require('async');\nconst request = require('superagent');\nconst printf = require('printf');\nconst https = require('https');\nconst marked = require('marked');\nconst cheerio = require('cheerio');\nconst redis = require('redis');\nconst crypto = require('crypto');\n\nconst url_is_badge = require('./lib/url_is_badge');\n\nvar redisCache = redis.createClient(process.env.REDIS_URL);\nredisCache.on('error', function (err) {\n    console.error('Redis error:', err);\n});\n\nvar app = express();\n\napp.set('x-powered-by', false);\n\napp.get('/', function(req, res, next) {\n    res.redirect('https://github.com/defunctzombie/badginator');\n});\n\napp.get('/:org/:repo.svg', function(req, res, next) {\n    var org = req.params.org;\n    var repo = req.params.repo;\n\n    // if badginator request, serve up dummy badge\n    if (req.headers['badginator-request'] === 'sup dog') {\n        var url = printf('https://img.shields.io/badge/badges-dummy-green.svg');\n        https.get(url, function(img_res) {\n            res.set({\n                'content-type': img_res.headers['content-type'],\n                'cache-control': 'no-cache, no-store, must-revalidate',\n            });\n            img_res.pipe(res);\n        });\n        return;\n    }\n\n    var count_fn = process.env.USE_REGEX_BADGES ? regex_count_readme_badges : count_readme_badges;\n\n    if (req.query.image_analysis) {\n        count_fn = count_readme_badges;\n    }\n\n    count_fn({\n        org: org,\n        repo: repo,\n    }, function(err, badge_count) {\n        if (err) {\n            return next(err);\n        }\n\n        var color = 'red';\n\n        if (badge_count <= 2) {\n            color = 'red';\n        }\n        else if (badge_count <= 4) {\n            color = 'orange';\n        }\n        else if (badge_count <= 6) {\n            color = 'green';\n        }\n        else {\n            color = 'brightgreen';\n        }\n\n        var etag = badge_count + color;\n        var style = req.query.style || 'flat';\n        var url = printf('https://img.shields.io/badge/badges-%d-%s.svg?style=%s', badge_count, color, style);\n        if (process.env.USE_REDIRECT_URL === '1') {\n            return res.redirect(url);\n        }\n\n        https.get(url, function(img_res) {\n            res.set({\n                'content-type': img_res.headers['content-type'],\n                'cache-control': 'no-cache, no-store, must-revalidate',\n                'etag': etag,\n            });\n            img_res.pipe(res);\n        });\n    });\n});\n\nfunction regex_count_readme_badges(opt, cb) {\n    fetch_readme(opt, function(err, readme) {\n        if (err) {\n            return cb(err);\n        }\n\n        // remove markdown sections\n        readme = readme.replace(/```[^]*?```/g, '');\n\n        // count instances of [![](.svg or .png)]\n        // followed by () which is a link\n        var regexp = /(\\[[!]\\[.*\\]\\(.*(\\.svg|\\.png).*\\)\\]\\(.*\\)|[!]\\[.*\\]\\(.*(\\.svg|\\.png).*\\))/g;\n        var count = 0;\n        while(regexp.exec(readme) !== null) {\n            count++;\n        }\n\n        cb(null, count);\n    });\n};\n\nfunction count_readme_badges(opt, cb) {\n    fetch_readme(opt, function(err, readme) {\n        if (err) {\n            return cb(err);\n        }\n\n        // process readme\n        var html = marked(readme);\n        var $ = cheerio.load(html);\n\n        var urls = $('img').map(function(idx, img) {\n            return $(img).attr('src');\n        }).get();\n\n        var count = 0;\n        async.each(urls, function(url, done) {\n            //async.reduce(urls, 0, function(count, url, done) {\n            // this is gnarly and could be a function now\n            var hash = crypto.createHash('md5').update(url).digest('hex');\n            var url_key = 'url-cache:' + hash;\n            redisCache.get(url_key, function(err, val) {\n                if (err) {\n                    console.error(err);\n                    return done();\n                }\n\n                // have cached value\n                if (val !== null) {\n                    count += (val === 'true' ? 1 : 0);\n                    // redis values are strings, yay\n                    //return done(null, count + (val === 'true' ? 1 : 0));\n                    return done();\n                }\n\n                url_is_badge(url, function(err, is_badge) {\n                    if (err) {\n                        console.error(err);\n                    }\n                    else {\n                        redisCache.setex(url_key, 60 * 15, is_badge, function(err) {\n                            if (err) {\n                                console.error(err);\n                            }\n                        });\n                    }\n\n                    count += (is_badge ? 1 : 0);\n                    done();\n                    //done(null, count + (is_badge ? 1 : 0));\n                });\n\n            });\n        }, function(err) {\n            cb(err, count);\n        });\n    });\n}\n\nfunction fetch_readme(opt, cb) {\n    var org = opt.org;\n    var repo = opt.repo;\n\n    var base_url = printf('https://raw.githubusercontent.com/%s/%s/master/', org, repo);\n    var readme_variants = ['README.md', 'readme.md', 'Readme.md', 'README.MD', 'readme.markdown'];\n    var readme_text = '';\n\n    async.some(readme_variants, function(name, cb) {\n        var url = base_url + name;\n        request.get(url).end(function(err, res) {\n            if (err) {\n                return cb(false);\n            }\n\n            if (res.status !== 200) {\n                return cb(false);\n            }\n\n            readme_text = res.text;\n            cb(true);\n        });\n    }, function(found) {\n        cb(null, readme_text);\n    });\n}\n\n\napp.listen(process.env.PORT || 3000);\n\n",
        "called_code_segment": "module.exports = function(url, cb) {\n    request\n    .get(url)\n    .set('badginator-request', 'sup dog')\n    .end((err, res) => {\n        if (err) {\n            return cb(err);\n        }\n\n        if (res.status !== 200) {\n            return cb(null, false);\n        }\n\n        var type = res.headers['content-type'];\n        var ext = mime.extension(type);\n\n        // only support png and svg badges for now\n        if (ext !== 'svg' && ext !== 'png') {\n            return cb(null, false);\n        }\n\n        if (ext === 'svg') {\n            // convert to png first\n            svg2png(res.body)\n            .then((buffer) => {\n                is_badge(buffer, (err, badge) => {\n                    cb(err, badge);\n                });\n            })\n            .catch((err) => {\n                cb(err);\n            });\n\n            return;\n        }\n\n        is_badge(res.body, (err, badge) => {\n            cb(err, badge);\n        });\n    });\n};",
        "invoking_code_segment": "var count = 0;\nasync.each(urls, function(url, done) {\n    // this is gnarly and could be a function now\n    var hash = crypto.createHash('md5').update(url).digest('hex');\n    var url_key = 'url-cache:' + hash;\n    redisCache.get(url_key, function(err, val) {\n        if (err) {\n            console.error(err);\n            return done();\n        }\n\n        // have cached value\n        if (val !== null) {\n            count += (val === 'true' ? 1 : 0);\n            // redis values are strings, yay\n            //return done(null, count + (val === 'true' ? 1 : 0));\n            return done();\n        }\n\n        url_is_badge(url, function(err, is_badge) {\n            if (err) {\n                console.error(err);\n            } else {\n                redisCache.setex(url_key, 60 * 15, is_badge, function(err) {\n                    if (err) {\n                        console.error(err);\n                    }\n                });\n            }\n\n            count += (is_badge ? 1 : 0);\n            done();\n            //done(null, count + (is_badge ? 1 : 0));\n        });\n    });\n}, function(err) {\n    cb(err, count);\n});",
        "new_file_code_segment": "module.exports = function(url, cb) {\n    request\n    .get(url)\n    .set('badginator-request', 'sup dog')\n    .end((err, res) => {\n        if (err) {\n            return cb(err);\n        }\n\n        if (res.status !== 200) {\n            return cb(null, false);\n        }\n\n        var type = res.headers['content-type'];\n        var ext = mime.extension(type);\n\n        // only support png and svg badges for now\n        if (ext !== 'svg' && ext !== 'png') {\n            return cb(null, false);\n        }\n\n        if (ext === 'svg') {\n            // convert to png first\n            svg2png(res.body)\n            .then((buffer) => {\n                is_badge(buffer, (err, badge) => {\n                    cb(err, badge);\n                });\n            })\n            .catch((err) => {\n                cb(err);\n            });\n\n            return;\n        }\n\n        is_badge(res.body, (err, badge) => {\n            cb(err, badge);\n        });\n    });\n};",
        "feature_description": "Add caching for badge identification results to reduce redundant network requests.",
        "detailed_feature_description": "The new feature introduces a caching mechanism for the badge identification results. This is achieved by modifying the `url_is_badge` function in #file 1 to check a cache before making a network request. If the result is already cached, it retrieves the result from the cache instead of making a new request. This reduces redundant network requests and speeds up the badge identification process. The caching logic is implemented in a new file (#file 3) and is integrated into both #file 1 and #file 2 to ensure compatibility.",
        "modified_complete_code": {
            "#file 1": "const request = require('superagent');\nconst mime = require('mime');\nconst svg2png = require('svg2png');\nconst redis = require('redis');\nconst crypto = require('crypto');\n\nconst is_badge = require('./is_badge');\nconst cache_badge_result = require('./cache_badge_result'); // #New\n\nconst redisCache = redis.createClient(process.env.REDIS_URL); // #New\n\n// cb(err, is_badge)\nmodule.exports = function(url, cb) {\n    const hash = crypto.createHash('md5').update(url).digest('hex'); // #New\n    const url_key = 'url-cache:' + hash; // #New\n\n    redisCache.get(url_key, function(err, val) { // #New\n        if (err) {\n            return cb(err);\n        }\n\n        // have cached value\n        if (val !== null) {\n            return cb(null, val === 'true'); // #New\n        }\n\n        request\n        .get(url)\n        .set('badginator-request', 'sup dog')\n        .end((err, res) => {\n            if (err) {\n                return cb(err);\n            }\n\n            if (res.status !== 200) {\n                return cb(null, false);\n            }\n\n            var type = res.headers['content-type'];\n            var ext = mime.extension(type);\n\n            // only support png and svg badges for now\n            if (ext !== 'svg' && ext !== 'png') {\n                return cb(null, false);\n            }\n\n            if (ext === 'svg') {\n                // convert to png first\n                svg2png(res.body)\n                .then((buffer) => {\n                    is_badge(buffer, (err, badge) => {\n                        cache_badge_result(redisCache, url_key, badge, cb); // #Modify\n                    });\n                })\n                .catch((err) => {\n                    cb(err);\n                });\n\n                return;\n            }\n\n            is_badge(res.body, (err, badge) => {\n                cache_badge_result(redisCache, url_key, badge, cb); // #Modify\n            });\n        });\n    });\n};",
            "#file 2": "var count = 0;\nasync.each(urls, function(url, done) {\n    // this is gnarly and could be a function now\n    var hash = crypto.createHash('md5').update(url).digest('hex');\n    var url_key = 'url-cache:' + hash;\n    redisCache.get(url_key, function(err, val) {\n        if (err) {\n            console.error(err);\n            return done();\n        }\n\n        // have cached value\n        if (val !== null) {\n            count += (val === 'true' ? 1 : 0);\n            // redis values are strings, yay\n            //return done(null, count + (val === 'true' ? 1 : 0));\n            return done();\n        }\n\n        url_is_badge(url, function(err, is_badge) {\n            if (err) {\n                console.error(err);\n            } else {\n                redisCache.setex(url_key, 60 * 15, is_badge, function(err) {\n                    if (err) {\n                        console.error(err);\n                    }\n                });\n            }\n\n            count += (is_badge ? 1 : 0);\n            done();\n            //done(null, count + (is_badge ? 1 : 0));\n        });\n    });\n}, function(err) {\n    cb(err, count);\n});",
            "#file 3": "module.exports = function(redisCache, url_key, badge, cb) {\n    redisCache.setex(url_key, 60 * 15, badge, function(err) {\n        if (err) {\n            console.error(err);\n        }\n        cb(null, badge);\n    });\n};"
        }
    },
    {
        "repo": "castnow",
        "content": "'castnow/plugins/xspf.js'\n:var path = require('path');\nvar debug = require('debug')('castnow:localfile');\nvar fs = require('fs');\nvar xspfr = require('xspfr');\n\nvar isFile = function(item) {\n  return fs.existsSync(item.path) && fs.statSync(item.path).isFile();\n}\nvar isXspf = function(item) {\n  return path.extname(item.path) === '.xspf';\n};\n\nvar contains = function(arr, cb) {\n  for (var i=0, len=arr.length; i<len; i++) {\n    if (cb(arr[i], i)) return true;\n  }\n  return false;\n};\n\nvar flatten1 = function(arrayOfArrays) {\n  return [].concat.apply([], arrayOfArrays);\n}\n\nvar localfile = function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (!contains(ctx.options.playlist, isXspf)) return next();\n\n  var list = ctx.options.playlist.slice(0);\n\n  Promise.all(list.map(function(item, idx) {\n    if (!isXspf(item)) {\n      return Promise.resolve([item]);\n    }\n\n    if (!isFile(item)) {\n      // TODO\n      throw 'Unsupported external XSPF links';\n    }\n\n    return new Promise(function(resolve, reject) {\n      xspfr(fs.readFileSync(item.path).toString(), function(err, result) {\n        if(err) reject(err)\n\n        resolve(result.map(function(item) {\n          return {\n            path: item.location,\n            media: {\n              metadata: {\n                title: item.title\n              }\n            }\n          }\n        }))\n      })\n    })\n\n  })).then(function(data) {\n    ctx.options.playlist = flatten1(data);\n    next()\n  })\n};\n\nmodule.exports = localfile;\n\n'castnow/index.js'\n:#!/usr/bin/env node\n\nvar fs = require('fs');\nvar path = require('path');\nvar player = require('chromecast-player')();\nvar chalk = require('chalk');\nvar keypress = require('keypress');\nvar ui = require('playerui')();\nvar circulate = require('array-loop');\nvar xtend = require('xtend');\nvar shuffle = require('array-shuffle');\nvar unformatTime = require('./utils/unformat-time');\nvar debug = require('debug')('castnow');\nvar debouncedSeeker = require('debounced-seeker');\nvar mime = require('mime');\nvar noop = function() {};\n\n// plugins\nvar directories = require('./plugins/directories');\nvar xspf = require('./plugins/xspf');\nvar localfile = require('./plugins/localfile');\nvar torrent = require('./plugins/torrent');\nvar transcode = require('./plugins/transcode');\nvar subtitles = require('./plugins/subtitles');\nvar stdin = require('./plugins/stdin');\n\nvar home = process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];\nvar rcOpts = [];\ntry {\n  rcOpts = fs.readFileSync(path.join(home, '.castnowrc')).toString().trim().split(/\\s+/);\n} catch(err) {}\n\nvar optConfig = {\n  boolean: \"tomp4 quiet bypass-srt-encoding loop shuffle recursive exit help\".split(/\\s+/),\n  string: \"device address subtitles subtitle-scale subtitle-color subtitle-port myip type seek volume-step localfile-port transcode-port torrent-port stdin-port command\".split(/\\s+/)\n}\nvar args = rcOpts.concat(process.argv.slice(2));\nvar opts = require('minimist')(args, optConfig);\n\n// Eliminate duplicate option values, prefering the final option value.\nfor (var opt in opts) {\n  if (opts.hasOwnProperty(opt) && opt[0].toLowerCase() != opt[0].toUpperCase() && Array.isArray(opts[opt]))\n    opts[opt] = opts[opt].pop()\n}\n\nif (opts.help) {\n  return console.log([\n    '',\n    'Usage: castnow [<media>, <media>, ...] [OPTIONS]',\n    '',\n    'Option                   Meaning',\n    '--tomp4                  Convert file to mp4 during playback',\n    '--device <name>          The name of the Chromecast device that should be used',\n    '--address <ip>           The IP address or hostname of your Chromecast device',\n    '--subtitles <path/url>   Path or URL to an SRT or VTT file',\n    '--subtitle-scale <scale> Subtitle font scale',\n    '--subtitle-color <color> Subtitle font RGBA color',\n    '--subtitle-port <port>   Specify the port to be used for serving subtitles',\n    '--myip <ip>              Your local IP address',\n    '--quiet                  No output',\n    '--peerflix-* <value>     Pass options to peerflix',\n    '--ffmpeg-* <value>       Pass options to ffmpeg',\n    '--type <type>            Explicitly set the mime-type (e.g. \"video/mp4\")',\n    '--bypass-srt-encoding    Disable automatic UTF-8 encoding of SRT subtitles',\n    '--seek <hh:mm:ss>        Seek to the specified time on start using the format hh:mm:ss or mm:ss',\n    '--loop                   Loop over playlist, or file, forever',\n    '--shuffle                Play in random order',\n    '--recursive              List all files in directories recursively',\n    '--volume-step <step>     Step at which the volume changes. Helpful for speakers that are softer or louder than normal. Value ranges from 0 to 1 (e.g. \".05\")',\n    '--localfile-port <port>  Specify the port to be used for serving a local file',\n    '--transcode-port <port>  Specify the port to be used for serving a transcoded file',\n    '--torrent-port <port>    Specify the port to be used for serving a torrented file',\n    '--stdin-port <port>      Specify the port to be used for serving a file read from stdin',\n    '--command <key1>,<key2>  Execute key command(s) (where each <key> is one of the keys listed below)',\n    '--exit                   Exit when playback begins or --command completes',\n\n    '--help                   This help screen',\n    '',\n    'Player controls',\n    '',\n    'Key                      Action',\n    'space                    Toggle between play and pause',\n    'm                        Toggle mute',\n    't                        Toggle subtitles',\n    'up                       Volume Up',\n    'down                     Volume Down',\n    'left                     Seek backward',\n    'right                    Seek forward',\n    'p                        Previous in playlist',\n    'n                        Next in playlist',\n    's                        Stop playback',\n    'quit                     Quit',\n    ''\n  ].join('\\n'));\n}\n\nif (opts._.length) {\n  opts.playlist = opts._.map(function(item) {\n    return {\n      path: item\n    };\n  });\n}\n\ndelete opts._;\n\nif (opts.quiet || opts.exit || process.env.DEBUG) {\n  ui.hide();\n}\n\nvar volumeStep = 0.05;\nvar stepOption = opts['volume-step'];\n\nif (stepOption) {\n  var parsed = parseFloat(stepOption);\n\n  if (isNaN(parsed)) {\n    fatalError('invalid --volume-step');\n  }\n\n  if (parsed < 0 || parsed > 1) {\n    fatalError('--volume-step must be between 0 and 1');\n  }\n\n  volumeStep = parsed;\n}\n\ndebug('volume step: %s', volumeStep);\n\nui.showLabels('state');\n\nfunction fatalError(err) {\n  ui.hide(err);\n  debug(err);\n  console.log(chalk.red(err));\n  process.exit();\n}\n\nvar last = function(fn, l) {\n  return function() {\n    var args = Array.prototype.slice.call(arguments);\n    args.push(l);\n    l = fn.apply(null, args);\n    return l;\n  };\n};\n\nvar ctrl = function(err, p, ctx) {\n  if (err) {\n    ui.hide();\n    debug('player error: %o', err);\n    console.log(chalk.red(err));\n    process.exit();\n  }\n\n  var playlist = ctx.options.playlist;\n  var playlist_history = ctx.options.playlist_history;\n  var volume;\n  var is_keyboard_interactive = process.stdin.isTTY || false;\n\n  if (is_keyboard_interactive) {\n    keypress(process.stdin);\n    process.stdin.setRawMode(true);\n    process.stdin.resume();\n  }\n\n  ctx.once('closed', function() {\n    ui.hide();\n    console.log(chalk.red('lost connection'));\n    process.exit();\n  });\n\n  // get initial volume\n  p.getVolume(function(err, status) {\n    volume = status;\n  });\n\n  if (!ctx.options.disableTimeline) {\n    p.on('position', function(pos) {\n      ui.setProgress(pos.percent);\n      ui.render();\n    });\n  }\n\n  var seekImmediate = function(offset) {\n    if (ctx.options.disableSeek || offset === 0) return;\n    var seconds = Math.max(0, (p.getPosition() / 1000) + offset);\n    debug('seeking to %s', seconds);\n    p.seek(seconds);\n  };\n\n  if (opts.exit) {\n    // cannot debounce or seek never executes before we exit\n    var seek = seekImmediate;\n  } else {\n    var seek = debouncedSeeker(function(offset) {\n      // handles seeking offset = seconds\n      seekImmediate(offset);\n    }, 500);\n  }\n\n  var updateTitle = function() {\n    p.getStatus(function(err, status) {\n      if (!status || !status.media ||\n          !status.media.metadata ||\n          !status.media.metadata.title) return;\n\n      var metadata = status.media.metadata;\n      var title;\n      if (metadata.artist) {\n        title = metadata.artist + ' - ' + metadata.title;\n      } else {\n        title = metadata.title;\n      }\n      ui.setLabel('source', 'Source', title);\n      ui.showLabels('state', 'source');\n      ui.render();\n    });\n  };\n\n  var initialSeek = function() {\n    var seconds = unformatTime(ctx.options.seek);\n    debug('seeking to %s', seconds);\n    p.seek(seconds);\n  };\n\n  p.on('playing', updateTitle);\n\n  if (!ctx.options.disableSeek && ctx.options.seek) {\n    p.once('playing', initialSeek);\n  }\n\n  updateTitle();\n\n  var nextInPlaylist = function() {\n    if (ctx.mode !== 'launch') return;\n    if (!playlist.length) return process.exit();\n    p.stop(function() {\n      ui.showLabels('state');\n      debug('loading next in playlist: %o', playlist[0]);\n      p.load(playlist[0], noop);\n      var file = playlist.shift();\n      if (ctx.options.loop)\n        playlist.push(file);\n      else\n        playlist_history.push(file);\n    });\n  };\n\n  var previousInPlaylist = function() {\n    if (ctx.options.loop) {\n      playlist.unshift(playlist.pop());\n      playlist.unshift(playlist.pop());\n      nextInPlaylist();\n    }\n    else if (0 < playlist_history.length) {\n      playlist.unshift(playlist_history.pop());\n      if (0 < playlist_history.length) playlist.unshift(playlist_history.pop());\n      nextInPlaylist();\n    }\n  };\n\n  p.on('status', last(function(status, memo) {\n    if (opts.exit && status.playerState == 'PLAYING') process.exit();\n    if (status.playerState !== 'IDLE') return;\n    if (status.idleReason !== 'FINISHED') return;\n    if (memo && memo.playerState === 'IDLE') return;\n    nextInPlaylist();\n    return status;\n  }));\n\n  var keyMappings = {\n\n    // toggle between play / pause\n    space: function() {\n      if (p.currentSession.playerState === 'PLAYING') {\n        p.pause();\n      } else if (p.currentSession.playerState === 'PAUSED') {\n        p.play();\n      }\n    },\n\n    // toggle between mute / unmute\n    m: function() {\n      if(!volume) {\n        return;\n      } else if (volume.muted) {\n        p.unmute(function(err, status) {\n          if (err) return;\n          volume = status;\n        });\n      } else {\n        p.mute(function(err, status) {\n          if (err) return;\n          volume = status;\n        });\n      }\n    },\n\n    t: function() {\n      if (!p.currentSession.media.tracks) { return }\n      var sessionRequestBody = {\n        type: 'EDIT_TRACKS_INFO'\n      }\n      sessionRequestBody.activeTrackIds = p.currentSession.activeTrackIds ? [] : [1];\n      p.sessionRequest(sessionRequestBody);\n    },\n\n    // volume up\n    up: function() {\n      if (!volume || volume.level >= 1) {\n        return;\n      }\n\n      var newVolume = Math.min(volume.level + volumeStep, 1);\n\n      p.setVolume(newVolume, function(err, status) {\n        if (err) {\n          return;\n        }\n\n        debug(\"volume up: %s\", status.level);\n\n        volume = status;\n      });\n    },\n\n    // volume down\n    down: function() {\n      if (!volume || volume.level <= 0) {\n        return;\n      }\n\n      var newVolume = Math.max(volume.level - volumeStep, 0);\n\n      p.setVolume(newVolume, function(err, status) {\n        if (err) {\n          return;\n        }\n\n        debug(\"volume down: %s\", status.level);\n\n        volume = status;\n      });\n    },\n\n    // next item in playlist\n    n: function() {\n      nextInPlaylist();\n    },\n\n    // previous item in playlist\n    p: function() {\n      previousInPlaylist();\n    },\n\n    // stop playback\n    s: function() {\n      p.stop();\n    },\n\n    // quit\n    q: function() {\n      process.exit();\n    },\n\n    // Rewind, one \"seekCount\" per press\n    left: function() {\n      seek(-30);\n    },\n\n    // Forward, one \"seekCount\" per press\n    right: function() {\n      seek(30);\n    }\n  };\n\n  if (is_keyboard_interactive) {\n    process.stdin.on('keypress', function(ch, key) {\n      if (key && key.name && keyMappings[key.name]) {\n        debug('key pressed: %s', key.name);\n        keyMappings[key.name]();\n      }\n      if (key && key.ctrl && key.name == 'c') {\n        process.exit();\n      }\n    });\n  }\n\n  if (opts.command) {\n    var commands = opts.command.split(\",\");\n    commands.forEach(function(command) {\n      if (!keyMappings[command]) {\n        fatalError('invalid --command: ' + command);\n      }\n    });\n\n    var index = 0;\n    function run_commands() {\n      if (index < commands.length) {\n        var command = commands[index++];\n        keyMappings[command]();\n        p.getStatus(run_commands);\n      } else {\n        if (opts.exit) {\n          process.exit();\n        }\n      }\n    }\n\n    p.getStatus(run_commands);\n  }\n};\n\nvar capitalize = function(str) {\n  return str.substr(0, 1).toUpperCase() + str.substr(1);\n};\n\nvar logState = (function() {\n  var inter;\n  var dots = circulate(['.', '..', '...', '....']);\n  return function(status) {\n    if (inter) clearInterval(inter);\n    debug('player status: %s', status);\n    inter = setInterval(function() {\n      ui.setLabel('state', 'State', capitalize(status) + dots());\n      ui.render();\n    }, 300);\n  };\n})();\n\nplayer.use(function(ctx, next) {\n  ctx.on('status', logState);\n  next();\n});\n\nplayer.use(stdin);\nplayer.use(directories);\nplayer.use(torrent);\nplayer.use(xspf);\nplayer.use(localfile);\nplayer.use(transcode);\nplayer.use(subtitles);\n\nplayer.use(function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (ctx.options.type)\n    // If a --type has been provided, then respect it.\n    ctx.options.playlist.map(function(item) {item.type = ctx.options.type;});\n  else {\n    ctx.options.playlist.map(function(item){\n      if (!item.type) {\n        // These will be URLs (the MIME type for files is filled in by the localfile plugin).\n        var mimeType = mime.lookup(item.path);\n        var type = mimeType.split('/')[0];\n        if (type === 'audio' || type === 'video') item.type = mimeType;\n      }\n    });\n  }\n  next()\n});\n\nplayer.use(function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (ctx.options.shuffle)\n    ctx.options.playlist = shuffle(ctx.options.playlist);\n  ctx.options = xtend(ctx.options, ctx.options.playlist[0]);\n  var file = ctx.options.playlist.shift();\n  if (ctx.options.loop)\n    ctx.options.playlist.push(file);\n  else\n    ctx.options.playlist_history = [file];\n  next();\n});\n\nif (!opts.playlist) {\n  debug('attaching...');\n  player.attach(opts, ctrl);\n} else {\n  debug('launching...');\n  player.launch(opts, ctrl);\n}\n\nprocess.on('SIGINT', function() {\n  process.exit();\n});\n\nprocess.on('exit', function() {\n  ui.hide();\n});\n\nmodule.exports = player;\n\n",
        "called_code_segment": "var localfile = function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (!contains(ctx.options.playlist, isXspf)) return next();\n\n  var list = ctx.options.playlist.slice(0);\n\n  Promise.all(list.map(function(item, idx) {\n    if (!isXspf(item)) {\n      return Promise.resolve([item]);\n    }\n\n    if (!isFile(item)) {\n      // TODO\n      throw 'Unsupported external XSPF links';\n    }\n\n    return new Promise(function(resolve, reject) {\n      xspfr(fs.readFileSync(item.path).toString(), function(err, result) {\n        if(err) reject(err)\n\n        resolve(result.map(function(item) {\n          return {\n            path: item.location,\n            media: {\n              metadata: {\n                title: item.title\n              }\n            }\n          }\n        }))\n      })\n    })\n\n  })).then(function(data) {\n    ctx.options.playlist = flatten1(data);\n    next()\n  })\n};",
        "invoking_code_segment": "player.use(localfile);",
        "new_file_code_segment": "var processXspf = function(item) {\n  return new Promise(function(resolve, reject) {\n    xspfr(fs.readFileSync(item.path).toString(), function(err, result) {\n      if(err) reject(err)\n\n      resolve(result.map(function(item) {\n        return {\n          path: item.location,\n          media: {\n            metadata: {\n              title: item.title\n            }\n          }\n        }\n      }))\n    })\n  })\n};",
        "feature_description": "Add a feature to process XSPF files asynchronously and handle errors more gracefully.",
        "detailed_feature_description": "The new feature involves creating a new file (#file 3) that contains a function to process XSPF files asynchronously. This function will be invoked from #file 1 where the XSPF processing logic currently resides. The new function will handle errors more gracefully and return a promise that resolves to the processed playlist items. This approach ensures that the XSPF processing is modular and can be easily extended or modified in the future.",
        "modified_complete_code": {
            "#file 1": "var localfile = function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (!contains(ctx.options.playlist, isXspf)) return next();\n\n  var list = ctx.options.playlist.slice(0);\n\n  Promise.all(list.map(function(item, idx) {\n    if (!isXspf(item)) {\n      return Promise.resolve([item]);\n    }\n\n    if (!isFile(item)) {\n      // TODO\n      throw 'Unsupported external XSPF links';\n    }\n\n    return processXspf(item); #Modify\n\n  })).then(function(data) {\n    ctx.options.playlist = flatten1(data);\n    next()\n  })\n};",
            "#file 2": "player.use(localfile);",
            "#file 3": "var processXspf = function(item) {\n  return new Promise(function(resolve, reject) {\n    xspfr(fs.readFileSync(item.path).toString(), function(err, result) {\n      if(err) reject(err)\n\n      resolve(result.map(function(item) {\n        return {\n          path: item.location,\n          media: {\n            metadata: {\n              title: item.title\n            }\n          }\n        }\n      }))\n    })\n  })\n}; #New"
        }
    },
    {
        "repo": "cls-rtracer",
        "content": "'cls-rtracer/index.js'\n:'use strict'\n\nconst {\n  expressMiddleware,\n  fastifyPlugin,\n  fastifyMiddleware,\n  koaMiddleware,\n  koaV1Middleware,\n  hapiPlugin,\n  runWithId,\n  id\n} = require('./src/rtracer')\n\nmodule.exports = {\n  expressMiddleware,\n  fastifyPlugin,\n  fastifyMiddleware,\n  koaMiddleware,\n  koaV1Middleware,\n  hapiPlugin,\n  runWithId,\n  id\n}\n\n'cls-rtracer/samples/koa.winston.js'\n:'use strict'\n\nconst rTracer = require('../index')\n\n// first - configure winston logger\n\nconst { createLogger, format, transports } = require('winston')\nconst { combine, timestamp, printf } = format\n\n// a custom format that outputs request id\nconst rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  return rid\n    ? `${info.timestamp} [request-id:${rid}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})\n\nconst logger = createLogger({\n  format: combine(\n    timestamp(),\n    rTracerFormat\n  ),\n  transports: [new transports.Console()]\n})\n\n// next - configure and start Koa app\n\nconst Koa = require('koa')\nconst app = new Koa()\n\napp.use(rTracer.koaMiddleware())\n\napp.use(async (ctx) => {\n  logger.info('Starting request handling')\n  const result = await fakeDbAccess()\n  ctx.body = result\n})\n\nasync function fakeDbAccess () {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      logger.info('Logs from fakeDbAccess')\n      resolve({ message: 'Hello from cls-rtracer Koa example' })\n    }, 0)\n  })\n}\n\napp.listen(3000, (err) => {\n  if (err) {\n    logger.err('The app could not start')\n  }\n  logger.info('The app is listening on 3000')\n})\n\n",
        "called_code_segment": "const rTracer = require('../index')\n\n// first - configure winston logger\n\nconst { createLogger, format, transports } = require('winston')\nconst { combine, timestamp, printf } = format\n\n// a custom format that outputs request id\nconst rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  return rid\n    ? `${info.timestamp} [request-id:${rid}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})\n\nconst logger = createLogger({\n  format: combine(\n    timestamp(),\n    rTracerFormat\n  ),\n  transports: [new transports.Console()]\n})",
        "invoking_code_segment": "app.use(rTracer.koaMiddleware())\n\napp.use(async (ctx) => {\n  logger.info('Starting request handling')\n  const result = await fakeDbAccess()\n  ctx.body = result\n})",
        "new_file_code_segment": "const rTracer = require('../index')\n\nfunction logWithRequestId(message) {\n  const rid = rTracer.id()\n  console.log(rid ? `[request-id:${rid}]: ${message}` : message)\n}\n\nmodule.exports = {\n  logWithRequestId\n}",
        "feature_description": "Add a new logging function that includes the request ID in the log message.",
        "detailed_feature_description": "A new file (#file 3) is created to encapsulate the logging functionality with request ID. This file exports a function `logWithRequestId` that logs messages with the request ID if available. The function is then integrated into both #file 1 and #file 2 to ensure consistent logging across the application.",
        "modified_complete_code": {
            "#file 1": "const rTracer = require('../index')\nconst { logWithRequestId } = require('./logger')\n\n// first - configure winston logger\n\nconst { createLogger, format, transports } = require('winston')\nconst { combine, timestamp, printf } = format\n\n// a custom format that outputs request id\nconst rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  return rid\n    ? `${info.timestamp} [request-id:${rid}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})\n\nconst logger = createLogger({\n  format: combine(\n    timestamp(),\n    rTracerFormat\n  ),\n  transports: [new transports.Console()]\n})\n\n// New: Use the new logging function\nlogger.info = logWithRequestId",
            "#file 2": "const Koa = require('koa')\nconst app = new Koa()\nconst { logWithRequestId } = require('./logger')\n\napp.use(rTracer.koaMiddleware())\n\napp.use(async (ctx) => {\n  logWithRequestId('Starting request handling')  // Modify: Use the new logging function\n  const result = await fakeDbAccess()\n  ctx.body = result\n})\n\nasync function fakeDbAccess () {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      logWithRequestId('Logs from fakeDbAccess')  // Modify: Use the new logging function\n      resolve({ message: 'Hello from cls-rtracer Koa example' })\n    }, 0)\n  })\n}\n\napp.listen(3000, (err) => {\n  if (err) {\n    logWithRequestId('The app could not start')  // Modify: Use the new logging function\n  }\n  logWithRequestId('The app is listening on 3000')  // Modify: Use the new logging function\n})",
            "#file 3": "const rTracer = require('../index')\n\nfunction logWithRequestId(message) {\n  const rid = rTracer.id()\n  console.log(rid ? `[request-id:${rid}]: ${message}` : message)\n}\n\nmodule.exports = {\n  logWithRequestId\n}"
        }
    },
    {
        "repo": "comments-api",
        "content": "'comments-api/__test__/fixtures/db.js'\n:import mongodb from 'mongodb'\nconst MongoClient = mongodb.MongoClient\n\nlet connection, db\n\nexport default async function makeDb () {\n  connection =\n    connection ||\n    (await MongoClient.connect(\n      global.__MONGO_URI__,\n      { useNewUrlParser: true }\n    ))\n  db = db || (await connection.db(global.__MONGO_DB_NAME__))\n  return db\n}\n\nexport async function closeDb () {\n  await connection.close()\n  await db.close()\n}\n\nexport async function clearDb () {\n  await db.collection('comments').deleteMany({})\n  return true\n}\n\nexport { connection, db }\n\n'comments-api/src/use-cases/list-comments.spec.js'\n:import makeGetComments from './list-comments'\nimport makeCommentsDb from '../data-access/comments-db'\nimport makeFakeComment from '../../__test__/fixtures/comment'\nimport makeDb from '../../__test__/fixtures/db'\n\ndescribe('get comments', () => {\n  let commentsDb, getComments\n  beforeAll(() => {\n    commentsDb = makeCommentsDb({ makeDb })\n    getComments = makeGetComments({ commentsDb })\n  })\n\n  it('requires a post id', () => {\n    expect(getComments()).rejects.toThrow('You must supply a post id.')\n  })\n  it('gets all comments', async () => {\n    const firstComment = makeFakeComment({ replyToId: null })\n    const secondComment = makeFakeComment({\n      replyToId: null,\n      postId: firstComment.postId\n    })\n    const thirdComment = makeFakeComment({\n      replyToId: null,\n      postId: firstComment.postId\n    })\n    const replyToFirstComment = makeFakeComment({\n      replyToId: firstComment.id,\n      postId: firstComment.postId\n    })\n    const anotherReplyToFirstComment = makeFakeComment({\n      replyToId: firstComment.id,\n      postId: firstComment.postId\n    })\n    const replyToSecondComment = makeFakeComment({\n      replyToId: secondComment.id,\n      postId: firstComment.postId\n    })\n    const comments = [\n      firstComment,\n      secondComment,\n      thirdComment,\n      replyToFirstComment,\n      anotherReplyToFirstComment,\n      replyToSecondComment\n    ]\n    await Promise.all(comments.map(commentsDb.insert))\n    const actualGraph = await getComments({ postId: firstComment.postId })\n\n    const firstCommentFromDb = actualGraph.filter(c => c.id === firstComment.id)\n    expect(firstCommentFromDb[0].replies.length).toBe(2)\n    expect(firstCommentFromDb[0].replies).toContainEqual({\n      ...replyToFirstComment,\n      replies: []\n    })\n    expect(firstCommentFromDb[0].replies).toContainEqual({\n      ...anotherReplyToFirstComment,\n      replies: []\n    })\n\n    const secondCommentFromDb = actualGraph.filter(\n      c => c.id === secondComment.id\n    )\n    expect(secondCommentFromDb[0].replies.length).toBe(1)\n    expect(secondCommentFromDb[0].replies).toContainEqual({\n      ...replyToSecondComment,\n      replies: []\n    })\n\n    const thirdCommentFromDb = actualGraph.filter(c => c.id === thirdComment.id)\n    expect(thirdCommentFromDb[0].replies.length).toBe(0)\n    return Promise.all(comments.map(commentsDb.remove))\n  })\n})\n\n",
        "called_code_segment": "export default async function makeDb () { connection = connection || (await MongoClient.connect( global.__MONGO_URI__, { useNewUrlParser: true } )); db = db || (await connection.db(global.__MONGO_DB_NAME__)); return db; }",
        "invoking_code_segment": "let commentsDb, getComments; beforeAll(() => { commentsDb = makeCommentsDb({ makeDb }); getComments = makeGetComments({ commentsDb }); });",
        "new_file_code_segment": "export function logDbConnection(db) { console.log(`Connected to database: ${db.databaseName}`); }",
        "feature_description": "Add logging for database connection.",
        "detailed_feature_description": "The new feature introduces logging to indicate when a database connection is established. This is implemented by creating a new function `logDbConnection` in a new file (#file 3). The `makeDb` function in #file 1 is updated to call this new function after establishing the database connection. The `beforeAll` block in #file 2 remains unchanged as it continues to use the `makeDb` function, which now includes the logging feature.",
        "modified_complete_code": {
            "#file 1": "//Modify export default async function makeDb () { connection = connection || (await MongoClient.connect( global.__MONGO_URI__, { useNewUrlParser: true } )); db = db || (await connection.db(global.__MONGO_DB_NAME__)); logDbConnection(db); //New return db; }",
            "#file 2": "let commentsDb, getComments; beforeAll(() => { commentsDb = makeCommentsDb({ makeDb }); getComments = makeGetComments({ commentsDb }); });",
            "#file 3": "//New export function logDbConnection(db) { console.log(`Connected to database: ${db.databaseName}`); }"
        }
    },
    {
        "repo": "community-edition",
        "content": "'community-edition/scripts/gatlight.js'\n:/**\n * File ops. Common. No jsPlumb specific stuff.\n */\nconst fs = require('fs');\nconst path = require('path');\n\nconst ANYTHING_PATTERN = \"**/*\";\n\nfunction PatternFilter(pattern, isDirectory) {\n\n    return (candidate) => {\n        //console.log(pattern, candidate)\n        return true;\n    }\n}\n\nfunction ExtensionFilter(extension) {\n    return (candidate) => candidate.endsWith(\".\" + extension)\n}\n\nfunction isDirectory(path) {\n    return fs.lstatSync(path).isDirectory()\n}\n\nfunction createFilter(options) {\n    options = options || {};\n    return options.filter || (options.extension ? new ExtensionFilter(options.extension) : new PatternFilter(options.pattern || ANYTHING_PATTERN));\n}\n\n/**\n * clean files from a directory, by default recursing into (and removing) subdirectories.\n * @param directory\n * @param options\n */\nfunction clean (directory, options) {\n\n    if (fs.existsSync(directory)) {\n\n        options = options || {};\n        //let filter = options.filter || new PatternFilter(options.pattern || ANYTHING_PATTERN);\n        let filter = createFilter(options);\n        let recurse = options.recurse !== false;\n\n        let _one = (dirPath, alsoRemoveDirectory) => {\n\n            fs.readdirSync(dirPath).forEach(file => {\n                let p = path.join(dirPath, file);\n\n                if (isDirectory(p)) {\n                    if (recurse && filter(file, true)) {\n                        _one(p, true);\n                    }\n                } else {\n                    if (filter(file, false)) {\n                        fs.unlinkSync(p);\n                    }\n                }\n            });\n\n            if (alsoRemoveDirectory) {\n                fs.rmdirSync(dirPath)\n            }\n        };\n\n        _one(directory);\n\n        if (options.andRemove) {\n            fs.rmdirSync(directory);\n        }\n    }\n\n}\n\nfunction rmdir(directory) {\n    clean(directory, {andRemove:true});\n}\n\nfunction exists(file) {\n    return fs.existsSync(file);\n}\n\nfunction copyDirectory (input, output, options) {\n\n    options = options || {};\n    let recurse = options.recurse !== false;\n    let includeHidden = options.hidden === true;\n\n    if (fs.existsSync(output)) {\n        clean(output, { andRemove:true });\n    }\n\n    let filter = createFilter(options);\n\n    let _one = (inputDir, outputDir) => {\n\n        fs.mkdirSync(outputDir);\n\n        fs.readdirSync(inputDir).forEach(file => {\n\n            if (filter(file)) {\n\n                let inputPath = path.join(inputDir, file);\n                if (isDirectory(inputPath)) {\n                    if (recurse) {\n                        _one(inputPath, path.join(outputDir, file));\n                    }\n                } else {\n                    if (includeHidden === true || file.indexOf(\".\") !== 0) {\n                        let outputPath = path.join(outputDir, file);\n                        console.log(\"gatlight: copying : \" + inputPath + \" to \" + outputPath);\n                        try {\n                            fs.copyFileSync(inputPath, outputPath);\n                        } catch (e) {\n                            console.log(e)\n                        }\n                    } else {\n                        console.log(\"gatlight: excluding \" + inputPath + \" due to a dot\")\n                    }\n                }\n            } else {\n                console.log(\"Filtered \" + file + \" from copy\");\n            }\n\n        });\n    };\n\n    _one(input, output);\n\n\n}\n\nfunction copy (source, target, options) {\n\n    options = options || {};\n    let filter = createFilter(options);\n\n    // for now this is just a straight single file copy\n    console.log(\"gatlight: copying : \" + source + \" to \" + target);\n    fs.copyFileSync(source, target);\n}\n\nfunction mkdir(target, silently) {\n\n    if (Array.isArray(target)) {\n        target = target.join(\"/\");\n    }\n\n    try {\n        fs.mkdirSync(target);\n    }\n    catch (e) {\n        if (!silently) {\n            console.log(\"Could not make directory `\" + target + \"` - perhaps it exists already. Not failing.\")\n        }\n    }\n}\n\nfunction mkdirs(target) {\n    const components = target.split(\"/\");\n    const stub = components.slice(0,1);\n    mkdir(stub, true);\n    for (let i = 1; i < components.length; i++) {\n        stub.push(components[i]);\n        mkdir(stub.join(\"/\"), true);\n    }\n}\n\n/**\n * Make a directory and then clean it - because if it existed already it could have stuff in it.\n * @param target\n */\nfunction mkdirClean(target) {\n    mkdir(target);\n    clean(target);\n\n}\n\nfunction ls(directory, options) {\n\n    options = options || {};\n    let filter = createFilter(options);\n\n    return fs.readdirSync(directory).filter(filter);\n}\n\nfunction lsAll(directories, options) {\n\n    options = options || {};\n    let filter = createFilter(options);\n    let out = [];\n    for (let i = 0; i < directories.length; i++) {\n        out.push.apply(out, fs.readdirSync(directories[i]).filter(filter).map(f => [f,directories[i]]));\n    }\n\n    return out;\n\n}\n\nfunction read(fileName, options) {\n    return fs.readFileSync(fileName, options);\n}\n\nfunction readString(fileName, encoding) {\n    return read(fileName, encoding || \"UTF-8\");\n}\n\nfunction write(fileName, content) {\n    fs.writeFileSync(fileName, content);\n}\n\nfunction remove(fileName, failOnError) {\n    try {\n        fs.unlinkSync(fileName);\n    }\n    catch (e) {\n        if (failOnError) {\n            throw e;\n        }\n    }\n}\n\nfunction markup(s) {\n\n    return s.replace(/\\!\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, \"<img src=\\\"$2\\\" alt=\\\"$1\\\">\")\n        .replace(/\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, \"<a href=\\\"$2\\\">$1</a>\")\n        .replace(/^######[\\s]*(.*)[\\n]*/mg, \"<h6>$1</h6>\\n\" )\n        .replace(/^#####[\\s]*(.*)[\\n]*/mg, \"<h5>$1</h5>\\n\" )\n        .replace(/^####[\\s]*(.*)[\\n]*/mg, \"<h4>$1</h4>\\n\" )\n        .replace(/^###[\\s]*(.*)[\\n]*/mg, \"<h3>$1</h3>\\n\" )\n        .replace(/^##[\\s]*(.*)[\\n]*/mg, \"<h2>$1</h2>\\n\" )\n        .replace(/^#[\\s]*(.*)[\\n]*/mg, \"<h1>$1</h1>\\n\" )\n        .replace(/```\\n([^```]*)```/mg, \"<pre>\\n$1</pre>\\n\")\n        .replace(/`([^`]*)`/mg, \"<strong>$1</strong>\")\n        .replace(/(^|\\s)_([^_]*)_(?=\\s|$)/g, \"$1<em>$2</em>\" )\n        .replace(/(^|\\s)\\*([^\\*]*)\\*(?=\\s|$)/g, \"$1<strong>$2</strong>\" )\n        .replace(/\\n---\\n/g, \"\\n<hr />\\n\")\n        .replace(/^[\\s]*-[\\s]*(.*)$/gm, \"<li>$1</li>\")\n        .replace(/(<li>.*<\\/li>)/gm, \"<ul>$1</ul>\").replace(/<\\/ul>\\n<ul>/gm, \"\").replace(/<\\/ul>/gm, \"</ul>\\n\");\n}\n\nfunction uuid() {\n    return ('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        let r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    }));\n}\n\nexports.copyDirectory = copyDirectory;\nexports.clean = clean;\nexports.copy = copy;\nexports.mkdir = mkdir;\nexports.mkdirs = mkdirs;\nexports.mkdirClean = mkdirClean;\nexports.rmdir = rmdir;\nexports.ls = ls;\nexports.lsAll = lsAll;\nexports.suffixFilter = function(suffix) { return function(file) { return file.endsWith(\".\" + suffix); } }\nexports.read = read;\nexports.readString = readString;\nexports.write = write;\nexports.markup = markup;\nexports.remove = remove;\nexports.rm = remove;\nexports.uuid = uuid;\nexports.exists = exists;\n\n'community-edition/scripts/link.js'\n:const childProcess = require(\"child_process\");\nconst g = require(\"./gatlight\")\n\nconst output = childProcess.execSync(\"npm link\", { cwd: \"./ts/core\"/*, env: process.env, stdio: 'inherit' */});\n\nconst r = /(.*)\\s{1}->/\nconst linkPath = output.toString().match(r)[1]\nconsole.log(\"Path to linked core : \" + linkPath)\nif (linkPath != null) {\n    g.mkdirs(\"./ts/dom/node_modules\")\n    g.mkdirClean(\"./ts/dom/node_modules/@jsplumb\")\n    childProcess.execSync(\"ln -s \" + linkPath + \" core\", { cwd: \"./ts/dom/node_modules/@jsplumb\", env: process.env, stdio: 'inherit' });\n\n} else {\n    console.log(\"Linked path to core is null; this is a fail.\")\n}\n\n\n\n",
        "called_code_segment": "function copyDirectory (input, output, options) {\n\n    options = options || {};\n    let recurse = options.recurse !== false;\n    let includeHidden = options.hidden === true;\n\n    if (fs.existsSync(output)) {\n        clean(output, { andRemove:true });\n    }\n\n    let filter = createFilter(options);\n\n    let _one = (inputDir, outputDir) => {\n\n        fs.mkdirSync(outputDir);\n\n        fs.readdirSync(inputDir).forEach(file => {\n\n            if (filter(file)) {\n\n                let inputPath = path.join(inputDir, file);\n                if (isDirectory(inputPath)) {\n                    if (recurse) {\n                        _one(inputPath, path.join(outputDir, file));\n                    }\n                } else {\n                    if (includeHidden === true || file.indexOf(\".\") !== 0) {\n                        let outputPath = path.join(outputDir, file);\n                        console.log(\"gatlight: copying : \" + inputPath + \" to \" + outputPath);\n                        try {\n                            fs.copyFileSync(inputPath, outputPath);\n                        } catch (e) {\n                            console.log(e)\n                        }\n                    } else {\n                        console.log(\"gatlight: excluding \" + inputPath + \" due to a dot\")\n                    }\n                }\n            } else {\n                console.log(\"Filtered \" + file + \" from copy\");\n            }\n\n        });\n    };\n\n    _one(input, output);\n}",
        "invoking_code_segment": "const output = childProcess.execSync(\"npm link\", { cwd: \"./ts/core\"/*, env: process.env, stdio: 'inherit' */});\n\nconst r = /(.*)\\s{1}->/\nconst linkPath = output.toString().match(r)[1]\nconsole.log(\"Path to linked core : \" + linkPath)\nif (linkPath != null) {\n    g.mkdirs(\"./ts/dom/node_modules\")\n    g.mkdirClean(\"./ts/dom/node_modules/@jsplumb\")\n    childProcess.execSync(\"ln -s \" + linkPath + \" core\", { cwd: \"./ts/dom/node_modules/@jsplumb\", env: process.env, stdio: 'inherit' });\n\n} else {\n    console.log(\"Linked path to core is null; this is a fail.\")\n}",
        "new_file_code_segment": "function logCopyOperation(inputPath, outputPath) {\n    console.log(\"gatlight: copying : \" + inputPath + \" to \" + outputPath);\n}\n\nexports.logCopyOperation = logCopyOperation;",
        "feature_description": "Add logging for each file copy operation.",
        "detailed_feature_description": "The new feature introduces a logging mechanism for each file copy operation. This is implemented in a new file (#file 3) which contains a function `logCopyOperation` that logs the input and output paths of each file being copied. This function is then invoked within the `copyDirectory` function in #file 1 to ensure that each copy operation is logged. The `copyDirectory` function in #file 1 is invoked by #file 2, and the logging functionality is seamlessly integrated without requiring any changes to the invocation in #file 2.",
        "modified_complete_code": {
            "#file 1": "const fs = require('fs');\nconst path = require('path');\nconst { logCopyOperation } = require('./logCopy'); // #New\n\nfunction copyDirectory (input, output, options) {\n\n    options = options || {};\n    let recurse = options.recurse !== false;\n    let includeHidden = options.hidden === true;\n\n    if (fs.existsSync(output)) {\n        clean(output, { andRemove:true });\n    }\n\n    let filter = createFilter(options);\n\n    let _one = (inputDir, outputDir) => {\n\n        fs.mkdirSync(outputDir);\n\n        fs.readdirSync(inputDir).forEach(file => {\n\n            if (filter(file)) {\n\n                let inputPath = path.join(inputDir, file);\n                if (isDirectory(inputPath)) {\n                    if (recurse) {\n                        _one(inputPath, path.join(outputDir, file));\n                    }\n                } else {\n                    if (includeHidden === true || file.indexOf(\".\") !== 0) {\n                        let outputPath = path.join(outputDir, file);\n                        logCopyOperation(inputPath, outputPath); // #Modify\n                        try {\n                            fs.copyFileSync(inputPath, outputPath);\n                        } catch (e) {\n                            console.log(e)\n                        }\n                    } else {\n                        console.log(\"gatlight: excluding \" + inputPath + \" due to a dot\")\n                    }\n                }\n            } else {\n                console.log(\"Filtered \" + file + \" from copy\");\n            }\n\n        });\n    };\n\n    _one(input, output);\n}",
            "#file 2": "const childProcess = require(\"child_process\");\nconst g = require(\"./gatlight\")\n\nconst output = childProcess.execSync(\"npm link\", { cwd: \"./ts/core\"/*, env: process.env, stdio: 'inherit' */});\n\nconst r = /(.*)\\s{1}->/\nconst linkPath = output.toString().match(r)[1]\nconsole.log(\"Path to linked core : \" + linkPath)\nif (linkPath != null) {\n    g.mkdirs(\"./ts/dom/node_modules\")\n    g.mkdirClean(\"./ts/dom/node_modules/@jsplumb\")\n    childProcess.execSync(\"ln -s \" + linkPath + \" core\", { cwd: \"./ts/dom/node_modules/@jsplumb\", env: process.env, stdio: 'inherit' });\n\n} else {\n    console.log(\"Linked path to core is null; this is a fail.\")\n}",
            "#file 3": "function logCopyOperation(inputPath, outputPath) {\n    console.log(\"gatlight: copying : \" + inputPath + \" to \" + outputPath);\n}\n\nexports.logCopyOperation = logCopyOperation;"
        }
    },
    {
        "repo": "expect-jsx",
        "content": "'expect-jsx/index.js'\n:import expect from 'expect';\nimport collapse from 'collapse-white-space';\n\nimport reactElementToJSXString from 'react-element-to-jsx-string';\n\nconst api = {\n  toEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toNotEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toNotEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toIncludeJSX(ReactElement) {\n    return expect(\n      collapse(reactElementToJSXString(this.actual))\n    ).toInclude(\n      collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n  toNotIncludeJSX(ReactElement) {\n    return expect(\n        collapse(reactElementToJSXString(this.actual))\n    ).toExclude(\n        collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n};\n\nexport default api;\n\n'expect-jsx/index-test.js'\n:/* eslint-env mocha */\n/* eslint react/prop-types:0 */\n\nimport React from 'react';\nimport expect from 'expect';\nimport expectJSX from './index';\n\nexpect.extend(expectJSX);\n\nclass TestComponent extends React.Component {\n  render() {\n    return <div>Hi! {this.props.name}</div>;\n  }\n}\n\ndescribe('expect(ReactElement).toEqualJSX(ReactElement)', () => {\n  context('api', () => {\n    it('has toEqualJSX', () => {\n      expect(expect().toEqualJSX).toBeA('function');\n    });\n\n    it('has toNotEqualJSX', () => {\n      expect(expect().toNotEqualJSX).toBeA('function');\n    });\n\n    it('has toIncludeJSX', () => {\n      expect(expect().toIncludeJSX).toBeA('function');\n    });\n  });\n\n  context('toEqualJSX', () => {\n    it('can diff React elements', () => {\n      expect(\n        <TestComponent />\n      ).toEqualJSX(\n        <TestComponent />\n      );\n    });\n\n    it('throws when elements are different', () => {\n      try {\n        expect(<TestComponent extra=\"neous\" />).toEqualJSX(<TestComponent />);\n      } catch (err) {\n        expect(err instanceof Error).toBe(true);\n        expect(err.message)\n          .toEqual('Expected \\'<TestComponent extra=\"neous\" />\\' to equal \\'<TestComponent />\\'');\n      }\n    });\n\n    it('does not care about function', () => {\n      const fns = {\n        one() { return 'one'; },\n        two() { return 'two'; },\n      };\n\n      expect(\n        <TestComponent fn={fns.one} />\n      ).toEqualJSX(\n        <TestComponent fn={fns.two} />\n      );\n    });\n\n    it('handle render method with interpolation', () => {\n      expect(\n        <TestComponent name=\"Jon\" />\n      ).toNotEqual(\n      <TestComponent name=\"Marry\" />\n      );\n    });\n  });\n\n  context('toNotEqualJSX', () => {\n    it('works', () => {\n      expect(<div />).toNotEqualJSX(<div Hello=\", world!\" />);\n    });\n\n    it('throws when elements are the same', () => {\n      try {\n        expect(<div />).toNotEqualJSX(<div />);\n      } catch (err) {\n        expect(err instanceof Error).toBe(true);\n        expect(err.message).toEqual('Expected \\'<div />\\' to not equal \\'<div />\\'');\n      }\n    });\n  });\n\n  context('toIncludeJSX', () => {\n    it('works', () => {\n      expect(<div><div><TestComponent Hello=\", world!\"/></div></div>)\n        .toIncludeJSX(<div><TestComponent Hello=\", world!\"/></div>);\n    });\n\n    it('throws when element is not included', () => {\n      try {\n        expect(<div />).toIncludeJSX(<div Hello=\", world!\" />);\n      } catch (err) {\n        expect(err instanceof Error).toBe(true);\n        expect(err.message).toEqual('Expected \\'<div />\\' to include \\'<div Hello=\", world!\" />\\'');\n      }\n    });\n  });\n\n  context('toNotIncludeJSX', () => {\n    it('works', () => {\n      expect(<div><div><TestComponent Hello=\", world!\"/></div></div>)\n        .toNotIncludeJSX(<div><TestComponent Jello=\", world!\"/></div>);\n    });\n\n    it('throws when element is included', () => {\n      try {\n        expect(<div Hello=\", world!\" />).toNotIncludeJSX(<div Hello=\", world!\" />);\n      } catch (err) {\n        expect(err instanceof Error).toBe(true);\n        const message = 'Expected \\'<div Hello=\", world!\" />\\' to exclude \\'<div Hello=\", world!\" />\\'';\n        expect(err.message).toEqual(message);\n      }\n    });\n  });\n});\n\n",
        "called_code_segment": "const api = {\n  toEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toNotEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toNotEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toIncludeJSX(ReactElement) {\n    return expect(\n      collapse(reactElementToJSXString(this.actual))\n    ).toInclude(\n      collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n  toNotIncludeJSX(ReactElement) {\n    return expect(\n        collapse(reactElementToJSXString(this.actual))\n    ).toExclude(\n        collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n};\n\nexport default api;",
        "invoking_code_segment": "expect.extend(expectJSX);",
        "new_file_code_segment": "const customMatchers = {\n  toMatchSnapshot(ReactElement) {\n    const snapshot = reactElementToJSXString(ReactElement);\n    expect(snapshot).toMatchSnapshot();\n  }\n};\n\nexport default customMatchers;",
        "feature_description": "Add a new matcher to compare React elements against a snapshot.",
        "detailed_feature_description": "The new feature introduces a `toMatchSnapshot` matcher that converts a React element to a JSX string and compares it against a stored snapshot. This functionality is implemented in a new file (#file 3) and integrated into the existing API in #file 1. The test file (#file 2) is updated to use this new matcher.",
        "modified_complete_code": {
            "#file 1": "import customMatchers from './customMatchers'; //New\n\nconst api = {\n  toEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toNotEqualJSX(ReactElement) {\n    return expect(\n      reactElementToJSXString(this.actual)\n    ).toNotEqual(\n      reactElementToJSXString(ReactElement)\n    );\n  },\n  toIncludeJSX(ReactElement) {\n    return expect(\n      collapse(reactElementToJSXString(this.actual))\n    ).toInclude(\n      collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n  toNotIncludeJSX(ReactElement) {\n    return expect(\n        collapse(reactElementToJSXString(this.actual))\n    ).toExclude(\n        collapse(reactElementToJSXString(ReactElement))\n    );\n  },\n  ...customMatchers //Modify\n};\n\nexport default api;",
            "#file 2": "import expect from 'expect';\nimport expectJSX from './index';\n\nexpect.extend(expectJSX);\n\n// Example usage of the new matcher\nexpect(<TestComponent name=\"Jon\" />).toMatchSnapshot(); //New",
            "#file 3": "import reactElementToJSXString from 'react-element-to-jsx-string';\n\nconst customMatchers = {\n  toMatchSnapshot(ReactElement) {\n    const snapshot = reactElementToJSXString(ReactElement);\n    expect(snapshot).toMatchSnapshot();\n  }\n};\n\nexport default customMatchers;"
        }
    },
    {
        "repo": "howtocenterincss",
        "content": "'howtocenterincss/js/how/findMethod.js'\n:/* @flow */\n\nvar Method = require('./methods/Method');\nvar Options = require('./Options');\nvar DoNothingMethod = require('./methods/DoNothingMethod');\nvar SingleLineTextLineHeightMethod =\n  require('./methods/SingleLineTextLineHeightMethod');\nvar PixelHeightContainerContentPaddingMethod =\n  require('./methods/PixelHeightContainerContentPaddingMethod');\nvar AbsolutePositionMethod = require('./methods/AbsolutePositionMethod');\nvar MarginAutoMethod = require('./methods/MarginAutoMethod');\nvar TableCellMethod = require('./methods/TableCellMethod');\nvar FlexMethod = require('./methods/FlexMethod');\nvar TextAlignMethod = require('./methods/TextAlignMethod');\n\n// This list is in order of preference. The first applicable method should be\n// used, as it's probably simpler.\nvar methods = [\n  new DoNothingMethod,\n  new TextAlignMethod,\n  new SingleLineTextLineHeightMethod(),\n  new MarginAutoMethod(),\n  new PixelHeightContainerContentPaddingMethod(),\n  new FlexMethod,\n  new AbsolutePositionMethod,\n  new TableCellMethod,\n];\n\nfunction findMethod(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): ?Method {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      return method;\n    }\n  }\n  return null;\n}\n\nmodule.exports = findMethod;\n\n'howtocenterincss/js/tests/snapshot.js'\n:/* @flow */\n\nrequire('colors');\nvar _ = require('underscore');\nvar fs = require('fs');\nvar wd = require('wd');\nvar BlinkDiff = require('blink-diff');\nvar PNGImage = require('pngjs-image');\nvar jsStringEscape = require('js-string-escape')\nvar chai = require('chai');\nvar invariant = require('invariant');\nvar tmp = require('tmp');\nvar Q = require('q');\nvar chaiAsPromised = require('chai-as-promised');\nvar findMethod = require('../how/findMethod');\n\nchai.use(chaiAsPromised);\nchai.should();\nchaiAsPromised.transferPromiseness = wd.transferPromiseness;\n\nvar testMatrix = require('./testMatrix');\nvar selenium = require('./selenium');\n\nfunction getReferenceFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getSnapshotName(test) + '.png';\n}\n\nfunction getReferenceTestHTMLFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getTestName(test) + '_test.html';\n}\n\nfunction getReferenceCodeFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getTestName(test) + '.txt';\n}\n\nwd.configureHttp({\n  timeout: 60000,\n  retryDelay: 15000,\n  retries: 5\n});\n\nvar remoteConfig = undefined;\nvar browserMappings;\nif (process.env.SAUCE_USERNAME && process.env.SAUCE_ACCESS_KEY) {\n  remoteConfig = {\n    hostname: 'ondemand.saucelabs.com',\n    port: 80,\n    username: process.env.SAUCE_USERNAME,\n    accessKey: process.env.SAUCE_ACCESS_KEY,\n  };\n  browserMappings = selenium.sauceLabsBrowserMappings;\n} else {\n  browserMappings = selenium.localBrowserMappings;\n}\n\nvar isCreatingSnapshots = !!process.env.CREATE_SNAPSHOTS;\nvar allTests = testMatrix.generateTestsForSeleniumBrowsers(\n  browserMappings\n);\n\n// browser text rendering variances\nvar SCREENSHOT_TOLERANCE = 0.000003;\n\nvar WINDOW_WIDTH = 400;\nvar WINDOW_HEIGHT = 400;\n\nvar css =\n'body, html { margin: 0; padding: 0; overflow: hidden; border: 0; }' +\n'body { font-family: arial; }' +\n// The container sizing will get overridden if the options specify it.\n'#content { background: #f00; width: 25px; height: 25px; }' +\n'#container { background: #0ff; width: 300px; height: 300px; }';\n\nvar fontSizeCSS =\n'body { font-size: ' + testMatrix.fontSize + 'px; }' +\n// By default, the browser has a 1.1-1.2em of line-height. This makes\n// calculating vertical centering different across methods.\n// TODO - this needs to be exposed as a notice to the user, or baked into the\n// code the method generates.\n'#content, #container { line-height: 1em; }' +\n'#content { background: 0 !important; }' +\n// The content sizing will get overridden if the method specifies it.\n'#content { width: auto; height: auto; }';\n\nfunction getOuterDivCSS(width, height) {\n  // For some reason, IE screenshots disregard the height of the body if there is\n  // nothing in it. We need a div to be opaquely white.\n  return '#testOuterDiv { background: white; width: ' + width + 'px; height: ' + height + 'px;}';\n}\n\n// http://www.phpied.com/dynamic-script-and-style-elements-in-ie/\nfunction getJStoInjectCSS(css: string) {\n  return (\n    'var ss1 = document.createElement(\"style\");' +\n    'var def = \"' + jsStringEscape(css) + '\";' +\n    'ss1.setAttribute(\"type\", \"text/css\");' +\n    'var hh1 = document.getElementsByTagName(\"head\")[0];' +\n    'hh1.appendChild(ss1);' +\n    'if (ss1.styleSheet) {' /*IE*/ +\n    '  ss1.styleSheet.cssText = def;' +\n    '} else {' /* errbody else */ +\n    '  var tt1 = document.createTextNode(def);' +\n    '  ss1.appendChild(tt1);' +\n    '}'\n  );\n}\n\nvar useBrowser = isCreatingSnapshots || remoteConfig;\n\nallTests.forEach(seleniumTests => {\n\n  var browser = seleniumTests.seleniumBrowser;\n  var tests = seleniumTests.tests;\n\n  global.suite('using ' + browser.getDisplayName(), () => {\n    var b;\n    var allPassed = true;\n    var windowWidth = WINDOW_WIDTH + browser.cropBoundary.addX;\n    var windowHeight = WINDOW_HEIGHT + browser.cropBoundary.addY;\n\n    global.suiteSetup(done => {\n      if (!useBrowser) {\n        done();\n        return;\n      }\n\n      b = wd.promiseChainRemote(remoteConfig);\n\n      if (process.env.SNAPSHOT_DEBUG) {\n        b.on('status', function(info) {\n            console.log(info.cyan);\n        });\n        b.on('command', function(eventType, command, response) {\n            console.log(' > ' + eventType.cyan, command, (response || '').grey);\n        });\n        b.on('http', function(meth, path, data) {\n            console.log(' > ' + meth.magenta, path, (data || '').grey);\n        });\n      }\n\n      b\n        .init(browser.toSeleniumJSON())\n        .setWindowSize(windowWidth, windowHeight)\n        .elementByTagName('html')\n        .getSize()\n        .then(size => {\n          invariant(b, 'flow');\n          // Browser titles/bars short change you, so set it so the document's\n          // 400x400.\n          return b.setWindowSize(windowWidth + (windowWidth - size.width), windowHeight + (windowHeight - size.height));\n        })\n        .nodeify(done);\n    });\n\n    global.suiteTeardown(done => {\n      if (!b) {\n        done();\n        return;\n      }\n\n      b\n        .quit()\n        .nodeify(done);\n    });\n\n    global.setup(done => {\n      if (!b) {\n        done();\n        return;\n      }\n      b\n        // Get all the browsers to render in as much standards mode as possible.\n        .get('http://dump.oliverzheng.com/doctype_html5.html')\n        .nodeify(done);\n    });\n\n    tests.forEach(t => {\n      var testName = testMatrix.getTestName(t);\n      var mochaTestName =\n        (isCreatingSnapshots ? 'Snapshot ' : 'Compare snapshot ') + testName;\n\n      global.test(mochaTestName, (done) => {\n        var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n        invariant(method, 'flow');\n        method.addIDs();\n        method.setIsTest();\n        var html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n        var canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n\n        var codeGenerated = canonicalCode.html;\n        if (canonicalCode.parentCSS) {\n          codeGenerated += '\\n\\n#parent {\\n' + canonicalCode.parentCSS + '\\n}';\n        }\n        if (canonicalCode.middleCSS) {\n          codeGenerated += '\\n\\n#middle {\\n' + canonicalCode.middleCSS + '\\n}';\n        }\n        if (canonicalCode.childCSS) {\n          codeGenerated += '\\n\\n#child {\\n' + canonicalCode.childCSS + '\\n}';\n        }\n\n        if (!useBrowser) {\n          // We only don't use the browser if we are comparing generated code\n          var referenceCode = fs.readFileSync(getReferenceCodeFilename(t), 'utf8');\n          if (referenceCode !== codeGenerated) {\n            done('Reference code not equal to code generated: ' + codeGenerated);\n          } else {\n            done();\n          }\n          return;\n        }\n\n        var cssToInject = css;\n        if (t.content.text) {\n          cssToInject += fontSizeCSS;\n        }\n\n        cssToInject += getOuterDivCSS(windowWidth, windowHeight);\n        if (isCreatingSnapshots) {\n          fs.writeFileSync(getReferenceCodeFilename(t), codeGenerated);\n        }\n        fs.writeFileSync(getReferenceTestHTMLFilename(t), '<style>' + cssToInject + '</style>' + html);\n\n        invariant(b, 'flow');\n        var insertJS =\n          'document.body.innerHTML = \"' + jsStringEscape('<div id=\"testOuterDiv\">' + html + '</div>') + '\";';\n        // In quirksmode, IE's box model stretches the height to fit the\n        // font-size. We could set 'overflow:hidden' to it, but it could mess\n        // with the actual generated code. So let's conditionally add font size\n        // when we need it.\n        var res =\n          b.execute(getJStoInjectCSS(cssToInject) + insertJS);\n\n        var referenceFilename = getReferenceFilename(t);\n        if (isCreatingSnapshots && !fs.existsSync(referenceFilename)) {\n          // Write the image for the first, compare all the ones after it to\n          // this.\n          res = res.saveScreenshot(referenceFilename);\n        } else {\n          var tmpFilename = tmp.tmpNameSync({\n            // for finding it easier in Finder\n            prefix: 'screenshot-' + Date.now() + '-' + testName + '-',\n            postfix: '.png',\n          });\n          res = res\n            .saveScreenshot(tmpFilename)\n            .then(() => {\n              tmpFilename\n              var blinkDiffOptions = {};\n              blinkDiffOptions.imageAPath = referenceFilename;\n              blinkDiffOptions.thresholdType = BlinkDiff.THRESHOLD_PERCENT;\n              if (browser.hasCropBoundary()) {\n                var image = PNGImage.readImageSync(tmpFilename);\n                image.clip(\n                  browser.cropBoundary.cropX,\n                  browser.cropBoundary.cropY,\n                  WINDOW_WIDTH,\n                  WINDOW_HEIGHT\n                );\n                blinkDiffOptions.imageB = image;\n              } else {\n                blinkDiffOptions.imageBPath = tmpFilename;\n              }\n              var blinkDiff = new BlinkDiff(blinkDiffOptions);\n              return Q.ninvoke(blinkDiff, 'run');\n            })\n            .then(result => {\n              var diff = result.differences / result.dimension;\n              var pass = diff < SCREENSHOT_TOLERANCE;\n              var deferred = Q.defer();\n              if (pass) {\n                fs.unlinkSync(tmpFilename);\n                deferred.resolve(diff);\n              } else {\n                deferred.reject(\n                  tmpFilename +\n                  ' is not equal to reference ' +\n                  referenceFilename +\n                  ', diff: ' + diff +\n                  ', tolerance: ' + SCREENSHOT_TOLERANCE\n                );\n              }\n              return deferred.promise;\n            });\n        }\n        res.nodeify(done);\n      });\n    });\n  });\n});\n\n",
        "called_code_segment": "function findMethod(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): ?Method {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      return method;\n    }\n  }\n  return null;\n}",
        "invoking_code_segment": "var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\ninvariant(method, 'flow');\nmethod.addIDs();\nmethod.setIsTest();\nvar html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\nvar canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);",
        "new_file_code_segment": "function logMethodDetails(\n  method: Method,\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n) {\n  console.log('Method Used:', method.constructor.name);\n  console.log('Content:', content);\n  console.log('Container:', container);\n  console.log('Horizontal Alignment:', horizontalAlignment);\n  console.log('Vertical Alignment:', verticalAlignment);\n  console.log('Browser Support:', browserSupport);\n}",
        "feature_description": "Logging details of the method used for centering.",
        "detailed_feature_description": "The new feature adds logging functionality to the `findMethod` function in #file 1. This logging will output details about the method used for centering, including the content, container, alignment, and browser support. A new file (#file 3) is created to handle this logging, and #file 1 is updated to invoke this logging function. #file 2 remains unchanged as it does not directly interact with the logging functionality.",
        "modified_complete_code": {
            "#file 1": "//Modify\nvar logMethodDetails = require('./logMethodDetails');\n\nfunction findMethod(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): ?Method {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      //Modify\n      logMethodDetails(method, content, container, horizontalAlignment, verticalAlignment, browserSupport);\n      return method;\n    }\n  }\n  return null;\n}",
            "#file 2": "var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\ninvariant(method, 'flow');\nmethod.addIDs();\nmethod.setIsTest();\nvar html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\nvar canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);",
            "#file 3": "//New\nfunction logMethodDetails(\n  method: Method,\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n) {\n  console.log('Method Used:', method.constructor.name);\n  console.log('Content:', content);\n  console.log('Container:', container);\n  console.log('Horizontal Alignment:', horizontalAlignment);\n  console.log('Vertical Alignment:', verticalAlignment);\n  console.log('Browser Support:', browserSupport);\n}"
        }
    },
    {
        "repo": "modern-desktop-app-template",
        "content": "'modern-desktop-app-template/src/Providers.jsx'\n:import '@fontsource/open-sans';\n\nimport { BrowserRouter } from 'react-router-dom';\n\nimport Mantine from './components/Mantine';\n\nimport { TauriProvider } from './tauri/TauriProvider';\n\nimport { TitleBar } from './tauri/TitleBar';\n\n\n\nexport default function ({ children }) {\n\n    return (\n\n        <TauriProvider>\n\n            <Mantine>\n\n                <BrowserRouter>\n\n                    <TitleBar />\n\n                    {children}\n\n                </BrowserRouter>\n\n            </Mantine>\n\n        </TauriProvider>\n\n    );\n\n}\n\n\n'modern-desktop-app-template/src/main.jsx'\n:import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from './App';\n// boilerplate components\nimport Providers from './Providers';\n// for internationalization (translations)\nimport './translations/i18n.js'\n\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <Providers>\n      <App />\n    </Providers>\n  </React.StrictMode>\n);\n\n",
        "called_code_segment": "export default function ({ children }) {\n\n    return (\n\n        <TauriProvider>\n\n            <Mantine>\n\n                <BrowserRouter>\n\n                    <TitleBar />\n\n                    {children}\n\n                </BrowserRouter>\n\n            </Mantine>\n\n        </TauriProvider>\n\n    );\n\n}",
        "invoking_code_segment": "const root = createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <Providers>\n      <App />\n    </Providers>\n  </React.StrictMode>\n);",
        "new_file_code_segment": "export function CustomTitleBar() {\n  return (\n    <div style={{ backgroundColor: '#333', color: '#fff', padding: '10px', textAlign: 'center' }}>\n      Custom Title Bar\n    </div>\n  );\n}",
        "feature_description": "Add a custom title bar with a dark theme.",
        "detailed_feature_description": "The new feature involves adding a custom title bar with a dark theme. This is implemented by creating a new file (`#file 3`) that exports a `CustomTitleBar` component. The `Providers` component in `#file 1` is updated to use this new component instead of the default `TitleBar`. The `main.jsx` file (`#file 2`) remains unchanged as it only invokes the `Providers` component, which now includes the custom title bar.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { BrowserRouter } from 'react-router-dom';\nimport Mantine from './components/Mantine';\nimport { TauriProvider } from './tauri/TauriProvider';\n//New\nimport { CustomTitleBar } from './tauri/CustomTitleBar';\n\nexport default function ({ children }) {\n\n    return (\n\n        <TauriProvider>\n\n            <Mantine>\n\n                <BrowserRouter>\n\n                    <CustomTitleBar />\n\n                    {children}\n\n                </BrowserRouter>\n\n            </Mantine>\n\n        </TauriProvider>\n\n    );\n\n}",
            "#file 2": "import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from './App';\nimport Providers from './Providers';\nimport './translations/i18n.js'\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <Providers>\n      <App />\n    </Providers>\n  </React.StrictMode>\n);",
            "#file 3": "export function CustomTitleBar() {\n  return (\n    <div style={{ backgroundColor: '#333', color: '#fff', padding: '10px', textAlign: 'center' }}>\n      Custom Title Bar\n    </div>\n  );\n}"
        }
    },
    {
        "repo": "neode",
        "content": "'neode/src/Query/Builder.js'\n:import Match from './Match';\nimport Order from './Order';\n// import Return from './Return';\nimport Statement from './Statement';\nimport Property from './Property';\nimport WhereStatement from './WhereStatement';\nimport Where, {OPERATOR_EQUALS} from './Where';\nimport WhereBetween from './WhereBetween';\nimport WhereId from './WhereId';\nimport WhereRaw from './WhereRaw';\nimport WithStatement from './WithStatement';\nimport WithDistinctStatement from './WithDistinctStatement';\nimport neo4j from 'neo4j-driver';\n\nexport const mode = {\n    READ: \"READ\",\n    WRITE: \"WRITE\"\n};\n\n\nexport default class Builder {\n\n    constructor(neode) {\n        this._neode = neode;\n\n        this._params = {};\n        this._statements = [];\n        this._current;\n        this._where;\n        this._set_count = 0;\n    }\n\n    /**\n     * Start a new Query segment and set the current statement\n     *\n     * @return {Builder}\n     */\n    statement(prefix) {\n        if (this._current) {\n            this._statements.push(this._current);\n        }\n\n        this._current = new Statement(prefix);\n\n        return this;\n    }\n\n    /**\n     * Start a new Where Segment\n     *\n     * @return {Builder}\n     */\n    whereStatement(prefix) {\n        if (this._where) {\n            this._current.where(this._where);\n        }\n\n        this._where = new WhereStatement(prefix);\n\n        return this;\n    }\n\n    /**\n     * Match a Node by a definition\n     *\n     * @param  {String} alias           Alias in query\n     * @param  {Model|String}  model    Model definition\n     * @param  {Object|null}   properties   Inline Properties\n     * @return {Builder}                Builder\n     */\n    match(alias, model, properties) {\n        this.whereStatement('WHERE');\n        this.statement();\n\n        this._current.match( new Match(alias, model, this._convertPropertyMap( alias, properties ) ) );\n\n        return this;\n    }\n\n    optionalMatch(alias, model) {\n        this.whereStatement('WHERE');\n        this.statement('OPTIONAL MATCH');\n\n        this._current.match(new Match(alias, model));\n\n        return this;\n    }\n\n    /**\n     * Add a 'with' statement to the query\n     *\n     * @param  {...String} args Variables/aliases to carry through\n     * @return {Builder}\n     */\n    with(...args) {\n        this.whereStatement('WHERE');\n        this.statement();\n\n        this._statements.push(new WithStatement(...args));\n\n        return this;\n    }\n\n    /**\n     * Add a 'with distinct' statement to the query\n     *\n     * @param  {...String} args Variables/aliases to carry through\n     * @return {Builder}\n     */\n    withDistinct(...args) {\n        this.whereStatement('WHERE');\n        this.statement();\n\n        this._statements.push(new WithDistinctStatement(...args));\n\n        return this;\n    }\n\n    /**\n     * Create a new WhereSegment\n     * @param  {...mixed} args\n     * @return {Builder}\n     */\n    or(...args) {\n        this.whereStatement('OR');\n\n        return this.where(...args);\n    }\n\n    /**\n     * Generate a unique key and add the value to the params object\n     *\n     * @param {String} key\n     * @param {Mixed} value\n     */\n    _addWhereParameter(key, value) {\n        let attempt = 1;\n        let base = `where_${key.replace(/[^a-z0-9]+/g, '_')}`;\n\n        // Try to create a unique key\n        let variable = base;\n\n        while ( typeof this._params[ variable ] != \"undefined\" ) {\n            attempt++;\n\n            variable = `${base}_${attempt}`;\n        }\n\n        this._params[ variable ] = value;\n\n        return variable;\n    }\n\n    /**\n     * Add a where condition to the current statement.\n     *\n     * @param  {...mixed} args Arguments\n     * @return {Builder}\n     */\n    where(...args) {\n        if (!args.length || !args[0]) return this;\n\n        // If 2 character length, it should be straight forward where\n        if (args.length == 2) {\n            args = [args[0], OPERATOR_EQUALS, args[1]];\n        }\n\n        // If only one argument, treat it as a single string\n        if ( args.length == 1) {\n            const [arg] = args;\n\n            if (Array.isArray(arg)) {\n                arg.forEach(inner => {\n                    this.where(...inner);\n                });\n            }\n            else if (typeof arg == 'object') {\n                Object.keys(arg).forEach(key => {\n                    this.where(key, arg[key]);\n                });\n            }\n            else {\n                this._where.append(new WhereRaw(args[0]));\n            }\n        }\n        else {\n            const [left, operator, value] = args;\n            const right = this._addWhereParameter(left, value);\n\n            this._params[ right ] = value;\n            this._where.append(new Where(left, operator, `$${right}`));\n        }\n\n        return this;\n    }\n\n    /**\n     * Query on Internal ID\n     *\n     * @param  {String} alias\n     * @param  {Int}    value\n     * @return {Builder}\n     */\n    whereId(alias, value) {\n        const param = this._addWhereParameter(`${alias}_id`, neo4j.int(value));\n\n        this._where.append(new WhereId(alias, param));\n\n        return this;\n    }\n\n    /**\n     * Add a raw where clause\n     *\n     * @param  {String} clause\n     * @return {Builder}\n     */\n    whereRaw(clause) {\n        this._where.append(new WhereRaw(clause));\n\n        return this;\n    }\n\n    /**\n     * A negative where clause\n     *\n     * @param {*} args\n     * @return {Builder}\n     */\n    whereNot(...args) {\n        this.where(...args);\n\n        this._where.last().setNegative();\n\n        return this;\n    }\n\n    /**\n     * Between clause\n     *\n     * @param {String} alias\n     * @param {Mixed} floor\n     * @param {Mixed} ceiling\n     * @return {Builder}\n     */\n    whereBetween(alias, floor, ceiling) {\n        const floor_alias = this._addWhereParameter(`${alias}_floor`, floor);\n        const ceiling_alias = this._addWhereParameter(`${alias}_ceiling`, ceiling);\n\n        this._where.append(new WhereBetween(alias, floor_alias, ceiling_alias));\n\n        return this;\n    }\n\n    /**\n     * Negative Between clause\n     *\n     * @param {String} alias\n     * @param {Mixed} floor\n     * @param {Mixed} ceiling\n     * @return {Builder}\n     */\n    whereNotBetween(alias, floor, ceiling) {\n        this.whereBetween(alias, floor, ceiling);\n\n        this._where.last().setNegative();\n\n        return this;\n    }\n\n    /**\n     * Set Delete fields\n     *\n     * @param  {...mixed} args\n     * @return {Builder}\n     */\n    delete(...args) {\n        this._current.delete(...args);\n\n        return this;\n    }\n\n    /**\n     * Set Detach Delete fields\n     *\n     * @param  {...mixed} args\n     * @return {Builder}\n     */\n    detachDelete(...args) {\n        this._current.detachDelete(...args);\n\n        return this;\n    }\n\n    /**\n     * Start a Create Statement by alias/definition\n     *\n     * @param  {String} alias               Alias in query\n     * @param  {Model|String}  model        Model definition\n     * @param  {Object|null}   properties   Inline Properties\n     * @return {Builder}                    Builder\n     */\n    create(alias, model, properties) {\n        this.whereStatement('WHERE');\n        this.statement('CREATE');\n\n        this._current.match( new Match(alias, model, this._convertPropertyMap( alias, properties ) ) );\n\n        return this;\n    }\n\n    /**\n     * Convert a map of properties into an Array of\n     *\n     * @param {Object|null} properties\n     */\n    _convertPropertyMap(alias, properties) {\n        if ( properties ) {\n            return Object.keys(properties).map(key => {\n                const property_alias = `${alias}_${key}`;\n\n                this._params[ property_alias ] = properties[ key ];\n\n                return new Property( key, property_alias );\n            });\n        }\n\n        return [];\n    }\n\n    /**\n     * Start a Merge Statement by alias/definition\n     *\n     * @param  {String}        alias        Alias in query\n     * @param  {Model|String}  model        Model definition\n     * @param  {Object|null}   properties   Inline Properties\n     * @return {Builder}                    Builder\n     */\n    merge(alias, model, properties) {\n        this.whereStatement('WHERE');\n        this.statement('MERGE');\n\n        this._current.match( new Match(alias, model, this._convertPropertyMap( alias, properties ) ) );\n\n        return this;\n    }\n\n    /**\n     * Set a property\n     *\n     * @param {String|Object} property   Property in {alias}.{property} format\n     * @param {Mixed}         value      Value\n     * @param {String}        operator   Operator\n     */\n    set(property, value, operator = '=') {\n        // Support a map of properties\n        if ( !value && property instanceof Object ) {\n            Object.keys(property).forEach(key => {\n                this.set(key, property[ key ]);\n            });\n        }\n        else {\n            if ( value !== undefined ) {\n                const alias = `set_${this._set_count}`;\n                this._params[ alias ] = value;\n\n                this._set_count++;\n\n                this._current.set(property, alias, operator);\n            } else {\n                this._current.setRaw(property);\n            }\n        }\n\n        return this;\n    }\n\n\n    /**\n     * Set a property\n     *\n     * @param {String|Object} property   Property in {alias}.{property} format\n     * @param {Mixed}         value      Value\n     * @param {String}        operator   Operator\n     */\n    onCreateSet(property, value, operator = '=') {\n        // Support a map of properties\n        if ( value === undefined && property instanceof Object ) {\n            Object.keys(property).forEach(key => {\n                this.onCreateSet(key, property[ key ]);\n            });\n        }\n        else {\n            const alias = `set_${this._set_count}`;\n            this._params[ alias ] = value;\n\n            this._set_count++;\n\n            this._current.onCreateSet(property, alias, operator);\n        }\n\n        return this;\n    }\n\n\n    /**\n     * Set a property\n     *\n     * @param {String|Object} property   Property in {alias}.{property} format\n     * @param {Mixed}         value      Value\n     * @param {String}        operator   Operator\n     */\n    onMatchSet(property, value, operator = '=') {\n        // Support a map of properties\n        if ( value === undefined && property instanceof Object ) {\n            Object.keys(property).forEach(key => {\n                this.onMatchSet(key, property[ key ]);\n            });\n        }\n        else {\n            const alias = `set_${this._set_count}`;\n            this._params[ alias ] = value;\n\n            this._set_count++;\n\n            this._current.onMatchSet(property, alias, operator);\n        }\n\n        return this;\n    }\n\n    /**\n     * Remove properties or labels in {alias}.{property}\n     * or {alias}:{Label} format\n     *\n     * @param {[String]} items\n     */\n    remove(...items) {\n        this._current.remove(items);\n\n        return this;\n    }\n\n    /**\n     * Set Return fields\n     *\n     * @param  {...mixed} args\n     * @return {Builder}\n     */\n    return(...args) {\n        this._current.return(...args);\n\n        return this;\n    }\n\n    /**\n     * Set Record Limit\n     *\n     * @param  {Int} limit\n     * @return {Builder}\n     */\n    limit(limit) {\n        this._current.limit(limit);\n\n        return this;\n    }\n\n    /**\n     * Set Records to Skip\n     *\n     * @param  {Int} skip\n     * @return {Builder}\n     */\n    skip(skip) {\n        this._current.skip(skip);\n\n        return this;\n    }\n\n    /**\n     * Add an order by statement\n     *\n     * @param  {...String|object} args  Order by statements\n     * @return {Builder}\n     */\n    orderBy(...args) {\n        let order_by;\n\n        if (args.length == 2) {\n            // Assume orderBy(what, how)\n            order_by = new Order(args[0], args[1]);\n\n        }\n        else if (Array.isArray(args[0])) {\n            // Handle array of where's\n            args[0].forEach(arg => {\n                this.orderBy(arg);\n            });\n        }\n        // TODO: Ugly, stop supporting this\n        else if (typeof args[0] == 'object' && args[0].field) {\n            // Assume orderBy(args[0].field, args[0].order)\n            order_by = new Order(args[0].field, args[0].order);\n        }\n        else if (typeof args[0] == 'object') {\n            // Assume {key: order}\n            Object.keys(args[0]).forEach(key => {\n                this.orderBy(key, args[0][key]);\n            });\n        }\n        else if (args[0]) {\n            // Assume orderBy(what, 'ASC')\n            order_by = new Order(args[0]);\n        }\n\n        if (order_by) {\n            this._current.order(order_by);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a relationship to the query\n     *\n     * @param  {String|RelationshipType} relationship  Relationship name or RelationshipType object\n     * @param  {String}                  direction     Direction of relationship DIRECTION_IN, DIRECTION_OUT\n     * @param  {String|null}             alias         Relationship alias\n     * @param  {Int|String}              degrees        Number of traversdegreesals (1, \"1..2\", \"0..2\", \"..3\")\n     * @return {Builder}\n     */\n    relationship(relationship, direction, alias, degrees) {\n        this._current.relationship(relationship, direction, alias, degrees);\n\n        return this;\n    }\n\n    /**\n     * Complete a relationship\n     * @param  {String} alias       Alias\n     * @param  {Model}  model       Model definition\n     * @param  {Object} properties  Properties\n     * @return {Builder}\n     */\n    to(alias, model, properties) {\n        this._current.match( new Match(alias, model, this._convertPropertyMap(alias, properties) ) );\n\n        return this;\n    }\n\n    /**\n     * Complete the relationship statement to point to anything\n     *\n     * @return {Builder}\n     */\n    toAnything() {\n        this._current.match(new Match());\n\n        return this;\n    }\n\n    /**\n     * Build the pattern without any keywords\n     *\n     * @return {String}\n     */\n    pattern() {\n        this.whereStatement();\n        this.statement();\n\n        return this._statements.map(statement => {\n            return statement.toString(false);\n        }).join('\\n');\n    }\n\n    /**\n     * Build the Query\n     *\n     * @param  {...String} output References to output\n     * @return {Object}           Object containing `query` and `params` property\n     */\n    build() {\n        // Append Statement to Statements\n        this.whereStatement();\n        this.statement();\n\n        const query = this._statements.map(statement => {\n            return statement.toString();\n        }).join('\\n');\n\n        return {\n            query,\n            params: this._params\n        };\n    }\n\n    /**\n     * Execute the query\n     *\n     * @param  {String}  query_mode\n     * @return {Promise}\n     */\n    execute(query_mode = mode.WRITE) {\n        const { query, params } = this.build();\n\n        let session\n\n        switch (query_mode) {\n            case mode.WRITE:\n                session = this._neode.writeSession()\n\n                return session.writeTransaction(tx => tx.run(query, params))\n                    .then(res => {\n                        session.close()\n\n                        return res\n                    })\n\n\n            default:\n                session = this._neode.readSession()\n\n                return session.readTransaction(tx => tx.run(query, params))\n                    .then(res => {\n                        session.close()\n\n                        return res\n                    })\n        }\n    }\n\n}\n'neode/test/index.spec.js'\n:import {assert, expect} from 'chai';\nimport Neode from '../src/index';\nimport Model from '../src/Model';\nimport Node from '../src/Node';\nimport Collection from '../src/Collection';\nimport Property from '../src/Property';\nimport Builder from '../src/Query/Builder';\nimport Relationship from '../src/Relationship';\nimport { ERROR_TRANSACTION_FAILED } from '../src/TransactionError';\n\ndescribe('index.js', () => {\n    const label = 'IndexTest';\n    const schema = {\n        name: {type: 'string', primary: true},\n        setme: 'string',\n        relate_test: {\n            type: 'relationship',\n            relationship: 'RELATE_TEST',\n            direction: 'OUT',\n            properties: {\n                test: 'boolean',\n            },\n        },\n    };\n    let instance;\n\n    before(() => instance = require('./instance')() );\n\n    after(done => {\n        instance.cypher(`MATCH (n:${label}) DETACH DELETE n`)\n            .then(() => instance.close())\n            .then(() => done())\n            .catch(e => done(e));\n    });\n\n    it('should instantiate', () => {\n        expect(instance).to.be.an.instanceOf(Neode);\n        // expect(instance.driver).to.be.an.instanceOf(neo4j.driver);\n    });\n\n    it('should instantiate with enterprise mode', () => {\n        const enterprise = new Neode('bolt://localhost:3000', 'username', 'password', true, 'defaultdb');\n\n        expect(enterprise).to.be.an.instanceOf(Neode);\n        expect(enterprise.enterprise()).to.equal(true);\n        expect(enterprise.database).to.equal('defaultdb');\n    });\n\n    it('should load models using `with` and return self', () => {\n        const output = instance.with({\n            WithTest: {\n                name: 'string'\n            }\n        });\n\n        expect(output).to.equal(instance);\n        expect(output.model('WithTest')).to.be.an.instanceOf(Model);\n    });\n\n    it('should load modules from a directory', () => {\n        const output = instance.withDirectory(__dirname + '/fixtures');\n        const properties = require('./fixtures/ScanDirTest');\n\n        expect(output).to.equal(instance);\n        expect(output.model('ScanDirTest')).to.be.an.instanceOf(Model);\n        expect(output.model('ScanDirTest').properties().get('id')).to.be.an.instanceOf(Property);\n        expect(output.model('ScanDirTest').properties().get('name')).to.be.an.instanceOf(Property);\n    });\n\n    it('should run cypher query', (done) => {\n        instance.cypher('MATCH (n) RETURN count(n)')\n            .then(res => {\n                expect(res.records).to.be.an('array');\n                expect(res.records.length).to.equal(1);\n\n                done();\n            })\n            .catch(err => {\n                done(err);\n            });\n    });\n\n    it('should run a cypher read query', (done) => {\n        instance.readCypher('MATCH (n) RETURN count(n)')\n            .then(res => {\n                expect(res.records).to.be.an('array');\n                expect(res.records.length).to.equal(1);\n\n                done();\n            })\n            .catch(err => {\n                done(err);\n            });\n    });\n\n    it('should handle error in syntax query', (done) => {\n        instance.cypher('MATCH (n) RETURN coutn(n)')\n            .catch(err => {\n                done();\n            });\n    });\n\n    describe('::batch', () => {\n        it('should handle a batch of queries', (done) => {\n            const queries = [\n                'MATCH (n) RETURN count(n)',\n                {query: 'MATCH (n) WHERE n.name = $name RETURN n', params: {name: 'name'}}\n            ];\n\n            instance.batch(queries)\n                .then(res => {\n                    assert.isArray(res)\n                    expect(res.length).to.equal(2)\n                })\n                .then(done)\n                .catch(done)\n        });\n\n        it('should throw a transaction error on error', done => {\n            instance.batch([\n                'MATCH (a) RETURN b',\n                'RETURN x'\n            ])\n                .then(() => {\n                    done( new Error('No TransactionError thrown') );\n                })\n                .catch(e => {\n                    expect(e).to.be.an.instanceOf(Error);\n                    expect(e.message).to.equal(ERROR_TRANSACTION_FAILED);\n                    expect(e.errors.length).to.equal(2);\n\n                    done();\n                })\n\n        });\n    });\n\n    describe('::model', () => {\n        it('should register a new model', () => {\n            const model = instance.model(label, schema);\n\n            expect(model).to.be.an.instanceOf(Model);\n            expect(model.name()).to.equal(label);\n        });\n    });\n\n    describe('::extend', () => {\n        it('should extend a model with new properties', () => {\n            const extended_label = 'ExtendedTest';\n            const using = {\n                extended_id: {\n                    primary: true\n                },\n                somethingelse: 'string'\n            };\n\n            const model = instance.extend(label, extended_label, using);\n\n            expect(model).to.be.an.instanceOf(Model);\n            expect(model.name()).to.equal(extended_label);\n            expect(model.labels()).to.contain(label, extended_label);\n\n            expect(model.primaryKey()).to.equal('extended_id');\n\n            const newprop = model.properties().get('somethingelse');\n\n            expect(newprop).to.be.an.instanceOf(Property);\n            expect(newprop.type()).to.equal('string');\n\n            expect(instance.model(extended_label)).to.equal(model);\n        });\n    });\n\n    describe('::create', () => {\n        it('should create a new model', (done) => {\n            const create_data = {name: 'Test'};\n\n            instance.create(label, create_data)\n                .then(res => {\n                    expect(res).to.be.an.instanceOf(Node);\n                    expect(res.get('name')).to.equal(create_data.name);\n\n                    expect( res.properties() ).to.deep.equal(create_data);\n\n                    expect( res.get('unknown', 'default') ).to.equal('default');\n\n                    return res.toJson();\n                })\n                .then(json => {\n                    expect(json.name).to.equal(create_data.name);\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n    });\n\n    describe('::merge', () => {\n        it('should merge a model', (done) => {\n            const create_data = {name: 'Test'};\n\n            Promise.all([\n                instance.merge(label, create_data),\n                instance.merge(label, create_data),\n            ])\n                .then(([ first, second ]) => {\n                    expect(first).to.be.an.instanceOf(Node);\n                    expect(first.get('name')).to.equal(create_data.name);\n\n                    expect(second).to.be.an.instanceOf(Node);\n                    expect(second.get('name')).to.equal(create_data.name);\n\n                    expect(first.id()).to.equal(second.id());\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n    });\n\n    describe('::mergeOn', () => {\n        it('should merge a model on specific properties', (done) => {\n            const match = {name: 'Test'};\n            const set = {setme: 'set'};\n\n            Promise.all([\n                instance.mergeOn(label, match, set),\n                instance.mergeOn(label, match, set),\n            ])\n                .then(([ first, second ]) => {\n                    expect(first).to.be.an.instanceOf(Node);\n                    expect(first.get('name')).to.equal(match.name);\n                    expect(first.get('setme')).to.equal(set.setme);\n\n                    expect(second).to.be.an.instanceOf(Node);\n                    expect(second.get('name')).to.equal(match.name);\n                    expect(second.get('setme')).to.equal(set.setme);\n\n                    expect(first.id()).to.equal(second.id());\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n    });\n\n    describe('::delete', () => {\n        it('should delete a node', (done) => {\n            const create_data = {name: 'DeleteTest'};\n            instance.create(label, create_data)\n                .then(node => instance.delete(node))\n                .then(() => done())\n                .catch(e => done(e));\n        })\n    });\n\n    describe('::relateTo', () => {\n        it('should relate two nodes', (done) => {\n            const props = { test: true };\n            Promise.all([\n                instance.create(label, {name: 'From'}),\n                instance.create(label, {name: 'To'}),\n            ])\n                .then(([from, to]) => {\n                    return instance.relate(from, to, 'relate_test', props)\n                        .then(rel => {\n                            expect(rel).to.be.instanceof(Relationship);\n                            expect(rel.get('test')).to.equal( props.test );\n\n                            return rel;\n                        })\n                        .then(rel => {\n                            expect( rel.properties() ).to.deep.equal(props);\n\n                            return rel;\n                        });\n                })\n                .then(rel => {\n                    return instance.cypher(\n                        'MATCH (start)-[rel]->(end) WHERE id(start) = $start AND id(rel) = $rel AND id(end) = $end RETURN count(*) as count',\n                        {\n                            start: rel.startNode().identity(),\n                            rel: rel.identity(),\n                            end: rel.endNode().identity(),\n                        }\n                    )\n                        .then(res => {\n                            expect( res.records[0].get('count').toNumber() ).to.equal(1);\n                        });\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n\n        it('should create a second relationship when forced', (done) => {\n            const props = { test: true };\n            Promise.all([\n                instance.create(label, {name: 'From'}),\n                instance.create(label, {name: 'To'}),\n            ])\n                .then(([from, to]) => {\n                    return instance.relate(from, to, 'relate_test', props)\n                        .then(rel => {\n                            expect(rel).to.be.instanceof(Relationship);\n                            expect(rel.get('test')).to.equal( props.test );\n\n                            return rel;\n                        })\n                        .then(rel => {\n                            expect( rel.properties() ).to.deep.equal(props);\n\n                            return rel;\n                        });\n                })\n                .then(rel => {\n                    return instance.relate(rel.startNode(), rel.endNode(), 'relate_test', props, true)\n                        .then(rel => {\n                            expect(rel).to.be.instanceof(Relationship);\n                            expect(rel.get('test')).to.equal( props.test );\n\n                            return rel;\n                        })\n                        .then(rel => {\n                            expect( rel.properties() ).to.deep.equal(props);\n\n                            return rel;\n                        });\n                })\n                .then(rel => {\n                    return instance.cypher(\n                        `MATCH (start)-[:${ rel.type() }]->(end) WHERE id(start) = $start AND id(end) = $end RETURN count(*) as count`,\n                        {\n                            start: rel.startNode().identity(),\n                            rel: rel.identity(),\n                            end: rel.endNode().identity(),\n                        }\n                    )\n                        .then(res => {\n                            expect( res.records[0].get('count').toNumber() ).to.equal(2);\n                        });\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n\n        it('should throw an error for an unknown relationship type', done => {\n            Promise.all([\n                instance.create(label, {name: 'From'}),\n                instance.create(label, {name: 'To'}),\n            ])\n                .then(([from, to]) => {\n                    return instance.relate(from, to, 'unknown')\n                        .then(rel => {\n                            assert(false, 'Error should be thrown on unknown relationship type');\n                        })\n                        .catch(e => {\n                            done();\n                        });\n                })\n        });\n    });\n\n    describe('::detachFrom', () => {\n        it('should detach two nodes', (done) => {\n            Promise.all([\n                instance.create(label, {name: 'From'}),\n                instance.create(label, {name: 'To'}),\n            ])\n                .then(([from, to]) => from.detachFrom(to))\n                .then(([from, to]) => {\n                    return instance.cypher(\n                        'MATCH (start)-[rel]->(end) WHERE id(start) = $start AND id(end) = $end RETURN count(*) as count',\n                        {\n                            start: from.identity(),\n                            end: to.identity(),\n                        }\n                    )\n                        .then(res => {\n                            expect(res.records[0].get('count').toNumber()).to.equal(0);\n                        });\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n    });\n\n    describe('::query', () => {\n        it('should return a query builder', () => {\n            const query = instance.query();\n\n            expect(query).to.be.an.instanceOf(Builder);\n        });\n    });\n\n    describe('::all', () => {\n        it('should return a collection of nodes', (done) => {\n            instance.all(label, {}, {}, 1, 0)\n                .then(res => {\n                    expect(res).to.be.an.instanceOf(Collection);\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n    });\n\n    describe('::find', () => {\n        it('should find a label by its primary key', (done) => {\n            const create_data = {name: 'FindTest'};\n            instance.create(label, create_data)\n                .then(res => {\n                    return instance.find(label, create_data.name)\n                        .then(found => {\n                            expect(found.id()).to.equal(res.id());\n                        })\n                        .then(() => res.delete())\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n    });\n\n    describe('::findById', () => {\n        it('should find a label by its internal ID', (done) => {\n            const create_data = {name: 'FindByIdTest'};\n            instance.create(label, create_data)\n                .then(res => {\n                    return instance.findById(label, res.id())\n                        .then(found => {\n                            expect(found.id()).to.equal(res.id());\n                        })\n                        .then(() => res.delete())\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n    });\n\n    describe('::first', () => {\n        it('should find a label by a property', (done) => {\n            const key = 'name';\n            const value = 'FirstTest';\n\n            instance.create(label, { [key] : value })\n                .then(res => {\n                    return instance.first(label, key, value)\n                        .then(found => {\n                            expect(found).to.be.instanceOf(Node);\n\n                            expect(found.id()).to.equal(res.id());\n                        });\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n\n        it('should find a label by a map of properties', (done) => {\n            const key = 'name';\n            const value = 'FirstMapTest';\n\n            instance.create(label, { [key] : value })\n                .then(res => {\n                    return instance.first(label, { [key] : value })\n                        .then(found => {\n                            expect(found).to.be.instanceOf(Node);\n\n                            expect(found.id()).to.equal(res.id());\n                        });\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n    });\n\n\n    describe('::cypher', () => {\n        it('should execute a function as part of a session', (done) => {\n            const session = instance.session();\n\n            instance.cypher('MATCH (n) RETURN COUNT(n)', {}, session)\n                .then(res => {\n                    expect(session._open).to.equal(true);\n\n                    session.close();\n                })\n                .then(() => done())\n                .catch(e => done(e));\n        });\n\n        // it('should execute a function as part of a transaction', (done) => {\n        //     done();\n        // });\n    });\n\n    // TODO: Killing queries, reinstate?\n    // describe('::close', () => {\n    //     it('should close the neo4j connection', () => {\n    //         const output = instance.close();\n    //     });\n    // });\n\n});\n",
        "called_code_segment": "execute(query_mode = mode.WRITE) {\n        const { query, params } = this.build();\n\n        let session\n\n        switch (query_mode) {\n            case mode.WRITE:\n                session = this._neode.writeSession()\n\n                return session.writeTransaction(tx => tx.run(query, params))\n                    .then(res => {\n                        session.close()\n\n                        return res\n                    })\n\n\n            default:\n                session = this._neode.readSession()\n\n                return session.readTransaction(tx => tx.run(query, params))\n                    .then(res => {\n                        session.close()\n\n                        return res\n                    })\n        }\n    }",
        "invoking_code_segment": "it('should run a cypher read query', (done) => {\n        instance.readCypher('MATCH (n) RETURN count(n)')\n            .then(res => {\n                expect(res.records).to.be.an('array');\n                expect(res.records.length).to.equal(1);\n\n                done();\n            })\n            .catch(err => {\n                done(err);\n            });\n    });",
        "new_file_code_segment": "export function logQueryExecution(query, params, mode) {\n    console.log(`Executing query in ${mode} mode:`);\n    console.log(query);\n    console.log(`With parameters:`);\n    console.log(params);\n}",
        "feature_description": "Add logging for query execution details.",
        "detailed_feature_description": "The new feature adds logging functionality to the query execution process. This will log the query being executed, the parameters used, and the mode (READ or WRITE). The logging function is implemented in a new file (#file 3) and is invoked from #file 1 where the query execution happens. This ensures that all queries executed through the Builder class are logged, providing transparency and debugging capabilities.",
        "modified_complete_code": {
            "#file 1": "execute(query_mode = mode.WRITE) {\n        const { query, params } = this.build();\n\n        let session\n\n        switch (query_mode) {\n            case mode.WRITE:\n                session = this._neode.writeSession()\n\n                logQueryExecution(query, params, 'WRITE'); //Modify\n                return session.writeTransaction(tx => tx.run(query, params))\n                    .then(res => {\n                        session.close()\n\n                        return res\n                    })\n\n\n            default:\n                session = this._neode.readSession()\n\n                logQueryExecution(query, params, 'READ'); //Modify\n                return session.readTransaction(tx => tx.run(query, params))\n                    .then(res => {\n                        session.close()\n\n                        return res\n                    })\n        }\n    }",
            "#file 2": "it('should run a cypher read query', (done) => {\n        instance.readCypher('MATCH (n) RETURN count(n)')\n            .then(res => {\n                expect(res.records).to.be.an('array');\n                expect(res.records.length).to.equal(1);\n\n                done();\n            })\n            .catch(err => {\n                done(err);\n            });\n    });",
            "#file 3": "export function logQueryExecution(query, params, mode) {\n    console.log(`Executing query in ${mode} mode:`);\n    console.log(query);\n    console.log(`With parameters:`);\n    console.log(params);\n}"
        }
    },
    {
        "repo": "nightwatch-cucumber",
        "content": "'nightwatch-cucumber/lib/runner.js'\n:const fs = require('fs')\nconst path = require('path')\nconst tmp = require('tmp')\nconst glob = require('glob')\nconst mkdirp = require('mkdirp')\nconst pify = require('pify')\nconst dummyTestModulesFolder = tmp.dirSync({ unsafeCleanup: true }).name\nconst NightwatchApi = require('./nightwatch-api')\nconst CucumberApi = require('./cucumber-api')\n\ntmp.setGracefulCleanup()\n\nmodule.exports = class Runner {\n  constructor () {\n    this.originalFeaturePath = {}\n  }\n\n  getSourceFile (featureSource) {\n    if (featureSource.startsWith('@')) {\n      return featureSource.substr(1, featureSource.length - 1)\n    }\n    return featureSource\n  }\n\n  getFeatureFilesFromRerunFile (rerunFile) {\n    const data = fs.readFileSync(this.getSourceFile(rerunFile))\n    return data.toString()\n      .split('\\n')\n      .map(featurePath => featurePath.trim().replace(/(:\\d*)/g, ''))\n      // filter empty paths\n      .filter(featurePath => featurePath)\n  }\n\n  getFeatureDirectories () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n            .map(featurePath => path.dirname(featurePath))\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return featureSource\n        }\n        return path.dirname(featureSource)\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n  }\n\n  getFeatureFiles () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return glob.sync(path.join(featureSource, '**/*.feature'))\n        }\n        return [featureSource]\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n      // make unique list\n      .filter((featureFilePath, idx, paths) => paths.indexOf(featureFilePath === idx))\n  }\n\n  generateDummyTestModules () {\n    this.getFeatureFiles().forEach((featureFile) => {\n      const dummyTestModuleFile = this.featurePathToDummyPath(featureFile)\n      mkdirp.sync(path.dirname(dummyTestModuleFile))\n      fs.writeFileSync(dummyTestModuleFile, '')\n    })\n  }\n\n  getTags (tags) {\n    tags = tags || []\n\n    if (typeof tags === 'string') {\n      tags = tags.split(',')\n    }\n\n    if (Array.isArray(tags)) {\n      return tags.map((tag) => `@${tag}`)\n    } else {\n      throw new Error(`Expected tags to be Array or String.`)\n    }\n  }\n\n  featurePathToDummyPath (featureFile) {\n    const lineNumberMatch = featureFile.match(/:(\\d+)$/)\n    let lineNumber\n    if (lineNumberMatch) {\n      lineNumber = parseInt(lineNumberMatch[1])\n      featureFile = featureFile.replace(/:\\d+$/, '')\n    }\n    try {\n      fs.statSync(featureFile)\n    } catch (err) {\n      if (!featureFile.match(/\\.feature$/)) featureFile += '.feature'\n      try {\n        fs.statSync(featureFile)\n      } catch (err) {\n        throw new Error(`Feature file or folder ${featureFile} was not found!`)\n      }\n    }\n\n    const dummyPath = path.join(dummyTestModulesFolder, featureFile.replace(/\\.feature$/, '.js'))\n\n    this.originalFeaturePath[dummyPath] = lineNumber ? `${featureFile}:${lineNumber}` : featureFile\n\n    return dummyPath\n  }\n\n  dummyPathToFeaturePath (dummyPath) {\n    if (!dummyPath.match(/\\.js$/)) dummyPath += '.js'\n\n    return this.originalFeaturePath[dummyPath] || dummyPath\n  }\n\n  addIndexToFileName (fileName, index) {\n    const cutIndex = fileName.lastIndexOf('.')\n    const ext = fileName.slice(cutIndex)\n    const rest = fileName.slice(0, cutIndex)\n    return `${rest}-${index}${ext}`\n  }\n\n  * executeTestModules (dummyTestModules) {\n    const featureFiles = dummyTestModules.map((dummyTestModule) => this.dummyPathToFeaturePath(dummyTestModule))\n\n    if (this.nightwatchApi.isRunningInParallel()) {\n      const workerIndex = this.nightwatchApi.getWorkerIndex()\n      this.jsonReport = this.addIndexToFileName(this.jsonReport, workerIndex)\n    }\n\n    if (this.jsonReport) {\n      yield pify(mkdirp)(path.dirname(this.jsonReport))\n    }\n    const cucumberArgs = this.cucumberApi.getAdjustedArgs({\n      args: this.options.cucumberArgs,\n      featureFiles,\n      jsonReport: this.jsonReport,\n      tags: this.getTags(this.nightwatchApi.nightwatchArgv.tag),\n      skipTags: this.getTags(this.nightwatchApi.nightwatchArgv.skiptags)\n    })\n    return yield * this.cucumberApi.run(cucumberArgs)\n  }\n\n  areColorsEnabled () {\n    const formatOptionsIndex = this.options.cucumberArgs.indexOf('--format-options')\n    if (formatOptionsIndex < 0) return true\n    const formatOptions = JSON.parse(this.options.cucumberArgs[formatOptionsIndex + 1])\n    return typeof formatOptions.colorsEnabled === 'undefined' ? true : formatOptions.colorsEnabled\n  }\n\n  run (options) {\n    const self = this\n    this.options = options\n    this.nightwatchApi = new NightwatchApi(options, this.areColorsEnabled())\n    this.cucumberApi = new CucumberApi(options)\n    this.jsonReport = this.cucumberApi.getJSONReportName(options.cucumberArgs)\n    this.featureFiles = this.cucumberApi.getFeatureFiles(options.cucumberArgs)\n    this.featureFiles\n      .map(this.getSourceFile)\n      .forEach((featureSource) => {\n        try {\n          fs.statSync(featureSource)\n        } catch (err) {\n          throw new Error(`Feature source ${featureSource} doesn't exists`)\n        }\n      })\n\n    // enforce relative paths so path.join() works on Windows\n    this.featureFiles = this.featureFiles.map((currentPath) => {\n      return path.isAbsolute(currentPath) ? path.relative(process.cwd(), currentPath) : currentPath\n    })\n\n    const dummyPaths = this.getFeatureDirectories().map(srcPath => path.join(dummyTestModulesFolder, srcPath))\n\n    this.generateDummyTestModules()\n\n    this.cucumberApi.injectTimeoutHandler()\n    this.cucumberApi.addAttachmentProvider(this.nightwatchApi.takeScreenshot.bind(this.nightwatchApi))\n\n    this.nightwatchApi.addTestModulePaths(dummyPaths)\n    this.nightwatchApi.addPathConverter(this.featurePathToDummyPath.bind(this), this.dummyPathToFeaturePath.bind(this))\n    this.nightwatchApi.overrideOriginalStartTestWorkers()\n    this.nightwatchApi.addTestRunner(this.executeTestModules.bind(this))\n    this.nightwatchApi.addHookAfterChildProcesses(function * () {\n      const reports = yield pify(glob)(self.addIndexToFileName(self.jsonReport, '*'))\n      yield * self.cucumberApi.mergeCucumberJsonReports(reports, self.jsonReport)\n    })\n  }\n}\n\n'nightwatch-cucumber/lib/index.js'\n:let runner\n\nmodule.exports = function (providedOptions) {\n  const options = Object.assign({\n    cucumberArgs: [\n      '--require', 'features/step_definitions',\n      '--format', 'json:reports/cucumber.json',\n      'features'\n    ],\n    nightwatchOutput: true\n  }, providedOptions)\n\n  const Runner = require('./runner')\n  runner = new Runner()\n  runner.run(options)\n}\n\nfunction getPageProxy (subPages) {\n  return new Proxy(() => getClientProxy(subPages), {\n    get: (target, pageName) => getPageProxy(subPages.concat([pageName]))\n  })\n}\n\nfunction getClientProxy (subPages) {\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (name !== 'page') {\n        const api = runner.nightwatchApi.getClientApi()\n\n        if (!subPages.length) {\n          return api[name]\n        }\n\n        return subPages.reduce((api, pageName) => {\n          return api[pageName]\n        }, api.page)()[name]\n      }\n\n      return getPageProxy([])\n    }\n  })\n}\n\nmodule.exports.client = getClientProxy([])\n\nmodule.exports.Section = new Proxy(function () {}, {\n  construct (target, args) {\n    return new runner.nightwatchApi.Section(...args)\n  }\n})\n\n",
        "called_code_segment": "this.nightwatchApi.addTestModulePaths(dummyPaths);",
        "invoking_code_segment": "this.nightwatchApi.addTestModulePaths(dummyPaths);",
        "new_file_code_segment": "function logTestModulePaths(paths) { console.log('Test module paths:', paths); }",
        "feature_description": "Add logging for test module paths to aid in debugging.",
        "detailed_feature_description": "The new feature involves adding logging for the test module paths. This will help in debugging by providing visibility into which paths are being added as test modules. The logging function will be implemented in a new file (#file 3) and invoked from both #file 1 and #file 2 where the test module paths are being added.",
        "modified_complete_code": {
            "#file 1": "// nightwatch-cucumber/lib/runner.js\n\nmodule.exports = class Runner {\n  // ...\n  run (options) {\n    // ...\n    const dummyPaths = this.getFeatureDirectories().map(srcPath => path.join(dummyTestModulesFolder, srcPath));\n    #Modify this.nightwatchApi.addTestModulePaths(dummyPaths);\n    #New logTestModulePaths(dummyPaths);\n    // ...\n  }\n}",
            "#file 2": "// nightwatch-cucumber/lib/index.js\n\nlet runner;\n\nmodule.exports = function (providedOptions) {\n  const options = Object.assign({\n    cucumberArgs: [\n      '--require', 'features/step_definitions',\n      '--format', 'json:reports/cucumber.json',\n      'features'\n    ],\n    nightwatchOutput: true\n  }, providedOptions);\n\n  const Runner = require('./runner');\n  runner = new Runner();\n  runner.run(options);\n}\n\nfunction getPageProxy (subPages) {\n  return new Proxy(() => getClientProxy(subPages), {\n    get: (target, pageName) => getPageProxy(subPages.concat([pageName]))\n  });\n}\n\nfunction getClientProxy (subPages) {\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (name !== 'page') {\n        const api = runner.nightwatchApi.getClientApi();\n\n        if (!subPages.length) {\n          return api[name];\n        }\n\n        return subPages.reduce((api, pageName) => {\n          return api[pageName];\n        }, api.page)()[name];\n      }\n\n      return getPageProxy([]);\n    }\n  });\n}\n\nmodule.exports.client = getClientProxy([]);\n\nmodule.exports.Section = new Proxy(function () {}, {\n  construct (target, args) {\n    return new runner.nightwatchApi.Section(...args);\n  }\n});\n\n#New function logTestModulePaths(paths) {\n  console.log('Test module paths:', paths);\n}",
            "#file 3": "// nightwatch-cucumber/lib/log-utils.js\n\n#New function logTestModulePaths(paths) {\n  console.log('Test module paths:', paths);\n}"
        }
    },
    {
        "repo": "nohost",
        "content": "'nohost/src/config.js'\n:'use strict';\n\nconst url = new URL(location);\n\n/**\n * Various features of the server can be configured by passing options on\n * the query string when registering the nohost-sw.js service worker file.\n * \n * `route`: `String` value with the route name to use when listening for filesystem\n * path requests. Defaults to `fs`, such that `/fs/path/to/file` would give\n * `/path/to/file`. If the `route` includes multiple levels, pass them on the\n * URL encoded (i.e., `'first%2Fsecond'` for `'/first/second'`).\n * \n * `disableIndexes`: if present (i.e., `Boolean`), directory indexes will not be shown.\n * Users will have to know the filename they wish to get back from the server.  Defaults\n * to `true` (i.e. directory indexes are shown).\n * \n * `directoryIndex`: `String` value used to override the default directory index\n * used when a filename isn't given. Defautls to `index.html`. For example,\n * `/fs/` would return `/fs/index.html` by default, or use another name if\n * specified.\n * \n * `debug`: if present (i.e., `Boolean`), enable workbox debug logging\n */\n\n/**\n * Given a route string, make sure it follows the pattern we expect:\n *  - no escaped characters\n *  - begins with a `/`\n *  - ends with a no trailing `/`\n * \n * If we were passed `'fs'`, we would normalize to `/fs` and\n * if we were passed `'first%2Fsecond'`, `'/first/second'`\n * \n * @param {String} route \n */\nfunction getNormalizeRoute() {\n  let route = url.searchParams.get('route') || 'fs';\n\n  // Only a single / at the front of the route\n  route = route.replace(/^\\/*/, '/');\n  // Only a single / at the end of the route\n  route = route.replace(/\\/*$/, '');\n\n  return route;\n}\n\nmodule.exports = {\n  route: getNormalizeRoute(),\n  disableIndexes: url.searchParams.get('disableIndexes') !== null,\n  directoryIndex: url.searchParams.get('route') || 'index.html',\n  debug: url.searchParams.get('debug') !== null\n};\n\n'nohost/src/nohost-sw.js'\n:const jsonFormatter = require('./json-formatter');\nconst htmlFormatter = require('./html-formatter');\nconst { serve } = require('./webserver');\nconst { debug, route } = require('./config');\n\n/* global workbox */\n// TODO: include this via package.json\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/4.1.1/workbox-sw.js');\n\nworkbox.setConfig({ debug });\n\n// Route with trailing slash (i.e., /path/into/filesystem)\nconst wwwRegex = new RegExp(`${route}(/.*)`);\n// Route minus the trailing slash\nconst wwwPartialRegex = new RegExp(`${route}$`);\n\nworkbox.routing.registerRoute(\n  wwwRegex,\n  ({ url }) => {\n    // Pull the filesystem path off the url \n    let path = url.pathname.match(wwwRegex)[1];\n    // Deal with encoding in the filename (e.g., spaces as %20)\n    path = decodeURI(path);\n\n    // Allow passing `?json` on URL to get back JSON vs. raw response\n    const formatter =\n      url.searchParams.get('json') !== null\n        ? jsonFormatter\n        : htmlFormatter;\n\n    // Allow passing `?download` or `dl` to have the file downloaded vs. displayed\n    const download =\n      url.searchParams.get('download') !== null ||\n      url.searchParams.get('dl') !== null;\n        \n    return serve(path, formatter, download);\n  },\n  'GET'\n);\n\n// Redirect if missing the / on our expected route\nworkbox.routing.registerRoute(\n  wwwPartialRegex,\n  ({ url }) => {\n    url.pathname = `${route}/`;\n    return Promise.resolve(Response.redirect(url, 302));\n  },\n  'GET'\n);\n\nworkbox.core.skipWaiting();\nworkbox.core.clientsClaim();\n\n",
        "called_code_segment": "function getNormalizeRoute() {\n  let route = url.searchParams.get('route') || 'fs';\n\n  // Only a single / at the front of the route\n  route = route.replace(/^\\/*/, '/');\n  // Only a single / at the end of the route\n  route = route.replace(/\\/*$/, '');\n\n  return route;\n}",
        "invoking_code_segment": "const { route, disableIndexes, directoryIndex, debug } = require('./config');",
        "new_file_code_segment": "function getCustomRoute() {\n  let route = url.searchParams.get('customRoute') || 'custom';\n\n  // Only a single / at the front of the route\n  route = route.replace(/^\\/*/, '/');\n  // Only a single / at the end of the route\n  route = route.replace(/\\/*$/, '');\n\n  return route;\n}",
        "feature_description": "Add support for a custom route parameter 'customRoute' to allow users to define a different route for serving files.",
        "detailed_feature_description": "The new feature allows users to specify a custom route using the 'customRoute' parameter in the URL. This custom route will be used instead of the default 'route' parameter. The new functionality is implemented in a new file (#file 3) and is invoked in both #file 1 and #file 2 to ensure compatibility and proper routing.",
        "modified_complete_code": {
            "#file 1": "// nohost/src/config.js\n'use strict';\n\nconst url = new URL(location);\n\n/**\n * Various features of the server can be configured by passing options on\n * the query string when registering the nohost-sw.js service worker file.\n * \n * `route`: `String` value with the route name to use when listening for filesystem\n * path requests. Defaults to `fs`, such that `/fs/path/to/file` would give\n * `/path/to/file`. If the `route` includes multiple levels, pass them on the\n * URL encoded (i.e., `'first%2Fsecond'` for `'/first/second'`).\n * \n * `disableIndexes`: if present (i.e., `Boolean`), directory indexes will not be shown.\n * Users will have to know the filename they wish to get back from the server.  Defaults\n * to `true` (i.e. directory indexes are shown).\n * \n * `directoryIndex`: `String` value used to override the default directory index\n * used when a filename isn't given. Defautls to `index.html`. For example,\n * `/fs/` would return `/fs/index.html` by default, or use another name if\n * specified.\n * \n * `debug`: if present (i.e., `Boolean`), enable workbox debug logging\n */\n\n/**\n * Given a route string, make sure it follows the pattern we expect:\n *  - no escaped characters\n *  - begins with a `/`\n *  - ends with a no trailing `/`\n * \n * If we were passed `'fs'`, we would normalize to `/fs` and\n * if we were passed `'first%2Fsecond'`, `'/first/second`\n * \n * @param {String} route \n */\nfunction getNormalizeRoute() {\n  let route = url.searchParams.get('route') || 'fs';\n\n  // Only a single / at the front of the route\n  route = route.replace(/^\\/*/, '/');\n  // Only a single / at the end of the route\n  route = route.replace(/\\/*$/, '');\n\n  return route;\n}\n\n#Modify function getCustomRoute() {\n  let route = url.searchParams.get('customRoute') || 'custom';\n\n  // Only a single / at the front of the route\n  route = route.replace(/^\\/*/, '/');\n  // Only a single / at the end of the route\n  route = route.replace(/\\/*$/, '');\n\n  return route;\n}\n\nmodule.exports = {\n  route: getNormalizeRoute(),\n  disableIndexes: url.searchParams.get('disableIndexes') !== null,\n  directoryIndex: url.searchParams.get('route') || 'index.html',\n  debug: url.searchParams.get('debug') !== null,\n  #New customRoute: getCustomRoute()\n};",
            "#file 2": "const jsonFormatter = require('./json-formatter');\nconst htmlFormatter = require('./html-formatter');\nconst { serve } = require('./webserver');\nconst { debug, route, #New customRoute } = require('./config');\n\n/* global workbox */\n// TODO: include this via package.json\nimportScripts('https://storage.googleapis.com/workbox-cdn/releases/4.1.1/workbox-sw.js');\n\nworkbox.setConfig({ debug });\n\n// Route with trailing slash (i.e., /path/into/filesystem)\nconst wwwRegex = new RegExp(`${route}(/.*)`);\n// Route minus the trailing slash\nconst wwwPartialRegex = new RegExp(`${route}$`);\n\n#Modify const customRegex = new RegExp(`${customRoute}(/.*)`);\n\nworkbox.routing.registerRoute(\n  wwwRegex,\n  ({ url }) => {\n    // Pull the filesystem path off the url \n    let path = url.pathname.match(wwwRegex)[1];\n    // Deal with encoding in the filename (e.g., spaces as %20)\n    path = decodeURI(path);\n\n    // Allow passing `?json` on URL to get back JSON vs. raw response\n    const formatter =\n      url.searchParams.get('json') !== null\n        ? jsonFormatter\n        : htmlFormatter;\n\n    // Allow passing `?download` or `dl` to have the file downloaded vs. displayed\n    const download =\n      url.searchParams.get('download') !== null ||\n      url.searchParams.get('dl') !== null;\n         \n    return serve(path, formatter, download);\n  },\n  'GET'\n);\n\n#New workbox.routing.registerRoute(\n  customRegex,\n  ({ url }) => {\n    // Pull the filesystem path off the url \n    let path = url.pathname.match(customRegex)[1];\n    // Deal with encoding in the filename (e.g., spaces as %20)\n    path = decodeURI(path);\n\n    // Allow passing `?json` on URL to get back JSON vs. raw response\n    const formatter =\n      url.searchParams.get('json') !== null\n        ? jsonFormatter\n        : htmlFormatter;\n\n    // Allow passing `?download` or `dl` to have the file downloaded vs. displayed\n    const download =\n      url.searchParams.get('download') !== null ||\n      url.searchParams.get('dl') !== null;\n         \n    return serve(path, formatter, download);\n  },\n  'GET'\n);\n\n// Redirect if missing the / on our expected route\nworkbox.routing.registerRoute(\n  wwwPartialRegex,\n  ({ url }) => {\n    url.pathname = `${route}/`;\n    return Promise.resolve(Response.redirect(url, 302));\n  },\n  'GET'\n);\n\nworkbox.core.skipWaiting();\nworkbox.core.clientsClaim();",
            "#file 3": "// nohost/src/custom-route.js\n'use strict';\n\nconst url = new URL(location);\n\nfunction getCustomRoute() {\n  let route = url.searchParams.get('customRoute') || 'custom';\n\n  // Only a single / at the front of the route\n  route = route.replace(/^\\/*/, '/');\n  // Only a single / at the end of the route\n  route = route.replace(/\\/*$/, '');\n\n  return route;\n}\n\nmodule.exports = {\n  getCustomRoute\n};"
        }
    },
    {
        "repo": "puppeteer-page-proxy",
        "content": "'puppeteer-page-proxy/src/core/proxy.js'\n:const got = require(\"got\");\nconst CookieHandler = require(\"../lib/cookies\");\nconst {setHeaders, setAgent} = require(\"../lib/options\");\nconst type = require(\"../util/types\");\n\n// Responsible for applying proxy\nconst requestHandler = async (request, proxy, overrides = {}) => {\n    // Reject non http(s) URI schemes\n    if (!request.url().startsWith(\"http\") && !request.url().startsWith(\"https\")) {\n        request.continue(); return;\n    }\n    const cookieHandler = new CookieHandler(request);\n    // Request options for GOT accounting for overrides\n    const options = {\n        cookieJar: await cookieHandler.getCookies(),\n        method: overrides.method || request.method(),\n        body: overrides.postData || request.postData(),\n        headers: overrides.headers || setHeaders(request),\n        agent: setAgent(proxy),\n        responseType: \"buffer\",\n        maxRedirects: 15,\n        throwHttpErrors: false,\n        ignoreInvalidCookies: true,\n        followRedirect: false\n    };\n    try {\n        const response = await got(overrides.url || request.url(), options);\n        // Set cookies manually because \"set-cookie\" doesn't set all cookies (?)\n        // Perhaps related to https://github.com/puppeteer/puppeteer/issues/5364\n        const setCookieHeader = response.headers[\"set-cookie\"];\n        if (setCookieHeader) {\n            await cookieHandler.setCookies(setCookieHeader);\n            response.headers[\"set-cookie\"] = undefined;\n        }\n        await request.respond({\n            status: response.statusCode,\n            headers: response.headers,\n            body: response.body\n        });\n    } catch (error) {\n        await request.abort();\n    }\n};\n\n// For reassigning proxy of page\nconst removeRequestListener = (page, listenerName) => {\n    const eventName = \"request\";\n    const listeners = page.eventsMap.get(eventName);\n    if (listeners) {\n        const i = listeners.findIndex((listener) => {\n            return listener.name === listenerName\n        });\n        listeners.splice(i, 1);\n        if (!listeners.length) {\n            page.eventsMap.delete(eventName);\n        }\n    }\n};\n\nconst useProxyPer = {\n    // Call this if request object passed\n    HTTPRequest: async (request, data) => {\n        let proxy, overrides;\n        // Separate proxy and overrides\n        if (type(data) === \"object\") {\n            if (Object.keys(data).length !== 0) {\n                proxy = data.proxy;\n                delete data.proxy;\n                overrides = data;\n            }\n        } else {proxy = data}\n        // Skip request if proxy omitted\n        if (proxy) {await requestHandler(request, proxy, overrides)}\n        else {request.continue(overrides)}\n    },\n\n    // Call this if page object passed\n    CDPPage: async (page, proxy) => {\n        await page.setRequestInterception(true);\n        const listener = \"$ppp_requestListener\";\n        removeRequestListener(page, listener);\n        const f = {[listener]: async (request) => {\n            await requestHandler(request, proxy);\n        }};\n        if (proxy) {page.on(\"request\", f[listener])}\n        else {await page.setRequestInterception(false)}\n    }\n}\n\n// Main function\nconst useProxy = async (target, data) => {\n    useProxyPer[target.constructor.name](target, data);\n};\n\nmodule.exports = useProxy;\n'puppeteer-page-proxy/src/index.js'\n:module.exports = require(\"./core/proxy\");\nmodule.exports.lookup = require(\"./core/lookup\");\n",
        "called_code_segment": "const requestHandler = async (request, proxy, overrides = {}) => {\n    // Reject non http(s) URI schemes\n    if (!request.url().startsWith(\"http\") && !request.url().startsWith(\"https\")) {\n        request.continue(); return;\n    }\n    const cookieHandler = new CookieHandler(request);\n    // Request options for GOT accounting for overrides\n    const options = {\n        cookieJar: await cookieHandler.getCookies(),\n        method: overrides.method || request.method(),\n        body: overrides.postData || request.postData(),\n        headers: overrides.headers || setHeaders(request),\n        agent: setAgent(proxy),\n        responseType: \"buffer\",\n        maxRedirects: 15,\n        throwHttpErrors: false,\n        ignoreInvalidCookies: true,\n        followRedirect: false\n    };\n    try {\n        const response = await got(overrides.url || request.url(), options);\n        // Set cookies manually because \"set-cookie\" doesn't set all cookies (?)\n        // Perhaps related to https://github.com/puppeteer/puppeteer/issues/5364\n        const setCookieHeader = response.headers[\"set-cookie\"];\n        if (setCookieHeader) {\n            await cookieHandler.setCookies(setCookieHeader);\n            response.headers[\"set-cookie\"] = undefined;\n        }\n        await request.respond({\n            status: response.statusCode,\n            headers: response.headers,\n            body: response.body\n        });\n    } catch (error) {\n        await request.abort();\n    }\n};",
        "invoking_code_segment": "const useProxyPer = {\n    // Call this if request object passed\n    HTTPRequest: async (request, data) => {\n        let proxy, overrides;\n        // Separate proxy and overrides\n        if (type(data) === \"object\") {\n            if (Object.keys(data).length !== 0) {\n                proxy = data.proxy;\n                delete data.proxy;\n                overrides = data;\n            }\n        } else {proxy = data}\n        // Skip request if proxy omitted\n        if (proxy) {await requestHandler(request, proxy, overrides)}\n        else {request.continue(overrides)}\n    },\n\n    // Call this if page object passed\n    CDPPage: async (page, proxy) => {\n        await page.setRequestInterception(true);\n        const listener = \"$ppp_requestListener\";\n        removeRequestListener(page, listener);\n        const f = {[listener]: async (request) => {\n            await requestHandler(request, proxy);\n        }};\n        if (proxy) {page.on(\"request\", f[listener])}\n        else {await page.setRequestInterception(false)}\n    }\n}",
        "new_file_code_segment": "const logRequest = (request, proxy) => {\n    console.log(`Request to ${request.url()} via proxy ${proxy}`);\n};\n\nmodule.exports = logRequest;",
        "feature_description": "Add logging for each request made through the proxy.",
        "detailed_feature_description": "A new function `logRequest` is added in #file 3 to log each request made through the proxy. This function is invoked in #file 1 within the `requestHandler` function to log the request details. The `requestHandler` function in #file 1 is invoked by the `useProxyPer` object in #file 2, ensuring that the logging feature is integrated seamlessly.",
        "modified_complete_code": {
            "#file 1": "const got = require(\"got\");\nconst CookieHandler = require(\"../lib/cookies\");\nconst {setHeaders, setAgent} = require(\"../lib/options\");\nconst type = require(\"../util/types\");\nconst logRequest = require(\"./logRequest\"); //New\n\n// Responsible for applying proxy\nconst requestHandler = async (request, proxy, overrides = {}) => {\n    // Reject non http(s) URI schemes\n    if (!request.url().startsWith(\"http\") && !request.url().startsWith(\"https\")) {\n        request.continue(); return;\n    }\n    const cookieHandler = new CookieHandler(request);\n    // Request options for GOT accounting for overrides\n    const options = {\n        cookieJar: await cookieHandler.getCookies(),\n        method: overrides.method || request.method(),\n        body: overrides.postData || request.postData(),\n        headers: overrides.headers || setHeaders(request),\n        agent: setAgent(proxy),\n        responseType: \"buffer\",\n        maxRedirects: 15,\n        throwHttpErrors: false,\n        ignoreInvalidCookies: true,\n        followRedirect: false\n    };\n    try {\n        logRequest(request, proxy); //Modify\n        const response = await got(overrides.url || request.url(), options);\n        // Set cookies manually because \"set-cookie\" doesn't set all cookies (?)\n        // Perhaps related to https://github.com/puppeteer/puppeteer/issues/5364\n        const setCookieHeader = response.headers[\"set-cookie\"];\n        if (setCookieHeader) {\n            await cookieHandler.setCookies(setCookieHeader);\n            response.headers[\"set-cookie\"] = undefined;\n        }\n        await request.respond({\n            status: response.statusCode,\n            headers: response.headers,\n            body: response.body\n        });\n    } catch (error) {\n        await request.abort();\n    }\n};",
            "#file 2": "const useProxyPer = {\n    // Call this if request object passed\n    HTTPRequest: async (request, data) => {\n        let proxy, overrides;\n        // Separate proxy and overrides\n        if (type(data) === \"object\") {\n            if (Object.keys(data).length !== 0) {\n                proxy = data.proxy;\n                delete data.proxy;\n                overrides = data;\n            }\n        } else {proxy = data}\n        // Skip request if proxy omitted\n        if (proxy) {await requestHandler(request, proxy, overrides)}\n        else {request.continue(overrides)}\n    },\n\n    // Call this if page object passed\n    CDPPage: async (page, proxy) => {\n        await page.setRequestInterception(true);\n        const listener = \"$ppp_requestListener\";\n        removeRequestListener(page, listener);\n        const f = {[listener]: async (request) => {\n            await requestHandler(request, proxy);\n        }};\n        if (proxy) {page.on(\"request\", f[listener])}\n        else {await page.setRequestInterception(false)}\n    }\n}\n\n// Main function\nconst useProxy = async (target, data) => {\n    useProxyPer[target.constructor.name](target, data);\n};\n\nmodule.exports = useProxy;",
            "#file 3": "const logRequest = (request, proxy) => {\n    console.log(`Request to ${request.url()} via proxy ${proxy}`);\n};\n\nmodule.exports = logRequest;"
        }
    },
    {
        "repo": "react-breadcrumbs",
        "content": "'react-breadcrumbs/src/store.js'\n:// Import External Dependencies\nimport { createStore } from 'redux'\n\n// Create the reducer\nlet crumbs = (state = [], action) => {\n    switch (action.type) {\n        case 'ADD_CRUMB':\n            return [\n                ...state,\n                action.payload\n            ]\n\n        case 'UPDATE_CRUMB':\n            return state.map(crumb => {\n                return crumb.id === action.payload.id ? action.payload : crumb\n            })\n\n        case 'REMOVE_CRUMB':\n            return state.filter(crumb => {\n                return crumb.id !== action.payload.id\n            })\n\n        default: \n            return state\n    }\n}\n\n// Create the store\nlet store = createStore(crumbs)\n\n// Export store and Dispatch method\nexport default store\nexport var Dispatch = store.dispatch\n\n'react-breadcrumbs/src/breadcrumb.jsx'\n:// Import External Dependencies\nimport React from 'react'\nimport PropTypes from 'prop-types'\nimport UUID from 'uuid'\nimport IsEqual from 'lodash.isequal'\n\n// Import Utilities\nimport { Dispatch } from './store'\n\n// Create and export the component\nexport default class Breadcrumb extends React.Component {\n\tstatic propTypes = {\n\t\tdata: PropTypes.object.isRequired,\n\t\thidden: PropTypes.bool,\n\t\tchildren: PropTypes.element\n\t}\n\n\tstatic defaultProps = {\n\t\thidden: false,\n\t\tchildren: null\n\t}\n\n\tstate = {\n\t\tid: UUID.v4()\n\t}\n\n\trender() {\n\t\treturn this.props.children\n\t}\n\n\tcomponentDidMount() {\n\t\tlet { data, hidden } = this.props\n\n\t\tif ( !hidden ) this._dispatch('ADD_CRUMB', data)\n\t}\n\n\tcomponentWillReceiveProps(nextProps) {\n\t\tlet { data, hidden } = nextProps\n\n\t\t// Update the crumb if its data has changed\n\t\tif ( !IsEqual(data, this.props.data) ) {\n\t\t\tthis._dispatch('UPDATE_CRUMB', data)\n\t\t}\n\n\t\t// Remove/add crumb based on `hidden` prop\n\t\tif ( hidden && !this.props.hidden ) {\n\t\t\tthis._dispatch('REMOVE_CRUMB', data)\n\t\t\t\n\t\t} else if ( !hidden && this.props.hidden ) {\n\t\t\tthis._dispatch('ADD_CRUMB', data)\n\t\t}\n\t}\n\n\tcomponentWillUnmount() {\n\t\tthis._dispatch(\n\t\t\t'REMOVE_CRUMB',\n\t\t\tthis.props.data\n\t\t)\n\t}\n\n\t/**\n\t * Dispatch the given `action`\n\t * \n\t * @param  {string} action - A valid action name accepted by the store\n\t * @param  {object} data   - The breadcrumb data to pass\n\t */\n\t_dispatch(action, data) {\n\t\tlet { id } = this.state\n\n\t\tDispatch({\n\t\t\ttype: action,\n\t\t\tpayload: { id, ...data }\n\t\t})\n\t}\n}\n\n",
        "called_code_segment": "let store = createStore(crumbs)\nexport default store\nexport var Dispatch = store.dispatch",
        "invoking_code_segment": "import { Dispatch } from './store'\n\n_dispatch(action, data) {\n    let { id } = this.state\n\n    Dispatch({\n        type: action,\n        payload: { id, ...data }\n    })\n}",
        "new_file_code_segment": "export const logAction = (action, payload) => {\n    console.log(`Action: ${action}, Payload:`, payload)\n}",
        "feature_description": "Add logging for dispatched actions.",
        "detailed_feature_description": "The new feature involves adding logging functionality to the dispatch actions. This will help in debugging and tracking the actions being dispatched. The logging function will be implemented in a new file (#file 3) and will be invoked from both #file 1 and #file 2 to log the dispatched actions.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { logAction } from './logger'\n\nlet store = createStore(crumbs)\nstore.subscribe(() => {\n    logAction('STATE_CHANGE', store.getState())\n})\nexport default store\nexport var Dispatch = store.dispatch",
            "#file 2": "//Modify\nimport { Dispatch, logAction } from './store'\n\n_dispatch(action, data) {\n    let { id } = this.state\n\n    Dispatch({\n        type: action,\n        payload: { id, ...data }\n    })\n    logAction(action, { id, ...data })\n}",
            "#file 3": "//New\nexport const logAction = (action, payload) => {\n    console.log(`Action: ${action}, Payload:`, payload)\n}"
        }
    },
    {
        "repo": "react-es6-webpack-boilerplate",
        "content": "'react-es6-webpack-boilerplate/scripts/App.js'\n:import React, { Component } from 'react';\n\nexport default class App extends Component {\n  render() {\n    return (\n      // Add your component markup and other subcomponent references here.\n      <h1>Hello, World!</h1>\n    );\n  }\n}\n\n'react-es6-webpack-boilerplate/scripts/index.js'\n:import React from 'react';\nimport { render } from 'react-dom';\nimport App from './App';\n\nrender(\n  <App />,\n  document.getElementById('root')\n);\n\n",
        "called_code_segment": "export default class App extends Component {\n  render() {\n    return (\n      <h1>Hello, World!</h1>\n    );\n  }\n}",
        "invoking_code_segment": "render(\n  <App />,\n  document.getElementById('root')\n);",
        "new_file_code_segment": "export const greetUser = (name) => {\n  return `Hello, ${name}!`;\n}",
        "feature_description": "Add a greeting message with a user's name.",
        "detailed_feature_description": "The new feature involves modifying the App component in #file 1 to accept a prop for the user's name and display a personalized greeting. A new utility function `greetUser` is created in #file 3 to handle the greeting message formatting. This function is then imported and used in both #file 1 and #file 2 to ensure the greeting message is correctly displayed.",
        "modified_complete_code": {
            "#file 1": "import React, { Component } from 'react';\nimport { greetUser } from './greetUser'; //New\n\n#Modify export default class App extends Component {\n  render() {\n    const { name } = this.props; //New\n    return (\n      <h1>{greetUser(name)}</h1> //Modify\n    );\n  }\n}",
            "#file 2": "import React from 'react';\nimport { render } from 'react-dom';\nimport App from './App';\nimport { greetUser } from './greetUser'; //New\n\n#Modify render(\n  <App name='World' />, //Modify\n  document.getElementById('root')\n);",
            "#file 3": "export const greetUser = (name) => {\n  return `Hello, ${name}!`;\n}"
        }
    },
    {
        "repo": "react-flask-app",
        "content": "'react-flask-app/src/App.js'\n:import React, { useState, useEffect } from 'react';\nimport { BrowserRouter, Link, Switch, Route } from 'react-router-dom';\nimport logo from './logo.svg';\nimport './App.css';\n\nfunction App() {\n  const [currentTime, setCurrentTime] = useState(0);\n\n  useEffect(() => {\n    fetch('/api/time').then(res => res.json()).then(data => {\n      setCurrentTime(data.time);\n    });\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <BrowserRouter>\n          <div>\n            <Link className=\"App-link\" to=\"/\">Home</Link>\n            &nbsp;|&nbsp;\n            <Link className=\"App-link\" to=\"/page2\">Page2</Link>\n          </div>\n          <Switch>\n            <Route exact path=\"/\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\n                <p>\n                  Edit <code>src/App.js</code> and save to reload.\n                </p>\n                <a\n                  className=\"App-link\"\n                  href=\"https://reactjs.org\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                >\n                  Learn React\n                </a>\n                <p>The current time is {currentTime}.</p>\n            </Route>\n            <Route path=\"/page2\">\n                <p>This is page 2!</p>\n            </Route>\n          </Switch>\n        </BrowserRouter>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n\n'react-flask-app/src/App.test.js'\n:import React from 'react';\nimport { render } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  const { getByText } = render(<App />);\n  const linkElement = getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n\n",
        "called_code_segment": "const [currentTime, setCurrentTime] = useState(0);\n\nuseEffect(() => {\n  fetch('/api/time').then(res => res.json()).then(data => {\n    setCurrentTime(data.time);\n  });\n}, []);",
        "invoking_code_segment": "<p>The current time is {currentTime}.</p>",
        "new_file_code_segment": "export function fetchCurrentTime() {\n  return fetch('/api/time').then(res => res.json()).then(data => data.time);\n}",
        "feature_description": "Add a function to fetch the current time from the API and use it in both the main App component and the Page2 component.",
        "detailed_feature_description": "The new feature involves creating a utility function in a new file (#file 3) that fetches the current time from the API. This function is then imported and used in both the main App component (#file 1) and the Page2 component (#file 2). This ensures that the fetching logic is centralized and can be reused across different parts of the application.",
        "modified_complete_code": {
            "#file 1": "import React, { useState, useEffect } from 'react';\nimport { BrowserRouter, Link, Switch, Route } from 'react-router-dom';\nimport logo from './logo.svg';\nimport './App.css';\nimport { fetchCurrentTime } from './utils'; // #New\n\nfunction App() {\n  const [currentTime, setCurrentTime] = useState(0);\n\n  useEffect(() => {\n    fetchCurrentTime().then(time => setCurrentTime(time)); // #Modify\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <BrowserRouter>\n          <div>\n            <Link className=\"App-link\" to=\"/\">Home</Link>\n            &nbsp;|&nbsp;\n            <Link className=\"App-link\" to=\"/page2\">Page2</Link>\n          </div>\n          <Switch>\n            <Route exact path=\"/\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\n                <p>\n                  Edit <code>src/App.js</code> and save to reload.\n                </p>\n                <a\n                  className=\"App-link\"\n                  href=\"https://reactjs.org\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                >\n                  Learn React\n                </a>\n                <p>The current time is {currentTime}.</p>\n            </Route>\n            <Route path=\"/page2\">\n                <Page2 />\n            </Route>\n          </Switch>\n        </BrowserRouter>\n      </header>\n    </div>\n  );\n}\n\nexport default App;",
            "#file 2": "import React, { useState, useEffect } from 'react';\nimport { fetchCurrentTime } from './utils'; // #New\n\nfunction Page2() {\n  const [currentTime, setCurrentTime] = useState(0);\n\n  useEffect(() => {\n    fetchCurrentTime().then(time => setCurrentTime(time)); // #Modify\n  }, []);\n\n  return (\n    <div>\n      <p>This is page 2!</p>\n      <p>The current time is {currentTime}.</p>\n    </div>\n  );\n}\n\nexport default Page2;",
            "#file 3": "export function fetchCurrentTime() {\n  return fetch('/api/time').then(res => res.json()).then(data => data.time);\n}"
        }
    },
    {
        "repo": "react-hooks-axios",
        "content": "'react-hooks-axios/example/App.jsx'\n:import React, { useState } from 'react';\n\nimport useAxios from '../src';\n\nexport default function App() {\n  const [gender, setGender] = useState('');\n  const { response, loading, error, reFetch } = useAxios({\n    url: `https://randomuser.me/api/${gender === 'unknown' ? 'unknown' : ''}`,\n    method: 'GET',\n    options: {\n      params: { gender },\n    },\n    trigger: gender,\n    // or\n    // trigger: { gender }\n    forceDispatchEffect: () => !!gender, // AUTO RUN only if gender is set\n  });\n\n  const { data } = response || {};\n\n  const options = [\n    { gender: 'female', title: 'Female' },\n    { gender: 'male', title: 'Male' },\n    { gender: 'unknown', title: 'Unknown' },\n  ];\n\n  if (loading) return 'loading...';\n  return (\n    <div>\n      <h2>\n        DEMO of\n        <span style={{ color: '#F44336' }}>@use-hooks/axios</span>\n      </h2>\n      {options.map(item => (\n        <div key={item.gender}>\n          <input\n            type=\"radio\"\n            id={item.gender}\n            value={item.gender}\n            checked={gender === item.gender}\n            onChange={e => setGender(e.target.value)}\n          />\n          {item.title}\n        </div>\n      ))}\n      <button type=\"button\" onClick={reFetch}>\n        Refresh\n      </button>\n      <div>\n        {error ? (\n          error.message || 'error'\n        ) : (\n          <textarea\n            cols=\"100\"\n            rows=\"30\"\n            defaultValue={JSON.stringify(data || {}, '', 2)}\n          />\n        )}\n      </div>\n    </div>\n  );\n}\n\n'react-hooks-axios/example/index.jsx'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('app'));\n\nif (module.hot) {\n  module.hot.accept();\n}\n\n",
        "called_code_segment": "export default function App() { ... }",
        "invoking_code_segment": "ReactDOM.render(<App />, document.getElementById('app'));",
        "new_file_code_segment": "export function fetchUserDetails(gender) { return fetch(`https://randomuser.me/api/${gender === 'unknown' ? 'unknown' : ''}?gender=${gender}`).then(response => response.json()); }",
        "feature_description": "Add a new function to fetch user details based on gender.",
        "detailed_feature_description": "A new function `fetchUserDetails` is added in #file 3 to handle fetching user details based on the gender selected. This function is then used in #file 1 to replace the direct API call within the `useAxios` hook. The `reFetch` function in #file 1 is updated to use this new function. #file 2 remains unchanged as it only renders the App component.",
        "modified_complete_code": {
            "#file 1": "import React, { useState } from 'react';\nimport useAxios from '../src';\nimport { fetchUserDetails } from './fetchUserDetails'; // #New\n\nexport default function App() {\n  const [gender, setGender] = useState('');\n  const { response, loading, error, reFetch } = useAxios({\n    url: `https://randomuser.me/api/${gender === 'unknown' ? 'unknown' : ''}`,\n    method: 'GET',\n    options: { params: { gender } },\n    trigger: gender,\n    forceDispatchEffect: () => !!gender\n  });\n\n  const { data } = response || {};\n\n  const options = [\n    { gender: 'female', title: 'Female' },\n    { gender: 'male', title: 'Male' },\n    { gender: 'unknown', title: 'Unknown' }\n  ];\n\n  if (loading) return 'loading...';\n  return (\n    <div>\n      <h2>\n        DEMO of\n        <span style={{ color: '#F44336' }}>@use-hooks/axios</span>\n      </h2>\n      {options.map(item => (\n        <div key={item.gender}>\n          <input\n            type=\"radio\"\n            id={item.gender}\n            value={item.gender}\n            checked={gender === item.gender}\n            onChange={e => setGender(e.target.value)}\n          />\n          {item.title}\n        </div>\n      ))}\n      <button type=\"button\" onClick={() => fetchUserDetails(gender).then(data => reFetch({ response: { data } }))}> // #Modify\n        Refresh\n      </button>\n      <div>\n        {error ? (\n          error.message || 'error'\n        ) : (\n          <textarea\n            cols=\"100\"\n            rows=\"30\"\n            defaultValue={JSON.stringify(data || {}, '', 2)}\n          />\n        )}\n      </div>\n    </div>\n  );\n}",
            "#file 2": "import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('app'));\n\nif (module.hot) {\n  module.hot.accept();\n}",
            "#file 3": "export function fetchUserDetails(gender) {\n  return fetch(`https://randomuser.me/api/${gender === 'unknown' ? 'unknown' : ''}?gender=${gender}`).then(response => response.json());\n}"
        }
    },
    {
        "repo": "react-mixin",
        "content": "'react-mixin/toUnsafe.js'\n:var objectAssign = require('object-assign');\n\nfunction toUnsafe(mixin) {\n  var mixin2 = objectAssign({}, mixin);\n\n  if (mixin2.componentWillMount) {\n    mixin2.UNSAFE_componentWillMount = mixin2.componentWillMount;\n    delete mixin2.componentWillMount;\n  }\n\n  if (mixin2.componentWillReceiveProps) {\n    mixin2.UNSAFE_componentWillReceiveProps = mixin2.componentWillReceiveProps;\n    delete mixin2.componentWillReceiveProps;\n  }\n\n  if (mixin2.componentWillUpdate) {\n    mixin2.UNSAFE_componentWillUpdate = mixin2.componentWillUpdate;\n    delete mixin2.componentWillUpdate;\n  }\n\n  return mixin2;\n}\n\nmodule.exports = toUnsafe;\n\n'react-mixin/test/toUnsafe.test.js'\n:const toUnsafe = require('../toUnsafe');\nvar expect = require('expect.js');\n\nit(`works`, () => {\n  const a = () => {};\n  const b = () => {};\n  const c = () => {};\n\n  const m1 = { componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c};\n  const m2 = toUnsafe(m1);\n\n  console.log(m1)\n  expect(m1).to.eql({ componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c}, 'm1 not modified');\n  expect(m2).to.eql({ UNSAFE_componentWillMount: a, UNSAFE_componentWillReceiveProps: b, UNSAFE_componentWillUpdate: c});\n  expect(Object.keys(m2).sort()).to.eql(['UNSAFE_componentWillMount', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'])\n})\n\n",
        "called_code_segment": "function toUnsafe(mixin) {\n  var mixin2 = objectAssign({}, mixin);\n\n  if (mixin2.componentWillMount) {\n    mixin2.UNSAFE_componentWillMount = mixin2.componentWillMount;\n    delete mixin2.componentWillMount;\n  }\n\n  if (mixin2.componentWillReceiveProps) {\n    mixin2.UNSAFE_componentWillReceiveProps = mixin2.componentWillReceiveProps;\n    delete mixin2.componentWillReceiveProps;\n  }\n\n  if (mixin2.componentWillUpdate) {\n    mixin2.UNSAFE_componentWillUpdate = mixin2.componentWillUpdate;\n    delete mixin2.componentWillUpdate;\n  }\n\n  return mixin2;\n}",
        "invoking_code_segment": "const m1 = { componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c};\nconst m2 = toUnsafe(m1);",
        "new_file_code_segment": "function logDeprecatedWarning(methodName) {\n  console.warn(`Warning: ${methodName} is deprecated and has been replaced with its UNSAFE_ counterpart.`);\n}\n\nmodule.exports = logDeprecatedWarning;",
        "feature_description": "Add logging for deprecated lifecycle methods.",
        "detailed_feature_description": "The new feature adds logging to warn developers when deprecated lifecycle methods are used. This is implemented by creating a new function `logDeprecatedWarning` in a new file (#file 3). This function logs a warning message to the console indicating that the method is deprecated. The `toUnsafe` function in #file 1 is updated to call this new function whenever a deprecated method is encountered. The test file (#file 2) remains unchanged as it does not need to invoke the new logging functionality directly.",
        "modified_complete_code": {
            "#file 1": "var objectAssign = require('object-assign');\nconst logDeprecatedWarning = require('./logDeprecatedWarning'); //New\n\nfunction toUnsafe(mixin) {\n  var mixin2 = objectAssign({}, mixin);\n\n  if (mixin2.componentWillMount) {\n    logDeprecatedWarning('componentWillMount'); //Modify\n    mixin2.UNSAFE_componentWillMount = mixin2.componentWillMount;\n    delete mixin2.componentWillMount;\n  }\n\n  if (mixin2.componentWillReceiveProps) {\n    logDeprecatedWarning('componentWillReceiveProps'); //Modify\n    mixin2.UNSAFE_componentWillReceiveProps = mixin2.componentWillReceiveProps;\n    delete mixin2.componentWillReceiveProps;\n  }\n\n  if (mixin2.componentWillUpdate) {\n    logDeprecatedWarning('componentWillUpdate'); //Modify\n    mixin2.UNSAFE_componentWillUpdate = mixin2.componentWillUpdate;\n    delete mixin2.componentWillUpdate;\n  }\n\n  return mixin2;\n}\n\nmodule.exports = toUnsafe;",
            "#file 2": "const toUnsafe = require('../toUnsafe');\nvar expect = require('expect.js');\n\nit(`works`, () => {\n  const a = () => {};\n  const b = () => {};\n  const c = () => {};\n\n  const m1 = { componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c};\n  const m2 = toUnsafe(m1);\n\n  console.log(m1)\n  expect(m1).to.eql({ componentWillMount: a, componentWillReceiveProps: b, componentWillUpdate: c}, 'm1 not modified');\n  expect(m2).to.eql({ UNSAFE_componentWillMount: a, UNSAFE_componentWillReceiveProps: b, UNSAFE_componentWillUpdate: c});\n  expect(Object.keys(m2).sort()).to.eql(['UNSAFE_componentWillMount', 'UNSAFE_componentWillReceiveProps', 'UNSAFE_componentWillUpdate'])\n})",
            "#file 3": "function logDeprecatedWarning(methodName) {\n  console.warn(`Warning: ${methodName} is deprecated and has been replaced with its UNSAFE_ counterpart.`);\n}\n\nmodule.exports = logDeprecatedWarning;"
        }
    },
    {
        "repo": "reddit-clone",
        "content": "'reddit-clone/backend/src/routers/comments.js'\n:const express = require('express')\n\nconst { query } = require('../db')\n\nconst { updateTableRow, userIsModerator } = require('../db/utils')\n\nconst auth = require('../middleware/auth')()\n\nconst optionalAuth = require('../middleware/auth')(true)\n\n\n\nconst router = express.Router()\n\n\n\nconst selectCommentStatement = `\n\n  select c.id, c.author_id, c.post_id, c.parent_comment_id, sr.name subreddit_name\n\n  from comments c\n\n  inner join posts p on c.post_id = p.id\n\n  inner join subreddits sr on p.subreddit_id = sr.id\n\n  where c.id = $1\n\n`\n\n\n\nconst selectAllCommentsStatement = `\n\n  select\n\n  c.id, c.body, c.post_id, c.parent_comment_id, c.created_at, c.updated_at,\n\n  max(u.username) author_name,\n\n  cast(coalesce(sum(cv.vote_value), 0) as int) votes,\n\n  max(ucv.vote_value) has_voted\n\n  from comments c\n\n  left join users u on c.author_id = u.id\n\n  left join comment_votes cv on c.id = cv.comment_id\n\n  left join comment_votes ucv on ucv.comment_id = c.id and ucv.user_id = $1\n\n  group by c.id\n\n`\n\n\n\nrouter.get('/', async (req, res) => {\n\n  try {\n\n    const selectCommentsStatement = `select * from comments`\n\n    const { rows } = await query(selectCommentsStatement)\n\n    res.send(rows)\n\n  } catch (e) {\n\n    res.status(500).send({ error: e.message })\n\n  }\n\n})\n\n\n\nrouter.get('/:post_id', optionalAuth, async (req, res) => {\n\n  try {\n\n    const { post_id } = req.params\n\n    const selectPostStatement = `\n\n      select\n\n      p.id, p.type, p.title, p.body, p.created_at, p.updated_at,\n\n      max(u.username) author_name,\n\n      cast(coalesce(sum(pv.vote_value), 0) as int) votes,\n\n      max(upv.vote_value) has_voted,\n\n      max(sr.name) subreddit_name\n\n      from posts p\n\n      left join users u on p.author_id = u.id\n\n      inner join subreddits sr on p.subreddit_id = sr.id\n\n      left join post_votes pv on p.id = pv.post_id\n\n      left join post_votes upv on upv.post_id = p.id and upv.user_id = $1\n\n      group by p.id\n\n      having p.id = $2\n\n    `\n\n\n\n    const selectCommentsStatement = `\n\n      ${selectAllCommentsStatement}\n\n      having c.post_id = $2\n\n      order by votes desc\n\n    `\n\n    const user_id = req.user ? req.user.id : -1\n\n    const { rows: [post] } = await query(selectPostStatement, [user_id, post_id])\n\n    const { rows: comments } = await query(selectCommentsStatement, [user_id, post_id])\n\n\n\n    if (!post) {\n\n      return res.status(404).send({ error: 'Could not find post with that id' })\n\n    }\n\n\n\n    res.send({ post, comments })\n\n  } catch (e) {\n\n    res.status(500).send({ error: e.message })\n\n  }\n\n})\n\n\n\nrouter.post('/', auth, async (req, res) => {\n\n  try {\n\n    const { body, post_id, parent_comment_id } = req.body\n\n    if (!body) {\n\n      throw new Error('Must specify comment body')\n\n    }\n\n    if (!post_id) {\n\n      throw new Error('Must specify post to comment on')\n\n    }\n\n    const insertCommentStatement = `\n\n      insert into comments(body, author_id, post_id, parent_comment_id)\n\n      values($1, $2, $3, $4)\n\n      returning *\n\n    `\n\n    const { rows: [{ id }] } = await query(insertCommentStatement, [\n\n      body,\n\n      req.user.id,\n\n      post_id,\n\n      parent_comment_id\n\n    ])\n\n\n\n    // Automatically upvote own comment\n\n    const createVoteStatement = `insert into comment_votes values ($1, $2, $3)`\n\n    await query(createVoteStatement, [req.user.id, id, 1])\n\n\n\n    const selectInsertedCommentStatement = `\n\n      ${selectAllCommentsStatement}\n\n      having c.id = $2\n\n    `\n\n\n\n    const { rows: [comment] } = await query(selectInsertedCommentStatement, [req.user.id, id])\n\n\n\n    res.status(201).send(comment)\n\n  } catch (e) {\n\n    res.status(400).send({ error: e.message })\n\n  }\n\n})\n\n\n\nrouter.put('/:id', auth, async (req, res) => {\n\n  try {\n\n    const { id } = req.params\n\n\n\n    const { rows: [comment] } = await query(selectCommentStatement, [id])\n\n    if (!comment) {\n\n      return res.status(404).send({ error: 'Could not find comment with that id' })\n\n    }\n\n    if ((comment.author_id !== req.user.id)\n\n        && (await userIsModerator(req.user.username, comment.subreddit_name) === false)) {\n\n      return res.status(403).send({ error: 'You must the comment author to edit it' })\n\n    }\n\n\n\n    const updatedComment = await updateTableRow('comments', id, ['body'], req.body)\n\n\n\n    res.send(updatedComment)\n\n  } catch (e) {\n\n    res.status(400).send({ error: e.message })\n\n  }\n\n})\n\n\n\nrouter.delete('/:id', auth, async (req, res) => {\n\n  try {\n\n    const { id } = req.params\n\n    const { rows: [comment] } = await query(selectCommentStatement, [id])\n\n    if (!comment) {\n\n      return res.status(404).send({ error: 'Could not find comment with that id' })\n\n    }\n\n    if ((comment.author_id !== req.user.id)\n\n        && (await userIsModerator(req.user.username, comment.subreddit_name) === false)) {\n\n      return res.status(403).send({ error: 'You must be the comment author to delete it' })\n\n    }\n\n\n\n    // const deleteCommentStatement = `delete from comments where id = $1 returning *`\n\n    // const { rows: [deletedComment] } = await query(deleteCommentStatement, [id])\n\n    \n\n    const setFieldsToNullStatement = `\n\n      update comments\n\n      set body = null,\n\n          author_id = null\n\n      where id = $1\n\n      returning *\n\n    `\n\n\n\n    const { rows: [deletedComment] } = await query(setFieldsToNullStatement, [id])\n\n\n\n    res.send(deletedComment)\n\n  } catch (e) {\n\n    res.status(400).send({ error: e.message })\n\n  }\n\n})\n\n\n\nmodule.exports = router\n'reddit-clone/backend/src/index.js'\n:const express = require('express')\n\nconst cors = require('cors')\n\n\n\nconst usersRouter = require('./routers/users')\n\nconst postsRouter = require('./routers/posts')\n\nconst subredditsRouter = require('./routers/subreddits')\n\nconst moderatorsRouter = require('./routers/moderators')\n\nconst commentsRouter = require('./routers/comments')\n\nconst votesRouter = require('./routers/votes')\n\n\n\nconst port = process.env.PORT\n\n\n\nconst app = express()\n\n\n\napp.use(cors())\n\napp.use(express.json())\n\n\n\napp.use('/users', usersRouter)\n\napp.use('/posts', postsRouter)\n\napp.use('/subreddits', subredditsRouter)\n\napp.use('/moderators', moderatorsRouter)\n\napp.use('/comments', commentsRouter)\n\napp.use('/votes', votesRouter)\n\n\n\napp.listen(port, () => {\n\n  console.log(`App is listening on port ${port}`)\n\n})\n",
        "called_code_segment": "router.get('/:post_id', optionalAuth, async (req, res) => {\n  try {\n    const { post_id } = req.params\n    const selectPostStatement = `\n      select\n      p.id, p.type, p.title, p.body, p.created_at, p.updated_at,\n      max(u.username) author_name,\n      cast(coalesce(sum(pv.vote_value), 0) as int) votes,\n      max(upv.vote_value) has_voted,\n      max(sr.name) subreddit_name\n      from posts p\n      left join users u on p.author_id = u.id\n      inner join subreddits sr on p.subreddit_id = sr.id\n      left join post_votes pv on p.id = pv.post_id\n      left join post_votes upv on upv.post_id = p.id and upv.user_id = $1\n      group by p.id\n      having p.id = $2\n    `\n\n    const selectCommentsStatement = `\n      ${selectAllCommentsStatement}\n      having c.post_id = $2\n      order by votes desc\n    `\n    const user_id = req.user ? req.user.id : -1\n    const { rows: [post] } = await query(selectPostStatement, [user_id, post_id])\n    const { rows: comments } = await query(selectCommentsStatement, [user_id, post_id])\n\n    if (!post) {\n      return res.status(404).send({ error: 'Could not find post with that id' })\n    }\n\n    res.send({ post, comments })\n  } catch (e) {\n    res.status(500).send({ error: e.message })\n  }\n})",
        "invoking_code_segment": "app.use('/comments', commentsRouter)",
        "new_file_code_segment": "const fetchPostAndComments = async (user_id, post_id) => {\n  const selectPostStatement = `\n    select\n    p.id, p.type, p.title, p.body, p.created_at, p.updated_at,\n    max(u.username) author_name,\n    cast(coalesce(sum(pv.vote_value), 0) as int) votes,\n    max(upv.vote_value) has_voted,\n    max(sr.name) subreddit_name\n    from posts p\n    left join users u on p.author_id = u.id\n    inner join subreddits sr on p.subreddit_id = sr.id\n    left join post_votes pv on p.id = pv.post_id\n    left join post_votes upv on upv.post_id = p.id and upv.user_id = $1\n    group by p.id\n    having p.id = $2\n  `\n\n  const selectCommentsStatement = `\n    ${selectAllCommentsStatement}\n    having c.post_id = $2\n    order by votes desc\n  `\n\n  const { rows: [post] } = await query(selectPostStatement, [user_id, post_id])\n  const { rows: comments } = await query(selectCommentsStatement, [user_id, post_id])\n\n  return { post, comments }\n}\n\nmodule.exports = {\n  fetchPostAndComments\n}",
        "feature_description": "Add a new utility function to fetch post and comments data in a more modular way.",
        "detailed_feature_description": "The new feature introduces a utility function in a new file (#file 3) that encapsulates the logic for fetching post and comments data. This function is then invoked in #file 1 where the original logic was present. This approach makes the code more modular and easier to maintain. The function is also designed to be reusable, which can be beneficial for future enhancements or similar use cases.",
        "modified_complete_code": {
            "#file 1": "const express = require('express')\nconst { query } = require('../db')\nconst { updateTableRow, userIsModerator } = require('../db/utils')\nconst auth = require('../middleware/auth')()\nconst optionalAuth = require('../middleware/auth')(true)\nconst router = express.Router()\n\nconst selectCommentStatement = `\n  select c.id, c.author_id, c.post_id, c.parent_comment_id, sr.name subreddit_name\n  from comments c\n  inner join posts p on c.post_id = p.id\n  inner join subreddits sr on p.subreddit_id = sr.id\n  where c.id = $1\n`\n\nconst selectAllCommentsStatement = `\n  select\n  c.id, c.body, c.post_id, c.parent_comment_id, c.created_at, c.updated_at,\n  max(u.username) author_name,\n  cast(coalesce(sum(cv.vote_value), 0) as int) votes,\n  max(ucv.vote_value) has_voted\n  from comments c\n  left join users u on c.author_id = u.id\n  left join comment_votes cv on c.id = cv.comment_id\n  left join comment_votes ucv on ucv.comment_id = c.id and ucv.user_id = $1\n  group by c.id\n`\n\nrouter.get('/', async (req, res) => {\n  try {\n    const selectCommentsStatement = `select * from comments`\n    const { rows } = await query(selectCommentsStatement)\n    res.send(rows)\n  } catch (e) {\n    res.status(500).send({ error: e.message })\n  }\n})\n\n#Modify\nconst { fetchPostAndComments } = require('./utils/fetchPostAndComments')\n\nrouter.get('/:post_id', optionalAuth, async (req, res) => {\n  try {\n    const { post_id } = req.params\n    const user_id = req.user ? req.user.id : -1\n    const { post, comments } = await fetchPostAndComments(user_id, post_id)\n\n    if (!post) {\n      return res.status(404).send({ error: 'Could not find post with that id' })\n    }\n\n    res.send({ post, comments })\n  } catch (e) {\n    res.status(500).send({ error: e.message })\n  }\n})\n\nrouter.post('/', auth, async (req, res) => {\n  try {\n    const { body, post_id, parent_comment_id } = req.body\n    if (!body) {\n      throw new Error('Must specify comment body')\n    }\n    if (!post_id) {\n      throw new Error('Must specify post to comment on')\n    }\n    const insertCommentStatement = `\n      insert into comments(body, author_id, post_id, parent_comment_id)\n      values($1, $2, $3, $4)\n      returning *\n    `\n    const { rows: [{ id }] } = await query(insertCommentStatement, [\n      body,\n      req.user.id,\n      post_id,\n      parent_comment_id\n    ])\n\n    const createVoteStatement = `insert into comment_votes values ($1, $2, $3)`\n    await query(createVoteStatement, [req.user.id, id, 1])\n\n    const selectInsertedCommentStatement = `\n      ${selectAllCommentsStatement}\n      having c.id = $2\n    `\n\n    const { rows: [comment] } = await query(selectInsertedCommentStatement, [req.user.id, id])\n\n    res.status(201).send(comment)\n  } catch (e) {\n    res.status(400).send({ error: e.message })\n  }\n})\n\nrouter.put('/:id', auth, async (req, res) => {\n  try {\n    const { id } = req.params\n\n    const { rows: [comment] } = await query(selectCommentStatement, [id])\n    if (!comment) {\n      return res.status(404).send({ error: 'Could not find comment with that id' })\n    }\n    if ((comment.author_id !== req.user.id)\n        && (await userIsModerator(req.user.username, comment.subreddit_name) === false)) {\n      return res.status(403).send({ error: 'You must the comment author to edit it' })\n    }\n\n    const updatedComment = await updateTableRow('comments', id, ['body'], req.body)\n\n    res.send(updatedComment)\n  } catch (e) {\n    res.status(400).send({ error: e.message })\n  }\n})\n\nrouter.delete('/:id', auth, async (req, res) => {\n  try {\n    const { id } = req.params\n    const { rows: [comment] } = await query(selectCommentStatement, [id])\n    if (!comment) {\n      return res.status(404).send({ error: 'Could not find comment with that id' })\n    }\n    if ((comment.author_id !== req.user.id)\n        && (await userIsModerator(req.user.username, comment.subreddit_name) === false)) {\n      return res.status(403).send({ error: 'You must be the comment author to delete it' })\n    }\n\n    const setFieldsToNullStatement = `\n      update comments\n      set body = null,\n          author_id = null\n      where id = $1\n      returning *\n    `\n\n    const { rows: [deletedComment] } = await query(setFieldsToNullStatement, [id])\n\n    res.send(deletedComment)\n  } catch (e) {\n    res.status(400).send({ error: e.message })\n  }\n})\n\nmodule.exports = router",
            "#file 2": "const express = require('express')\nconst cors = require('cors')\n\nconst usersRouter = require('./routers/users')\nconst postsRouter = require('./routers/posts')\nconst subredditsRouter = require('./routers/subreddits')\nconst moderatorsRouter = require('./routers/moderators')\nconst commentsRouter = require('./routers/comments')\nconst votesRouter = require('./routers/votes')\n\nconst port = process.env.PORT\n\nconst app = express()\n\napp.use(cors())\napp.use(express.json())\n\napp.use('/users', usersRouter)\napp.use('/posts', postsRouter)\napp.use('/subreddits', subredditsRouter)\napp.use('/moderators', moderatorsRouter)\napp.use('/comments', commentsRouter)\napp.use('/votes', votesRouter)\n\napp.listen(port, () => {\n  console.log(`App is listening on port ${port}`)\n})",
            "#file 3": "#New\nconst { query } = require('../../db')\n\nconst selectAllCommentsStatement = `\n  select\n  c.id, c.body, c.post_id, c.parent_comment_id, c.created_at, c.updated_at,\n  max(u.username) author_name,\n  cast(coalesce(sum(cv.vote_value), 0) as int) votes,\n  max(ucv.vote_value) has_voted\n  from comments c\n  left join users u on c.author_id = u.id\n  left join comment_votes cv on c.id = cv.comment_id\n  left join comment_votes ucv on ucv.comment_id = c.id and ucv.user_id = $1\n  group by c.id\n`\n\nconst fetchPostAndComments = async (user_id, post_id) => {\n  const selectPostStatement = `\n    select\n    p.id, p.type, p.title, p.body, p.created_at, p.updated_at,\n    max(u.username) author_name,\n    cast(coalesce(sum(pv.vote_value), 0) as int) votes,\n    max(upv.vote_value) has_voted,\n    max(sr.name) subreddit_name\n    from posts p\n    left join users u on p.author_id = u.id\n    inner join subreddits sr on p.subreddit_id = sr.id\n    left join post_votes pv on p.id = pv.post_id\n    left join post_votes upv on upv.post_id = p.id and upv.user_id = $1\n    group by p.id\n    having p.id = $2\n  `\n\n  const selectCommentsStatement = `\n    ${selectAllCommentsStatement}\n    having c.post_id = $2\n    order by votes desc\n  `\n\n  const { rows: [post] } = await query(selectPostStatement, [user_id, post_id])\n  const { rows: comments } = await query(selectCommentsStatement, [user_id, post_id])\n\n  return { post, comments }\n}\n\nmodule.exports = {\n  fetchPostAndComments\n}"
        }
    },
    {
        "repo": "tabex",
        "content": "'tabex/lib/router.js'\n:// LocalStorage router\n//\n'use strict';\n\n\n/* global document, window */\nvar Timer = require('./timer');\nvar LocalStorage = require('./local_storage');\nvar $$ = require('./utils');\n\n\n// Max lifetime of router record in storage\nvar TIMEOUT = 4000;\n// Update router record frequency\nvar UPDATE_INTERVAL = TIMEOUT / 4;\n\n\n// Constructor\n//\n// options:\n//\n//  - namespace (String) - optional, localStorage keys prefix, default 'tabex_default_'\n//\nfunction Router(options) {\n  var self = this;\n\n  options = options || {};\n\n  this.__namespace__ = options.namespace || 'tabex_default_';\n  this.__node_id__ = Math.floor(Math.random() * 1e10) + 1;\n  this.__last_message_cnt__ = 0;\n  this.__handlers__ = [];\n  this.__router_channels__ = {};\n\n  // Constants for convenience\n  this.__router_id_prefix__ = this.__namespace__ + 'router_';\n  this.__router_channels_prefix__ = this.__namespace__ + 'subscribed_';\n  this.__lock_prefix__ = this.__namespace__ + 'lock_';\n\n  // IE broadcasts storage events also to the same window, we should filter that messages\n  this.__storage_events_filter__ = [];\n\n  for (var i = 0; i < 100; i++) {\n    this.__storage_events_filter__.push('');\n  }\n\n  this.__ls__ = new LocalStorage();\n\n  // Id of master tab\n  this.__master_id__ = null;\n\n  // Handle `localStorage` update\n  $$.addEvent(window, 'storage', function (e) {\n    if (e.key === null) {\n      // If event is caused by `localStorage.clear()` `key` will be null. Skip this\n      // event and reestablish normal behaviour by `.__check_master__()` call.\n      self.__check_master__();\n      return;\n    }\n\n    // IE needs kludge because event fire before data was saved\n    if ('onstoragecommit' in document) {\n      setTimeout(function () {\n        self.__on_changed__(e);\n      }, 1);\n\n      return;\n    }\n\n    self.__on_changed__(e);\n  });\n\n  // Handle page unload (listen `onbeforeunload` and `onunload` to ensure that data is stored successfully)\n  // http://stackoverflow.com/questions/3775566/javascript-question-onbeforeunload-or-onunload\n  //\n  this.__destroyed__ = false;\n  $$.addEvent(window, 'beforeunload', function () {\n    self.__destroy__();\n  });\n  $$.addEvent(window, 'unload', function () {\n    self.__destroy__();\n  });\n\n  // Update current tab info and check master alive\n  this.__check_master__();\n\n  // Instell timers & remember those to cleanup in __destroy__()\n  this.__timer_cm__ = Timer.setInterval(function () {\n    self.__check_master__();\n  }, UPDATE_INTERVAL);\n\n  // Remove outdated lock records\n  this.__timer_lc__ = Timer.setInterval(function () {\n    self.__locks_cleanup__();\n  }, 1000);\n}\n\n\n// Broadcast message between all clients\n//\n// - channel (String) - channel name\n// - message (Object) - message data\n//\nRouter.prototype.broadcast = function (channel, message) {\n  // If it is system subscribe message - update channels list\n  if (channel === '!sys.channels.add') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]++;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system unsubscribe message - update channels list\n  if (channel === '!sys.channels.remove') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]--;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system lock message - try acquire lock\n  if (channel === '!sys.lock.request') {\n    this.__lock__(message.data.id, message.id, message.data.timeout);\n\n    return;\n  }\n\n  // If it is system unlock message - remove lock data\n  if (channel === '!sys.lock.release') {\n    this.__ls__.removeItem(this.__lock_prefix__ + message.data.id);\n\n    return;\n  }\n\n  var serializedMessage = JSON.stringify({\n    channel: channel,\n    message: message,\n\n    // Add random to be sure that `localStorage` sent event even new massage is same than previous\n    random: Math.floor(Math.random() * 1e10)\n  });\n\n  // Add message to `localStorage` to distribute over Router instances\n  this.__storage_events_filter__.shift();\n  this.__storage_events_filter__.push(this.__namespace__ + 'broadcast' + '_' + serializedMessage);\n  this.__ls__.setItem(this.__namespace__ + 'broadcast', serializedMessage);\n\n  // Emit message for all clients and proxies registered on this router\n  this.__handlers__.forEach(function (handler) {\n    handler(channel, message);\n  });\n};\n\n\n// Subscribe handler to all messages\n//\nRouter.prototype.onmessage = function (handler) {\n  var self = this;\n\n  this.__handlers__.push(handler);\n\n  // Delay sending events to next tick to allow client initialize handlers\n  setTimeout(function () {\n    // Sent master info for every new client\n    handler('!sys.master', {\n      data: {\n        node_id: self.__node_id__,\n        master_id: self.__master_id__\n      },\n      node_id: self.__node_id__,\n      id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n    });\n\n    // Send channels info\n    self.__on_channels_list_changed__();\n  }, 0);\n};\n\n\n// Try acquire lock\n//\n// - lockId (String)\n// - requestId (String)\n// - timeout (Number)\n//\nRouter.prototype.__lock__ = function (lockId, requestId, timeout) {\n  var self = this;\n  var lockKey = this.__lock_prefix__ + lockId;\n  var lockValue = this.__ls__.getItem(lockKey);\n\n  if (lockValue) {\n    try {\n      lockValue = JSON.parse(lockValue);\n    } catch (__) {\n      lockValue = null;\n    }\n  }\n\n  // If `expire` not in past - lock already acquired, exit here\n  if (lockValue && lockValue.expire > Date.now()) {\n    return;\n  }\n\n  // Try acquire lock\n  this.__ls__.setItem(lockKey, JSON.stringify({ expire: timeout + Date.now(), requestId: requestId }));\n\n  // Read lock value again after 30 ms to check `requestId` (race condition\n  // here - other tab may rewrite value in store). Delay needed to ensure that\n  // localStorage's data synchronized\n  setTimeout(function () {\n    lockValue = self.__ls__.getItem(lockKey);\n\n    if (lockValue) {\n      try {\n        lockValue = JSON.parse(lockValue);\n      } catch (__) {\n        lockValue = null;\n      }\n    }\n\n    // If `requestId` is not same - other tab acquire lock, exit here\n    if (!lockValue || lockValue.requestId !== requestId) {\n      return;\n    }\n\n    // Here lock acquired - send message to clients\n    self.__handlers__.forEach(function (handler) {\n      handler('!sys.lock.acquired', {\n        data: {\n          request_id: requestId\n        },\n        node_id: self.__node_id__,\n        id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n      });\n    });\n  }, 30);\n};\n\n\n// Remove outdated lock records from storage\n//\nRouter.prototype.__locks_cleanup__ = function () {\n  for (var i = 0, key, val; i < this.__ls__.length; i++) {\n    key = this.__ls__.key(i);\n\n    // Filter localStorage records by prefix\n    if (key.indexOf(this.__lock_prefix__) !== 0) {\n      continue;\n    }\n\n    val = this.__ls__.getItem(key);\n\n    try {\n      val = JSON.parse(val);\n    } catch (__) {\n      val = null;\n    }\n\n    // If lock expire or record is broken - remove it\n    if (!val || val.expire < Date.now()) {\n      this.__ls__.removeItem(key);\n    }\n  }\n};\n\n\n// Update master id, if current tab is master - init connect and subscribe channels\n//\nRouter.prototype.__on_master_changed__ = function (newMasterID) {\n  var self = this;\n\n  // If master tab closed\n  if (!newMasterID) {\n    // Select random master (tab with smallest ID becomes master)\n    if (this.__get_alive_router_ids__().sort()[0] === this.__node_id__) {\n      this.__storage_events_filter__.pop();\n      this.__storage_events_filter__.push(this.__namespace__ + 'master' + '_' + this.__node_id__);\n      this.__ls__.setItem(this.__namespace__ + 'master', this.__node_id__);\n      this.__on_master_changed__(this.__node_id__);\n    }\n    return;\n  }\n\n  this.__master_id__ = +newMasterID;\n\n  this.__handlers__.forEach(function (handler) {\n    handler('!sys.master', {\n      data: {\n        node_id: self.__node_id__,\n        master_id: self.__master_id__\n      },\n      node_id: self.__node_id__,\n      id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n    });\n  });\n\n  // Update channels list for this tab before sending channels info. Needed if\n  // master changed by calling `localStorage.clear()`\n  self.__update_channels_list__(true);\n\n  // Send channels info\n  self.__on_channels_list_changed__();\n};\n\n\n// localStorage change handler. Updates master ID, receive subscribe requests\n//\nRouter.prototype.__on_changed__ = function (e) {\n\n  // IE broadcasts storage events also to the same window, we should filter that messages\n  if (this.__storage_events_filter__.indexOf(e.key + '_' + e.newValue) !== -1) {\n    return;\n  }\n\n  // Master changed\n  if (e.key === this.__namespace__ + 'master') {\n    this.__on_master_changed__(e.newValue);\n  }\n\n  // Channels list changed\n  if (e.key.indexOf(this.__router_channels_prefix__) === 0) {\n    this.__on_channels_list_changed__();\n  }\n\n  // Emit message for all clients and proxies registered on this router\n  if (e.key === this.__namespace__ + 'broadcast') {\n    var data = JSON.parse(e.newValue);\n\n    this.__handlers__.forEach(function (handler) {\n      handler(data.channel, data.message);\n    });\n  }\n};\n\n\n// Page unload handler. Remove tab data from store & kill timers\n//\nRouter.prototype.__destroy__ = function () {\n  if (this.__destroyed__) {\n    return;\n  }\n\n  this.__destroyed__ = true;\n\n  Timer.clearInterval(this.__timer_cm__);\n  Timer.clearInterval(this.__timer_lc__);\n\n  this.__ls__.removeItem(this.__router_id_prefix__ + this.__node_id__);\n  this.__ls__.removeItem(this.__router_channels_prefix__ + this.__node_id__);\n\n  if (this.__master_id__ === this.__node_id__) {\n    this.__ls__.removeItem(this.__namespace__ + 'master');\n  }\n};\n\n\n// Get alive tabs IDs and remove timeouted tabs\n//\nRouter.prototype.__get_alive_router_ids__ = function () {\n  var maxTime = Date.now() - TIMEOUT;\n  var id;\n  var routersIDs = [];\n\n  for (var i = 0, key; i < this.__ls__.length; i++) {\n    key = this.__ls__.key(i);\n\n    // Filter localStorage records by prefix\n    if (key.indexOf(this.__router_id_prefix__) !== 0) {\n      continue;\n    }\n\n    id = +key.substr(this.__router_id_prefix__.length);\n\n    // Check router is alive and remove if not\n    if (this.__ls__.getItem(key) < maxTime) {\n      this.__ls__.removeItem(key);\n      this.__ls__.removeItem(this.__router_channels_prefix__ + id);\n      continue;\n    }\n\n    routersIDs.push(id);\n  }\n\n  return routersIDs;\n};\n\n\n// Update tab channels list\n//\nRouter.prototype.__update_channels_list__ = function (silent) {\n  var self = this;\n  var channels = [];\n\n  Object.keys(this.__router_channels__).forEach(function (channel) {\n    if (self.__router_channels__[channel] > 0) {\n      channels.push(channel);\n    }\n  });\n\n  var serializedChannels = JSON.stringify(channels.sort());\n\n  // Update channels list if changed\n  if (this.__ls__.getItem(this.__router_channels_prefix__ + this.__node_id__) !== serializedChannels) {\n    this.__storage_events_filter__.pop();\n    this.__storage_events_filter__.push(this.__router_channels_prefix__ + this.__node_id__ + '_' + serializedChannels);\n    this.__ls__.setItem(this.__router_channels_prefix__ + this.__node_id__, serializedChannels);\n    if (!silent) {\n      this.__on_channels_list_changed__();\n    }\n  }\n};\n\n\n// Update subscribes if channels list changed (run only on master)\n//\nRouter.prototype.__on_channels_list_changed__ = function () {\n  var self = this;\n  var channels = [];\n\n  for (var i = 0, key; i < this.__ls__.length; i++) {\n    key = this.__ls__.key(i);\n\n    // Filter localStorage records by prefix\n    if (key.indexOf(this.__router_channels_prefix__) !== 0) {\n      continue;\n    }\n\n    channels = channels.concat(JSON.parse(this.__ls__.getItem(key)));\n  }\n\n  // Get unique channels names\n  channels = channels.reduce(function (result, item) {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n    return result;\n  }, []);\n\n  this.__handlers__.forEach(function (handler) {\n    handler('!sys.channels.refresh', {\n      id: self.__node_id__ + '_' + (self.__last_message_cnt__++),\n      node_id: self.__node_id__,\n      data: {\n        channels: channels\n      }\n    });\n  });\n};\n\n\n// Update tab livetime and become master if not exists\n//\nRouter.prototype.__check_master__ = function () {\n  // Update current tab time\n  this.__ls__.setItem(this.__router_id_prefix__ + this.__node_id__, Date.now());\n\n  // Update local value of master ID\n  this.__master_id__ = +this.__ls__.getItem(this.__namespace__ + 'master');\n\n  // If master tab not found - become master\n  if (this.__get_alive_router_ids__().indexOf(this.__master_id__) === -1) {\n    this.__storage_events_filter__.pop();\n    this.__storage_events_filter__.push(this.__namespace__ + 'master' + '_' + this.__node_id__);\n    this.__ls__.setItem(this.__namespace__ + 'master', this.__node_id__);\n    this.__on_master_changed__(this.__node_id__);\n  }\n};\n\n\nmodule.exports = Router;\n\n'tabex/lib/index.js'\n:'use strict';\n\n\nvar Router = require('./router');\nvar Client = require('./client');\nvar Tunnel = require('./tunnel');\n\n\nvar routerInstances = {};\n\n\nvar Tabex = { _: {} };\n\n\n// Expose classes for testing\n//\nTabex._.Router = Router;\nTabex._.Client = Client;\nTabex._.Tunnel = Tunnel;\n\n\n// Create client\n//\nTabex.client = function (options) {\n  options = options || {};\n\n  var namespace = options.namespace || 'tabex_default_';\n\n  var router;\n\n  // If router in iframe (cross-domain) - create tunnel\n  if (options.iframe) {\n    router = new Tunnel.TunnelClient(options);\n\n  // If router is local (single-domain) - try to reuse existing router\n  } else {\n    if (!routerInstances[namespace]) {\n      routerInstances[namespace] = new Router({\n        namespace: namespace\n      });\n    }\n\n    router = routerInstances[namespace];\n  }\n\n  return new Client({ router: router });\n};\n\n\n// Create router\n//\nTabex.router = function (options) {\n  options = options || {};\n\n  var namespace = options.namespace || 'tabex_default_';\n\n  // Try to reuse existing router\n  if (!routerInstances[namespace]) {\n    routerInstances[namespace] = new Router({\n      namespace: namespace\n    });\n  }\n\n  // Create tunnel to communicate between router and client\n  /* eslint-disable no-new */\n  new Tunnel.TunnelRouter({\n    router: routerInstances[namespace],\n    namespace: namespace,\n    origin: options.origin\n  });\n\n  return routerInstances[namespace];\n};\n\n\nmodule.exports = Tabex;\n\n",
        "called_code_segment": "Router.prototype.broadcast = function (channel, message) {\n  // If it is system subscribe message - update channels list\n  if (channel === '!sys.channels.add') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]++;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system unsubscribe message - update channels list\n  if (channel === '!sys.channels.remove') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]--;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system lock message - try acquire lock\n  if (channel === '!sys.lock.request') {\n    this.__lock__(message.data.id, message.id, message.data.timeout);\n\n    return;\n  }\n\n  // If it is system unlock message - remove lock data\n  if (channel === '!sys.lock.release') {\n    this.__ls__.removeItem(this.__lock_prefix__ + message.data.id);\n\n    return;\n  }\n\n  var serializedMessage = JSON.stringify({\n    channel: channel,\n    message: message,\n\n    // Add random to be sure that `localStorage` sent event even new massage is same than previous\n    random: Math.floor(Math.random() * 1e10)\n  });\n\n  // Add message to `localStorage` to distribute over Router instances\n  this.__storage_events_filter__.shift();\n  this.__storage_events_filter__.push(this.__namespace__ + 'broadcast' + '_' + serializedMessage);\n  this.__ls__.setItem(this.__namespace__ + 'broadcast', serializedMessage);\n\n  // Emit message for all clients and proxies registered on this router\n  this.__handlers__.forEach(function (handler) {\n    handler(channel, message);\n  });\n};",
        "invoking_code_segment": "Router.prototype.onmessage = function (handler) {\n  var self = this;\n\n  this.__handlers__.push(handler);\n\n  // Delay sending events to next tick to allow client initialize handlers\n  setTimeout(function () {\n    // Sent master info for every new client\n    handler('!sys.master', {\n      data: {\n        node_id: self.__node_id__,\n        master_id: self.__master_id__\n      },\n      node_id: self.__node_id__,\n      id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n    });\n\n    // Send channels info\n    self.__on_channels_list_changed__();\n  }, 0);\n};",
        "new_file_code_segment": "function logMessage(channel, message) {\n  console.log('Received message on channel:', channel, 'with data:', message);\n}\n\nmodule.exports = {\n  logMessage: logMessage\n};",
        "feature_description": "Add logging for all messages received by the router.",
        "detailed_feature_description": "The new feature adds logging functionality to the router. Whenever a message is received by the router, it will log the channel and the message data to the console. This is implemented by creating a new file (#file 3) that contains the logging function. The `onmessage` method in #file 2 is updated to invoke this logging function from #file 3. The `broadcast` method in #file 1 is also updated to invoke the logging function from #file 3 when a message is broadcasted.",
        "modified_complete_code": {
            "#file 1": "Router.prototype.broadcast = function (channel, message) {\n  // If it is system subscribe message - update channels list\n  if (channel === '!sys.channels.add') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]++;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system unsubscribe message - update channels list\n  if (channel === '!sys.channels.remove') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]--;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system lock message - try acquire lock\n  if (channel === '!sys.lock.request') {\n    this.__lock__(message.data.id, message.id, message.data.timeout);\n\n    return;\n  }\n\n  // If it is system unlock message - remove lock data\n  if (channel === '!sys.lock.release') {\n    this.__ls__.removeItem(this.__lock_prefix__ + message.data.id);\n\n    return;\n  }\n\n  var serializedMessage = JSON.stringify({\n    channel: channel,\n    message: message,\n\n    // Add random to be sure that `localStorage` sent event even new massage is same than previous\n    random: Math.floor(Math.random() * 1e10)\n  });\n\n  // Add message to `localStorage` to distribute over Router instances\n  this.__storage_events_filter__.shift();\n  this.__storage_events_filter__.push(this.__namespace__ + 'broadcast' + '_' + serializedMessage);\n  this.__ls__.setItem(this.__namespace__ + 'broadcast', serializedMessage);\n\n  // Emit message for all clients and proxies registered on this router\n  this.__handlers__.forEach(function (handler) {\n    handler(channel, message);\n  });\n\n  // #Modify: Add logging for broadcasted messages\n  var logger = require('./logger');\n  logger.logMessage(channel, message);\n};",
            "#file 2": "Router.prototype.onmessage = function (handler) {\n  var self = this;\n\n  this.__handlers__.push(handler);\n\n  // Delay sending events to next tick to allow client initialize handlers\n  setTimeout(function () {\n    // Sent master info for every new client\n    handler('!sys.master', {\n      data: {\n        node_id: self.__node_id__,\n        master_id: self.__master_id__\n      },\n      node_id: self.__node_id__,\n      id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n    });\n\n    // Send channels info\n    self.__on_channels_list_changed__();\n  }, 0);\n\n  // #Modify: Add logging for received messages\n  var logger = require('./logger');\n  logger.logMessage('!sys.master', {\n    data: {\n      node_id: self.__node_id__,\n      master_id: self.__master_id__\n    },\n    node_id: self.__node_id__,\n    id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n  });\n};",
            "#file 3": "function logMessage(channel, message) {\n  console.log('Received message on channel:', channel, 'with data:', message);\n}\n\nmodule.exports = {\n  logMessage: logMessage\n};"
        }
    },
    {
        "repo": "vuex-shopping-cart",
        "content": "'vuex-shopping-cart/src/store/mutation-types.js'\n:export const ADD_TO_CART = 'ADD_TO_CART'\n'vuex-shopping-cart/src/store/index.js'\n:import Vue from 'vue'\nimport Vuex from 'vuex'\nimport * as types from './mutation-types'\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== 'production'\n\n// initial state\nconst state = {\n  added: [],\n  all: [\n    {\n      id: 'cc919e21-ae5b-5e1f-d023-c40ee669520c',\n      name: 'COBOL 101 vintage',\n      description: 'Learn COBOL with this vintage programming book',\n      price: 399\n    },\n    {\n      id: 'bcd755a6-9a19-94e1-0a5d-426c0303454f',\n      name: 'Sharp C2719 curved TV',\n      description: 'Watch TV like never before with the brand new curved screen technology',\n      price: 1995\n    },\n    {\n      id: '727026b7-7f2f-c5a0-ace9-cc227e686b8e',\n      name: 'Remmington X mechanical keyboard',\n      description: 'Excellent for gaming and typing, this Remmington X keyboard ' +\n        'features tactile, clicky switches for speed and accuracy',\n      price: 595\n    }\n  ]\n}\n\n// getters\nconst getters = {\n\tallProducts: state => state.all, // would need action/mutation if data fetched async\n\tgetNumberOfProducts: state => (state.all) ? state.all.length : 0,\n\tcartProducts: state => {\n\t\treturn state.added.map(({ id, quantity }) => {\n\t\t\tconst product = state.all.find(p => p.id === id)\n\n\t\t\treturn {\n\t\t\t\tname: product.name,\n\t\t\t\tprice: product.price,\n\t\t\t\tquantity\n\t\t\t}\n\t\t})\n\t}\n}\n\n// actions\nconst actions = {\n\taddToCart({ commit }, product){\n\t\tcommit(types.ADD_TO_CART, {\n\t\t\tid: product.id\n\t\t})\n\t}\n}\n\n// mutations\nconst mutations = {\n\n\t[types.ADD_TO_CART] (state, { id }) {\n\t    const record = state.added.find(p => p.id === id)\n\n\t    if (!record) {\n\t      state.added.push({\n\t        id,\n\t        quantity: 1\n\t      })\n\t    } else {\n\t      record.quantity++\n\t    }\n\t  }\n}\n\n// one store for entire application\nexport default new Vuex.Store({\n\tstate,\n\tstrict: debug,\n\tgetters,\n\tactions,\n\tmutations\n})\n\n",
        "called_code_segment": "mutations: {\n\n\t[types.ADD_TO_CART] (state, { id }) {\n\t    const record = state.added.find(p => p.id === id)\n\n\t    if (!record) {\n\t      state.added.push({\n\t        id,\n\t        quantity: 1\n\t      })\n\t    } else {\n\t      record.quantity++\n\t    }\n\t  }\n}",
        "invoking_code_segment": "actions: {\n\taddToCart({ commit }, product){\n\t\tcommit(types.ADD_TO_CART, {\n\t\t\tid: product.id\n\t\t})\n\t}\n}",
        "new_file_code_segment": "export const logAddToCart = (product) => {\n\tconsole.log(`Product ${product.name} added to cart.`)\n}",
        "feature_description": "Add logging functionality when a product is added to the cart.",
        "detailed_feature_description": "The new feature introduces logging functionality that will log a message to the console whenever a product is added to the cart. This is implemented by creating a new file (#file 3) that exports a function to log the addition of a product. The #file 1 (store) is updated to invoke this logging function whenever a product is added to the cart. The #file 2 (actions) is also updated to pass the product details to the logging function.",
        "modified_complete_code": {
            "#file 1 (store/index.js)": "import Vue from 'vue'\nimport Vuex from 'vuex'\nimport * as types from './mutation-types'\nimport { logAddToCart } from './logAddToCart'\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== 'production'\n\n// initial state\nconst state = {\n  added: [],\n  all: [\n    {\n      id: 'cc919e21-ae5b-5e1f-d023-c40ee669520c',\n      name: 'COBOL 101 vintage',\n      description: 'Learn COBOL with this vintage programming book',\n      price: 399\n    },\n    {\n      id: 'bcd755a6-9a19-94e1-0a5d-426c0303454f',\n      name: 'Sharp C2719 curved TV',\n      description: 'Watch TV like never before with the brand new curved screen technology',\n      price: 1995\n    },\n    {\n      id: '727026b7-7f2f-c5a0-ace9-cc227e686b8e',\n      name: 'Remmington X mechanical keyboard',\n      description: 'Excellent for gaming and typing, this Remmington X keyboard ' +\n        'features tactile, clicky switches for speed and accuracy',\n      price: 595\n    }\n  ]\n}\n\n// getters\nconst getters = {\n\tallProducts: state => state.all, // would need action/mutation if data fetched async\n\tgetNumberOfProducts: state => (state.all) ? state.all.length : 0,\n\tcartProducts: state => {\n\t\treturn state.added.map(({ id, quantity }) => {\n\t\t\tconst product = state.all.find(p => p.id === id)\n\n\t\t\treturn {\n\t\t\t\tname: product.name,\n\t\t\t\tprice: product.price,\n\t\t\t\tquantity\n\t\t\t}\n\t\t})\n\t}\n}\n\n// actions\nconst actions = {\n\taddToCart({ commit }, product){\n\t\tcommit(types.ADD_TO_CART, {\n\t\t\tid: product.id\n\t\t})\n\t\tlogAddToCart(product) #Modify\n\t}\n}\n\n// mutations\nconst mutations = {\n\n\t[types.ADD_TO_CART] (state, { id }) {\n\t    const record = state.added.find(p => p.id === id)\n\n\t    if (!record) {\n\t      state.added.push({\n\t        id,\n\t        quantity: 1\n\t      })\n\t    } else {\n\t      record.quantity++\n\t    }\n\t  }\n}\n\n// one store for entire application\nexport default new Vuex.Store({\n\tstate,\n\tstrict: debug,\n\tgetters,\n\tactions,\n\tmutations\n})",
            "#file 2 (store/mutation-types.js)": "export const ADD_TO_CART = 'ADD_TO_CART'",
            "#file 3 (store/logAddToCart.js)": "export const logAddToCart = (product) => {\n\tconsole.log(`Product ${product.name} added to cart.`)\n}"
        }
    },
    {
        "repo": "web-ifc-three",
        "content": "'web-ifc-three/example/src/scene.js'\n:import { AmbientLight, Color, DirectionalLight, PerspectiveCamera, Scene, WebGLRenderer, GridHelper } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\nimport Stats from 'stats.js/src/Stats';\n\nexport class ThreeScene {\n    constructor() {\n        this.threeCanvas = document.getElementById('threeCanvas');\n        this.scene = new Scene();\n        this.camera = new PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);\n        this.renderer = new WebGLRenderer({ antialias: true, canvas: this.threeCanvas });\n        this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n        this.stats = new Stats();\n        this.grid = new GridHelper();\n        this.setupScene();\n    }\n\n    setupScene() {\n        this.setupBasics();\n        this.setupLights();\n        this.setupWindowResize();\n        this.setupMonitoring();\n        this.setupAnimation();\n        this.setupCamera();\n        this.scene.add(this.grid);\n    }\n\n    setupAnimation = () => {\n        this.stats.begin();\n        this.controls.update();\n        this.renderer.render(this.scene, this.camera);\n        this.stats.end();\n        requestAnimationFrame(this.setupAnimation);\n    }\n\n    setupBasics() {\n        this.scene.background = new Color(0x8cc7de);\n        this.renderer.setSize(window.innerWidth, window.innerHeight);\n        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));\n        this.camera.position.z = 5;\n    }\n\n    setupLights() {\n        const directionalLight1 = new DirectionalLight(0xffeeff, 0.8);\n        directionalLight1.position.set(1, 1, 1);\n        this.scene.add(directionalLight1);\n        const directionalLight2 = new DirectionalLight(0xffffff, 0.8);\n        directionalLight2.position.set(-1, 0.5, -1);\n        this.scene.add(directionalLight2);\n        const ambientLight = new AmbientLight(0xffffee, 0.25);\n        this.scene.add(ambientLight);\n    }\n\n    setupWindowResize() {\n        window.addEventListener('resize', () => {\n            this.camera.aspect = window.innerWidth / window.innerHeight;\n            this.camera.updateProjectionMatrix();\n            this.renderer.setSize(window.innerWidth, window.innerHeight);\n        });\n    }\n\n    setupMonitoring() {\n        this.stats.showPanel(0);\n        this.stats.dom.style.cssText = 'position:absolute;top:1rem;left:1rem;z-index:1;';\n        document.body.appendChild(this.stats.dom);\n    }\n\n    setupCamera() {\n        this.camera.position.set(10, 10, 10);\n        this.controls.target.set(0, 0, 0);\n    }\n}\n'web-ifc-three/example/src/main.js'\n:import { ThreeScene } from './scene';\nimport { IfcManager } from './ifc-manager';\n\nconst ifcModels = [];\nconst baseScene = new ThreeScene();\nconst loader = new IfcManager(baseScene.scene, ifcModels);\n",
        "called_code_segment": "this.setupAnimation = () => {\n        this.stats.begin();\n        this.controls.update();\n        this.renderer.render(this.scene, this.camera);\n        this.stats.end();\n        requestAnimationFrame(this.setupAnimation);\n    }",
        "invoking_code_segment": "const baseScene = new ThreeScene();\nconst loader = new IfcManager(baseScene.scene, ifcModels);",
        "new_file_code_segment": "export const animateIfcModels = (scene, ifcModels) => {\n    ifcModels.forEach(model => {\n        scene.add(model);\n    });\n}",
        "feature_description": "Add a feature to animate IFC models in the scene.",
        "detailed_feature_description": "The new feature involves adding IFC models to the scene during the animation loop. This is achieved by creating a new function `animateIfcModels` in a new file (#file 3) that iterates over the `ifcModels` array and adds each model to the scene. The `setupAnimation` method in #file 1 is modified to call this new function, ensuring that the IFC models are added to the scene during each animation frame. The `IfcManager` class in #file 2 is updated to pass the `ifcModels` array to the `ThreeScene` instance, ensuring that the models are available for animation.",
        "modified_complete_code": {
            "#file 1": "//Modify\nthis.setupAnimation = () => {\n        this.stats.begin();\n        this.controls.update();\n        animateIfcModels(this.scene, ifcModels); //Modify\n        this.renderer.render(this.scene, this.camera);\n        this.stats.end();\n        requestAnimationFrame(this.setupAnimation);\n    }\n\n//New\nimport { animateIfcModels } from './animateIfcModels';",
            "#file 2": "//Modify\nconst baseScene = new ThreeScene(ifcModels);\nconst loader = new IfcManager(baseScene.scene, ifcModels);\n\n//New\nimport { ThreeScene } from './scene';",
            "#file 3": "//New\nexport const animateIfcModels = (scene, ifcModels) => {\n    ifcModels.forEach(model => {\n        scene.add(model);\n    });\n}"
        }
    },
    {
        "repo": "wifi-card",
        "content": "'wifi-card/src/App.js'\n:import { Button, Heading, Link, Pane, Paragraph } from 'evergreen-ui';\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport logo from '../src/images/wifi.png';\nimport { Settings } from './components/Settings';\nimport { WifiCard } from './components/WifiCard';\nimport './style.css';\nimport { Translations } from './translations';\n\nfunction App() {\n  const html = document.querySelector('html');\n  const { t, i18n } = useTranslation();\n  const firstLoad = useRef(true);\n  const [settings, setSettings] = useState({\n    // Network SSID name\n    ssid: '',\n    // Network password\n    password: '',\n    // Settings: Network encryption mode\n    encryptionMode: 'WPA',\n    // Settings: EAP Method\n    eapMethod: 'PWD',\n    // Settings: EAP identity\n    eapIdentity: '',\n    // Settings: Hide password on the printed card\n    hidePassword: false,\n    // Settings: Mark your network as hidden SSID\n    hiddenSSID: false,\n    // Settings: Portrait orientation\n    portrait: false,\n    // Settings: Additional cards\n    additionalCards: 0,\n    // Settings: Show tip (legend) on card\n    hideTip: false,\n  });\n  const [errors, setErrors] = useState({\n    ssidError: '',\n    passwordError: '',\n    eapIdentityError: '',\n  });\n\n  const htmlDirection = (languageID) => {\n    languageID = languageID || i18n.language;\n    const rtl = Translations.filter((t) => t.id === languageID)[0]?.rtl;\n    return rtl ? 'rtl' : 'ltr';\n  };\n\n  const onChangeLanguage = (language) => {\n    html.style.direction = htmlDirection(language);\n    i18n.changeLanguage(language);\n  };\n\n  const onPrint = () => {\n    if (!settings.ssid.length) {\n      setErrors({\n        ...errors,\n        ssidError: t('wifi.alert.name'),\n      });\n      return;\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.8'),\n      });\n      return;\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.5'),\n      });\n      return;\n    }\n    if (\n      settings.password.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password'),\n      });\n      return;\n    }\n    if (\n      settings.eapIdentity.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        eapIdentityError: t('wifi.alert.eapIdentity'),\n      });\n      return;\n    }\n    document.title = 'WiFi Card - ' + settings.ssid;\n    window.print();\n  };\n\n  const onSSIDChange = (ssid) => {\n    setErrors({ ...errors, ssidError: '' });\n    setSettings({ ...settings, ssid });\n  };\n  const onPasswordChange = (password) => {\n    setErrors({ ...errors, passwordError: '' });\n    setSettings({ ...settings, password });\n  };\n  const onEncryptionModeChange = (encryptionMode) => {\n    setErrors({ ...errors, passwordError: '' });\n    setSettings({ ...settings, encryptionMode });\n  };\n  const onEapMethodChange = (eapMethod) => {\n    setSettings({ ...settings, eapMethod });\n  };\n  const onEapIdentityChange = (eapIdentity) => {\n    setErrors({ ...errors, eapIdentityError: '' });\n    setSettings({ ...settings, eapIdentity });\n  };\n  const onOrientationChange = (portrait) => {\n    setSettings({ ...settings, portrait });\n  };\n  const onHidePasswordChange = (hidePassword) => {\n    setSettings({ ...settings, hidePassword });\n  };\n  const onHiddenSSIDChange = (hiddenSSID) => {\n    setSettings({ ...settings, hiddenSSID });\n  };\n  const onAdditionalCardsChange = (additionalCardsStr) => {\n    const amount = parseInt(additionalCardsStr);\n    amount >= 0 && setSettings({ ...settings, additionalCards: amount });\n  };\n  const onHideTipChange = (hideTip) => {\n    setSettings({ ...settings, hideTip });\n  };\n  const onFirstLoad = () => {\n    html.style.direction = htmlDirection();\n    firstLoad.current = false;\n  };\n\n  useEffect(() => {\n    // Ensure the page direction is set properly on first load\n    if (htmlDirection() === 'rtl') {\n      html.style.direction = 'rtl';\n    }\n  });\n\n  return (\n    <Pane>\n      <Pane display=\"flex\">\n        <img alt=\"icon\" src={logo} width=\"32\" height=\"32\" />\n        <Heading size={900} paddingRight={16} paddingLeft={16}>\n          {t('title')}\n        </Heading>\n      </Pane>\n\n      <Pane>\n        <Paragraph marginTop={12}>{t('desc.use')}</Paragraph>\n\n        <Paragraph marginTop={12}>\n          {t('desc.privacy')}{' '}\n          <Link href=\"https://github.com/bndw/wifi-card\">\n            {t('desc.source')}\n          </Link>\n          .\n        </Paragraph>\n      </Pane>\n\n      <Pane>\n        <WifiCard\n          settings={settings}\n          ssidError={errors.ssidError}\n          passwordError={errors.passwordError}\n          eapIdentityError={errors.eapIdentityError}\n          onSSIDChange={onSSIDChange}\n          onEapIdentityChange={onEapIdentityChange}\n          onPasswordChange={onPasswordChange}\n        />\n      </Pane>\n\n      <Settings\n        settings={settings}\n        firstLoad={firstLoad}\n        onFirstLoad={onFirstLoad}\n        onLanguageChange={onChangeLanguage}\n        onEncryptionModeChange={onEncryptionModeChange}\n        onEapMethodChange={onEapMethodChange}\n        onOrientationChange={onOrientationChange}\n        onHidePasswordChange={onHidePasswordChange}\n        onHiddenSSIDChange={onHiddenSSIDChange}\n        onAdditionalCardsChange={onAdditionalCardsChange}\n        onHideTipChange={onHideTipChange}\n      />\n\n      <Button\n        id=\"print\"\n        appearance=\"primary\"\n        height={40}\n        marginRight={16}\n        onClick={onPrint}\n      >\n        {t('button.print')}\n      </Button>\n      <Pane id=\"print-area\">\n        {settings.additionalCards >= 0 &&\n          [...Array(settings.additionalCards + 1)].map((el, idx) => (\n            <WifiCard\n              key={`card-nr-${idx}`}\n              settings={settings}\n              ssidError={errors.ssidError}\n              passwordError={errors.passwordError}\n              eapIdentityError={errors.eapIdentityError}\n              onSSIDChange={onSSIDChange}\n              onEapIdentityChange={onEapIdentityChange}\n              onPasswordChange={onPasswordChange}\n            />\n          ))}\n      </Pane>\n    </Pane>\n  );\n}\n\nexport default App;\n\n'wifi-card/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './i18n';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n",
        "called_code_segment": "function onPrint() {\n    if (!settings.ssid.length) {\n      setErrors({\n        ...errors,\n        ssidError: t('wifi.alert.name'),\n      });\n      return;\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.8'),\n      });\n      return;\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.5'),\n      });\n      return;\n    }\n    if (\n      settings.password.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password'),\n      });\n      return;\n    }\n    if (\n      settings.eapIdentity.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        eapIdentityError: t('wifi.alert.eapIdentity'),\n      });\n      return;\n    }\n    document.title = 'WiFi Card - ' + settings.ssid;\n    window.print();\n  }",
        "invoking_code_segment": "<Button\n        id=\"print\"\n        appearance=\"primary\"\n        height={40}\n        marginRight={16}\n        onClick={onPrint}\n      >\n        {t('button.print')}\n      </Button>",
        "new_file_code_segment": "function validateSettings(settings) {\n    const errors = {};\n    if (!settings.ssid.length) {\n      errors.ssidError = 'SSID is required';\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      errors.passwordError = 'Password must be at least 8 characters';\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      errors.passwordError = 'Password must be at least 5 characters';\n    }\n    if (settings.password.length < 1 && settings.encryptionMode === 'WPA2-EAP') {\n      errors.passwordError = 'Password is required';\n    }\n    if (settings.eapIdentity.length < 1 && settings.encryptionMode === 'WPA2-EAP') {\n      errors.eapIdentityError = 'EAP Identity is required';\n    }\n    return errors;\n  }",
        "feature_description": "Add a validation function to centralize error handling and improve code maintainability.",
        "detailed_feature_description": "The new feature introduces a validation function in a new file (#file 3) that centralizes the error handling logic. This function is called from the onPrint function in #file 1 to validate the settings before proceeding with the print action. This approach improves code maintainability and reduces redundancy.",
        "modified_complete_code": {
            "#file 1": "function onPrint() {\n    const validationErrors = validateSettings(settings);\n    if (Object.keys(validationErrors).length > 0) {\n      setErrors(validationErrors);\n      return;\n    }\n    document.title = 'WiFi Card - ' + settings.ssid;\n    window.print();\n  }\n\n  #Modify",
            "#file 2": "<Button\n        id=\"print\"\n        appearance=\"primary\"\n        height={40}\n        marginRight={16}\n        onClick={onPrint}\n      >\n        {t('button.print')}\n      </Button>",
            "#file 3": "function validateSettings(settings) {\n    const errors = {};\n    if (!settings.ssid.length) {\n      errors.ssidError = 'SSID is required';\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      errors.passwordError = 'Password must be at least 8 characters';\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      errors.passwordError = 'Password must be at least 5 characters';\n    }\n    if (settings.password.length < 1 && settings.encryptionMode === 'WPA2-EAP') {\n      errors.passwordError = 'Password is required';\n    }\n    if (settings.eapIdentity.length < 1 && settings.encryptionMode === 'WPA2-EAP') {\n      errors.eapIdentityError = 'EAP Identity is required';\n    }\n    return errors;\n  }\n\n  #New"
        }
    },
    {
        "repo": "wildemitter",
        "content": "'wildemitter/wildemitter.js'\n:/*\nWildEmitter.js is a slim little event emitter by @henrikjoreteg largely based\non @visionmedia's Emitter from UI Kit.\n\nWhy? I wanted it standalone.\n\nI also wanted support for wildcard emitters like this:\n\nemitter.on('*', function (eventName, other, event, payloads) {\n\n});\n\nemitter.on('somenamespace*', function (eventName, payloads) {\n\n});\n\nPlease note that callbacks triggered by wildcard registered events also get\nthe event name as the first argument.\n*/\n\nmodule.exports = WildEmitter;\n\nfunction WildEmitter() { }\n\nWildEmitter.mixin = function (constructor) {\n    var prototype = constructor.prototype || constructor;\n\n    prototype.isWildEmitter= true;\n\n    // Listen on the given `event` with `fn`. Store a group name if present.\n    prototype.on = function (event, groupName, fn) {\n        this.callbacks = this.callbacks || {};\n        var hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        func._groupName = group;\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\n        return this;\n    };\n\n    // Adds an `event` listener that will be invoked a single\n    // time then automatically removed.\n    prototype.once = function (event, groupName, fn) {\n        var self = this,\n            hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        function on() {\n            self.off(event, on);\n            func.apply(this, arguments);\n        }\n        this.on(event, group, on);\n        return this;\n    };\n\n    // Unbinds an entire group\n    prototype.releaseGroup = function (groupName) {\n        this.callbacks = this.callbacks || {};\n        var item, i, len, handlers;\n        for (item in this.callbacks) {\n            handlers = this.callbacks[item];\n            for (i = 0, len = handlers.length; i < len; i++) {\n                if (handlers[i]._groupName === groupName) {\n                    //console.log('removing');\n                    // remove it and shorten the array we're looping through\n                    handlers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n        return this;\n    };\n\n    // Remove the given callback for `event` or all\n    // registered callbacks.\n    prototype.off = function (event, fn) {\n        this.callbacks = this.callbacks || {};\n        var callbacks = this.callbacks[event],\n            i;\n\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (arguments.length === 1) {\n            delete this.callbacks[event];\n            return this;\n        }\n\n        // remove specific handler\n        i = callbacks.indexOf(fn);\n        if (i !== -1) {\n            callbacks.splice(i, 1);\n            if (callbacks.length === 0) {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    };\n\n    /// Emit `event` with the given args.\n    // also calls any `*` handlers\n    prototype.emit = function (event) {\n        this.callbacks = this.callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this.callbacks[event],\n            specialCallbacks = this.getWildcardCallbacks(event),\n            i,\n            len,\n            item,\n            listeners;\n\n        if (callbacks) {\n            listeners = callbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, args);\n            }\n        }\n\n        if (specialCallbacks) {\n            len = specialCallbacks.length;\n            listeners = specialCallbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, [event].concat(args));\n            }\n        }\n\n        return this;\n    };\n\n    // Helper for for finding special wildcard event handlers that match the event\n    prototype.getWildcardCallbacks = function (eventName) {\n        this.callbacks = this.callbacks || {};\n        var item,\n            split,\n            result = [];\n\n        for (item in this.callbacks) {\n            split = item.split('*');\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\n                result = result.concat(this.callbacks[item]);\n            }\n        }\n        return result;\n    };\n\n};\n\nWildEmitter.mixin(WildEmitter);\n\n'wildemitter/test.js'\n:var Emitter = require(\"./wildemitter\");\n\nfunction Fruit(name) {\n  this.name = name;\n  Emitter.call(this);\n}\n\nFruit.prototype = new Emitter();\n\nFruit.prototype.test = function() {\n  this.emit(\"test\", this.name);\n};\n\n// set up some test fruits\nvar apple = new Fruit(\"apple\"),\n  orange = new Fruit(\"orange\");\n\nexports[\"Make sure wildcard handlers work\"] = function(test) {\n  var count = 0,\n    cb = function() {\n      return function() {\n        count++;\n      };\n    };\n\n  apple.on(\"*\", cb());\n  apple.on(\"te*\", cb());\n  // This should NOT add to count. Regression test for issue #4\n  apple.on(\"other*\", cb());\n  apple.on(\"test\", cb());\n  apple.test();\n\n  // sanity check to make sure we've got the emitter isolated to the instance\n  orange.test();\n\n  test.equal(count, 3);\n\n  apple.off(\"test\");\n\n  // reset our counter\n  count = 0;\n  apple.test();\n\n  test.equal(count, 2);\n  test.done();\n};\n\nexports[\"Test group binding and unbinding\"] = function(test) {\n  var count = 0,\n    cb = function() {\n      return function() {\n        count++;\n      };\n    };\n\n  // test our groups\n  orange.on(\"test\", \"lumped\", cb());\n  orange.on(\"test\", \"lumped\", cb());\n  orange.on(\"test\", \"lumped\", cb());\n  orange.on(\"test\", cb());\n  orange.test();\n  test.equal(count, 4);\n\n  count = 0;\n  orange.releaseGroup(\"lumped\");\n  orange.test();\n\n  test.equal(count, 1);\n  test.done();\n};\n\nexports[\"Test once for multiple functions\"] = function(test) {\n  var count, cb1, cb2;\n\n  count = 0;\n  cb1 = function() {\n    count++;\n  };\n  cb2 = function() {\n    count++;\n  };\n\n  orange.once(\"test\", cb1);\n  orange.once(\"test\", cb2);\n  orange.test();\n\n  test.equal(count, 2);\n\n  orange.test();\n  test.equal(count, 2);\n\n  test.done();\n};\n\nexports[\"Test on and off\"] = function(test) {\n  var count, cb1, cb2;\n  var orange = new Fruit(\"orange\");\n\n  count = 0;\n  cb1 = function() {\n    count++;\n  };\n  cb2 = function() {\n    count++;\n  };\n\n  orange.on(\"test\", cb1);\n  orange.on(\"test2\", cb2);\n  orange.test();\n\n  test.equal(count, 1);\n\n  orange.off(\"test\", cb1);\n  orange.test();\n  test.equal(count, 1);\n\n  orange.emit(\"test2\");\n  test.equal(count, 2);\n\n  orange.off(\"test2\", cb2);\n\n  //ensure callbacks array is removed entirely\n  test.ok(orange.callbacks.test == null);\n  test.ok(orange.callbacks.test2 == null);\n\n  test.done();\n};\n\nexports[\"Mixin to constructor\"] = function(test) {\n  function Vegetable(name) {\n    this.name = name;\n  }\n\n  Emitter.mixin(Vegetable);\n\n  Vegetable.prototype.test = function() {\n    this.emit(\"test\", this.name);\n  };\n\n  // set up a test vegetable\n  var lettuce = new Vegetable(\"lettuce\");\n  var count, cb1, cb2;\n\n  count = 0;\n  cb1 = function() {\n    count++;\n  };\n  cb2 = function() {\n    count++;\n  };\n\n  lettuce.on(\"test\", cb1);\n  lettuce.on(\"test2\", cb2);\n  lettuce.test();\n\n  test.equal(count, 1);\n\n  lettuce.off(\"test\", cb1);\n  lettuce.test();\n  test.equal(count, 1);\n\n  lettuce.emit(\"test2\");\n  test.equal(count, 2);\n\n  test.done();\n};\n\nexports[\"Mixin to plain javascript objects\"] = function(test) {\n  var potato = {};\n  Emitter.mixin(potato);\n\n  potato.test = function() {\n    this.emit(\"test\", this.name);\n  };\n\n  var count, cb1, cb2;\n\n  count = 0;\n  cb1 = function() {\n    count++;\n  };\n  cb2 = function() {\n    count++;\n  };\n\n  potato.on(\"test\", cb1);\n  potato.on(\"test2\", cb2);\n  potato.test();\n\n  test.equal(count, 1);\n\n  potato.off(\"test\", cb1);\n  potato.test();\n  test.equal(count, 1);\n\n  potato.emit(\"test2\");\n  test.equal(count, 2);\n\n  test.done();\n};\n\n",
        "called_code_segment": "prototype.emit = function (event) {\n    this.callbacks = this.callbacks || {};\n    var args = [].slice.call(arguments, 1),\n        callbacks = this.callbacks[event],\n        specialCallbacks = this.getWildcardCallbacks(event),\n        i,\n        len,\n        item,\n        listeners;\n\n    if (callbacks) {\n        listeners = callbacks.slice();\n        for (i = 0, len = listeners.length; i < len; ++i) {\n            if (!listeners[i]) {\n                break;\n            }\n            listeners[i].apply(this, args);\n        }\n    }\n\n    if (specialCallbacks) {\n        len = specialCallbacks.length;\n        listeners = specialCallbacks.slice();\n        for (i = 0, len = listeners.length; i < len; ++i) {\n            if (!listeners[i]) {\n                break;\n            }\n            listeners[i].apply(this, [event].concat(args));\n        }\n    }\n\n    return this;\n};",
        "invoking_code_segment": "Fruit.prototype.test = function() {\n  this.emit(\"test\", this.name);\n};",
        "new_file_code_segment": "function logEvent(eventName, args) {\n    console.log('Event:', eventName, 'Args:', args);\n}\n\nmodule.exports = {\n    logEvent: logEvent\n};",
        "feature_description": "Add logging for emitted events.",
        "detailed_feature_description": "The new feature involves adding logging functionality for emitted events. This will help in debugging and monitoring the events emitted by the emitter. The logging function will be implemented in a new file (#file 3) and will be invoked within the emit function in #file 1. The test function in #file 2 will remain unchanged as it will continue to emit events as usual, but now with added logging.",
        "modified_complete_code": {
            "#file 1": "module.exports = WildEmitter;\n\nfunction WildEmitter() { }\n\nWildEmitter.mixin = function (constructor) {\n    var prototype = constructor.prototype || constructor;\n\n    prototype.isWildEmitter= true;\n\n    // Listen on the given `event` with `fn`. Store a group name if present.\n    prototype.on = function (event, groupName, fn) {\n        this.callbacks = this.callbacks || {};\n        var hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        func._groupName = group;\n        (this.callbacks[event] = this.callbacks[event] || []).push(func);\n        return this;\n    };\n\n    // Adds an `event` listener that will be invoked a single\n    // time then automatically removed.\n    prototype.once = function (event, groupName, fn) {\n        var self = this,\n            hasGroup = (arguments.length === 3),\n            group = hasGroup ? arguments[1] : undefined,\n            func = hasGroup ? arguments[2] : arguments[1];\n        function on() {\n            self.off(event, on);\n            func.apply(this, arguments);\n        }\n        this.on(event, group, on);\n        return this;\n    };\n\n    // Unbinds an entire group\n    prototype.releaseGroup = function (groupName) {\n        this.callbacks = this.callbacks || {};\n        var item, i, len, handlers;\n        for (item in this.callbacks) {\n            handlers = this.callbacks[item];\n            for (i = 0, len = handlers.length; i < len; i++) {\n                if (handlers[i]._groupName === groupName) {\n                    handlers.splice(i, 1);\n                    i--;\n                    len--;\n                }\n            }\n        }\n        return this;\n    };\n\n    // Remove the given callback for `event` or all\n    // registered callbacks.\n    prototype.off = function (event, fn) {\n        this.callbacks = this.callbacks || {};\n        var callbacks = this.callbacks[event],\n            i;\n\n        if (!callbacks) return this;\n\n        // remove all handlers\n        if (arguments.length === 1) {\n            delete this.callbacks[event];\n            return this;\n        }\n\n        // remove specific handler\n        i = callbacks.indexOf(fn);\n        if (i !== -1) {\n            callbacks.splice(i, 1);\n            if (callbacks.length === 0) {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    };\n\n    /// Emit `event` with the given args.\n    // also calls any `*` handlers\n    prototype.emit = function (event) {\n        this.callbacks = this.callbacks || {};\n        var args = [].slice.call(arguments, 1),\n            callbacks = this.callbacks[event],\n            specialCallbacks = this.getWildcardCallbacks(event),\n            i,\n            len,\n            item,\n            listeners;\n\n        if (callbacks) {\n            listeners = callbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, args);\n            }\n        }\n\n        if (specialCallbacks) {\n            len = specialCallbacks.length;\n            listeners = specialCallbacks.slice();\n            for (i = 0, len = listeners.length; i < len; ++i) {\n                if (!listeners[i]) {\n                    break;\n                }\n                listeners[i].apply(this, [event].concat(args));\n            }\n        }\n\n        // #Modify: Add logging for emitted events\n        var logger = require('./logger');\n        logger.logEvent(event, args);\n\n        return this;\n    };\n\n    // Helper for for finding special wildcard event handlers that match the event\n    prototype.getWildcardCallbacks = function (eventName) {\n        this.callbacks = this.callbacks || {};\n        var item,\n            split,\n            result = [];\n\n        for (item in this.callbacks) {\n            split = item.split('*');\n            if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {\n                result = result.concat(this.callbacks[item]);\n            }\n        }\n        return result;\n    };\n\n};\n\nWildEmitter.mixin(WildEmitter);",
            "#file 2": "var Emitter = require(\"./wildemitter\");\n\nfunction Fruit(name) {\n  this.name = name;\n  Emitter.call(this);\n}\n\nFruit.prototype = new Emitter();\n\nFruit.prototype.test = function() {\n  this.emit(\"test\", this.name);\n};\n\n// set up some test fruits\nvar apple = new Fruit(\"apple\"),\n  orange = new Fruit(\"orange\");\n\nexports[\"Make sure wildcard handlers work\"] = function(test) {\n  var count = 0,\n    cb = function() {\n      return function() {\n        count++;\n      };\n    };\n\n  apple.on(\"*\", cb());\n  apple.on(\"te*\", cb());\n  apple.on(\"test\", cb());\n  apple.test();\n\n  orange.test();\n\n  test.equal(count, 3);\n\n  apple.off(\"test\");\n\n  count = 0;\n  apple.test();\n\n  test.equal(count, 2);\n  test.done();\n};\n\nexports[\"Test group binding and unbinding\"] = function(test) {\n  var count = 0,\n    cb = function() {\n      return function() {\n        count++;\n      };\n    };\n\n  orange.on(\"test\", \"lumped\", cb());\n  orange.on(\"test\", \"lumped\", cb());\n  orange.on(\"test\", \"lumped\", cb());\n  orange.on(\"test\", cb());\n  orange.test();\n  test.equal(count, 4);\n\n  count = 0;\n  orange.releaseGroup(\"lumped\");\n  orange.test();\n\n  test.equal(count, 1);\n  test.done();\n};\n\nexports[\"Test once for multiple functions\"] = function(test) {\n  var count, cb1, cb2;\n\n  count = 0;\n  cb1 = function() {\n    count++;\n  };\n  cb2 = function() {\n    count++;\n  };\n\n  orange.once(\"test\", cb1);\n  orange.once(\"test\", cb2);\n  orange.test();\n\n  test.equal(count, 2);\n\n  orange.test();\n  test.equal(count, 2);\n\n  test.done();\n};\n\nexports[\"Test on and off\"] = function(test) {\n  var count, cb1, cb2;\n  var orange = new Fruit(\"orange\");\n\n  count = 0;\n  cb1 = function() {\n    count++;\n  };\n  cb2 = function() {\n    count++;\n  };\n\n  orange.on(\"test\", cb1);\n  orange.on(\"test2\", cb2);\n  orange.test();\n\n  test.equal(count, 1);\n\n  orange.off(\"test\", cb1);\n  orange.test();\n  test.equal(count, 1);\n\n  orange.emit(\"test2\");\n  test.equal(count, 2);\n\n  orange.off(\"test2\", cb2);\n\n  test.ok(orange.callbacks.test == null);\n  test.ok(orange.callbacks.test2 == null);\n\n  test.done();\n};\n\nexports[\"Mixin to constructor\"] = function(test) {\n  function Vegetable(name) {\n    this.name = name;\n  }\n\n  Emitter.mixin(Vegetable);\n\n  Vegetable.prototype.test = function() {\n    this.emit(\"test\", this.name);\n  };\n\n  var lettuce = new Vegetable(\"lettuce\");\n  var count, cb1, cb2;\n\n  count = 0;\n  cb1 = function() {\n    count++;\n  };\n  cb2 = function() {\n    count++;\n  };\n\n  lettuce.on(\"test\", cb1);\n  lettuce.on(\"test2\", cb2);\n  lettuce.test();\n\n  test.equal(count, 1);\n\n  lettuce.off(\"test\", cb1);\n  lettuce.test();\n  test.equal(count, 1);\n\n  lettuce.emit(\"test2\");\n  test.equal(count, 2);\n\n  test.done();\n};\n\nexports[\"Mixin to plain javascript objects\"] = function(test) {\n  var potato = {};\n  Emitter.mixin(potato);\n\n  potato.test = function() {\n    this.emit(\"test\", this.name);\n  };\n\n  var count, cb1, cb2;\n\n  count = 0;\n  cb1 = function() {\n    count++;\n  };\n  cb2 = function() {\n    count++;\n  };\n\n  potato.on(\"test\", cb1);\n  potato.on(\"test2\", cb2);\n  potato.test();\n\n  test.equal(count, 1);\n\n  potato.off(\"test\", cb1);\n  potato.test();\n  test.equal(count, 1);\n\n  potato.emit(\"test2\");\n  test.equal(count, 2);\n\n  test.done();\n};",
            "#file 3": "function logEvent(eventName, args) {\n    console.log('Event:', eventName, 'Args:', args);\n}\n\nmodule.exports = {\n    logEvent: logEvent\n};"
        }
    },
    {
        "repo": "winston-logstash",
        "content": "'winston-logstash/lib/connection.js'\n:\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecureConnection = exports.PlainConnection = exports.ConnectionEvents = exports.ConnectionActions = exports.Connection = void 0;\nvar _net = require(\"net\");\nvar _fs = require(\"fs\");\nvar _tls = _interopRequireDefault(require(\"tls\"));\nvar _events = require(\"events\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nlet ConnectionActions;\nexports.ConnectionActions = ConnectionActions;\n(function (ConnectionActions) {\n  ConnectionActions[\"Initializing\"] = \"Initializing\";\n  ConnectionActions[\"Connecting\"] = \"Connecting\";\n  ConnectionActions[\"Closing\"] = \"Closing\";\n  ConnectionActions[\"Tranferring\"] = \"Transferring\";\n  ConnectionActions[\"HandlingError\"] = \"HandlingError\";\n})(ConnectionActions || (exports.ConnectionActions = ConnectionActions = {}));\nlet ConnectionEvents;\nexports.ConnectionEvents = ConnectionEvents;\n(function (ConnectionEvents) {\n  ConnectionEvents[\"Connected\"] = \"connection:connected\";\n  ConnectionEvents[\"Closed\"] = \"connection:closed\";\n  ConnectionEvents[\"ClosedByServer\"] = \"connection:closed:by-server\";\n  ConnectionEvents[\"Error\"] = \"connection:error\";\n  ConnectionEvents[\"Timeout\"] = \"connection:timeout\";\n  ConnectionEvents[\"Drain\"] = \"connection:drain\";\n})(ConnectionEvents || (exports.ConnectionEvents = ConnectionEvents = {}));\nclass Connection extends _events.EventEmitter {\n  constructor(options) {\n    var _options$host, _options$port;\n    super();\n    _defineProperty(this, \"socket\", void 0);\n    _defineProperty(this, \"host\", void 0);\n    _defineProperty(this, \"port\", void 0);\n    _defineProperty(this, \"action\", void 0);\n    this.action = ConnectionActions.Initializing;\n    this.host = (_options$host = options === null || options === void 0 ? void 0 : options.host) !== null && _options$host !== void 0 ? _options$host : '127.0.0.1';\n    this.port = (_options$port = options === null || options === void 0 ? void 0 : options.port) !== null && _options$port !== void 0 ? _options$port : 28777;\n  }\n  socketOnError(error) {\n    this.action = ConnectionActions.HandlingError;\n    this.emit(ConnectionEvents.Error, error);\n  }\n  socketOnTimeout() {\n    var _this$socket;\n    this.action = ConnectionActions.HandlingError;\n    this.emit(ConnectionEvents.Timeout, (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState);\n  }\n  socketOnConnect() {\n    var _this$socket2;\n    (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.setKeepAlive(true, 60 * 1000);\n    this.action = ConnectionActions.Tranferring;\n    this.emit(ConnectionEvents.Connected);\n  }\n  socketOnDrain() {\n    this.emit(ConnectionEvents.Drain);\n  }\n  socketOnClose(error) {\n    if (this.action === ConnectionActions.Closing) {\n      this.emit(ConnectionEvents.Closed, error);\n    } else {\n      this.emit(ConnectionEvents.ClosedByServer, error);\n    }\n  }\n  addEventListeners(socket) {\n    socket.on('drain', this.socketOnDrain.bind(this));\n    socket.once('error', this.socketOnError.bind(this));\n    socket.once('timeout', this.socketOnTimeout.bind(this));\n    socket.once('close', this.socketOnClose.bind(this));\n  }\n  close() {\n    var _this$socket3, _this$socket4;\n    this.action = ConnectionActions.Closing;\n    (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.removeAllListeners();\n    (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.destroy();\n    this.emit(ConnectionEvents.Closed);\n  }\n  send(message, writeCallback) {\n    var _this$socket5;\n    return ((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.write(Buffer.from(message), writeCallback)) === true;\n  }\n  readyToSend() {\n    var _this$socket6;\n    return ((_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.readyState) === 'open';\n  }\n  connect() {\n    this.action = ConnectionActions.Connecting;\n  }\n}\nexports.Connection = Connection;\nclass PlainConnection extends Connection {\n  connect() {\n    super.connect();\n    try {\n      this.socket = new _net.Socket();\n      super.addEventListeners(this.socket);\n      this.socket.once('connect', super.socketOnConnect.bind(this));\n      this.socket.connect(this.port, this.host);\n    } catch (error) {\n      this.emit(ConnectionEvents.Error, error);\n    }\n  }\n}\nexports.PlainConnection = PlainConnection;\nclass SecureConnection extends Connection {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"secureContextOptions\", void 0);\n    this.secureContextOptions = SecureConnection.createSecureContextOptions(options);\n  }\n  static createSecureContextOptions(options) {\n    const sslKey = options.ssl_key;\n    const sslCert = options.ssl_cert;\n    const ca = options.ca;\n    const sslPassphrase = options.ssl_passphrase;\n    const rejectUnauthorized = options.rejectUnauthorized;\n    const secureContextOptions = {\n      key: sslKey && (0, _fs.readFileSync)(sslKey),\n      cert: sslCert && (0, _fs.readFileSync)(sslCert),\n      passphrase: sslPassphrase || undefined,\n      rejectUnauthorized: rejectUnauthorized,\n      ca: ca && (0, _fs.readFileSync)(ca)\n    };\n    return secureContextOptions;\n  }\n  connect() {\n    super.connect();\n    try {\n      this.socket = _tls.default.connect(this.port, this.host, this.secureContextOptions);\n      super.addEventListeners(this.socket);\n      this.socket.once('secureConnect', super.socketOnConnect.bind(this));\n    } catch (error) {\n      this.emit(ConnectionEvents.Error, error);\n    }\n  }\n}\nexports.SecureConnection = SecureConnection;\n'winston-logstash/lib/winston-logstash-latest.js'\n:\"use strict\";\n\nvar _winstonTransport = _interopRequireDefault(require(\"winston-transport\"));\nvar _manager = require(\"./manager\");\nvar _connection = require(\"./connection\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n//\n// Inherit from `winston-transport` so you can take advantage\n// of the base functionality and `.exceptions.handle()`.\n//\nmodule.exports = class LogstashTransport extends _winstonTransport.default {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"manager\", void 0);\n    _defineProperty(this, \"connection\", void 0);\n    _defineProperty(this, \"name\", void 0);\n    this.name = 'logstash';\n    this.connection = options.ssl_enable ? new _connection.SecureConnection(options) : new _connection.PlainConnection(options);\n    this.manager = new _manager.Manager(options, this.connection);\n    this.manager.on('error', this.onError.bind(this));\n    this.manager.start();\n  }\n  onError(error) {\n    this.silent = true;\n    this.emit('error', error);\n  }\n  log(info, callback) {\n    setImmediate(() => {\n      this.emit('logged', info);\n    });\n\n    // Perform the writing to the remote service\n    this.manager.log(JSON.stringify(info), callback);\n  }\n  close() {\n    this.manager.close();\n  }\n};\n",
        "called_code_segment": "log(info, callback) {\n    setImmediate(() => {\n      this.emit('logged', info);\n    });\n\n    // Perform the writing to the remote service\n    this.manager.log(JSON.stringify(info), callback);\n  }",
        "invoking_code_segment": "this.manager.log(JSON.stringify(info), callback);",
        "new_file_code_segment": "function logWithRetry(manager, message, callback, retries = 3) {\n  if (retries === 0) {\n    callback(new Error('Max retries reached'));\n    return;\n  }\n  manager.log(message, (err) => {\n    if (err) {\n      setTimeout(() => {\n        logWithRetry(manager, message, callback, retries - 1);\n      }, 1000);\n    } else {\n      callback();\n    }\n  });\n}",
        "feature_description": "Add retry mechanism for logging to handle transient errors.",
        "detailed_feature_description": "The new feature introduces a retry mechanism for logging operations. If a logging attempt fails, the system will retry the operation up to three times with a delay of one second between each retry. This is implemented in a new file (#file 3) and is invoked from #file 1 where the logging operation is performed. The modification in #file 1 ensures that the retry mechanism is used for logging, and #file 2 remains compatible by invoking the modified logging method.",
        "modified_complete_code": {
            "#file 1": "//Modify for modified parts and #New for newly added parts\n\nlog(info, callback) {\n    setImmediate(() => {\n      this.emit('logged', info);\n    });\n\n    // Perform the writing to the remote service\n    //Modify\n    logWithRetry(this.manager, JSON.stringify(info), callback);\n  }\n\n  //New\n  close() {\n    this.manager.close();\n  }",
            "#file 2": "//Modify for modified parts and #New for newly added parts\n\nthis.manager.log(JSON.stringify(info), callback);\n\n//Modify\nlogWithRetry(this.manager, JSON.stringify(info), callback);",
            "#file 3": "//New\nfunction logWithRetry(manager, message, callback, retries = 3) {\n  if (retries === 0) {\n    callback(new Error('Max retries reached'));\n    return;\n  }\n  manager.log(message, (err) => {\n    if (err) {\n      setTimeout(() => {\n        logWithRetry(manager, message, callback, retries - 1);\n      }, 1000);\n    } else {\n      callback();\n    }\n  });\n}"
        }
    },
    {
        "repo": "ach-ingen-zell",
        "content": "'ach-ingen-zell/src/jsx/Map.jsx'\n:import React from 'react';\nimport d3_scale from 'd3-scale';\nconst colorScale = d3_scale.viridis();\n\nexport default class Map extends React.Component {\n  render() {\n\n    // percentage of suffix ocurring in each bin\n    let percentages = {};\n\n    let placenames = {};\n\n    // max percentage (for defining the color scale)\n    let maxPercent = 0;\n    // total number of places with suffix\n    let totalCount = 0;\n\n    this.props.data.forEach((x)=>{\n      // for each bin\n\n      const myRegexp = new RegExp(this.props.suffix.join('$|') + '$', 'i');\n\n      // count matches with suffix\n      let hits = x.filter((y)=> y.label.match(myRegexp));\n      let count = hits.length;\n\n      totalCount += count;\n      percentages[x.id] = count/x.length;\n\n      placenames[x.id] = `${percentages[x.id].toFixed(3)}% of place names have suffix \\'${this.props.suffix[0]}\\' or variations: ${hits.map((y)=> y.label).filter(function(value, index, self) {return self.indexOf(value) === index;}).join(\", \")}`;\n      // count only bins with at least 20 villages or towns for color scale maximum\n      if(x.length>20) {\n        maxPercent = Math.max(maxPercent, percentages[x.id]);\n      }\n    });\n\n    colorScale.domain([maxPercent, 0])\n\n  \tlet dots = this.props.data.map((x)=>{\n      // one dot per bin\n  \t\tlet col = colorScale(percentages[x.id]);\n      if(percentages[x.id]>0){\n        return <circle key={x.id} cx={x.x} cy={x.y} r=\"2.5\" style={{\"fill\": col}}>\n        <title>{placenames[x.id]}</title>\n        </circle>;\n      } else {\n        return <circle key={x.id} cx={x.x} cy={x.y} r=\"2.5\" style={{\"fill\": col}}></circle>;\n      }\n\n  \t});\n\n    let mainLabel = this.props.suffix[0];\n    let variations = this.props.suffix.slice(1).map((x)=>`-${x}`).join(\", \");\n\n    return (\n      <div className=\"map-tile\">\n        <h2>-{mainLabel}</h2>\n        <h4>{variations}</h4>\n        <h3>{totalCount} places</h3>\n        <svg width=\"200\" height=\"300\">\n      \t\t{dots}\n      \t</svg>\n       </div>\n    );\n  }\n}\n\nexport default Map;\n\n'ach-ingen-zell/src/jsx/App.jsx'\n:import React from 'react';\nimport Map from 'Map';\n\nexport default class App extends React.Component {\n  render() {\n\n  \tlet maps = this.props.suffixList.map((suffix)=>\n  \t\t// one Map per suffix\n  \t\t<Map key={suffix} data={this.props.data} suffix={suffix}/>\n  \t\t);\n\n    return <div>\n    \t\t{maps}\n    \t</div>\n  }\n}\n\n",
        "called_code_segment": "export default class Map extends React.Component {\n  render() {\n    // percentage of suffix occurring in each bin\n    let percentages = {};\n\n    let placenames = {};\n\n    // max percentage (for defining the color scale)\n    let maxPercent = 0;\n    // total number of places with suffix\n    let totalCount = 0;\n\n    this.props.data.forEach((x)=>{\n      // for each bin\n\n      const myRegexp = new RegExp(this.props.suffix.join('$|') + '$', 'i');\n\n      // count matches with suffix\n      let hits = x.filter((y)=> y.label.match(myRegexp));\n      let count = hits.length;\n\n      totalCount += count;\n      percentages[x.id] = count/x.length;\n\n      placenames[x.id] = `${percentages[x.id].toFixed(3)}% of place names have suffix '${this.props.suffix[0]}' or variations: ${hits.map((y)=> y.label).filter(function(value, index, self) {return self.indexOf(value) === index;}).join(\", \")}`;\n      // count only bins with at least 20 villages or towns for color scale maximum\n      if(x.length>20) {\n        maxPercent = Math.max(maxPercent, percentages[x.id]);\n      }\n    });\n\n    colorScale.domain([maxPercent, 0])\n\n    let dots = this.props.data.map((x)=>{\n      // one dot per bin\n      let col = colorScale(percentages[x.id]);\n      if(percentages[x.id]>0){\n        return <circle key={x.id} cx={x.x} cy={x.y} r=\"2.5\" style={{\"fill\": col}}>\n        <title>{placenames[x.id]}</title>\n        </circle>;\n      } else {\n        return <circle key={x.id} cx={x.x} cy={x.y} r=\"2.5\" style={{\"fill\": col}}></circle>;\n      }\n\n    });\n\n    let mainLabel = this.props.suffix[0];\n    let variations = this.props.suffix.slice(1).map((x)=>`-${x}`).join(\", \");\n\n    return (\n      <div className=\"map-tile\">\n        <h2>-{mainLabel}</h2>\n        <h4>{variations}</h4>\n        <h3>{totalCount} places</h3>\n        <svg width=\"200\" height=\"300\">\n          {dots}\n        </svg>\n       </div>\n    );\n  }\n}",
        "invoking_code_segment": "let maps = this.props.suffixList.map((suffix)=>\n  // one Map per suffix\n  <Map key={suffix} data={this.props.data} suffix={suffix}/>\n  );",
        "new_file_code_segment": "export const getColorScale = (maxPercent) => {\n  const colorScale = d3_scale.viridis();\n  colorScale.domain([maxPercent, 0]);\n  return colorScale;\n};\n\nexport const calculatePercentages = (data, suffix) => {\n  let percentages = {};\n  let placenames = {};\n  let maxPercent = 0;\n  let totalCount = 0;\n\n  data.forEach((x) => {\n    const myRegexp = new RegExp(suffix.join('$|') + '$', 'i');\n    let hits = x.filter((y) => y.label.match(myRegexp));\n    let count = hits.length;\n\n    totalCount += count;\n    percentages[x.id] = count / x.length;\n\n    placenames[x.id] = `${percentages[x.id].toFixed(3)}% of place names have suffix '${suffix[0]}' or variations: ${hits.map((y) => y.label).filter((value, index, self) => self.indexOf(value) === index).join(\", \")}`;\n    if (x.length > 20) {\n      maxPercent = Math.max(maxPercent, percentages[x.id]);\n    }\n  });\n\n  return { percentages, placenames, maxPercent, totalCount };\n};",
        "feature_description": "Add a new feature to calculate percentages and generate a color scale using helper functions.",
        "detailed_feature_description": "The new feature involves refactoring the percentage calculation and color scale generation into helper functions. These functions are moved to a new file (`#file 3`) to improve code modularity and reusability. The `Map` component in `#file 1` now invokes these helper functions to perform the necessary calculations and generate the color scale. This approach ensures that the `Map` component remains clean and focused on rendering, while the logic is handled by the helper functions.",
        "modified_complete_code": {
            "#file 1": "import React from 'react';\nimport d3_scale from 'd3-scale';\nimport { getColorScale, calculatePercentages } from './utils'; //Modify\n\nexport default class Map extends React.Component {\n  render() {\n    const { percentages, placenames, maxPercent, totalCount } = calculatePercentages(this.props.data, this.props.suffix); //Modify\n    const colorScale = getColorScale(maxPercent); //Modify\n\n    let dots = this.props.data.map((x)=>{\n      // one dot per bin\n      let col = colorScale(percentages[x.id]);\n      if(percentages[x.id]>0){\n        return <circle key={x.id} cx={x.x} cy={x.y} r=\"2.5\" style={{\"fill\": col}}>\n        <title>{placenames[x.id]}</title>\n        </circle>;\n      } else {\n        return <circle key={x.id} cx={x.x} cy={x.y} r=\"2.5\" style={{\"fill\": col}}></circle>;\n      }\n\n    });\n\n    let mainLabel = this.props.suffix[0];\n    let variations = this.props.suffix.slice(1).map((x)=>`-${x}`).join(\", \");\n\n    return (\n      <div className=\"map-tile\">\n        <h2>-{mainLabel}</h2>\n        <h4>{variations}</h4>\n        <h3>{totalCount} places</h3>\n        <svg width=\"200\" height=\"300\">\n          {dots}\n        </svg>\n       </div>\n    );\n  }\n}",
            "#file 2": "import React from 'react';\nimport Map from 'Map';\n\nexport default class App extends React.Component {\n  render() {\n    let maps = this.props.suffixList.map((suffix)=>\n      // one Map per suffix\n      <Map key={suffix} data={this.props.data} suffix={suffix}/>\n      );\n\n    return <div>\n        {maps}\n      </div>\n  }\n}",
            "#file 3": "import d3_scale from 'd3-scale';\n\nexport const getColorScale = (maxPercent) => {\n  const colorScale = d3_scale.viridis();\n  colorScale.domain([maxPercent, 0]);\n  return colorScale;\n};\n\nexport const calculatePercentages = (data, suffix) => {\n  let percentages = {};\n  let placenames = {};\n  let maxPercent = 0;\n  let totalCount = 0;\n\n  data.forEach((x) => {\n    const myRegexp = new RegExp(suffix.join('$|') + '$', 'i');\n    let hits = x.filter((y) => y.label.match(myRegexp));\n    let count = hits.length;\n\n    totalCount += count;\n    percentages[x.id] = count / x.length;\n\n    placenames[x.id] = `${percentages[x.id].toFixed(3)}% of place names have suffix '${suffix[0]}' or variations: ${hits.map((y) => y.label).filter((value, index, self) => self.indexOf(value) === index).join(\", \")}`;\n    if (x.length > 20) {\n      maxPercent = Math.max(maxPercent, percentages[x.id]);\n    }\n  });\n\n  return { percentages, placenames, maxPercent, totalCount };\n};"
        }
    },
    {
        "repo": "ui5-ecosystem-showcase",
        "content": "'ui5-ecosystem-showcase/packages/cds-plugin-ui5/lib/applyUI5Middleware.js'\n:const path = require(\"path\");\nconst fs = require(\"fs\");\n\n/**\n * @typedef UI5AppInfo\n * @type {object}\n * @property {Array<string>} pages root path of the module\n */\n\n/**\n * @typedef applyUI5MiddlewareOptions\n * @type {object}\n * @property {string} [cwd] cwd to resolve relative config files to, e.g. \"./ui5.yaml\" or \"./ui5-workspace.yaml\" (defaults to `process.cwd()`)\n * @property {string} [basePath] base path of the UI5 application (defaults to `process.cwd()`)\n * @property {string} [configFile] name of the config file (defaults to \"ui5.yaml\")\n * @property {string} [configPath] /!\\ RESTRICTED /!\\ - path to the ui5.yaml (defaults to \"${basePath}/${configFile}\")\n * @property {string} [workspaceName] name of the workspace (defaults to \"default\" when the file at workspaceConfigPath exists)\n * @property {string} [workspaceConfigFile] name of the workspace config file (defaults to \"ui5-workspace.yaml\")\n * @property {string} [workspaceConfigPath] /!\\ RESTRICTED /!\\ - path to the ui5-workspace.yaml (defaults to \"${basePath}/${workspaceConfigFile}\")\n * @property {string} [versionOverride] Framework version to use instead of the one defined in the root project\n * @property {string} [cacheMode] /!\\ RESTRICTED /!\\ - Cache mode to use when consuming SNAPSHOT versions of a framework (one of: Default|False|Off)\n * @property {string} [log] the logger (defaults to console)\n */\n\n// inspired by https://github.com/SAP/karma-ui5/blob/main/lib/framework.js#L466-L522\n/**\n * Applies the middlewares for the UI5 application located in the given\n * root directory to the given router.\n * @param {import(\"express\").Router} router Express Router instance\n * @param {applyUI5MiddlewareOptions} options configuration options\n * @returns {UI5AppInfo} UI5 application information object\n */\nmodule.exports = async function applyUI5Middleware(router, options) {\n\tconst { graphFromPackageDependencies } = await import(\"@ui5/project/graph\");\n\tconst { createReaderCollection } = await import(\"@ui5/fs/resourceFactory\");\n\n\toptions.cwd = options.cwd || process.cwd();\n\toptions.basePath = options.basePath || process.cwd();\n\n\tconst log = options.log || console;\n\n\tconst configPath = options.configPath || options.basePath;\n\tconst configFile = options.configFile || \"ui5.yaml\";\n\tconst workspaceConfigPath = options.workspaceConfigPath || options.basePath;\n\tconst workspaceConfigFile = options.workspaceConfigFile || \"ui5-workspace.yaml\";\n\n\tconst determineConfigPath = function (configPath, configFile) {\n\t\t// ensure that the config path is absolute\n\t\tif (!path.isAbsolute(configPath)) {\n\t\t\tconfigPath = path.resolve(options.basePath, configPath);\n\t\t}\n\t\t// if the config path is a file, then we assume that this is the\n\t\t// configuration which should be used for the UI5 server middlewares\n\t\tif (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {\n\t\t\treturn configPath;\n\t\t}\n\t\t// if the configuration file is starting with ./ or ../ then we\n\t\t// resolve the configuration relative to the current working dir\n\t\t// otherwise we are resolving it relative to the config path\n\t\t// which is typically the directory of the UI5 application\n\t\tconfigPath = path.resolve(/^\\.\\.?\\//.test(configFile) ? options.cwd : configPath, configFile);\n\t\tif (fs.existsSync(configPath) && fs.statSync(configPath).isFile()) {\n\t\t\treturn configPath;\n\t\t}\n\t\t// nothing matched => no config\n\t\treturn undefined;\n\t};\n\n\tconst graph = await graphFromPackageDependencies({\n\t\tcwd: options.basePath,\n\t\trootConfigPath: determineConfigPath(configPath, configFile),\n\t\tworkspaceName: process.env[\"ui5-workspace\"] || options.workspaceName || \"default\",\n\t\tworkspaceConfigPath: determineConfigPath(workspaceConfigPath, workspaceConfigFile),\n\t\tversionOverride: options.versionOverride,\n\t\tcacheMode: options.cacheMode,\n\t});\n\n\tconst rootProject = graph.getRoot();\n\n\tconst readers = [];\n\tawait graph.traverseBreadthFirst(async function ({ project: dep }) {\n\t\tif (dep.getName() === rootProject.getName()) {\n\t\t\t// Ignore root project\n\t\t\treturn;\n\t\t}\n\t\treaders.push(dep.getReader({ style: \"runtime\" }));\n\t});\n\n\tconst dependencies = createReaderCollection({\n\t\tname: `Dependency reader collection for project ${rootProject.getName()}`,\n\t\treaders,\n\t});\n\n\tconst rootReader = rootProject.getReader({ style: \"runtime\" });\n\n\t// TODO change to ReaderCollection once duplicates are sorted out\n\tconst combo = createReaderCollection({\n\t\tname: \"server - prioritize workspace over dependencies\",\n\t\treaders: [rootReader, dependencies],\n\t});\n\tconst resources = {\n\t\trootProject: rootReader,\n\t\tdependencies: dependencies,\n\t\tall: combo,\n\t};\n\n\t// TODO: rework ui5-server API and make public\n\tconst { default: MiddlewareManager } = await import(\"@ui5/server/internal/MiddlewareManager\");\n\tconst middlewareManager = new MiddlewareManager({\n\t\tgraph,\n\t\trootProject,\n\t\tresources,\n\t\toptions: {\n\t\t\t//sendSAPTargetCSP,\n\t\t\t//serveCSPReports,\n\t\t\t//simpleIndex: true\n\t\t},\n\t});\n\tawait middlewareManager.applyMiddleware(router);\n\n\t// for Fiori elements based applications we need to invalidate the view cache\n\tconst isFioriElementsBased = rootProject.getFrameworkDependencies().find((lib) => lib.name.startsWith(\"sap.fe\"));\n\n\t// collect app pages from workspace (glob testing: https://globster.xyz/ and https://codepen.io/mrmlnc/pen/OXQjMe)\n\t//   -> but exclude the HTML fragments from the list of app pages!\n\tconst pages = (await rootReader.byGlob(\"**/!(*.fragment).{html,htm}\")).map((resource) => `${resource.getPath()}${isFioriElementsBased ? \"?sap-ui-xx-viewCache=false\" : \"\"}`);\n\n\t// collect app pages from middlewares implementing the getAppPages\n\tmiddlewareManager.middlewareExecutionOrder?.map((name) => {\n\t\tconst { middleware } = middlewareManager.middleware?.[name] || {};\n\t\tif (typeof middleware?.getAppPages === \"function\") {\n\t\t\tconst customAppPages = middleware.getAppPages();\n\t\t\tif (Array.isArray(customAppPages)) {\n\t\t\t\tpages.push(...customAppPages);\n\t\t\t} else {\n\t\t\t\tif (customAppPages) {\n\t\t\t\t\tlog.warn(`The middleware ${name} returns an unexpected value for \"getAppPages\". The value must be either undefined or string[]! Ignoring app pages from middleware!`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn {\n\t\tpages,\n\t};\n};\n\n'ui5-ecosystem-showcase/packages/cds-plugin-ui5/cds-plugin.js'\n:// >> IMPORTANT <<\n//\n// JEST has issues with dynamic imports and will fail when they are used,\n// e.g. in the findUI5Modules the UI5 tooling is used which is implemented\n// using ES modules. To avoid issues when running JEST tests, the plugin\n// will be disabled by default but it can be enforced with CDS_PLUGIN_UI5_ACTIVE=true\n// since JEST supports ES modules when using Node.js 21 and the experimental\n// support for VM modules via:\n//\n//   > NODE_OPTIONS=--experimental-vm-modules jest\n//\n// Details can be found in the following issue:\n//   - https://github.com/ui5-community/ui5-ecosystem-showcase/issues/901\n//\n// To disable JEST we rely on env variables (see https://jestjs.io/docs/environment-variables)\nlet skip = false;\nif (process.env.NODE_ENV === \"test\" && process.env.JEST_WORKER_ID && process.env.CDS_PLUGIN_UI5_ACTIVE !== \"true\") {\n\tconsole.log(\n\t\tprocess.env.NO_COLOR ? \"[%s] %s\" : \"\\x1b[36m[%s]\\x1b[0m \\x1b[31m%s\\x1b[0m\",\n\t\t\"cds-plugin-ui5\",\n\t\t\"Skip execution because JEST is running tests! To force the execution of the plugin set env var CDS_PLUGIN_UI5_ACTIVE=true...\",\n\t);\n\tskip = true;\n}\nif (process.env.CDS_PLUGIN_UI5_ACTIVE === \"false\") {\n\tconsole.log(process.env.NO_COLOR ? \"[%s] %s\" : \"\\x1b[36m[%s]\\x1b[0m \\x1b[31m%s\\x1b[0m\", \"cds-plugin-ui5\", \"Skip execution because it has been disabled by env var CDS_PLUGIN_UI5_ACTIVE!\");\n\tskip = true;\n}\n\n// only execute the plugin if it should not be skipped\nif (!skip) {\n\t// @sap/cds/lib/index.js#138: global.cds = cds // REVISIT: using global.cds seems wrong\n\tconst cds = global.cds || require(\"@sap/cds\"); // reuse already loaded cds!\n\n\t// add color support to the logger\n\tif (!(process.env.NO_COLOR || process.env.CDS_PLUGIN_UI5_NO_CUSTOM_LOGGER)) {\n\t\tconst LOG_COLORS = {\n\t\t\tTRACE: \"\\x1b[0m\", // default\n\t\t\tDEBUG: \"\\x1b[34m\", // blue\n\t\t\tINFO: \"\\x1b[32m\", // green\n\t\t\tWARN: \"\\x1b[33m\", // yellow\n\t\t\tERROR: \"\\x1b[31m\", // red\n\t\t};\n\t\tconst LOG_LEVEL_TO_COLOR = Object.fromEntries(Object.keys(LOG_COLORS).map((level) => [cds.log.levels[level], LOG_COLORS[level]]));\n\t\tconst LOG_LEVEL_TO_TEXT = Object.fromEntries(Object.keys(LOG_COLORS).map((level) => [cds.log.levels[level], level]));\n\t\tcds.log.format = (label, level, ...args) => {\n\t\t\treturn [\"\\x1b[36m[%s]\\x1b[0m %s[%s]\\x1b[0m %s\", label, LOG_LEVEL_TO_COLOR[level], LOG_LEVEL_TO_TEXT[level], ...args];\n\t\t};\n\t}\n\n\t// create a logger for the cds-plugin-ui5\n\tconst LOG = cds.log(\"cds-plugin-ui5\");\n\n\tconst findUI5Modules = require(\"./lib/findUI5Modules\");\n\tconst createPatchedRouter = require(\"./lib/createPatchedRouter\");\n\tconst applyUI5Middleware = require(\"./lib/applyUI5Middleware\");\n\tconst rewriteHTML = require(\"./lib/rewriteHTML\");\n\n\t// identify whether the execution should be skipped\n\tif (process.env[\"ui5-middleware-cap\"]) {\n\t\tLOG.info(\"Skip execution of plugin because is has been started via ui5-middleware-cap!\");\n\t\tskip = true;\n\t} else if (process.env[\"dev-approuter\"]) {\n\t\tLOG.info(\"Skip execution of plugin because is has been started via dev-approuter!\");\n\t\tskip = true;\n\t}\n\n\t// only hook into lifecycle if the plugin should not be skipped\n\tif (!skip) {\n\t\t// marker that the cds-plugin-ui5 plugin is running\n\t\t// to disable the ui5-middleware-cap if used in apps\n\t\tprocess.env[\"cds-plugin-ui5\"] = true;\n\n\t\tconst { dirname, join, resolve } = require(\"path\");\n\t\tconst { readFileSync, existsSync, realpathSync } = require(\"fs\");\n\t\tconst { execSync } = require(\"child_process\");\n\n\t\tconst { version: cdsPluginUI5Version } = require(`${__dirname}/package.json`);\n\n\t\t// function to resolve a module with the given paths without throwing an error\n\t\tconst resolveModule = function resolveModule(moduleName, paths) {\n\t\t\ttry {\n\t\t\t\treturn require.resolve(moduleName, { paths });\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t} catch (err) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\n\t\t// helper to find the package.json in the current dir or upwards\n\t\tconst findPackageJson = function findPackageJson(dir) {\n\t\t\tlet currentDir = dir;\n\t\t\twhile (currentDir !== resolve(currentDir, \"..\")) {\n\t\t\t\tconst packageJsonPath = join(currentDir, \"package.json\");\n\t\t\t\tif (existsSync(packageJsonPath)) {\n\t\t\t\t\treturn packageJsonPath;\n\t\t\t\t}\n\t\t\t\tcurrentDir = resolve(currentDir, \"..\");\n\t\t\t}\n\t\t\treturn undefined;\n\t\t};\n\n\t\t// find out the CDS-DK version to control the behavior of the plugin\n\t\tconst getCDSDKVersion = function getCDSDKVersion() {\n\t\t\tlet cdsDkPath = process.argv[1];\n\t\t\ttry {\n\t\t\t\tcdsDkPath = realpathSync(cdsDkPath);\n\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t} catch (err) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t\tconst cdsDkDir = dirname(cdsDkPath);\n\t\t\tconst packageJsonPath = findPackageJson(cdsDkDir);\n\t\t\tif (packageJsonPath) {\n\t\t\t\tconst packageJson = JSON.parse(readFileSync(packageJsonPath, { encoding: \"utf-8\" }));\n\t\t\t\treturn packageJson.version;\n\t\t\t} else {\n\t\t\t\tconst moduleName = \"@sap/cds-dk\";\n\t\t\t\tlet resolvedPath = resolveModule(`${moduleName}/package.json`);\n\t\t\t\tif (!resolvedPath) {\n\t\t\t\t\tconst globalModulesPath = execSync(\"npm root -g\").toString().trim();\n\t\t\t\t\tresolvedPath = resolveModule(`${moduleName}/package.json`, [globalModulesPath]);\n\t\t\t\t}\n\t\t\t\tif (resolvedPath) {\n\t\t\t\t\tconst packageJson = JSON.parse(readFileSync(resolvedPath, { encoding: \"utf-8\" }));\n\t\t\t\t\treturn packageJson.version;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t};\n\n\t\t// get the CDS-DK version to control the behavior of the plugin\n\t\tconst cdsdkVersion = getCDSDKVersion();\n\t\tconst logVersion = function () {\n\t\t\t// logging the version of the cds-plugin-ui5\n\t\t\tLOG.info(`Running cds-plugin-ui5@${cdsPluginUI5Version} (@sap/cds-dk@${cdsdkVersion}, @sap/cds@${cds.version})`);\n\t\t\tif (global.__cds_loaded_from?.size > 1) {\n\t\t\t\tLOG.warn(\"  !! Multiple versions of @sap/cds loaded !!\");\n\t\t\t\tglobal.__cds_loaded_from.forEach((cdsPath) => {\n\t\t\t\t\tLOG.warn(`    => ${cdsPath}`);\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t// promise to await the bootstrap and lock the\n\t\t// served event to delay the startup a bit\n\t\tlet bootstrapped;\n\t\tconst bootstrapCompleted = new Promise((r) => {\n\t\t\tbootstrapped = r;\n\t\t});\n\n\t\t// hook into the \"served\" event to delay the startup of the\n\t\t// CDS server until the bootstrap is completed and the UI5\n\t\t// middlewares for the UI5 applications are properly available\n\t\tcds.on(\"served\", async function served(/* cdsServices */) {\n\t\t\tLOG.debug(\"served\");\n\t\t\tawait bootstrapCompleted;\n\t\t});\n\n\t\t// hook into the \"bootstrap\" event to startup the UI5 middlewares\n\t\t// for the available UI5 applications in the CDS server and its deps\n\t\tcds.on(\"bootstrap\", async function bootstrap(app) {\n\t\t\tLOG.debug(\"bootstrap\");\n\n\t\t\t// only for cds serve or serving all services the cds-plugin-ui5 is active\n\t\t\tif (cds.cli?.command === \"serve\" || cds.options?.service === \"all\") {\n\t\t\t\tconst cwd = cds.env?._home || process.cwd();\n\t\t\t\tconst ui5Modules = await findUI5Modules({ cwd, cds, LOG });\n\t\t\t\tconst { localApps, config } = ui5Modules;\n\n\t\t\t\tconst links = [];\n\n\t\t\t\t// log the version of the cds-plugin-ui5\n\t\t\t\tlogVersion();\n\n\t\t\t\t// register the UI5 modules via their own router/middlewares\n\t\t\t\tfor await (const ui5Module of ui5Modules) {\n\t\t\t\t\tconst { moduleId, mountPath, modulePath } = ui5Module;\n\n\t\t\t\t\t// mounting the Router for the UI5 application to the CDS server\n\t\t\t\t\tLOG.info(`Mounting ${mountPath} to UI5 app ${modulePath} (id=${moduleId})${config[moduleId] ? ` using config=${JSON.stringify(config[moduleId])}` : \"\"}`);\n\n\t\t\t\t\t// create a patched router\n\t\t\t\t\tconst router = await createPatchedRouter();\n\n\t\t\t\t\t// apply the UI5 middlewares to the router and\n\t\t\t\t\t// retrieve the available HTML pages\n\t\t\t\t\tconst appInfo = await applyUI5Middleware(router, {\n\t\t\t\t\t\tcwd,\n\t\t\t\t\t\tbasePath: modulePath,\n\t\t\t\t\t\t...(config[moduleId] || {}),\n\t\t\t\t\t\tLOG,\n\t\t\t\t\t});\n\n\t\t\t\t\t// register the router to the specified mount path\n\t\t\t\t\tapp.use(mountPath, router);\n\n\t\t\t\t\t// append the HTML pages to the links\n\t\t\t\t\tappInfo.pages.forEach((page) => {\n\t\t\t\t\t\tconst prefix = mountPath !== \"/\" ? mountPath : \"\";\n\t\t\t\t\t\tlinks.push(`${prefix}${page}`);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// identify whether the welcome page should be rewritten\n\t\t\t\tlet rewrite = links.length > 0;\n\n\t\t\t\t// rewrite the welcome page\n\t\t\t\tif (rewrite) {\n\t\t\t\t\t// register the custom middleware (similar like in @sap/cds/server.js)\n\t\t\t\t\tapp.get(\"/\", function appendLinksToIndex(req, res, next) {\n\t\t\t\t\t\treq._cds_plugin_ui5 = true; // marker for patched router to ignore\n\t\t\t\t\t\trewriteHTML(\n\t\t\t\t\t\t\treq,\n\t\t\t\t\t\t\tres,\n\t\t\t\t\t\t\t() => true,\n\t\t\t\t\t\t\t(doc) => {\n\t\t\t\t\t\t\t\t// the first <ul> element contains the links to the\n\t\t\t\t\t\t\t\t// application pages which is fully under control of\n\t\t\t\t\t\t\t\t// our plugin now and we keep all links to static\n\t\t\t\t\t\t\t\t// pages to ensure coop with classic apps\n\t\t\t\t\t\t\t\tconst head = doc.getElementsByTagName(\"head\")?.[0];\n\t\t\t\t\t\t\t\thead?.insertAdjacentHTML(\n\t\t\t\t\t\t\t\t\t\"beforeend\",\n\t\t\t\t\t\t\t\t\t`<style>\n\t\t\t\t\t\t\t\ta.ui5:after {\n\t\t\t\t\t\t\t\t\tcontent: \"UI5\";\n\t\t\t\t\t\t\t\t\tfont-weight: bold;\n\t\t\t\t\t\t\t\t\tfont-size: 0.5rem;\n\t\t\t\t\t\t\t\t\tvertical-align: super;\n\t\t\t\t\t\t\t\t\tmargin: 0.25rem;\n\t\t\t\t\t\t\t\t\tcolor: #1873B4;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t@media (prefers-color-scheme: dark) {\n\t\t\t\t\t\t\t\t\ta.ui5:after {\n\t\t\t\t\t\t\t\t\t\tcolor: #FF5A37;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t</style>`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst ul = doc.getElementsByTagName(\"ul\")?.[0];\n\t\t\t\t\t\t\t\tif (ul) {\n\t\t\t\t\t\t\t\t\tconst newLis = [];\n\t\t\t\t\t\t\t\t\tconst lis = ul.getElementsByTagName(\"li\");\n\t\t\t\t\t\t\t\t\tlis?.forEach((li) => {\n\t\t\t\t\t\t\t\t\t\tconst appDir = li.firstChild?.text?.split(\"/\")?.[1];\n\t\t\t\t\t\t\t\t\t\tif (localApps.has(appDir)) {\n\t\t\t\t\t\t\t\t\t\t\tnewLis.push(li.toString());\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tnewLis.push(\n\t\t\t\t\t\t\t\t\t\t...links.sort().map((link) => {\n\t\t\t\t\t\t\t\t\t\t\t// we remove the query parameters from the link text\n\t\t\t\t\t\t\t\t\t\t\tconst linkText = link.indexOf(\"?\") === -1 ? link : link.substr(0, link.indexOf(\"?\"));\n\t\t\t\t\t\t\t\t\t\t\t// renders a UI5 link ;-)\n\t\t\t\t\t\t\t\t\t\t\treturn `<li><a class=\"ui5\" href=\"${link}\">${linkText}</a></li>`;\n\t\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tul.innerHTML = newLis.join(\"\\n\");\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tLOG.warn(`Failed to inject application links into CDS index page!`);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t);\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\n\t\t\t\t\t// move our middleware before the CDS index serve middleware to\n\t\t\t\t\t// allow that we can intercept the response and modify it to\n\t\t\t\t\t// inject our application pages an remove the exitsing ones\n\t\t\t\t\tconst middlewareStack = app?._router?.stack;\n\t\t\t\t\tif (Array.isArray(middlewareStack)) {\n\t\t\t\t\t\tconst cmw = middlewareStack.pop();\n\t\t\t\t\t\tconst idxOfServeStatic = middlewareStack.findIndex((layer) => layer.name === \"serveStatic\");\n\t\t\t\t\t\tif (idxOfServeStatic !== -1) {\n\t\t\t\t\t\t\tmiddlewareStack.splice(idxOfServeStatic, 0, cmw);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLOG.error(`Failed to determine welcome page middleware! The links of the application pages may not work properly!`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLOG.error(`Failed to inject application pages to welcome page! The links of the application pages may not work properly!`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLOG.info(\"Skip execution of plugin! The plugin is only active for 'cds serve'!\");\n\t\t\t}\n\n\t\t\t// bootstrap completed, unlock the \"served\" event\n\t\t\tbootstrapped();\n\t\t});\n\n\t\t// check if the register function for build tasks is available at the cds object\n\t\t// and if the Plugin class is available to register the cds build task to cover\n\t\t// the tracks of the cds-plugin-ui5 workspace configuration and dependencies\n\t\tconst { minVersion, satisfies } = require(\"semver\");\n\t\tif (typeof cds.build?.register === \"function\" && typeof cds.build?.Plugin?.constructor === \"function\") {\n\t\t\tconst { readFile, writeFile } = require(\"fs\").promises;\n\t\t\tconst { existsSync } = require(\"fs\");\n\t\t\tconst { join } = require(\"path\");\n\t\t\tconst util = require(\"util\");\n\t\t\tconst exec = util.promisify(require(\"child_process\").exec);\n\n\t\t\t// log the version of the cds-plugin-ui5\n\t\t\tlogVersion();\n\n\t\t\t// helper to check whether a semantic version is valid\n\t\t\tconst valid = (version) => {\n\t\t\t\ttry {\n\t\t\t\t\treturn minVersion(version) !== null;\n\t\t\t\t\t// eslint-disable-next-line no-unused-vars\n\t\t\t\t} catch (err) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// register the cds build task to sanitize the package.json and update the package-lock.json\n\t\t\tcds.build.register(\n\t\t\t\t\"ui5\",\n\t\t\t\t/**\n\t\t\t\t * CDS Build Plugin to ensure that the workspace configuration and the workspace dev\n\t\t\t\t * dependencies are removed and finally runs the npm install --package-lock-only to\n\t\t\t\t * update the package-lock.json\n\t\t\t\t */\n\t\t\t\tclass UI5Plugin extends cds.build.Plugin {\n\t\t\t\t\tstatic taskDefaults = { src: cds.env.folders.srv };\n\t\t\t\t\tstatic hasTask() {\n\t\t\t\t\t\treturn true; // plugin is a cds build task\n\t\t\t\t\t}\n\t\t\t\t\tinit() {}\n\t\t\t\t\tclean() {\n\t\t\t\t\t\tif (!satisfies(cdsdkVersion, \">=8\")) {\n\t\t\t\t\t\t\tthis._priority = -1; // hack to ensure that the task is executed last!\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tget priority() {\n\t\t\t\t\t\tif (!satisfies(cdsdkVersion, \">=8\")) {\n\t\t\t\t\t\t\treturn this._priority || 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tasync build() {\n\t\t\t\t\t\t// determine the namespace from the model\n\t\t\t\t\t\tconst model = await this.model();\n\t\t\t\t\t\tif (!model) return;\n\t\t\t\t\t\tconst namespace = model.namespace || \"<unknown>\";\n\t\t\t\t\t\t// sanitize the package.json if it exists\n\t\t\t\t\t\tconst packageJsonPath = join(this.task.dest, \"package.json\");\n\t\t\t\t\t\tif (existsSync(packageJsonPath)) {\n\t\t\t\t\t\t\tLOG.info(`Sanitizing the package.json for \"${namespace}\"...`);\n\t\t\t\t\t\t\tconst packageJson = JSON.parse(await readFile(packageJsonPath), \"utf-8\");\n\t\t\t\t\t\t\tlet modified = false;\n\t\t\t\t\t\t\t// remove the workspace configuration\n\t\t\t\t\t\t\tif (packageJson.workspaces) {\n\t\t\t\t\t\t\t\tdelete packageJson.workspaces;\n\t\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// remove the workspace dev dependencies and the cds-plugin-ui5\n\t\t\t\t\t\t\tif (packageJson.devDependencies) {\n\t\t\t\t\t\t\t\tpackageJson.devDependencies = Object.entries(packageJson.devDependencies).reduce((acc, [dep, version]) => {\n\t\t\t\t\t\t\t\t\tif (valid(version) && dep !== \"cds-plugin-ui5\") {\n\t\t\t\t\t\t\t\t\t\tacc[dep] = version;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn acc;\n\t\t\t\t\t\t\t\t}, {});\n\t\t\t\t\t\t\t\tmodified = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// overwrite the package.json if it was modified only\n\t\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\t\tawait writeFile(packageJsonPath, JSON.stringify(packageJson, null, 2), \"utf-8\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// update the package-lock.json if it exists\n\t\t\t\t\t\tif (existsSync(join(this.task.dest, \"package-lock.json\"))) {\n\t\t\t\t\t\t\tLOG.info(`Updating the package-lock.json for \"${namespace}\"...`);\n\t\t\t\t\t\t\t// run the npm install --package-lock-only to only update the package-lock.json\n\t\t\t\t\t\t\t// without installing the dependencies to node_modules\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t/* const { stdout, stderr } = */ await exec(\"npm install --package-lock-only\", { cwd: this.task.dest });\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\tLOG.error(`Failed to update the package-lock.json for \"${namespace}\"! Error: ${e.code} - ${e.message}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t);\n\t\t} else {\n\t\t\tif (!satisfies(cdsdkVersion, \">=7.5.0\")) {\n\t\t\t\t// TODO: add error message to inform the user that the cds build task is not available\n\t\t\t\t//       and that the @sap/cds-dk version is too old to support the cds build task\n\t\t\t\tLOG.warn(\"The cds build task requires @sap/cds-dk version >= 7.5.0! Skipping execution as your @sap/cds-dk version is too old...\");\n\t\t\t}\n\t\t}\n\t}\n}\n\n",
        "called_code_segment": "module.exports = async function applyUI5Middleware(router, options) {\n  const { graphFromPackageDependencies } = await import(\"@ui5/project/graph\");\n  const { createReaderCollection } = await import(\"@ui5/fs/resourceFactory\");\n  // ... (rest of the code in applyUI5Middleware)\n}",
        "invoking_code_segment": "const applyUI5Middleware = require(\"./lib/applyUI5Middleware\");\n// ...\nconst appInfo = await applyUI5Middleware(router, {\n  cwd,\n  basePath: modulePath,\n  ...(config[moduleId] || {}),\n  LOG,\n});",
        "new_file_code_segment": "module.exports = async function additionalMiddleware(router, options) {\n  // Additional middleware logic\n  router.use((req, res, next) => {\n    // Custom middleware logic\n    next();\n  });\n}",
        "feature_description": "Add a new middleware to enhance functionality in the UI5 application.",
        "detailed_feature_description": "The new feature introduces an additional middleware in #file 3 that is invoked by #file 1. This middleware enhances the functionality of the UI5 application by adding custom logic to the request/response cycle. The modification in #file 1 ensures that the new middleware is applied alongside the existing middlewares, maintaining compatibility with #file 2.",
        "modified_complete_code": {
            "#file 1": "module.exports = async function applyUI5Middleware(router, options) {\n  const { graphFromPackageDependencies } = await import(\"@ui5/project/graph\");\n  const { createReaderCollection } = await import(\"@ui5/fs/resourceFactory\");\n  // ... (rest of the code in applyUI5Middleware)\n  #Modify const additionalMiddleware = require(\"./additionalMiddleware\");\n  #Modify await additionalMiddleware(router, options);\n}",
            "#file 2": "const applyUI5Middleware = require(\"./lib/applyUI5Middleware\");\n// ...\nconst appInfo = await applyUI5Middleware(router, {\n  cwd,\n  basePath: modulePath,\n  ...(config[moduleId] || {}),\n  LOG,\n});",
            "#file 3": "module.exports = async function additionalMiddleware(router, options) {\n  #New router.use((req, res, next) => {\n    #New // Custom middleware logic\n    #New next();\n  #New });\n}"
        }
    },
    {
        "repo": "Instagram",
        "content": "'Instagram/components/PhotoGridItem.js'\n:import { Ionicons } from '@expo/vector-icons';\nimport React from 'react';\nimport { Image, TouchableOpacity } from 'react-native';\n\nimport Square from './Square';\nimport NavigationService from '../navigation/NavigationService';\n\nexport default class PhotoGridItem extends React.PureComponent {\n  render() {\n    const { hasMulti } = this.props;\n    return (\n      <Square\n        style={{\n          aspectRatio: 1,\n          flex: 0.333,\n          marginRight: 1,\n        }}\n      >\n        <TouchableOpacity\n          onPress={() =>\n            NavigationService.navigate('Profile_Details', { item: this.props })\n          }\n          activeOpacity={0.6}\n          style={{ flex: 1 }}\n        >\n          <Image\n            style={{\n              resizeMode: 'cover',\n              flex: 1,\n            }}\n            source={this.props.source}\n          />\n        </TouchableOpacity>\n\n        {hasMulti && (\n          <Ionicons\n            style={{\n              transform: [{ scaleX: -1 }],\n              position: 'absolute',\n              top: 8,\n              right: 8,\n            }}\n            name={'md-copy'}\n            size={26}\n            color={'white'}\n          />\n        )}\n      </Square>\n    );\n  }\n}\n\n'Instagram/components/PhotoGrid.js'\n:import React from 'react';\nimport { FlatList } from 'react-native';\n\nimport PhotoGridItem from './PhotoGridItem';\n\nexport default class PhotoGrid extends React.Component {\n  render() {\n    const { onPressFooter, ...props } = this.props;\n    return (\n      <FlatList\n        numColumns={3}\n        columnWrapperStyle={{\n          marginHorizontal: -1,\n          marginBottom: 1,\n          justifyContent: 'space-between',\n        }}\n        contentContainerStyle={{ marginBottom: 64 }}\n        renderItem={({ item }) => <PhotoGridItem {...item} />}\n        keyExtractor={(item, index) => item.key + ' ' + index}\n        {...props}\n      />\n    );\n  }\n}\n\n",
        "called_code_segment": "render() {\n    const { hasMulti } = this.props;\n    return (\n      <Square\n        style={{ aspectRatio: 1, flex: 0.333, marginRight: 1 }}\n      >\n        <TouchableOpacity\n          onPress={() =>\n            NavigationService.navigate('Profile_Details', { item: this.props })\n          }\n          activeOpacity={0.6}\n          style={{ flex: 1 }}\n        >\n          <Image\n            style={{ resizeMode: 'cover', flex: 1 }}\n            source={this.props.source}\n          />\n        </TouchableOpacity>\n\n        {hasMulti &&\n          <Ionicons\n            style={{ transform: [{ scaleX: -1 }], position: 'absolute', top: 8, right: 8 }}\n            name={'md-copy'}\n            size={26}\n            color={'white'}\n          />\n        }\n      </Square>\n    );\n  }",
        "invoking_code_segment": "render() {\n    const { onPressFooter, ...props } = this.props;\n    return (\n      <FlatList\n        numColumns={3}\n        columnWrapperStyle={{ marginHorizontal: -1, marginBottom: 1, justifyContent: 'space-between' }}\n        contentContainerStyle={{ marginBottom: 64 }}\n        renderItem={({ item }) => <PhotoGridItem {...item} />}\n        keyExtractor={(item, index) => item.key + ' ' + index}\n        {...props}\n      />\n    );\n  }",
        "new_file_code_segment": "export const handlePhotoPress = (item) => {\n  NavigationService.navigate('Profile_Details', { item });\n};\n\nexport const renderMultiIcon = (hasMulti) => {\n  if (hasMulti) {\n    return (\n      <Ionicons\n        style={{ transform: [{ scaleX: -1 }], position: 'absolute', top: 8, right: 8 }}\n        name={'md-copy'}\n        size={26}\n        color={'white'}\n      />\n    );\n  }\n  return null;\n};",
        "feature_description": "Add a new feature to handle photo press and render multi icon in a more modular way.",
        "detailed_feature_description": "The new feature modularizes the handling of photo press and rendering of the multi icon. This is achieved by creating a new file (#file 3) that contains functions to handle these actions. The PhotoGridItem component in #file 1 is updated to use these functions, making the code cleaner and more maintainable. The PhotoGrid component in #file 2 remains unchanged as it continues to render the PhotoGridItem component.",
        "modified_complete_code": {
            "#file 1": "import React from 'react';\nimport { Image, TouchableOpacity } from 'react-native';\nimport Square from './Square';\nimport { handlePhotoPress, renderMultiIcon } from './PhotoGridItemUtils'; #New\n\nexport default class PhotoGridItem extends React.PureComponent {\n  render() {\n    const { hasMulti } = this.props;\n    return (\n      <Square\n        style={{ aspectRatio: 1, flex: 0.333, marginRight: 1 }}\n      >\n        <TouchableOpacity\n          onPress={() => handlePhotoPress(this.props)} #Modify\n          activeOpacity={0.6}\n          style={{ flex: 1 }}\n        >\n          <Image\n            style={{ resizeMode: 'cover', flex: 1 }}\n            source={this.props.source}\n          />\n        </TouchableOpacity>\n\n        {renderMultiIcon(hasMulti)} #Modify\n      </Square>\n    );\n  }\n}",
            "#file 2": "import React from 'react';\nimport { FlatList } from 'react-native';\nimport PhotoGridItem from './PhotoGridItem';\n\nexport default class PhotoGrid extends React.Component {\n  render() {\n    const { onPressFooter, ...props } = this.props;\n    return (\n      <FlatList\n        numColumns={3}\n        columnWrapperStyle={{ marginHorizontal: -1, marginBottom: 1, justifyContent: 'space-between' }}\n        contentContainerStyle={{ marginBottom: 64 }}\n        renderItem={({ item }) => <PhotoGridItem {...item} />}\n        keyExtractor={(item, index) => item.key + ' ' + index}\n        {...props}\n      />\n    );\n  }\n}",
            "#file 3": "import NavigationService from '../navigation/NavigationService';\nimport { Ionicons } from '@expo/vector-icons';\n\nexport const handlePhotoPress = (item) => {\n  NavigationService.navigate('Profile_Details', { item });\n};\n\nexport const renderMultiIcon = (hasMulti) => {\n  if (hasMulti) {\n    return (\n      <Ionicons\n        style={{ transform: [{ scaleX: -1 }], position: 'absolute', top: 8, right: 8 }}\n        name={'md-copy'}\n        size={26}\n        color={'white'}\n      />\n    );\n  }\n  return null;\n};"
        }
    },
    {
        "repo": "Knockout-UI",
        "content": "'Knockout-UI/examples/js/shCore.js'\n:/**\n * SyntaxHighlighter\n * http://alexgorbatchev.com/SyntaxHighlighter\n *\n * SyntaxHighlighter is donationware. If you are using it, please donate.\n * http://alexgorbatchev.com/SyntaxHighlighter/donate.html\n *\n * @version\n * 3.0.83 (July 02 2010)\n * \n * @copyright\n * Copyright (C) 2004-2010 Alex Gorbatchev.\n *\n * @license\n * Dual licensed under the MIT and GPL licenses.\n */\neval(function(p,a,c,k,e,d){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--){d[e(c)]=k[c]||e(c)}k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1};while(c--){if(k[c]){p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c])}}return p}('K M;I(M)1S 2U(\"2a\\'t 4k M 4K 2g 3l 4G 4H\");(6(){6 r(f,e){I(!M.1R(f))1S 3m(\"3s 15 4R\");K a=f.1w;f=M(f.1m,t(f)+(e||\"\"));I(a)f.1w={1m:a.1m,19:a.19?a.19.1a(0):N};H f}6 t(f){H(f.1J?\"g\":\"\")+(f.4s?\"i\":\"\")+(f.4p?\"m\":\"\")+(f.4v?\"x\":\"\")+(f.3n?\"y\":\"\")}6 B(f,e,a,b){K c=u.L,d,h,g;v=R;5K{O(;c--;){g=u[c];I(a&g.3r&&(!g.2p||g.2p.W(b))){g.2q.12=e;I((h=g.2q.X(f))&&h.P===e){d={3k:g.2b.W(b,h,a),1C:h};1N}}}}5v(i){1S i}5q{v=11}H d}6 p(f,e,a){I(3b.Z.1i)H f.1i(e,a);O(a=a||0;a<f.L;a++)I(f[a]===e)H a;H-1}M=6(f,e){K a=[],b=M.1B,c=0,d,h;I(M.1R(f)){I(e!==1d)1S 3m(\"2a\\'t 5r 5I 5F 5B 5C 15 5E 5p\");H r(f)}I(v)1S 2U(\"2a\\'t W 3l M 59 5m 5g 5x 5i\");e=e||\"\";O(d={2N:11,19:[],2K:6(g){H e.1i(g)>-1},3d:6(g){e+=g}};c<f.L;)I(h=B(f,c,b,d)){a.U(h.3k);c+=h.1C[0].L||1}Y I(h=n.X.W(z[b],f.1a(c))){a.U(h[0]);c+=h[0].L}Y{h=f.3a(c);I(h===\"[\")b=M.2I;Y I(h===\"]\")b=M.1B;a.U(h);c++}a=15(a.1K(\"\"),n.Q.W(e,w,\"\"));a.1w={1m:f,19:d.2N?d.19:N};H a};M.3v=\"1.5.0\";M.2I=1;M.1B=2;K C=/\\\\$(?:(\\\\d\\\\d?|[$&`\\'])|{([$\\\\w]+)})/g,w=/[^5h]+|([\\\\s\\\\S])(?=[\\\\s\\\\S]*\\\\1)/g,A=/^(?:[?*+]|{\\\\d+(?:,\\\\d*)?})\\\\??/,v=11,u=[],n={X:15.Z.X,1A:15.Z.1A,1C:1r.Z.1C,Q:1r.Z.Q,1e:1r.Z.1e},x=n.X.W(/()??/,\"\")[1]===1d,D=6(){K f=/^/g;n.1A.W(f,\"\");H!f.12}(),y=6(){K f=/x/g;n.Q.W(\"x\",f,\"\");H!f.12}(),E=15.Z.3n!==1d,z={};z[M.2I]=/^(?:\\\\\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\\\29-26-f]{2}|u[\\\\29-26-f]{4}|c[A-3o-z]|[\\\\s\\\\S]))/;z[M.1B]=/^(?:\\\\\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\\\d*|x[\\\\29-26-f]{2}|u[\\\\29-26-f]{4}|c[A-3o-z]|[\\\\s\\\\S])|\\\\(\\\\?[:=!]|[?*+]\\\\?|{\\\\d+(?:,\\\\d*)?}\\\\??)/;M.1h=6(f,e,a,b){u.U({2q:r(f,\"g\"+(E?\"y\":\"\")),2b:e,3r:a||M.1B,2p:b||N})};M.2n=6(f,e){K a=f+\"/\"+(e||\"\");H M.2n[a]||(M.2n[a]=M(f,e))};M.3c=6(f){H r(f,\"g\")};M.5l=6(f){H f.Q(/[-[\\\\]{}()*+?.,\\\\\\\\^$|#\\\\s]/g,\"\\\\\\\\$&\")};M.5e=6(f,e,a,b){e=r(e,\"g\"+(b&&E?\"y\":\"\"));e.12=a=a||0;f=e.X(f);H b?f&&f.P===a?f:N:f};M.3q=6(){M.1h=6(){1S 2U(\"2a\\'t 55 1h 54 3q\")}};M.1R=6(f){H 53.Z.1q.W(f)===\"[2m 15]\"};M.3p=6(f,e,a,b){O(K c=r(e,\"g\"),d=-1,h;h=c.X(f);){a.W(b,h,++d,f,c);c.12===h.P&&c.12++}I(e.1J)e.12=0};M.57=6(f,e){H 6 a(b,c){K d=e[c].1I?e[c]:{1I:e[c]},h=r(d.1I,\"g\"),g=[],i;O(i=0;i<b.L;i++)M.3p(b[i],h,6(k){g.U(d.3j?k[d.3j]||\"\":k[0])});H c===e.L-1||!g.L?g:a(g,c+1)}([f],0)};15.Z.1p=6(f,e){H J.X(e[0])};15.Z.W=6(f,e){H J.X(e)};15.Z.X=6(f){K e=n.X.1p(J,14),a;I(e){I(!x&&e.L>1&&p(e,\"\")>-1){a=15(J.1m,n.Q.W(t(J),\"g\",\"\"));n.Q.W(f.1a(e.P),a,6(){O(K c=1;c<14.L-2;c++)I(14[c]===1d)e[c]=1d})}I(J.1w&&J.1w.19)O(K b=1;b<e.L;b++)I(a=J.1w.19[b-1])e[a]=e[b];!D&&J.1J&&!e[0].L&&J.12>e.P&&J.12--}H e};I(!D)15.Z.1A=6(f){(f=n.X.W(J,f))&&J.1J&&!f[0].L&&J.12>f.P&&J.12--;H!!f};1r.Z.1C=6(f){M.1R(f)||(f=15(f));I(f.1J){K e=n.1C.1p(J,14);f.12=0;H e}H f.X(J)};1r.Z.Q=6(f,e){K a=M.1R(f),b,c;I(a&&1j e.58()===\"3f\"&&e.1i(\"${\")===-1&&y)H n.Q.1p(J,14);I(a){I(f.1w)b=f.1w.19}Y f+=\"\";I(1j e===\"6\")c=n.Q.W(J,f,6(){I(b){14[0]=1f 1r(14[0]);O(K d=0;d<b.L;d++)I(b[d])14[0][b[d]]=14[d+1]}I(a&&f.1J)f.12=14[14.L-2]+14[0].L;H e.1p(N,14)});Y{c=J+\"\";c=n.Q.W(c,f,6(){K d=14;H n.Q.W(e,C,6(h,g,i){I(g)5b(g){24\"$\":H\"$\";24\"&\":H d[0];24\"`\":H d[d.L-1].1a(0,d[d.L-2]);24\"\\'\":H d[d.L-1].1a(d[d.L-2]+d[0].L);5a:i=\"\";g=+g;I(!g)H h;O(;g>d.L-3;){i=1r.Z.1a.W(g,-1)+i;g=1Q.3i(g/10)}H(g?d[g]||\"\":\"$\")+i}Y{g=+i;I(g<=d.L-3)H d[g];g=b?p(b,i):-1;H g>-1?d[g+1]:h}})})}I(a&&f.1J)f.12=0;H c};1r.Z.1e=6(f,e){I(!M.1R(f))H n.1e.1p(J,14);K a=J+\"\",b=[],c=0,d,h;I(e===1d||+e<0)e=5D;Y{e=1Q.3i(+e);I(!e)H[]}O(f=M.3c(f);d=f.X(a);){I(f.12>c){b.U(a.1a(c,d.P));d.L>1&&d.P<a.L&&3b.Z.U.1p(b,d.1a(1));h=d[0].L;c=f.12;I(b.L>=e)1N}f.12===d.P&&f.12++}I(c===a.L){I(!n.1A.W(f,\"\")||h)b.U(\"\")}Y b.U(a.1a(c));H b.L>e?b.1a(0,e):b};M.1h(/\\\\(\\\\?#[^)]*\\\\)/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?\"\":\"(?:)\"});M.1h(/\\\\((?!\\\\?)/,6(){J.19.U(N);H\"(\"});M.1h(/\\\\(\\\\?<([$\\\\w]+)>/,6(f){J.19.U(f[1]);J.2N=R;H\"(\"});M.1h(/\\\\\\\\k<([\\\\w$]+)>/,6(f){K e=p(J.19,f[1]);H e>-1?\"\\\\\\\\\"+(e+1)+(3R(f.2S.3a(f.P+f[0].L))?\"\":\"(?:)\"):f[0]});M.1h(/\\\\[\\\\^?]/,6(f){H f[0]===\"[]\"?\"\\\\\\\\b\\\\\\\\B\":\"[\\\\\\\\s\\\\\\\\S]\"});M.1h(/^\\\\(\\\\?([5A]+)\\\\)/,6(f){J.3d(f[1]);H\"\"});M.1h(/(?:\\\\s+|#.*)+/,6(f){H n.1A.W(A,f.2S.1a(f.P+f[0].L))?\"\":\"(?:)\"},M.1B,6(){H J.2K(\"x\")});M.1h(/\\\\./,6(){H\"[\\\\\\\\s\\\\\\\\S]\"},M.1B,6(){H J.2K(\"s\")})})();1j 2e!=\"1d\"&&(2e.M=M);K 1v=6(){6 r(a,b){a.1l.1i(b)!=-1||(a.1l+=\" \"+b)}6 t(a){H a.1i(\"3e\")==0?a:\"3e\"+a}6 B(a){H e.1Y.2A[t(a)]}6 p(a,b,c){I(a==N)H N;K d=c!=R?a.3G:[a.2G],h={\"#\":\"1c\",\".\":\"1l\"}[b.1o(0,1)]||\"3h\",g,i;g=h!=\"3h\"?b.1o(1):b.5u();I((a[h]||\"\").1i(g)!=-1)H a;O(a=0;d&&a<d.L&&i==N;a++)i=p(d[a],b,c);H i}6 C(a,b){K c={},d;O(d 2g a)c[d]=a[d];O(d 2g b)c[d]=b[d];H c}6 w(a,b,c,d){6 h(g){g=g||1P.5y;I(!g.1F){g.1F=g.52;g.3N=6(){J.5w=11}}c.W(d||1P,g)}a.3g?a.3g(\"4U\"+b,h):a.4y(b,h,11)}6 A(a,b){K c=e.1Y.2j,d=N;I(c==N){c={};O(K h 2g e.1U){K g=e.1U[h];d=g.4x;I(d!=N){g.1V=h.4w();O(g=0;g<d.L;g++)c[d[g]]=h}}e.1Y.2j=c}d=e.1U[c[a]];d==N&&b!=11&&1P.1X(e.13.1x.1X+(e.13.1x.3E+a));H d}6 v(a,b){O(K c=a.1e(\"\\\\n\"),d=0;d<c.L;d++)c[d]=b(c[d],d);H c.1K(\"\\\\n\")}6 u(a,b){I(a==N||a.L==0||a==\"\\\\n\")H a;a=a.Q(/</g,\"&1y;\");a=a.Q(/ {2,}/g,6(c){O(K d=\"\",h=0;h<c.L-1;h++)d+=e.13.1W;H d+\" \"});I(b!=N)a=v(a,6(c){I(c.L==0)H\"\";K d=\"\";c=c.Q(/^(&2s;| )+/,6(h){d=h;H\"\"});I(c.L==0)H d;H d+\\'<17 1g=\"\\'+b+\\'\">\\'+c+\"</17>\"});H a}6 n(a,b){a.1e(\"\\\\n\");O(K c=\"\",d=0;d<50;d++)c+=\"                    \";H a=v(a,6(h){I(h.1i(\"\\\\t\")==-1)H h;O(K g=0;(g=h.1i(\"\\\\t\"))!=-1;)h=h.1o(0,g)+c.1o(0,b-g%b)+h.1o(g+1,h.L);H h})}6 x(a){H a.Q(/^\\\\s+|\\\\s+$/g,\"\")}6 D(a,b){I(a.P<b.P)H-1;Y I(a.P>b.P)H 1;Y I(a.L<b.L)H-1;Y I(a.L>b.L)H 1;H 0}6 y(a,b){6 c(k){H k[0]}O(K d=N,h=[],g=b.2D?b.2D:c;(d=b.1I.X(a))!=N;){K i=g(d,b);I(1j i==\"3f\")i=[1f e.2L(i,d.P,b.23)];h=h.1O(i)}H h}6 E(a){K b=/(.*)((&1G;|&1y;).*)/;H a.Q(e.3A.3M,6(c){K d=\"\",h=N;I(h=b.X(c)){c=h[1];d=h[2]}H\\'<a 2h=\"\\'+c+\\'\">\\'+c+\"</a>\"+d})}6 z(){O(K a=1E.36(\"1k\"),b=[],c=0;c<a.L;c++)a[c].3s==\"20\"&&b.U(a[c]);H b}6 f(a){a=a.1F;K b=p(a,\".20\",R);a=p(a,\".3O\",R);K c=1E.4i(\"3t\");I(!(!a||!b||p(a,\"3t\"))){B(b.1c);r(b,\"1m\");O(K d=a.3G,h=[],g=0;g<d.L;g++)h.U(d[g].4z||d[g].4A);h=h.1K(\"\\\\r\");c.39(1E.4D(h));a.39(c);c.2C();c.4C();w(c,\"4u\",6(){c.2G.4E(c);b.1l=b.1l.Q(\"1m\",\"\")})}}I(1j 3F!=\"1d\"&&1j M==\"1d\")M=3F(\"M\").M;K e={2v:{\"1g-27\":\"\",\"2i-1s\":1,\"2z-1s-2t\":11,1M:N,1t:N,\"42-45\":R,\"43-22\":4,1u:R,16:R,\"3V-17\":R,2l:11,\"41-40\":R,2k:11,\"1z-1k\":11},13:{1W:\"&2s;\",2M:R,46:11,44:11,34:\"4n\",1x:{21:\"4o 1m\",2P:\"?\",1X:\"1v\\\\n\\\\n\",3E:\"4r\\'t 4t 1D O: \",4g:\"4m 4B\\'t 51 O 1z-1k 4F: \",37:\\'<!4T 1z 4S \"-//4V//3H 4W 1.0 4Z//4Y\" \"1Z://2y.3L.3K/4X/3I/3H/3I-4P.4J\"><1z 4I=\"1Z://2y.3L.3K/4L/5L\"><3J><4N 1Z-4M=\"5G-5M\" 6K=\"2O/1z; 6J=6I-8\" /><1t>6L 1v</1t></3J><3B 1L=\"25-6M:6Q,6P,6O,6N-6F;6y-2f:#6x;2f:#6w;25-22:6v;2O-3D:3C;\"><T 1L=\"2O-3D:3C;3w-32:1.6z;\"><T 1L=\"25-22:6A-6E;\">1v</T><T 1L=\"25-22:.6C;3w-6B:6R;\"><T>3v 3.0.76 (72 73 3x)</T><T><a 2h=\"1Z://3u.2w/1v\" 1F=\"38\" 1L=\"2f:#3y\">1Z://3u.2w/1v</a></T><T>70 17 6U 71.</T><T>6T 6X-3x 6Y 6D.</T></T><T>6t 61 60 J 1k, 5Z <a 2h=\"6u://2y.62.2w/63-66/65?64=5X-5W&5P=5O\" 1L=\"2f:#3y\">5R</a> 5V <2R/>5U 5T 5S!</T></T></3B></1z>\\'}},1Y:{2j:N,2A:{}},1U:{},3A:{6n:/\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\//2c,6m:/\\\\/\\\\/.*$/2c,6l:/#.*$/2c,6k:/\"([^\\\\\\\\\"\\\\n]|\\\\\\\\.)*\"/g,6o:/\\'([^\\\\\\\\\\'\\\\n]|\\\\\\\\.)*\\'/g,6p:1f M(\\'\"([^\\\\\\\\\\\\\\\\\"]|\\\\\\\\\\\\\\\\.)*\"\\',\"3z\"),6s:1f M(\"\\'([^\\\\\\\\\\\\\\\\\\']|\\\\\\\\\\\\\\\\.)*\\'\",\"3z\"),6q:/(&1y;|<)!--[\\\\s\\\\S]*?--(&1G;|>)/2c,3M:/\\\\w+:\\\\/\\\\/[\\\\w-.\\\\/?%&=:@;]*/g,6a:{18:/(&1y;|<)\\\\?=?/g,1b:/\\\\?(&1G;|>)/g},69:{18:/(&1y;|<)%=?/g,1b:/%(&1G;|>)/g},6d:{18:/(&1y;|<)\\\\s*1k.*?(&1G;|>)/2T,1b:/(&1y;|<)\\\\/\\\\s*1k\\\\s*(&1G;|>)/2T}},16:{1H:6(a){6 b(i,k){H e.16.2o(i,k,e.13.1x[k])}O(K c=\\'<T 1g=\"16\">\\',d=e.16.2x,h=d.2X,g=0;g<h.L;g++)c+=(d[h[g]].1H||b)(a,h[g]);c+=\"</T>\";H c},2o:6(a,b,c){H\\'<2W><a 2h=\"#\" 1g=\"6e 6h\\'+b+\" \"+b+\\'\">\\'+c+\"</a></2W>\"},2b:6(a){K b=a.1F,c=b.1l||\"\";b=B(p(b,\".20\",R).1c);K d=6(h){H(h=15(h+\"6f(\\\\\\\\w+)\").X(c))?h[1]:N}(\"6g\");b&&d&&e.16.2x[d].2B(b);a.3N()},2x:{2X:[\"21\",\"2P\"],21:{1H:6(a){I(a.V(\"2l\")!=R)H\"\";K b=a.V(\"1t\");H e.16.2o(a,\"21\",b?b:e.13.1x.21)},2B:6(a){a=1E.6j(t(a.1c));a.1l=a.1l.Q(\"47\",\"\")}},2P:{2B:6(){K a=\"68=0\";a+=\", 18=\"+(31.30-33)/2+\", 32=\"+(31.2Z-2Y)/2+\", 30=33, 2Z=2Y\";a=a.Q(/^,/,\"\");a=1P.6Z(\"\",\"38\",a);a.2C();K b=a.1E;b.6W(e.13.1x.37);b.6V();a.2C()}}}},35:6(a,b){K c;I(b)c=[b];Y{c=1E.36(e.13.34);O(K d=[],h=0;h<c.L;h++)d.U(c[h]);c=d}c=c;d=[];I(e.13.2M)c=c.1O(z());I(c.L===0)H d;O(h=0;h<c.L;h++){O(K g=c[h],i=a,k=c[h].1l,j=3W 0,l={},m=1f M(\"^\\\\\\\\[(?<2V>(.*?))\\\\\\\\]$\"),s=1f M(\"(?<27>[\\\\\\\\w-]+)\\\\\\\\s*:\\\\\\\\s*(?<1T>[\\\\\\\\w-%#]+|\\\\\\\\[.*?\\\\\\\\]|\\\\\".*?\\\\\"|\\'.*?\\')\\\\\\\\s*;?\",\"g\");(j=s.X(k))!=N;){K o=j.1T.Q(/^[\\'\"]|[\\'\"]$/g,\"\");I(o!=N&&m.1A(o)){o=m.X(o);o=o.2V.L>0?o.2V.1e(/\\\\s*,\\\\s*/):[]}l[j.27]=o}g={1F:g,1n:C(i,l)};g.1n.1D!=N&&d.U(g)}H d},1M:6(a,b){K c=J.35(a,b),d=N,h=e.13;I(c.L!==0)O(K g=0;g<c.L;g++){b=c[g];K i=b.1F,k=b.1n,j=k.1D,l;I(j!=N){I(k[\"1z-1k\"]==\"R\"||e.2v[\"1z-1k\"]==R){d=1f e.4l(j);j=\"4O\"}Y I(d=A(j))d=1f d;Y 6H;l=i.3X;I(h.2M){l=l;K m=x(l),s=11;I(m.1i(\"<![6G[\")==0){m=m.4h(9);s=R}K o=m.L;I(m.1i(\"]]\\\\>\")==o-3){m=m.4h(0,o-3);s=R}l=s?m:l}I((i.1t||\"\")!=\"\")k.1t=i.1t;k.1D=j;d.2Q(k);b=d.2F(l);I((i.1c||\"\")!=\"\")b.1c=i.1c;i.2G.74(b,i)}}},2E:6(a){w(1P,\"4k\",6(){e.1M(a)})}};e.2E=e.2E;e.1M=e.1M;e.2L=6(a,b,c){J.1T=a;J.P=b;J.L=a.L;J.23=c;J.1V=N};e.2L.Z.1q=6(){H J.1T};e.4l=6(a){6 b(j,l){O(K m=0;m<j.L;m++)j[m].P+=l}K c=A(a),d,h=1f e.1U.5Y,g=J,i=\"2F 1H 2Q\".1e(\" \");I(c!=N){d=1f c;O(K k=0;k<i.L;k++)(6(){K j=i[k];g[j]=6(){H h[j].1p(h,14)}})();d.28==N?1P.1X(e.13.1x.1X+(e.13.1x.4g+a)):h.2J.U({1I:d.28.17,2D:6(j){O(K l=j.17,m=[],s=d.2J,o=j.P+j.18.L,F=d.28,q,G=0;G<s.L;G++){q=y(l,s[G]);b(q,o);m=m.1O(q)}I(F.18!=N&&j.18!=N){q=y(j.18,F.18);b(q,j.P);m=m.1O(q)}I(F.1b!=N&&j.1b!=N){q=y(j.1b,F.1b);b(q,j.P+j[0].5Q(j.1b));m=m.1O(q)}O(j=0;j<m.L;j++)m[j].1V=c.1V;H m}})}};e.4j=6(){};e.4j.Z={V:6(a,b){K c=J.1n[a];c=c==N?b:c;K d={\"R\":R,\"11\":11}[c];H d==N?c:d},3Y:6(a){H 1E.4i(a)},4c:6(a,b){K c=[];I(a!=N)O(K d=0;d<a.L;d++)I(1j a[d]==\"2m\")c=c.1O(y(b,a[d]));H J.4e(c.6b(D))},4e:6(a){O(K b=0;b<a.L;b++)I(a[b]!==N)O(K c=a[b],d=c.P+c.L,h=b+1;h<a.L&&a[b]!==N;h++){K g=a[h];I(g!==N)I(g.P>d)1N;Y I(g.P==c.P&&g.L>c.L)a[b]=N;Y I(g.P>=c.P&&g.P<d)a[h]=N}H a},4d:6(a){K b=[],c=2u(J.V(\"2i-1s\"));v(a,6(d,h){b.U(h+c)});H b},3U:6(a){K b=J.V(\"1M\",[]);I(1j b!=\"2m\"&&b.U==N)b=[b];a:{a=a.1q();K c=3W 0;O(c=c=1Q.6c(c||0,0);c<b.L;c++)I(b[c]==a){b=c;1N a}b=-1}H b!=-1},2r:6(a,b,c){a=[\"1s\",\"6i\"+b,\"P\"+a,\"6r\"+(b%2==0?1:2).1q()];J.3U(b)&&a.U(\"67\");b==0&&a.U(\"1N\");H\\'<T 1g=\"\\'+a.1K(\" \")+\\'\">\\'+c+\"</T>\"},3Q:6(a,b){K c=\"\",d=a.1e(\"\\\\n\").L,h=2u(J.V(\"2i-1s\")),g=J.V(\"2z-1s-2t\");I(g==R)g=(h+d-1).1q().L;Y I(3R(g)==R)g=0;O(K i=0;i<d;i++){K k=b?b[i]:h+i,j;I(k==0)j=e.13.1W;Y{j=g;O(K l=k.1q();l.L<j;)l=\"0\"+l;j=l}a=j;c+=J.2r(i,k,a)}H c},49:6(a,b){a=x(a);K c=a.1e(\"\\\\n\");J.V(\"2z-1s-2t\");K d=2u(J.V(\"2i-1s\"));a=\"\";O(K h=J.V(\"1D\"),g=0;g<c.L;g++){K i=c[g],k=/^(&2s;|\\\\s)+/.X(i),j=N,l=b?b[g]:d+g;I(k!=N){j=k[0].1q();i=i.1o(j.L);j=j.Q(\" \",e.13.1W)}i=x(i);I(i.L==0)i=e.13.1W;a+=J.2r(g,l,(j!=N?\\'<17 1g=\"\\'+h+\\' 5N\">\\'+j+\"</17>\":\"\")+i)}H a},4f:6(a){H a?\"<4a>\"+a+\"</4a>\":\"\"},4b:6(a,b){6 c(l){H(l=l?l.1V||g:g)?l+\" \":\"\"}O(K d=0,h=\"\",g=J.V(\"1D\",\"\"),i=0;i<b.L;i++){K k=b[i],j;I(!(k===N||k.L===0)){j=c(k);h+=u(a.1o(d,k.P-d),j+\"48\")+u(k.1T,j+k.23);d=k.P+k.L+(k.75||0)}}h+=u(a.1o(d),c()+\"48\");H h},1H:6(a){K b=\"\",c=[\"20\"],d;I(J.V(\"2k\")==R)J.1n.16=J.1n.1u=11;1l=\"20\";J.V(\"2l\")==R&&c.U(\"47\");I((1u=J.V(\"1u\"))==11)c.U(\"6S\");c.U(J.V(\"1g-27\"));c.U(J.V(\"1D\"));a=a.Q(/^[ ]*[\\\\n]+|[\\\\n]*[ ]*$/g,\"\").Q(/\\\\r/g,\" \");b=J.V(\"43-22\");I(J.V(\"42-45\")==R)a=n(a,b);Y{O(K h=\"\",g=0;g<b;g++)h+=\" \";a=a.Q(/\\\\t/g,h)}a=a;a:{b=a=a;h=/<2R\\\\s*\\\\/?>|&1y;2R\\\\s*\\\\/?&1G;/2T;I(e.13.46==R)b=b.Q(h,\"\\\\n\");I(e.13.44==R)b=b.Q(h,\"\");b=b.1e(\"\\\\n\");h=/^\\\\s*/;g=4Q;O(K i=0;i<b.L&&g>0;i++){K k=b[i];I(x(k).L!=0){k=h.X(k);I(k==N){a=a;1N a}g=1Q.4q(k[0].L,g)}}I(g>0)O(i=0;i<b.L;i++)b[i]=b[i].1o(g);a=b.1K(\"\\\\n\")}I(1u)d=J.4d(a);b=J.4c(J.2J,a);b=J.4b(a,b);b=J.49(b,d);I(J.V(\"41-40\"))b=E(b);1j 2H!=\"1d\"&&2H.3S&&2H.3S.1C(/5s/)&&c.U(\"5t\");H b=\\'<T 1c=\"\\'+t(J.1c)+\\'\" 1g=\"\\'+c.1K(\" \")+\\'\">\\'+(J.V(\"16\")?e.16.1H(J):\"\")+\\'<3Z 5z=\"0\" 5H=\"0\" 5J=\"0\">\\'+J.4f(J.V(\"1t\"))+\"<3T><3P>\"+(1u?\\'<2d 1g=\"1u\">\\'+J.3Q(a)+\"</2d>\":\"\")+\\'<2d 1g=\"17\"><T 1g=\"3O\">\\'+b+\"</T></2d></3P></3T></3Z></T>\"},2F:6(a){I(a===N)a=\"\";J.17=a;K b=J.3Y(\"T\");b.3X=J.1H(a);J.V(\"16\")&&w(p(b,\".16\"),\"5c\",e.16.2b);J.V(\"3V-17\")&&w(p(b,\".17\"),\"56\",f);H b},2Q:6(a){J.1c=\"\"+1Q.5d(1Q.5n()*5k).1q();e.1Y.2A[t(J.1c)]=J;J.1n=C(e.2v,a||{});I(J.V(\"2k\")==R)J.1n.16=J.1n.1u=11},5j:6(a){a=a.Q(/^\\\\s+|\\\\s+$/g,\"\").Q(/\\\\s+/g,\"|\");H\"\\\\\\\\b(?:\"+a+\")\\\\\\\\b\"},5f:6(a){J.28={18:{1I:a.18,23:\"1k\"},1b:{1I:a.1b,23:\"1k\"},17:1f M(\"(?<18>\"+a.18.1m+\")(?<17>.*?)(?<1b>\"+a.1b.1m+\")\",\"5o\")}}};H e}();1j 2e!=\"1d\"&&(2e.1v=1v);',62,441,'||||||function|||||||||||||||||||||||||||||||||||||return|if|this|var|length|XRegExp|null|for|index|replace|true||div|push|getParam|call|exec|else|prototype||false|lastIndex|config|arguments|RegExp|toolbar|code|left|captureNames|slice|right|id|undefined|split|new|class|addToken|indexOf|typeof|script|className|source|params|substr|apply|toString|String|line|title|gutter|SyntaxHighlighter|_xregexp|strings|lt|html|test|OUTSIDE_CLASS|match|brush|document|target|gt|getHtml|regex|global|join|style|highlight|break|concat|window|Math|isRegExp|throw|value|brushes|brushName|space|alert|vars|http|syntaxhighlighter|expandSource|size|css|case|font|Fa|name|htmlScript|dA|can|handler|gm|td|exports|color|in|href|first|discoveredBrushes|light|collapse|object|cache|getButtonHtml|trigger|pattern|getLineHtml|nbsp|numbers|parseInt|defaults|com|items|www|pad|highlighters|execute|focus|func|all|getDiv|parentNode|navigator|INSIDE_CLASS|regexList|hasFlag|Match|useScriptTags|hasNamedCapture|text|help|init|br|input|gi|Error|values|span|list|250|height|width|screen|top|500|tagName|findElements|getElementsByTagName|aboutDialog|_blank|appendChild|charAt|Array|copyAsGlobal|setFlag|highlighter_|string|attachEvent|nodeName|floor|backref|output|the|TypeError|sticky|Za|iterate|freezeTokens|scope|type|textarea|alexgorbatchev|version|margin|2010|005896|gs|regexLib|body|center|align|noBrush|require|childNodes|DTD|xhtml1|head|org|w3|url|preventDefault|container|tr|getLineNumbersHtml|isNaN|userAgent|tbody|isLineHighlighted|quick|void|innerHTML|create|table|links|auto|smart|tab|stripBrs|tabs|bloggerMode|collapsed|plain|getCodeLinesHtml|caption|getMatchesHtml|findMatches|figureOutLineNumbers|removeNestedMatches|getTitleHtml|brushNotHtmlScript|substring|createElement|Highlighter|load|HtmlScript|Brush|pre|expand|multiline|min|Can|ignoreCase|find|blur|extended|toLowerCase|aliases|addEventListener|innerText|textContent|wasn|select|createTextNode|removeChild|option|same|frame|xmlns|dtd|twice|1999|equiv|meta|htmlscript|transitional|1E3|expected|PUBLIC|DOCTYPE|on|W3C|XHTML|TR|EN|Transitional||configured|srcElement|Object|after|run|dblclick|matchChain|valueOf|constructor|default|switch|click|round|execAt|forHtmlScript|token|gimy|functions|getKeywords|1E6|escape|within|random|sgi|another|finally|supply|MSIE|ie|toUpperCase|catch|returnValue|definition|event|border|imsx|constructing|one|Infinity|from|when|Content|cellpadding|flags|cellspacing|try|xhtml|Type|spaces|2930402|hosted_button_id|lastIndexOf|donate|active|development|keep|to|xclick|_s|Xml|please|like|you|paypal|cgi|cmd|webscr|bin|highlighted|scrollbars|aspScriptTags|phpScriptTags|sort|max|scriptScriptTags|toolbar_item|_|command|command_|number|getElementById|doubleQuotedString|singleLinePerlComments|singleLineCComments|multiLineCComments|singleQuotedString|multiLineDoubleQuotedString|xmlComments|alt|multiLineSingleQuotedString|If|https|1em|000|fff|background|5em|xx|bottom|75em|Gorbatchev|large|serif|CDATA|continue|utf|charset|content|About|family|sans|Helvetica|Arial|Geneva|3em|nogutter|Copyright|syntax|close|write|2004|Alex|open|JavaScript|highlighter|July|02|replaceChild|offset|83'.split('|'),0,{}))\n\n'Knockout-UI/examples/js/shBrushJScript.js'\n:/**\n * SyntaxHighlighter\n * http://alexgorbatchev.com/SyntaxHighlighter\n *\n * SyntaxHighlighter is donationware. If you are using it, please donate.\n * http://alexgorbatchev.com/SyntaxHighlighter/donate.html\n *\n * @version\n * 3.0.83 (July 02 2010)\n * \n * @copyright\n * Copyright (C) 2004-2010 Alex Gorbatchev.\n *\n * @license\n * Dual licensed under the MIT and GPL licenses.\n */\n;(function()\n{\n\t// CommonJS\n\ttypeof(require) != 'undefined' ? SyntaxHighlighter = require('shCore').SyntaxHighlighter : null;\n\n\tfunction Brush()\n\t{\n\t\tvar keywords =\t'break case catch continue ' +\n\t\t\t\t\t\t'default delete do else false  ' +\n\t\t\t\t\t\t'for function if in instanceof ' +\n\t\t\t\t\t\t'new null return super switch ' +\n\t\t\t\t\t\t'this throw true try typeof var while with'\n\t\t\t\t\t\t;\n\n\t\tvar r = SyntaxHighlighter.regexLib;\n\t\t\n\t\tthis.regexList = [\n\t\t\t{ regex: r.multiLineDoubleQuotedString,\t\t\t\t\tcss: 'string' },\t\t\t// double quoted strings\n\t\t\t{ regex: r.multiLineSingleQuotedString,\t\t\t\t\tcss: 'string' },\t\t\t// single quoted strings\n\t\t\t{ regex: r.singleLineCComments,\t\t\t\t\t\t\tcss: 'comments' },\t\t\t// one line comments\n\t\t\t{ regex: r.multiLineCComments,\t\t\t\t\t\t\tcss: 'comments' },\t\t\t// multiline comments\n\t\t\t{ regex: /\\s*#.*/gm,\t\t\t\t\t\t\t\t\tcss: 'preprocessor' },\t\t// preprocessor tags like #region and #endregion\n\t\t\t{ regex: new RegExp(this.getKeywords(keywords), 'gm'),\tcss: 'keyword' }\t\t\t// keywords\n\t\t\t];\n\t\n\t\tthis.forHtmlScript(r.scriptScriptTags);\n\t};\n\n\tBrush.prototype\t= new SyntaxHighlighter.Highlighter();\n\tBrush.aliases\t= ['js', 'jscript', 'javascript'];\n\n\tSyntaxHighlighter.brushes.JScript = Brush;\n\n\t// CommonJS\n\ttypeof(exports) != 'undefined' ? exports.Brush = Brush : null;\n})();\n\n",
        "called_code_segment": "function Brush() {\n    var keywords = 'break case catch continue ' + 'default delete do else false  ' + 'for function if in instanceof ' + 'new null return super switch ' + 'this throw true try typeof var while with';\n    var r = SyntaxHighlighter.regexLib;\n    this.regexList = [\n        { regex: r.multiLineDoubleQuotedString, css: 'string' }, // double quoted strings\n        { regex: r.multiLineSingleQuotedString, css: 'string' }, // single quoted strings\n        { regex: r.singleLineCComments, css: 'comments' }, // one line comments\n        { regex: r.multiLineCComments, css: 'comments' }, // multiline comments\n        { regex: /\\s*#.*/gm, css: 'preprocessor' }, // preprocessor tags like #region and #endregion\n        { regex: new RegExp(this.getKeywords(keywords), 'gm'), css: 'keyword' } // keywords\n    ];\n    this.forHtmlScript(r.scriptScriptTags);\n}",
        "invoking_code_segment": "Brush.prototype = new SyntaxHighlighter.Highlighter();\nBrush.aliases = ['js', 'jscript', 'javascript'];\nSyntaxHighlighter.brushes.JScript = Brush;",
        "new_file_code_segment": "function addNewFeature() {\n    console.log('New feature added!');\n}",
        "feature_description": "Add a new feature to log a message when the Brush function is invoked.",
        "detailed_feature_description": "The new feature involves adding a function `addNewFeature` in a new file (#file 3) that logs a message. This function is then invoked within the `Brush` constructor in #file 1. The modification ensures that the new feature is integrated without affecting the existing functionality in #file 1 and #file 2.",
        "modified_complete_code": {
            "#file 1": "//Modify\nfunction Brush() {\n    var keywords = 'break case catch continue ' + 'default delete do else false  ' + 'for function if in instanceof ' + 'new null return super switch ' + 'this throw true try typeof var while with';\n    var r = SyntaxHighlighter.regexLib;\n    this.regexList = [\n        { regex: r.multiLineDoubleQuotedString, css: 'string' }, // double quoted strings\n        { regex: r.multiLineSingleQuotedString, css: 'string' }, // single quoted strings\n        { regex: r.singleLineCComments, css: 'comments' }, // one line comments\n        { regex: r.multiLineCComments, css: 'comments' }, // multiline comments\n        { regex: /\\s*#.*/gm, css: 'preprocessor' }, // preprocessor tags like #region and #endregion\n        { regex: new RegExp(this.getKeywords(keywords), 'gm'), css: 'keyword' } // keywords\n    ];\n    this.forHtmlScript(r.scriptScriptTags);\n    addNewFeature(); //New\n}",
            "#file 2": "Brush.prototype = new SyntaxHighlighter.Highlighter();\nBrush.aliases = ['js', 'jscript', 'javascript'];\nSyntaxHighlighter.brushes.JScript = Brush;",
            "#file 3": "//New\nfunction addNewFeature() {\n    console.log('New feature added!');\n}"
        }
    },
    {
        "repo": "Next-GraphQL-Blog",
        "content": "'Next-GraphQL-Blog/client/lib/withUser.js'\n:import React from 'react'\n\nimport { Context } from '../context'\n\nexport default Page =>\n  class BaseComponent extends React.Component {\n    static async getInitialProps(ctx) {\n      const props = {}\n\n      if (Page.getInitialProps) {\n        Object.assign(props, (await Page.getInitialProps(ctx)) || {})\n      }\n      return props\n    }\n\n    render() {\n      return (\n        <Context.Consumer>\n          {context => {\n            return (\n              <Page\n                {...this.props}\n                user={context ? context.state.user : ''}\n                setUser={context ? context.actions.setUser : ''}\n                clearUser={context ? context.actions.clearUser : ''}\n              />\n            )\n          }}\n        </Context.Consumer>\n      )\n    }\n  }\n\n'Next-GraphQL-Blog/client/pages/signup.js'\n:import React, { Component } from 'react'\nimport { graphql, compose, Query, Mutation } from 'react-apollo'\nimport Router from 'next/router'\nimport styled from 'styled-components'\nimport Link from 'next/link'\nimport { Button, Form, Loader, Message, Header } from 'semantic-ui-react'\n\nimport withUser from '../lib/withUser'\nimport parseError from '../lib/parseError'\n\nimport GoogleLoginButton from '../components/GoogleLoginButton'\nimport StyledSignForm from '../components/StyledSignForm'\n\nimport { SIGNUP_MUTATION } from '../api/mutations/user/signup'\n\nclass Login extends Component {\n  state = {\n    email: '',\n    password: '',\n    name: ''\n  }\n\n  handleChange = event => {\n    this.setState({ [event.target.name]: event.target.value })\n  }\n\n  handleSubmit = async (e, signup) => {\n    e.preventDefault()\n\n    try {\n      const { data } = await signup()\n      Router.push(`/authcallback?token=${data.signup.token}`)\n    } catch (error) {\n      this.setState({\n        email: '',\n        password: '',\n        name: ''\n      })\n    }\n  }\n\n  render() {\n    const { email, password, name } = this.state\n    return (\n      <Mutation\n        mutation={SIGNUP_MUTATION}\n        variables={{ email, password, name }}\n      >\n        {(signup, { loading, error, data }) => (\n          <Container>\n            <StyledSignForm\n              error={!!error}\n              onSubmit={e => this.handleSubmit(e, signup)}\n            >\n              <Header size=\"large\">Signup</Header>\n              <Form.Field>\n                <label>Email</label>\n                <input\n                  name=\"email\"\n                  onChange={this.handleChange}\n                  placeholder=\"Please enter your email\"\n                  autoComplete=\"email\"\n                  value={this.state.email}\n                />\n              </Form.Field>\n\n              <Form.Field>\n                <label>Name</label>\n                <input\n                  name=\"name\"\n                  onChange={this.handleChange}\n                  placeholder=\"Please enter your name\"\n                  autoComplete=\"name\"\n                  value={this.state.name}\n                />\n              </Form.Field>\n\n              <Form.Field>\n                <label>Password</label>\n                <input\n                  name=\"password\"\n                  onChange={this.handleChange}\n                  placeholder=\"Please enter your password\"\n                  autoComplete=\"password\"\n                  type=\"password\"\n                  value={this.state.password}\n                />\n              </Form.Field>\n\n              {error && (\n                <Message\n                  error\n                  header=\"Ooops!\"\n                  content={parseError(error.message)}\n                />\n              )}\n              {loading ? (\n                <StyledLoader active inline />\n              ) : (\n                <LoginButton type=\"submit\">Signup</LoginButton>\n              )}\n              <Link href=\"/login\">\n                <a>Have an account? Click here to login</a>\n              </Link>\n              <GoogleLoginButton text=\"Signup with Google\" />\n            </StyledSignForm>\n          </Container>\n        )}\n      </Mutation>\n    )\n  }\n}\n\nexport default withUser(Login)\n\nconst Container = styled.div`\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  height: calc(200px + 40vh);\n`\n\nconst LoginButton = styled(Button)`\n  &&& {\n    width: 100%;\n    height: 40px;\n    background: #f5ca66;\n    margin: 15px 0px;\n  }\n`\nconst StyledLoader = styled(Loader)`\n  align-self: center;\n`\n\n",
        "called_code_segment": "class BaseComponent extends React.Component {\n    static async getInitialProps(ctx) {\n      const props = {}\n\n      if (Page.getInitialProps) {\n        Object.assign(props, (await Page.getInitialProps(ctx)) || {})\n      }\n      return props\n    }\n\n    render() {\n      return (\n        <Context.Consumer>\n          {context => {\n            return (\n              <Page\n                {...this.props}\n                user={context ? context.state.user : ''}\n                setUser={context ? context.actions.setUser : ''}\n                clearUser={context ? context.actions.clearUser : ''}\n              />\n            )\n          }}\n        </Context.Consumer>\n      )\n    }\n  }",
        "invoking_code_segment": "export default Page =>\n  class BaseComponent extends React.Component {\n    static async getInitialProps(ctx) {\n      const props = {}\n\n      if (Page.getInitialProps) {\n        Object.assign(props, (await Page.getInitialProps(ctx)) || {})\n      }\n      return props\n    }\n\n    render() {\n      return (\n        <Context.Consumer>\n          {context => {\n            return (\n              <Page\n                {...this.props}\n                user={context ? context.state.user : ''}\n                setUser={context ? context.actions.setUser : ''}\n                clearUser={context ? context.actions.clearUser : ''}\n              />\n            )\n          }}\n        </Context.Consumer>\n      )\n    }\n  }",
        "new_file_code_segment": "export const checkUserRole = (user, role) => {\n  return user && user.role === role\n}",
        "feature_description": "Add a feature to check the user's role before rendering the page.",
        "detailed_feature_description": "The new feature involves adding a function in #file 3 to check the user's role. This function will be invoked in #file 1 to conditionally render the page based on the user's role. #file 2 will remain unchanged as it is the higher-order component that wraps the page component.",
        "modified_complete_code": {
            "#file 1": "class BaseComponent extends React.Component {\n    static async getInitialProps(ctx) {\n      const props = {}\n\n      if (Page.getInitialProps) {\n        Object.assign(props, (await Page.getInitialProps(ctx)) || {})\n      }\n      return props\n    }\n\n    render() {\n      return (\n        <Context.Consumer>\n          {context => {\n            const userRole = context ? context.state.user.role : ''\n            const isAuthorized = checkUserRole(context.state.user, 'admin') // #Modify\n            return (\n              isAuthorized ? (\n                <Page\n                  {...this.props}\n                  user={context ? context.state.user : ''}\n                  setUser={context ? context.actions.setUser : ''}\n                  clearUser={context ? context.actions.clearUser : ''}\n                />\n              ) : (\n                <div>Unauthorized Access</div>\n              )\n            )\n          }}\n        </Context.Consumer>\n      )\n    }\n  }",
            "#file 2": "export default Page =>\n  class BaseComponent extends React.Component {\n    static async getInitialProps(ctx) {\n      const props = {}\n\n      if (Page.getInitialProps) {\n        Object.assign(props, (await Page.getInitialProps(ctx)) || {})\n      }\n      return props\n    }\n\n    render() {\n      return (\n        <Context.Consumer>\n          {context => {\n            return (\n              <Page\n                {...this.props}\n                user={context ? context.state.user : ''}\n                setUser={context ? context.actions.setUser : ''}\n                clearUser={context ? context.actions.clearUser : ''}\n              />\n            )\n          }}\n        </Context.Consumer>\n      )\n    }\n  }",
            "#file 3": "export const checkUserRole = (user, role) => {\n  return user && user.role === role\n}"
        }
    },
    {
        "repo": "Registration-and-Login-using-MERN-stack",
        "content": "'Registration-and-Login-using-MERN-stack/api/server.js'\n:const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst PORT = 4000;\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst config = require('./DB.js');\nconst registrationRoutes = require('./route');\n\nmongoose.Promise = global.Promise;\nmongoose.connect(config.DB, { useNewUrlParser: true }).then(\n    () => { console.log('Database is connected') },\n    err => { console.log('Can not connect to the database' + err) }\n);\n\napp.use(cors());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(\"./schema/User\", registrationRoutes);\n\n\nmodule.exports = app\n'Registration-and-Login-using-MERN-stack/api/app.js'\n:var app = require(\"./server\");\nconst PORT = 4000;\n\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});\n",
        "called_code_segment": "app.use(cors());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(\"./schema/User\", registrationRoutes);",
        "invoking_code_segment": "var app = require(\"./server\");\nconst PORT = 4000;\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});",
        "new_file_code_segment": "const rateLimit = require('express-rate-limit');\n\nconst limiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100 // limit each IP to 100 requests per windowMs\n});\n\nmodule.exports = limiter;",
        "feature_description": "Implement rate limiting to prevent abuse of the API.",
        "detailed_feature_description": "The new feature introduces rate limiting to the API using the `express-rate-limit` middleware. This will limit the number of requests a client can make to the server within a specified time window. The rate limiter is configured to allow a maximum of 100 requests per IP address within a 15-minute window. The `limiter` middleware is added to the `app` in #file 1 to enforce this rate limit across all routes.",
        "modified_complete_code": {
            "#file 1": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst config = require('./DB.js');\nconst registrationRoutes = require('./route');\nconst limiter = require('./rateLimiter'); // #New\n\nmongoose.Promise = global.Promise;\nmongoose.connect(config.DB, { useNewUrlParser: true }).then(\n    () => { console.log('Database is connected') },\n    err => { console.log('Can not connect to the database' + err) }\n);\n\napp.use(cors());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(limiter); // #Modify\napp.use(\"./schema/User\", registrationRoutes);\n\nmodule.exports = app;",
            "#file 2": "var app = require(\"./server\");\nconst PORT = 4000;\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});",
            "#file 3": "const rateLimit = require('express-rate-limit');\n\nconst limiter = rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    max: 100 // limit each IP to 100 requests per windowMs\n});\n\nmodule.exports = limiter;"
        }
    },
    {
        "repo": "badginator",
        "content": "'badginator/lib/url_is_badge.js'\n:/// file: identify if a url is a badge\n\nconst request = require('superagent');\nconst mime = require('mime');\nconst svg2png = require('svg2png');\n\nconst is_badge = require('./is_badge');\n\n// cb(err, is_badge)\nmodule.exports = function(url, cb) {\n    request\n    .get(url)\n    .set('badginator-request', 'sup dog')\n    .end((err, res) => {\n        if (err) {\n            return cb(err);\n        }\n\n        if (res.status !== 200) {\n            return cb(null, false);\n        }\n\n        var type = res.headers['content-type'];\n        var ext = mime.extension(type);\n\n        // only support png and svg badges for now\n        if (ext !== 'svg' && ext !== 'png') {\n            return cb(null, false);\n        }\n\n        if (ext === 'svg') {\n            // convert to png first\n            svg2png(res.body)\n            .then((buffer) => {\n                is_badge(buffer, (err, badge) => {\n                    cb(err, badge);\n                });\n            })\n            .catch((err) => {\n                cb(err);\n            });\n\n            return;\n        }\n\n        is_badge(res.body, (err, badge) => {\n            cb(err, badge);\n        });\n    });\n};\n\n'badginator/index.js'\n:const express = require('express');\nconst async = require('async');\nconst request = require('superagent');\nconst printf = require('printf');\nconst https = require('https');\nconst marked = require('marked');\nconst cheerio = require('cheerio');\nconst redis = require('redis');\nconst crypto = require('crypto');\n\nconst url_is_badge = require('./lib/url_is_badge');\n\nvar redisCache = redis.createClient(process.env.REDIS_URL);\nredisCache.on('error', function (err) {\n    console.error('Redis error:', err);\n});\n\nvar app = express();\n\napp.set('x-powered-by', false);\n\napp.get('/', function(req, res, next) {\n    res.redirect('https://github.com/defunctzombie/badginator');\n});\n\napp.get('/:org/:repo.svg', function(req, res, next) {\n    var org = req.params.org;\n    var repo = req.params.repo;\n\n    // if badginator request, serve up dummy badge\n    if (req.headers['badginator-request'] === 'sup dog') {\n        var url = printf('https://img.shields.io/badge/badges-dummy-green.svg');\n        https.get(url, function(img_res) {\n            res.set({\n                'content-type': img_res.headers['content-type'],\n                'cache-control': 'no-cache, no-store, must-revalidate',\n            });\n            img_res.pipe(res);\n        });\n        return;\n    }\n\n    var count_fn = process.env.USE_REGEX_BADGES ? regex_count_readme_badges : count_readme_badges;\n\n    if (req.query.image_analysis) {\n        count_fn = count_readme_badges;\n    }\n\n    count_fn({\n        org: org,\n        repo: repo,\n    }, function(err, badge_count) {\n        if (err) {\n            return next(err);\n        }\n\n        var color = 'red';\n\n        if (badge_count <= 2) {\n            color = 'red';\n        }\n        else if (badge_count <= 4) {\n            color = 'orange';\n        }\n        else if (badge_count <= 6) {\n            color = 'green';\n        }\n        else {\n            color = 'brightgreen';\n        }\n\n        var etag = badge_count + color;\n        var style = req.query.style || 'flat';\n        var url = printf('https://img.shields.io/badge/badges-%d-%s.svg?style=%s', badge_count, color, style);\n        if (process.env.USE_REDIRECT_URL === '1') {\n            return res.redirect(url);\n        }\n\n        https.get(url, function(img_res) {\n            res.set({\n                'content-type': img_res.headers['content-type'],\n                'cache-control': 'no-cache, no-store, must-revalidate',\n                'etag': etag,\n            });\n            img_res.pipe(res);\n        });\n    });\n});\n\nfunction regex_count_readme_badges(opt, cb) {\n    fetch_readme(opt, function(err, readme) {\n        if (err) {\n            return cb(err);\n        }\n\n        // remove markdown sections\n        readme = readme.replace(/```[^]*?```/g, '');\n\n        // count instances of [![](.svg or .png)]\n        // followed by () which is a link\n        var regexp = /(\\[[!]\\[.*\\]\\(.*(\\.svg|\\.png).*\\)\\]\\(.*\\)|[!]\\[.*\\]\\(.*(\\.svg|\\.png).*\\))/g;\n        var count = 0;\n        while(regexp.exec(readme) !== null) {\n            count++;\n        }\n\n        cb(null, count);\n    });\n};\n\nfunction count_readme_badges(opt, cb) {\n    fetch_readme(opt, function(err, readme) {\n        if (err) {\n            return cb(err);\n        }\n\n        // process readme\n        var html = marked(readme);\n        var $ = cheerio.load(html);\n\n        var urls = $('img').map(function(idx, img) {\n            return $(img).attr('src');\n        }).get();\n\n        var count = 0;\n        async.each(urls, function(url, done) {\n            //async.reduce(urls, 0, function(count, url, done) {\n            // this is gnarly and could be a function now\n            var hash = crypto.createHash('md5').update(url).digest('hex');\n            var url_key = 'url-cache:' + hash;\n            redisCache.get(url_key, function(err, val) {\n                if (err) {\n                    console.error(err);\n                    return done();\n                }\n\n                // have cached value\n                if (val !== null) {\n                    count += (val === 'true' ? 1 : 0);\n                    // redis values are strings, yay\n                    //return done(null, count + (val === 'true' ? 1 : 0));\n                    return done();\n                }\n\n                url_is_badge(url, function(err, is_badge) {\n                    if (err) {\n                        console.error(err);\n                    }\n                    else {\n                        redisCache.setex(url_key, 60 * 15, is_badge, function(err) {\n                            if (err) {\n                                console.error(err);\n                            }\n                        });\n                    }\n\n                    count += (is_badge ? 1 : 0);\n                    done();\n                    //done(null, count + (is_badge ? 1 : 0));\n                });\n\n            });\n        }, function(err) {\n            cb(err, count);\n        });\n    });\n}\n\nfunction fetch_readme(opt, cb) {\n    var org = opt.org;\n    var repo = opt.repo;\n\n    var base_url = printf('https://raw.githubusercontent.com/%s/%s/master/', org, repo);\n    var readme_variants = ['README.md', 'readme.md', 'Readme.md', 'README.MD', 'readme.markdown'];\n    var readme_text = '';\n\n    async.some(readme_variants, function(name, cb) {\n        var url = base_url + name;\n        request.get(url).end(function(err, res) {\n            if (err) {\n                return cb(false);\n            }\n\n            if (res.status !== 200) {\n                return cb(false);\n            }\n\n            readme_text = res.text;\n            cb(true);\n        });\n    }, function(found) {\n        cb(null, readme_text);\n    });\n}\n\n\napp.listen(process.env.PORT || 3000);\n\n",
        "called_code_segment": "module.exports = function(url, cb) {\n    request\n    .get(url)\n    .set('badginator-request', 'sup dog')\n    .end((err, res) => {\n        if (err) {\n            return cb(err);\n        }\n\n        if (res.status !== 200) {\n            return cb(null, false);\n        }\n\n        var type = res.headers['content-type'];\n        var ext = mime.extension(type);\n\n        // only support png and svg badges for now\n        if (ext !== 'svg' && ext !== 'png') {\n            return cb(null, false);\n        }\n\n        if (ext === 'svg') {\n            // convert to png first\n            svg2png(res.body)\n            .then((buffer) => {\n                is_badge(buffer, (err, badge) => {\n                    cb(err, badge);\n                });\n            })\n            .catch((err) => {\n                cb(err);\n            });\n\n            return;\n        }\n\n        is_badge(res.body, (err, badge) => {\n            cb(err, badge);\n        });\n    });\n};",
        "invoking_code_segment": "var count = 0;\nasync.each(urls, function(url, done) {\n    // this is gnarly and could be a function now\n    var hash = crypto.createHash('md5').update(url).digest('hex');\n    var url_key = 'url-cache:' + hash;\n    redisCache.get(url_key, function(err, val) {\n        if (err) {\n            console.error(err);\n            return done();\n        }\n\n        // have cached value\n        if (val !== null) {\n            count += (val === 'true' ? 1 : 0);\n            // redis values are strings, yay\n            //return done(null, count + (val === 'true' ? 1 : 0));\n            return done();\n        }\n\n        url_is_badge(url, function(err, is_badge) {\n            if (err) {\n                console.error(err);\n            } else {\n                redisCache.setex(url_key, 60 * 15, is_badge, function(err) {\n                    if (err) {\n                        console.error(err);\n                    }\n                });\n            }\n\n            count += (is_badge ? 1 : 0);\n            done();\n            //done(null, count + (is_badge ? 1 : 0));\n        });\n    });\n}, function(err) {\n    cb(err, count);\n});",
        "new_file_code_segment": "module.exports = function(url, cb) {\n    request\n    .get(url)\n    .set('badginator-request', 'sup dog')\n    .end((err, res) => {\n        if (err) {\n            return cb(err);\n        }\n\n        if (res.status !== 200) {\n            return cb(null, false);\n        }\n\n        var type = res.headers['content-type'];\n        var ext = mime.extension(type);\n\n        // only support png and svg badges for now\n        if (ext !== 'svg' && ext !== 'png') {\n            return cb(null, false);\n        }\n\n        if (ext === 'svg') {\n            // convert to png first\n            svg2png(res.body)\n            .then((buffer) => {\n                is_badge(buffer, (err, badge) => {\n                    cb(err, badge);\n                });\n            })\n            .catch((err) => {\n                cb(err);\n            });\n\n            return;\n        }\n\n        is_badge(res.body, (err, badge) => {\n            cb(err, badge);\n        });\n    });\n};",
        "feature_description": "Add caching for badge identification results to reduce redundant network requests.",
        "detailed_feature_description": "The new feature introduces a caching mechanism for the badge identification results. This is achieved by modifying the `url_is_badge` function in #file 1 to check a cache before making a network request. If the result is already cached, it retrieves the result from the cache instead of making a new request. This reduces redundant network requests and speeds up the badge identification process. The caching logic is implemented in a new file (#file 3) and is integrated into both #file 1 and #file 2 to ensure compatibility.",
        "modified_complete_code": {
            "#file 1": "const request = require('superagent');\nconst mime = require('mime');\nconst svg2png = require('svg2png');\nconst redis = require('redis');\nconst crypto = require('crypto');\n\nconst is_badge = require('./is_badge');\nconst cache_badge_result = require('./cache_badge_result'); // #New\n\nconst redisCache = redis.createClient(process.env.REDIS_URL); // #New\n\n// cb(err, is_badge)\nmodule.exports = function(url, cb) {\n    const hash = crypto.createHash('md5').update(url).digest('hex'); // #New\n    const url_key = 'url-cache:' + hash; // #New\n\n    redisCache.get(url_key, function(err, val) { // #New\n        if (err) {\n            return cb(err);\n        }\n\n        // have cached value\n        if (val !== null) {\n            return cb(null, val === 'true'); // #New\n        }\n\n        request\n        .get(url)\n        .set('badginator-request', 'sup dog')\n        .end((err, res) => {\n            if (err) {\n                return cb(err);\n            }\n\n            if (res.status !== 200) {\n                return cb(null, false);\n            }\n\n            var type = res.headers['content-type'];\n            var ext = mime.extension(type);\n\n            // only support png and svg badges for now\n            if (ext !== 'svg' && ext !== 'png') {\n                return cb(null, false);\n            }\n\n            if (ext === 'svg') {\n                // convert to png first\n                svg2png(res.body)\n                .then((buffer) => {\n                    is_badge(buffer, (err, badge) => {\n                        cache_badge_result(redisCache, url_key, badge, cb); // #Modify\n                    });\n                })\n                .catch((err) => {\n                    cb(err);\n                });\n\n                return;\n            }\n\n            is_badge(res.body, (err, badge) => {\n                cache_badge_result(redisCache, url_key, badge, cb); // #Modify\n            });\n        });\n    });\n};",
            "#file 2": "var count = 0;\nasync.each(urls, function(url, done) {\n    // this is gnarly and could be a function now\n    var hash = crypto.createHash('md5').update(url).digest('hex');\n    var url_key = 'url-cache:' + hash;\n    redisCache.get(url_key, function(err, val) {\n        if (err) {\n            console.error(err);\n            return done();\n        }\n\n        // have cached value\n        if (val !== null) {\n            count += (val === 'true' ? 1 : 0);\n            // redis values are strings, yay\n            //return done(null, count + (val === 'true' ? 1 : 0));\n            return done();\n        }\n\n        url_is_badge(url, function(err, is_badge) {\n            if (err) {\n                console.error(err);\n            } else {\n                redisCache.setex(url_key, 60 * 15, is_badge, function(err) {\n                    if (err) {\n                        console.error(err);\n                    }\n                });\n            }\n\n            count += (is_badge ? 1 : 0);\n            done();\n            //done(null, count + (is_badge ? 1 : 0));\n        });\n    });\n}, function(err) {\n    cb(err, count);\n});",
            "#file 3": "module.exports = function(redisCache, url_key, badge, cb) {\n    redisCache.setex(url_key, 60 * 15, badge, function(err) {\n        if (err) {\n            console.error(err);\n        }\n        cb(null, badge);\n    });\n};"
        }
    },
    {
        "repo": "castnow",
        "content": "'castnow/plugins/xspf.js'\n:var path = require('path');\nvar debug = require('debug')('castnow:localfile');\nvar fs = require('fs');\nvar xspfr = require('xspfr');\n\nvar isFile = function(item) {\n  return fs.existsSync(item.path) && fs.statSync(item.path).isFile();\n}\nvar isXspf = function(item) {\n  return path.extname(item.path) === '.xspf';\n};\n\nvar contains = function(arr, cb) {\n  for (var i=0, len=arr.length; i<len; i++) {\n    if (cb(arr[i], i)) return true;\n  }\n  return false;\n};\n\nvar flatten1 = function(arrayOfArrays) {\n  return [].concat.apply([], arrayOfArrays);\n}\n\nvar localfile = function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (!contains(ctx.options.playlist, isXspf)) return next();\n\n  var list = ctx.options.playlist.slice(0);\n\n  Promise.all(list.map(function(item, idx) {\n    if (!isXspf(item)) {\n      return Promise.resolve([item]);\n    }\n\n    if (!isFile(item)) {\n      // TODO\n      throw 'Unsupported external XSPF links';\n    }\n\n    return new Promise(function(resolve, reject) {\n      xspfr(fs.readFileSync(item.path).toString(), function(err, result) {\n        if(err) reject(err)\n\n        resolve(result.map(function(item) {\n          return {\n            path: item.location,\n            media: {\n              metadata: {\n                title: item.title\n              }\n            }\n          }\n        }))\n      })\n    })\n\n  })).then(function(data) {\n    ctx.options.playlist = flatten1(data);\n    next()\n  })\n};\n\nmodule.exports = localfile;\n\n'castnow/index.js'\n:#!/usr/bin/env node\n\nvar fs = require('fs');\nvar path = require('path');\nvar player = require('chromecast-player')();\nvar chalk = require('chalk');\nvar keypress = require('keypress');\nvar ui = require('playerui')();\nvar circulate = require('array-loop');\nvar xtend = require('xtend');\nvar shuffle = require('array-shuffle');\nvar unformatTime = require('./utils/unformat-time');\nvar debug = require('debug')('castnow');\nvar debouncedSeeker = require('debounced-seeker');\nvar mime = require('mime');\nvar noop = function() {};\n\n// plugins\nvar directories = require('./plugins/directories');\nvar xspf = require('./plugins/xspf');\nvar localfile = require('./plugins/localfile');\nvar torrent = require('./plugins/torrent');\nvar transcode = require('./plugins/transcode');\nvar subtitles = require('./plugins/subtitles');\nvar stdin = require('./plugins/stdin');\n\nvar home = process.env[(process.platform == 'win32') ? 'USERPROFILE' : 'HOME'];\nvar rcOpts = [];\ntry {\n  rcOpts = fs.readFileSync(path.join(home, '.castnowrc')).toString().trim().split(/\\s+/);\n} catch(err) {}\n\nvar optConfig = {\n  boolean: \"tomp4 quiet bypass-srt-encoding loop shuffle recursive exit help\".split(/\\s+/),\n  string: \"device address subtitles subtitle-scale subtitle-color subtitle-port myip type seek volume-step localfile-port transcode-port torrent-port stdin-port command\".split(/\\s+/)\n}\nvar args = rcOpts.concat(process.argv.slice(2));\nvar opts = require('minimist')(args, optConfig);\n\n// Eliminate duplicate option values, prefering the final option value.\nfor (var opt in opts) {\n  if (opts.hasOwnProperty(opt) && opt[0].toLowerCase() != opt[0].toUpperCase() && Array.isArray(opts[opt]))\n    opts[opt] = opts[opt].pop()\n}\n\nif (opts.help) {\n  return console.log([\n    '',\n    'Usage: castnow [<media>, <media>, ...] [OPTIONS]',\n    '',\n    'Option                   Meaning',\n    '--tomp4                  Convert file to mp4 during playback',\n    '--device <name>          The name of the Chromecast device that should be used',\n    '--address <ip>           The IP address or hostname of your Chromecast device',\n    '--subtitles <path/url>   Path or URL to an SRT or VTT file',\n    '--subtitle-scale <scale> Subtitle font scale',\n    '--subtitle-color <color> Subtitle font RGBA color',\n    '--subtitle-port <port>   Specify the port to be used for serving subtitles',\n    '--myip <ip>              Your local IP address',\n    '--quiet                  No output',\n    '--peerflix-* <value>     Pass options to peerflix',\n    '--ffmpeg-* <value>       Pass options to ffmpeg',\n    '--type <type>            Explicitly set the mime-type (e.g. \"video/mp4\")',\n    '--bypass-srt-encoding    Disable automatic UTF-8 encoding of SRT subtitles',\n    '--seek <hh:mm:ss>        Seek to the specified time on start using the format hh:mm:ss or mm:ss',\n    '--loop                   Loop over playlist, or file, forever',\n    '--shuffle                Play in random order',\n    '--recursive              List all files in directories recursively',\n    '--volume-step <step>     Step at which the volume changes. Helpful for speakers that are softer or louder than normal. Value ranges from 0 to 1 (e.g. \".05\")',\n    '--localfile-port <port>  Specify the port to be used for serving a local file',\n    '--transcode-port <port>  Specify the port to be used for serving a transcoded file',\n    '--torrent-port <port>    Specify the port to be used for serving a torrented file',\n    '--stdin-port <port>      Specify the port to be used for serving a file read from stdin',\n    '--command <key1>,<key2>  Execute key command(s) (where each <key> is one of the keys listed below)',\n    '--exit                   Exit when playback begins or --command completes',\n\n    '--help                   This help screen',\n    '',\n    'Player controls',\n    '',\n    'Key                      Action',\n    'space                    Toggle between play and pause',\n    'm                        Toggle mute',\n    't                        Toggle subtitles',\n    'up                       Volume Up',\n    'down                     Volume Down',\n    'left                     Seek backward',\n    'right                    Seek forward',\n    'p                        Previous in playlist',\n    'n                        Next in playlist',\n    's                        Stop playback',\n    'quit                     Quit',\n    ''\n  ].join('\\n'));\n}\n\nif (opts._.length) {\n  opts.playlist = opts._.map(function(item) {\n    return {\n      path: item\n    };\n  });\n}\n\ndelete opts._;\n\nif (opts.quiet || opts.exit || process.env.DEBUG) {\n  ui.hide();\n}\n\nvar volumeStep = 0.05;\nvar stepOption = opts['volume-step'];\n\nif (stepOption) {\n  var parsed = parseFloat(stepOption);\n\n  if (isNaN(parsed)) {\n    fatalError('invalid --volume-step');\n  }\n\n  if (parsed < 0 || parsed > 1) {\n    fatalError('--volume-step must be between 0 and 1');\n  }\n\n  volumeStep = parsed;\n}\n\ndebug('volume step: %s', volumeStep);\n\nui.showLabels('state');\n\nfunction fatalError(err) {\n  ui.hide(err);\n  debug(err);\n  console.log(chalk.red(err));\n  process.exit();\n}\n\nvar last = function(fn, l) {\n  return function() {\n    var args = Array.prototype.slice.call(arguments);\n    args.push(l);\n    l = fn.apply(null, args);\n    return l;\n  };\n};\n\nvar ctrl = function(err, p, ctx) {\n  if (err) {\n    ui.hide();\n    debug('player error: %o', err);\n    console.log(chalk.red(err));\n    process.exit();\n  }\n\n  var playlist = ctx.options.playlist;\n  var playlist_history = ctx.options.playlist_history;\n  var volume;\n  var is_keyboard_interactive = process.stdin.isTTY || false;\n\n  if (is_keyboard_interactive) {\n    keypress(process.stdin);\n    process.stdin.setRawMode(true);\n    process.stdin.resume();\n  }\n\n  ctx.once('closed', function() {\n    ui.hide();\n    console.log(chalk.red('lost connection'));\n    process.exit();\n  });\n\n  // get initial volume\n  p.getVolume(function(err, status) {\n    volume = status;\n  });\n\n  if (!ctx.options.disableTimeline) {\n    p.on('position', function(pos) {\n      ui.setProgress(pos.percent);\n      ui.render();\n    });\n  }\n\n  var seekImmediate = function(offset) {\n    if (ctx.options.disableSeek || offset === 0) return;\n    var seconds = Math.max(0, (p.getPosition() / 1000) + offset);\n    debug('seeking to %s', seconds);\n    p.seek(seconds);\n  };\n\n  if (opts.exit) {\n    // cannot debounce or seek never executes before we exit\n    var seek = seekImmediate;\n  } else {\n    var seek = debouncedSeeker(function(offset) {\n      // handles seeking offset = seconds\n      seekImmediate(offset);\n    }, 500);\n  }\n\n  var updateTitle = function() {\n    p.getStatus(function(err, status) {\n      if (!status || !status.media ||\n          !status.media.metadata ||\n          !status.media.metadata.title) return;\n\n      var metadata = status.media.metadata;\n      var title;\n      if (metadata.artist) {\n        title = metadata.artist + ' - ' + metadata.title;\n      } else {\n        title = metadata.title;\n      }\n      ui.setLabel('source', 'Source', title);\n      ui.showLabels('state', 'source');\n      ui.render();\n    });\n  };\n\n  var initialSeek = function() {\n    var seconds = unformatTime(ctx.options.seek);\n    debug('seeking to %s', seconds);\n    p.seek(seconds);\n  };\n\n  p.on('playing', updateTitle);\n\n  if (!ctx.options.disableSeek && ctx.options.seek) {\n    p.once('playing', initialSeek);\n  }\n\n  updateTitle();\n\n  var nextInPlaylist = function() {\n    if (ctx.mode !== 'launch') return;\n    if (!playlist.length) return process.exit();\n    p.stop(function() {\n      ui.showLabels('state');\n      debug('loading next in playlist: %o', playlist[0]);\n      p.load(playlist[0], noop);\n      var file = playlist.shift();\n      if (ctx.options.loop)\n        playlist.push(file);\n      else\n        playlist_history.push(file);\n    });\n  };\n\n  var previousInPlaylist = function() {\n    if (ctx.options.loop) {\n      playlist.unshift(playlist.pop());\n      playlist.unshift(playlist.pop());\n      nextInPlaylist();\n    }\n    else if (0 < playlist_history.length) {\n      playlist.unshift(playlist_history.pop());\n      if (0 < playlist_history.length) playlist.unshift(playlist_history.pop());\n      nextInPlaylist();\n    }\n  };\n\n  p.on('status', last(function(status, memo) {\n    if (opts.exit && status.playerState == 'PLAYING') process.exit();\n    if (status.playerState !== 'IDLE') return;\n    if (status.idleReason !== 'FINISHED') return;\n    if (memo && memo.playerState === 'IDLE') return;\n    nextInPlaylist();\n    return status;\n  }));\n\n  var keyMappings = {\n\n    // toggle between play / pause\n    space: function() {\n      if (p.currentSession.playerState === 'PLAYING') {\n        p.pause();\n      } else if (p.currentSession.playerState === 'PAUSED') {\n        p.play();\n      }\n    },\n\n    // toggle between mute / unmute\n    m: function() {\n      if(!volume) {\n        return;\n      } else if (volume.muted) {\n        p.unmute(function(err, status) {\n          if (err) return;\n          volume = status;\n        });\n      } else {\n        p.mute(function(err, status) {\n          if (err) return;\n          volume = status;\n        });\n      }\n    },\n\n    t: function() {\n      if (!p.currentSession.media.tracks) { return }\n      var sessionRequestBody = {\n        type: 'EDIT_TRACKS_INFO'\n      }\n      sessionRequestBody.activeTrackIds = p.currentSession.activeTrackIds ? [] : [1];\n      p.sessionRequest(sessionRequestBody);\n    },\n\n    // volume up\n    up: function() {\n      if (!volume || volume.level >= 1) {\n        return;\n      }\n\n      var newVolume = Math.min(volume.level + volumeStep, 1);\n\n      p.setVolume(newVolume, function(err, status) {\n        if (err) {\n          return;\n        }\n\n        debug(\"volume up: %s\", status.level);\n\n        volume = status;\n      });\n    },\n\n    // volume down\n    down: function() {\n      if (!volume || volume.level <= 0) {\n        return;\n      }\n\n      var newVolume = Math.max(volume.level - volumeStep, 0);\n\n      p.setVolume(newVolume, function(err, status) {\n        if (err) {\n          return;\n        }\n\n        debug(\"volume down: %s\", status.level);\n\n        volume = status;\n      });\n    },\n\n    // next item in playlist\n    n: function() {\n      nextInPlaylist();\n    },\n\n    // previous item in playlist\n    p: function() {\n      previousInPlaylist();\n    },\n\n    // stop playback\n    s: function() {\n      p.stop();\n    },\n\n    // quit\n    q: function() {\n      process.exit();\n    },\n\n    // Rewind, one \"seekCount\" per press\n    left: function() {\n      seek(-30);\n    },\n\n    // Forward, one \"seekCount\" per press\n    right: function() {\n      seek(30);\n    }\n  };\n\n  if (is_keyboard_interactive) {\n    process.stdin.on('keypress', function(ch, key) {\n      if (key && key.name && keyMappings[key.name]) {\n        debug('key pressed: %s', key.name);\n        keyMappings[key.name]();\n      }\n      if (key && key.ctrl && key.name == 'c') {\n        process.exit();\n      }\n    });\n  }\n\n  if (opts.command) {\n    var commands = opts.command.split(\",\");\n    commands.forEach(function(command) {\n      if (!keyMappings[command]) {\n        fatalError('invalid --command: ' + command);\n      }\n    });\n\n    var index = 0;\n    function run_commands() {\n      if (index < commands.length) {\n        var command = commands[index++];\n        keyMappings[command]();\n        p.getStatus(run_commands);\n      } else {\n        if (opts.exit) {\n          process.exit();\n        }\n      }\n    }\n\n    p.getStatus(run_commands);\n  }\n};\n\nvar capitalize = function(str) {\n  return str.substr(0, 1).toUpperCase() + str.substr(1);\n};\n\nvar logState = (function() {\n  var inter;\n  var dots = circulate(['.', '..', '...', '....']);\n  return function(status) {\n    if (inter) clearInterval(inter);\n    debug('player status: %s', status);\n    inter = setInterval(function() {\n      ui.setLabel('state', 'State', capitalize(status) + dots());\n      ui.render();\n    }, 300);\n  };\n})();\n\nplayer.use(function(ctx, next) {\n  ctx.on('status', logState);\n  next();\n});\n\nplayer.use(stdin);\nplayer.use(directories);\nplayer.use(torrent);\nplayer.use(xspf);\nplayer.use(localfile);\nplayer.use(transcode);\nplayer.use(subtitles);\n\nplayer.use(function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (ctx.options.type)\n    // If a --type has been provided, then respect it.\n    ctx.options.playlist.map(function(item) {item.type = ctx.options.type;});\n  else {\n    ctx.options.playlist.map(function(item){\n      if (!item.type) {\n        // These will be URLs (the MIME type for files is filled in by the localfile plugin).\n        var mimeType = mime.lookup(item.path);\n        var type = mimeType.split('/')[0];\n        if (type === 'audio' || type === 'video') item.type = mimeType;\n      }\n    });\n  }\n  next()\n});\n\nplayer.use(function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (ctx.options.shuffle)\n    ctx.options.playlist = shuffle(ctx.options.playlist);\n  ctx.options = xtend(ctx.options, ctx.options.playlist[0]);\n  var file = ctx.options.playlist.shift();\n  if (ctx.options.loop)\n    ctx.options.playlist.push(file);\n  else\n    ctx.options.playlist_history = [file];\n  next();\n});\n\nif (!opts.playlist) {\n  debug('attaching...');\n  player.attach(opts, ctrl);\n} else {\n  debug('launching...');\n  player.launch(opts, ctrl);\n}\n\nprocess.on('SIGINT', function() {\n  process.exit();\n});\n\nprocess.on('exit', function() {\n  ui.hide();\n});\n\nmodule.exports = player;\n\n",
        "called_code_segment": "var localfile = function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (!contains(ctx.options.playlist, isXspf)) return next();\n\n  var list = ctx.options.playlist.slice(0);\n\n  Promise.all(list.map(function(item, idx) {\n    if (!isXspf(item)) {\n      return Promise.resolve([item]);\n    }\n\n    if (!isFile(item)) {\n      // TODO\n      throw 'Unsupported external XSPF links';\n    }\n\n    return new Promise(function(resolve, reject) {\n      xspfr(fs.readFileSync(item.path).toString(), function(err, result) {\n        if(err) reject(err)\n\n        resolve(result.map(function(item) {\n          return {\n            path: item.location,\n            media: {\n              metadata: {\n                title: item.title\n              }\n            }\n          }\n        }))\n      })\n    })\n\n  })).then(function(data) {\n    ctx.options.playlist = flatten1(data);\n    next()\n  })\n};",
        "invoking_code_segment": "player.use(localfile);",
        "new_file_code_segment": "var processXspf = function(item) {\n  return new Promise(function(resolve, reject) {\n    xspfr(fs.readFileSync(item.path).toString(), function(err, result) {\n      if(err) reject(err)\n\n      resolve(result.map(function(item) {\n        return {\n          path: item.location,\n          media: {\n            metadata: {\n              title: item.title\n            }\n          }\n        }\n      }))\n    })\n  })\n};",
        "feature_description": "Add a feature to process XSPF files asynchronously and handle errors more gracefully.",
        "detailed_feature_description": "The new feature involves creating a new file (#file 3) that contains a function to process XSPF files asynchronously. This function will be invoked from #file 1 where the XSPF processing logic currently resides. The new function will handle errors more gracefully and return a promise that resolves to the processed playlist items. This approach ensures that the XSPF processing is modular and can be easily extended or modified in the future.",
        "modified_complete_code": {
            "#file 1": "var localfile = function(ctx, next) {\n  if (ctx.mode !== 'launch') return next();\n  if (!contains(ctx.options.playlist, isXspf)) return next();\n\n  var list = ctx.options.playlist.slice(0);\n\n  Promise.all(list.map(function(item, idx) {\n    if (!isXspf(item)) {\n      return Promise.resolve([item]);\n    }\n\n    if (!isFile(item)) {\n      // TODO\n      throw 'Unsupported external XSPF links';\n    }\n\n    return processXspf(item); #Modify\n\n  })).then(function(data) {\n    ctx.options.playlist = flatten1(data);\n    next()\n  })\n};",
            "#file 2": "player.use(localfile);",
            "#file 3": "var processXspf = function(item) {\n  return new Promise(function(resolve, reject) {\n    xspfr(fs.readFileSync(item.path).toString(), function(err, result) {\n      if(err) reject(err)\n\n      resolve(result.map(function(item) {\n        return {\n          path: item.location,\n          media: {\n            metadata: {\n              title: item.title\n            }\n          }\n        }\n      }))\n    })\n  })\n}; #New"
        }
    },
    {
        "repo": "cls-rtracer",
        "content": "'cls-rtracer/index.js'\n:'use strict'\n\nconst {\n  expressMiddleware,\n  fastifyPlugin,\n  fastifyMiddleware,\n  koaMiddleware,\n  koaV1Middleware,\n  hapiPlugin,\n  runWithId,\n  id\n} = require('./src/rtracer')\n\nmodule.exports = {\n  expressMiddleware,\n  fastifyPlugin,\n  fastifyMiddleware,\n  koaMiddleware,\n  koaV1Middleware,\n  hapiPlugin,\n  runWithId,\n  id\n}\n\n'cls-rtracer/samples/koa.winston.js'\n:'use strict'\n\nconst rTracer = require('../index')\n\n// first - configure winston logger\n\nconst { createLogger, format, transports } = require('winston')\nconst { combine, timestamp, printf } = format\n\n// a custom format that outputs request id\nconst rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  return rid\n    ? `${info.timestamp} [request-id:${rid}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})\n\nconst logger = createLogger({\n  format: combine(\n    timestamp(),\n    rTracerFormat\n  ),\n  transports: [new transports.Console()]\n})\n\n// next - configure and start Koa app\n\nconst Koa = require('koa')\nconst app = new Koa()\n\napp.use(rTracer.koaMiddleware())\n\napp.use(async (ctx) => {\n  logger.info('Starting request handling')\n  const result = await fakeDbAccess()\n  ctx.body = result\n})\n\nasync function fakeDbAccess () {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      logger.info('Logs from fakeDbAccess')\n      resolve({ message: 'Hello from cls-rtracer Koa example' })\n    }, 0)\n  })\n}\n\napp.listen(3000, (err) => {\n  if (err) {\n    logger.err('The app could not start')\n  }\n  logger.info('The app is listening on 3000')\n})\n\n",
        "called_code_segment": "const rTracer = require('../index')\n\n// first - configure winston logger\n\nconst { createLogger, format, transports } = require('winston')\nconst { combine, timestamp, printf } = format\n\n// a custom format that outputs request id\nconst rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  return rid\n    ? `${info.timestamp} [request-id:${rid}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})\n\nconst logger = createLogger({\n  format: combine(\n    timestamp(),\n    rTracerFormat\n  ),\n  transports: [new transports.Console()]\n})",
        "invoking_code_segment": "app.use(rTracer.koaMiddleware())\n\napp.use(async (ctx) => {\n  logger.info('Starting request handling')\n  const result = await fakeDbAccess()\n  ctx.body = result\n})",
        "new_file_code_segment": "const rTracer = require('../index')\n\nfunction logWithRequestId(message) {\n  const rid = rTracer.id()\n  console.log(rid ? `[request-id:${rid}]: ${message}` : message)\n}\n\nmodule.exports = {\n  logWithRequestId\n}",
        "feature_description": "Add a new logging function that includes the request ID in the log message.",
        "detailed_feature_description": "A new file (#file 3) is created to encapsulate the logging functionality with request ID. This file exports a function `logWithRequestId` that logs messages with the request ID if available. The function is then integrated into both #file 1 and #file 2 to ensure consistent logging across the application.",
        "modified_complete_code": {
            "#file 1": "const rTracer = require('../index')\nconst { logWithRequestId } = require('./logger')\n\n// first - configure winston logger\n\nconst { createLogger, format, transports } = require('winston')\nconst { combine, timestamp, printf } = format\n\n// a custom format that outputs request id\nconst rTracerFormat = printf((info) => {\n  const rid = rTracer.id()\n  return rid\n    ? `${info.timestamp} [request-id:${rid}]: ${info.message}`\n    : `${info.timestamp}: ${info.message}`\n})\n\nconst logger = createLogger({\n  format: combine(\n    timestamp(),\n    rTracerFormat\n  ),\n  transports: [new transports.Console()]\n})\n\n// New: Use the new logging function\nlogger.info = logWithRequestId",
            "#file 2": "const Koa = require('koa')\nconst app = new Koa()\nconst { logWithRequestId } = require('./logger')\n\napp.use(rTracer.koaMiddleware())\n\napp.use(async (ctx) => {\n  logWithRequestId('Starting request handling')  // Modify: Use the new logging function\n  const result = await fakeDbAccess()\n  ctx.body = result\n})\n\nasync function fakeDbAccess () {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      logWithRequestId('Logs from fakeDbAccess')  // Modify: Use the new logging function\n      resolve({ message: 'Hello from cls-rtracer Koa example' })\n    }, 0)\n  })\n}\n\napp.listen(3000, (err) => {\n  if (err) {\n    logWithRequestId('The app could not start')  // Modify: Use the new logging function\n  }\n  logWithRequestId('The app is listening on 3000')  // Modify: Use the new logging function\n})",
            "#file 3": "const rTracer = require('../index')\n\nfunction logWithRequestId(message) {\n  const rid = rTracer.id()\n  console.log(rid ? `[request-id:${rid}]: ${message}` : message)\n}\n\nmodule.exports = {\n  logWithRequestId\n}"
        }
    },
    {
        "repo": "gulp-ng-config",
        "content": "'gulp-ng-config/gulp-ng-config.js'\n:'use strict';\n\nvar through = require('through2'),\n    _ = require('lodash'),\n    fs = require('fs'),\n    jsYaml = require('js-yaml'),\n    replaceExt = require('replace-ext'),\n    PluginError = require('plugin-error'),\n    VALID_TYPES = ['constant', 'value'],\n    PLUGIN_NAME = 'gulp-ng-config',\n    WRAP_TEMPLATE = '(function () { \\n return <%= module %>\\n})();\\n',\n    ES6_TEMPLATE = 'import angular from \\'angular\\';\\nexport default <%= module %>';\n\nfunction gulpNgConfig (moduleName, configuration) {\n  var stream, defaults;\n  defaults = {\n    type: 'constant',\n    createModule: true,\n    wrap: false,\n    environment: null,\n    parser: null,\n    pretty: false,\n    keys: null,\n    templateFilePath:  __dirname + '/template.html'\n  };\n\n  if (!moduleName) {\n    throw new PluginError(PLUGIN_NAME, 'Missing required moduleName option for gulp-ng-config');\n  }\n\n  configuration = configuration || {};\n  configuration = _.merge({}, defaults, configuration);\n\n  stream = through.obj(function (file, encoding, callback) {\n    var constants = [],\n        templateFile,\n        templateOutput,\n        jsonObj,\n        wrapTemplate,\n        spaces,\n        environmentKeys;\n\n    try {\n      templateFile = fs.readFileSync(configuration.templateFilePath || defaults.templateFilePath, 'utf8');\n    } catch (error) {\n      this.emit('error', new PluginError(PLUGIN_NAME, 'invalid templateFilePath option, file not found'));\n      return callback();\n    }\n\n    if (!configuration.parser && (_.endsWith(file.path, 'yml') || _.endsWith(file.path, 'yaml'))) {\n      configuration.parser = 'yml';\n    }\n\n    if (!configuration.parser) {\n      configuration.parser = 'json';\n    }\n\n    if (configuration.parser === 'json') {\n      try {\n        jsonObj = file.isNull() ? {} : JSON.parse(file.contents.toString('utf8'));\n      } catch (e) {\n        this.emit('error', new PluginError(PLUGIN_NAME, 'invalid JSON file provided'));\n        return callback();\n      }\n    } else if (configuration.parser === 'yml' || configuration.parser === 'yaml') {\n      try {\n        jsonObj = jsYaml.safeLoad(file.contents);\n      } catch (e) {\n        this.emit('error', new PluginError(PLUGIN_NAME, 'invaild YML file provided'));\n        return callback();\n      }\n    } else {\n      this.emit('error', new PluginError(PLUGIN_NAME, configuration.parser + ' is not supported as a valid parser'));\n      return callback();\n    }\n\n    if (!_.isPlainObject(jsonObj)) {\n      this.emit('error', new PluginError(PLUGIN_NAME, 'configuration file contains invalid JSON'));\n      return callback();\n    }\n\n    // select the environment in the configuration\n    if (configuration.environment) {\n      // transform values into a flat array\n      environmentKeys = [].concat(configuration.environment);\n\n      // build the output based on the specifid keys\n      jsonObj = environmentKeys.reduce(_.bind(function (obj, environmentKey) {\n        var value = _.get(jsonObj, environmentKey);\n\n        // if the key does not exist, raise an error.\n        if (value === undefined) {\n          this.emit('error', new PluginError(PLUGIN_NAME, 'invalid \\'environment\\' value'));\n          return callback();\n        }\n\n        // add the value to the output object\n        _.merge(obj, value);\n        return obj;\n      }, this), {});\n    }\n\n    if (!_.includes(VALID_TYPES, configuration.type)) {\n      this.emit('error', new PluginError(PLUGIN_NAME, 'invalid \\'type\\' value'));\n      return callback();\n    }\n\n    if (configuration.keys) {\n      if (_.isArray(configuration.keys)) {\n        jsonObj = _.pick(jsonObj, configuration.keys);\n      } else {\n        this.emit('error', new PluginError(PLUGIN_NAME, 'invalid \\'keys\\' value'));\n        return callback();\n      }\n    }\n\n    jsonObj = _.merge({}, jsonObj, configuration.constants || {});\n\n    if (_.isUndefined(configuration.pretty) || configuration.pretty === false) {\n      spaces = 0;\n    } else if (configuration.pretty === true) {\n      spaces = 2;\n    } else if (!isNaN(configuration.pretty) && Number.isFinite(configuration.pretty)) {\n      spaces = parseInt(configuration.pretty);\n    } else {\n      this.emit('error', new PluginError(\n        PLUGIN_NAME,\n        'invalid \\'pretty\\' value. Should be boolean value or an integer number'\n      ));\n      return callback();\n    }\n\n    _.each(jsonObj, function (value, key) {\n      constants.push({\n        name: key,\n        value: JSON.stringify(value, null, spaces)\n      });\n    });\n\n    templateOutput = _.template(templateFile)({\n      createModule: configuration.createModule,\n      moduleName: moduleName,\n      type: configuration.type,\n      constants: constants\n    });\n\n    if (configuration.wrap) {\n      if (typeof configuration.wrap === 'string' &&\n        (configuration.wrap.toUpperCase() === 'ES6' || configuration.wrap.toUpperCase() === 'ES2015')) {\n        wrapTemplate = ES6_TEMPLATE;\n      } else if (typeof configuration.wrap === 'string') {\n        wrapTemplate = configuration.wrap;\n      } else {\n        wrapTemplate = WRAP_TEMPLATE;\n      }\n      templateOutput = _.template(wrapTemplate)({\n        module: templateOutput\n      });\n    }\n\n    file.path = replaceExt(file.path, '.js');\n    file.contents = new Buffer(templateOutput);\n    this.push(file);\n    callback();\n  });\n\n  return stream;\n}\n\nmodule.exports = gulpNgConfig;\n\n'gulp-ng-config/index.js'\n:module.exports = require('./gulp-ng-config');\n\n",
        "called_code_segment": "module.exports = gulpNgConfig;",
        "invoking_code_segment": "module.exports = require('./gulp-ng-config');",
        "new_file_code_segment": "function validateConfig(config) {\n  if (!config.moduleName) {\n    throw new PluginError(PLUGIN_NAME, 'Missing required moduleName option for gulp-ng-config');\n  }\n  if (!_.includes(VALID_TYPES, config.type)) {\n    throw new PluginError(PLUGIN_NAME, 'invalid 'type' value');\n  }\n  // Additional validation logic can be added here\n}",
        "feature_description": "Added configuration validation to ensure required fields and valid types are provided.",
        "detailed_feature_description": "The new feature introduces a validation function in #file 3 that checks if the required 'moduleName' field is present and if the 'type' field is one of the valid types. This function is invoked in #file 1 before proceeding with the configuration processing. This ensures that the configuration is valid before any processing occurs, preventing potential errors during runtime.",
        "modified_complete_code": {
            "#file 1": "'use strict';\n\nvar through = require('through2'),\n    _ = require('lodash'),\n    fs = require('fs'),\n    jsYaml = require('js-yaml'),\n    replaceExt = require('replace-ext'),\n    PluginError = require('plugin-error'),\n    VALID_TYPES = ['constant', 'value'],\n    PLUGIN_NAME = 'gulp-ng-config',\n    WRAP_TEMPLATE = '(function () { \n return <%= module %>\n})();\n',\n    ES6_TEMPLATE = 'import angular from 'angular';\nexport default <%= module %>'\n\nfunction gulpNgConfig (moduleName, configuration) {\n  var stream, defaults;\n  defaults = {\n    type: 'constant',\n    createModule: true,\n    wrap: false,\n    environment: null,\n    parser: null,\n    pretty: false,\n    keys: null,\n    templateFilePath:  __dirname + '/template.html'\n  };\n\n  // Modify\n  validateConfig({ moduleName: moduleName, type: configuration.type });\n\n  configuration = configuration || {};\n  configuration = _.merge({}, defaults, configuration);\n\n  stream = through.obj(function (file, encoding, callback) {\n    var constants = [],\n        templateFile,\n        templateOutput,\n        jsonObj,\n        wrapTemplate,\n        spaces,\n        environmentKeys;\n\n    try {\n      templateFile = fs.readFileSync(configuration.templateFilePath || defaults.templateFilePath, 'utf8');\n    } catch (error) {\n      this.emit('error', new PluginError(PLUGIN_NAME, 'invalid templateFilePath option, file not found'));\n      return callback();\n    }\n\n    if (!configuration.parser && (_.endsWith(file.path, 'yml') || _.endsWith(file.path, 'yaml'))) {\n      configuration.parser = 'yml';\n    }\n\n    if (!configuration.parser) {\n      configuration.parser = 'json';\n    }\n\n    if (configuration.parser === 'json') {\n      try {\n        jsonObj = file.isNull() ? {} : JSON.parse(file.contents.toString('utf8'));\n      } catch (e) {\n        this.emit('error', new PluginError(PLUGIN_NAME, 'invalid JSON file provided'));\n        return callback();\n      }\n    } else if (configuration.parser === 'yml' || configuration.parser === 'yaml') {\n      try {\n        jsonObj = jsYaml.safeLoad(file.contents);\n      } catch (e) {\n        this.emit('error', new PluginError(PLUGIN_NAME, 'invaild YML file provided'));\n        return callback();\n      }\n    } else {\n      this.emit('error', new PluginError(PLUGIN_NAME, configuration.parser + ' is not supported as a valid parser'));\n      return callback();\n    }\n\n    if (!_.isPlainObject(jsonObj)) {\n      this.emit('error', new PluginError(PLUGIN_NAME, 'configuration file contains invalid JSON'));\n      return callback();\n    }\n\n    // select the environment in the configuration\n    if (configuration.environment) {\n      // transform values into a flat array\n      environmentKeys = [].concat(configuration.environment);\n\n      // build the output based on the specifid keys\n      jsonObj = environmentKeys.reduce(_.bind(function (obj, environmentKey) {\n        var value = _.get(jsonObj, environmentKey);\n\n        // if the key does not exist, raise an error.\n        if (value === undefined) {\n          this.emit('error', new PluginError(PLUGIN_NAME, 'invalid 'environment' value'));\n          return callback();\n        }\n\n        // add the value to the output object\n        _.merge(obj, value);\n        return obj;\n      }, this), {});\n    }\n\n    if (configuration.keys) {\n      if (_.isArray(configuration.keys)) {\n        jsonObj = _.pick(jsonObj, configuration.keys);\n      } else {\n        this.emit('error', new PluginError(PLUGIN_NAME, 'invalid 'keys' value'));\n        return callback();\n      }\n    }\n\n    jsonObj = _.merge({}, jsonObj, configuration.constants || {});\n\n    if (_.isUndefined(configuration.pretty) || configuration.pretty === false) {\n      spaces = 0;\n    } else if (configuration.pretty === true) {\n      spaces = 2;\n    } else if (!isNaN(configuration.pretty) && Number.isFinite(configuration.pretty)) {\n      spaces = parseInt(configuration.pretty);\n    } else {\n      this.emit('error', new PluginError(\n        PLUGIN_NAME,\n        'invalid 'pretty' value. Should be boolean value or an integer number'\n      ));\n      return callback();\n    }\n\n    _.each(jsonObj, function (value, key) {\n      constants.push({\n        name: key,\n        value: JSON.stringify(value, null, spaces)\n      });\n    });\n\n    templateOutput = _.template(templateFile)({\n      createModule: configuration.createModule,\n      moduleName: moduleName,\n      type: configuration.type,\n      constants: constants\n    });\n\n    if (configuration.wrap) {\n      if (typeof configuration.wrap === 'string' &&\n        (configuration.wrap.toUpperCase() === 'ES6' || configuration.wrap.toUpperCase() === 'ES2015')) {\n        wrapTemplate = ES6_TEMPLATE;\n      } else if (typeof configuration.wrap === 'string') {\n        wrapTemplate = configuration.wrap;\n      } else {\n        wrapTemplate = WRAP_TEMPLATE;\n      }\n      templateOutput = _.template(wrapTemplate)({\n        module: templateOutput\n      });\n    }\n\n    file.path = replaceExt(file.path, '.js');\n    file.contents = new Buffer(templateOutput);\n    this.push(file);\n    callback();\n  });\n\n  return stream;\n}\n\n// New\nfunction validateConfig(config) {\n  if (!config.moduleName) {\n    throw new PluginError(PLUGIN_NAME, 'Missing required moduleName option for gulp-ng-config');\n  }\n  if (!_.includes(VALID_TYPES, config.type)) {\n    throw new PluginError(PLUGIN_NAME, 'invalid 'type' value');\n  }\n  // Additional validation logic can be added here\n}\n\nmodule.exports = gulpNgConfig;",
            "#file 2": "module.exports = require('./gulp-ng-config');",
            "#file 3": "function validateConfig(config) {\n  if (!config.moduleName) {\n    throw new PluginError(PLUGIN_NAME, 'Missing required moduleName option for gulp-ng-config');\n  }\n  if (!_.includes(VALID_TYPES, config.type)) {\n    throw new PluginError(PLUGIN_NAME, 'invalid 'type' value');\n  }\n  // Additional validation logic can be added here\n}"
        }
    },
    {
        "repo": "jquery-autocompleter",
        "content": "'jquery-autocompleter/examples/demo/src/data.js'\n:/**\n * Crayola colors in JSON format\n * from: https://gist.github.com/jjdelc/1868136\n */\nexport default [\n  {\n    hex: \"#EFDECD\",\n    name: \"Almond\",\n    rgb: \"(239, 222, 205)\",\n  },\n  {\n    hex: \"#CD9575\",\n    name: \"Antique Brass\",\n    rgb: \"(205, 149, 117)\",\n  },\n  {\n    hex: \"#FDD9B5\",\n    name: \"Apricot\",\n    rgb: \"(253, 217, 181)\",\n  },\n  {\n    hex: \"#78DBE2\",\n    name: \"Aquamarine\",\n    rgb: \"(120, 219, 226)\",\n  },\n  {\n    hex: \"#87A96B\",\n    name: \"Asparagus\",\n    rgb: \"(135, 169, 107)\",\n  },\n  {\n    hex: \"#FFA474\",\n    name: \"Atomic Tangerine\",\n    rgb: \"(255, 164, 116)\",\n  },\n  {\n    hex: \"#FAE7B5\",\n    name: \"Banana Mania\",\n    rgb: \"(250, 231, 181)\",\n  },\n  {\n    hex: \"#9F8170\",\n    name: \"Beaver\",\n    rgb: \"(159, 129, 112)\",\n  },\n  {\n    hex: \"#FD7C6E\",\n    name: \"Bittersweet\",\n    rgb: \"(253, 124, 110)\",\n  },\n  {\n    hex: \"#000000\",\n    name: \"Black\",\n    rgb: \"(0,0,0)\",\n  },\n  {\n    hex: \"#ACE5EE\",\n    name: \"Blizzard Blue\",\n    rgb: \"(172, 229, 238)\",\n  },\n  {\n    hex: \"#1F75FE\",\n    name: \"Blue\",\n    rgb: \"(31, 117, 254)\",\n  },\n  {\n    hex: \"#A2A2D0\",\n    name: \"Blue Bell\",\n    rgb: \"(162, 162, 208)\",\n  },\n  {\n    hex: \"#6699CC\",\n    name: \"Blue Gray\",\n    rgb: \"(102, 153, 204)\",\n  },\n  {\n    hex: \"#0D98BA\",\n    name: \"Blue Green\",\n    rgb: \"(13, 152, 186)\",\n  },\n  {\n    hex: \"#7366BD\",\n    name: \"Blue Violet\",\n    rgb: \"(115, 102, 189)\",\n  },\n  {\n    hex: \"#DE5D83\",\n    name: \"Blush\",\n    rgb: \"(222, 93, 131)\",\n  },\n  {\n    hex: \"#CB4154\",\n    name: \"Brick Red\",\n    rgb: \"(203, 65, 84)\",\n  },\n  {\n    hex: \"#B4674D\",\n    name: \"Brown\",\n    rgb: \"(180, 103, 77)\",\n  },\n  {\n    hex: \"#FF7F49\",\n    name: \"Burnt Orange\",\n    rgb: \"(255, 127, 73)\",\n  },\n  {\n    hex: \"#EA7E5D\",\n    name: \"Burnt Sienna\",\n    rgb: \"(234, 126, 93)\",\n  },\n  {\n    hex: \"#B0B7C6\",\n    name: \"Cadet Blue\",\n    rgb: \"(176, 183, 198)\",\n  },\n  {\n    hex: \"#FFFF99\",\n    name: \"Canary\",\n    rgb: \"(255, 255, 153)\",\n  },\n  {\n    hex: \"#1CD3A2\",\n    name: \"Caribbean Green\",\n    rgb: \"(28, 211, 162)\",\n  },\n  {\n    hex: \"#FFAACC\",\n    name: \"Carnation Pink\",\n    rgb: \"(255, 170, 204)\",\n  },\n  {\n    hex: \"#DD4492\",\n    name: \"Cerise\",\n    rgb: \"(221, 68, 146)\",\n  },\n  {\n    hex: \"#1DACD6\",\n    name: \"Cerulean\",\n    rgb: \"(29, 172, 214)\",\n  },\n  {\n    hex: \"#BC5D58\",\n    name: \"Chestnut\",\n    rgb: \"(188, 93, 88)\",\n  },\n  {\n    hex: \"#DD9475\",\n    name: \"Copper\",\n    rgb: \"(221, 148, 117)\",\n  },\n  {\n    hex: \"#9ACEEB\",\n    name: \"Cornflower\",\n    rgb: \"(154, 206, 235)\",\n  },\n  {\n    hex: \"#FFBCD9\",\n    name: \"Cotton Candy\",\n    rgb: \"(255, 188, 217)\",\n  },\n  {\n    hex: \"#FDDB6D\",\n    name: \"Dandelion\",\n    rgb: \"(253, 219, 109)\",\n  },\n  {\n    hex: \"#2B6CC4\",\n    name: \"Denim\",\n    rgb: \"(43, 108, 196)\",\n  },\n  {\n    hex: \"#EFCDB8\",\n    name: \"Desert Sand\",\n    rgb: \"(239, 205, 184)\",\n  },\n  {\n    hex: \"#6E5160\",\n    name: \"Eggplant\",\n    rgb: \"(110, 81, 96)\",\n  },\n  {\n    hex: \"#CEFF1D\",\n    name: \"Electric Lime\",\n    rgb: \"(206, 255, 29)\",\n  },\n  {\n    hex: \"#71BC78\",\n    name: \"Fern\",\n    rgb: \"(113, 188, 120)\",\n  },\n  {\n    hex: \"#6DAE81\",\n    name: \"Forest Green\",\n    rgb: \"(109, 174, 129)\",\n  },\n  {\n    hex: \"#C364C5\",\n    name: \"Fuchsia\",\n    rgb: \"(195, 100, 197)\",\n  },\n  {\n    hex: \"#CC6666\",\n    name: \"Fuzzy Wuzzy\",\n    rgb: \"(204, 102, 102)\",\n  },\n  {\n    hex: \"#E7C697\",\n    name: \"Gold\",\n    rgb: \"(231, 198, 151)\",\n  },\n  {\n    hex: \"#FCD975\",\n    name: \"Goldenrod\",\n    rgb: \"(252, 217, 117)\",\n  },\n  {\n    hex: \"#A8E4A0\",\n    name: \"Granny Smith Apple\",\n    rgb: \"(168, 228, 160)\",\n  },\n  {\n    hex: \"#95918C\",\n    name: \"Gray\",\n    rgb: \"(149, 145, 140)\",\n  },\n  {\n    hex: \"#1CAC78\",\n    name: \"Green\",\n    rgb: \"(28, 172, 120)\",\n  },\n  {\n    hex: \"#1164B4\",\n    name: \"Green Blue\",\n    rgb: \"(17, 100, 180)\",\n  },\n  {\n    hex: \"#F0E891\",\n    name: \"Green Yellow\",\n    rgb: \"(240, 232, 145)\",\n  },\n  {\n    hex: \"#FF1DCE\",\n    name: \"Hot Magenta\",\n    rgb: \"(255, 29, 206)\",\n  },\n  {\n    hex: \"#B2EC5D\",\n    name: \"Inchworm\",\n    rgb: \"(178, 236, 93)\",\n  },\n  {\n    hex: \"#5D76CB\",\n    name: \"Indigo\",\n    rgb: \"(93, 118, 203)\",\n  },\n  {\n    hex: \"#CA3767\",\n    name: \"Jazzberry Jam\",\n    rgb: \"(202, 55, 103)\",\n  },\n  {\n    hex: \"#3BB08F\",\n    name: \"Jungle Green\",\n    rgb: \"(59, 176, 143)\",\n  },\n  {\n    hex: \"#FEFE22\",\n    name: \"Laser Lemon\",\n    rgb: \"(254, 254, 34)\",\n  },\n  {\n    hex: \"#FCB4D5\",\n    name: \"Lavender\",\n    rgb: \"(252, 180, 213)\",\n  },\n  {\n    hex: \"#FFF44F\",\n    name: \"Lemon Yellow\",\n    rgb: \"(255, 244, 79)\",\n  },\n  {\n    hex: \"#FFBD88\",\n    name: \"Macaroni and Cheese\",\n    rgb: \"(255, 189, 136)\",\n  },\n  {\n    hex: \"#F664AF\",\n    name: \"Magenta\",\n    rgb: \"(246, 100, 175)\",\n  },\n  {\n    hex: \"#AAF0D1\",\n    name: \"Magic Mint\",\n    rgb: \"(170, 240, 209)\",\n  },\n  {\n    hex: \"#CD4A4C\",\n    name: \"Mahogany\",\n    rgb: \"(205, 74, 76)\",\n  },\n  {\n    hex: \"#EDD19C\",\n    name: \"Maize\",\n    rgb: \"(237, 209, 156)\",\n  },\n  {\n    hex: \"#979AAA\",\n    name: \"Manatee\",\n    rgb: \"(151, 154, 170)\",\n  },\n  {\n    hex: \"#FF8243\",\n    name: \"Mango Tango\",\n    rgb: \"(255, 130, 67)\",\n  },\n  {\n    hex: \"#C8385A\",\n    name: \"Maroon\",\n    rgb: \"(200, 56, 90)\",\n  },\n  {\n    hex: \"#EF98AA\",\n    name: \"Mauvelous\",\n    rgb: \"(239, 152, 170)\",\n  },\n  {\n    hex: \"#FDBCB4\",\n    name: \"Melon\",\n    rgb: \"(253, 188, 180)\",\n  },\n  {\n    hex: \"#1A4876\",\n    name: \"Midnight Blue\",\n    rgb: \"(26, 72, 118)\",\n  },\n  {\n    hex: \"#30BA8F\",\n    name: \"Mountain Meadow\",\n    rgb: \"(48, 186, 143)\",\n  },\n  {\n    hex: \"#C54B8C\",\n    name: \"Mulberry\",\n    rgb: \"(197, 75, 140)\",\n  },\n  {\n    hex: \"#1974D2\",\n    name: \"Navy Blue\",\n    rgb: \"(25, 116, 210)\",\n  },\n  {\n    hex: \"#FFA343\",\n    name: \"Neon Carrot\",\n    rgb: \"(255, 163, 67)\",\n  },\n  {\n    hex: \"#BAB86C\",\n    name: \"Olive Green\",\n    rgb: \"(186, 184, 108)\",\n  },\n  {\n    hex: \"#FF7538\",\n    name: \"Orange\",\n    rgb: \"(255, 117, 56)\",\n  },\n  {\n    hex: \"#FF2B2B\",\n    name: \"Orange Red\",\n    rgb: \"(255, 43, 43)\",\n  },\n  {\n    hex: \"#F8D568\",\n    name: \"Orange Yellow\",\n    rgb: \"(248, 213, 104)\",\n  },\n  {\n    hex: \"#E6A8D7\",\n    name: \"Orchid\",\n    rgb: \"(230, 168, 215)\",\n  },\n  {\n    hex: \"#414A4C\",\n    name: \"Outer Space\",\n    rgb: \"(65, 74, 76)\",\n  },\n  {\n    hex: \"#FF6E4A\",\n    name: \"Outrageous Orange\",\n    rgb: \"(255, 110, 74)\",\n  },\n  {\n    hex: \"#1CA9C9\",\n    name: \"Pacific Blue\",\n    rgb: \"(28, 169, 201)\",\n  },\n  {\n    hex: \"#FFCFAB\",\n    name: \"Peach\",\n    rgb: \"(255, 207, 171)\",\n  },\n  {\n    hex: \"#C5D0E6\",\n    name: \"Periwinkle\",\n    rgb: \"(197, 208, 230)\",\n  },\n  {\n    hex: \"#FDDDE6\",\n    name: \"Piggy Pink\",\n    rgb: \"(253, 221, 230)\",\n  },\n  {\n    hex: \"#158078\",\n    name: \"Pine Green\",\n    rgb: \"(21, 128, 120)\",\n  },\n  {\n    hex: \"#FC74FD\",\n    name: \"Pink Flamingo\",\n    rgb: \"(252, 116, 253)\",\n  },\n  {\n    hex: \"#F78FA7\",\n    name: \"Pink Sherbet\",\n    rgb: \"(247, 143, 167)\",\n  },\n  {\n    hex: \"#8E4585\",\n    name: \"Plum\",\n    rgb: \"(142, 69, 133)\",\n  },\n  {\n    hex: \"#7442C8\",\n    name: \"Purple Heart\",\n    rgb: \"(116, 66, 200)\",\n  },\n  {\n    hex: \"#9D81BA\",\n    name: \"Purple Mountain's Majesty\",\n    rgb: \"(157, 129, 186)\",\n  },\n  {\n    hex: \"#FE4EDA\",\n    name: \"Purple Pizzazz\",\n    rgb: \"(254, 78, 218)\",\n  },\n  {\n    hex: \"#FF496C\",\n    name: \"Radical Red\",\n    rgb: \"(255, 73, 108)\",\n  },\n  {\n    hex: \"#D68A59\",\n    name: \"Raw Sienna\",\n    rgb: \"(214, 138, 89)\",\n  },\n  {\n    hex: \"#714B23\",\n    name: \"Raw Umber\",\n    rgb: \"(113, 75, 35)\",\n  },\n  {\n    hex: \"#FF48D0\",\n    name: \"Razzle Dazzle Rose\",\n    rgb: \"(255, 72, 208)\",\n  },\n  {\n    hex: \"#E3256B\",\n    name: \"Razzmatazz\",\n    rgb: \"(227, 37, 107)\",\n  },\n  {\n    hex: \"#EE204D\",\n    name: \"Red\",\n    rgb: \"(238,32 ,77 )\",\n  },\n  {\n    hex: \"#FF5349\",\n    name: \"Red Orange\",\n    rgb: \"(255, 83, 73)\",\n  },\n  {\n    hex: \"#C0448F\",\n    name: \"Red Violet\",\n    rgb: \"(192, 68, 143)\",\n  },\n  {\n    hex: \"#1FCECB\",\n    name: \"Robin's Egg Blue\",\n    rgb: \"(31, 206, 203)\",\n  },\n  {\n    hex: \"#7851A9\",\n    name: \"Royal Purple\",\n    rgb: \"(120, 81, 169)\",\n  },\n  {\n    hex: \"#FF9BAA\",\n    name: \"Salmon\",\n    rgb: \"(255, 155, 170)\",\n  },\n  {\n    hex: \"#FC2847\",\n    name: \"Scarlet\",\n    rgb: \"(252, 40, 71)\",\n  },\n  {\n    hex: \"#76FF7A\",\n    name: \"Screamin' Green\",\n    rgb: \"(118, 255, 122)\",\n  },\n  {\n    hex: \"#9FE2BF\",\n    name: \"Sea Green\",\n    rgb: \"(159, 226, 191)\",\n  },\n  {\n    hex: \"#A5694F\",\n    name: \"Sepia\",\n    rgb: \"(165, 105, 79)\",\n  },\n  {\n    hex: \"#8A795D\",\n    name: \"Shadow\",\n    rgb: \"(138, 121, 93)\",\n  },\n  {\n    hex: \"#45CEA2\",\n    name: \"Shamrock\",\n    rgb: \"(69, 206, 162)\",\n  },\n  {\n    hex: \"#FB7EFD\",\n    name: \"Shocking Pink\",\n    rgb: \"(251, 126, 253)\",\n  },\n  {\n    hex: \"#CDC5C2\",\n    name: \"Silver\",\n    rgb: \"(205, 197, 194)\",\n  },\n  {\n    hex: \"#80DAEB\",\n    name: \"Sky Blue\",\n    rgb: \"(128, 218, 235)\",\n  },\n  {\n    hex: \"#ECEABE\",\n    name: \"Spring Green\",\n    rgb: \"(236, 234, 190)\",\n  },\n  {\n    hex: \"#FFCF48\",\n    name: \"Sunglow\",\n    rgb: \"(255, 207, 72)\",\n  },\n  {\n    hex: \"#FD5E53\",\n    name: \"Sunset Orange\",\n    rgb: \"(253, 94, 83)\",\n  },\n  {\n    hex: \"#FAA76C\",\n    name: \"Tan\",\n    rgb: \"(250, 167, 108)\",\n  },\n  {\n    hex: \"#18A7B5\",\n    name: \"Teal Blue\",\n    rgb: \"(24, 167, 181)\",\n  },\n  {\n    hex: \"#EBC7DF\",\n    name: \"Thistle\",\n    rgb: \"(235, 199, 223)\",\n  },\n  {\n    hex: \"#FC89AC\",\n    name: \"Tickle Me Pink\",\n    rgb: \"(252, 137, 172)\",\n  },\n  {\n    hex: \"#DBD7D2\",\n    name: \"Timberwolf\",\n    rgb: \"(219, 215, 210)\",\n  },\n  {\n    hex: \"#17806D\",\n    name: \"Tropical Rain Forest\",\n    rgb: \"(23, 128, 109)\",\n  },\n  {\n    hex: \"#DEAA88\",\n    name: \"Tumbleweed\",\n    rgb: \"(222, 170, 136)\",\n  },\n  {\n    hex: \"#77DDE7\",\n    name: \"Turquoise Blue\",\n    rgb: \"(119, 221, 231)\",\n  },\n  {\n    hex: \"#FFFF66\",\n    name: \"Unmellow Yellow\",\n    rgb: \"(255, 255, 102)\",\n  },\n  {\n    hex: \"#926EAE\",\n    name: \"Violet (Purple)\",\n    rgb: \"(146, 110, 174)\",\n  },\n  {\n    hex: \"#324AB2\",\n    name: \"Violet Blue\",\n    rgb: \"(50, 74, 178)\",\n  },\n  {\n    hex: \"#F75394\",\n    name: \"Violet Red\",\n    rgb: \"(247, 83, 148)\",\n  },\n  {\n    hex: \"#FFA089\",\n    name: \"Vivid Tangerine\",\n    rgb: \"(255, 160, 137)\",\n  },\n  {\n    hex: \"#8F509D\",\n    name: \"Vivid Violet\",\n    rgb: \"(143, 80, 157)\",\n  },\n  {\n    hex: \"#FFFFFF\",\n    name: \"White\",\n    rgb: \"(255, 255, 255)\",\n  },\n  {\n    hex: \"#A2ADD0\",\n    name: \"Wild Blue Yonder\",\n    rgb: \"(162, 173, 208)\",\n  },\n  {\n    hex: \"#FF43A4\",\n    name: \"Wild Strawberry\",\n    rgb: \"(255, 67, 164)\",\n  },\n  {\n    hex: \"#FC6C85\",\n    name: \"Wild Watermelon\",\n    rgb: \"(252, 108, 133)\",\n  },\n  {\n    hex: \"#CDA4DE\",\n    name: \"Wisteria\",\n    rgb: \"(205, 164, 222)\",\n  },\n  {\n    hex: \"#FCE883\",\n    name: \"Yellow\",\n    rgb: \"(252, 232, 131)\",\n  },\n  {\n    hex: \"#C5E384\",\n    name: \"Yellow Green\",\n    rgb: \"(197, 227, 132)\",\n  },\n  {\n    hex: \"#FFAE42\",\n    name: \"Yellow Orange\",\n    rgb: \"(255, 174, 66)\",\n  },\n];\n\n'jquery-autocompleter/examples/demo/src/index.js'\n:import \"./normalize.css\";\nimport \"./styles.css\";\n\nimport $ from \"jquery\";\nimport \"jquery-autocompleter\";\n\nimport colors from \"./data\";\n\n$(function () {\n  $(\"#nope\").autocompleter({\n    // map \"name\" as label\n    customLabel: \"name\",\n\n    // marker for autocomplete matches\n    highlightMatches: true,\n\n    // object to local or url to remote search\n    source: colors,\n\n    // custom template\n    template: '{{ label }} <span style=\"color: {{ hex }};\">({{ hex }})</span>',\n\n    // show hint\n    hint: true,\n\n    // abort source if empty field\n    empty: false,\n\n    // max results\n    limit: 10,\n\n    // user callback\n    callback: function (value, index, selected) {\n      console.log(\"callback\", { value, index, selected });\n\n      if (selected) {\n        $(\".icon\").css(\"background-color\", selected.hex);\n      }\n    },\n  });\n});\n\n",
        "called_code_segment": "$(function () {\n  $('#nope').autocompleter({\n    customLabel: 'name',\n    highlightMatches: true,\n    source: colors,\n    template: '{{ label }} <span style=\"color: {{ hex }};\">({{ hex }})</span>',\n    hint: true,\n    empty: false,\n    limit: 10,\n    callback: function (value, index, selected) {\n      console.log('callback', { value, index, selected });\n      if (selected) {\n        $('.icon').css('background-color', selected.hex);\n      }\n    },\n  });\n});",
        "invoking_code_segment": "$(function () {\n  $('#nope').autocompleter({\n    customLabel: 'name',\n    highlightMatches: true,\n    source: colors,\n    template: '{{ label }} <span style=\"color: {{ hex }};\">({{ hex }})</span>',\n    hint: true,\n    empty: false,\n    limit: 10,\n    callback: function (value, index, selected) {\n      console.log('callback', { value, index, selected });\n      if (selected) {\n        $('.icon').css('background-color', selected.hex);\n      }\n    },\n  });\n});",
        "new_file_code_segment": "function updateBackgroundColor(selected) {\n  if (selected) {\n    $('.icon').css('background-color', selected.hex);\n  }\n}\n\nexport { updateBackgroundColor };",
        "feature_description": "Add a function to update the background color of an element based on the selected color in the autocomplete.",
        "detailed_feature_description": "The new feature introduces a function `updateBackgroundColor` in #file 3 that updates the background color of an element with the class `icon` based on the selected color from the autocomplete. This function is imported and used in #file 1 to replace the inline code that updates the background color. This modular approach enhances code readability and maintainability.",
        "modified_complete_code": {
            "#file 1": "import { updateBackgroundColor } from './newFile'; //New\n\n$(function () {\n  $('#nope').autocompleter({\n    customLabel: 'name',\n    highlightMatches: true,\n    source: colors,\n    template: '{{ label }} <span style=\"color: {{ hex }};\">({{ hex }})</span>',\n    hint: true,\n    empty: false,\n    limit: 10,\n    callback: function (value, index, selected) {\n      console.log('callback', { value, index, selected });\n      updateBackgroundColor(selected); //Modify\n    },\n  });\n});",
            "#file 2": "$(function () {\n  $('#nope').autocompleter({\n    customLabel: 'name',\n    highlightMatches: true,\n    source: colors,\n    template: '{{ label }} <span style=\"color: {{ hex }};\">({{ hex }})</span>',\n    hint: true,\n    empty: false,\n    limit: 10,\n    callback: function (value, index, selected) {\n      console.log('callback', { value, index, selected });\n      updateBackgroundColor(selected); //Modify\n    },\n  });\n});",
            "#file 3": "function updateBackgroundColor(selected) {\n  if (selected) {\n    $('.icon').css('background-color', selected.hex);\n  }\n}\n\nexport { updateBackgroundColor };"
        }
    },
    {
        "repo": "mime-db",
        "content": "'mime-db/scripts/lib/write-db.js'\n:/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2022 Douglas Christopher Wilson\n * MIT Licensed\n */\n\nvar fs = require('fs')\n\nmodule.exports = function writeDatabaseSync (fileName, obj) {\n  var fd = fs.openSync(fileName, 'w')\n  var keys = Object.keys(obj).sort()\n\n  fs.writeSync(fd, '{\\n')\n\n  keys.forEach(function (key, i, arr) {\n    fs.writeSync(fd, '  ' + JSON.stringify(key) + ': {')\n\n    var end = endLine.apply(this, arguments)\n    var data = obj[key]\n    var keys = Object.keys(data).sort(sortDataKeys)\n\n    if (keys.length === 0) {\n      fs.writeSync(fd, '}' + end)\n      return\n    }\n\n    fs.writeSync(fd, '\\n')\n    keys.forEach(function (key, i, arr) {\n      var end = endLine.apply(this, arguments)\n      var val = data[key]\n\n      if (val !== undefined) {\n        var str = Array.isArray(val) && val.some(function (v) { return String(v).length > 15 })\n          ? JSON.stringify(val, null, 2).split('\\n').join('\\n    ')\n          : JSON.stringify(val)\n\n        fs.writeSync(fd, '    ' + JSON.stringify(key) + ': ' + str + end)\n      }\n    })\n\n    fs.writeSync(fd, '  }' + end)\n  })\n\n  fs.writeSync(fd, '}\\n')\n\n  fs.closeSync(fd)\n}\n\nfunction endLine (key, i, arr) {\n  var comma = i + 1 === arr.length\n    ? ''\n    : ','\n  return comma + '\\n'\n}\n\nfunction sortDataKeys (a, b) {\n  var cmp = a.localeCompare(b)\n\n  return cmp && (a === 'source' || b === 'source')\n    ? (a === 'source' ? -1 : 1)\n    : cmp\n}\n\n'mime-db/scripts/fetch-iana.js'\n:/*!\n * mime-db\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2015-2023 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n/**\n * Convert the IANA definitions from CSV to local.\n */\n\nvar got = require('got')\nvar parser = require('csv-parse')\nvar toArray = require('stream-to-array')\nvar typer = require('media-typer')\nvar writedb = require('./lib/write-db')\n\nvar extensionsQuotedRegExp = /^\\s*(?:\\d\\.\\s+)?File extension(?:\\(s\\)|s|)\\s?:(?:[^'\"\\r\\n]+)(?:\"\\.?([0-9a-z_-]+)\"|'\\.?([0-9a-z_-]+)')/im\nvar leadingSpacesRegExp = /^\\s+/\nvar listColonRegExp = /:(?:\\s|$)/m\nvar nameWithNotesRegExp = /^(\\S+)(?: - (.*)$| \\((.*)\\)$|)/\nvar mimeTypeLineRegExp = /^(?:\\s*|[^:\\s-]*\\s+)(?:MIME type(?: name)?|MIME media type(?: name)?|Media type(?: name)?|Type name)\\s?:\\s+(.*)$/im\nvar mimeSubtypesLineRegExp = /^[^:\\s-]*\\s*(?:MIME |Media )?subtype(?: names)?\\s?:\\s+(?:[a-z]+ Tree\\s+(?:- ?)?)?(.*)$/im\nvar rfcReferenceRegExp = /\\[(RFC[0-9]{4})]/gi\nvar slurpModeRegExp = /^\\s{0,3}(?:[1-4]\\. )?[a-z]{4,}(?: [a-z]{4,})+(?:s|\\(s\\))?\\s*:\\s*/i\nvar symbolRegExp = /[._-]/g\nvar trimQuotesRegExp = /^\"|\"$/gm\nvar urlReferenceRegExp = /\\[(https?:\\/\\/[^\\]]+)]/gi\n\nvar CHARSET_DEFAULT_REGEXP = /(?:\\bcharset\\b[^.]*(?:\\.\\s+default\\s+(?:value\\s+)?is|\\bdefault[^.]*(?:of|is)|\\bmust\\s+have\\s+the\\s+value|\\bvalue\\s+must\\s+be)\\s+|\\bcharset\\s*\\(?defaults\\s+to\\s+|\\bdefault\\b[^.]*?\\bchar(?:set|act[eo]r\\s+set)\\b[^.]*?(?:of|is)\\s+|\\bcharset\\s+(?:must|is)\\s+always\\s+(?:be\\s+)?)[\"']?([a-z0-9]+-[a-z0-9-]+)/im\nvar EXTENSIONS_REGEXP = /(?:^\\s*(?:\\d\\.\\s+)?|\\s+[23]\\.\\s+)[Ff]ile [Ee]xtension(?:\\(s\\)|s|)\\s?:\\s+(?:\\*\\.|\\.|)([0-9a-z_-]+|[0-9A-Z_-]+)(?:(?:\\s+(?:and|or)|\\s*,)\\s+(?:\\*\\.|\\.|)([0-9a-z_-]+|[0-9A-Z_-]+)\\s*)?(?:\\s*[34]\\.\\s+|\\s+[A-Z(]|\\s+(?:are(?:\\s+both)?)\\s+declared|\\s*$)/m\nvar INTENDED_USAGE_REGEXP = /^\\s*(?:(?:\\d{1,2}\\.|o)\\s+)?Intended\\s+Usage\\s*:\\s*([0-9a-z]+)/im\nvar MIME_SUBTYPE_LINE_REGEXP = /^[^:\\s-]*\\s*(?:MIME )?(?:[Mm]edia )?(?:[Ss]ub ?type|SUB ?TYPE)(?: (?:[Nn]ame|NAME))?\\s*:\\s+(?:[A-Za-z]+ [Tt]ree\\s+(?:- ?)?|(?:[a-z]+ )+- )?([0-9A-Za-z][0-9A-Za-z_.+-]*)(?:\\s|$)/m\nvar MIME_TYPE_HAS_CHARSET_PARAMETER_REGEXP = /parameters\\s*:[^.]*\\bcharset\\b/im\n\n;(async function () {\n  const results = Array.prototype.concat.apply([], [\n    await get('application', { extensions: /(?:\\/(?:automationml-amlx?\\+.+|cwl|ecmascript|express|fdf|gzip|(?:ld|manifest)\\+json|mp4|n-quads|n-triples|pgp-.+|sql|trig|vnd\\.(?:age|apple\\..+|dbf|mapbox-vector-tile|rar))|xfdf|\\+xml)$/ }),\n    await get('audio', { extensions: /\\/(?:aac|mobile-xmf)$/ }),\n    await get('font', { extensions: true }),\n    await get('image', { extensions: true }),\n    await get('message', { extensions: true }),\n    await get('model', { extensions: true }),\n    await get('multipart'),\n    await get('text', { extensions: /\\/(?:javascript|markdown|spdx|turtle|vnd\\.familysearch\\.gedcom|vtt|wgsl)$/ }),\n    await get('video', { extensions: /\\/iso\\.segment$/ })\n  ])\n\n  // gather extension frequency\n  var exts = Object.create(null)\n  results.forEach(function (result) {\n    (result.extensions || []).forEach(function (ext) {\n      exts[ext] = (exts[ext] || 0) + 1\n    })\n  })\n\n  // construct json map\n  var json = Object.create(null)\n  results.forEach(function (result) {\n    var mime = result.mime\n\n    if (mime in json) {\n      throw new Error('duplicate entry for ' + mime)\n    }\n\n    // skip obsoleted mimes\n    if (result.usage === 'obsolete') {\n      return\n    }\n\n    json[mime] = {\n      charset: result.charset,\n      notes: result.notes,\n      sources: result.sources\n    }\n\n    // keep unambigious extensions\n    var extensions = (result.extensions || []).filter(function (ext) {\n      return exts[ext] === 1 || typer.parse(mime).subtype === ext\n    })\n\n    if (extensions.length !== 0) {\n      json[mime].extensions = extensions\n    }\n  })\n\n  writedb('src/iana-types.json', json)\n}())\n\nasync function addTemplateData (data, options) {\n  var opts = options || {}\n\n  if (!data.template) {\n    return\n  }\n\n  let res = await got('https://www.iana.org/assignments/media-types/' + data.template)\n  var ref = data.type + '/' + data.name\n  var rfc = getRfcReferences(data.reference)[0]\n\n  if (res.statusCode === 404 && data.template !== ref) {\n    console.log('template ' + data.template + ' not found, retry as ' + ref)\n    data.template = ref\n    res = await got('https://www.iana.org/assignments/media-types/' + ref)\n\n    // replace the guessed mime\n    if (res.statusCode === 200) {\n      data.mime = data.template\n    }\n  }\n\n  if (res.statusCode === 404 && rfc !== undefined) {\n    console.log('template ' + data.template + ' not found, fetch ' + rfc)\n    res = await got('https://tools.ietf.org/rfc/' + rfc.toLowerCase() + '.txt')\n  }\n\n  if (res.statusCode === 404) {\n    console.log('template ' + data.template + ' not found')\n    return\n  }\n\n  if (res.statusCode !== 200) {\n    throw new Error('got status code ' + res.statusCode + ' from template ' + data.template)\n  }\n\n  var body = getTemplateBody(res.body)\n  var mime = extractTemplateMime(body)\n\n  // add the template as a source\n  addSource(data, res.url)\n\n  if (mimeEql(mime, data.mime)) {\n    // use extracted mime\n    data.mime = mime\n\n    // use extracted charset\n    data.charset = extractTemplateCharset(body)\n\n    // use extracted usage\n    data.usage = extractIntendedUsage(body)\n\n    // use extracted extensions\n    if (data.usage === 'common' && opts.extensions &&\n      (opts.extensions === true || opts.extensions.test(data.mime))) {\n      data.extensions = extractTemplateExtensions(body)\n    }\n  }\n}\n\nfunction extractIntendedUsage (body) {\n  var match = INTENDED_USAGE_REGEXP.exec(body)\n\n  return match\n    ? match[1].toLocaleLowerCase()\n    : undefined\n}\n\nfunction extractTemplateMime (body) {\n  var type = mimeTypeLineRegExp.exec(body)\n  var subtype = MIME_SUBTYPE_LINE_REGEXP.exec(body)\n\n  if (!subtype && (subtype = mimeSubtypesLineRegExp.exec(body)) && !/^[A-Za-z0-9.+-]+$/.test(subtype[1])) {\n    return\n  }\n\n  if (!type || !subtype) {\n    return\n  }\n\n  type = type[1].trim().replace(trimQuotesRegExp, '')\n  subtype = subtype[1].trim().replace(trimQuotesRegExp, '')\n\n  if (!subtype) {\n    return\n  }\n\n  if (subtype.slice(0, type.length + 1) === type + '/') {\n    // strip type from subtype\n    subtype = subtype.slice(type.length + 1)\n  }\n\n  return (type + '/' + subtype).toLowerCase()\n}\n\nfunction extractTemplateCharset (body) {\n  if (!MIME_TYPE_HAS_CHARSET_PARAMETER_REGEXP.test(body)) {\n    return undefined\n  }\n\n  var match = CHARSET_DEFAULT_REGEXP.exec(body)\n\n  return match\n    ? match[1].toUpperCase()\n    : undefined\n}\n\nfunction extractTemplateExtensions (body) {\n  var match = EXTENSIONS_REGEXP.exec(body) || extensionsQuotedRegExp.exec(body)\n\n  if (!match) {\n    return\n  }\n\n  var exts = match\n    .slice(1)\n    .filter(Boolean)\n    .map(function (ext) { return ext.toLowerCase() })\n    .filter(function (ext) { return ext !== 'none' })\n\n  return exts.length === 0\n    ? undefined\n    : exts\n}\n\nasync function get (type, options) {\n  const res = await got('https://www.iana.org/assignments/media-types/' + encodeURIComponent(type) + '.csv')\n\n  if (res.statusCode !== 200) {\n    throw new Error('got status code ' + res.statusCode + ' from ' + type)\n  }\n\n  const mimes = await toArray(parser(res.body))\n  var headers = mimes.shift().map(normalizeHeader)\n  var reduceRows = generateRowMapper(headers)\n  const results = []\n  var templates = Object.create(null)\n\n  for (const row of mimes) {\n    var data = row.reduce(reduceRows, { type: type })\n\n    if (data.template) {\n      if (data.template === type + '/example') {\n        continue\n      }\n\n      if (templates[data.template]) {\n        // duplicate entry\n        continue\n      }\n\n      templates[data.template] = true\n    }\n\n    // guess mime type\n    data.mime = (data.template || (type + '/' + data.name)).toLowerCase()\n\n    // extract notes from name\n    var nameMatch = nameWithNotesRegExp.exec(data.name)\n    data.name = nameMatch[1]\n    data.notes = nameMatch[2] || nameMatch[3]\n\n    // add reference sources\n    parseReferences(data.reference).forEach(function (url) {\n      addSource(data, url)\n    })\n\n    await addTemplateData(data, options)\n\n    results.push(data)\n  }\n\n  return results\n}\n\nfunction getTemplateBody (body) {\n  var lines = body.split(/\\r?\\n/)\n  var slurp = false\n\n  return lines.reduce(function (lines, line) {\n    line = line.replace(/=20$/, ' ')\n\n    var prev = (lines[lines.length - 1] || '')\n    var match = leadingSpacesRegExp.exec(line)\n\n    if (slurp && line.trim().length === 0 && !/:\\s*$/.test(prev)) {\n      slurp = false\n      return lines\n    }\n\n    if (slurpModeRegExp.test(line)) {\n      slurp = false\n      lines.push(line)\n    } else if (slurp) {\n      lines[lines.length - 1] = appendToLine(prev, line)\n    } else if (match && match[0].length >= 3 && match[0].trim() !== 0 && prev.trim().length !== 0 && !listColonRegExp.test(line)) {\n      lines[lines.length - 1] = appendToLine(prev, line)\n    } else {\n      lines.push(line)\n    }\n\n    // turn on slurp mode\n    slurp = slurp || slurpModeRegExp.test(line)\n\n    return lines\n  }, []).join('\\n')\n}\n\nfunction addSource (data, url) {\n  var sources = data.sources || (data.sources = [])\n\n  if (sources.indexOf(url) === -1) {\n    sources.push(url)\n  }\n}\n\nfunction appendToLine (line, str) {\n  var trimmed = line.trimRight()\n  var append = trimmed.slice(-1) === '-'\n    ? str.trimLeft()\n    : ' ' + str.trimLeft()\n  return trimmed + append\n}\n\nfunction generateRowMapper (headers) {\n  return function reduceRows (obj, val, index) {\n    if (val !== '') {\n      obj[headers[index]] = val\n    }\n\n    return obj\n  }\n}\n\nfunction getRfcReferences (reference) {\n  var match = null\n  var rfcs = []\n\n  rfcReferenceRegExp.index = 0\n\n  while ((match = rfcReferenceRegExp.exec(reference))) {\n    rfcs.push(match[1].toUpperCase())\n  }\n\n  return rfcs\n}\n\nfunction getUrlReferences (reference) {\n  var match = null\n  var urls = []\n\n  urlReferenceRegExp.index = 0\n\n  while ((match = urlReferenceRegExp.exec(reference))) {\n    urls.push(match[1])\n  }\n\n  return urls\n}\n\nfunction mimeEql (mime1, mime2) {\n  return mime1 && mime2 &&\n    mime1.replace(symbolRegExp, '-') === mime2.replace(symbolRegExp, '-')\n}\n\nfunction normalizeHeader (val) {\n  return val.slice(0, 1).toLowerCase() + val.slice(1).replace(/ (.)/, function (s, c) {\n    return c.toUpperCase()\n  })\n}\n\nfunction parseReferences (reference) {\n  return getUrlReferences(reference).concat(getRfcReferences(reference).map(function (rfc) {\n    return 'https://tools.ietf.org/rfc/' + rfc.toLowerCase() + '.txt'\n  }))\n}\n\n",
        "called_code_segment": "function writeDatabaseSync (fileName, obj) {\n  var fd = fs.openSync(fileName, 'w')\n  var keys = Object.keys(obj).sort()\n\n  fs.writeSync(fd, '{\\n')\n\n  keys.forEach(function (key, i, arr) {\n    fs.writeSync(fd, '  ' + JSON.stringify(key) + ': {')\n\n    var end = endLine.apply(this, arguments)\n    var data = obj[key]\n    var keys = Object.keys(data).sort(sortDataKeys)\n\n    if (keys.length === 0) {\n      fs.writeSync(fd, '}' + end)\n      return\n    }\n\n    fs.writeSync(fd, '\\n')\n    keys.forEach(function (key, i, arr) {\n      var end = endLine.apply(this, arguments)\n      var val = data[key]\n\n      if (val !== undefined) {\n        var str = Array.isArray(val) && val.some(function (v) { return String(v).length > 15 }) ? JSON.stringify(val, null, 2).split('\\n').join('\\n    ') : JSON.stringify(val)\n\n        fs.writeSync(fd, '    ' + JSON.stringify(key) + ': ' + str + end)\n      }\n    })\n\n    fs.writeSync(fd, '  }' + end)\n  })\n\n  fs.writeSync(fd, '}\\n')\n\n  fs.closeSync(fd)\n}",
        "invoking_code_segment": "writedb('src/iana-types.json', json)",
        "new_file_code_segment": "function logDatabaseWrite (fileName, obj) {\n  console.log('Writing database to ' + fileName)\n  console.log('Database content:', JSON.stringify(obj, null, 2))\n}",
        "feature_description": "Add logging for database write operations.",
        "detailed_feature_description": "The new feature introduces logging for database write operations. This will help in debugging and monitoring the database write process. The logging function is implemented in a new file (#file 3) and is invoked from #file 1 before the actual write operation. This ensures that the logging is done consistently and does not interfere with the existing functionality in #file 1 and #file 2.",
        "modified_complete_code": {
            "#file 1": "function writeDatabaseSync (fileName, obj) {\n  #Modify logDatabaseWrite(fileName, obj)\n  var fd = fs.openSync(fileName, 'w')\n  var keys = Object.keys(obj).sort()\n\n  fs.writeSync(fd, '{\\n')\n\n  keys.forEach(function (key, i, arr) {\n    fs.writeSync(fd, '  ' + JSON.stringify(key) + ': {')\n\n    var end = endLine.apply(this, arguments)\n    var data = obj[key]\n    var keys = Object.keys(data).sort(sortDataKeys)\n\n    if (keys.length === 0) {\n      fs.writeSync(fd, '}' + end)\n      return\n    }\n\n    fs.writeSync(fd, '\\n')\n    keys.forEach(function (key, i, arr) {\n      var end = endLine.apply(this, arguments)\n      var val = data[key]\n\n      if (val !== undefined) {\n        var str = Array.isArray(val) && val.some(function (v) { return String(v).length > 15 }) ? JSON.stringify(val, null, 2).split('\\n').join('\\n    ') : JSON.stringify(val)\n\n        fs.writeSync(fd, '    ' + JSON.stringify(key) + ': ' + str + end)\n      }\n    })\n\n    fs.writeSync(fd, '  }' + end)\n  })\n\n  fs.writeSync(fd, '}\\n')\n\n  fs.closeSync(fd)\n}",
            "#file 2": "writedb('src/iana-types.json', json)",
            "#file 3": "#New function logDatabaseWrite (fileName, obj) {\n  console.log('Writing database to ' + fileName)\n  console.log('Database content:', JSON.stringify(obj, null, 2))\n}"
        }
    },
    {
        "repo": "mongodb-express-rest-api-example",
        "content": "'mongodb-express-rest-api-example/app/src/components/PostSummary.js'\n:import React from \"react\";\nimport Card from \"@leafygreen-ui/card\";\nimport { css } from \"@leafygreen-ui/emotion\";\nimport { H3 } from \"@leafygreen-ui/typography\";\nimport Badge from \"@leafygreen-ui/badge\";\nimport { Link } from \"react-router-dom\";\n\nconst cardStyle = css`\n  margin: 1em;\n`\nconst badgeColors = [\"lightgray\", \"darkgray\", \"red\", \"blue\", \"green\", \"yellow\"];\nconst getBadgeColor = tag => {\n  let tagId = tag.split(\"\").map(char => char.charCodeAt(0)).reduce((s,a) => s + a, 0) % 6;\n  return badgeColors[tagId];\n}\n\nexport default function PostSummary(props) {\n  return (\n    <Card className={cardStyle}>\n      <H3>{props.title}</H3>\n      by {props.author} on {(new Date(props.date)).toLocaleDateString()}<br/>\n      <Link to={`/post/${props._id}`}>Read More...</Link><br/>\n      {props && props.tags && props.tags.map(tag => (<React.Fragment><Badge variant={getBadgeColor(tag)}>{tag}</Badge> </React.Fragment>))}\n    </Card>\n  )\n}\n'mongodb-express-rest-api-example/app/src/pages/Archive.js'\n:import React, {useState, useEffect} from \"react\";\nimport { H2 } from \"@leafygreen-ui/typography\";\nimport PostSummary from \"../components/PostSummary\";\nimport { baseUrl } from \"../config\";\n\nexport default function App() {\n\n  let [posts, setPosts] = useState([]);\n\n  useEffect(() => {\n    const loadPosts = async () => {\n      let results = await fetch(`${baseUrl}/posts/`).then(resp => resp.json());\n      setPosts(results);\n    }\n\n    loadPosts();\n  }, []);\n\n  return (\n    <React.Fragment>\n      <H2>All Articles</H2>\n      <div>\n        {posts.map(post => {\n          return(\n            <PostSummary {...post} key={post._id} />\n          )\n        })}\n      </div>\n    </React.Fragment>\n  )\n}\n",
        "called_code_segment": "export default function PostSummary(props) {\n  return (\n    <Card className={cardStyle}>\n      <H3>{props.title}</H3>\n      by {props.author} on {(new Date(props.date)).toLocaleDateString()}<br/>\n      <Link to={`/post/${props._id}`}>Read More...</Link><br/>\n      {props && props.tags && props.tags.map(tag => (<React.Fragment><Badge variant={getBadgeColor(tag)}>{tag}</Badge> </React.Fragment>))}\n    </Card>\n  )\n}",
        "invoking_code_segment": "let [posts, setPosts] = useState([]);\n\nuseEffect(() => {\n  const loadPosts = async () => {\n    let results = await fetch(`${baseUrl}/posts/`).then(resp => resp.json());\n    setPosts(results);\n  }\n\n  loadPosts();\n}, []);\n\nreturn (\n  <React.Fragment>\n    <H2>All Articles</H2>\n    <div>\n      {posts.map(post => {\n        return(\n          <PostSummary {...post} key={post._id} />\n        )\n      })}\n    </div>\n  </React.Fragment>\n)",
        "new_file_code_segment": "export const getPostSummary = (post) => {\n  return {\n    title: post.title,\n    author: post.author,\n    date: post.date,\n    _id: post._id,\n    tags: post.tags\n  };\n}",
        "feature_description": "Add a utility function to extract summary data from a post object.",
        "detailed_feature_description": "The new feature introduces a utility function in a new file (#file 3) that extracts summary data from a post object. This function is then used in #file 1 to simplify the creation of the PostSummary component. The #file 2 is updated to use this utility function when mapping over the posts array.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport { getPostSummary } from './utils';\n\nexport default function PostSummary(props) {\n  const summary = getPostSummary(props);\n  return (\n    <Card className={cardStyle}>\n      <H3>{summary.title}</H3>\n      by {summary.author} on {(new Date(summary.date)).toLocaleDateString()}<br/>\n      <Link to={`/post/${summary._id}`}>Read More...</Link><br/>\n      {summary.tags && summary.tags.map(tag => (<React.Fragment><Badge variant={getBadgeColor(tag)}>{tag}</Badge> </React.Fragment>))}\n    </Card>\n  )\n}",
            "#file 2": "//Modify\nimport { getPostSummary } from '../utils';\n\nlet [posts, setPosts] = useState([]);\n\nuseEffect(() => {\n  const loadPosts = async () => {\n    let results = await fetch(`${baseUrl}/posts/`).then(resp => resp.json());\n    setPosts(results);\n  }\n\n  loadPosts();\n}, []);\n\nreturn (\n  <React.Fragment>\n    <H2>All Articles</H2>\n    <div>\n      {posts.map(post => {\n        return(\n          <PostSummary {...getPostSummary(post)} key={post._id} />\n        )\n      })}\n    </div>\n  </React.Fragment>\n)",
            "#file 3": "//New\nexport const getPostSummary = (post) => {\n  return {\n    title: post.title,\n    author: post.author,\n    date: post.date,\n    _id: post._id,\n    tags: post.tags\n  };\n}"
        }
    },
    {
        "repo": "ms-Dropdown",
        "content": "'ms-Dropdown/src/js/lib/dd-webcomponent.js'\n:import MsDropdown from \"./dd\";\n\nclass dd extends HTMLSelectElement {\n\n    constructor(element, settings) {\n        super();\n    }\n\n\n    connectedCallback() {\n        setTimeout(()=> {\n            if(!this.msDropdown) {\n                this.msDropdown = new MsDropdown(this);\n            }\n            try {\n                this.addEventListener(\"change\", (evt)=> {if(!this.multiple) {\n                    this.msDropdown.selectedIndex = this.selectedIndex;\n                } else {\n                    this.msDropdown.refresh();\n                }\n                });\n\n            } catch (e) {\n                console.log(e.message);\n            }\n        },1);\n    }\n\n    disconnectedCallback() {\n       // console.log('disconnectedCallback');\n    }\n\n    adoptedCallback() {\n        //console.log('adoptedCallback', this);\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        if(this.msDropdown) {\n            if(name.indexOf(\"data-\") !== -1) {\n                name = name.replace(\"data-\", \"\");\n                let nameStr = name.toLowerCase().split('-');\n                for (let i = 1; i < nameStr.length; i++) {\n                    nameStr[i] = nameStr[i].charAt(0).toUpperCase() + nameStr[i].substring(1);\n                }\n                this.msDropdown.setSettingAttribute(nameStr.join(\"\"), newValue, true); //update settings and refresh\n            } else {\n                //this.msDropdown[name] = newValue;\n            }\n\n        }\n        console.log('attributeChangedCallback');\n\n    }\n\n    static get observedAttributes() { return [\n        'data-main-css',\n        'data-show-icon',\n        'data-event',\n        'data-child-width',\n        'data-child-height',\n        'data-enable-checkbox',\n        'data-checkbox-name-suffix',\n        'data-enable-auto-filter',\n        'data-visible-rows',\n        'data-show-plus-item-counter',\n        'data-error-message',\n        'data-show-filter-always',\n        'data-show-list-counter',\n        'data-image-position'\n    ];\n    }\n\n}\n\ncustomElements.define('ms-dropdown', dd, {extends:'select'});\n'ms-Dropdown/src/js/index.js'\n:import WebComponent from \"./lib/dd-webcomponent\";\nimport MsDropdown from './lib/dd';\nwindow.MsDropdown = MsDropdown;\n\n\n(function () {\n    let isSafari = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;\n    if(isSafari) {\n        MsDropdown.make(\"select[is='ms-dropdown']\");\n        /**\n         * Not a good idea to override this\n         * but if you want to use document.createElement(\"select\"); this can be enable for safari.\n         * how to use:\n         * var select = document.createElement(\"select\", {is:'ms-dropdown'});\n         * select.setAttribute(\"is\", \"ms-dropdown\");\n         * select.options[0] = new Option(\"Hashtag CMS\", \"https://www.hashtagcms.org\"); // add an option\n         * select.options[1] = new Option(\"My Website\", \"https://www.marghoobsuleman.com\"); // add an option\n         * document.body.appendChild(select);\n         */\n\n        /*\n        window.addEventListener(\"load\", ()=> {\n            let OriginalAppendChild = Element.prototype.appendChild;\n            Element.prototype.appendChild = function() {\n                OriginalAppendChild.apply(this, arguments);\n                let select = arguments[0];\n                if(select.nodeName === \"SELECT\" && select.getAttribute(\"is\") === \"ms-dropdown\") {\n                    select.msDropdown = new MsDropdown(select);\n                }\n            };\n\n        })\n         */\n\n    }\n})();\n\n",
        "called_code_segment": "class dd extends HTMLSelectElement {\n    constructor(element, settings) {\n        super();\n    }\n\n    connectedCallback() {\n        setTimeout(()=> {\n            if(!this.msDropdown) {\n                this.msDropdown = new MsDropdown(this);\n            }\n            try {\n                this.addEventListener(\"change\", (evt)=> {\n                    if(!this.multiple) {\n                        this.msDropdown.selectedIndex = this.selectedIndex;\n                    } else {\n                        this.msDropdown.refresh();\n                    }\n                });\n            } catch (e) {\n                console.log(e.message);\n            }\n        },1);\n    }\n\n    disconnectedCallback() {\n        // console.log('disconnectedCallback');\n    }\n\n    adoptedCallback() {\n        // console.log('adoptedCallback', this);\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        if(this.msDropdown) {\n            if(name.indexOf(\"data-\") !== -1) {\n                name = name.replace(\"data-\", \"\");\n                let nameStr = name.toLowerCase().split('-');\n                for (let i = 1; i < nameStr.length; i++) {\n                    nameStr[i] = nameStr[i].charAt(0).toUpperCase() + nameStr[i].substring(1);\n                }\n                this.msDropdown.setSettingAttribute(nameStr.join(\"\"), newValue, true); //update settings and refresh\n            } else {\n                //this.msDropdown[name] = newValue;\n            }\n        }\n        console.log('attributeChangedCallback');\n    }\n\n    static get observedAttributes() {\n        return [\n            'data-main-css',\n            'data-show-icon',\n            'data-event',\n            'data-child-width',\n            'data-child-height',\n            'data-enable-checkbox',\n            'data-checkbox-name-suffix',\n            'data-enable-auto-filter',\n            'data-visible-rows',\n            'data-show-plus-item-counter',\n            'data-error-message',\n            'data-show-filter-always',\n            'data-show-list-counter',\n            'data-image-position'\n        ];\n    }\n}\n\ncustomElements.define('ms-dropdown', dd, {extends:'select'});",
        "invoking_code_segment": "(function () {\n    let isSafari = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;\n    if(isSafari) {\n        MsDropdown.make(\"select[is='ms-dropdown']\");\n    }\n})();",
        "new_file_code_segment": "export function initializeDropdown(element) {\n    if(!element.msDropdown) {\n        element.msDropdown = new MsDropdown(element);\n    }\n    element.addEventListener(\"change\", (evt)=> {\n        if(!element.multiple) {\n            element.msDropdown.selectedIndex = element.selectedIndex;\n        } else {\n            element.msDropdown.refresh();\n        }\n    });\n}\n\nexport function updateDropdownSettings(element, name, newValue) {\n    if(element.msDropdown) {\n        if(name.indexOf(\"data-\") !== -1) {\n            name = name.replace(\"data-\", \"\");\n            let nameStr = name.toLowerCase().split('-');\n            for (let i = 1; i < nameStr.length; i++) {\n                nameStr[i] = nameStr[i].charAt(0).toUpperCase() + nameStr[i].substring(1);\n            }\n            element.msDropdown.setSettingAttribute(nameStr.join(\"\"), newValue, true); //update settings and refresh\n        }\n    }\n}",
        "feature_description": "Add a new feature to initialize and update dropdown settings using a separate utility function.",
        "detailed_feature_description": "The new feature introduces a utility function to initialize and update dropdown settings. This is implemented in a new file (#file 3) and is invoked from #file 1 and #file 2. The utility function ensures that the dropdown is initialized correctly and settings are updated dynamically. This approach enhances modularity and reusability of the code.",
        "modified_complete_code": {
            "#file 1": "//Modify class dd extends HTMLSelectElement {\n    constructor(element, settings) {\n        super();\n    }\n\n    connectedCallback() {\n        setTimeout(()=> {\n            initializeDropdown(this);\n        },1);\n    }\n\n    disconnectedCallback() {\n        // console.log('disconnectedCallback');\n    }\n\n    adoptedCallback() {\n        // console.log('adoptedCallback', this);\n    }\n\n    attributeChangedCallback(name, oldValue, newValue) {\n        updateDropdownSettings(this, name, newValue);\n        console.log('attributeChangedCallback');\n    }\n\n    static get observedAttributes() {\n        return [\n            'data-main-css',\n            'data-show-icon',\n            'data-event',\n            'data-child-width',\n            'data-child-height',\n            'data-enable-checkbox',\n            'data-checkbox-name-suffix',\n            'data-enable-auto-filter',\n            'data-visible-rows',\n            'data-show-plus-item-counter',\n            'data-error-message',\n            'data-show-filter-always',\n            'data-show-list-counter',\n            'data-image-position'\n        ];\n    }\n}\n\ncustomElements.define('ms-dropdown', dd, {extends:'select'});",
            "#file 2": "//Modify (function () {\n    let isSafari = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;\n    if(isSafari) {\n        MsDropdown.make(\"select[is='ms-dropdown']\").forEach(element => initializeDropdown(element));\n    }\n})();",
            "#file 3": "//New export function initializeDropdown(element) {\n    if(!element.msDropdown) {\n        element.msDropdown = new MsDropdown(element);\n    }\n    element.addEventListener(\"change\", (evt)=> {\n        if(!element.multiple) {\n            element.msDropdown.selectedIndex = element.selectedIndex;\n        } else {\n            element.msDropdown.refresh();\n        }\n    });\n}\n\nexport function updateDropdownSettings(element, name, newValue) {\n    if(element.msDropdown) {\n        if(name.indexOf(\"data-\") !== -1) {\n            name = name.replace(\"data-\", \"\");\n            let nameStr = name.toLowerCase().split('-');\n            for (let i = 1; i < nameStr.length; i++) {\n                nameStr[i] = nameStr[i].charAt(0).toUpperCase() + nameStr[i].substring(1);\n            }\n            element.msDropdown.setSettingAttribute(nameStr.join(\"\"), newValue, true); //update settings and refresh\n        }\n    }\n}"
        }
    },
    {
        "repo": "nightwatch-cucumber",
        "content": "'nightwatch-cucumber/lib/runner.js'\n:const fs = require('fs')\nconst path = require('path')\nconst tmp = require('tmp')\nconst glob = require('glob')\nconst mkdirp = require('mkdirp')\nconst pify = require('pify')\nconst dummyTestModulesFolder = tmp.dirSync({ unsafeCleanup: true }).name\nconst NightwatchApi = require('./nightwatch-api')\nconst CucumberApi = require('./cucumber-api')\n\ntmp.setGracefulCleanup()\n\nmodule.exports = class Runner {\n  constructor () {\n    this.originalFeaturePath = {}\n  }\n\n  getSourceFile (featureSource) {\n    if (featureSource.startsWith('@')) {\n      return featureSource.substr(1, featureSource.length - 1)\n    }\n    return featureSource\n  }\n\n  getFeatureFilesFromRerunFile (rerunFile) {\n    const data = fs.readFileSync(this.getSourceFile(rerunFile))\n    return data.toString()\n      .split('\\n')\n      .map(featurePath => featurePath.trim().replace(/(:\\d*)/g, ''))\n      // filter empty paths\n      .filter(featurePath => featurePath)\n  }\n\n  getFeatureDirectories () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n            .map(featurePath => path.dirname(featurePath))\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return featureSource\n        }\n        return path.dirname(featureSource)\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n  }\n\n  getFeatureFiles () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return glob.sync(path.join(featureSource, '**/*.feature'))\n        }\n        return [featureSource]\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n      // make unique list\n      .filter((featureFilePath, idx, paths) => paths.indexOf(featureFilePath === idx))\n  }\n\n  generateDummyTestModules () {\n    this.getFeatureFiles().forEach((featureFile) => {\n      const dummyTestModuleFile = this.featurePathToDummyPath(featureFile)\n      mkdirp.sync(path.dirname(dummyTestModuleFile))\n      fs.writeFileSync(dummyTestModuleFile, '')\n    })\n  }\n\n  getTags (tags) {\n    tags = tags || []\n\n    if (typeof tags === 'string') {\n      tags = tags.split(',')\n    }\n\n    if (Array.isArray(tags)) {\n      return tags.map((tag) => `@${tag}`)\n    } else {\n      throw new Error(`Expected tags to be Array or String.`)\n    }\n  }\n\n  featurePathToDummyPath (featureFile) {\n    const lineNumberMatch = featureFile.match(/:(\\d+)$/)\n    let lineNumber\n    if (lineNumberMatch) {\n      lineNumber = parseInt(lineNumberMatch[1])\n      featureFile = featureFile.replace(/:\\d+$/, '')\n    }\n    try {\n      fs.statSync(featureFile)\n    } catch (err) {\n      if (!featureFile.match(/\\.feature$/)) featureFile += '.feature'\n      try {\n        fs.statSync(featureFile)\n      } catch (err) {\n        throw new Error(`Feature file or folder ${featureFile} was not found!`)\n      }\n    }\n\n    const dummyPath = path.join(dummyTestModulesFolder, featureFile.replace(/\\.feature$/, '.js'))\n\n    this.originalFeaturePath[dummyPath] = lineNumber ? `${featureFile}:${lineNumber}` : featureFile\n\n    return dummyPath\n  }\n\n  dummyPathToFeaturePath (dummyPath) {\n    if (!dummyPath.match(/\\.js$/)) dummyPath += '.js'\n\n    return this.originalFeaturePath[dummyPath] || dummyPath\n  }\n\n  addIndexToFileName (fileName, index) {\n    const cutIndex = fileName.lastIndexOf('.')\n    const ext = fileName.slice(cutIndex)\n    const rest = fileName.slice(0, cutIndex)\n    return `${rest}-${index}${ext}`\n  }\n\n  * executeTestModules (dummyTestModules) {\n    const featureFiles = dummyTestModules.map((dummyTestModule) => this.dummyPathToFeaturePath(dummyTestModule))\n\n    if (this.nightwatchApi.isRunningInParallel()) {\n      const workerIndex = this.nightwatchApi.getWorkerIndex()\n      this.jsonReport = this.addIndexToFileName(this.jsonReport, workerIndex)\n    }\n\n    if (this.jsonReport) {\n      yield pify(mkdirp)(path.dirname(this.jsonReport))\n    }\n    const cucumberArgs = this.cucumberApi.getAdjustedArgs({\n      args: this.options.cucumberArgs,\n      featureFiles,\n      jsonReport: this.jsonReport,\n      tags: this.getTags(this.nightwatchApi.nightwatchArgv.tag),\n      skipTags: this.getTags(this.nightwatchApi.nightwatchArgv.skiptags)\n    })\n    return yield * this.cucumberApi.run(cucumberArgs)\n  }\n\n  areColorsEnabled () {\n    const formatOptionsIndex = this.options.cucumberArgs.indexOf('--format-options')\n    if (formatOptionsIndex < 0) return true\n    const formatOptions = JSON.parse(this.options.cucumberArgs[formatOptionsIndex + 1])\n    return typeof formatOptions.colorsEnabled === 'undefined' ? true : formatOptions.colorsEnabled\n  }\n\n  run (options) {\n    const self = this\n    this.options = options\n    this.nightwatchApi = new NightwatchApi(options, this.areColorsEnabled())\n    this.cucumberApi = new CucumberApi(options)\n    this.jsonReport = this.cucumberApi.getJSONReportName(options.cucumberArgs)\n    this.featureFiles = this.cucumberApi.getFeatureFiles(options.cucumberArgs)\n    this.featureFiles\n      .map(this.getSourceFile)\n      .forEach((featureSource) => {\n        try {\n          fs.statSync(featureSource)\n        } catch (err) {\n          throw new Error(`Feature source ${featureSource} doesn't exists`)\n        }\n      })\n\n    // enforce relative paths so path.join() works on Windows\n    this.featureFiles = this.featureFiles.map((currentPath) => {\n      return path.isAbsolute(currentPath) ? path.relative(process.cwd(), currentPath) : currentPath\n    })\n\n    const dummyPaths = this.getFeatureDirectories().map(srcPath => path.join(dummyTestModulesFolder, srcPath))\n\n    this.generateDummyTestModules()\n\n    this.cucumberApi.injectTimeoutHandler()\n    this.cucumberApi.addAttachmentProvider(this.nightwatchApi.takeScreenshot.bind(this.nightwatchApi))\n\n    this.nightwatchApi.addTestModulePaths(dummyPaths)\n    this.nightwatchApi.addPathConverter(this.featurePathToDummyPath.bind(this), this.dummyPathToFeaturePath.bind(this))\n    this.nightwatchApi.overrideOriginalStartTestWorkers()\n    this.nightwatchApi.addTestRunner(this.executeTestModules.bind(this))\n    this.nightwatchApi.addHookAfterChildProcesses(function * () {\n      const reports = yield pify(glob)(self.addIndexToFileName(self.jsonReport, '*'))\n      yield * self.cucumberApi.mergeCucumberJsonReports(reports, self.jsonReport)\n    })\n  }\n}\n\n'nightwatch-cucumber/lib/index.js'\n:let runner\n\nmodule.exports = function (providedOptions) {\n  const options = Object.assign({\n    cucumberArgs: [\n      '--require', 'features/step_definitions',\n      '--format', 'json:reports/cucumber.json',\n      'features'\n    ],\n    nightwatchOutput: true\n  }, providedOptions)\n\n  const Runner = require('./runner')\n  runner = new Runner()\n  runner.run(options)\n}\n\nfunction getPageProxy (subPages) {\n  return new Proxy(() => getClientProxy(subPages), {\n    get: (target, pageName) => getPageProxy(subPages.concat([pageName]))\n  })\n}\n\nfunction getClientProxy (subPages) {\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (name !== 'page') {\n        const api = runner.nightwatchApi.getClientApi()\n\n        if (!subPages.length) {\n          return api[name]\n        }\n\n        return subPages.reduce((api, pageName) => {\n          return api[pageName]\n        }, api.page)()[name]\n      }\n\n      return getPageProxy([])\n    }\n  })\n}\n\nmodule.exports.client = getClientProxy([])\n\nmodule.exports.Section = new Proxy(function () {}, {\n  construct (target, args) {\n    return new runner.nightwatchApi.Section(...args)\n  }\n})\n\n",
        "called_code_segment": "this.nightwatchApi.addTestModulePaths(dummyPaths);",
        "invoking_code_segment": "this.nightwatchApi.addTestModulePaths(dummyPaths);",
        "new_file_code_segment": "function logTestModulePaths(paths) { console.log('Test module paths:', paths); }",
        "feature_description": "Add logging for test module paths to aid in debugging.",
        "detailed_feature_description": "The new feature involves adding logging for the test module paths. This will help in debugging by providing visibility into which paths are being added as test modules. The logging function will be implemented in a new file (#file 3) and invoked from both #file 1 and #file 2 where the test module paths are being added.",
        "modified_complete_code": {
            "#file 1": "// nightwatch-cucumber/lib/runner.js\n\nmodule.exports = class Runner {\n  // ...\n  run (options) {\n    // ...\n    const dummyPaths = this.getFeatureDirectories().map(srcPath => path.join(dummyTestModulesFolder, srcPath));\n    #Modify this.nightwatchApi.addTestModulePaths(dummyPaths);\n    #New logTestModulePaths(dummyPaths);\n    // ...\n  }\n}",
            "#file 2": "// nightwatch-cucumber/lib/index.js\n\nlet runner;\n\nmodule.exports = function (providedOptions) {\n  const options = Object.assign({\n    cucumberArgs: [\n      '--require', 'features/step_definitions',\n      '--format', 'json:reports/cucumber.json',\n      'features'\n    ],\n    nightwatchOutput: true\n  }, providedOptions);\n\n  const Runner = require('./runner');\n  runner = new Runner();\n  runner.run(options);\n}\n\nfunction getPageProxy (subPages) {\n  return new Proxy(() => getClientProxy(subPages), {\n    get: (target, pageName) => getPageProxy(subPages.concat([pageName]))\n  });\n}\n\nfunction getClientProxy (subPages) {\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (name !== 'page') {\n        const api = runner.nightwatchApi.getClientApi();\n\n        if (!subPages.length) {\n          return api[name];\n        }\n\n        return subPages.reduce((api, pageName) => {\n          return api[pageName];\n        }, api.page)()[name];\n      }\n\n      return getPageProxy([]);\n    }\n  });\n}\n\nmodule.exports.client = getClientProxy([]);\n\nmodule.exports.Section = new Proxy(function () {}, {\n  construct (target, args) {\n    return new runner.nightwatchApi.Section(...args);\n  }\n});\n\n#New function logTestModulePaths(paths) {\n  console.log('Test module paths:', paths);\n}",
            "#file 3": "// nightwatch-cucumber/lib/log-utils.js\n\n#New function logTestModulePaths(paths) {\n  console.log('Test module paths:', paths);\n}"
        }
    },
    {
        "repo": "nodebb-plugin-write-api",
        "content": "'nodebb-plugin-write-api/lib/errorHandler.js'\n:'use strict';\n\nvar translator = require.main.require('./src/translator');\nvar isLanguageKey = /^\\[\\[[\\w.,\\s\\-_:]+]]$/;\n\nvar ErrorHandler = {};\n\nErrorHandler.respond = function (status, res) {\n\tvar errorPayload = ErrorHandler.generate(status);\n\n\tres.status(status).json(errorPayload);\n\treturn true;\n};\n\nErrorHandler.handle = function (err, res, payload) {\n\tif (err) {\n\t\tif (isLanguageKey.test(err.message)) {\n\t\t\ttranslator.translate(err.message, 'en-GB', function (translated) {\n\t\t\t\tres.status(400).json(ErrorHandler.generate(400, undefined, translated));\n\t\t\t});\n\t\t} else {\n\t\t\tres.status(500).json(ErrorHandler.generate(500, undefined, err.message));\n\t\t}\n\t} else {\n\t\tres.status(200).json({\n\t\t\tcode: 'ok',\n\t\t\tpayload: payload || {},\n\t\t});\n\t}\n};\n\nErrorHandler.generate = function (status, code, message, params) {\n\t// All arguments are optional\n\tvar errorPayload = ErrorHandler.statusToCode(status);\n\n\terrorPayload.code = code || errorPayload.code;\n\terrorPayload.message = message ? (errorPayload.message + ' | ' + message) : errorPayload.message;\n\terrorPayload.params = { ...params, ...errorPayload.params };\n\n\treturn errorPayload;\n};\n\nErrorHandler.statusToCode = function (status) {\n\tvar payload = {\n\t\tcode: 'internal-server-error',\n\t\tmessage: 'An unexpected error was encountered while attempting to service your request.',\n\t\tparams: {},\n\t};\n\n\tswitch (status) {\n\tcase 400:\n\t\tpayload.code = 'bad-request';\n\t\tpayload.message = 'Something was wrong with the request payload you passed in.';\n\t\tbreak;\n\n\tcase 401:\n\t\tpayload.code = 'not-authorised';\n\t\tpayload.message = 'A valid login session was not found. Please log in and try again.';\n\t\tbreak;\n\n\tcase 403:\n\t\tpayload.code = 'forbidden';\n\t\tpayload.message = 'You are not authorised to make this call';\n\t\tbreak;\n\n\tcase 404:\n\t\tpayload.code = 'not-found';\n\t\tpayload.message = 'Invalid API call';\n\t\tbreak;\n\n\tcase 426:\n\t\tpayload.code = 'upgrade-required';\n\t\tpayload.message = 'HTTPS is required for requests to the write api, please re-send your request via HTTPS';\n\t\tbreak;\n\t}\n\n\treturn payload;\n};\n\nmodule.exports = ErrorHandler;\n\n'nodebb-plugin-write-api/routes/v1/groups.js'\n:'use strict';\n/* globals module, require */\n\nvar Groups = require.main.require('./src/groups'),\n\tMeta = require.main.require('./src/meta'),\n\tapiMiddleware = require('./middleware'),\n\terrorHandler = require('../../lib/errorHandler'),\n\tutils = require('./utils');\n\n\nmodule.exports = function(middleware) {\n\tvar app = require('express').Router();\n\n\tapp.post('/', apiMiddleware.requireUser, apiMiddleware.requireAdmin, function(req, res) {\n\t\tif (!utils.checkRequired(['name'], req, res)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tGroups.create(req.body, function(err, groupObj) {\n\t\t\terrorHandler.handle(err, res, groupObj);\n\t\t});\n\t});\n\n\tapp.delete('/:slug', apiMiddleware.requireUser, middleware.exposeGroupName, apiMiddleware.validateGroup, apiMiddleware.requireGroupOwner, function(req, res) {\n\t\tGroups.destroy(res.locals.groupName, function(err) {\n\t\t\terrorHandler.handle(err, res);\n\t\t});\n\t});\n\n\tapp.post('/:slug/membership', apiMiddleware.requireUser, middleware.exposeGroupName, apiMiddleware.validateGroup, function(req, res) {\n\t\tif (Meta.config.allowPrivateGroups !== '0') {\n\t\t\tGroups.isPrivate(res.locals.groupName, function(err, isPrivate) {\n\t\t\t\tif (isPrivate) {\n\t\t\t\t\tGroups.requestMembership(res.locals.groupName, req.user.uid, function(err) {\n\t\t\t\t\t\terrorHandler.handle(err, res);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tGroups.join(res.locals.groupName, req.user.uid, function(err) {\n\t\t\t\t\t\terrorHandler.handle(err, res);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tGroups.join(res.locals.groupName, req.user.uid, function(err) {\n\t\t\t\terrorHandler.handle(err, res);\n\t\t\t});\n\t\t}\n\t});\n\n\tapp.delete('/:slug/membership', apiMiddleware.requireUser, middleware.exposeGroupName, apiMiddleware.validateGroup, function(req, res) {\n\t\tGroups.isMember(req.user.uid, res.locals.groupName, function(err, isMember) {\n\t\t\tif (isMember) {\n\t\t\t\tGroups.leave(res.locals.groupName, req.user.uid, function(err) {\n\t\t\t\t\terrorHandler.handle(err, res);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\terrorHandler.respond(400, res);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn app;\n};\n",
        "called_code_segment": "ErrorHandler.handle = function (err, res, payload) {\n    if (err) {\n        if (isLanguageKey.test(err.message)) {\n            translator.translate(err.message, 'en-GB', function (translated) {\n                res.status(400).json(ErrorHandler.generate(400, undefined, translated));\n            });\n        } else {\n            res.status(500).json(ErrorHandler.generate(500, undefined, err.message));\n        }\n    } else {\n        res.status(200).json({\n            code: 'ok',\n            payload: payload || {},\n        });\n    }\n};",
        "invoking_code_segment": "app.delete('/:slug', apiMiddleware.requireUser, middleware.exposeGroupName, apiMiddleware.validateGroup, apiMiddleware.requireGroupOwner, function(req, res) {\n    Groups.destroy(res.locals.groupName, function(err) {\n        errorHandler.handle(err, res);\n    });\n});",
        "new_file_code_segment": "function logError(err, status) {\n    console.error(`Error ${status}: ${err.message}`);\n}\n\nmodule.exports = {\n    logError\n};",
        "feature_description": "Add error logging for better debugging.",
        "detailed_feature_description": "The new feature introduces error logging to the existing error handling mechanism. When an error is handled, it will now log the error message and status code to the console. This will help in debugging and monitoring errors more effectively. The new functionality is implemented in a separate file (#file 3) and is integrated into the existing error handling logic in #file 1. The invoking code in #file 2 is updated to utilize this new logging functionality.",
        "modified_complete_code": {
            "#file 1": "'use strict';\n\nvar translator = require.main.require('./src/translator');\nvar isLanguageKey = /^[[[w.,s-_:]+]]$/;\nvar logger = require('./logger'); //New\n\nvar ErrorHandler = {};\n\nErrorHandler.respond = function (status, res) {\n    var errorPayload = ErrorHandler.generate(status);\n\n    res.status(status).json(errorPayload);\n    return true;\n};\n\nErrorHandler.handle = function (err, res, payload) {\n    if (err) {\n        if (isLanguageKey.test(err.message)) {\n            translator.translate(err.message, 'en-GB', function (translated) {\n                res.status(400).json(ErrorHandler.generate(400, undefined, translated));\n            });\n        } else {\n            res.status(500).json(ErrorHandler.generate(500, undefined, err.message));\n        }\n        logger.logError(err, 500); //Modify\n    } else {\n        res.status(200).json({\n            code: 'ok',\n            payload: payload || {},\n        });\n    }\n};\n\nErrorHandler.generate = function (status, code, message, params) {\n    // All arguments are optional\n    var errorPayload = ErrorHandler.statusToCode(status);\n\n    errorPayload.code = code || errorPayload.code;\n    errorPayload.message = message ? (errorPayload.message + ' | ' + message) : errorPayload.message;\n    errorPayload.params = { ...params, ...errorPayload.params };\n\n    return errorPayload;\n};\n\nErrorHandler.statusToCode = function (status) {\n    var payload = {\n        code: 'internal-server-error',\n        message: 'An unexpected error was encountered while attempting to service your request.',\n        params: {},\n    };\n\n    switch (status) {\n    case 400:\n        payload.code = 'bad-request';\n        payload.message = 'Something was wrong with the request payload you passed in.';\n        break;\n\n    case 401:\n        payload.code = 'not-authorised';\n        payload.message = 'A valid login session was not found. Please log in and try again.';\n        break;\n\n    case 403:\n        payload.code = 'forbidden';\n        payload.message = 'You are not authorised to make this call';\n        break;\n\n    case 404:\n        payload.code = 'not-found';\n        payload.message = 'Invalid API call';\n        break;\n\n    case 426:\n        payload.code = 'upgrade-required';\n        payload.message = 'HTTPS is required for requests to the write api, please re-send your request via HTTPS';\n        break;\n    }\n\n    return payload;\n};\n\nmodule.exports = ErrorHandler;",
            "#file 2": "'use strict';\n/* globals module, require */\n\nvar Groups = require.main.require('./src/groups'),\n    Meta = require.main.require('./src/meta'),\n    apiMiddleware = require('./middleware'),\n    errorHandler = require('../../lib/errorHandler'),\n    utils = require('./utils');\n\n\nmodule.exports = function(middleware) {\n    var app = require('express').Router();\n\n    app.post('/', apiMiddleware.requireUser, apiMiddleware.requireAdmin, function(req, res) {\n        if (!utils.checkRequired(['name'], req, res)) {\n            return false;\n        }\n\n        Groups.create(req.body, function(err, groupObj) {\n            errorHandler.handle(err, res, groupObj);\n        });\n    });\n\n    app.delete('/:slug', apiMiddleware.requireUser, middleware.exposeGroupName, apiMiddleware.validateGroup, apiMiddleware.requireGroupOwner, function(req, res) {\n        Groups.destroy(res.locals.groupName, function(err) {\n            errorHandler.handle(err, res);\n        });\n    });\n\n    app.post('/:slug/membership', apiMiddleware.requireUser, middleware.exposeGroupName, apiMiddleware.validateGroup, function(req, res) {\n        if (Meta.config.allowPrivateGroups !== '0') {\n            Groups.isPrivate(res.locals.groupName, function(err, isPrivate) {\n                if (isPrivate) {\n                    Groups.requestMembership(res.locals.groupName, req.user.uid, function(err) {\n                        errorHandler.handle(err, res);\n                    });\n                } else {\n                    Groups.join(res.locals.groupName, req.user.uid, function(err) {\n                        errorHandler.handle(err, res);\n                    });\n                }\n            });\n        } else {\n            Groups.join(res.locals.groupName, req.user.uid, function(err) {\n                errorHandler.handle(err, res);\n            });\n        }\n    });\n\n    app.delete('/:slug/membership', apiMiddleware.requireUser, middleware.exposeGroupName, apiMiddleware.validateGroup, function(req, res) {\n        Groups.isMember(req.user.uid, res.locals.groupName, function(err, isMember) {\n            if (isMember) {\n                Groups.leave(res.locals.groupName, req.user.uid, function(err) {\n                    errorHandler.handle(err, res);\n                });\n            } else {\n                errorHandler.respond(400, res);\n            }\n        });\n    });\n\n    return app;\n};",
            "#file 3": "'use strict';\n\nfunction logError(err, status) {\n    console.error(`Error ${status}: ${err.message}`);\n}\n\nmodule.exports = {\n    logError\n};"
        }
    },
    {
        "repo": "pug-loader",
        "content": "'pug-loader/test/fakeModuleSystem.js'\n:var fs = require(\"fs\");\nvar path = require(\"path\");\n\nmodule.exports = function runLoader(loader, directory, filename, arg, callback) {\n\tvar async = false;\n\tvar loaderContext = {\n\t\tasync: function() {\n\t\t\tasync = true;\n\t\t\treturn callback;\n\t\t},\n\t\tloaders: [\"itself\"],\n\t\tloaderIndex: 0,\n\t\tquery: \"?root=\" + encodeURIComponent(directory),\n\t\toptions: {},\n\t\tresource: filename,\n\t\tcallback: function() {\n\t\t\tasync = true;\n\t\t\treturn callback.apply(this, arguments);\n\t\t},\n\t\tresolve: function(context, request, resolveCallback) {\n\t\t\tprocess.nextTick(function() {\n\t\t\t\tresolveCallback(null, path.resolve(context, request));\n\t\t\t});\n\t\t},\n\t\tloadModule: function(request, loadCallback) {\n\t\t\trequest = request.replace(/^-?!+/, \"\");\n\t\t\trequest = request.split(\"!\");\n\t\t\tfs.readFile(request.pop(), 'utf-8', function(err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tloadCallback(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif(request[0] && /stringify/.test(request[0])) {\n\t\t\t\t\tcontent = JSON.stringify(content);\n\t\t\t\t}\n\n\t\t\t\tloadCallback(null, content);\n\t\t\t});\n\t\t}\n\t};\n\tvar res = loader.call(loaderContext, arg);\n\tif(!async) callback(null, res);\n}\n\n'pug-loader/test/extend+include.test.js'\n:var should = require(\"should\");\n\nvar fs = require(\"fs\");\nvar path = require(\"path\");\n\nvar runLoader = require(\"./fakeModuleSystem\");\nvar pugLoader = require(\"../\");\n\nvar fixtures = path.join(__dirname, \"fixtures\");\n\ndescribe(\"extend+include\", function() {\n\tit(\"should generate correct code\", function(done) {\n\t\tvar template = path.join(fixtures, \"extend+include\", \"template.pug\");\n\t\trunLoader(pugLoader, path.join(fixtures, \"extend+include\"), template, fs.readFileSync(template, \"utf-8\"), function(err, result) {\n\t\t\tif(err) throw err;\n\n\t\t\tresult.should.have.type(\"string\");\n\t\t\tresult.should.match(/\\\\u003Cp\\\\u003E/); // <p>\n\t\t\tresult.should.match(/\\\\u003C\\\\u002Fp\\\\u003E/); // </p>\n\t\t\tresult.should.match(/included\\.pug/);\n\t\t\tresult.should.match(/abc/);\n\t\t\tdone();\n\t\t});\n\t});\n});\n\n",
        "called_code_segment": "module.exports = function runLoader(loader, directory, filename, arg, callback) {\n\tvar async = false;\n\tvar loaderContext = {\n\t\tasync: function() {\n\t\t\tasync = true;\n\t\t\treturn callback;\n\t\t},\n\t\tloaders: [\"itself\"],\n\t\tloaderIndex: 0,\n\t\tquery: \"?root=\" + encodeURIComponent(directory),\n\t\toptions: {},\n\t\tresource: filename,\n\t\tcallback: function() {\n\t\t\tasync = true;\n\t\t\treturn callback.apply(this, arguments);\n\t\t},\n\t\tresolve: function(context, request, resolveCallback) {\n\t\t\tprocess.nextTick(function() {\n\t\t\t\tresolveCallback(null, path.resolve(context, request));\n\t\t\t});\n\t\t},\n\t\tloadModule: function(request, loadCallback) {\n\t\t\trequest = request.replace(/^-?!+/, \"\");\n\t\t\trequest = request.split(\"!\");\n\t\t\tfs.readFile(request.pop(), 'utf-8', function(err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tloadCallback(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif(request[0] && /stringify/.test(request[0])) {\n\t\t\t\t\tcontent = JSON.stringify(content);\n\t\t\t\t}\n\n\t\t\t\tloadCallback(null, content);\n\t\t\t});\n\t\t}\n\t};\n\tvar res = loader.call(loaderContext, arg);\n\tif(!async) callback(null, res);\n}",
        "invoking_code_segment": "var template = path.join(fixtures, \"extend+include\", \"template.pug\");\nrunLoader(pugLoader, path.join(fixtures, \"extend+include\"), template, fs.readFileSync(template, \"utf-8\"), function(err, result) {\n\tif(err) throw err;\n\n\tresult.should.have.type(\"string\");\n\tresult.should.match(/\\\\u003Cp\\\\u003E/); // <p>\n\tresult.should.match(/\\\\u003C\\\\u002Fp\\\\u003E/); // </p>\n\tresult.should.match(/included\\\\.pug/);\n\tresult.should.match(/abc/);\n\tdone();\n});",
        "new_file_code_segment": "module.exports = function logLoaderExecution(loader, directory, filename, arg, callback) {\n\tconsole.log(`Loader executed for file: ${filename} in directory: ${directory}`);\n\tcallback();\n}",
        "feature_description": "Add logging for loader execution.",
        "detailed_feature_description": "A new feature is added to log the execution of the loader. This is implemented by creating a new file (#file 3) that contains a function to log the loader execution details. The #file 1 is modified to invoke this logging function before calling the loader. The #file 2 remains unchanged as it directly invokes the runLoader function from #file 1.",
        "modified_complete_code": {
            "#file 1": "#Modify module.exports = function runLoader(loader, directory, filename, arg, callback) {\n\tvar async = false;\n\tvar loaderContext = {\n\t\tasync: function() {\n\t\t\tasync = true;\n\t\t\treturn callback;\n\t\t},\n\t\tloaders: [\"itself\"],\n\t\tloaderIndex: 0,\n\t\tquery: \"?root=\" + encodeURIComponent(directory),\n\t\toptions: {},\n\t\tresource: filename,\n\t\tcallback: function() {\n\t\t\tasync = true;\n\t\t\treturn callback.apply(this, arguments);\n\t\t},\n\t\tresolve: function(context, request, resolveCallback) {\n\t\t\tprocess.nextTick(function() {\n\t\t\t\tresolveCallback(null, path.resolve(context, request));\n\t\t\t});\n\t\t},\n\t\tloadModule: function(request, loadCallback) {\n\t\t\trequest = request.replace(/^-?!+/, \"\");\n\t\t\trequest = request.split(\"!\");\n\t\t\tfs.readFile(request.pop(), 'utf-8', function(err, content) {\n\t\t\t\tif (err) {\n\t\t\t\t\tloadCallback(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif(request[0] && /stringify/.test(request[0])) {\n\t\t\t\t\tcontent = JSON.stringify(content);\n\t\t\t\t}\n\n\t\t\t\tloadCallback(null, content);\n\t\t\t});\n\t\t}\n\t};\n\t#New require('./logLoaderExecution')(loader, directory, filename, arg, function() {\n\t\tvar res = loader.call(loaderContext, arg);\n\t\tif(!async) callback(null, res);\n\t});\n}",
            "#file 2": "var template = path.join(fixtures, \"extend+include\", \"template.pug\");\nrunLoader(pugLoader, path.join(fixtures, \"extend+include\"), template, fs.readFileSync(template, \"utf-8\"), function(err, result) {\n\tif(err) throw err;\n\n\tresult.should.have.type(\"string\");\n\tresult.should.match(/\\\\u003Cp\\\\u003E/); // <p>\n\tresult.should.match(/\\\\u003C\\\\u002Fp\\\\u003E/); // </p>\n\tresult.should.match(/included\\\\.pug/);\n\tresult.should.match(/abc/);\n\tdone();\n});",
            "#file 3": "#New module.exports = function logLoaderExecution(loader, directory, filename, arg, callback) {\n\tconsole.log(`Loader executed for file: ${filename} in directory: ${directory}`);\n\tcallback();\n}"
        }
    },
    {
        "repo": "react-flask-app",
        "content": "'react-flask-app/src/App.js'\n:import React, { useState, useEffect } from 'react';\nimport { BrowserRouter, Link, Switch, Route } from 'react-router-dom';\nimport logo from './logo.svg';\nimport './App.css';\n\nfunction App() {\n  const [currentTime, setCurrentTime] = useState(0);\n\n  useEffect(() => {\n    fetch('/api/time').then(res => res.json()).then(data => {\n      setCurrentTime(data.time);\n    });\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <BrowserRouter>\n          <div>\n            <Link className=\"App-link\" to=\"/\">Home</Link>\n            &nbsp;|&nbsp;\n            <Link className=\"App-link\" to=\"/page2\">Page2</Link>\n          </div>\n          <Switch>\n            <Route exact path=\"/\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\n                <p>\n                  Edit <code>src/App.js</code> and save to reload.\n                </p>\n                <a\n                  className=\"App-link\"\n                  href=\"https://reactjs.org\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                >\n                  Learn React\n                </a>\n                <p>The current time is {currentTime}.</p>\n            </Route>\n            <Route path=\"/page2\">\n                <p>This is page 2!</p>\n            </Route>\n          </Switch>\n        </BrowserRouter>\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n\n'react-flask-app/src/App.test.js'\n:import React from 'react';\nimport { render } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  const { getByText } = render(<App />);\n  const linkElement = getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n\n",
        "called_code_segment": "const [currentTime, setCurrentTime] = useState(0);\n\nuseEffect(() => {\n  fetch('/api/time').then(res => res.json()).then(data => {\n    setCurrentTime(data.time);\n  });\n}, []);",
        "invoking_code_segment": "<p>The current time is {currentTime}.</p>",
        "new_file_code_segment": "export function fetchCurrentTime() {\n  return fetch('/api/time').then(res => res.json()).then(data => data.time);\n}",
        "feature_description": "Add a function to fetch the current time from the API and use it in both the main App component and the Page2 component.",
        "detailed_feature_description": "The new feature involves creating a utility function in a new file (#file 3) that fetches the current time from the API. This function is then imported and used in both the main App component (#file 1) and the Page2 component (#file 2). This ensures that the fetching logic is centralized and can be reused across different parts of the application.",
        "modified_complete_code": {
            "#file 1": "import React, { useState, useEffect } from 'react';\nimport { BrowserRouter, Link, Switch, Route } from 'react-router-dom';\nimport logo from './logo.svg';\nimport './App.css';\nimport { fetchCurrentTime } from './utils'; // #New\n\nfunction App() {\n  const [currentTime, setCurrentTime] = useState(0);\n\n  useEffect(() => {\n    fetchCurrentTime().then(time => setCurrentTime(time)); // #Modify\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <BrowserRouter>\n          <div>\n            <Link className=\"App-link\" to=\"/\">Home</Link>\n            &nbsp;|&nbsp;\n            <Link className=\"App-link\" to=\"/page2\">Page2</Link>\n          </div>\n          <Switch>\n            <Route exact path=\"/\">\n                <img src={logo} className=\"App-logo\" alt=\"logo\" />\n                <p>\n                  Edit <code>src/App.js</code> and save to reload.\n                </p>\n                <a\n                  className=\"App-link\"\n                  href=\"https://reactjs.org\"\n                  target=\"_blank\"\n                  rel=\"noopener noreferrer\"\n                >\n                  Learn React\n                </a>\n                <p>The current time is {currentTime}.</p>\n            </Route>\n            <Route path=\"/page2\">\n                <Page2 />\n            </Route>\n          </Switch>\n        </BrowserRouter>\n      </header>\n    </div>\n  );\n}\n\nexport default App;",
            "#file 2": "import React, { useState, useEffect } from 'react';\nimport { fetchCurrentTime } from './utils'; // #New\n\nfunction Page2() {\n  const [currentTime, setCurrentTime] = useState(0);\n\n  useEffect(() => {\n    fetchCurrentTime().then(time => setCurrentTime(time)); // #Modify\n  }, []);\n\n  return (\n    <div>\n      <p>This is page 2!</p>\n      <p>The current time is {currentTime}.</p>\n    </div>\n  );\n}\n\nexport default Page2;",
            "#file 3": "export function fetchCurrentTime() {\n  return fetch('/api/time').then(res => res.json()).then(data => data.time);\n}"
        }
    },
    {
        "repo": "react-native-fontawesome",
        "content": "'react-native-fontawesome/Icon.js'\n:import React, { Component } from 'react';\n\nimport { Text, StyleSheet } from 'react-native';\n\n\n\nimport { SolidIcons, RegularIcons, BrandIcons, parseIconFromClassName } from './FontAwesomeIcons';\n\n\n\nclass Icon extends Component {\n\n  setNativeProps(nativeProps) {\n\n    this._root.setNativeProps(nativeProps);\n\n  }\n\n\n\n  render() {\n\n    const { style, color, icon, pro, ...props } = this.props;\n\n    const [code, type] = (icon || '').split('|')\n\n\n\n    const IconType = type === 'brand' ? BrandIcons :\n\n                     type === 'regular' ? RegularIcons\n\n                     : SolidIcons\n\n\n\n    const font = { fontFamily: IconType._fontFamily || '' }\n\n\n\n    if (pro) {\n\n      font.fontFamily = font.fontFamily.replace('Free', 'Pro')\n\n    }\n\n\n\n    return (\n\n      <Text\n\n        {...props}\n\n        style={[styles.icon, { color }, style, font]}\n\n        ref={component => this._root = component}\n\n      >\n\n        {code}\n\n      </Text>\n\n    );\n\n  }\n\n}\n\n\n\nconst styles = StyleSheet.create({\n\n  icon: {\n\n    backgroundColor: 'transparent'\n\n  },\n\n});\n\n\n\nexport { SolidIcons, RegularIcons, BrandIcons, parseIconFromClassName };\n\nexport default Icon;\n\n\n'react-native-fontawesome/__tests__/FontAwesomeIconsSpecificAndroidTest.js'\n:import { BrandIcons, SolidIcons, RegularIcons } from '../FontAwesomeIcons';\n\nimport { parseIconFromClassName } from '../Icon'\n\n\n\njest.mock('react-native', () => {\n\n  return {\n\n    StyleSheet: {\n\n      create: jest.fn(),\n\n    },\n\n    Platform: {\n\n      OS: 'android'\n\n    }\n\n  };\n\n});\n\n\n\ndescribe('Testing FontAwesomeIcons Specific Android Tests', () => {\n\n  it('get the right platform font family name', () => {\n\n    expect(BrandIcons._fontFamily).toBe('fa-brands-400')\n\n    expect(SolidIcons._fontFamily).toBe('fa-solid-900')\n\n    expect(RegularIcons._fontFamily).toBe('fa-regular-400')\n\n  })\n\n});\n\n\n",
        "called_code_segment": "class Icon extends Component {\n  setNativeProps(nativeProps) {\n    this._root.setNativeProps(nativeProps);\n  }\n\n  render() {\n    const { style, color, icon, pro, ...props } = this.props;\n    const [code, type] = (icon || '').split('|')\n\n    const IconType = type === 'brand' ? BrandIcons :\n                     type === 'regular' ? RegularIcons\n                     : SolidIcons\n\n    const font = { fontFamily: IconType._fontFamily || '' }\n\n    if (pro) {\n      font.fontFamily = font.fontFamily.replace('Free', 'Pro')\n    }\n\n    return (\n      <Text\n        {...props}\n        style={[styles.icon, { color }, style, font]}\n        ref={component => this._root = component}\n      >\n        {code}\n      </Text>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  icon: {\n    backgroundColor: 'transparent'\n  },\n});",
        "invoking_code_segment": "import Icon from './Icon';\n\n// Usage example\n<Icon icon='fa-home|solid' color='blue' />",
        "new_file_code_segment": "const getIconFontFamily = (type, pro) => {\n  const IconType = type === 'brand' ? BrandIcons :\n                   type === 'regular' ? RegularIcons\n                   : SolidIcons\n\n  let fontFamily = IconType._fontFamily || ''\n\n  if (pro) {\n    fontFamily = fontFamily.replace('Free', 'Pro')\n  }\n\n  return fontFamily\n}\n\nexport { getIconFontFamily };",
        "feature_description": "Add a utility function to get the font family based on icon type and pro status.",
        "detailed_feature_description": "The new feature introduces a utility function `getIconFontFamily` in a new file (#file 3) that encapsulates the logic for determining the font family based on the icon type and whether it is a pro version. This function is then used in #file 1 to simplify the `render` method, making it more modular and easier to maintain. #file 2 remains unchanged as it directly uses the `Icon` component from #file 1.",
        "modified_complete_code": {
            "#file 1": "import { getIconFontFamily } from './IconUtils'; #New\n\nclass Icon extends Component {\n  setNativeProps(nativeProps) {\n    this._root.setNativeProps(nativeProps);\n  }\n\n  render() {\n    const { style, color, icon, pro, ...props } = this.props;\n    const [code, type] = (icon || '').split('|')\n\n    const font = { fontFamily: getIconFontFamily(type, pro) } #Modify\n\n    return (\n      <Text\n        {...props}\n        style={[styles.icon, { color }, style, font]}\n        ref={component => this._root = component}\n      >\n        {code}\n      </Text>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  icon: {\n    backgroundColor: 'transparent'\n  },\n});",
            "#file 2": "import Icon from './Icon';\n\n// Usage example\n<Icon icon='fa-home|solid' color='blue' />",
            "#file 3": "const getIconFontFamily = (type, pro) => {\n  const IconType = type === 'brand' ? BrandIcons :\n                   type === 'regular' ? RegularIcons\n                   : SolidIcons\n\n  let fontFamily = IconType._fontFamily || ''\n\n  if (pro) {\n    fontFamily = fontFamily.replace('Free', 'Pro')\n  }\n\n  return fontFamily\n}\n\nexport { getIconFontFamily };"
        }
    },
    {
        "repo": "resourceful",
        "content": "'resourceful/lib/resourceful/engines/memory.js'\n:var resourceful = require('../../resourceful'),\n    Cache = resourceful.Cache;\n\nexports.stores = {};\nexports.caches = {};\n\nvar Memory = exports.Memory = function (options) {\n  var counter = 0;\n  options = options || {};\n  this.uri = options.uri;\n\n  this.increment = function () {\n    return ++counter;\n  };\n\n  if (typeof(this.uri) === 'string') {\n    // Application-wide store\n    if (!exports.stores[this.uri]) {\n      this.store = exports.stores[this.uri] = {};\n      this.cache = exports.caches[this.uri] = new Cache();\n    } else {\n      // Use store that was created before\n      this.store = exports.stores[this.uri];\n      this.cache = exports.caches[this.uri];\n    }\n  }\n  else {\n    // Connection-wise store\n    this.store = {};\n    this.cache = new Cache();\n  }\n};\n\nMemory.prototype.protocol = 'memory';\n\nMemory.prototype.load = function (data) {\n  if (data instanceof Array) {\n    var tmp = {};\n    data.forEach(function (e) {\n      tmp[e.id] = JSON.stringify(e);\n    });\n    data = tmp;\n  }\n\n  this.store = data;\n\n  // Update cache\n  if (this.uri) {\n    exports.stores[this.uri] = JSON.parse(JSON.stringify(this.store));\n  }\n  return this;\n};\n\nMemory.prototype.request = function (fn) {\n  var self = this;\n\n  process.nextTick(function () {\n    fn.call(self);\n  });\n};\n\nMemory.prototype.save = function (key, val, callback) {\n  var args = Array.prototype.slice.call(arguments);\n  var callback = args.pop(), val = args.pop();\n  if (!args.length || !key) {\n    key = this.increment();\n    val.id = key;\n  }\n\n  // Forces key to be a string\n  key += '';\n  val.id += '';\n\n  this.request(function () {\n    this.store[key] = JSON.stringify(val);\n    callback(null, val);\n  });\n};\n\nMemory.prototype.put = function () {\n  this.save.apply(this, arguments);\n};\n\nMemory.prototype.update = function (key, obj, callback) {\n  var jsObj = JSON.parse(this.store[key] || \"{}\");\n  this.put(key, resourceful.mixin({}, jsObj, obj), callback);\n};\n\nMemory.prototype.get =  function (key, callback) {\n  this.request(function () {\n    key = key.toString();\n    return key in this.store ?\n        callback(null, JSON.parse(this.store[key] || \"null\"))\n        :\n        callback({ status: 404 });\n  });\n};\n\nMemory.prototype.destroy = function (key, callback) {\n  this.request(function () {\n    delete this.store[key];\n    return callback(null, { status: 204 });\n  });\n};\n\nMemory.prototype.find = function (conditions, callback) {\n  var self = this,\n      searchers = {};\n  Object.keys(conditions).forEach(function (k) {\n    searchers[k] = self._reduceFactory(conditions[k]);\n  });\n\n  this.search(function (obj) {\n    return Object.keys(searchers).every(function (k) {\n      return searchers[k](obj[k]);\n    });\n  }, callback);\n};\n\nMemory.prototype._reduceFactory = function(param) {\n  if (param instanceof Array) {\n    return function(value) {\n      return param.indexOf(value) >= 0;\n    };\n  } else if (param instanceof Object) {\n    if (param.key) {\n      return function(value) {\n        return param.key === value;\n      };\n    } else if (param.keys) {\n      return function(value) {\n        return param.keys.indexOf(value) >= 0;\n      };\n    } else if (param.keys().length === 0) {\n      return function(value) {\n        return true;\n      };\n    } else {\n      throw new Error('Criteria object without key or keys fields');\n    };\n  } else {\n    return function(value) {\n       return param === value;\n    }\n  };\n}\n\nMemory.prototype.search = function (filter, callback) {\n  this.request(function () {\n    var result = [],\n        store = this.store;\n\n    Object.keys(this.store).forEach(function (k) {\n      var obj = JSON.parse(store[k]);\n      if (filter(obj)) {\n        obj.id = obj.id.split('/').slice(1).join('/');\n        result.push(obj);\n      }\n    });\n\n    callback(null, result);\n  });\n};\n\n\nMemory.prototype.filter = function (name, data) {\n  var resource = data.resource,\n      filter = data.filter,\n      path = [resource._resource, name].join('/'),\n      map;\n  if (typeof(filter) === 'object') {\n    if (filter.map) {\n      // Mimic CouchDB's view API.\n      map = new Function([\n        'return (function (_doc, emit) {',\n        '  (' + filter.map.toString() + ')(_doc)',\n       '})'\n      ].join('\\n'));\n      \n      \n      resource[name] = function (param, callback) {\n        var results = [],\n            reduce;\n        if (typeof param === 'function') {\n          callback = param;\n          param = {};\n        };\n        reduce = resource.connection._reduceFactory(param);\n        \n        function emit(id, doc) {\n          if(reduce(id)) {\n            results.push(doc);\n          };\n        };\n        \n        resource.connection.request(function () {\n          Object.keys(resource.connection.store).forEach(function (key) {\n            map()(JSON.parse(resource.connection.store[key]), emit);\n          });\n          \n          resource.view(path, { err: null, res: results }, callback);\n        });\n      };\n    } else {\n      // Simple object criteria (can use .find)\n      resource[name] = function (callback) {\n        var conditions = resourceful.mixin({}, {resource: resource._resource}, filter)\n        resource.connection.find(conditions, function(err, res) {\n          resource.view(path, { err: err, res: res }, callback);\n        });\n      };\n    };\n  } else if (typeof(filter) === 'function') {\n    // Function which generates object criteria (can use .find)\n    resource[name] = function (param, callback) {\n      if (typeof param === 'function') {\n        callback = param;\n        param = {};\n      };\n      conditions = filter(param);\n      conditions = resourceful.mixin({}, {resource: resource._resource}, conditions)\n      resource.connection.find(conditions, function(err, res) {\n        resource.view(path, { err: err, res: res }, callback);\n      });\n    };\n  } else {\n    throw new TypeError('Filter must be an object or function');\n  };\n};\n\nMemory.prototype.view = function (path, opts, callback) {\n  if(opts.err) {\n    callback(opts.err);\n  };\n  callback(null, opts.res);\n};\n\nMemory.prototype.sync = function (factory, callback) {\n  process.nextTick(function () { callback(); });\n};\n\n'resourceful/lib/browser.js'\n:window.resourceful = require('./resourceful');\n\nrequire('./resourceful/engines/memory');\n\n",
        "called_code_segment": "Memory.prototype.save = function (key, val, callback) {\n  var args = Array.prototype.slice.call(arguments);\n  var callback = args.pop(), val = args.pop();\n  if (!args.length || !key) {\n    key = this.increment();\n    val.id = key;\n  }\n\n  // Forces key to be a string\n  key += '';\n  val.id += '';\n\n  this.request(function () {\n    this.store[key] = JSON.stringify(val);\n    callback(null, val);\n  });\n};",
        "invoking_code_segment": "Memory.prototype.put = function () {\n  this.save.apply(this, arguments);\n};",
        "new_file_code_segment": "function validateResource(val) {\n  if (!val.id || !val.type) {\n    throw new Error('Resource must have an id and type');\n  }\n}\n\nmodule.exports = {\n  validateResource: validateResource\n};",
        "feature_description": "Add validation for resource objects before saving them.",
        "detailed_feature_description": "The new feature introduces a validation step to ensure that every resource object being saved has a valid 'id' and 'type'. This is implemented in a new file (#file 3) which exports a validation function. The 'save' method in #file 1 is modified to call this validation function before proceeding with the save operation. The 'put' method in #file 2 remains unchanged as it directly invokes the 'save' method, ensuring compatibility.",
        "modified_complete_code": {
            "#file 1": "Memory.prototype.save = function (key, val, callback) {\n  var args = Array.prototype.slice.call(arguments);\n  var callback = args.pop(), val = args.pop();\n  if (!args.length || !key) {\n    key = this.increment();\n    val.id = key;\n  }\n\n  // Forces key to be a string\n  key += '';\n  val.id += '';\n\n  //Modify: Add validation step\n  var validateResource = require('./file3').validateResource;\n  try {\n    validateResource(val);\n  } catch (err) {\n    return callback(err);\n  }\n\n  this.request(function () {\n    this.store[key] = JSON.stringify(val);\n    callback(null, val);\n  });\n};",
            "#file 2": "Memory.prototype.put = function () {\n  this.save.apply(this, arguments);\n};",
            "#file 3": "function validateResource(val) {\n  if (!val.id || !val.type) {\n    throw new Error('Resource must have an id and type');\n  }\n}\n\nmodule.exports = {\n  validateResource: validateResource\n};"
        }
    },
    {
        "repo": "three.bas",
        "content": "'three.bas/src/materials/BaseAnimationMaterial.js'\n:import {\n  ShaderMaterial,\n  UniformsUtils,\n} from 'three';\n\nclass BaseAnimationMaterial extends ShaderMaterial {\n  constructor (parameters, uniforms) {\n    super();\n\n    if (parameters.uniformValues) {\n      console.warn('THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters.')\n\n      Object.keys(parameters.uniformValues).forEach((key) => {\n        parameters[key] = parameters.uniformValues[key]\n      })\n\n      delete parameters.uniformValues\n    }\n\n    // copy parameters to (1) make use of internal #define generation\n    // and (2) prevent 'x is not a property of this material' warnings.\n    Object.keys(parameters).forEach((key) => {\n      this[key] = parameters[key]\n    })\n\n    // override default parameter values\n    this.setValues(parameters);\n\n    // override uniforms\n    this.uniforms = UniformsUtils.merge([uniforms, parameters.uniforms || {}]);\n\n    // set uniform values from parameters that affect uniforms\n    this.setUniformValues(parameters);\n  }\n\n  setUniformValues (values) {\n    if (!values) return;\n\n    const keys = Object.keys(values);\n\n    keys.forEach((key) => {\n      key in this.uniforms && (this.uniforms[key].value = values[key]);\n    });\n  }\n\n  stringifyChunk (name) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return value;\n  }\n}\n\nexport default BaseAnimationMaterial;\n\n'three.bas/src/materials/ToonAnimationMaterial.js'\n:import { ShaderLib } from 'three'\nimport BaseAnimationMaterial from './BaseAnimationMaterial';\n\nclass ToonAnimationMaterial extends BaseAnimationMaterial {\n  /**\n   * Extends THREE.MeshToonMaterial with custom shader chunks.\n   *\n   * @param {Object} parameters Object containing material properties and custom shader chunks.\n   */\n  constructor (parameters) {\n    super(parameters, ShaderLib['toon'].uniforms);\n\n    this.lights = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = this.concatFragmentShader();\n  }\n\n  concatVertexShader () {\n    return ShaderLib.toon.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n\n  concatFragmentShader () {\n    return ShaderLib.toon.fragmentShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('fragmentParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('fragmentFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('fragmentInit')}\n        `\n      )\n      .replace(\n        '#include <map_fragment>',\n        `\n        ${this.stringifyChunk('fragmentDiffuse')}\n        ${(this.stringifyChunk('fragmentMap') || '#include <map_fragment>')}\n\n        `\n      )\n      .replace(\n        '#include <emissivemap_fragment>',\n        `\n        ${this.stringifyChunk('fragmentEmissive')}\n\n        #include <emissivemap_fragment>\n        `\n      )\n  }\n}\n\nexport { ToonAnimationMaterial };\n\n",
        "called_code_segment": "stringifyChunk (name) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return value;\n  }",
        "invoking_code_segment": "concatVertexShader () {\n    return ShaderLib.toon.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('varyingParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        ${this.stringifyChunk('vertexColor')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }",
        "new_file_code_segment": "export function customStringifyChunk (name, additionalData) {\n  let value = '';\n  if (this[name]) {\n    value = typeof this[name] === 'string' ? this[name] : this[name].join('\\n');\n  }\n  if (additionalData) {\n    value += '\\n' + additionalData;\n  }\n  return value;\n}",
        "feature_description": "Enhance the `stringifyChunk` method to support additional data injection.",
        "detailed_feature_description": "The new feature enhances the `stringifyChunk` method in #file 1 by allowing additional data to be injected into the stringified chunk. This is implemented in a new file (#file 3) and is invoked in both #file 1 and #file 2 to maintain compatibility and functionality.",
        "modified_complete_code": {
            "#file 1": "//Modify\nstringifyChunk (name, additionalData) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    if (additionalData) {\n      value += '\\n' + additionalData;\n    }\n\n    return value;\n  }",
            "#file 2": "//Modify\nconcatVertexShader () {\n    return ShaderLib.toon.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters', customStringifyChunk('vertexParameters'))}\n        ${this.stringifyChunk('varyingParameters', customStringifyChunk('varyingParameters'))}\n        ${this.stringifyChunk('vertexFunctions', customStringifyChunk('vertexFunctions'))}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit', customStringifyChunk('vertexInit'))}\n        `\n      )\n      .replace(\n        '#include <beginnormal_vertex>',\n        `\n        #include <beginnormal_vertex>\n\n        ${this.stringifyChunk('vertexNormal', customStringifyChunk('vertexNormal'))}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition', customStringifyChunk('vertexPosition'))}\n        ${this.stringifyChunk('vertexColor', customStringifyChunk('vertexColor'))}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph', customStringifyChunk('vertexPostMorph'))}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning', customStringifyChunk('vertexPostSkinning'))}\n        `\n      )\n  }",
            "#file 3": "//New\nexport function customStringifyChunk (name, additionalData) {\n  let value = '';\n  if (this[name]) {\n    value = typeof this[name] === 'string' ? this[name] : this[name].join('\\n');\n  }\n  if (additionalData) {\n    value += '\\n' + additionalData;\n  }\n  return value;\n}"
        }
    },
    {
        "repo": "vue-form-json-schema",
        "content": "'vue-form-json-schema/src/vfjs-global-mixin/data.js'\n:import {\n  VFJS_EVENT_FIELD_MODEL_CLEAR_HIDDEN,\n  VFJS_EVENT_FIELD_MODEL_UPDATE,\n  VFJS_EVENT_FIELD_MODEL_VALIDATE,\n  VFJS_EVENT_FIELD_MODELS_VALIDATE,\n  VFJS_EVENT_FIELD_STATE_UPDATE,\n  VFJS_EVENT_MODEL_UPDATE,\n  VFJS_EVENT_MODEL_UPDATED,\n  VFJS_EVENT_MODEL_VALIDATE,\n  VFJS_EVENT_STATE_UPDATE,\n  VFJS_EVENT_STATE_UPDATED,\n  VFJS_EVENT_UI_FIELDS_UPDATE,\n} from '../constants';\n\nconst data = () => ({\n  vfjsBus: {},\n  vfjsEvents: [\n    VFJS_EVENT_FIELD_MODEL_CLEAR_HIDDEN,\n    VFJS_EVENT_FIELD_MODEL_UPDATE,\n    VFJS_EVENT_FIELD_MODEL_VALIDATE,\n    VFJS_EVENT_FIELD_MODELS_VALIDATE,\n    VFJS_EVENT_FIELD_STATE_UPDATE,\n    VFJS_EVENT_MODEL_UPDATE,\n    VFJS_EVENT_MODEL_UPDATED,\n    VFJS_EVENT_MODEL_VALIDATE,\n    VFJS_EVENT_STATE_UPDATE,\n    VFJS_EVENT_STATE_UPDATED,\n    VFJS_EVENT_UI_FIELDS_UPDATE,\n  ],\n  vfjsFields: [],\n  vfjsFieldsActive: [],\n  vfjsFieldsActiveModels: [],\n  vfjsFieldsRequired: [],\n  vfjsModel: {},\n  vfjsOptions: {\n    ajv: {\n      keywords: {},\n      locale: null,\n      options: {\n        allErrors: true,\n      },\n    },\n    allowInvalidModel: true,\n    castToSchemaType: false,\n    componentProperties: {\n      attrs: {\n        // Components which support the 'checked' attribute\n        checked: [\n          {\n            component: 'input',\n            attrs: {\n              type: 'checkbox',\n            },\n          },\n          {\n            component: 'input',\n            attrs: {\n              type: 'radio',\n            },\n          },\n        ],\n        // Components which support the 'required' attribute\n        required: ['input', 'select', 'textarea'],\n        // Components which support the 'value' attribute\n        value: ['input', 'option', 'textarea'],\n      },\n      domProps: {\n        // Components which should have its DOM property 'checked' updated\n        checked: [\n          {\n            component: 'input',\n            attrs: {\n              type: 'checkbox',\n            },\n          },\n          {\n            component: 'input',\n            attrs: {\n              type: 'radio',\n            },\n          },\n        ],\n        // Components which should have its DOM property 'required' updated\n        required: ['input', 'select', 'textarea'],\n        // Components which should have its DOM property 'value' updated\n        value: ['input', 'textarea'],\n      },\n      props: {\n        // Components which support the 'required' prop\n        required: [],\n      },\n      // Components which has their value within the tags\n      innerHTML: ['textarea'],\n    },\n    showValidationErrors: false,\n    validate: true,\n    validateOnLoad: true,\n    validateOnChange: true,\n    valueProp: 'value',\n    eventProp: 'value',\n  },\n  vfjsSchema: {},\n  vfjsState: {},\n  vfjsUiSchema: [],\n});\n\nexport default data;\n\n'vue-form-json-schema/src/vfjs-global-mixin/index.js'\n:import computed from './computed';\nimport data from './data';\nimport methods from './methods';\nimport props from './props';\nimport watch from './watch';\nimport { VFJS_EXTERNAL_MODEL_PROP, VFJS_EXTERNAL_EVENT_CHANGE } from '../constants';\n\nconst vfjsGlobalMixin = {\n  model: {\n    prop: VFJS_EXTERNAL_MODEL_PROP,\n    event: VFJS_EXTERNAL_EVENT_CHANGE,\n  },\n  created() {\n    this.vfjsInitialize();\n  },\n  beforeDestroy() {\n    this.vfjsDestroy();\n  },\n  computed,\n  data,\n  props,\n  methods,\n  watch,\n};\n\nexport default vfjsGlobalMixin;\n\n",
        "called_code_segment": "const data = () => ({\n  vfjsBus: {},\n  vfjsEvents: [\n    VFJS_EVENT_FIELD_MODEL_CLEAR_HIDDEN,\n    VFJS_EVENT_FIELD_MODEL_UPDATE,\n    VFJS_EVENT_FIELD_MODEL_VALIDATE,\n    VFJS_EVENT_FIELD_MODELS_VALIDATE,\n    VFJS_EVENT_FIELD_STATE_UPDATE,\n    VFJS_EVENT_MODEL_UPDATE,\n    VFJS_EVENT_MODEL_UPDATED,\n    VFJS_EVENT_MODEL_VALIDATE,\n    VFJS_EVENT_STATE_UPDATE,\n    VFJS_EVENT_STATE_UPDATED,\n    VFJS_EVENT_UI_FIELDS_UPDATE,\n  ],\n  vfjsFields: [],\n  vfjsFieldsActive: [],\n  vfjsFieldsActiveModels: [],\n  vfjsFieldsRequired: [],\n  vfjsModel: {},\n  vfjsOptions: {\n    ajv: {\n      keywords: {},\n      locale: null,\n      options: {\n        allErrors: true,\n      },\n    },\n    allowInvalidModel: true,\n    castToSchemaType: false,\n    componentProperties: {\n      attrs: {\n        // Components which support the 'checked' attribute\n        checked: [\n          { component: 'input', attrs: { type: 'checkbox' } },\n          { component: 'input', attrs: { type: 'radio' } },\n        ],\n        // Components which support the 'required' attribute\n        required: ['input', 'select', 'textarea'],\n        // Components which support the 'value' attribute\n        value: ['input', 'option', 'textarea'],\n      },\n      domProps: {\n        // Components which should have its DOM property 'checked' updated\n        checked: [\n          { component: 'input', attrs: { type: 'checkbox' } },\n          { component: 'input', attrs: { type: 'radio' } },\n        ],\n        // Components which should have its DOM property 'required' updated\n        required: ['input', 'select', 'textarea'],\n        // Components which should have its DOM property 'value' updated\n        value: ['input', 'textarea'],\n      },\n      props: {\n        // Components which support the 'required' prop\n        required: [],\n      },\n      // Components which has their value within the tags\n      innerHTML: ['textarea'],\n    },\n    showValidationErrors: false,\n    validate: true,\n    validateOnLoad: true,\n    validateOnChange: true,\n    valueProp: 'value',\n    eventProp: 'value',\n  },\n  vfjsSchema: {},\n  vfjsState: {},\n  vfjsUiSchema: [],\n});\n\nexport default data;",
        "invoking_code_segment": "const vfjsGlobalMixin = {\n  model: {\n    prop: VFJS_EXTERNAL_MODEL_PROP,\n    event: VFJS_EXTERNAL_EVENT_CHANGE,\n  },\n  created() {\n    this.vfjsInitialize();\n  },\n  beforeDestroy() {\n    this.vfjsDestroy();\n  },\n  computed,\n  data,\n  props,\n  methods,\n  watch,\n};\n\nexport default vfjsGlobalMixin;",
        "new_file_code_segment": "const vfjsInitialize = function() {\n  // Initialize the vfjsBus and other necessary data\n  this.vfjsBus = new Vue();\n  this.vfjsFields = [];\n  this.vfjsFieldsActive = [];\n  this.vfjsFieldsActiveModels = [];\n  this.vfjsFieldsRequired = [];\n  this.vfjsModel = {};\n  this.vfjsSchema = {};\n  this.vfjsState = {};\n  this.vfjsUiSchema = [];\n};\n\nexport default vfjsInitialize;",
        "feature_description": "Add an initialization function to handle the setup of the vfjsBus and other necessary data.",
        "detailed_feature_description": "The new feature introduces an initialization function in #file 3 (`vfjsInitialize`) that handles the setup of the `vfjsBus` and other necessary data. This function is invoked in #file 2 (`vfjsGlobalMixin`) during the `created` lifecycle hook. This ensures that the `vfjsBus` and other data are properly initialized when the component is created. The `vfjsInitialize` function is imported and used in #file 2 to replace the direct invocation of the data initialization logic.",
        "modified_complete_code": {
            "#file 1": "//Modify\nconst data = () => ({\n  vfjsBus: {},\n  vfjsEvents: [\n    VFJS_EVENT_FIELD_MODEL_CLEAR_HIDDEN,\n    VFJS_EVENT_FIELD_MODEL_UPDATE,\n    VFJS_EVENT_FIELD_MODEL_VALIDATE,\n    VFJS_EVENT_FIELD_MODELS_VALIDATE,\n    VFJS_EVENT_FIELD_STATE_UPDATE,\n    VFJS_EVENT_MODEL_UPDATE,\n    VFJS_EVENT_MODEL_UPDATED,\n    VFJS_EVENT_MODEL_VALIDATE,\n    VFJS_EVENT_STATE_UPDATE,\n    VFJS_EVENT_STATE_UPDATED,\n    VFJS_EVENT_UI_FIELDS_UPDATE,\n  ],\n  vfjsFields: [],\n  vfjsFieldsActive: [],\n  vfjsFieldsActiveModels: [],\n  vfjsFieldsRequired: [],\n  vfjsModel: {},\n  vfjsOptions: {\n    ajv: {\n      keywords: {},\n      locale: null,\n      options: {\n        allErrors: true,\n      },\n    },\n    allowInvalidModel: true,\n    castToSchemaType: false,\n    componentProperties: {\n      attrs: {\n        // Components which support the 'checked' attribute\n        checked: [\n          { component: 'input', attrs: { type: 'checkbox' } },\n          { component: 'input', attrs: { type: 'radio' } },\n        ],\n        // Components which support the 'required' attribute\n        required: ['input', 'select', 'textarea'],\n        // Components which support the 'value' attribute\n        value: ['input', 'option', 'textarea'],\n      },\n      domProps: {\n        // Components which should have its DOM property 'checked' updated\n        checked: [\n          { component: 'input', attrs: { type: 'checkbox' } },\n          { component: 'input', attrs: { type: 'radio' } },\n        ],\n        // Components which should have its DOM property 'required' updated\n        required: ['input', 'select', 'textarea'],\n        // Components which should have its DOM property 'value' updated\n        value: ['input', 'textarea'],\n      },\n      props: {\n        // Components which support the 'required' prop\n        required: [],\n      },\n      // Components which has their value within the tags\n      innerHTML: ['textarea'],\n    },\n    showValidationErrors: false,\n    validate: true,\n    validateOnLoad: true,\n    validateOnChange: true,\n    valueProp: 'value',\n    eventProp: 'value',\n  },\n  vfjsSchema: {},\n  vfjsState: {},\n  vfjsUiSchema: [],\n});\n\nexport default data;",
            "#file 2": "//Modify\nimport vfjsInitialize from './vfjsInitialize';\n\nconst vfjsGlobalMixin = {\n  model: {\n    prop: VFJS_EXTERNAL_MODEL_PROP,\n    event: VFJS_EXTERNAL_EVENT_CHANGE,\n  },\n  created() {\n    this.vfjsInitialize();\n  },\n  beforeDestroy() {\n    this.vfjsDestroy();\n  },\n  computed,\n  data,\n  props,\n  methods,\n  watch,\n};\n\nexport default vfjsGlobalMixin;",
            "#file 3": "//New\nconst vfjsInitialize = function() {\n  // Initialize the vfjsBus and other necessary data\n  this.vfjsBus = new Vue();\n  this.vfjsFields = [];\n  this.vfjsFieldsActive = [];\n  this.vfjsFieldsActiveModels = [];\n  this.vfjsFieldsRequired = [];\n  this.vfjsModel = {};\n  this.vfjsSchema = {};\n  this.vfjsState = {};\n  this.vfjsUiSchema = [];\n};\n\nexport default vfjsInitialize;"
        }
    },
    {
        "repo": "Instagram",
        "content": "'Instagram/components/InstaIcon.js'\n:import React from 'react';\nimport { Image } from 'react-native';\n\nimport Assets from '../Assets';\n\nexport default class InstaIcon extends React.PureComponent {\n  render() {\n    const {\n      name,\n      active,\n      disabled,\n      size,\n      color = 'white',\n      style,\n      ...props\n    } = this.props;\n    if (!name) {\n      return null;\n    }\n    const colorStyle = [\n      {\n        opacity: disabled ? 0.5 : 1,\n        width: size,\n        height: size,\n        resizeMode: 'contain',\n        // tintColor: color,\n        flex: size === undefined ? 1 : undefined,\n      },\n      style,\n    ];\n\n    let icon = Assets.icons[color][name + '.png'];\n    if (active && Assets.icons[color][name + '-on' + '.png']) {\n      icon = Assets.icons[color][name + '-on' + '.png'];\n    } else if (Assets.icons[color][name + '-off' + '.png']) {\n      icon = Assets.icons[color][name + '-off' + '.png'];\n    }\n    return <Image source={icon} style={colorStyle} {...props} />;\n  }\n}\n\n'Instagram/components/FeedDisplayOptionButton.js'\n:import React from 'react';\nimport { TouchableHighlight, View } from 'react-native';\n\nimport InstaIcon from './InstaIcon';\n\nexport class FeedDisplayOptionButton extends React.Component {\n  render() {\n    const { icon, onPress, selected } = this.props;\n    return (\n      <TouchableHighlight\n        underlayColor={'rgba(0,0,0,0.02)'}\n        onPress={onPress}\n        style={{ flex: 1 }}\n      >\n        <View\n          style={{\n            flex: 1,\n            marginTop: 8,\n            justifyContent: 'center',\n            alignItems: 'center',\n            opacity: selected ? 1 : 0.5,\n          }}\n        >\n          <InstaIcon size={32} color={'black'} name={icon} />\n        </View>\n      </TouchableHighlight>\n    );\n  }\n}\n\n'Instagram/components/FeedDisplayRow.js'\n:import React from 'react';\nimport { StyleSheet, View } from 'react-native';\n\nimport { FeedDisplayOptionButton } from './FeedDisplayOptionButton';\n\nexport const DISPLAY_FORMATS = ['grid', 'list', 'tag-user'];\n\nexport default class FeedDisplayRow extends React.Component {\n  render() {\n    const { onSelect, selected } = this.props;\n    return (\n      <View style={styles.row}>\n        {DISPLAY_FORMATS.map(tag => {\n          return (\n            <FeedDisplayOptionButton\n              icon={tag}\n              selected={tag === selected}\n              key={tag}\n              onPress={() => onSelect(tag)}\n            />\n          );\n        })}\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  row: {\n    flexDirection: 'row',\n    marginBottom: 8,\n    paddingHorizontal: 12,\n    borderTopWidth: StyleSheet.hairlineWidth,\n    borderTopColor: 'rgba(0,0,0,0.3)',\n    height: 48,\n  },\n});\n\n",
        "called_code_segment_file_1": "render() {\n    const { name, active, disabled, size, color = 'white', style, ...props } = this.props;\n    if (!name) {\n      return null;\n    }\n    const colorStyle = [\n      {\n        opacity: disabled ? 0.5 : 1,\n        width: size,\n        height: size,\n        resizeMode: 'contain',\n        flex: size === undefined ? 1 : undefined,\n      },\n      style,\n    ];\n\n    let icon = Assets.icons[color][name + '.png'];\n    if (active && Assets.icons[color][name + '-on' + '.png']) {\n      icon = Assets.icons[color][name + '-on' + '.png'];\n    } else if (Assets.icons[color][name + '-off' + '.png']) {\n      icon = Assets.icons[color][name + '-off' + '.png'];\n    }\n    return <Image source={icon} style={colorStyle} {...props} />;\n  }",
        "invoking_code_segment_file_2": "render() {\n    const { icon, onPress, selected } = this.props;\n    return (\n      <TouchableHighlight\n        underlayColor={'rgba(0,0,0,0.02)'}\n        onPress={onPress}\n        style={{ flex: 1 }}\n      >\n        <View\n          style={{ flex: 1, marginTop: 8, justifyContent: 'center', alignItems: 'center', opacity: selected ? 1 : 0.5 }}\n        >\n          <InstaIcon size={32} color={'black'} name={icon} />\n        </View>\n      </TouchableHighlight>\n    );\n  }",
        "called_code_segment_file_2": "render() {\n    const { onSelect, selected } = this.props;\n    return (\n      <View style={styles.row}>\n        {DISPLAY_FORMATS.map(tag => {\n          return (\n            <FeedDisplayOptionButton\n              icon={tag}\n              selected={tag === selected}\n              key={tag}\n              onPress={() => onSelect(tag)}\n            />\n          );\n        })}\n      </View>\n    );\n  }",
        "using_code_segment_file_3": "render() {\n    const { onSelect, selected } = this.props;\n    return (\n      <View style={styles.row}>\n        {DISPLAY_FORMATS.map(tag => {\n          return (\n            <FeedDisplayOptionButton\n              icon={tag}\n              selected={tag === selected}\n              key={tag}\n              onPress={() => onSelect(tag)}\n            />\n          );\n        })}\n      </View>\n    );\n  }",
        "feature_description": "Add a new feature to toggle the icon color between black and white based on the selected state.",
        "detailed_feature_description": "Modify the InstaIcon component in #file 1 to accept a new prop 'selectedColor' which will be used to change the icon color when the icon is selected. Update the FeedDisplayOptionButton in #file 2 to pass the 'selectedColor' prop to InstaIcon based on the 'selected' state. Ensure that the FeedDisplayRow in #file 3 remains unchanged as it already handles the 'selected' state correctly.",
        "modified_complete_code": {
            "file_1": "// Instagram/components/InstaIcon.js\n:import React from 'react';\nimport { Image } from 'react-native';\n\nimport Assets from '../Assets';\n\nexport default class InstaIcon extends React.PureComponent {\n  render() {\n    const { name, active, disabled, size, color = 'white', selectedColor, style, ...props } = this.props;\n    if (!name) {\n      return null;\n    }\n    const colorStyle = [\n      {\n        opacity: disabled ? 0.5 : 1,\n        width: size,\n        height: size,\n        resizeMode: 'contain',\n        flex: size === undefined ? 1 : undefined,\n      },\n      style,\n    ];\n\n    let icon = Assets.icons[color][name + '.png'];\n    if (active && Assets.icons[color][name + '-on' + '.png']) {\n      icon = Assets.icons[color][name + '-on' + '.png'];\n    } else if (Assets.icons[color][name + '-off' + '.png']) {\n      icon = Assets.icons[color][name + '-off' + '.png'];\n    }\n    // Modify\n    const finalColor = active ? selectedColor : color;\n    return <Image source={Assets.icons[finalColor][name + '.png']} style={colorStyle} {...props} />;\n  }\n}",
            "file_2": "// Instagram/components/FeedDisplayOptionButton.js\n:import React from 'react';\nimport { TouchableHighlight, View } from 'react-native';\n\nimport InstaIcon from './InstaIcon';\n\nexport class FeedDisplayOptionButton extends React.Component {\n  render() {\n    const { icon, onPress, selected } = this.props;\n    return (\n      <TouchableHighlight\n        underlayColor={'rgba(0,0,0,0.02)'}\n        onPress={onPress}\n        style={{ flex: 1 }}\n      >\n        <View\n          style={{ flex: 1, marginTop: 8, justifyContent: 'center', alignItems: 'center', opacity: selected ? 1 : 0.5 }}\n        >\n          // Modify\n          <InstaIcon size={32} color={selected ? 'white' : 'black'} selectedColor={'white'} name={icon} />\n        </View>\n      </TouchableHighlight>\n    );\n  }\n}",
            "file_3": "// Instagram/components/FeedDisplayRow.js\n:import React from 'react';\nimport { StyleSheet, View } from 'react-native';\n\nimport { FeedDisplayOptionButton } from './FeedDisplayOptionButton';\n\nexport const DISPLAY_FORMATS = ['grid', 'list', 'tag-user'];\n\nexport default class FeedDisplayRow extends React.Component {\n  render() {\n    const { onSelect, selected } = this.props;\n    return (\n      <View style={styles.row}>\n        {DISPLAY_FORMATS.map(tag => {\n          return (\n            <FeedDisplayOptionButton\n              icon={tag}\n              selected={tag === selected}\n              key={tag}\n              onPress={() => onSelect(tag)}\n            />\n          );\n        })}\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  row: {\n    flexDirection: 'row',\n    marginBottom: 8,\n    paddingHorizontal: 12,\n    borderTopWidth: StyleSheet.hairlineWidth,\n    borderTopColor: 'rgba(0,0,0,0.3)',\n    height: 48,\n  },\n});"
        }
    },
    {
        "repo": "Next-GraphQL-Blog",
        "content": "'Next-GraphQL-Blog/server/db/models/User.js'\n:import mongoose from 'mongoose'\n\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  // Don't return password unless specified to\n  password: {\n    type: String,\n    select: false\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User\n\n'Next-GraphQL-Blog/server/auth/google.js'\n:var passport = require('passport')\nvar GoogleStrategy = require('passport-google-oauth').OAuth2Strategy\nimport jwt from 'jsonwebtoken'\n\nconst dev = process.env.NODE_ENV !== 'production'\n\nimport User from '../db/models/User'\n\nexport default server => {\n  passport.use(\n    new GoogleStrategy(\n      {\n        clientID: process.env.GOOGLE_CLIENT_ID,\n        clientSecret: process.env.GOOGLE_SECRET_ID,\n        callbackURL: dev\n          ? `${process.env.ROOT_URL_DEV}/auth/googlecallback`\n          : `${process.env.ROOT_URL_PROD}/auth/googlecallback`\n      },\n      async (accessToken, refreshToken, profile, done) => {\n        const name =\n          profile.displayName || profile.name\n            ? `${profile.name.givenName} ${profile.name.familyName}`\n            : ''\n\n        const email =\n          (profile.emails &&\n            profile.emails.length > 0 &&\n            profile.emails[0].value) ||\n          null\n\n        const googleId = profile.id\n\n        try {\n          let user = await User.findOne({ googleId }).exec()\n\n          if (user) {\n            return done(null, user)\n          }\n\n          const emailExist = await User.findOne({ email }).exec()\n\n          if (emailExist) {\n            return done('Email already exists')\n          }\n\n          user = await User.create({\n            email,\n            name,\n            googleId\n          })\n\n          done(null, user)\n        } catch (err) {\n          console.log(err)\n          done(err)\n        }\n      }\n    )\n  )\n\n  passport.serializeUser((user, done) => {\n    done(null, user.id)\n  })\n\n  passport.deserializeUser((id, done) => {\n    User.findById({ _id: id }, (err, user) => {\n      done(err, user)\n    })\n  })\n\n  server.get('/auth/google', (req, res) => {\n    passport.authenticate('google', {\n      scope: ['profile', 'email'],\n      prompt: 'select_account'\n    })(req, res)\n  })\n\n  server.get(\n    '/auth/googlecallback',\n    passport.authenticate('google', {\n      session: false,\n      failureRedirect: dev\n        ? `${process.env.CLIENT_URL_DEV}/login`\n        : `${process.env.CLIENT_URL_PROD}/login`\n    }),\n    (req, res) => {\n      const token = jwt.sign({ userId: req.user._id }, process.env.AUTH_SECRET)\n      console.log(token)\n      res.redirect(\n        dev\n          ? `${process.env.CLIENT_URL_DEV}/authcallback?token=${token}`\n          : `${process.env.CLIENT_URL_PROD}/authcallback?token=${token}`\n      )\n    }\n  )\n}\n\n'Next-GraphQL-Blog/server/index.js'\n:require('dotenv').config()\n\nimport { GraphQLServer, PubSub } from 'graphql-yoga'\nimport cors from 'cors'\nimport cookieParser from 'cookie-parser'\nimport depthLimit from 'graphql-depth-limit'\nimport helmet from 'helmet'\nimport compression from 'compression'\n\nimport initGoogleAuth from './auth/google'\nimport passport from 'passport'\nimport resolvers from './resolvers'\nimport typeDefs from './types'\nimport db from './db'\nimport { initUser } from './utils'\nimport createLoaders from './loaders'\n\nconst dev = process.env.NODE_ENV !== 'production'\n\nconst startServer = async () => {\n  const initDB = await db()\n\n  const pubsub = new PubSub()\n\n  const server = new GraphQLServer({\n    typeDefs,\n    resolvers,\n    context: async req => ({\n      ...req,\n      pubsub,\n      loaders: createLoaders(),\n      user: initUser(req),\n      db: initDB\n    }),\n    validationRules: [depthLimit(10)]\n  })\n\n  server.express.use(compression())\n  server.express.use(helmet())\n  server.express.use(cookieParser())\n\n  const ONE_YEAR = 31556952000\n\n  if (!dev) {\n    server.express.set('trust proxy', 1)\n  }\n\n  server.express.use(passport.initialize())\n\n  initGoogleAuth(server.express)\n\n  const corsOptions = {\n    origin: dev ? process.env.CLIENT_URL_DEV : process.env.CLIENT_URL_PROD,\n    credentials: true\n  }\n\n  //option object for graphql yoga\n  const port = parseInt(process.env.PORT, 10) || 4000\n  const options = {\n    port,\n    cors: corsOptions\n  }\n\n  server.start(options, ({ port }) =>\n    console.log(\n      `Server started, listening on port ${port} for incoming requests. [${\n        process.env.NODE_ENV\n      }]`\n    )\n  )\n}\n\nstartServer()\n\n",
        "called_code_segment_file_1": "const userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  password: {\n    type: String,\n    select: false\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User",
        "invoking_code_segment_file_2": "const name = profile.displayName || profile.name ? `${profile.name.givenName} ${profile.name.familyName}` : ''\n\nconst email = (profile.emails && profile.emails.length > 0 && profile.emails[0].value) || null\n\nconst googleId = profile.id\n\ntry {\n  let user = await User.findOne({ googleId }).exec()\n\n  if (user) {\n    return done(null, user)\n  }\n\n  const emailExist = await User.findOne({ email }).exec()\n\n  if (emailExist) {\n    return done('Email already exists')\n  }\n\n  user = await User.create({\n    email,\n    name,\n    googleId\n  })\n\n  done(null, user)\n} catch (err) {\n  console.log(err)\n  done(err)\n}",
        "called_code_segment_file_2": "server.get('/auth/google', (req, res) => {\n  passport.authenticate('google', {\n    scope: ['profile', 'email'],\n    prompt: 'select_account'\n  })(req, res)\n})",
        "using_code_segment_file_3": "server.express.use(passport.initialize())",
        "feature_description": "Add a new field 'username' to the User schema and ensure it is populated during Google authentication.",
        "detailed_feature_description": "Modify the User schema in #file 1 to include a new 'username' field. Update the Google authentication logic in #file 2 to populate this new field when creating a new user. Ensure that #file 3 initializes passport correctly to handle the new field.",
        "modified_complete_code": {
            "#file 1": "const userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  password: {\n    type: String,\n    select: false\n  },\n  #Modify username: {\n    type: String,\n    required: true,\n    unique: true\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User",
            "#file 2": "const name = profile.displayName || profile.name ? `${profile.name.familyName} ${profile.name.givenName}` : ''\n\nconst email = (profile.emails && profile.emails.length > 0 && profile.emails[0].value) || null\n\nconst googleId = profile.id\n\n#Modify const username = profile.displayName.replace(/\\s+/g, '').toLowerCase()\n\ntry {\n  let user = await User.findOne({ googleId }).exec()\n\n  if (user) {\n    return done(null, user)\n  }\n\n  const emailExist = await User.findOne({ email }).exec()\n\n  if (emailExist) {\n    return done('Email already exists')\n  }\n\n  user = await User.create({\n    email,\n    name,\n    googleId,\n    #Modify username\n  })\n\n  done(null, user)\n} catch (err) {\n  console.log(err)\n  done(err)\n}\n\nserver.get('/auth/google', (req, res) => {\n  passport.authenticate('google', {\n    scope: ['profile', 'email'],\n    prompt: 'select_account'\n  })(req, res)\n})",
            "#file 3": "server.express.use(compression())\nserver.express.use(helmet())\nserver.express.use(cookieParser())\n\nconst ONE_YEAR = 31556952000\n\nif (!dev) {\n  server.express.set('trust proxy', 1)\n}\n\nserver.express.use(passport.initialize())\n\ninitGoogleAuth(server.express)\n\nconst corsOptions = {\n  origin: dev ? process.env.CLIENT_URL_DEV : process.env.CLIENT_URL_PROD,\n  credentials: true\n}\n\nconst port = parseInt(process.env.PORT, 10) || 4000\nconst options = {\n  port,\n  cors: corsOptions\n}\n\nserver.start(options, ({ port }) =>\n  console.log(\n    `Server started, listening on port ${port} for incoming requests. [${process.env.NODE_ENV}]`\n  )\n)"
        }
    },
    {
        "repo": "PERN-STACK-DEPLOYMENT",
        "content": "'PERN-STACK-DEPLOYMENT/client/src/context/RestaurantsContext.js'\n:import React, { useState, createContext } from \"react\";\n\nexport const RestaurantsContext = createContext();\n\nexport const RestaurantsContextProvider = (props) => {\n  const [restaurants, setRestaurants] = useState([]);\n  const [selectedRestaurant, setSelectedRestaurant] = useState(null);\n\n  const addRestaurants = (restaurant) => {\n    setRestaurants([...restaurants, restaurant]);\n  };\n  return (\n    <RestaurantsContext.Provider\n      value={{\n        restaurants,\n        setRestaurants,\n        addRestaurants,\n        selectedRestaurant,\n        setSelectedRestaurant,\n      }}\n    >\n      {props.children}\n    </RestaurantsContext.Provider>\n  );\n};\n\n'PERN-STACK-DEPLOYMENT/client/src/App.jsx'\n:import React from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Home from \"./routes/Home\";\nimport UpdatePage from \"./routes/UpdatePage\";\nimport RestaurantDetailPage from \"./routes/RestaurantDetailPage\";\nimport { RestaurantsContextProvider } from \"./context/RestaurantsContext\";\nconst App = () => {\n  return (\n    <RestaurantsContextProvider>\n      <div className=\"container\">\n        <Router>\n          <Switch>\n            <Route exact path=\"/\" component={Home} />\n            <Route\n              exact\n              path=\"/restaurants/:id/update\"\n              component={UpdatePage}\n            />\n            <Route\n              exact\n              path=\"/restaurants/:id\"\n              component={RestaurantDetailPage}\n            />\n          </Switch>\n        </Router>\n      </div>\n    </RestaurantsContextProvider>\n  );\n};\n\nexport default App;\n\n'PERN-STACK-DEPLOYMENT/client/src/index.js'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n",
        "called_code_segment_file_1": "const addRestaurants = (restaurant) => { setRestaurants([...restaurants, restaurant]); };",
        "invoking_code_segment_file_2": "<RestaurantsContextProvider> <div className=\"container\"> <Router> <Switch> <Route exact path=\"/\" component={Home} /> <Route exact path=\"/restaurants/:id/update\" component={UpdatePage} /> <Route exact path=\"/restaurants/:id\" component={RestaurantDetailPage} /> </Switch> </Router> </div> </RestaurantsContextProvider>",
        "called_code_segment_file_2": "const { addRestaurants } = useContext(RestaurantsContext);",
        "using_code_segment_file_3": "addRestaurants(newRestaurant);",
        "feature_description": "Add a feature to update the restaurant list in the context when a new restaurant is added.",
        "detailed_feature_description": "The new feature involves modifying the addRestaurants function in the RestaurantsContext to also update the selectedRestaurant state if the newly added restaurant matches the selected one. This ensures that the context state is always up-to-date with the latest restaurant data. The UpdatePage component will use this updated context to reflect any changes immediately.",
        "modified_complete_code": {
            "#file 1": "//Modify const addRestaurants = (restaurant) => { setRestaurants([...restaurants, restaurant]); if (selectedRestaurant && selectedRestaurant.id === restaurant.id) { setSelectedRestaurant(restaurant); } };",
            "#file 2": "//Modify const { addRestaurants } = useContext(RestaurantsContext); //New const updateSelectedRestaurant = (restaurant) => { setSelectedRestaurant(restaurant); };",
            "#file 3": "//Modify addRestaurants(newRestaurant); //New if (selectedRestaurant && selectedRestaurant.id === newRestaurant.id) { updateSelectedRestaurant(newRestaurant); }"
        }
    },
    {
        "repo": "React-Native-Reflective-UI",
        "content": "'React-Native-Reflective-UI/components/Story.jsx'\n:import { StyleSheet, View } from 'react-native';\nimport React from 'react';\n\nimport { SCREEN_WIDTH } from '../utils/dimensions';\n\nconst size = SCREEN_WIDTH / 4 - 10;\n\nconst Story = () => {\n return (\n  <View style={styles.storyContainer}>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n  </View>\n );\n};\n\nexport default Story;\n\nconst styles = StyleSheet.create({\n storyContainer: {\n  flexDirection: 'row',\n  justifyContent: 'space-evenly',\n  marginBottom: 10,\n },\n userPhoto: {\n  width: size,\n  height: size,\n  borderRadius: size,\n  borderColor: 'white',\n  borderWidth: 3,\n  marginRight: 0,\n },\n});\n\n'React-Native-Reflective-UI/App.js'\n:import { useFonts } from 'expo-font';\nimport { BlurView } from '@react-native-community/blur';\n\nimport React, { useEffect } from 'react';\nimport {\n Alert,\n Linking,\n Platform,\n ScrollView,\n StatusBar,\n StyleSheet,\n View,\n} from 'react-native';\nimport MaskedView from '@react-native-masked-view/masked-view';\n\nimport { Camera, CameraType } from 'expo-camera';\n\nimport Tabs from './components/Tabs';\nimport Post from './components/Post';\nimport Header from './components/Header';\nimport Story from './components/Story';\n\nif (Platform.OS === 'android') {\n StatusBar.setTranslucent(true);\n StatusBar.setBackgroundColor('transparent');\n}\n\nconst usersArray = [\n {\n  name: 'Nika Gabunia',\n  role: 'Chief Executive Officer',\n },\n {\n  name: 'Jeko Tediashvili',\n  role: 'Web/Mobile Developer',\n },\n {\n  name: 'Niko Chopikashvili',\n  role: 'NodeJS Developer',\n },\n {\n  name: 'Alexander Pataridze',\n  role: 'Junior Developer',\n },\n {\n  name: 'Miranda Pagava',\n  role: 'Project Manager',\n },\n {\n  name: 'Nika Kereselidze',\n  role: 'NodeJS Developer',\n },\n];\n\nconst App = () => {\n const [fontsLoaded] = useFonts({\n  MontserratRegular: require('./assets/fonts/Montserrat-Regular.ttf'),\n  MontserratBold: require('./assets/fonts/Montserrat-Bold.ttf'),\n });\n\n const [permission, requestPermission] = Camera.useCameraPermissions();\n\n const goToSettings = () =>\n  Alert.alert(\n   '',\n   'You do not have a camera permission. Go to application settings and enable it manually.',\n   [\n    {\n     text: 'Not right now',\n     onPress: () => console.log('Cancel Pressed'),\n     style: 'cancel',\n    },\n    {\n     text: 'Go to settings',\n     onPress: () => Linking.openSettings(),\n    },\n   ]\n  );\n\n useEffect(() => {\n  requestPermission();\n }, []);\n\n useEffect(() => {\n  if (permission && !permission.granted) {\n   goToSettings();\n  }\n }, [permission]);\n\n if (fontsLoaded) {\n  return (\n   <View style={styles.screenContainer}>\n    {permission.granted && (\n     <MaskedView\n      style={styles.maskViewStyle}\n      maskElement={\n       <>\n        <Header />\n        <Story />\n\n        {usersArray.map((user, i) => (\n         <Post key={i} user={user} />\n        ))}\n\n        <Tabs />\n       </>\n      }>\n      <Camera style={{ flex: 1 }} ratio='16:9' type={CameraType.back}></Camera>\n      <BlurView\n       style={styles.blurViewStyle}\n       blurType='light'\n       blurAmount={20}\n       reducedTransparencyFallbackColor='white'\n      />\n     </MaskedView>\n    )}\n   </View>\n  );\n }\n\n return null;\n};\n\nexport default App;\n\nconst styles = StyleSheet.create({\n screenContainer: {\n  flex: 1,\n  backgroundColor: 'black',\n },\n maskViewStyle: {\n  flex: 1,\n  flexDirection: 'row',\n },\n blurViewStyle: {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0,\n  flex: 1,\n  display: Platform.OS === 'android' ? 'none' : 'flex',\n },\n});\n\n'React-Native-Reflective-UI/index.js'\n:import { registerRootComponent } from 'expo';\n\nimport App from './App';\n\n// registerRootComponent calls AppRegistry.registerComponent('main', () => App);\n// It also ensures that whether you load the app in Expo Go or in a native build,\n// the environment is set up appropriately\nregisterRootComponent(App);\n\n",
        "called_code_segment_file_1": "const Story = () => {\n return (\n  <View style={styles.storyContainer}>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n  </View>\n );\n};",
        "invoking_code_segment_file_2": "<Story />",
        "called_code_segment_file_2": "const Post = ({ user }) => {\n return (\n  <View style={styles.postContainer}>\n   <View style={styles.userInfo}>\n    <Text style={styles.userName}>{user.name}</Text>\n    <Text style={styles.userRole}>{user.role}</Text>\n   </View>\n  </View>\n );\n};",
        "using_code_segment_file_3": "usersArray.map((user, i) => (\n <Post key={i} user={user} />\n))",
        "feature_description": "Add a new feature to display user avatars in the Story component.",
        "detailed_feature_description": "Modify the Story component to display user avatars instead of empty views. Update the Post component to include a user avatar and ensure the App component handles the new avatar display correctly.",
        "modified_complete_code": {
            "file_1": "const Story = () => {\n return (\n  <View style={styles.storyContainer}>\n   {usersArray.map((user, i) => (\n    <Image key={i} source={{ uri: user.avatar }} style={styles.userPhoto} />\n   ))}\n  </View>\n );\n};\n\n#Modify const styles = StyleSheet.create({\n storyContainer: {\n  flexDirection: 'row',\n  justifyContent: 'space-evenly',\n  marginBottom: 10,\n },\n userPhoto: {\n  width: size,\n  height: size,\n  borderRadius: size,\n  borderColor: 'white',\n  borderWidth: 3,\n  marginRight: 0,\n },\n});",
            "file_2": "const Post = ({ user }) => {\n return (\n  <View style={styles.postContainer}>\n   <View style={styles.userInfo}>\n    <Image source={{ uri: user.avatar }} style={styles.userAvatar} />\n    <Text style={styles.userName}>{user.name}</Text>\n    <Text style={styles.userRole}>{user.role}</Text>\n   </View>\n  </View>\n );\n};\n\n#Modify const styles = StyleSheet.create({\n postContainer: {\n  marginBottom: 20,\n },\n userInfo: {\n  flexDirection: 'row',\n  alignItems: 'center',\n },\n userAvatar: {\n  width: 50,\n  height: 50,\n  borderRadius: 25,\n  marginRight: 10,\n },\n userName: {\n  fontFamily: 'MontserratBold',\n  fontSize: 16,\n },\n userRole: {\n  fontFamily: 'MontserratRegular',\n  fontSize: 14,\n },\n});",
            "file_3": "const usersArray = [\n {\n  name: 'Nika Gabunia',\n  role: 'Chief Executive Officer',\n  avatar: 'https://example.com/avatar1.jpg',\n },\n {\n  name: 'Jeko Tediashvili',\n  role: 'Web/Mobile Developer',\n  avatar: 'https://example.com/avatar2.jpg',\n },\n {\n  name: 'Niko Chopikashvili',\n  role: 'NodeJS Developer',\n  avatar: 'https://example.com/avatar3.jpg',\n },\n {\n  name: 'Alexander Pataridze',\n  role: 'Junior Developer',\n  avatar: 'https://example.com/avatar4.jpg',\n },\n {\n  name: 'Miranda Pagava',\n  role: 'Project Manager',\n  avatar: 'https://example.com/avatar5.jpg',\n },\n {\n  name: 'Nika Kereselidze',\n  role: 'NodeJS Developer',\n  avatar: 'https://example.com/avatar6.jpg',\n },\n];\n\n#Modify usersArray.map((user, i) => (\n <Post key={i} user={user} />\n))"
        }
    },
    {
        "repo": "Sorting-Visualizer-Tutorial",
        "content": "'Sorting-Visualizer-Tutorial/src/SortingVisualizer/SortingVisualizer.jsx'\n:import React from 'react';\nimport {getMergeSortAnimations} from '../sortingAlgorithms/sortingAlgorithms.js';\nimport './SortingVisualizer.css';\n\n// Change this value for the speed of the animations.\nconst ANIMATION_SPEED_MS = 1;\n\n// Change this value for the number of bars (value) in the array.\nconst NUMBER_OF_ARRAY_BARS = 310;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = 'turquoise';\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = 'red';\n\nexport default class SortingVisualizer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      array: [],\n    };\n  }\n\n  componentDidMount() {\n    this.resetArray();\n  }\n\n  resetArray() {\n    const array = [];\n    for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n      array.push(randomIntFromInterval(5, 730));\n    }\n    this.setState({array});\n  }\n\n  mergeSort() {\n    const animations = getMergeSortAnimations(this.state.array);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName('array-bar');\n      const isColorChange = i % 3 !== 2;\n      if (isColorChange) {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n\n  quickSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  heapSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  bubbleSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  // NOTE: This method will only work if your sorting algorithms actually return\n  // the sorted arrays; if they return the animations (as they currently do), then\n  // this method will be broken.\n  testSortingAlgorithms() {\n    for (let i = 0; i < 100; i++) {\n      const array = [];\n      const length = randomIntFromInterval(1, 1000);\n      for (let i = 0; i < length; i++) {\n        array.push(randomIntFromInterval(-1000, 1000));\n      }\n      const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\n      const mergeSortedArray = getMergeSortAnimations(array.slice());\n      console.log(arraysAreEqual(javaScriptSortedArray, mergeSortedArray));\n    }\n  }\n\n  render() {\n    const {array} = this.state;\n\n    return (\n      <div className=\"array-container\">\n        {array.map((value, idx) => (\n          <div\n            className=\"array-bar\"\n            key={idx}\n            style={{\n              backgroundColor: PRIMARY_COLOR,\n              height: `${value}px`,\n            }}></div>\n        ))}\n        <button onClick={() => this.resetArray()}>Generate New Array</button>\n        <button onClick={() => this.mergeSort()}>Merge Sort</button>\n        <button onClick={() => this.quickSort()}>Quick Sort</button>\n        <button onClick={() => this.heapSort()}>Heap Sort</button>\n        <button onClick={() => this.bubbleSort()}>Bubble Sort</button>\n        <button onClick={() => this.testSortingAlgorithms()}>\n          Test Sorting Algorithms (BROKEN)\n        </button>\n      </div>\n    );\n  }\n}\n\n// From https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction arraysAreEqual(arrayOne, arrayTwo) {\n  if (arrayOne.length !== arrayTwo.length) return false;\n  for (let i = 0; i < arrayOne.length; i++) {\n    if (arrayOne[i] !== arrayTwo[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n'Sorting-Visualizer-Tutorial/src/App.js'\n:import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n\n'Sorting-Visualizer-Tutorial/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n",
        "called_code_segment_file_1": "function randomIntFromInterval(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}",
        "invoking_code_segment_file_2": "resetArray() {\n  const array = [];\n  for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n    array.push(randomIntFromInterval(5, 730));\n  }\n  this.setState({array});\n}",
        "called_code_segment_file_2": "mergeSort() {\n  const animations = getMergeSortAnimations(this.state.array);\n  for (let i = 0; i < animations.length; i++) {\n    const arrayBars = document.getElementsByClassName('array-bar');\n    const isColorChange = i % 3 !== 2;\n    if (isColorChange) {\n      const [barOneIdx, barTwoIdx] = animations[i];\n      const barOneStyle = arrayBars[barOneIdx].style;\n      const barTwoStyle = arrayBars[barTwoIdx].style;\n      const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n      setTimeout(() => {\n        barOneStyle.backgroundColor = color;\n        barTwoStyle.backgroundColor = color;\n      }, i * ANIMATION_SPEED_MS);\n    } else {\n      setTimeout(() => {\n        const [barOneIdx, newHeight] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        barOneStyle.height = `${newHeight}px`;\n      }, i * ANIMATION_SPEED_MS);\n    }\n  }\n}",
        "using_code_segment_file_3": "ReactDOM.render(<App />, document.getElementById('root'));",
        "feature_description": "Add a new feature to generate arrays with a specified range of values.",
        "detailed_feature_description": "Modify the `randomIntFromInterval` function in `#file 1` to accept an additional parameter for the range. Update the `resetArray` function in `#file 2` to use this new parameter. Ensure that the `mergeSort` function in `#file 2` and the `ReactDOM.render` in `#file 3` remain unaffected by these changes.",
        "modified_complete_code": {
            "#file 1": "function randomIntFromInterval(min, max, range) {\n  return Math.floor(Math.random() * (range + 1) + min);\n} #Modify",
            "#file 2": "resetArray(range = 725) {\n  const array = [];\n  for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n    array.push(randomIntFromInterval(5, 730, range));\n  }\n  this.setState({array});\n} #Modify\n\nmergeSort() {\n  const animations = getMergeSortAnimations(this.state.array);\n  for (let i = 0; i < animations.length; i++) {\n    const arrayBars = document.getElementsByClassName('array-bar');\n    const isColorChange = i % 3 !== 2;\n    if (isColorChange) {\n      const [barOneIdx, barTwoIdx] = animations[i];\n      const barOneStyle = arrayBars[barOneIdx].style;\n      const barTwoStyle = arrayBars[barTwoIdx].style;\n      const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n      setTimeout(() => {\n        barOneStyle.backgroundColor = color;\n        barTwoStyle.backgroundColor = color;\n      }, i * ANIMATION_SPEED_MS);\n    } else {\n      setTimeout(() => {\n        const [barOneIdx, newHeight] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        barOneStyle.height = `${newHeight}px`;\n      }, i * ANIMATION_SPEED_MS);\n    }\n  }\n}",
            "#file 3": "ReactDOM.render(<App />, document.getElementById('root'));"
        }
    },
    {
        "repo": "ThreeJS-Webpack-ES6-Boilerplate",
        "content": "'ThreeJS-Webpack-ES6-Boilerplate/src/js/app/components/renderer.js'\n:import * as THREE from 'three';\n\nimport Config from '../../data/config';\n\n// Main webGL renderer class\nexport default class Renderer {\n  constructor(scene, container) {\n    // Properties\n    this.scene = scene;\n    this.container = container;\n\n    // Create WebGL renderer and set its antialias\n    this.threeRenderer = new THREE.WebGLRenderer({antialias: true});\n\n    // Set clear color to fog to enable fog or to hex color for no fog\n    this.threeRenderer.setClearColor(scene.fog.color);\n    this.threeRenderer.setPixelRatio(window.devicePixelRatio); // For retina\n\n    // Appends canvas\n    container.appendChild(this.threeRenderer.domElement);\n\n    // Shadow map options\n    this.threeRenderer.shadowMap.enabled = true;\n    this.threeRenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n    // Get anisotropy for textures\n    Config.maxAnisotropy = this.threeRenderer.capabilities.getMaxAnisotropy();\n\n    // Initial size update set to canvas container\n    this.updateSize();\n\n    // Listeners\n    document.addEventListener('DOMContentLoaded', () => this.updateSize(), false);\n    window.addEventListener('resize', () => this.updateSize(), false);\n  }\n\n  updateSize() {\n    this.threeRenderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n  }\n\n  render(scene, camera) {\n    // Renders scene to canvas target\n    this.threeRenderer.render(scene, camera);\n  }\n}\n\n'ThreeJS-Webpack-ES6-Boilerplate/src/js/app/main.js'\n:// Global imports -\nimport * as THREE from 'three';\nimport TWEEN from '@tweenjs/tween.js';\n\n// Local imports -\n// Components\nimport Renderer from './components/renderer';\nimport Camera from './components/camera';\nimport Light from './components/light';\nimport Controls from './components/controls';\nimport Geometry from './components/geometry';\n\n// Helpers\nimport Stats from './helpers/stats';\nimport MeshHelper from './helpers/meshHelper';\n\n// Model\nimport Texture from './model/texture';\nimport Model from './model/model';\n\n// Managers\nimport Interaction from './managers/interaction';\nimport DatGUI from './managers/datGUI';\n\n// data\nimport Config from './../data/config';\n// -- End of imports\n\n// This class instantiates and ties all of the components together, starts the loading process and renders the main loop\nexport default class Main {\n  constructor(container) {\n    // Set container property to container element\n    this.container = container;\n\n    // Start Three clock\n    this.clock = new THREE.Clock();\n\n    // Main scene creation\n    this.scene = new THREE.Scene();\n    this.scene.fog = new THREE.FogExp2(Config.fog.color, Config.fog.near);\n\n    // Get Device Pixel Ratio first for retina\n    if(window.devicePixelRatio) {\n      Config.dpr = window.devicePixelRatio;\n    }\n\n    // Main renderer constructor\n    this.renderer = new Renderer(this.scene, container);\n\n    // Components instantiations\n    this.camera = new Camera(this.renderer.threeRenderer);\n    this.controls = new Controls(this.camera.threeCamera, container);\n    this.light = new Light(this.scene);\n\n    // Create and place lights in scene\n    const lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach((light) => this.light.place(light));\n\n    // Create and place geo in scene\n    this.geometry = new Geometry(this.scene);\n    this.geometry.make('plane')(150, 150, 10, 10);\n    this.geometry.place([0, -20, 0], [Math.PI / 2, 0, 0]);\n\n    // Set up rStats if dev environment\n    if(Config.isDev && Config.isShowingStats) {\n      this.stats = new Stats(this.renderer);\n      this.stats.setUp();\n    }\n\n    // Set up gui\n    if (Config.isDev) {\n      this.gui = new DatGUI(this)\n    }\n\n    // Instantiate texture class\n    this.texture = new Texture();\n\n    // Start loading the textures and then go on to load the model after the texture Promises have resolved\n    this.texture.load().then(() => {\n      this.manager = new THREE.LoadingManager();\n\n      // Textures loaded, load model\n      this.model = new Model(this.scene, this.manager, this.texture.textures);\n      this.model.load(Config.models[Config.model.selected].type);\n\n      // onProgress callback\n      this.manager.onProgress = (item, loaded, total) => {\n        console.log(`${item}: ${loaded} ${total}`);\n      };\n\n      // All loaders done now\n      this.manager.onLoad = () => {\n        // Set up interaction manager with the app now that the model is finished loading\n        new Interaction(this.renderer.threeRenderer, this.scene, this.camera.threeCamera, this.controls.threeControls);\n\n        // Add dat.GUI controls if dev\n        if(Config.isDev) {\n          this.meshHelper = new MeshHelper(this.scene, this.model.obj);\n          if (Config.mesh.enableHelper) this.meshHelper.enable();\n\n          this.gui.load(this, this.model.obj);\n        }\n\n        // Everything is now fully loaded\n        Config.isLoaded = true;\n        this.container.querySelector('#loading').style.display = 'none';\n      };\n    });\n\n    // Start render which does not wait for model fully loaded\n    this.render();\n  }\n\n  render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }\n}\n\n'ThreeJS-Webpack-ES6-Boilerplate/src/js/app.js'\n:import Config from './data/config';\nimport Detector from './utils/detector';\nimport Main from './app/main';\n\n// Styles\nimport './../css/app.scss';\n\n// Check environment and set the Config helper\nif(__ENV__ === 'dev') {\n  console.log('----- RUNNING IN DEV ENVIRONMENT! -----');\n\n  Config.isDev = true;\n}\n\nfunction init() {\n  // Check for webGL capabilities\n  if(!Detector.webgl) {\n    Detector.addGetWebGLMessage();\n  } else {\n    const container = document.getElementById('appContainer');\n    new Main(container);\n  }\n}\n\ninit();\n\n",
        "called_code_segment_file_1": "render(scene, camera) { this.threeRenderer.render(scene, camera); }",
        "invoking_code_segment_file_2": "this.renderer.render(this.scene, this.camera.threeCamera);",
        "called_code_segment_file_2": "render() { this.renderer.render(this.scene, this.camera.threeCamera); }",
        "using_code_segment_file_3": "requestAnimationFrame(this.render.bind(this));",
        "feature_description": "Add a post-processing effect to the renderer.",
        "detailed_feature_description": "Modify the Renderer class in #file 1 to include a post-processing effect. Update the Main class in #file 2 to initialize and update this effect. Ensure the render loop in #file 3 accommodates the new post-processing setup.",
        "modified_complete_code": {
            "#file 1": "// Main webGL renderer class\nexport default class Renderer {\n  constructor(scene, container) {\n    // Properties\n    this.scene = scene;\n    this.container = container;\n\n    // Create WebGL renderer and set its antialias\n    this.threeRenderer = new THREE.WebGLRenderer({antialias: true});\n\n    // Set clear color to fog to enable fog or to hex color for no fog\n    this.threeRenderer.setClearColor(scene.fog.color);\n    this.threeRenderer.setPixelRatio(window.devicePixelRatio); // For retina\n\n    // Appends canvas\n    container.appendChild(this.threeRenderer.domElement);\n\n    // Shadow map options\n    this.threeRenderer.shadowMap.enabled = true;\n    this.threeRenderer.shadowMap.type = THREE.PCFSoftShadowMap;\n\n    // Get anisotropy for textures\n    Config.maxAnisotropy = this.threeRenderer.capabilities.getMaxAnisotropy();\n\n    // Initial size update set to canvas container\n    this.updateSize();\n\n    // Listeners\n    document.addEventListener('DOMContentLoaded', () => this.updateSize(), false);\n    window.addEventListener('resize', () => this.updateSize(), false);\n\n    // #Modify: Initialize post-processing\n    this.composer = new EffectComposer(this.threeRenderer);\n    this.composer.addPass(new RenderPass(scene, camera));\n    this.bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);\n    this.composer.addPass(this.bloomPass);\n  }\n\n  updateSize() {\n    this.threeRenderer.setSize(this.container.offsetWidth, this.container.offsetHeight);\n    this.composer.setSize(this.container.offsetWidth, this.container.offsetHeight); // #Modify: Update composer size\n  }\n\n  render(scene, camera) {\n    // Renders scene to canvas target\n    this.composer.render(); // #Modify: Use composer for rendering\n  }\n}",
            "#file 2": "export default class Main {\n  constructor(container) {\n    // Set container property to container element\n    this.container = container;\n\n    // Start Three clock\n    this.clock = new THREE.Clock();\n\n    // Main scene creation\n    this.scene = new THREE.Scene();\n    this.scene.fog = new THREE.FogExp2(Config.fog.color, Config.fog.near);\n\n    // Get Device Pixel Ratio first for retina\n    if(window.devicePixelRatio) {\n      Config.dpr = window.devicePixelRatio;\n    }\n\n    // Main renderer constructor\n    this.renderer = new Renderer(this.scene, container);\n\n    // Components instantiations\n    this.camera = new Camera(this.renderer.threeRenderer);\n    this.controls = new Controls(this.camera.threeCamera, container);\n    this.light = new Light(this.scene);\n\n    // Create and place lights in scene\n    const lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach((light) => this.light.place(light));\n\n    // Create and place geo in scene\n    this.geometry = new Geometry(this.scene);\n    this.geometry.make('plane')(150, 150, 10, 10);\n    this.geometry.place([0, -20, 0], [Math.PI / 2, 0, 0]);\n\n    // Set up rStats if dev environment\n    if(Config.isDev && Config.isShowingStats) {\n      this.stats = new Stats(this.renderer);\n      this.stats.setUp();\n    }\n\n    // Set up gui\n    if (Config.isDev) {\n      this.gui = new DatGUI(this)\n    }\n\n    // Instantiate texture class\n    this.texture = new Texture();\n\n    // Start loading the textures and then go on to load the model after the texture Promises have resolved\n    this.texture.load().then(() => {\n      this.manager = new THREE.LoadingManager();\n\n      // Textures loaded, load model\n      this.model = new Model(this.scene, this.manager, this.texture.textures);\n      this.model.load(Config.models[Config.model.selected].type);\n\n      // onProgress callback\n      this.manager.onProgress = (item, loaded, total) => {\n        console.log(`${item}: ${loaded} ${total}`);\n      };\n\n      // All loaders done now\n      this.manager.onLoad = () => {\n        // Set up interaction manager with the app now that the model is finished loading\n        new Interaction(this.renderer.threeRenderer, this.scene, this.camera.threeCamera, this.controls.threeControls);\n\n        // Add dat.GUI controls if dev\n        if(Config.isDev) {\n          this.meshHelper = new MeshHelper(this.scene, this.model.obj);\n          if (Config.mesh.enableHelper) this.meshHelper.enable();\n\n          this.gui.load(this, this.model.obj);\n        }\n\n        // Everything is now fully loaded\n        Config.isLoaded = true;\n        this.container.querySelector('#loading').style.display = 'none';\n      };\n    });\n\n    // Start render which does not wait for model fully loaded\n    this.render();\n  }\n\n  render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }\n}",
            "#file 3": "export default class Main {\n  constructor(container) {\n    // Set container property to container element\n    this.container = container;\n\n    // Start Three clock\n    this.clock = new THREE.Clock();\n\n    // Main scene creation\n    this.scene = new THREE.Scene();\n    this.scene.fog = new THREE.FogExp2(Config.fog.color, Config.fog.near);\n\n    // Get Device Pixel Ratio first for retina\n    if(window.devicePixelRatio) {\n      Config.dpr = window.devicePixelRatio;\n    }\n\n    // Main renderer constructor\n    this.renderer = new Renderer(this.scene, container);\n\n    // Components instantiations\n    this.camera = new Camera(this.renderer.threeRenderer);\n    this.controls = new Controls(this.camera.threeCamera, container);\n    this.light = new Light(this.scene);\n\n    // Create and place lights in scene\n    const lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach((light) => this.light.place(light));\n\n    // Create and place geo in scene\n    this.geometry = new Geometry(this.scene);\n    this.geometry.make('plane')(150, 150, 10, 10);\n    this.geometry.place([0, -20, 0], [Math.PI / 2, 0, 0]);\n\n    // Set up rStats if dev environment\n    if(Config.isDev && Config.isShowingStats) {\n      this.stats = new Stats(this.renderer);\n      this.stats.setUp();\n    }\n\n    // Set up gui\n    if (Config.isDev) {\n      this.gui = new DatGUI(this)\n    }\n\n    // Instantiate texture class\n    this.texture = new Texture();\n\n    // Start loading the textures and then go on to load the model after the texture Promises have resolved\n    this.texture.load().then(() => {\n      this.manager = new THREE.LoadingManager();\n\n      // Textures loaded, load model\n      this.model = new Model(this.scene, this.manager, this.texture.textures);\n      this.model.load(Config.models[Config.model.selected].type);\n\n      // onProgress callback\n      this.manager.onProgress = (item, loaded, total) => {\n        console.log(`${item}: ${loaded} ${total}`);\n      };\n\n      // All loaders done now\n      this.manager.onLoad = () => {\n        // Set up interaction manager with the app now that the model is finished loading\n        new Interaction(this.renderer.threeRenderer, this.scene, this.camera.threeCamera, this.controls.threeControls);\n\n        // Add dat.GUI controls if dev\n        if(Config.isDev) {\n          this.meshHelper = new MeshHelper(this.scene, this.model.obj);\n          if (Config.mesh.enableHelper) this.meshHelper.enable();\n\n          this.gui.load(this, this.model.obj);\n        }\n\n        // Everything is now fully loaded\n        Config.isLoaded = true;\n        this.container.querySelector('#loading').style.display = 'none';\n      };\n    });\n\n    // Start render which does not wait for model fully loaded\n    this.render();\n  }\n\n  render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }\n}"
        }
    },
    {
        "repo": "badginator",
        "content": "'badginator/lib/is_badge.js'\n:const gm = require('gm');\nconst printf = require('printf');\n\n// we resize the image to this size for our analysis algos\nconst WIDTH = 50;\nconst HEIGHT = 15;\n\nfunction is_badge(buff, cb) {\n    gm(buff, 'image.png')\n    .trim()\n    .size(function(err, size) {\n        if (err) {\n            return cb(err);\n        }\n\n        if (size.height > 40) {\n            return cb(null, false);\n        }\n\n        if (size.width < 40) {\n            return cb(null, false);\n        }\n\n        this\n        // order matters otherwise bitdepth doesn't behave how we want\n        .resize(WIDTH, HEIGHT, '!')\n        .bitdepth(3)\n        .toBuffer('GRAY', function(err, img) {\n            if (err) {\n                return cb(err, false);\n                }\n\n            const is_badge = buffer_is_badge(new Uint8Array(img));\n            cb(null, is_badge);\n        });\n    });\n}\n\nfunction buffer_is_badge(img) {\n    // get a histogram of image values\n    // key: count\n    var hist = histogram_val(img);\n\n    // turn the histogram of key: count -> array of { count: X, value: Y }\n    var arr = [];\n    Object.keys(hist).forEach(function(key) {\n        arr.push({\n            count: hist[key],\n            value: key,\n        });\n    });\n\n    // sort so we get most frequent first\n    arr.sort(function(a, b) {\n        return b.count - a.count;\n    });\n    //console.log(arr);\n\n    const pixels = img.length;\n    var primary_colors = 0;\n    arr.reduce(function(prev, curr) {\n        if (prev/pixels < 0.60) {\n            primary_colors += 1;\n        }\n\n        return prev + curr.count;\n    }, 0);\n    //console.log(primary_colors);\n\n    /*\n    for (var r=0 ; r<HEIGHT ; ++r) {\n        for (var c=0 ; c<WIDTH ; ++c) {\n            process.stdout.write(printf('%4d', img[WIDTH * r + c] + ' '));\n        }\n        process.stdout.write('\\n');\n    }\n    */\n\n    // badges will have at least 2 primary colors and no more than 5\n    if (primary_colors > 5 || primary_colors < 2) {\n        return false;\n    }\n\n    var primaries = new Set();\n    arr.slice(0, primary_colors).map(function(val) {\n        primaries.add(+val.value);\n    });\n    //console.log(primaries);\n\n    var column = 0;\n    var enough = 0;\n    var best_score = 0;\n\n    // algo\n    // loop over columns (width)\n    // for each column we need to see how many primary colors we found before and after\n    for (var c=10 ; c<WIDTH ; ++c) {\n        // new column means we expect 80% of representation\n        enough += HEIGHT;\n\n        var total = 0;\n        var locations = {\n            before: {},\n            after: {},\n        };\n\n        // before or after column\n        for (var c2 = 0 ; c2 < WIDTH ; ++c2 ) {\n            var before = c2 < c;\n            // loop over columns again and mark before or after\n\n            // each column will need to loop over rows\n            for (var r=0 ; r<HEIGHT ; ++r) {\n                var col_value = img[WIDTH * r + c2];\n\n                // is col_value in primaries?\n                if (!primaries.has(col_value)) { // === undefined) {\n                    continue;\n                }\n\n                if (before) {\n                    locations.before[col_value] = locations.before[col_value] || 0;\n                    locations.before[col_value] += 1;\n                }\n                else {\n                    locations.after[col_value] = locations.after[col_value] || 0;\n                    locations.after[col_value] += 1;\n                }\n                total += 1;\n            }\n        }\n        //console.log(locations);\n\n        // normalize count of each against total pixels of primary colors\n        normalize(locations.after, total);\n        normalize(locations.before, total);\n\n        //console.log(locations);\n\n        // score is the difference between primary with most pixels in region\n        // and primary with least pixels in region\n        var score = score_region(locations.before) + score_region(locations.after);\n\n        //console.log(score, best_score, c);\n        if (score > best_score) {\n            best_score = score;\n            column = c;\n        }\n    }\n\n    //console.log(column);\n    // midpoint will not be too far on either size\n    // we expect at least a score of 0.5 (evenly matched primaries on either side)\n    if (column < 10 || column > 40 || best_score < 0.5) {\n        return false;\n    }\n\n    return true;\n}\n\nfunction normalize(obj, den) {\n    // normalize count of each against total pixels of primary colors\n    Object.keys(obj).forEach(function(key) {\n        obj[key] = obj[key] / den;\n    });\n}\n\nfunction score_region(region) {\n    var score = 0;\n    var vals = Object.keys(region).map(function(key) {\n        return region[key];\n    });\n\n    vals.sort(function(a, b) {\n        return b - a;\n    });\n\n    if (vals.length == 1) {\n        score += vals[0];\n    }\n    else if (vals.length > 1) {\n        score += vals[0] - vals[vals.length - 1];\n    }\n\n    return score;\n}\n\n// given an array of values\n// return { 'val': count }\n// where count is the number of occurrences of 'val'\nfunction histogram_val(array) {\n    var out = Object.create(null);\n\n    array.forEach(function(val) {\n        val = String(val);\n        var prev = out[val] || 0;\n        out[val] = prev + 1;\n    });\n\n    return out;\n}\n\nmodule.exports = is_badge;\n\n'badginator/lib/url_is_badge.js'\n:/// file: identify if a url is a badge\n\nconst request = require('superagent');\nconst mime = require('mime');\nconst svg2png = require('svg2png');\n\nconst is_badge = require('./is_badge');\n\n// cb(err, is_badge)\nmodule.exports = function(url, cb) {\n    request\n    .get(url)\n    .set('badginator-request', 'sup dog')\n    .end((err, res) => {\n        if (err) {\n            return cb(err);\n        }\n\n        if (res.status !== 200) {\n            return cb(null, false);\n        }\n\n        var type = res.headers['content-type'];\n        var ext = mime.extension(type);\n\n        // only support png and svg badges for now\n        if (ext !== 'svg' && ext !== 'png') {\n            return cb(null, false);\n        }\n\n        if (ext === 'svg') {\n            // convert to png first\n            svg2png(res.body)\n            .then((buffer) => {\n                is_badge(buffer, (err, badge) => {\n                    cb(err, badge);\n                });\n            })\n            .catch((err) => {\n                cb(err);\n            });\n\n            return;\n        }\n\n        is_badge(res.body, (err, badge) => {\n            cb(err, badge);\n        });\n    });\n};\n\n'badginator/index.js'\n:const express = require('express');\nconst async = require('async');\nconst request = require('superagent');\nconst printf = require('printf');\nconst https = require('https');\nconst marked = require('marked');\nconst cheerio = require('cheerio');\nconst redis = require('redis');\nconst crypto = require('crypto');\n\nconst url_is_badge = require('./lib/url_is_badge');\n\nvar redisCache = redis.createClient(process.env.REDIS_URL);\nredisCache.on('error', function (err) {\n    console.error('Redis error:', err);\n});\n\nvar app = express();\n\napp.set('x-powered-by', false);\n\napp.get('/', function(req, res, next) {\n    res.redirect('https://github.com/defunctzombie/badginator');\n});\n\napp.get('/:org/:repo.svg', function(req, res, next) {\n    var org = req.params.org;\n    var repo = req.params.repo;\n\n    // if badginator request, serve up dummy badge\n    if (req.headers['badginator-request'] === 'sup dog') {\n        var url = printf('https://img.shields.io/badge/badges-dummy-green.svg');\n        https.get(url, function(img_res) {\n            res.set({\n                'content-type': img_res.headers['content-type'],\n                'cache-control': 'no-cache, no-store, must-revalidate',\n            });\n            img_res.pipe(res);\n        });\n        return;\n    }\n\n    var count_fn = process.env.USE_REGEX_BADGES ? regex_count_readme_badges : count_readme_badges;\n\n    if (req.query.image_analysis) {\n        count_fn = count_readme_badges;\n    }\n\n    count_fn({\n        org: org,\n        repo: repo,\n    }, function(err, badge_count) {\n        if (err) {\n            return next(err);\n        }\n\n        var color = 'red';\n\n        if (badge_count <= 2) {\n            color = 'red';\n        }\n        else if (badge_count <= 4) {\n            color = 'orange';\n        }\n        else if (badge_count <= 6) {\n            color = 'green';\n        }\n        else {\n            color = 'brightgreen';\n        }\n\n        var etag = badge_count + color;\n        var style = req.query.style || 'flat';\n        var url = printf('https://img.shields.io/badge/badges-%d-%s.svg?style=%s', badge_count, color, style);\n        if (process.env.USE_REDIRECT_URL === '1') {\n            return res.redirect(url);\n        }\n\n        https.get(url, function(img_res) {\n            res.set({\n                'content-type': img_res.headers['content-type'],\n                'cache-control': 'no-cache, no-store, must-revalidate',\n                'etag': etag,\n            });\n            img_res.pipe(res);\n        });\n    });\n});\n\nfunction regex_count_readme_badges(opt, cb) {\n    fetch_readme(opt, function(err, readme) {\n        if (err) {\n            return cb(err);\n        }\n\n        // remove markdown sections\n        readme = readme.replace(/```[^]*?```/g, '');\n\n        // count instances of [![](.svg or .png)]\n        // followed by () which is a link\n        var regexp = /(\\[[!]\\[.*\\]\\(.*(\\.svg|\\.png).*\\)\\]\\(.*\\)|[!]\\[.*\\]\\(.*(\\.svg|\\.png).*\\))/g;\n        var count = 0;\n        while(regexp.exec(readme) !== null) {\n            count++;\n        }\n\n        cb(null, count);\n    });\n};\n\nfunction count_readme_badges(opt, cb) {\n    fetch_readme(opt, function(err, readme) {\n        if (err) {\n            return cb(err);\n        }\n\n        // process readme\n        var html = marked(readme);\n        var $ = cheerio.load(html);\n\n        var urls = $('img').map(function(idx, img) {\n            return $(img).attr('src');\n        }).get();\n\n        var count = 0;\n        async.each(urls, function(url, done) {\n            //async.reduce(urls, 0, function(count, url, done) {\n            // this is gnarly and could be a function now\n            var hash = crypto.createHash('md5').update(url).digest('hex');\n            var url_key = 'url-cache:' + hash;\n            redisCache.get(url_key, function(err, val) {\n                if (err) {\n                    console.error(err);\n                    return done();\n                }\n\n                // have cached value\n                if (val !== null) {\n                    count += (val === 'true' ? 1 : 0);\n                    // redis values are strings, yay\n                    //return done(null, count + (val === 'true' ? 1 : 0));\n                    return done();\n                }\n\n                url_is_badge(url, function(err, is_badge) {\n                    if (err) {\n                        console.error(err);\n                    }\n                    else {\n                        redisCache.setex(url_key, 60 * 15, is_badge, function(err) {\n                            if (err) {\n                                console.error(err);\n                            }\n                        });\n                    }\n\n                    count += (is_badge ? 1 : 0);\n                    done();\n                    //done(null, count + (is_badge ? 1 : 0));\n                });\n\n            });\n        }, function(err) {\n            cb(err, count);\n        });\n    });\n}\n\nfunction fetch_readme(opt, cb) {\n    var org = opt.org;\n    var repo = opt.repo;\n\n    var base_url = printf('https://raw.githubusercontent.com/%s/%s/master/', org, repo);\n    var readme_variants = ['README.md', 'readme.md', 'Readme.md', 'README.MD', 'readme.markdown'];\n    var readme_text = '';\n\n    async.some(readme_variants, function(name, cb) {\n        var url = base_url + name;\n        request.get(url).end(function(err, res) {\n            if (err) {\n                return cb(false);\n            }\n\n            if (res.status !== 200) {\n                return cb(false);\n            }\n\n            readme_text = res.text;\n            cb(true);\n        });\n    }, function(found) {\n        cb(null, readme_text);\n    });\n}\n\n\napp.listen(process.env.PORT || 3000);\n\n",
        "called_code_segment_file_1": "function is_badge(buff, cb) { ... }",
        "invoking_code_segment_file_2": "const is_badge = require('./is_badge');\n\nmodule.exports = function(url, cb) {\n    request\n    .get(url)\n    .set('badginator-request', 'sup dog')\n    .end((err, res) => {\n        if (err) {\n            return cb(err);\n        }\n\n        if (res.status !== 200) {\n            return cb(null, false);\n        }\n\n        var type = res.headers['content-type'];\n        var ext = mime.extension(type);\n\n        if (ext !== 'svg' && ext !== 'png') {\n            return cb(null, false);\n        }\n\n        if (ext === 'svg') {\n            svg2png(res.body)\n            .then((buffer) => {\n                is_badge(buffer, (err, badge) => {\n                    cb(err, badge);\n                });\n            })\n            .catch((err) => {\n                cb(err);\n            });\n\n            return;\n        }\n\n        is_badge(res.body, (err, badge) => {\n            cb(err, badge);\n        });\n    });\n};",
        "called_code_segment_file_2": "function count_readme_badges(opt, cb) { ... }",
        "using_code_segment_file_3": "app.get('/:org/:repo.svg', function(req, res, next) {\n    var org = req.params.org;\n    var repo = req.params.repo;\n\n    var count_fn = process.env.USE_REGEX_BADGES ? regex_count_readme_badges : count_readme_badges;\n\n    if (req.query.image_analysis) {\n        count_fn = count_readme_badges;\n    }\n\n    count_fn({\n        org: org,\n        repo: repo,\n    }, function(err, badge_count) { ... });\n});",
        "feature_description": "Add a feature to log the number of badges found for each repository to a file.",
        "detailed_feature_description": "Modify the `count_readme_badges` function in `#file 2` to log the number of badges found for each repository to a file. Update the `count_fn` call in `#file 3` to pass an additional callback for logging. Ensure that the logging mechanism is integrated into the existing flow without disrupting the badge counting process.",
        "modified_complete_code": {
            "#file 1": "function is_badge(buff, cb) { ... } #Modify",
            "#file 2": "const fs = require('fs');\nconst path = require('path');\n\nconst is_badge = require('./is_badge');\n\nmodule.exports = function(url, cb) { ... };\n\nfunction count_readme_badges(opt, cb, logCb) { #Modify\n    fetch_readme(opt, function(err, readme) { ... });\n}\n\nfunction logBadgeCount(org, repo, count) { #New\n    const logFilePath = path.join(__dirname, 'badge_counts.log');\n    const logEntry = `[${new Date().toISOString()}] ${org}/${repo}: ${count} badges\\n`;\n    fs.appendFile(logFilePath, logEntry, (err) => {\n        if (err) console.error('Failed to log badge count:', err);\n    });\n}",
            "#file 3": "app.get('/:org/:repo.svg', function(req, res, next) {\n    var org = req.params.org;\n    var repo = req.params.repo;\n\n    var count_fn = process.env.USE_REGEX_BADGES ? regex_count_readme_badges : count_readme_badges;\n\n    if (req.query.image_analysis) {\n        count_fn = count_readme_badges;\n    }\n\n    count_fn({\n        org: org,\n        repo: repo,\n    }, function(err, badge_count) {\n        if (err) {\n            return next(err);\n        }\n\n        logBadgeCount(org, repo, badge_count); #New\n\n        var color = 'red';\n        if (badge_count <= 2) {\n            color = 'red';\n        } else if (badge_count <= 4) {\n            color = 'orange';\n        } else if (badge_count <= 6) {\n            color = 'green';\n        } else {\n            color = 'brightgreen';\n        }\n\n        var etag = badge_count + color;\n        var style = req.query.style || 'flat';\n        var url = printf('https://img.shields.io/badge/badges-%d-%s.svg?style=%s', badge_count, color, style);\n        if (process.env.USE_REDIRECT_URL === '1') {\n            return res.redirect(url);\n        }\n\n        https.get(url, function(img_res) {\n            res.set({\n                'content-type': img_res.headers['content-type'],\n                'cache-control': 'no-cache, no-store, must-revalidate',\n                'etag': etag,\n            });\n            img_res.pipe(res);\n        });\n    }, logBadgeCount); #Modify\n});"
        }
    },
    {
        "repo": "better-onetab",
        "content": "'better-onetab/src/background/commandHandler.js'\n:import tabs from '../common/tabs'\n\nconst commands = {\n  'store-selected-tabs': tabs.storeSelectedTabs,\n  'store-all-tabs': tabs.storeAllTabs,\n  'store-all-in-all-windows': tabs.storeAllTabInAllWindows,\n  'restore-lastest-list': tabs.restoreLastestList,\n  'open-lists': tabs.openTabLists,\n}\n\nconst commandHandler = command => {\n  console.log('received command', command)\n  const handler = commands[command]\n  if (!handler) return\n  handler()\n  if (PRODUCTION) ga('send', 'event', 'Command used', command)\n}\n\nexport default commandHandler\n\n'better-onetab/src/background/init.js'\n:import _ from 'lodash'\nimport logger from '../common/logger'\nimport options from '../common/options'\nimport storage from '../common/storage'\nimport migrate from '../common/migrate'\nimport boss from '../common/service/boss'\nimport {normalizeList} from '../common/list'\nimport commandHandler from './commandHandler'\nimport messageHandler from './messageHandler'\nimport listManager from '../common/listManager'\nimport {setupContextMenus, dynamicDisableMenu} from './contextMenus'\nimport installedEventHandler from './installedEventHandler'\nimport {updateBrowserAction} from './browserAction'\n\nimport browser from 'webextension-polyfill'\n\n/* eslint-disable-next-line */\nif (DEBUG && !MOZ) import(\n  /* webpackChunkName: \"autoreload\", webpackMode: \"lazy\" */\n  '../common/autoreload'\n).then(({autoreload}) => autoreload())\n\n/* eslint-disable-next-line */\nif (PRODUCTION) import(\n  /* webpackChunkName: \"tracker\", webpackMode: \"lazy\" */\n  '../common/tracker'\n).then(({tracker}) => tracker())\n\nif (DEBUG) {\n  window.browser = browser\n  window.listManager = listManager\n  window.boss = boss\n  browser.browserAction.setBadgeText({text: 'dev'})\n  import(\n    /* webpackChunkName: \"helper\", webpackMode: \"lazy\" */\n    '../common/helper'\n  ).then(helper => { window.helper = helper })\n}\n\nconst initOptions = async () => {\n  // mount the `opts` to global\n  const opts = window.opts = await storage.getOptions() || {}\n  const defaultOptions = options.getDefaultOptions()\n\n  // set it as default value if there is an option not in current options\n  if (_.keys(defaultOptions).some(key => !_.has(opts, key))) {\n    _.defaults(opts, defaultOptions)\n    await storage.setOptions(opts)\n  }\n\n  // init nightmode status\n  window.nightmode = opts.defaultNightMode\n  return opts\n}\n\nconst storageChangedHandler = changes => {\n  console.debug('[storage changed]', changes)\n  if (changes.boss_token) {\n    window.boss_token = changes.boss_token\n  }\n  if (changes.lists) {\n    if (window.opts.disableDynamicMenu) return\n    setupContextMenus(window.opts)\n  }\n}\n\nconst tabsChangedHandler = activeInfo => {\n  if (window.opts.disableDynamicMenu) return\n  window.coverBrowserAction(activeInfo)\n  dynamicDisableMenu(activeInfo)\n}\n\nconst fixDirtyData = async () => {\n  const unlock = await listManager.RWLock.lock()\n  const {lists} = await browser.storage.local.get('lists')\n  if (lists) {\n    const cleanLists = lists.filter(_.isPlainObject).map(normalizeList)\n    await browser.storage.local.set({lists: cleanLists})\n  }\n  await unlock()\n}\n\nconst init = async () => {\n  logger.init()\n  await listManager.init()\n  const opts = await initOptions()\n  await updateBrowserAction(opts.browserAction)\n  await setupContextMenus(opts)\n  await Promise.all([\n    browser.commands.onCommand.addListener(commandHandler),\n    browser.runtime.onMessageExternal.addListener(commandHandler),\n    browser.runtime.onMessage.addListener(messageHandler),\n    browser.runtime.onUpdateAvailable.addListener(detail => { window.update = detail.version }),\n    browser.runtime.onInstalled.addListener(installedEventHandler),\n    browser.browserAction.onClicked.addListener(() => window.browswerActionClickedHandler()),\n    browser.contextMenus.onClicked.addListener(info => window.contextMenusClickedHandler(info)),\n    browser.tabs.onActivated.addListener(_.debounce(tabsChangedHandler, 200)),\n    browser.storage.onChanged.addListener(storageChangedHandler),\n  ])\n  await migrate()\n  await fixDirtyData()\n  await boss.init()\n}\n\nexport default init\n\n'better-onetab/src/background/index.js'\n:import init from './init'\n\ninit()\n\n",
        "called_code_segment_file_1": "const commandHandler = command => {\n  console.log('received command', command)\n  const handler = commands[command]\n  if (!handler) return\n  handler()\n  if (PRODUCTION) ga('send', 'event', 'Command used', command)\n}",
        "invoking_code_segment_file_2": "await Promise.all([\n    browser.commands.onCommand.addListener(commandHandler),\n    browser.runtime.onMessageExternal.addListener(commandHandler),\n    browser.runtime.onMessage.addListener(messageHandler),\n    browser.runtime.onUpdateAvailable.addListener(detail => { window.update = detail.version }),\n    browser.runtime.onInstalled.addListener(installedEventHandler),\n    browser.browserAction.onClicked.addListener(() => window.browswerActionClickedHandler()),\n    browser.contextMenus.onClicked.addListener(info => window.contextMenusClickedHandler(info)),\n    browser.tabs.onActivated.addListener(_.debounce(tabsChangedHandler, 200)),\n    browser.storage.onChanged.addListener(storageChangedHandler),\n])",
        "called_code_segment_file_2": "const messageHandler = async (message, sender, sendResponse) => {\n  if (message.type === 'getOptions') {\n    sendResponse(await storage.getOptions())\n  }\n}",
        "using_code_segment_file_3": "const tracker = () => {\n  ga('create', 'UA-12345678-1', 'auto')\n  ga('send', 'pageview')\n}",
        "feature_description": "Add a new command to handle a custom analytics event.",
        "detailed_feature_description": "Modify the commandHandler in #file 1 to include a new command 'send-custom-event' that sends a custom analytics event. Update #file 2 to handle this new command and ensure that #file 3 (tracker) is updated to handle the new event type.",
        "modified_complete_code": {
            "#file 1": "const commandHandler = command => {\n  console.log('received command', command)\n  const handler = commands[command]\n  if (!handler) return\n  handler()\n  if (PRODUCTION) ga('send', 'event', 'Command used', command)\n  #Modify if (command === 'send-custom-event') {\n    ga('send', 'event', 'Custom Event', 'Custom Action')\n  }\n}",
            "#file 2": "await Promise.all([\n    browser.commands.onCommand.addListener(commandHandler),\n    browser.runtime.onMessageExternal.addListener(commandHandler),\n    browser.runtime.onMessage.addListener(messageHandler),\n    browser.runtime.onUpdateAvailable.addListener(detail => { window.update = detail.version }),\n    browser.runtime.onInstalled.addListener(installedEventHandler),\n    browser.browserAction.onClicked.addListener(() => window.browswerActionClickedHandler()),\n    browser.contextMenus.onClicked.addListener(info => window.contextMenusClickedHandler(info)),\n    browser.tabs.onActivated.addListener(_.debounce(tabsChangedHandler, 200)),\n    browser.storage.onChanged.addListener(storageChangedHandler),\n])",
            "#file 3": "const tracker = () => {\n  ga('create', 'UA-12345678-1', 'auto')\n  ga('send', 'pageview')\n  #New ga('send', 'event', 'Custom Event', 'Custom Action')\n}"
        }
    },
    {
        "repo": "budo",
        "content": "'budo/lib/file-watch.js'\n:// a thin wrapper around chokidar file watching HTML / CSS\nvar watch = require('chokidar').watch\nvar xtend = require('xtend')\nvar Emitter = require('events/')\n\nvar ignores = [\n  'node_modules/**', 'bower_components/**',\n  '.git', '.hg', '.svn', '.DS_Store',\n  '*.swp', 'thumbs.db', 'desktop.ini'\n]\n\nmodule.exports = function (glob, opt) {\n  opt = xtend({\n    usePolling: opt && opt.poll,\n    ignored: ignores,\n    ignoreInitial: true\n  }, opt)\n\n  var emitter = new Emitter()\n  var closed = false\n\n  var watcher = watch(glob, opt)\n  watcher.on('add', onWatch.bind(null, 'add'))\n  watcher.on('change', onWatch.bind(null, 'change'))\n\n  function onWatch (event, path) {\n    emitter.emit('watch', event, path)\n  }\n\n  emitter.close = function () {\n    if (closed) return\n    watcher.close()\n    closed = true\n  }\n  return emitter\n}\n\nmodule.exports.ignores = ignores\n\n'budo/lib/budo.js'\n:var bole = require('bole')\nvar xtend = require('xtend')\nvar once = require('once')\nvar path = require('path')\nvar EventEmitter = require('events').EventEmitter\nvar isMatch = require('micromatch')\nvar openUrl = require('opn')\nvar internalIp = require('internal-ip')\nvar garnish = require('garnish')\n\nvar defaults = require('./parse-args').defaults\nvar getPorts = require('./get-ports')\nvar createServer = require('./server')\nvar createBundler = require('./bundler')\nvar createFileWatch = require('./file-watch')\nvar createReloadServer = require('./reload/server')\nvar mapEntry = require('./map-entry')\n\nvar noop = function () {}\n\nmodule.exports = createBudo\nfunction createBudo (entries, opts) {\n  var log = bole('budo')\n\n  // if no entries are specified, just options\n  if (entries && !Array.isArray(entries) && typeof entries === 'object') {\n    opts = entries\n    entries = []\n  }\n\n  // do not mutate user options\n  opts = xtend({}, defaults, { stream: false }, opts)\n  entries = entries || []\n\n  // perhaps later this will be configurable\n  opts.cwd = process.cwd()\n\n  // log to output stream\n  if (opts.stream) {\n    // by default, pretty-print to the stream with info logging\n    if (!opts.ndjson) {\n      var pretty = garnish({\n        level: opts.verbose ? 'debug' : 'info',\n        name: 'budo'\n      })\n      pretty.pipe(opts.stream)\n      opts.stream = pretty\n    }\n\n    bole.output({\n      stream: opts.stream,\n      level: 'debug'\n    })\n  }\n\n  // optionally allow as arrays\n  entries = [].concat(entries).filter(Boolean)\n\n  var entryObjects = entries.map(mapEntry)\n  var entryFiles = entryObjects.map(function (entry) {\n    return entry.from\n  })\n\n  if (opts.serve && typeof opts.serve !== 'string') {\n    throw new TypeError('opts.serve must be a string or undefined')\n  } else if (!opts.serve && entries.length > 0) {\n    opts.serve = entryObjects[0].url\n  }\n\n  // default to cwd\n  if (!opts.dir || opts.dir.length === 0) {\n    opts.dir = opts.cwd\n  }\n\n  var emitter = new EventEmitter()\n  var bundler, middleware\n\n  if (entries.length > 0 || (opts.browserify && opts.browserify.entries)) {\n    bundler = createBundler(entryFiles, opts)\n    middleware = bundler.middleware\n\n    bundler.on('log', function (ev) {\n      if (ev.type === 'bundle') {\n        var time = ev.elapsed\n        ev.elapsed = time\n        ev.name = 'browserify'\n        ev.type = undefined\n        ev.colors = {\n          elapsed: time > 1000 ? 'yellow' : 'dim',\n          message: 'dim '\n        }\n        log.info(ev)\n      }\n    })\n\n    // uncaught syntax errors should not stop the server\n    // this only happens when errorHandler: false\n    bundler.on('error', function (err) {\n      console.error('Error:', err.message ? err.message : err)\n    })\n    bundler.on('bundle-error', emitter.emit.bind(emitter, 'bundle-error'))\n    bundler.on('update', emitter.emit.bind(emitter, 'update'))\n    bundler.on('pending', emitter.emit.bind(emitter, 'pending'))\n\n    emitter.on('update', function (contents, deps) {\n      if (deps.length > 1) {\n        log.debug({\n          name: 'browserify',\n          message: deps.length + ' files changed'\n        })\n      }\n    })\n  }\n\n  var defaultInternalIp = internalIp.v4.sync()\n  var defaultWatchGlob = opts.watchGlob || '**/*.{html,css}'\n  var server = null\n  var closed = false\n  var started = false\n  var fileWatcher = null\n  var reloader = null\n  var deferredWatch = noop\n  var deferredLive = noop\n\n  // public API\n  emitter.close = once(close)\n  emitter.reload = reload\n  emitter.error = errorPopup\n  emitter.live = live\n  emitter.watch = watch\n\n  // setup defaults for live reload / watchify\n  if (opts.live) {\n    var initialLiveOpts = typeof opts.live === 'object' ? opts.live : undefined\n    var initialLiveMatch = typeof opts.live === 'string' ? opts.live : undefined\n    if (initialLiveMatch) {\n      emitter.once('connect', function () {\n        log.info({ message: 'LiveReload filtering filenames with glob:', url: initialLiveMatch })\n        if (entryObjects.length === 0) {\n          log.info({ message: '\\nNOTE: It looks like you are using budo without a JavaScript entry.\\n' +\n            '  This is fine, but if you were trying to bundle the \"' + initialLiveMatch + '\" file,\\n  you should re-arrange' +\n            ' your arguments like so:\\n\\n' +\n            '      budo ' + initialLiveMatch + ' --live' })\n        }\n      })\n    }\n    emitter\n      .watch()\n      .live(initialLiveOpts)\n      .on('watch', function (ev, file) {\n        if (ev !== 'change' && ev !== 'add') {\n          return\n        }\n        defaultFileEvent(file)\n      })\n      .on('pending', function () {\n        defaultFileEvent(opts.serve)\n      })\n  }\n\n  // First, setup a server\n  createServer(middleware, xtend(opts, { ip: defaultInternalIp }), function (err, serverInstance) {\n    if (err) {\n      emitter.emit('error', err)\n      return\n    }\n\n    server = serverInstance\n\n    // start portfinding + connect\n    getPorts(opts, handlePorts)\n  })\n\n  return emitter\n\n  function defaultFileEvent (file) {\n    var filename = path.basename(file)\n    if ((Array.isArray(opts.live) || typeof opts.live === 'string') &&\n        isMatch(filename, opts.live).length === 0) {\n      return\n    }\n    emitter.reload(file)\n  }\n\n  function reload (file) {\n    process.nextTick(emitter.emit.bind(emitter, 'reload', file))\n    if (reloader) {\n      reloader.reload(file)\n    }\n  }\n\n  function errorPopup (message) {\n    if (reloader) {\n      reloader.errorPopup(message)\n    }\n  }\n\n  // enable file watch capabilities\n  function watch (glob, watchOpt) {\n    if (!started) {\n      deferredWatch = emitter.watch.bind(null, glob, watchOpt)\n    } else {\n      // destroy previous\n      if (fileWatcher) fileWatcher.close()\n      glob = glob && glob.length > 0 ? glob : defaultWatchGlob\n      glob = Array.isArray(glob) ? glob : [ glob ]\n      watchOpt = xtend({ poll: opts.poll }, watchOpt)\n\n      fileWatcher = createFileWatch(glob, watchOpt)\n      fileWatcher.on('watch', emitter.emit.bind(emitter, 'watch'))\n    }\n    return emitter\n  }\n\n  // enables LiveReload capabilities\n  function live (liveOpts) {\n    if (!started) {\n      deferredLive = emitter.live.bind(null, liveOpts)\n    } else {\n      // destroy previous\n      if (reloader) reloader.close()\n\n      // pass some options for the server middleware\n      server.setLiveOptions(xtend(liveOpts))\n\n      // create a web socket server for live reload\n      reloader = createReloadServer(server, opts)\n    }\n    return emitter\n  }\n\n  function getHostAddress (host) {\n    // user can specify \"::\" or \"0.0.0.0\" as host exactly\n    // or if undefined, default to internal-ip\n    if (!host) {\n      host = server.address().address\n      if (host === '0.0.0.0') {\n        // node 0.10 returns this when no host is specified\n        // node 0.12 returns internal-ip\n        host = '::'\n      }\n    }\n    if (host === '::') {\n      host = defaultInternalIp\n    }\n    if (!host) {\n      host = '127.0.0.1'\n    }\n    return host\n  }\n\n  function handlePorts (err, result) {\n    if (closed) return\n    if (err) {\n      emitter.emit('error', err)\n      return\n    }\n\n    opts.port = result.port\n\n    // improve error messaging\n    server.on('error', function (err) {\n      if (err.code === 'EADDRINUSE') {\n        err.message = 'port ' + opts.port + ' is in use'\n        emitter.emit('error', err)\n      } else {\n        emitter.emit('error', err)\n      }\n    })\n\n    // start server\n    // no host -> use localhost + internal-ip\n    server.listen(opts.port, opts.host || undefined, connect)\n  }\n\n  function connect () {\n    if (closed) return\n    started = true\n\n    // default host is internal IP\n    opts.host = getHostAddress(opts.host)\n\n    var port = opts.port\n    var protocol = opts.ssl ? 'https' : 'http'\n    var uri = protocol + '://' + opts.host + ':' + port + '/'\n\n    log.info({ message: 'Server running at', url: uri, type: 'connect' })\n\n    // if live() or watch() was called before connection\n    deferredWatch()\n    deferredLive()\n\n    // provide info on server connection\n    emitter.emit('connect', {\n      uri: uri,\n      port: port,\n      host: opts.host,\n      serve: opts.serve,\n      entries: entryFiles,\n      server: server,\n      webSocketServer: reloader ? reloader.webSocketServer : undefined,\n      dir: opts.dir\n    })\n\n    // initial bundle should come after\n    // connect event!\n    if (bundler) bundler.bundle()\n\n    // launch browser\n    if (opts.open) {\n      openUrl(uri)\n    }\n  }\n\n  function close () {\n    var next = emitter.emit.bind(emitter, 'exit')\n    if (started) {\n      server.once('close', next)\n    } else {\n      process.nextTick(next)\n    }\n\n    if (started) bole.reset()\n    if (started) server.close()\n    if (reloader) reloader.close()\n    if (bundler) bundler.close()\n    if (fileWatcher) fileWatcher.close()\n    closed = true\n    started = false\n  }\n}\n\n'budo/index.js'\n:var parseArgs = require('./lib/parse-args')\nvar budo = require('./lib/budo')\nvar color = require('term-color')\nvar stdoutStream = require('stdout-stream')\nvar exec = require('child_process').exec\n\nmodule.exports = budo\nmodule.exports.cli = budoCLI\n\nfunction budoCLI (args, opts) {\n  var argv = parseArgs(args, opts)\n\n  // if no stream is specified, default to stdout\n  if (argv.stream !== false) {\n    argv.stream = /^win/.test(process.platform) ? process.stdout : stdoutStream\n  }\n\n  var entries = argv._\n  delete argv._\n\n  argv.browserifyArgs = argv['--']\n  delete argv['--']\n\n  if (argv.version) {\n    console.log('budo v' + require('./package.json').version)\n    console.log('browserify v' + require('browserify/package.json').version)\n    console.log('watchify v' + require('watchify-middleware').getWatchifyVersion())\n    return null\n  }\n\n  if (argv.help) {\n    var help = require('path').join(__dirname, 'bin', 'help.txt')\n    require('fs').createReadStream(help)\n      .pipe(process.stdout)\n    return null\n  }\n\n  if (argv.outfile) {\n    console.error(color.yellow('WARNING'), '--outfile has been removed in budo@3.0')\n  }\n\n  if (typeof argv.pushstate === 'string') {\n    // support backwards compatibility with CLI like this:\n    //    budo -P index.js:bundle.js\n    var newEntry = argv.pushstate\n    argv.pushstate = argv.P = true\n    entries.unshift(newEntry)\n    console.error(color.yellow('WARNING'), '\\nAs of budo@10.x, --pushstate should come ' +\n        'after your JS entries.\\nExample:\\n' +\n        '  budo index.js:bundle.js --pushstate')\n  }\n\n  if (typeof argv.port === 'string') {\n    argv.port = parseInt(argv.port, 10)\n  }\n  if (typeof argv.livePort === 'string') {\n    argv.livePort = parseInt(argv.livePort, 10)\n  }\n\n  // opts.live can be a glob or a boolean\n  if (typeof argv.live === 'string' && /(true|false)/.test(argv.live)) {\n    argv.live = argv.live === 'true'\n  }\n\n  // CLI only option for executing a child process\n  var instance = budo(entries, argv).on('error', exit)\n  var onUpdates = [].concat(argv.onupdate).filter(Boolean)\n  onUpdates.forEach(function (cmd) {\n    instance.on('update', execFunc(cmd))\n  })\n\n  return instance\n}\n\nfunction execFunc (cmd) {\n  return function run () {\n    var p = exec(cmd)\n    p.stderr.pipe(process.stderr)\n    p.stdout.pipe(process.stdout)\n  }\n}\n\nfunction exit (err) {\n  console.log(color.red('ERROR'), err.message)\n  process.exit(1)\n}\n\n",
        "called_code_segment_file_1": "function createBundler(entryFiles, opts) {\n  var bundler = watchifyMiddleware(entryFiles, opts);\n  bundler.on('log', function (ev) {\n    if (ev.type === 'bundle') {\n      var time = ev.elapsed;\n      ev.elapsed = time;\n      ev.name = 'browserify';\n      ev.type = undefined;\n      ev.colors = {\n        elapsed: time > 1000 ? 'yellow' : 'dim',\n        message: 'dim '\n      };\n      log.info(ev);\n    }\n  });\n  return bundler;\n}",
        "invoking_code_segment_file_2": "var bundler = createBundler(entryFiles, opts);\nmiddleware = bundler.middleware;\nbundler.on('bundle-error', emitter.emit.bind(emitter, 'bundle-error'));\nbundler.on('update', emitter.emit.bind(emitter, 'update'));\nbundler.on('pending', emitter.emit.bind(emitter, 'pending'));",
        "called_code_segment_file_2": "function reload(file) {\n  process.nextTick(emitter.emit.bind(emitter, 'reload', file));\n  if (reloader) {\n    reloader.reload(file);\n  }\n}",
        "using_code_segment_file_3": "emitter.on('update', function (contents, deps) {\n  if (deps.length > 1) {\n    log.debug({\n      name: 'browserify',\n      message: deps.length + ' files changed'\n    });\n  }\n});",
        "feature_description": "Add a feature to log the number of files changed during a bundle update.",
        "detailed_feature_description": "Modify the `createBundler` function in `#file 1` to include a new event that logs the number of files changed during a bundle update. Update `#file 2` to handle this new event and ensure `#file 3` can log the number of files changed.",
        "modified_complete_code": {
            "#file 1": "function createBundler(entryFiles, opts) {\n  var bundler = watchifyMiddleware(entryFiles, opts);\n  bundler.on('log', function (ev) {\n    if (ev.type === 'bundle') {\n      var time = ev.elapsed;\n      ev.elapsed = time;\n      ev.name = 'browserify';\n      ev.type = undefined;\n      ev.colors = {\n        elapsed: time > 1000 ? 'yellow' : 'dim',\n        message: 'dim '\n      };\n      log.info(ev);\n    }\n  });\n  #Modify\n  bundler.on('files-changed', function (count) {\n    log.debug({ name: 'browserify', message: count + ' files changed' });\n  });\n  return bundler;\n}",
            "#file 2": "var bundler = createBundler(entryFiles, opts);\nmiddleware = bundler.middleware;\nbundler.on('bundle-error', emitter.emit.bind(emitter, 'bundle-error'));\nbundler.on('update', emitter.emit.bind(emitter, 'update'));\nbundler.on('pending', emitter.emit.bind(emitter, 'pending'));\n#Modify\nbundler.on('files-changed', function (count) {\n  emitter.emit('files-changed', count);\n});",
            "#file 3": "emitter.on('update', function (contents, deps) {\n  if (deps.length > 1) {\n    log.debug({\n      name: 'browserify',\n      message: deps.length + ' files changed'\n    });\n  }\n});\n#Modify\nemitter.on('files-changed', function (count) {\n  log.debug({ name: 'browserify', message: count + ' files changed' });\n});"
        }
    },
    {
        "repo": "dnsbin",
        "content": "'dnsbin/web/config.js'\n:// The domain name on which you have configured your DNS setup.\nvar targetDomain     = \"zhack.ca\";\n\n// Websocket URI that the client will use to connect\nvar websocketUrl     = \"ws://dns1.zhack.ca:8001/dnsbin\";\n\n// Subdomain used for the service.\nvar prefixes         = { \n\t\"standard\" : \".d.\", \n\t\"in\"       : \".i.\", \n\t\"out\"      : \".o.\" \n};\n\n// Where the logs are stored, use undefined or null if you don't want any log.\nvar logFile          = \"log.txt\";\n\n// Port used for the websocket communication. If you wish to change this value to \n// something else than the default 8001, make sure to change it in the index.html \n// page too.\nvar websocketPort    = 8001;\n\n// Use \":memory:\" if you don't want to store data on disk (recommended when testing)\n// Otherwise specify a filename\nvar sqliteDatabase   = \":memory:\"; \n\n// Maximum of entry stored in the database. Once the limit is reached older entry \n// will be deleted.\nvar sqliteMaxEntry   = 100000;\n\n// Polyfill for when this file is loaded in the browser.\nif (typeof window !== \"undefined\" && !window.exports) {\n\texports = {};\n}\n\nexports.targetDomain = targetDomain;\nexports.prefixes = prefixes;\nexports.logFile = logFile;\nexports.websocketPort = websocketPort;\nexports.sqliteDatabase = sqliteDatabase;\nexports.websocketUrl = websocketUrl;\n'dnsbin/web/persistence.js'\n:var sqlite3   = require('sqlite3');\nvar config    = require('./config');\nvar fs        = require('fs');\n\nvar db = new sqlite3.Database(config.sqliteDatabase);\n\n// Make sure the table are initialized\ndb.serialize(function() {\n\tdb.run(\"CREATE TABLE IF NOT EXISTS requests (master TEXT, data TEXT, timestamp INTEGER); \");\n\tdb.run(\"CREATE TABLE IF NOT EXISTS identity (master TEXT, subdomain TEXT, timestamp INTEGER); \");\n\tdb.run(\"CREATE INDEX IF NOT EXISTS req_master ON requests (master); \");\n\tdb.run(\"CREATE INDEX IF NOT EXISTS ident_master ON identity (master); \");\n\tdb.run(\"CREATE INDEX IF NOT EXISTS ident_subdomain ON identity (subdomain); \");\n});\n\nfunction storeSubdomainRequest(subdomain, data) {\n\tdb.each(\"SELECT master FROM identity WHERE subdomain = ?; \", subdomain, function (err, row) {\n\t\tif (err) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (row[\"master\"]) {\n\t\t\tdb.run(\"INSERT INTO requests VALUES (?, ?, ?); \", row[\"master\"], data, new Date().getTime());\n\t\t}\n\t});\n}\n\nfunction createIdentity(master, subdomain) {\n\tdb.run(\"INSERT INTO identity VALUES (?, ?, ?); \", master, subdomain, new Date().getTime());\n}\n\nfunction restoreFromMaster(master, callback) {\n\tdb.all(\"SELECT subdomain FROM identity WHERE master = ?\", master, function (err, rows) {\n\t\tif (err || rows.length == 0) {\n\t\t\tcallback({\"err\" : \"Master token not found !\", \"data\" : []});\n\t\t\treturn;\n\t\t}\n\n\t\tvar subdomain = rows[0][\"subdomain\"];\n\n\t\tdb.all(\"SELECT data FROM requests WHERE master = ? ORDER BY timestamp ASC\", master, function (err, rows) {\n\t\t\tif (err) {\n\t\t\t\tcallback({\"err\" : \"Error while finding existing request. \" + err, \"data\" : []});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallback({\"err\" : null, \"data\" : rows, \"subdomain\" : subdomain });\n\t\t});\n\t});\n\t\n}\n\nexports.storeSubdomainRequest = storeSubdomainRequest;\nexports.createIdentity = createIdentity;\nexports.restoreFromMaster = restoreFromMaster;\n'dnsbin/web/index.js'\n:// NodeJS dependencies\nvar dnsd      = require('dnsd');\nvar ws        = require(\"nodejs-websocket\");\nvar crypto    = require('crypto');\nvar fs        = require('fs');\n\n// Configuration & Custom module\nvar config = require('./config');\nvar persistence = require('./persistence');\nvar map = {};\n\nfunction bin2hex (d) {\n    var hex, i;\n\n    if (d == \"\") { \n        return \"00\"; \n    }\n\n    var result = \"\";\n    for (i=0; i<d.length; i++) {\n        hex = d.charCodeAt(i).toString(16);\n        result += (\"0\" + hex).slice(-2);\n    }\n\n    return result\n}\n\nfunction logData(message) {\n    if (config.logFile) {\n        fs.appendFile(config.logFile, \"[\" + (new Date().toString()) + \"] \" + message, function (err) {\n            if (err) {\n                console.error(\"Failed to log message ! \" + err);\n            }\n        });\n    }\n}\n\nvar server = ws.createServer(function (conn) {\n    try {\n        var token;\n        var master;\n\n        crypto.randomBytes(20, function(err, buffer) {\n            // If the token variable is already defined, this means \n            // a restore as already happened.\n            if (token) {\n                return;\n            }\n\n            try {\n                token  = buffer.toString('hex').substr(0,  20);\n                master = buffer.toString('hex').substr(20, 20);\n\n                map[token] = {\n                    \"connection\" : conn, \n                    \"buffer\" : \"\" \n                };\n\n                conn.sendText(JSON.stringify({\n                    \"type\" : \"token\", \n                    \"master\" : master, \n                    \"data\" : token \n                }));\n                \n                persistence.createIdentity(master, token);\n\n                logData(\"Token assignment '\" + token + \"' with IP '\" + conn.socket.remoteAddress + \"' \\n\");\n            } catch (e) {\n\n            }\n        });\n\n        conn.on(\"text\", function (data) {\n            try {\n                data = JSON.parse(data);\n\n                // When the attribute text is defined, the client is sending data for the in/out request.\n                if (data.text) {\n                    if (map[token][\"buffer\"].length + data.text.length > 2048) {\n                        map[token][\"connection\"].sendText(JSON.stringify({\n                            \"type\":\"error\", \n                            \"data\" : \"Maximum buffering is 2048 bytes.\"\n                        }));\n                        return;\n                    }\n                    map[token][\"buffer\"] += data.text;\n                }\n\n                // When the attribute restore is defined, the client is trying to restore the previously \n                // saved data from a master token.\n                if (data.restore && data.master) {\n                    persistence.restoreFromMaster(data.master, function (data) {\n                        // If the restore was succesful we add the information to the map so \n                        // that the connection can receive real-time data.\n                        if (!data.err) {\n                            token = data.subdomain;\n\n                            map[token] = {\n                                \"connection\" : conn, \n                                \"buffer\" : \"\" \n                            };\n                        }\n\n                        data[\"type\"] = \"restore\";\n                        conn.sendText(JSON.stringify(data));\n                    });\n                }\n\n            } catch (e) {}\n        })\n\n        conn.on(\"close\", function (code, reason) {\n            try {\n                delete map[token];\n            } catch (e) {\n\n            } \n        });\n    } catch (e) {\n    \n    }\n\n}).listen(config.websocketPort);\n\ndnsd.createServer(function(req, res) {\n\n    try {\n        var domain = res.question[0].name;\n\n        var domainWithPrefixStandard = config.prefixes[\"standard\"] + config.targetDomain;\n        var domainWithPrefixIn       = config.prefixes[\"in\"] + config.targetDomain;\n        var domainWithPrefixOut      = config.prefixes[\"out\"] + config.targetDomain;\n\n        if (domain.endsWith(domainWithPrefixStandard)) {\n            // Dissect the request domain name to extract the data and generated id\n            // Format looks like : [data].[id].d.zhack.ca\n            domain = domain.substring(0, domain.length - domainWithPrefixStandard.length);\n            parts = domain.split(\".\");\n            id = parts[parts.length - 1];\n            content = parts.slice(0, parts.length - 1).join(\".\");\n        \n            // Persistence to allow restore from the UI.\n            persistence.storeSubdomainRequest(id, content);\n\n            // Send real time data if the client is still connected.\n            if (map.hasOwnProperty(id) && map[id]) {\n                map[id][\"connection\"].sendText(JSON.stringify({\n                    \"type\" : \"request\", \n                    \"data\" : content \n                }));\n            }\n\n            logData(\"Data request : \" + domain +  \" (IP : \" + req.connection.remoteAddress + \")\\n\");\n        \n        } else if (domain.endsWith(domainWithPrefixIn)) {\n            // Dissect the request domain name to extract the data and generated id\n            // Format looks like : [data].[id].i.zhack.ca\n            domain = domain.substring(0, domain.length - domainWithPrefixIn.length);\n            parts = domain.split(\".\");\n            id = parts[parts.length - 1];\n            \n            logData(\"Input request : \" + domain + \" (IP : \" + req.connection.remoteAddress + \")\\n\");\n\n            // In and out request are only supported in real-time, no restore is done here.\n            if (map.hasOwnProperty(id) && map[id]) {\n                buffer = map[id][\"buffer\"];\n\n                res.answer.push({ \n                    name: res.question[0].name, \n                    type:'CNAME', \n                    data: bin2hex(buffer.substr(0, 30)) + \".\" +  bin2hex(buffer.substr(30, 30))  + domainWithPrefixOut, \n                    'ttl': 0 \n                });\n                res.end();\n\n                map[id][\"buffer\"] = buffer.substr(60);\n                map[id][\"connection\"].sendText(JSON.stringify({\n                    \"type\" : \"dataconsumed\", \n                    \"data\" : map[id][\"buffer\"].length \n                }));\n                return;\n            }\n        \n        } else {\n            // Unrecognized request (it's usually DNS scanner that looks for open DNS).\n            logData(\"No match ! \" + domain  +  \" (IP : \" + req.connection.remoteAddress + \")\\n\");\n        }   \n\n        // Always return localhost\n        res.end('127.0.0.1');\n    } catch (e) {\n    \n    }\n\n}).listen(53, '0.0.0.0');\n\nconsole.log(\"Started !\");\n\n",
        "called_code_segment_file_1": "function storeSubdomainRequest(subdomain, data) {\n\tdb.each(\"SELECT master FROM identity WHERE subdomain = ?; \", subdomain, function (err, row) {\n\t\tif (err) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (row[\"master\"]) {\n\t\t\tdb.run(\"INSERT INTO requests VALUES (?, ?, ?); \", row[\"master\"], data, new Date().getTime());\n\t\t}\n\t});\n}",
        "invoking_code_segment_file_2": "persistence.storeSubdomainRequest(id, content);",
        "called_code_segment_file_2": "function restoreFromMaster(master, callback) {\n\tdb.all(\"SELECT subdomain FROM identity WHERE master = ?\", master, function (err, rows) {\n\t\tif (err || rows.length == 0) {\n\t\t\tcallback({\"err\" : \"Master token not found !\", \"data\" : []});\n\t\t\treturn;\n\t\t}\n\n\t\tvar subdomain = rows[0][\"subdomain\"];\n\n\t\tdb.all(\"SELECT data FROM requests WHERE master = ? ORDER BY timestamp ASC\", master, function (err, rows) {\n\t\t\tif (err) {\n\t\t\t\tcallback({\"err\" : \"Error while finding existing request. \" + err, \"data\" : []});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallback({\"err\" : null, \"data\" : rows, \"subdomain\" : subdomain });\n\t\t});\n\t});\n}",
        "using_code_segment_file_3": "persistence.restoreFromMaster(data.master, function (data) {\n\t\t// If the restore was succesful we add the information to the map so \n\t\t// that the connection can receive real-time data.\n\t\tif (!data.err) {\n\t\t\ttoken = data.subdomain;\n\n\t\t\tmap[token] = {\n\t\t\t\t\"connection\" : conn, \n\t\t\t\t\"buffer\" : \"\" \n\t\t\t};\n\t\t}\n\n\t\tdata[\"type\"] = \"restore\";\n\t\tconn.sendText(JSON.stringify(data));\n});",
        "feature_description": "Add a feature to log the timestamp of each request stored in the database.",
        "detailed_feature_description": "Modify the `storeSubdomainRequest` function in `persistence.js` to log the timestamp of each request stored in the database. Update the `storeSubdomainRequest` call in `index.js` to pass the current timestamp. Ensure that the `restoreFromMaster` function in `persistence.js` is updated to include the timestamp in the response data.",
        "modified_complete_code": {
            "persistence.js": "var sqlite3   = require('sqlite3');\nvar config    = require('./config');\nvar fs        = require('fs');\n\nvar db = new sqlite3.Database(config.sqliteDatabase);\n\n// Make sure the table are initialized\ndb.serialize(function() {\n\tdb.run(\"CREATE TABLE IF NOT EXISTS requests (master TEXT, data TEXT, timestamp INTEGER); \");\n\tdb.run(\"CREATE TABLE IF NOT EXISTS identity (master TEXT, subdomain TEXT, timestamp INTEGER); \");\n\tdb.run(\"CREATE INDEX IF NOT EXISTS req_master ON requests (master); \");\n\tdb.run(\"CREATE INDEX IF NOT EXISTS ident_master ON identity (master); \");\n\tdb.run(\"CREATE INDEX IF NOT EXISTS ident_subdomain ON identity (subdomain); \");\n});\n\nfunction storeSubdomainRequest(subdomain, data, timestamp) {\n\tdb.each(\"SELECT master FROM identity WHERE subdomain = ?; \", subdomain, function (err, row) {\n\t\tif (err) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (row[\"master\"]) {\n\t\t\tdb.run(\"INSERT INTO requests VALUES (?, ?, ?); \", row[\"master\"], data, timestamp);\n\t\t}\n\t});\n}\n\nfunction createIdentity(master, subdomain) {\n\tdb.run(\"INSERT INTO identity VALUES (?, ?, ?); \", master, subdomain, new Date().getTime());\n}\n\nfunction restoreFromMaster(master, callback) {\n\tdb.all(\"SELECT subdomain FROM identity WHERE master = ?\", master, function (err, rows) {\n\t\tif (err || rows.length == 0) {\n\t\t\tcallback({\"err\" : \"Master token not found !\", \"data\" : []});\n\t\t\treturn;\n\t\t}\n\n\t\tvar subdomain = rows[0][\"subdomain\"];\n\n\t\tdb.all(\"SELECT data, timestamp FROM requests WHERE master = ? ORDER BY timestamp ASC\", master, function (err, rows) {\n\t\t\tif (err) {\n\t\t\t\tcallback({\"err\" : \"Error while finding existing request. \" + err, \"data\" : []});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcallback({\"err\" : null, \"data\" : rows, \"subdomain\" : subdomain });\n\t\t});\n\t});\n}\n\nexports.storeSubdomainRequest = storeSubdomainRequest;\nexports.createIdentity = createIdentity;\nexports.restoreFromMaster = restoreFromMaster;",
            "index.js": "// NodeJS dependencies\nvar dnsd      = require('dnsd');\nvar ws        = require(\"nodejs-websocket\");\nvar crypto    = require('crypto');\nvar fs        = require('fs');\n\n// Configuration & Custom module\nvar config = require('./config');\nvar persistence = require('./persistence');\nvar map = {};\n\nfunction bin2hex (d) {\n    var hex, i;\n\n    if (d == \"\") { \n        return \"00\"; \n    }\n\n    var result = \"\";\n    for (i=0; i<d.length; i++) {\n        hex = d.charCodeAt(i).toString(16);\n        result += (\"0\" + hex).slice(-2);\n    }\n\n    return result\n}\n\nfunction logData(message) {\n    if (config.logFile) {\n        fs.appendFile(config.logFile, \"[\" + (new Date().toString()) + \"] \" + message, function (err) {\n            if (err) {\n                console.error(\"Failed to log message ! \" + err);\n            }\n        });\n    }\n}\n\nvar server = ws.createServer(function (conn) {\n    try {\n        var token;\n        var master;\n\n        crypto.randomBytes(20, function(err, buffer) {\n            // If the token variable is already defined, this means \n            // a restore as already happened.\n            if (token) {\n                return;\n            }\n\n            try {\n                token  = buffer.toString('hex').substr(0,  20);\n                master = buffer.toString('hex').substr(20, 20);\n\n                map[token] = {\n                    \"connection\" : conn, \n                    \"buffer\" : \"\" \n                };\n\n                conn.sendText(JSON.stringify({\n                    \"type\" : \"token\", \n                    \"master\" : master, \n                    \"data\" : token \n                }));\n                \n                persistence.createIdentity(master, token);\n\n                logData(\"Token assignment '\" + token + \"' with IP '\" + conn.socket.remoteAddress + \"' \\n\");\n            } catch (e) {\n\n            }\n        });\n\n        conn.on(\"text\", function (data) {\n            try {\n                data = JSON.parse(data);\n\n                // When the attribute text is defined, the client is sending data for the in/out request.\n                if (data.text) {\n                    if (map[token][\"buffer\"].length + data.text.length > 2048) {\n                        map[token][\"connection\"].sendText(JSON.stringify({\n                            \"type\":\"error\", \n                            \"data\" : \"Maximum buffering is 2048 bytes.\"\n                        }));\n                        return;\n                    }\n                    map[token][\"buffer\"] += data.text;\n                }\n\n                // When the attribute restore is defined, the client is trying to restore the previously \n                // saved data from a master token.\n                if (data.restore && data.master) {\n                    persistence.restoreFromMaster(data.master, function (data) {\n                        // If the restore was succesful we add the information to the map so \n                        // that the connection can receive real-time data.\n                        if (!data.err) {\n                            token = data.subdomain;\n\n                            map[token] = {\n                                \"connection\" : conn, \n                                \"buffer\" : \"\" \n                            };\n                        }\n\n                        data[\"type\"] = \"restore\";\n                        conn.sendText(JSON.stringify(data));\n                    });\n                }\n\n            } catch (e) {}\n        })\n\n        conn.on(\"close\", function (code, reason) {\n            try {\n                delete map[token];\n            } catch (e) {\n\n            } \n        });\n    } catch (e) {\n    \n    }\n\n}).listen(config.websocketPort);\n\ndnsd.createServer(function(req, res) {\n\n    try {\n        var domain = res.question[0].name;\n\n        var domainWithPrefixStandard = config.prefixes[\"standard\"] + config.targetDomain;\n        var domainWithPrefixIn       = config.prefixes[\"in\"] + config.targetDomain;\n        var domainWithPrefixOut      = config.prefixes[\"out\"] + config.targetDomain;\n\n        if (domain.endsWith(domainWithPrefixStandard)) {\n            // Dissect the request domain name to extract the data and generated id\n            // Format looks like : [data].[id].d.zhack.ca\n            domain = domain.substring(0, domain.length - domainWithPrefixStandard.length);\n            parts = domain.split(\".\");\n            id = parts[parts.length - 1];\n            content = parts.slice(0, parts.length - 1).join(\".\");\n        \n            // Persistence to allow restore from the UI.\n            persistence.storeSubdomainRequest(id, content, new Date().getTime());\n\n            // Send real time data if the client is still connected.\n            if (map.hasOwnProperty(id) && map[id]) {\n                map[id][\"connection\"].sendText(JSON.stringify({\n                    \"type\" : \"request\", \n                    \"data\" : content \n                }));\n            }\n\n            logData(\"Data request : \" + domain +  \" (IP : \" + req.connection.remoteAddress + \")\\n\");\n        \n        } else if (domain.endsWith(domainWithPrefixIn)) {\n            // Dissect the request domain name to extract the data and generated id\n            // Format looks like : [data].[id].i.zhack.ca\n            domain = domain.substring(0, domain.length - domainWithPrefixIn.length);\n            parts = domain.split(\".\");\n            id = parts[parts.length - 1];\n            \n            logData(\"Input request : \" + domain + \" (IP : \" + req.connection.remoteAddress + \")\\n\");\n\n            // In and out request are only supported in real-time, no restore is done here.\n            if (map.hasOwnProperty(id) && map[id]) {\n                buffer = map[id][\"buffer\"];\n\n                res.answer.push({\n                    name: res.question[0].name, \n                    type:'CNAME', \n                    data: bin2hex(buffer.substr(0, 30)) + \".\" +  bin2hex(buffer.substr(30, 30))  + domainWithPrefixOut, \n                    'ttl': 0 \n                });\n                res.end();\n\n                map[id][\"buffer\"] = buffer.substr(60);\n                map[id][\"connection\"].sendText(JSON.stringify({\n                    \"type\" : \"dataconsumed\", \n                    \"data\" : map[id][\"buffer\"].length \n                }));\n                return;\n            }\n        \n        } else {\n            // Unrecognized request (it's usually DNS scanner that looks for open DNS).\n            logData(\"No match ! \" + domain  +  \" (IP : \" + req.connection.remoteAddress + \")\\n\");\n        }   \n\n        // Always return localhost\n        res.end('127.0.0.1');\n    } catch (e) {\n    \n    }\n\n}).listen(53, '0.0.0.0');\n\nconsole.log(\"Started !\");",
            "config.js": "// The domain name on which you have configured your DNS setup.\nvar targetDomain     = \"zhack.ca\";\n\n// Websocket URI that the client will use to connect\nvar websocketUrl     = \"ws://dns1.zhack.ca:8001/dnsbin\";\n\n// Subdomain used for the service.\nvar prefixes         = { \n\t\"standard\" : \".d.\", \n\t\"in\"       : \".i.\", \n\t\"out\"      : \".o.\" \n};\n\n// Where the logs are stored, use undefined or null if you don't want any log.\nvar logFile          = \"log.txt\";\n\n// Port used for the websocket communication. If you wish to change this value to \n// something else than the default 8001, make sure to change it in the index.html \n// page too.\nvar websocketPort    = 8001;\n\n// Use \":memory:\" if you don't want to store data on disk (recommended when testing)\n// Otherwise specify a filename\nvar sqliteDatabase   = \":memory:\"; \n\n// Maximum of entry stored in the database. Once the limit is reached older entry \n// will be deleted.\nvar sqliteMaxEntry   = 100000;\n\n// Polyfill for when this file is loaded in the browser.\nif (typeof window !== \"undefined\" && !window.exports) {\n\texports = {};\n}\n\nexports.targetDomain = targetDomain;\nexports.prefixes = prefixes;\nexports.logFile = logFile;\nexports.websocketPort = websocketPort;\nexports.sqliteDatabase = sqliteDatabase;\nexports.websocketUrl = websocketUrl;"
        }
    },
    {
        "repo": "dumb-react",
        "content": "'dumb-react/src/components/PrimaryNav/PrimaryNav.js'\n:import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport './PrimaryNav.css';\n\nexport class PrimaryNav extends Component {\n  render() {\n\n    return (\n      <nav className=\"c-primary-nav { this.props.styleModifier }\">\n        <ul className=\"c-primary-nav__list\">\n          {this.props.listItems.map(function(listItem, index){\n            return <li className=\"c-primary-nav__item\" key={`c-primary-nav__item-${index}`}>\n              <a href={ listItem.href }>\n                { listItem.text }\n              </a>\n            </li>\n          })}\n        </ul>\n      </nav>\n    );\n  }\n}\n\nPrimaryNav.propTypes = {\n  listItems: PropTypes.array.isRequired,\n  href: PropTypes.string,\n  text: PropTypes.string\n}\n\n\n'dumb-react/src/components/Header/Header.js'\n:import React, { Component } from \"react\";\nimport PropTypes from 'prop-types';\nimport \"./Header.css\";\nimport { Logo } from \"../Logo/Logo\";\nimport { PrimaryNav } from \"../PrimaryNav/PrimaryNav\";\nimport { InlineForm } from \"../InlineForm/InlineForm\";\nimport logoImg from \"../../images/fpo-120x60.png\";\nimport globals from \"../../data/globals.json\";\n\nexport class Header extends Component {\n    render() {\n        return (\n            <header className=\"c-header\" {...this.props}>\n                <Logo\n                    href=\"#\"\n                    src={logoImg}\n                    alt={globals.company.name}\n                />\n\n                <PrimaryNav\n                    listItems={[\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 1\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item \"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 3\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 4\"\n                        }\n                    ]}\n                />\n\n                <InlineForm\n\t\t\t\t\tmethod=\"post\"\n\t\t\t\t\taction=\"#\"\n                    placeholder=\"Search the site\"\n                    cta=\"Search\"\n                    id=\"search-form\"\n                    label=\"Search the site\"\n                />\n                {this.props.children}\n            </header>\n        );\n    }\n}\n\nHeader.propTypes = {\n    children: PropTypes.node\n}\n'dumb-react/src/components/Header/Header.stories.js'\n:import React from 'react';\nimport { storiesOf } from '@storybook/react';\nimport { withKnobs } from '@storybook/addon-knobs/react';\nimport { withSmartKnobs } from 'storybook-addon-smart-knobs';\nimport { Header } from './Header';\n\nlet stories = storiesOf('Global/Header', module);\n\nstories.addDecorator(withSmartKnobs).addDecorator(withKnobs);\n\nstories.add('Default', () =>\n  <Header />\n);\n\n",
        "called_code_segment_file_1": "export class PrimaryNav extends Component {\n  render() {\n    return (\n      <nav className=\"c-primary-nav { this.props.styleModifier }\">\n        <ul className=\"c-primary-nav__list\">\n          {this.props.listItems.map(function(listItem, index){\n            return <li className=\"c-primary-nav__item\" key={`c-primary-nav__item-${index}`}>\n              <a href={ listItem.href }>\n                { listItem.text }\n              </a>\n            </li>\n          })}\n        </ul>\n      </nav>\n    );\n  }\n}",
        "invoking_code_segment_file_2": "<PrimaryNav\n  listItems={[\n    {\n      href: \"#\",\n      text: \"Nav Item 1\"\n    },\n    {\n      href: \"#\",\n      text: \"Nav Item 2\"\n    },\n    {\n      href: \"#\",\n      text: \"Nav Item 3\"\n    },\n    {\n      href: \"#\",\n      text: \"Nav Item 4\"\n    }\n  ]}\n/>",
        "called_code_segment_file_2": "export class Header extends Component {\n  render() {\n    return (\n      <header className=\"c-header\" {...this.props}>\n        <Logo\n          href=\"#\"\n          src={logoImg}\n          alt={globals.company.name}\n        />\n        <PrimaryNav\n          listItems={[\n            {\n              href: \"#\",\n              text: \"Nav Item 1\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 2\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 3\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 4\"\n            }\n          ]}\n        />\n        <InlineForm\n          method=\"post\"\n          action=\"#\"\n          placeholder=\"Search the site\"\n          cta=\"Search\"\n          id=\"search-form\"\n          label=\"Search the site\"\n        />\n        {this.props.children}\n      </header>\n    );\n  }\n}",
        "using_code_segment_file_3": "stories.add('Default', () =>\n  <Header />\n);",
        "feature_description": "Add a new prop to PrimaryNav to allow custom classes for the nav items.",
        "detailed_feature_description": "The new feature allows passing a custom class name for each nav item through a new prop called 'itemClass'. This prop will be an array of strings, where each string corresponds to the class name for the respective nav item. The Header component will be updated to pass this new prop to the PrimaryNav component, and the PrimaryNav component will be modified to use this new prop to apply the custom class names to the nav items.",
        "modified_complete_code": {
            "file_1": "export class PrimaryNav extends Component {\n  render() {\n    return (\n      <nav className=\"c-primary-nav { this.props.styleModifier }\">\n        <ul className=\"c-primary-nav__list\">\n          {this.props.listItems.map(function(listItem, index){\n            return <li className={\"c-primary-nav__item \" + (this.props.itemClass ? this.props.itemClass[index] : '')} key={`c-primary-nav__item-${index}`}>\n              <a href={ listItem.href }>\n                { listItem.text }\n              </a>\n            </li>\n          }.bind(this))}\n        </ul>\n      </nav>\n    );\n  }\n}\n\nPrimaryNav.propTypes = {\n  listItems: PropTypes.array.isRequired,\n  href: PropTypes.string,\n  text: PropTypes.string,\n  itemClass: PropTypes.arrayOf(PropTypes.string) // #Modify\n}",
            "file_2": "export class Header extends Component {\n  render() {\n    return (\n      <header className=\"c-header\" {...this.props}>\n        <Logo\n          href=\"#\"\n          src={logoImg}\n          alt={globals.company.name}\n        />\n        <PrimaryNav\n          listItems={[\n            {\n              href: \"#\",\n              text: \"Nav Item 1\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 2\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 3\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 4\"\n            }\n          ]}\n          itemClass={['custom-class-1', 'custom-class-2', 'custom-class-3', 'custom-class-4']} // #Modify\n        />\n        <InlineForm\n          method=\"post\"\n          action=\"#\"\n          placeholder=\"Search the site\"\n          cta=\"Search\"\n          id=\"search-form\"\n          label=\"Search the site\"\n        />\n        {this.props.children}\n      </header>\n    );\n  }\n}",
            "file_3": "stories.add('Default', () =>\n  <Header />\n);"
        }
    },
    {
        "repo": "globalnoc-networkmap-panel",
        "content": "'globalnoc-networkmap-panel/src/js/map/NetworkLayer.js'\n:/*\nCopyright 2018 The Trustees of Indiana University\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar ds                  = require('../util/DataSource.js');\nvar _                   = require('lodash');\nvar BaseLayer           = require('./BaseLayer');\nvar Topology            = require('../util/Topology.js');\n//var DataSourceFormatter = require('../util/DataSourceFormatter');\nvar Functions           = require('../util/Functions.js');\nvar NETWORK_LAYER_TYPE  = require('../util/Enums').LAYER_TYPES.NETWORK;\nvar d3        = require('d3');\nrequire('d3-geo-projection')(d3); //externd d3 with extra geo projections\n/**\n* Adds additional network specific functionality to BaseLayer  \n* ```\nvar layer = NetworkLayer(config)\n```\n* @class NetworkLayer\n* @extends BaseLayer\n* @constructor BaseLayer\n* @static\n* @param {Object} params - The configuration object for the NetworkLayer\n* @param {Object:Optional} params.onLinkEvent - An object key'd on event types whose values are callbacks to be executed when the event happens to a link\n* @param {Object:Optional} params.onEndpointEvent - An object key'd on event types whose values are callbacks to be executed when the event happens to an endpoint\n* @param {Function:Required} params.onLatLngToXy - A function describing how to convert lat/lng coordinates to xy coordinates \n*/\nvar NetworkLayer = function(params){\n    var layer = BaseLayer(_.merge({ layerType: NETWORK_LAYER_TYPE }, params));\n    var offsets = params.offsets || [0];\n    if(!params.map){\n        console.error(\"Must pass in a reference to the containing map object!\");\n        return;\n    }\n    var tooltip;\n    if(params.tooltip){\n        tooltip = params.tooltip;\n    }\n   \n\n    /**\n     * A css hex color string used to define the color of the endpoints\n     * @property {String} endpointColor\n     * @private\n     */\n    var endpointColor;\n\n    /**\n     * A css opacity value to set the opacity of endpoints\n     * @property {Integer} endpointOpacity\n     * @private\n     */\n    var endpointOpacity;\n\n    /**\n     * A css hex color string used to define the color of link lines\n     * @property {String} lineColor\n     * @private\n     */\n    var lineColor;\n    \n    /**\n     * A css opacity value to set the opacity of link lines\n     * @property {Integer} lineOpacity\n     * @private\n     */\n    var lineOpacity;\n    /**\n     * The width of lines representing links on the layer \n     * @property {Integer} lineWidth\n     * @private\n     */\n    var lineWidth = params.lineWidth;\n    /**\n     * The function to be called when retrieving the maps' lineWidth\n     * @property {Funciton} onLineWidth\n     * @private\n     */\n    var onLineWidth = function(){};\n    /** \n     * The topology object of the network layer\n     * @property {Topology} topology - The Topology object of the network layer\n     * @private \n     */\n    var topology;\n    /** \n     * The function defining how to convert from xy coordinates to lat/lng coordinates\n     * @property {Function} onXyToLatLng\n     * @private \n     */\n    var onXyToLatLng = params.onXyToLatLng;\n\n\n    /** \n     * The function defining how to convert from xy coordinates to lat/lng coordinates\n     * @property {Function} onXyToLatLng\n     * @private \n     */\n    var max; \n    var min;\n\n    /** \n     * A function describing how to convert from lat/lng coordinates to xy coordinates \n     * @property {Function} onLatLngToXy\n     * @private \n     */\n    var onLatLngToXy = params.onLatLngToXy || \n        function(){ console.error(\"Must implement onLatLngToXy in extending layer class\"); };\n    /** \n     * An object whose keys are event types and values callbacks for those events to be called on endpoints elements \n     * @property {Object} onEndpointEvent\n     * @private \n     */\n    var onEndpointEvent = params.onEndpointEvent || {\n        mouseover: function(params){\n            layer.showEndpointInfo({\n                endpoint: params.data,\n                pos: params.pos\n            }); \n        },\n        mouseout: function(params){\n            layer.map().infoDiv().hide();\n        },\n        click: function(params){\n            layer.showEndpointInfo({\n                endpoint: params.data,\n                pin: true\n            }); \n        }\n    };\n\n    /** \n     * An object whose keys are event types and values callbacks for those events to be called on link elements \n     * @property {Object} onLinkEvent\n     * @private \n     */\n    var onLinkEvent = params.onLinkEvent || {\n        mouseover: function(params){ \n            layer.showLinkInfo({\n                link: params.data,\n\t\t        pos: params.pos\n            }); \n        },\n        mouseout: function(params){\n            layer.map().infoDiv().hide();\n        },\n        click: function(params){\n            layer.showLinkInfo({\n                link: params.data,\n                pin: true\n            }); \n        }            \n    };\n    /** \n     * A function describing what to do when the layer's topology is set \n     * @property {Function} onTopology\n     * @private \n     */\n    var onTopology = function(){};\n    /** \n     * A function describing how to retrieve the endpoint elements of the layer\n     * @property {Function} onEndpoints\n     * @private \n     */\n    var onEndpoints = function(){ console.error(\"Must implement onEndpoints in extending layer class\"); };\n    /** \n     * A function describing how to retrieve the link elements in the layer\n     * @property {Function} onLinks\n     * @private \n     */\n    var onLinks = function(){ console.error(\"Must implement onLinks in extending layer class\"); };\n    /** \n     * A function, given an link object, returns the bounding box for the dom window of the link\n     * @property {Function} onLinkBoundingClientRect\n     * @private \n     */\n    var onLinkBoundingClientRect = function(){ console.error(\"Must implement onLinkBoundingClientRect in extending layer class\"); };\n\n    //helper function to make sure some arguements are always passed into the event callback\n    function _onEventWrapper(evt, callback){\n        return function(){\n            if(!layer.active()){ return; }\n            if(arguments[0].constructor !== Object){\n                console.error('First argument of event handler must be an object!');\n                return;\n            }\n            var data     = arguments[0].data;\n            var eventObj = arguments[0].event;\n            \n            if(data === undefined){\n                console.error('Must pass in data for clicked object');\n                return;\n            }\n\n            //include a boundingClientRect in the function args\n            var bb = layer.getBoundingClientRect({\n                data: data,\n                event: eventObj\n            });\n            arguments[0].bb = bb;\n            \n            console.debug(evt+' '+data.name);\n            callback.apply(layer, arguments); \n        }\n    }\n\n    //helper method to register an event\n    function _registerEvent(onEvent, args){\n        if(!args.length){\n            return onEvent;\n        }\n        else if(args.length === 1 && args[0].constructor === Object){\n            var eventObj = args[0];\n            _.forEach(eventObj, function(callback, evt){\n                onEvent[evt] = _onEventWrapper(evt, callback);\n            });\n        }\n        else if(args.length === 2){\n            var evt      = args[0];\n            var callback = args[1];\n            onEvent[evt] = _onEventWrapper(evt, callback);\n        }else {\n            console.error(\"onEvent must be called with either an event string and callback or an object whose keys are event strings and values are callbacks\");\n            return;\n        }\n        return true;\n    }\n\n    /**\n     * A Getter/Setter for link events. Callbacks can be set two ways; 1.) First arg is event type string and the second arg is the callback to be executed.\n     * 2.) A single object arg whose keys are event type strings and whose values are the callbacks to be executed when that event type occurs\n     * @method onLinkEvent\n     * @param {String:Optional} evt - The event to set the callback for\n     * @param {Function:Optional} callback - The callback to be executed given the evt event type\n     * @param {Object:Optional} callback_object - A function whose keys are event types and values callback s\n     * @chainable\n     */\n    layer.onLinkEvent = function(){\n        var ret = _registerEvent(onLinkEvent, arguments);\n        if(ret !== true ){ return ret; }\n        return layer; \n    };\n\n    /**\n     * A Getter/Setter for endpoint events. Callbacks can be set two ways; 1.) First arg is event type string and the second arg is the callback to be executed.\n     * 2.) A single object arg whose keys are event type strings and whose values are the callbacks to be executed when that event type occurs\n     * @method onEndpointEvent\n     * @param {String:Optional} evt - The event to set the callback for\n     * @param {Function:Optional} callback - The callback to be executed given the evt event type\n     * @param {Object:Optional} callback_object - A function whose keys are event types and values callback s\n     * @chainable\n     */\n    layer.onEndpointEvent = function(){\n        var ret = _registerEvent(onEndpointEvent, arguments);\n        if(ret !== true ){ return ret; }\n        return layer; \n    };\n\n    //helper function to format the bps string\n    function _formatRate(bps){\n        var prefix = d3.formatPrefix(bps);\n\n        return d3.format(',.3f')(parseFloat(prefix.scale(bps))) + ' ' + prefix.symbol + 'bps';\n    }\n\n    //helper function to get the styling for the circles that indicate laod color in the infoDiv when hovering over a link\n    function _getBadgeStyle(color){\n        var dc = d3.rgb(color).darker();\n        return 'style=\"background-color: '+color+'; border-color: '+dc+'; text-shadow: 1px 1px '+dc+';\"';\n    }\n    \n\n    function _parseHtml(htmlContent, element){\n        var customContent = htmlContent;\n        const possible_vars = ['$input.min','$input.max','$input.avg','$input.sum','$input.now','$output.min','$output.max','$output.avg','$output.sum','$output.now','$name','$input.name','$output.name','$count', '$node.min', '$node.max', '$node.avg', '$node.sum', '$node.label','$node.current'];\n        _.forEach(possible_vars, function(variable){\n            switch(variable){ \n                case '$name':\n                    if(customContent.search(/\\$name/g) > 0) { \n                        customContent = customContent.replace(/\\$name/g, element.name);\n                    }\n                    break;\n                case '$count':\n                    if(customContent.search(/\\$count/g) > 0) {\n                        customContent = customContent.replace(/\\$count/g, element.count);\n                    }\n                    break;\n                case '$input.min':\n                    if(customContent.search(/\\$input.min/g) > 0) {\n                        customContent = customContent.replace(/\\$input.min/g, element.az.min);\n                    }\n                    break;\n                case '$input.max':\n                    if(customContent.search(/\\$input.max/g) > 0) {\n                        customContent = customContent.replace(/\\$input.max/g, element.az.max);\n                    }\n                    break;\n                case '$input.avg':\n                    if(customContent.search(/\\$input.avg/g) > 0) { \n                        customContent = customContent.replace(/\\$input.avg/g, element.az.avg);\n                    }\n                    break;\n                case '$input.sum':\n                    if(customContent.search(/\\$input.sum/g) > 0) {\n                        customContent = customContent.replace(/\\$input.sum/g, element.az.sum);\n                    }\n                    break;\n                case '$input.now':\n                    if(customContent.search(/\\$input.now/g) > 0) {\n                        customContent = customContent.replace(/\\$input.now/g, element.az.now);\n                    }\n                    break;\n                case '$input.name':\n                    if(customContent.search(/\\$input.name/g) > 0) {\n                        if(element.az.label) element.az.name = element.az.label;\n                        customContent = customContent.replace(/\\$input.name/g, element.az.name);\n                    }\n                    break;\n                case '$output.min':\n                    if(customContent.search(/\\$output.min/g) > 0) {\n                        customContent = customContent.replace(/\\$output.min/g,element.za.min);\n                    } \n                    break;\n                case '$output.max':\n                    if(customContent.search(/\\$output.max/g) > 0) {\n                        customContent = customContent.replace(/\\$output.max/g,element.za.max);\n                    }\n                    break;\n                case '$output.avg':\n                    if(customContent.search(/\\$output.avg/g) > 0) {\n                        customContent = customContent.replace(/\\$output.avg/g, element.za.avg);\n                    }    \n                    break;\n                case '$output.sum':\n                    if(customContent.search(/\\$output.sum/g) > 0) {\n                        customContent = customContent.replace(/\\$output.sum/g, element.za.sum);\n                    }\n                    break;\n                case '$output.now':\n                    if(customContent.search(/\\$output.now/g) > 0) {\n                        customContent = customContent.replace(/\\$output.now/g, element.za.now);\n                    }\n                    break;\n                case '$output.name':\n                    if(customContent.search(/\\$output.name/g) > 0) {\n                        if(element.za.label) element.za.name = element.za.label;\n                        customContent = customContent.replace(/\\$output.name/g, element.za.name);\n                    }\n                    break;\n                case '$node.label':\n                    if(customContent.search(/\\$node.label/g) > 0) {\n                        customContent = customContent.replace(/\\$node.label/g, element.label);\n                    }\n                    break;\n                case '$node.min':\n                    if(customContent.search(/\\$node.min/g) > 0) {\n                        customContent = customContent.replace(/\\$node.min/g, element.min);\n                    }\n                    break;\n                case '$node.max':\n                    if(customContent.search(/\\$node.max/g) > 0) {\n                        customContent = customContent.replace(/\\$node.max/g, element.max);\n                    }\n                    break;\n                case '$node.avg':\n                    if(customContent.search(/\\$node.avg/g) > 0) {\n                        customContent = customContent.replace(/\\$node.avg/g, element.avg);\n                    }\n                    break;\n                case '$node.sum':\n                    if(customContent.search(/\\$node.sum/g) > 0) {\n                        customContent = customContent.replace(/\\$node.sum/g, element.sum);\n                    }\n                    break;\n                case '$node.current':\n                    if(customContent.search(/\\$node.current/g) > 0) {\n                        customContent = customContent.replace(/\\$node.current/g, element.cur);\n                    }\n                    break;\n                default:\n                    break;\n            }\n        });\n        return customContent;\n    }\n\n    //helper function to create the body markup for the details div when hovering over an endpoint\n\n    function _createEndpointInfoMarkup(endpoint){\n\n        if(tooltip.show && tooltip.showNodeHover && tooltip.node_content){\n            let customHtml = _parseHtml(tooltip.node_content, endpoint);\n            return customHtml;\n        } else if(tooltip.showNodeHover){\n            return '<div>Enter your custom node hover box display options or uncheck custom node tooltip option</div>';\n        }\n        var endpointStr =`<div class=\"pop-info\">`;\n        if(endpoint.label){\n            endpointStr += `<div><b>Endpoint Label: </b> ${endpoint.label} </div>`;\n        }\n        endpointStr += `<div><b>Endpoint Name: </b> ${endpoint.name} </div>`;\n        endpointStr += `<hr>`; \n        endpointStr += `<div>`; \n        endpointStr += `<div><table>`;\n        endpointStr += `<tr><td style=\"font-weight: bold;text-align:left\">Min:</td><td> ${endpoint.min} </td></tr>`;\n        endpointStr += `<tr><td style=\"font-weight: bold;text-align:left\">Max:</td><td> ${endpoint.max} </td></tr>`;\n        endpointStr += `<tr><td style=\"font-weight: bold;text-align:left\">Average:</td><td> ${endpoint.avg} </td></tr>`;\n        endpointStr += `<tr><td style=\"font-weight:bold;text-align:left\">Current:</td><td> ${endpoint.cur} </td></tr>`;\n        endpointStr += `</table></div>`;\n        \n        endpointStr += `</div>`;\n\n        endpointStr += `</div>`;\n        return endpointStr;\n    }\n\n\n    //helper function to create the body markup for the details div when hovering over a link\n    function _createLinkInfoMarkup(link){\n\n        if(tooltip.show && tooltip.showLinkHover && tooltip.content){\n            let customHtml = _parseHtml(tooltip.content, link);\n            return customHtml;\n        } else if(tooltip.showLinkHover){\n            return '<div>Enter your custom link hover box display options or uncheck custom link tooltip option</div>';\n        }  \n        //create the markup\n        var linkStr = '<div class=\"adj-info\">';\n        linkStr    += '<div><b>Link:</b> ' + link.name +'</div>';\n        linkStr += '<hr>';\n        linkStr += '<div>';\n        if(link.az.label){\n            linkStr += '<div style=\"float: left\"><div><center> To <b>' + link.az.label + '</b></center></div>'; \n        }else {\n            linkStr += '<div style=\"float: left\"><div><center> To <b>' + link.az.name + '</b></center></div>';  \n        }\n        linkStr += '<div><table>';\n        linkStr += '<tr><td style=\"font-weight:bold\">Now:</td><td>' + link.az.now + '</td><td>Gbps</td></tr>';\n        linkStr += '<tr><td style=\"font-weight:bold\">Min:</td><td>' + link.az.min + '</td><td>Gbps</td></tr>';\n        linkStr += '<tr><td style=\"font-weight:bold\">Max:</td><td>' + link.az.max + '</td><td>Gbps</td></tr>';\n        linkStr += '<tr><td style=\"font-weight:bold\">Avg:</td><td>' + link.az.avg + '</td><td>Gbps</td></tr>'; \n        linkStr += '<tr><td style=\"font-weight:bold\">Sum:</td><td>' + link.az.sum + '</td><td>Gbps</td></tr>';\n        linkStr += '</table></div></div>';\n        \n        if(link.za.label){\n            linkStr += '<div style=\"float: right\"><div><center> To <b>' + link.za.label + '</b></center></div>';\n        } else{\n            linkStr += '<div style=\"float: left\"><div><center> To <b>' + link.za.name + '</b></center></div>';\n        } \n        linkStr += '<div><table>';\n        linkStr += '<tr><td style=\"font-weight:bold\">Now:</td><td>' + link.za.now + '</td><td>Gbps</td></tr>';\n        linkStr += '<tr><td style=\"font-weight:bold\">Min:</td><td>' + link.za.min + '</td><td>Gbps</td></tr>';\n        linkStr += '<tr><td style=\"font-weight:bold\">Max:</td><td>' + link.za.max + '</td><td>Gbps</td></tr>';\n        linkStr += '<tr><td style=\"font-weight:bold\">Avg:</td><td>' + link.za.avg + '</td><td>Gbps</td></tr>'; \n        linkStr += '<tr><td style=\"font-weight:bold\">Sum:</td><td>' + link.za.sum + '</td><td>Gbps</td></tr>';\n        linkStr += '</table></div></div></div>';\n\n        linkStr += '</div>';\n        return linkStr;\n    }\n\n    /**\n     * Displays a panel in the lower right corner of the map containing information about a link\n     * @method showLinkInfo \n     * @param {Object} params - The method parameters \n     * @param {Object} params.link - The link object of the link to display info on\n     * @param {Boolean} params.pin - If true the panel will continue to be displayed in the corner otherwise it will dissapear after a few moments\n     * @chainable\n     */\n    layer.showLinkInfo = function(params){\n        var link = params.link; \n        var div_pos = params.pos;\n        if(!tooltip.show) return;\n        var linkStr = _createLinkInfoMarkup(link);\n\n        //if the infoDiv is not already pinned and we were told to pin this\n        //select and update \n        if(params.pin){\n            if(layer.map().infoDiv().pin()){\n                layer.map().deselectAll();\n            }\n            link.selected = true;\n            layer.map().update();\n        }\n\n        layer.map().infoDiv().show({\n            width: 400,\n            content: linkStr,\n            pin: params.pin,\n\t        pos: div_pos // cursor coordinates\n        });\n    };\n\n    /**\n     * A method to update the content of the infoDiv with LinkInformation\n     * @method updateLinkInfo\n     * @param {Object} params - The method parameters \n     * @param {Object} params.link - The link object of the link to display info on\n     * @chainable\n     */\n    layer.updateLinkInfo = function(params){\n        var link = params.link; \n\n        var linkStr = _createLinkInfoMarkup(link);\n        \n        layer.map().infoDiv().setContent({\n            content: linkStr\n        });\n    };\n\n    \n    layer.updateEndpointInfo = function(params){\n        var endpoint = params.endpoint;\n        var endpointStr = _createEndpointInfoMarkup(endpoint);\n        layer.map().infoDiv().setContent({\n            content: endpointStr\n        });\n    };\n\n    /**\n     * Displays a panel in the lower right corner of the map containing information about a endpoint\n     * @method showEndpointInfo \n     * @param {Object} params - The method parameters \n     * @param {Object} params.endpoint - The endpoint object of the endpoint to display info on\n     * @param {Boolean} params.pin - If true the panel will continue to be displayed in the corner otherwise it will dissapear after a few moments\n     * @chainable\n     */\n    layer.showEndpointInfo = function(params){\n        if (params.static_tooltip) return;\n        var endpoint = params.endpoint; \n        var div_pos = params.pos;\n        if(!tooltip.show) return;\n        var endpointStr = _createEndpointInfoMarkup(endpoint); \n        //if it's pinned select the link\n        if(params.pin){\n            endpoint.selected = true;\n            layer.map().update();\n        }\n        layer.map().infoDiv().show({\n            width: 100,\n            content: endpointStr,\n            pin: params.pini,\n            pos: div_pos\n        });\n    };\n    \n    /**\n     * A Getter/Setter for the onEndpoints method\n     * @method onEndpoints\n     * @param {Function} value - The method describing how to get endpoint elements for the layer \n     * @chainable\n     */\n    layer.onEndpoints = function(value){\n        if(!arguments.length){ return onEndpoints; }\n        onEndpoints = value;\n        return layer;\n    };\n\n    /**\n     * A function that returns the endpoint elements for the layer \n     * @method endpointss\n     * @chainable\n     */\n    layer.endpoints = function(){\n        return onEndpoints();\n    };\n\n    /**\n     * A function sets and gets the max bps of the layer for computing load %\n     * @method max\n     * @chainable\n     */\n    layer.max = function(value){\n        if(!arguments.length){ return max; }\n\n        max = value;\n        \n        return max;\n    };\n\n    layer.min = function(value){\n\tif(!arguments.length){ return min; }\n\tmin = value;\n\treturn min;\n    };\n\n    /**\n     * A Getter/Setter for the onLinks\n      @method onLinks\n     * @param {Function} value - The method describing how to get link elements for the layer\n     * @chainable\n     */\n    layer.onLinks = function(value){\n        if(!arguments.length){ return onLinks; }\n        onLinks = value;\n        return layer;\n    };\n    \n    /**\n     * A function that returns the link elements for the layer \n     * @method links\n     * @chainable\n     */\n    layer.links = function(){\n        return onLinks();\n    };\n\n    /**\n     * A Getter/Setter for the onLatLngToXy method\n     * @method onLatLngToXy\n     * @param {Function} value - The method describing how to convert lat/lng coordiantes to xy coordiates\n     * @chainable\n     */\n    layer.onLatLngToXy = function(value){\n        if(!arguments.length){ return onLatLngToXy; }\n        onLatLngToXy = value;\n        return layer;\n    };\n\n    /**\n     * A method that converts lat/lng coordiantes to xy coordinates\n     * @method onLatLngToXy\n     * @return {Array} xy - An array in the format [{x},{y}]\n     */\n    layer.latLngToXy = function(){\n        return onLatLngToXy.apply(layer, arguments);\n    };\n    \n    /**\n     * A Getter/Setter for the onXyToLatLng method\n     * @method onXyToLatLng\n     * @param {Function} value - The method describing how to convert xy coordiantes to lat/lng coordiantes \n     * @chainable\n     */\n    layer.onXyToLatLng = function(value){\n        if(!arguments.length){ return onXyToLatLng; }\n        onXyToLatLng = value;\n        return layer;\n    };\n\n    /**\n     * A method that converts xy coordiantes to lat/lng coordinates\n     * @method xyToLatLng\n     * @return {Array} latlng - An array in the format [{lat},{lng}]\n     */\n    layer.xyToLatLng = function(){\n        return onXyToLatLng.apply(layer, arguments);\n    };\n\n    /**\n     * A method that takes either an link object or a endpoint object and returns a boundingClientRect\n     * a boundingClientRect\n     * @method getBoundingClientRect\n     * @return {Object} boundingClientRect - An object containing values in catesian space for top, left, right, bottom, height,\n     * and width \n     */\n    layer.getBoundingClientRect = function(params){\n        var data     = params.data;\n        var eventObj = params.event;\n\n        var bb;\n        //if an event obj exists just determine the bounding box from the target\n        if(eventObj){\n            bbClientRect = eventObj.target.getBoundingClientRect();\n            bb = {\n                top: bbClientRect.top,\n                bottom: bbClientRect.bottom,\n                right: bbClientRect.right,\n                left: bbClientRect.left,\n                width: bbClientRect.width,\n                height: bbClientRect.height\n            };\n        }\n        //otherwise if the data.path key exists it's a link\n        else if(data.path){\n            bb = layer.linkBoundingClientRect({ link: data });\n        }\n        //otherwise it must be a endpoint\n        else if(data.lat !== undefined && data.lon !== undefined) {\n            bb = layer.endpointBoundingClientRect({ endpoint: data });\n        }\n        else {\n            console.error(\"Error! Must pass an link, endpoint object, or an event object to determine the bounding box!\");\n            return;\n        }\n\n        return bb;\n    };\n\n    /**\n     * Takes a client bounding box for a network topology element and subtracts the container bounding box\n     * values from it. This is used to correct bounding box values that are relative to the container instead\n     * of absolute coordinates on the page, such as those returned for cesium elements.\n     * @method subtractContainerBoundingClientRect\n     * @param {Object} params - The parameter object \n     * @param {Object} params.bb - The bounding box of the netork topology element\n     * @chainable\n     */\n    layer.subtractContainerBoundingClientRect = function(params){\n        if(!params.bb){\n            console.error(\"Must pass in the bounding box object\");\n            return;\n        }\n        var bb = params.bb;\n\n        var containerBB = d3.select('#'+layer.map().containerId()).node().getBoundingClientRect();\n        //subtract the container's offset\n        _.forEach(['left','right','top','bottom'], function(key){\n            bb[key] = bb[key] + containerBB[key];\n        });\n\n        return bb;\n    };\n\n    /**\n     * A Getter/Setter for the onBoundingBoxClientRect method\n     * @method onBoundingBoxClientRect\n     * @param {Function} value - The method describing what to do when the topology object is set\n     * @chainable\n     */\n    layer.onLinkBoundingClientRect = function(value){\n        if(!arguments.length){ return onLinkBoundingClientRect; }\n        onLinkBoundingClientRect = value;\n        return layer;\n    };\n    \n    /**\n     * A method that takes either a link object or an endpoint object and returns a boundingClientRect\n     * a boundingClientRect\n     * @method boundingClientRect\n     * @return {Object} boundingClientRect - An object containing values in catesian space (the Dom window's cartesian space\n     * for top, left, right, bottom, height, and width \n     */\n    layer.linkBoundingClientRect = function(params){\n        if(!params.link){\n            console.error(\"Must pass in the link data object\");\n            return;\n        }\n\n        return onLinkBoundingClientRect.apply(layer, arguments);\n    };\n    \n    /**\n     * A Getter/Setter for the onTopology method\n     * @method onTopology\n     * @param {Function} value - The method describing what to do when the topology object is set \n     * @chainable\n     */\n    layer.onTopology = function(value){\n        if(!arguments.length){ return onTopology; }\n        onTopology = value;\n        return layer;\n    };\n\n    /**\n     * A method that converts xy coordiantes to lat/lng coordinates\n     * @method xyToLatLng\n     * @return {Array} latlng - An array in the format [{lat},{lng}]\n     * @chainable\n     * @return {[Topology](Topology.html) topology - Returns a Topology object\n     */\n    layer.topology = function(value, params){\n        if(!arguments.length){ return topology; }\n        //convert to a Topology Object if it's not one already\n        if(value.__factory__ === undefined || value.__factory__ !== 'Topology'){\n            topology = Topology(value, offsets);\n        }else {\n            topology = value;\n        }\n        onTopology.call(layer, topology, params);\n\n        layer.update();\n\n        return layer;\n    };\n\n    /**\n     * Getter/Setter of the onLineWidth function\n     * @method onLineWidth\n     * @param {Function} value - Method that defines how to compute line width for the map (Generally line width is relative to zoom level)\n     * @chainable\n     */\n    layer.onLineWidth = function(value){\n        if(!arguments.length){ return onLineWidth; }\n        onLineWidth = value;\n        return layer;\n    };\n\n    /**\n     * Getter/Setter the lineWidth of lines representing links on the layer\n     * @method lineWidth\n     * @param  {Integer} value - The new value of the lineWidth\n     * @return {Integer} lineWidth - Returns the current lineWidth\n     * @chainable\n     */\n    layer.lineWidth = function(value){\n        if(arguments.length === 0){ return lineWidth; }\n        \n        lineWidth = value;\n        onLineWidth.call(layer, lineWidth);\n\n        return layer;\n    };\n\n    /**\n     * Getter/Setter the endpointColor of the circles representing nodes on the layer\n     * @method endpointColor \n     * @params {String} value - The new value of the endpointColor as a css color string\n     * @return {String} endpointColor - Returns the current endpointColor\n     */\n    layer.endpointColor = function(value){\n        if(arguments.length === 0){ return endpointColor; }\n        endpointColor = value;\n        return layer;\n    };\n\n    /**\n     * Getter/Setter the lineColor of lines representing links on the layer\n     * @method lineColor\n     * @param  {String} value - The new value of the lineColor as a css color string\n     * @return {String} lineColor - Returns the current lineColor\n     * @chainable\n     */\n    layer.lineColor = function(value){\n        if(arguments.length === 0){ return lineColor; }\n       \n        lineColor = value;\n        \n        return layer;\n    };\n\n    /**\n     * Getter/Setter the endpointOpacity of circles representing nodes on the layer\n     * @method endpointOpacity\n     * @param {Integer} value - The new value of the endpointOpacity as a css opacity value\n     * @return endpointOpacity - Returns the current endpointOpacity\n     */\n    \n    layer.endpointOpacity = function(value){\n        if(arguments.length === 0){ return endpointOpacity; }\n        endpointOpacity = value;\n        return layer;\n    };\n\n    /** \n     * Getter/Setter the lineOpacity of lines representing links on the layer \n     * @method lineOpacity\n     * @param {Integer} value - The new value of the lineOpacity as a css opacity value\n     * @return lineOpacity - Returns the current lineOpacity\n     * @chainable\n     */\n    layer.lineOpacity = function(value){\n        if(arguments.length === 0){ return lineOpacity; }\n        lineOpacity = value;\n        return layer;\n    };\n\n    function _isJson(str){\n        try {\n            JSON.parse(str);\n        } catch(e){\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * A method that takes a [DataSource](DataSource.html) source object and restrieves a map topology\n     * @method loadMap\n     * @chainable\n     */\n    layer.loadMap = function(source){\n        let json_obj;\n        if(_isJson(source)){\n            json_obj = JSON.parse(source);\n            let topo = json_obj.results[0];\n            if(!topo){\n                console.log('No map topology returned for the given source');\n                return;\n            }\n            layer.topology(topo);\n        } else {\n            var req = ds({\n                source: source,\n                onSuccess: function(params){\n                    var d = params.data.results[0];\n                    if(!d){\n                        console.error('No map topology returned for '+layer.name()+' ',req);\n                        return;\n                    }\n                    layer.topology(d);\n                }\n            });\n        }\n        return layer;\n    };\n\n    //extend update function to include updating the info div\n    var _superUpdate = layer.update;\n    layer.update = function(){\n        //do inherited update\n        var success = _superUpdate.apply(layer, arguments);\n        \n        //now check to see if we need to update our infoDiv\n        if (layer.map().infoDiv().pin()) {\n            if(!layer.topology()){ return; }\n            var links = _.find(layer.topology().data().links, function(a) {\n                return a.selected;\n            });\n            if (links) {\n                layer.updateLinkInfo({ link: links });\n            }\n        }\n        return success;\n    };\n    // initialize event handlers if there are any\n    if(params.onEndpointEvent){\n        layer.onEndpointEvent(params.onEndpointEvent);\n    }\n    if(params.onLinkEvent){\n        layer.onLinkEvent(params.onLinkEvent);\n    }\n    if(params.max){\n        layer.max(params.max);\n    }\n    if(params.min){\n\tlayer.min(params.min);\n    }\n\n    layer.endpointColor(params.endpointColor || '#dddddd');\n    layer.endpointOpacity(params.endpointOpacity || 1);\n    layer.lineColor(params.lineColor || '#262F36');\n    layer.lineOpacity(params.lineOpacity || 1);\n\n    return layer; \n};\nmodule.exports = NetworkLayer;\n\n'globalnoc-networkmap-panel/src/js/map/SingleTubeLayer.js'\n:/*\nCopyright 2018 The Trustees of Indiana University\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar d3                 = require('d3');\nvar NetworkLayer       = require('./NetworkLayer');\nvar ARROW              = require('../util/Enums').ARROW;\nvar _                  = require('lodash');\n/** \n* Renders a topology object as d3 lines and circles into the provided svg element\n```\nsingleTubeLayer = SingleTubeLayer({\n        name: layer.name(),\n        svg:  svg.append(\"g\")\n    })\n    //--- let d3 do the projecting for this example\n    .onLatLngToXy(layer.onLatLngToXy())\n    .onLinkEvent('mouseover', function(d){\n        d3.select(d.event.target).style(\"cursor\", \"pointer\");\n    })\n    .onLinkEvent('mouseout', function(d){\n        d3.select(d.event.target).style(\"cursor\", \"default\");\n    })\n    .onEndpointEvent('mouseover', function(d){\n        d3.select(d.event.target).style(\"cursor\", \"pointer\");\n    })\n    .onEndpointEvent('mouseout', function(d){\n        d3.select(d.event.target).style(\"cursor\", \"default\");\n    });\n```\n* @class SingleTubeLayer\n* @extends BaseLayer\n* @constructor SingleTubeLayer\n* @static \n* @property {Object} params - The parameter object for the Layer\n* @property {d3.selection(svg):Required} params.svg - A d3 selection of the svg element to render the editor layer into \n*/\n\nvar SingleTubeLayer = function(params){\n    params.lineColor = params.lineColor || '#ddd';\n    params.lineOpacity = params.lineOpacity || 1;\n    params.endpointOpacity = params.endpointOpacity || 1;\n    params.endpointColor = params.endpointColor || '#ddd';\n    console.log(params)\n    var layer = NetworkLayer(params);\n    if(!params.svg){\n        console.error('Must pass in a svg element to render into');\n        return;\n    }\n    var tooltip;\n    if(params.tooltip){\n        tooltip = params.tooltip;\n    }\n    //add an id and class to the layer\n    var svg = params.svg;\n    svg.attr('id', layer.layerId());\n    svg.classed(params.map.containerId(), true);\n    svg.classed('single-tube', true);\n\n    //define how to toggle the layer\n    layer.onToggle(function(active){\n        svg.transition().style('opacity', (active) ? 1 : 0);\n    });\n\n\n    var line = d3.svg.line()\n    .interpolate(\"bundle\")\n    .x(function(d) {\n            return layer.latLngToXy([d.lat, d.lon])[0];\n        })\n    .y(function(d) {\n            return layer.latLngToXy([d.lat, d.lon])[1];\n        });\n    \n    //set default event handlers for links if none were passed in\n    layer.onLinkEvent(params.onLinkEvent || {\n        click: function(d){\n            layer.showLinkInfo({\n                link: d.data,\n                pin: true\n            });\n            d3.event.stopPropagation();\n        },\n        mouseover: function(d){ \n            if(!tooltip.show){\n                d3.select(d.event.target).style(\"cursor\",\"default\"); \n                return;\n            }\n            layer.showLinkInfo({\n    \t\tlink: d.data,\n\t    \tpos: {\n\t\t        page_x: d.event.pageX,\n\t\t        page_y: d.event.pageY\n\t\t    }   \n            });\n            d3.select(d.event.target).style(\"cursor\", \"pointer\");\n        },\n        mouseout: function(d){\n            layer.map().infoDiv().hide();\n            d3.select(d.event.target).style(\"cursor\", \"default\");\n        }\n    });\n\n    //set default event handlers for endpoints if none were passed in\n    layer.onEndpointEvent(params.onEndpointEvent || {\n        click: function(d){\n            layer.showEndpointInfo({\n                endpoint: d.data,\n                pin: true\n            });\n            d3.event.stopPropagation();\n        },\n        mouseover: function(d){\n            if(!tooltip.show){\n                d3.select(d.event.target).style(\"cursor\",\"default\");\n            }\n            layer.showEndpointInfo({\n                endpoint: d.data,\n                pos: {\n                    page_x: d.event.pageX,\n                    page_y: d.event.pageY\n                },\n                static_tooltip: params.static_node_tooltip\n            });\n            d3.select(d.event.target).style(\"cursor\", \"pointer\");\n        },\n        mouseout: function(d){\n            layer.map().infoDiv().hide();\n            d3.select(d.event.target).style(\"cursor\", \"default\");\n        }\n    });\n\n    /**\n     * Returns the d3 svg selection\n     * @method svg\n     * @return {d3.selection(svg)} params.svg - A d3 selection of the svg element\n     */\n    layer.svg = function(){\n        return svg\n    };\n\n    //define how to remove the layer\n    layer.onRemove(function(){\n        svg.selectAll(\"*\").remove();\n    });\n\n    //define how to retrieve the link elements\n    layer.onLinks(function(){\n        return svg.selectAll(\"g.adjacency\");\n    });\n\n    //define how to retrieve the endpoint elements\n    layer.onEndpoints(function(){\n        return svg.selectAll(\"g.pop\");\n    }); \n   \n    //helper function to get the angle of the directional arrow \n    function getAngle(pointA,pointB) {\n        var dy = pointB.y - pointA.y\n        var dx = pointB.x - pointA.x;\n        // range (-PI, PI]\n        var theta = Math.atan2(dy, dx); \n        // rads to degs, range (-180, 180]\n        theta *= 180 / Math.PI; \n        //if (theta < 0) theta = 360 + theta; // range [0, 360)\n        return theta;\n    }\n\n    //this function sets the correct translation of the directional arrow at the center of\n    //the circuitShadow path under the same parent group.\n    function arrowTranslate(d){\n        if(d.arrow === undefined || d.arrow === ARROW.NONE ){\n            return;\n        }\n    \n        //make the scale of the arrow a function of the line width\n        var arrow_scale;\n        if(layer.lineWidth() <=2){\n            arrow_scale = 0;\n        }else if(layer.lineWidth() <= 4){\n            arrow_scale = 2;\n        }else if(layer.lineWidth() <= 6){\n            arrow_scale = 3;\n        }else{\n            arrow_scale = 4;\n        }\n\n        var path = d3.select(this.parentNode).select(\"path\").filter(\".adjacencyShadow\")[0][0];\n        var p  = path.getPointAtLength(path.getTotalLength()/2);\n\n        //look after the midpoint in the path (away from A) to get our angle\n        var p2 = path.getPointAtLength((path.getTotalLength()/2)+12);\n        //if Z is passing more traffic, look before the midpoint to get the angle away from Z\n        if(d.arrow == ARROW.ZA){\n            p2 = path.getPointAtLength((path.getTotalLength()/2)-12);\n        }\n        \n        var angle = getAngle(p,p2);\n\n        //this works b/c it we know the ratio of the height/width of the arrow is 2 to 1\n        //initially it's rendered with the top left corner of its bounding box centered on p\n        //so we need to shift it left and up the arrows width and height respectively\n        p.y -= 1 * arrow_scale;\n        p.x -= 2 * arrow_scale;\n\n        return \"translate(\" + p.x+','+p.y+ \") scale(\"+arrow_scale+\") rotate(\"+angle+\",2,1)\"\n    }\n\n    //define how to update the layers components\n    layer.onUpdate(function(){\n        if(!layer.topology()){\n            console.warn('No topology set, skipping update for '+layer.name());\n            return;\n        }\n        //--- Render Links\n        var links = layer.links()\n            .data(layer.topology().data().links, function(d){\n                    return d.linkId;\n            });\n\n        //--- ENTER -- add any new links\n        var linksEnter = links.enter()\n            .append(\"g\")\n            .attr(\"id\", function(d) { return d.linkId })\n            .attr(\"class\",\"adjacency\");\n\n        //add a shadow path for new adjacencys \n        linksEnter.append(\"path\")\n        .attr(\"d\",function(d){\n            return line(d.path);\n        })\n        //.classed('adjacencyShadow adjacencyHighlight', true)\n            .attr(\"class\",\"adjacencyShadow\")\n            .call(function(selection){\n                _.forEach(layer.onLinkEvent(), function(callback, evt){\n                    selection.on(evt, function(d){\n                        callback({\n                            event: d3.event,\n                            data:  d\n                        });\n                    });\n                });\n            });\n\t\n        //add a highlight path for new links\n        linksEnter.append(\"path\")\n            .attr(\"d\",function(d){return line(d.path)})\n            .attr(\"class\",\"adjacencyHighlight\")\n            .call(function(selection){\n                _.forEach(layer.onLinkEvent(), function(callback, evt){\n                    selection.on(evt, function(d){\n                        callback({\n                            event: d3.event,\n                            data:  d\n                        });\n                    });\n                });\n            });\n\t\n        //add directional indicator by appending yet another path to the g\n        linksEnter.append(\"path\")\n            .attr(\"class\",\"arrow\")\n            .attr(\"d\",\"M.5,1 L0,2 L3,1 L0,0 Z\")\n            .attr(\"transform\", arrowTranslate);\n\t\n        //--- UPDATE -- update the paths of any existing links\n\t\n        //update shadow path\n        links.select(\".adjacencyShadow\")\n            .attr(\"d\",function(d){return line(d.path)})\n            .style('stroke-width', function(d){\n\t\tvar strokeWidth = d.lineColor === undefined ? (layer.lineWidth()-1) : (layer.lineWidth());\n                if (d.selected) {\n                    return (strokeWidth * 2)+'px';\n                } else {\n                    return strokeWidth+'px';\n                }\n            })\n            .style('opacity',function(d){\n                return d.lineOpacity === undefined ? layer.lineOpacity() : d.lineOpacity;\n            })\n            .style('stroke', function(d){\n                return d.lineColor === undefined ? d3.rgb(layer.lineColor()).darker() : d3.rgb(d.lineColor).darker();\n            });\n        //update highlight path\n        links.select(\".adjacencyHighlight\")\n            .attr(\"d\",function(d){return line(d.path)})\n            .style('stroke-width', function(d){\n                var strokeWidth = d.lineColor === undefined ? (layer.lineWidth()-2) : (layer.lineWidth()-1);\n                if (d.selected) {\n                    return (strokeWidth * 2)+'px';\n                } else {\n                    return strokeWidth+'px';\n                }\n            })\n            .style('opacity', function(d){\n                return d.lineOpacity === undefined ? layer.lineOpacity() : d.lineOpacity;\n            })\n            .style('stroke', function(d){\n                return d.lineColor === undefined ? d3.rgb(layer.lineColor()) : d3.rgb(d.lineColor);\n            });\n        \n        //update arrow path\n        links.select('.arrow')\n            .attr(\"transform\",arrowTranslate);\n\t\n        //--- EXIT -- remove any links we no longer need\n        links.exit().remove();\n\n       \n        //--- Render Endpoints\n        var endpoints = layer.endpoints()\n            .data(layer.topology().data().endpoints, function(d){\n                    return d.endpointId;\n            });\n\n        //--- ENTER -- add any new endpoints\n        var endpointsEnter = endpoints.enter().append(\"g\")\n            .attr(\"id\", function(d) { return d.endpointId; })\n            .attr(\"class\",\"pop\");\n        \n        // Enter SVG Shape Elements\n        endpointsEnter.append(function(d) {\n                var svgTag = \"circle\";\n                if (d.shape && [\"triangle\",\"square\",\"diamond\"].indexOf(String(d.shape).toLowerCase().trim()) !== -1) {\n                    svgTag = \"polygon\";\n                }\n                return document.createElementNS(\"http://www.w3.org/2000/svg\", svgTag);\n            })\n            .attr(\"class\", function(d) {\n                var shape = \"circle\";\n                if (d.shape && [\"triangle\",\"square\",\"diamond\"].indexOf(String(d.shape).toLowerCase().trim()) !== -1) {\n                    shape = String(d.shape).toLowerCase().trim();\n                }\n                return \"popHighlight \" + shape;\n            })\n            .call(function(selection){\n                _.forEach(layer.onEndpointEvent(), function(callback, evt){\n                    selection.on(evt, function(d){\n                        callback({\n                            event: d3.event,\n                            data:  d\n                        });\n                    });\n                });\n            });\n\n        // Default Drawing Radius for Markers\n        var ddr = 5;\n\n        // Draw Circular Markers\n        endpoints.select(\".popHighlight.circle\")\n            .attr(\"cx\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[0];\n            })\n            .attr(\"cy\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[1];\n            })\n            .attr(\"r\", ddr+\"px\");\n        \n        if (params.static_node_tooltip) {\n            endpoints.selectAll('foreignObject').remove()\n            endpoints\n                .append('foreignObject')\n                .style('overflow', 'visible')\n                .html(function(d) {\n                    let strHTML = params.node_content.replace('$name', d.name)\n                    return strHTML\n                })\n                .attr(\"x\", function (d) {\n                    let offset = this.getElementsByClassName('atlas-node-tooltip')[0].offsetWidth/2\n                    return layer.latLngToXy([d.lat, d.lon])[0] - offset;\n                })\n                .attr(\"y\", function (d) {\n                    let offset = this.getElementsByClassName('atlas-node-tooltip')[0].offsetHeight\n                    let yOffset = this.querySelector('.atlas-node-tooltip').getAttribute('yOffset')\n                    return layer.latLngToXy([d.lat, d.lon])[1] - offset - yOffset;\n                })\n        }\n        \n        \n        // Draw Pointed Shapes\n        endpoints.select(\".popHighlight.triangle, .popHighlight.square, .popHighlight.diamond\")\n            .attr(\"points\", function(d) {\n                var xy = layer.latLngToXy([d.lat, d.lon]);\n                if (d.shape.toLowerCase().trim() === \"triangle\") {\n                    return xy[0]+\",\"+(xy[1]-ddr)+\" \"+(xy[0]-ddr)+\",\"+(xy[1]+ddr)+\" \"+(xy[0]+ddr)+\",\"+(xy[1]+ddr);\n                } else {\n                    return (xy[0]-ddr)+\",\"+(xy[1]-ddr)+\" \"+(xy[0]+ddr)+\",\"+(xy[1]-ddr)+\" \"+(xy[0]+ddr)+\",\"+(xy[1]+ddr)+\" \"+(xy[0]-ddr)+\",\"+(xy[1]+ddr);\n                }\n            });\n\n        // Rotate Diamonds\n        endpoints.select(\".popHighlight.diamond\")\n            .attr(\"transform\", function(d) {\n                var xy = layer.latLngToXy([d.lat, d.lon]);\n                return \"rotate(45 \"+xy[0]+\" \"+xy[1]+\")\";\n            });\n\n        // Enter Node Labels\n        var labelLift = 14; // Distance that labels will appear above their node\n        // Label Text\n        endpointsEnter.filter(function (d) {\n                return (d.label && typeof d.label === \"string\"); // Add to nodes with labels\n            })\n            .append(\"rect\")\n            .attr(\"class\", \"nodeLabelBack\")\n            .attr(\"x\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[0];\n            })\n            .attr(\"y\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[1] - labelLift;\n            })\n            .attr(\"width\", function (d) {\n                return this.parentNode.getBBox().width;\n            })\n            .attr(\"height\", \"18\") // Set as a default right now\n            .attr(\"rx\", \"5\")\n            .attr(\"ry\", \"10\")\n            .style(\"fill\", \"#000\")\n            .style(\"fill-opacity\", \"0.5\")\n            .style(\"stroke\", \"#fff\");\n        // Label Background\n        endpointsEnter.filter(function (d) {\n                return (d.label && typeof d.label === \"string\"); // Add to nodes with labels\n            })\n            .append(\"text\")\n            .attr(\"x\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[0];\n            })\n            .attr(\"y\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[1] - labelLift;\n            })\n            .attr(\"class\", \"nodeLabel\")\n            .style(\"fill\", \"#fff\") // Default set to white for now\n            .style(\"font-weight\", \"300\")\n            .style(\"font-size\",\"15px\") // Default readable text size for now\n            .text(function (d) { return d.label; });\n\n        //--- UPDATE -- Update any existing endpoints\n        endpoints.select('.popHighlight')\n            .style(\"fill\", function(d){\n                return d.endpointColor === undefined ? layer.endpointColor() : d.endpointColor;\n            })\n        //.style('fill',layer.endpointColor()||d.endpointColor)\n            .attr(\"fill-opacity\", function(d){\n                return d.endpointOpacity === undefined ? layer.endpointOpacity() : d.endpointOpacity;\n            });\n\n        // Update Circles\n        endpoints.select(\".popHighlight.circle\")\n            .attr(\"cx\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[0];\n            })\n            .attr(\"cy\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[1];\n            })\n            .attr(\"r\",function(d) {\n                var r = 3;\n                if (layer.lineWidth()) {\n                    r = layer.lineWidth()+2;\n                }\n                if (d.scale && !isNaN(d.scale)) {\n                    r *= Math.abs(d.scale);\n                }\n                return r + \"px\";\n            });\n\n        // Update Pointed Shapes\n        endpoints.select(\".popHighlight.triangle, .popHighlight.square, .popHighlight.diamond\")\n            .attr(\"points\", function(d) {\n                var sdr = 3; // Scaled Drawing Radius\n                var xy = layer.latLngToXy([d.lat, d.lon]);\n                if (layer.lineWidth() > 1) {\n                    sdr = layer.lineWidth()+2;\n                }\n                if (d.scale && !isNaN(d.scale)) {\n                    sdr *= Math.abs(d.scale); // Does not need absolute because it is drawn\n                }\n                if (d.shape.toLowerCase().trim() === \"triangle\") {\n                    return xy[0]+\",\"+(xy[1]-sdr)+\" \"+(xy[0]-sdr)+\",\"+(xy[1]+sdr)+\" \"+(xy[0]+sdr)+\",\"+(xy[1]+sdr);\n                } else {\n                    return (xy[0]-sdr)+\",\"+(xy[1]-sdr)+\" \"+(xy[0]+sdr)+\",\"+(xy[1]-sdr)+\" \"+(xy[0]+sdr)+\",\"+(xy[1]+sdr)+\" \"+(xy[0]-sdr)+\",\"+(xy[1]+sdr);\n                }\n            });\n\n        // Rotate Diamonds\n        endpoints.select(\".popHighlight.diamond\")\n            .attr(\"transform\", function(d) {\n                var xy = layer.latLngToXy([d.lat, d.lon]);\n                return \"rotate(45 \"+xy[0]+\" \"+xy[1]+\")\";\n            });\n\n        // Update Node Labels\n        endpoints.select(\".pop .nodeLabel\").filter(function (d) {\n                return (d.label && typeof d.label === \"string\"); // Add to nodes with labels\n            })\n            .attr(\"x\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[0] - (this.getBBox().width / 2);\n            })\n            .attr(\"y\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[1] - labelLift;\n            });\n\n        var pad = 8; // Padding for label text\n        endpoints.select(\".pop .nodeLabelBack\").filter(function (d) {\n                return (d.label && typeof d.label === \"string\"); // Add to nodes with labels\n            })\n            .attr(\"x\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[0] - ((this.parentNode.lastChild.getBBox().width + pad)  / 2);\n            })\n            .attr(\"y\", function (d) {\n                return layer.latLngToXy([d.lat, d.lon])[1] - labelLift - 16; // -16 centers bckgrd with text\n            })\n            .attr(\"width\", function (d) {\n                return this.parentNode.lastChild.getBBox().width + pad;\n            })\n            .attr(\"height\", function (d) {\n                return this.parentNode.lastChild.getBBox().height + (pad /2);\n            });\n\n        //--- EXIT-- remove any endpoint we no longer need\n        endpoints.exit().remove();\n\t\n\tif(!this.isInitDone()){\n\t    console.log(\"Init Complete!\");\n\t    this.isInitDone(true);\n\t    this.initComplete();\n\t}\n\n        return true;\n    });\n\n    return layer;\n};\nmodule.exports = SingleTubeLayer;\n\n'globalnoc-networkmap-panel/src/js/map/LeafletMap.js'\n:/*\nCopyright 2018 The Trustees of Indiana University\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nvar _                = require('lodash');\nvar ds               = require('../util/DataSource.js');\nvar d3               = require('d3');\nvar BaseMap          = require('./BaseMap.js');\nvar BaseLayer        = require('./BaseLayer.js');\nvar L                = require('leaflet');\nvar omnivore         = require('leaflet-omnivore');\nvar bing             = require('leaflet-bing-layer');\nvar plugins          = require('leaflet-plugins/layer/vector/KML');\nvar TrafficLayer     = require('../map/TrafficLayer');\nvar SingleTubeLayer  = require('../map/SingleTubeLayer');\nvar TwinTubeLayer    = require('../map/TwinTubeLayer');\nvar LAYER_TYPES      = require('../util/Enums.js').LAYER_TYPES;\n/**\n* An extension of the BaseMap that renders onto the Google Maps platform\n* ```\nvar map = LeafletMap({\n    bing_api_key: \"API KEY\",\n    containerId: \"map\",\n    zoom: 4,\n    lat: 37,\n    lng: -97,\n    networkLayers: [{\n        name: \"AL2S\",\n        lineWidth: 4,\n        mapSource: \"../networks/al2s.json\",\n        map2dataSource: {\n            type: 'atlasUsage',\n            source: '../data/al2s.xml'\n        }\n    }]\n});\n```\n* @class LeafletMap\n* @extends BaseMap\n* @constructor LeafletMap\n* @static\n* @param {Object} config - The configuration object for the GoogleMap\n* @param {String:Required} config.containerId - The map's container id\n* @param {Integer:Required} config.zoom - The zoom level the map should be intialized at\n* @param {Integer:Required} config.lat - The latitude coordinate the map should be initialized at\n* @param {Integer:Required} config.lng - The longitude coordinate the map should be initialized at\n* @param {String:Required} config.bing_api_key\n* @param {String:Required} config.map_tile_url\n*/\nvar LeafletMap = function(params) {\n    params.mapType = 'leaflet';\n    var map = BaseMap(params);\n    var zoom,lat,lng;\n    lat = params.lat;\n    lng = params.lng;\n    if(params.zoom){\n        zoom = params.zoom;\n    }\n    else if(params.height){\n        zoom = _convertAltitudeToZoom(params.height);\n    }\n    var tooltip;\n    if(params.tooltip){\n        tooltip = params.tooltip;\n    }\n    if(!lat){\n       lat = 45;\n    }\n    if(!lng){\n        lng = -90;\n    }\n\n    var legend;\n    if(params.legend){\n        legend = params.legend;\n    }\n\n    //initialize the leaflet map object\n    var lmap;\n    var mapTileURL = params.map_tile_url;\n    var imageOverlayURL = params.image_url;\n    var weatherTileURL = 'https://mesonet.agron.iastate.edu/cache/tile.py/1.0.0/nexrad-n0q-900913/{z}/{x}/{y}.png'\n    var tiles;\n    var image;\n    var weather_tile;\n    var center = {lat: lat, lng: lng};\n\n    var lmapOptions = {\n        center: center,\n        preferCanvas: false,\n        mapTypeId: \"hybrid\",\n        minZoom: 2,\n        zoomDelta: 0.25,\n        zoomSnap: 0.25,\n        zoom: zoom,\n        zoomAnimation: true,\n        worldCopyJump: true,\n        scrollWheelZoom: false,\n        nowrap: true\n    };\n\n    lmap = L.map(document.getElementById(params.containerId), lmapOptions);\n    lmap.on('click', function(event){\n        console.log(event.latlng);\n    });\n\n    if(!imageOverlayURL){\n        lmap.options.maxZoom = 18;\n        tiles = L.tileLayer(mapTileURL, { opacity: 1, attribution: '&copy GlobalNOC' })\n        lmap.addLayer(tiles);\n        if (params.weather_tile) {\n            weather_tile = L.tileLayer(weatherTileURL)\n            lmap.addLayer(weather_tile);\n        }\n    }else {\n        var bounds = L.latLngBounds(L.latLng(-90,-180), L.latLng(90,180));\n        image = new L.ImageOverlay(imageOverlayURL, bounds, {\n            interactive: true,\n            opacity: 1,\n            attribution: '&copy GlobalNOC',\n            zIndex: -999\n        });\n        lmap.addLayer(image);\n\n        lmap.fitBounds(bounds).once('zoomend', function(){\n            if(lmap.getZoom() != zoom){\n                lmap.setZoom(zoom);\n            }\n        });\n        lmap.setZoom(zoom);\n        lmap.setMaxBounds(bounds);\n        lmap.options.maxZoom = 4;\n    }\n\n    map.validateSize = function(){\n        lmap.invalidateSize();\n    }\n\n    function _removeLayer(){\n        if(lmap.hasLayer(tiles)){\n            lmap.removeLayer(tiles);\n        }\n        if(lmap.hasLayer(image)){\n            lmap.removeLayer(image);\n        }\n    }\n\n    map.setMapUrl = function(map_tile_url){\n        _removeLayer();\n        tiles = L.tileLayer(map_tile_url, { attribution: '&copy GlobalNOC' });\n        lmap.addLayer(tiles);\n        lmap.options.maxZoom = 18;\n    }\n    map.setImageUrl = function(image_url, zoom){\n        _removeLayer();\n        var bounds = L.latLngBounds(L.latLng(-90,-180), L.latLng(90,180));\n        image = new L.ImageOverlay(image_url, bounds, {\n            interactive: true,\n            opacity: 1,\n            attribution: '&copy GlobalNOC',\n            zIndex: -999\n            });\n        lmap.addLayer(image);\n        lmap.options.maxZoom = 4;\n    }\n\n    map.toggleWeatherTile = function(tile_switch) {\n        if(lmap.hasLayer(weather_tile)){\n            lmap.removeLayer(weather_tile);\n        }\n        if (tile_switch) {\n            weather_tile = L.tileLayer(weatherTileURL)\n            lmap.addLayer(weather_tile);\n        }\n    }\n\n    //setup our svg layer to drawn on\n    var svgLayer = L.svg();\n    svgLayer.addTo(lmap);\n\n    //helper function to convert an altitude in meters to a google maps zoom level\n    function _convertAltitudeToZoom(altitude) {\n        //estimates retrieved by doing a trial and error\n        //side by side with cesium\n        if(altitude >= 50000000){\n            return 1;\n        }\n        if(altitude >= 25000000){\n            return 2;\n        }\n        else if(altitude >= 12500000){\n            return 3;\n        }\n        else if(altitude >= 7500000){\n            return 4;\n        }\n        else if(altitude >= 3750000){\n            return 5;\n        }\n        else if(altitude >= 1875000){\n            return 6;\n        }\n        else if(altitude >= 937500) {\n            return 7;\n        }\n        else if(altitude >= 468750) {\n            return 8;\n        }\n        else if(altitude >= 234375) {\n            return 9;\n        }\n        else if(altitude >= 117187.5) {\n            return 10;\n        }\n        else if(altitude >= 58593.75){\n            return 11;\n        }\n        else if(altitude >= 29296.875){\n            return 12;\n        }\n        else if(altitude >= 14648.4375){\n            return 13\n        }\n        else if(altitude >= 7324.21875){\n            return 14;\n        }\n        else if(altitude >= 3662.109375){\n            return 15;\n        }\n        return 16;\n    }\n\n    //get the styles of the features given the state of the feature boolean flags\n    map.getStyles = function(){\n        return [{\n            featureType: \"road\",\n            elementType: \"all\",\n            stylers: [\n                { visibility: (map.roadsActive()) ? \"on\" : \"off\" }\n            ]\n        },{\n            featureType: \"poi\",\n                elementType: \"all\",\n                stylers: [\n                    { visibility: (map.poiActive()) ? \"on\" : \"off\" }\n                ]\n        },{\n            featureType: \"administrative\",\n            elementType: \"all\",\n            stylers: [\n                { visibility: (map.bordersActive()) ? \"on\" : \"off\" }\n            ]\n        }];\n    };\n\n    //define how to convert from lat/lng to xy coords\n    map.onLatLngToXy(function(latlng){\n        var point = lmap.latLngToLayerPoint(L.latLng(latlng[0],latlng[1]));\n        return [point.x, point.y];\n    });\n\n    //define hot to convert from xy to lat/ong coords\n    map.onXyToLatLng(function(xy){\n        var latlng = lmap.PointToLatLng(L.point(xy[0],xy[1]));\n        return [latlng.lat(), latlng.lng()];\n    });\n\n    //define how to pan to a lat/lng coordinate on the map\n    map.onPanTo(function(params){\n        var latlng = params.latlng;\n        lmap.panTo(L.latLng(latlng[0], latlng[1]));\n        });\n\n    //define how to zoom the camera\n    map.onZoom(function(params){\n        console.log(params.zoom);\n        var zoom;\n        if(params.zoom){\n            zoom = params.zoom;\n        }\n        else if(params.height){\n            zoom = _convertAltitudeToZoom(params.height);\n        }\n        lmap.setZoom(zoom);\n    });\n\n    // make the line width a fucntion of the zoom level\n    map.onLineWidth(function(){\n        var zoom = lmap.getZoom();\n        var width = 1;\n        if(zoom < 3){\n            width = 1;\n        }\n        else if(zoom < 4){\n            width = 2;\n        }\n        else if(zoom < 6){\n            width = 2;\n        }\n        else if(zoom < 8){\n            width = 2;\n        }\n        else if(zoom < 12){\n            width = 3;\n        }\n        else {\n            width = 3;\n        }\n\n        console.log('zoom = '+zoom+', line = '+width);\n        return width;\n    });\n\n\n\n    map.onAddGeoJsonLayer(function(layer){\n\t    var geo_json_layer = BaseLayer({\n\t\t    layerType: map.LAYER_TYPES.GEOJSON,\n\t\t    active: layer.active,\n\t\t    name: layer.name\n\t\t});\n\n\t    var geoJSON_layer = L.geoJSON([],{\n\t\t    pointToLayer: function (feature, latlng) {\n\t\t\tvar color,\n\t\t\tmag,\n\t\t\tradius;\n\t\t\tmag = feature.properties.mag;\n\t\t\tif (mag === null) {\n\t\t\t    color = '#fff';\n\t\t\t    radius = 2;\n\t\t\t} else {\n\t\t\t    color = '#00f';\n\t\t\t    radius = 2 * Math.max(mag, 1);\n\t\t\t}\n\t\t\tif (feature.properties.type === 'quarry blast') {\n\t\t\t    color = '#f00';\n\t\t\t}\n\t\t\treturn L.circleMarker(latlng, {\n\t\t\t\tcolor: color,\n\t\t\t\tradius: radius\n\t\t\t    });\n\t\t    }\n\t\t});\n\n\t    //define how to remove the kml layer\n\t    geo_json_layer.onRemove(function(l){\n                    geoJSON_layer.remove();\n\t\t});\n\n\t    //define how to toggle the kml layer\n\t    geo_json_layer.onToggle(function(active){\n\t\t    if(active) {\n\t\t\tgeoJSON_layer.addTo(lmap);\n\t\t    }else {\n                        geoJSON_layer.remove();\n\t\t    }\n\t\t});\n\n\t    if(geo_json_layer.active()){\n\t\tgeoJSON_layer.addTo(lmap);\n\t    }\n\n\n\t    var xhr = new XMLHttpRequest();\n\t    xhr.onload = function () {\n\t\tvar results = JSON.parse(xhr.responseText);\n\t\tgeoJSON_layer.addData(results);\n\t    };\n\t    xhr.open('GET',layer.url, true);\n\t    xhr.send();\n\n\n\t    return geo_json_layer;\n\t});\n\n    //define how to add a network layer to the map\n    map.onAddNetworkLayer(function(layer){\n        var layer_options = {\n            map: map,\n            svg: bg,\n            lmap: lmap,\n            lineColor: layer.lineColor,\n            lineOpacity: layer.lineOpacity,\n            endpointColor: layer.endpointColor,\n            endpointOpacity: layer.endpointOpacity,\n            active: layer.active,\n            name: layer.name,\n            onLatLngToXy: map.onLatLngToXy(),\n            onLinkEvent: layer.onLinkEvent,\n            onEndpointEvent: layer.onEndpointEvent,\n            tooltip: tooltip,\n            max: layer.max,\n            min: layer.min,\n            offsets: [-360,0,360],\n            lineThickness: layer.lineWidth,\n            node_content: layer.node_content || params.node_content,\n            static_node_tooltip: layer.static_node_tooltip\n        };\n        \n        var network_layer;\n        //if we don't have a way to get topology data just show the single tube layers\n        if(layer.map2dataSource === undefined){\n\t    layer_options.svg = bg.append(\"g\");\n            if(!layer.twin_tubes){\n       \t\tnetwork_layer = SingleTubeLayer(layer_options)\n               \t \t.lineWidth(layer_options.lineThickness * map.lineWidth())\n               \t\t.loadMap(layer.mapSource);\n\t     }else {\n                network_layer = TwinTubeLayer(layer_options)\n                    .lineWidth(layer_options.lineThickness * map.lineWidth())\n                    .loadMap(layer.mapSource);\n             }\n        }\n        //otherwise load the traffic layer with live updates\n        else {\n            layer_options.maxBps = layer.maxBps;\n            network_layer = TrafficLayer(layer_options).lineWidth(layer_options.lineThickness * map.lineWidth())\n                .map2dataSource(layer.map2dataSource)\n                .loadMap(layer.mapSource);\n        }\n\n        return network_layer;\n    });\n\n\n    map.onAddKmzLayer(function(layer){\n\t    var kml_layer = BaseLayer({\n\t\t    layerType: map.LAYER_TYPES.KML,\n\t\t    active: layer.active,\n\t\t    name: layer.name\n\t\t});\n\n\n\t    return kml_layer;\n\t});\n\n    //define how to add a kml layer to the map\n    map.onAddKmlLayer(function(layer){\n        var kml_layer = BaseLayer({\n            layerType: map.LAYER_TYPES.KML,\n            active: layer.active,\n            name: layer.name\n        });\n\n        var lkml_layer = new L.KML(layer.url, { async: true });\n\n        //define how to remove the kml layer\n        kml_layer.onRemove(function(l){\n                lkml_layer.remove();\n        });\n\n        //define how to toggle the kml layer\n        kml_layer.onToggle(function(active){\n            if(active) {\n                lkml_layer.addTo(lmap);\n            }else {\n                lkml_layer.remove();\n            }\n        });\n\n        if(kml_layer.active()){\n            lkml_layer.addTo(lmap);\n        }\n\n        return kml_layer;\n    });\n\n    map.onAddTileLayerWMS(function(layer){\n\t    var tile_layer = BaseLayer({\n\t\t    layerType: map.LAYER_TYPES.TILE_WMS,\n\t\t    active: layer.active,\n\t\t    name: layer.name\n\t\t});\n\n\t    var leaflet_tile_layer = L.tileLayer.wms( layer.url, {\n            layers: layer.params.layers,\n            version: layer.params.version,\n            format: layer.params.format,\n            transparent: true,\n            updateWhenZooming: false,\n            updateInterval: 900,\n            zoomAnimation: false,\n            interactive: false,\n            opacity: 0\n\t\t});\n\n\t    //remove the SVG layer cause suck!\n\t    svgLayer.remove();\n\t    leaflet_tile_layer.addTo(lmap);\n\t    svgLayer.addTo(lmap);\n\n\t    //define how to remove the tile layer\n\t    tile_layer.onRemove(function(){\n\t\t    leaflet_tile_layer.remove();\n\t\t});\n\n\t    //define how to toggle the tile layer\n\t    tile_layer.onToggle(function(active){\n\t\t    if(active){\n\t\t\tleaflet_tile_layer.setOpacity(1);\n\t\t    }else {\n\t\t\tleaflet_tile_layer.setOpacity(0);\n\t\t    }\n\t\t});\n\n\t    return tile_layer;\n\n\t});\n\n    //define how to add a tile layer to the map\n    map.onAddTileLayer(function(layer){\n        var tile_layer = BaseLayer({\n            layerType: map.LAYER_TYPES.TILE,\n            active: layer.active,\n            name: layer.name\n        });\n\n        var leaflet_tile_layer = L.tileLayer( layer.url, {\n                name: layer.name,\n                maxZoom: 16,\n                opacity: 0,\n                updateWhenZooming: false,\n                updateInterval: 900,\n                cacheBuster: function() { return Math.random().toString().replace(/^[^.]*\\./, ''); } //used to defeat overzealous browser caching\n        });\n\n\tsvgLayer.remove();\n\tleaflet_tile_layer.addTo(lmap);\n\tsvgLayer.addTo(lmap);\n\n        //optionally, periodically refresh the layer\n        var timerId = null;\n        if(_.isFinite(layer.refreshInterval) && layer.refreshInterval >= 1){\n            timerId = setInterval(function(){\n                leaflet_tile_layer.redraw();\n            }, layer.refreshInterval * 1000);\n        }\n\n        //define how to remove the tile layer\n        tile_layer.onRemove(function(){\n                if(!_.isNull(timerId)){\n                    clearInterval(timerId);\n                }\n                leaflet_tile_layer.remove();\n        });\n\n        //define how to toggle the tile layer\n        tile_layer.onToggle(function(active){\n            if(active){\n\t\tleaflet_tile_layer.setOpacity(1);\n            }else {\n                leaflet_tile_layer.setOpacity(0);\n            }\n        });\n\n        return tile_layer;\n    });\n\n    //define how to toggle road features\n    map.onToggleRoads(function(){\n            if(this.roadsActive()){\n\t\ttiles.setOpacity(0);\n\t\tsatTiles.setOpacity(1);\n            }else{\n\t\tsatTiles.setOpacity(0);\n\t\ttiles.setOpacity(1);\n\t    }\n    });\n\n    map.removeMap = function() {\n        lmap.remove();\n    };\n\n    // svg element to hold layers\n    var bg;\n    map.onInit(function(){\n            var container = d3.select(\"#\" + map.containerId());\n            bg = container.select(\"svg\");\n            bg.attr(\"pointer-events\",\"auto\");\n            bg.classed(map.containerId(), true);\n        });\n\n    lmap.on(\"viewreset\", function(d){\n            map.update();\n        });\n\n    lmap.on(\"zoomend\", function(e){\n            map.update();\n        });\n\n    lmap.on(\"moveend\", function(e){\n        if(e.hard){\n            lmap.setZoom(zoom);\n        }\n        map.update();\n    });\n\n    map.onUpdate(function(){\n            var layers = map.layers({layerTypes: [LAYER_TYPES.NETWORK]});\n            _.forEach(layers, function(l){\n\t\t        l.lineWidth(l.lineWidth());\n\t\t        l.update();\n            });\n        });\n\n    //define how to resize the map\n    map.onResize(function(active){\n\t    lmap.invalidateSize();\n\t});\n\n\n    map.init();\n\n    return map;\n};\n\nmodule.exports = LeafletMap;\n\n",
        "called_code_segment_file_1": "layer.onLatLngToXy(function(latlng){ var point = lmap.latLngToLayerPoint(L.latLng(latlng[0],latlng[1])); return [point.x, point.y]; });",
        "invoking_code_segment_file_2": "var network_layer = SingleTubeLayer(layer_options) .lineWidth(layer_options.lineThickness * map.lineWidth()) .loadMap(layer.mapSource);",
        "called_code_segment_file_2": "layer.onLatLngToXy = function(value){ if(!arguments.length){ return onLatLngToXy; } onLatLngToXy = value; return layer; };",
        "using_code_segment_file_3": "var line = d3.svg.line() .interpolate(\"bundle\") .x(function(d) { return layer.latLngToXy([d.lat, d.lon])[0]; }) .y(function(d) { return layer.latLngToXy([d.lat, d.lon])[1]; });",
        "feature_description": "Add a new feature to allow dynamic adjustment of the map's zoom level based on user input.",
        "detailed_feature_description": "The new feature will allow users to input a desired zoom level, which will be passed to the map's zoom function. This will require modifications in `#file 1` to handle the new zoom input, updates in `#file 2` to pass the new zoom level, and adjustments in `#file 3` to ensure the map updates correctly based on the new zoom level.",
        "modified_complete_code": {
            "#file 1": "//Modify map.onZoom(function(params){ var zoom; if(params.zoom){ zoom = params.zoom; } else if(params.height){ zoom = _convertAltitudeToZoom(params.height); } lmap.setZoom(zoom); }); //New map.onSetZoom(function(newZoom){ lmap.setZoom(newZoom); });",
            "#file 2": "//Modify var network_layer = SingleTubeLayer(layer_options) .lineWidth(layer_options.lineThickness * map.lineWidth()) .loadMap(layer.mapSource); //New map.onSetZoom(userInputZoom);",
            "#file 3": "//Modify var line = d3.svg.line() .interpolate(\"bundle\") .x(function(d) { return layer.latLngToXy([d.lat, d.lon])[0]; }) .y(function(d) { return layer.latLngToXy([d.lat, d.lon])[1]; }); //New map.onSetZoom(userInputZoom);"
        }
    },
    {
        "repo": "google-autocomplete",
        "content": "'google-autocomplete/src/js/Components/index.js'\n:\n/**\n * Registering the component as global.\n *\n * @author Gustavo Ocanto <gustavoocanto@gmail.com>\n * @license https://github.com/gocanto/google-autocomplete/blob/master/LICENSE.md\n */\n\nimport Vue from 'vue';\nimport GoogleAutocomplete from './googleAutocomplete.vue';\n\nVue.component('google-autocomplete', GoogleAutocomplete);\n'google-autocomplete/src/js/bootstrap.js'\n:\n/*\n|------------------------------------------------------------------------------------\n| Vue\n|------------------------------------------------------------------------------------\n|\n| Vue is a modern JavaScript library for building interactive web interfaces\n| using reactive data binding and reusable components. Vue's API is clean\n| and simple, leaving you to focus on building your next great project.\n*/\n\nwindow.Vue = require('vue');\n\n/*\n|------------------------------------------------------------------------------------\n| Vuemit\n|------------------------------------------------------------------------------------\n|\n| The smallest Vue.js events handler.\n| @link https://github.com/gocanto/vuemit\n*/\n\nwindow.Vuemit = require('vuemit');\n\n/*\n|------------------------------------------------------------------------------------\n| Global components entry point\n|------------------------------------------------------------------------------------\n|\n| We register all the global components within this file.\n*/\n\nrequire('./Components/index');\n\n/*\n|------------------------------------------------------------------------------------\n| Google Autocomplete Component\n|------------------------------------------------------------------------------------\n|\n| The google autocomplete is the configuration object for the component.\n| Here, you will be able to set the API domain, your personal key\n| number, and the library required.\n*/\n\nwindow.GOOGLE_AUTOCOMPLETE = {\n\t'domain': 'https://maps.googleapis.com/maps/api/js',\n\t'key': 'AIzaSyBCxExDtVmUoKn1B18Vs0ULNKq0qu6hmsM',\n\t'library' : 'places',\n\n\t// google inputs retrieved.\n\t'inputs': {\n\t\tadministrative_area_level_1: 'long_name',\n\t\tstreet_number: 'short_name',\n\t\tpostal_code: 'short_name',\n\t\tlocality: 'long_name',\n\t\tcountry: 'long_name',\n\t\troute: 'long_name'\n\t}\n}\n\n'google-autocomplete/src/js/demo.js'\n:\n/**\n * The demo Vue instance.\n *\n * @author Gustavo Ocanto <gustavoocanto@gmail.com>\n * @license https://github.com/gocanto/google-autocomplete/blob/master/LICENSE.md\n */\n\nrequire('./bootstrap');\n\nnew Vue({\n\n\tel: '#demo',\n\n\tdata:\n\t{\n\t\toutput: {}, address: {}, sent: false, response: {}, configs: {}\n\t},\n\n\tmounted()\n\t{\n\t\t//Set an event listener for 'setAddress'.\n\t\tVuemit.listen('setAddress', this.onAddressChanged);\n\t},\n\n\tmethods:\n\t{\n\t\t/**\n\t\t * Submit the data to be evaluated.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tsubmit()\n\t\t{\n\t\t\tthis.sent = true;\n\t\t\tthis.output = this.address;\n\t\t\tthis.address = {};\n\t\t},\n\n\t\t/**\n\t\t * Checks whether the output data is valid.\n\t\t *\n\t\t * @return {Bool}\n\t\t */\n\t\tisValid()\n\t\t{\n\t\t\treturn Object.keys(this.output).length > 0;\n\t\t},\n\n\t\t/**\n\t\t * Checks whether the output data is not valid.\n\t\t *\n\t\t * @return {Bool}\n\t\t */\n\t\tisNotValid()\n\t\t{\n\t\t\treturn ! this.isValid();\n\t\t},\n\n\t\t/**\n\t\t * The callback fired when the autocomplete event was fired.\n\t\t *\n\t\t * @param {Object}\n\t\t * @return {Void}\n\t\t */\n\t\tonAddressChanged(payload)\n\t\t{\n\t\t\tif (Object.keys(payload.place).length > 0) {\n\t\t\t\tthis.address = payload.place;\n\t\t\t\tthis.response = payload.response;\n\t\t\t}\n\t\t}\n\t}\n\n});\n",
        "called_code_segment_file_1": "Vuemit.listen('setAddress', this.onAddressChanged);",
        "invoking_code_segment_file_2": "Vue.component('google-autocomplete', GoogleAutocomplete);",
        "called_code_segment_file_2": "Vue.component('google-autocomplete', GoogleAutocomplete);",
        "using_code_segment_file_3": "Vuemit.listen('setAddress', this.onAddressChanged);",
        "feature_description": "Add a new feature to validate the address format before emitting the 'setAddress' event.",
        "detailed_feature_description": "In the new feature, the 'setAddress' event will only be emitted if the address format is valid. This involves modifying the 'onAddressChanged' method in #file 1 to include a validation check. The 'submit' method in #file 3 will also be updated to handle the validation result.",
        "modified_complete_code": {
            "file_1": "// #file 1\n\nVue.component('google-autocomplete', GoogleAutocomplete);",
            "file_2": "// #file 2\n\nnew Vue({\n\n\tel: '#demo',\n\n\tdata: {\n\t\toutput: {}, address: {}, sent: false, response: {}, configs: {}\n\t},\n\n\tmounted() {\n\t\t//Set an event listener for 'setAddress'.\n\t\tVuemit.listen('setAddress', this.onAddressChanged);\n\t},\n\n\tmethods: {\n\t\t/**\n\t\t * Submit the data to be evaluated.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tsubmit() {\n\t\t\tthis.sent = true;\n\t\t\tthis.output = this.address;\n\t\t\tthis.address = {};\n\t\t},\n\n\t\t/**\n\t\t * Checks whether the output data is valid.\n\t\t *\n\t\t * @return {Bool}\n\t\t */\n\t\tisValid() {\n\t\t\treturn Object.keys(this.output).length > 0;\n\t\t},\n\n\t\t/**\n\t\t * Checks whether the output data is not valid.\n\t\t *\n\t\t * @return {Bool}\n\t\t */\n\t\tisNotValid() {\n\t\t\treturn ! this.isValid();\n\t\t},\n\n\t\t/**\n\t\t * The callback fired when the autocomplete event was fired.\n\t\t *\n\t\t * @param {Object}\n\t\t * @return {Void}\n\t\t */\n\t\tonAddressChanged(payload) {\n\t\t\tif (Object.keys(payload.place).length > 0) {\n\t\t\t\tthis.address = payload.place;\n\t\t\t\tthis.response = payload.response;\n\t\t\t}\n\t\t}\n\t}\n\n});",
            "file_3": "// #file 3\n\nrequire('./bootstrap');\n\nnew Vue({\n\n\tel: '#demo',\n\n\tdata: {\n\t\toutput: {}, address: {}, sent: false, response: {}, configs: {}\n\t},\n\n\tmounted() {\n\t\t//Set an event listener for 'setAddress'.\n\t\tVuemit.listen('setAddress', this.onAddressChanged);\n\t},\n\n\tmethods: {\n\t\t/**\n\t\t * Submit the data to be evaluated.\n\t\t *\n\t\t * @return {Void}\n\t\t */\n\t\tsubmit() {\n\t\t\tthis.sent = true;\n\t\t\tthis.output = this.address;\n\t\t\tthis.address = {};\n\t\t},\n\n\t\t/**\n\t\t * Checks whether the output data is valid.\n\t\t *\n\t\t * @return {Bool}\n\t\t */\n\t\tisValid() {\n\t\t\treturn Object.keys(this.output).length > 0;\n\t\t},\n\n\t\t/**\n\t\t * Checks whether the output data is not valid.\n\t\t *\n\t\t * @return {Bool}\n\t\t */\n\t\tisNotValid() {\n\t\t\treturn ! this.isValid();\n\t\t},\n\n\t\t/**\n\t\t * The callback fired when the autocomplete event was fired.\n\t\t *\n\t\t * @param {Object}\n\t\t * @return {Void}\n\t\t */\n\t\tonAddressChanged(payload) {\n\t\t\tif (Object.keys(payload.place).length > 0) {\n\t\t\t\tthis.address = payload.place;\n\t\t\t\tthis.response = payload.response;\n\t\t\t}\n\t\t}\n\t}\n\n});"
        }
    },
    {
        "repo": "google-fonts-webpack-plugin",
        "content": "'google-fonts-webpack-plugin/src/FontTypes.js'\n:module.exports = {\n\t\"eot\": \"embedded-opentype\",\n\t\"woff2\": \"woff2\",\n\t\"woff\": \"woff\",\n\t\"ttf\": \"truetype\",\n\t\"svg\": \"svg\"\n}\n\n'google-fonts-webpack-plugin/src/GoogleWebfonts.js'\n:const _ = require(\"lodash\")\nconst path = require(\"path\")\nconst yauzl = require(\"yauzl\")\nconst fetch = require(\"node-fetch\")\nconst { RawSource } = require(\"webpack-sources\")\nconst FontTypes = require(\"./FontTypes\")\n\nconst API_URL = \"https://google-webfonts-helper.herokuapp.com/api/fonts\"\n\nconst FONT_SRC = (font, format) => `url(\"${font}\")${format ? ` format(\"${format}\")` : \"\"}`\n\nconst FONT_FACE = ({ fontFamily, fontStyle, fontWeight, src, fallback }) => `\n@font-face {\n\tfont-family: ${fontFamily};\n\tfont-style: ${fontStyle};\n\tfont-weight: ${fontWeight};\n\t${fallback ? `src: ${fallback};` : \"\"}\n\t${src.length ? `src: ${src.join(\",\\n\\t\\t\")};` : \"\"}\n}\n`\n\nfunction getVariantCss({ variant, info, font, formats, fontsPath }) {\n\tconst src = info.local.map(fileName => `local(\"${fileName}\")`)\n\tlet fallback\n\tformats.forEach(ext => {\n\t\tif(ext in info) {\n\t\t\tconst url = (\n\t\t\t\ttypeof fontsPath !== \"undefined\" ?\n\t\t\t\t`./${fontsPath}/${font.getName(variant)}.${ext}` :\n\t\t\t\tinfo[ext]\n\t\t\t)\n\t\t\tconst format = FontTypes[ext]\n\t\t\tsrc.push(FONT_SRC(url, format))\n\t\t\tif(ext === \"eot\") {\n\t\t\t\tfallback = FONT_SRC(url)\n\t\t\t}\n\t\t}\n\t})\n\treturn (\n\t\t`/* === ${font.family} - ${variant} */` +\n\t\tFONT_FACE(_.assign({ src, fallback }, info))\n\t)\n}\n\nclass Selection {\n\tconstructor(font, query, info) {\n\t\tthis.font = font\n\t\tthis.query = {\n\t\t\tsubsets: query.subsets || font.defaults.subsets,\n\t\t\tvariants: query.variants || font.defaults.variants,\n\t\t\tformats: query.formats || _.keys(FontTypes)\n\t\t}\n\t\tthis.query.variants = this.query.variants.map(value => {\n\t\t\tswitch(value) {\n\t\t\t\tcase \"400\": return \"regular\"\n\t\t\t\tcase \"400italic\": return \"italic\"\n\t\t\t\tdefault: return value\n\t\t\t}\n\t\t})\n\t}\n\n\tcss(fontsPath) {\n\t\tconst { font, query: { subsets, variants, formats } } = this\n\t\treturn font.info(subsets)\n\t\t\t.then(info => {\n\t\t\t\tconst css = []\n\t\t\t\tvariants.forEach(variant => {\n\t\t\t\t\tconst variantInfo = info.variants.filter(node => node.id === variant).pop()\n\t\t\t\t\tif(variantInfo) {\n\t\t\t\t\t\tcss.push(getVariantCss({\n\t\t\t\t\t\t\tinfo: variantInfo,\n\t\t\t\t\t\t\tformats,\n\t\t\t\t\t\t\tvariant,\n\t\t\t\t\t\t\tfont,\n\t\t\t\t\t\t\tfontsPath\n\t\t\t\t\t\t}))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn css.join(\"\\n\")\n\t\t\t})\n\t}\n\n\tdownload() {\n\t\tif(this._response) {\n\t\t\treturn Promise.resolve(this._response)\n\t\t}\n\t\tconst { font } = this\n\t\tconst { subsets, variants, formats } = this.query\n\t\tlet url = `${font.url}?download=zip`\n\t\turl += \"&subsets=\" + subsets.join(\",\")\n\t\turl += \"&variants=\" + variants.join(\",\")\n\t\tif(formats) {\n\t\t\turl += \"&formats=\" + formats.join(\",\")\n\t\t}\n\t\treturn fetch(url)\n\t\t\t.then(response => {\n\t\t\t\tif(response.status !== 200) {\n\t\t\t\t\tthrow new Error(response.statusText)\n\t\t\t\t}\n\t\t\t\tthis._response = response\n\t\t\t\treturn response\n\t\t\t})\n\t}\n\n\tfiles() {\n\t\tif(this._files) {\n\t\t\treturn Promise.resolve(this._files)\n\t\t}\n\t\treturn this.download()\n\t\t\t.then(response => response.buffer())\n\t\t\t.then(buffer => new Promise((resolve, reject) => {\n\t\t\t\tthis._files = {}\n\t\t\t\tyauzl.fromBuffer(buffer, { lazyEntries: true }, (err, zipFile) => {\n\t\t\t\t\tif(err) {\n\t\t\t\t\t\treject(err)\n\t\t\t\t\t}\n\t\t\t\t\tconst next = () => zipFile.readEntry()\n\t\t\t\t\tzipFile\n\t\t\t\t\t\t.on(\"error\", reject)\n\t\t\t\t\t\t.on(\"end\", () => resolve(this._files))\n\t\t\t\t\t\t.on(\"entry\", entry => {\n\t\t\t\t\t\t\tif(/\\/$/.test(entry.fileName)) next()\n\t\t\t\t\t\t\tconst ext = path.extname(entry.fileName).slice(1)\n\t\t\t\t\t\t\tconst variant = entry.fileName.match(/\\-([a-z0-9]+)\\..*$/)[1]\n\t\t\t\t\t\t\tconst fileName = `${this.font.getName(variant)}.${ext}`\n\t\t\t\t\t\t\tzipFile.openReadStream(entry, (err, stream) => {\n\t\t\t\t\t\t\t\tif(err) reject(err)\n\t\t\t\t\t\t\t\tconst buffer = []\n\t\t\t\t\t\t\t\tstream.on(\"data\", data => buffer.push(data))\n\t\t\t\t\t\t\t\tstream.on(\"end\", () => {\n\t\t\t\t\t\t\t\t\tthis._files[fileName] = Buffer.concat(buffer)\n\t\t\t\t\t\t\t\t\tnext()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t})\n\t\t\t\t\tzipFile.readEntry()\n\t\t\t\t})\n\t\t\t}))\n\t}\n\n\tassets() {\n\t\treturn this.files()\n\t\t\t.then(files => {\n\t\t\t\tconst assets = {}\n\t\t\t\tfor(const fileName in files) {\n\t\t\t\t\tassets[fileName] = new RawSource(files[fileName])\n\t\t\t\t}\n\t\t\t\treturn assets\n\t\t\t})\n\t}\n}\n\nclass Font {\n\tconstructor(url, { id, family, variants, formats, defSubset, defVariant }) {\n\t\tthis.apiUrl = url\n\t\tthis.id = id\n\t\tthis.family = family\n\t\tthis.variants = variants\n\t\tthis.formats = formats\n\t\tthis.defaults = {\n\t\t\tsubsets: [ defSubset ],\n\t\t\tvariants: [ defVariant ]\n\t\t}\n\t\tthis.getName = this.getName.bind(this)\n\t}\n\n\tget url() { return `${this.apiUrl}/${this.id}` }\n\n\tgetName(variant) {\n\t\tlet name = _.chain(this.family).camelCase().upperFirst().value()\n\t\tif(variant) {\n\t\t\tconst weight = parseInt(variant.substr(0, 3))\n\t\t\tlet suffix = \"Regular\"\n\t\t\tswitch(weight) {\n\t\t\t\tcase 100: suffix = \"Thin\"; break;\n\t\t\t\tcase 200: suffix = \"ExtraLight\"; break;\n\t\t\t\tcase 300: suffix = \"Light\"; break;\n\t\t\t\tcase 400: suffix = \"Regular\"; break;\n\t\t\t\tcase 500: suffix = \"Medium\"; break;\n\t\t\t\tcase 600: suffix = \"SemiBold\"; break;\n\t\t\t\tcase 700: suffix = \"Bold\"; break;\n\t\t\t\tcase 800: suffix = \"ExtraBold\"; break;\n\t\t\t\tcase 900: suffix = \"Black\"; break;\n\t\t\t}\n\t\t\tif(/italic$/.test(variant)) {\n\t\t\t\tsuffix = (suffix === \"Regular\" ? \"Italic\" : `${suffix}Italic`)\n\t\t\t}\n\t\t\tname += `-${suffix}`\n\t\t}\n\t\treturn name\n\t}\n\n\tinfo(subsets) {\n\t\tif(this._info) {\n\t\t\treturn Promise.resolve(this._info)\n\t\t}\n\t\tlet url = this.url + \"?\"\n\t\tif(subsets) {\n\t\t\turl += \"subsets=\" + subsets.join(\",\")\n\t\t}\n\t\treturn fetch(url)\n\t\t\t.then(response => {\n\t\t\t\tif(response.status !== 200) {\n\t\t\t\t\tthrow new Error(response.statusText)\n\t\t\t\t}\n\t\t\t\treturn response.json()\n\t\t\t})\n\t\t\t.then(info => {\n\t\t\t\tthis._info = info\n\t\t\t\treturn info\n\t\t\t})\n\t}\n\n\tselect(options = {}) {\n\t\treturn new Selection(this, options)\n\t}\n}\n\nclass GoogleWebfonts {\n\tconstructor(apiUrl = API_URL) {\n\t\tthis.url = apiUrl\n\t}\n\n\tgetFonts() {\n\t\tif(this._fonts) {\n\t\t\treturn Promise.resolve(this._fonts)\n\t\t} else {\n\t\t\treturn fetch(this.url)\n\t\t\t\t.then(response => {\n\t\t\t\t\tif(response.status !== 200) {\n\t\t\t\t\t\tthrow new Error(response.statusText)\n\t\t\t\t\t}\n\t\t\t\t\treturn response.json()\n\t\t\t\t})\n\t\t\t\t.then(fonts => fonts.map(font => new Font(this.url, font)))\n\t\t\t\t.then(fonts => {\n\t\t\t\t\tthis._fonts = fonts\n\t\t\t\t\treturn fonts\n\t\t\t\t})\n\t\t}\n\t}\n\n\tgetFontById(id) {\n\t\treturn this.getFonts()\n\t\t\t.then(fonts => fonts.filter(font => font.id === id).pop())\n\t}\n\n\tgetFontByFamily(family) {\n\t\treturn this.getFonts()\n\t\t\t.then(fonts => fonts.filter(font => font.family.toLowerCase() === family.toLowerCase()).pop())\n\t}\n}\n\nGoogleWebfonts.Font = Font\n\nGoogleWebfonts.Selection = Selection\n\nmodule.exports = GoogleWebfonts\n\n'google-fonts-webpack-plugin/src/index.js'\n:const _ = require(\"lodash\")\nconst path = require(\"path\")\nconst Chunk = require(\"webpack/lib/Chunk\")\nconst { RawSource } = require(\"webpack-sources\")\nconst GoogleWebfonts = require(\"./GoogleWebfonts\")\nconst cssUrl = require(\"./cssUrl\")\n\nconst defaults = {\n\tfonts: undefined,\n\tname: \"fonts\",\n\tapiUrl: undefined,\n\tformats: undefined,\n\tfilename: \"fonts.css\",\n\tpath: \"font/\",\n\tlocal: true\n}\n\nclass GoogleWebfontsPlugin {\n\tconstructor(options) {\n\t\tthis.options = Object.assign({}, defaults, options)\n\t\tthis.chunk = new Chunk(this.options.name)\n\t\tthis.chunk.ids = []\n\t\tthis.chunk.name = this.options.name\n\t}\n\n\tget api() {\n\t\tif(!this._api) {\n\t\t\tthis._api = new GoogleWebfonts(this.options.apiUrl)\n\t\t}\n\t\treturn this._api\n\t}\n\n\tfetch() {\n\t\tconst {\n\t\t\tfonts,\n\t\t\tapiUrl,\n\t\t\tpath: fontsPath,\n\t\t\tfilename: cssFile,\n\t\t\tformats: defaultFormats\n\t\t} = this.options\n\t\tconst compareCss = (a, b) => (a.id.localeCompare(b.id))\n\t\tconst fontsCss = []\n\t\tconst files = {}\n\t\tconst promises = []\n\t\tfonts.forEach((fontOptions) => {\n\t\t\tconst { family } = fontOptions\n\t\t\tconst query = this.api.getFontByFamily(family)\n\t\t\t\t.then(font => {\n\t\t\t\t\tif(!font) {\n\t\t\t\t\t\tthrow new Error(`Font family \\\"${family}\\\" not found.`)\n\t\t\t\t\t}\n\t\t\t\t\treturn font.select(_.assign(\n\t\t\t\t\t\tfontOptions,\n\t\t\t\t\t\t{ formats: defaultFormats }\n\t\t\t\t\t))\n\t\t\t\t})\n\t\t\tconst cssRelativePath = path.posix.relative(\n\t\t\t\tpath.dirname(cssFile),\n\t\t\t\tfontsPath\n\t\t\t)\n\t\t\tpromises.push(\n\t\t\t\tquery.then(selection => {\n\t\t\t\t\treturn selection.css(cssRelativePath).then((css) => {\n\t\t\t\t\t\tfontsCss.push({\n\t\t\t\t\t\t\tcss,\n\t\t\t\t\t\t\tid: selection.font.id\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t)\n\t\t\tif(fontsPath) {\n\t\t\t\tpromises.push(\n\t\t\t\t\tquery.then(q => q.assets())\n\t\t\t\t\t.then(assets => {\n\t\t\t\t\t\tfor(const fileName in assets) {\n\t\t\t\t\t\t\tfiles[fontsPath + fileName] = assets[fileName]\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t\treturn Promise.all(promises)\n\t\t\t.then(() => {\n\t\t\t\tfontsCss.sort(compareCss)\n\t\t\t\tconst css = fontsCss.map(font => font.css).join(\"\\n\")\n\t\t\t\treturn { css, files }\n\t\t\t})\n\t}\n\n\tapply(compiler) {\n\t\tconst { fonts, local, filename: cssFile } = this.options\n\t\tcompiler.plugin(\"make\", (compilation, cb) => {\n\t\t\tif(local) {\n\t\t\t\tconst addFile = (fileName, source) => {\n\t\t\t\t\tthis.chunk.files.push(fileName)\n\t\t\t\t\tcompilation.assets[fileName] = source\n\t\t\t\t}\n\t\t\t\tthis.fetch().then(({ css, files }) => {\n\t\t\t\t\taddFile(cssFile, new RawSource(css))\n\t\t\t\t\tfor(const fileName in files) {\n\t\t\t\t\t\taddFile(fileName, files[fileName])\n\t\t\t\t\t}\n\t\t\t\t\tcb()\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tcb()\n\t\t\t}\n\t\t\tcompilation.plugin(\"html-webpack-plugin-before-html-generation\", (data, cb) => {\n\t\t\t\tif (local && (data.assets.publicPath.indexOf(\"://\") !== -1 || data.assets.publicPath.indexOf(\":\") !== -1)) {\n                    data.assets.css.push(data.assets.publicPath + cssFile);\n                } else if (local) {\n                    data.assets.css.push(path.posix.join(data.assets.publicPath, cssFile));\n                } else {\n                    data.assets.css.push(cssUrl(fonts));\n                }\n\t\t\t\tcb(null, data)\n\t\t\t})\n\t\t\tcompilation.plugin(\"additional-assets\", cb => {\n\t\t\t\tcompilation.chunks.push(this.chunk)\n\t\t\t\tcompilation.namedChunks[this.options.name] = this.chunk\n\t\t\t\tcb()\n\t\t\t})\n\t\t})\n\t}\n}\n\nGoogleWebfontsPlugin.GoogleWebfonts = GoogleWebfonts\n\nGoogleWebfontsPlugin.cssUrl = cssUrl\n\nmodule.exports = GoogleWebfontsPlugin\n\n",
        "called_code_segment_file_1": "getVariantCss({ variant, info, font, formats, fontsPath })",
        "invoking_code_segment_file_2": "css.push(getVariantCss({ info: variantInfo, formats, variant, font, fontsPath }))",
        "called_code_segment_file_2": "fetch().then(({ css, files }) => { addFile(cssFile, new RawSource(css)); for(const fileName in files) { addFile(fileName, files[fileName]); } cb(); })",
        "using_code_segment_file_3": "compilation.plugin('html-webpack-plugin-before-html-generation', (data, cb) => { if (local && (data.assets.publicPath.indexOf('://') !== -1 || data.assets.publicPath.indexOf(':') !== -1)) { data.assets.css.push(data.assets.publicPath + cssFile); } else if (local) { data.assets.css.push(path.posix.join(data.assets.publicPath, cssFile)); } else { data.assets.css.push(cssUrl(fonts)); } cb(null, data); })",
        "feature_description": "Add a feature to include a fallback URL for each font variant in the generated CSS.",
        "detailed_feature_description": "The new feature will modify the `getVariantCss` function in `#file 1` to include a fallback URL for each font variant. This fallback URL will be provided as an additional parameter to the `getVariantCss` function. The `fetch` function in `#file 2` will be updated to handle this new parameter and pass the fallback URL to `getVariantCss`. If `#file 3` directly interacts with the updated segments in `#file 2`, the code in `#file 3` will be modified to accommodate the changes.",
        "modified_complete_code": {
            "file_1": "function getVariantCss({ variant, info, font, formats, fontsPath, fallbackUrl }) { #Modify\n const src = info.local.map(fileName => `local(\"${fileName}\")`);\n let fallback;\n formats.forEach(ext => {\n if(ext in info) {\n const url = (typeof fontsPath !== \"undefined\" ? `./${fontsPath}/${font.getName(variant)}.${ext}` : info[ext]);\n const format = FontTypes[ext];\n src.push(FONT_SRC(url, format));\n if(ext === \"eot\") {\n fallback = FONT_SRC(url);\n }\n }\n });\n if (fallbackUrl) { #New\n src.push(FONT_SRC(fallbackUrl));\n }\n return (`/* === ${font.family} - ${variant} */` + FONT_FACE(_.assign({ src, fallback }, info)));\n}",
            "file_2": "fetch().then(({ css, files, fallbackUrls }) => { #Modify\n addFile(cssFile, new RawSource(css));\n for(const fileName in files) {\n addFile(fileName, files[fileName]);\n }\n for (const variant in fallbackUrls) { #New\n const fallbackUrl = fallbackUrls[variant];\n css.push(getVariantCss({ info: variantInfo, formats, variant, font, fontsPath, fallbackUrl }));\n }\n cb();\n })",
            "file_3": "compilation.plugin('html-webpack-plugin-before-html-generation', (data, cb) => { if (local && (data.assets.publicPath.indexOf('://') !== -1 || data.assets.publicPath.indexOf(':') !== -1)) { data.assets.css.push(data.assets.publicPath + cssFile); } else if (local) { data.assets.css.push(path.posix.join(data.assets.publicPath, cssFile)); } else { data.assets.css.push(cssUrl(fonts)); } cb(null, data); })"
        }
    },
    {
        "repo": "hype-beats",
        "content": "'hype-beats/src/DrumMachine.js'\n:import React, { useReducer, useState, useEffect, useRef } from 'react';\nimport { Link } from 'react-router-dom';\nimport styled from 'styled-components';\nimport Tone from 'tone';\n\nimport useBPM from './useBPM';\nimport useStart from './useStart';\nimport StepContext from './StepContext';\nimport Transport from './Transport';\nimport StepSequencer from './StepSequencer';\nimport Fx from './FX';\n\nimport { API, graphqlOperation } from 'aws-amplify'\nimport { createDrumMachine as CreateDrumMachine, updateDrumMachine as UpdateDrumMachine } from './graphql/mutations'\nimport { onUpdateByID } from './graphql/subscriptions'\nimport uuid from 'uuid/v4'\n\nconst clientId = uuid()\n\nconst Wrapper = styled.div`\n  border: 9px solid #ff32ff;\n  min-width: 840px;\n  height: 100vh;\n`\n\nconst Title = styled.div`\n  max-width: 800px;\n  margin: auto;\n  margin-top: 20px;\n  color: #ffe700;\n  text-decoration: none;\n  @media (max-width: 440px) {\n    margin-left: 20px;\n  }\n`\n\nconst Container = styled.div`\n  min-width: 800px;\n  max-width: 800px;\n  margin: auto;\n  background: linear-gradient(to bottom right, #222, #0a0a0a);\n  border: 2px solid black;\n  border-radius: 4px;\n  margin-top: 20px;\n  display: flex;\n  flex-direction: column;\n`;\n\nconst ButtonContainer = styled.div`\n  flex: 1;\n  flex-direction: row;\n  align-items: stretch;\n  width: 100%;\n  padding: 0px 20px 10px;\n  display: flex;\n`;\n\nconst Logo = styled.h1`\n  font-size: 28px;\n  color: #25ccf7;\n  font-family: 'Righteous', cursive;\n  padding: 20px;\n  margin: 0;\n  text-transform: uppercase;\n  display: inline-block;\n`;\n\nconst config = {\n  tracks: ['Kick', 'Sub1', 'Sub2', 'Snare', 'Clap', 'HiHat', 'OpenHiHat'],\n  samples: {\n    Kick: 'sounds/kick.wav',\n    Sub1: 'sounds/bass.wav',\n    Sub2: 'sounds/sub.wav',\n    Snare: 'sounds/snare.wav',\n    Clap: 'sounds/clap.wav',\n    HiHat: 'sounds/hat2.wav',\n    OpenHiHat: 'sounds/openhihat.wav',\n  },\n};\n\nconst initialStepState = {\n  Kick: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  Sub1: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  Sub2: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  Snare: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  Clap: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  HiHat: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  OpenHiHat: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n}\n\nasync function updateDrumMachine(beats, machineId) {\n  const beatbox = {\n    id: machineId, clientId, beats: JSON.stringify(beats)\n  }\n  try {\n    await API.graphql(graphqlOperation(UpdateDrumMachine, { input: beatbox }))\n    console.log('successfully updated drum machine...')\n  } catch (err) {\n    console.log('error updating drum machine...:', err)\n  }\n  return () => {}\n}\n\nasync function createDrumMachine(machine, setSteps) {\n  try {\n    await API.graphql(graphqlOperation(CreateDrumMachine, { input: machine }))\n    console.log('successfully created drum machine!')\n  } catch (err) {\n    console.log('error creating drum machine...: ', err)\n    const { errors } = err\n    const beats = errors[0].data.beats\n    setSteps(JSON.parse(beats))\n  }\n}\n\nfunction reducer(state, action) {\n  return action\n}\n\nexport default function DrumMachine(props) {\n  const { name: machineName, id: machineId } = props.match.params\n\n  const [stepState, setSteps] = useReducer(reducer, initialStepState)\n  const [buffers, setBuffers] = useState({});\n\n  const [currentStep, setCurrentStepState] = useState(0);\n\n  const [start, startButton] = useStart();\n  const [bpm, bpmSelector] = useBPM(65);\n\n  const buffersRef = useRef(buffers);\n  buffersRef.current = buffers;\n  const stepsRef = useRef(stepState);\n  stepsRef.current = stepState;\n  const currentStepRef = useRef(currentStep);\n  currentStepRef.current = currentStep;\n  \n  useEffect(() => {\n    const machine = {\n      id: machineId,\n      clientId,\n      beats: JSON.stringify(stepState),\n      name: machineName\n    }\n    createDrumMachine(machine, setSteps)\n  }, [])\n\n  useEffect(() => {\n    console.log('machineId: ', machineId)\n    const subscriber = API.graphql(graphqlOperation(onUpdateByID, { id: machineId })).subscribe({\n      next: data => {\n        console.log('data:', data)\n        const { value: { data: { onUpdateByID: { clientId: ClientId, beats }}}} = data\n        if (ClientId === clientId) return\n        setSteps(JSON.parse(beats))\n      }\n    });\n    return () => subscriber.unsubscribe()\n  }, []);\n\n  useEffect(\n    () => {\n      Tone.Transport.scheduleRepeat(function(time) {\n        Object.keys(buffersRef.current).forEach(b => {\n          let targetStep = stepsRef.current[b][currentStepRef.current];\n          let targetBuffer = buffersRef.current[b];\n\n          if (targetStep === 1) {\n            targetBuffer.start(time);\n          } else if (targetStep === 2) {\n            targetBuffer.start();\n            targetBuffer.start('+64n');\n            targetBuffer.start('+32n');\n          }\n        });\n\n        setCurrentStepState(step => {\n          return step > 14 ? 0 : step + 1;\n        });\n      }, '16n');\n      return () => buffersRef.current = {}\n    },\n    [config]\n  );\n\n  useEffect(\n    () => {\n      Tone.Transport.bpm.value = bpm;\n    },\n    [bpm]\n  );\n\n  useEffect(\n    () => {\n      if (start) {\n        Tone.Transport.start();\n      } else {\n        Tone.Transport.stop();\n        setCurrentStepState(0);\n      }\n      return () => Tone.Transport.stop()\n    },\n    [start]\n  );\n  return (\n    <Wrapper>\n    <StepContext.Provider value={{ state: stepState, setSteps, updateDrumMachine, machineId }}>\n      <Link to='/'>\n        <Title>View Beatboxes</Title>\n      </Link>\n      <Container>\n        <Transport>\n          <Logo>{machineName}</Logo>\n          {bpmSelector}\n          {startButton}\n        </Transport>\n        <React.Suspense fallback={<p style={{paddingLeft: 30, color: 'white'}}>loading</p>}>\n          <StepSequencer\n            config={config}\n            currentStep={currentStepRef.current}\n            playing={start}\n            setBuffers={setBuffers}\n          />\n          <ButtonContainer>\n            <Fx sound=\"sounds/loop.wav\" title=\"Turn Up (F)\" />\n            <Fx sound=\"sounds/loop130.wav\" title=\"SQUAD (Am)\" />\n            <Fx sound=\"sounds/hey.wav\" title=\"Hey\" />\n            <Fx sound=\"sounds/yeah.wav\" title=\"Yeah\" />\n          </ButtonContainer>\n        </React.Suspense>\n      </Container>\n    </StepContext.Provider>\n    </Wrapper>\n  );\n}\n\n\n'hype-beats/src/Router.js'\n:import React from 'react'\nimport { HashRouter as Router, Switch, Route } from 'react-router-dom'\n\nimport Machines from './Machines'\nimport Machine from './DrumMachine'\n\nfunction Main() {\n  return (\n    <Router>\n      <div>\n        <Switch>\n          <Route exact path=\"/\" component={Machines} />\n          <Route path=\"/machine/:id/:name?\" component={Machine} />\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n\nexport default Main\n'hype-beats/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport Amplify from 'aws-amplify'\nimport AWSAppSyncClient from 'aws-appsync'\nimport { Rehydrated } from 'aws-appsync-react'\nimport { ApolloProvider } from 'react-apollo'\n\nimport './index.css';\nimport Router from './Router';\nimport config from './aws-exports'\n\nAmplify.configure(config)\n\nconst client = new AWSAppSyncClient({\n  url: config.aws_appsync_graphqlEndpoint,\n  region: config.aws_appsync_region,\n  auth: {\n    type: config.aws_appsync_authenticationType,\n    apiKey: config.aws_appsync_apiKey\n  }\n});\n\nwindow.LOG_LEVEL = \"DEBUG\"\n\nconst AppWithProvider = () => (\n  <ApolloProvider client={client}>\n    <Rehydrated\n      render={({ rehydrated }) => (\n        rehydrated ? <Router /> : <p style={{ padding: 30, color: 'white' }}>Loading...</p>\n      )}\n    />\n  </ApolloProvider>\n);\n\nReactDOM.createRoot(document.getElementById('root')).render(<AppWithProvider />);\n\n",
        "called_code_segment_file_1": "function reducer(state, action) {\n  return action\n}",
        "invoking_code_segment_file_2": "const [stepState, setSteps] = useReducer(reducer, initialStepState)",
        "called_code_segment_file_2": "const [stepState, setSteps] = useReducer(reducer, initialStepState)",
        "using_code_segment_file_3": "const { state: stepState, setSteps, updateDrumMachine, machineId } = useContext(StepContext)",
        "feature_description": "Add a feature to allow users to clear all steps in the drum machine.",
        "detailed_feature_description": "Modify the reducer function in #file 1 to handle a new action type 'CLEAR_ALL' which resets all steps to their initial state. Update #file 2 to include a new function clearAllSteps that dispatches this action. Ensure #file 3 can call this new function when a 'Clear All' button is clicked.",
        "modified_complete_code": {
            "#file 1": "function reducer(state, action) {\n  switch (action.type) {\n    case 'CLEAR_ALL':\n      return initialStepState;\n    default:\n      return action;\n  }\n}",
            "#file 2": "const [stepState, setSteps] = useReducer(reducer, initialStepState);\n\nconst clearAllSteps = () => {\n  setSteps({ type: 'CLEAR_ALL' });\n};\n\n#Modify\n#New\n<Button onClick={clearAllSteps}>Clear All</Button>",
            "#file 3": "const { state: stepState, setSteps, updateDrumMachine, machineId, clearAllSteps } = useContext(StepContext);\n\n#Modify\n#New\n<Button onClick={clearAllSteps}>Clear All</Button>"
        }
    },
    {
        "repo": "mediumdesk-v1",
        "content": "'mediumdesk-v1/src/menu.js'\n:'use strict';\nconst os = require('os');\nconst path = require('path');\nconst electron = require('electron');\nconst app = electron.app;\nconst BrowserWindow = electron.BrowserWindow;\nconst shell = electron.shell;\nconst appName = app.getName();\nconst UpdateHandler = require('./update');\n\nconst params = {};\n\nfunction sendAction(action) {\n\tconst win = BrowserWindow.getAllWindows()[0];\n\n\tif (process.platform === 'darwin') {\n\t\twin.restore();\n\t}\n\n\twin.webContents.send(action);\n}\n\nfunction checkUpdate() {\n\tconst updateHandler = new UpdateHandler();\n\tupdateHandler.checkForUpdate(`v${app.getVersion()}`, false);\n}\n\nconst helpSubmenu = [\n\t{\n\t\tlabel: `${appName} Website...`,\n\t\tclick() {\n\t\t\tshell.openExternal('https://medium.com/desktop-apps');\n\t\t}\n\t},\n\t{\n\t\tlabel: `Medium Website...`,\n\t\tclick() {\n\t\t\tshell.openExternal('https://medium.com');\n\t\t}\n\t},\n\t{\n\t\ttype: 'separator'\n\t},\n\t{\n\t\tlabel: `Check for updates...`,\n\t\tclick() {\n\t\t\tcheckUpdate();\n\t\t}\n\t},\n\t{\n\t\tlabel: 'Report an Issue...',\n\t\tclick() {\n\t\t\tconst body = `\n<< Please succinctly describe your issue and steps to reproduce it. >>\n\n----\n${app.getName()} ${app.getVersion()}\nElectron ${process.versions.electron}\n${process.platform} ${process.arch} ${os.release()}`;\n\n\t\t\tshell.openExternal(`https://github.com/sivragav/mediumdesk/issues/new?body=${encodeURIComponent(body)}`);\n\t\t}\n\t}\n];\n\nconst viewSubmenu = [\n\t{\n\t\tlabel: `Reload`,\n\t\taccelerator: 'CmdOrCtrl+R',\n\t\tclick() {\n\t\t\tconst win = BrowserWindow.getAllWindows()[0];\n\t\t\twin.reload();\n\t\t}\n\t},\n\t{\n\t\tlabel: `Back`,\n\t\taccelerator: `CmdOrCtrl+[`,\n\t\tclick() {\n\t\t\tsendAction('go-back');\n\t\t}\n\t},\n\t{\n\t\tlabel: `Forward`,\n\t\taccelerator: `CmdOrCtrl+]`,\n\t\tclick() {\n\t\t\tsendAction('go-forward');\n\t\t}\n\t}\n];\n\nif (process.platform !== 'darwin') {\n\thelpSubmenu.push({\n\t\ttype: 'separator'\n\t}, {\n\t\tlabel: `About ${appName}`,\n\t\tclick() {\n\t\t\telectron.dialog.showMessageBox({\n\t\t\t\ttitle: `About ${appName}`,\n\t\t\t\tmessage: `${appName} ${app.getVersion()}`,\n\t\t\t\tdetail: 'Created by Sivaprakash Ragavan',\n\t\t\t\ticon: path.join(__dirname, '../static/Icon.png'),\n\t\t\t\tbuttons: []\n\t\t\t});\n\t\t}\n\t});\n}\n\nconst darwinTpl = [\n\t{\n\t\tlabel: appName,\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: `About ${appName}`,\n\t\t\t\trole: 'about'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Preferences...',\n\t\t\t\taccelerator: 'Cmd+,',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Services',\n\t\t\t\trole: 'services',\n\t\t\t\tsubmenu: []\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: `Hide ${appName}`,\n\t\t\t\taccelerator: 'Cmd+H',\n\t\t\t\trole: 'hide'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Hide Others',\n\t\t\t\taccelerator: 'Cmd+Shift+H',\n\t\t\t\trole: 'hideothers'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Show All',\n\t\t\t\trole: 'unhide'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: `Quit ${appName}`,\n\t\t\t\taccelerator: 'Cmd+Q',\n\t\t\t\tclick() {\n\t\t\t\t\tapp.quit();\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'File',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'New Story',\n\t\t\t\taccelerator: 'Cmd+N',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-new');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Import from disk...',\n\t\t\t\taccelerator: 'Cmd+O',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-file');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Search Medium',\n\t\t\t\taccelerator: 'Cmd+Shift+F',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-search');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Home',\n\t\t\t\taccelerator: 'Cmd+0',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-home');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Drafts',\n\t\t\t\taccelerator: 'Cmd+1',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-drafts');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stories',\n\t\t\t\taccelerator: 'Cmd+2',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stories');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stats',\n\t\t\t\taccelerator: 'Cmd+3',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stats');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bookmarks',\n\t\t\t\taccelerator: 'Cmd+4',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-bookmarks');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Publications',\n\t\t\t\taccelerator: 'Cmd+5',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-pubs');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Profile',\n\t\t\t\taccelerator: 'Cmd+6',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-profile');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Settings',\n\t\t\t\taccelerator: 'Cmd+7',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Login',\n\t\t\t\taccelerator: 'Cmd+8',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-login');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Open in Browser',\n\t\t\t\taccelerator: 'Cmd+9',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-in-browser')\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Edit',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Undo',\n\t\t\t\taccelerator: 'Cmd+Z',\n\t\t\t\trole: 'undo'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Redo',\n\t\t\t\taccelerator: 'Shift+Cmd+Z',\n\t\t\t\trole: 'redo'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Cut',\n\t\t\t\taccelerator: 'Cmd+X',\n\t\t\t\trole: 'cut'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Copy',\n\t\t\t\taccelerator: 'Cmd+C',\n\t\t\t\trole: 'copy'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Paste',\n\t\t\t\taccelerator: 'Cmd+V',\n\t\t\t\trole: 'paste'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Select All',\n\t\t\t\taccelerator: 'Cmd+A',\n\t\t\t\trole: 'selectall'\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'View',\n\t\tsubmenu: viewSubmenu\n\t},\n\t{\n\t\tlabel: 'Window',\n\t\trole: 'window',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Minimize',\n\t\t\t\taccelerator: 'Cmd+M',\n\t\t\t\trole: 'minimize'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Close',\n\t\t\t\taccelerator: 'Cmd+W',\n\t\t\t\trole: 'close'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bring All to Front',\n\t\t\t\trole: 'front'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Toggle Full Screen',\n\t\t\t\taccelerator: 'Ctrl+Cmd+F',\n\t\t\t\tclick() {\n\t\t\t\t\tconst win = BrowserWindow.getAllWindows()[0];\n\t\t\t\t\twin.setFullScreen(!win.isFullScreen());\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Help',\n\t\trole: 'help',\n\t\tsubmenu: helpSubmenu\n\t}\n];\n\nconst otherTpl = [\n\t{\n\t\tlabel: 'File',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'New Story',\n\t\t\t\taccelerator: 'Ctrl+N',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-new');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Import from disk...',\n\t\t\t\taccelerator: 'Ctrl+O',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-file');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Search Medium',\n\t\t\t\taccelerator: 'Ctrl+Shift+F',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-search');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Home',\n\t\t\t\taccelerator: 'Ctrl+0',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-home');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Drafts',\n\t\t\t\taccelerator: 'Ctrl+1',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-drafts');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stories',\n\t\t\t\taccelerator: 'Ctrl+2',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stories');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stats',\n\t\t\t\taccelerator: 'Ctrl+3',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stats');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bookmarks',\n\t\t\t\taccelerator: 'Ctrl+4',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-bookmarks');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Publications',\n\t\t\t\taccelerator: 'Ctrl+5',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-pubs');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Profile',\n\t\t\t\taccelerator: 'Ctrl+6',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-profile');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Settings',\n\t\t\t\taccelerator: 'Ctrl+7',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Login',\n\t\t\t\taccelerator: 'Ctrl+8',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-login');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Open in Browser',\n\t\t\t\taccelerator: 'Ctrl+9',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-in-browser')\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Quit',\n\t\t\t\taccelerator: 'Ctrl+W',\n\t\t\t\tclick() {\n\t\t\t\t\tapp.quit();\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Edit',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Cut',\n\t\t\t\taccelerator: 'Ctrl+X',\n\t\t\t\trole: 'cut'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Copy',\n\t\t\t\taccelerator: 'Ctrl+C',\n\t\t\t\trole: 'copy'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Paste',\n\t\t\t\taccelerator: 'Ctrl+V',\n\t\t\t\trole: 'paste'\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'View',\n\t\tsubmenu: viewSubmenu\n\t},\n\t{\n\t\tlabel: 'Help',\n\t\trole: 'help',\n\t\tsubmenu: helpSubmenu\n\t}\n];\n\nexports.build = () => {\n\tconsole.log(params);\n\tconst tpl = process.platform === 'darwin' ? darwinTpl : otherTpl;\n\treturn electron.Menu.buildFromTemplate(tpl);\n};\n\nexports.setParam = (name, value) => {\n\tparams[name] = value;\n};\n\nexports.getParam = name => {\n\treturn params[name];\n};\n\n'mediumdesk-v1/src/navigate.js'\n:'use strict';\nconst electron = require('electron');\nconst menu = require('./menu');\n\nexports.onNavigate = (e, url) => {\n  if (url.startsWith('https://medium.com/new-story')) {\n\t\tmenu.setParam('showEditMenu', true);\n\t\telectron.Menu.setApplicationMenu(menu.build());\n\t} else {\n    if(menu.getParam('showEditMenu')) {\n      menu.setParam('showEditMenu', false);\n\t\t  electron.Menu.setApplicationMenu(menu.build());\n    }\n  }\n}\n\n'mediumdesk-v1/src/index.js'\n:'use strict';\nconst path = require('path');\nconst fs = require('fs');\nconst electron = require('electron');\nconst app = electron.app;\nconst menu = require('./menu');\nconst Store = require('electron-store');\nconst storage = new Store();\nconst navigate = require('./navigate');\nconst tray = require('./tray');\nconst UpdateHandler = require('./update');\nconst Common = require('./common');\nconst {ipcMain} = require('electron');\nconst mediumapi = require('./mediumapi');\n\nrequire('electron-debug')();\nrequire('electron-dl')();\n\nlet mainWindow;\nlet isQuitting = false;\n\nconst isAlreadyRunning = app.makeSingleInstance(() => {\n\tif (mainWindow) {\n\t\tif (mainWindow.isMinimized()) {\n\t\t\tmainWindow.restore();\n\t\t}\n\t\tmainWindow.show();\n\t}\n});\n\nif (isAlreadyRunning) {\n\tapp.quit();\n}\n\nfunction createMainWindow() {\n\tconst lastWindowState = storage.get('lastWindowState') || Common.WINDOW_SIZE;\n\n\tconst win = new electron.BrowserWindow({\n\t\ttitle: app.getName(),\n\t\tshow: false,\n\t\tx: lastWindowState.x,\n\t\ty: lastWindowState.y,\n\t\twidth: lastWindowState.width,\n\t\theight: lastWindowState.height,\n\t\ticon: process.platform === 'linux' && path.join(__dirname, '../static/Icon.png'),\n\t\tminWidth: 992,\n\t\tminHeight: 450,\n\t\t// titleBarStyle: 'hidden-inset',\n\t\t// autoHideMenuBar: true,\n\t\twebPreferences: {\n\t\t\t// fails without this because of CommonJS script detection\n\t\t\tnodeIntegration: false,\n\t\t\tpreload: path.join(__dirname, 'browser.js'),\n\t\t\twebSecurity: true,\n\t\t\tplugins: true\n\t\t}\n\t});\n\n\tlet startPage = null;\n\tswitch(storage.get('start-page')) {\n\t\tcase 'home':\n\t\t\tstartPage = Common.MEDIUM_HOME;\n\t\t\tbreak;\n\t\tcase 'new':\n\t\t\tstartPage = 'https://medium.com/new-story';\n\t\t\tbreak;\n\t\tcase 'drafts':\n\t\t\tstartPage = 'https://medium.com/me/stories/drafts';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstartPage = Common.MEDIUM_HOME;\n\t\t\tbreak;\n\t}\n\n\twin.loadURL(startPage);\n\twin.on('close', e => {\n\t\tif (!isQuitting) {\n\t\t\te.preventDefault();\n\n\t\t\tif (process.platform === 'darwin') {\n\t\t\t\tapp.hide();\n\t\t\t} else {\n\t\t\t\twin.hide();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn win;\n}\n\napp.on('ready', () => {\n\telectron.Menu.setApplicationMenu(menu.build());\n\tmainWindow = createMainWindow();\n\ttray.create(mainWindow);\n\n\tconst page = mainWindow.webContents;\n\n\tpage.on('dom-ready', () => {\n\t\tpage.insertCSS(fs.readFileSync(path.join(__dirname, 'styles/browser.css'), 'utf8'));\n\t\tmainWindow.show();\n\t});\n\n\tpage.on('did-navigate', navigate.onNavigate);\n\tpage.on('did-navigate-in-page', navigate.onNavigate);\n\n\tpage.on('new-window', (e, url) => {\n\t\te.preventDefault();\n\t\telectron.shell.openExternal(url);\n\t});\n\n\tnew UpdateHandler().checkForUpdate(`v${app.getVersion()}`, true);\n});\n\napp.on('activate', () => {\n\tmainWindow.show();\n});\n\napp.on('before-quit', () => {\n\tisQuitting = true;\n\n\tif (!mainWindow.isFullScreen()) {\n\t\tstorage.set('lastWindowState', mainWindow.getBounds());\n\t}\n});\n\n// Messages\nipcMain.on('import-file', (event, file) => {\n\tconsole.log(\"Importing : \" + file);\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\tshowLoadingMessage('Importing from disk...');\n\tsetTimeout(() => {\n\t\ttry {\n\t\t\tfs.openSync(file, 'r+');\n\t\t\tvar data = fs.readFileSync(file).toString();\n\t\t\tmediumapi.publish(\"\", data, file.endsWith(\"html\") | file.endsWith(\"html\") ? \"html\" : \"markdown\", [],\n\t\t\t\t(error, statusCode, headers, body) => {\n\t\t\t\t\tif(error || !(statusCode == 200 || statusCode == 201)) {\n\t\t\t\t\t\tconsole.log('Error: ', error);\n\t\t\t\t\t\tconsole.log('Status: ', statusCode);\n\t\t\t\t\t\tconsole.log('Headers: ', JSON.stringify(headers));\n\t\t\t\t\t\tconsole.log('Body: ', body);\n\t\t\t\t\t\tif(body) {\n\t\t\t\t\t\t\tvar bodyContents = JSON.parse(body);\n\t\t\t\t\t\t\tshowErrorMessage(bodyContents[\"errors\"][0][\"message\"]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshowErrorMessage('Unknown Error Occured');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Reponse from Medium: ', body);\n\t\t\t\t\t\tvar bodyContents = JSON.parse(body);\n\t\t\t\t\t\tconst url = bodyContents[\"data\"][\"url\"];\n\t\t\t\t\t\tif(url) {\n\t\t\t\t\t\t\twin.loadURL(url);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshowErrorMessage('Error loading Draft');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tconsole.error('Couldn\\'t read file' + err);\n\t\t\tshowErrorMessage('Error reading file');\n\t\t}\n\t}, 100);\n});\n\nfunction showLoadingMessage(msg) {\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\twin.loadURL('file://' + __dirname + '/pages/message.html?msg=' + encodeURIComponent(msg) + '&loading=true');\n}\n\nfunction showErrorMessage(msg) {\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\twin.loadURL('file://' + __dirname + '/pages/message.html?msg=' + encodeURIComponent(msg) + '&error=true');\n\tsetTimeout(() => {\n\t\twin.loadURL(Common.MEDIUM_HOME);\n\t}, 2500);\n}\n\n",
        "called_code_segment_file_1": "exports.onNavigate = (e, url) => { if (url.startsWith('https://medium.com/new-story')) { menu.setParam('showEditMenu', true); electron.Menu.setApplicationMenu(menu.build()); } else { if(menu.getParam('showEditMenu')) { menu.setParam('showEditMenu', false); electron.Menu.setApplicationMenu(menu.build()); } } }",
        "invoking_code_segment_file_2": "page.on('did-navigate', navigate.onNavigate); page.on('did-navigate-in-page', navigate.onNavigate);",
        "called_code_segment_file_2": "exports.onNavigate = (e, url) => { if (url.startsWith('https://medium.com/new-story')) { menu.setParam('showEditMenu', true); electron.Menu.setApplicationMenu(menu.build()); } else { if(menu.getParam('showEditMenu')) { menu.setParam('showEditMenu', false); electron.Menu.setApplicationMenu(menu.build()); } } }",
        "using_code_segment_file_3": "const navigate = require('./navigate');",
        "feature_description": "Add a feature to automatically save the last visited URL to a file when the application is closed.",
        "detailed_feature_description": "Modify the `onNavigate` function in `navigate.js` to save the last visited URL to a file. Update the `app.on('before-quit')` event in `index.js` to read this saved URL and load it when the application starts. Ensure that the `navigate.js` file is updated to handle the new functionality and that `index.js` is modified to read from the saved file on startup.",
        "modified_complete_code": {
            "navigate.js": "#Modify exports.onNavigate = (e, url) => { if (url.startsWith('https://medium.com/new-story')) { menu.setParam('showEditMenu', true); electron.Menu.setApplicationMenu(menu.build()); } else { if(menu.getParam('showEditMenu')) { menu.setParam('showEditMenu', false); electron.Menu.setApplicationMenu(menu.build()); } } #New fs.writeFileSync('last_url.txt', url); }",
            "index.js": "#Modify app.on('before-quit', () => { isQuitting = true; if (!mainWindow.isFullScreen()) { storage.set('lastWindowState', mainWindow.getBounds()); } }); #New app.on('ready', () => { electron.Menu.setApplicationMenu(menu.build()); mainWindow = createMainWindow(); tray.create(mainWindow); const page = mainWindow.webContents; page.on('dom-ready', () => { page.insertCSS(fs.readFileSync(path.join(__dirname, 'styles/browser.css'), 'utf8')); mainWindow.show(); }); page.on('did-navigate', navigate.onNavigate); page.on('did-navigate-in-page', navigate.onNavigate); page.on('new-window', (e, url) => { e.preventDefault(); electron.shell.openExternal(url); }); new UpdateHandler().checkForUpdate(`v${app.getVersion()}`, true); #New if (fs.existsSync('last_url.txt')) { const lastUrl = fs.readFileSync('last_url.txt', 'utf8'); mainWindow.loadURL(lastUrl); } });",
            "menu.js": "const navigate = require('./navigate');"
        }
    },
    {
        "repo": "multiplayerSnake",
        "content": "'multiplayerSnake/server/constants.js'\n:const FRAME_RATE = 10;\nconst GRID_SIZE = 20;\n\nmodule.exports = {\n  FRAME_RATE,\n  GRID_SIZE,\n}\n\n'multiplayerSnake/server/game.js'\n:const { GRID_SIZE } = require('./constants');\n\nmodule.exports = {\n  initGame,\n  gameLoop,\n  getUpdatedVelocity,\n}\n\nfunction initGame() {\n  const state = createGameState()\n  randomFood(state);\n  return state;\n}\n\nfunction createGameState() {\n  return {\n    players: [{\n      pos: {\n        x: 3,\n        y: 10,\n      },\n      vel: {\n        x: 1,\n        y: 0,\n      },\n      snake: [\n        {x: 1, y: 10},\n        {x: 2, y: 10},\n        {x: 3, y: 10},\n      ],\n    }, {\n      pos: {\n        x: 18,\n        y: 10,\n      },\n      vel: {\n        x: 0,\n        y: 0,\n      },\n      snake: [\n        {x: 20, y: 10},\n        {x: 19, y: 10},\n        {x: 18, y: 10},\n      ],\n    }],\n    food: {},\n    gridsize: GRID_SIZE,\n  };\n}\n\nfunction gameLoop(state) {\n  if (!state) {\n    return;\n  }\n\n  const playerOne = state.players[0];\n  const playerTwo = state.players[1];\n\n  playerOne.pos.x += playerOne.vel.x;\n  playerOne.pos.y += playerOne.vel.y;\n\n  playerTwo.pos.x += playerTwo.vel.x;\n  playerTwo.pos.y += playerTwo.vel.y;\n\n  if (playerOne.pos.x < 0 || playerOne.pos.x > GRID_SIZE || playerOne.pos.y < 0 || playerOne.pos.y > GRID_SIZE) {\n    return 2;\n  }\n\n  if (playerTwo.pos.x < 0 || playerTwo.pos.x > GRID_SIZE || playerTwo.pos.y < 0 || playerTwo.pos.y > GRID_SIZE) {\n    return 1;\n  }\n\n  if (state.food.x === playerOne.pos.x && state.food.y === playerOne.pos.y) {\n    playerOne.snake.push({ ...playerOne.pos });\n    playerOne.pos.x += playerOne.vel.x;\n    playerOne.pos.y += playerOne.vel.y;\n    randomFood(state);\n  }\n\n  if (state.food.x === playerTwo.pos.x && state.food.y === playerTwo.pos.y) {\n    playerTwo.snake.push({ ...playerTwo.pos });\n    playerTwo.pos.x += playerTwo.vel.x;\n    playerTwo.pos.y += playerTwo.vel.y;\n    randomFood(state);\n  }\n\n  if (playerOne.vel.x || playerOne.vel.y) {\n    for (let cell of playerOne.snake) {\n      if (cell.x === playerOne.pos.x && cell.y === playerOne.pos.y) {\n        return 2;\n      }\n    }\n\n    playerOne.snake.push({ ...playerOne.pos });\n    playerOne.snake.shift();\n  }\n\n  if (playerTwo.vel.x || playerTwo.vel.y) {\n    for (let cell of playerTwo.snake) {\n      if (cell.x === playerTwo.pos.x && cell.y === playerTwo.pos.y) {\n        return 1;\n      }\n    }\n\n    playerTwo.snake.push({ ...playerTwo.pos });\n    playerTwo.snake.shift();\n  }\n\n  return false;\n}\n\nfunction randomFood(state) {\n  food = {\n    x: Math.floor(Math.random() * GRID_SIZE),\n    y: Math.floor(Math.random() * GRID_SIZE),\n  }\n\n  for (let cell of state.players[0].snake) {\n    if (cell.x === food.x && cell.y === food.y) {\n      return randomFood(state);\n    }\n  }\n\n  for (let cell of state.players[1].snake) {\n    if (cell.x === food.x && cell.y === food.y) {\n      return randomFood(state);\n    }\n  }\n\n  state.food = food;\n}\n\nfunction getUpdatedVelocity(keyCode) {\n  switch (keyCode) {\n    case 37: { // left\n      return { x: -1, y: 0 };\n    }\n    case 38: { // down\n      return { x: 0, y: -1 };\n    }\n    case 39: { // right\n      return { x: 1, y: 0 };\n    }\n    case 40: { // up\n      return { x: 0, y: 1 };\n    }\n  }\n}\n\n'multiplayerSnake/server/server.js'\n:const io = require('socket.io')();\nconst { initGame, gameLoop, getUpdatedVelocity } = require('./game');\nconst { FRAME_RATE } = require('./constants');\nconst { makeid } = require('./utils');\n\nconst state = {};\nconst clientRooms = {};\n\nio.on('connection', client => {\n\n  client.on('keydown', handleKeydown);\n  client.on('newGame', handleNewGame);\n  client.on('joinGame', handleJoinGame);\n\n  function handleJoinGame(roomName) {\n    const room = io.sockets.adapter.rooms[roomName];\n\n    let allUsers;\n    if (room) {\n      allUsers = room.sockets;\n    }\n\n    let numClients = 0;\n    if (allUsers) {\n      numClients = Object.keys(allUsers).length;\n    }\n\n    if (numClients === 0) {\n      client.emit('unknownCode');\n      return;\n    } else if (numClients > 1) {\n      client.emit('tooManyPlayers');\n      return;\n    }\n\n    clientRooms[client.id] = roomName;\n\n    client.join(roomName);\n    client.number = 2;\n    client.emit('init', 2);\n    \n    startGameInterval(roomName);\n  }\n\n  function handleNewGame() {\n    let roomName = makeid(5);\n    clientRooms[client.id] = roomName;\n    client.emit('gameCode', roomName);\n\n    state[roomName] = initGame();\n\n    client.join(roomName);\n    client.number = 1;\n    client.emit('init', 1);\n  }\n\n  function handleKeydown(keyCode) {\n    const roomName = clientRooms[client.id];\n    if (!roomName) {\n      return;\n    }\n    try {\n      keyCode = parseInt(keyCode);\n    } catch(e) {\n      console.error(e);\n      return;\n    }\n\n    const vel = getUpdatedVelocity(keyCode);\n\n    if (vel) {\n      state[roomName].players[client.number - 1].vel = vel;\n    }\n  }\n});\n\nfunction startGameInterval(roomName) {\n  const intervalId = setInterval(() => {\n    const winner = gameLoop(state[roomName]);\n    \n    if (!winner) {\n      emitGameState(roomName, state[roomName])\n    } else {\n      emitGameOver(roomName, winner);\n      state[roomName] = null;\n      clearInterval(intervalId);\n    }\n  }, 1000 / FRAME_RATE);\n}\n\nfunction emitGameState(room, gameState) {\n  // Send this event to everyone in the room.\n  io.sockets.in(room)\n    .emit('gameState', JSON.stringify(gameState));\n}\n\nfunction emitGameOver(room, winner) {\n  io.sockets.in(room)\n    .emit('gameOver', JSON.stringify({ winner }));\n}\n\nio.listen(process.env.PORT || 3000);\n\n",
        "called_code_segment_file_1": "function getUpdatedVelocity(keyCode) {\n  switch (keyCode) {\n    case 37: { // left\n      return { x: -1, y: 0 };\n    }\n    case 38: { // down\n      return { x: 0, y: -1 };\n    }\n    case 39: { // right\n      return { x: 1, y: 0 };\n    }\n    case 40: { // up\n      return { x: 0, y: 1 };\n    }\n  }\n}",
        "invoking_code_segment_file_2": "function handleKeydown(keyCode) {\n  const roomName = clientRooms[client.id];\n  if (!roomName) {\n    return;\n  }\n  try {\n    keyCode = parseInt(keyCode);\n  } catch(e) {\n    console.error(e);\n    return;\n  }\n\n  const vel = getUpdatedVelocity(keyCode);\n\n  if (vel) {\n    state[roomName].players[client.number - 1].vel = vel;\n  }\n}",
        "called_code_segment_file_2": "function startGameInterval(roomName) {\n  const intervalId = setInterval(() => {\n    const winner = gameLoop(state[roomName]);\n    \n    if (!winner) {\n      emitGameState(roomName, state[roomName])\n    } else {\n      emitGameOver(roomName, winner);\n      state[roomName] = null;\n      clearInterval(intervalId);\n    }\n  }, 1000 / FRAME_RATE);\n}",
        "using_code_segment_file_3": "io.on('connection', client => {\n\n  client.on('keydown', handleKeydown);\n  client.on('newGame', handleNewGame);\n  client.on('joinGame', handleJoinGame);\n\n  function handleJoinGame(roomName) {\n    const room = io.sockets.adapter.rooms[roomName];\n\n    let allUsers;\n    if (room) {\n      allUsers = room.sockets;\n    }\n\n    let numClients = 0;\n    if (allUsers) {\n      numClients = Object.keys(allUsers).length;\n    }\n\n    if (numClients === 0) {\n      client.emit('unknownCode');\n      return;\n    } else if (numClients > 1) {\n      client.emit('tooManyPlayers');\n      return;\n    }\n\n    clientRooms[client.id] = roomName;\n\n    client.join(roomName);\n    client.number = 2;\n    client.emit('init', 2);\n    \n    startGameInterval(roomName);\n  }\n\n  function handleNewGame() {\n    let roomName = makeid(5);\n    clientRooms[client.id] = roomName;\n    client.emit('gameCode', roomName);\n\n    state[roomName] = initGame();\n\n    client.join(roomName);\n    client.number = 1;\n    client.emit('init', 1);\n  }\n\n  function handleKeydown(keyCode) {\n    const roomName = clientRooms[client.id];\n    if (!roomName) {\n      return;\n    }\n    try {\n      keyCode = parseInt(keyCode);\n    } catch(e) {\n      console.error(e);\n      return;\n    }\n\n    const vel = getUpdatedVelocity(keyCode);\n\n    if (vel) {\n      state[roomName].players[client.number - 1].vel = vel;\n    }\n  }\n});",
        "feature_description": "Add a feature to reverse the snake's direction when the 'R' key is pressed.",
        "detailed_feature_description": "Modify the `getUpdatedVelocity` function in `#file 1` to handle the 'R' key. Update the `handleKeydown` function in `#file 2` to call the new logic. Ensure that the `startGameInterval` function in `#file 2` handles the new state correctly. No direct interaction with `#file 3` is required for this feature.",
        "modified_complete_code": {
            "file_1": "const { GRID_SIZE } = require('./constants');\n\nmodule.exports = {\n  initGame,\n  gameLoop,\n  getUpdatedVelocity,\n}\n\nfunction initGame() {\n  const state = createGameState()\n  randomFood(state);\n  return state;\n}\n\nfunction createGameState() {\n  return {\n    players: [{\n      pos: { x: 3, y: 10, },\n      vel: { x: 1, y: 0, },\n      snake: [\n        {x: 1, y: 10},\n        {x: 2, y: 10},\n        {x: 3, y: 10},\n      ],\n    }, {\n      pos: { x: 18, y: 10, },\n      vel: { x: 0, y: 0, },\n      snake: [\n        {x: 20, y: 10},\n        {x: 19, y: 10},\n        {x: 18, y: 10},\n      ],\n    }],\n    food: {},\n    gridsize: GRID_SIZE,\n  };\n}\n\nfunction gameLoop(state) {\n  if (!state) {\n    return;\n  }\n\n  const playerOne = state.players[0];\n  const playerTwo = state.players[1];\n\n  playerOne.pos.x += playerOne.vel.x;\n  playerOne.pos.y += playerOne.vel.y;\n\n  playerTwo.pos.x += playerTwo.vel.x;\n  playerTwo.pos.y += playerTwo.vel.y;\n\n  if (playerOne.pos.x < 0 || playerOne.pos.x > GRID_SIZE || playerOne.pos.y < 0 || playerOne.pos.y > GRID_SIZE) {\n    return 2;\n  }\n\n  if (playerTwo.pos.x < 0 || playerTwo.pos.x > GRID_SIZE || playerTwo.pos.y < 0 || playerTwo.pos.y > GRID_SIZE) {\n    return 1;\n  }\n\n  if (state.food.x === playerOne.pos.x && state.food.y === playerOne.pos.y) {\n    playerOne.snake.push({ ...playerOne.pos });\n    playerOne.pos.x += playerOne.vel.x;\n    playerOne.pos.y += playerOne.vel.y;\n    randomFood(state);\n  }\n\n  if (state.food.x === playerTwo.pos.x && state.food.y === playerTwo.pos.y) {\n    playerTwo.snake.push({ ...playerTwo.pos });\n    playerTwo.pos.x += playerTwo.vel.x;\n    playerTwo.pos.y += playerTwo.vel.y;\n    randomFood(state);\n  }\n\n  if (playerOne.vel.x || playerOne.vel.y) {\n    for (let cell of playerOne.snake) {\n      if (cell.x === playerOne.pos.x && cell.y === playerOne.pos.y) {\n        return 2;\n      }\n    }\n\n    playerOne.snake.push({ ...playerOne.pos });\n    playerOne.snake.shift();\n  }\n\n  if (playerTwo.vel.x || playerTwo.vel.y) {\n    for (let cell of playerTwo.snake) {\n      if (cell.x === playerTwo.pos.x && cell.y === playerTwo.pos.y) {\n        return 1;\n      }\n    }\n\n    playerTwo.snake.push({ ...playerTwo.pos });\n    playerTwo.snake.shift();\n  }\n\n  return false;\n}\n\nfunction randomFood(state) {\n  food = {\n    x: Math.floor(Math.random() * GRID_SIZE),\n    y: Math.floor(Math.random() * GRID_SIZE),\n  }\n\n  for (let cell of state.players[0].snake) {\n    if (cell.x === food.x && cell.y === food.y) {\n      return randomFood(state);\n    }\n  }\n\n  for (let cell of state.players[1].snake) {\n    if (cell.x === food.x && cell.y === food.y) {\n      return randomFood(state);\n    }\n  }\n\n  state.food = food;\n}\n\n#Modify\nfunction getUpdatedVelocity(keyCode) {\n  switch (keyCode) {\n    case 37: { // left\n      return { x: -1, y: 0 };\n    }\n    case 38: { // down\n      return { x: 0, y: -1 };\n    }\n    case 39: { // right\n      return { x: 1, y: 0 };\n    }\n    case 40: { // up\n      return { x: 0, y: 1 };\n    }\n    case 82: { // 'R' key\n      return { x: -state.players[client.number - 1].vel.x, y: -state.players[client.number - 1].vel.y };\n    }\n  }\n}",
            "file_2": "const io = require('socket.io')();\nconst { initGame, gameLoop, getUpdatedVelocity } = require('./game');\nconst { FRAME_RATE } = require('./constants');\nconst { makeid } = require('./utils');\n\nconst state = {};\nconst clientRooms = {};\n\nio.on('connection', client => {\n\n  client.on('keydown', handleKeydown);\n  client.on('newGame', handleNewGame);\n  client.on('joinGame', handleJoinGame);\n\n  function handleJoinGame(roomName) {\n    const room = io.sockets.adapter.rooms[roomName];\n\n    let allUsers;\n    if (room) {\n      allUsers = room.sockets;\n    }\n\n    let numClients = 0;\n    if (allUsers) {\n      numClients = Object.keys(allUsers).length;\n    }\n\n    if (numClients === 0) {\n      client.emit('unknownCode');\n      return;\n    } else if (numClients > 1) {\n      client.emit('tooManyPlayers');\n      return;\n    }\n\n    clientRooms[client.id] = roomName;\n\n    client.join(roomName);\n    client.number = 2;\n    client.emit('init', 2);\n    \n    startGameInterval(roomName);\n  }\n\n  function handleNewGame() {\n    let roomName = makeid(5);\n    clientRooms[client.id] = roomName;\n    client.emit('gameCode', roomName);\n\n    state[roomName] = initGame();\n\n    client.join(roomName);\n    client.number = 1;\n    client.emit('init', 1);\n  }\n\n  #Modify\n  function handleKeydown(keyCode) {\n    const roomName = clientRooms[client.id];\n    if (!roomName) {\n      return;\n    }\n    try {\n      keyCode = parseInt(keyCode);\n    } catch(e) {\n      console.error(e);\n      return;\n    }\n\n    const vel = getUpdatedVelocity(keyCode);\n\n    if (vel) {\n      state[roomName].players[client.number - 1].vel = vel;\n    }\n  }\n});\n\nfunction startGameInterval(roomName) {\n  const intervalId = setInterval(() => {\n    const winner = gameLoop(state[roomName]);\n    \n    if (!winner) {\n      emitGameState(roomName, state[roomName])\n    } else {\n      emitGameOver(roomName, winner);\n      state[roomName] = null;\n      clearInterval(intervalId);\n    }\n  }, 1000 / FRAME_RATE);\n}\n\nfunction emitGameState(room, gameState) {\n  // Send this event to everyone in the room.\n  io.sockets.in(room)\n    .emit('gameState', JSON.stringify(gameState));\n}\n\nfunction emitGameOver(room, winner) {\n  io.sockets.in(room)\n    .emit('gameOver', JSON.stringify({ winner }));\n}\n\nio.listen(process.env.PORT || 3000);",
            "file_3": "const io = require('socket.io')();\nconst { initGame, gameLoop, getUpdatedVelocity } = require('./game');\nconst { FRAME_RATE } = require('./constants');\nconst { makeid } = require('./utils');\n\nconst state = {};\nconst clientRooms = {};\n\nio.on('connection', client => {\n\n  client.on('keydown', handleKeydown);\n  client.on('newGame', handleNewGame);\n  client.on('joinGame', handleJoinGame);\n\n  function handleJoinGame(roomName) {\n    const room = io.sockets.adapter.rooms[roomName];\n\n    let allUsers;\n    if (room) {\n      allUsers = room.sockets;\n    }\n\n    let numClients = 0;\n    if (allUsers) {\n      numClients = Object.keys(allUsers).length;\n    }\n\n    if (numClients === 0) {\n      client.emit('unknownCode');\n      return;\n    } else if (numClients > 1) {\n      client.emit('tooManyPlayers');\n      return;\n    }\n\n    clientRooms[client.id] = roomName;\n\n    client.join(roomName);\n    client.number = 2;\n    client.emit('init', 2);\n    \n    startGameInterval(roomName);\n  }\n\n  function handleNewGame() {\n    let roomName = makeid(5);\n    clientRooms[client.id] = roomName;\n    client.emit('gameCode', roomName);\n\n    state[roomName] = initGame();\n\n    client.join(roomName);\n    client.number = 1;\n    client.emit('init', 1);\n  }\n\n  function handleKeydown(keyCode) {\n    const roomName = clientRooms[client.id];\n    if (!roomName) {\n      return;\n    }\n    try {\n      keyCode = parseInt(keyCode);\n    } catch(e) {\n      console.error(e);\n      return;\n    }\n\n    const vel = getUpdatedVelocity(keyCode);\n\n    if (vel) {\n      state[roomName].players[client.number - 1].vel = vel;\n    }\n  }\n});\n\nfunction startGameInterval(roomName) {\n  const intervalId = setInterval(() => {\n    const winner = gameLoop(state[roomName]);\n    \n    if (!winner) {\n      emitGameState(roomName, state[roomName])\n    } else {\n      emitGameOver(roomName, winner);\n      state[roomName] = null;\n      clearInterval(intervalId);\n    }\n  }, 1000 / FRAME_RATE);\n}\n\nfunction emitGameState(room, gameState) {\n  // Send this event to everyone in the room.\n  io.sockets.in(room)\n    .emit('gameState', JSON.stringify(gameState));\n}\n\nfunction emitGameOver(room, winner) {\n  io.sockets.in(room)\n    .emit('gameOver', JSON.stringify({ winner }));\n}\n\nio.listen(process.env.PORT || 3000);"
        }
    },
    {
        "repo": "nextjs-client-auth-architectures",
        "content": "'nextjs-client-auth-architectures/ssr/src/providers/Auth.js'\n:import React from 'react';\n\nconst AuthContext = React.createContext({\n  isAuthenticated: false,\n  setAuthenticated: () => {}\n});\n\n/**\n * The initial value of `isAuthenticated` comes from the `authenticated`\n * prop which gets set by _app. We store that value in state and ignore\n * the prop from then on. The value can be changed by calling the\n * `setAuthenticated()` method in the context.\n */\nexport const AuthProvider = ({ children, authenticated }) => {\n  const [isAuthenticated, setAuthenticated] = React.useState(authenticated);\n  return (\n    <AuthContext.Provider\n      value={{\n        isAuthenticated,\n        setAuthenticated\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport function useAuth() {\n  const context = React.useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n\nexport function useIsAuthenticated() {\n  const context = useAuth();\n  return context.isAuthenticated;\n}\n\n'nextjs-client-auth-architectures/ssr/src/hocs/withAuth.js'\n:import { useIsAuthenticated } from '../providers/Auth';\nimport withConditionalRedirect from './withConditionalRedirect';\n\n/**\n * Require the user to be authenticated in order to render the component.\n * If the user isn't authenticated, forward to the given URL.\n */\nexport default function withAuth(WrappedComponent, location = '/login') {\n  return withConditionalRedirect({\n    WrappedComponent,\n    location,\n    clientCondition: function withAuthClientCondition() {\n      return !useIsAuthenticated();\n    },\n    serverCondition: function withAuthServerCondition(ctx) {\n      return !ctx.req?.cookies.session;\n    }\n  });\n}\n\n'nextjs-client-auth-architectures/ssr/src/pages/logout.js'\n:import { useEffect } from 'react';\nimport { useAuth } from '../providers/Auth';\nimport withAuth from '../hocs/withAuth';\n\nexport default withAuth(function Logout() {\n  const { setAuthenticated } = useAuth();\n  useEffect(() => {\n    async function doLogout() {\n      const response = await fetch('/api/logout');\n      if (response.status === 200) {\n        setAuthenticated(false);\n      } else {\n        console.error('Failed to logout', response);\n      }\n    }\n    doLogout();\n  }, [setAuthenticated]);\n  return <p>Logging out...</p>;\n}, '/');\n\n",
        "called_code_segment_file_1": "function useIsAuthenticated() {\n  const context = useAuth();\n  return context.isAuthenticated;\n}",
        "invoking_code_segment_file_2": "clientCondition: function withAuthClientCondition() {\n  return !useIsAuthenticated();\n}",
        "called_code_segment_file_2": "export default function withAuth(WrappedComponent, location = '/login') {\n  return withConditionalRedirect({\n    WrappedComponent,\n    location,\n    clientCondition: function withAuthClientCondition() {\n      return !useIsAuthenticated();\n    },\n    serverCondition: function withAuthServerCondition(ctx) {\n      return !ctx.req?.cookies.session;\n    }\n  });\n}",
        "using_code_segment_file_3": "export default withAuth(function Logout() {\n  const { setAuthenticated } = useAuth();\n  useEffect(() => {\n    async function doLogout() {\n      const response = await fetch('/api/logout');\n      if (response.status === 200) {\n        setAuthenticated(false);\n      } else {\n        console.error('Failed to logout', response);\n      }\n    }\n    doLogout();\n  }, [setAuthenticated]);\n  return <p>Logging out...</p>;\n}, '/');",
        "feature_description": "Add a feature to handle user roles and redirect based on roles.",
        "detailed_feature_description": "Modify the `useIsAuthenticated` function to also check for user roles. Update `withAuth` to handle role-based redirects. Ensure `Logout` component handles role-based logic if necessary.",
        "modified_complete_code": {
            "#file 1": "import React from 'react';\n\nconst AuthContext = React.createContext({\n  isAuthenticated: false,\n  setAuthenticated: () => {},\n  userRole: null\n});\n\n/**\n * The initial value of `isAuthenticated` comes from the `authenticated`\n * prop which gets set by _app. We store that value in state and ignore\n * the prop from then on. The value can be changed by calling the\n * `setAuthenticated()` method in the context.\n */\nexport const AuthProvider = ({ children, authenticated, userRole }) => {\n  const [isAuthenticated, setAuthenticated] = React.useState(authenticated);\n  const [role, setRole] = React.useState(userRole);\n  return (\n    <AuthContext.Provider\n      value={{\n        isAuthenticated,\n        setAuthenticated,\n        userRole: role,\n        setRole\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport function useAuth() {\n  const context = React.useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n\nexport function useIsAuthenticated() {\n  const context = useAuth();\n  return context.isAuthenticated && context.userRole;\n}",
            "#file 2": "import { useIsAuthenticated } from '../providers/Auth';\nimport withConditionalRedirect from './withConditionalRedirect';\n\n/**\n * Require the user to be authenticated in order to render the component.\n * If the user isn't authenticated, forward to the given URL.\n */\nexport default function withAuth(WrappedComponent, location = '/login', requiredRole = null) {\n  return withConditionalRedirect({\n    WrappedComponent,\n    location,\n    clientCondition: function withAuthClientCondition() {\n      const { isAuthenticated, userRole } = useIsAuthenticated();\n      return !isAuthenticated || (requiredRole && userRole !== requiredRole);\n    },\n    serverCondition: function withAuthServerCondition(ctx) {\n      return !ctx.req?.cookies.session || (requiredRole && ctx.req?.cookies.userRole !== requiredRole);\n    }\n  });\n}",
            "#file 3": "import { useEffect } from 'react';\nimport { useAuth } from '../providers/Auth';\nimport withAuth from '../hocs/withAuth';\n\nexport default withAuth(function Logout() {\n  const { setAuthenticated, setRole } = useAuth();\n  useEffect(() => {\n    async function doLogout() {\n      const response = await fetch('/api/logout');\n      if (response.status === 200) {\n        setAuthenticated(false);\n        setRole(null);\n      } else {\n        console.error('Failed to logout', response);\n      }\n    }\n    doLogout();\n  }, [setAuthenticated, setRole]);\n  return <p>Logging out...</p>;\n}, '/', 'user');"
        }
    },
    {
        "repo": "onedrive-api",
        "content": "'onedrive-api/lib/config.js'\n:module.exports = {\n  apiUrl: \"https://graph.microsoft.com/v1.0/\",\n};\n\n'onedrive-api/lib/index.js'\n:// lib/index.js\n\nconst items = require(\"./items\");\nconst config = require(\"./config\");\n\nglobal.appConfig = config;\n\nmodule.exports = {\n  items: items,\n};\n\n'onedrive-api/test/unit/index.test.js'\n:const chai = require(\"chai\");\nconst expect = chai.expect;\n\ndescribe(\"Loading the module\", () => {\n  it(\"Should load object with items property which is type of object\", () => {\n    const value = require(\"../../lib/index\");\n    expect(value).to.be.a(\"object\");\n    expect(value.items).to.be.a(\"object\");\n  });\n});\n\n",
        "called_code_segment_file_1": "module.exports = { apiUrl: \"https://graph.microsoft.com/v1.0/\", };",
        "invoking_code_segment_file_2": "global.appConfig = config;",
        "called_code_segment_file_2": "global.appConfig = config;",
        "using_code_segment_file_3": "const value = require(\"../../lib/index\");",
        "feature_description": "Add a new configuration option for the API version.",
        "detailed_feature_description": "Modify the config file to include a new option for the API version. Update the index file to use this new configuration option. Ensure the test file remains compatible with the new configuration structure.",
        "modified_complete_code": {
            "lib/config.js": "module.exports = { apiUrl: \"https://graph.microsoft.com/v1.0/\", apiVersion: \"v1.0\" }; #Modify",
            "lib/index.js": "const items = require(\"./items\");\nconst config = require(\"./config\");\nglobal.appConfig = config;\nmodule.exports = {\n  items: items,\n  apiVersion: config.apiVersion #New\n}; #Modify",
            "test/unit/index.test.js": "const chai = require(\"chai\");\nconst expect = chai.expect;\ndescribe(\"Loading the module\", () => {\n  it(\"Should load object with items property which is type of object\", () => {\n    const value = require(\"../../lib/index\");\n    expect(value).to.be.a(\"object\");\n    expect(value.items).to.be.a(\"object\");\n    expect(value.apiVersion).to.equal(\"v1.0\"); #New\n  });\n}); #Modify"
        }
    },
    {
        "repo": "pkglink",
        "content": "'pkglink/src/util/managed-child.js'\n:import R from 'ramda';\n\nexport default function runAsChild(INTERRUPT_TYPE) {\n  const onInterrupt = (fn) => {\n    // set the onInterrupt fn to call\n    const interruptOnce = R.once(fn);\n    process\n      .once('SIGINT', interruptOnce)\n      .once('SIGTERM', interruptOnce)\n      .on('message', (msg) => {\n        if (msg && msg.type === INTERRUPT_TYPE) {\n          interruptOnce();\n        }\n      });\n  };\n\n  const shutdown = R.once(() => {\n    process.disconnect();\n  });\n\n  return {\n    onInterrupt,\n    shutdown\n  };\n}\n\n'pkglink/src/util/managed.js'\n:import runAsManagedChild from './managed-child';\nimport runAsMaster from './managed-master';\n\nconst INTERRUPT_TYPE = 'INTERRUPT_SHUTDOWN';\n\n/*\n  Handles setting up signals and if we are running\n  a child process then it hooks signals up so we can\n  do a graceful shutdown on Control-c including from\n  Windows.\n */\n\nlet launchWorkerMain = () => {}; // defined later\n\nfunction launchWorker(script, opts) {\n  return launchWorkerMain(script, opts);\n}\n\nif (process.disconnect) {\n  // running as a child\n  const childMethods = runAsManagedChild(INTERRUPT_TYPE);\n  launchWorker.onInterrupt = childMethods.onInterrupt;\n  launchWorker.shutdown = childMethods.shutdown;\n} else {\n  // otherwise running as master\n  const masterMethods = runAsMaster(INTERRUPT_TYPE);\n  launchWorkerMain = masterMethods.launchChildWorker;\n  launchWorker.onInterrupt = masterMethods.onInterrupt;\n  launchWorker.shutdown = masterMethods.shutdown;\n}\n\nexport default launchWorker;\n\n'pkglink/src/cli.js'\n:#!/usr/bin/env node\nimport chalk from 'chalk';\nimport fs from 'fs-extra-promise';\nimport numeral from 'numeral';\nimport OS from 'os';\nimport Path from 'path';\nimport R from 'ramda';\nimport { Observable, ReplaySubject, Subject } from 'rxjs';\nimport SingleLineLog from 'single-line-log';\nimport stripAnsi from 'strip-ansi';\nimport { formatBytes, sortObjKeys } from './util/format';\nimport { outputFileStderrSync } from './util/file';\nimport defaultRTEnv from './run-env-defaults';\nimport { prune, scanAndLink } from './index';\nimport managed from './util/managed';\nimport { gatherOptionsConfig } from './cli-options';\n\nconst isTTY = process.stdout.isTTY; // truthy if in terminal\nconst singleLineLog = SingleLineLog.stderr;\n\nconst rtenv = {\n  // create our copy\n  ...defaultRTEnv\n};\n\nconst { argv, config } = gatherOptionsConfig(\n  process.argv.slice(2),\n  displayHelp\n);\n\n// should we be using terminal output\nconst isTermOut = isTTY && !argv['gen-ln-cmds'];\n\nif (argv.help || (!argv._.length && !argv.prune)) {\n  // display help\n  displayHelp();\n  process.exit(23);\n}\n\nfunction displayHelp() {\n  outputFileStderrSync(Path.join(__dirname, '..', 'usage.txt'));\n}\n\nfs.ensureFileSync(config.refsFile);\n\nconst startingDirs = argv._.map((x) => Path.resolve(x));\n\n// key=nameVersion value: array of ref tuples [modPath, packJsonInode, packJsonMTimeEpoch]\nrtenv.existingPackRefs =\n  fs.readJsonSync(config.refsFile, { throws: false }) || {};\n\nrtenv.cancelled$ = new ReplaySubject(1);\n\nconst singleLineLog$ = new Subject();\nsingleLineLog$\n  .filter((x) => isTermOut) // only if in terminal\n  .distinctUntilChanged()\n  .throttleTime(100)\n  .takeUntil(rtenv.cancelled$)\n  .subscribe({\n    next: (x) => singleLineLog(x),\n    complete: () => {\n      singleLineLog('');\n      singleLineLog.clear();\n    }\n  });\nconst log = singleLineLog$.next.bind(singleLineLog$);\nlog.clear = () => {\n  if (isTermOut) {\n    singleLineLog('');\n    singleLineLog.clear();\n  }\n};\nrtenv.log = log; // share this logger in the rtenv\n\nfunction out(str) {\n  const s = isTermOut ? str : stripAnsi(str);\n  process.stdout.write(s);\n  process.stdout.write(OS.EOL);\n}\nrtenv.out = out; // share this output fn in the rtenv\n\nconst cancel = R.once(() => {\n  rtenv.cancelled = true;\n  rtenv.cancelled$.next(true);\n  console.error('cancelling...');\n});\nconst finalTasks = R.once(() => {\n  singleLineLog$.complete();\n  if (argv.dryrun || argv['gen-ln-cmds']) {\n    out(\n      `# ${chalk.blue('pkgs:')} ${numeral(rtenv.packageCount).format(\n        '0,0'\n      )} ${chalk.yellow('would save:')} ${chalk.bold(\n        formatBytes(rtenv.savedByteCount)\n      )}`\n    );\n    managed.shutdown();\n    return;\n  }\n  if (argv.prune || Object.keys(rtenv.updatedPackRefs).length) {\n    const sortedExistingPackRefs = sortObjKeys(\n      R.merge(rtenv.existingPackRefs, rtenv.updatedPackRefs)\n    );\n    fs.outputJsonSync(config.refsFile, sortedExistingPackRefs);\n    // if pruned or if no savings, at least let them know refs updated\n    if (argv.prune || !rtenv.savedByteCount) {\n      out(`updated ${config.refsFile}`);\n    }\n  }\n  out(\n    `${chalk.blue('pkgs:')} ${numeral(rtenv.packageCount).format(\n      '0,0'\n    )} ${chalk.green('saved:')} ${chalk.bold(\n      formatBytes(rtenv.savedByteCount)\n    )}`\n  );\n  managed.shutdown();\n});\n\nmanaged.onInterrupt(cancel); // fires on SIGINT\nprocess.once('SIGTERM', cancel).once('EXIT', finalTasks);\n\nif (argv.verbose) {\n  console.log('argv', argv);\n  console.log('config', config);\n}\n\nout(''); // advance to full line\n\n// Main program start, create task$ and run\nconst arrTaskObs = [];\nif (argv.prune) {\n  arrTaskObs.push(\n    Observable.defer(() => {\n      log(`${chalk.bold('pruning...')}`);\n      return prune(config, rtenv.existingPackRefs);\n    }).do((newShares) => {\n      rtenv.existingPackRefs = newShares;\n    })\n  );\n}\nif (startingDirs.length) {\n  arrTaskObs.push(\n    Observable.defer(() => scanAndLink(config, rtenv, startingDirs))\n  );\n}\n\n// run all the task observables serially\nif (arrTaskObs.length) {\n  Observable.concat(...arrTaskObs).subscribe({\n    error: (err) => console.error(err),\n    complete: () => finalTasks()\n  });\n}\n\n",
        "called_code_segment_file_1": "export default function runAsChild(INTERRUPT_TYPE) {\n  const onInterrupt = (fn) => {\n    // set the onInterrupt fn to call\n    const interruptOnce = R.once(fn);\n    process\n      .once('SIGINT', interruptOnce)\n      .once('SIGTERM', interruptOnce)\n      .on('message', (msg) => {\n        if (msg && msg.type === INTERRUPT_TYPE) {\n          interruptOnce();\n        }\n      });\n  };\n\n  const shutdown = R.once(() => {\n    process.disconnect();\n  });\n\n  return {\n    onInterrupt,\n    shutdown\n  };\n}",
        "invoking_code_segment_file_2": "if (process.disconnect) {\n  // running as a child\n  const childMethods = runAsManagedChild(INTERRUPT_TYPE);\n  launchWorker.onInterrupt = childMethods.onInterrupt;\n  launchWorker.shutdown = childMethods.shutdown;\n} else {\n  // otherwise running as master\n  const masterMethods = runAsMaster(INTERRUPT_TYPE);\n  launchWorkerMain = masterMethods.launchChildWorker;\n  launchWorker.onInterrupt = masterMethods.onInterrupt;\n  launchWorker.shutdown = masterMethods.shutdown;\n}",
        "called_code_segment_file_2": "launchWorker.onInterrupt = childMethods.onInterrupt;\nlaunchWorker.shutdown = childMethods.shutdown;",
        "using_code_segment_file_3": "managed.onInterrupt(cancel); // fires on SIGINT\nprocess.once('SIGTERM', cancel).once('EXIT', finalTasks);",
        "feature_description": "Add a feature to log the interrupt signal type when an interrupt is received.",
        "detailed_feature_description": "Modify the `runAsChild` function in `#file 1` to log the interrupt signal type when an interrupt is received. Update the `launchWorker` object in `#file 2` to handle the modified `onInterrupt` function. Ensure that `#file 3` uses the updated `onInterrupt` function to log the interrupt signal type.",
        "modified_complete_code": {
            "#file 1": "export default function runAsChild(INTERRUPT_TYPE) {\n  const onInterrupt = (fn) => {\n    // set the onInterrupt fn to call\n    const interruptOnce = R.once(fn);\n    process\n      .once('SIGINT', () => {\n        console.log('Received SIGINT');\n        interruptOnce();\n      })\n      .once('SIGTERM', () => {\n        console.log('Received SIGTERM');\n        interruptOnce();\n      })\n      .on('message', (msg) => {\n        if (msg && msg.type === INTERRUPT_TYPE) {\n          console.log('Received INTERRUPT_SHUTDOWN');\n          interruptOnce();\n        }\n      });\n  };\n\n  const shutdown = R.once(() => {\n    process.disconnect();\n  });\n\n  return {\n    onInterrupt,\n    shutdown\n  };\n}",
            "#file 2": "if (process.disconnect) {\n  // running as a child\n  const childMethods = runAsManagedChild(INTERRUPT_TYPE);\n  launchWorker.onInterrupt = childMethods.onInterrupt;\n  launchWorker.shutdown = childMethods.shutdown;\n} else {\n  // otherwise running as master\n  const masterMethods = runAsMaster(INTERRUPT_TYPE);\n  launchWorkerMain = masterMethods.launchChildWorker;\n  launchWorker.onInterrupt = masterMethods.onInterrupt;\n  launchWorker.shutdown = masterMethods.shutdown;\n}",
            "#file 3": "managed.onInterrupt(cancel); // fires on SIGINT\nprocess.once('SIGTERM', cancel).once('EXIT', finalTasks);"
        }
    },
    {
        "repo": "rangetouch",
        "content": "'rangetouch/src/js/utils/css.js'\n:// Element matches a selector\nexport function matches(element, selector) {\n    const prototype = { Element };\n\n    function match() {\n        return Array.from(document.querySelectorAll(selector)).includes(this);\n    }\n\n    const method =\n        prototype.matches ||\n        prototype.webkitMatchesSelector ||\n        prototype.mozMatchesSelector ||\n        prototype.msMatchesSelector ||\n        match;\n\n    return method.call(element, selector);\n}\n\nexport default { matches };\n\n'rangetouch/src/js/rangetouch.js'\n:// ==========================================================================\n// rangetouch.js v2.0.1\n// Making <input type=\"range\"> work on touch devices\n// https://github.com/sampotts/rangetouch\n// License: The MIT License (MIT)\n// ==========================================================================\n\nimport defaults from './config';\nimport { matches } from './utils/css';\nimport { trigger } from './utils/events';\nimport is from './utils/is';\nimport { round } from './utils/numbers';\n\nclass RangeTouch {\n    /**\n     * Setup a new instance\n     * @param {String|Element} target\n     * @param {Object} options\n     */\n    constructor(target, options) {\n        if (is.element(target)) {\n            // An Element is passed, use it directly\n            this.element = target;\n        } else if (is.string(target)) {\n            // A CSS Selector is passed, fetch it from the DOM\n            this.element = document.querySelector(target);\n        }\n\n        if (!is.element(this.element) || !is.empty(this.element.rangeTouch)) {\n            return;\n        }\n\n        this.config = { ...defaults, ...options };\n\n        this.init();\n    }\n\n    static get enabled() {\n        return 'ontouchstart' in document.documentElement;\n    }\n\n    /**\n     * Setup multiple instances\n     * @param {String|Element|NodeList|Array} target\n     * @param {Object} options\n     */\n    static setup(target, options = {}) {\n        let targets = null;\n\n        if (is.empty(target) || is.string(target)) {\n            targets = Array.from(document.querySelectorAll(is.string(target) ? target : 'input[type=\"range\"]'));\n        } else if (is.element(target)) {\n            targets = [target];\n        } else if (is.nodeList(target)) {\n            targets = Array.from(target);\n        } else if (is.array(target)) {\n            targets = target.filter(is.element);\n        }\n\n        if (is.empty(targets)) {\n            return null;\n        }\n\n        const config = { ...defaults, ...options };\n\n        if (is.string(target) && config.watch) {\n            // Create an observer instance\n            const observer = new MutationObserver(mutations => {\n                Array.from(mutations).forEach(mutation => {\n                    Array.from(mutation.addedNodes).forEach(node => {\n                        if (!is.element(node) || !matches(node, target)) {\n                            return;\n                        }\n\n                        // eslint-disable-next-line no-unused-vars\n                        const range = new RangeTouch(node, config);\n                    });\n                });\n            });\n\n            // Pass in the target node, as well as the observer options\n            observer.observe(document.body, {\n                childList: true,\n                subtree: true,\n            });\n        }\n\n        return targets.map(t => new RangeTouch(t, options));\n    }\n\n    init() {\n        // Bail if not a touch enabled device\n        if (!RangeTouch.enabled) {\n            return;\n        }\n\n        // Add useful CSS\n        if (this.config.addCSS) {\n            this.element.style.userSelect = 'none';\n            this.element.style.webKitUserSelect = 'none';\n            this.element.style.touchAction = 'manipulation';\n        }\n\n        this.listeners(true);\n\n        this.element.rangeTouch = this;\n    }\n\n    destroy() {\n        // Bail if not a touch enabled device\n        if (!RangeTouch.enabled) {\n            return;\n        }\n\n        // Remove useful CSS\n        if (this.config.addCSS) {\n            this.element.style.userSelect = '';\n            this.element.style.webKitUserSelect = '';\n            this.element.style.touchAction = '';\n        }\n\n        this.listeners(false);\n\n        this.element.rangeTouch = null;\n    }\n\n    listeners(toggle) {\n        const method = toggle ? 'addEventListener' : 'removeEventListener';\n\n        // Listen for events\n        ['touchstart', 'touchmove', 'touchend'].forEach(type => {\n            this.element[method](type, event => this.set(event), false);\n        });\n    }\n\n    /**\n     * Get the value based on touch position\n     * @param {Event} event\n     */\n    get(event) {\n        if (!RangeTouch.enabled || !is.event(event)) {\n            return null;\n        }\n\n        const input = event.target;\n        const touch = event.changedTouches[0];\n        const min = parseFloat(input.getAttribute('min')) || 0;\n        const max = parseFloat(input.getAttribute('max')) || 100;\n        const step = parseFloat(input.getAttribute('step')) || 1;\n        const delta = max - min;\n\n        // Calculate percentage\n        let percent;\n        const clientRect = input.getBoundingClientRect();\n        const thumbWidth = ((100 / clientRect.width) * (this.config.thumbWidth / 2)) / 100;\n\n        // Determine left percentage\n        percent = (100 / clientRect.width) * (touch.clientX - clientRect.left);\n\n        // Don't allow outside bounds\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 100) {\n            percent = 100;\n        }\n\n        // Factor in the thumb offset\n        if (percent < 50) {\n            percent -= (100 - percent * 2) * thumbWidth;\n        } else if (percent > 50) {\n            percent += (percent - 50) * 2 * thumbWidth;\n        }\n\n        // Find the closest step to the mouse position\n        return min + round(delta * (percent / 100), step);\n    }\n\n    /**\n     * Update range value based on position\n     * @param {Event} event\n     */\n    set(event) {\n        if (!RangeTouch.enabled || !is.event(event) || event.target.disabled) {\n            return;\n        }\n\n        // Prevent text highlight on iOS\n        event.preventDefault();\n\n        // Set value\n        // eslint-disable-next-line no-param-reassign\n        event.target.value = this.get(event);\n\n        // Trigger event\n        trigger(event.target, event.type === 'touchend' ? 'change' : 'input');\n    }\n}\n\nexport default RangeTouch;\n\n'rangetouch/docs/src/js/docs.js'\n:// ==========================================================================\n// Docs example\n// ==========================================================================\n\nimport RangeTouch from '../../../src/js/rangetouch';\n\nconst loadSprite = url => {\n    const xhr = new XMLHttpRequest();\n    const { body } = document;\n\n    // Check for CORS support\n    // If you're loading from same domain, you can remove the whole if/else statement\n    // XHR for Chrome/Firefox/Opera/Safari/IE10+\n    if (!('withCredentials' in xhr)) {\n        return;\n    }\n\n    xhr.open('GET', url, true);\n\n    // Inject hidden div with sprite on load\n    xhr.onload = () => {\n        const container = document.createElement('div');\n        container.setAttribute('hidden', '');\n        container.innerHTML = xhr.responseText;\n        body.insertBefore(container, body.childNodes[0]);\n    };\n\n    xhr.send();\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n    // Load the sprite\n    ['dist/docs.svg'].forEach(loadSprite);\n\n    // Setup shr\n    window.shr.setup({\n        count: {\n            classname: 'btn__count',\n        },\n    });\n\n    // Set range thumb size\n    RangeTouch.setup('.js-example', { thumbWidth: 20 });\n});\n\n",
        "called_code_segment_file_1": "get(event) {\n        if (!RangeTouch.enabled || !is.event(event)) {\n            return null;\n        }\n\n        const input = event.target;\n        const touch = event.changedTouches[0];\n        const min = parseFloat(input.getAttribute('min')) || 0;\n        const max = parseFloat(input.getAttribute('max')) || 100;\n        const step = parseFloat(input.getAttribute('step')) || 1;\n        const delta = max - min;\n\n        // Calculate percentage\n        let percent;\n        const clientRect = input.getBoundingClientRect();\n        const thumbWidth = ((100 / clientRect.width) * (this.config.thumbWidth / 2)) / 100;\n\n        // Determine left percentage\n        percent = (100 / clientRect.width) * (touch.clientX - clientRect.left);\n\n        // Don't allow outside bounds\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 100) {\n            percent = 100;\n        }\n\n        // Factor in the thumb offset\n        if (percent < 50) {\n            percent -= (100 - percent * 2) * thumbWidth;\n        } else if (percent > 50) {\n            percent += (percent - 50) * 2 * thumbWidth;\n        }\n\n        // Find the closest step to the mouse position\n        return min + round(delta * (percent / 100), step);\n    }",
        "invoking_code_segment_file_2": "set(event) {\n        if (!RangeTouch.enabled || !is.event(event) || event.target.disabled) {\n            return;\n        }\n\n        // Prevent text highlight on iOS\n        event.preventDefault();\n\n        // Set value\n        // eslint-disable-next-line no-param-reassign\n        event.target.value = this.get(event);\n\n        // Trigger event\n        trigger(event.target, event.type === 'touchend' ? 'change' : 'input');\n    }",
        "called_code_segment_file_2": "listeners(toggle) {\n        const method = toggle ? 'addEventListener' : 'removeEventListener';\n\n        // Listen for events\n        ['touchstart', 'touchmove', 'touchend'].forEach(type => {\n            this.element[method](type, event => this.set(event), false);\n        });\n    }",
        "using_code_segment_file_3": "document.addEventListener('DOMContentLoaded', () => {\n    // Load the sprite\n    ['dist/docs.svg'].forEach(loadSprite);\n\n    // Setup shr\n    window.shr.setup({\n        count: {\n            classname: 'btn__count',\n        },\n    });\n\n    // Set range thumb size\n    RangeTouch.setup('.js-example', { thumbWidth: 20 });\n});",
        "feature_description": "Add a feature to allow custom step values for each range input individually.",
        "detailed_feature_description": "Modify the `get` method in `#file 1` to accept a custom step value if provided. Update the `set` method in `#file 2` to pass this custom step value if available. Ensure `#file 3` sets up the custom step value when initializing the RangeTouch instance.",
        "modified_complete_code": {
            "#file 1": "get(event, customStep) {\n        if (!RangeTouch.enabled || !is.event(event)) {\n            return null;\n        }\n\n        const input = event.target;\n        const touch = event.changedTouches[0];\n        const min = parseFloat(input.getAttribute('min')) || 0;\n        const max = parseFloat(input.getAttribute('max')) || 100;\n        const step = customStep || parseFloat(input.getAttribute('step')) || 1;\n        const delta = max - min;\n\n        // Calculate percentage\n        let percent;\n        const clientRect = input.getBoundingClientRect();\n        const thumbWidth = ((100 / clientRect.width) * (this.config.thumbWidth / 2)) / 100;\n\n        // Determine left percentage\n        percent = (100 / clientRect.width) * (touch.clientX - clientRect.left);\n\n        // Don't allow outside bounds\n        if (percent < 0) {\n            percent = 0;\n        } else if (percent > 100) {\n            percent = 100;\n        }\n\n        // Factor in the thumb offset\n        if (percent < 50) {\n            percent -= (100 - percent * 2) * thumbWidth;\n        } else if (percent > 50) {\n            percent += (percent - 50) * 2 * thumbWidth;\n        }\n\n        // Find the closest step to the mouse position\n        return min + round(delta * (percent / 100), step);\n    }",
            "#file 2": "set(event) {\n        if (!RangeTouch.enabled || !is.event(event) || event.target.disabled) {\n            return;\n        }\n\n        // Prevent text highlight on iOS\n        event.preventDefault();\n\n        // Set value\n        // eslint-disable-next-line no-param-reassign\n        event.target.value = this.get(event, this.config.customStep);\n\n        // Trigger event\n        trigger(event.target, event.type === 'touchend' ? 'change' : 'input');\n    }",
            "#file 3": "document.addEventListener('DOMContentLoaded', () => {\n    // Load the sprite\n    ['dist/docs.svg'].forEach(loadSprite);\n\n    // Setup shr\n    window.shr.setup({\n        count: {\n            classname: 'btn__count',\n        },\n    });\n\n    // Set range thumb size and custom step value\n    RangeTouch.setup('.js-example', { thumbWidth: 20, customStep: 5 });\n});"
        }
    },
    {
        "repo": "react-html-document",
        "content": "'react-html-document/src/index.js'\n:import HTMLDocument from './HTMLDocument';\nimport getUniversalState from './client';\nexport { getUniversalState, HTMLDocument as default };\n\n'react-html-document/test/utils.js'\n:import React from 'react';\nimport cheerio from 'cheerio';\nimport HTMLDocument from '../src/index';\nimport { renderToStaticMarkup } from 'react-dom/server';\n\n\nexport function renderAndGetQuerySelector(props, children) {\n  const htmlDocumentEl = <HTMLDocument {...props}>{children}</HTMLDocument>;\n  const markup = renderToStaticMarkup(htmlDocumentEl);\n  return cheerio.load(markup);\n}\n\n'react-html-document/test/HTMLDocument.spec.js'\n:import React from 'react';\nimport path from 'path';\nimport fs from 'fs';\nimport { expect } from 'chai';\n\nimport { STATE_SCRIPT_ID } from '../src/constants';\n\nimport { renderAndGetQuerySelector } from './utils';\nimport TestApp from './TestApp';\n\n\ndescribe('HTMLDocument', () => {\n  it('should render with default props', () => {\n    const props = { };\n    const qs = renderAndGetQuerySelector(props);\n    expect(qs('html').length).to.equal(1);\n  });\n\n  it('should render page title', () => {\n    const props = {\n      title: 'My Title'\n    };\n    const qs = renderAndGetQuerySelector(props);\n    expect(qs('title').html()).to.equal(props.title);\n  });\n\n  it('should render html attributes', () => {\n    const props = {\n      htmlAttributes: {\n        lang: 'es'\n      }\n    };\n    const qs = renderAndGetQuerySelector(props);\n    expect(qs('html').attr('lang')).to.equal(props.htmlAttributes.lang);\n  });\n\n  it('should render favicon link', () => {\n    const props = {\n      favicon: 'path/to/favicon.ico'\n    };\n    const qs = renderAndGetQuerySelector(props);\n    const $links = qs('link');\n    expect($links.length).to.equal(1);\n    expect($links.attr('rel')).to.equal('icon');\n    expect($links.attr('href')).to.equal(props.favicon);\n  });\n\n  describe('Metatags', () => {\n    it('should render metatags', () => {\n      const props = {\n        metatags: [\n          { name: 'description', content: 'My Description' },\n          { name: 'title', content: 'My Title' }\n        ]\n      };\n      const qs = renderAndGetQuerySelector(props);\n      const $metatags = qs('meta');\n      expect($metatags.length).to.equal(2);\n      $metatags.each((index, metatag) => {\n        expect(metatag.attribs).to.deep.equal(props.metatags[index]);\n      });\n    });\n  });\n\n  describe('Stylesheets', () => {\n    it('should render linked stylesheets from a list of strings', () => {\n      const props = {\n        stylesheets: ['mysite.com/styles.css']\n      };\n      const qs = renderAndGetQuerySelector(props);\n      const $links = qs('link');\n      expect($links.length).to.equal(1);\n      expect($links.attr('href')).to.equal(props.stylesheets[0]);\n    });\n\n    it('should render linked stylesheet from a list of objects', () => {\n      const props = {\n        stylesheets: [\n          { href: 'mysite.com/styles.css' }\n        ]\n      };\n      const qs = renderAndGetQuerySelector(props);\n      const $links = qs('link');\n      expect($links.length).to.equal(1);\n      expect($links.attr('href')).to.equal(props.stylesheets[0].href);\n    });\n\n    it('should render inline styles', () => {\n      const props = {\n        stylesheets: [\n          { inline: '.body { color: #333 }' }\n        ]\n      };\n      const qs = renderAndGetQuerySelector(props);\n      const $styles = qs('style');\n      expect($styles.length).to.equal(1);\n      expect($styles.html()).to.equal(props.stylesheets[0].inline);\n    });\n\n    it('should render stylesheets from files', () => {\n      const file = path.join(__dirname, 'test-css.css');\n      const props = {\n        stylesheets: [\n          { file }\n        ]\n      };\n      const styleSheetContents = fs.readFileSync(file, 'utf-8');\n      const qs = renderAndGetQuerySelector(props);\n      const $styles = qs('style');\n      expect($styles.length).to.equal(1);\n      expect($styles.html()).to.equal(styleSheetContents);\n    });\n  });\n\n  describe('State', () => {\n    it('should render universalState script', () => {\n      const universalState = {\n        user: {\n          name: 'Professor Charles Xavier'\n        }\n      };\n      const props = {\n        universalState\n      };\n      const qs = renderAndGetQuerySelector(props);\n      const universalStateFromDOM = JSON.parse(qs(`script#${STATE_SCRIPT_ID}`).text());\n      expect(universalStateFromDOM).to.deep.equal(universalState);\n    });\n\n    it('should use internal universalState key as universalState script id', () => {\n      const props = {\n        universalState: { myuniversalState: true }\n      };\n      const qs = renderAndGetQuerySelector(props);\n      expect(qs(`script#${STATE_SCRIPT_ID}`).length).to.equal(1);\n    });\n  });\n\n  describe('Scripts', () => {\n    it('should render script tags from a list of strings', () => {\n      const props = {\n        scripts: [\n          'mysite.com/main.js'\n        ],\n        universalStateKey: '__universalState'\n      };\n      const qs = renderAndGetQuerySelector(props);\n      const $scripts = qs('script').not(`[data-${props.universalStateKey}]`);\n      expect($scripts.length).to.equal(1);\n      expect($scripts.get(0).attribs.src).to.equal(props.scripts[0]);\n    });\n\n    it('should render script tags from a list of objects', () => {\n      const props = {\n        scripts: [\n          { src: 'mysite.com/main.js' }\n        ],\n        universalStateKey: '__universalState'\n      };\n      const qs = renderAndGetQuerySelector(props);\n      const $scripts = qs('script').not(`script[data-${props.universalStateKey}]`);\n      expect($scripts.length).to.equal(1);\n      expect($scripts.get(0).attribs.src).to.equal(props.scripts[0].src);\n    });\n\n    it('should render inline scripts', () => {\n      const props = {\n        scripts: [\n          { inline: 'window.myApp = true;' }\n        ]\n      };\n      const qs = renderAndGetQuerySelector(props);\n      const $scripts = qs('script').not(`script#${STATE_SCRIPT_ID}`);\n      expect($scripts.length).to.equal(1);\n      expect($scripts.html()).to.equal(props.scripts[0].inline);\n    });\n\n    it('should render scripts from files', () => {\n      const file = path.join(__dirname, 'test-script.js');\n      const props = {\n        scripts: [\n          { file }\n        ]\n      };\n      const scriptContents = fs.readFileSync(file, 'utf-8');\n      const qs = renderAndGetQuerySelector(props);\n      const $scripts = qs('script').not(`script#${STATE_SCRIPT_ID}`);\n      expect($scripts.length).to.equal(1);\n      expect($scripts.html()).to.equal(scriptContents);\n    });\n  });\n\n  describe('Children', () => {\n    it('should use right children container id', () => {\n      const childrenContainerId = 'my-app';\n      const props = {\n        childrenContainerId\n      };\n      const children = <TestApp />;\n      const qs = renderAndGetQuerySelector(props, children);\n      expect(qs(`#${childrenContainerId}`).length).to.equal(1);\n    });\n\n    it('should render children with own props', () => {\n      const props = {\n        childrenContainerId: 'app'\n      };\n      const testAppProps = {\n        message: 'Sahp'\n      };\n      const children = <TestApp {...testAppProps} />;\n      const qs = renderAndGetQuerySelector(props, children);\n      expect(qs(`#${props.childrenContainerId}`).text()).to.equal(testAppProps.message);\n    });\n\n    it('should render children statically when given no universalState', () => {\n      const props = { };\n      const children = <TestApp />;\n      const qs = renderAndGetQuerySelector(props, children);\n      const reactSelector = '[data-reactid]';\n      expect(qs(reactSelector).length).to.equal(0);\n    });\n\n    it('should render children with react ids for client mounting when given universalState', () => {\n      const props = {\n        universalState: { myuniversalState: true }\n      };\n      const children = <TestApp />;\n      const qs = renderAndGetQuerySelector(props, children);\n      const reactSelector = '[data-reactid]';\n      expect(qs(reactSelector).length).to.equal(1);\n    });\n  });\n});\n\n",
        "called_code_segment_file_1": "export { getUniversalState, HTMLDocument as default };",
        "invoking_code_segment_file_2": "const qs = renderAndGetQuerySelector(props, children);",
        "called_code_segment_file_2": "const markup = renderToStaticMarkup(htmlDocumentEl);",
        "using_code_segment_file_3": "const htmlDocumentEl = <HTMLDocument {...props}>{children}</HTMLDocument>;",
        "feature_description": "Add a new prop to HTMLDocument to allow customizing the script tag for universal state.",
        "detailed_feature_description": "Modify the HTMLDocument component to accept a new prop 'universalStateScriptProps' which allows customizing the script tag for the universal state. Update the renderAndGetQuerySelector function to pass this new prop to HTMLDocument. Ensure that the TestApp component is updated to handle this new prop if necessary.",
        "modified_complete_code": {
            "#file 1": {
                "modified_code": "export { getUniversalState, HTMLDocument as default }; #Modify"
            },
            "#file 2": {
                "modified_code": "const qs = renderAndGetQuerySelector(props, children); #Modify",
                "new_code": "const markup = renderToStaticMarkup(htmlDocumentEl); #Modify\n\nfunction renderAndGetQuerySelector(props, children) {\n  const htmlDocumentEl = <HTMLDocument {...props} universalStateScriptProps={props.universalStateScriptProps}>{children}</HTMLDocument>;\n  const markup = renderToStaticMarkup(htmlDocumentEl);\n  return cheerio.load(markup);\n} #New"
            },
            "#file 3": {
                "modified_code": "const htmlDocumentEl = <HTMLDocument {...props}>{children}</HTMLDocument>; #Modify",
                "new_code": "const htmlDocumentEl = <HTMLDocument {...props} universalStateScriptProps={props.universalStateScriptProps}>{children}</HTMLDocument>; #New"
            }
        }
    },
    {
        "repo": "react-native-collapsible-tabview",
        "content": "'react-native-collapsible-tabview/src/PullRefreshTabView.js'\n:import React, {useState, useEffect, useRef} from 'react';\nimport {\n  StyleSheet,\n  View,\n  Text,\n  Dimensions,\n  Animated,\n  PanResponder,\n  Platform,\n  TouchableOpacity,\n  Alert,\n  StatusBar,\n  ActivityIndicator,\n} from 'react-native';\nimport {TabView, TabBar} from 'react-native-tab-view';\n\nconst AnimatedIndicator = Animated.createAnimatedComponent(ActivityIndicator);\nconst windowHeight = Dimensions.get('window').height;\nconst windowWidth = Dimensions.get('window').width;\nconst TabBarHeight = 48;\nconst HeaderHeight = 300;\nconst SafeStatusBar = Platform.select({\n  ios: 44,\n  android: StatusBar.currentHeight,\n});\nconst tab1ItemSize = (windowWidth - 30) / 2;\nconst tab2ItemSize = (windowWidth - 40) / 3;\nconst PullToRefreshDist = 150;\n\nconst App = () => {\n  /**\n   * stats\n   */\n  const [tabIndex, setIndex] = useState(0);\n  const [routes] = useState([\n    {key: 'tab1', title: 'Tab1'},\n    {key: 'tab2', title: 'Tab2'},\n  ]);\n  const [canScroll, setCanScroll] = useState(true);\n  const [tab1Data] = useState(Array(40).fill(0));\n  const [tab2Data] = useState(Array(30).fill(0));\n\n  /**\n   * ref\n   */\n  const scrollY = useRef(new Animated.Value(0)).current;\n  const headerScrollY = useRef(new Animated.Value(0)).current;\n  // for capturing header scroll on Android\n  const headerMoveScrollY = useRef(new Animated.Value(0)).current;\n  const listRefArr = useRef([]);\n  const listOffset = useRef({});\n  const isListGliding = useRef(false);\n  const headerScrollStart = useRef(0);\n  const _tabIndex = useRef(0);\n  const refreshStatusRef = useRef(false);\n\n  /**\n   * PanResponder for header\n   */\n  const headerPanResponder = useRef(\n    PanResponder.create({\n      onStartShouldSetPanResponderCapture: (evt, gestureState) => false,\n      onMoveShouldSetPanResponderCapture: (evt, gestureState) => false,\n      onStartShouldSetPanResponder: (evt, gestureState) => {\n        headerScrollY.stopAnimation();\n        syncScrollOffset();\n        return false;\n      },\n\n      onMoveShouldSetPanResponder: (evt, gestureState) => {\n        headerScrollY.stopAnimation();\n        return Math.abs(gestureState.dy) > 5;\n      },\n      onPanResponderEnd: (evt, gestureState) => {\n        handlePanReleaseOrEnd(evt, gestureState);\n      },\n      onPanResponderMove: (evt, gestureState) => {\n        const curListRef = listRefArr.current.find(\n          (ref) => ref.key === routes[_tabIndex.current].key,\n        );\n        const headerScrollOffset = -gestureState.dy + headerScrollStart.current;\n        if (curListRef.value) {\n          // scroll up\n          if (headerScrollOffset > 0) {\n            curListRef.value.scrollToOffset({\n              offset: headerScrollOffset,\n              animated: false,\n            });\n            // start pull down\n          } else {\n            if (Platform.OS === 'ios') {\n              curListRef.value.scrollToOffset({\n                offset: headerScrollOffset / 3,\n                animated: false,\n              });\n            } else if (Platform.OS === 'android') {\n              if (!refreshStatusRef.current) {\n                headerMoveScrollY.setValue(headerScrollOffset / 1.5);\n              }\n            }\n          }\n        }\n      },\n      onShouldBlockNativeResponder: () => true,\n      onPanResponderGrant: (evt, gestureState) => {\n        headerScrollStart.current = scrollY._value;\n      },\n    }),\n  ).current;\n\n  /**\n   * PanResponder for list in tab scene\n   */\n  const listPanResponder = useRef(\n    PanResponder.create({\n      onStartShouldSetPanResponderCapture: (evt, gestureState) => false,\n      onMoveShouldSetPanResponderCapture: (evt, gestureState) => false,\n      onStartShouldSetPanResponder: (evt, gestureState) => false,\n      onMoveShouldSetPanResponder: (evt, gestureState) => {\n        headerScrollY.stopAnimation();\n        return false;\n      },\n      onShouldBlockNativeResponder: () => true,\n      onPanResponderGrant: (evt, gestureState) => {\n        headerScrollY.stopAnimation();\n      },\n    }),\n  ).current;\n\n  /**\n   * effect\n   */\n  useEffect(() => {\n    scrollY.addListener(({value}) => {\n      const curRoute = routes[tabIndex].key;\n      listOffset.current[curRoute] = value;\n    });\n\n    headerScrollY.addListener(({value}) => {\n      listRefArr.current.forEach((item) => {\n        if (item.key !== routes[tabIndex].key) {\n          return;\n        }\n        if (value > HeaderHeight || value < 0) {\n          headerScrollY.stopAnimation();\n          syncScrollOffset();\n        }\n        if (item.value && value <= HeaderHeight) {\n          item.value.scrollToOffset({\n            offset: value,\n            animated: false,\n          });\n        }\n      });\n    });\n    return () => {\n      scrollY.removeAllListeners();\n      headerScrollY.removeAllListeners();\n    };\n  }, [routes, tabIndex]);\n\n  /**\n   *  helper functions\n   */\n  const syncScrollOffset = () => {\n    const curRouteKey = routes[_tabIndex.current].key;\n\n    listRefArr.current.forEach((item) => {\n      if (item.key !== curRouteKey) {\n        if (scrollY._value < HeaderHeight && scrollY._value >= 0) {\n          if (item.value) {\n            item.value.scrollToOffset({\n              offset: scrollY._value,\n              animated: false,\n            });\n            listOffset.current[item.key] = scrollY._value;\n          }\n        } else if (scrollY._value >= HeaderHeight) {\n          if (\n            listOffset.current[item.key] < HeaderHeight ||\n            listOffset.current[item.key] == null\n          ) {\n            if (item.value) {\n              item.value.scrollToOffset({\n                offset: HeaderHeight,\n                animated: false,\n              });\n              listOffset.current[item.key] = HeaderHeight;\n            }\n          }\n        }\n      }\n    });\n  };\n\n  const startRefreshAction = () => {\n    if (Platform.OS === 'ios') {\n      listRefArr.current.forEach((listRef) => {\n        listRef.value.scrollToOffset({\n          offset: -50,\n          animated: true,\n        });\n      });\n      refresh().finally(() => {\n        syncScrollOffset();\n        // do not bounce back if user scroll to another position\n        if (scrollY._value < 0) {\n          listRefArr.current.forEach((listRef) => {\n            listRef.value.scrollToOffset({\n              offset: 0,\n              animated: true,\n            });\n          });\n        }\n      });\n    } else if (Platform.OS === 'android') {\n      Animated.timing(headerMoveScrollY, {\n        toValue: -150,\n        duration: 300,\n        useNativeDriver: true,\n      }).start();\n      refresh().finally(() => {\n        Animated.timing(headerMoveScrollY, {\n          toValue: 0,\n          duration: 300,\n          useNativeDriver: true,\n        }).start();\n      });\n    }\n  };\n\n  const handlePanReleaseOrEnd = (evt, gestureState) => {\n    // console.log('handlePanReleaseOrEnd', scrollY._value);\n    syncScrollOffset();\n    headerScrollY.setValue(scrollY._value);\n    if (Platform.OS === 'ios') {\n      if (scrollY._value < 0) {\n        if (scrollY._value < -PullToRefreshDist && !refreshStatusRef.current) {\n          startRefreshAction();\n        } else {\n          // should bounce back\n          listRefArr.current.forEach((listRef) => {\n            listRef.value.scrollToOffset({\n              offset: 0,\n              animated: true,\n            });\n          });\n        }\n      } else {\n        if (Math.abs(gestureState.vy) < 0.2) {\n          return;\n        }\n        Animated.decay(headerScrollY, {\n          velocity: -gestureState.vy,\n          useNativeDriver: true,\n        }).start(() => {\n          syncScrollOffset();\n        });\n      }\n    } else if (Platform.OS === 'android') {\n      if (\n        headerMoveScrollY._value < 0 &&\n        headerMoveScrollY._value / 1.5 < -PullToRefreshDist\n      ) {\n        startRefreshAction();\n      } else {\n        Animated.timing(headerMoveScrollY, {\n          toValue: 0,\n          duration: 300,\n          useNativeDriver: true,\n        }).start();\n      }\n    }\n  };\n\n  const onMomentumScrollBegin = () => {\n    isListGliding.current = true;\n  };\n\n  const onMomentumScrollEnd = () => {\n    isListGliding.current = false;\n    syncScrollOffset();\n    // console.log('onMomentumScrollEnd'); \n  };\n\n  const onScrollEndDrag = (e) => {\n    syncScrollOffset();\n\n    const offsetY = e.nativeEvent.contentOffset.y;\n    // console.log('onScrollEndDrag', offsetY);\n    // iOS only\n    if (Platform.OS === 'ios') {\n      if (offsetY < -PullToRefreshDist && !refreshStatusRef.current) {\n        startRefreshAction();\n      }\n    }\n\n    // check pull to refresh\n  };\n\n  const refresh = async () => {\n    console.log('-- start refresh');\n    refreshStatusRef.current = true;\n    await new Promise((resolve, reject) => {\n      setTimeout(() => {\n        resolve('done');\n      }, 2000);\n    }).then((value) => {\n      console.log('-- refresh done!');\n      refreshStatusRef.current = false;\n    });\n  };\n\n  /**\n   * render Helper\n   */\n  const renderHeader = () => {\n    const y = scrollY.interpolate({\n      inputRange: [0, HeaderHeight],\n      outputRange: [0, -HeaderHeight],\n      extrapolateRight: 'clamp',\n      // extrapolate: 'clamp',\n    });\n    return (\n      <Animated.View\n        {...headerPanResponder.panHandlers}\n        style={[styles.header, {transform: [{translateY: y}]}]}>\n        <TouchableOpacity\n          style={{flex: 1, justifyContent: 'center'}}\n          activeOpacity={1}\n          onPress={() => Alert.alert('header Clicked!')}>\n          <Text>Pull to Refresh Header</Text>\n        </TouchableOpacity>\n      </Animated.View>\n    );\n  };\n\n  const rednerTab1Item = ({item, index}) => {\n    return (\n      <View\n        style={{\n          borderRadius: 16,\n          marginLeft: index % 2 === 0 ? 0 : 10,\n          width: tab1ItemSize,\n          height: tab1ItemSize,\n          backgroundColor: '#aaa',\n          justifyContent: 'center',\n          alignItems: 'center',\n        }}>\n        <Text>{index}</Text>\n      </View>\n    );\n  };\n\n  const rednerTab2Item = ({item, index}) => {\n    return (\n      <View\n        style={{\n          marginLeft: index % 3 === 0 ? 0 : 10,\n          borderRadius: 16,\n          width: tab2ItemSize,\n          height: tab2ItemSize,\n          backgroundColor: '#aaa',\n          justifyContent: 'center',\n          alignItems: 'center',\n        }}>\n        <Text>{index}</Text>\n      </View>\n    );\n  };\n\n  const renderLabel = ({route, focused}) => {\n    return (\n      <Text style={[styles.label, {opacity: focused ? 1 : 0.5}]}>\n        {route.title}\n      </Text>\n    );\n  };\n\n  const renderScene = ({route}) => {\n    const focused = route.key === routes[tabIndex].key;\n    let numCols;\n    let data;\n    let renderItem;\n    switch (route.key) {\n      case 'tab1':\n        numCols = 2;\n        data = tab1Data;\n        renderItem = rednerTab1Item;\n        break;\n      case 'tab2':\n        numCols = 3;\n        data = tab2Data;\n        renderItem = rednerTab2Item;\n        break;\n      default:\n        return null;\n    }\n    return (\n      <Animated.FlatList\n        scrollToOverflowEnabled={true}\n        // scrollEnabled={canScroll}\n        {...listPanResponder.panHandlers}\n        numColumns={numCols}\n        ref={(ref) => {\n          if (ref) {\n            const found = listRefArr.current.find((e) => e.key === route.key);\n            if (!found) {\n              listRefArr.current.push({\n                key: route.key,\n                value: ref,\n              });\n            }\n          }\n        }}\n        scrollEventThrottle={16}\n        onScroll={\n          focused\n            ? Animated.event(\n                [\n                  {\n                    nativeEvent: {contentOffset: {y: scrollY}},\n                  },\n                ],\n                {useNativeDriver: true},\n              )\n            : null\n        }\n        onMomentumScrollBegin={onMomentumScrollBegin}\n        onScrollEndDrag={onScrollEndDrag}\n        onMomentumScrollEnd={onMomentumScrollEnd}\n        ItemSeparatorComponent={() => <View style={{height: 10}} />}\n        ListHeaderComponent={() => <View style={{height: 10}} />}\n        contentContainerStyle={{\n          paddingTop: HeaderHeight + TabBarHeight,\n          paddingHorizontal: 10,\n          minHeight: windowHeight - SafeStatusBar + HeaderHeight,\n        }}\n        showsHorizontalScrollIndicator={false}\n        data={data}\n        renderItem={renderItem}\n        showsVerticalScrollIndicator={false}\n        keyExtractor={(item, index) => index.toString()}\n      />\n    );\n  };\n\n  const renderTabBar = (props) => {\n    const y = scrollY.interpolate({\n      inputRange: [0, HeaderHeight],\n      outputRange: [HeaderHeight, 0],\n      // extrapolate: 'clamp',\n      extrapolateRight: 'clamp',\n    });\n    return (\n      <Animated.View\n        style={{\n          top: 0,\n          zIndex: 1,\n          position: 'absolute',\n          transform: [{translateY: y}],\n          width: '100%',\n        }}>\n        <TabBar\n          {...props}\n          onTabPress={({route, preventDefault}) => {\n            if (isListGliding.current) {\n              preventDefault();\n            }\n          }}\n          style={styles.tab}\n          renderLabel={renderLabel}\n          indicatorStyle={styles.indicator}\n        />\n      </Animated.View>\n    );\n  };\n\n  const renderTabView = () => {\n    return (\n      <TabView\n        onSwipeStart={() => setCanScroll(false)}\n        onSwipeEnd={() => setCanScroll(true)}\n        onIndexChange={(id) => {\n          _tabIndex.current = id;\n          setIndex(id);\n        }}\n        navigationState={{index: tabIndex, routes}}\n        renderScene={renderScene}\n        renderTabBar={renderTabBar}\n        initialLayout={{\n          height: 0,\n          width: windowWidth,\n        }}\n      />\n    );\n  };\n\n  const renderCustomRefresh = () => {\n    // headerMoveScrollY\n    return Platform.select({\n      ios: (\n        <AnimatedIndicator\n          style={{\n            top: -50,\n            position: 'absolute',\n            alignSelf: 'center',\n            transform: [\n              {\n                translateY: scrollY.interpolate({\n                  inputRange: [-100, 0],\n                  outputRange: [120, 0],\n                  extrapolate: 'clamp',\n                }),\n              },\n            ],\n          }}\n          animating\n        />\n      ),\n      android: (\n        <Animated.View\n          style={{\n            transform: [\n              {\n                translateY: headerMoveScrollY.interpolate({\n                  inputRange: [-300, 0],\n                  outputRange: [150, 0],\n                  extrapolate: 'clamp',\n                }),\n              },\n            ],\n            backgroundColor: '#eee',\n            height: 38,\n            width: 38,\n            borderRadius: 19,\n            borderWidth: 2,\n            borderColor: '#ddd',\n            justifyContent: 'center',\n            alignItems: 'center',\n            alignSelf: 'center',\n            top: -50,\n            position: 'absolute',\n          }}>\n          <ActivityIndicator animating />\n        </Animated.View>\n      ),\n    });\n  };\n\n  return (\n    <View style={styles.container}>\n      {renderTabView()}\n      {renderHeader()}\n      {renderCustomRefresh()}\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  header: {\n    height: HeaderHeight,\n    width: '100%',\n    alignItems: 'center',\n    justifyContent: 'center',\n    position: 'absolute',\n    backgroundColor: '#FFA088',\n  },\n  label: {fontSize: 16, color: '#222'},\n  tab: {\n    elevation: 0,\n    shadowOpacity: 0,\n    backgroundColor: '#FFCC80',\n    height: TabBarHeight,\n  },\n  indicator: {backgroundColor: '#222'},\n});\n\nexport default App;\n\n'react-native-collapsible-tabview/App.js'\n:import React, {useState} from 'react';\nimport {\n  View,\n  SafeAreaView,\n  TouchableOpacity,\n  Text,\n  StyleSheet,\n} from 'react-native';\nimport CollapsibleTabView from './src/CollapsibleTabView';\nimport HeaderScrollableTabView from './src/HeaderScrollableTabView';\nimport PullRefreshTabView from './src/PullRefreshTabView';\n\nconst App = () => {\n  const [mode, setMode] = useState('collapsible');\n\n  const renderDemo = () => {\n    switch (mode) {\n      case 'collapsible':\n        return <CollapsibleTabView />;\n      case 'scrollable':\n        return <HeaderScrollableTabView />;\n      case 'refresh':\n        return <PullRefreshTabView />;\n    }\n  };\n\n  return (\n    <SafeAreaView style={{flex: 1}}>\n      {renderDemo()}\n      <View style={styles.container}>\n        {/*  collapsible */}\n        <TouchableOpacity\n          onPress={() => setMode('collapsible')}\n          style={{...styles.button}}>\n          <Text\n            style={{\n              textAlign: 'center',\n              color: mode === 'collapsible' ? 'red' : 'black',\n            }}>\n            Collapsible\n          </Text>\n        </TouchableOpacity>\n        {/* header scrollable */}\n        <TouchableOpacity\n          onPress={() => setMode('scrollable')}\n          style={{...styles.button}}>\n          <Text\n            style={{\n              textAlign: 'center',\n              color: mode === 'scrollable' ? 'red' : 'black',\n            }}>\n            Header Scrollable\n          </Text>\n        </TouchableOpacity>\n        {/* pull refresh */}\n        <TouchableOpacity\n          onPress={() => setMode('refresh')}\n          style={{...styles.button}}>\n          <Text\n            style={{\n              textAlign: 'center',\n              color: mode === 'refresh' ? 'red' : 'black',\n            }}>\n            pull refresh\n          </Text>\n        </TouchableOpacity>\n      </View>\n    </SafeAreaView>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    alignItems: 'center',\n    justifyContent: 'center',\n    flexDirection: 'row',\n    padding: 16,\n  },\n  button: {\n    flex: 1,\n    height: 48,\n    backgroundColor: '#eee',\n    alignItems: 'center',\n    justifyContent: 'center',\n    borderRadius: 24,\n    paddingHorizontal: 16,\n  },\n});\n\nexport default App;\n\n'react-native-collapsible-tabview/index.js'\n:/**\n * @format\n */\n\nimport {AppRegistry} from 'react-native';\nimport App from './App';\nimport {name as appName} from './app.json';\n\nAppRegistry.registerComponent(appName, () => App);\n\n",
        "called_code_segment_file_1": "const renderHeader = () => {\n    const y = scrollY.interpolate({\n      inputRange: [0, HeaderHeight],\n      outputRange: [0, -HeaderHeight],\n      extrapolateRight: 'clamp',\n    });\n    return (\n      <Animated.View\n        {...headerPanResponder.panHandlers}\n        style={[styles.header, {transform: [{translateY: y}]}]}>\n        <TouchableOpacity\n          style={{flex: 1, justifyContent: 'center'}}\n          activeOpacity={1}\n          onPress={() => Alert.alert('header Clicked!')}>\n          <Text>Pull to Refresh Header</Text>\n        </TouchableOpacity>\n      </Animated.View>\n    );\n  };",
        "invoking_code_segment_file_2": "const renderTabView = () => {\n    return (\n      <TabView\n        onSwipeStart={() => setCanScroll(false)}\n        onSwipeEnd={() => setCanScroll(true)}\n        onIndexChange={(id) => {\n          _tabIndex.current = id;\n          setIndex(id);\n        }}\n        navigationState={{index: tabIndex, routes}}\n        renderScene={renderScene}\n        renderTabBar={renderTabBar}\n        initialLayout={{\n          height: 0,\n          width: windowWidth,\n        }}\n      />\n    );\n  };",
        "called_code_segment_file_2": "const renderScene = ({route}) => {\n    const focused = route.key === routes[tabIndex].key;\n    let numCols;\n    let data;\n    let renderItem;\n    switch (route.key) {\n      case 'tab1':\n        numCols = 2;\n        data = tab1Data;\n        renderItem = rednerTab1Item;\n        break;\n      case 'tab2':\n        numCols = 3;\n        data = tab2Data;\n        renderItem = rednerTab2Item;\n        break;\n      default:\n        return null;\n    }\n    return (\n      <Animated.FlatList\n        scrollToOverflowEnabled={true}\n        {...listPanResponder.panHandlers}\n        numColumns={numCols}\n        ref={(ref) => {\n          if (ref) {\n            const found = listRefArr.current.find((e) => e.key === route.key);\n            if (!found) {\n              listRefArr.current.push({\n                key: route.key,\n                value: ref,\n              });\n            }\n          }\n        }}\n        scrollEventThrottle={16}\n        onScroll={focused ? Animated.event([{nativeEvent: {contentOffset: {y: scrollY}}}], {useNativeDriver: true}) : null}\n        onMomentumScrollBegin={onMomentumScrollBegin}\n        onScrollEndDrag={onScrollEndDrag}\n        onMomentumScrollEnd={onMomentumScrollEnd}\n        ItemSeparatorComponent={() => <View style={{height: 10}} />}\n        ListHeaderComponent={() => <View style={{height: 10}} />}\n        contentContainerStyle={{\n          paddingTop: HeaderHeight + TabBarHeight,\n          paddingHorizontal: 10,\n          minHeight: windowHeight - SafeStatusBar + HeaderHeight,\n        }}\n        showsHorizontalScrollIndicator={false}\n        data={data}\n        renderItem={renderItem}\n        showsVerticalScrollIndicator={false}\n        keyExtractor={(item, index) => index.toString()}\n      />\n    );\n  };",
        "using_code_segment_file_3": "const renderDemo = () => {\n    switch (mode) {\n      case 'collapsible':\n        return <CollapsibleTabView />;\n      case 'scrollable':\n        return <HeaderScrollableTabView />;\n      case 'refresh':\n        return <PullRefreshTabView />;\n    }\n  };",
        "feature_description": "Add a feature to allow the header to display a custom message when pulled down.",
        "detailed_feature_description": "Modify the `renderHeader` function in `#file 1` to include a state variable that changes when the header is pulled down. Update the `onScrollEndDrag` function in `#file 2` to set this state variable. Ensure that `#file 3` remains unaffected by these changes.",
        "modified_complete_code": {
            "#file 1": "const renderHeader = () => {\n    const y = scrollY.interpolate({\n      inputRange: [0, HeaderHeight],\n      outputRange: [0, -HeaderHeight],\n      extrapolateRight: 'clamp',\n    });\n    return (\n      <Animated.View\n        {...headerPanResponder.panHandlers}\n        style={[styles.header, {transform: [{translateY: y}]}]}>\n        <TouchableOpacity\n          style={{flex: 1, justifyContent: 'center'}}\n          activeOpacity={1}\n          onPress={() => Alert.alert('header Clicked!')}>\n          <Text>{refreshMessage ? refreshMessage : 'Pull to Refresh Header'}</Text>\n        </TouchableOpacity>\n      </Animated.View>\n    );\n  };\n\n  #Modify\n  const [refreshMessage, setRefreshMessage] = useState('');\n\n  #New\n  const handlePullDown = () => {\n    setRefreshMessage('Release to refresh');\n  };",
            "#file 2": "const onScrollEndDrag = (e) => {\n    syncScrollOffset();\n\n    const offsetY = e.nativeEvent.contentOffset.y;\n    // iOS only\n    if (Platform.OS === 'ios') {\n      if (offsetY < -PullToRefreshDist && !refreshStatusRef.current) {\n        startRefreshAction();\n      }\n    }\n\n    // check pull to refresh\n    #Modify\n    if (offsetY < -PullToRefreshDist) {\n      handlePullDown();\n    }\n  };",
            "#file 3": "const renderDemo = () => {\n    switch (mode) {\n      case 'collapsible':\n        return <CollapsibleTabView />;\n      case 'scrollable':\n        return <HeaderScrollableTabView />;\n      case 'refresh':\n        return <PullRefreshTabView />;\n    }\n  };"
        }
    },
    {
        "repo": "react-native-gesture-recognizers",
        "content": "'react-native-gesture-recognizers/src/utils/isValidSwipe.js'\n:'use strict';\n\nexport default (velocity, directionalChange, velocityThreshold, changeThreshold) => {\n  return Math.abs(velocity) > velocityThreshold && Math.abs(directionalChange) < changeThreshold;\n};\n\n'react-native-gesture-recognizers/src/recognizers/swipeable.js'\n:'use strict';\n\nimport React, {Component, PropTypes} from 'react';\nimport { View, PanResponder, Animated } from 'react-native';\nimport isValidSwipe from '../utils/isValidSwipe';\n\nconst directions = {\n  SWIPE_UP: 'SWIPE_UP',\n  SWIPE_DOWN: 'SWIPE_DOWN',\n  SWIPE_LEFT: 'SWIPE_LEFT',\n  SWIPE_RIGHT: 'SWIPE_RIGHT'\n};\n\nconst propTypes = {\n  onSwipeBegin: PropTypes.func,\n  onSwipe: PropTypes.func,\n  onSwipeEnd: PropTypes.func,\n  swipeDecoratorStyle: PropTypes.object\n};\n\nconst swipeable = ({\n  horizontal = false,\n  vertical = false,\n  left = false,\n  right = false,\n  up = false,\n  down = false,\n  continuous = true,\n  initialVelocityThreshold = 0.7,\n  verticalThreshold = 10,\n  horizontalThreshold = 10,\n  setGestureState = true\n} = {}) => BaseComponent => {\n\n  const checkHorizontal = horizontal || (left || right);\n  const checkVertical = vertical || (up || down);\n\n  return class extends Component {\n\n    static propTypes = propTypes;\n\n    constructor(props, context) {\n      super(props, context);\n\n      this.state = {\n        swipe: {\n          direction: null,\n          distance: 0,\n          velocity: 0\n        }\n      };\n\n      this.swipeDetected = false;\n      this.velocityProp = null;\n      this.distanceProp = null;\n      this.swipeDirection = null;\n     }\n\n    componentWillMount() {\n      this.panResponder = PanResponder.create({\n\n        onStartShouldSetPanResponder: (evt) => {\n          return evt.nativeEvent.touches.length === 1;\n        },\n\n        onMoveShouldSetPanResponder: (evt) => {\n          return evt.nativeEvent.touches.length === 1;\n        },\n\n        onPanResponderMove: (evt, gestureState) => {\n          const {dx, dy, vx, vy} = gestureState;\n          const { onSwipeBegin, onSwipe } = this.props;\n\n          if (!continuous && this.swipeDetected) {\n            return;\n          }\n\n          let initialDetection = false;\n          let validHorizontal = false;\n          let validVertical = false;\n\n          if (!this.swipeDetected) {\n            initialDetection = true;\n\n            validHorizontal = checkHorizontal && isValidSwipe(\n              vx, dy, initialVelocityThreshold, verticalThreshold\n            );\n            validVertical = checkVertical && isValidSwipe(\n              vy, dx, initialVelocityThreshold, horizontalThreshold\n            );\n\n            if (validHorizontal) {\n              this.velocityProp = 'vx';\n              this.distanceProp = 'dx';\n\n              if ((horizontal || left) && dx < 0) {\n                this.swipeDirection = directions.SWIPE_LEFT;\n              } else if ((horizontal || right) && dx > 0) {\n                this.swipeDirection = directions.SWIPE_RIGHT;\n              }\n            } else if (validVertical) {\n              this.velocityProp = 'vy';\n              this.distanceProp = 'dy';\n\n              if ((vertical || up) && dy < 0) {\n                this.swipeDirection = directions.SWIPE_UP;\n              } else if ((vertical || down) && dy > 0) {\n                this.swipeDirection = directions.SWIPE_DOWN;\n              }\n            }\n\n            if (this.swipeDirection) {\n              this.swipeDetected = true;\n            }\n          }\n\n          if (this.swipeDetected) {\n            const distance = gestureState[this.distanceProp];\n            const velocity = gestureState[this.velocityProp];\n\n            const swipeState = {\n              direction: this.swipeDirection,\n              distance,\n              velocity\n            };\n\n            if (initialDetection) {\n              onSwipeBegin && onSwipeBegin(swipeState); // eslint-disable-line no-unused-expressions\n            } else {\n              onSwipe && onSwipe(swipeState); // eslint-disable-line no-unused-expressions\n            }\n\n            if (setGestureState) {\n              this.setState({\n                swipe: swipeState\n              });\n            }\n          }\n        },\n\n        onPanResponderTerminationRequest: () => true,\n        onPanResponderTerminate: this.handleTerminationAndRelease,\n        onPanResponderRelease: this.handleTerminationAndRelease\n      });\n    }\n\n    handleTerminationAndRelease = () => {\n      if (this.swipeDetected) {\n        const { onSwipeEnd } = this.props;\n        onSwipeEnd && onSwipeEnd({ // eslint-disable-line no-unused-expressions\n          direction: this.swipeDirection\n        });\n      }\n\n      this.swipeDetected = false;\n      this.velocityProp = null;\n      this.distanceProp = null;\n      this.swipeDirection = null;\n    }\n\n    render() {\n      const {\n        onSwipeBegin,\n        onSwipe,\n        onSwipeEnd,\n        swipeDecoratorStyle,\n        ...props\n      } = this.props;\n\n      const style = {\n        ...swipeDecoratorStyle,\n        alignSelf: 'flex-start'\n      };\n\n      const state = setGestureState ? this.state : null;\n\n      return (\n        <View {...this.panResponder.panHandlers} style={style}>\n          <BaseComponent {...props} {...state} />\n        </View>\n      );\n    }\n  };\n};\n\nswipeable.directions = directions;\n\nexport default swipeable;\n\n'react-native-gesture-recognizers/src/index.js'\n:'use strict';\n\nimport pannable from './recognizers/pannable';\nimport swipeable from './recognizers/swipeable';\n\nexport {\n    pannable,\n    swipeable\n}\n\n",
        "called_code_segment_file_1": "export default (velocity, directionalChange, velocityThreshold, changeThreshold) => {\n  return Math.abs(velocity) > velocityThreshold && Math.abs(directionalChange) < changeThreshold;\n};",
        "invoking_code_segment_file_2": "validHorizontal = checkHorizontal && isValidSwipe(\n  vx, dy, initialVelocityThreshold, verticalThreshold\n);\nvalidVertical = checkVertical && isValidSwipe(\n  vy, dx, initialVelocityThreshold, horizontalThreshold\n);",
        "called_code_segment_file_2": "onSwipeBegin && onSwipeBegin(swipeState); // eslint-disable-line no-unused-expressions\nelse {\n  onSwipe && onSwipe(swipeState); // eslint-disable-line no-unused-expressions\n}",
        "using_code_segment_file_3": "No direct interaction found in #file 3 with #file 2 or #file 1.",
        "feature_description": "Add a new feature to allow custom thresholds for swipe detection.",
        "detailed_feature_description": "Modify the isValidSwipe function to accept custom thresholds for velocity and directional change. Update the swipeable recognizer to pass these custom thresholds if provided in props.",
        "modified_complete_code": {
            "#file 1": "'use strict';\n\n#Modify export default (velocity, directionalChange, velocityThreshold, changeThreshold, customVelocityThreshold, customChangeThreshold) => {\n  const finalVelocityThreshold = customVelocityThreshold || velocityThreshold;\n  const finalChangeThreshold = customChangeThreshold || changeThreshold;\n  return Math.abs(velocity) > finalVelocityThreshold && Math.abs(directionalChange) < finalChangeThreshold;\n};",
            "#file 2": "'use strict';\n\nimport React, {Component, PropTypes} from 'react';\nimport { View, PanResponder, Animated } from 'react-native';\nimport isValidSwipe from '../utils/isValidSwipe';\n\nconst directions = {\n  SWIPE_UP: 'SWIPE_UP',\n  SWIPE_DOWN: 'SWIPE_DOWN',\n  SWIPE_LEFT: 'SWIPE_LEFT',\n  SWIPE_RIGHT: 'SWIPE_RIGHT'\n};\n\nconst propTypes = {\n  onSwipeBegin: PropTypes.func,\n  onSwipe: PropTypes.func,\n  onSwipeEnd: PropTypes.func,\n  swipeDecoratorStyle: PropTypes.object,\n  customVelocityThreshold: PropTypes.number,\n  customChangeThreshold: PropTypes.number\n};\n\nconst swipeable = ({...\n\n#Modify validHorizontal = checkHorizontal && isValidSwipe(\n  vx, dy, initialVelocityThreshold, verticalThreshold, props.customVelocityThreshold, props.customChangeThreshold\n);\nvalidVertical = checkVertical && isValidSwipe(\n  vy, dx, initialVelocityThreshold, horizontalThreshold, props.customVelocityThreshold, props.customChangeThreshold\n);",
            "#file 3": "'use strict';\n\nimport pannable from './recognizers/pannable';\nimport swipeable from './recognizers/swipeable';\n\nexport {\n    pannable,\n    swipeable\n}"
        }
    },
    {
        "repo": "replpad",
        "content": "'replpad/lib/utl.js'\n:'use strict';\n\nvar path    =  require('path')\n  , fs      =  require('fs')\n  , util    =  require('util')\n  , logFile =  path.join(__dirname, '../logs/debug.log');\n\nexports.shallowClone = function shallowClone(obj) {\n  var clone = {};\n  Object.keys(obj).forEach(function (k) {\n    clone[k] = obj[k];\n  });\n  return clone;\n};\n\nexports.pad = function pad(s, len, padding) {\n  len = len || 0;\n  padding = padding || ' ';\n\n  return len + 1 >= s.length\n    ? s + new Array(len + 1 - s.length).join(padding)\n    : s;\n};\n\nexports.log = function log(obj, depth) {\n  var s = util.inspect(obj, false, depth || 5, true);\n  fs.appendFileSync(logFile, s);\n};\n\nexports.inspect = function(obj, depth) {\n  return util.inspect(obj, false, depth || 5, true);\n};\n\nexports.existsSync =  fs.existsSync || path.existsSync;\n\n/**\n * Copies srcFile to tgtFile without checking if paths are valid and calls back when done.\n * srcFile is streamed to tgtFile\n *\n * @name copyFile\n * @function\n * @param srcFile {String}\n * @param tgtFile {String}\n * @param cb {Function} called when file is completely copied or an error occurs\n */\nexports.copyFile = function (srcFile, tgtFile, cb) {\n  var readStream = fs.createReadStream(srcFile)\n    , writeStream = fs.createWriteStream(tgtFile);\n\n  writeStream\n    .on('close', cb)\n    .on('error', cb);\n\n  readStream\n    .on('error', cb);\n\n  readStream.pipe(writeStream);\n};\n\n\n/**\n * Copies srcFile to tgtFile without checking if paths are valid and returns when done.\n * srcFile is copied to tgtFile in chunks\n *\n * @name copyFileSync\n * @function\n * @param srcFile {String}\n * @param tgtFile {String}\n * @return {void}\n */\nexports.copyFileSync = function(srcFile, tgtFile) {\n  var buflen    =  64 * 1024\n    , buf       =  new Buffer(buflen)\n    , fdr       =  fs.openSync(srcFile, 'r')\n    , fdw       =  fs.openSync(tgtFile, 'w')\n    , bytesRead =  1\n    , pos       =  0\n    ;\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, buf, 0, buflen, pos);\n    fs.writeSync(fdw, buf, 0, bytesRead);\n    pos += bytesRead;\n  }\n\n  fs.closeSync(fdr);\n  return fs.closeSync(fdw);\n};\n\n'replpad/lib/feedEdits.js'\n:'use strict';\n\nvar path        =  require('path')\n  , fs          =  require('fs')\n  , cardinal    =  require('cardinal')\n  , state       =  require('./state')\n  , utl         =  require('./utl')\n  , log         =  require('./log')\n  , rewrite     =  require('./rewrite')\n  , wire        =  require('./wire')\n  , requireLike =  require('require-like')\n  , talk        =  require('./talk')\n  , config      =  require('../config/current')\n  , findexquire =  require('./findexquire')\n  ;\n\nmodule.exports = function feedEdits(stdin, stdout) {\n  var repl       =  state.repl\n    , rli        =  repl.rli\n    , feed       =  config.feed\n    , exportsKey =  config.feed.exports || '$';\n\n  state.format = feed.format || {\n      indent      :  { style: '  ', base: 0 }\n    , quotes      :  'single'\n    , json        :  false\n    , renumber    :  false\n    , hexadecimal :  false\n    , escapeless  :  false\n    , compact     :  true\n    , parentheses :  false\n    , semicolons  :  false\n  };\n\n  function feedEdit(file) {\n\n    if (state.fileFeedSuspended) return;\n\n    function adaptGlobals() {\n      global.require    =  findexquire(file.fullPath, true);\n      global.__filename =  file.fullPath;\n      global.__dirname  =  path.dirname(file.fullPath);\n      global.exports    =  global.module.exports;\n    }\n\n    function restoreGlobals() {\n      global.require = findexquire(path.join(process.cwd(), 'repl.js'), true);\n    }\n\n    function emitHighlightedCode(src, format) {\n      if (config.highlight) {\n        // force 'compact' since there is no point in sourcing entire code if we printed it highlighted already\n        format.compact = true;\n        try {\n          stdout.write(cardinal.highlight(src, { linenos: true }) + '\\n');\n        } catch(e) { }\n      }\n    }\n\n    function rewriteCode(src, format) {\n      try {\n        return rewrite(src, format);\n      } catch (e) {\n        stdout.write('\\n');\n        log.error('Unable to parse source from: ' + file.path + '\\n' + e);\n        return null;\n      }\n    }\n\n    function emitCode(rewritten) {\n      // ensure emitted lines don't become part of the history\n      var currentHist = rli.history.slice(0);\n\n      wire.emit('emit-code.start');\n\n      try {\n        // source last in order to have results show last\n        stdin.emit('data', rewritten);\n      } catch(e) { }\n\n      wire.emit('emit-code.finish');\n      rli.history = currentHist;\n    }\n\n    function talkCode(code) {\n      talk(code, file);\n    }\n\n    fs.readFile(file.fullPath, 'utf-8', function (err, src) {\n      var format, rewritten;\n\n      if (err) return log.error(err);\n\n      // Avoid code being appended to garbage\n      rli.clearLine();\n\n      format = utl.shallowClone(state.format);\n\n      state.feedingFile = true;\n      emitHighlightedCode(src, format);\n\n      rewritten = rewriteCode(src, format);\n\n      if (!rewritten) return repl.displayPrompt();\n\n      try {\n        adaptGlobals();\n\n        emitCode(rewritten);\n        log.displayPrompt();\n\n        // talking after emitting causes error inside difflet in cases so for now we talk first\n        talkCode(src);\n        log.displayPrompt();\n\n        state.lastFedFile = file;\n        global[exportsKey] = global.module.exports;\n\n      } finally {\n        restoreGlobals();\n        repl.displayPrompt();\n        state.feedingFile = false;\n      }\n    });\n  }\n\n  return feedEdit;\n};\n\n'replpad/repreprep.js'\n:'use strict';\n\nvar repl            =  require('repl')\n  , path            =  require('path')\n  , cardinal        =  require('cardinal')\n  , util            =  require('util')\n  , xtend           =  require('xtend')\n  , state           =  require('./lib/state')\n  , config          =  require('./config/current')\n  , initConfig      =  require('./config/init')\n  , managePlugins   =  require('./lib/manage-plugins')\n  , initWatcher     =  require('./lib/watcher-init')\n  , feedEdits       =  require('./lib/feedEdits')\n  , core            =  require('./lib/dox/core')\n  , log             =  require('./lib/log')\n  , instructions    =  require('./lib/instructions')\n  , initBuiltins    =  require('./lib/builtins/init')\n  , findexquire     =  require('./lib/findexquire')\n  , stdin           =  process.stdin\n  , stdout          =  process.stdout\n  ;\nfunction createRepl(opts) {\n  var r = repl.start(opts);\n  log.repl = r;\n\n  r.state = state;\n  r.config = config;\n\n  global.$repl = r;\n  global.require = findexquire(path.join(process.cwd(), 'repl.js'), true);\n\n  r.writer = function (s) {\n    // i.e. Function.src returns the higlighted string at __replpad_print_raw__ which we just want to print as is\n    var printRaw = s && s.__replpad_print_raw__;\n    return printRaw || util.inspect(s, config.inspect.showHidden, config.inspect.depth, true);\n  };\n\n  return r;\n}\n\nfunction boot(opts) {\n  instructions(opts.output);\n\n  var repl = createRepl(opts);\n  state.__defineGetter__('repl', function () { return repl; });\n\n  managePlugins();\n  initBuiltins();\n\n  core(repl);\n  return repl;\n}\n\nfunction getReplOpts (opts) {\n  return xtend({\n      input           :  stdin\n    , output          :  stdout\n    , ignoreUndefined :  true\n    , useColors       :  true\n    , useGlobal       :  true\n    , terminal        :  true\n  }, opts);\n}\n\n\nmodule.exports = function repreprep(root, opts) {\n\n  if (typeof root === 'object') {\n    opts = root;\n    root = null;\n  }\n  opts = opts || {};\n\n  var replOpts = getReplOpts(opts);\n  log.output = replOpts.output;\n\n  initConfig();\n\n  // override prompt with the one given in opts AFTER config was initialized\n  config.prompt = opts.prompt || config.prompt || 'pad > ';\n  replOpts.prompt = config.prompt;\n\n  if (!root) {\n    log.print('Watching no files since no path was specified.');\n    return boot(replOpts);\n  }\n\n  var watcher = initWatcher(root);\n  watcher.on('initialized', function () {\n    boot(replOpts);\n    var feedEdit = feedEdits(stdin, stdout);\n    watcher.on('file-changed', feedEdit);\n  });\n};\n\n",
        "called_code_segment_file_1": "function feedEdit(file) {\n  // ...\n  function adaptGlobals() {\n    global.require    =  findexquire(file.fullPath, true);\n    global.__filename =  file.fullPath;\n    global.__dirname  =  path.dirname(file.fullPath);\n    global.exports    =  global.module.exports;\n  }\n  // ...\n}",
        "invoking_code_segment_file_2": "var feedEdit = feedEdits(stdin, stdout);\nwatcher.on('file-changed', feedEdit);",
        "called_code_segment_file_2": "function feedEdits(stdin, stdout) {\n  // ...\n  return feedEdit;\n}",
        "using_code_segment_file_3": "var feedEdits = require('./lib/feedEdits');\n// ...\nvar feedEdit = feedEdits(stdin, stdout);\nwatcher.on('file-changed', feedEdit);",
        "feature_description": "Add a feature to log the file being fed into the REPL.",
        "detailed_feature_description": "Modify the `feedEdit` function in `#file 1` to log the file being fed into the REPL. Update `#file 2` to handle this logging and ensure `#file 3` is aware of this change.",
        "modified_complete_code": {
            "#file 1": "function feedEdit(file) {\n  // Modify: Add logging for the file being fed\n  console.log('Feeding file:', file.fullPath);\n  // ...\n  function adaptGlobals() {\n    global.require    =  findexquire(file.fullPath, true);\n    global.__filename =  file.fullPath;\n    global.__dirname  =  path.dirname(file.fullPath);\n    global.exports    =  global.module.exports;\n  }\n  // ...\n}",
            "#file 2": "var feedEdit = feedEdits(stdin, stdout);\nwatcher.on('file-changed', feedEdit);",
            "#file 3": "var feedEdits = require('./lib/feedEdits');\n// ...\nvar feedEdit = feedEdits(stdin, stdout);\nwatcher.on('file-changed', feedEdit);"
        }
    },
    {
        "repo": "ruui",
        "content": "'ruui/examples/legacy/share/NavigationBackButton.js'\n:import React from 'react';\nimport { I18nManager, Image, Platform, StyleSheet, TouchableOpacity } from 'react-native';\n\nconst backIconImage = require('./back-icon.png');\n\ntype Props = {\n\tonPress: Function,\n};\n\nconst NavigationHeaderBackButton = (props: Props) => (\n\t<TouchableOpacity style={styles.buttonContainer} onPress={props.onPress}>\n\t\t<Image style={styles.button} source={backIconImage} />\n\t</TouchableOpacity>\n);\n\nconst styles = StyleSheet.create({\n\tbuttonContainer: {\n\t\tflex: 1,\n\t\tflexDirection: 'row',\n\t\talignItems: 'center',\n\t\tjustifyContent: 'center',\n\t},\n\tbutton: {\n\t\theight: 24,\n\t\twidth: 24,\n\t\tmargin: new Set(['ios', 'web']).has(Platform.OS) ? 10 : 16,\n\t\tresizeMode: 'contain',\n\t\ttransform: [{ scaleX: I18nManager.isRTL ? -1 : 1 }],\n\t}\n});\n\nexport default NavigationHeaderBackButton;\n\n'ruui/examples/legacy/share/NavigationHeader.js'\n:import React, { Component } from 'react';\nimport { StyleSheet, View, Text } from 'react-native';\nimport { connect } from 'react-redux';\n\nimport { colors } from '../utils';\nimport { NavigationHeader, routeAction } from '../../../src';\nimport NavigationBackButton from './NavigationBackButton';\n\n@connect(({ app }) => {\n\treturn {\n\n\t};\n})\n\nexport default class Header extends Component {\n\trender() {\n\t\treturn <NavigationHeader\n\t\t\t{...this.props}\n\t\t\tstyle={styles.navigationContainer}\n\t\t\trenderTitleComponent={this.renderTitleComponent}\n\t\t\trenderLeftComponent={this.renderLeftComponent}/>;\n\t}\n\n\trenderTitleComponent = (props) => {\n\t\treturn <NavigationHeader.Title\n\t\t\t\ttextStyle={styles.navigationTitle}>\n\t\t\t{props.scene.route.key}\n\t\t</NavigationHeader.Title>;\n\t};\n\n\trenderLeftComponent = (props) => {\n\t\treturn props.scene.index === 0 ?\n\t\t\tnull : <NavigationBackButton onPress={this.onNavigateBack}/>;\n\t};\n\n\tonNavigateBack = () => {\n\t\tthis.props.dispatch(routeAction.pop());\n\t}\n}\n\nconst styles = StyleSheet.create({\n\tnavigationContainer: {\n\t\tbackgroundColor: colors.main,\n\t\tborderBottomColor: colors.main,\n\t},\n\tnavigationTitle: {\n\t\tcolor: 'white',\n\t}\n});\n'ruui/examples/legacy/index.js'\n:import React, { Component } from 'react';\nimport { AsyncStorage, View, Text, StyleSheet } from 'react-native';\nimport Drawer from 'react-native-drawer';\n\nimport { connect, ContextProvider, ConnectionMask, NavigationCardStack, Snackbar, Modal, Dropdown, routeAction, appAction } from '../../src';\nimport Menu from './share/Menu';\nimport NavigationHeader from './share/NavigationHeader';\nimport Welcome from './scenes/welcome';\nimport * as appActions from './store/action/app';\n\ntype AppContainerProps = {\n\tstore?: Object,\n};\n\nexport default function AppContainer({ store }: AppContainerProps) {\n\treturn <ContextProvider store={store}>\n\t\t<App/>\n\t</ContextProvider>;\n}\n\ntype Props = {\n\tdispatch?: Function,\n\trouter?: Object,\n};\n\n@connect(({ router, app }) => {\n\treturn {\n\t\trouter,\n\t\tcounter: app.counter,\n\t};\n})\n\nexport class App extends Component {\n\tprops: Props;\n\n\trender() {\n\t\treturn <Drawer\n\t\t\ttype=\"overlay\"\n\t\t\tside=\"right\"\n\t\t\tnegotiatePan tapToClose\n\t\t\tpanOpenMask={0.2}\n\t\t\topenDrawerOffset={0.2}\n\t\t\tcontent={<Menu/>}\n\t\t\ttweenHandler={drawerTween}>\n\n\t\t\t<NavigationCardStack\n\t\t\t\tstyle={styles.navigator}\n\t\t\t\tnavigationState={this.props.router}\n\t\t\t\trenderScene={this.renderScene}\n\t\t\t\trenderHeader={this.renderHeader}\n\t\t\t\tgestureResponseDistance={50}\n\t\t\t\tonNavigateBack={() => this.props.dispatch(routeAction.pop())}/>\n\n\t\t\t<Snackbar/>\n\t\t\t<Modal/>\n\t\t\t<ConnectionMask/>\n\t\t\t<Dropdown/>\n\t\t</Drawer>;\n\t}\n\n\trenderScene = (props) => {\n\t\tconst Scene = props.scene.route.component;\n\t\treturn <Scene/>;\n\t};\n\n\trenderHeader = (sceneProps) => {\n\t\treturn <NavigationHeader {...sceneProps}/>;\n\t};\n}\n\nfunction drawerTween(ratio, side = 'left') {\n\treturn {\n\t\tmain: { opacity: (2 - ratio) / 1.2 },\n\t\tdrawer: {\n\t\t\tshadowColor: '#000000',\n\t\t\tshadowOpacity: 0.1 + (ratio * 0.3),\n\t\t\tshadowRadius: ratio * 60,\n\t\t\televation: ratio * 50,\n\t\t}\n\t};\n}\n\nconst styles = StyleSheet.create({\n\tdrawer: {\n\t\tbackgroundColor: '#000',\n\t},\n\tnavigator: {\n\n\t}\n});\n\n",
        "called_code_segment_file_1": "const NavigationHeaderBackButton = (props: Props) => (\n\t<TouchableOpacity style={styles.buttonContainer} onPress={props.onPress}>\n\t\t<Image style={styles.button} source={backIconImage} />\n\t</TouchableOpacity>\n);",
        "invoking_code_segment_file_2": "renderLeftComponent = (props) => {\n\treturn props.scene.index === 0 ?\n\t\tnull : <NavigationBackButton onPress={this.onNavigateBack}/>;\n};",
        "called_code_segment_file_2": "onNavigateBack = () => {\n\tthis.props.dispatch(routeAction.pop());\n}",
        "using_code_segment_file_3": "renderHeader = (sceneProps) => {\n\treturn <NavigationHeader {...sceneProps}/>;\n};",
        "feature_description": "Add a new feature to display a custom message when the back button is pressed.",
        "detailed_feature_description": "Modify the NavigationHeaderBackButton component in #file 1 to display a custom message when the back button is pressed. Update the onNavigateBack method in #file 2 to handle the new message. Ensure that the renderHeader method in #file 3 is updated to accommodate any changes in the header rendering.",
        "modified_complete_code": {
            "#file 1": "const NavigationHeaderBackButton = (props: Props) => (\n\t<TouchableOpacity style={styles.buttonContainer} onPress={() => {\n\t\tprops.onPress();\n\t\tAlert.alert('Back Button Pressed', 'You are navigating back!');\n\t}}>\n\t\t<Image style={styles.button} source={backIconImage} />\n\t</TouchableOpacity>\n);",
            "#file 2": "renderLeftComponent = (props) => {\n\treturn props.scene.index === 0 ?\n\t\tnull : <NavigationHeaderBackButton onPress={this.onNavigateBack}/>;\n};\n\n#Modify\nonNavigateBack = () => {\n\tthis.props.dispatch(routeAction.pop());\n\tAlert.alert('Back Button Pressed', 'You are navigating back!');\n}",
            "#file 3": "renderHeader = (sceneProps) => {\n\treturn <NavigationHeader {...sceneProps}/>;\n};"
        }
    },
    {
        "repo": "shopify-react-astro",
        "content": "'shopify-react-astro/src/utilityFunctions.js'\n:export function formatPrice(num, currency) {\n  return parseFloat(num).toLocaleString('en-US', {\n    style: 'currency',\n    currency: currency || 'USD',\n  });\n}\n\nexport function formatPriceWithDefault(num, currency) {\n  if (num === null) {\n    return '$0.00';\n  }\n  return parseFloat(num).toLocaleString('en-US', {\n    style: 'currency',\n    currency: currency || 'USD',\n  });\n}\n\nexport function itemTotal(price, quantity) {\n  const totalPrice = parseFloat(price.amount) * parseInt(quantity);\n\n  return formatPrice(totalPrice, price.currencyCode);\n}\n\nexport default { formatPrice, itemTotal };\n\n'shopify-react-astro/src/components/CartTotal.jsx'\n:import React from 'react';\nimport { formatPriceWithDefault } from '../utilityFunctions';\n\nexport default function CartTotal({ cost }) {\n  let subtotal, tax, total;\n\n  subtotal = formatPriceWithDefault(\n    cost?.subtotalAmount?.amount,\n    cost?.subtotalAmount?.currency\n  );\n  tax = formatPriceWithDefault(\n    cost?.totalTaxAmount?.amount,\n    cost?.totalTaxAmount?.currency\n  );\n  total = formatPriceWithDefault(\n    cost?.totalAmount?.amount,\n    cost?.totalAmount?.currency\n  );\n\n  return (\n    <section className=\"cart-total\">\n      <div className=\"cart-total-content\">\n        <div className=\"cart-total-column\">\n          <p>\n            <strong>Subtotal:</strong>\n          </p>\n          <p>Shipping:</p>\n          <p>Tax:</p>\n          <p>Total:</p>\n        </div>\n        <div className=\"cart-total-column\">\n          <p>\n            <strong>{subtotal}</strong>\n          </p>\n          <p>Free Shipping</p>\n          <p>{tax}</p>\n          <p>{total}</p>\n        </div>\n      </div>\n    </section>\n  );\n}\n\n'shopify-react-astro/src/components/Cart.jsx'\n:import React, { useState, useEffect } from 'react';\nimport CartTable from './CartTable';\nimport CartTotal from './CartTotal';\n\nexport default function Cart() {\n  const [showProducts, setShowProducts] = useState(true);\n  const [products, setProducts] = useState([]);\n  const [cost, setCost] = useState({});\n  const [cartId, setCartId] = useState(null);\n\n  useEffect(() => {\n    const localCart = window.localStorage.getItem('astroCartId');\n\n    let data;\n\n    if (localCart === null) {\n      setShowProducts(false);\n    } else {\n      setCartId(localCart);\n      data = fetch(\n        `${import.meta.env.NETLIFY_URL}/.netlify/functions/get-cart`,\n        {\n          method: 'post',\n          body: JSON.stringify({\n            cartId: localCart,\n          }),\n          headers: { 'Content-Type': 'application/json' },\n        }\n      )\n        .then((res) => res.json())\n        .then((response) => {\n          setProducts(response.cart.lines.edges);\n          setCost(response.cart.estimatedCost);\n          return response;\n        });\n    }\n  }, []);\n\n  return (\n    <div>\n      {showProducts && products.length > 0 ? (\n        <div>\n          <CartTable\n            cartItems={products}\n            cartId={cartId}\n            removeItem={setProducts}\n          />\n          <CartTotal cost={cost} />\n        </div>\n      ) : (\n        <div className=\"cart-page-message\">\n          No products to show! Get shopping!\n        </div>\n      )}\n    </div>\n  );\n}\n\n",
        "called_code_segment_file_1": "export function formatPriceWithDefault(num, currency) {\n  if (num === null) {\n    return '$0.00';\n  }\n  return parseFloat(num).toLocaleString('en-US', {\n    style: 'currency',\n    currency: currency || 'USD',\n  });\n}",
        "invoking_code_segment_file_2": "subtotal = formatPriceWithDefault(\n    cost?.subtotalAmount?.amount,\n    cost?.subtotalAmount?.currency\n  );\n  tax = formatPriceWithDefault(\n    cost?.totalTaxAmount?.amount,\n    cost?.totalTaxAmount?.currency\n  );\n  total = formatPriceWithDefault(\n    cost?.totalAmount?.amount,\n    cost?.totalAmount?.currency\n  );",
        "called_code_segment_file_2": "export default function CartTotal({ cost }) {\n  let subtotal, tax, total;\n\n  subtotal = formatPriceWithDefault(\n    cost?.subtotalAmount?.amount,\n    cost?.subtotalAmount?.currency\n  );\n  tax = formatPriceWithDefault(\n    cost?.totalTaxAmount?.amount,\n    cost?.totalTaxAmount?.currency\n  );\n  total = formatPriceWithDefault(\n    cost?.totalAmount?.amount,\n    cost?.totalAmount?.currency\n  );\n\n  return (\n    <section className=\"cart-total\">\n      <div className=\"cart-total-content\">\n        <div className=\"cart-total-column\">\n          <p>\n            <strong>Subtotal:</strong>\n          </p>\n          <p>Shipping:</p>\n          <p>Tax:</p>\n          <p>Total:</p>\n        </div>\n        <div className=\"cart-total-column\">\n          <p>\n            <strong>{subtotal}</strong>\n          </p>\n          <p>Free Shipping</p>\n          <p>{tax}</p>\n          <p>{total}</p>\n        </div>\n      </div>\n    </section>\n  );\n}",
        "using_code_segment_file_3": "export default function Cart() {\n  const [showProducts, setShowProducts] = useState(true);\n  const [products, setProducts] = useState([]);\n  const [cost, setCost] = useState({});\n  const [cartId, setCartId] = useState(null);\n\n  useEffect(() => {\n    const localCart = window.localStorage.getItem('astroCartId');\n\n    let data;\n\n    if (localCart === null) {\n      setShowProducts(false);\n    } else {\n      setCartId(localCart);\n      data = fetch(\n        `${import.meta.env.NETLIFY_URL}/.netlify/functions/get-cart`,\n        {\n          method: 'post',\n          body: JSON.stringify({\n            cartId: localCart,\n          }),\n          headers: { 'Content-Type': 'application/json' },\n        }\n      )\n        .then((res) => res.json())\n        .then((response) => {\n          setProducts(response.cart.lines.edges);\n          setCost(response.cart.estimatedCost);\n          return response;\n        });\n    }\n  }, []);\n\n  return (\n    <div>\n      {showProducts && products.length > 0 ? (\n        <div>\n          <CartTable\n            cartItems={products}\n            cartId={cartId}\n            removeItem={setProducts}\n          />\n          <CartTotal cost={cost} />\n        </div>\n      ) : (\n        <div className=\"cart-page-message\">\n          No products to show! Get shopping!\n        </div>\n      )}\n    </div>\n  );\n}",
        "feature_description": "Add a discount feature that applies a percentage discount to the total cost.",
        "detailed_feature_description": "Modify the `formatPriceWithDefault` function in `#file 1` to accept an optional discount parameter. Update `#file 2` to calculate the discounted total and pass the discount to `formatPriceWithDefault`. Ensure `#file 3` updates the cost state to include the discount.",
        "modified_complete_code": {
            "#file 1": "export function formatPriceWithDefault(num, currency, discount = 0) {\n  if (num === null) {\n    return '$0.00';\n  }\n  const discountedAmount = parseFloat(num) * (1 - discount);\n  return discountedAmount.toLocaleString('en-US', {\n    style: 'currency',\n    currency: currency || 'USD',\n  });\n}",
            "#file 2": "export default function CartTotal({ cost, discount }) {\n  let subtotal, tax, total;\n\n  subtotal = formatPriceWithDefault(\n    cost?.subtotalAmount?.amount,\n    cost?.subtotalAmount?.currency,\n    discount\n  );\n  tax = formatPriceWithDefault(\n    cost?.totalTaxAmount?.amount,\n    cost?.totalTaxAmount?.currency,\n    discount\n  );\n  total = formatPriceWithDefault(\n    cost?.totalAmount?.amount,\n    cost?.totalAmount?.currency,\n    discount\n  );\n\n  return (\n    <section className=\"cart-total\">\n      <div className=\"cart-total-content\">\n        <div className=\"cart-total-column\">\n          <p>\n            <strong>Subtotal:</strong>\n          </p>\n          <p>Shipping:</p>\n          <p>Tax:</p>\n          <p>Total:</p>\n        </div>\n        <div className=\"cart-total-column\">\n          <p>\n            <strong>{subtotal}</strong>\n          </p>\n          <p>Free Shipping</p>\n          <p>{tax}</p>\n          <p>{total}</p>\n        </div>\n      </div>\n    </section>\n  );\n}",
            "#file 3": "export default function Cart() {\n  const [showProducts, setShowProducts] = useState(true);\n  const [products, setProducts] = useState([]);\n  const [cost, setCost] = useState({});\n  const [cartId, setCartId] = useState(null);\n  const [discount, setDiscount] = useState(0.1); // #New: Default 10% discount\n\n  useEffect(() => {\n    const localCart = window.localStorage.getItem('astroCartId');\n\n    let data;\n\n    if (localCart === null) {\n      setShowProducts(false);\n    } else {\n      setCartId(localCart);\n      data = fetch(\n        `${import.meta.env.NETLIFY_URL}/.netlify/functions/get-cart`,\n        {\n          method: 'post',\n          body: JSON.stringify({\n            cartId: localCart,\n          }),\n          headers: { 'Content-Type': 'application/json' },\n        }\n      )\n        .then((res) => res.json())\n        .then((response) => {\n          setProducts(response.cart.lines.edges);\n          setCost(response.cart.estimatedCost);\n          return response;\n        });\n    }\n  }, []);\n\n  return (\n    <div>\n      {showProducts && products.length > 0 ? (\n        <div>\n          <CartTable\n            cartItems={products}\n            cartId={cartId}\n            removeItem={setProducts}\n          />\n          <CartTotal cost={cost} discount={discount} />\n        </div>\n      ) : (\n        <div className=\"cart-page-message\">\n          No products to show! Get shopping!\n        </div>\n      )}\n    </div>\n  );\n}"
        }
    },
    {
        "repo": "stresser",
        "content": "'stresser/config.js'\n:'use strict';\nconst path = require('path');\nconst argv = require('minimist')(process.argv.slice(2));\nconst url = argv._[0];\n\nif (argv.h || argv.help || !url) {\n    console.log(\n        `\n    Usage: stresser <URL> [options]\n\n    Options:\n        -h | --help\n            Outputs this helpful information\n\n        -t | --timeout= <milliseconds> [10000]\n            Sets the time a request waits for response\n\n        -n | --count= <number> [10]\n            Sets the number of seconds\n\n        -c | --concurrent= <number> [100]\n            Sets the number of concurrent requests\n\n        -m | --method <GET|HEAD|POST|PUT|DELETE|*> [GET]\n            Sets the request method\n\n        -b | --body <body as string>\n            Sets body of the request (JSON)\n\n        -f | --force\n            Forces the stress test to stop at the requested time even if requests have not finished\n\n        -v | --verbose <e|b|c>\n            Sets verbosity\n                - e: Errors\n                - c: HTTP Status Codes\n                - b: HTTP body\n\n        --html=<path/to/report/file.html> [${path.join(__dirname, 'report', `report-${Date.now()}.html`)}]\n            Outputs an HTML report file to location\n            Set --html=false if you want to disable it\n\n        --threads=<number> [#cpus]\n            The number of cpus that will be used to stress test\n\n\n    Example: stresser http://example.com/page.html -c 10000 -n 10 -t 20000 --html=/home/reports/report-$(date +%s).html --threads=16 --force\n`\n    );\n\n    process.exit(1);\n}\n\nconst html = argv.html === false || argv.html === 'false' ? null : argv.html || path.join(path.dirname(process.argv[1]), 'report', `report-${Date.now()}.html`);\nconst timeout = argv.t || argv.timeout || 10000;\nconst count = argv.n || argv.count || 10;\nconst concurrent = argv.c || argv.concurrent || 100;\nconst method = argv.m || argv.method || 'get';\nconst body = argv.b || argv.body;\n\nconst _v = argv.v || argv.verbose || '';\nconst verbose = {\n    e: ~_v.indexOf('e'),\n    c: ~_v.indexOf('c'),\n    b: ~_v.indexOf('b')\n};\n\nconst CPUs = argv.threads || require('os').cpus().length;\nconst concurrentPerCPU = Math.max(Math.floor(concurrent / CPUs), 1);\nconst force = argv.f || argv.force;\n\nmodule.exports = {\n    url,\n    method,\n    body,\n    count,\n    concurrent,\n    timeout,\n    html,\n    verbose,\n    concurrentPerCPU,\n    CPUs,\n    force\n};\n\nhtml && console.error('Will output report file to', html);\n'stresser/master.js'\n:'use strict';\nconst cluster = require('cluster');\nconst workers = Object.keys(cluster.workers);\n\nconst range = require('node-range');\nconst pad = require('pad');\n\nconst helpers = require('./helpers');\nconst display = require('./display');\n\nconst config = require('./config');\n\nconst amount = config.count;\n\nlet _statsForSecond = null;\nconst resetStats = () => {\n    _statsForSecond = {\n        code: {\n            '1': 0,\n            '2': 0,\n            '3': 0,\n            '4': 0,\n            '5': 0\n        },\n        err: 0,\n        to: 0,\n        body: 0,\n\n        cnt: 0,\n        time: 0,\n        min: Infinity,\n        max: 0\n    }\n};\nresetStats();\n\nconst SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};\n\nlet _RAW_CNT = 0;\nconst RAW = (data) => {\n    data.forEach((req) => _requests.push(req));\n    _RAW_CNT++;\n    if (_RAW_CNT % workers.length === 0) {\n        _finish();\n    }\n};\n\nlet _STATS_CNT = 0;\nconst STATS = (data, reqCnt) => {\n    _statsForSecond.err += data.err;\n    _statsForSecond.to += data.to;\n    _statsForSecond.body += data.body;\n    _statsForSecond.cnt += data.cnt;\n    _statsForSecond.time += data.time;\n\n    _statsForSecond.min = Math.min(_statsForSecond.min, data.min);\n    _statsForSecond.max = Math.max(_statsForSecond.max, data.max);\n\n    for (let i = 1; i <= 5; i++) {\n        _statsForSecond.code[i.toString()] += data.code[i.toString()];\n    }\n\n    _requestCountActive += reqCnt;\n\n    _STATS_CNT++;\n    if (_STATS_CNT % workers.length === 0) {\n        printStats(_statsForSecond);\n\n        _second++;\n\n        const somethingLeft = (\n            _statsForSecond.cnt === 0 &&\n            _statsForSecond.err === 0 &&\n            _statsForSecond.to === 0 &&\n            _requestCountActive === 0\n        );\n\n        const forceStop = (\n            config.force &&\n            _second > config.count\n        );\n\n        if (\n            somethingLeft || forceStop\n        ) {\n            SEND('raw');\n        } else {\n            _secondHistory.push(Object.assign({}, _statsForSecond, { active: _requestCountActive }));\n            setTimeout(_doWork, 1000);\n        }\n\n        resetStats();\n        _requestCountActive = 0;\n    }\n};\n\n\nworkers\n    .map(wid => cluster.workers[wid])\n    .forEach(worker => {\n        worker.on('message', (msg) => {\n            switch (msg.type) {\n                case 'stats':\n                    STATS(msg.data, msg.req);\n                    break;\n                case 'raw':\n                    RAW(msg.data);\n                    break;\n            }\n        })\n    });\n\nconst _requests = [];\nlet _requestCountActive = 0;\nlet _second = 0;\nconst _secondHistory = [];\n\nconst printStats = (stats, finish) => {\n    let str = (\n        `  S=${pad(6, _second)} |   T=${pad(6, stats.cnt + stats.to + stats.err)} | A=${pad(6, _requestCountActive)}\n  E=${pad(6, stats.err)} | T/O=${pad(6, stats.to)} | \\\nW/B=${pad(6, stats.body)} | AVG=${pad(6, (stats.time / stats.cnt) | 0)} | MIN=${pad(6, stats.min)} | MAX=${pad(6, stats.max)}\n${range(1, 6).map(code => `${code}xx=${pad(6, stats.code[code.toString()])}`).join(' | ')}\n`);\n\n    const howManyReq = config.concurrentPerCPU * config.CPUs * config.count;\n    const howManyDone = stats.cnt + stats.err + stats.to;\n    if (finish && howManyDone < howManyReq) {\n        str += `NOT FINISHED=${pad(6, howManyReq - howManyDone)}\n`;\n    }\n\n    console.error(str);\n    return str;\n};\n\nconst _finish = () => {\n    workers.forEach(worker => cluster.workers[worker].kill());\n\n    const stats = {\n        code: {\n            '1': 0,\n            '2': 0,\n            '3': 0,\n            '4': 0,\n            '5': 0\n        },\n        err: 0,\n        to: 0,\n        body: 0,\n\n        cnt: 0,\n        time: 0,\n        min: Infinity,\n        max: 0\n    };\n    _requests.forEach(req => {\n        stats.to += req.to;\n        stats.err += req.err;\n        stats.body += req.body;\n\n        stats.code[req.code.toString()[0]]++;\n\n        if (req.time) {\n            stats.time += req.time;\n            stats.cnt++;\n\n            if (req.time < stats.min) {\n                stats.min = req.time;\n            }\n            if (req.time > stats.max) {\n                stats.max = req.time;\n            }\n        }\n    });\n\n    console.error('~~~ Aggregated Stats: ~~~');\n\n    const statsStr = printStats(stats, true);\n\n    if (config.html) {\n        display(config.html, _requests, statsStr, _secondHistory, config.url);\n    }\n\n    setTimeout(() => process.exit(0), 100);\n};\n\nconst _doWork = () => {\n    if (_second < amount) {\n        _requestCountActive += config.concurrentPerCPU * workers.length;\n        SEND('req', _second);\n    }\n\n    SEND('stats');\n};\n\n_doWork();\n'stresser/index.js'\n:#!/usr/bin/env node\n'use strict';\nconst cluster = require('cluster');\n\nif (cluster.isMaster) {\n    const config = require('./config');\n\n    console.error('Booting up', config.CPUs, 'workers');\n    let online = 0;\n    for (let i = 0; i < config.CPUs; i++) {\n        const worker = cluster.fork();\n        worker.on('online', () => {\n            online++;\n\n            setTimeout(() => {\n                worker.send({ type: 'setup', data: config });\n\n                if (online === config.CPUs) {\n                    return setTimeout(() => require('./master'), 100);\n                }\n            }, 100);\n        });\n    }\n\n    return;\n}\n\nreturn require('./worker');\n",
        "called_code_segment_file_1": "const config = require('./config');",
        "invoking_code_segment_file_2": "const worker = cluster.fork();\nworker.on('online', () => {\n    online++;\n\n    setTimeout(() => {\n        worker.send({ type: 'setup', data: config });\n\n        if (online === config.CPUs) {\n            return setTimeout(() => require('./master'), 100);\n        }\n    }, 100);\n});",
        "called_code_segment_file_2": "const SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};",
        "using_code_segment_file_3": "workers\n    .map(wid => cluster.workers[wid])\n    .forEach(worker => {\n        worker.on('message', (msg) => {\n            switch (msg.type) {\n                case 'stats':\n                    STATS(msg.data, msg.req);\n                    break;\n                case 'raw':\n                    RAW(msg.data);\n                    break;\n            }\n        })\n    });",
        "feature_description": "Add a new feature to log the start and end times of each request.",
        "detailed_feature_description": "Modify the part in `#file 1` that is being called by `#file 2` to include logging the start and end times of each request. Update `#file 2` to handle the modified code from `#file 1` and ensure any related code segments used by `#file 3` are updated accordingly. If `#file 3` directly interacts with updated segments in `#file 2`, modify the code in `#file 3` to accommodate the changes.",
        "modified_complete_code": {
            "#file 1": "'use strict';\nconst path = require('path');\nconst argv = require('minimist')(process.argv.slice(2));\nconst url = argv._[0];\n\nif (argv.h || argv.help || !url) {\n    console.log(\n        `\n    Usage: stresser <URL> [options]\n\n    Options:\n        -h | --help\n            Outputs this helpful information\n\n        -t | --timeout= <milliseconds> [10000]\n            Sets the time a request waits for response\n\n        -n | --count= <number> [10]\n            Sets the number of seconds\n\n        -c | --concurrent= <number> [100]\n            Sets the number of concurrent requests\n\n        -m | --method <GET|HEAD|POST|PUT|DELETE|*> [GET]\n            Sets the request method\n\n        -b | --body <body as string>\n            Sets body of the request (JSON)\n\n        -f | --force\n            Forces the stress test to stop at the requested time even if requests have not finished\n\n        -v | --verbose <e|b|c>\n            Sets verbosity\n                - e: Errors\n                - c: HTTP Status Codes\n                - b: HTTP body\n\n        --html=<path/to/report/file.html> [${path.join(__dirname, 'report', `report-${Date.now()}.html`)}]\n            Outputs an HTML report file to location\n            Set --html=false if you want to disable it\n\n        --threads=<number> [#cpus]\n            The number of cpus that will be used to stress test\n\n\n    Example: stresser http://example.com/page.html -c 10000 -n 10 -t 20000 --html=/home/reports/report-$(date +%s).html --threads=16 --force\n`\n    );\n\n    process.exit(1);\n}\n\nconst html = argv.html === false || argv.html === 'false' ? null : argv.html || path.join(path.dirname(process.argv[1]), 'report', `report-${Date.now()}.html`);\nconst timeout = argv.t || argv.timeout || 10000;\nconst count = argv.n || argv.count || 10;\nconst concurrent = argv.c || argv.concurrent || 100;\nconst method = argv.m || argv.method || 'get';\nconst body = argv.b || argv.body;\n\nconst _v = argv.v || argv.verbose || '';\nconst verbose = {\n    e: ~_v.indexOf('e'),\n    c: ~_v.indexOf('c'),\n    b: ~_v.indexOf('b')\n};\n\nconst CPUs = argv.threads || require('os').cpus().length;\nconst concurrentPerCPU = Math.max(Math.floor(concurrent / CPUs), 1);\nconst force = argv.f || argv.force;\n\nmodule.exports = {\n    url,\n    method,\n    body,\n    count,\n    concurrent,\n    timeout,\n    html,\n    verbose,\n    concurrentPerCPU,\n    CPUs,\n    force\n};\n\nhtml && console.error('Will output report file to', html);",
            "#file 2": "'use strict';\nconst cluster = require('cluster');\n\nif (cluster.isMaster) {\n    const config = require('./config');\n\n    console.error('Booting up', config.CPUs, 'workers');\n    let online = 0;\n    for (let i = 0; i < config.CPUs; i++) {\n        const worker = cluster.fork();\n        worker.on('online', () => {\n            online++;\n\n            setTimeout(() => {\n                worker.send({ type: 'setup', data: config });\n\n                if (online === config.CPUs) {\n                    return setTimeout(() => require('./master'), 100);\n                }\n            }, 100);\n        });\n    }\n\n    return;\n}\n\nreturn require('./worker');",
            "#file 3": "'use strict';\nconst cluster = require('cluster');\nconst workers = Object.keys(cluster.workers);\n\nconst range = require('node-range');\nconst pad = require('pad');\n\nconst helpers = require('./helpers');\nconst display = require('./display');\n\nconst config = require('./config');\n\nconst amount = config.count;\n\nlet _statsForSecond = null;\nconst resetStats = () => {\n    _statsForSecond = {\n        code: {\n            '1': 0,\n            '2': 0,\n            '3': 0,\n            '4': 0,\n            '5': 0\n        },\n        err: 0,\n        to: 0,\n        body: 0,\n\n        cnt: 0,\n        time: 0,\n        min: Infinity,\n        max: 0\n    }\n};\nresetStats();\n\nconst SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};\n\nlet _RAW_CNT = 0;\nconst RAW = (data) => {\n    data.forEach((req) => _requests.push(req));\n    _RAW_CNT++;\n    if (_RAW_CNT % workers.length === 0) {\n        _finish();\n    }\n};\n\nlet _STATS_CNT = 0;\nconst STATS = (data, reqCnt) => {\n    _statsForSecond.err += data.err;\n    _statsForSecond.to += data.to;\n    _statsForSecond.body += data.body;\n    _statsForSecond.cnt += data.cnt;\n    _statsForSecond.time += data.time;\n\n    _statsForSecond.min = Math.min(_statsForSecond.min, data.min);\n    _statsForSecond.max = Math.max(_statsForSecond.max, data.max);\n\n    for (let i = 1; i <= 5; i++) {\n        _statsForSecond.code[i.toString()] += data.code[i.toString()];\n    }\n\n    _requestCountActive += reqCnt;\n\n    _STATS_CNT++;\n    if (_STATS_CNT % workers.length === 0) {\n        printStats(_statsForSecond);\n\n        _second++;\n\n        const somethingLeft = (\n            _statsForSecond.cnt === 0 &&\n            _statsForSecond.err === 0 &&\n            _statsForSecond.to === 0 &&\n            _requestCountActive === 0\n        );\n\n        const forceStop = (\n            config.force &&\n            _second > config.count\n        );\n\n        if (\n            somethingLeft || forceStop\n        ) {\n            SEND('raw');\n        } else {\n            _secondHistory.push(Object.assign({}, _statsForSecond, { active: _requestCountActive }));\n            setTimeout(_doWork, 1000);\n        }\n\n        resetStats();\n        _requestCountActive = 0;\n    }\n};\n\nworkers\n    .map(wid => cluster.workers[wid])\n    .forEach(worker => {\n        worker.on('message', (msg) => {\n            switch (msg.type) {\n                case 'stats':\n                    STATS(msg.data, msg.req);\n                    break;\n                case 'raw':\n                    RAW(msg.data);\n                    break;\n            }\n        })\n    });\n\nconst _requests = [];\nlet _requestCountActive = 0;\nlet _second = 0;\nconst _secondHistory = [];\n\nconst printStats = (stats, finish) => {\n    let str = (\n        `  S=${pad(6, _second)} |   T=${pad(6, stats.cnt + stats.to + stats.err)} | A=${pad(6, _requestCountActive)}\n  E=${pad(6, stats.err)} | T/O=${pad(6, stats.to)} | \nW/B=${pad(6, stats.body)} | AVG=${pad(6, (stats.time / stats.cnt) | 0)} | MIN=${pad(6, stats.min)} | MAX=${pad(6, stats.max)}\n${range(1, 6).map(code => `${code}xx=${pad(6, stats.code[code.toString()])}`).join(' | ')}\n`);\n\n    const howManyReq = config.concurrentPerCPU * config.CPUs * config.count;\n    const howManyDone = stats.cnt + stats.err + stats.to;\n    if (finish && howManyDone < howManyReq) {\n        str += `NOT FINISHED=${pad(6, howManyReq - howManyDone)}\n`;\n    }\n\n    console.error(str);\n    return str;\n};\n\nconst _finish = () => {\n    workers.forEach(worker => cluster.workers[worker].kill());\n\n    const stats = {\n        code: {\n            '1': 0,\n            '2': 0,\n            '3': 0,\n            '4': 0,\n            '5': 0\n        },\n        err: 0,\n        to: 0,\n        body: 0,\n\n        cnt: 0,\n        time: 0,\n        min: Infinity,\n        max: 0\n    };\n    _requests.forEach(req => {\n        stats.to += req.to;\n        stats.err += req.err;\n        stats.body += req.body;\n\n        stats.code[req.code.toString()[0]]++;\n\n        if (req.time) {\n            stats.time += req.time;\n            stats.cnt++;\n\n            if (req.time < stats.min) {\n                stats.min = req.time;\n            }\n            if (req.time > stats.max) {\n                stats.max = req.time;\n            }\n        }\n    });\n\n    console.error('~~~ Aggregated Stats: ~~~');\n\n    const statsStr = printStats(stats, true);\n\n    if (config.html) {\n        display(config.html, _requests, statsStr, _secondHistory, config.url);\n    }\n\n    setTimeout(() => process.exit(0), 100);\n};\n\nconst _doWork = () => {\n    if (_second < amount) {\n        _requestCountActive += config.concurrentPerCPU * workers.length;\n        SEND('req', _second);\n    }\n\n    SEND('stats');\n};\n\n_doWork();"
        }
    },
    {
        "repo": "three.bas",
        "content": "'three.bas/src/materials/DepthAnimationMaterial.js'\n:import { ShaderLib, RGBADepthPacking } from 'three';\nimport BaseAnimationMaterial from './BaseAnimationMaterial';\n\nclass DepthAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['depth'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['depth'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.depth.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nexport { DepthAnimationMaterial };\n\n'three.bas/src/Utils.js'\n:import { MathUtils, Vector3 } from 'three';\nimport { DepthAnimationMaterial } from './materials/DepthAnimationMaterial';\nimport { DistanceAnimationMaterial } from './materials/DistanceAnimationMaterial';\n\n/**\n * Collection of utility functions.\n * @namespace\n */\nconst Utils = {\n  /**\n   * Duplicates vertices so each face becomes separate.\n   * Same as THREE.ExplodeModifier.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance to modify.\n   */\n  separateFaces: function (geometry) {\n    let vertices = [];\n\n    for (let i = 0, il = geometry.faces.length; i < il; i++) {\n      let n = vertices.length;\n      let face = geometry.faces[i];\n\n      let a = face.a;\n      let b = face.b;\n      let c = face.c;\n\n      let va = geometry.vertices[a];\n      let vb = geometry.vertices[b];\n      let vc = geometry.vertices[c];\n\n      vertices.push(va.clone());\n      vertices.push(vb.clone());\n      vertices.push(vc.clone());\n\n      face.a = n;\n      face.b = n + 1;\n      face.c = n + 2;\n    }\n\n    geometry.vertices = vertices;\n  },\n\n  /**\n   * Compute the centroid (center) of a THREE.Face3.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance the face is in.\n   * @param {THREE.Face3} face Face object from the THREE.Geometry.faces array\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  computeCentroid: function(geometry, face, v) {\n    let a = geometry.vertices[face.a];\n    let b = geometry.vertices[face.b];\n    let c = geometry.vertices[face.c];\n\n    v = v || new Vector3();\n\n    v.x = (a.x + b.x + c.x) / 3;\n    v.y = (a.y + b.y + c.y) / 3;\n    v.z = (a.z + b.z + c.z) / 3;\n\n    return v;\n  },\n\n  /**\n   * Get a random vector between box.min and box.max.\n   *\n   * @param {THREE.Box3} box THREE.Box3 instance.\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomInBox: function(box, v) {\n    v = v || new Vector3();\n\n    v.x = MathUtils.randFloat(box.min.x, box.max.x);\n    v.y = MathUtils.randFloat(box.min.y, box.max.y);\n    v.z = MathUtils.randFloat(box.min.z, box.max.z);\n\n    return v;\n  },\n\n  /**\n   * Get a random axis for quaternion rotation.\n   *\n   * @param {THREE.Vector3=} v Option vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomAxis: function(v) {\n    v = v || new Vector3();\n\n    v.x = MathUtils.randFloatSpread(2.0);\n    v.y = MathUtils.randFloatSpread(2.0);\n    v.z = MathUtils.randFloatSpread(2.0);\n    v.normalize();\n\n    return v;\n  },\n\n  /**\n   * Create a THREE.BAS.DepthAnimationMaterial for shadows from a THREE.SpotLight or THREE.DirectionalLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the depth material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DepthAnimationMaterial}\n   */\n  createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  },\n\n  /**\n   * Create a THREE.BAS.DistanceAnimationMaterial for shadows from a THREE.PointLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the distance material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DistanceAnimationMaterial}\n   */\n  createDistanceAnimationMaterial: function(sourceMaterial) {\n    return new DistanceAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }\n};\n\nexport { Utils };\n\n'three.bas/src/geometry/ModelBufferGeometry.js'\n:import { BufferGeometry, BufferAttribute } from 'three';\nimport { Utils } from '../Utils';\n\nclass ModelBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry for animating individual faces of a THREE.Geometry.\n   *\n   * @param {THREE.Geometry} model The THREE.Geometry to base this geometry on.\n   * @param {Object=} options\n   * @param {Boolean=} options.computeCentroids If true, a centroids will be computed for each face and stored in THREE.BAS.ModelBufferGeometry.centroids.\n   * @param {Boolean=} options.localizeFaces If true, the positions for each face will be stored relative to the centroid. This is useful if you want to rotate or scale faces around their center.\n   */\n  constructor (model, options) {\n    super();\n\n    /**\n     * A reference to the geometry used to create this instance.\n     * @type {THREE.Geometry}\n     */\n    this.modelGeometry = model;\n\n    /**\n     * Number of faces of the model.\n     * @type {Number}\n     */\n    this.faceCount = this.modelGeometry.faces.length;\n\n    /**\n     * Number of vertices of the model.\n     * @type {Number}\n     */\n    this.vertexCount = this.modelGeometry.vertices.length;\n\n    options = options || {};\n    options.computeCentroids && this.computeCentroids();\n\n    this.bufferIndices();\n    this.bufferPositions(options.localizeFaces);\n  }\n\n  /**\n   * Computes a centroid for each face and stores it in THREE.BAS.ModelBufferGeometry.centroids.\n   */\n  computeCentroids () {\n    /**\n     * An array of centroids corresponding to the faces of the model.\n     *\n     * @type {Array}\n     */\n    this.centroids = [];\n\n    for (let i = 0; i < this.faceCount; i++) {\n      this.centroids[i] = Utils.computeCentroid(this.modelGeometry, this.modelGeometry.faces[i]);\n    }\n  }\n\n  bufferIndices () {\n    const indexBuffer = new Uint32Array(this.faceCount * 3);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0, offset = 0; i < this.faceCount; i++, offset += 3) {\n      const face = this.modelGeometry.faces[i];\n\n      indexBuffer[offset    ] = face.a;\n      indexBuffer[offset + 1] = face.b;\n      indexBuffer[offset + 2] = face.c;\n    }\n  }\n\n  bufferPositions (localizeFaces) {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    let i, offset;\n\n    if (localizeFaces === true) {\n      for (i = 0; i < this.faceCount; i++) {\n        const face = this.modelGeometry.faces[i];\n        const centroid = this.centroids ? this.centroids[i] : Utils.computeCentroid(this.modelGeometry, face);\n\n        const a = this.modelGeometry.vertices[face.a];\n        const b = this.modelGeometry.vertices[face.b];\n        const c = this.modelGeometry.vertices[face.c];\n\n        positionBuffer[face.a * 3]     = a.x - centroid.x;\n        positionBuffer[face.a * 3 + 1] = a.y - centroid.y;\n        positionBuffer[face.a * 3 + 2] = a.z - centroid.z;\n\n        positionBuffer[face.b * 3]     = b.x - centroid.x;\n        positionBuffer[face.b * 3 + 1] = b.y - centroid.y;\n        positionBuffer[face.b * 3 + 2] = b.z - centroid.z;\n\n        positionBuffer[face.c * 3]     = c.x - centroid.x;\n        positionBuffer[face.c * 3 + 1] = c.y - centroid.y;\n        positionBuffer[face.c * 3 + 2] = c.z - centroid.z;\n      }\n    }\n    else {\n      for (i = 0, offset = 0; i < this.vertexCount; i++, offset += 3) {\n        const vertex = this.modelGeometry.vertices[i];\n\n        positionBuffer[offset    ] = vertex.x;\n        positionBuffer[offset + 1] = vertex.y;\n        positionBuffer[offset + 2] = vertex.z;\n      }\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    for (let i = 0; i < this.faceCount; i++) {\n\n      const face = this.modelGeometry.faces[i];\n      let uv;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][0];\n      uvBuffer[face.a * 2]     = uv.x;\n      uvBuffer[face.a * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][1];\n      uvBuffer[face.b * 2]     = uv.x;\n      uvBuffer[face.b * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][2];\n      uvBuffer[face.c * 2]     = uv.x;\n      uvBuffer[face.c * 2 + 1] = uv.y;\n    }\n  }\n\n  /**\n   * Creates two THREE.BufferAttributes: skinIndex and skinWeight. Both are required for skinning.\n   */\n  bufferSkinning () {\n    const skinIndexBuffer = this.createAttribute('skinIndex', 4).array;\n    const skinWeightBuffer = this.createAttribute('skinWeight', 4).array;\n\n    for (let i = 0; i < this.vertexCount; i++) {\n      const skinIndex = this.modelGeometry.skinIndices[i];\n      const skinWeight = this.modelGeometry.skinWeights[i];\n\n      skinIndexBuffer[i * 4    ] = skinIndex.x;\n      skinIndexBuffer[i * 4 + 1] = skinIndex.y;\n      skinIndexBuffer[i * 4 + 2] = skinIndex.z;\n      skinIndexBuffer[i * 4 + 3] = skinIndex.w;\n\n      skinWeightBuffer[i * 4    ] = skinWeight.x;\n      skinWeightBuffer[i * 4 + 1] = skinWeight.y;\n      skinWeightBuffer[i * 4 + 2] = skinWeight.z;\n      skinWeightBuffer[i * 4 + 3] = skinWeight.w;\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {int} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each face upon creation. Accepts 3 arguments: data[], index and faceCount. Calls setFaceData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.vertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.faceCount; i++) {\n        factory(data, i, this.faceCount);\n        this.setFaceData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a face at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|THREE.BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {int} faceIndex Index of the face in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setFaceData (attribute, faceIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = faceIndex * 3 * attribute.itemSize;\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nexport { ModelBufferGeometry };\n\n",
        "called_code_segment_file_1": "concatVertexShader () {\n    return ShaderLib.depth.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }",
        "invoking_code_segment_file_2": "constructor (parameters) {\n    super(parameters, ShaderLib['depth'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['depth'].fragmentShader;\n  }",
        "called_code_segment_file_2": "createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }",
        "using_code_segment_file_3": "const depthMaterial = Utils.createDepthAnimationMaterial(sourceMaterial);",
        "feature_description": "Add a new method to DepthAnimationMaterial to allow custom vertex shader modifications.",
        "detailed_feature_description": "The new feature allows users to pass a custom vertex shader function to DepthAnimationMaterial. This function will be invoked during the vertex shader concatenation process. The modification involves updating the constructor of DepthAnimationMaterial to accept an optional custom vertex shader function and then using this function within the concatVertexShader method.",
        "modified_complete_code": {
            "file_1": "class DepthAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters, customVertexShader) {\n    super(parameters, ShaderLib['depth'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader(customVertexShader);\n    this.fragmentShader = ShaderLib['depth'].fragmentShader;\n  }\n\n  concatVertexShader (customVertexShader) {\n    let vertexShader = ShaderLib.depth.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      );\n\n    if (customVertexShader) {\n      vertexShader = customVertexShader(vertexShader);\n    }\n\n    return vertexShader;\n  }\n}",
            "file_2": "import { DepthAnimationMaterial } from './materials/DepthAnimationMaterial';\n\nconst Utils = {\n  createDepthAnimationMaterial: function(sourceMaterial, customVertexShader) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    }, customVertexShader);\n  }\n};",
            "file_3": "const customVertexShader = (shader) => {\n  return shader.replace(\n    '#include <begin_vertex>',\n    `\n    #include <begin_vertex>\n\n    // Custom vertex shader modifications\n    `\n  );\n};\n\nconst depthMaterial = Utils.createDepthAnimationMaterial(sourceMaterial, customVertexShader);"
        }
    },
    {
        "repo": "tile-reduce",
        "content": "'tile-reduce/src/vt.js'\n:'use strict';\n\nvar VectorTile = require('@mapbox/vector-tile').VectorTile;\nvar Pbf = require('pbf');\n\nmodule.exports = parseData;\n\nfunction parseData(data, tile, source) {\n  var layers = new VectorTile(new Pbf(data)).layers;\n  return source.raw ? layers : toGeoJSON(layers, tile, source);\n}\n\nfunction toGeoJSON(layers, tile, source) {\n  var collections = {};\n\n  for (var layerId in layers) {\n    if (source.layers && source.layers.indexOf(layerId) === -1) continue;\n\n    collections[layerId] = {\n      type: 'FeatureCollection',\n      features: []\n    };\n    for (var k = 0; k < layers[layerId].length; k++) {\n      collections[layerId].features.push(\n        layers[layerId].feature(k).toGeoJSON(tile[0], tile[1], tile[2])\n      );\n    }\n  }\n  return collections;\n}\n\n'tile-reduce/src/remote.js'\n:'use strict';\n\nvar request = require('request');\nvar parseVT = require('./vt');\nvar rateLimit = require('function-rate-limit');\n\nmodule.exports = remoteVT;\n\nfunction remoteVT(source, ready) {\n  var getTile = function(tile, done) {\n    var url = source.url\n      .replace('{x}', tile[0])\n      .replace('{y}', tile[1])\n      .replace('{z}', tile[2]);\n\n    request({url: url, gzip: true, encoding: null}, function(err, res, body) {\n      if (err) return done(err);\n      else if (res.statusCode === 200) return done(null, parseVT(body, tile, source));\n      else if (res.statusCode === 401) return done();\n      else return done(new Error('Server responded with status code ' + res.statusCode));\n    });\n  };\n\n  if (source.maxrate) getTile = rateLimit(source.maxrate, 1000, getTile);\n  ready(null, getTile);\n}\n\n'tile-reduce/test/test.remote.js'\n:'use strict';\n\nvar test = require('tap').test;\nvar remote = require('../src/remote');\nvar queue = require('queue-async');\n\ntest('remote - raw parse', function(t) {\n  var osmUrl = 'https://b.tiles.mapbox.com/v4/morganherlocker.3vsvfjjw/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1IjoibW9yZ2FuaGVybG9ja2VyIiwiYSI6Ii1zLU4xOWMifQ.FubD68OEerk74AYCLduMZQ';\n  var source = {\n    name: 'osm',\n    url: osmUrl,\n    raw: true\n  };\n  remote(source, function(err, getTile) {\n    t.notOk(err, 'remote initialized without error');\n    getTile([5276, 12757, 15], function(err, layers) {\n      t.notOk(err, 'remote VT unpacked without error');\n      t.ok(layers, 'layers parsed from remote source');\n      t.equal(layers.buildings.length, 264, 'layers have correct number of buildings');\n      t.equal(layers.roads.length, 384, 'layers have correct number of roads');\n      t.end();\n    });\n  });\n});\n\ntest('remote - full GeoJSON parse', function(t) {\n  var osmUrl = 'https://b.tiles.mapbox.com/v4/morganherlocker.3vsvfjjw/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1IjoibW9yZ2FuaGVybG9ja2VyIiwiYSI6Ii1zLU4xOWMifQ.FubD68OEerk74AYCLduMZQ';\n  var source = {\n    name: 'osm',\n    url: osmUrl\n  };\n  remote(source, function(err, getTile) {\n    t.notOk(err, 'remote initialized without error');\n    getTile([5276, 12757, 15], function(err, layers) {\n      t.notOk(err, 'remote unpacked without error');\n      t.ok(layers, 'layers parsed from remote');\n      t.equal(layers.buildings.features.length, 264, 'layers have correct number of buildings');\n      t.equal(layers.buildings.type, 'FeatureCollection', 'buildings decoded as GeoJSON FeatureCollection');\n      t.equal(layers.buildings.features[0].geometry.type, 'Polygon', 'building decoded as GeoJSON Polygon');\n      t.equal(layers.roads.features.length, 384, 'layers have correct number of roads');\n      t.equal(layers.roads.type, 'FeatureCollection', 'roads decoded as GeoJSON FeatureCollection');\n      t.equal(layers.roads.features[0].geometry.type, 'LineString', 'road decoded as GeoJSON LineString');\n      t.end();\n    });\n  });\n});\n\ntest('remote - sparse GeoJSON parse', function(t) {\n  var osmUrl = 'https://b.tiles.mapbox.com/v4/morganherlocker.3vsvfjjw/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1IjoibW9yZ2FuaGVybG9ja2VyIiwiYSI6Ii1zLU4xOWMifQ.FubD68OEerk74AYCLduMZQ';\n  var source = {\n    name: 'osm',\n    url: osmUrl,\n    layers: ['buildings']\n  };\n  remote(source, function(err, getTile) {\n    t.notOk(err, 'remote initialized without error');\n    getTile([5276, 12757, 15], function(err, layers) {\n      t.notOk(err, 'remote unpacked without error');\n      t.ok(layers, 'layers parsed from remote');\n      t.equal(layers.buildings.features.length, 264, 'layers have correct number of buildings');\n      t.notOk(layers.roads);\n      t.end();\n    });\n  });\n});\n\ntest('remote - init', function(t) {\n  var osmUrl = 'https://b.tiles.mapbox.com/v4/morganherlocker.3vsvfjjw/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1IjoibW9yZ2FuaGVybG9ja2VyIiwiYSI6Ii1zLU4xOWMifQ.FubD68OEerk74AYCLduMZQ';\n  var source = {name: 'osm', url: osmUrl};\n\n  remote(source, function(err, getTile) {\n    t.notOk(err, 'remote getTile init without error');\n    t.ok(typeof getTile === 'function', 'remote getTile is a function');\n    t.end();\n  });\n});\n\ntest('remote - raw invalid url - 401', function(t) {\n  var badUrl = 'https://b.tiles.mapbox.com/v4/morganherlocker.3vsvfjjw/{z}/{x}.awesome.pbf';\n  var source = {name: 'osm', url: badUrl};\n  remote(source, function(err, getTile) {\n    t.notOk(err, 'remote initialized without error');\n    getTile([5276, 12757, 15], function(err, layers) {\n      t.notOk(err, 'does not return an error with a missing tile remote url');\n      t.notOk(layers, 'does not return layers with a missing tile remote url');\n      t.end();\n    });\n  });\n});\n\ntest('remote - raw invalid url - no server', function(t) {\n  var badUrl = 'https://tiles.mapox.com/v4/morganherlocker.3vsvfjjw/{z}/{x}.vector.pbf';\n  var source = {name: 'osm', url: badUrl};\n  remote(source, function(err, getTile) {\n    t.notOk(err, 'remote initialized without error');\n    getTile([5276, 12757, 15], function(err, layers) {\n      t.ok(err, 'returns an error with a bad remote url');\n      t.ok(err.message.indexOf('getaddrinfo ENOTFOUND') === 0, 'HTTP address not found');\n      t.notOk(layers, 'does not return layers with a bad remote url');\n      t.end();\n    });\n  });\n});\n\ntest('remote - throttle', function(t) {\n  var url = 'https://b.tiles.mapbox.com/v4/morganherlocker.4c81vjdd/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1IjoibW9yZ2FuaGVybG9ja2VyIiwiYSI6Ii1zLU4xOWMifQ.FubD68OEerk74AYCLduMZQ';\n  var maxrate = 5;\n  var tile = [5276, 12757, 15];\n  var source = {name: 'osm', url: url, maxrate: maxrate};\n  var intervals = {};\n  var q = queue(100);\n\n  remote(source, function(err, getTile) {\n    t.notOk(err, 'remote initialized without error');\n\n    for (var i = 0; i < 100; i++) {\n      q.defer(request);\n    }\n\n    q.awaitAll(function() {\n      Object.keys(intervals).forEach(function(interval) {\n        if (intervals[interval] > maxrate * 3)\n          t.fail(intervals[interval] + ' ops/sec detected; should be ' + maxrate + ' ops/sec');\n        else t.pass(intervals[interval] + ' ops/sec detected');\n      });\n      t.end();\n    });\n\n    function request(cb) {\n      getTile(tile, function(err) {\n        if (err) t.error(err);\n\n        var now = new Date();\n        var time = now.getMinutes() + ':' + now.getSeconds();\n        if (!intervals[time]) intervals[time] = 1;\n        else intervals[time]++;\n        cb();\n      });\n    }\n  });\n});\n\n",
        "called_code_segment_file_1": "function parseData(data, tile, source) {\n  var layers = new VectorTile(new Pbf(data)).layers;\n  return source.raw ? layers : toGeoJSON(layers, tile, source);\n}",
        "invoking_code_segment_file_2": "var getTile = function(tile, done) {\n  var url = source.url\n    .replace('{x}', tile[0])\n    .replace('{y}', tile[1])\n    .replace('{z}', tile[2]);\n\n  request({url: url, gzip: true, encoding: null}, function(err, res, body) {\n    if (err) return done(err);\n    else if (res.statusCode === 200) return done(null, parseVT(body, tile, source));\n    else if (res.statusCode === 401) return done();\n    else return done(new Error('Server responded with status code ' + res.statusCode));\n  });\n};",
        "called_code_segment_file_2": "var getTile = function(tile, done) {\n  var url = source.url\n    .replace('{x}', tile[0])\n    .replace('{y}', tile[1])\n    .replace('{z}', tile[2]);\n\n  request({url: url, gzip: true, encoding: null}, function(err, res, body) {\n    if (err) return done(err);\n    else if (res.statusCode === 200) return done(null, parseVT(body, tile, source));\n    else if (res.statusCode === 401) return done();\n    else return done(new Error('Server responded with status code ' + res.statusCode));\n  });\n};",
        "using_code_segment_file_3": "remote(source, function(err, getTile) {\n  t.notOk(err, 'remote initialized without error');\n  getTile([5276, 12757, 15], function(err, layers) {\n    t.notOk(err, 'remote VT unpacked without error');\n    t.ok(layers, 'layers parsed from remote source');\n    t.equal(layers.buildings.length, 264, 'layers have correct number of buildings');\n    t.equal(layers.roads.length, 384, 'layers have correct number of roads');\n    t.end();\n  });\n});",
        "feature_description": "Add a feature to cache parsed vector tiles to reduce redundant network requests.",
        "detailed_feature_description": "Modify the `parseData` function in `#file 1` to store parsed tiles in a cache. Update `#file 2` to check this cache before making a network request. If `#file 3` directly interacts with the updated segments in `#file 2`, ensure it handles the caching logic correctly.",
        "modified_complete_code": {
            "#file 1": {
                "code": "'use strict';\n\nvar VectorTile = require('@mapbox/vector-tile').VectorTile;\nvar Pbf = require('pbf');\n\nmodule.exports = parseData;\n\nvar cache = {}; // #New: Add a cache object\n\nfunction parseData(data, tile, source) {\n  var cacheKey = tile.join('-');\n  if (cache[cacheKey]) return cache[cacheKey]; // #Modify: Check cache before parsing\n\n  var layers = new VectorTile(new Pbf(data)).layers;\n  var result = source.raw ? layers : toGeoJSON(layers, tile, source);\n  cache[cacheKey] = result; // #Modify: Store result in cache\n  return result;\n}\n\nfunction toGeoJSON(layers, tile, source) {\n  var collections = {};\n\n  for (var layerId in layers) {\n    if (source.layers && source.layers.indexOf(layerId) === -1) continue;\n\n    collections[layerId] = {\n      type: 'FeatureCollection',\n      features: []\n    };\n    for (var k = 0; k < layers[layerId].length; k++) {\n      collections[layerId].features.push(\n        layers[layerId].feature(k).toGeoJSON(tile[0], tile[1], tile[2])\n      );\n    }\n  }\n  return collections;\n}"
            },
            "#file 2": {
                "code": "'use strict';\n\nvar request = require('request');\nvar parseVT = require('./vt');\nvar rateLimit = require('function-rate-limit');\n\nmodule.exports = remoteVT;\n\nfunction remoteVT(source, ready) {\n  var cache = {}; // #New: Add a cache object\n\n  var getTile = function(tile, done) {\n    var cacheKey = tile.join('-');\n    if (cache[cacheKey]) return done(null, cache[cacheKey]); // #Modify: Check cache before making request\n\n    var url = source.url\n      .replace('{x}', tile[0])\n      .replace('{y}', tile[1])\n      .replace('{z}', tile[2]);\n\n    request({url: url, gzip: true, encoding: null}, function(err, res, body) {\n      if (err) return done(err);\n      else if (res.statusCode === 200) {\n        var result = parseVT(body, tile, source);\n        cache[cacheKey] = result; // #Modify: Store result in cache\n        return done(null, result);\n      }\n      else if (res.statusCode === 401) return done();\n      else return done(new Error('Server responded with status code ' + res.statusCode));\n    });\n  };\n\n  if (source.maxrate) getTile = rateLimit(source.maxrate, 1000, getTile);\n  ready(null, getTile);\n}"
            },
            "#file 3": {
                "code": "'use strict';\n\nvar test = require('tap').test;\nvar remote = require('../src/remote');\nvar queue = require('queue-async');\n\ntest('remote - raw parse', function(t) {\n  var osmUrl = 'https://b.tiles.mapbox.com/v4/morganherlocker.3vsvfjjw/{z}/{x}/{y}.vector.pbf?access_token=pk.eyJ1IjoibW9yZ2FuaGVybG9ja2VyIiwiYSI6Ii1zLU4xOWMifQ.FubD68OEerk74AYCLduMZQ';\n  var source = {\n    name: 'osm',\n    url: osmUrl,\n    raw: true\n  };\n  remote(source, function(err, getTile) {\n    t.notOk(err, 'remote initialized without error');\n    getTile([5276, 12757, 15], function(err, layers) {\n      t.notOk(err, 'remote VT unpacked without error');\n      t.ok(layers, 'layers parsed from remote source');\n      t.equal(layers.buildings.length, 264, 'layers have correct number of buildings');\n      t.equal(layers.roads.length, 384, 'layers have correct number of roads');\n      t.end();\n    });\n  });\n});"
            }
        }
    },
    {
        "repo": "vue-cart",
        "content": "'vue-cart/build/vue-loader.conf.js'\n:'use strict'\nconst utils = require('./utils')\nconst config = require('../config')\nconst isProduction = process.env.NODE_ENV === 'production'\nconst sourceMapEnabled = isProduction\n  ? config.build.productionSourceMap\n  : config.dev.cssSourceMap\n\nmodule.exports = {\n  loaders: utils.cssLoaders({\n    sourceMap: sourceMapEnabled,\n    extract: isProduction\n  }),\n  cssSourceMap: sourceMapEnabled,\n  cacheBusting: config.dev.cacheBusting,\n  transformToRequire: {\n    video: ['src', 'poster'],\n    source: 'src',\n    img: 'src',\n    image: 'xlink:href'\n  }\n}\n\n'vue-cart/build/webpack.base.conf.js'\n:'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst config = require('../config')\nconst vueLoaderConfig = require('./vue-loader.conf')\n\nfunction resolve (dir) {\n  return path.join(__dirname, '..', dir)\n}\n\nconst createLintingRule = () => ({\n  test: /\\.(js|vue)$/,\n  loader: 'eslint-loader',\n  enforce: 'pre',\n  include: [resolve('src'), resolve('test')],\n  options: {\n    formatter: require('eslint-friendly-formatter'),\n    emitWarning: !config.dev.showEslintErrorsInOverlay\n  }\n})\n\nmodule.exports = {\n  context: path.resolve(__dirname, '../'),\n  entry: {\n    app: './src/main.js'\n  },\n  output: {\n    path: config.build.assetsRoot,\n    filename: '[name].js',\n    publicPath: process.env.NODE_ENV === 'production'\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n  resolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n    }\n  },\n  module: {\n    rules: [\n      ...(config.dev.useEslint ? [createLintingRule()] : []),\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('img/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('media/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n        }\n      }\n    ]\n  },\n  node: {\n    // prevent webpack from injecting useless setImmediate polyfill because Vue\n    // source contains it (although only uses it if it's native).\n    setImmediate: false,\n    // prevent webpack from injecting mocks to Node native modules\n    // that does not make sense for the client\n    dgram: 'empty',\n    fs: 'empty',\n    net: 'empty',\n    tls: 'empty',\n    child_process: 'empty'\n  }\n}\n\n'vue-cart/build/webpack.dev.conf.js'\n:'use strict'\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst path = require('path')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')\nconst portfinder = require('portfinder')\n\nconst HOST = process.env.HOST\nconst PORT = process.env.PORT && Number(process.env.PORT)\n\nconst devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  // cheap-module-eval-source-map is faster for development\n  devtool: config.dev.devtool,\n\n  // these devServer options should be customized in /config/index.js\n  devServer: {\n    clientLogLevel: 'warning',\n    historyApiFallback: {\n      rewrites: [\n        { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },\n      ],\n    },\n    hot: true,\n    contentBase: false, // since we use CopyWebpackPlugin.\n    compress: true,\n    host: HOST || config.dev.host,\n    port: PORT || config.dev.port,\n    open: config.dev.autoOpenBrowser,\n    overlay: config.dev.errorOverlay\n      ? { warnings: false, errors: true }\n      : false,\n    publicPath: config.dev.assetsPublicPath,\n    proxy: config.dev.proxyTable,\n    quiet: true, // necessary for FriendlyErrorsPlugin\n    watchOptions: {\n      poll: config.dev.poll,\n    }\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env': require('../config/dev.env')\n    }),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n    new webpack.NoEmitOnErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: 'index.html',\n      inject: true\n    }),\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.dev.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nmodule.exports = new Promise((resolve, reject) => {\n  portfinder.basePort = process.env.PORT || config.dev.port\n  portfinder.getPort((err, port) => {\n    if (err) {\n      reject(err)\n    } else {\n      // publish the new Port, necessary for e2e tests\n      process.env.PORT = port\n      // add port to devServer config\n      devWebpackConfig.devServer.port = port\n\n      // Add FriendlyErrorsPlugin\n      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({\n        compilationSuccessInfo: {\n          messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],\n        },\n        onErrors: config.dev.notifyOnErrors\n        ? utils.createNotifierCallback()\n        : undefined\n      }))\n\n      resolve(devWebpackConfig)\n    }\n  })\n})\n\n",
        "called_code_segment_file_1": "function resolve (dir) { return path.join(__dirname, '..', dir) }",
        "invoking_code_segment_file_2": "include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]",
        "called_code_segment_file_2": "include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]",
        "using_code_segment_file_3": "portfinder.getPort((err, port) => { if (err) { reject(err) } else { process.env.PORT = port devWebpackConfig.devServer.port = port devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({ compilationSuccessInfo: { messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`], }, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined })) resolve(devWebpackConfig) } })",
        "feature_description": "Add a feature to log the resolved directory path to the console.",
        "detailed_feature_description": "Modify the resolve function in #file 1 to log the resolved directory path to the console. Update the invoking code segment in #file 2 to handle the modified resolve function. Ensure that #file 3, which uses the resolve function indirectly through #file 2, is updated to accommodate the changes.",
        "modified_complete_code": {
            "#file 1": "//Modify function resolve (dir) { const resolvedPath = path.join(__dirname, '..', dir) console.log(`Resolved path: ${resolvedPath}`) return resolvedPath }",
            "#file 2": "//Modify include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]",
            "#file 3": "//Modify portfinder.getPort((err, port) => { if (err) { reject(err) } else { process.env.PORT = port devWebpackConfig.devServer.port = port devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({ compilationSuccessInfo: { messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`], }, onErrors: config.dev.notifyOnErrors ? utils.createNotifierCallback() : undefined })) resolve(devWebpackConfig) } })"
        }
    },
    {
        "repo": "winston-logstash",
        "content": "'winston-logstash/lib/connection.js'\n:\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecureConnection = exports.PlainConnection = exports.ConnectionEvents = exports.ConnectionActions = exports.Connection = void 0;\nvar _net = require(\"net\");\nvar _fs = require(\"fs\");\nvar _tls = _interopRequireDefault(require(\"tls\"));\nvar _events = require(\"events\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nlet ConnectionActions;\nexports.ConnectionActions = ConnectionActions;\n(function (ConnectionActions) {\n  ConnectionActions[\"Initializing\"] = \"Initializing\";\n  ConnectionActions[\"Connecting\"] = \"Connecting\";\n  ConnectionActions[\"Closing\"] = \"Closing\";\n  ConnectionActions[\"Tranferring\"] = \"Transferring\";\n  ConnectionActions[\"HandlingError\"] = \"HandlingError\";\n})(ConnectionActions || (exports.ConnectionActions = ConnectionActions = {}));\nlet ConnectionEvents;\nexports.ConnectionEvents = ConnectionEvents;\n(function (ConnectionEvents) {\n  ConnectionEvents[\"Connected\"] = \"connection:connected\";\n  ConnectionEvents[\"Closed\"] = \"connection:closed\";\n  ConnectionEvents[\"ClosedByServer\"] = \"connection:closed:by-server\";\n  ConnectionEvents[\"Error\"] = \"connection:error\";\n  ConnectionEvents[\"Timeout\"] = \"connection:timeout\";\n  ConnectionEvents[\"Drain\"] = \"connection:drain\";\n})(ConnectionEvents || (exports.ConnectionEvents = ConnectionEvents = {}));\nclass Connection extends _events.EventEmitter {\n  constructor(options) {\n    var _options$host, _options$port;\n    super();\n    _defineProperty(this, \"socket\", void 0);\n    _defineProperty(this, \"host\", void 0);\n    _defineProperty(this, \"port\", void 0);\n    _defineProperty(this, \"action\", void 0);\n    this.action = ConnectionActions.Initializing;\n    this.host = (_options$host = options === null || options === void 0 ? void 0 : options.host) !== null && _options$host !== void 0 ? _options$host : '127.0.0.1';\n    this.port = (_options$port = options === null || options === void 0 ? void 0 : options.port) !== null && _options$port !== void 0 ? _options$port : 28777;\n  }\n  socketOnError(error) {\n    this.action = ConnectionActions.HandlingError;\n    this.emit(ConnectionEvents.Error, error);\n  }\n  socketOnTimeout() {\n    var _this$socket;\n    this.action = ConnectionActions.HandlingError;\n    this.emit(ConnectionEvents.Timeout, (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState);\n  }\n  socketOnConnect() {\n    var _this$socket2;\n    (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.setKeepAlive(true, 60 * 1000);\n    this.action = ConnectionActions.Tranferring;\n    this.emit(ConnectionEvents.Connected);\n  }\n  socketOnDrain() {\n    this.emit(ConnectionEvents.Drain);\n  }\n  socketOnClose(error) {\n    if (this.action === ConnectionActions.Closing) {\n      this.emit(ConnectionEvents.Closed, error);\n    } else {\n      this.emit(ConnectionEvents.ClosedByServer, error);\n    }\n  }\n  addEventListeners(socket) {\n    socket.on('drain', this.socketOnDrain.bind(this));\n    socket.once('error', this.socketOnError.bind(this));\n    socket.once('timeout', this.socketOnTimeout.bind(this));\n    socket.once('close', this.socketOnClose.bind(this));\n  }\n  close() {\n    var _this$socket3, _this$socket4;\n    this.action = ConnectionActions.Closing;\n    (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.removeAllListeners();\n    (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.destroy();\n    this.emit(ConnectionEvents.Closed);\n  }\n  send(message, writeCallback) {\n    var _this$socket5;\n    return ((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.write(Buffer.from(message), writeCallback)) === true;\n  }\n  readyToSend() {\n    var _this$socket6;\n    return ((_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.readyState) === 'open';\n  }\n  connect() {\n    this.action = ConnectionActions.Connecting;\n  }\n}\nexports.Connection = Connection;\nclass PlainConnection extends Connection {\n  connect() {\n    super.connect();\n    try {\n      this.socket = new _net.Socket();\n      super.addEventListeners(this.socket);\n      this.socket.once('connect', super.socketOnConnect.bind(this));\n      this.socket.connect(this.port, this.host);\n    } catch (error) {\n      this.emit(ConnectionEvents.Error, error);\n    }\n  }\n}\nexports.PlainConnection = PlainConnection;\nclass SecureConnection extends Connection {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"secureContextOptions\", void 0);\n    this.secureContextOptions = SecureConnection.createSecureContextOptions(options);\n  }\n  static createSecureContextOptions(options) {\n    const sslKey = options.ssl_key;\n    const sslCert = options.ssl_cert;\n    const ca = options.ca;\n    const sslPassphrase = options.ssl_passphrase;\n    const rejectUnauthorized = options.rejectUnauthorized;\n    const secureContextOptions = {\n      key: sslKey && (0, _fs.readFileSync)(sslKey),\n      cert: sslCert && (0, _fs.readFileSync)(sslCert),\n      passphrase: sslPassphrase || undefined,\n      rejectUnauthorized: rejectUnauthorized,\n      ca: ca && (0, _fs.readFileSync)(ca)\n    };\n    return secureContextOptions;\n  }\n  connect() {\n    super.connect();\n    try {\n      this.socket = _tls.default.connect(this.port, this.host, this.secureContextOptions);\n      super.addEventListeners(this.socket);\n      this.socket.once('secureConnect', super.socketOnConnect.bind(this));\n    } catch (error) {\n      this.emit(ConnectionEvents.Error, error);\n    }\n  }\n}\nexports.SecureConnection = SecureConnection;\n'winston-logstash/lib/winston-logstash.js'\n:\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Logstash = void 0;\nvar _winston = require(\"winston\");\nvar _manager = require(\"./manager\");\nvar _connection = require(\"./connection\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nconst common = require('winston/lib/winston/common');\nclass Logstash extends _winston.Transport {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"node_name\", void 0);\n    _defineProperty(this, \"json\", true);\n    _defineProperty(this, \"label\", void 0);\n    _defineProperty(this, \"meta_defaults\", void 0);\n    _defineProperty(this, \"manager\", void 0);\n    _defineProperty(this, \"connection\", void 0);\n    this.name = 'logstash';\n    this.node_name = options.node_name || process.title;\n\n    // Miscellaneous options\n    this.label = options.label || this.node_name;\n    this.meta_defaults = Object.assign({}, options.meta);\n    this.connection = options.ssl_enable ? new _connection.SecureConnection(options) : new _connection.PlainConnection(options);\n    this.manager = new _manager.Manager(options, this.connection);\n    this.manager.on('error', this.onError.bind(this));\n    this.manager.start();\n  }\n  log(level, msg, meta, callback) {\n    if (this.silent) {\n      return callback(null, true);\n    }\n    const logEntry = this.defaultTransform(level, msg, Object.assign({}, meta, this.meta_defaults));\n    this.manager.log(logEntry, () => {\n      callback(null, true);\n    });\n    this.emit('logged');\n  }\n  onError(error) {\n    this.silent = true;\n    this.emit('error', error);\n  }\n  close() {\n    this.manager.close();\n  }\n  defaultTransform(level, msg, meta) {\n    return common.log({\n      level: level,\n      message: msg,\n      meta: meta,\n      json: this.json,\n      label: this.label,\n      humanReadableUnhandledException: this.humanReadableUnhandledException\n    });\n  }\n}\nexports.Logstash = Logstash;\n'winston-logstash/test-bench/winston-2x/test/on_error_test.js'\n:\nconst winston = require('winston');\nconst transports = require('../../../lib/winston-logstash');\n\ndescribe('Ensure error is handled correctly', () => {\n  it('add error eventhandler for logger', (done) => {\n    const logstashTransport = new transports.Logstash({\n      max_connect_retries: 2,\n      port: 7878,\n      node_name: 'my node name',\n      host: 'localhost',\n      ssl_enable: true,\n      ca: __dirname + '/../../../test/support/ssl/ca.cert',\n      ssl_key: __dirname + '/../../../test/support/ssl/client.key',\n      ssl_cert: __dirname + '/../../../test/support/ssl/client.cert',\n    });\n    const logger = new (winston.Logger)({\n      transports: [\n        logstashTransport,\n      ],\n    });\n\n    logstashTransport.on('error', (error) => {\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message)\n          .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n      done();\n    });\n    logger.log('info', 'random message');\n  });\n});\n\n",
        "called_code_segment_file_1": "socketOnError(error) {\n    this.action = ConnectionActions.HandlingError;\n    this.emit(ConnectionEvents.Error, error);\n  }",
        "invoking_code_segment_file_2": "this.manager.on('error', this.onError.bind(this));",
        "called_code_segment_file_2": "onError(error) {\n    this.silent = true;\n    this.emit('error', error);\n  }",
        "using_code_segment_file_3": "logstashTransport.on('error', (error) => {\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message)\n          .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n      done();\n    });",
        "feature_description": "Add a retry mechanism for the Logstash transport to handle transient errors.",
        "detailed_feature_description": "Introduce a retry mechanism in the Logstash transport to handle transient errors. When an error is emitted, the transport will attempt to reconnect a specified number of times before going into silent mode. This feature will be implemented by modifying the `onError` method in `#file 2` to include retry logic. The `onError` method will be updated to call a new method `retryConnection` that handles the reconnection attempts. The `retryConnection` method will be added to `#file 2` and will be invoked by `#file 3` when an error is detected.",
        "modified_complete_code": {
            "#file 1": "// No changes needed in #file 1",
            "#file 2": "class Logstash extends _winston.Transport {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"node_name\", void 0);\n    _defineProperty(this, \"json\", true);\n    _defineProperty(this, \"label\", void 0);\n    _defineProperty(this, \"meta_defaults\", void 0);\n    _defineProperty(this, \"manager\", void 0);\n    _defineProperty(this, \"connection\", void 0);\n    _defineProperty(this, \"retryCount\", 0);\n    this.name = 'logstash';\n    this.node_name = options.node_name || process.title;\n    this.label = options.label || this.node_name;\n    this.meta_defaults = Object.assign({}, options.meta);\n    this.connection = options.ssl_enable ? new _connection.SecureConnection(options) : new _connection.PlainConnection(options);\n    this.manager = new _manager.Manager(options, this.connection);\n    this.manager.on('error', this.onError.bind(this));\n    this.manager.start();\n  }\n\n  onError(error) {\n    this.silent = true;\n    this.emit('error', error);\n    this.retryConnection(); // #Modify\n  }\n\n  retryConnection() {\n    const maxRetries = 3; // #New\n    if (this.retryCount < maxRetries) {\n      this.retryCount++;\n      setTimeout(() => {\n        this.manager.start();\n      }, 1000 * this.retryCount);\n    } else {\n      this.emit('error', new Error('Max retries reached, transport in silent mode, OFFLINE'));\n    }\n  }\n}",
            "#file 3": "logstashTransport.on('error', (error) => {\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message)\n          .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n      done();\n    });\n\n    logstashTransport.on('retrying', (retryCount) => {\n      console.log(`Retrying connection, attempt ${retryCount}`); // #New\n    });"
        }
    },
    {
        "repo": "wp-optionskit",
        "content": "'wp-optionskit/build/utils.js'\n:'use strict'\nconst path = require('path')\nconst config = require('../config')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst packageConfig = require('../package.json')\n\nexports.assetsPath = function (_path) {\n  const assetsSubDirectory = process.env.NODE_ENV === 'production'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  return path.posix.join(assetsSubDirectory, _path)\n}\n\nexports.cssLoaders = function (options) {\n  options = options || {}\n\n  const cssLoader = {\n    loader: 'css-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  const postcssLoader = {\n    loader: 'postcss-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  // generate loader string to be used with extract text plugin\n  function generateLoaders (loader, loaderOptions) {\n    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n\n    if (loader) {\n      loaders.push({\n        loader: loader + '-loader',\n        options: Object.assign({}, loaderOptions, {\n          sourceMap: options.sourceMap\n        })\n      })\n    }\n\n    // Extract CSS when that option is specified\n    // (which is the case during production build)\n    if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader'\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }\n  }\n\n  // https://vue-loader.vuejs.org/en/configurations/extract-css.html\n  return {\n    css: generateLoaders(),\n    postcss: generateLoaders(),\n    less: generateLoaders('less'),\n    sass: generateLoaders('sass', { indentedSyntax: true }),\n    scss: generateLoaders('sass'),\n    stylus: generateLoaders('stylus'),\n    styl: generateLoaders('stylus')\n  }\n}\n\n// Generate loaders for standalone style files (outside of .vue)\nexports.styleLoaders = function (options) {\n  const output = []\n  const loaders = exports.cssLoaders(options)\n\n  for (const extension in loaders) {\n    const loader = loaders[extension]\n    output.push({\n      test: new RegExp('\\\\.' + extension + '$'),\n      use: loader\n    })\n  }\n\n  return output\n}\n\nexports.createNotifierCallback = () => {\n  const notifier = require('node-notifier')\n\n  return (severity, errors) => {\n    if (severity !== 'error') return\n\n    const error = errors[0]\n    const filename = error.file && error.file.split('!').pop()\n\n    notifier.notify({\n      title: packageConfig.name,\n      message: severity + ': ' + error.name,\n      subtitle: filename || '',\n      icon: path.join(__dirname, 'logo.png')\n    })\n  }\n}\n\n'wp-optionskit/build/webpack.base.conf.js'\n:'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst config = require('../config')\nconst vueLoaderConfig = require('./vue-loader.conf')\n\nfunction resolve (dir) {\n  return path.join(__dirname, '..', dir)\n}\n\n\n\nmodule.exports = {\n  context: path.resolve(__dirname, '../'),\n  entry: {\n    app: './src/main.js'\n  },\n  output: {\n    path: config.build.assetsRoot,\n\t  jsonpFunction: 'wpJsonpFlightsWidget',\n    filename: '[name].js',\n    publicPath: process.env.NODE_ENV === 'production'\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n  resolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n    }\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('img/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('media/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n        }\n      }\n    ]\n  },\n  node: {\n    // prevent webpack from injecting useless setImmediate polyfill because Vue\n    // source contains it (although only uses it if it's native).\n    setImmediate: false,\n    // prevent webpack from injecting mocks to Node native modules\n    // that does not make sense for the client\n    dgram: 'empty',\n    fs: 'empty',\n    net: 'empty',\n    tls: 'empty',\n    child_process: 'empty'\n  }\n}\n\n'wp-optionskit/build/webpack.dev.conf.js'\n:'use strict'\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst path = require('path')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')\nconst portfinder = require('portfinder')\n\nconst HOST = process.env.HOST\nconst PORT = process.env.PORT && Number(process.env.PORT)\n\nconst devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  // cheap-module-eval-source-map is faster for development\n  devtool: config.dev.devtool,\n\n  // these devServer options should be customized in /config/index.js\n  devServer: {\n    clientLogLevel: 'warning',\n    historyApiFallback: {\n      rewrites: [\n        { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },\n      ],\n    },\n    hot: true,\n    contentBase: false, // since we use CopyWebpackPlugin.\n    compress: true,\n    host: HOST || config.dev.host,\n    port: PORT || config.dev.port,\n    open: config.dev.autoOpenBrowser,\n    overlay: config.dev.errorOverlay\n      ? { warnings: false, errors: true }\n      : false,\n    publicPath: config.dev.assetsPublicPath,\n    proxy: config.dev.proxyTable,\n    quiet: true, // necessary for FriendlyErrorsPlugin\n    watchOptions: {\n      poll: config.dev.poll,\n    }\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env': require('../config/dev.env')\n    }),\n    new webpack.HotModuleReplacementPlugin(),\n    new webpack.NamedModulesPlugin(), // HMR shows correct file names in console on update.\n    new webpack.NoEmitOnErrorsPlugin(),\n    // https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: 'index.html',\n      template: 'index.html',\n      inject: true\n    }),\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.dev.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nmodule.exports = new Promise((resolve, reject) => {\n  portfinder.basePort = process.env.PORT || config.dev.port\n  portfinder.getPort((err, port) => {\n    if (err) {\n      reject(err)\n    } else {\n      // publish the new Port, necessary for e2e tests\n      process.env.PORT = port\n      // add port to devServer config\n      devWebpackConfig.devServer.port = port\n\n      // Add FriendlyErrorsPlugin\n      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({\n        compilationSuccessInfo: {\n          messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],\n        },\n        onErrors: config.dev.notifyOnErrors\n        ? utils.createNotifierCallback()\n        : undefined\n      }))\n\n      resolve(devWebpackConfig)\n    }\n  })\n})\n\n",
        "called_code_segment_file_1": "exports.assetsPath = function (_path) {\n  const assetsSubDirectory = process.env.NODE_ENV === 'production'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  return path.posix.join(assetsSubDirectory, _path)\n}",
        "invoking_code_segment_file_2": "const devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  // other configurations...\n})",
        "called_code_segment_file_2": "const devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })\n  },\n  // other configurations...\n})",
        "using_code_segment_file_3": "module.exports = new Promise((resolve, reject) => {\n  portfinder.basePort = process.env.PORT || config.dev.port\n  portfinder.getPort((err, port) => {\n    if (err) {\n      reject(err)\n    } else {\n      // publish the new Port, necessary for e2e tests\n      process.env.PORT = port\n      // add port to devServer config\n      devWebpackConfig.devServer.port = port\n\n      // Add FriendlyErrorsPlugin\n      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({\n        compilationSuccessInfo: {\n          messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],\n        },\n        onErrors: config.dev.notifyOnErrors\n        ? utils.createNotifierCallback()\n        : undefined\n      }))\n\n      resolve(devWebpackConfig)\n    }\n  })\n})",
        "feature_description": "Add a new feature to allow customizing the assets path dynamically based on an environment variable.",
        "detailed_feature_description": "Modify the `assetsPath` function in `#file 1` to accept an optional `env` parameter. Update `#file 2` to pass this parameter when calling `utils.styleLoaders`. Ensure `#file 3` handles any changes in the configuration structure.",
        "modified_complete_code": {
            "#file 1": "exports.assetsPath = function (_path, env) {\n  const assetsSubDirectory = env === 'production'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  return path.posix.join(assetsSubDirectory, _path)\n} #Modify",
            "#file 2": "const devWebpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true, env: process.env.NODE_ENV })\n  },\n  // other configurations...\n}) #Modify",
            "#file 3": "module.exports = new Promise((resolve, reject) => {\n  portfinder.basePort = process.env.PORT || config.dev.port\n  portfinder.getPort((err, port) => {\n    if (err) {\n      reject(err)\n    } else {\n      // publish the new Port, necessary for e2e tests\n      process.env.PORT = port\n      // add port to devServer config\n      devWebpackConfig.devServer.port = port\n\n      // Add FriendlyErrorsPlugin\n      devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({\n        compilationSuccessInfo: {\n          messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],\n        },\n        onErrors: config.dev.notifyOnErrors\n        ? utils.createNotifierCallback()\n        : undefined\n      }))\n\n      resolve(devWebpackConfig)\n    }\n  })\n})"
        }
    },
    {
        "repo": "Next-GraphQL-Blog",
        "content": "'Next-GraphQL-Blog/server/db/models/User.js'\n:import mongoose from 'mongoose'\n\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  // Don't return password unless specified to\n  password: {\n    type: String,\n    select: false\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User\n\n'Next-GraphQL-Blog/server/auth/google.js'\n:var passport = require('passport')\nvar GoogleStrategy = require('passport-google-oauth').OAuth2Strategy\nimport jwt from 'jsonwebtoken'\n\nconst dev = process.env.NODE_ENV !== 'production'\n\nimport User from '../db/models/User'\n\nexport default server => {\n  passport.use(\n    new GoogleStrategy(\n      {\n        clientID: process.env.GOOGLE_CLIENT_ID,\n        clientSecret: process.env.GOOGLE_SECRET_ID,\n        callbackURL: dev\n          ? `${process.env.ROOT_URL_DEV}/auth/googlecallback`\n          : `${process.env.ROOT_URL_PROD}/auth/googlecallback`\n      },\n      async (accessToken, refreshToken, profile, done) => {\n        const name =\n          profile.displayName || profile.name\n            ? `${profile.name.givenName} ${profile.name.familyName}`\n            : ''\n\n        const email =\n          (profile.emails &&\n            profile.emails.length > 0 &&\n            profile.emails[0].value) ||\n          null\n\n        const googleId = profile.id\n\n        try {\n          let user = await User.findOne({ googleId }).exec()\n\n          if (user) {\n            return done(null, user)\n          }\n\n          const emailExist = await User.findOne({ email }).exec()\n\n          if (emailExist) {\n            return done('Email already exists')\n          }\n\n          user = await User.create({\n            email,\n            name,\n            googleId\n          })\n\n          done(null, user)\n        } catch (err) {\n          console.log(err)\n          done(err)\n        }\n      }\n    )\n  )\n\n  passport.serializeUser((user, done) => {\n    done(null, user.id)\n  })\n\n  passport.deserializeUser((id, done) => {\n    User.findById({ _id: id }, (err, user) => {\n      done(err, user)\n    })\n  })\n\n  server.get('/auth/google', (req, res) => {\n    passport.authenticate('google', {\n      scope: ['profile', 'email'],\n      prompt: 'select_account'\n    })(req, res)\n  })\n\n  server.get(\n    '/auth/googlecallback',\n    passport.authenticate('google', {\n      session: false,\n      failureRedirect: dev\n        ? `${process.env.CLIENT_URL_DEV}/login`\n        : `${process.env.CLIENT_URL_PROD}/login`\n    }),\n    (req, res) => {\n      const token = jwt.sign({ userId: req.user._id }, process.env.AUTH_SECRET)\n      console.log(token)\n      res.redirect(\n        dev\n          ? `${process.env.CLIENT_URL_DEV}/authcallback?token=${token}`\n          : `${process.env.CLIENT_URL_PROD}/authcallback?token=${token}`\n      )\n    }\n  )\n}\n\n'Next-GraphQL-Blog/server/index.js'\n:require('dotenv').config()\n\nimport { GraphQLServer, PubSub } from 'graphql-yoga'\nimport cors from 'cors'\nimport cookieParser from 'cookie-parser'\nimport depthLimit from 'graphql-depth-limit'\nimport helmet from 'helmet'\nimport compression from 'compression'\n\nimport initGoogleAuth from './auth/google'\nimport passport from 'passport'\nimport resolvers from './resolvers'\nimport typeDefs from './types'\nimport db from './db'\nimport { initUser } from './utils'\nimport createLoaders from './loaders'\n\nconst dev = process.env.NODE_ENV !== 'production'\n\nconst startServer = async () => {\n  const initDB = await db()\n\n  const pubsub = new PubSub()\n\n  const server = new GraphQLServer({\n    typeDefs,\n    resolvers,\n    context: async req => ({\n      ...req,\n      pubsub,\n      loaders: createLoaders(),\n      user: initUser(req),\n      db: initDB\n    }),\n    validationRules: [depthLimit(10)]\n  })\n\n  server.express.use(compression())\n  server.express.use(helmet())\n  server.express.use(cookieParser())\n\n  const ONE_YEAR = 31556952000\n\n  if (!dev) {\n    server.express.set('trust proxy', 1)\n  }\n\n  server.express.use(passport.initialize())\n\n  initGoogleAuth(server.express)\n\n  const corsOptions = {\n    origin: dev ? process.env.CLIENT_URL_DEV : process.env.CLIENT_URL_PROD,\n    credentials: true\n  }\n\n  //option object for graphql yoga\n  const port = parseInt(process.env.PORT, 10) || 4000\n  const options = {\n    port,\n    cors: corsOptions\n  }\n\n  server.start(options, ({ port }) =>\n    console.log(\n      `Server started, listening on port ${port} for incoming requests. [${\n        process.env.NODE_ENV\n      }]`\n    )\n  )\n}\n\nstartServer()\n\n",
        "called_code_segment_file_1": "const userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  password: {\n    type: String,\n    select: false\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User",
        "invoking_code_segment_file_2": "const email = (profile.emails && profile.emails.length > 0 && profile.emails[0].value) || null\n\nconst googleId = profile.id\n\ntry {\n  let user = await User.findOne({ googleId }).exec()\n\n  if (user) {\n    return done(null, user)\n  }\n\n  const emailExist = await User.findOne({ email }).exec()\n\n  if (emailExist) {\n    return done('Email already exists')\n  }\n\n  user = await User.create({\n    email,\n    name,\n    googleId\n  })\n\n  done(null, user)\n} catch (err) {\n  console.log(err)\n  done(err)\n}",
        "invoking_code_segment_file_3": "const initUser = req => {\n  const token = req.cookies.token || req.headers.authorization\n  if (token) {\n    try {\n      const { userId } = jwt.verify(token, process.env.AUTH_SECRET)\n      return User.findById(userId).exec()\n    } catch (err) {\n      return null\n    }\n  }\n  return null\n}\n\nexport { initUser }",
        "new_file_code_segment": "const verifyUser = async (userId) => {\n  try {\n    const user = await User.findById(userId).exec()\n    return user ? true : false\n  } catch (err) {\n    console.log(err)\n    return false\n  }\n}\n\nexport { verifyUser }",
        "feature_description": "Add a feature to verify if a user exists by their userId.",
        "detailed_feature_description": "The new feature involves adding a function in a new file (#file 4) that verifies if a user exists by their userId. This function will be invoked in #file 1 to enhance the user verification process. #file 2 and #file 3 will be updated to use this new function where applicable.",
        "modified_complete_code": {
            "file_1": "const userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  password: {\n    type: String,\n    select: false\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User\n\n#Modify\nimport { verifyUser } from './verifyUser'\n\nconst initUser = req => {\n  const token = req.cookies.token || req.headers.authorization\n  if (token) {\n    try {\n      const { userId } = jwt.verify(token, process.env.AUTH_SECRET)\n      return verifyUser(userId) ? User.findById(userId).exec() : null\n    } catch (err) {\n      return null\n    }\n  }\n  return null\n}\n\nexport { initUser }",
            "file_2": "const email = (profile.emails && profile.emails.length > 0 && profile.emails[0].value) || null\n\nconst googleId = profile.id\n\ntry {\n  let user = await User.findOne({ googleId }).exec()\n\n  if (user) {\n    return done(null, user)\n  }\n\n  const emailExist = await User.findOne({ email }).exec()\n\n  if (emailExist) {\n    return done('Email already exists')\n  }\n\n  user = await User.create({\n    email,\n    name,\n    googleId\n  })\n\n  done(null, user)\n} catch (err) {\n  console.log(err)\n  done(err)\n}\n\n#Modify\nimport { verifyUser } from './verifyUser'\n\nconst verifyAndCreateUser = async (email, name, googleId) => {\n  const emailExist = await User.findOne({ email }).exec()\n  if (emailExist) {\n    return 'Email already exists'\n  }\n  const user = await User.create({\n    email,\n    name,\n    googleId\n  })\n  return user\n}\n\nconst createUser = async (accessToken, refreshToken, profile, done) => {\n  const name = profile.displayName || profile.name ? `${profile.name.givenName} ${profile.name.familyName}` : ''\n  const email = (profile.emails && profile.emails.length > 0 && profile.emails[0].value) || null\n  const googleId = profile.id\n\n  try {\n    let user = await User.findOne({ googleId }).exec()\n    if (user) {\n      return done(null, user)\n    }\n    user = await verifyAndCreateUser(email, name, googleId)\n    done(null, user)\n  } catch (err) {\n    console.log(err)\n    done(err)\n  }\n}",
            "file_3": "const initUser = req => {\n  const token = req.cookies.token || req.headers.authorization\n  if (token) {\n    try {\n      const { userId } = jwt.verify(token, process.env.AUTH_SECRET)\n      return User.findById(userId).exec()\n    } catch (err) {\n      return null\n    }\n  }\n  return null\n}\n\nexport { initUser }\n\n#Modify\nimport { verifyUser } from './verifyUser'\n\nconst initUser = req => {\n  const token = req.cookies.token || req.headers.authorization\n  if (token) {\n    try {\n      const { userId } = jwt.verify(token, process.env.AUTH_SECRET)\n      return verifyUser(userId) ? User.findById(userId).exec() : null\n    } catch (err) {\n      return null\n    }\n  }\n  return null\n}\n\nexport { initUser }",
            "file_4": "#New\nconst verifyUser = async (userId) => {\n  try {\n    const user = await User.findById(userId).exec()\n    return user ? true : false\n  } catch (err) {\n    console.log(err)\n    return false\n  }\n}\n\nexport { verifyUser }"
        }
    },
    {
        "repo": "replpad",
        "content": "'replpad/lib/utl.js'\n:'use strict';\n\nvar path    =  require('path')\n  , fs      =  require('fs')\n  , util    =  require('util')\n  , logFile =  path.join(__dirname, '../logs/debug.log');\n\nexports.shallowClone = function shallowClone(obj) {\n  var clone = {};\n  Object.keys(obj).forEach(function (k) {\n    clone[k] = obj[k];\n  });\n  return clone;\n};\n\nexports.pad = function pad(s, len, padding) {\n  len = len || 0;\n  padding = padding || ' ';\n\n  return len + 1 >= s.length\n    ? s + new Array(len + 1 - s.length).join(padding)\n    : s;\n};\n\nexports.log = function log(obj, depth) {\n  var s = util.inspect(obj, false, depth || 5, true);\n  fs.appendFileSync(logFile, s);\n};\n\nexports.inspect = function(obj, depth) {\n  return util.inspect(obj, false, depth || 5, true);\n};\n\nexports.existsSync =  fs.existsSync || path.existsSync;\n\n/**\n * Copies srcFile to tgtFile without checking if paths are valid and calls back when done.\n * srcFile is streamed to tgtFile\n *\n * @name copyFile\n * @function\n * @param srcFile {String}\n * @param tgtFile {String}\n * @param cb {Function} called when file is completely copied or an error occurs\n */\nexports.copyFile = function (srcFile, tgtFile, cb) {\n  var readStream = fs.createReadStream(srcFile)\n    , writeStream = fs.createWriteStream(tgtFile);\n\n  writeStream\n    .on('close', cb)\n    .on('error', cb);\n\n  readStream\n    .on('error', cb);\n\n  readStream.pipe(writeStream);\n};\n\n\n/**\n * Copies srcFile to tgtFile without checking if paths are valid and returns when done.\n * srcFile is copied to tgtFile in chunks\n *\n * @name copyFileSync\n * @function\n * @param srcFile {String}\n * @param tgtFile {String}\n * @return {void}\n */\nexports.copyFileSync = function(srcFile, tgtFile) {\n  var buflen    =  64 * 1024\n    , buf       =  new Buffer(buflen)\n    , fdr       =  fs.openSync(srcFile, 'r')\n    , fdw       =  fs.openSync(tgtFile, 'w')\n    , bytesRead =  1\n    , pos       =  0\n    ;\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, buf, 0, buflen, pos);\n    fs.writeSync(fdw, buf, 0, bytesRead);\n    pos += bytesRead;\n  }\n\n  fs.closeSync(fdr);\n  return fs.closeSync(fdw);\n};\n\n'replpad/lib/complete-append.js'\n:var cardinal =  require('cardinal')\n  , rewrite  =  require('./rewrite')\n  , config   =  require('../config/current')\n  , utl      =  require('./utl');\n\n/**\n * Tries to grab a complete JavaScript snippet from the history.\n *\n * @name completeAppend\n * @function\n * @param history {Array[{String}]} last entered lines in reverse order (i.e., last entered line is at index 0)\n * @return {Object} the smallest portion of the history that was parsable or just the last line if none was found as { raw, highlighted }\n */\nmodule.exports = function completeAppend(history) {\n  var highlighted\n    , code = ''\n    , rewritten\n    , l = history.length\n    , start = 0\n    , format = utl.shallowClone(config.feed.format);\n\n  if (l === 0) return null;\n\n  // skip commands, i.e. '.append'\n  while (/^[ ]*\\.\\w+[ ]*$/.test(history[start])) {\n    start++;\n    if (start == l) return null;\n  }\n\n  format.compact = false;\n  for (var i = start; i < l; i++) {\n    try {\n      code = '\\n' + history[i] + code;\n\n      rewritten = '\\n' + rewrite(code, format);\n      highlighted = cardinal.highlight(rewritten);\n      // no blow up means code was parsable, so we are done\n      return { raw: rewritten, highlighted: highlighted };\n    } catch (e) {/* keep trying */ }\n  }\n\n  code = '\\n' + history[start] + '\\n';\n  // we got here because no parsable portion was found\n  return { raw: code, highlighted: code };\n};\n\n'replpad/test/complete-append.js'\n:/*jshint asi:true */\n'use strict';\n\nvar test = require('tap').test\n  , completeAppend = require('../lib/complete-append')\n  , config = require('../config/current')\n\nconfig.feed.format = {\n    indent      :  { style: '  ', base: 0 }\n  , quotes      :  'single'\n  , json        :  false\n  , renumber    :  false\n  , hexadecimal :  false\n  , escapeless  :  false\n  , compact     :  true\n  , parentheses :  false\n  , semicolons  :  true\n};\n\ntest('\\nhandles no history case', function (t) {\n  var history = []\n    , append = completeAppend(history)\n\n  t.equal(append, null, 'returns null')\n  t.end()\n})\n\ntest('\\nhandles command only case', function (t) {\n  var history = [' .append  ']\n    , append = completeAppend(history)\n\n  t.equal(append, null, 'returns null')\n  t.end()\n})\n\ntest('\\nappends first expression before command', function (t) {\n  var history = [\n       '2 + 3'\n    ,  'var a = true;'\n    ,  '.append'\n    ].reverse()\n    , expected = '\\nvar a = true;\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\nappends multiline function before commands', function (t) {\n  var history = [\n      'function foo() {'\n    ,  '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ,  '   .clear '\n    ,  '.append'\n    ].reverse()\n\n    , expected = '\\nfunction foo() {\\n  var a = 2;\\n  return a + 1;\\n}\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ncompletes 3 line function at end of history', function (t) {\n  var history = [\n      '1'\n    , '2'\n    , 'function foo() {'\n    ,  '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ].reverse()\n    , expected = '\\nfunction foo() {\\n  var a = 2;\\n  return a + 1;\\n}\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ncompletes 3 line function at end of history that are badly formatted in a better formatted way', function (t) {\n  var history = [\n      '1'\n    , '2'\n    , 'function foo() {'\n    ,  'var a = 2;'\n    ,  '           return a + 1;'\n    ,  '}'\n    ].reverse()\n    , expected = '\\nfunction foo() {\\n  var a = 2;\\n  return a + 1;\\n}\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ndoes not complete incomplete function at end of history', function (t) {\n  var history = [\n       '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ].reverse()\n    , expected = '\\n}\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.equal(append.raw, append.highlighted, 'does not highlight')\n    t.end()\n})\n\ntest('\\ncompletes 2 + 3 at end of history', function (t) {\n  var history = [\n       '3 + 4'\n    ,  '2 + 3'\n    ].reverse()\n    , expected = '\\n2 + 3;\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ncompletes var a = true; at end of history with complete function right before', function (t) {\n  var history = [\n      'function foo () {'\n    ,  '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ,  'var a = true;'\n    ].reverse()\n    , expected = '\\nvar a = true;\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ndoes not complete \"var a =\" at end of history with complete function right before', function (t) {\n  var history = [\n      'function foo () {'\n    ,  '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ,  'var a ='\n    ].reverse()\n    , expected = '\\nvar a =\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.equal(append.raw, append.highlighted, 'does not highlight')\n    t.end()\n})\n\ntest('\\ncompletes 2 + 3 close to end whan .append is at end of history, thus ignoring .append', function (t) {\n  var history = [\n       '2 + 3'\n    ,  '.append'\n    ].reverse()\n    , expected = '\\n2 + 3;\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\n",
        "called_code_segment_file_1": "module.exports = function completeAppend(history) {\n  var highlighted\n    , code = ''\n    , rewritten\n    , l = history.length\n    , start = 0\n    , format = utl.shallowClone(config.feed.format);\n\n  if (l === 0) return null;\n\n  // skip commands, i.e. '.append'\n  while (/^[ ]*\\.\\w+[ ]*$/.test(history[start])) {\n    start++;\n    if (start == l) return null;\n  }\n\n  format.compact = false;\n  for (var i = start; i < l; i++) {\n    try {\n      code = '\\n' + history[i] + code;\n\n      rewritten = '\\n' + rewrite(code, format);\n      highlighted = cardinal.highlight(rewritten);\n      // no blow up means code was parsable, so we are done\n      return { raw: rewritten, highlighted: highlighted };\n    } catch (e) {/* keep trying */ }\n  }\n\n  code = '\\n' + history[start] + '\\n';\n  // we got here because no parsable portion was found\n  return { raw: code, highlighted: code };\n};",
        "invoking_code_segment_file_2": "var append = completeAppend(history);\n\nt.equal(append, null, 'returns null');\nt.end();",
        "invoking_code_segment_file_3": "var history = [\n     '2 + 3'\n  ,  'var a = true;'\n  ,  '.append'\n].reverse();\nvar expected = '\\nvar a = true;\\n';\nvar append = completeAppend(history);\n\nt.equal(append.raw, expected, 'gets raw');\nt.notEqual(append.raw, append.highlighted, 'gets highlighted');\nt.end();",
        "new_file_code_segment": "module.exports = function logHistory(history) {\n  console.log('History:', history);\n};",
        "feature_description": "Add logging of the history array before invoking the `completeAppend` function.",
        "detailed_feature_description": "The new feature involves adding a logging mechanism to the `completeAppend` function. This will help in debugging and understanding the history array before any processing is done. A new file (#file 4) is created to implement this logging functionality. The `logHistory` function in #file 4 will be invoked from #file 2 and #file 3 to log the history array before calling `completeAppend`.",
        "modified_complete_code": {
            "#file 1": "module.exports = function completeAppend(history) {\n  var highlighted\n    , code = ''\n    , rewritten\n    , l = history.length\n    , start = 0\n    , format = utl.shallowClone(config.feed.format);\n\n  if (l === 0) return null;\n\n  // skip commands, i.e. '.append'\n  while (/^[ ]*\\.\\w+[ ]*$/.test(history[start])) {\n    start++;\n    if (start == l) return null;\n  }\n\n  format.compact = false;\n  for (var i = start; i < l; i++) {\n    try {\n      code = '\\n' + history[i] + code;\n\n      rewritten = '\\n' + rewrite(code, format);\n      highlighted = cardinal.highlight(rewritten);\n      // no blow up means code was parsable, so we are done\n      return { raw: rewritten, highlighted: highlighted };\n    } catch (e) {/* keep trying */ }\n  }\n\n  code = '\\n' + history[start] + '\\n';\n  // we got here because no parsable portion was found\n  return { raw: code, highlighted: code };\n};",
            "#file 2": "var logHistory = require('./logHistory'); // #New\n\nvar append = completeAppend(history);\nlogHistory(history); // #Modify\n\nt.equal(append, null, 'returns null');\nt.end();",
            "#file 3": "var logHistory = require('./logHistory'); // #New\n\nvar history = [\n     '2 + 3'\n  ,  'var a = true;'\n  ,  '.append'\n].reverse();\nvar expected = '\\nvar a = true;\\n';\nlogHistory(history); // #Modify\nvar append = completeAppend(history);\n\nt.equal(append.raw, expected, 'gets raw');\nt.notEqual(append.raw, append.highlighted, 'gets highlighted');\nt.end();",
            "#file 4": "module.exports = function logHistory(history) {\n  console.log('History:', history);\n};"
        }
    },
    {
        "repo": "tile-reduce",
        "content": "'tile-reduce/src/vt.js'\n:'use strict';\n\nvar VectorTile = require('@mapbox/vector-tile').VectorTile;\nvar Pbf = require('pbf');\n\nmodule.exports = parseData;\n\nfunction parseData(data, tile, source) {\n  var layers = new VectorTile(new Pbf(data)).layers;\n  return source.raw ? layers : toGeoJSON(layers, tile, source);\n}\n\nfunction toGeoJSON(layers, tile, source) {\n  var collections = {};\n\n  for (var layerId in layers) {\n    if (source.layers && source.layers.indexOf(layerId) === -1) continue;\n\n    collections[layerId] = {\n      type: 'FeatureCollection',\n      features: []\n    };\n    for (var k = 0; k < layers[layerId].length; k++) {\n      collections[layerId].features.push(\n        layers[layerId].feature(k).toGeoJSON(tile[0], tile[1], tile[2])\n      );\n    }\n  }\n  return collections;\n}\n\n'tile-reduce/src/remote.js'\n:'use strict';\n\nvar request = require('request');\nvar parseVT = require('./vt');\nvar rateLimit = require('function-rate-limit');\n\nmodule.exports = remoteVT;\n\nfunction remoteVT(source, ready) {\n  var getTile = function(tile, done) {\n    var url = source.url\n      .replace('{x}', tile[0])\n      .replace('{y}', tile[1])\n      .replace('{z}', tile[2]);\n\n    request({url: url, gzip: true, encoding: null}, function(err, res, body) {\n      if (err) return done(err);\n      else if (res.statusCode === 200) return done(null, parseVT(body, tile, source));\n      else if (res.statusCode === 401) return done();\n      else return done(new Error('Server responded with status code ' + res.statusCode));\n    });\n  };\n\n  if (source.maxrate) getTile = rateLimit(source.maxrate, 1000, getTile);\n  ready(null, getTile);\n}\n\n'tile-reduce/src/worker.js'\n:'use strict';\n\nvar queue = require('queue-async');\nvar q = queue();\nvar sources = [];\nvar tilesQueue = queue(1);\nvar isOldNode = process.versions.node.split('.')[0] < 4;\n\nglobal.mapOptions = JSON.parse(process.argv[4]);\nvar map = require(process.argv[2]);\n\nJSON.parse(process.argv[3]).forEach(function(source) {\n  q.defer(loadSource, source);\n});\n\nfunction loadSource(source, done) {\n  var loaded = {name: source.name};\n  sources.push(loaded);\n\n  /*eslint global-require: 0 */\n  if (source.mbtiles) require('./mbtiles')(source, done);\n  else if (source.url) require('./remote')(source, done);\n  else throw new Error('Unknown source type');\n}\n\nq.awaitAll(function(err, results) {\n  if (err) throw err;\n  for (var i = 0; i < results.length; i++) sources[i].getTile = results[i];\n  process.send({ready: true});\n});\n\nfunction processTile(tile, callback) {\n  var q = queue();\n\n  for (var i = 0; i < sources.length; i++) {\n    q.defer(sources[i].getTile, tile);\n  }\n\n  q.awaitAll(gotData);\n\n  function gotData(err, results) {\n    if (err) throw err;\n\n    var data = {};\n    for (var i = 0; i < results.length; i++) {\n      data[sources[i].name] = results[i];\n      if (!results[i]) {\n        callback();\n        process.send({reduce: true});\n        return;\n      }\n    }\n\n    var writeQueue = queue(1);\n\n    function write(data) {\n      writeQueue.defer(writeStdout, (typeof data !== 'string' ? JSON.stringify(data) : data) + '\\x1e');\n    }\n\n    function gotResults(err, value) {\n      if (err) throw err;\n      writeQueue.awaitAll(function() {\n        process.send({reduce: true, value: value, tile: tile}, null, callback);\n        if (isOldNode) callback(); // process.send is async since Node 4.0\n      });\n    }\n\n    map(data, tile, write, gotResults);\n  }\n}\n\nfunction writeStdout(str, cb) {\n  process.stdout.write(str, cb);\n}\n\nprocess.on('message', function(tile) {\n  tilesQueue.defer(processTile, tile);\n});\n\n\n",
        "called_code_segment_file_1": "function parseData(data, tile, source) { var layers = new VectorTile(new Pbf(data)).layers; return source.raw ? layers : toGeoJSON(layers, tile, source); }",
        "invoking_code_segment_file_2": "function remoteVT(source, ready) { var getTile = function(tile, done) { var url = source.url .replace('{x}', tile[0]) .replace('{y}', tile[1]) .replace('{z}', tile[2]); request({url: url, gzip: true, encoding: null}, function(err, res, body) { if (err) return done(err); else if (res.statusCode === 200) return done(null, parseVT(body, tile, source)); else if (res.statusCode === 401) return done(); else return done(new Error('Server responded with status code ' + res.statusCode)); }); }; if (source.maxrate) getTile = rateLimit(source.maxrate, 1000, getTile); ready(null, getTile); }",
        "invoking_code_segment_file_3": "function loadSource(source, done) { var loaded = {name: source.name}; sources.push(loaded); if (source.mbtiles) require('./mbtiles')(source, done); else if (source.url) require('./remote')(source, done); else throw new Error('Unknown source type'); }",
        "new_file_code_segment": "function logTileRequest(tile) { console.log(`Tile requested: ${tile[0]}, ${tile[1]}, ${tile[2]}`); }",
        "feature_description": "Add logging for tile requests.",
        "detailed_feature_description": "The new feature adds logging for each tile request. This is implemented by creating a new function in #file 4 that logs the tile coordinates. This function is then invoked in #file 1 where the tile data is processed. The invocation in #file 2 is updated to pass the tile to the new logging function.",
        "modified_complete_code": {
            "#file 1": "function parseData(data, tile, source) { logTileRequest(tile); #Modify var layers = new VectorTile(new Pbf(data)).layers; return source.raw ? layers : toGeoJSON(layers, tile, source); }",
            "#file 2": "function remoteVT(source, ready) { var getTile = function(tile, done) { var url = source.url .replace('{x}', tile[0]) .replace('{y}', tile[1]) .replace('{z}', tile[2]); request({url: url, gzip: true, encoding: null}, function(err, res, body) { if (err) return done(err); else if (res.statusCode === 200) return done(null, parseVT(body, tile, source)); else if (res.statusCode === 401) return done(); else return done(new Error('Server responded with status code ' + res.statusCode)); }); }; if (source.maxrate) getTile = rateLimit(source.maxrate, 1000, getTile); ready(null, getTile); }",
            "#file 3": "function loadSource(source, done) { var loaded = {name: source.name}; sources.push(loaded); if (source.mbtiles) require('./mbtiles')(source, done); else if (source.url) require('./remote')(source, done); else throw new Error('Unknown source type'); }",
            "#file 4": "function logTileRequest(tile) { console.log(`Tile requested: ${tile[0]}, ${tile[1]}, ${tile[2]}`); } #New"
        }
    },
    {
        "repo": "Next-GraphQL-Blog",
        "content": "'Next-GraphQL-Blog/server/db/models/User.js'\n:import mongoose from 'mongoose'\n\nconst userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  // Don't return password unless specified to\n  password: {\n    type: String,\n    select: false\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User\n\n'Next-GraphQL-Blog/server/auth/google.js'\n:var passport = require('passport')\nvar GoogleStrategy = require('passport-google-oauth').OAuth2Strategy\nimport jwt from 'jsonwebtoken'\n\nconst dev = process.env.NODE_ENV !== 'production'\n\nimport User from '../db/models/User'\n\nexport default server => {\n  passport.use(\n    new GoogleStrategy(\n      {\n        clientID: process.env.GOOGLE_CLIENT_ID,\n        clientSecret: process.env.GOOGLE_SECRET_ID,\n        callbackURL: dev\n          ? `${process.env.ROOT_URL_DEV}/auth/googlecallback`\n          : `${process.env.ROOT_URL_PROD}/auth/googlecallback`\n      },\n      async (accessToken, refreshToken, profile, done) => {\n        const name =\n          profile.displayName || profile.name\n            ? `${profile.name.givenName} ${profile.name.familyName}`\n            : ''\n\n        const email =\n          (profile.emails &&\n            profile.emails.length > 0 &&\n            profile.emails[0].value) ||\n          null\n\n        const googleId = profile.id\n\n        try {\n          let user = await User.findOne({ googleId }).exec()\n\n          if (user) {\n            return done(null, user)\n          }\n\n          const emailExist = await User.findOne({ email }).exec()\n\n          if (emailExist) {\n            return done('Email already exists')\n          }\n\n          user = await User.create({\n            email,\n            name,\n            googleId\n          })\n\n          done(null, user)\n        } catch (err) {\n          console.log(err)\n          done(err)\n        }\n      }\n    )\n  )\n\n  passport.serializeUser((user, done) => {\n    done(null, user.id)\n  })\n\n  passport.deserializeUser((id, done) => {\n    User.findById({ _id: id }, (err, user) => {\n      done(err, user)\n    })\n  })\n\n  server.get('/auth/google', (req, res) => {\n    passport.authenticate('google', {\n      scope: ['profile', 'email'],\n      prompt: 'select_account'\n    })(req, res)\n  })\n\n  server.get(\n    '/auth/googlecallback',\n    passport.authenticate('google', {\n      session: false,\n      failureRedirect: dev\n        ? `${process.env.CLIENT_URL_DEV}/login`\n        : `${process.env.CLIENT_URL_PROD}/login`\n    }),\n    (req, res) => {\n      const token = jwt.sign({ userId: req.user._id }, process.env.AUTH_SECRET)\n      console.log(token)\n      res.redirect(\n        dev\n          ? `${process.env.CLIENT_URL_DEV}/authcallback?token=${token}`\n          : `${process.env.CLIENT_URL_PROD}/authcallback?token=${token}`\n      )\n    }\n  )\n}\n\n'Next-GraphQL-Blog/server/index.js'\n:require('dotenv').config()\n\nimport { GraphQLServer, PubSub } from 'graphql-yoga'\nimport cors from 'cors'\nimport cookieParser from 'cookie-parser'\nimport depthLimit from 'graphql-depth-limit'\nimport helmet from 'helmet'\nimport compression from 'compression'\n\nimport initGoogleAuth from './auth/google'\nimport passport from 'passport'\nimport resolvers from './resolvers'\nimport typeDefs from './types'\nimport db from './db'\nimport { initUser } from './utils'\nimport createLoaders from './loaders'\n\nconst dev = process.env.NODE_ENV !== 'production'\n\nconst startServer = async () => {\n  const initDB = await db()\n\n  const pubsub = new PubSub()\n\n  const server = new GraphQLServer({\n    typeDefs,\n    resolvers,\n    context: async req => ({\n      ...req,\n      pubsub,\n      loaders: createLoaders(),\n      user: initUser(req),\n      db: initDB\n    }),\n    validationRules: [depthLimit(10)]\n  })\n\n  server.express.use(compression())\n  server.express.use(helmet())\n  server.express.use(cookieParser())\n\n  const ONE_YEAR = 31556952000\n\n  if (!dev) {\n    server.express.set('trust proxy', 1)\n  }\n\n  server.express.use(passport.initialize())\n\n  initGoogleAuth(server.express)\n\n  const corsOptions = {\n    origin: dev ? process.env.CLIENT_URL_DEV : process.env.CLIENT_URL_PROD,\n    credentials: true\n  }\n\n  //option object for graphql yoga\n  const port = parseInt(process.env.PORT, 10) || 4000\n  const options = {\n    port,\n    cors: corsOptions\n  }\n\n  server.start(options, ({ port }) =>\n    console.log(\n      `Server started, listening on port ${port} for incoming requests. [${\n        process.env.NODE_ENV\n      }]`\n    )\n  )\n}\n\nstartServer()\n\n",
        "called_code_segment_file_1": "const userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  password: {\n    type: String,\n    select: false\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User",
        "invoking_code_segment_file_2": "const email = (profile.emails && profile.emails.length > 0 && profile.emails[0].value) || null\n\nconst googleId = profile.id\n\ntry {\n  let user = await User.findOne({ googleId }).exec()\n\n  if (user) {\n    return done(null, user)\n  }\n\n  const emailExist = await User.findOne({ email }).exec()\n\n  if (emailExist) {\n    return done('Email already exists')\n  }\n\n  user = await User.create({\n    email,\n    name,\n    googleId\n  })\n\n  done(null, user)\n} catch (err) {\n  console.log(err)\n  done(err)\n}",
        "invoking_code_segment_file_3": "const initUser = req => {\n  const token = req.cookies.token || req.headers.authorization\n  if (token) {\n    try {\n      const { userId } = jwt.verify(token, process.env.AUTH_SECRET)\n      return User.findById(userId).exec()\n    } catch (err) {\n      return null\n    }\n  }\n  return null\n}\n\nexport { initUser }",
        "new_file_code_segment": "const verifyUser = async (userId) => {\n  try {\n    const user = await User.findById(userId).exec()\n    return user ? true : false\n  } catch (err) {\n    console.log(err)\n    return false\n  }\n}\n\nexport { verifyUser }",
        "feature_description": "Add a feature to verify if a user exists by their userId.",
        "detailed_feature_description": "The new feature involves adding a function in a new file (#file 4) that verifies if a user exists by their userId. This function will be invoked in #file 1 to enhance the user verification process. #file 2 and #file 3 will be updated to use this new function where applicable.",
        "modified_complete_code": {
            "file_1": "const userSchema = new mongoose.Schema({\n  email: {\n    type: String,\n    required: true,\n    unique: true\n  },\n  createdAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  updatedAt: {\n    type: Date,\n    required: true,\n    default: Date.now\n  },\n  name: {\n    type: String,\n    required: true\n  },\n  googleId: {\n    type: String,\n    default: null\n  },\n  password: {\n    type: String,\n    select: false\n  }\n})\n\nconst User = mongoose.model('user', userSchema)\n\nexport default User\n\n#Modify\nimport { verifyUser } from './verifyUser'\n\nconst initUser = req => {\n  const token = req.cookies.token || req.headers.authorization\n  if (token) {\n    try {\n      const { userId } = jwt.verify(token, process.env.AUTH_SECRET)\n      return verifyUser(userId) ? User.findById(userId).exec() : null\n    } catch (err) {\n      return null\n    }\n  }\n  return null\n}\n\nexport { initUser }",
            "file_2": "const email = (profile.emails && profile.emails.length > 0 && profile.emails[0].value) || null\n\nconst googleId = profile.id\n\ntry {\n  let user = await User.findOne({ googleId }).exec()\n\n  if (user) {\n    return done(null, user)\n  }\n\n  const emailExist = await User.findOne({ email }).exec()\n\n  if (emailExist) {\n    return done('Email already exists')\n  }\n\n  user = await User.create({\n    email,\n    name,\n    googleId\n  })\n\n  done(null, user)\n} catch (err) {\n  console.log(err)\n  done(err)\n}\n\n#Modify\nimport { verifyUser } from './verifyUser'\n\nconst verifyAndCreateUser = async (email, name, googleId) => {\n  const emailExist = await User.findOne({ email }).exec()\n  if (emailExist) {\n    return 'Email already exists'\n  }\n  const user = await User.create({\n    email,\n    name,\n    googleId\n  })\n  return user\n}\n\nconst createUser = async (accessToken, refreshToken, profile, done) => {\n  const name = profile.displayName || profile.name ? `${profile.name.givenName} ${profile.name.familyName}` : ''\n  const email = (profile.emails && profile.emails.length > 0 && profile.emails[0].value) || null\n  const googleId = profile.id\n\n  try {\n    let user = await User.findOne({ googleId }).exec()\n    if (user) {\n      return done(null, user)\n    }\n    user = await verifyAndCreateUser(email, name, googleId)\n    done(null, user)\n  } catch (err) {\n    console.log(err)\n    done(err)\n  }\n}",
            "file_3": "const initUser = req => {\n  const token = req.cookies.token || req.headers.authorization\n  if (token) {\n    try {\n      const { userId } = jwt.verify(token, process.env.AUTH_SECRET)\n      return User.findById(userId).exec()\n    } catch (err) {\n      return null\n    }\n  }\n  return null\n}\n\nexport { initUser }\n\n#Modify\nimport { verifyUser } from './verifyUser'\n\nconst initUser = req => {\n  const token = req.cookies.token || req.headers.authorization\n  if (token) {\n    try {\n      const { userId } = jwt.verify(token, process.env.AUTH_SECRET)\n      return verifyUser(userId) ? User.findById(userId).exec() : null\n    } catch (err) {\n      return null\n    }\n  }\n  return null\n}\n\nexport { initUser }",
            "file_4": "#New\nconst verifyUser = async (userId) => {\n  try {\n    const user = await User.findById(userId).exec()\n    return user ? true : false\n  } catch (err) {\n    console.log(err)\n    return false\n  }\n}\n\nexport { verifyUser }"
        }
    },
    {
        "repo": "react-router-bootstrap",
        "content": "'react-router-bootstrap/src/LinkContainer.js'\n:import React from 'react';\nimport PropTypes from 'prop-types';\nimport { useHref, useLocation, useMatch, useNavigate } from 'react-router-dom';\n\nconst isModifiedEvent = (event) =>\n  !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n\nconst LinkContainer = ({\n  children,\n  onClick,\n  replace = false, // eslint-disable-line no-unused-vars\n  to,\n  state,\n  activeClassName = 'active',\n  className,\n  activeStyle,\n  style,\n  isActive: getIsActive,\n  // eslint-disable-next-line comma-dangle\n  ...props\n}) => {\n  const path = typeof to === 'object' ? to.pathname || '' : to;\n  const navigate = useNavigate();\n  const href = useHref(typeof to === 'string' ? { pathname: to } : to);\n  const match = useMatch(path);\n  const location = useLocation();\n  const child = React.Children.only(children);\n\n  const isActive = !!(getIsActive\n    ? typeof getIsActive === 'function'\n      ? getIsActive(match, location)\n      : getIsActive\n    : match);\n\n  const handleClick = (event) => {\n    if (children.props.onClick) {\n      children.props.onClick(event);\n    }\n\n    if (onClick) {\n      onClick(event);\n    }\n\n    if (\n      !event.defaultPrevented && // onClick prevented default\n      event.button === 0 && // ignore right clicks\n      !isModifiedEvent(event) // ignore clicks with modifier keys\n    ) {\n      event.preventDefault();\n\n      navigate(to, {\n        replace,\n        state,\n      });\n    }\n  };\n\n  return React.cloneElement(child, {\n    ...props,\n    className: [\n      className,\n      child.props.className,\n      isActive ? activeClassName : null,\n    ]\n      .join(' ')\n      .trim(),\n    style: isActive ? { ...style, ...activeStyle } : style,\n    href,\n    onClick: handleClick,\n  });\n};\n\nLinkContainer.propTypes = {\n  children: PropTypes.element.isRequired,\n  onClick: PropTypes.func,\n  replace: PropTypes.bool,\n  to: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,\n  state: PropTypes.object,\n  className: PropTypes.string,\n  activeClassName: PropTypes.string,\n  style: PropTypes.objectOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  activeStyle: PropTypes.objectOf(\n    PropTypes.oneOfType([PropTypes.string, PropTypes.number]),\n  ),\n  isActive: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),\n};\n\nexport default LinkContainer;\n\n'react-router-bootstrap/test/visual/ListGroupItemVisual.js'\n:import React from 'react';\nimport ListGroup from 'react-bootstrap/ListGroup';\nimport ListGroupItem from 'react-bootstrap/ListGroupItem';\nimport { Link } from 'react-router-dom';\n\nimport LinkContainer from '../../src/LinkContainer';\n\nexport default () => (\n  <div>\n    <Link to=\"/home\">Back to Index</Link>\n    <h2>ListGroupItem</h2>\n\n    <h3>Baseline</h3>\n    <ListGroup>\n      <ListGroupItem href=\"#/home\" active header=\"ListGroupItem 1 Heading\">\n        ListGroupItem 1 content\n      </ListGroupItem>\n      <ListGroupItem header=\"ListGroupItem 2 Heading\">\n        ListGroupItem 2 content\n      </ListGroupItem>\n      <ListGroupItem disabled>\n        ListGroupItem 3 content disabled\n      </ListGroupItem>\n      <ListGroupItem variant=\"success\">\n        ListGroupItem 4 content success\n      </ListGroupItem>\n      <ListGroupItem variant=\"info\">\n        ListGroupItem 5 content info\n      </ListGroupItem>\n      <ListGroupItem variant=\"warning\">\n        ListGroupItem 6 content warning\n      </ListGroupItem>\n      <ListGroupItem variant=\"danger\">\n        ListGroupItem 7 content danger\n      </ListGroupItem>\n    </ListGroup>\n\n    <h3>LinkContainer</h3>\n    <ListGroup>\n      <LinkContainer to=\"/list-group-item\">\n        <ListGroupItem header=\"ListGroupItem 1 Heading\">\n          ListGroupItem 1 content\n        </ListGroupItem>\n      </LinkContainer>\n      <LinkContainer to=\"/home\">\n        <ListGroupItem header=\"ListGroupItem 2 Heading\">\n          ListGroupItem 2 content\n        </ListGroupItem>\n      </LinkContainer>\n      <LinkContainer to=\"/home\" disabled>\n        <ListGroupItem>\n          ListGroupItem 3 content disabled\n        </ListGroupItem>\n      </LinkContainer>\n      <LinkContainer to=\"/home\">\n        <ListGroupItem variant=\"success\">\n          ListGroupItem 4 content success\n        </ListGroupItem>\n      </LinkContainer>\n      <LinkContainer to=\"/home\">\n        <ListGroupItem variant=\"info\">\n          ListGroupItem 5 content info\n        </ListGroupItem>\n      </LinkContainer>\n      <LinkContainer to=\"/home\">\n        <ListGroupItem variant=\"warning\">\n          ListGroupItem 6 content warning\n        </ListGroupItem>\n      </LinkContainer>\n      <LinkContainer to=\"/home\">\n        <ListGroupItem variant=\"danger\">\n          ListGroupItem 7 content danger\n        </ListGroupItem>\n      </LinkContainer>\n    </ListGroup>\n  </div>\n);\n\n'react-router-bootstrap/test/visual/index.js'\n:import React, { useEffect } from 'react';\nimport Container from 'react-bootstrap/Container';\nimport ReactDOM from 'react-dom';\nimport { useLocation, useNavigate } from 'react-router';\nimport { HashRouter as Router, Route, Routes } from 'react-router-dom';\n\nimport ButtonVisual from './ButtonVisual';\nimport Home from './Home';\nimport ListGroupItemVisual from './ListGroupItemVisual';\nimport MenuItemVisual from './MenuItemVisual';\nimport NavItemVisual from './NavItemVisual';\n\nimport 'bootstrap/dist/css/bootstrap.css';\n\nconst mountNode = document.createElement('div');\ndocument.body.appendChild(mountNode);\n\nconst App = () => {\n  const location = useLocation();\n  const navigate = useNavigate();\n  useEffect(() => {\n    if (location.pathname === '/') {\n      navigate('/home');\n    }\n  }, [location, navigate]);\n  return (\n    <Container>\n      <h1>React-Router-Bootstrap Module Visual Test</h1>\n\n      <Routes>\n        <Route path=\"/home\" element={<Home />} />\n        <Route path=\"/button\" element={<ButtonVisual />} />\n        <Route path=\"/nav-item\" element={<NavItemVisual />} />\n        <Route path=\"/menu-item\" element={<MenuItemVisual />} />\n        <Route path=\"/list-group-item\" element={<ListGroupItemVisual />} />\n      </Routes>\n    </Container>\n  );\n};\n\nReactDOM.render(\n  <Router>\n    <App />\n  </Router>,\n  mountNode,\n);\n\n",
        "called_code_segment_file_1": "const handleClick = (event) => {\n  if (children.props.onClick) {\n    children.props.onClick(event);\n  }\n\n  if (onClick) {\n    onClick(event);\n  }\n\n  if (\n    !event.defaultPrevented &&\n    event.button === 0 &&\n    !isModifiedEvent(event)\n  ) {\n    event.preventDefault();\n\n    navigate(to, {\n      replace,\n      state,\n    });\n  }\n};",
        "invoking_code_segment_file_2": "<LinkContainer to=\"/list-group-item\">\n  <ListGroupItem header=\"ListGroupItem 1 Heading\">\n    ListGroupItem 1 content\n  </ListGroupItem>\n</LinkContainer>",
        "invoking_code_segment_file_3": "<LinkContainer to=\"/home\">\n  <ListGroupItem header=\"ListGroupItem 2 Heading\">\n    ListGroupItem 2 content\n  </ListGroupItem>\n</LinkContainer>",
        "new_file_code_segment": "const handleCustomClick = (event, customData) => {\n  console.log('Custom click handler with data:', customData);\n  // Additional custom logic can be added here\n};\n\nexport default handleCustomClick;",
        "feature_description": "Add a custom click handler with additional data",
        "detailed_feature_description": "The new feature allows for a custom click handler that can accept additional data. This handler will be invoked instead of the default handleClick in LinkContainer. The new file (#file 4) contains the custom click handler logic, which is then integrated into LinkContainer in #file 1. The invoking files (#file 2 and #file 3) are updated to pass the custom data to the new handler.",
        "modified_complete_code": {
            "#file 1": "const handleClick = (event, customData) => {\n  if (children.props.onClick) {\n    children.props.onClick(event);\n  }\n\n  if (onClick) {\n    onClick(event);\n  }\n\n  if (\n    !event.defaultPrevented &&\n    event.button === 0 &&\n    !isModifiedEvent(event)\n  ) {\n    event.preventDefault();\n\n    navigate(to, {\n      replace,\n      state,\n    });\n  }\n\n  // New: Invoke custom click handler with additional data\n  handleCustomClick(event, customData);\n};",
            "#file 2": "<LinkContainer to=\"/list-group-item\" customData=\"Custom Data 1\">\n  <ListGroupItem header=\"ListGroupItem 1 Heading\">\n    ListGroupItem 1 content\n  </ListGroupItem>\n</LinkContainer>",
            "#file 3": "<LinkContainer to=\"/home\" customData=\"Custom Data 2\">\n  <ListGroupItem header=\"ListGroupItem 2 Heading\">\n    ListGroupItem 2 content\n  </ListGroupItem>\n</LinkContainer>",
            "#file 4": "const handleCustomClick = (event, customData) => {\n  console.log('Custom click handler with data:', customData);\n  // Additional custom logic can be added here\n};\n\nexport default handleCustomClick;"
        }
    },
    {
        "repo": "stresser",
        "content": "'stresser/helpers.js'\n:'use strict';\nconst range = require('node-range');\nconst pad = require('pad');\nconst helpers = {};\n\nArray.prototype.trim = function(proc) {\n    const newArr = [];\n    for (let i = 0; i < this.length * proc; i++) {\n        newArr.push(this[i]);\n    }\n    return newArr;\n};\n\n\nhelpers.std = (arr)=> {\n    arr = arr.sort();\n\n    let left = arr.trim(0.5);\n    let right = arr.reverse().trim(0.5);\n\n    const leftCnt = left.length;\n    const rightCnt = right.length;\n\n    const leftMean = helpers.avg(left);\n    const rightMean = helpers.avg(right);\n\n    left = left.map(val => Math.pow(Math.abs(leftMean - val), 2));\n    right = right.map(val => Math.pow(Math.abs(rightMean - val), 2));\n\n    left = helpers.sum(left) / leftCnt;\n    right = helpers.sum(right) / rightCnt;\n\n    left = Math.sqrt(left);\n    right = Math.sqrt(right);\n\n    return {\n        left,\n        right,\n    }\n};\n\nhelpers.max = (arr) => {\n    let max = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (max < arr[i]) {\n            max = arr[i];\n        }\n    }\n    return max;\n};\nhelpers.min = (arr) => {\n    let min = Infinity;\n    for (let i = 0; i < arr.length; i++) {\n        if (min > arr[i]) {\n            min = arr[i];\n        }\n    }\n    return min;\n};\n\nhelpers.avg = (arr) => {\n    return helpers.sum(arr) / arr.length;\n};\n\nhelpers.sum = (arr) => {\n    return arr.reduce((sum, val) => sum + val);\n};\n\nhelpers.outputTime = (arr, proc) => {\n    arr = arr.trim(proc);\n    const std = helpers.std(arr);\n\n    const str = [\n        'time @ ', pad(3, proc * 100), '%', '|',\n        'min:', helpers.min(arr) | 0,\n        'left std:', std.left | 0,\n        'mean:', helpers.avg(arr) | 0,\n        'right std:', std.right | 0, '|',\n        'max:', helpers.max(arr) | 0\n    ].join(' ');\n    console.log(str);\n\n    return str;\n};\n\nmodule.exports = helpers;\n'stresser/master.js'\n:'use strict';\nconst cluster = require('cluster');\nconst workers = Object.keys(cluster.workers);\n\nconst range = require('node-range');\nconst pad = require('pad');\n\nconst helpers = require('./helpers');\nconst display = require('./display');\n\nconst config = require('./config');\n\nconst amount = config.count;\n\nlet _statsForSecond = null;\nconst resetStats = () => {\n    _statsForSecond = {\n        code: {\n            '1': 0,\n            '2': 0,\n            '3': 0,\n            '4': 0,\n            '5': 0\n        },\n        err: 0,\n        to: 0,\n        body: 0,\n\n        cnt: 0,\n        time: 0,\n        min: Infinity,\n        max: 0\n    }\n};\nresetStats();\n\nconst SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};\n\nlet _RAW_CNT = 0;\nconst RAW = (data) => {\n    data.forEach((req) => _requests.push(req));\n    _RAW_CNT++;\n    if (_RAW_CNT % workers.length === 0) {\n        _finish();\n    }\n};\n\nlet _STATS_CNT = 0;\nconst STATS = (data, reqCnt) => {\n    _statsForSecond.err += data.err;\n    _statsForSecond.to += data.to;\n    _statsForSecond.body += data.body;\n    _statsForSecond.cnt += data.cnt;\n    _statsForSecond.time += data.time;\n\n    _statsForSecond.min = Math.min(_statsForSecond.min, data.min);\n    _statsForSecond.max = Math.max(_statsForSecond.max, data.max);\n\n    for (let i = 1; i <= 5; i++) {\n        _statsForSecond.code[i.toString()] += data.code[i.toString()];\n    }\n\n    _requestCountActive += reqCnt;\n\n    _STATS_CNT++;\n    if (_STATS_CNT % workers.length === 0) {\n        printStats(_statsForSecond);\n\n        _second++;\n\n        const somethingLeft = (\n            _statsForSecond.cnt === 0 &&\n            _statsForSecond.err === 0 &&\n            _statsForSecond.to === 0 &&\n            _requestCountActive === 0\n        );\n\n        const forceStop = (\n            config.force &&\n            _second > config.count\n        );\n\n        if (\n            somethingLeft || forceStop\n        ) {\n            SEND('raw');\n        } else {\n            _secondHistory.push(Object.assign({}, _statsForSecond, { active: _requestCountActive }));\n            setTimeout(_doWork, 1000);\n        }\n\n        resetStats();\n        _requestCountActive = 0;\n    }\n};\n\n\nworkers\n    .map(wid => cluster.workers[wid])\n    .forEach(worker => {\n        worker.on('message', (msg) => {\n            switch (msg.type) {\n                case 'stats':\n                    STATS(msg.data, msg.req);\n                    break;\n                case 'raw':\n                    RAW(msg.data);\n                    break;\n            }\n        })\n    });\n\nconst _requests = [];\nlet _requestCountActive = 0;\nlet _second = 0;\nconst _secondHistory = [];\n\nconst printStats = (stats, finish) => {\n    let str = (\n        `  S=${pad(6, _second)} |   T=${pad(6, stats.cnt + stats.to + stats.err)} | A=${pad(6, _requestCountActive)}\n  E=${pad(6, stats.err)} | T/O=${pad(6, stats.to)} | \\\nW/B=${pad(6, stats.body)} | AVG=${pad(6, (stats.time / stats.cnt) | 0)} | MIN=${pad(6, stats.min)} | MAX=${pad(6, stats.max)}\n${range(1, 6).map(code => `${code}xx=${pad(6, stats.code[code.toString()])}`).join(' | ')}\n`);\n\n    const howManyReq = config.concurrentPerCPU * config.CPUs * config.count;\n    const howManyDone = stats.cnt + stats.err + stats.to;\n    if (finish && howManyDone < howManyReq) {\n        str += `NOT FINISHED=${pad(6, howManyReq - howManyDone)}\n`;\n    }\n\n    console.error(str);\n    return str;\n};\n\nconst _finish = () => {\n    workers.forEach(worker => cluster.workers[worker].kill());\n\n    const stats = {\n        code: {\n            '1': 0,\n            '2': 0,\n            '3': 0,\n            '4': 0,\n            '5': 0\n        },\n        err: 0,\n        to: 0,\n        body: 0,\n\n        cnt: 0,\n        time: 0,\n        min: Infinity,\n        max: 0\n    };\n    _requests.forEach(req => {\n        stats.to += req.to;\n        stats.err += req.err;\n        stats.body += req.body;\n\n        stats.code[req.code.toString()[0]]++;\n\n        if (req.time) {\n            stats.time += req.time;\n            stats.cnt++;\n\n            if (req.time < stats.min) {\n                stats.min = req.time;\n            }\n            if (req.time > stats.max) {\n                stats.max = req.time;\n            }\n        }\n    });\n\n    console.error('~~~ Aggregated Stats: ~~~');\n\n    const statsStr = printStats(stats, true);\n\n    if (config.html) {\n        display(config.html, _requests, statsStr, _secondHistory, config.url);\n    }\n\n    setTimeout(() => process.exit(0), 100);\n};\n\nconst _doWork = () => {\n    if (_second < amount) {\n        _requestCountActive += config.concurrentPerCPU * workers.length;\n        SEND('req', _second);\n    }\n\n    SEND('stats');\n};\n\n_doWork();\n'stresser/index.js'\n:#!/usr/bin/env node\n'use strict';\nconst cluster = require('cluster');\n\nif (cluster.isMaster) {\n    const config = require('./config');\n\n    console.error('Booting up', config.CPUs, 'workers');\n    let online = 0;\n    for (let i = 0; i < config.CPUs; i++) {\n        const worker = cluster.fork();\n        worker.on('online', () => {\n            online++;\n\n            setTimeout(() => {\n                worker.send({ type: 'setup', data: config });\n\n                if (online === config.CPUs) {\n                    return setTimeout(() => require('./master'), 100);\n                }\n            }, 100);\n        });\n    }\n\n    return;\n}\n\nreturn require('./worker');\n",
        "called_code_segment_file_1": "const _doWork = () => {\n    if (_second < amount) {\n        _requestCountActive += config.concurrentPerCPU * workers.length;\n        SEND('req', _second);\n    }\n\n    SEND('stats');\n};",
        "invoking_code_segment_file_2": "worker.on('message', (msg) => {\n    switch (msg.type) {\n        case 'stats':\n            STATS(msg.data, msg.req);\n            break;\n        case 'raw':\n            RAW(msg.data);\n            break;\n    }\n})",
        "invoking_code_segment_file_3": "const SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};",
        "new_file_code_segment": "const newFeature = () => {\n    console.log('New feature invoked');\n    // Additional functionality can be added here\n};\n\nmodule.exports = newFeature;",
        "feature_description": "Add a new feature to log additional information when a request is processed.",
        "detailed_feature_description": "The new feature involves adding a logging mechanism to the existing request processing workflow. This will be implemented in a new file (#file 4) and will be invoked from #file 1. The changes in #file 1 will ensure that the new feature is integrated seamlessly with the existing code. #file 2 and #file 3 will remain unchanged as they do not directly interact with the new feature.",
        "modified_complete_code": {
            "#file 1": "#Modify\nconst _doWork = () => {\n    if (_second < amount) {\n        _requestCountActive += config.concurrentPerCPU * workers.length;\n        SEND('req', _second);\n    }\n\n    SEND('stats');\n    newFeature(); // #New: Invoke new feature\n};",
            "#file 2": "worker.on('message', (msg) => {\n    switch (msg.type) {\n        case 'stats':\n            STATS(msg.data, msg.req);\n            break;\n        case 'raw':\n            RAW(msg.data);\n            break;\n    }\n})",
            "#file 3": "const SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};",
            "#file 4": "const newFeature = () => {\n    console.log('New feature invoked');\n    // Additional functionality can be added here\n};\n\nmodule.exports = newFeature;"
        }
    },
    {
        "repo": "wifi-card",
        "content": "'wifi-card/src/components/Settings.js'\n:import {\n  Checkbox,\n  Pane,\n  RadioGroup,\n  SelectField,\n  TextInputField,\n} from 'evergreen-ui';\nimport { useEffect } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport i18n from '../i18n';\nimport { Translations } from '../translations';\nimport './style.css';\n\nexport const Settings = (props) => {\n  const { t } = useTranslation();\n  const encryptionModes = [\n    { label: t('wifi.password.encryption.none'), value: '' },\n    { label: 'WPA/WPA2/WPA3', value: 'WPA' },\n    { label: 'WPA2-EAP', value: 'WPA2-EAP' },\n    { label: 'WEP', value: 'WEP' },\n  ];\n  const eapMethods = [{ label: 'PWD', value: 'PWD' }];\n  const langSelectDefaultValue = () => {\n    const t = Translations.filter((t) => t.id === i18n.language);\n    if (t.length !== 1) {\n      return 'en-US';\n    }\n    return t[0].id;\n  };\n\n  useEffect(() => {\n    if (props.firstLoad.current && window.innerWidth < 500) {\n      props.onFirstLoad();\n      props.onOrientationChange(true);\n    }\n  });\n\n  return (\n    <Pane id=\"settings\" maxWidth={props.settings.portrait ? '350px' : '100%'}>\n      <SelectField\n        width={300}\n        inputHeight={38}\n        label={t('select')}\n        onChange={(e) => props.onLanguageChange(e.target.value)}\n        defaultValue={langSelectDefaultValue()}\n      >\n        {Translations.map((t) => (\n          <option key={t.id} value={t.id}>\n            {t.name}\n          </option>\n        ))}\n      </SelectField>\n\n      <Checkbox\n        label={t('button.rotate')}\n        checked={props.settings.portrait}\n        onChange={() => props.onOrientationChange(!props.settings.portrait)}\n      />\n      <Checkbox\n        label={t('wifi.password.hide')}\n        checked={props.settings.hidePassword}\n        onChange={() =>\n          props.onHidePasswordChange(!props.settings.hidePassword)\n        }\n      />\n      <Checkbox\n        label={t('wifi.name.hiddenSSID')}\n        checked={props.settings.hiddenSSID}\n        onChange={() => props.onHiddenSSIDChange(!props.settings.hiddenSSID)}\n      />\n\n      <Checkbox\n        label={t('cards.tip.hide')}\n        checked={props.settings.hideTip}\n        onChange={() => props.onHideTipChange(!props.settings.hideTip)}\n      />\n      <TextInputField\n        type=\"number\"\n        width={300}\n        label={t('cards.additional')}\n        value={props.settings.additionalCards}\n        onChange={(e) => props.onAdditionalCardsChange(e.target.value)}\n      />\n      <RadioGroup\n        label={t('wifi.password.encryption')}\n        size={16}\n        value={props.settings.encryptionMode}\n        options={encryptionModes}\n        onChange={(e) => props.onEncryptionModeChange(e.target.value)}\n      />\n      <RadioGroup\n        label={t('wifi.encryption.eapMethod')}\n        size={16}\n        value={props.settings.eapMethod}\n        options={eapMethods}\n        className={`\n          ${props.settings.encryptionMode !== 'WPA2-EAP' && 'hidden'}\n        `}\n        onChange={(e) => props.onEapMethodChange(e.target.value)}\n      />\n    </Pane>\n  );\n};\n\n'wifi-card/src/App.js'\n:import { Button, Heading, Link, Pane, Paragraph } from 'evergreen-ui';\nimport React, { useEffect, useRef, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport logo from '../src/images/wifi.png';\nimport { Settings } from './components/Settings';\nimport { WifiCard } from './components/WifiCard';\nimport './style.css';\nimport { Translations } from './translations';\n\nfunction App() {\n  const html = document.querySelector('html');\n  const { t, i18n } = useTranslation();\n  const firstLoad = useRef(true);\n  const [settings, setSettings] = useState({\n    // Network SSID name\n    ssid: '',\n    // Network password\n    password: '',\n    // Settings: Network encryption mode\n    encryptionMode: 'WPA',\n    // Settings: EAP Method\n    eapMethod: 'PWD',\n    // Settings: EAP identity\n    eapIdentity: '',\n    // Settings: Hide password on the printed card\n    hidePassword: false,\n    // Settings: Mark your network as hidden SSID\n    hiddenSSID: false,\n    // Settings: Portrait orientation\n    portrait: false,\n    // Settings: Additional cards\n    additionalCards: 0,\n    // Settings: Show tip (legend) on card\n    hideTip: false,\n  });\n  const [errors, setErrors] = useState({\n    ssidError: '',\n    passwordError: '',\n    eapIdentityError: '',\n  });\n\n  const htmlDirection = (languageID) => {\n    languageID = languageID || i18n.language;\n    const rtl = Translations.filter((t) => t.id === languageID)[0]?.rtl;\n    return rtl ? 'rtl' : 'ltr';\n  };\n\n  const onChangeLanguage = (language) => {\n    html.style.direction = htmlDirection(language);\n    i18n.changeLanguage(language);\n  };\n\n  const onPrint = () => {\n    if (!settings.ssid.length) {\n      setErrors({\n        ...errors,\n        ssidError: t('wifi.alert.name'),\n      });\n      return;\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.8'),\n      });\n      return;\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.5'),\n      });\n      return;\n    }\n    if (\n      settings.password.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password'),\n      });\n      return;\n    }\n    if (\n      settings.eapIdentity.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        eapIdentityError: t('wifi.alert.eapIdentity'),\n      });\n      return;\n    }\n    document.title = 'WiFi Card - ' + settings.ssid;\n    window.print();\n  };\n\n  const onSSIDChange = (ssid) => {\n    setErrors({ ...errors, ssidError: '' });\n    setSettings({ ...settings, ssid });\n  };\n  const onPasswordChange = (password) => {\n    setErrors({ ...errors, passwordError: '' });\n    setSettings({ ...settings, password });\n  };\n  const onEncryptionModeChange = (encryptionMode) => {\n    setErrors({ ...errors, passwordError: '' });\n    setSettings({ ...settings, encryptionMode });\n  };\n  const onEapMethodChange = (eapMethod) => {\n    setSettings({ ...settings, eapMethod });\n  };\n  const onEapIdentityChange = (eapIdentity) => {\n    setErrors({ ...errors, eapIdentityError: '' });\n    setSettings({ ...settings, eapIdentity });\n  };\n  const onOrientationChange = (portrait) => {\n    setSettings({ ...settings, portrait });\n  };\n  const onHidePasswordChange = (hidePassword) => {\n    setSettings({ ...settings, hidePassword });\n  };\n  const onHiddenSSIDChange = (hiddenSSID) => {\n    setSettings({ ...settings, hiddenSSID });\n  };\n  const onAdditionalCardsChange = (additionalCardsStr) => {\n    const amount = parseInt(additionalCardsStr);\n    amount >= 0 && setSettings({ ...settings, additionalCards: amount });\n  };\n  const onHideTipChange = (hideTip) => {\n    setSettings({ ...settings, hideTip });\n  };\n  const onFirstLoad = () => {\n    html.style.direction = htmlDirection();\n    firstLoad.current = false;\n  };\n\n  useEffect(() => {\n    // Ensure the page direction is set properly on first load\n    if (htmlDirection() === 'rtl') {\n      html.style.direction = 'rtl';\n    }\n  });\n\n  return (\n    <Pane>\n      <Pane display=\"flex\">\n        <img alt=\"icon\" src={logo} width=\"32\" height=\"32\" />\n        <Heading size={900} paddingRight={16} paddingLeft={16}>\n          {t('title')}\n        </Heading>\n      </Pane>\n\n      <Pane>\n        <Paragraph marginTop={12}>{t('desc.use')}</Paragraph>\n\n        <Paragraph marginTop={12}>\n          {t('desc.privacy')}{' '}\n          <Link href=\"https://github.com/bndw/wifi-card\">\n            {t('desc.source')}\n          </Link>\n          .\n        </Paragraph>\n      </Pane>\n\n      <Pane>\n        <WifiCard\n          settings={settings}\n          ssidError={errors.ssidError}\n          passwordError={errors.passwordError}\n          eapIdentityError={errors.eapIdentityError}\n          onSSIDChange={onSSIDChange}\n          onEapIdentityChange={onEapIdentityChange}\n          onPasswordChange={onPasswordChange}\n        />\n      </Pane>\n\n      <Settings\n        settings={settings}\n        firstLoad={firstLoad}\n        onFirstLoad={onFirstLoad}\n        onLanguageChange={onChangeLanguage}\n        onEncryptionModeChange={onEncryptionModeChange}\n        onEapMethodChange={onEapMethodChange}\n        onOrientationChange={onOrientationChange}\n        onHidePasswordChange={onHidePasswordChange}\n        onHiddenSSIDChange={onHiddenSSIDChange}\n        onAdditionalCardsChange={onAdditionalCardsChange}\n        onHideTipChange={onHideTipChange}\n      />\n\n      <Button\n        id=\"print\"\n        appearance=\"primary\"\n        height={40}\n        marginRight={16}\n        onClick={onPrint}\n      >\n        {t('button.print')}\n      </Button>\n      <Pane id=\"print-area\">\n        {settings.additionalCards >= 0 &&\n          [...Array(settings.additionalCards + 1)].map((el, idx) => (\n            <WifiCard\n              key={`card-nr-${idx}`}\n              settings={settings}\n              ssidError={errors.ssidError}\n              passwordError={errors.passwordError}\n              eapIdentityError={errors.eapIdentityError}\n              onSSIDChange={onSSIDChange}\n              onEapIdentityChange={onEapIdentityChange}\n              onPasswordChange={onPasswordChange}\n            />\n          ))}\n      </Pane>\n    </Pane>\n  );\n}\n\nexport default App;\n\n'wifi-card/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport './i18n';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n",
        "called_code_segment_file_1": "const onPrint = () => {\n    if (!settings.ssid.length) {\n      setErrors({\n        ...errors,\n        ssidError: t('wifi.alert.name'),\n      });\n      return;\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.8'),\n      });\n      return;\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.5'),\n      });\n      return;\n    }\n    if (\n      settings.password.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password'),\n      });\n      return;\n    }\n    if (\n      settings.eapIdentity.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        eapIdentityError: t('wifi.alert.eapIdentity'),\n      });\n      return;\n    }\n    document.title = 'WiFi Card - ' + settings.ssid;\n    window.print();\n  };",
        "invoking_code_segment_file_2": "<Button\n        id=\"print\"\n        appearance=\"primary\"\n        height={40}\n        marginRight={16}\n        onClick={onPrint}\n      >\n        {t('button.print')}\n      </Button>",
        "invoking_code_segment_file_3": "const onPrint = () => {\n    if (!settings.ssid.length) {\n      setErrors({\n        ...errors,\n        ssidError: t('wifi.alert.name'),\n      });\n      return;\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.8'),\n      });\n      return;\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.5'),\n      });\n      return;\n    }\n    if (\n      settings.password.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password'),\n      });\n      return;\n    }\n    if (\n      settings.eapIdentity.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        eapIdentityError: t('wifi.alert.eapIdentity'),\n      });\n      return;\n    }\n    document.title = 'WiFi Card - ' + settings.ssid;\n    window.print();\n  };",
        "new_file_code_segment": "const saveToPDF = () => {\n    const input = document.getElementById('print-area');\n    html2canvas(input)\n      .then((canvas) => {\n        const imgData = canvas.toDataURL('image/png');\n        const pdf = new jsPDF();\n        pdf.addImage(imgData, 'PNG', 0, 0);\n        pdf.save('wifi-card.pdf');\n      });\n  };",
        "feature_description": "Add a feature to save the WiFi card as a PDF.",
        "detailed_feature_description": "The new feature allows users to save the WiFi card as a PDF. This is implemented by capturing the print area using html2canvas and then converting it to a PDF using jsPDF. The saveToPDF function is added to the App component and invoked when the user clicks a new button labeled 'Save as PDF'.",
        "modified_complete_code": {
            "file_1": "const onPrint = () => {\n    if (!settings.ssid.length) {\n      setErrors({\n        ...errors,\n        ssidError: t('wifi.alert.name'),\n      });\n      return;\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.8'),\n      });\n      return;\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.5'),\n      });\n      return;\n    }\n    if (\n      settings.password.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password'),\n      });\n      return;\n    }\n    if (\n      settings.eapIdentity.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        eapIdentityError: t('wifi.alert.eapIdentity'),\n      });\n      return;\n    }\n    document.title = 'WiFi Card - ' + settings.ssid;\n    window.print();\n  };\n\n  #Modify\n  const saveToPDF = () => {\n    const input = document.getElementById('print-area');\n    html2canvas(input)\n      .then((canvas) => {\n        const imgData = canvas.toDataURL('image/png');\n        const pdf = new jsPDF();\n        pdf.addImage(imgData, 'PNG', 0, 0);\n        pdf.save('wifi-card.pdf');\n      });\n  };",
            "file_2": "<Button\n        id=\"print\"\n        appearance=\"primary\"\n        height={40}\n        marginRight={16}\n        onClick={onPrint}\n      >\n        {t('button.print')}\n      </Button>\n\n      #New\n      <Button\n        id=\"save-pdf\"\n        appearance=\"primary\"\n        height={40}\n        marginRight={16}\n        onClick={saveToPDF}\n      >\n        {t('button.save_pdf')}\n      </Button>",
            "file_3": "const onPrint = () => {\n    if (!settings.ssid.length) {\n      setErrors({\n        ...errors,\n        ssidError: t('wifi.alert.name'),\n      });\n      return;\n    }\n    if (settings.password.length < 8 && settings.encryptionMode === 'WPA') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.8'),\n      });\n      return;\n    }\n    if (settings.password.length < 5 && settings.encryptionMode === 'WEP') {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password.length.5'),\n      });\n      return;\n    }\n    if (\n      settings.password.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        passwordError: t('wifi.alert.password'),\n      });\n      return;\n    }\n    if (\n      settings.eapIdentity.length < 1 &&\n      settings.encryptionMode === 'WPA2-EAP'\n    ) {\n      setErrors({\n        ...errors,\n        eapIdentityError: t('wifi.alert.eapIdentity'),\n      });\n      return;\n    }\n    document.title = 'WiFi Card - ' + settings.ssid;\n    window.print();\n  };\n\n  #Modify\n  const saveToPDF = () => {\n    const input = document.getElementById('print-area');\n    html2canvas(input)\n      .then((canvas) => {\n        const imgData = canvas.toDataURL('image/png');\n        const pdf = new jsPDF();\n        pdf.addImage(imgData, 'PNG', 0, 0);\n        pdf.save('wifi-card.pdf');\n      });\n  };",
            "file_4": "const saveToPDF = () => {\n    const input = document.getElementById('print-area');\n    html2canvas(input)\n      .then((canvas) => {\n        const imgData = canvas.toDataURL('image/png');\n        const pdf = new jsPDF();\n        pdf.addImage(imgData, 'PNG', 0, 0);\n        pdf.save('wifi-card.pdf');\n      });\n  };"
        }
    },
    {
        "repo": "imgsible",
        "content": "'imgsible/app/server/errors.js'\n:function genErr(res, code, msg) {\n  res.format({\n    html: function() {\n      res.sendfile('public/errors/' + code + '.html');\n    },\n\n    json: function() {\n      res.json(code, {\n        error: true,\n        status: code,\n        message: message\n      });\n    }\n  });\n}\n\nmodule.exports = {\n  notFound: function(res) {\n    genErr(res, 404, 'Not found');\n  },\n\n  genericError: function(res) {\n    genErr(res, 500, 'Internal server error');\n  }\n};\n\n'imgsible/app/server/web.js'\n:var fs = require('fs');\n\nvar Q = require('q');\nvar React = require('react');\n\nvar AppDispatcher = require('../client/dispatchers/app_dispatcher.js');\nvar ApplicationView = require('../client/components/application_view.jsx');\nvar errors = require('./errors');\nvar ImageActions = require('../client/actions/image_actions.js');\nvar ImageDb = require('./databases/image_db.js');\nvar ImageStore = require('../client/stores/image_store.js');\nvar RouteActions = require('../client/actions/route_actions.js');\nvar RouteStore = require('../client/stores/route_store.js');\n\nvar mimeTypes = {\n  jpg: 'image/jpeg',\n  gif: 'image/gif',\n  png: 'image/png'\n};\n\nmodule.exports = function(app, db) {\n  function createDispatcher() {\n    var dispatcher = new AppDispatcher();\n    dispatcher.register(new ImageStore(ImageDb(db)));\n    dispatcher.register(new RouteStore());\n    return dispatcher;\n  }\n\n  app.get('/', function(req, res) {\n    var dispatcher = createDispatcher();\n\n    var promise = dispatcher.dispatch(RouteActions.setUrlFromRequest(req.url)).then(function(state) {\n      return dispatcher.dispatch(ImageActions.loadIndex(null, 'date', state.route.params.sortdir));\n    });\n\n    promise.then(function(state) {\n      var html =  React.renderComponentToString(ApplicationView({preloadData: state, dispatcher: dispatcher}));\n      res.render('index', {app: html, preloadData: state});\n      dispatcher.destroy();\n    });\n  });\n\n  app.get('/image/:img', function(req, res) {\n    var dispatcher = createDispatcher();\n\n    var promise = dispatcher.dispatch(RouteActions.setUrlFromRequest(req.url)).then(function() {\n      return dispatcher.dispatch(ImageActions.loadImage(req.params.img));\n    });\n\n    promise.then(function(state) {\n      var html =  React.renderComponentToString(ApplicationView({preloadData: state, dispatcher: dispatcher}));\n      res.render('index', {app: html, preloadData: state});\n      dispatcher.destroy();\n    });\n  });\n\n  app.get(/^\\/i\\/(\\w+)(-t)?.(jpg|jpeg|gif|png)/, function(req, res) {\n    var id = req.params[0];\n    var thumb = req.params[1];\n    Q.nfcall(db.hgetall.bind(db), 'img:' + id).then(function(reply) {\n      if (!reply) {\n        errors.notFound(res);\n      } else {\n        var fname = thumb ? id + '_thumb.jpg' : id;\n        res.header('Content-Type', mimeTypes[reply.type]);\n        res.header('ETag', thumb ? id + '-t' : id);\n\n        if (req.fresh) {\n          res.send(304);\n        } else {\n          fs.createReadStream(app.get('uploadDir') + '/' + fname).pipe(res);\n        }\n      }\n    }, function(reason) {\n      console.error('Error in web/i');\n      console.error(reason);\n      errors.genericError(res);\n    });\n  });\n};\n\n'imgsible/index.js'\n:require('node-jsx').install({extension: '.jsx'});\nglobal.React = require('react/addons');\n\nvar http = require('http');\n\nvar express = require('express');\nvar redis = require('redis');\n\nvar api = require('./app/server/api');\nvar web = require('./app/server/web');\n\nvar PORT = process.env.PORT || 3000;\n\nvar app = express();\nvar server = http.createServer(app);\nvar db = redis.createClient(6379, 'localhost', {retry_max_delay: 10 * 1000});\n\n// TODO: figure out why errors in express, etc. are triggering this event on db\ndb.on('error', function(e) {});\n\ndb.on('end', function() {\n  app.set('dbConnected', false);\n});\n\ndb.on('connect', function() {\n  app.set('dbConnected', true);\n});\n\napp.set('root', __dirname);\napp.set('uploadDir', __dirname + '/images-upload');\napp.set('view engine', 'ejs');\n\nif (app.get('env') === 'production') app.use(express.logger());\napp.use(express.compress());\napp.use(express.static(app.get('root') + '/public'));\nif (app.get('env') === 'development') app.use(express.logger('dev'));\napp.use(app.router);\nif (app.get('env') === 'development') app.use(express.errorHandler());\n\n[api, web].forEach(function(extension) {\n  extension(app, db);\n});\n\nserver.listen(PORT, function() {\n  console.log(\"Listening at http://localhost:\" + PORT);\n});\n\n",
        "called_code_segment_file_1": "function genErr(res, code, msg) {\n  res.format({\n    html: function() {\n      res.sendfile('public/errors/' + code + '.html');\n    },\n\n    json: function() {\n      res.json(code, {\n        error: true,\n        status: code,\n        message: message\n      });\n    }\n  });\n}",
        "invoking_code_segment_file_2": "module.exports = {\n  notFound: function(res) {\n    genErr(res, 404, 'Not found');\n  },\n\n  genericError: function(res) {\n    genErr(res, 500, 'Internal server error');\n  }\n};",
        "invoking_code_segment_file_3": "Q.nfcall(db.hgetall.bind(db), 'img:' + id).then(function(reply) {\n  if (!reply) {\n    errors.notFound(res);\n  } else {\n    var fname = thumb ? id + '_thumb.jpg' : id;\n    res.header('Content-Type', mimeTypes[reply.type]);\n    res.header('ETag', thumb ? id + '-t' : id);\n\n    if (req.fresh) {\n      res.send(304);\n    } else {\n      fs.createReadStream(app.get('uploadDir') + '/' + fname).pipe(res);\n    }\n  }\n}, function(reason) {\n  console.error('Error in web/i');\n  console.error(reason);\n  errors.genericError(res);\n});",
        "new_file_code_segment": "function logError(code, msg) {\n  console.error(`Error ${code}: ${msg}`);\n}",
        "feature_description": "Add error logging for better debugging.",
        "detailed_feature_description": "The new feature involves adding error logging to the existing error handling mechanism. When an error is generated using the `genErr` function, it will now also log the error details to the console. This will help in debugging issues more effectively. The `logError` function in the new file (#file 4) will be invoked within the `genErr` function in #file 1. The existing invocations in #file 2 and #file 3 will remain unchanged, but they will now indirectly benefit from the new logging feature.",
        "modified_complete_code": {
            "file_1": "#Modify\nfunction genErr(res, code, msg) {\n  logError(code, msg); // New\n  res.format({\n    html: function() {\n      res.sendfile('public/errors/' + code + '.html');\n    },\n\n    json: function() {\n      res.json(code, {\n        error: true,\n        status: code,\n        message: message\n      });\n    }\n  });\n}",
            "file_2": "module.exports = {\n  notFound: function(res) {\n    genErr(res, 404, 'Not found');\n  },\n\n  genericError: function(res) {\n    genErr(res, 500, 'Internal server error');\n  }\n};",
            "file_3": "Q.nfcall(db.hgetall.bind(db), 'img:' + id).then(function(reply) {\n  if (!reply) {\n    errors.notFound(res);\n  } else {\n    var fname = thumb ? id + '_thumb.jpg' : id;\n    res.header('Content-Type', mimeTypes[reply.type]);\n    res.header('ETag', thumb ? id + '-t' : id);\n\n    if (req.fresh) {\n      res.send(304);\n    } else {\n      fs.createReadStream(app.get('uploadDir') + '/' + fname).pipe(res);\n    }\n  }\n}, function(reason) {\n  console.error('Error in web/i');\n  console.error(reason);\n  errors.genericError(res);\n});",
            "file_4": "#New\nfunction logError(code, msg) {\n  console.error(`Error ${code}: ${msg}`);\n}"
        }
    },
    {
        "repo": "movix",
        "content": "'movix/src/store/homeSlice.js'\n:import { createSlice } from \"@reduxjs/toolkit\";\n\nexport const homeSlice = createSlice({\n    name: \"home\",\n    initialState: {\n        url: {},\n        genres: {},\n    },\n    reducers: {\n        getApiConfiguration: (state, action) => {\n            state.url = action.payload;\n        },\n        getGenres: (state, action) => {\n            state.genres = action.payload;\n        },\n    },\n});\n\n// Action creators are generated for each case reducer function\nexport const { getApiConfiguration, getGenres } = homeSlice.actions;\n\nexport default homeSlice.reducer;\n\n'movix/src/App.jsx'\n:import { useState, useEffect } from \"react\";\nimport { BrowserRouter, Routes, Route } from \"react-router-dom\";\nimport { fetchDataFromApi } from \"./utils/api\";\n\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { getApiConfiguration, getGenres } from \"./store/homeSlice\";\n\nimport Header from \"./components/header/Header\";\nimport Footer from \"./components/footer/Footer\";\nimport Home from \"./pages/home/Home\";\nimport Details from \"./pages/details/Details\";\nimport SearchResult from \"./pages/searchResult/SearchResult\";\nimport Explore from \"./pages/explore/Explore\";\nimport PageNotFound from \"./pages/404/PageNotFound\";\n\nfunction App() {\n    const dispatch = useDispatch();\n    const { url } = useSelector((state) => state.home);\n    console.log(url);\n\n    useEffect(() => {\n        fetchApiConfig();\n        genresCall();\n    }, []);\n\n    const fetchApiConfig = () => {\n        fetchDataFromApi(\"/configuration\").then((res) => {\n            console.log(res);\n\n            const url = {\n                backdrop: res.images.secure_base_url + \"original\",\n                poster: res.images.secure_base_url + \"original\",\n                profile: res.images.secure_base_url + \"original\",\n            };\n\n            dispatch(getApiConfiguration(url));\n        });\n    };\n\n    const genresCall = async () => {\n        let promises = [];\n        let endPoints = [\"tv\", \"movie\"];\n        let allGenres = {};\n\n        endPoints.forEach((url) => {\n            promises.push(fetchDataFromApi(`/genre/${url}/list`));\n        });\n\n        const data = await Promise.all(promises);\n        console.log(data);\n        data.map(({ genres }) => {\n            return genres.map((item) => (allGenres[item.id] = item));\n        });\n\n        dispatch(getGenres(allGenres));\n    };\n\n    return (\n        <BrowserRouter>\n            <Header />\n            <Routes>\n                <Route path=\"/\" element={<Home />} />\n                <Route path=\"/:mediaType/:id\" element={<Details />} />\n                <Route path=\"/search/:query\" element={<SearchResult />} />\n                <Route path=\"/explore/:mediaType\" element={<Explore />} />\n                <Route path=\"*\" element={<PageNotFound />} />\n            </Routes>\n            <Footer />\n        </BrowserRouter>\n    );\n}\n\nexport default App;\n\n'movix/src/main.jsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.scss\";\n\nimport { store } from \"./store/store\";\nimport { Provider } from \"react-redux\";\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n    <Provider store={store}>\n        <App />\n    </Provider>\n);\n\n",
        "called_code_segment_file_1": "const fetchApiConfig = () => {\n    fetchDataFromApi(\"/configuration\").then((res) => {\n        console.log(res);\n\n        const url = {\n            backdrop: res.images.secure_base_url + \"original\",\n            poster: res.images.secure_base_url + \"original\",\n            profile: res.images.secure_base_url + \"original\",\n        };\n\n        dispatch(getApiConfiguration(url));\n    });\n};",
        "invoking_code_segment_file_2": "useEffect(() => {\n    fetchApiConfig();\n    genresCall();\n}, []);",
        "invoking_code_segment_file_3": "const { url } = useSelector((state) => state.home);\nconsole.log(url);",
        "new_file_code_segment": "export const fetchAdditionalData = (endpoint) => {\n    return fetchDataFromApi(endpoint).then((res) => {\n        return res;\n    });\n};",
        "feature_description": "Add a new feature to fetch additional data from the API.",
        "detailed_feature_description": "The new feature involves adding a function in #file 4 to fetch additional data from the API. This function will be invoked in #file 1 where the existing fetchApiConfig function is called. The fetched data will be used in #file 2 and #file 3 to display additional information.",
        "modified_complete_code": {
            "#file 1": "const fetchApiConfig = () => {\n    fetchDataFromApi(\"/configuration\").then((res) => {\n        console.log(res);\n\n        const url = {\n            backdrop: res.images.secure_base_url + \"original\",\n            poster: res.images.secure_base_url + \"original\",\n            profile: res.images.secure_base_url + \"original\",\n        };\n\n        dispatch(getApiConfiguration(url));\n    });\n};\n\n#Modify\nconst fetchAdditionalData = (endpoint) => {\n    return fetchDataFromApi(endpoint).then((res) => {\n        return res;\n    });\n};",
            "#file 2": "useEffect(() => {\n    fetchApiConfig();\n    genresCall();\n    fetchAdditionalData(\"/additional-endpoint\").then((data) => {\n        console.log(data);\n        // Handle additional data\n    });\n}, []);",
            "#file 3": "const { url } = useSelector((state) => state.home);\nconsole.log(url);\n\n#Modify\nconst additionalData = useSelector((state) => state.home.additionalData);\nconsole.log(additionalData);",
            "#file 4": "export const fetchAdditionalData = (endpoint) => {\n    return fetchDataFromApi(endpoint).then((res) => {\n        return res;\n    });\n};"
        }
    },
    {
        "repo": "mediumdesk-v1",
        "content": "'mediumdesk-v1/src/menu.js'\n:'use strict';\nconst os = require('os');\nconst path = require('path');\nconst electron = require('electron');\nconst app = electron.app;\nconst BrowserWindow = electron.BrowserWindow;\nconst shell = electron.shell;\nconst appName = app.getName();\nconst UpdateHandler = require('./update');\n\nconst params = {};\n\nfunction sendAction(action) {\n\tconst win = BrowserWindow.getAllWindows()[0];\n\n\tif (process.platform === 'darwin') {\n\t\twin.restore();\n\t}\n\n\twin.webContents.send(action);\n}\n\nfunction checkUpdate() {\n\tconst updateHandler = new UpdateHandler();\n\tupdateHandler.checkForUpdate(`v${app.getVersion()}`, false);\n}\n\nconst helpSubmenu = [\n\t{\n\t\tlabel: `${appName} Website...`,\n\t\tclick() {\n\t\t\tshell.openExternal('https://medium.com/desktop-apps');\n\t\t}\n\t},\n\t{\n\t\tlabel: `Medium Website...`,\n\t\tclick() {\n\t\t\tshell.openExternal('https://medium.com');\n\t\t}\n\t},\n\t{\n\t\ttype: 'separator'\n\t},\n\t{\n\t\tlabel: `Check for updates...`,\n\t\tclick() {\n\t\t\tcheckUpdate();\n\t\t}\n\t},\n\t{\n\t\tlabel: 'Report an Issue...',\n\t\tclick() {\n\t\t\tconst body = `\n<< Please succinctly describe your issue and steps to reproduce it. >>\n\n----\n${app.getName()} ${app.getVersion()}\nElectron ${process.versions.electron}\n${process.platform} ${process.arch} ${os.release()}`;\n\n\t\t\tshell.openExternal(`https://github.com/sivragav/mediumdesk/issues/new?body=${encodeURIComponent(body)}`);\n\t\t}\n\t}\n];\n\nconst viewSubmenu = [\n\t{\n\t\tlabel: `Reload`,\n\t\taccelerator: 'CmdOrCtrl+R',\n\t\tclick() {\n\t\t\tconst win = BrowserWindow.getAllWindows()[0];\n\t\t\twin.reload();\n\t\t}\n\t},\n\t{\n\t\tlabel: `Back`,\n\t\taccelerator: `CmdOrCtrl+[`,\n\t\tclick() {\n\t\t\tsendAction('go-back');\n\t\t}\n\t},\n\t{\n\t\tlabel: `Forward`,\n\t\taccelerator: `CmdOrCtrl+]`,\n\t\tclick() {\n\t\t\tsendAction('go-forward');\n\t\t}\n\t}\n];\n\nif (process.platform !== 'darwin') {\n\thelpSubmenu.push({\n\t\ttype: 'separator'\n\t}, {\n\t\tlabel: `About ${appName}`,\n\t\tclick() {\n\t\t\telectron.dialog.showMessageBox({\n\t\t\t\ttitle: `About ${appName}`,\n\t\t\t\tmessage: `${appName} ${app.getVersion()}`,\n\t\t\t\tdetail: 'Created by Sivaprakash Ragavan',\n\t\t\t\ticon: path.join(__dirname, '../static/Icon.png'),\n\t\t\t\tbuttons: []\n\t\t\t});\n\t\t}\n\t});\n}\n\nconst darwinTpl = [\n\t{\n\t\tlabel: appName,\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: `About ${appName}`,\n\t\t\t\trole: 'about'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Preferences...',\n\t\t\t\taccelerator: 'Cmd+,',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Services',\n\t\t\t\trole: 'services',\n\t\t\t\tsubmenu: []\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: `Hide ${appName}`,\n\t\t\t\taccelerator: 'Cmd+H',\n\t\t\t\trole: 'hide'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Hide Others',\n\t\t\t\taccelerator: 'Cmd+Shift+H',\n\t\t\t\trole: 'hideothers'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Show All',\n\t\t\t\trole: 'unhide'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: `Quit ${appName}`,\n\t\t\t\taccelerator: 'Cmd+Q',\n\t\t\t\tclick() {\n\t\t\t\t\tapp.quit();\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'File',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'New Story',\n\t\t\t\taccelerator: 'Cmd+N',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-new');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Import from disk...',\n\t\t\t\taccelerator: 'Cmd+O',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-file');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Search Medium',\n\t\t\t\taccelerator: 'Cmd+Shift+F',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-search');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Home',\n\t\t\t\taccelerator: 'Cmd+0',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-home');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Drafts',\n\t\t\t\taccelerator: 'Cmd+1',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-drafts');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stories',\n\t\t\t\taccelerator: 'Cmd+2',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stories');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stats',\n\t\t\t\taccelerator: 'Cmd+3',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stats');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bookmarks',\n\t\t\t\taccelerator: 'Cmd+4',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-bookmarks');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Publications',\n\t\t\t\taccelerator: 'Cmd+5',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-pubs');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Profile',\n\t\t\t\taccelerator: 'Cmd+6',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-profile');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Settings',\n\t\t\t\taccelerator: 'Cmd+7',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Login',\n\t\t\t\taccelerator: 'Cmd+8',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-login');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Open in Browser',\n\t\t\t\taccelerator: 'Cmd+9',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-in-browser')\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Edit',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Undo',\n\t\t\t\taccelerator: 'Cmd+Z',\n\t\t\t\trole: 'undo'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Redo',\n\t\t\t\taccelerator: 'Shift+Cmd+Z',\n\t\t\t\trole: 'redo'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Cut',\n\t\t\t\taccelerator: 'Cmd+X',\n\t\t\t\trole: 'cut'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Copy',\n\t\t\t\taccelerator: 'Cmd+C',\n\t\t\t\trole: 'copy'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Paste',\n\t\t\t\taccelerator: 'Cmd+V',\n\t\t\t\trole: 'paste'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Select All',\n\t\t\t\taccelerator: 'Cmd+A',\n\t\t\t\trole: 'selectall'\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'View',\n\t\tsubmenu: viewSubmenu\n\t},\n\t{\n\t\tlabel: 'Window',\n\t\trole: 'window',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Minimize',\n\t\t\t\taccelerator: 'Cmd+M',\n\t\t\t\trole: 'minimize'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Close',\n\t\t\t\taccelerator: 'Cmd+W',\n\t\t\t\trole: 'close'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bring All to Front',\n\t\t\t\trole: 'front'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Toggle Full Screen',\n\t\t\t\taccelerator: 'Ctrl+Cmd+F',\n\t\t\t\tclick() {\n\t\t\t\t\tconst win = BrowserWindow.getAllWindows()[0];\n\t\t\t\t\twin.setFullScreen(!win.isFullScreen());\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Help',\n\t\trole: 'help',\n\t\tsubmenu: helpSubmenu\n\t}\n];\n\nconst otherTpl = [\n\t{\n\t\tlabel: 'File',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'New Story',\n\t\t\t\taccelerator: 'Ctrl+N',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-new');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Import from disk...',\n\t\t\t\taccelerator: 'Ctrl+O',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-file');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Search Medium',\n\t\t\t\taccelerator: 'Ctrl+Shift+F',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-search');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Home',\n\t\t\t\taccelerator: 'Ctrl+0',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-home');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Drafts',\n\t\t\t\taccelerator: 'Ctrl+1',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-drafts');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stories',\n\t\t\t\taccelerator: 'Ctrl+2',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stories');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stats',\n\t\t\t\taccelerator: 'Ctrl+3',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stats');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bookmarks',\n\t\t\t\taccelerator: 'Ctrl+4',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-bookmarks');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Publications',\n\t\t\t\taccelerator: 'Ctrl+5',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-pubs');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Profile',\n\t\t\t\taccelerator: 'Ctrl+6',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-profile');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Settings',\n\t\t\t\taccelerator: 'Ctrl+7',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Login',\n\t\t\t\taccelerator: 'Ctrl+8',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-login');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Open in Browser',\n\t\t\t\taccelerator: 'Ctrl+9',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-in-browser')\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Quit',\n\t\t\t\taccelerator: 'Ctrl+W',\n\t\t\t\tclick() {\n\t\t\t\t\tapp.quit();\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Edit',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Cut',\n\t\t\t\taccelerator: 'Ctrl+X',\n\t\t\t\trole: 'cut'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Copy',\n\t\t\t\taccelerator: 'Ctrl+C',\n\t\t\t\trole: 'copy'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Paste',\n\t\t\t\taccelerator: 'Ctrl+V',\n\t\t\t\trole: 'paste'\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'View',\n\t\tsubmenu: viewSubmenu\n\t},\n\t{\n\t\tlabel: 'Help',\n\t\trole: 'help',\n\t\tsubmenu: helpSubmenu\n\t}\n];\n\nexports.build = () => {\n\tconsole.log(params);\n\tconst tpl = process.platform === 'darwin' ? darwinTpl : otherTpl;\n\treturn electron.Menu.buildFromTemplate(tpl);\n};\n\nexports.setParam = (name, value) => {\n\tparams[name] = value;\n};\n\nexports.getParam = name => {\n\treturn params[name];\n};\n\n'mediumdesk-v1/src/navigate.js'\n:'use strict';\nconst electron = require('electron');\nconst menu = require('./menu');\n\nexports.onNavigate = (e, url) => {\n  if (url.startsWith('https://medium.com/new-story')) {\n\t\tmenu.setParam('showEditMenu', true);\n\t\telectron.Menu.setApplicationMenu(menu.build());\n\t} else {\n    if(menu.getParam('showEditMenu')) {\n      menu.setParam('showEditMenu', false);\n\t\t  electron.Menu.setApplicationMenu(menu.build());\n    }\n  }\n}\n\n'mediumdesk-v1/src/index.js'\n:'use strict';\nconst path = require('path');\nconst fs = require('fs');\nconst electron = require('electron');\nconst app = electron.app;\nconst menu = require('./menu');\nconst Store = require('electron-store');\nconst storage = new Store();\nconst navigate = require('./navigate');\nconst tray = require('./tray');\nconst UpdateHandler = require('./update');\nconst Common = require('./common');\nconst {ipcMain} = require('electron');\nconst mediumapi = require('./mediumapi');\n\nrequire('electron-debug')();\nrequire('electron-dl')();\n\nlet mainWindow;\nlet isQuitting = false;\n\nconst isAlreadyRunning = app.makeSingleInstance(() => {\n\tif (mainWindow) {\n\t\tif (mainWindow.isMinimized()) {\n\t\t\tmainWindow.restore();\n\t\t}\n\t\tmainWindow.show();\n\t}\n});\n\nif (isAlreadyRunning) {\n\tapp.quit();\n}\n\nfunction createMainWindow() {\n\tconst lastWindowState = storage.get('lastWindowState') || Common.WINDOW_SIZE;\n\n\tconst win = new electron.BrowserWindow({\n\t\ttitle: app.getName(),\n\t\tshow: false,\n\t\tx: lastWindowState.x,\n\t\ty: lastWindowState.y,\n\t\twidth: lastWindowState.width,\n\t\theight: lastWindowState.height,\n\t\ticon: process.platform === 'linux' && path.join(__dirname, '../static/Icon.png'),\n\t\tminWidth: 992,\n\t\tminHeight: 450,\n\t\t// titleBarStyle: 'hidden-inset',\n\t\t// autoHideMenuBar: true,\n\t\twebPreferences: {\n\t\t\t// fails without this because of CommonJS script detection\n\t\t\tnodeIntegration: false,\n\t\t\tpreload: path.join(__dirname, 'browser.js'),\n\t\t\twebSecurity: true,\n\t\t\tplugins: true\n\t\t}\n\t});\n\n\tlet startPage = null;\n\tswitch(storage.get('start-page')) {\n\t\tcase 'home':\n\t\t\tstartPage = Common.MEDIUM_HOME;\n\t\t\tbreak;\n\t\tcase 'new':\n\t\t\tstartPage = 'https://medium.com/new-story';\n\t\t\tbreak;\n\t\tcase 'drafts':\n\t\t\tstartPage = 'https://medium.com/me/stories/drafts';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstartPage = Common.MEDIUM_HOME;\n\t\t\tbreak;\n\t}\n\n\twin.loadURL(startPage);\n\twin.on('close', e => {\n\t\tif (!isQuitting) {\n\t\t\te.preventDefault();\n\n\t\t\tif (process.platform === 'darwin') {\n\t\t\t\tapp.hide();\n\t\t\t} else {\n\t\t\t\twin.hide();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn win;\n}\n\napp.on('ready', () => {\n\telectron.Menu.setApplicationMenu(menu.build());\n\tmainWindow = createMainWindow();\n\ttray.create(mainWindow);\n\n\tconst page = mainWindow.webContents;\n\n\tpage.on('dom-ready', () => {\n\t\tpage.insertCSS(fs.readFileSync(path.join(__dirname, 'styles/browser.css'), 'utf8'));\n\t\tmainWindow.show();\n\t});\n\n\tpage.on('did-navigate', navigate.onNavigate);\n\tpage.on('did-navigate-in-page', navigate.onNavigate);\n\n\tpage.on('new-window', (e, url) => {\n\t\te.preventDefault();\n\t\telectron.shell.openExternal(url);\n\t});\n\n\tnew UpdateHandler().checkForUpdate(`v${app.getVersion()}`, true);\n});\n\napp.on('activate', () => {\n\tmainWindow.show();\n});\n\napp.on('before-quit', () => {\n\tisQuitting = true;\n\n\tif (!mainWindow.isFullScreen()) {\n\t\tstorage.set('lastWindowState', mainWindow.getBounds());\n\t}\n});\n\n// Messages\nipcMain.on('import-file', (event, file) => {\n\tconsole.log(\"Importing : \" + file);\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\tshowLoadingMessage('Importing from disk...');\n\tsetTimeout(() => {\n\t\ttry {\n\t\t\tfs.openSync(file, 'r+');\n\t\t\tvar data = fs.readFileSync(file).toString();\n\t\t\tmediumapi.publish(\"\", data, file.endsWith(\"html\") | file.endsWith(\"html\") ? \"html\" : \"markdown\", [],\n\t\t\t\t(error, statusCode, headers, body) => {\n\t\t\t\t\tif(error || !(statusCode == 200 || statusCode == 201)) {\n\t\t\t\t\t\tconsole.log('Error: ', error);\n\t\t\t\t\t\tconsole.log('Status: ', statusCode);\n\t\t\t\t\t\tconsole.log('Headers: ', JSON.stringify(headers));\n\t\t\t\t\t\tconsole.log('Body: ', body);\n\t\t\t\t\t\tif(body) {\n\t\t\t\t\t\t\tvar bodyContents = JSON.parse(body);\n\t\t\t\t\t\t\tshowErrorMessage(bodyContents[\"errors\"][0][\"message\"]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshowErrorMessage('Unknown Error Occured');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Reponse from Medium: ', body);\n\t\t\t\t\t\tvar bodyContents = JSON.parse(body);\n\t\t\t\t\t\tconst url = bodyContents[\"data\"][\"url\"];\n\t\t\t\t\t\tif(url) {\n\t\t\t\t\t\t\twin.loadURL(url);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshowErrorMessage('Error loading Draft');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tconsole.error('Couldn\\'t read file' + err);\n\t\t\tshowErrorMessage('Error reading file');\n\t\t}\n\t}, 100);\n});\n\nfunction showLoadingMessage(msg) {\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\twin.loadURL('file://' + __dirname + '/pages/message.html?msg=' + encodeURIComponent(msg) + '&loading=true');\n}\n\nfunction showErrorMessage(msg) {\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\twin.loadURL('file://' + __dirname + '/pages/message.html?msg=' + encodeURIComponent(msg) + '&error=true');\n\tsetTimeout(() => {\n\t\twin.loadURL(Common.MEDIUM_HOME);\n\t}, 2500);\n}\n\n",
        "called_code_segment_file_1": "exports.onNavigate = (e, url) => {\n  if (url.startsWith('https://medium.com/new-story')) {\n\t\tmenu.setParam('showEditMenu', true);\n\t\telectron.Menu.setApplicationMenu(menu.build());\n\t} else {\n    if(menu.getParam('showEditMenu')) {\n      menu.setParam('showEditMenu', false);\n\t\telectron.Menu.setApplicationMenu(menu.build());\n    }\n  }\n}",
        "invoking_code_segment_file_2": "page.on('did-navigate', navigate.onNavigate);\npage.on('did-navigate-in-page', navigate.onNavigate);",
        "invoking_code_segment_file_3": "const navigate = require('./navigate');",
        "new_file_code_segment": "exports.checkNavigation = (url) => {\n  if (url.startsWith('https://medium.com/new-story')) {\n\t\tconsole.log('Navigating to new story page');\n\t} else {\n\t\tconsole.log('Navigating to other page');\n\t}\n}",
        "feature_description": "Add a logging feature to track navigation events.",
        "detailed_feature_description": "The new feature involves adding a logging mechanism to track navigation events. When a navigation event occurs, it will log whether the user is navigating to a new story page or another page. This functionality is implemented in a new file (#file 4) and is integrated into the existing navigation handling in #file 1. The navigation handling in #file 2 and #file 3 is updated to invoke the new logging functionality from #file 4.",
        "modified_complete_code": {
            "#file 1": "exports.onNavigate = (e, url) => {\n  if (url.startsWith('https://medium.com/new-story')) {\n\t\tmenu.setParam('showEditMenu', true);\n\t\telectron.Menu.setApplicationMenu(menu.build());\n\t} else {\n    if(menu.getParam('showEditMenu')) {\n      menu.setParam('showEditMenu', false);\n\t\telectron.Menu.setApplicationMenu(menu.build());\n    }\n  }\n  #Modify\n  require('./navigationLogger').checkNavigation(url);\n}",
            "#file 2": "page.on('did-navigate', navigate.onNavigate);\npage.on('did-navigate-in-page', navigate.onNavigate);",
            "#file 3": "const navigate = require('./navigate');",
            "#file 4": "#New\nexports.checkNavigation = (url) => {\n  if (url.startsWith('https://medium.com/new-story')) {\n\t\tconsole.log('Navigating to new story page');\n\t} else {\n\t\tconsole.log('Navigating to other page');\n\t}\n}"
        }
    },
    {
        "repo": "better-onetab",
        "content": "'better-onetab/src/common/listManager.js'\n:import browser from 'webextension-polyfill'\nimport {\n  SYNCED_LIST_PROPS,\n  END_FRONT,\n  END_BACKGROUND,\n  ADD_LIST,\n  UPDATE_LIST_BY_ID,\n  REMOVE_LIST_BY_ID,\n  CHANGE_LIST_ORDER,\n} from './constants'\nimport {isBackground, sendMessage, Mutex} from './utils'\n\nconst cache = { lists: null, ops: null }\nconst RWLock = new Mutex()\nconst getStorage = async () => {\n  const unlockRW = await RWLock.lock()\n  if (cache.lists && cache.ops) return cache\n  const {lists, ops} = await browser.storage.local.get(['lists', 'ops'])\n  cache.lists = lists || []\n  cache.ops = ops || []\n  await unlockRW()\n  return cache\n}\nconst compressOps = ops => {\n  console.debug('[listManager] compress ops: (before)', ops)\n  const removed = []\n  const updated = {}\n  const finalOps = []\n  for (let i = ops.length - 1; i > -1; i -= 1) {\n    const op = ops[i]\n    // ignore all actions for the list if that list will be removed finally\n    if (op.args && op.args[0] && removed.includes(op.args[0]._id)\n      || typeof op.args[0] === 'string' && removed.includes(op.args[0])) continue\n\n    if (op.method === 'removeListById') {\n      removed.push(op.args[0])\n      finalOps.unshift(op)\n    } else if (op.method === 'updateListById') {\n      // keep the final result of every property if a list will be updated\n      const [listId, newList, time] = op.args\n      if (updated[listId]) {\n        for (const key in newList) {\n          if (key in updated[listId]) continue\n          updated[listId][key] = newList[key]\n        }\n        continue\n      } else {\n        updated[listId] = Object.assign({}, newList)\n        finalOps.unshift({method: 'updateListById', args: [listId, updated[listId], time]})\n      }\n    } else if (op.method === 'changeListOrderRelatively') {\n      // combine the value if a list is reordered continuously\n      if (i > 0 && ops[i - 1].method === 'changeListOrderRelatively' && op.args[0] === ops[i - 1].args[0]) {\n        ops[i - 1].args[1] += ops[i].args[1]\n      } else finalOps.unshift(op)\n    } else {\n      // do nothing if add a list\n      finalOps.unshift(op)\n    }\n  }\n  console.debug('[listManager] compress ops: (after)', finalOps)\n  return finalOps\n}\n\nconst manager = {}\n// lists modifier (return true if need to add ops)\nmanager.modifiers = {\n  [ADD_LIST](lists, [list]) {\n    if (~lists.findIndex(i => i._id === list._id)) return\n    lists.unshift(list)\n    return [list]\n  },\n  [UPDATE_LIST_BY_ID](lists, [listId, newList, time = Date.now()]) {\n    const normal = Object.keys(newList).some(k => SYNCED_LIST_PROPS.includes(k))\n    for (let i = 0; i < lists.length; i += 1) {\n      if (lists[i]._id !== listId) continue\n      const list = lists[i]\n      for (const [k, v] of Object.entries(newList)) {\n        list[k] = v\n      }\n      if (normal) list.updatedAt = time\n      return normal ? [listId, newList, time] : null\n    }\n  },\n  [REMOVE_LIST_BY_ID](lists, [listId]) {\n    const index = lists.findIndex(list => list._id === listId)\n    lists.splice(index, 1)\n    return [listId]\n  },\n  [CHANGE_LIST_ORDER](lists, [listId, diff]) {\n    const index = lists.findIndex(list => list._id === listId)\n    const [list] = lists.splice(index, 1)\n    lists.splice(index + diff, 0, list)\n    return [listId, diff]\n  },\n}\n\n// use myself throttle function to replace Lodash.throttle to make sure\n// this function cannot be executed concurrently\nconst saveStorage = async (lists, ops) => {\n  const unlock = await RWLock.lock()\n  const data = {\n    lists,\n    ops: compressOps(ops)\n  }\n  await browser.storage.local.set(data)\n  cache.lists = cache.ops = null\n  await sendMessage({refresh: true})\n  await unlock()\n}\n// avoid getting storage at the same time\nconst _modifyQueue = []\nconst _startModifyWork = (lists, ops) => new Promise(resolve => {\n  while (_modifyQueue.length) {\n    const [method, args] = _modifyQueue.shift()\n    const opArgs = manager.modifiers[method](lists, args)\n    if (opArgs) ops.push({method, args: opArgs, time: Date.now()})\n  }\n  setTimeout(() => {\n    if (_modifyQueue.length) _startModifyWork(lists, ops).then(resolve)\n    else resolve()\n  }, 100)\n})\n\nlet _working = false\nconst applyChangesToStorage = async (method, args) => {\n  _modifyQueue.push([method, args])\n  // not need to start work if modify work is processing\n  if (_working) return\n  _working = true\n  const {lists, ops} = await getStorage()\n  await _startModifyWork(lists, ops)\n  // from here won't modify data if do not call start function\n  _working = false\n  await saveStorage(lists, ops)\n}\nconst addEventListener = (receiveFrom, callback) => browser.runtime.onMessage.addListener(({listModifed, from}) => {\n  if (receiveFrom !== from || !listModifed) return\n  const {method, args} = listModifed\n  return callback(method, args)\n})\nconst genMethods = isBackground => {\n  Object.keys(manager.modifiers).forEach(method => {\n    manager[method] = isBackground ? async (...args) => { // for background\n      console.debug('[list manager] modify list:', method, ...args)\n      await sendMessage({listModifed: {method, args}, from: END_BACKGROUND})\n      // no need to await changes applied for close tabs immediately\n      applyChangesToStorage(method, args)\n    } : async (...args) => { // for front end\n      console.debug('[list manager] call to modify list:', name, ...args)\n      await sendMessage({listModifed: {method, args}, from: END_FRONT})\n    }\n  })\n}\nmanager.init = async () => {\n  if (manager.inited) return\n  manager.inited = true\n  const _isBackground = await isBackground()\n  if (_isBackground) await addEventListener(END_FRONT, applyChangesToStorage)\n  genMethods(_isBackground)\n}\nmanager.mapMutations = () => {\n  const mutations = {}\n  Object.entries(manager.modifiers).forEach(([method, fn]) => {\n    mutations[method] = (state, payload) => fn(state.lists, payload)\n  })\n  mutations.receiveData = (state, {method, args}) => {\n    manager.modifiers[method](state.lists, args)\n  }\n  return mutations\n}\nmanager.createVuexPlugin = () => store => {\n  addEventListener(END_BACKGROUND, (method, args) => {\n    store.commit('receiveData', {method, args})\n  })\n  browser.runtime.onMessage.addListener(({refreshed}) => {\n    if (refreshed && refreshed.success) store.dispatch('getLists')\n  })\n  store.subscribe(({type, payload}) => {\n    if (type in manager.modifiers) {\n      manager[type](...payload)\n    }\n  })\n}\nmanager.RWLock = RWLock\nmanager.isWorking = () => _working\nexport default manager\n\n'better-onetab/src/background/init.js'\n:import _ from 'lodash'\nimport logger from '../common/logger'\nimport options from '../common/options'\nimport storage from '../common/storage'\nimport migrate from '../common/migrate'\nimport boss from '../common/service/boss'\nimport {normalizeList} from '../common/list'\nimport commandHandler from './commandHandler'\nimport messageHandler from './messageHandler'\nimport listManager from '../common/listManager'\nimport {setupContextMenus, dynamicDisableMenu} from './contextMenus'\nimport installedEventHandler from './installedEventHandler'\nimport {updateBrowserAction} from './browserAction'\n\nimport browser from 'webextension-polyfill'\n\n/* eslint-disable-next-line */\nif (DEBUG && !MOZ) import(\n  /* webpackChunkName: \"autoreload\", webpackMode: \"lazy\" */\n  '../common/autoreload'\n).then(({autoreload}) => autoreload())\n\n/* eslint-disable-next-line */\nif (PRODUCTION) import(\n  /* webpackChunkName: \"tracker\", webpackMode: \"lazy\" */\n  '../common/tracker'\n).then(({tracker}) => tracker())\n\nif (DEBUG) {\n  window.browser = browser\n  window.listManager = listManager\n  window.boss = boss\n  browser.browserAction.setBadgeText({text: 'dev'})\n  import(\n    /* webpackChunkName: \"helper\", webpackMode: \"lazy\" */\n    '../common/helper'\n  ).then(helper => { window.helper = helper })\n}\n\nconst initOptions = async () => {\n  // mount the `opts` to global\n  const opts = window.opts = await storage.getOptions() || {}\n  const defaultOptions = options.getDefaultOptions()\n\n  // set it as default value if there is an option not in current options\n  if (_.keys(defaultOptions).some(key => !_.has(opts, key))) {\n    _.defaults(opts, defaultOptions)\n    await storage.setOptions(opts)\n  }\n\n  // init nightmode status\n  window.nightmode = opts.defaultNightMode\n  return opts\n}\n\nconst storageChangedHandler = changes => {\n  console.debug('[storage changed]', changes)\n  if (changes.boss_token) {\n    window.boss_token = changes.boss_token\n  }\n  if (changes.lists) {\n    if (window.opts.disableDynamicMenu) return\n    setupContextMenus(window.opts)\n  }\n}\n\nconst tabsChangedHandler = activeInfo => {\n  if (window.opts.disableDynamicMenu) return\n  window.coverBrowserAction(activeInfo)\n  dynamicDisableMenu(activeInfo)\n}\n\nconst fixDirtyData = async () => {\n  const unlock = await listManager.RWLock.lock()\n  const {lists} = await browser.storage.local.get('lists')\n  if (lists) {\n    const cleanLists = lists.filter(_.isPlainObject).map(normalizeList)\n    await browser.storage.local.set({lists: cleanLists})\n  }\n  await unlock()\n}\n\nconst init = async () => {\n  logger.init()\n  await listManager.init()\n  const opts = await initOptions()\n  await updateBrowserAction(opts.browserAction)\n  await setupContextMenus(opts)\n  await Promise.all([\n    browser.commands.onCommand.addListener(commandHandler),\n    browser.runtime.onMessageExternal.addListener(commandHandler),\n    browser.runtime.onMessage.addListener(messageHandler),\n    browser.runtime.onUpdateAvailable.addListener(detail => { window.update = detail.version }),\n    browser.runtime.onInstalled.addListener(installedEventHandler),\n    browser.browserAction.onClicked.addListener(() => window.browswerActionClickedHandler()),\n    browser.contextMenus.onClicked.addListener(info => window.contextMenusClickedHandler(info)),\n    browser.tabs.onActivated.addListener(_.debounce(tabsChangedHandler, 200)),\n    browser.storage.onChanged.addListener(storageChangedHandler),\n  ])\n  await migrate()\n  await fixDirtyData()\n  await boss.init()\n}\n\nexport default init\n\n'better-onetab/src/background/index.js'\n:import init from './init'\n\ninit()\n\n",
        "called_code_segment_file_1": "manager.init = async () => {\n  if (manager.inited) return\n  manager.inited = true\n  const _isBackground = await isBackground()\n  if (_isBackground) await addEventListener(END_FRONT, applyChangesToStorage)\n  genMethods(_isBackground)\n}",
        "invoking_code_segment_file_2": "const init = async () => {\n  logger.init()\n  await listManager.init()\n  const opts = await initOptions()\n  await updateBrowserAction(opts.browserAction)\n  await setupContextMenus(opts)\n  await Promise.all([\n    browser.commands.onCommand.addListener(commandHandler),\n    browser.runtime.onMessageExternal.addListener(commandHandler),\n    browser.runtime.onMessage.addListener(messageHandler),\n    browser.runtime.onUpdateAvailable.addListener(detail => { window.update = detail.version }),\n    browser.runtime.onInstalled.addListener(installedEventHandler),\n    browser.browserAction.onClicked.addListener(() => window.browswerActionClickedHandler()),\n    browser.contextMenus.onClicked.addListener(info => window.contextMenusClickedHandler(info)),\n    browser.tabs.onActivated.addListener(_.debounce(tabsChangedHandler, 200)),\n    browser.storage.onChanged.addListener(storageChangedHandler),\n  ])\n  await migrate()\n  await fixDirtyData()\n  await boss.init()\n}",
        "invoking_code_segment_file_3": "manager.createVuexPlugin = () => store => {\n  addEventListener(END_BACKGROUND, (method, args) => {\n    store.commit('receiveData', {method, args})\n  })\n  browser.runtime.onMessage.addListener(({refreshed}) => {\n    if (refreshed && refreshed.success) store.dispatch('getLists')\n  })\n  store.subscribe(({type, payload}) => {\n    if (type in manager.modifiers) {\n      manager[type](...payload)\n    }\n  })\n}",
        "new_file_code_segment": "const newFeature = () => {\n  console.log('New feature implemented!')\n}\n\nexport default newFeature",
        "feature_description": "Add a new feature to log a message when the list manager is initialized.",
        "detailed_feature_description": "The new feature involves adding a logging mechanism that prints a message to the console whenever the list manager is initialized. This will help in debugging and tracking the initialization process. The new functionality is implemented in a new file (#file 4) and is invoked from #file 1 during the initialization process.",
        "modified_complete_code": {
            "#file 1": "manager.init = async () => {\n  if (manager.inited) return\n  manager.inited = true\n  const _isBackground = await isBackground()\n  if (_isBackground) await addEventListener(END_FRONT, applyChangesToStorage)\n  genMethods(_isBackground)\n  #Modify newFeature()\n}",
            "#file 2": "const init = async () => {\n  logger.init()\n  await listManager.init()\n  const opts = await initOptions()\n  await updateBrowserAction(opts.browserAction)\n  await setupContextMenus(opts)\n  await Promise.all([\n    browser.commands.onCommand.addListener(commandHandler),\n    browser.runtime.onMessageExternal.addListener(commandHandler),\n    browser.runtime.onMessage.addListener(messageHandler),\n    browser.runtime.onUpdateAvailable.addListener(detail => { window.update = detail.version }),\n    browser.runtime.onInstalled.addListener(installedEventHandler),\n    browser.browserAction.onClicked.addListener(() => window.browswerActionClickedHandler()),\n    browser.contextMenus.onClicked.addListener(info => window.contextMenusClickedHandler(info)),\n    browser.tabs.onActivated.addListener(_.debounce(tabsChangedHandler, 200)),\n    browser.storage.onChanged.addListener(storageChangedHandler),\n  ])\n  await migrate()\n  await fixDirtyData()\n  await boss.init()\n}",
            "#file 3": "manager.createVuexPlugin = () => store => {\n  addEventListener(END_BACKGROUND, (method, args) => {\n    store.commit('receiveData', {method, args})\n  })\n  browser.runtime.onMessage.addListener(({refreshed}) => {\n    if (refreshed && refreshed.success) store.dispatch('getLists')\n  })\n  store.subscribe(({type, payload}) => {\n    if (type in manager.modifiers) {\n      manager[type](...payload)\n    }\n  })\n}",
            "#file 4": "const newFeature = () => {\n  console.log('New feature implemented!')\n}\n\nexport default newFeature"
        }
    },
    {
        "repo": "stresser",
        "content": "'stresser/helpers.js'\n:'use strict';\nconst range = require('node-range');\nconst pad = require('pad');\nconst helpers = {};\n\nArray.prototype.trim = function(proc) {\n    const newArr = [];\n    for (let i = 0; i < this.length * proc; i++) {\n        newArr.push(this[i]);\n    }\n    return newArr;\n};\n\n\nhelpers.std = (arr)=> {\n    arr = arr.sort();\n\n    let left = arr.trim(0.5);\n    let right = arr.reverse().trim(0.5);\n\n    const leftCnt = left.length;\n    const rightCnt = right.length;\n\n    const leftMean = helpers.avg(left);\n    const rightMean = helpers.avg(right);\n\n    left = left.map(val => Math.pow(Math.abs(leftMean - val), 2));\n    right = right.map(val => Math.pow(Math.abs(rightMean - val), 2));\n\n    left = helpers.sum(left) / leftCnt;\n    right = helpers.sum(right) / rightCnt;\n\n    left = Math.sqrt(left);\n    right = Math.sqrt(right);\n\n    return {\n        left,\n        right,\n    }\n};\n\nhelpers.max = (arr) => {\n    let max = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (max < arr[i]) {\n            max = arr[i];\n        }\n    }\n    return max;\n};\nhelpers.min = (arr) => {\n    let min = Infinity;\n    for (let i = 0; i < arr.length; i++) {\n        if (min > arr[i]) {\n            min = arr[i];\n        }\n    }\n    return min;\n};\n\nhelpers.avg = (arr) => {\n    return helpers.sum(arr) / arr.length;\n};\n\nhelpers.sum = (arr) => {\n    return arr.reduce((sum, val) => sum + val);\n};\n\nhelpers.outputTime = (arr, proc) => {\n    arr = arr.trim(proc);\n    const std = helpers.std(arr);\n\n    const str = [\n        'time @ ', pad(3, proc * 100), '%', '|',\n        'min:', helpers.min(arr) | 0,\n        'left std:', std.left | 0,\n        'mean:', helpers.avg(arr) | 0,\n        'right std:', std.right | 0, '|',\n        'max:', helpers.max(arr) | 0\n    ].join(' ');\n    console.log(str);\n\n    return str;\n};\n\nmodule.exports = helpers;\n'stresser/master.js'\n:'use strict';\nconst cluster = require('cluster');\nconst workers = Object.keys(cluster.workers);\n\nconst range = require('node-range');\nconst pad = require('pad');\n\nconst helpers = require('./helpers');\nconst display = require('./display');\n\nconst config = require('./config');\n\nconst amount = config.count;\n\nlet _statsForSecond = null;\nconst resetStats = () => {\n    _statsForSecond = {\n        code: {\n            '1': 0,\n            '2': 0,\n            '3': 0,\n            '4': 0,\n            '5': 0\n        },\n        err: 0,\n        to: 0,\n        body: 0,\n\n        cnt: 0,\n        time: 0,\n        min: Infinity,\n        max: 0\n    }\n};\nresetStats();\n\nconst SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};\n\nlet _RAW_CNT = 0;\nconst RAW = (data) => {\n    data.forEach((req) => _requests.push(req));\n    _RAW_CNT++;\n    if (_RAW_CNT % workers.length === 0) {\n        _finish();\n    }\n};\n\nlet _STATS_CNT = 0;\nconst STATS = (data, reqCnt) => {\n    _statsForSecond.err += data.err;\n    _statsForSecond.to += data.to;\n    _statsForSecond.body += data.body;\n    _statsForSecond.cnt += data.cnt;\n    _statsForSecond.time += data.time;\n\n    _statsForSecond.min = Math.min(_statsForSecond.min, data.min);\n    _statsForSecond.max = Math.max(_statsForSecond.max, data.max);\n\n    for (let i = 1; i <= 5; i++) {\n        _statsForSecond.code[i.toString()] += data.code[i.toString()];\n    }\n\n    _requestCountActive += reqCnt;\n\n    _STATS_CNT++;\n    if (_STATS_CNT % workers.length === 0) {\n        printStats(_statsForSecond);\n\n        _second++;\n\n        const somethingLeft = (\n            _statsForSecond.cnt === 0 &&\n            _statsForSecond.err === 0 &&\n            _statsForSecond.to === 0 &&\n            _requestCountActive === 0\n        );\n\n        const forceStop = (\n            config.force &&\n            _second > config.count\n        );\n\n        if (\n            somethingLeft || forceStop\n        ) {\n            SEND('raw');\n        } else {\n            _secondHistory.push(Object.assign({}, _statsForSecond, { active: _requestCountActive }));\n            setTimeout(_doWork, 1000);\n        }\n\n        resetStats();\n        _requestCountActive = 0;\n    }\n};\n\n\nworkers\n    .map(wid => cluster.workers[wid])\n    .forEach(worker => {\n        worker.on('message', (msg) => {\n            switch (msg.type) {\n                case 'stats':\n                    STATS(msg.data, msg.req);\n                    break;\n                case 'raw':\n                    RAW(msg.data);\n                    break;\n            }\n        })\n    });\n\nconst _requests = [];\nlet _requestCountActive = 0;\nlet _second = 0;\nconst _secondHistory = [];\n\nconst printStats = (stats, finish) => {\n    let str = (\n        `  S=${pad(6, _second)} |   T=${pad(6, stats.cnt + stats.to + stats.err)} | A=${pad(6, _requestCountActive)}\n  E=${pad(6, stats.err)} | T/O=${pad(6, stats.to)} | \\\nW/B=${pad(6, stats.body)} | AVG=${pad(6, (stats.time / stats.cnt) | 0)} | MIN=${pad(6, stats.min)} | MAX=${pad(6, stats.max)}\n${range(1, 6).map(code => `${code}xx=${pad(6, stats.code[code.toString()])}`).join(' | ')}\n`);\n\n    const howManyReq = config.concurrentPerCPU * config.CPUs * config.count;\n    const howManyDone = stats.cnt + stats.err + stats.to;\n    if (finish && howManyDone < howManyReq) {\n        str += `NOT FINISHED=${pad(6, howManyReq - howManyDone)}\n`;\n    }\n\n    console.error(str);\n    return str;\n};\n\nconst _finish = () => {\n    workers.forEach(worker => cluster.workers[worker].kill());\n\n    const stats = {\n        code: {\n            '1': 0,\n            '2': 0,\n            '3': 0,\n            '4': 0,\n            '5': 0\n        },\n        err: 0,\n        to: 0,\n        body: 0,\n\n        cnt: 0,\n        time: 0,\n        min: Infinity,\n        max: 0\n    };\n    _requests.forEach(req => {\n        stats.to += req.to;\n        stats.err += req.err;\n        stats.body += req.body;\n\n        stats.code[req.code.toString()[0]]++;\n\n        if (req.time) {\n            stats.time += req.time;\n            stats.cnt++;\n\n            if (req.time < stats.min) {\n                stats.min = req.time;\n            }\n            if (req.time > stats.max) {\n                stats.max = req.time;\n            }\n        }\n    });\n\n    console.error('~~~ Aggregated Stats: ~~~');\n\n    const statsStr = printStats(stats, true);\n\n    if (config.html) {\n        display(config.html, _requests, statsStr, _secondHistory, config.url);\n    }\n\n    setTimeout(() => process.exit(0), 100);\n};\n\nconst _doWork = () => {\n    if (_second < amount) {\n        _requestCountActive += config.concurrentPerCPU * workers.length;\n        SEND('req', _second);\n    }\n\n    SEND('stats');\n};\n\n_doWork();\n'stresser/index.js'\n:#!/usr/bin/env node\n'use strict';\nconst cluster = require('cluster');\n\nif (cluster.isMaster) {\n    const config = require('./config');\n\n    console.error('Booting up', config.CPUs, 'workers');\n    let online = 0;\n    for (let i = 0; i < config.CPUs; i++) {\n        const worker = cluster.fork();\n        worker.on('online', () => {\n            online++;\n\n            setTimeout(() => {\n                worker.send({ type: 'setup', data: config });\n\n                if (online === config.CPUs) {\n                    return setTimeout(() => require('./master'), 100);\n                }\n            }, 100);\n        });\n    }\n\n    return;\n}\n\nreturn require('./worker');\n",
        "called_code_segment_file_1": "const _doWork = () => {\n    if (_second < amount) {\n        _requestCountActive += config.concurrentPerCPU * workers.length;\n        SEND('req', _second);\n    }\n\n    SEND('stats');\n};",
        "invoking_code_segment_file_2": "worker.on('message', (msg) => {\n    switch (msg.type) {\n        case 'stats':\n            STATS(msg.data, msg.req);\n            break;\n        case 'raw':\n            RAW(msg.data);\n            break;\n    }\n})",
        "invoking_code_segment_file_3": "const SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};",
        "new_file_code_segment": "const newFeature = () => {\n    console.log('New feature invoked');\n    // Additional functionality can be added here\n};\n\nmodule.exports = newFeature;",
        "feature_description": "Add a new feature to log additional information when a request is processed.",
        "detailed_feature_description": "The new feature involves adding a logging mechanism to the existing request processing workflow. This will be implemented in a new file (#file 4) and will be invoked from #file 1. The changes in #file 1 will ensure that the new feature is integrated seamlessly with the existing code. #file 2 and #file 3 will remain unchanged as they do not directly interact with the new feature.",
        "modified_complete_code": {
            "#file 1": "#Modify\nconst _doWork = () => {\n    if (_second < amount) {\n        _requestCountActive += config.concurrentPerCPU * workers.length;\n        SEND('req', _second);\n    }\n\n    SEND('stats');\n    newFeature(); // #New: Invoke new feature\n};",
            "#file 2": "worker.on('message', (msg) => {\n    switch (msg.type) {\n        case 'stats':\n            STATS(msg.data, msg.req);\n            break;\n        case 'raw':\n            RAW(msg.data);\n            break;\n    }\n})",
            "#file 3": "const SEND = (type, data) => {\n    workers.forEach(wid => cluster.workers[wid].send({ type, data }))\n};",
            "#file 4": "const newFeature = () => {\n    console.log('New feature invoked');\n    // Additional functionality can be added here\n};\n\nmodule.exports = newFeature;"
        }
    },
    {
        "repo": "z",
        "content": "'z/src/option.js'\n:module.exports = {\n  Some: (value) => ({ value, hasValue: true }),\n  None: {}\n}\n\n'z/src/match.js'\n:const deepEqual = require('deep-equal')\nconst objectEquals = require('./objectEquals')\nconst option = require('./option')\n\nmodule.exports = (match, subjectToMatch) => {\n  const hasMatchValue = match.args[0].length >= 2\n  if (!hasMatchValue) {\n    return option.Some(subjectToMatch)\n  }\n\n  const matchValue = match.args[0][1]\n\n  // if is a type check, check type\n  if (matchValue === Boolean && typeof subjectToMatch === 'boolean') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === undefined && typeof subjectToMatch === 'undefined') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === Number && typeof subjectToMatch === 'number') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === String && typeof subjectToMatch === 'string') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === Object && typeof subjectToMatch === 'object') {\n    return option.Some(subjectToMatch)\n  }\n\n  // if is instance check, check instance\n  if (\n    typeof matchValue === 'function' &&\n    subjectToMatch instanceof matchValue\n  ) {\n    return option.Some(subjectToMatch)\n  }\n\n  // if it is a regex, and the value is a string, test that it matches\n  if (matchValue instanceof RegExp && typeof subjectToMatch === 'string') {\n    if (matchValue.test(subjectToMatch)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if its array\n  if (\n    subjectToMatch instanceof Array &&\n    matchValue instanceof Array\n  ) {\n    if (deepEqual(subjectToMatch, matchValue)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if is object (and not an array), check if contains\n  if (typeof subjectToMatch === 'object' && subjectToMatch !== null && !(subjectToMatch instanceof Array) && typeof matchValue === 'object') {\n    if (objectEquals(matchValue, subjectToMatch)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if is value check, check value\n  if (subjectToMatch === matchValue) {\n    return option.Some(subjectToMatch)\n  }\n\n  return option.None\n}\n\n'z/src/z.js'\n:const getMatchDetails = require('./getMatchDetails')\nconst match = require('./match')\nconst matchArray = require('./matchArray')\nconst { hasDestructuredObjectArguments } = require('./utils')\nconst { objectAndArgsDestructureMatches } = require('./matchObject')\n\nconst resolveMatchFunctions = (subjectToMatch, functions, scope) => {\n  for (let i = 0; i < functions.length; i++) {\n    const currentMatch = getMatchDetails.call(scope, functions[i])\n\n    const matchHasSingleArgument = currentMatch.args.length === 1\n    if (matchHasSingleArgument) {\n      const singleValueResolve = match(currentMatch, subjectToMatch)\n      if (singleValueResolve.hasValue) {\n        return currentMatch.func(singleValueResolve.value)\n      }\n    }\n\n    const matchHasMultipleArguments = currentMatch.args.length > 1\n    if (matchHasMultipleArguments && Array.isArray(subjectToMatch)) {\n      const multipleItemResolve = matchArray(currentMatch, subjectToMatch)\n      if (\n        multipleItemResolve.hasValue &&\n        Array.isArray(multipleItemResolve.value)\n      ) {\n        return currentMatch.func.apply(null, multipleItemResolve.value)\n      }\n\n      if (multipleItemResolve.hasValue) {\n        return currentMatch.func(multipleItemResolve.value)\n      }\n    }\n\n    if (\n      hasDestructuredObjectArguments(currentMatch.args) &&\n      objectAndArgsDestructureMatches(currentMatch.args, subjectToMatch)\n    ) {\n      return currentMatch.func(subjectToMatch)\n    }\n  }\n}\n\nconst matches = (subjectToMatch) => function (...functions) {\n  return resolveMatchFunctions(subjectToMatch, functions, this)\n}\n\nmodule.exports = { matches }\n\n",
        "called_code_segment_file_1": "module.exports = (match, subjectToMatch) => {\n  const hasMatchValue = match.args[0].length >= 2\n  if (!hasMatchValue) {\n    return option.Some(subjectToMatch)\n  }\n\n  const matchValue = match.args[0][1]\n\n  // if is a type check, check type\n  if (matchValue === Boolean && typeof subjectToMatch === 'boolean') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === undefined && typeof subjectToMatch === 'undefined') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === Number && typeof subjectToMatch === 'number') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === String && typeof subjectToMatch === 'string') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === Object && typeof subjectToMatch === 'object') {\n    return option.Some(subjectToMatch)\n  }\n\n  // if is instance check, check instance\n  if (\n    typeof matchValue === 'function' &&\n    subjectToMatch instanceof matchValue\n  ) {\n    return option.Some(subjectToMatch)\n  }\n\n  // if it is a regex, and the value is a string, test that it matches\n  if (matchValue instanceof RegExp && typeof subjectToMatch === 'string') {\n    if (matchValue.test(subjectToMatch)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if its array\n  if (\n    subjectToMatch instanceof Array &&\n    matchValue instanceof Array\n  ) {\n    if (deepEqual(subjectToMatch, matchValue)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if is object (and not an array), check if contains\n  if (typeof subjectToMatch === 'object' && subjectToMatch !== null && !(subjectToMatch instanceof Array) && typeof matchValue === 'object') {\n    if (objectEquals(matchValue, subjectToMatch)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if is value check, check value\n  if (subjectToMatch === matchValue) {\n    return option.Some(subjectToMatch)\n  }\n\n  return option.None\n}",
        "invoking_code_segment_file_2": "const match = require('./match')\n\nconst resolveMatchFunctions = (subjectToMatch, functions, scope) => {\n  for (let i = 0; i < functions.length; i++) {\n    const currentMatch = getMatchDetails.call(scope, functions[i])\n\n    const matchHasSingleArgument = currentMatch.args.length === 1\n    if (matchHasSingleArgument) {\n      const singleValueResolve = match(currentMatch, subjectToMatch)\n      if (singleValueResolve.hasValue) {\n        return currentMatch.func(singleValueResolve.value)\n      }\n    }\n\n    const matchHasMultipleArguments = currentMatch.args.length > 1\n    if (matchHasMultipleArguments && Array.isArray(subjectToMatch)) {\n      const multipleItemResolve = matchArray(currentMatch, subjectToMatch)\n      if (\n        multipleItemResolve.hasValue &&\n        Array.isArray(multipleItemResolve.value)\n      ) {\n        return currentMatch.func.apply(null, multipleItemResolve.value)\n      }\n\n      if (multipleItemResolve.hasValue) {\n        return currentMatch.func(multipleItemResolve.value)\n      }\n    }\n\n    if (\n      hasDestructuredObjectArguments(currentMatch.args) &&\n      objectAndArgsDestructureMatches(currentMatch.args, subjectToMatch)\n    ) {\n      return currentMatch.func(subjectToMatch)\n    }\n  }\n}",
        "invoking_code_segment_file_3": "const { matches } = require('./z')\n\nconst result = matches(subjectToMatch)(...functions)",
        "new_file_code_segment": "module.exports = (matchValue, subjectToMatch) => {\n  if (typeof matchValue === 'function' && typeof subjectToMatch === 'function') {\n    return matchValue.toString() === subjectToMatch.toString()\n  }\n  return false\n}",
        "feature_description": "Add support for function equality checks in the match function.",
        "detailed_feature_description": "The new feature extends the match function to support checking if two functions are equal by comparing their string representations. This is implemented in a new file (#file 4) and is invoked within the match function in #file 1. The resolveMatchFunctions in #file 2 is updated to handle this new functionality, and the matches function in #file 3 remains unchanged as it directly uses the modified match function.",
        "modified_complete_code": {
            "z/src/match.js": "#Modify module.exports = (match, subjectToMatch) => {\n  const hasMatchValue = match.args[0].length >= 2\n  if (!hasMatchValue) {\n    return option.Some(subjectToMatch)\n  }\n\n  const matchValue = match.args[0][1]\n\n  // if is a type check, check type\n  if (matchValue === Boolean && typeof subjectToMatch === 'boolean') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === undefined && typeof subjectToMatch === 'undefined') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === Number && typeof subjectToMatch === 'number') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === String && typeof subjectToMatch === 'string') {\n    return option.Some(subjectToMatch)\n  }\n  if (matchValue === Object && typeof subjectToMatch === 'object') {\n    return option.Some(subjectToMatch)\n  }\n\n  // if is instance check, check instance\n  if (\n    typeof matchValue === 'function' &&\n    subjectToMatch instanceof matchValue\n  ) {\n    return option.Some(subjectToMatch)\n  }\n\n  // if it is a regex, and the value is a string, test that it matches\n  if (matchValue instanceof RegExp && typeof subjectToMatch === 'string') {\n    if (matchValue.test(subjectToMatch)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if its array\n  if (\n    subjectToMatch instanceof Array &&\n    matchValue instanceof Array\n  ) {\n    if (deepEqual(subjectToMatch, matchValue)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if is object (and not an array), check if contains\n  if (typeof subjectToMatch === 'object' && subjectToMatch !== null && !(subjectToMatch instanceof Array) && typeof matchValue === 'object') {\n    if (objectEquals(matchValue, subjectToMatch)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  // if is value check, check value\n  if (subjectToMatch === matchValue) {\n    return option.Some(subjectToMatch)\n  }\n\n  // New: Check if both are functions and their string representations are equal\n  if (typeof matchValue === 'function' && typeof subjectToMatch === 'function') {\n    if (functionEqualityCheck(matchValue, subjectToMatch)) {\n      return option.Some(subjectToMatch)\n    }\n  }\n\n  return option.None\n}",
            "z/src/z.js": "#Modify const resolveMatchFunctions = (subjectToMatch, functions, scope) => {\n  for (let i = 0; i < functions.length; i++) {\n    const currentMatch = getMatchDetails.call(scope, functions[i])\n\n    const matchHasSingleArgument = currentMatch.args.length === 1\n    if (matchHasSingleArgument) {\n      const singleValueResolve = match(currentMatch, subjectToMatch)\n      if (singleValueResolve.hasValue) {\n        return currentMatch.func(singleValueResolve.value)\n      }\n    }\n\n    const matchHasMultipleArguments = currentMatch.args.length > 1\n    if (matchHasMultipleArguments && Array.isArray(subjectToMatch)) {\n      const multipleItemResolve = matchArray(currentMatch, subjectToMatch)\n      if (\n        multipleItemResolve.hasValue &&\n        Array.isArray(multipleItemResolve.value)\n      ) {\n        return currentMatch.func.apply(null, multipleItemResolve.value)\n      }\n\n      if (multipleItemResolve.hasValue) {\n        return currentMatch.func(multipleItemResolve.value)\n      }\n    }\n\n    if (\n      hasDestructuredObjectArguments(currentMatch.args) &&\n      objectAndArgsDestructureMatches(currentMatch.args, subjectToMatch)\n    ) {\n      return currentMatch.func(subjectToMatch)\n    }\n  }\n}",
            "z/src/matchArray.js": "#New module.exports = (matchValue, subjectToMatch) => {\n  if (typeof matchValue === 'function' && typeof subjectToMatch === 'function') {\n    return matchValue.toString() === subjectToMatch.toString()\n  }\n  return false\n}",
            "z/src/utils.js": "#New const functionEqualityCheck = require('./matchArray')\n\nmodule.exports = {\n  functionEqualityCheck\n}"
        }
    },
    {
        "repo": "modern-desktop-app-template",
        "content": "'modern-desktop-app-template/src/components/ScrollToTop.jsx'\n:import { ActionIcon, Affix, Transition, useComputedColorScheme } from '@mantine/core';\nimport { useEffect, useState } from 'react';\nimport { IoArrowUp } from 'react-icons/io5';\n\nexport function ScrollToTop({ scroller, bottom = 10 }) {\n  const [scrollY, setScrollY] = useState();\n  const colorScheme = useComputedColorScheme();\n\n  const handleScroll = () => {\n    setScrollY(scroller.scrollTop);\n  };\n\n  useEffect(() => {\n    if (scroller !== null) {\n      scroller.addEventListener('scroll', handleScroll, { passive: true });\n      return () => {\n        scroller.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [scroller]);\n\n  return <Affix position={{ bottom, right: 20 }}>\n    <Transition transition='slide-up' mounted={scrollY > 0}>\n      {transitionStyles =>\n        <ActionIcon style={transitionStyles} size='lg' variant={colorScheme === 'dark' ? 'light' : 'filled'}\n          onClick={() => scroller.scrollTo({ top: 0, behavior: 'smooth' })}>\n          <IoArrowUp size={25} />\n        </ActionIcon>\n      }\n    </Transition>\n  </Affix>;\n}\n\n'modern-desktop-app-template/src/App.jsx'\n:import { ActionIcon, AppShell, AppShellAside, AppShellFooter, AppShellHeader, AppShellMain, AppShellNavbar, AppShellSection, Burger, Button, Group, Space, Text, useComputedColorScheme, useMantineColorScheme } from '@mantine/core';\n\nimport { useDisclosure, useHotkeys } from '@mantine/hooks';\n\nimport { notifications } from '@mantine/notifications';\n\nimport * as tauriEvent from '@tauri-apps/api/event';\n\nimport { relaunch } from '@tauri-apps/api/process';\n\nimport { checkUpdate, installUpdate } from '@tauri-apps/api/updater';\n\nimport { appWindow } from '@tauri-apps/api/window';\n\nimport React, { useEffect, useRef, useState } from 'react';\n\nimport { useTranslation } from 'react-i18next';\n\nimport { BsMoonStarsFill } from 'react-icons/bs';\n\nimport { ImCross } from 'react-icons/im';\n\nimport { IoSunnySharp } from 'react-icons/io5';\n\nimport { NavLink, Navigate, Route, Routes } from 'react-router-dom';\n\nimport SimpleBar from 'simplebar-react';\n\nimport 'simplebar-react/dist/simplebar.min.css';\n\nimport classes from './App.module.css';\n\n// src imports\n\nimport { FOOTER, HEADER_TITLE, useCookie, useLocalForage } from './common/utils';\n\nimport LanguageHeaders from './components/LanguageHeaders';\n\nimport { ScrollToTop } from './components/ScrollToTop';\n\nimport { RUNNING_IN_TAURI, useTauriContext } from './tauri/TauriProvider';\n\n// imported views need to be added to the `views` list variable\n\nimport ExampleView from './views/ExampleView';\n\n// fallback for React Suspense\n\n// import Home from './Views/Home';\n\n// import About from './Views/About';\n\n// import CIFInfo from './Views/CIFInfo';\n\n// if your views are large, you can use lazy loading to reduce the initial load time\n\n// const Settings = lazy(() => import('./Views/Settings'));\n\n\n\nexport default function () {\n\n  const { t, i18n } = useTranslation();\n\n  // check if using custom titlebar to adjust other components\n\n  const { usingCustomTitleBar } = useTauriContext();\n\n\n\n  // left sidebar\n\n  const views = [\n\n    //     { component: () => <Home prop1={'stuff'} />, path: '/home', name: t('Home') },\n\n    //     { component: CIFInfo, path: '/cif-info', name: 'CIF ' + t('Info') },\n\n    //     { component: React.memo(About), path: '/about', name: t('About') },\n\n    // Suspense example when a component was lazy loaded\n\n    //     { component: () => <React.Suspense fallback={<Fallback />}><Setting /></React.Suspense>, path: '/settings', name: t('Settings') },\n\n    { component: ExampleView, path: '/example-view', name: t('ExampleView') },\n\n  ];\n\n\n\n  const { toggleColorScheme } = useMantineColorScheme();\n\n  const colorScheme = useComputedColorScheme();\n\n  useHotkeys([['ctrl+J', toggleColorScheme]]);\n\n\n\n  // opened is for mobile nav\n\n  const [mobileNavOpened, { toggle: toggleMobileNav }] = useDisclosure();\n\n  const [desktopNavOpened, setDesktopNavOpened] = useCookie('desktop-nav-opened', true);\n\n  const toggleDesktopNav = () => setDesktopNavOpened(o => !o);\n\n  // load preferences using localForage\n\n  const [footersSeen, setFootersSeen, footersSeenLoading] = useLocalForage('footersSeen', {});\n\n\n\n  const [navbarClearance, setNavbarClearance] = useState(0);\n\n  const footerRef = useRef(null);\n\n  useEffect(() => {\n\n    if (footerRef.current) setNavbarClearance(footerRef.current.clientHeight);\n\n  }, [footersSeen]);\n\n\n\n  // Updater integration\n\n\n\n  function startInstall(newVersion) {\n\n    notifications.show({ title: t('Installing update v{{ v }}', { v: newVersion }), message: t('Will relaunch afterwards'), autoClose: false });\n\n    installUpdate().then(relaunch);\n\n  }\n\n\n\n  // Tauri event listeners (run on mount)\n\n  if (RUNNING_IN_TAURI) {\n\n    useEffect(() => {\n\n      const promise = tauriEvent.listen('longRunningThread', ({payload}) => {\n\n        console.log(payload.message);\n\n      });\n\n      return () => promise.then(unlisten => unlisten());\n\n    }, []);\n\n    // system tray events\n\n    useEffect(() => {\n\n      const promise = tauriEvent.listen('systemTray', ({ payload, ...eventObj }) => {\n\n        console.log(payload.message);\n\n        // for debugging purposes only\n\n        notifications.show({\n\n          title: '[DEBUG] System Tray Event',\n\n          message: payload.message\n\n        });\n\n      });\n\n      return () => promise.then(unlisten => unlisten());\n\n    }, []);\n\n\n\n    // update checker\n\n    useEffect(() => {\n\n      checkUpdate().then(({ shouldUpdate, manifest }) => {\n\n        if (shouldUpdate) {\n\n          const { version: newVersion, body: releaseNotes } = manifest;\n\n          const color = colorScheme === 'dark' ? 'teal' : 'teal.8';\n\n          notifications.show({\n\n            title: t('Update v{{ v }} available', { v: newVersion }),\n\n            color,\n\n            message: <>\n\n              <Text>{releaseNotes}</Text>\n\n              <Button color={color} style={{ width: '100%' }} onClick={() => startInstall(newVersion)}>{t('Install update and relaunch')}</Button>\n\n            </>,\n\n            autoClose: false\n\n          });\n\n        }\n\n      });\n\n    }, []);\n\n\n\n    // Handle additional app launches (url, etc.)\n\n    useEffect(() => {\n\n      const promise = tauriEvent.listen('newInstance', async ({ payload, ...eventObj }) => {\n\n        if (!(await appWindow.isVisible())) await appWindow.show();\n\n\n\n        if (await appWindow.isMinimized()) {\n\n          await appWindow.unminimize();\n\n          await appWindow.setFocus(true);\n\n        }\n\n\n\n        let args = payload?.args;\n\n        let cwd = payload?.cwd;\n\n        if (args?.length > 1) {\n\n\n\n        }\n\n      });\n\n      return () => promise.then(unlisten => unlisten());\n\n    }, []);\n\n  }\n\n\n\n  function NavLinks() {\n\n    // TODO: useHotkeys and abstract this\n\n    return views.map((view, index) =>\n\n      <NavLink align='left' to={view.path} key={index} end={view.exact} onClick={() => toggleMobileNav(false)}\n\n        className={({ isActive }) => classes.navLink + ' ' + (isActive ? classes.navLinkActive : classes.navLinkInactive)}>\n\n        {/* TODO: Icons */}\n\n        <Group><Text>{view.name ? view.name : view.name}</Text></Group>\n\n      </NavLink>\n\n    );\n\n  }\n\n\n\n  const showFooter = FOOTER && !footersSeenLoading && !(FOOTER in footersSeen);\n\n  const footerText = t(FOOTER);\n\n\n\n  const scrollbarRef = useRef();\n\n\n\n  // hack for global styling the vertical simplebar based on state\n\n  useEffect(() => {\n\n    const el = document.getElementsByClassName('simplebar-vertical')[0];\n\n    if (el !== undefined) {\n\n      el.style.marginTop = usingCustomTitleBar ? '100px' : '70px';\n\n      el.style.marginBottom = showFooter ? '50px' : 0;\n\n    }\n\n  }, [usingCustomTitleBar, showFooter]);\n\n\n\n  return <>\n\n    <SimpleBar scrollableNodeProps={{ ref: scrollbarRef }} autoHide={false} className={classes.simpleBar}>\n\n      <AppShell padding='md'\n\n        header={{ height: 60 }}\n\n        footer={{ height: showFooter ? 60 : undefined }}\n\n        navbar={{ width: 200, breakpoint: 'sm', collapsed: { mobile: !mobileNavOpened, desktop: !desktopNavOpened } }}\n\n        aside={{ width: 200, breakpoint: 'sm', collapsed: { desktop: false, mobile: true } }}\n\n        className={classes.appShell}>\n\n        <AppShellMain>\n\n          {usingCustomTitleBar && <Space h='xl' />}\n\n          <Routes>\n\n            <Route exact path='/' element={<Navigate to={views[0].path} />} />\n\n            {views.map((view, index) => <Route key={index} exact={view.exact}\n\n              path={view.path} element={\n\n                <view.component />\n\n              } />)}\n\n          </Routes>\n\n          {/* prevent the footer from covering bottom text of a route view */}\n\n          <Space h={showFooter ? 80 : 50} />\n\n          <ScrollToTop scroller={scrollbarRef.current} bottom={showFooter ? 70 : 20} />\n\n        </AppShellMain>\n\n\n\n        <AppShellHeader data-tauri-drag-region p='md' className={classes.header}>\n\n          <Group h='100%'>\n\n            <Burger hiddenFrom='sm' opened={mobileNavOpened} onClick={toggleMobileNav} size='sm' />\n\n            <Burger visibleFrom='sm' opened={desktopNavOpened} onClick={toggleDesktopNav} size='sm' />\n\n            <Text>{HEADER_TITLE}</Text>\n\n          </Group>\n\n          <Group className={classes.headerRightItems} h='110%'>\n\n            <LanguageHeaders i18n={i18n} />\n\n            <ActionIcon id='toggle-theme' title='Ctrl + J' variant='default' onClick={toggleColorScheme} size={30}>\n\n              {/* icon to show based on colorScheme */}\n\n              {colorScheme === 'dark' ? <IoSunnySharp size={'1.5em'} /> : <BsMoonStarsFill />}\n\n            </ActionIcon>\n\n          </Group>\n\n        </AppShellHeader>\n\n\n\n        <AppShellNavbar className={classes.titleBarAdjustedHeight} height='100%' width={{ sm: 200 }} p='xs' hidden={!mobileNavOpened}>\n\n          <AppShellSection grow><NavLinks /></AppShellSection>\n\n          <AppShellSection>\n\n            {/* Bottom of Navbar Example: https://github.com/mantinedev/mantine/blob/master/src/mantine-demos/src/demos/core/AppShell/_user.tsx */}\n\n            <Space h={navbarClearance} /> {/* Account for footer */}\n\n          </AppShellSection>\n\n        </AppShellNavbar>\n\n\n\n        <AppShellAside className={classes.titleBarAdjustedHeight} p='md' width={{ sm: 200, lg: 300 }}>\n\n          <Text>Right Side. Use for help, support, quick action menu? For example, if we were building a trading app, we could use the aside for the trade parameters while leaving the main UI with the data</Text>\n\n        </AppShellAside>\n\n\n\n        {showFooter &&\n\n          <AppShellFooter p='md' className={classes.footer}>\n\n            {footerText}\n\n            <Button variant='subtle' size='xs' onClick={() => setFootersSeen(prev => ({ ...prev, [FOOTER]: '' }))}>\n\n              <ImCross />\n\n            </Button>\n\n          </AppShellFooter>\n\n        }\n\n      </AppShell>\n\n    </SimpleBar>\n\n  </>;\n\n}\n\n\n'modern-desktop-app-template/src/main.jsx'\n:import React from 'react';\nimport { createRoot } from 'react-dom/client';\nimport App from './App';\n// boilerplate components\nimport Providers from './Providers';\n// for internationalization (translations)\nimport './translations/i18n.js'\n\n\nconst root = createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <Providers>\n      <App />\n    </Providers>\n  </React.StrictMode>\n);\n\n",
        "called_code_segment_file_1": "export function ScrollToTop({ scroller, bottom = 10 }) {\n  const [scrollY, setScrollY] = useState();\n  const colorScheme = useComputedColorScheme();\n\n  const handleScroll = () => {\n    setScrollY(scroller.scrollTop);\n  };\n\n  useEffect(() => {\n    if (scroller !== null) {\n      scroller.addEventListener('scroll', handleScroll, { passive: true });\n      return () => {\n        scroller.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [scroller]);\n\n  return <Affix position={{ bottom, right: 20 }}>\n    <Transition transition='slide-up' mounted={scrollY > 0}>\n      {transitionStyles =>\n        <ActionIcon style={transitionStyles} size='lg' variant={colorScheme === 'dark' ? 'light' : 'filled'}\n          onClick={() => scroller.scrollTo({ top: 0, behavior: 'smooth' })}>\n          <IoArrowUp size={25} />\n        </ActionIcon>\n      }\n    </Transition>\n  </Affix>;\n}",
        "invoking_code_segment_file_2": "<ScrollToTop scroller={scrollbarRef.current} bottom={showFooter ? 70 : 20} />",
        "invoking_code_segment_file_3": "No direct invocation of #file 1 in #file 3.",
        "new_file_code_segment": "export function CustomScrollToTop({ scroller, bottom = 10, customMessage }) {\n  const [scrollY, setScrollY] = useState();\n  const colorScheme = useComputedColorScheme();\n\n  const handleScroll = () => {\n    setScrollY(scroller.scrollTop);\n  };\n\n  useEffect(() => {\n    if (scroller !== null) {\n      scroller.addEventListener('scroll', handleScroll, { passive: true });\n      return () => {\n        scroller.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [scroller]);\n\n  return <Affix position={{ bottom, right: 20 }}>\n    <Transition transition='slide-up' mounted={scrollY > 0}>\n      {transitionStyles =>\n        <ActionIcon style={transitionStyles} size='lg' variant={colorScheme === 'dark' ? 'light' : 'filled'}\n          onClick={() => {\n            scroller.scrollTo({ top: 0, behavior: 'smooth' });\n            alert(customMessage);\n          }}>\n          <IoArrowUp size={25} />\n        </ActionIcon>\n      }\n    </Transition>\n  </Affix>;\n}",
        "feature_description": "Add a custom message alert when the 'Scroll to Top' button is clicked.",
        "detailed_feature_description": "The new feature involves modifying the 'ScrollToTop' component to accept a custom message. When the 'Scroll to Top' button is clicked, the custom message will be displayed in an alert box. This functionality is implemented in a new file (#file 4) and integrated into the existing codebase.",
        "modified_complete_code": {
            "file_1": "export function ScrollToTop({ scroller, bottom = 10, customMessage }) {\n  const [scrollY, setScrollY] = useState();\n  const colorScheme = useComputedColorScheme();\n\n  const handleScroll = () => {\n    setScrollY(scroller.scrollTop);\n  };\n\n  useEffect(() => {\n    if (scroller !== null) {\n      scroller.addEventListener('scroll', handleScroll, { passive: true });\n      return () => {\n        scroller.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [scroller]);\n\n  return <Affix position={{ bottom, right: 20 }}>\n    <Transition transition='slide-up' mounted={scrollY > 0}>\n      {transitionStyles =>\n        <ActionIcon style={transitionStyles} size='lg' variant={colorScheme === 'dark' ? 'light' : 'filled'}\n          onClick={() => {\n            scroller.scrollTo({ top: 0, behavior: 'smooth' });\n            alert(customMessage);\n          }}>\n          <IoArrowUp size={25} />\n        </ActionIcon>\n      }\n    </Transition>\n  </Affix>;\n}",
            "file_2": "<CustomScrollToTop scroller={scrollbarRef.current} bottom={showFooter ? 70 : 20} customMessage='You have scrolled to the top!' />",
            "file_3": "No changes required in #file 3.",
            "file_4": "export function CustomScrollToTop({ scroller, bottom = 10, customMessage }) {\n  const [scrollY, setScrollY] = useState();\n  const colorScheme = useComputedColorScheme();\n\n  const handleScroll = () => {\n    setScrollY(scroller.scrollTop);\n  };\n\n  useEffect(() => {\n    if (scroller !== null) {\n      scroller.addEventListener('scroll', handleScroll, { passive: true });\n      return () => {\n        scroller.removeEventListener('scroll', handleScroll);\n      };\n    }\n  }, [scroller]);\n\n  return <Affix position={{ bottom, right: 20 }}>\n    <Transition transition='slide-up' mounted={scrollY > 0}>\n      {transitionStyles =>\n        <ActionIcon style={transitionStyles} size='lg' variant={colorScheme === 'dark' ? 'light' : 'filled'}\n          onClick={() => {\n            scroller.scrollTo({ top: 0, behavior: 'smooth' });\n            alert(customMessage);\n          }}>\n          <IoArrowUp size={25} />\n        </ActionIcon>\n      }\n    </Transition>\n  </Affix>;\n}"
        }
    },
    {
        "repo": "replpad",
        "content": "'replpad/lib/utl.js'\n:'use strict';\n\nvar path    =  require('path')\n  , fs      =  require('fs')\n  , util    =  require('util')\n  , logFile =  path.join(__dirname, '../logs/debug.log');\n\nexports.shallowClone = function shallowClone(obj) {\n  var clone = {};\n  Object.keys(obj).forEach(function (k) {\n    clone[k] = obj[k];\n  });\n  return clone;\n};\n\nexports.pad = function pad(s, len, padding) {\n  len = len || 0;\n  padding = padding || ' ';\n\n  return len + 1 >= s.length\n    ? s + new Array(len + 1 - s.length).join(padding)\n    : s;\n};\n\nexports.log = function log(obj, depth) {\n  var s = util.inspect(obj, false, depth || 5, true);\n  fs.appendFileSync(logFile, s);\n};\n\nexports.inspect = function(obj, depth) {\n  return util.inspect(obj, false, depth || 5, true);\n};\n\nexports.existsSync =  fs.existsSync || path.existsSync;\n\n/**\n * Copies srcFile to tgtFile without checking if paths are valid and calls back when done.\n * srcFile is streamed to tgtFile\n *\n * @name copyFile\n * @function\n * @param srcFile {String}\n * @param tgtFile {String}\n * @param cb {Function} called when file is completely copied or an error occurs\n */\nexports.copyFile = function (srcFile, tgtFile, cb) {\n  var readStream = fs.createReadStream(srcFile)\n    , writeStream = fs.createWriteStream(tgtFile);\n\n  writeStream\n    .on('close', cb)\n    .on('error', cb);\n\n  readStream\n    .on('error', cb);\n\n  readStream.pipe(writeStream);\n};\n\n\n/**\n * Copies srcFile to tgtFile without checking if paths are valid and returns when done.\n * srcFile is copied to tgtFile in chunks\n *\n * @name copyFileSync\n * @function\n * @param srcFile {String}\n * @param tgtFile {String}\n * @return {void}\n */\nexports.copyFileSync = function(srcFile, tgtFile) {\n  var buflen    =  64 * 1024\n    , buf       =  new Buffer(buflen)\n    , fdr       =  fs.openSync(srcFile, 'r')\n    , fdw       =  fs.openSync(tgtFile, 'w')\n    , bytesRead =  1\n    , pos       =  0\n    ;\n\n  while (bytesRead > 0) {\n    bytesRead = fs.readSync(fdr, buf, 0, buflen, pos);\n    fs.writeSync(fdw, buf, 0, bytesRead);\n    pos += bytesRead;\n  }\n\n  fs.closeSync(fdr);\n  return fs.closeSync(fdw);\n};\n\n'replpad/lib/complete-append.js'\n:var cardinal =  require('cardinal')\n  , rewrite  =  require('./rewrite')\n  , config   =  require('../config/current')\n  , utl      =  require('./utl');\n\n/**\n * Tries to grab a complete JavaScript snippet from the history.\n *\n * @name completeAppend\n * @function\n * @param history {Array[{String}]} last entered lines in reverse order (i.e., last entered line is at index 0)\n * @return {Object} the smallest portion of the history that was parsable or just the last line if none was found as { raw, highlighted }\n */\nmodule.exports = function completeAppend(history) {\n  var highlighted\n    , code = ''\n    , rewritten\n    , l = history.length\n    , start = 0\n    , format = utl.shallowClone(config.feed.format);\n\n  if (l === 0) return null;\n\n  // skip commands, i.e. '.append'\n  while (/^[ ]*\\.\\w+[ ]*$/.test(history[start])) {\n    start++;\n    if (start == l) return null;\n  }\n\n  format.compact = false;\n  for (var i = start; i < l; i++) {\n    try {\n      code = '\\n' + history[i] + code;\n\n      rewritten = '\\n' + rewrite(code, format);\n      highlighted = cardinal.highlight(rewritten);\n      // no blow up means code was parsable, so we are done\n      return { raw: rewritten, highlighted: highlighted };\n    } catch (e) {/* keep trying */ }\n  }\n\n  code = '\\n' + history[start] + '\\n';\n  // we got here because no parsable portion was found\n  return { raw: code, highlighted: code };\n};\n\n'replpad/test/complete-append.js'\n:/*jshint asi:true */\n'use strict';\n\nvar test = require('tap').test\n  , completeAppend = require('../lib/complete-append')\n  , config = require('../config/current')\n\nconfig.feed.format = {\n    indent      :  { style: '  ', base: 0 }\n  , quotes      :  'single'\n  , json        :  false\n  , renumber    :  false\n  , hexadecimal :  false\n  , escapeless  :  false\n  , compact     :  true\n  , parentheses :  false\n  , semicolons  :  true\n};\n\ntest('\\nhandles no history case', function (t) {\n  var history = []\n    , append = completeAppend(history)\n\n  t.equal(append, null, 'returns null')\n  t.end()\n})\n\ntest('\\nhandles command only case', function (t) {\n  var history = [' .append  ']\n    , append = completeAppend(history)\n\n  t.equal(append, null, 'returns null')\n  t.end()\n})\n\ntest('\\nappends first expression before command', function (t) {\n  var history = [\n       '2 + 3'\n    ,  'var a = true;'\n    ,  '.append'\n    ].reverse()\n    , expected = '\\nvar a = true;\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\nappends multiline function before commands', function (t) {\n  var history = [\n      'function foo() {'\n    ,  '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ,  '   .clear '\n    ,  '.append'\n    ].reverse()\n\n    , expected = '\\nfunction foo() {\\n  var a = 2;\\n  return a + 1;\\n}\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ncompletes 3 line function at end of history', function (t) {\n  var history = [\n      '1'\n    , '2'\n    , 'function foo() {'\n    ,  '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ].reverse()\n    , expected = '\\nfunction foo() {\\n  var a = 2;\\n  return a + 1;\\n}\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ncompletes 3 line function at end of history that are badly formatted in a better formatted way', function (t) {\n  var history = [\n      '1'\n    , '2'\n    , 'function foo() {'\n    ,  'var a = 2;'\n    ,  '           return a + 1;'\n    ,  '}'\n    ].reverse()\n    , expected = '\\nfunction foo() {\\n  var a = 2;\\n  return a + 1;\\n}\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ndoes not complete incomplete function at end of history', function (t) {\n  var history = [\n       '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ].reverse()\n    , expected = '\\n}\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.equal(append.raw, append.highlighted, 'does not highlight')\n    t.end()\n})\n\ntest('\\ncompletes 2 + 3 at end of history', function (t) {\n  var history = [\n       '3 + 4'\n    ,  '2 + 3'\n    ].reverse()\n    , expected = '\\n2 + 3;\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ncompletes var a = true; at end of history with complete function right before', function (t) {\n  var history = [\n      'function foo () {'\n    ,  '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ,  'var a = true;'\n    ].reverse()\n    , expected = '\\nvar a = true;\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\ntest('\\ndoes not complete \"var a =\" at end of history with complete function right before', function (t) {\n  var history = [\n      'function foo () {'\n    ,  '  var a = 2;'\n    ,  '  return a + 1;'\n    ,  '}'\n    ,  'var a ='\n    ].reverse()\n    , expected = '\\nvar a =\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.equal(append.raw, append.highlighted, 'does not highlight')\n    t.end()\n})\n\ntest('\\ncompletes 2 + 3 close to end whan .append is at end of history, thus ignoring .append', function (t) {\n  var history = [\n       '2 + 3'\n    ,  '.append'\n    ].reverse()\n    , expected = '\\n2 + 3;\\n'\n    , append = completeAppend(history)\n\n    t.equal(append.raw, expected, 'gets raw')\n    t.notEqual(append.raw, append.highlighted, 'gets highlighted')\n    t.end()\n})\n\n",
        "called_code_segment_file_1": "module.exports = function completeAppend(history) {\n  var highlighted\n    , code = ''\n    , rewritten\n    , l = history.length\n    , start = 0\n    , format = utl.shallowClone(config.feed.format);\n\n  if (l === 0) return null;\n\n  // skip commands, i.e. '.append'\n  while (/^[ ]*\\.\\w+[ ]*$/.test(history[start])) {\n    start++;\n    if (start == l) return null;\n  }\n\n  format.compact = false;\n  for (var i = start; i < l; i++) {\n    try {\n      code = '\\n' + history[i] + code;\n\n      rewritten = '\\n' + rewrite(code, format);\n      highlighted = cardinal.highlight(rewritten);\n      // no blow up means code was parsable, so we are done\n      return { raw: rewritten, highlighted: highlighted };\n    } catch (e) {/* keep trying */ }\n  }\n\n  code = '\\n' + history[start] + '\\n';\n  // we got here because no parsable portion was found\n  return { raw: code, highlighted: code };\n};",
        "invoking_code_segment_file_2": "var append = completeAppend(history);\n\nt.equal(append, null, 'returns null');\nt.end();",
        "invoking_code_segment_file_3": "var history = [\n     '2 + 3'\n  ,  'var a = true;'\n  ,  '.append'\n].reverse();\nvar expected = '\\nvar a = true;\\n';\nvar append = completeAppend(history);\n\nt.equal(append.raw, expected, 'gets raw');\nt.notEqual(append.raw, append.highlighted, 'gets highlighted');\nt.end();",
        "new_file_code_segment": "module.exports = function logHistory(history) {\n  console.log('History:', history);\n};",
        "feature_description": "Add logging of the history array before invoking the `completeAppend` function.",
        "detailed_feature_description": "The new feature involves adding a logging mechanism to the `completeAppend` function. This will help in debugging and understanding the history array before any processing is done. A new file (#file 4) is created to implement this logging functionality. The `logHistory` function in #file 4 will be invoked from #file 2 and #file 3 to log the history array before calling `completeAppend`.",
        "modified_complete_code": {
            "#file 1": "module.exports = function completeAppend(history) {\n  var highlighted\n    , code = ''\n    , rewritten\n    , l = history.length\n    , start = 0\n    , format = utl.shallowClone(config.feed.format);\n\n  if (l === 0) return null;\n\n  // skip commands, i.e. '.append'\n  while (/^[ ]*\\.\\w+[ ]*$/.test(history[start])) {\n    start++;\n    if (start == l) return null;\n  }\n\n  format.compact = false;\n  for (var i = start; i < l; i++) {\n    try {\n      code = '\\n' + history[i] + code;\n\n      rewritten = '\\n' + rewrite(code, format);\n      highlighted = cardinal.highlight(rewritten);\n      // no blow up means code was parsable, so we are done\n      return { raw: rewritten, highlighted: highlighted };\n    } catch (e) {/* keep trying */ }\n  }\n\n  code = '\\n' + history[start] + '\\n';\n  // we got here because no parsable portion was found\n  return { raw: code, highlighted: code };\n};",
            "#file 2": "var logHistory = require('./logHistory'); // #New\n\nvar append = completeAppend(history);\nlogHistory(history); // #Modify\n\nt.equal(append, null, 'returns null');\nt.end();",
            "#file 3": "var logHistory = require('./logHistory'); // #New\n\nvar history = [\n     '2 + 3'\n  ,  'var a = true;'\n  ,  '.append'\n].reverse();\nvar expected = '\\nvar a = true;\\n';\nlogHistory(history); // #Modify\nvar append = completeAppend(history);\n\nt.equal(append.raw, expected, 'gets raw');\nt.notEqual(append.raw, append.highlighted, 'gets highlighted');\nt.end();",
            "#file 4": "module.exports = function logHistory(history) {\n  console.log('History:', history);\n};"
        }
    },
    {
        "repo": "parcel-plugin-imagemin",
        "content": "'parcel-plugin-imagemin/lib/parcelRequires.js'\n:const path = require('path');\n\nfunction getParcel() {\n  try {\n    require('parcel');\n    return 'parcel';\n  } catch (e) {\n    return 'parcel-bundler';\n  }\n}\n\nconst parcelRoot = parseInt(process.versions.node, 10) >= 8 ? `${getParcel()}/src/` : `${getParcel()}/lib/`;\n\nmodule.exports = {\n  config: require(path.join(parcelRoot, 'utils/config')),\n  Packager: require(getParcel()).Packager,\n  Asset: require(getParcel()).Asset\n};\n\n'parcel-plugin-imagemin/lib/assets/ImageAsset.js'\n:const fs = require('fs');\nconst path = require('path');\n\nconst Asset = require('../parcelRequires').Asset;\nconst urlJoin = require('../urlJoin');\n\nclass ImageAsset extends Asset {\n  constructor(...args) {\n    super(...args);\n\n    this.encoding = null;\n  }\n\n  async packageImage(options, location) {\n    return imagemin([location]);\n  }\n\n  async transform() {\n    if (this.options.minify) {\n      let config = await this.getConfig(['imagemin.config.js'], {\n        packageKey: 'imagemin'\n      });\n\n      let imagePath = path.resolve(this.name);\n      let stat = await new Promise((resolve, reject) =>\n        fs.stat(imagePath, (err, stats) => {\n          if (err) return reject(err);\n          resolve(stats);\n        })\n      );\n      let originalFileSize = stat.size;\n      let result = await this.packageImage(config, path.resolve(this.name));\n      if (result[0] && result[0].data && Buffer.isBuffer(result[0].data)) {\n        let minifiedSize = result[0].data.byteLength;\n        // If compressed version is larger for some reason, skip it\n        if (minifiedSize < originalFileSize) {\n          this.outputData = result[0].data;\n        }\n      }\n    }\n  }\n\n  generate() {\n    // Don't return a URL to the JS bundle if there is a bundle loader defined for this asset type.\n    // This will cause the actual asset to be automatically preloaded prior to the JS bundle running.\n    if (this.options.bundleLoaders[this.type]) {\n      return {};\n    }\n\n    const pathToAsset = urlJoin(this.options.publicURL, this.generateBundleName());\n\n    return [\n      {\n        type: this.type,\n        value: this.outputData || this.contents || null,\n        hasDependencies: false\n      }\n    ];\n  }\n}\n\nmodule.exports = ImageAsset;\n\n'parcel-plugin-imagemin/lib/assets/JpgAsset.js'\n:const ImageAsset = require('./ImageAsset');\n\n// Imagemin\nconst imagemin = require('imagemin');\nconst imageminMozjpeg = require('imagemin-mozjpeg');\n\nclass JpgAsset extends ImageAsset {\n  async packageImage(options, location) {\n    const params = options && options.mozjpeg ? options.mozjpeg : { quality: 75 };\n    return imagemin([location], {\n      plugins: [imageminMozjpeg(params)]\n    });\n  }\n}\n\nmodule.exports = JpgAsset;\n\n",
        "called_code_segment_file_1": "class ImageAsset extends Asset {\n  constructor(...args) {\n    super(...args);\n    this.encoding = null;\n  }\n\n  async packageImage(options, location) {\n    return imagemin([location]);\n  }\n\n  async transform() {\n    if (this.options.minify) {\n      let config = await this.getConfig(['imagemin.config.js'], {\n        packageKey: 'imagemin'\n      });\n\n      let imagePath = path.resolve(this.name);\n      let stat = await new Promise((resolve, reject) =>\n        fs.stat(imagePath, (err, stats) => {\n          if (err) return reject(err);\n          resolve(stats);\n        })\n      );\n      let originalFileSize = stat.size;\n      let result = await this.packageImage(config, path.resolve(this.name));\n      if (result[0] && result[0].data && Buffer.isBuffer(result[0].data)) {\n        let minifiedSize = result[0].data.byteLength;\n        if (minifiedSize < originalFileSize) {\n          this.outputData = result[0].data;\n        }\n      }\n    }\n  }\n\n  generate() {\n    if (this.options.bundleLoaders[this.type]) {\n      return {};\n    }\n\n    const pathToAsset = urlJoin(this.options.publicURL, this.generateBundleName());\n\n    return [\n      {\n        type: this.type,\n        value: this.outputData || this.contents || null,\n        hasDependencies: false\n      }\n    ];\n  }\n}",
        "invoking_code_segment_file_2": "class JpgAsset extends ImageAsset {\n  async packageImage(options, location) {\n    const params = options && options.mozjpeg ? options.mozjpeg : { quality: 75 };\n    return imagemin([location], {\n      plugins: [imageminMozjpeg(params)]\n    });\n  }\n}",
        "invoking_code_segment_file_3": "const path = require('path');\n\nfunction getParcel() {\n  try {\n    require('parcel');\n    return 'parcel';\n  } catch (e) {\n    return 'parcel-bundler';\n  }\n}\n\nconst parcelRoot = parseInt(process.versions.node, 10) >= 8 ? `${getParcel()}/src/` : `${getParcel()}/lib/`;\n\nmodule.exports = {\n  config: require(path.join(parcelRoot, 'utils/config')),\n  Packager: require(getParcel()).Packager,\n  Asset: require(getParcel()).Asset\n};",
        "new_file_code_segment": "const imagemin = require('imagemin');\nconst imageminPngquant = require('imagemin-pngquant');\n\nasync function optimizePng(location, options) {\n  const params = options && options.pngquant ? options.pngquant : { quality: '65-80' };\n  return imagemin([location], {\n    plugins: [imageminPngquant(params)]\n  });\n}\n\nmodule.exports = {\n  optimizePng\n};",
        "feature_description": "Add PNG optimization support.",
        "detailed_feature_description": "The new feature introduces PNG optimization using the `imagemin-pngquant` plugin. A new function `optimizePng` is added in #file 4 to handle PNG optimization. This function is then invoked in #file 1's `packageImage` method to handle PNG files. The `JpgAsset` class in #file 2 is updated to check the file type and invoke the appropriate optimization function from #file 4.",
        "modified_complete_code": {
            "#file 1": "const fs = require('fs');\nconst path = require('path');\n\nconst Asset = require('../parcelRequires').Asset;\nconst urlJoin = require('../urlJoin');\nconst { optimizePng } = require('./newFile'); //New\n\nclass ImageAsset extends Asset {\n  constructor(...args) {\n    super(...args);\n    this.encoding = null;\n  }\n\n  async packageImage(options, location) {\n    if (this.type === 'png') {\n      return optimizePng(location, options); //Modify\n    }\n    return imagemin([location]);\n  }\n\n  async transform() {\n    if (this.options.minify) {\n      let config = await this.getConfig(['imagemin.config.js'], {\n        packageKey: 'imagemin'\n      });\n\n      let imagePath = path.resolve(this.name);\n      let stat = await new Promise((resolve, reject) =>\n        fs.stat(imagePath, (err, stats) => {\n          if (err) return reject(err);\n          resolve(stats);\n        })\n      );\n      let originalFileSize = stat.size;\n      let result = await this.packageImage(config, path.resolve(this.name));\n      if (result[0] && result[0].data && Buffer.isBuffer(result[0].data)) {\n        let minifiedSize = result[0].data.byteLength;\n        if (minifiedSize < originalFileSize) {\n          this.outputData = result[0].data;\n        }\n      }\n    }\n  }\n\n  generate() {\n    if (this.options.bundleLoaders[this.type]) {\n      return {};\n    }\n\n    const pathToAsset = urlJoin(this.options.publicURL, this.generateBundleName());\n\n    return [\n      {\n        type: this.type,\n        value: this.outputData || this.contents || null,\n        hasDependencies: false\n      }\n    ];\n  }\n}",
            "#file 2": "const ImageAsset = require('./ImageAsset');\n\n// Imagemin\nconst imagemin = require('imagemin');\nconst imageminMozjpeg = require('imagemin-mozjpeg');\n\nclass JpgAsset extends ImageAsset {\n  async packageImage(options, location) {\n    const params = options && options.mozjpeg ? options.mozjpeg : { quality: 75 };\n    return imagemin([location], {\n      plugins: [imageminMozjpeg(params)]\n    });\n  }\n}",
            "#file 3": "const path = require('path');\n\nfunction getParcel() {\n  try {\n    require('parcel');\n    return 'parcel';\n  } catch (e) {\n    return 'parcel-bundler';\n  }\n}\n\nconst parcelRoot = parseInt(process.versions.node, 10) >= 8 ? `${getParcel()}/src/` : `${getParcel()}/lib/`;\n\nmodule.exports = {\n  config: require(path.join(parcelRoot, 'utils/config')),\n  Packager: require(getParcel()).Packager,\n  Asset: require(getParcel()).Asset\n};",
            "#file 4": "const imagemin = require('imagemin');\nconst imageminPngquant = require('imagemin-pngquant');\n\nasync function optimizePng(location, options) {\n  const params = options && options.pngquant ? options.pngquant : { quality: '65-80' };\n  return imagemin([location], {\n    plugins: [imageminPngquant(params)]\n  });\n}\n\nmodule.exports = {\n  optimizePng\n};"
        }
    },
    {
        "repo": "node-dualshock-controller",
        "content": "'node-dualshock-controller/src/gyro.js'\n:'use strict';\n// Module dependencies.\nvar dsutilities = require('./utilities'),\n    Smoothing = require('./smoothing'),\n    config = require('./config');\n\n//Proccess button events.\nvar motionProcessor = function(controller) {\n\n    var varianceThreshhold = 1,\n        smoothInput = config.getOptions().accelerometerSmoothing,\n        outputSmoothing = new Smoothing(smoothInput),\n        motionInputs = config.getControllerConfig().motionInputs;\n\n    //generate event name aliases:\n    motionInputs.forEach(function(motionAxis) {\n        motionAxis.eventPrefixes = dsutilities.generateEventPrefixAliases(motionAxis.name);\n    });\n\n    //Private methods\n    //data corrections so that each dirrection has a 0 throug x value\n    var correctData = function(motionAxis, data) {\n        var value;\n        //ensuring that both directions start from 0 and move to -x or x;\n        if (data[motionAxis.directionPin] === 1) {\n            //we need the values to be from 0 to x.\n            value = 255 - data[motionAxis.valuePin];\n        } else if (data[motionAxis.directionPin] === 2) {\n            //going in the oposite direction, we need to values to be from 0 to -x;\n            value = data[motionAxis.valuePin] * -1;\n        }\n\n        //return an object with both value and dirrection.\n        return {\n            direction: data[motionAxis.directionPin],\n            value: value\n        };\n    };\n\n    //process the axis movement.\n    var processAxis = function(motionAxis, data) {\n        //every motion will have a dirrection and a value\n        var motionValue = correctData(motionAxis, data),\n            lastPosition = outputSmoothing.readLastPosition(motionAxis.name);\n\n        //check if the values are within variance\n        if (dsutilities.isWithinVariance(lastPosition, motionValue.value, varianceThreshhold)) {\n            motionValue.value = outputSmoothing.smooth(motionAxis.name, motionValue.value);\n\n            // Don't assign motionValue directly to controller[motionAxis.name],\n            // this will break the reference.\n            if (controller[motionAxis.name]) {\n                controller[motionAxis.name].value = motionValue.value;\n                controller[motionAxis.name].direction = motionValue.direction;\n            }\n\n            motionAxis.eventPrefixes.forEach(function(eventPrefix) {\n                controller.emit(eventPrefix + ':motion', motionValue);\n            });\n        }\n    };\n\n    // Public methods\n    //process all configured motion inputs.\n    this.process = function(data) {\n        for (var i = 0; i < motionInputs.length; i++) {\n            processAxis(motionInputs[i], data);\n        }\n    };\n};\n\nmodule.exports = motionProcessor;\n\n'node-dualshock-controller/src/controller.js'\n:// Module dependencies.\nconst util = require('util'),\n    dsutilities = require('./utilities'),\n    Emitter = require('events').EventEmitter,\n    Gyro = require('./gyro'),\n    Analogs = require('./analogs'),\n    Buttons = require('./buttons'),\n    Status = require('./status'),\n    HID = require('node-hid'),\n    config = require('./config'),\n    TouchPad = require('./touchpad');\n\n//generic controller object, it will need a controller Configuration with a buttons array passed into its connect function.\nconst Controller = function() {\n    'use strict';\n    Emitter.call(this);\n\n    const controllerConfig = config.getControllerConfig(),\n        options = config.getOptions(),\n        indexes = controllerConfig.output.indexes,\n        analogs = new Analogs(this),\n        buttons = new Buttons(this),\n        gyro = new Gyro(this),\n        status = new Status(this),\n        touchPad = new TouchPad(this);\n\n    let device = null;\n\n    [{\n        type: 'analogSticks',\n        properties: [{\n            name: 'x',\n            initialValue: 0\n        }, {\n            name: 'y',\n            initialValue: 0\n        }]\n    }, {\n        type: 'buttons',\n        properties: [{\n            name: 'state',\n            initialValue: 0\n        }, {\n            name: 'value',\n            initialValue: 0\n        }]\n    }, {\n        type: 'motionInputs',\n        properties: [{\n            name: 'value',\n            initialValue: 0\n        }, {\n            name: 'direction',\n            initialValue: 0\n        }]\n    }, {\n        type: 'status',\n        properties: [{\n            name: 'state',\n            initialValue: ''\n        }]\n    }].forEach(function(setup) {\n        const entities = controllerConfig[setup.type],\n            properties = setup.properties;\n\n        if (entities.length) {\n            entities.forEach(function(entity) {\n                this[entity.name] = properties.reduce(function(accum, property) {\n                    return (accum[property.name] = property.initialValue, accum);\n                }, {});\n            }, this);\n        }\n    }, this);\n\n    //Private methods\n    //emit an error event or log it to the console.\n    const handleException = function(ex) {\n        //if exception was generated within our stream\n        if (this && this.emit) {\n            this.emit('error', ex);\n        } else {\n            dsutilities.warn(ex);\n            throw (ex);\n        }\n    };\n\n    //process data from HID connected device.\n    const processFrame = function(data) {\n        if (controllerConfig.motionInputs) {\n            gyro.process(data);\n        }\n        if (controllerConfig.analogSticks) {\n            analogs.process(data);\n        }\n        if (controllerConfig.buttons) {\n            buttons.process(data);\n        }\n        if (controllerConfig.status) {\n            status.process(data);\n        }\n        if (controllerConfig.touchPad) {\n            touchPad.process(data);\n        }\n    };\n\n    const isController = function(device) {\n        return device.vendorId == controllerConfig.vendorId && device.productId == controllerConfig.productId;\n    };\n\n    // Public methods\n    this.connect = function() {\n        dsutilities.warn('connect method is deprecated, controller now connects upon declaration.');\n    };\n\n    this.disconnect = function() {\n        if (device && device.close) {\n            device.close();\n        }\n        this.emit('disconnecting');\n        dsutilities.warn('node dualshock disconnecting');\n    };\n\n    // Used to set controller rumble and light\n    this.setExtras = function(data) {\n\n        let buff = controllerConfig.output.defaultBuffer.slice();\n\n        Object.keys(data).forEach(k => {\n            buff[indexes[k]] = data[k];\n        });\n        device.write(buff);\n    };\n\n    //connect to the controller.\n    if (typeof options.device === 'undefined') {\n        dsutilities.warn('node dualshock connecting');\n\n        const deviceMeta = HID.devices()\n            .filter(isController)[0];\n        if (deviceMeta) {\n            device = new HID.HID(deviceMeta.path);\n        } else {\n            handleException(new Error(`device with VID:${controllerConfig.vendorId} PID:${controllerConfig.productId} not found`));\n        }\n\n    } else {\n        // Allow user-specified device\n        device = options.device;\n    }\n\n    device.on('data', processFrame.bind(this));\n    device.on('error', handleException.bind(this));\n\n    //subscribe to the exit event:\n    process.on('exit', this.disconnect.bind(this));\n};\n\n//need to inherit from event emiter.\nutil.inherits(Controller, Emitter);\n\nmodule.exports = Controller;\n\n'node-dualshock-controller/src/dualshock.js'\n:// Module dependencies.\nvar Controller = require('./controller'),\n    config = require('./config');\n\n// This is the app entry point.\n//  options you can pass:\n//  {\n//   config : \"File from controllerConfigurations\" or a JS object containing configuration,\n//   accelerometerSmoothing : true/false, this will activate motion/acelerometer output smoothing. true by default.\n//   analogStickSmoothing : true/false, this will activate analog thumb stick smoothing\n//  }\nvar dualShock = function(options) {\n    'use strict';\n\n    //set the current options\n    config.setOptions(options);\n\n    //returns the controller.\n    return new Controller();\n};\n\nmodule.exports = dualShock;\n\n",
        "called_code_segment_file_1": "var correctData = function(motionAxis, data) {\n    var value;\n    //ensuring that both directions start from 0 and move to -x or x;\n    if (data[motionAxis.directionPin] === 1) {\n        //we need the values to be from 0 to x.\n        value = 255 - data[motionAxis.valuePin];\n    } else if (data[motionAxis.directionPin] === 2) {\n        //going in the oposite direction, we need to values to be from 0 to -x;\n        value = data[motionAxis.valuePin] * -1;\n    }\n\n    //return an object with both value and dirrection.\n    return {\n        direction: data[motionAxis.directionPin],\n        value: value\n    };\n};",
        "invoking_code_segment_file_2": "var processAxis = function(motionAxis, data) {\n    //every motion will have a dirrection and a value\n    var motionValue = correctData(motionAxis, data),\n        lastPosition = outputSmoothing.readLastPosition(motionAxis.name);\n\n    //check if the values are within variance\n    if (dsutilities.isWithinVariance(lastPosition, motionValue.value, varianceThreshhold)) {\n        motionValue.value = outputSmoothing.smooth(motionAxis.name, motionValue.value);\n\n        // Don't assign motionValue directly to controller[motionAxis.name],\n        // this will break the reference.\n        if (controller[motionAxis.name]) {\n            controller[motionAxis.name].value = motionValue.value;\n            controller[motionAxis.name].direction = motionValue.direction;\n        }\n\n        motionAxis.eventPrefixes.forEach(function(eventPrefix) {\n            controller.emit(eventPrefix + ':motion', motionValue);\n        });\n    }\n};",
        "invoking_code_segment_file_3": "device.on('data', processFrame.bind(this));",
        "new_file_code_segment": "// #file 4: new_feature.js\nconst newFeature = function(controller) {\n    this.process = function(data) {\n        // New feature logic\n        console.log('New feature processed:', data);\n    };\n};\n\nmodule.exports = newFeature;",
        "feature_description": "Add a new feature to log processed data.",
        "detailed_feature_description": "A new feature is added to log the processed data from the controller. This feature is implemented in a new file (#file 4) and is integrated into the existing flow by modifying the gyro.js (#file 1) to invoke the new feature. The controller.js (#file 2) and gyro.js (#file 1) are updated to handle this new feature.",
        "modified_complete_code": {
            "file_1": "// #file 1: gyro.js\nvar correctData = function(motionAxis, data) {\n    var value;\n    //ensuring that both directions start from 0 and move to -x or x;\n    if (data[motionAxis.directionPin] === 1) {\n        //we need the values to be from 0 to x.\n        value = 255 - data[motionAxis.valuePin];\n    } else if (data[motionAxis.directionPin] === 2) {\n        //going in the oposite direction, we need to values to be from 0 to -x;\n        value = data[motionAxis.valuePin] * -1;\n    }\n\n    //return an object with both value and dirrection.\n    return {\n        direction: data[motionAxis.directionPin],\n        value: value\n    };\n};\n\n// #Modify\nvar newFeature = require('./new_feature');\nvar newFeatureInstance = new newFeature(controller);\n\nvar processAxis = function(motionAxis, data) {\n    //every motion will have a dirrection and a value\n    var motionValue = correctData(motionAxis, data),\n        lastPosition = outputSmoothing.readLastPosition(motionAxis.name);\n\n    //check if the values are within variance\n    if (dsutilities.isWithinVariance(lastPosition, motionValue.value, varianceThreshhold)) {\n        motionValue.value = outputSmoothing.smooth(motionAxis.name, motionValue.value);\n\n        // Don't assign motionValue directly to controller[motionAxis.name],\n        // this will break the reference.\n        if (controller[motionAxis.name]) {\n            controller[motionAxis.name].value = motionValue.value;\n            controller[motionAxis.name].direction = motionValue.direction;\n        }\n\n        motionAxis.eventPrefixes.forEach(function(eventPrefix) {\n            controller.emit(eventPrefix + ':motion', motionValue);\n        });\n    }\n\n    // #Modify\n    newFeatureInstance.process(data);\n};",
            "file_2": "// #file 2: controller.js\n// #Modify\nconst newFeature = require('./new_feature');\nconst newFeatureInstance = new newFeature(this);\n\n//process data from HID connected device.\nconst processFrame = function(data) {\n    if (controllerConfig.motionInputs) {\n        gyro.process(data);\n    }\n    if (controllerConfig.analogSticks) {\n        analogs.process(data);\n    }\n    if (controllerConfig.buttons) {\n        buttons.process(data);\n    }\n    if (controllerConfig.status) {\n        status.process(data);\n    }\n    if (controllerConfig.touchPad) {\n        touchPad.process(data);\n    }\n\n    // #Modify\n    newFeatureInstance.process(data);\n};",
            "file_3": "// #file 3: dualshock.js\n// #Modify\nconst newFeature = require('./new_feature');\nconst newFeatureInstance = new newFeature(this);\n\n//connect to the controller.\nif (typeof options.device === 'undefined') {\n    dsutilities.warn('node dualshock connecting');\n\n    const deviceMeta = HID.devices()\n        .filter(isController)[0];\n    if (deviceMeta) {\n        device = new HID.HID(deviceMeta.path);\n    } else {\n        handleException(new Error(`device with VID:${controllerConfig.vendorId} PID:${controllerConfig.productId} not found`));\n    }\n\n} else {\n    // Allow user-specified device\n    device = options.device;\n}\n\ndevice.on('data', processFrame.bind(this));\ndevice.on('error', handleException.bind(this));\n\n//subscribe to the exit event:\nprocess.on('exit', this.disconnect.bind(this));\n\n// #Modify\nnewFeatureInstance.process(data);",
            "file_4": "// #file 4: new_feature.js\nconst newFeature = function(controller) {\n    this.process = function(data) {\n        // New feature logic\n        console.log('New feature processed:', data);\n    };\n};\n\nmodule.exports = newFeature;"
        }
    },
    {
        "repo": "nightwatch-cucumber",
        "content": "'nightwatch-cucumber/lib/cucumber-api.js'\n:const path = require('path')\nconst pify = require('pify')\nconst co = require('co')\nconst tmp = pify(require('tmp'), { include: ['file'] })\nconst fs = pify(require('fs'), { include: ['readFile', 'writeFile', 'unlink'] })\nconst Cucumber = {\n  Cli: require('cucumber/lib/cli').default,\n  TestCaseRunner: require('cucumber/lib/runtime/test_case_runner').default,\n  UserCodeRunner: require('cucumber/lib/user_code_runner').default,\n  statuses: require('cucumber/lib/status').default\n}\n\ntmp.setGracefulCleanup()\n\nmodule.exports = class CucumberAPI {\n  addAttachmentProvider (attachmentProvider) {\n    this.attachmentProvider = attachmentProvider\n    this.injectAttachmentHandler()\n  }\n\n  * handleAttachments (testCase, stepResult, attach) {\n    if (\n      !this.attachmentProvider ||\n        stepResult.status !== Cucumber.statuses.FAILED ||\n        stepResult._handledByNightwatchCucumber\n    ) return\n\n    stepResult._handledByNightwatchCucumber = true\n\n    try {\n      const feature = path.basename(testCase.uri, path.extname(testCase.uri))\n      const scenario = testCase.pickle.name\n      const attachment = yield * this.attachmentProvider(feature, scenario)\n\n      if (attachment) {\n        attach(attachment)\n      }\n    } catch (err) {\n      console.error(err.stack)\n    }\n  }\n\n  injectAttachmentHandler () {\n    const self = this\n    const originalTestCaseRunnerInvokeStep = Cucumber.TestCaseRunner.prototype.invokeStep\n    Cucumber.TestCaseRunner.prototype.invokeStep = co.wrap(function * (step, stepDefinition) {\n      const result = yield originalTestCaseRunnerInvokeStep.apply(this, arguments)\n\n      yield * self.handleAttachments(\n        this.testCase,\n        result,\n        ({ data, mimeType }) => {\n          this.emit('test-step-attachment', {\n            index: this.testStepIndex,\n            data,\n            media: {\n              type: mimeType\n            }\n          })\n        }\n      )\n\n      return result\n    })\n  }\n\n  injectTimeoutHandler () {\n    const originalUserCodeRunnerRun = Cucumber.UserCodeRunner.run\n    Cucumber.UserCodeRunner.run = function (props) {\n      props.timeoutInMilliseconds = -1\n      return originalUserCodeRunnerRun.call(this, props)\n    }\n  }\n\n  * run (args) {\n    const cli = new Cucumber.Cli({\n      argv: process.argv.slice(0, 2).concat(args),\n      cwd: process.cwd(),\n      stdout: process.stdout\n    })\n\n    return yield cli.run()\n  }\n\n  getJSONReportName (args) {\n    const pattern = /^(.*)json:(.*)$/\n    let i = 0\n    while (i < args.length - 2 && !(args[i] === '--format' && pattern.test(args[i + 1]))) {\n      i++\n    }\n    if (i < args.length - 2) {\n      return args[i + 1].match(pattern)[2]\n    }\n  }\n\n  isBooleanArg (args, index) {\n    const nextIndex = index + 1\n    return args[nextIndex].startsWith('--') || nextIndex === args.length - 1\n  }\n\n  getFeatureFiles (args) {\n    const featureFiles = []\n    let i = 0\n    while (i < args.length) {\n      if (args[i].startsWith('--')) {\n        i += this.isBooleanArg(args, i) ? 1 : 2\n      } else {\n        featureFiles.push(args[i])\n        i++\n      }\n    }\n    return featureFiles\n  }\n\n  getAdjustedArgs ({args, featureFiles, jsonReport, tags, skipTags}) {\n    const result = []\n    let i = 0\n    while (i < args.length) {\n      if (args[i] === '--format' && args[i + 1].startsWith('json:')) {\n        result.push('--format')\n        result.push(`json:${jsonReport}`)\n        i += 2\n      } else if (args[i].startsWith('--')) {\n        result.push(args[i])\n        if (this.isBooleanArg(args, i)) {\n          i++\n        } else {\n          result.push(args[i + 1])\n          i += 2\n        }\n      } else {\n        i++\n      }\n    }\n\n    if (tags.length || skipTags.length) {\n      result.push('--tags')\n      const joinedTags = tags.join(' or ')\n      const joinedSkipTags = skipTags.map(tag => `(not ${tag})`).join(' and ')\n      if (joinedTags && joinedSkipTags) {\n        result.push(`(${joinedTags}) and ${joinedSkipTags}`)\n      } else if (joinedTags) {\n        result.push(`${joinedTags}`)\n      } else if (joinedSkipTags) {\n        result.push(`${joinedSkipTags}`)\n      }\n    }\n\n    featureFiles.forEach((featureFile) => {\n      result.push(featureFile)\n    })\n\n    return result\n  }\n\n  * mergeCucumberJsonReports (reports, target) {\n    let sumReport = []\n    for (let i = 0; i < reports.length; i++) {\n      try {\n        const report = JSON.parse(yield fs.readFile(reports[i]))\n        sumReport = sumReport.concat(report)\n      } catch (e) {}\n      try {\n        yield fs.unlink(reports[i])\n      } catch (e) {}\n    }\n    yield fs.writeFile(target, JSON.stringify(sumReport, null, 2))\n  }\n}\n\n'nightwatch-cucumber/lib/runner.js'\n:const fs = require('fs')\nconst path = require('path')\nconst tmp = require('tmp')\nconst glob = require('glob')\nconst mkdirp = require('mkdirp')\nconst pify = require('pify')\nconst dummyTestModulesFolder = tmp.dirSync({ unsafeCleanup: true }).name\nconst NightwatchApi = require('./nightwatch-api')\nconst CucumberApi = require('./cucumber-api')\n\ntmp.setGracefulCleanup()\n\nmodule.exports = class Runner {\n  constructor () {\n    this.originalFeaturePath = {}\n  }\n\n  getSourceFile (featureSource) {\n    if (featureSource.startsWith('@')) {\n      return featureSource.substr(1, featureSource.length - 1)\n    }\n    return featureSource\n  }\n\n  getFeatureFilesFromRerunFile (rerunFile) {\n    const data = fs.readFileSync(this.getSourceFile(rerunFile))\n    return data.toString()\n      .split('\\n')\n      .map(featurePath => featurePath.trim().replace(/(:\\d*)/g, ''))\n      // filter empty paths\n      .filter(featurePath => featurePath)\n  }\n\n  getFeatureDirectories () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n            .map(featurePath => path.dirname(featurePath))\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return featureSource\n        }\n        return path.dirname(featureSource)\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n  }\n\n  getFeatureFiles () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return glob.sync(path.join(featureSource, '**/*.feature'))\n        }\n        return [featureSource]\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n      // make unique list\n      .filter((featureFilePath, idx, paths) => paths.indexOf(featureFilePath === idx))\n  }\n\n  generateDummyTestModules () {\n    this.getFeatureFiles().forEach((featureFile) => {\n      const dummyTestModuleFile = this.featurePathToDummyPath(featureFile)\n      mkdirp.sync(path.dirname(dummyTestModuleFile))\n      fs.writeFileSync(dummyTestModuleFile, '')\n    })\n  }\n\n  getTags (tags) {\n    tags = tags || []\n\n    if (typeof tags === 'string') {\n      tags = tags.split(',')\n    }\n\n    if (Array.isArray(tags)) {\n      return tags.map((tag) => `@${tag}`)\n    } else {\n      throw new Error(`Expected tags to be Array or String.`)\n    }\n  }\n\n  featurePathToDummyPath (featureFile) {\n    const lineNumberMatch = featureFile.match(/:(\\d+)$/)\n    let lineNumber\n    if (lineNumberMatch) {\n      lineNumber = parseInt(lineNumberMatch[1])\n      featureFile = featureFile.replace(/:\\d+$/, '')\n    }\n    try {\n      fs.statSync(featureFile)\n    } catch (err) {\n      if (!featureFile.match(/\\.feature$/)) featureFile += '.feature'\n      try {\n        fs.statSync(featureFile)\n      } catch (err) {\n        throw new Error(`Feature file or folder ${featureFile} was not found!`)\n      }\n    }\n\n    const dummyPath = path.join(dummyTestModulesFolder, featureFile.replace(/\\.feature$/, '.js'))\n\n    this.originalFeaturePath[dummyPath] = lineNumber ? `${featureFile}:${lineNumber}` : featureFile\n\n    return dummyPath\n  }\n\n  dummyPathToFeaturePath (dummyPath) {\n    if (!dummyPath.match(/\\.js$/)) dummyPath += '.js'\n\n    return this.originalFeaturePath[dummyPath] || dummyPath\n  }\n\n  addIndexToFileName (fileName, index) {\n    const cutIndex = fileName.lastIndexOf('.')\n    const ext = fileName.slice(cutIndex)\n    const rest = fileName.slice(0, cutIndex)\n    return `${rest}-${index}${ext}`\n  }\n\n  * executeTestModules (dummyTestModules) {\n    const featureFiles = dummyTestModules.map((dummyTestModule) => this.dummyPathToFeaturePath(dummyTestModule))\n\n    if (this.nightwatchApi.isRunningInParallel()) {\n      const workerIndex = this.nightwatchApi.getWorkerIndex()\n      this.jsonReport = this.addIndexToFileName(this.jsonReport, workerIndex)\n    }\n\n    if (this.jsonReport) {\n      yield pify(mkdirp)(path.dirname(this.jsonReport))\n    }\n    const cucumberArgs = this.cucumberApi.getAdjustedArgs({\n      args: this.options.cucumberArgs,\n      featureFiles,\n      jsonReport: this.jsonReport,\n      tags: this.getTags(this.nightwatchApi.nightwatchArgv.tag),\n      skipTags: this.getTags(this.nightwatchApi.nightwatchArgv.skiptags)\n    })\n    return yield * this.cucumberApi.run(cucumberArgs)\n  }\n\n  areColorsEnabled () {\n    const formatOptionsIndex = this.options.cucumberArgs.indexOf('--format-options')\n    if (formatOptionsIndex < 0) return true\n    const formatOptions = JSON.parse(this.options.cucumberArgs[formatOptionsIndex + 1])\n    return typeof formatOptions.colorsEnabled === 'undefined' ? true : formatOptions.colorsEnabled\n  }\n\n  run (options) {\n    const self = this\n    this.options = options\n    this.nightwatchApi = new NightwatchApi(options, this.areColorsEnabled())\n    this.cucumberApi = new CucumberApi(options)\n    this.jsonReport = this.cucumberApi.getJSONReportName(options.cucumberArgs)\n    this.featureFiles = this.cucumberApi.getFeatureFiles(options.cucumberArgs)\n    this.featureFiles\n      .map(this.getSourceFile)\n      .forEach((featureSource) => {\n        try {\n          fs.statSync(featureSource)\n        } catch (err) {\n          throw new Error(`Feature source ${featureSource} doesn't exists`)\n        }\n      })\n\n    // enforce relative paths so path.join() works on Windows\n    this.featureFiles = this.featureFiles.map((currentPath) => {\n      return path.isAbsolute(currentPath) ? path.relative(process.cwd(), currentPath) : currentPath\n    })\n\n    const dummyPaths = this.getFeatureDirectories().map(srcPath => path.join(dummyTestModulesFolder, srcPath))\n\n    this.generateDummyTestModules()\n\n    this.cucumberApi.injectTimeoutHandler()\n    this.cucumberApi.addAttachmentProvider(this.nightwatchApi.takeScreenshot.bind(this.nightwatchApi))\n\n    this.nightwatchApi.addTestModulePaths(dummyPaths)\n    this.nightwatchApi.addPathConverter(this.featurePathToDummyPath.bind(this), this.dummyPathToFeaturePath.bind(this))\n    this.nightwatchApi.overrideOriginalStartTestWorkers()\n    this.nightwatchApi.addTestRunner(this.executeTestModules.bind(this))\n    this.nightwatchApi.addHookAfterChildProcesses(function * () {\n      const reports = yield pify(glob)(self.addIndexToFileName(self.jsonReport, '*'))\n      yield * self.cucumberApi.mergeCucumberJsonReports(reports, self.jsonReport)\n    })\n  }\n}\n\n'nightwatch-cucumber/lib/index.js'\n:let runner\n\nmodule.exports = function (providedOptions) {\n  const options = Object.assign({\n    cucumberArgs: [\n      '--require', 'features/step_definitions',\n      '--format', 'json:reports/cucumber.json',\n      'features'\n    ],\n    nightwatchOutput: true\n  }, providedOptions)\n\n  const Runner = require('./runner')\n  runner = new Runner()\n  runner.run(options)\n}\n\nfunction getPageProxy (subPages) {\n  return new Proxy(() => getClientProxy(subPages), {\n    get: (target, pageName) => getPageProxy(subPages.concat([pageName]))\n  })\n}\n\nfunction getClientProxy (subPages) {\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (name !== 'page') {\n        const api = runner.nightwatchApi.getClientApi()\n\n        if (!subPages.length) {\n          return api[name]\n        }\n\n        return subPages.reduce((api, pageName) => {\n          return api[pageName]\n        }, api.page)()[name]\n      }\n\n      return getPageProxy([])\n    }\n  })\n}\n\nmodule.exports.client = getClientProxy([])\n\nmodule.exports.Section = new Proxy(function () {}, {\n  construct (target, args) {\n    return new runner.nightwatchApi.Section(...args)\n  }\n})\n\n",
        "called_code_segment_file_1": "addAttachmentProvider (attachmentProvider) {\n    this.attachmentProvider = attachmentProvider;\n    this.injectAttachmentHandler();\n  }",
        "invoking_code_segment_file_2": "this.cucumberApi.addAttachmentProvider(this.nightwatchApi.takeScreenshot.bind(this.nightwatchApi));",
        "invoking_code_segment_file_3": "const result = yield originalTestCaseRunnerInvokeStep.apply(this, arguments);\n\n      yield * self.handleAttachments(\n        this.testCase,\n        result,\n        ({ data, mimeType }) => {\n          this.emit('test-step-attachment', {\n            index: this.testStepIndex,\n            data,\n            media: {\n              type: mimeType\n            }\n          });\n        }\n      );",
        "new_file_code_segment": "function logStepResult(testCase, stepResult) {\n  console.log(`Step result for ${testCase.pickle.name}: ${stepResult.status}`);\n}",
        "feature_description": "Add logging for step results in Cucumber tests.",
        "detailed_feature_description": "The new feature involves adding logging for each step result in Cucumber tests. This will help in debugging and understanding the flow of tests better. A new function `logStepResult` is created in a new file (#file 4) to handle this logging. This function will be invoked within the existing `handleAttachments` method in #file 1, and the relevant parts of #file 2 and #file 3 will be updated to ensure compatibility.",
        "modified_complete_code": {
            "#file 1": "addAttachmentProvider (attachmentProvider) {\n    this.attachmentProvider = attachmentProvider;\n    this.injectAttachmentHandler();\n  }\n\n  * handleAttachments (testCase, stepResult, attach) {\n    if (\n      !this.attachmentProvider ||\n        stepResult.status !== Cucumber.statuses.FAILED ||\n        stepResult._handledByNightwatchCucumber\n    ) return\n\n    stepResult._handledByNightwatchCucumber = true\n\n    try {\n      const feature = path.basename(testCase.uri, path.extname(testCase.uri))\n      const scenario = testCase.pickle.name\n      const attachment = yield * this.attachmentProvider(feature, scenario)\n\n      if (attachment) {\n        attach(attachment)\n      }\n    } catch (err) {\n      console.error(err.stack)\n    }\n\n    #Modify: Add logging for step results\n    logStepResult(testCase, stepResult);\n  }\n\n  #New: Import the new logging function\n  const logStepResult = require('./logStepResult');",
            "#file 2": "this.cucumberApi.addAttachmentProvider(this.nightwatchApi.takeScreenshot.bind(this.nightwatchApi));",
            "#file 3": "const result = yield originalTestCaseRunnerInvokeStep.apply(this, arguments);\n\n      yield * self.handleAttachments(\n        this.testCase,\n        result,\n        ({ data, mimeType }) => {\n          this.emit('test-step-attachment', {\n            index: this.testStepIndex,\n            data,\n            media: {\n              type: mimeType\n            }\n          });\n        }\n      );",
            "#file 4": "function logStepResult(testCase, stepResult) {\n  console.log(`Step result for ${testCase.pickle.name}: ${stepResult.status}`);\n}"
        }
    },
    {
        "repo": "browsers-support-badges",
        "content": "'browsers-support-badges/src/components/footer.jsx'\n:/* eslint-disable */\n\nimport React from 'react';\n\nimport {ReactComponent as IconMarkGithub} from '@primer/octicons/build/svg/mark-github.svg';\n\n(function(d,s,id){let js,fjs=d.getElementsByTagName(s)[0];if(d.getElementById(id))return;js=d.createElement(s);js.id=id;js.src='https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.12&appId=1547693265447721&autoLogAppEvents=1';fjs.parentNode.insertBefore(js,fjs);}(document,'script','facebook-jssdk'));\n\nconst Footer = () => {\n    return (\n        <footer className=\"footer\">\n            <div className=\"author\">\n                made by\n                <a\n                    className=\"authorLink\"\n                    href=\"https://github.com/godban\"\n                    target=\"_blank\"\n                    rel=\"author\"\n                >\n                    <IconMarkGithub className=\"authorIcon\" />\n                    {'godban'}\n                </a>\n            </div>\n            <div className=\"social-box\">\n                <div className=\"social-box__item social-box__item--gh\">\n                    <a\n                        className=\"github-button\"\n                        href=\"https://github.com/godban/browsers-support-badges\"\n                        data-icon=\"octicon-star\"\n                        data-show-count=\"true\"\n                        aria-label=\"Star godban/browsers-support-badges on GitHub\"\n                    >Star</a>\n                </div>\n                <div className=\"social-box__twitter social-box__item\">\n                    <a\n                        href=\"https://twitter.com/share\"\n                        className=\"twitter-share-button\"\n                        data-show-count=\"false\"\n                    >Tweet</a>\n                </div>\n                <div className=\"social-box__facebook social-box__item\">\n                    <div\n                        className=\"fb-like\"\n                        data-href=\"http://godban.github.io/browsers-support-badges\"\n                        data-layout=\"button_count\"\n                        data-action=\"like\"\n                        data-size=\"small\"\n                        data-show-faces=\"false\"\n                        data-share=\"false\"\n                    />\n                </div>\n            </div>\n        </footer>\n    );\n};\n\nexport default Footer;\n\n'browsers-support-badges/src/components/main.jsx'\n:import React, {Component} from 'react';\n\nimport Panel from './panel';\nimport Footer from './footer';\n\nclass App extends Component {\n    render() {\n        return (\n            <main className=\"main\">\n                <Panel/>\n                <Footer/>\n            </main>\n        );\n    }\n}\n\nexport default App;\n\n'browsers-support-badges/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport Main from './components/main';\n\nimport 'no-sheet-reset/index.css';\nimport './markdown.css';\nimport './index.css';\n\nReactDOM.render(<Main />, document.getElementById('root'));\n\n",
        "called_code_segment_file_1": "const Footer = () => {\n    return (\n        <footer className=\"footer\">\n            <div className=\"author\">\n                made by\n                <a\n                    className=\"authorLink\"\n                    href=\"https://github.com/godban\"\n                    target=\"_blank\"\n                    rel=\"author\"\n                >\n                    <IconMarkGithub className=\"authorIcon\" />\n                    {'godban'}\n                </a>\n            </div>\n            <div className=\"social-box\">\n                <div className=\"social-box__item social-box__item--gh\">\n                    <a\n                        className=\"github-button\"\n                        href=\"https://github.com/godban/browsers-support-badges\"\n                        data-icon=\"octicon-star\"\n                        data-show-count=\"true\"\n                        aria-label=\"Star godban/browsers-support-badges on GitHub\"\n                    >Star</a>\n                </div>\n                <div className=\"social-box__twitter social-box__item\">\n                    <a\n                        href=\"https://twitter.com/share\"\n                        className=\"twitter-share-button\"\n                        data-show-count=\"false\"\n                    >Tweet</a>\n                </div>\n                <div className=\"social-box__facebook social-box__item\">\n                    <div\n                        className=\"fb-like\"\n                        data-href=\"http://godban.github.io/browsers-support-badges\"\n                        data-layout=\"button_count\"\n                        data-action=\"like\"\n                        data-size=\"small\"\n                        data-show-faces=\"false\"\n                        data-share=\"false\"\n                    />\n                </div>\n            </div>\n        </footer>\n    );\n};",
        "invoking_code_segment_file_2": "class App extends Component {\n    render() {\n        return (\n            <main className=\"main\">\n                <Panel/>\n                <Footer/>\n            </main>\n        );\n    }\n}",
        "invoking_code_segment_file_3": "ReactDOM.render(<Main />, document.getElementById('root'));",
        "new_file_code_segment": "const SocialMediaLinks = () => {\n    return (\n        <div className=\"social-media-links\">\n            <a href=\"https://twitter.com/godban\" target=\"_blank\" rel=\"noopener noreferrer\">Twitter</a>\n            <a href=\"https://github.com/godban\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>\n        </div>\n    );\n};",
        "feature_description": "Add social media links to the footer.",
        "detailed_feature_description": "A new component `SocialMediaLinks` is created in a new file (#file 4) to display links to the author's social media profiles. This component is then integrated into the `Footer` component in #file 1. The `Footer` component is invoked by the `App` component in #file 2, which is rendered by the `ReactDOM.render` call in #file 3. The new feature ensures that the social media links are displayed in the footer of the application.",
        "modified_complete_code": {
            "file_1": "const Footer = () => {\n    return (\n        <footer className=\"footer\">\n            <div className=\"author\">\n                made by\n                <a\n                    className=\"authorLink\"\n                    href=\"https://github.com/godban\"\n                    target=\"_blank\"\n                    rel=\"author\"\n                >\n                    <IconMarkGithub className=\"authorIcon\" />\n                    {'godban'}\n                </a>\n            </div>\n            <div className=\"social-box\">\n                <div className=\"social-box__item social-box__item--gh\">\n                    <a\n                        className=\"github-button\"\n                        href=\"https://github.com/godban/browsers-support-badges\"\n                        data-icon=\"octicon-star\"\n                        data-show-count=\"true\"\n                        aria-label=\"Star godban/browsers-support-badges on GitHub\"\n                    >Star</a>\n                </div>\n                <div className=\"social-box__twitter social-box__item\">\n                    <a\n                        href=\"https://twitter.com/share\"\n                        className=\"twitter-share-button\"\n                        data-show-count=\"false\"\n                    >Tweet</a>\n                </div>\n                <div className=\"social-box__facebook social-box__item\">\n                    <div\n                        className=\"fb-like\"\n                        data-href=\"http://godban.github.io/browsers-support-badges\"\n                        data-layout=\"button_count\"\n                        data-action=\"like\"\n                        data-size=\"small\"\n                        data-show-faces=\"false\"\n                        data-share=\"false\"\n                    />\n                </div>\n            </div>\n            #Modify\n            <SocialMediaLinks />\n        </footer>\n    );\n};",
            "file_2": "class App extends Component {\n    render() {\n        return (\n            <main className=\"main\">\n                <Panel/>\n                <Footer/>\n            </main>\n        );\n    }\n}",
            "file_3": "ReactDOM.render(<Main />, document.getElementById('root'));",
            "file_4": "#New\nconst SocialMediaLinks = () => {\n    return (\n        <div className=\"social-media-links\">\n            <a href=\"https://twitter.com/godban\" target=\"_blank\" rel=\"noopener noreferrer\">Twitter</a>\n            <a href=\"https://github.com/godban\" target=\"_blank\" rel=\"noopener noreferrer\">GitHub</a>\n        </div>\n    );\n};"
        }
    },
    {
        "repo": "three.bas",
        "content": "'three.bas/src/timeline/TimelineSegment.js'\n:/**\n * A timeline transition segment. An instance of this class is created internally when calling {@link THREE.BAS.Timeline.add}, so you should not use this class directly.\n * The instance is also passed the the compiler function if you register a transition through {@link THREE.BAS.Timeline.register}. There you can use the public properties of the segment to compile the glsl string.\n * @param {string} key A string key generated by the timeline to which this segment belongs. Keys are unique.\n * @param {number} start Start time of this segment in a timeline in seconds.\n * @param {number} duration Duration of this segment in seconds.\n * @param {object} transition Object describing the transition.\n * @param {function} compiler A reference to the compiler function from a transition definition.\n * @constructor\n */\nfunction TimelineSegment(key, start, duration, transition, compiler) {\n  this.key = key;\n  this.start = start;\n  this.duration = duration;\n  this.transition = transition;\n  this.compiler = compiler;\n\n  this.trail = 0;\n}\n\nTimelineSegment.prototype.compile = function() {\n  return this.compiler(this);\n};\n\nObject.defineProperty(TimelineSegment.prototype, 'end', {\n  get: function() {\n    return this.start + this.duration;\n  }\n});\n\nexport { TimelineSegment };\n\n'three.bas/src/timeline/Timeline.js'\n:import { TimelineSegment } from './TimelineSegment';\n\n/**\n * A utility class to create an animation timeline which can be baked into a (vertex) shader.\n * By default the timeline supports translation, scale and rotation. This can be extended or overridden.\n * @constructor\n */\nfunction Timeline() {\n  /**\n   * The total duration of the timeline in seconds.\n   * @type {number}\n   */\n  this.duration = 0;\n\n  /**\n   * The name of the value that segments will use to read the time. Defaults to 'tTime'.\n   * @type {string}\n   */\n  this.timeKey = 'tTime';\n\n  this.segments = {};\n  this.__key = 0;\n}\n\n// static definitions map\nTimeline.segmentDefinitions = {};\n\n/**\n * Registers a transition definition for use with {@link THREE.BAS.Timeline.add}.\n * @param {String} key Name of the transition. Defaults include 'scale', 'rotate' and 'translate'.\n * @param {Object} definition\n * @param {Function} definition.compiler A function that generates a glsl string for a transition segment. Accepts a THREE.BAS.TimelineSegment as the sole argument.\n * @param {*} definition.defaultFrom The initial value for a transform.from. For example, the defaultFrom for a translation is THREE.Vector3(0, 0, 0).\n * @static\n */\nTimeline.register = function(key, definition) {\n  Timeline.segmentDefinitions[key] = definition;\n  \n  return definition;\n};\n\n/**\n * Add a transition to the timeline.\n * @param {number} duration Duration in seconds\n * @param {object} transitions An object containing one or several transitions. The keys should match transform definitions.\n * The transition object for each key will be passed to the matching definition's compiler. It can have arbitrary properties, but the Timeline expects at least a 'to', 'from' and an optional 'ease'.\n * @param {number|string} [positionOffset] Position in the timeline. Defaults to the end of the timeline. If a number is provided, the transition will be inserted at that time in seconds. Strings ('+=x' or '-=x') can be used for a value relative to the end of timeline.\n */\nTimeline.prototype.add = function(duration, transitions, positionOffset) {\n  // stop rollup from complaining about eval\n  const _eval = eval;\n  \n  let start = this.duration;\n\n  if (positionOffset !== undefined) {\n    if (typeof positionOffset === 'number') {\n      start = positionOffset;\n    }\n    else if (typeof positionOffset === 'string') {\n      _eval('start' + positionOffset);\n    }\n\n    this.duration = Math.max(this.duration, start + duration);\n  }\n  else {\n    this.duration += duration;\n  }\n\n  let keys = Object.keys(transitions), key;\n\n  for (let i = 0; i < keys.length; i++) {\n    key = keys[i];\n\n    this.processTransition(key, transitions[key], start, duration);\n  }\n};\n\nTimeline.prototype.processTransition = function(key, transition, start, duration) {\n  const definition = Timeline.segmentDefinitions[key];\n\n  let segments = this.segments[key];\n  if (!segments) segments = this.segments[key] = [];\n\n  if (transition.from === undefined) {\n    if (segments.length === 0) {\n      transition.from = definition.defaultFrom;\n    }\n    else {\n      transition.from = segments[segments.length - 1].transition.to;\n    }\n  }\n\n  segments.push(new TimelineSegment((this.__key++).toString(), start, duration, transition, definition.compiler));\n};\n\n/**\n * Compiles the timeline into a glsl string array that can be injected into a (vertex) shader.\n * @returns {Array}\n */\nTimeline.prototype.compile = function() {\n  const c = [];\n\n  const keys = Object.keys(this.segments);\n  let segments;\n\n  for (let i = 0; i < keys.length; i++) {\n    segments = this.segments[keys[i]];\n\n    this.fillGaps(segments);\n\n    segments.forEach(function(s) {\n      c.push(s.compile());\n    });\n  }\n\n  return c;\n};\nTimeline.prototype.fillGaps = function(segments) {\n  if (segments.length === 0) return;\n\n  let s0, s1;\n\n  for (let i = 0; i < segments.length - 1; i++) {\n    s0 = segments[i];\n    s1 = segments[i + 1];\n\n    s0.trail = s1.start - s0.end;\n  }\n\n  // pad last segment until end of timeline\n  s0 = segments[segments.length - 1];\n  s0.trail = this.duration - s0.end;\n};\n\n/**\n * Get a compiled glsl string with calls to transform functions for a given key.\n * The order in which these transitions are applied matters because they all operate on the same value.\n * @param {string} key A key matching a transform definition.\n * @returns {string}\n */\nTimeline.prototype.getTransformCalls = function(key) {\n  let t = this.timeKey;\n\n  return this.segments[key] ?  this.segments[key].map(function(s) {\n    return `applyTransform${s.key}(${t}, transformed);`;\n  }).join('\\n') : '';\n};\n\nexport { Timeline }\n\n'three.bas/src/timeline/RotationSegment.js'\n:import { Timeline } from './Timeline';\nimport { TimelineChunks } from './TimelineChunks';\nimport { Vector3, Vector4 } from 'three';\n\nconst RotationSegment = {\n  compiler(segment) {\n    const fromAxisAngle = new Vector4(\n      segment.transition.from.axis.x,\n      segment.transition.from.axis.y,\n      segment.transition.from.axis.z,\n      segment.transition.from.angle\n    );\n  \n    const toAxis = segment.transition.to.axis || segment.transition.from.axis;\n    const toAxisAngle = new Vector4(\n      toAxis.x,\n      toAxis.y,\n      toAxis.z,\n      segment.transition.to.angle\n    );\n  \n    const origin = segment.transition.origin;\n    \n    return `\n    ${TimelineChunks.delayDuration(segment)}\n    ${TimelineChunks.vec4(`cRotationFrom${segment.key}`, fromAxisAngle, 8)}\n    ${TimelineChunks.vec4(`cRotationTo${segment.key}`, toAxisAngle, 8)}\n    ${origin ? TimelineChunks.vec3(`cOrigin${segment.key}`, origin, 2) : ''}\n    \n    void applyTransform${segment.key}(float time, inout vec3 v) {\n      ${TimelineChunks.renderCheck(segment)}\n      ${TimelineChunks.progress(segment)}\n\n      ${origin ? `v -= cOrigin${segment.key};` : ''}\n      vec3 axis = normalize(mix(cRotationFrom${segment.key}.xyz, cRotationTo${segment.key}.xyz, progress));\n      float angle = mix(cRotationFrom${segment.key}.w, cRotationTo${segment.key}.w, progress);\n      vec4 q = quatFromAxisAngle(axis, angle);\n      v = rotateVector(q, v);\n      ${origin ? `v += cOrigin${segment.key};` : ''}\n    }\n    `;\n  },\n  defaultFrom: {axis: new Vector3(), angle: 0}\n};\n\nTimeline.register('rotate', RotationSegment);\n\nexport { RotationSegment };\n\n",
        "called_code_segment_file_1": "TimelineSegment.prototype.compile = function() {\n  return this.compiler(this);\n};",
        "invoking_code_segment_file_2": "Timeline.prototype.compile = function() {\n  const c = [];\n\n  const keys = Object.keys(this.segments);\n  let segments;\n\n  for (let i = 0; i < keys.length; i++) {\n    segments = this.segments[keys[i]];\n\n    this.fillGaps(segments);\n\n    segments.forEach(function(s) {\n      c.push(s.compile());\n    });\n  }\n\n  return c;\n};",
        "invoking_code_segment_file_3": "Timeline.prototype.getTransformCalls = function(key) {\n  let t = this.timeKey;\n\n  return this.segments[key] ?  this.segments[key].map(function(s) {\n    return `applyTransform${s.key}(${t}, transformed);`;\n  }).join('\\n') : '';\n};",
        "new_file_code_segment": "function newFeatureFunction(segment) {\n  return `\n    // New feature code\n    float newFeatureValue = segment.transition.newFeature;\n    // Use newFeatureValue in some way\n  `;\n}",
        "feature_description": "Add a new feature to the TimelineSegment that allows for additional custom functionality during the compilation process.",
        "detailed_feature_description": "The new feature involves adding a new property to the transition object in the TimelineSegment. This property will be used to inject custom GLSL code during the compilation process. The new file (#file 4) contains a function that generates this custom GLSL code. The TimelineSegment's compile method is updated to invoke this new function if the new feature property is present in the transition object.",
        "modified_complete_code": {
            "file_1": "TimelineSegment.prototype.compile = function() {\n  let compiledCode = this.compiler(this);\n  if (this.transition.newFeature !== undefined) {\n    compiledCode += newFeatureFunction(this); // Modify\n  }\n  return compiledCode;\n};",
            "file_2": "Timeline.prototype.compile = function() {\n  const c = [];\n\n  const keys = Object.keys(this.segments);\n  let segments;\n\n  for (let i = 0; i < keys.length; i++) {\n    segments = this.segments[keys[i]];\n\n    this.fillGaps(segments);\n\n    segments.forEach(function(s) {\n      c.push(s.compile());\n    });\n  }\n\n  return c;\n};",
            "file_3": "Timeline.prototype.getTransformCalls = function(key) {\n  let t = this.timeKey;\n\n  return this.segments[key] ?  this.segments[key].map(function(s) {\n    return `applyTransform${s.key}(${t}, transformed);`;\n  }).join('\\n') : '';\n};",
            "file_4": "function newFeatureFunction(segment) {\n  return `\n    // New feature code\n    float newFeatureValue = segment.transition.newFeature;\n    // Use newFeatureValue in some way\n  `;\n} // New"
        }
    },
    {
        "repo": "electron-boilerplate-vue",
        "content": "'electron-boilerplate-vue/config.js'\n:/**\n * General configuration for build and release scripts.\n *\n * This file as adapted from http://vuejs-templates.github.io/webpack.\n * Some options were removed or changed to simplify things and/or\n * make them more applicable to Electron apps.\n */\nvar path = require('path')\n\nmodule.exports = {\n  build: {\n    // The directory which will contained packaged releases and installers\n    // for various operation systems.\n    releasesRoot: path.resolve(__dirname, 'releases'),\n\n    // The target directory for your app's compiled assets. Must be an absolute path.\n    // This is the directory which will contain a runnable electron app.\n    outputRoot: path.resolve(__dirname, 'dist'),\n\n    // Nest webpack-generated assets under this directory in `assetsRoot`.\n    // This applies to all non-JavaScript assets processed by webpack.\n    assetsSubDirectory: 'assets',\n\n    // Whether to generate source maps for production builds.\n    productionSourceMap: true\n  },\n  release: {\n    // The Electron version to use for packaged releases. If blank, it defaults\n    // to the version of electron-prebuilt in your development package.json.\n    //\n    // electronVersion: '0.37.2',\n\n    // The target platforms for packaged releases. For options, see\n    // https://github.com/electron-userland/electron-packager\n    platform: 'all'\n  },\n  dev: {\n    // Dev server port.\n    port: 8080,\n\n    // Proxy requests to different backend during development.\n    // https://github.com/chimurai/http-proxy-middleware\n    proxyTable: {\n      // '/api': {\n      //   target: 'http://jsonplaceholder.typicode.com',\n      //   changeOrigin: true,\n      //   pathRewrite: {\n      //     '^/api': ''\n      //   }\n      // }\n    },\n\n    // Whether or not open another Electron window with vue-devtools.\n    vueDevTools: true\n  }\n}\n\n'electron-boilerplate-vue/build/webpack.base.conf.js'\n:var path = require('path')\nvar webpack = require('webpack')\nvar config = require('../config')\nvar cssLoaders = require('./css-loaders')\nvar projectRoot = path.resolve(__dirname, '../')\n\nmodule.exports = {\n  // Note: entry points are added by environment-specific configs.\n\n  output: {\n    path: config.build.outputRoot,\n    filename: '[name].js'\n  },\n  // Use target 'node' so that __dirname works properly. We then need\n  // to manually specify the electron modules in the ExternalsPlugin\n  // since we're not using target 'electron'.\n  target: 'node',\n  node: {\n    __filename: false,\n    __dirname: false\n  },\n  resolve: {\n    extensions: ['', '.js', '.vue'],\n    fallback: [path.join(__dirname, '../node_modules')],\n    alias: {\n      app: path.resolve(__dirname, '../app')\n    }\n  },\n  resolveLoader: {\n    fallback: [path.join(__dirname, '../node_modules')]\n  },\n  module: {\n    preLoaders: [\n      {\n        test: /\\.vue$/,\n        loader: 'eslint',\n        include: projectRoot,\n        exclude: /node_modules/\n      },\n      {\n        test: /\\.js$/,\n        loader: 'eslint',\n        include: projectRoot,\n        exclude: /vue-devtools|node_modules/\n      }\n    ],\n    loaders: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue'\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel',\n        include: projectRoot,\n        exclude: /vue-devtools|node_modules/\n      },\n      {\n        test: /\\.json$/,\n        loader: 'json'\n      },\n      {\n        test: /\\.html$/,\n        loader: 'vue-html'\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg|woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url',\n        query: {\n          limit: 10000,\n          name: path.join(config.build.assetsSubDirectory, '[name].[ext]').replace('\\\\', '/')\n        }\n      }\n    ]\n  },\n  plugins: [\n    new webpack.ExternalsPlugin('commonjs2', [\n      'desktop-capturer',\n      'electron',\n      'ipc',\n      'ipc-renderer',\n      'native-image',\n      'remote',\n      'web-frame',\n      'clipboard',\n      'crash-reporter',\n      'screen',\n      'shell'\n    ])\n  ],\n  vue: {\n    loaders: cssLoaders()\n  },\n  eslint: {\n    formatter: require('eslint-friendly-formatter')\n  }\n}\n\n'electron-boilerplate-vue/build/webpack.prod.conf.js'\n:var path = require('path')\nvar webpack = require('webpack')\nvar merge = require('webpack-merge')\nvar ExtractTextPlugin = require('extract-text-webpack-plugin')\nvar HtmlWebpackPlugin = require('html-webpack-plugin')\nvar CopyWebpackPlugin = require('copy-webpack-plugin')\nvar config = require('../config')\nvar baseWebpackConfig = require('./webpack.base.conf')\nvar cssLoaders = require('./css-loaders')\n\nmodule.exports = merge(baseWebpackConfig, {\n  entry: {\n    app: './app/main.js',\n    background: './app/background.js'\n  },\n  devtool: config.build.productionSourceMap ? '#source-map' : false,\n  output: {\n    filename: '[name].js',\n    chunkFilename: '[id].js'\n  },\n  vue: {\n    loaders: cssLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true\n    })\n  },\n  plugins: [\n    new CopyWebpackPlugin([\n      { from: './app/package.json', to: '.' },\n      { from: './static', to: 'static' }\n    ]),\n    // http://vuejs.github.io/vue-loader/workflow/production.html\n    new webpack.DefinePlugin({\n      'process.env': {\n        NODE_ENV: '\"production\"'\n      }\n    }),\n    new webpack.optimize.UglifyJsPlugin({\n      compress: {\n        warnings: false\n      }\n    }),\n    new webpack.optimize.OccurenceOrderPlugin(),\n    // extract css into its own file\n    new ExtractTextPlugin(path.join(config.build.assetsSubDirectory, '[name].css')),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: 'main.html',\n      template: './app/main.html',\n      excludeChunks: ['background'],\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      }\n    })\n  ]\n})\n\n",
        "called_code_segment_file_1": "module.exports = { build: { releasesRoot: path.resolve(__dirname, 'releases'), outputRoot: path.resolve(__dirname, 'dist'), assetsSubDirectory: 'assets', productionSourceMap: true }, release: { platform: 'all' }, dev: { port: 8080, proxyTable: {}, vueDevTools: true } }",
        "invoking_code_segment_file_2": "var config = require('../config')",
        "invoking_code_segment_file_3": "var config = require('../config')",
        "new_file_code_segment": "module.exports = { newFeature: { enableFeature: true, featureName: 'New Feature' } }",
        "feature_description": "Add a new feature to enable or disable a specific functionality in the application.",
        "detailed_feature_description": "The new feature will be implemented by adding a new configuration option in the config file (#file 1). This new configuration will be used to enable or disable a specific feature in the application. The new file (#file 4) will contain the configuration for this new feature. The existing files (#file 2 and #file 3) will be updated to check this new configuration and act accordingly.",
        "modified_complete_code": {
            "#file 1": "var path = require('path') #Modify module.exports = { build: { releasesRoot: path.resolve(__dirname, 'releases'), outputRoot: path.resolve(__dirname, 'dist'), assetsSubDirectory: 'assets', productionSourceMap: true }, release: { platform: 'all' }, dev: { port: 8080, proxyTable: {}, vueDevTools: true }, newFeature: require('./newFeatureConfig').newFeature }",
            "#file 2": "var config = require('../config') #Modify if (config.newFeature.enableFeature) { console.log('New Feature Enabled:', config.newFeature.featureName) }",
            "#file 3": "var config = require('../config') #Modify if (config.newFeature.enableFeature) { console.log('New Feature Enabled in File 3:', config.newFeature.featureName) }",
            "#file 4": "#New module.exports = { newFeature: { enableFeature: true, featureName: 'New Feature' } }"
        }
    },
    {
        "repo": "spa",
        "content": "'spa/listings/ch08/8.6.1-chat-setup/lib/chat.js'\n:/*\n * chat.js - module to provide chat messaging\n*/\n\n/*jslint         node    : true, continue : true,\n  devel  : true, indent  : 2,    maxerr   : 50,\n  newcap : true, nomen   : true, plusplus : true,\n  regexp : true, sloppy  : true, vars     : false,\n  white  : true\n*/\n/*global */\n\n// ------------ BEGIN MODULE SCOPE VARIABLES --------------\n'use strict';\nvar\n  chatObj,\n  socket = require( 'socket.io' ),\n  crud   = require( './crud'    );\n// ------------- END MODULE SCOPE VARIABLES ---------------\n\n// ---------------- BEGIN PUBLIC METHODS ------------------\nchatObj = {\n  connect : function ( server ) {\n    var io = socket.listen( server );\n\n    // Begin io setup\n    io\n      .set( 'blacklist' , [] )\n      .of( '/chat' )\n      .on( 'connection', function ( socket ) {\n        socket.on( 'adduser',      function () {} );\n        socket.on( 'updatechat',   function () {} );\n        socket.on( 'leavechat',    function () {} );\n        socket.on( 'disconnect',   function () {} );\n        socket.on( 'updateavatar', function () {} );\n      }\n    );\n    // End io setup\n\n    return io;\n  }\n};\n\nmodule.exports = chatObj;\n// ----------------- END PUBLIC METHODS -------------------\n\n'spa/listings/ch08/8.6.1-chat-setup/lib/routes.js'\n:/*\n * routes.js - module to provide routing\n*/\n\n/*jslint         node    : true, continue : true,\n  devel  : true, indent  : 2,    maxerr   : 50,\n  newcap : true, nomen   : true, plusplus : true,\n  regexp : true, sloppy  : true, vars     : false,\n  white  : true\n*/\n/*global */\n\n// ------------ BEGIN MODULE SCOPE VARIABLES --------------\n'use strict';\nvar\n  configRoutes,\n  crud        = require( './crud' ),\n  chat        = require( './chat' ),\n  makeMongoId = crud.makeMongoId;\n// ------------- END MODULE SCOPE VARIABLES ---------------\n\n// ---------------- BEGIN PUBLIC METHODS ------------------\nconfigRoutes = function ( app, server ) {\n  app.get( '/', function ( request, response ) {\n    response.redirect( '/spa.html' );\n  });\n\n  app.all( '/:obj_type/*?', function ( request, response, next ) {\n    response.contentType( 'json' );\n    next();\n  });\n\n  app.get( '/:obj_type/list', function ( request, response ) {\n    crud.read(\n      request.params.obj_type,\n      {}, {},\n      function ( map_list ) { response.send( map_list ); }\n    );\n  });\n\n  app.post( '/:obj_type/create', function ( request, response ) {\n    crud.construct(\n      request.params.obj_type,\n      request.body,\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  app.get( '/:obj_type/read/:id', function ( request, response ) {\n    crud.read(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      {},\n      function ( map_list ) { response.send( map_list ); }\n    );\n  });\n\n  app.post( '/:obj_type/update/:id', function ( request, response ) {\n    crud.update(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      request.body,\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  app.get( '/:obj_type/delete/:id', function ( request, response ) {\n    crud.destroy(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  chat.connect( server );\n};\n\nmodule.exports = { configRoutes : configRoutes };\n// ----------------- END PUBLIC METHODS -------------------\n\n'spa/listings/ch08/8.6.1-chat-setup/app.js'\n:/*\n * app.js - Express server with routing\n*/\n\n/*jslint         node    : true, continue : true,\n  devel  : true, indent  : 2,    maxerr   : 50,\n  newcap : true, nomen   : true, plusplus : true,\n  regexp : true, sloppy  : true, vars     : false,\n  white  : true\n*/\n/*global */\n\n// ------------ BEGIN MODULE SCOPE VARIABLES --------------\n'use strict';\nvar\n  http    = require( 'http'         ),\n  express = require( 'express'      ),\n  routes  = require( './lib/routes' ),\n\n  app     = express(),\n  server  = http.createServer( app );\n// ------------- END MODULE SCOPE VARIABLES ---------------\n\n// ------------- BEGIN SERVER CONFIGURATION ---------------\napp.configure( function () {\n  app.use( express.bodyParser() );\n  app.use( express.methodOverride() );\n  app.use( express.static( __dirname + '/public' ) );\n  app.use( app.router );\n});\n\napp.configure( 'development', function () {\n  app.use( express.logger() );\n  app.use( express.errorHandler({\n    dumpExceptions : true,\n    showStack      : true\n  }) );\n});\n\napp.configure( 'production', function () {\n  app.use( express.errorHandler() );\n});\n\nroutes.configRoutes( app, server );\n// -------------- END SERVER CONFIGURATION ----------------\n\n// ----------------- BEGIN START SERVER -------------------\nserver.listen( 3000 );\nconsole.log(\n  'Express server listening on port %d in %s mode',\n   server.address().port, app.settings.env\n);\n// ------------------ END START SERVER --------------------\n\n",
        "called_code_segment_file_1": "chatObj = {\n  connect : function ( server ) {\n    var io = socket.listen( server );\n\n    // Begin io setup\n    io\n      .set( 'blacklist' , [] )\n      .of( '/chat' )\n      .on( 'connection', function ( socket ) {\n        socket.on( 'adduser',      function () {} );\n        socket.on( 'updatechat',   function () {} );\n        socket.on( 'leavechat',    function () {} );\n        socket.on( 'disconnect',   function () {} );\n        socket.on( 'updateavatar', function () {} );\n      }\n    );\n    // End io setup\n\n    return io;\n  }\n};",
        "invoking_code_segment_file_2": "configRoutes = function ( app, server ) {\n  app.get( '/', function ( request, response ) {\n    response.redirect( '/spa.html' );\n  });\n\n  app.all( '/:obj_type/*?', function ( request, response, next ) {\n    response.contentType( 'json' );\n    next();\n  });\n\n  app.get( '/:obj_type/list', function ( request, response ) {\n    crud.read(\n      request.params.obj_type,\n      {}, {},\n      function ( map_list ) { response.send( map_list ); }\n    );\n  });\n\n  app.post( '/:obj_type/create', function ( request, response ) {\n    crud.construct(\n      request.params.obj_type,\n      request.body,\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  app.get( '/:obj_type/read/:id', function ( request, response ) {\n    crud.read(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      {},\n      function ( map_list ) { response.send( map_list ); }\n    );\n  });\n\n  app.post( '/:obj_type/update/:id', function ( request, response ) {\n    crud.update(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      request.body,\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  app.get( '/:obj_type/delete/:id', function ( request, response ) {\n    crud.destroy(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  chat.connect( server );\n};",
        "invoking_code_segment_file_3": "server  = http.createServer( app );",
        "new_file_code_segment": "var newFeature = {\n  init: function (io) {\n    io.of('/chat').on('connection', function (socket) {\n      socket.on('newFeatureEvent', function (data) {\n        // Handle new feature event\n        console.log('New feature event received:', data);\n      });\n    });\n  }\n};\n\nmodule.exports = newFeature;",
        "feature_description": "Add a new feature to handle a custom event in the chat module.",
        "detailed_feature_description": "The new feature involves adding a custom event listener in the chat module. This will allow the server to handle a new event called 'newFeatureEvent'. The new functionality is implemented in a new file (#file 4) and integrated into the existing chat module (#file 1). The routes module (#file 2) and the main app module (#file 3) are updated to ensure compatibility and invoke the new feature.",
        "modified_complete_code": {
            "file_1": "/* #Modify */\nchatObj = {\n  connect : function ( server ) {\n    var io = socket.listen( server );\n\n    // Begin io setup\n    io\n      .set( 'blacklist' , [] )\n      .of( '/chat' )\n      .on( 'connection', function ( socket ) {\n        socket.on( 'adduser',      function () {} );\n        socket.on( 'updatechat',   function () {} );\n        socket.on( 'leavechat',    function () {} );\n        socket.on( 'disconnect',   function () {} );\n        socket.on( 'updateavatar', function () {} );\n      }\n    );\n    // End io setup\n\n    /* #New */\n    require('./newFeature').init(io);\n\n    return io;\n  }\n};",
            "file_2": "/* #Modify */\nconfigRoutes = function ( app, server ) {\n  app.get( '/', function ( request, response ) {\n    response.redirect( '/spa.html' );\n  });\n\n  app.all( '/:obj_type/*?', function ( request, response, next ) {\n    response.contentType( 'json' );\n    next();\n  });\n\n  app.get( '/:obj_type/list', function ( request, response ) {\n    crud.read(\n      request.params.obj_type,\n      {}, {},\n      function ( map_list ) { response.send( map_list ); }\n    );\n  });\n\n  app.post( '/:obj_type/create', function ( request, response ) {\n    crud.construct(\n      request.params.obj_type,\n      request.body,\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  app.get( '/:obj_type/read/:id', function ( request, response ) {\n    crud.read(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      {},\n      function ( map_list ) { response.send( map_list ); }\n    );\n  });\n\n  app.post( '/:obj_type/update/:id', function ( request, response ) {\n    crud.update(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      request.body,\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  app.get( '/:obj_type/delete/:id', function ( request, response ) {\n    crud.destroy(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  chat.connect( server );\n};",
            "file_3": "/* #Modify */\nserver  = http.createServer( app );",
            "file_4": "/* #New */\nvar newFeature = {\n  init: function (io) {\n    io.of('/chat').on('connection', function (socket) {\n      socket.on('newFeatureEvent', function (data) {\n        // Handle new feature event\n        console.log('New feature event received:', data);\n      });\n    });\n  }\n};\n\nmodule.exports = newFeature;"
        }
    },
    {
        "repo": "wp-optionskit",
        "content": "'wp-optionskit/config/prod.env.js'\n:'use strict'\nmodule.exports = {\n  NODE_ENV: '\"production\"'\n}\n\n'wp-optionskit/build/webpack.prod.conf.js'\n:'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\n\nconst env = require('../config/prod.env')\n\nconst webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  devtool: config.build.productionSourceMap ? config.build.devtool : false,\n  output: {\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath('js/[name].js'),\n    chunkFilename: utils.assetsPath('js/[id].js')\n  },\n  plugins: [\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    new webpack.DefinePlugin({\n      'process.env': env\n    }),\n    new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          warnings: false\n        }\n      },\n      sourceMap: config.build.productionSourceMap,\n      parallel: true\n    }),\n    // extract css into its own file\n    new ExtractTextPlugin({\n      filename: utils.assetsPath('css/[name].css'),\n      // Setting the following option to `false` will not extract CSS from codesplit chunks.\n      // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.\n      // It's currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it's `false`, \n      // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110\n      allChunks: true,\n    }),\n    // Compress extracted CSS. We are using this plugin so that possible\n    // duplicated CSS from different components can be deduped.\n    new OptimizeCSSPlugin({\n      cssProcessorOptions: config.build.productionSourceMap\n        ? { safe: true, map: { inline: false } }\n        : { safe: true }\n    }),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: 'index.html',\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      chunksSortMode: 'dependency'\n    }),\n    // keep module.id stable when vendor modules does not change\n    new webpack.HashedModuleIdsPlugin(),\n    // enable scope hoisting\n    new webpack.optimize.ModuleConcatenationPlugin(),\n    // split vendor js into its own file\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n      minChunks (module) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &&\n          /\\.js$/.test(module.resource) &&\n          module.resource.indexOf(\n            path.join(__dirname, '../node_modules')\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'manifest',\n      minChunks: Infinity\n    }),\n    // This instance extracts shared chunks from code splitted chunks and bundles them\n    // in a separate chunk, similar to the vendor chunk\n    // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'app',\n      async: 'vendor-async',\n      children: true,\n      minChunks: 3\n    }),\n\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.build.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nif (config.build.productionGzip) {\n  const CompressionWebpackPlugin = require('compression-webpack-plugin')\n\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      asset: '[path].gz[query]',\n      algorithm: 'gzip',\n      test: new RegExp(\n        '\\\\.(' +\n        config.build.productionGzipExtensions.join('|') +\n        ')$'\n      ),\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nif (config.build.bundleAnalyzerReport) {\n  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n  webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n\nmodule.exports = webpackConfig\n\n'wp-optionskit/build/build.js'\n:'use strict'\nrequire('./check-versions')()\n\nprocess.env.NODE_ENV = 'production'\n\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n\nconst spinner = ora('building for production...')\nspinner.start()\n\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {\n  if (err) throw err\n  webpack(webpackConfig, (err, stats) => {\n    spinner.stop()\n    if (err) throw err\n    process.stdout.write(stats.toString({\n      colors: true,\n      modules: false,\n      children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build.\n      chunks: false,\n      chunkModules: false\n    }) + '\\n\\n')\n\n    if (stats.hasErrors()) {\n      console.log(chalk.red('  Build failed with errors.\\n'))\n      process.exit(1)\n    }\n\n    console.log(chalk.cyan('  Build complete.\\n'))\n    console.log(chalk.yellow(\n      '  Tip: built files are meant to be served over an HTTP server.\\n' +\n      '  Opening index.html over file:// won\\'t work.\\n'\n    ))\n  })\n})\n\n",
        "called_code_segment_file_1": "module.exports = { NODE_ENV: '\"production\"' }",
        "invoking_code_segment_file_2": "const env = require('../config/prod.env')",
        "invoking_code_segment_file_3": "require('./check-versions')()",
        "new_file_code_segment": "module.exports = { newFeature: function() { console.log('New Feature Activated'); } }",
        "feature_description": "Add a new feature to log a message when the production build is complete.",
        "detailed_feature_description": "A new function `newFeature` is added in #file 4 which logs a message. This function is invoked in #file 1 after the build process is complete. #file 2 and #file 3 are updated to ensure compatibility with the new feature.",
        "modified_complete_code": {
            "file_1": "'use strict'\nmodule.exports = {\n  NODE_ENV: '\"production\"',\n  #Modify newFeature: require('./newFeature').newFeature\n}",
            "file_2": "'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\n\nconst env = require('../config/prod.env')\n\nconst webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  devtool: config.build.productionSourceMap ? config.build.devtool : false,\n  output: {\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath('js/[name].js'),\n    chunkFilename: utils.assetsPath('js/[id].js')\n  },\n  plugins: [\n    new webpack.DefinePlugin({\n      'process.env': env\n    }),\n    new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          warnings: false\n        }\n      },\n      sourceMap: config.build.productionSourceMap,\n      parallel: true\n    }),\n    new ExtractTextPlugin({\n      filename: utils.assetsPath('css/[name].css'),\n      allChunks: true,\n    }),\n    new OptimizeCSSPlugin({\n      cssProcessorOptions: config.build.productionSourceMap\n        ? { safe: true, map: { inline: false } }\n        : { safe: true }\n    }),\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: 'index.html',\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n      },\n      chunksSortMode: 'dependency'\n    }),\n    new webpack.HashedModuleIdsPlugin(),\n    new webpack.optimize.ModuleConcatenationPlugin(),\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n      minChunks (module) {\n        return (module.resource &&\n          /\\.js$/.test(module.resource) &&\n          module.resource.indexOf(\n            path.join(__dirname, '../node_modules')\n          ) === 0)\n      }\n    }),\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'manifest',\n      minChunks: Infinity\n    }),\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'app',\n      async: 'vendor-async',\n      children: true,\n      minChunks: 3\n    }),\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.build.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nif (config.build.productionGzip) {\n  const CompressionWebpackPlugin = require('compression-webpack-plugin')\n\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      asset: '[path].gz[query]',\n      algorithm: 'gzip',\n      test: new RegExp(\n        '\\.(' +\n        config.build.productionGzipExtensions.join('|') +\n        ')$'\n      ),\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nif (config.build.bundleAnalyzerReport) {\n  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n  webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n\nmodule.exports = webpackConfig",
            "file_3": "'use strict'\nrequire('./check-versions')()\n\nprocess.env.NODE_ENV = 'production'\n\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n\nconst spinner = ora('building for production...')\nspinner.start()\n\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {\n  if (err) throw err\n  webpack(webpackConfig, (err, stats) => {\n    spinner.stop()\n    if (err) throw err\n    process.stdout.write(stats.toString({\n      colors: true,\n      modules: false,\n      children: false,\n      chunks: false,\n      chunkModules: false\n    }) + '\\n\\n')\n\n    if (stats.hasErrors()) {\n      console.log(chalk.red('  Build failed with errors.\\n'))\n      process.exit(1)\n    }\n\n    console.log(chalk.cyan('  Build complete.\\n'))\n    console.log(chalk.yellow(\n      '  Tip: built files are meant to be served over an HTTP server.\\n' +\n      '  Opening index.html over file:// won\\'t work.\\n'\n    ))\n    #Modify require('../config/prod.env').newFeature()\n  })\n})",
            "file_4": "'use strict'\nmodule.exports = {\n  newFeature: function() {\n    console.log('New Feature Activated');\n  }\n}"
        }
    },
    {
        "repo": "place-to-stay",
        "content": "'place-to-stay/client/src/components/Loading.js'\n:import { Backdrop, CircularProgress } from '@mui/material';\nimport React from 'react';\nimport { useValue } from '../context/ContextProvider';\n\nconst Loading = () => {\n  const {\n    state: { loading },\n  } = useValue();\n  return (\n    <Backdrop open={loading} sx={{ zIndex: (theme) => theme.zIndex.modal + 1 }}>\n      <CircularProgress sx={{ color: 'white' }} />\n    </Backdrop>\n  );\n};\n\nexport default Loading;\n\n'place-to-stay/client/src/App.js'\n:import { BrowserRouter, Route, Routes } from 'react-router-dom';\nimport Dashboard from './pages/dashboard/Dashboard';\nimport Home from './pages/Home';\nimport Loading from './components/Loading';\nimport Notification from './components/Notification';\nimport Room from './components/rooms/Room';\n\nconst App = () => {\n  return (\n    <>\n      <Loading />\n      <Notification />\n      <BrowserRouter>\n        <Routes>\n          <Route path=\"dashboard/*\" element={<Dashboard />} />\n          <Route path=\"*\" element={<Home />} />\n        </Routes>\n      </BrowserRouter>\n      <Room />\n    </>\n  );\n};\n\nexport default App;\n\n'place-to-stay/client/src/index.js'\n:import { createRoot } from 'react-dom/client';\nimport App from './App';\nimport ContextProvider from './context/ContextProvider';\n\ncreateRoot(document.getElementById('root')).render(\n  <ContextProvider>\n    <App />\n  </ContextProvider>\n);\n\n",
        "called_code_segment_file_1": "const { state: { loading } } = useValue();\nreturn (\n  <Backdrop open={loading} sx={{ zIndex: (theme) => theme.zIndex.modal + 1 }}>\n    <CircularProgress sx={{ color: 'white' }} />\n  </Backdrop>\n);",
        "invoking_code_segment_file_2": "<Loading />",
        "invoking_code_segment_file_3": "<Loading />",
        "new_file_code_segment": "const CustomLoading = () => {\n  const { state: { loading, customLoadingText } } = useValue();\n  return (\n    <Backdrop open={loading} sx={{ zIndex: (theme) => theme.zIndex.modal + 1 }}>\n      <CircularProgress sx={{ color: 'white' }} />\n      <Typography variant=\"h6\" sx={{ color: 'white', marginTop: 2 }}>\n        {customLoadingText || 'Loading...'}\n      </Typography>\n    </Backdrop>\n  );\n};",
        "feature_description": "Add a custom loading text feature to the Loading component.",
        "detailed_feature_description": "The new feature allows for a custom loading text to be displayed alongside the loading spinner. This is implemented by adding a new state variable 'customLoadingText' in the context and updating the Loading component to display this text if provided.",
        "modified_complete_code": {
            "file_1": "//Modify\nconst CustomLoading = () => {\n  const { state: { loading, customLoadingText } } = useValue();\n  return (\n    <Backdrop open={loading} sx={{ zIndex: (theme) => theme.zIndex.modal + 1 }}>\n      <CircularProgress sx={{ color: 'white' }} />\n      <Typography variant=\"h6\" sx={{ color: 'white', marginTop: 2 }}>\n        {customLoadingText || 'Loading...'}\n      </Typography>\n    </Backdrop>\n  );\n};",
            "file_2": "//Modify\n<CustomLoading />",
            "file_3": "//Modify\n<CustomLoading />",
            "file_4": "//New\nimport { Backdrop, CircularProgress, Typography } from '@mui/material';\nimport React from 'react';\nimport { useValue } from '../context/ContextProvider';\n\nconst CustomLoading = () => {\n  const { state: { loading, customLoadingText } } = useValue();\n  return (\n    <Backdrop open={loading} sx={{ zIndex: (theme) => theme.zIndex.modal + 1 }}>\n      <CircularProgress sx={{ color: 'white' }} />\n      <Typography variant=\"h6\" sx={{ color: 'white', marginTop: 2 }}>\n        {customLoadingText || 'Loading...'}\n      </Typography>\n    </Backdrop>\n  );\n};\n\nexport default CustomLoading;"
        }
    },
    {
        "repo": "dumb-react",
        "content": "'dumb-react/src/components/CardList/CardList.js'\n:import React, { Component } from \"react\";\nimport PropTypes from 'prop-types';\nimport \"./CardList.css\";\nimport { Card } from \"../Card/Card\";\n\nexport class CardList extends Component {\n    render() {\n        return (\n            <ul className=\"c-card-list\">\n                {this.props.listItems.map(function(listItem, index) {\n                    return (\n                        <Card\n                            key={`c-card-${index}`}\n                            theme={listItem.theme}\n                            title={listItem.title}\n                            description={listItem.description}\n                        />\n                    );\n                })}\n            </ul>\n        );\n    }\n}\n\nCardList.propTypes = {\n    listItems: PropTypes.array\n}\n\n'dumb-react/src/App.js'\n:import React, { Component } from 'react';\nimport './css/App.css';\nimport { Header } from './components/Header/Header';\nimport { Hero } from './components/Hero/Hero';\nimport { Section } from './components/Section/Section';\nimport { CardList } from './components/CardList/CardList';\nimport { TextPassage } from './components/TextPassage/TextPassage';\nimport { Footer } from './components/Footer/Footer';\n\nimport heroImg from './images/fpo-1200x650.png';\n\nclass App extends Component {\n  render() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<Header />\n\t\t\t\n\t\t\t<Hero title=\"This is my hero\" description=\"This is the hero description text\" heroimgsrc={ heroImg } />\n\t\t\t<Section title=\"Hi I'm a section title\" description=\"This is a description of the section\">\n\t\t  \t\t<CardList listItems={[\n\t\t\t\t\t{\n\t\t\t\t\t\"theme\" : \"dark\",\n\t\t\t\t\t\"title\": \"Squeeze Its\",\n\t\t\t\t\t\"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\"title\": \"Capri Suns\",\n\t\t\t\t\t\"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\"title\": \"Hugs\",\n\t\t\t\t\t\"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\"href\": \"http://google.com\",\n\t\t\t\t\t\"title\": \"Mondo\",\n\t\t\t\t\t\"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n\t\t\t\t\t}\n\t\t  \t\t]} />\n\t\t\t\t\n\t\t\t</Section>\n\n\t\t\t<Section title=\"Hi I'm another section\" description=\"This is a different description\">\n\t\t\t\t<div className=\"l-linelength-container\">\n\t\t\t\t\t<TextPassage>\n\t\t\t\t\t\t<p>A text passage contains arbitrary text that might come from a CMS. It should live within a container that caps the line length of the text to avoid a straining reading experience.</p>\n\n\t\t\t\t\t\t<h2>Heading 2</h2>\n\n\t\t\t\t\t\t<p>This is another paragraph of text. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t</ul>\n\n\t\t\t\t\t\t<h3>Heading 3</h3>\n\n\t\t\t\t\t\t<ol>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t</ol>\n\n\t\t\t\t\t\t<p><a href=\"#link\">Lorem ipsum dolor sit amet</a>, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n\n\t\t\t\t\t\t<blockquote>\n\t\t\t\t\t\t<p>This is a quotation from something.</p>\n\t\t\t\t\t\t<cite>Cite source</cite>\n\t\t\t\t\t\t</blockquote>\n\n\t\t\t\t\t\t<p>That is all.</p>\n\t\t\t\t\t</TextPassage>\n\t\t\t\t</div>{/* end l-linelength-container */}\n\t\t\t</Section>\n\t\t\t<Footer />\n\t  \t</div>\n\t);\n  }\n}\n\nexport default App;\n\n'dumb-react/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n",
        "called_code_segment_file_1": "export class CardList extends Component {\n    render() {\n        return (\n            <ul className=\"c-card-list\">\n                {this.props.listItems.map(function(listItem, index) {\n                    return (\n                        <Card\n                            key={`c-card-${index}`}\n                            theme={listItem.theme}\n                            title={listItem.title}\n                            description={listItem.description}\n                        />\n                    );\n                })}\n            </ul>\n        );\n    }\n}\n\nCardList.propTypes = {\n    listItems: PropTypes.array\n}",
        "invoking_code_segment_file_2": "<Section title=\"Hi I'm a section title\" description=\"This is a description of the section\">\n        <CardList listItems={[\n            {\n                \"theme\" : \"dark\",\n                \"title\": \"Squeeze Its\",\n                \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n                \"title\": \"Capri Suns\",\n                \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n                \"title\": \"Hugs\",\n                \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n                \"href\": \"http://google.com\",\n                \"title\": \"Mondo\",\n                \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            }\n        ]} />\n</Section>",
        "invoking_code_segment_file_3": "No direct invocation of #file 1 or #file 2 in #file 3.",
        "new_file_code_segment": "export const filterListItems = (listItems, filter) => {\n    return listItems.filter(item => item.title.toLowerCase().includes(filter.toLowerCase()));\n}",
        "feature_description": "Add a filtering feature to the CardList component.",
        "detailed_feature_description": "The new feature allows filtering the list of cards based on the title. A new function `filterListItems` is added in #file 4 to handle the filtering logic. This function is then invoked in #file 1 to filter the listItems before rendering the cards. The filter functionality is integrated into the CardList component, and the App component is updated to include a filter input.",
        "modified_complete_code": {
            "file_1": "export class CardList extends Component {\n    render() {\n        const { listItems, filter } = this.props;\n        const filteredListItems = filterListItems(listItems, filter); #Modify\n        return (\n            <ul className=\"c-card-list\">\n                {filteredListItems.map(function(listItem, index) {\n                    return (\n                        <Card\n                            key={`c-card-${index}`}\n                            theme={listItem.theme}\n                            title={listItem.title}\n                            description={listItem.description}\n                        />\n                    );\n                })}\n            </ul>\n        );\n    }\n}\n\nCardList.propTypes = {\n    listItems: PropTypes.array,\n    filter: PropTypes.string #Modify\n}",
            "file_2": "import { filterListItems } from './filterListItems'; #New\n\n<Section title=\"Hi I'm a section title\" description=\"This is a description of the section\">\n    <input type=\"text\" onChange={(e) => this.setState({ filter: e.target.value })} placeholder=\"Filter by title\" /> #New\n    <CardList listItems={[\n        {\n            \"theme\" : \"dark\",\n            \"title\": \"Squeeze Its\",\n            \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n        },\n        {\n            \"title\": \"Capri Suns\",\n            \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n        },\n        {\n            \"title\": \"Hugs\",\n            \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n        },\n        {\n            \"href\": \"http://google.com\",\n            \"title\": \"Mondo\",\n            \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n        }\n    ]} filter={this.state.filter} /> #Modify\n</Section>",
            "file_3": "No changes required in #file 3.",
            "file_4": "export const filterListItems = (listItems, filter) => {\n    return listItems.filter(item => item.title.toLowerCase().includes(filter.toLowerCase()));\n}"
        }
    },
    {
        "repo": "vuex-examples",
        "content": "'vuex-examples/auth/models/user.js'\n:const mongoose = require('mongoose')\nconst Schema = mongoose.Schema\nconst bcrypt = require('bcrypt-nodejs')\n\nconst userSchema = new Schema({\n\temail: { type: String, unique: true, lowercase: true },\n\tpassword: String\n})\n\n//OnSave Encrypt Password\nuserSchema.pre('save', function(next) {\n\tconst user = this\n\n\tbcrypt.genSalt(10, (err, salt) => {\n\t\tif (err) {\n\t\t\treturn next(err)\n\t\t}\n\n\t\tbcrypt.hash(user.password, salt, null, (err, hash) => {\n\t\t\tif (err) {\n\t\t\t\treturn next(err)\n\t\t\t}\n\n\t\t\tuser.password = hash\n\t\t\tnext()\n\t\t})\n\t})\n})\n\nuserSchema.methods.comparePassword = function(candidatePassword, callback) {\n\tbcrypt.compare(candidatePassword, this.password, (err, isMatch) => {\n\t\tif (err) {\n\t\t\treturn callback(err)\n\t\t}\n\n\t\tcallback(null, isMatch)\n\t})\n}\n\nconst ModelClass = mongoose.model('user', userSchema)\n\nmodule.exports = ModelClass\n\n'vuex-examples/auth/controllers/auth.js'\n:const jwt = require('jwt-simple')\nconst User = require('../models/user')\n\nfunction tokenForUser(user) {\n\tconst timeStamp = new Date().getTime()\n\treturn jwt.encode({ sub: user.id, iat: timeStamp }, 'VueJS')\n}\n\nexports.signin = (req, res, next) => {\n\t//User has already had their email and password auth'd\n\t//req.user is passed on from passort\n\tres.send({ token: tokenForUser(req.user) })\n}\n\nexports.signup = (req, res, next) => {\n\tconst email = req.body.email\n\tconst password = req.body.password\n\n\tif (!email || !password) {\n\t\treturn res.status(422).send('You must provide email and password')\n\t}\n\n\tUser.findOne({ email }, (err, existingUser) => {\n\t\tif (err) {\n\t\t\treturn next(err)\n\t\t}\n\n\t\tif (existingUser) {\n\t\t\treturn res.status(422).send('Email is in use')\n\t\t}\n\n\t\tconst user = new User({ email, password })\n\n\t\tuser.save(err => {\n\t\t\tif (err) {\n\t\t\t\treturn next(err)\n\t\t\t}\n\n\t\t\tres.json({ token: tokenForUser(user) })\n\t\t})\n\t})\n}\n\n'vuex-examples/auth/server.js'\n:const express = require('express');\nconst bodyParser = require('body-parser');\nconst mongoose = require('mongoose');\nconst passport = require('passport');\n\nconst app = express();\n\nconst MONGO_URI =\n\tprocess.env.NODE_ENV === 'development'\n\t\t? 'mongodb://localhost:27017/auth'\n\t\t: 'mongodb://heroku_x4xnglm7:em5c6br38p6molbe25j3qfqod6@ds011880.mlab.com:11880/heroku_x4xnglm7';\n\nmongoose.connect(MONGO_URI);\n\nif (process.env.NODE_ENV === 'development') {\n\tconst webpack = require('webpack');\n\tconst webpackDevMiddleware = require('webpack-dev-middleware');\n\tconst config = require('./webpack.config');\n\tconst compiler = webpack(config);\n\n\tapp.use(\n\t\twebpackDevMiddleware(compiler, {\n\t\t\tnoInfo: true,\n\t\t\tpublicPath: config.output.publicPath,\n\t\t\twriteToDisk: filePath => {\n\t\t\t\treturn /.*\\.html$/.test(filePath);\n\t\t\t}\n\t\t})\n\t);\n}\n\napp.use(bodyParser.json());\n\nconst Auth = require('./controllers/auth');\nrequire('./services/passport');\n\nconst requireAuth = passport.authenticate('jwt', { session: false });\nconst requireSignin = passport.authenticate('local', { session: false });\n\napp.post('/auth/signin', requireSignin, Auth.signin);\napp.post('/auth/signup', Auth.signup);\napp.get('/auth/verify', requireAuth);\n\napp.use('/dist', express.static(process.cwd() + '/dist'));\n\napp.use((req, res) => res.sendFile(__dirname + '/dist/index.html'));\n\napp.listen(3000, () => console.log('Server Listening on PORT 3000'));\n\n",
        "called_code_segment_file_1": "userSchema.methods.comparePassword = function(candidatePassword, callback) {\n\tbcrypt.compare(candidatePassword, this.password, (err, isMatch) => {\n\t\tif (err) {\n\t\t\treturn callback(err)\n\t\t}\n\n\t\tcallback(null, isMatch)\n\t})\n}",
        "invoking_code_segment_file_2": "const requireSignin = passport.authenticate('local', { session: false });\n\napp.post('/auth/signin', requireSignin, Auth.signin);",
        "invoking_code_segment_file_3": "exports.signin = (req, res, next) => {\n\t//User has already had their email and password auth'd\n\t//req.user is passed on from passort\n\tres.send({ token: tokenForUser(req.user) })\n}",
        "new_file_code_segment": "exports.generateToken = (user) => {\n\tconst timeStamp = new Date().getTime()\n\treturn jwt.encode({ sub: user.id, iat: timeStamp }, 'VueJS')\n}",
        "feature_description": "Add a new feature to generate a token with additional claims.",
        "detailed_feature_description": "The new feature involves modifying the token generation process to include additional claims. A new file (#file 4) is created to handle the token generation with additional claims. This new functionality is integrated into the existing flow by updating the token generation logic in #file 1 and ensuring that #file 2 and #file 3 can invoke the new token generation method from #file 4.",
        "modified_complete_code": {
            "file_1": "const mongoose = require('mongoose')\nconst Schema = mongoose.Schema\nconst bcrypt = require('bcrypt-nodejs')\n\nconst userSchema = new Schema({\n\temail: { type: String, unique: true, lowercase: true },\n\tpassword: String\n})\n\n//OnSave Encrypt Password\nuserSchema.pre('save', function(next) {\n\tconst user = this\n\n\tbcrypt.genSalt(10, (err, salt) => {\n\t\tif (err) {\n\t\t\treturn next(err)\n\t\t}\n\n\t\tbcrypt.hash(user.password, salt, null, (err, hash) => {\n\t\t\tif (err) {\n\t\t\t\treturn next(err)\n\t\t\t}\n\n\t\t\tuser.password = hash\n\t\t\tnext()\n\t\t})\n\t})\n})\n\nuserSchema.methods.comparePassword = function(candidatePassword, callback) {\n\tbcrypt.compare(candidatePassword, this.password, (err, isMatch) => {\n\t\tif (err) {\n\t\t\treturn callback(err)\n\t\t}\n\n\t\tcallback(null, isMatch)\n\t})\n}\n\nconst ModelClass = mongoose.model('user', userSchema)\n\nmodule.exports = ModelClass",
            "file_2": "const jwt = require('jwt-simple')\nconst User = require('../models/user')\nconst TokenService = require('./tokenService') // #New\n\nfunction tokenForUser(user) {\n\treturn TokenService.generateToken(user) // #Modify\n}\n\nexports.signin = (req, res, next) => {\n\t//User has already had their email and password auth'd\n\t//req.user is passed on from passort\n\tres.send({ token: tokenForUser(req.user) })\n}\n\nexports.signup = (req, res, next) => {\n\tconst email = req.body.email\n\tconst password = req.body.password\n\n\tif (!email || !password) {\n\t\treturn res.status(422).send('You must provide email and password')\n\t}\n\n\tUser.findOne({ email }, (err, existingUser) => {\n\t\tif (err) {\n\t\t\treturn next(err)\n\t\t}\n\n\t\tif (existingUser) {\n\t\t\treturn res.status(422).send('Email is in use')\n\t\t}\n\n\t\tconst user = new User({ email, password })\n\n\t\tuser.save(err => {\n\t\t\tif (err) {\n\t\t\t\treturn next(err)\n\t\t\t}\n\n\t\t\tres.json({ token: tokenForUser(user) })\n\t\t})\n\t})\n}",
            "file_3": "const express = require('express')\nconst bodyParser = require('body-parser')\nconst mongoose = require('mongoose')\nconst passport = require('passport')\n\nconst app = express()\n\nconst MONGO_URI = process.env.NODE_ENV === 'development' ? 'mongodb://localhost:27017/auth' : 'mongodb://heroku_x4xnglm7:em5c6br38p6molbe25j3qfqod6@ds011880.mlab.com:11880/heroku_x4xnglm7'\n\nmongoose.connect(MONGO_URI)\n\nif (process.env.NODE_ENV === 'development') {\n\tconst webpack = require('webpack')\n\tconst webpackDevMiddleware = require('webpack-dev-middleware')\n\tconst config = require('./webpack.config')\n\tconst compiler = webpack(config)\n\n\tapp.use(\n\t\twebpackDevMiddleware(compiler, {\n\t\t\tnoInfo: true,\n\t\t\tpublicPath: config.output.publicPath,\n\t\t\twriteToDisk: filePath => {\n\t\t\t\treturn /.*\\.html$/.test(filePath)\n\t\t\t}\n\t\t})\n\t)\n}\n\napp.use(bodyParser.json())\n\nconst Auth = require('./controllers/auth')\nrequire('./services/passport')\n\nconst requireAuth = passport.authenticate('jwt', { session: false })\nconst requireSignin = passport.authenticate('local', { session: false })\n\napp.post('/auth/signin', requireSignin, Auth.signin)\napp.post('/auth/signup', Auth.signup)\napp.get('/auth/verify', requireAuth)\n\napp.use('/dist', express.static(process.cwd() + '/dist'))\n\napp.use((req, res) => res.sendFile(__dirname + '/dist/index.html'))\n\napp.listen(3000, () => console.log('Server Listening on PORT 3000'))",
            "file_4": "const jwt = require('jwt-simple')\n\nexports.generateToken = (user) => {\n\tconst timeStamp = new Date().getTime()\n\treturn jwt.encode({ sub: user.id, iat: timeStamp, role: user.role }, 'VueJS') // #Modify\n}"
        }
    },
    {
        "repo": "ProjectFlowerbed",
        "content": "'ProjectFlowerbed/src/js/systems/ui/NUXSystem.js'\n:/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as THREE from 'three';\nimport * as localforage from 'localforage';\n\nimport {\n\tNUXMovementTriggerArea,\n\tNUXPanelComponent,\n\tNUXStateComponent,\n\tNUX_STEPS,\n} from '../../components/NUXStateComponent';\nimport {\n\tSelectionWheelComponent,\n\tWHEEL_STATE,\n} from '../../components/SelectionWheelComponent';\n\nimport { GameStateComponent } from '../../components/GameStateComponent';\nimport { IsActive } from '../../components/GameObjectTagComponents';\nimport { JoystickMovementSystem } from '../locomotion/JoystickMovementSystem';\nimport { LOCALSTORAGE_KEYS } from '../../Constants';\nimport { LocomotionVignetteSystem } from '../locomotion/LocomotionVignetteSystem';\nimport { PlantGrowingComponent } from '../../components/PlantingComponents';\nimport { PlayerStateComponent } from '../../components/PlayerStateComponent';\nimport { SeedboxComponent } from '../../components/SeedboxComponents';\nimport { SelectionWheelSystem } from '../selectionWheels/SelectionWheelSystem';\nimport { SnapTurnSystem } from '../locomotion/SnapTurnSystem';\nimport { System } from 'ecsy';\nimport { THREEGlobalComponent } from '../../components/THREEGlobalComponent';\nimport { TeleportationSystem } from '../locomotion/TeleportationSystem';\nimport { UIPanelComponent } from '../../components/UIPanelComponent';\nimport { VrControllerComponent } from '../../components/VrControllerComponent';\nimport { getOnlyEntity } from '../../utils/entityUtils';\n\n/**\n * Creates and updates the NUX.\n */\nexport class NUXSystem extends System {\n\tinit() {\n\t\tthis.queries.gameManager.results.forEach((entity) => {\n\t\t\tthis.renderer = entity.getComponent(THREEGlobalComponent).renderer;\n\t\t});\n\n\t\t// used to accumulate player movement for the locomotion step\n\t\tthis.totalPlayerMovement = new THREE.Vector3();\n\t\tthis.previousSeedboxPage = -1;\n\t\tthis.previousSeedboxIndex = -1;\n\t}\n\n\texecute() {\n\t\tconst nuxState = getOnlyEntity(this.queries.nux).getMutableComponent(\n\t\t\tNUXStateComponent,\n\t\t);\n\t\tif (!nuxState.shouldShowNUX) {\n\t\t\tif (\n\t\t\t\tnuxState.currentState !== NUX_STEPS.BEFORE_START &&\n\t\t\t\tnuxState.currentState !== NUX_STEPS.ENDED\n\t\t\t) {\n\t\t\t\t// restart mode selection wheel system\n\t\t\t\tthis.world.getSystem(SelectionWheelSystem).play();\n\t\t\t}\n\t\t\tnuxState.currentState = NUX_STEPS.ENDED;\n\t\t\tthis.stop();\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.renderer || !this.renderer.xr.isPresenting) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.queries.controllers.results.forEach((entity) => {\n\t\t\tlet vrControllerComponent = entity.getComponent(VrControllerComponent);\n\t\t\tif (vrControllerComponent.handedness === 'right') {\n\t\t\t\tthis.controllerInterface = vrControllerComponent.controllerInterface;\n\t\t\t}\n\t\t});\n\n\t\tconst selectionWheelEntity = getOnlyEntity(\n\t\t\tthis.queries.selectionWheel,\n\t\t\tfalse,\n\t\t);\n\t\tif (!selectionWheelEntity) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst selectionWheel = selectionWheelEntity.getComponent(\n\t\t\tSelectionWheelComponent,\n\t\t);\n\n\t\t// check ongoing NUX actions\n\t\tswitch (nuxState.currentState) {\n\t\t\tcase NUX_STEPS.LOCOMOTION_MOVE_TO: {\n\t\t\t\t// check if we've teleported, or if we traveled a certain distance with the joystick\n\t\t\t\tconst player = getOnlyEntity(this.queries.player).getComponent(\n\t\t\t\t\tPlayerStateComponent,\n\t\t\t\t);\n\t\t\t\tif (player.didJustTeleport) {\n\t\t\t\t\tnuxState.setState(NUX_STEPS.SEEDBOX);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (player.didMove) {\n\t\t\t\t\tthis.totalPlayerMovement.add(player.deltaMovement);\n\t\t\t\t\tif (this.totalPlayerMovement.lengthSq() > 9) {\n\t\t\t\t\t\t// 3m of movement\n\t\t\t\t\t\tnuxState.setState(NUX_STEPS.SEEDBOX);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase NUX_STEPS.SEEDBOX_OPEN_MENU:\n\t\t\t\tif (selectionWheel.state === WHEEL_STATE.DEPLOYED) {\n\t\t\t\t\tnuxState.setState(NUX_STEPS.SEEDBOX_OPEN_SEEDBOX);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase NUX_STEPS.SEEDBOX_OPEN_SEEDBOX:\n\t\t\t\tif (selectionWheel.state === WHEEL_STATE.RETRACTED) {\n\t\t\t\t\tconst currentInteractionMode = getOnlyEntity(\n\t\t\t\t\t\tthis.queries.gameState,\n\t\t\t\t\t).getComponent(GameStateComponent).interactionMode;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcurrentInteractionMode ===\n\t\t\t\t\t\tGameStateComponent.INTERACTION_MODES.PLANTING\n\t\t\t\t\t) {\n\t\t\t\t\t\tnuxState.setState(NUX_STEPS.SEEDBOX_PLANT_SEED);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnuxState.setState(NUX_STEPS.SEEDBOX_OPEN_MENU);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase NUX_STEPS.SEEDBOX_PLANT_SEED:\n\t\t\t\tif (this.queries.plantedSeed.added.length > 0) {\n\t\t\t\t\tnuxState.setState(NUX_STEPS.CLOSING);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (nuxState.justUpdatedCurrentNUXState) {\n\t\t\tthis._justUpdatedNUXState(nuxState);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t_justUpdatedNUXState(nuxState) {\n\t\tnuxState.justUpdatedCurrentNUXState = false;\n\n\t\t// Hide or show NUX panels depending on what the current state is.\n\t\tthis.queries.nuxPanels.results.forEach((entity) => {\n\t\t\tconst nuxPanel = entity.getComponent(NUXPanelComponent);\n\t\t\tif (nuxPanel.id === nuxState.currentState) {\n\t\t\t\tif (nuxPanel.delay > 0) {\n\t\t\t\t\t// timeout, show if it's still relevant\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tif (nuxPanel.id !== nuxState.currentState) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._showPanel(entity);\n\t\t\t\t\t}, nuxPanel.delay);\n\t\t\t\t} else {\n\t\t\t\t\t// show immediately\n\t\t\t\t\tthis._showPanel(entity);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (entity.hasComponent(IsActive)) {\n\t\t\t\t\tentity.removeComponent(IsActive);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// custom handling for every step\n\t\tswitch (nuxState.currentState) {\n\t\t\tcase NUX_STEPS.BEFORE_START:\n\t\t\t\t// disable a bunch of systems\n\t\t\t\tthis.world.getSystem(LocomotionVignetteSystem).stop();\n\t\t\t\tthis.world.getSystem(TeleportationSystem).stop();\n\t\t\t\tthis.world.getSystem(JoystickMovementSystem).stop();\n\t\t\t\tthis.world.getSystem(SnapTurnSystem).stop();\n\t\t\t\tthis.world.getSystem(SelectionWheelSystem).stop();\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tnuxState.setState(NUX_STEPS.WELCOME);\n\t\t\t\t}, 1000);\n\t\t\t\tbreak;\n\t\t\tcase NUX_STEPS.LOCOMOTION_MOVE_TO:\n\t\t\t\tthis.world.getSystem(LocomotionVignetteSystem).play();\n\t\t\t\tthis.world.getSystem(TeleportationSystem).play();\n\t\t\t\tthis.world.getSystem(JoystickMovementSystem).play();\n\t\t\t\tthis.world.getSystem(SnapTurnSystem).play();\n\n\t\t\t\t// a timeout that will be canceled if we have already moved\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (nuxState.currentState === NUX_STEPS.LOCOMOTION_MOVE_TO) {\n\t\t\t\t\t\tnuxState.setState(NUX_STEPS.SEEDBOX);\n\t\t\t\t\t}\n\t\t\t\t}, 40000);\n\n\t\t\t\tbreak;\n\t\t\tcase NUX_STEPS.SEEDBOX_OPEN_MENU:\n\t\t\t\tthis.world.getSystem(SelectionWheelSystem).play();\n\t\t\t\tbreak;\n\t\t\tcase NUX_STEPS.SEEDBOX_PLANT_SEED: {\n\t\t\t\tconst seedbox = getOnlyEntity(this.queries.seedbox).getMutableComponent(\n\t\t\t\t\tSeedboxComponent,\n\t\t\t\t);\n\t\t\t\tthis.previousSeedboxPage = seedbox.currentPageId;\n\t\t\t\tthis.previousSeedboxIndex = seedbox.currentPlantIndex;\n\n\t\t\t\tseedbox.selectPlantGroup('sugarpine');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase NUX_STEPS.ENDED: {\n\t\t\t\t// restart all systems that the NUX could've stopped.\n\t\t\t\tthis.world.getSystem(LocomotionVignetteSystem).play();\n\t\t\t\tthis.world.getSystem(TeleportationSystem).play();\n\t\t\t\tthis.world.getSystem(JoystickMovementSystem).play();\n\t\t\t\tthis.world.getSystem(SnapTurnSystem).play();\n\t\t\t\tthis.world.getSystem(SelectionWheelSystem).play();\n\n\t\t\t\t// flag that we've seen the NUX, so we don't show it again.\n\t\t\t\tlocalforage.setItem(LOCALSTORAGE_KEYS.SEEN_NUX, true);\n\n\t\t\t\tconst seedbox = getOnlyEntity(this.queries.seedbox).getMutableComponent(\n\t\t\t\t\tSeedboxComponent,\n\t\t\t\t);\n\n\t\t\t\t// restore seedbox defaults if we changed it as a result of going through the\n\t\t\t\t// planting tutorial.\n\t\t\t\tif (this.previousSeedboxPage >= 0) {\n\t\t\t\t\tseedbox.currentPageId = this.previousSeedboxPage;\n\t\t\t\t}\n\t\t\t\tif (this.previousSeedboxIndex >= 0) {\n\t\t\t\t\tseedbox.currentPlantIndex = this.previousSeedboxIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t_showPanel(nuxPanelEntity) {\n\t\tif (!nuxPanelEntity.hasComponent(IsActive)) {\n\t\t\tnuxPanelEntity.addComponent(IsActive);\n\t\t\tconst nuxPanel = nuxPanelEntity.getComponent(NUXPanelComponent);\n\t\t\tif (nuxPanel.onShow) {\n\t\t\t\tnuxPanel.onShow();\n\t\t\t}\n\t\t}\n\t}\n\n\t_ensureUIRayActive() {\n\t\tlet gameState = getOnlyEntity(this.queries.gameState).getMutableComponent(\n\t\t\tGameStateComponent,\n\t\t);\n\t\tif (\n\t\t\tgameState.interactionMode !== GameStateComponent.INTERACTION_MODES.DEFAULT\n\t\t) {\n\t\t\tgameState.setInteractionMode(\n\t\t\t\tGameStateComponent.INTERACTION_MODES.DEFAULT,\n\t\t\t);\n\t\t}\n\t}\n}\n\nNUXSystem.queries = {\n\tcontrollers: { components: [VrControllerComponent], listen: { added: true } },\n\tgameManager: {\n\t\tcomponents: [THREEGlobalComponent],\n\t\tlisten: { added: true },\n\t},\n\tgameState: {\n\t\tcomponents: [GameStateComponent],\n\t},\n\tnux: { components: [NUXStateComponent] },\n\tnuxPanels: { components: [NUXPanelComponent, UIPanelComponent] },\n\n\tplayer: {\n\t\tcomponents: [PlayerStateComponent],\n\t},\n\n\t// queries needed for individual steps.\n\tintendedTeleportArea: {\n\t\tcomponents: [NUXMovementTriggerArea],\n\t},\n\tseedbox: {\n\t\tcomponents: [SeedboxComponent],\n\t},\n\tselectionWheel: {\n\t\tcomponents: [SelectionWheelComponent],\n\t},\n\tplantedSeed: {\n\t\tcomponents: [PlantGrowingComponent],\n\t\tlisten: { added: true },\n\t},\n};\n\n'ProjectFlowerbed/src/js/ECSYConfig.js'\n:/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport {\n\tAerialFaunaGroupComponent,\n\tAerialFaunaMovementComponent,\n\tWaterFaunaGroupComponent,\n\tWaterFaunaMovementComponent,\n} from './components/FaunaComponents';\nimport {\n\tCapsuleColliderComponent,\n\tCollisionAreaComponent,\n\tCollisionWorldComponent,\n\tStaticColliderComponent,\n\tStaticColliderResources,\n} from './components/ColliderComponents';\nimport {\n\tControlsPanelComponent,\n\tSettingsComponent,\n\tSettingsPanelComponent,\n} from './components/SettingsComponent';\nimport {\n\tCurvedRay,\n\tRayComponent,\n\tShortRay,\n\tStraightRay,\n} from './components/RayComponents';\nimport {\n\tEnvironmentProp,\n\tHovered,\n\tIsActive,\n\tLight,\n\tMainEnvironment,\n\tPressed,\n} from './components/GameObjectTagComponents';\nimport {\n\tInstancedMeshComponent,\n\tInstancedMeshInstanceComponent,\n} from './components/InstancedMeshComponent';\nimport {\n\tLoopingAudioComponent,\n\tLoopingAudioResources,\n\tOneshotAudioComponent,\n\tPlaylistAudioComponent,\n\tPlaylistAudioResources,\n} from './components/AudioComponents';\nimport {\n\tMorphTargetAnimationComponent,\n\tMorphTargetMeshInitialized,\n} from './components/MorphTargetAnimationComponent';\nimport {\n\tNUXMovementTriggerArea,\n\tNUXPanelComponent,\n\tNUXStateComponent,\n} from './components/NUXStateComponent';\nimport {\n\tPhotoComponent,\n\tPhotoMenuComponent,\n\tScreenshotCameraComponent,\n} from './components/ScreenshotCameraComponent';\nimport {\n\tPickedPlantComponent,\n\tPlantGrowingComponent,\n\tPlantShrinkingComponent,\n\tPlantTinyColliderComponent,\n\tPlantedComponent,\n\tPlantingStateComponent,\n\tSeedAnimationComponent,\n} from './components/PlantingComponents';\nimport {\n\tPlayerColliderComponent,\n\tPlayerStateComponent,\n} from './components/PlayerStateComponent';\nimport {\n\tSeedComponent,\n\tSeedbagComponent,\n\tSeedboxButtonComponent,\n\tSeedboxComponent,\n} from './components/SeedboxComponents';\nimport {\n\tUIPanelComponent,\n\tUIPanelMedia,\n\tUIPanelResources,\n} from './components/UIPanelComponent';\n\nimport { AerialFaunaCreationSystem } from './systems/fauna/AerialFaunaCreationSystem';\nimport { AerialFaunaMovementSystem } from './systems/fauna/AerialFaunaMovementSystem';\nimport { AmbientSoundCreationSystem } from './systems/audio/AmbientSoundCreationSystem';\nimport { AssetDatabaseComponent } from './components/AssetDatabaseComponent';\nimport { AssetLoadingSystem } from './systems/assets/AssetLoadingSystem';\nimport { AudioSystem } from './systems/audio/AudioSystem';\nimport { BootstrapSessionSystem } from './systems/core/BootstrapSessionSystem';\nimport { CameraHandContextualNUXSystem } from './systems/hands/CameraHandContextualNUXSystem';\nimport { CameraPhotoGrabTooltipSystem } from './systems/ui/progressiveTooltips/CameraPhotoGrabTooltipSystem';\nimport { CollisionAreaSystem } from './systems/collisions/CollisionAreaSystems';\nimport { CollisionWorldSystem } from './systems/collisions/CollisionSystem';\nimport { ControlsPanelSystem } from './systems/settings/ControlsPanelSystem';\nimport { DEBUG_CONSTANTS } from './Constants';\nimport { DebugClearFlagsSystem } from './systems/landing-page/DebugClearFlagsSystem';\nimport { EnterVRTransitionSystem } from './systems/locomotion/EnterVRTransitionSystem';\nimport { FaunaAnimationComponent } from './components/FaunaAnimationComponent';\nimport { FaunaAnimationSystem } from './systems/fauna/FaunaAnimationSystem';\nimport { FaunaClusterComponent } from './components/FaunaClusterComponent';\nimport { FaunaColliderComponent } from './components/FaunaColliderComponent';\nimport { FaunaCreationSystem } from './systems/fauna/FaunaCreationSystem';\nimport { FaunaMovementBoundSamplerSystem } from './devTools/FaunaMovementBoundSamplerSystem';\nimport { GameStateComponent } from './components/GameStateComponent';\nimport { GameStateUpdateSystem } from './systems/core/GameStateUpdateSystem';\nimport { GardenManagementSystem } from './systems/landing-page/GardenManagementSystem';\nimport { GazeFollowSystem } from './systems/ui/GazeFollowSystem';\nimport { GazeFollowerComponent } from './components/GazeFollowerComponent';\nimport { HandAnimationSystem } from './systems/hands/HandAnimationSystem';\nimport { HandCreationSystem } from './systems/hands/HandCreationSystem';\nimport { HandNUXSystem } from './systems/hands/HandNUXSystem';\nimport { HandPoseExtractionSystem } from './devTools/HandPoseExtractorSystem';\nimport { IndicatorRingComponent } from './components/IndicatorRingComponent';\nimport { IndicatorRingSystem } from './systems/ui/IndicatorRingSystem';\nimport { JoystickMovementSystem } from './systems/locomotion/JoystickMovementSystem';\nimport { LoadingScreenComponent } from './components/LoadingScreenComponent';\nimport { LoadingScreenSystem } from './systems/landing-page/LoadingScreenSystem';\nimport { LocalSaveDataSystem } from './systems/saveLoad/SaveDataSystem';\nimport { LocomotionVignetteSystem } from './systems/locomotion/LocomotionVignetteSystem';\nimport { MeshIdComponent } from './components/AssetReplacementComponents';\nimport { MeshInstancingSystem } from './systems/mesh/MeshInstancingSystem';\nimport { MeshPreviewObject } from './components/MeshPreviewObjectComponent';\nimport { ModelOptimizeSystem } from './systems/mesh/ModelOptimizeSystem';\nimport { MorphTargetAnimationSystem } from './systems/fauna/MorphTargetAnimationSystem';\nimport { MovableFaunaComponent } from './components/MovableFaunaComponent';\nimport { MovableFaunaSystem } from './systems/fauna/MovableFaunaSystem';\nimport { MusicSystem } from './systems/audio/MusicSystem';\nimport { NUXCreationSystem } from './systems/ui/NUXCreationSystem';\nimport { NUXSystem } from './systems/ui/NUXSystem';\nimport { Object3DComponent } from './components/Object3DComponent';\nimport { ObjectFollowSystem } from './systems/ui/ObjectFollowSystem';\nimport { ObjectFollowerComponent } from './components/ObjectFollowerComponent';\nimport { OptimizedModelComponent } from './components/OptimizedModelComponent';\nimport { PerformanceOptionsComponent } from './components/PerformanceOptionsComponent';\nimport { PerformanceTestSystem } from './systems/performance/PerformanceTestSystem';\nimport { PhotoAutoDeleteSystem } from './systems/camera/PhotoAutoDeleteSystem';\nimport { PhotoMenuCreationSystem } from './systems/camera/PhotoMenuCreationSystem';\nimport { PhotoSystem } from './systems/camera/PhotoSystem';\nimport { PlantColliderSystem } from './systems/plants/PlantColliderSystem';\nimport { PlantGrowingSystem } from './systems/plants/PlantGrowingSystem';\nimport { PlantPickingSystem } from './systems/plants/PlantPickingSystem';\nimport { PlantShrinkingSystem } from './systems/plants/PlantShrinkingSystem';\nimport { PlantingArrowSystem } from './systems/plants/PlantingArrowSystem';\nimport { PlantingSystem } from './systems/plants/PlantingSystem';\nimport { PlayerPhysicsSystem } from './systems/core/PlayerPhysicsSystem';\nimport { PlaylistAudioSystem } from './systems/audio/PlaylistAudioSystem';\nimport { PropsCalibrationSystem } from './devTools/PropsCalibrationSystem';\nimport { RayDrawingSystem } from './systems/raycasting/RayDrawingSystem';\nimport { RaycastSystem } from './systems/raycasting/RaycastSystem';\nimport { RenderingSystem } from './systems/core/RenderingSystem';\nimport { ResetNUXSystem } from './systems/ui/ResetNUXSystem';\nimport { SavableObject } from './components/SaveDataComponents';\nimport { SaveControllerSystem } from './systems/saveLoad/SaveControllerSystem';\nimport { SceneCreationSystem } from './systems/core/SceneCreationSystem';\nimport { SceneLightingComponent } from './components/SceneLightingComponent';\nimport { ScreenshotCameraCreationSystem } from './systems/camera/ScreenshotCameraCreationSystem';\nimport { ScreenshotCameraSystem } from './systems/camera/ScreenshotCameraSystem';\nimport { SeedAnimationSystem } from './systems/plants/SeedAnimationSystem';\nimport { SeedboxChangePageTooltipSystem } from './systems/ui/progressiveTooltips/SeedboxChangePageTooltipSystem';\nimport { SeedboxCreationSystem } from './systems/seedbox/SeedboxCreationSystem';\nimport { SeedboxFocusDetectionSystem } from './systems/seedbox/SeedboxFocusDetectionSystem';\nimport { SeedboxHandContextualNUXSystem } from './systems/hands/SeedboxHandContextualNUXSystem';\nimport { SeedboxSystem } from './systems/seedbox/SeedboxSystem';\nimport { SelectionWheelComponent } from './components/SelectionWheelComponent';\nimport { SelectionWheelCreationSystem } from './systems/selectionWheels/SelectionWheelCreationSystem';\nimport { SelectionWheelSystem } from './systems/selectionWheels/SelectionWheelSystem';\nimport { SessionComponent } from './components/SessionComponent';\nimport { SettingsCreationSystem } from './systems/settings/SettingsCreationSystem';\nimport { SettingsSystem } from './systems/settings/SettingsSystem';\nimport { SkeletonAnimationComponent } from './components/SkeletonAnimationComponent';\nimport { SnapTurnSystem } from './systems/locomotion/SnapTurnSystem';\nimport { StationaryFaunaComponent } from './components/StationaryFaunaComponent';\nimport { StationaryFaunaSystem } from './systems/fauna/StationaryFaunaSystem';\nimport { THREEGlobalComponent } from './components/THREEGlobalComponent';\nimport { TeleportationSystem } from './systems/locomotion/TeleportationSystem';\nimport { UIPanelInteractionSystem } from './systems/ui/UIPanelInteractionSystem';\nimport { UIPanelMediaSystem } from './systems/ui/UIPanelMediaSystem';\nimport { UIPanelPreviewSystem } from './systems/ui/UIPanelPreviewSystem';\nimport { UIPanelResourcesSystem } from './systems/ui/UIPanelResourcesSystem';\nimport { UserIdentityComponent } from './components/UserIdentityComponent';\nimport { VrControllerComponent } from './components/VrControllerComponent';\nimport { VrInputSystem } from './systems/core/VrInputSystem';\nimport { WaterFaunaCreationSystem } from './systems/fauna/WaterFaunaCreationSystem';\nimport { WaterFaunaMovementSystem } from './systems/fauna/WaterFaunaMovementSystem';\nimport { WateringSystem } from './systems/plants/WateringSystem';\nimport { World } from 'ecsy';\n\nconst ENABLE_HAND_POSER = false;\n\nexport const setupECSY = () => {\n\tlet world = new World();\n\n\tregisterTagComponents(world);\n\n\tregisterComponents(world);\n\n\tregisterSystems(world);\n\n\treturn world;\n};\n\n/**\n * Register TagComponents\n * @param {World} world\n */\nconst registerTagComponents = (world) => {\n\tworld.registerComponent(Light);\n\tworld.registerComponent(Hovered);\n\tworld.registerComponent(Pressed);\n\tworld.registerComponent(IsActive);\n\tworld.registerComponent(StraightRay);\n\tworld.registerComponent(ShortRay);\n\tworld.registerComponent(CurvedRay);\n\tworld.registerComponent(MainEnvironment);\n\tworld.registerComponent(EnvironmentProp);\n\tworld.registerComponent(MorphTargetMeshInitialized);\n};\n\n/**\n * Regitser normal components\n * @param {World} world\n */\nconst registerComponents = (world) => {\n\tworld.registerComponent(VrControllerComponent);\n\tworld.registerComponent(Object3DComponent);\n\tworld.registerComponent(GameStateComponent);\n\tworld.registerComponent(PlayerStateComponent);\n\tworld.registerComponent(OptimizedModelComponent);\n\tworld.registerComponent(PerformanceOptionsComponent);\n\tworld.registerComponent(THREEGlobalComponent);\n\tworld.registerComponent(SeedComponent);\n\tworld.registerComponent(CollisionWorldComponent);\n\tworld.registerComponent(StaticColliderComponent);\n\tworld.registerComponent(StaticColliderResources);\n\tworld.registerComponent(CapsuleColliderComponent);\n\tworld.registerComponent(PlayerColliderComponent);\n\tworld.registerComponent(SeedboxComponent);\n\tworld.registerComponent(SeedboxButtonComponent);\n\tworld.registerComponent(GazeFollowerComponent);\n\tworld.registerComponent(ObjectFollowerComponent);\n\tworld.registerComponent(UIPanelComponent);\n\tworld.registerComponent(UIPanelResources);\n\tworld.registerComponent(UIPanelMedia);\n\tworld.registerComponent(NUXStateComponent);\n\tworld.registerComponent(NUXPanelComponent);\n\tworld.registerComponent(RayComponent);\n\tworld.registerComponent(IndicatorRingComponent);\n\tworld.registerComponent(PlantedComponent);\n\tworld.registerComponent(PickedPlantComponent);\n\tworld.registerComponent(SavableObject);\n\tworld.registerComponent(CollisionAreaComponent);\n\tworld.registerComponent(NUXMovementTriggerArea);\n\tworld.registerComponent(ScreenshotCameraComponent);\n\tworld.registerComponent(PhotoComponent);\n\tworld.registerComponent(PhotoMenuComponent);\n\tworld.registerComponent(AssetDatabaseComponent);\n\tworld.registerComponent(MeshIdComponent);\n\tworld.registerComponent(SelectionWheelComponent);\n\tworld.registerComponent(OneshotAudioComponent);\n\tworld.registerComponent(PlantGrowingComponent);\n\tworld.registerComponent(PlantShrinkingComponent);\n\tworld.registerComponent(PlantingStateComponent);\n\tworld.registerComponent(LoopingAudioComponent);\n\tworld.registerComponent(LoopingAudioResources);\n\tworld.registerComponent(PlaylistAudioComponent);\n\tworld.registerComponent(PlaylistAudioResources);\n\tworld.registerComponent(PlantTinyColliderComponent);\n\tworld.registerComponent(SeedAnimationComponent);\n\tworld.registerComponent(SeedbagComponent);\n\tworld.registerComponent(InstancedMeshComponent);\n\tworld.registerComponent(InstancedMeshInstanceComponent);\n\tworld.registerComponent(FaunaClusterComponent);\n\tworld.registerComponent(FaunaColliderComponent);\n\tworld.registerComponent(FaunaAnimationComponent);\n\tworld.registerComponent(MorphTargetAnimationComponent);\n\tworld.registerComponent(SkeletonAnimationComponent);\n\tworld.registerComponent(MovableFaunaComponent);\n\tworld.registerComponent(StationaryFaunaComponent);\n\tworld.registerComponent(MeshPreviewObject);\n\tworld.registerComponent(SceneLightingComponent, false); // disable component pooling so we can setup on construction\n\tworld.registerComponent(LoadingScreenComponent);\n\tworld.registerComponent(UserIdentityComponent);\n\tworld.registerComponent(WaterFaunaMovementComponent);\n\tworld.registerComponent(WaterFaunaGroupComponent);\n\tworld.registerComponent(SettingsPanelComponent);\n\tworld.registerComponent(ControlsPanelComponent);\n\tworld.registerComponent(SettingsComponent);\n\tworld.registerComponent(AerialFaunaMovementComponent);\n\tworld.registerComponent(AerialFaunaGroupComponent);\n\tworld.registerComponent(SessionComponent);\n};\n\n/**\n * Register the systems that need to run on startup in the world.\n * These include anything that interacts with the 2D landing page, or\n * any code that needs to setup THREE.JS before assets are loaded.\n * @param {World} world\n */\nconst registerSystems = (world) => {\n\tworld.registerSystem(GardenManagementSystem);\n\t// the AssetLoadingSystem calls `registerSystemsAfterLoad` once all assets\n\t// have finished loading.\n\tworld.registerSystem(AssetLoadingSystem, { priority: -10 });\n\n\t// loading screen is calculated after we spin up asset loading, before everything else\n\tworld.registerSystem(LoadingScreenSystem, { priority: -9 });\n\n\t// allows for resetting the NUX before loading\n\tworld.registerSystem(DebugClearFlagsSystem);\n\tworld.registerSystem(ResetNUXSystem);\n\n\t// rendering should happen after all the logic of the frame has been calculated.\n\tworld.registerSystem(RenderingSystem, { priority: 99 });\n};\n\n/**\n * Systems that don't need to run until after we've loaded in the assets\n * should be defined here. Most gameplay systems fall into this category.\n * @param {World} world\n */\nexport const registerSystemsAfterLoad = (world) => {\n\t// collisions and other level-altering systems rely on scene creation\n\t// running first.\n\tworld.registerSystem(SceneCreationSystem, { priority: -2 });\n\n\t// model optimization processing needs to happen before calculating\n\t// collisions\n\tworld.registerSystem(ModelOptimizeSystem, { priority: -1 });\n\tworld.registerSystem(BootstrapSessionSystem);\n\n\t// the UI systems need to come before any systems that create UI panels.\n\tworld.registerSystem(UIPanelResourcesSystem);\n\tworld.registerSystem(UIPanelInteractionSystem);\n\tworld.registerSystem(UIPanelMediaSystem);\n\n\tworld.registerSystem(HandCreationSystem);\n\tworld.registerSystem(EnterVRTransitionSystem);\n\tworld.registerSystem(ScreenshotCameraCreationSystem);\n\tworld.registerSystem(PhotoMenuCreationSystem);\n\tworld.registerSystem(SelectionWheelCreationSystem);\n\tworld.registerSystem(SeedboxCreationSystem);\n\tworld.registerSystem(CollisionWorldSystem);\n\tworld.registerSystem(CollisionAreaSystem);\n\tworld.registerSystem(VrInputSystem);\n\tworld.registerSystem(HandAnimationSystem);\n\n\tworld.registerSystem(PlayerPhysicsSystem);\n\tworld.registerSystem(WateringSystem); // needs to be executed before RaycastSystem to update water ray in time\n\n\t// Raycast system sets up rays based on controller inputs -- needs to happen after controller movement, but before\n\t// any of the systems that use raycasting. This way, we set the ray (which clears out renderedPoints), then use the ray\n\t// (which may generate rendered points), then render the ray\n\tworld.registerSystem(RaycastSystem);\n\n\t// GameStateUpdateSystem resets the interactionModeOverridden flag every frame\n\t// It needs to be executed before mode selection and teleportaion\n\tworld.registerSystem(GameStateUpdateSystem);\n\tworld.registerSystem(SelectionWheelSystem);\n\tworld.registerSystem(IndicatorRingSystem);\n\tworld.registerSystem(SnapTurnSystem);\n\tworld.registerSystem(TeleportationSystem);\n\tworld.registerSystem(HandNUXSystem);\n\tworld.registerSystem(SeedboxHandContextualNUXSystem);\n\tworld.registerSystem(CameraHandContextualNUXSystem);\n\tworld.registerSystem(JoystickMovementSystem);\n\tif (ENABLE_HAND_POSER) {\n\t\t// hand poser and keyboard movement are using the same keys, enable only one\n\t\tworld.registerSystem(HandPoseExtractionSystem);\n\t}\n\n\tworld.registerSystem(GazeFollowSystem);\n\tworld.registerSystem(ObjectFollowSystem);\n\tworld.registerSystem(NUXCreationSystem);\n\tworld.registerSystem(SettingsCreationSystem);\n\n\tworld.registerSystem(SettingsSystem);\n\tworld.registerSystem(ControlsPanelSystem);\n\n\t// plant picking system executes before planting system as it controls the\n\t// entry and exit of planting mode\n\tworld.registerSystem(ScreenshotCameraSystem);\n\tworld.registerSystem(PhotoSystem);\n\tworld.registerSystem(PhotoAutoDeleteSystem);\n\tworld.registerSystem(PlantPickingSystem);\n\tworld.registerSystem(SeedboxFocusDetectionSystem);\n\tworld.registerSystem(SeedboxSystem);\n\tworld.registerSystem(PlantingSystem);\n\tworld.registerSystem(PlantingArrowSystem);\n\tworld.registerSystem(SeedAnimationSystem);\n\tworld.registerSystem(PlantGrowingSystem);\n\tworld.registerSystem(PlantShrinkingSystem);\n\tworld.registerSystem(PlantColliderSystem);\n\tworld.registerSystem(SaveControllerSystem);\n\tworld.registerSystem(RayDrawingSystem);\n\tworld.registerSystem(LocalSaveDataSystem);\n\tworld.registerSystem(WaterFaunaCreationSystem);\n\tworld.registerSystem(WaterFaunaMovementSystem);\n\tworld.registerSystem(AerialFaunaCreationSystem);\n\tworld.registerSystem(AerialFaunaMovementSystem);\n\tworld.registerSystem(FaunaAnimationSystem);\n\tworld.registerSystem(FaunaCreationSystem);\n\tworld.registerSystem(MovableFaunaSystem);\n\tworld.registerSystem(FaunaMovementBoundSamplerSystem);\n\tworld.registerSystem(StationaryFaunaSystem);\n\tworld.registerSystem(MorphTargetAnimationSystem);\n\tworld.registerSystem(PerformanceTestSystem);\n\tworld.registerSystem(LocomotionVignetteSystem);\n\tif (ENABLE_HAND_POSER) {\n\t\tworld.registerSystem(PropsCalibrationSystem);\n\t}\n\t// add this near the end so it can properly collect removed instances\n\tworld.registerSystem(MeshInstancingSystem);\n};\n\n/**\n * Systems that should only be initialized after the player is ready to move\n * (e.g. programs and materials compiled) go here.\n * Audio, notably, goes here.\n * @param {World} world\n */\nexport const registerSystemsAfterReady = (world) => {\n\t// needs to be registered after first person mouselook\n\t// so that the pointerlock component is created.\n\n\tworld.registerSystem(AudioSystem);\n\n\tworld.registerSystem(AmbientSoundCreationSystem);\n\tworld.registerSystem(MusicSystem);\n\tworld.registerSystem(PlaylistAudioSystem);\n\n\t// NUX system needs to be after gaze follow system until the xrCamera position is no longer\n\t// behind a frame, otherwise the NUX won't 'snap' to the camera properly upon entering XR.\n\tworld.registerSystem(NUXSystem);\n\n\tworld.registerSystem(SeedboxChangePageTooltipSystem);\n\tworld.registerSystem(CameraPhotoGrabTooltipSystem);\n\n\tif (DEBUG_CONSTANTS.ENABLE_UI_PREVIEW_SYSTEM) {\n\t\tworld.registerSystem(UIPanelPreviewSystem);\n\t}\n};\n\n'ProjectFlowerbed/src/js/systems/assets/AssetLoadingSystem.js'\n:/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport * as THREE from 'three';\nimport { AssetDatabaseComponent } from '../../components/AssetDatabaseComponent';\nimport { AssetReplacementSystem } from './AssetReplacementSystem';\nimport { AssetURLs } from '@config/AssetURLs';\nimport { AudioDatabase } from '../../lib/databases/AudioDatabase';\nimport { DEBUG_CONSTANTS } from '../../Constants';\nimport { LoadingScreenComponent } from '../../components/LoadingScreenComponent';\nimport { MeshDatabase } from '../../lib/databases/MeshDatabase';\nimport { MeshPreviewSystem } from '../mesh/MeshPreviewSystem';\nimport { System } from 'ecsy';\nimport { THREEGlobalComponent } from '../../components/THREEGlobalComponent';\nimport { getOnlyEntity } from '../../utils/entityUtils';\nimport { registerSystemsAfterLoad } from '../../ECSYConfig';\n\nconst kMaxMeshes = 568;\n\nexport class AssetLoadingSystem extends System {\n\tinit() {\n\t\tthis.hasStartedLoadingAssets = false;\n\t}\n\n\t/**\n\t * Called once when the system is registered to load all the models, finishing setup for\n\t * other systems when all the models are loaded.\n\t * Currently only loads GLTFs, but will be expanded to load other assets too.\n\t *\n\t * This is not called in init, because it relies upon the existence of components that may\n\t * not have been created in time for init()\n\t */\n\t_loadAssets() {\n\t\tconst gameManager = getOnlyEntity(this.queries.gameManager);\n\t\tconst threeConstants = gameManager.getComponent(THREEGlobalComponent);\n\n\t\tif (!getOnlyEntity(this.queries.loadingScreen, false)) {\n\t\t\tconst loadingScreenEntity = this.world.createEntity();\n\t\t\tloadingScreenEntity.addComponent(LoadingScreenComponent, {\n\t\t\t\ttotalMeshes: kMaxMeshes,\n\t\t\t});\n\t\t}\n\n\t\tthis.loadingManager = new THREE.LoadingManager(\n\t\t\t() => {},\n\t\t\t(_url, loaded, total) => {\n\t\t\t\tconst loadingScreen = getOnlyEntity(\n\t\t\t\t\tthis.queries.loadingScreen,\n\t\t\t\t).getMutableComponent(LoadingScreenComponent);\n\t\t\t\tloadingScreen.totalMeshes = Math.max(total, kMaxMeshes);\n\t\t\t\tloadingScreen.loadedMeshes = loaded;\n\t\t\t},\n\t\t);\n\n\t\t// create the asset database entity, and load all of the pieces\n\t\tconst assetDatabaseEntity = this.world.createEntity();\n\t\tconst meshDatabase = new MeshDatabase(\n\t\t\tthreeConstants.renderer,\n\t\t\tthis.loadingManager,\n\t\t);\n\n\t\tassetDatabaseEntity.addComponent(AssetDatabaseComponent, {\n\t\t\tmeshes: meshDatabase,\n\t\t\taudio: new AudioDatabase(),\n\t\t});\n\n\t\tconst assetDatabaseComponent = assetDatabaseEntity.getMutableComponent(\n\t\t\tAssetDatabaseComponent,\n\t\t);\n\n\t\tthis.hasStartedLoadingAssets = true;\n\n\t\t// check if the server is actually running\n\t\tlet shouldUseLocalhostServer = false;\n\t\tconst performLoad = async () => {\n\t\t\tconst promises = [];\n\t\t\tpromises.push(\n\t\t\t\tassetDatabaseComponent.loadAllMeshes(shouldUseLocalhostServer),\n\t\t\t);\n\t\t\tpromises.push(assetDatabaseComponent.loadAllAudio());\n\n\t\t\tawait Promise.all(promises);\n\t\t\tthis._onLoad();\n\n\t\t\tif (shouldUseLocalhostServer) {\n\t\t\t\tthis.world.registerSystem(MeshPreviewSystem);\n\t\t\t}\n\t\t};\n\t\tif (!DEBUG_CONSTANTS.ENABLE_LOCALHOST_ASSETS) {\n\t\t\tperformLoad();\n\t\t\treturn;\n\t\t}\n\n\t\t// 1 second timeout for the localhost server\n\t\tconst controller = new AbortController();\n\t\tconst timeoutId = setTimeout(() => controller.abort(), 1000);\n\t\tfetch('http://localhost:8080/', { signal: controller.signal })\n\t\t\t.then((_response) => {\n\t\t\t\t// as long as we get a response, even if it's 404, we use the localhost server.\n\t\t\t\tshouldUseLocalhostServer = true;\n\n\t\t\t\t// make sure we can look for linked models on the localhost server too.\n\t\t\t\t// unshift so that we look for models on localhost before going for the pre-linked assets.\n\t\t\t\tAssetURLs.ADDITIONAL_MESH_DIRS.unshift('http://localhost:8080/');\n\n\t\t\t\tclearTimeout(timeoutId);\n\t\t\t})\n\t\t\t.catch((_e) => {\n\t\t\t\t// no-op\n\t\t\t})\n\t\t\t.finally(() => {\n\t\t\t\tperformLoad();\n\t\t\t});\n\t}\n\n\t_onLoad() {\n\t\tthis.world.registerSystem(AssetReplacementSystem, { priority: -10 });\n\t\tregisterSystemsAfterLoad(this.world);\n\n\t\tconst loadingScreen = getOnlyEntity(\n\t\t\tthis.queries.loadingScreen,\n\t\t).getMutableComponent(LoadingScreenComponent);\n\t\tloadingScreen.isDoneLoading = true;\n\t}\n\n\texecute() {\n\t\tif (!this.hasStartedLoadingAssets) {\n\t\t\tthis._loadAssets();\n\t\t}\n\t}\n}\n\nAssetLoadingSystem.queries = {\n\tgameManager: {\n\t\tcomponents: [THREEGlobalComponent],\n\t},\n\tloadingScreen: {\n\t\tcomponents: [LoadingScreenComponent],\n\t},\n};\n\n",
        "called_code_segment_file_1": "const assetDatabaseEntity = this.world.createEntity();\nconst meshDatabase = new MeshDatabase(\n  threeConstants.renderer,\n  this.loadingManager,\n);\n\nassetDatabaseEntity.addComponent(AssetDatabaseComponent, {\n  meshes: meshDatabase,\n  audio: new AudioDatabase(),\n});\n\nconst assetDatabaseComponent = assetDatabaseEntity.getMutableComponent(\n  AssetDatabaseComponent,\n);",
        "invoking_code_segment_file_2": "const assetDatabaseComponent = assetDatabaseEntity.getMutableComponent(\n  AssetDatabaseComponent,\n);\n\nthis.hasStartedLoadingAssets = true;\n\nconst performLoad = async () => {\n  const promises = [];\n  promises.push(\n    assetDatabaseComponent.loadAllMeshes(shouldUseLocalhostServer),\n  );\n  promises.push(assetDatabaseComponent.loadAllAudio());\n\n  await Promise.all(promises);\n  this._onLoad();\n\n  if (shouldUseLocalhostServer) {\n    this.world.registerSystem(MeshPreviewSystem);\n  }\n};",
        "invoking_code_segment_file_3": "const assetDatabaseComponent = assetDatabaseEntity.getMutableComponent(\n  AssetDatabaseComponent,\n);\n\nconst promises = [];\npromises.push(\n  assetDatabaseComponent.loadAllMeshes(shouldUseLocalhostServer),\n);\npromises.push(assetDatabaseComponent.loadAllAudio());\n\nawait Promise.all(promises);\nthis._onLoad();",
        "new_file_code_segment": "export const loadAdditionalAssets = async (assetDatabaseComponent) => {\n  const additionalPromises = [];\n  additionalPromises.push(assetDatabaseComponent.loadAdditionalMeshes());\n  additionalPromises.push(assetDatabaseComponent.loadAdditionalAudio());\n  await Promise.all(additionalPromises);\n};\n\nexport const initializeAdditionalFeatures = () => {\n  // Additional initialization code for new features\n};",
        "feature_description": "Add support for loading additional assets and initializing new features.",
        "detailed_feature_description": "The new feature involves extending the asset loading process to include additional meshes and audio files. A new function, loadAdditionalAssets, is created in #file 4 to handle this. This function is then invoked in #file 1 after the initial asset loading is complete. Additionally, a new initialization function, initializeAdditionalFeatures, is provided in #file 4 to set up any new features that depend on these additional assets. This function is called in #file 1 to ensure all new features are properly initialized.",
        "modified_complete_code": {
            "file_1": "const assetDatabaseEntity = this.world.createEntity();\nconst meshDatabase = new MeshDatabase(\n  threeConstants.renderer,\n  this.loadingManager,\n);\n\nassetDatabaseEntity.addComponent(AssetDatabaseComponent, {\n  meshes: meshDatabase,\n  audio: new AudioDatabase(),\n});\n\nconst assetDatabaseComponent = assetDatabaseEntity.getMutableComponent(\n  AssetDatabaseComponent,\n);\n\n#Modify\nimport { loadAdditionalAssets, initializeAdditionalFeatures } from './file4';\n\nthis.hasStartedLoadingAssets = true;\n\nconst performLoad = async () => {\n  const promises = [];\n  promises.push(\n    assetDatabaseComponent.loadAllMeshes(shouldUseLocalhostServer),\n  );\n  promises.push(assetDatabaseComponent.loadAllAudio());\n\n  await Promise.all(promises);\n  this._onLoad();\n\n  if (shouldUseLocalhostServer) {\n    this.world.registerSystem(MeshPreviewSystem);\n  }\n\n  #New\n  await loadAdditionalAssets(assetDatabaseComponent);\n  initializeAdditionalFeatures();\n};",
            "file_2": "const assetDatabaseComponent = assetDatabaseEntity.getMutableComponent(\n  AssetDatabaseComponent,\n);\n\nthis.hasStartedLoadingAssets = true;\n\nconst performLoad = async () => {\n  const promises = [];\n  promises.push(\n    assetDatabaseComponent.loadAllMeshes(shouldUseLocalhostServer),\n  );\n  promises.push(assetDatabaseComponent.loadAllAudio());\n\n  await Promise.all(promises);\n  this._onLoad();\n\n  if (shouldUseLocalhostServer) {\n    this.world.registerSystem(MeshPreviewSystem);\n  }\n\n  #New\n  await loadAdditionalAssets(assetDatabaseComponent);\n  initializeAdditionalFeatures();\n};",
            "file_3": "const assetDatabaseComponent = assetDatabaseEntity.getMutableComponent(\n  AssetDatabaseComponent,\n);\n\nconst promises = [];\npromises.push(\n  assetDatabaseComponent.loadAllMeshes(shouldUseLocalhostServer),\n);\npromises.push(assetDatabaseComponent.loadAllAudio());\n\nawait Promise.all(promises);\nthis._onLoad();\n\n#New\nawait loadAdditionalAssets(assetDatabaseComponent);\ninitializeAdditionalFeatures();",
            "file_4": "export const loadAdditionalAssets = async (assetDatabaseComponent) => {\n  const additionalPromises = [];\n  additionalPromises.push(assetDatabaseComponent.loadAdditionalMeshes());\n  additionalPromises.push(assetDatabaseComponent.loadAdditionalAudio());\n  await Promise.all(additionalPromises);\n};\n\nexport const initializeAdditionalFeatures = () => {\n  // Additional initialization code for new features\n};"
        }
    },
    {
        "repo": "searchjs",
        "content": "'searchjs/src/option.js'\n:function _getSingleOpt(first,override,fallback) {\n\tlet ret;\n\tif (first !== undefined) {\n\t\tret = first;\n\t} else if (override !== undefined) {\n\t\tret = override;\n\t} else {\n\t\tret = fallback;\n\t}\n\treturn ret;\n}\n\nexport function _getOptions(search, _defaults) {\n\tconst options = {};\n\n\tsearch = search || {};\n\n\t// did we have a negator?\n\t//options.negator = search._not ? true : _defaults.negator || false;\n\toptions.negator = _getSingleOpt(search._not,_defaults.negator,false);\n\t// do we join via AND or OR\n\t//options.joinAnd = search._join && search._join === \"OR\" ? false : _defaults.join || true;\n\toptions.joinAnd = _getSingleOpt(search._join, _defaults.join, \"AND\") !== \"OR\";\n\n\t// did we have text, word, regex, start or end search?\n\toptions.text = _getSingleOpt(search._text,_defaults.text,false);\n\toptions.word = _getSingleOpt(search._word,_defaults.word,false);\n\toptions.regexp = _getSingleOpt(search._regexp, _defaults.regexp, false)\n\toptions.start = _getSingleOpt(search._start,_defaults.start,false);\n\toptions.end = _getSingleOpt(search._end,_defaults.end,false);\n\n\toptions.separator = search._separator || _defaults.separator || '.';\n\toptions.propertySearch = _getSingleOpt(search._propertySearch,_defaults.propertySearch,false);\n\toptions.propertySearchDepth = _getSingleOpt(search._propertySearchDepth,_defaults.propertySearchDepth,-1);\n\n\n\treturn options;\n}\n\n'searchjs/src/searchjs.js'\n:import {toType, deepField} from './util';\nimport {_getOptions} from './option';\n\nlet _defaults = {};\n\n// Allows to overwrite the global default values\nexport function setDefaults(options) {\n\tfor (const key in options) {\n\t\t_defaults[key] = options[key];\n\t}\n}\n\nexport function resetDefaults() {\n\t_defaults = {};\n}\n\nexport function singleMatch(field,s,text,word,regexp,start,end) {\n\tlet oneMatch = false, t, re, j, from, to;\n\t// for numbers, exact match; for strings, ignore-case match; for anything else, no match\n\tt = typeof(field);\n\tif (field === null) {\n\t\toneMatch = s === null;\n\t} else if (field === undefined) {\n\t\toneMatch = s === undefined;\n\t} else if (t === \"boolean\") {\n\t\toneMatch = s === field;\n\t} else if (t === \"number\" || field instanceof Date) {\n\t\tif(s !== null && s !== undefined && toType(s) === \"object\") {\n\t\t\tif (s.from !== undefined || s.to !== undefined || s.gte !== undefined || s.lte !== undefined) {\n\t\t\t\tfrom = s.from || s.gte;\n\t\t\t\tto = s.to || s.lte;\n\t\t\t\toneMatch = (s.from !== undefined || s.gte !== undefined ? field >= from : true) &&\n\t\t\t\t\t(s.to !== undefined || s.lte !== undefined ? field <= to: true);\n\t\t\t} else if (s.gt !== undefined || s.lt !== undefined) {\n\t\t\t\toneMatch = (s.gt !== undefined ? field > s.gt : true) &&\n\t\t\t\t\t(s.lt !== undefined ? field < s.lt: true);\n\t\t\t}\n\t\t} else {\n\t\t\tif(field instanceof Date && s instanceof Date) {\n\t\t\t\toneMatch = field.getTime() === s.getTime();\n\t\t\t} else {\n\t\t\t\toneMatch = field === s;\n\t\t\t}\n\t\t}\n\t} else if (t === \"string\") {\n\t\tif (typeof(s) === \"string\") {\n\t\t\ts = s.toLowerCase();\n\t\t}\n\t\tfield = field.toLowerCase();\n\t\tif (text) {\n\t\t\toneMatch = field.indexOf(s) !== -1;\n\t\t} else if (regexp) {\n\t\t\t// strip the first slash and last slash\n\t\t\tre = regexParser(s)\n\t\t\toneMatch = field && field.match(re) !== null;\n\t\t} else if (word) {\n\t\t\tre = new RegExp(\"(\\\\s|^)\"+s+\"(?=\\\\s|$)\",\"i\");\n\t\t\toneMatch = field && field.match(re) !== null;\n\t\t} else if (start) {\n\t\t\tre = new RegExp(\"^\"+s, \"i\");\n\t\t\toneMatch = field && field.match(re) !== null;\n\t\t} else if (end) {\n\t\t\tre = new RegExp(s+\"$\" , \"i\");\n\t\t\toneMatch = field && field.match(re) !== null;\n\t\t} else if (s !== null && s !== undefined && toType(s) === \"object\") {\n\t\t\t\tif (s.from !== undefined || s.to !== undefined || s.gte !== undefined || s.lte !== undefined) {\n\t\t\t\t\tfrom = s.from || s.gte;\n\t\t\t\t\tto = s.to || s.lte;\n\t\t\t\t\toneMatch = (s.from !== undefined || s.gte !== undefined ? field >= from : true) &&\n\t\t\t\t\t\t(s.to !== undefined || s.lte !== undefined ? field <= to: true);\n\t\t\t\t} else if (s.gt !== undefined || s.lt !== undefined) {\n\t\t\t\t\toneMatch = (s.gt !== undefined ? field > s.gt : true) &&\n\t\t\t\t\t\t(s.lt !== undefined ? field < s.lt: true);\n\t\t\t\t}\n\t\t} else {\n\t\t\toneMatch = s === field;\n\t\t}\n\t} else if (field.length !== undefined) {\n\t  // array, so go through each\n\t  for (j=0;j<field.length;j++) {\n\t\toneMatch = singleMatch(field[j],s,text,word,regexp,start,end);\n\tif (oneMatch) {\n\t  break;\n\t}\n\t  }\n\t} else if (t === \"object\") {\n\t\tif(typeof s === \"object\") {\n\t\t\t// s (search) is a nested primitive\n\t\t\toneMatch = matchObject(field,s);\n\t\t} else {\n\t\t  \toneMatch = field[s] !== undefined;\n\t\t}\n\t}\n\treturn(oneMatch);\n}\n\nexport function matchArray(ary,search) {\n\tlet matched = false, i, ret = [], options = _getOptions(search, _defaults);\n\tif (ary && ary.length > 0) {\n\t\tfor (i=0;i<ary.length;i++) {\n\t\t\tmatched = _matchObj(ary[i],search,options);\n\t\t\tif (matched) {\n\t\t\t\tret.push(ary[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn(ret);\n}\n\nexport function matchObject(obj,search) {\n\tconst options = _getOptions(search, _defaults);\n\treturn _matchObj(obj,search,options);\n}\n\nfunction _matchObj(obj,search,options) {\n\tlet i, j, matched, oneMatch, ary, searchTermParts;\n\tsearch = search || {};\n\n\t// if joinAnd, then matched=true until we have a single non-match; if !joinAnd, then matched=false until we have a single match\n\tmatched = !!options.joinAnd;\n\n\t// are we a primitive or a composite?\n\tif (search.terms) {\n\t\tfor (j=0; j<search.terms.length; j++) {\n\t\t\toneMatch = matchObject(obj,search.terms[j]);\n\t\t\tif (options.negator) {\n\t\t\t\toneMatch = !oneMatch;\n\t\t\t}\n\t\t\t// if AND, a single match failure makes all fail, and we break\n\t\t\t// if OR, a single match success makes all succeed, and we break\n\t\t\tif (options.joinAnd && !oneMatch) {\n\t\t\t\tmatched = false;\n\t\t\t\tbreak;\n\t\t\t} else if (!options.joinAnd && oneMatch) {\n\t\t\t\tmatched = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// match to the search field\n\t\tfor(i in search) {\n\t\t\tif (search.hasOwnProperty(i) && i.indexOf(\"_\") !== 0) {\n\t  \t\t\t// match each one, if search[i] is an array - just concat to be safe\n\t\t\t\tsearchTermParts = i.split(options.separator);\n\t\t\t  \tary = [].concat(search[i]);\n\t\t\t  \tfor (j=0;j<ary.length;j++) {\n\t\t\t\t\toneMatch = singleMatch(deepField(obj,searchTermParts,options.propertySearch,options.propertySearchDepth),ary[j],options.text,options.word,options.regexp,options.start,options.end);\n\t\t\t\t\tif (oneMatch) {\n\t\t  \t\t\t\tbreak;\n\t\t\t\t\t}\n\t  \t\t\t}\n\t\t\t\t// negator\n\t\t\t\tif (options.negator) {\n\t\t\t\t\toneMatch = !oneMatch;\n\t\t\t\t}\n\n\t\t\t\t// if AND, a single match failure makes all fail, and we break\n\t\t\t\t// if OR, a single match success makes all succeed, and we break\n\t\t\t\tif (options.joinAnd && !oneMatch) {\n\t\t\t\t\tmatched = false;\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (!options.joinAnd && oneMatch) {\n\t\t\t\t\tmatched = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn(matched);\n}\n\nfunction regexParser(input) {\n\t// Parse input\n\tvar m = input.match(/(\\/?)(.+)\\1([a-z]*)/i);\n\n\t// Invalid flags\n\tif (m[3] && !/^(?!.*?(.).*?\\1)[gmixXsuUAJ]+$/.test(m[3])) {\n\t\t\treturn RegExp(input);\n\t}\n\n\t// Create the regular expression\n\treturn new RegExp(m[2], m[3]);\n\n}\n\n'searchjs/test/test.js'\n:/*jslint node:true, nomen:true */\n/*global it, describe, before, after */\nimport {matchObject, matchArray, setDefaults, resetDefaults} from \"../src/searchjs\";\nconst should = require('should');\nlet data, searches;\n\ndata = [\n\t{name:\"Alice\",fullname:\"I am Alice Shiller\",age:25,birthday: new Date(1992, 1, 28),email: \"alice@searchjs.com\",city:{\"Montreal\":\"first\",\"Toronto\":\"second\"}, other: { personal: { birthPlace: \"Vancouver\" }, emptyArray2: [] }, emptyArray1: [] },\n\t{name:\"Brian\",age:30,birthday: new Date(1987, 10, 16),email: \"brian@searchjs.com\",male:true,empty:\"hello\"},\n\t{name:\"Carrie\",age:30,birthday: new Date(1987, 5, 9), email: \"carrie@searchjs.com\",city:{\"Montreal\":true,\"New York\":false}},\n\t{name:\"David\",age:35,birthday: new Date(1982, 9, 17), email: \"david@searchjs.com\",male:true, personal: {cars: [{ brand: 'Porsche', build: 2016}, {brand: 'BMW', build: 2014}]}},\n\t{name:\"Alice\",age:30,birthday: new Date(1987, 6, 10), email: [\"alice@searchjs.com\",\"alice@gmail.com\"], cars: [{automatic: true, manual: false, brand: 'BMW', build: 2015, cds: [{title:'Best Of 2015'}, {title:'Best Of 2016'}]}, {brand: 'Porsche', build: 2013}]},\n\t{name:\"Other\",id: 3,currentC: {cer: {id: 2}}},\n\t{name:\"John\", \"level1\":{\"level2\":{\"level3\":{\"level4\":{\"level5\":{\"level6\": 200}}}}}}\n];\nsearches = [\n\t// regexp\n\t{search: {name: \"/Car/\", \"_regexp\": true}, results:[2]},\n\t{search: {name: \"/car/i\", \"_regexp\": true}, results:[2]},\n\t{search: {name: \"/ali/i\", \"_regexp\": true}, results:[0,4]},\n\t{search: {name: \"/car/i\", \"_regexp\": true}, results:[2]},\n\t{search: {name: \"/(l|r)i/i\", \"_regexp\": true}, results:[0,1,2,4]},\n\t{search: {name: \"/^ri/i\", \"_regexp\": true}, results:[]},\n\n\t{search: {name:\"alice\"}, results:[0,4]},\n\t{search: {name:undefined}, results:[]},\n\t{search: {empty:undefined}, results:[0,2,3,4,5,6]} ,\n\t{search: {name:\"alic\"}, results:[]},\n\t{search: {name:\"alic\",_text:true}, results:[0,4]},\n\t{search: {name:\"alic\",_word:true}, results:[]},\n\t{search: {name:\"alice\",_word:true}, results:[0,4]},\n\t{search: {name:\"brian\"}, results:[1]},\n\t{search: {name:\"alice\",_not: true}, results:[1,2,3,5,6]},\n\t{search: {male:true}, results:[1,3]},\n\t{search: {age:30,male:true}, results:[1]},\n\t{search: {male:true,_not:true}, results:[0,2,4,5,6]},\n\t{search: {age:25}, results:[0]},\n\t{search: {age:30}, results:[1,2,4]},\n\t{search: {age:25, name: \"Alice\",email2:\"foo@foo.com\"},results: []},\n\t{search: {age:35, name: \"Alice\", _join: \"OR\"},results: [0,3,4]},\n\t{search: {age:35, name: \"Alice\", _not: true},results: [1,2,5,6]},\n\t{search: {terms: [{age:30,name:\"Brian\",_join:\"AND\"},{age:25}], _join:\"OR\"}, results:[0,1]},\n\t{search: {email: \"alice@searchjs.com\"},results: [0,4]},\n\t{search: {name: [\"Brian\",\"Carrie\"]},results: [1,2]},\n\t{search: {email: [\"alice@searchjs.com\",\"carrie@searchjs.com\"]},results: [0,2,4]},\n\t{search: {_not: true, name: [\"Brian\",\"Carrie\"]},results: [0,3,4,5,6]},\n\t{search: {_not:true, email: [\"alice@searchjs.com\",\"carrie@searchjs.com\"]},results: [1,3,5,6]},\n\t{search: {city:\"Montreal\"},results:[0,2]},\n\t{search: {\"city.New York\": false},results:[2]},\n\t{search: {_not:true,city:\"Montreal\"},results:[1,3,4,5,6]},\n\t// Number\n\t{search: {age:{from:30}},results:[1,2,3,4]},\n\t{search: {age:{gte:30}},results:[1,2,3,4]},\n\t{search: {age:{from:30,to:34}},results:[1,2,4]},\n\t{search: {age:{gte:30,lte:34}},results:[1,2,4]},\n\t{search: {age:{from:25,to:30}},results:[0,1,2,4]},\n\t{search: {age:{gte:25,lte:30}},results:[0,1,2,4]},\n\t{search: {age:{to:29}},results:[0]},\n\t{search: {age:{lte:29}},results:[0]},\n\t{search: {age:{gt:30}},results:[3]},\n\t{search: {age:{lt:30}},results:[0]},\n\t{search: {age:{gt:25,lt:35}},results:[1,2,4]},\n\t{search: {_not:true,age:{to:29}},results:[1,2,3,4,5,6]},\n\t{search: {_not:true,age:{from:30,to:34}},results:[0,3,5,6]},\n\t// Date\n\t{search: {birthday: new Date(1992, 1, 28)}, results:[0]},\n\t{search: {birthday:{from: new Date(1985, 9, 17)}},results:[0,1,2,4]},\n\t{search: {birthday:{gte:new Date(1982, 9, 17)}},results:[0,1,2,3,4]},\n\t{search: {birthday:{from:new Date(1981, 9, 17),to:new Date(1995, 1, 28)}},results:[0,1,2,3,4]},\n\t{search: {birthday:{gte:new Date(1982, 9, 17),lte:new Date(1992, 1, 28)}},results:[0,1,2,3,4]},\n\t{search: {birthday:{to:new Date(1987, 5, 7)}},results:[3]},\n\t{search: {birthday:{lte:new Date(1987, 5, 9)}},results:[2,3]},\n\t{search: {birthday:{gt:new Date(1987, 5, 9)}},results:[0,1,4]},\n\t{search: {birthday:{lt:new Date(1987, 5, 9)}},results:[3]},\n\t{search: {birthday:{gt:new Date(1982, 9, 17),lt:new Date(1992, 1, 28)}},results:[1,2,4]},\n\t{search: {_not:true,birthday:{to:new Date(1987, 5, 9)}},results:[0,1,4,5,6]},\n\t{search: {_not:true,birthday:{from:new Date(1987, 5, 9),to:new Date(1987, 10, 16)}},results:[0,3,5,6]},\n\t{search: {\"city.Montreal\":\"first\"},results:[0]},\n\t{search: {\"city.Montreal\":[\"first\",\"abc\"]},results:[0]},\n\t{search: {\"city:Montreal\":\"first\",_separator: ':'},results:[0]},\n\t{search: {\"city:Montreal\":[\"first\",\"abc\"],_separator: ':'},results:[0]},\n\t{search: {\"city.Montreal\":true},results:[2]},\n\t{search: {\"city.Montreal\":\"abc\"},results:[]},\n\t{search: {\"city.Montreal\":[\"abc\"]},results:[]},\n\t{search: {\"city.foo\":\"abc\"},results:[]},\n\t{search: {\"other.personal.birthPlace\":\"vancouver\"},results:[0]},\n\t{search: {\"other:personal:birthPlace\":\"vancouver\",_separator: ':'},results:[0]},\n\t{search: {\"cars.brand\":\"bmw\"},results:[4]},\n\t{search: {\"cars.automatic\": true},results:[4]},\n\t{search: {\"cars.manual\": false},results:[4]},\n\t{search: {\"cars.cds.title\":\"Best Of 2014\"},results:[]},\n\t{search: {\"cars.cds.title\":\"Best Of 2015\"},results:[4]},\n\t{search: {\"cars:cds:title\":\"Best Of 2015\",_separator: ':'},results:[4]},\n\t{search: {\"cars.cds.title\":\"Best Of 2016\"},results:[4]},\n\t{search: {\"currentC.cer.id\": [1, 2]},results: [5]},\n\t{search: {\"currentC.cer.id\": [2, 1]},results: [5]},\n\t{search: {\"Montreal\":\"first\", _propertySearch:true}, results:[0]},\n\t{search: {\"Montreal\":\"second\", _propertySearch:true}, results:[]},\n\t{search: {\"personal.cars.brand\":\"bmw\", _propertySearch:true}, results:[3]},\n\t{search: {\"brand\":\"bmw\", _propertySearch:true}, results:[3,4]},\n\t{search: {\"title\":\"Best Of 2015\", _propertySearch:true}, results:[4]},\n\t{search: {build:{from:2016}},results:[]},\n\t{search: {build:{from:2016}, _propertySearch:true},results:[3]},\n\t{search: {\"brand\":\"bmw\", _propertySearch:true, _propertySearchDepth: 2}, results:[4]},\n\t{search: {\"brand\":\"bmw\", _propertySearch:true, _propertySearchDepth: 3}, results:[3,4]},\n\t{search: {\"brand\":\"bmw\", _propertySearch:true, _propertySearchDepth: -1}, results:[3,4]},\n\t{search: {\"personal.brand\":\"bmw\", _propertySearch:true, _propertySearchDepth: 3},results:[3]},\n\t{search: {\"level1.level6\":200}, results:[]},\n\t{search: {\"level6\":200}, results:[]},\n\t{search: {\"level1.level6\":200, _propertySearch:true}, results:[6]},\n\t{search: {\"level2.level4.level6\":200, _propertySearch:true}, results:[6]},\n\t{search: {\"level4.level6\":200, _propertySearch:true}, results:[6]},\n\t{search: {\"level1.level2.level6\":200, _propertySearch:true}, results:[6]},\n\t{search: {\"level4.level6\":200, _propertySearch:true, _propertySearchDepth: 5}, results:[]},\n\t{search: {\"level4.level6\":200, _propertySearch:true, _propertySearchDepth: 6}, results:[6]},\n\t{search: {\"level3.level4.level6\":200, _propertySearch:true, _propertySearchDepth: 6}, results:[6]},\n\t{search: {\"level6\":{gte:100,lte:300}, _propertySearch:true},results:[6]},\n\t{search: {\"terms\":[{\"level6\":{gte:100}, _propertySearch:true}, {\"level1.level6\":{lte:300}, _propertySearch:true}]},results:[6]},\n\t{search: {name:\"bri\",_start:true}, results:[1]},\n\t{search: {name:\"n\",_end:true}, results:[1,6]},\n\t{search: {name:{gt:'d'}},results:[3,5,6]},\n\t{search: {name:{gt:'da'}},results:[3,5,6]},\n\t{search: {name:{gt:'db'}},results:[5,6]},\n\t{search: {name:{lt:'d'}},results:[0,1,2,4]},\n\t{search: {name:{lt:'cb'}},results:[0,1,2,4]},\n\t{search: {name:{from:'d',to:'e'}},results:[3]},\n\t{search: {name:{from:'br',to:'cb'}},results:[1,2]},\n\t{search: {name:{from:'bs',to:'cb'}},results:[2]},\n\n\t// nested objects matching\n\t{search: {\"personal.cars\": {\"brand\": \"bmw\", \"build\": 2016}}, results:[]},\n\t{search: {\"personal.cars\": {\"brand\": \"bmw\", \"build\": 2014}}, results:[3]},\n\t{search: {\"personal\": {\"cars\": {\"brand\": \"bmw\", \"build\": 2016}}}, results:[]},\n\t{search: {\"personal\": {\"cars\": {\"brand\": \"bmw\", \"build\": 2014}}}, results:[3]},\n\t// object property matching\n\t{search: {\"personal.cars\": \"brand\"}, results: [3]},\n\t{search: {\"personal.cars\": \"model\"}, results: []},\n];\n\n\ndescribe('searchjs', () => {\n\tdescribe('without defaults', () => {\n\t\tlet i, j, m, hash, arrayResults, entry;\n\t\t// we will go through each search\n\t\tfor (i=0;i<searches.length;i++) {\n\t\t\t// turn the results array into a hash\n\t\t\thash = {};\n\t\t\tarrayResults = [];\n\t\t\tentry = searches[i];\n\t\t\t// first indicate that none of the data should be a match unless we say it is\n\t\t\tfor (j=0; j<data.length;j++) {\n\t\t\t\thash[j] = false;\n\t\t\t}\n\t\t\t// identify those that we expect to be a match: mark the hash as true, and save the actual data entry to arrayResults\n\t\t\tfor (j=0; j<entry.results.length; j++) {\n\t\t\t\thash[entry.results[j]] = true;\n\t\t\t\tarrayResults.push(data[entry.results[j]]);\n\t\t\t}\n\t\t\t// first do the object search matches - search across all the objects, and expect the results to match only the ones we indicated in the hash\n\t\t\t(function(hash,arrayResults,entry){\n\t\t\t\tdescribe('for entry '+JSON.stringify(entry.search), function(){\n\t\t\t\t\tdescribe('matchObject', function(){\n\t\t\t\t\t\tfor (j=0; j<data.length;j++) {\n\t\t\t\t\t\t\t(function (d,h) {\n\t\t\t\t\t\t\t\tlet isNot = (h?\"\":\"NOT \");\n\t\t\t\t\t\t\t\tit('should '+isNot+\"match for data \"+JSON.stringify(d), function(){\n\t\t\t\t\t\t\t\t\tm = matchObject(d,entry.search);\n\t\t\t\t\t\t\t\t\t// it should be a match or not\n\t\t\t\t\t\t\t\t\tm.should.eql(h);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}(data[j],hash[j]));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tdescribe('matchArray', function(){\n\t\t\t\t\t\tit('should match only '+JSON.stringify(arrayResults), function(){\n\t\t\t\t\t\t\t// next do the array matches - match against the entire data set, and expect the results to match our results\n\t\t\t\t\t\t\tm = matchArray(data,entry.search);\n\t\t\t\t\t\t\t// check the results - we need to find a way to match the entries of two arrays of objects\n\t\t\t\t\t\t\t//  easiest is probably to just json-ify them and compare the strings\n\t\t\t\t\t\t\tm.should.eql(arrayResults);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}(hash,arrayResults,entry));\n\t\t}\n\t});\n\n\t// defaults has many more permutations, so we are structuring it manually\n\tdescribe('with defaults', () => {\n\t\tdescribe('negator', () => {\n\t\t\tlet nonot, yesnot;\n\t\t\tbefore(function(){\n\t\t\t\tyesnot = matchArray(data,{name:\"alice\",_not:true});\n\t\t\t\tnonot = matchArray(data,{name:\"alice\",_not:false});\n\t\t\t\tsetDefaults({negator:true});\n\t\t\t});\n\t\t\tafter(function () {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match NOT without explicit _not', function(){\n\t\t\t\tmatchArray(data,{name:\"alice\"}).should.eql(yesnot);\n\t\t\t});\n\t\t\tit('should match true with explicit override', function(){\n\t\t\t\tmatchArray(data,{name:\"alice\",_not:false}).should.eql(nonot);\n\t\t\t});\n\t\t});\n\t\tdescribe('join', () => {\n\t\t\tlet joinand, joinor;\n\t\t\tbefore(function(){\n\t\t\t\tjoinand = matchArray(data,{age:25, name: \"Alice\"});\n\t\t\t\tjoinor = matchArray(data,{age:25, name: \"Alice\",_join:\"OR\"});\n\t\t\t\tsetDefaults({join:\"OR\"});\n\t\t\t});\n\t\t\tafter(() => {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match OR without explicit OR', function(){\n\t\t\t\tmatchArray(data,{name:\"alice\",\"age\":25}).should.eql(joinor);\n\t\t\t});\n\t\t\tit('should match AND with explicit override', function(){\n\t\t\t\tmatchArray(data,{name:\"alice\",\"age\":25,_join:\"AND\"}).should.eql(joinand);\n\t\t\t});\n\t\t});\n\t\tdescribe('text', () => {\n\t\t\tlet yestext, notext;\n\t\t\tbefore(function(){\n\t\t\t\tyestext = matchArray(data,{name:\"alic\",_text:true});\n\t\t\t\tnotext = matchArray(data,{name:\"alic\"});\n\t\t\t\tsetDefaults({text:true});\n\t\t\t});\n\t\t\tafter(function () {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match text without explicit _text', function(){\n\t\t\t\tmatchArray(data,{name:\"alic\"}).should.eql(yestext);\n\t\t\t});\n\t\t\tit('should match not text with explicit override', function(){\n\t\t\t\tmatchArray(data,{name:\"alic\",_text:false}).should.eql(notext);\n\t\t\t});\n\t\t});\n\t\tdescribe('word', () => {\n\t\t\tlet yesword, noword;\n\t\t\tbefore(function(){\n\t\t\t\tyesword = matchArray(data,{fullname:\"alice\",_word:true});\n\t\t\t\tnoword = matchArray(data,{fullname:\"alice\"});\n\t\t\t\tsetDefaults({word:true});\n\t\t\t});\n\t\t\tafter(function () {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match text without explicit _text', function(){\n\t\t\t\tmatchArray(data,{fullname:\"alice\"}).should.eql(yesword);\n\t\t\t});\n\t\t\tit('should match not text with explicit override', function(){\n\t\t\t\tmatchArray(data,{fullname:\"alice\",_word:false}).should.eql(noword);\n\t\t\t});\n\t\t});\n\t\tdescribe('start', () => {\n\t\t\tlet yesword, noword;\n\t\t\tbefore(function(){\n\t\t\t\tyesword = matchArray(data,{fullname:\"car\",_start:true});\n\t\t\t\tnoword = matchArray(data,{fullname:\"cari\"});\n\t\t\t\tsetDefaults({start:true});\n\t\t\t});\n\t\t\tafter(function () {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match begin text without explicit _start', function(){\n\t\t\t\tmatchArray(data,{fullname:\"car\"}).should.eql(yesword);\n\t\t\t});\n\t\t\tit('should match begin text with explicit _start true', function(){\n\t\t\t\tmatchArray(data,{fullname:\"car\",_start:true}).should.eql(yesword);\n\t\t\t});\n\t\t\tit('should not match text with explicit _start false', function(){\n\t\t\t\tmatchArray(data,{fullname:\"alice\",_start:false}).should.eql(noword);\n\t\t\t});\n\t\t\tit('should not match text _start true but not beginning of word', function(){\n\t\t\t\tmatchArray(data,{fullname:\"lice\",_start:true}).should.eql(noword);\n\t\t\t});\n\t\t});\n\t\tdescribe('end', () => {\n\t\t\tlet yesword, noword;\n\t\t\tbefore(function(){\n\t\t\t\tyesword = matchArray(data,{fullname:\"rrie\",_end:true});\n\t\t\t\tnoword = matchArray(data,{fullname:\"arie\"});\n\t\t\t\tsetDefaults({end:true});\n\t\t\t});\n\t\t\tafter(function () {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match end text without explicit _end', function(){\n\t\t\t\tmatchArray(data,{fullname:\"rrie\"}).should.eql(yesword);\n\t\t\t});\n\t\t\tit('should match end text with explicit _end true', function(){\n\t\t\t\tmatchArray(data,{fullname:\"rrie\", _end:true}).should.eql(yesword);\n\t\t\t});\n\t\t\tit('should not match text with explicit _end false', function(){\n\t\t\t\tmatchArray(data,{fullname:\"rrie\",_end:false}).should.eql(noword);\n\t\t\t});\n\t\t\tit('should not match text _end true but not end of word', function(){\n\t\t\t\tmatchArray(data,{fullname:\"rri\",_end:true}).should.eql(noword);\n\t\t\t});\n\t\t});\n\t\tdescribe('separator', () => {\n\t\t\tlet matches;\n\t\t\tbefore(function(){\n\t\t\t\tmatches = matchArray(data,{\"city.Montreal\":\"first\"});\n\t\t\t\tsetDefaults({separator:\":\"});\n\t\t\t});\n\t\t\tafter(function () {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match field without explicit separator', function(){\n\t\t\t\tmatchArray(data,{\"city:Montreal\":\"first\"}).should.eql(matches);\n\t\t\t});\n\t\t\tit('should match field with explicit separator override', function(){\n\t\t\t\tmatchArray(data,{\"city.Montreal\":\"first\",_separator:\".\"}).should.eql(matches);\n\t\t\t});\n\t\t});\n\t\tdescribe('propertySearch', () => {\n\t\t\tlet yesdeep, nodeep;\n\t\t\tbefore(function(){\n\t\t\t\tyesdeep = matchArray(data,{\"Montreal\":\"first\",_propertySearch:true});\n\t\t\t\tnodeep = matchArray(data,{\"Montreal\":\"first\"});\n\t\t\t\tsetDefaults({propertySearch:true});\n\t\t\t});\n\t\t\tafter(function () {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match field without explicit _propertySearch', function(){\n\t\t\t\tmatchArray(data,{\"Montreal\":\"first\"}).should.eql(yesdeep);\n\t\t\t});\n\t\t\tit('should not match field with explicit _propertySearch override', function(){\n\t\t\t\tmatchArray(data,{\"Montreal\":\"first\",_propertySearch:false}).should.eql(nodeep);\n\t\t\t});\n\t\t});\n\t\tdescribe('propertySearchDepth', () => {\n\t\t\tlet yesdepth, nodepth;\n\t\t\tbefore(function(){\n\t\t\t\tyesdepth = matchArray(data,{\"brand\":\"bmw\",_propertySearch:true,_propertySearchDepth: 2});\n\t\t\t\tnodepth = matchArray(data,{\"brand\":\"bmw\",_propertySearch:true});\n\t\t\t\tsetDefaults({propertySearchDepth:2});\n\t\t\t});\n\t\t\tafter(function () {\n\t\t\t\tresetDefaults();\n\t\t\t});\n\t\t\tit('should match correct fields without explicit _propertySearchDepth', function(){\n\t\t\t\tmatchArray(data,{\"brand\":\"bmw\",_propertySearch:true}).should.eql(yesdepth);\n\t\t\t});\n\t\t\tit('should not match field with explicit _propertySearch override', function(){\n\t\t\t\tmatchArray(data,{\"brand\":\"bmw\",_propertySearch:true,_propertySearchDepth:-1}).should.eql(nodepth);\n\t\t\t});\n\t\t});\n\t});\n});\n\n",
        "called_code_segment_file_1": "function _getOptions(search, _defaults) {\n  const options = {};\n  options.negator = _getSingleOpt(search._not, _defaults.negator, false);\n  options.joinAnd = _getSingleOpt(search._join, _defaults.join, \"AND\") !== \"OR\";\n  options.text = _getSingleOpt(search._text, _defaults.text, false);\n  options.word = _getSingleOpt(search._word, _defaults.word, false);\n  options.regexp = _getSingleOpt(search._regexp, _defaults.regexp, false);\n  options.start = _getSingleOpt(search._start, _defaults.start, false);\n  options.end = _getSingleOpt(search._end, _defaults.end, false);\n  options.separator = search._separator || _defaults.separator || '.';\n  options.propertySearch = _getSingleOpt(search._propertySearch, _defaults.propertySearch, false);\n  options.propertySearchDepth = _getSingleOpt(search._propertySearchDepth, _defaults.propertySearchDepth, -1);\n  return options;\n}",
        "invoking_code_segment_file_2": "export function matchObject(obj, search) {\n  const options = _getOptions(search, _defaults);\n  return _matchObj(obj, search, options);\n}",
        "invoking_code_segment_file_3": "for (i = 0; i < searches.length; i++) {\n  const entry = searches[i];\n  describe('for entry ' + JSON.stringify(entry.search), function () {\n    describe('matchObject', function () {\n      for (j = 0; j < data.length; j++) {\n        (function (d, h) {\n          let isNot = (h ? \"\" : \"NOT \");\n          it('should ' + isNot + \"match for data \" + JSON.stringify(d), function () {\n            m = matchObject(d, entry.search);\n            m.should.eql(h);\n          });\n        }(data[j], hash[j]));\n      }\n    });\n  });\n}",
        "new_file_code_segment": "export function _getAdvancedOptions(search, _defaults) {\n  const options = _getOptions(search, _defaults);\n  options.caseSensitive = _getSingleOpt(search._caseSensitive, _defaults.caseSensitive, false);\n  return options;\n}",
        "feature_description": "Add case sensitivity option for search operations.",
        "detailed_feature_description": "The new feature introduces a case sensitivity option for search operations. This option allows users to specify whether the search should be case-sensitive or not. The new functionality is implemented in a new file (#file 4) and is integrated into the existing code by modifying the _getOptions function in #file 1 to invoke the new _getAdvancedOptions function from #file 4. The matchObject function in #file 2 is updated to use the new options, and the test cases in #file 3 are adjusted to handle the new case sensitivity option.",
        "modified_complete_code": {
            "#file 1": "function _getSingleOpt(first, override, fallback) {\n  let ret;\n  if (first !== undefined) {\n    ret = first;\n  } else if (override !== undefined) {\n    ret = override;\n  } else {\n    ret = fallback;\n  }\n  return ret;\n}\n\n#Modify export function _getOptions(search, _defaults) {\n  return _getAdvancedOptions(search, _defaults);\n}",
            "#file 2": "import { _getAdvancedOptions } from './new_file';\n\n#Modify export function matchObject(obj, search) {\n  const options = _getAdvancedOptions(search, _defaults);\n  return _matchObj(obj, search, options);\n}",
            "#file 3": "for (i = 0; i < searches.length; i++) {\n  const entry = searches[i];\n  describe('for entry ' + JSON.stringify(entry.search), function () {\n    describe('matchObject', function () {\n      for (j = 0; j < data.length; j++) {\n        (function (d, h) {\n          let isNot = (h ? \"\" : \"NOT \");\n          it('should ' + isNot + \"match for data \" + JSON.stringify(d), function () {\n            m = matchObject(d, entry.search);\n            m.should.eql(h);\n          });\n        }(data[j], hash[j]));\n      }\n    });\n  });\n}",
            "#file 4": "#New export function _getAdvancedOptions(search, _defaults) {\n  const options = _getOptions(search, _defaults);\n  options.caseSensitive = _getSingleOpt(search._caseSensitive, _defaults.caseSensitive, false);\n  return options;\n}"
        }
    },
    {
        "repo": "React_Redux_Tutorial",
        "content": "'React_Redux_Tutorial/src/containers/Header.js'\n:import React from \"react\";\n\nconst Header = () => {\n  return (\n    <div className=\"ui fixed menu\">\n      <div className=\"ui container center\">\n        <h2>FakeShop</h2>\n      </div>\n    </div>\n  );\n};\n\nexport default Header;\n\n'React_Redux_Tutorial/src/App.js'\n:import React from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport ProductListing from \"./containers/ProductListing\";\nimport Header from \"./containers/Header\";\nimport \"./App.css\";\nimport ProductDetails from \"./containers/ProductDetails\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Router>\n        <Header />\n        <Switch>\n          <Route path=\"/\" exact component={ProductListing} />\n          <Route path=\"/product/:productId\" component={ProductDetails} />\n          <Route>404 Not Found!</Route>\n        </Switch>\n      </Router>\n    </div>\n  );\n}\n\nexport default App;\n\n'React_Redux_Tutorial/src/App.test.js'\n:import { render, screen } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n\n",
        "called_code_segment_file_1": "const Header = () => {\n  return (\n    <div className=\"ui fixed menu\">\n      <div className=\"ui container center\">\n        <h2>FakeShop</h2>\n      </div>\n    </div>\n  );\n};",
        "invoking_code_segment_file_2": "function App() {\n  return (\n    <div className=\"App\">\n      <Router>\n        <Header />\n        <Switch>\n          <Route path=\"/\" exact component={ProductListing} />\n          <Route path=\"/product/:productId\" component={ProductDetails} />\n          <Route>404 Not Found!</Route>\n        </Switch>\n      </Router>\n    </div>\n  );\n}",
        "invoking_code_segment_file_3": "No direct invocation of #file 1 or #file 2 in #file 3.",
        "new_file_code_segment": "const NewFeature = () => {\n  return (\n    <div className=\"new-feature\">\n      <h3>New Feature Section</h3>\n      <p>This is a new feature added to the application.</p>\n    </div>\n  );\n};",
        "feature_description": "Add a new feature section in the Header component.",
        "detailed_feature_description": "The new feature involves adding a new section in the Header component to display additional information. This new section will be implemented in a new file (#file 4) and will be invoked from the Header component in #file 1. The App component in #file 2 will remain unchanged as it already includes the Header component. The new feature will be integrated by modifying the Header component to include the new section and ensuring that the new file (#file 4) is imported and used appropriately.",
        "modified_complete_code": {
            "#file 1": "//Modify\nimport React from \"react\";\nimport NewFeature from \"./NewFeature\"; //New\n\nconst Header = () => {\n  return (\n    <div className=\"ui fixed menu\">\n      <div className=\"ui container center\">\n        <h2>FakeShop</h2>\n        <NewFeature /> //New\n      </div>\n    </div>\n  );\n};\n\nexport default Header;",
            "#file 2": "import React from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport ProductListing from \"./containers/ProductListing\";\nimport Header from \"./containers/Header\";\nimport \"./App.css\";\nimport ProductDetails from \"./containers/ProductDetails\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Router>\n        <Header />\n        <Switch>\n          <Route path=\"/\" exact component={ProductListing} />\n          <Route path=\"/product/:productId\" component={ProductDetails} />\n          <Route>404 Not Found!</Route>\n        </Switch>\n      </Router>\n    </div>\n  );\n}\n\nexport default App;",
            "#file 3": "No changes needed in #file 3.",
            "#file 4": "//New\nimport React from \"react\";\n\nconst NewFeature = () => {\n  return (\n    <div className=\"new-feature\">\n      <h3>New Feature Section</h3>\n      <p>This is a new feature added to the application.</p>\n    </div>\n  );\n};\n\nexport default NewFeature;"
        }
    },
    {
        "repo": "tabex",
        "content": "'tabex/lib/utils.js'\n:'use strict';\n\n\n/* global document */\n\n\n// Run each function with params and callback after all\n//\n// - functions ([Function]) - array of functions to run\n// - params... - params for functions and callback\n// - callback (Function) - execute after all\n//\nexports.asyncEach = function (functions/* , params..., callback */) {\n  functions = functions.slice(0);\n\n  var callback = arguments[arguments.length - 1];\n  var params = Array.prototype.slice.call(arguments, 1);\n\n  // Remove callback from params\n  params.pop();\n\n  function next() {\n    if (functions.length === 0) {\n      callback.apply(this, arguments);\n      return;\n    }\n\n    var fn = functions.shift();\n\n    fn.apply(this, Array.prototype.slice.call(arguments, 0).concat(next));\n  }\n\n  next.apply(this, params);\n};\n\n\n// `addEventListener` not supported in IE <= 8, fallback to `attachEvent`\n//\nexports.addEvent = function (target, type, listener) {\n  if (document.addEventListener) {\n    target.addEventListener(type, listener);\n    return;\n  }\n\n  target.attachEvent('on' + type, listener);\n};\n\n'tabex/lib/router.js'\n:// LocalStorage router\n//\n'use strict';\n\n\n/* global document, window */\nvar Timer = require('./timer');\nvar LocalStorage = require('./local_storage');\nvar $$ = require('./utils');\n\n\n// Max lifetime of router record in storage\nvar TIMEOUT = 4000;\n// Update router record frequency\nvar UPDATE_INTERVAL = TIMEOUT / 4;\n\n\n// Constructor\n//\n// options:\n//\n//  - namespace (String) - optional, localStorage keys prefix, default 'tabex_default_'\n//\nfunction Router(options) {\n  var self = this;\n\n  options = options || {};\n\n  this.__namespace__ = options.namespace || 'tabex_default_';\n  this.__node_id__ = Math.floor(Math.random() * 1e10) + 1;\n  this.__last_message_cnt__ = 0;\n  this.__handlers__ = [];\n  this.__router_channels__ = {};\n\n  // Constants for convenience\n  this.__router_id_prefix__ = this.__namespace__ + 'router_';\n  this.__router_channels_prefix__ = this.__namespace__ + 'subscribed_';\n  this.__lock_prefix__ = this.__namespace__ + 'lock_';\n\n  // IE broadcasts storage events also to the same window, we should filter that messages\n  this.__storage_events_filter__ = [];\n\n  for (var i = 0; i < 100; i++) {\n    this.__storage_events_filter__.push('');\n  }\n\n  this.__ls__ = new LocalStorage();\n\n  // Id of master tab\n  this.__master_id__ = null;\n\n  // Handle `localStorage` update\n  $$.addEvent(window, 'storage', function (e) {\n    if (e.key === null) {\n      // If event is caused by `localStorage.clear()` `key` will be null. Skip this\n      // event and reestablish normal behaviour by `.__check_master__()` call.\n      self.__check_master__();\n      return;\n    }\n\n    // IE needs kludge because event fire before data was saved\n    if ('onstoragecommit' in document) {\n      setTimeout(function () {\n        self.__on_changed__(e);\n      }, 1);\n\n      return;\n    }\n\n    self.__on_changed__(e);\n  });\n\n  // Handle page unload (listen `onbeforeunload` and `onunload` to ensure that data is stored successfully)\n  // http://stackoverflow.com/questions/3775566/javascript-question-onbeforeunload-or-onunload\n  //\n  this.__destroyed__ = false;\n  $$.addEvent(window, 'beforeunload', function () {\n    self.__destroy__();\n  });\n  $$.addEvent(window, 'unload', function () {\n    self.__destroy__();\n  });\n\n  // Update current tab info and check master alive\n  this.__check_master__();\n\n  // Instell timers & remember those to cleanup in __destroy__()\n  this.__timer_cm__ = Timer.setInterval(function () {\n    self.__check_master__();\n  }, UPDATE_INTERVAL);\n\n  // Remove outdated lock records\n  this.__timer_lc__ = Timer.setInterval(function () {\n    self.__locks_cleanup__();\n  }, 1000);\n}\n\n\n// Broadcast message between all clients\n//\n// - channel (String) - channel name\n// - message (Object) - message data\n//\nRouter.prototype.broadcast = function (channel, message) {\n  // If it is system subscribe message - update channels list\n  if (channel === '!sys.channels.add') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]++;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system unsubscribe message - update channels list\n  if (channel === '!sys.channels.remove') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]--;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system lock message - try acquire lock\n  if (channel === '!sys.lock.request') {\n    this.__lock__(message.data.id, message.id, message.data.timeout);\n\n    return;\n  }\n\n  // If it is system unlock message - remove lock data\n  if (channel === '!sys.lock.release') {\n    this.__ls__.removeItem(this.__lock_prefix__ + message.data.id);\n\n    return;\n  }\n\n  var serializedMessage = JSON.stringify({\n    channel: channel,\n    message: message,\n\n    // Add random to be sure that `localStorage` sent event even new massage is same than previous\n    random: Math.floor(Math.random() * 1e10)\n  });\n\n  // Add message to `localStorage` to distribute over Router instances\n  this.__storage_events_filter__.shift();\n  this.__storage_events_filter__.push(this.__namespace__ + 'broadcast' + '_' + serializedMessage);\n  this.__ls__.setItem(this.__namespace__ + 'broadcast', serializedMessage);\n\n  // Emit message for all clients and proxies registered on this router\n  this.__handlers__.forEach(function (handler) {\n    handler(channel, message);\n  });\n};\n\n\n// Subscribe handler to all messages\n//\nRouter.prototype.onmessage = function (handler) {\n  var self = this;\n\n  this.__handlers__.push(handler);\n\n  // Delay sending events to next tick to allow client initialize handlers\n  setTimeout(function () {\n    // Sent master info for every new client\n    handler('!sys.master', {\n      data: {\n        node_id: self.__node_id__,\n        master_id: self.__master_id__\n      },\n      node_id: self.__node_id__,\n      id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n    });\n\n    // Send channels info\n    self.__on_channels_list_changed__();\n  }, 0);\n};\n\n\n// Try acquire lock\n//\n// - lockId (String)\n// - requestId (String)\n// - timeout (Number)\n//\nRouter.prototype.__lock__ = function (lockId, requestId, timeout) {\n  var self = this;\n  var lockKey = this.__lock_prefix__ + lockId;\n  var lockValue = this.__ls__.getItem(lockKey);\n\n  if (lockValue) {\n    try {\n      lockValue = JSON.parse(lockValue);\n    } catch (__) {\n      lockValue = null;\n    }\n  }\n\n  // If `expire` not in past - lock already acquired, exit here\n  if (lockValue && lockValue.expire > Date.now()) {\n    return;\n  }\n\n  // Try acquire lock\n  this.__ls__.setItem(lockKey, JSON.stringify({ expire: timeout + Date.now(), requestId: requestId }));\n\n  // Read lock value again after 30 ms to check `requestId` (race condition\n  // here - other tab may rewrite value in store). Delay needed to ensure that\n  // localStorage's data synchronized\n  setTimeout(function () {\n    lockValue = self.__ls__.getItem(lockKey);\n\n    if (lockValue) {\n      try {\n        lockValue = JSON.parse(lockValue);\n      } catch (__) {\n        lockValue = null;\n      }\n    }\n\n    // If `requestId` is not same - other tab acquire lock, exit here\n    if (!lockValue || lockValue.requestId !== requestId) {\n      return;\n    }\n\n    // Here lock acquired - send message to clients\n    self.__handlers__.forEach(function (handler) {\n      handler('!sys.lock.acquired', {\n        data: {\n          request_id: requestId\n        },\n        node_id: self.__node_id__,\n        id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n      });\n    });\n  }, 30);\n};\n\n\n// Remove outdated lock records from storage\n//\nRouter.prototype.__locks_cleanup__ = function () {\n  for (var i = 0, key, val; i < this.__ls__.length; i++) {\n    key = this.__ls__.key(i);\n\n    // Filter localStorage records by prefix\n    if (key.indexOf(this.__lock_prefix__) !== 0) {\n      continue;\n    }\n\n    val = this.__ls__.getItem(key);\n\n    try {\n      val = JSON.parse(val);\n    } catch (__) {\n      val = null;\n    }\n\n    // If lock expire or record is broken - remove it\n    if (!val || val.expire < Date.now()) {\n      this.__ls__.removeItem(key);\n    }\n  }\n};\n\n\n// Update master id, if current tab is master - init connect and subscribe channels\n//\nRouter.prototype.__on_master_changed__ = function (newMasterID) {\n  var self = this;\n\n  // If master tab closed\n  if (!newMasterID) {\n    // Select random master (tab with smallest ID becomes master)\n    if (this.__get_alive_router_ids__().sort()[0] === this.__node_id__) {\n      this.__storage_events_filter__.pop();\n      this.__storage_events_filter__.push(this.__namespace__ + 'master' + '_' + this.__node_id__);\n      this.__ls__.setItem(this.__namespace__ + 'master', this.__node_id__);\n      this.__on_master_changed__(this.__node_id__);\n    }\n    return;\n  }\n\n  this.__master_id__ = +newMasterID;\n\n  this.__handlers__.forEach(function (handler) {\n    handler('!sys.master', {\n      data: {\n        node_id: self.__node_id__,\n        master_id: self.__master_id__\n      },\n      node_id: self.__node_id__,\n      id: self.__node_id__ + '_' + (self.__last_message_cnt__++)\n    });\n  });\n\n  // Update channels list for this tab before sending channels info. Needed if\n  // master changed by calling `localStorage.clear()`\n  self.__update_channels_list__(true);\n\n  // Send channels info\n  self.__on_channels_list_changed__();\n};\n\n\n// localStorage change handler. Updates master ID, receive subscribe requests\n//\nRouter.prototype.__on_changed__ = function (e) {\n\n  // IE broadcasts storage events also to the same window, we should filter that messages\n  if (this.__storage_events_filter__.indexOf(e.key + '_' + e.newValue) !== -1) {\n    return;\n  }\n\n  // Master changed\n  if (e.key === this.__namespace__ + 'master') {\n    this.__on_master_changed__(e.newValue);\n  }\n\n  // Channels list changed\n  if (e.key.indexOf(this.__router_channels_prefix__) === 0) {\n    this.__on_channels_list_changed__();\n  }\n\n  // Emit message for all clients and proxies registered on this router\n  if (e.key === this.__namespace__ + 'broadcast') {\n    var data = JSON.parse(e.newValue);\n\n    this.__handlers__.forEach(function (handler) {\n      handler(data.channel, data.message);\n    });\n  }\n};\n\n\n// Page unload handler. Remove tab data from store & kill timers\n//\nRouter.prototype.__destroy__ = function () {\n  if (this.__destroyed__) {\n    return;\n  }\n\n  this.__destroyed__ = true;\n\n  Timer.clearInterval(this.__timer_cm__);\n  Timer.clearInterval(this.__timer_lc__);\n\n  this.__ls__.removeItem(this.__router_id_prefix__ + this.__node_id__);\n  this.__ls__.removeItem(this.__router_channels_prefix__ + this.__node_id__);\n\n  if (this.__master_id__ === this.__node_id__) {\n    this.__ls__.removeItem(this.__namespace__ + 'master');\n  }\n};\n\n\n// Get alive tabs IDs and remove timeouted tabs\n//\nRouter.prototype.__get_alive_router_ids__ = function () {\n  var maxTime = Date.now() - TIMEOUT;\n  var id;\n  var routersIDs = [];\n\n  for (var i = 0, key; i < this.__ls__.length; i++) {\n    key = this.__ls__.key(i);\n\n    // Filter localStorage records by prefix\n    if (key.indexOf(this.__router_id_prefix__) !== 0) {\n      continue;\n    }\n\n    id = +key.substr(this.__router_id_prefix__.length);\n\n    // Check router is alive and remove if not\n    if (this.__ls__.getItem(key) < maxTime) {\n      this.__ls__.removeItem(key);\n      this.__ls__.removeItem(this.__router_channels_prefix__ + id);\n      continue;\n    }\n\n    routersIDs.push(id);\n  }\n\n  return routersIDs;\n};\n\n\n// Update tab channels list\n//\nRouter.prototype.__update_channels_list__ = function (silent) {\n  var self = this;\n  var channels = [];\n\n  Object.keys(this.__router_channels__).forEach(function (channel) {\n    if (self.__router_channels__[channel] > 0) {\n      channels.push(channel);\n    }\n  });\n\n  var serializedChannels = JSON.stringify(channels.sort());\n\n  // Update channels list if changed\n  if (this.__ls__.getItem(this.__router_channels_prefix__ + this.__node_id__) !== serializedChannels) {\n    this.__storage_events_filter__.pop();\n    this.__storage_events_filter__.push(this.__router_channels_prefix__ + this.__node_id__ + '_' + serializedChannels);\n    this.__ls__.setItem(this.__router_channels_prefix__ + this.__node_id__, serializedChannels);\n    if (!silent) {\n      this.__on_channels_list_changed__();\n    }\n  }\n};\n\n\n// Update subscribes if channels list changed (run only on master)\n//\nRouter.prototype.__on_channels_list_changed__ = function () {\n  var self = this;\n  var channels = [];\n\n  for (var i = 0, key; i < this.__ls__.length; i++) {\n    key = this.__ls__.key(i);\n\n    // Filter localStorage records by prefix\n    if (key.indexOf(this.__router_channels_prefix__) !== 0) {\n      continue;\n    }\n\n    channels = channels.concat(JSON.parse(this.__ls__.getItem(key)));\n  }\n\n  // Get unique channels names\n  channels = channels.reduce(function (result, item) {\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n    return result;\n  }, []);\n\n  this.__handlers__.forEach(function (handler) {\n    handler('!sys.channels.refresh', {\n      id: self.__node_id__ + '_' + (self.__last_message_cnt__++),\n      node_id: self.__node_id__,\n      data: {\n        channels: channels\n      }\n    });\n  });\n};\n\n\n// Update tab livetime and become master if not exists\n//\nRouter.prototype.__check_master__ = function () {\n  // Update current tab time\n  this.__ls__.setItem(this.__router_id_prefix__ + this.__node_id__, Date.now());\n\n  // Update local value of master ID\n  this.__master_id__ = +this.__ls__.getItem(this.__namespace__ + 'master');\n\n  // If master tab not found - become master\n  if (this.__get_alive_router_ids__().indexOf(this.__master_id__) === -1) {\n    this.__storage_events_filter__.pop();\n    this.__storage_events_filter__.push(this.__namespace__ + 'master' + '_' + this.__node_id__);\n    this.__ls__.setItem(this.__namespace__ + 'master', this.__node_id__);\n    this.__on_master_changed__(this.__node_id__);\n  }\n};\n\n\nmodule.exports = Router;\n\n'tabex/lib/index.js'\n:'use strict';\n\n\nvar Router = require('./router');\nvar Client = require('./client');\nvar Tunnel = require('./tunnel');\n\n\nvar routerInstances = {};\n\n\nvar Tabex = { _: {} };\n\n\n// Expose classes for testing\n//\nTabex._.Router = Router;\nTabex._.Client = Client;\nTabex._.Tunnel = Tunnel;\n\n\n// Create client\n//\nTabex.client = function (options) {\n  options = options || {};\n\n  var namespace = options.namespace || 'tabex_default_';\n\n  var router;\n\n  // If router in iframe (cross-domain) - create tunnel\n  if (options.iframe) {\n    router = new Tunnel.TunnelClient(options);\n\n  // If router is local (single-domain) - try to reuse existing router\n  } else {\n    if (!routerInstances[namespace]) {\n      routerInstances[namespace] = new Router({\n        namespace: namespace\n      });\n    }\n\n    router = routerInstances[namespace];\n  }\n\n  return new Client({ router: router });\n};\n\n\n// Create router\n//\nTabex.router = function (options) {\n  options = options || {};\n\n  var namespace = options.namespace || 'tabex_default_';\n\n  // Try to reuse existing router\n  if (!routerInstances[namespace]) {\n    routerInstances[namespace] = new Router({\n      namespace: namespace\n    });\n  }\n\n  // Create tunnel to communicate between router and client\n  /* eslint-disable no-new */\n  new Tunnel.TunnelRouter({\n    router: routerInstances[namespace],\n    namespace: namespace,\n    origin: options.origin\n  });\n\n  return routerInstances[namespace];\n};\n\n\nmodule.exports = Tabex;\n\n",
        "called_code_segment_file_1": "Router.prototype.broadcast = function (channel, message) {\n  // If it is system subscribe message - update channels list\n  if (channel === '!sys.channels.add') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]++;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system unsubscribe message - update channels list\n  if (channel === '!sys.channels.remove') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]--;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  var serializedMessage = JSON.stringify({\n    channel: channel,\n    message: message,\n\n    // Add random to be sure that `localStorage` sent event even new massage is same than previous\n    random: Math.floor(Math.random() * 1e10)\n  });\n\n  // Add message to `localStorage` to distribute over Router instances\n  this.__storage_events_filter__.shift();\n  this.__storage_events_filter__.push(this.__namespace__ + 'broadcast' + '_' + serializedMessage);\n  this.__ls__.setItem(this.__namespace__ + 'broadcast', serializedMessage);\n\n  // Emit message for all clients and proxies registered on this router\n  this.__handlers__.forEach(function (handler) {\n    handler(channel, message);\n  });\n};",
        "invoking_code_segment_file_2": "Client.prototype.subscribe = function (channel, handler) {\n  if (this.__subscriptions__[channel]) {\n    this.__subscriptions__[channel].push(handler);\n  } else {\n    this.__subscriptions__[channel] = [handler];\n    this.__router__.broadcast('!sys.channels.add', { data: { channel: channel } });\n  }\n};\n\nClient.prototype.unsubscribe = function (channel, handler) {\n  if (!this.__subscriptions__[channel]) {\n    return;\n  }\n\n  if (handler) {\n    var index = this.__subscriptions__[channel].indexOf(handler);\n    if (index !== -1) {\n      this.__subscriptions__[channel].splice(index, 1);\n    }\n  } else {\n    this.__subscriptions__[channel] = [];\n  }\n\n  if (this.__subscriptions__[channel].length === 0) {\n    delete this.__subscriptions__[channel];\n    this.__router__.broadcast('!sys.channels.remove', { data: { channel: channel } });\n  }\n};",
        "invoking_code_segment_file_3": "Tunnel.TunnelRouter = function (options) {\n  var self = this;\n  options = options || {};\n\n  this.__router__ = options.router;\n  this.__namespace__ = options.namespace;\n  this.__origin__ = options.origin;\n\n  this.__router__.onmessage(function (channel, message) {\n    if (channel === '!sys.channels.refresh') {\n      self.__send_channels_list__(message.data.channels);\n    }\n  });\n};",
        "new_file_code_segment": "// #file 4\n// New feature to log messages\n\nfunction logMessage(channel, message) {\n  console.log(`Channel: ${channel}, Message:`, message);\n}\n\nmodule.exports = {\n  logMessage: logMessage\n};",
        "feature_description": "Add logging functionality to log messages broadcasted by the Router.",
        "detailed_feature_description": "The new feature involves adding a logging mechanism that logs all messages broadcasted by the Router. This is achieved by modifying the Router's broadcast method to invoke the logging function from a new file (#file 4). The logging function will log the channel and message details to the console. This feature enhances debugging and monitoring capabilities by providing a record of all messages sent through the Router.",
        "modified_complete_code": {
            "file_1": "// #file 1\nRouter.prototype.broadcast = function (channel, message) {\n  // If it is system subscribe message - update channels list\n  if (channel === '!sys.channels.add') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]++;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  // If it is system unsubscribe message - update channels list\n  if (channel === '!sys.channels.remove') {\n    this.__router_channels__[message.data.channel] = this.__router_channels__[message.data.channel] || 0;\n    this.__router_channels__[message.data.channel]--;\n    this.__update_channels_list__();\n\n    return;\n  }\n\n  var serializedMessage = JSON.stringify({\n    channel: channel,\n    message: message,\n\n    // Add random to be sure that `localStorage` sent event even new massage is same than previous\n    random: Math.floor(Math.random() * 1e10)\n  });\n\n  // Add message to `localStorage` to distribute over Router instances\n  this.__storage_events_filter__.shift();\n  this.__storage_events_filter__.push(this.__namespace__ + 'broadcast' + '_' + serializedMessage);\n  this.__ls__.setItem(this.__namespace__ + 'broadcast', serializedMessage);\n\n  // Emit message for all clients and proxies registered on this router\n  this.__handlers__.forEach(function (handler) {\n    handler(channel, message);\n  });\n\n  // #Modify: Add logging functionality\n  var logger = require('./logger');\n  logger.logMessage(channel, message);\n};",
            "file_2": "// #file 2\nClient.prototype.subscribe = function (channel, handler) {\n  if (this.__subscriptions__[channel]) {\n    this.__subscriptions__[channel].push(handler);\n  } else {\n    this.__subscriptions__[channel] = [handler];\n    this.__router__.broadcast('!sys.channels.add', { data: { channel: channel } });\n  }\n};\n\nClient.prototype.unsubscribe = function (channel, handler) {\n  if (!this.__subscriptions__[channel]) {\n    return;\n  }\n\n  if (handler) {\n    var index = this.__subscriptions__[channel].indexOf(handler);\n    if (index !== -1) {\n      this.__subscriptions__[channel].splice(index, 1);\n    }\n  } else {\n    this.__subscriptions__[channel] = [];\n  }\n\n  if (this.__subscriptions__[channel].length === 0) {\n    delete this.__subscriptions__[channel];\n    this.__router__.broadcast('!sys.channels.remove', { data: { channel: channel } });\n  }\n};",
            "file_3": "// #file 3\nTunnel.TunnelRouter = function (options) {\n  var self = this;\n  options = options || {};\n\n  this.__router__ = options.router;\n  this.__namespace__ = options.namespace;\n  this.__origin__ = options.origin;\n\n  this.__router__.onmessage(function (channel, message) {\n    if (channel === '!sys.channels.refresh') {\n      self.__send_channels_list__(message.data.channels);\n    }\n  });\n};",
            "file_4": "// #file 4\n// New feature to log messages\n\nfunction logMessage(channel, message) {\n  console.log(`Channel: ${channel}, Message:`, message);\n}\n\nmodule.exports = {\n  logMessage: logMessage\n};"
        }
    },
    {
        "repo": "PERN-STACK-DEPLOYMENT",
        "content": "'PERN-STACK-DEPLOYMENT/client/src/routes/Home.jsx'\n:import React from \"react\";\nimport Header from \"../components/Header\";\nimport AddRestaurant from \"../components/AddRestaurant\";\nimport RestaurantList from \"../components/RestaurantList\";\n\nconst Home = () => {\n  return (\n    <div>\n      <Header />\n      <AddRestaurant />\n      <RestaurantList />\n    </div>\n  );\n};\n\nexport default Home;\n\n'PERN-STACK-DEPLOYMENT/client/src/App.jsx'\n:import React from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Home from \"./routes/Home\";\nimport UpdatePage from \"./routes/UpdatePage\";\nimport RestaurantDetailPage from \"./routes/RestaurantDetailPage\";\nimport { RestaurantsContextProvider } from \"./context/RestaurantsContext\";\nconst App = () => {\n  return (\n    <RestaurantsContextProvider>\n      <div className=\"container\">\n        <Router>\n          <Switch>\n            <Route exact path=\"/\" component={Home} />\n            <Route\n              exact\n              path=\"/restaurants/:id/update\"\n              component={UpdatePage}\n            />\n            <Route\n              exact\n              path=\"/restaurants/:id\"\n              component={RestaurantDetailPage}\n            />\n          </Switch>\n        </Router>\n      </div>\n    </RestaurantsContextProvider>\n  );\n};\n\nexport default App;\n\n'PERN-STACK-DEPLOYMENT/client/src/index.js'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n",
        "called_code_segment_file_1": "const Home = () => {\n  return (\n    <div>\n      <Header />\n      <AddRestaurant />\n      <RestaurantList />\n    </div>\n  );\n};",
        "invoking_code_segment_file_2": "<Route exact path=\"/\" component={Home} />",
        "invoking_code_segment_file_3": "No direct invocation of #file 1 or #file 2 in #file 3.",
        "new_file_code_segment": "const NewFeatureComponent = () => {\n  return (\n    <div>\n      <h2>New Feature Component</h2>\n      <p>This is a new feature added to the Home page.</p>\n    </div>\n  );\n};",
        "feature_description": "Add a new feature component to the Home page.",
        "detailed_feature_description": "A new feature component named NewFeatureComponent is added to the Home page. This component will be displayed below the RestaurantList component. The new feature component is implemented in a new file (#file 4) and is integrated into the Home component in #file 1. The App component in #file 2 remains unchanged as it already routes to the Home component.",
        "modified_complete_code": {
            "#file 1": "//Modify\nconst Home = () => {\n  return (\n    <div>\n      <Header />\n      <AddRestaurant />\n      <RestaurantList />\n      <NewFeatureComponent />\n    </div>\n  );\n};",
            "#file 2": "const App = () => {\n  return (\n    <RestaurantsContextProvider>\n      <div className=\"container\">\n        <Router>\n          <Switch>\n            <Route exact path=\"/\" component={Home} />\n            <Route\n              exact\n              path=\"/restaurants/:id/update\"\n              component={UpdatePage}\n            />\n            <Route\n              exact\n              path=\"/restaurants/:id\"\n              component={RestaurantDetailPage}\n            />\n          </Switch>\n        </Router>\n      </div>\n    </RestaurantsContextProvider>\n  );\n};",
            "#file 3": "No changes required in #file 3.",
            "#file 4": "//New\nconst NewFeatureComponent = () => {\n  return (\n    <div>\n      <h2>New Feature Component</h2>\n      <p>This is a new feature added to the Home page.</p>\n    </div>\n  );\n};"
        }
    },
    {
        "repo": "react-modal",
        "content": "'react-modal/scripts/defaultConfig.js'\n:const path = require('path');\n\nmodule.exports = {\n  mode: 'development',\n  output: {\n    filename: '[name].js',\n    path: path.resolve(__dirname, './examples/__build__'),\n    publicPath: '/__build__/'\n  },\n  module: {\n    rules: [\n      { test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader' } }\n    ]\n  },\n  resolve: {\n    alias: {\n      \"react-modal\": path.resolve(__dirname, \"../src\")\n    }\n  }\n};\n\n'react-modal/scripts/webpack.test.config.js'\n:const path = require('path');\nconst defaultConfig = require('./defaultConfig');\n\nmodule.exports = {\n  ...defaultConfig,\n  plugins: [],\n  entry: path.resolve(__dirname, '../specs/index.js'),\n  devtool: 'inline-source-map',\n  module: {\n    ...defaultConfig.module,\n    rules: [\n      {\n        test: /\\.js$/,\n        use: { loader: 'istanbul-instrumenter-loader' },\n        enforce: 'post',\n        include: path.resolve(__dirname, '../src')\n      },\n      ...defaultConfig.module.rules\n    ]\n  }\n};\n\n'react-modal/karma.conf.js'\n:let browsers = ['ChromeHeadless'];\nlet coverageType = 'text';\n\nif (process.env.CONTINUOUS_INTEGRATION) {\n  browsers = ['Firefox'];\n  coverageType = 'lcovonly';\n}\n\nmodule.exports = function(config) {\n  config.set({\n    frameworks: ['mocha'],\n\n    preprocessors: {\n      './src/*.js': ['coverage'],\n      './src/**/*.js': ['coverage'],\n      './specs/index.js': ['webpack', 'sourcemap']\n    },\n\n    files: ['./specs/index.js'],\n\n    webpack: require('./scripts/webpack.test.config'),\n\n    webpackMiddleware: { stats: 'errors-only' },\n\n    reporters: ['mocha', 'coverage'],\n\n    mochaReporter: { showDiff: true },\n\n    coverageReporter: {\n      type : coverageType,\n      dir : 'coverage/',\n      subdir: '.'\n    },\n\n    port: 9876,\n\n    colors: true,\n\n    logLevel: config.LOG_INFO,\n\n    autoWatch: true,\n\n    browsers,\n\n    // Increase timeouts to prevent the issue with disconnected tests (https://goo.gl/nstA69)\n    captureTimeout: 4 * 60 * 1000,\n\n    singleRun: (process.env.CONTINUOUS_INTEGRATION)\n  });\n};\n\n",
        "called_code_segment_file_1": "module.exports = { ...defaultConfig, plugins: [], entry: path.resolve(__dirname, '../specs/index.js'), devtool: 'inline-source-map', module: { ...defaultConfig.module, rules: [ { test: /\\.js$/, use: { loader: 'istanbul-instrumenter-loader' }, enforce: 'post', include: path.resolve(__dirname, '../src') }, ...defaultConfig.module.rules ] } };",
        "invoking_code_segment_file_2": "files: ['./specs/index.js'], webpack: require('./scripts/webpack.test.config'), webpackMiddleware: { stats: 'errors-only' },",
        "invoking_code_segment_file_3": "preprocessors: { './src/*.js': ['coverage'], './src/**/*.js': ['coverage'], './specs/index.js': ['webpack', 'sourcemap'] },",
        "new_file_code_segment": "module.exports = { coverageReporter: { type: 'text', dir: 'coverage/', subdir: '.' } };",
        "feature_description": "Add a coverage reporter configuration to the webpack test configuration.",
        "detailed_feature_description": "The new feature involves adding a coverage reporter configuration to the webpack test configuration. This will help in generating coverage reports during the test runs. The new file (#file 4) contains the coverage reporter configuration, which is then integrated into the existing webpack test configuration in #file 1. The changes in #file 1 are then propagated to #file 2 and #file 3 to ensure compatibility and proper invocation of the new functionality.",
        "modified_complete_code": {
            "#file 1": "const path = require('path');\nconst defaultConfig = require('./defaultConfig');\n\nmodule.exports = {\n  ...defaultConfig,\n  plugins: [],\n  entry: path.resolve(__dirname, '../specs/index.js'),\n  devtool: 'inline-source-map',\n  module: {\n    ...defaultConfig.module,\n    rules: [\n      {\n        test: /\\.js$/,\n        use: { loader: 'istanbul-instrumenter-loader' },\n        enforce: 'post',\n        include: path.resolve(__dirname, '../src')\n      },\n      ...defaultConfig.module.rules\n    ]\n  },\n  #Modify coverageReporter: require('./coverageReporterConfig').coverageReporter\n};",
            "#file 2": "let browsers = ['ChromeHeadless'];\nlet coverageType = 'text';\n\nif (process.env.CONTINUOUS_INTEGRATION) {\n  browsers = ['Firefox'];\n  coverageType = 'lcovonly';\n}\n\nmodule.exports = function(config) {\n  config.set({\n    frameworks: ['mocha'],\n    preprocessors: {\n      './src/*.js': ['coverage'],\n      './src/**/*.js': ['coverage'],\n      './specs/index.js': ['webpack', 'sourcemap']\n    },\n    files: ['./specs/index.js'],\n    webpack: require('./scripts/webpack.test.config'),\n    webpackMiddleware: { stats: 'errors-only' },\n    reporters: ['mocha', 'coverage'],\n    mochaReporter: { showDiff: true },\n    coverageReporter: {\n      type: coverageType,\n      dir: 'coverage/',\n      subdir: '.'\n    },\n    port: 9876,\n    colors: true,\n    logLevel: config.LOG_INFO,\n    autoWatch: true,\n    browsers,\n    captureTimeout: 4 * 60 * 1000,\n    singleRun: (process.env.CONTINUOUS_INTEGRATION)\n  });\n};",
            "#file 3": "preprocessors: {\n  './src/*.js': ['coverage'],\n  './src/**/*.js': ['coverage'],\n  './specs/index.js': ['webpack', 'sourcemap']\n},",
            "#file 4": "module.exports = {\n  coverageReporter: {\n    type: 'text',\n    dir: 'coverage/',\n    subdir: '.'\n  }\n};"
        }
    },
    {
        "repo": "nft-marketplace-showcase",
        "content": "'nft-marketplace-showcase/src/styles/Global.js'\n:const styles = {\n  whiteText: \"text-white\",\n  blackText: \"text-tertiary\",\n\n  bgWhite: \"bg-white\",\n  bgPrimary: \"bg-primary\",\n\n  boxClass: \"flex-row md:flex-col\",\n  boxReverseClass: \"flex-row-reverse md:flex-col-reverse\",\n\n  textLeft: \"text-left\",\n  textRight: \"text-right\",\n\n  h1Text:\n    \"font-bold font-IBMPlex text-5xl sm:text-4xl minmd:text-6xl minlg:text-8xl leading-12 minmd:leading-13\",\n  pText:\n    \"my-5 minmd:my-10 font-IBMPlex font-light text-xl minmd:text-3xl minlg:text-4xl minmd:leading-16\",\n  descriptionText:\n    \"my-5 minmd:my-10 font-IBMPlex font-light text-xl minmd:text-3xl minlg:text-4xl minmd:leading-16\",\n  btnText: \"text-white font-IBMPlex minmd:text-lg\",\n\n  btnPrimary:\n    \"bg-primary mt-4 py-4 px-6 text-white text-lg minmd:text-2xl font-IBMPlex font-medium rounded-lg hover:shadow-2xl\",\n  btnBlack:\n    \"bg-black flex items-center py-2 px-4 rounded-md mt-2 w-fit cursor-pointer\",\n\n  section: \"flex justify-center items-center p-16 sm:p-8\",\n  subSection: \"flex items-center w-full minmd:w-3/4\",\n  descDiv: \"flex-1 w-full flex justify-start flex-col md:mb-10 \",\n\n  flexCenter: \"flex justify-center items-center\",\n  flexWrap: \"flex justify-center flex-wrap\",\n\n  fullImg: \"w-full h-full object-cover\",\n  sectionImg: \"w-full h-full minmd:w-11/12 minmd:h-11/12 object-contain\",\n  btnIcon: \"w-5 h-5 minmd:w-10 minmd:h-10 object-contain\",\n\n  featureImg: \"w-20 h-20 minlg:w-40 minlg:h-40 object-contain mb-1\",\n  featureText:\n    \"font-semibold font-IBMPlex text-base minlg:text-3xl text-tertiary\",\n  featureCard:\n    \"bg-white m-10 p-6 rounded-md flex justify-around items-center flex-col hover:shadow-lg cursor-pointer w-40 h-40 minlg:w-80 minlg:h-80\",\n};\n\nexport default styles;\n\n'nft-marketplace-showcase/src/components/SectionWrapper.jsx'\n:import React from 'react';\n\nimport styles from '../styles/Global';\nimport assets from '../assets';\nimport Button from './Button';\n\nconst SectionWrapper = ({ title, description, showBtn, mockupImg, banner, reverse }) => {\n  return (\n    <div className={`min-h-screen ${styles.section} \n      ${reverse ? styles.bgWhite : styles.bgPrimary} \n      ${banner}`}>\n      <div className={`flex items-center \n        ${reverse ? styles.boxReverseClass : styles.boxClass} \n        w-11/12 sm:w-full minmd:w-3/4`}>\n        <div className={`${styles.descDiv} \n          ${reverse ? \" fadeRightMini\" : \" fadeLeftMini\"}\n          ${reverse ? styles.textRight : styles.textLeft}\n        `}>\n          <h1 className={`\n          ${reverse ? styles.blackText : styles.whiteText}\n          ${styles.h1Text}`}>{title}</h1>\n          <p className={`\n          ${reverse ? styles.blackText : styles.whiteText}\n          ${styles.descriptionText}`}>{description}</p>\n          {showBtn && (\n            <Button \n              assetUrl={assets.expo}\n              link=\"https://expo.dev/@adrianhajdin/react_native_app?serviceType=classic&distribution=expo-go\"\n            />\n          )}\n        </div>\n        <div\n          className={`flex-1 ${styles.flexCenter}p-8 sm:px-0`}\n        >\n          <img src={mockupImg} alt=\"mockup\" className={`\n           ${reverse ? \" fadeLeftMini\" : \" fadeRightMini\"}\n          ${styles.sectionImg}`} />\n        </div>\n      </div>\n    </div>\n  )\n}\n\nexport default SectionWrapper\n'nft-marketplace-showcase/src/components/index.js'\n:import Features from './Features';\nimport Download from './Download';\nimport SectionWrapper from './SectionWrapper';\n\nexport { Features, Download, SectionWrapper };\n",
        "called_code_segment_file_1": "const styles = {\n  whiteText: \"text-white\",\n  blackText: \"text-tertiary\",\n  // ... other styles ...\n};\n\nexport default styles;",
        "invoking_code_segment_file_2": "import styles from '../styles/Global';\n\nconst SectionWrapper = ({ title, description, showBtn, mockupImg, banner, reverse }) => {\n  return (\n    <div className={`min-h-screen ${styles.section} \n      ${reverse ? styles.bgWhite : styles.bgPrimary} \n      ${banner}`}>\n      <div className={`flex items-center \n        ${reverse ? styles.boxReverseClass : styles.boxClass} \n        w-11/12 sm:w-full minmd:w-3/4`}>\n        <div className={`${styles.descDiv} \n          ${reverse ? \" fadeRightMini\" : \" fadeLeftMini\"}\n          ${reverse ? styles.textRight : styles.textLeft}\n        `}>\n          <h1 className={`\n          ${reverse ? styles.blackText : styles.whiteText}\n          ${styles.h1Text}`}>{title}</h1>\n          <p className={`\n          ${reverse ? styles.blackText : styles.whiteText}\n          ${styles.descriptionText}`}>{description}</p>\n          {showBtn && (\n            <Button \n              assetUrl={assets.expo}\n              link=\"https://expo.dev/@adrianhajdin/react_native_app?serviceType=classic&distribution=expo-go\"\n            />\n          )}\n        </div>\n        <div\n          className={`flex-1 ${styles.flexCenter}p-8 sm:px-0`}\n        >\n          <img src={mockupImg} alt=\"mockup\" className={`\n           ${reverse ? \" fadeLeftMini\" : \" fadeRightMini\"}\n          ${styles.sectionImg}`} />\n        </div>\n      </div>\n    </div>\n  )\n}",
        "invoking_code_segment_file_3": "import { SectionWrapper } from './components';\n\nconst App = () => {\n  return (\n    <div className=\"flex justify-center sm:px-8 px-4\">\n      <div className=\"flex flex-col w-full minmd:w-4/5\">\n        <SectionWrapper \n          title=\"NFT Marketplace\"\n          description=\"Explore and trade unique digital assets\"\n          showBtn\n          mockupImg={assets.homeHero}\n          banner=\"banner01\"\n        />\n        <SectionWrapper \n          title=\"Discover More\"\n          description=\"Find rare and valuable NFTs\"\n          mockupImg={assets.homeCards}\n          reverse\n        />\n        <Features />\n        <Download />\n      </div>\n    </div>\n  );\n};",
        "new_file_code_segment": "const newFeatureStyles = {\n  highlightText: \"text-highlight\",\n  // ... other new styles ...\n};\n\nexport default newFeatureStyles;",
        "feature_description": "Add a new feature to highlight specific text in the SectionWrapper component.",
        "detailed_feature_description": "The new feature involves adding a new style for highlighting text within the SectionWrapper component. This will be implemented by creating a new file (#file 4) that exports the new styles. The SectionWrapper component in #file 2 will be updated to use these new styles when a 'highlight' prop is passed. The App component in #file 3 will also be updated to pass the 'highlight' prop when needed.",
        "modified_complete_code": {
            "#file_1": "const styles = {\n  whiteText: \"text-white\",\n  blackText: \"text-tertiary\",\n  // ... other styles ...\n};\n\nexport default styles;",
            "#file_2": "import styles from '../styles/Global';\nimport newFeatureStyles from '../styles/NewFeatureStyles'; // #New\n\nconst SectionWrapper = ({ title, description, showBtn, mockupImg, banner, reverse, highlight }) => {\n  return (\n    <div className={`min-h-screen ${styles.section} \n      ${reverse ? styles.bgWhite : styles.bgPrimary} \n      ${banner}`}>\n      <div className={`flex items-center \n        ${reverse ? styles.boxReverseClass : styles.boxClass} \n        w-11/12 sm:w-full minmd:w-3/4`}>\n        <div className={`${styles.descDiv} \n          ${reverse ? \" fadeRightMini\" : \" fadeLeftMini\"}\n          ${reverse ? styles.textRight : styles.textLeft}\n        `}>\n          <h1 className={`\n          ${reverse ? styles.blackText : styles.whiteText}\n          ${highlight ? newFeatureStyles.highlightText : styles.h1Text}`}>{title}</h1> // #Modify\n          <p className={`\n          ${reverse ? styles.blackText : styles.whiteText}\n          ${styles.descriptionText}`}>{description}</p>\n          {showBtn && (\n            <Button \n              assetUrl={assets.expo}\n              link=\"https://expo.dev/@adrianhajdin/react_native_app?serviceType=classic&distribution=expo-go\"\n            />\n          )}\n        </div>\n        <div\n          className={`flex-1 ${styles.flexCenter}p-8 sm:px-0`}\n        >\n          <img src={mockupImg} alt=\"mockup\" className={`\n           ${reverse ? \" fadeLeftMini\" : \" fadeRightMini\"}\n          ${styles.sectionImg}`} />\n        </div>\n      </div>\n    </div>\n  )\n}",
            "#file_3": "import { SectionWrapper } from './components';\n\nconst App = () => {\n  return (\n    <div className=\"flex justify-center sm:px-8 px-4\">\n      <div className=\"flex flex-col w-full minmd:w-4/5\">\n        <SectionWrapper \n          title=\"NFT Marketplace\"\n          description=\"Explore and trade unique digital assets\"\n          showBtn\n          mockupImg={assets.homeHero}\n          banner=\"banner01\"\n          highlight // #New\n        />\n        <SectionWrapper \n          title=\"Discover More\"\n          description=\"Find rare and valuable NFTs\"\n          mockupImg={assets.homeCards}\n          reverse\n        />\n        <Features />\n        <Download />\n      </div>\n    </div>\n  );\n};",
            "#file_4": "const newFeatureStyles = {\n  highlightText: \"text-highlight\",\n  // ... other new styles ...\n};\n\nexport default newFeatureStyles;"
        }
    },
    {
        "repo": "Sorting-Visualizer-Tutorial",
        "content": "'Sorting-Visualizer-Tutorial/src/SortingVisualizer/SortingVisualizer.jsx'\n:import React from 'react';\nimport {getMergeSortAnimations} from '../sortingAlgorithms/sortingAlgorithms.js';\nimport './SortingVisualizer.css';\n\n// Change this value for the speed of the animations.\nconst ANIMATION_SPEED_MS = 1;\n\n// Change this value for the number of bars (value) in the array.\nconst NUMBER_OF_ARRAY_BARS = 310;\n\n// This is the main color of the array bars.\nconst PRIMARY_COLOR = 'turquoise';\n\n// This is the color of array bars that are being compared throughout the animations.\nconst SECONDARY_COLOR = 'red';\n\nexport default class SortingVisualizer extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      array: [],\n    };\n  }\n\n  componentDidMount() {\n    this.resetArray();\n  }\n\n  resetArray() {\n    const array = [];\n    for (let i = 0; i < NUMBER_OF_ARRAY_BARS; i++) {\n      array.push(randomIntFromInterval(5, 730));\n    }\n    this.setState({array});\n  }\n\n  mergeSort() {\n    const animations = getMergeSortAnimations(this.state.array);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName('array-bar');\n      const isColorChange = i % 3 !== 2;\n      if (isColorChange) {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }\n\n  quickSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  heapSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  bubbleSort() {\n    // We leave it as an exercise to the viewer of this code to implement this method.\n  }\n\n  // NOTE: This method will only work if your sorting algorithms actually return\n  // the sorted arrays; if they return the animations (as they currently do), then\n  // this method will be broken.\n  testSortingAlgorithms() {\n    for (let i = 0; i < 100; i++) {\n      const array = [];\n      const length = randomIntFromInterval(1, 1000);\n      for (let i = 0; i < length; i++) {\n        array.push(randomIntFromInterval(-1000, 1000));\n      }\n      const javaScriptSortedArray = array.slice().sort((a, b) => a - b);\n      const mergeSortedArray = getMergeSortAnimations(array.slice());\n      console.log(arraysAreEqual(javaScriptSortedArray, mergeSortedArray));\n    }\n  }\n\n  render() {\n    const {array} = this.state;\n\n    return (\n      <div className=\"array-container\">\n        {array.map((value, idx) => (\n          <div\n            className=\"array-bar\"\n            key={idx}\n            style={{\n              backgroundColor: PRIMARY_COLOR,\n              height: `${value}px`,\n            }}></div>\n        ))}\n        <button onClick={() => this.resetArray()}>Generate New Array</button>\n        <button onClick={() => this.mergeSort()}>Merge Sort</button>\n        <button onClick={() => this.quickSort()}>Quick Sort</button>\n        <button onClick={() => this.heapSort()}>Heap Sort</button>\n        <button onClick={() => this.bubbleSort()}>Bubble Sort</button>\n        <button onClick={() => this.testSortingAlgorithms()}>\n          Test Sorting Algorithms (BROKEN)\n        </button>\n      </div>\n    );\n  }\n}\n\n// From https://stackoverflow.com/questions/4959975/generate-random-number-between-two-numbers-in-javascript\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction arraysAreEqual(arrayOne, arrayTwo) {\n  if (arrayOne.length !== arrayTwo.length) return false;\n  for (let i = 0; i < arrayOne.length; i++) {\n    if (arrayOne[i] !== arrayTwo[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n'Sorting-Visualizer-Tutorial/src/App.js'\n:import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\nexport default App;\n\n'Sorting-Visualizer-Tutorial/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n\n",
        "called_code_segment_file_1": "mergeSort() {\n    const animations = getMergeSortAnimations(this.state.array);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName('array-bar');\n      const isColorChange = i % 3 !== 2;\n      if (isColorChange) {\n        const [barOneIdx, barTwoIdx] = animations[i];\n        const barOneStyle = arrayBars[barOneIdx].style;\n        const barTwoStyle = arrayBars[barTwoIdx].style;\n        const color = i % 3 === 0 ? SECONDARY_COLOR : PRIMARY_COLOR;\n        setTimeout(() => {\n          barOneStyle.backgroundColor = color;\n          barTwoStyle.backgroundColor = color;\n        }, i * ANIMATION_SPEED_MS);\n      } else {\n        setTimeout(() => {\n          const [barOneIdx, newHeight] = animations[i];\n          const barOneStyle = arrayBars[barOneIdx].style;\n          barOneStyle.height = `${newHeight}px`;\n        }, i * ANIMATION_SPEED_MS);\n      }\n    }\n  }",
        "invoking_code_segment_file_2": "<button onClick={() => this.mergeSort()}>Merge Sort</button>",
        "invoking_code_segment_file_3": "const mergeSortedArray = getMergeSortAnimations(array.slice());",
        "new_file_code_segment": "export function getInsertionSortAnimations(array) {\n  const animations = [];\n  for (let i = 1; i < array.length; i++) {\n    let key = array[i];\n    let j = i - 1;\n    while (j >= 0 && array[j] > key) {\n      animations.push([j + 1, array[j]]);\n      array[j + 1] = array[j];\n      j = j - 1;\n    }\n    animations.push([j + 1, key]);\n    array[j + 1] = key;\n  }\n  return animations;\n}",
        "feature_description": "Add Insertion Sort Algorithm",
        "detailed_feature_description": "The new feature involves adding the Insertion Sort algorithm to the existing sorting visualizer. A new file (#file 4) is created to implement the Insertion Sort algorithm. The SortingVisualizer component is updated to include a new button for Insertion Sort and to invoke the new Insertion Sort function from #file 4. The testSortingAlgorithms method is also updated to include the new Insertion Sort algorithm for testing.",
        "modified_complete_code": {
            "SortingVisualizer.jsx": "#Modify\n  insertionSort() {\n    const animations = getInsertionSortAnimations(this.state.array);\n    for (let i = 0; i < animations.length; i++) {\n      const arrayBars = document.getElementsByClassName('array-bar');\n      setTimeout(() => {\n        const [barIdx, newHeight] = animations[i];\n        const barStyle = arrayBars[barIdx].style;\n        barStyle.height = `${newHeight}px`;\n      }, i * ANIMATION_SPEED_MS);\n    }\n  }\n\n  render() {\n    const {array} = this.state;\n\n    return (\n      <div className=\"array-container\">\n        {array.map((value, idx) => (\n          <div\n            className=\"array-bar\"\n            key={idx}\n            style={{\n              backgroundColor: PRIMARY_COLOR,\n              height: `${value}px`,\n            }}></div>\n        ))}\n        <button onClick={() => this.resetArray()}>Generate New Array</button>\n        <button onClick={() => this.mergeSort()}>Merge Sort</button>\n        <button onClick={() => this.quickSort()}>Quick Sort</button>\n        <button onClick={() => this.heapSort()}>Heap Sort</button>\n        <button onClick={() => this.bubbleSort()}>Bubble Sort</button>\n        <button onClick={() => this.insertionSort()}>Insertion Sort</button>\n        <button onClick={() => this.testSortingAlgorithms()}>\n          Test Sorting Algorithms (BROKEN)\n        </button>\n      </div>\n    );\n  }\n\n#New\nimport {getInsertionSortAnimations} from '../sortingAlgorithms/insertionSort.js';",
            "App.js": "#Modify\nfunction App() {\n  return (\n    <div className=\"App\">\n      <SortingVisualizer></SortingVisualizer>\n    </div>\n  );\n}\n\n#New\nimport './App.css';",
            "index.js": "#Modify\nReactDOM.render(<App />, document.getElementById('root'));\n\n#New\nimport './index.css';",
            "insertionSort.js": "#New\nexport function getInsertionSortAnimations(array) {\n  const animations = [];\n  for (let i = 1; i < array.length; i++) {\n    let key = array[i];\n    let j = i - 1;\n    while (j >= 0 && array[j] > key) {\n      animations.push([j + 1, array[j]]);\n      array[j + 1] = array[j];\n      j = j - 1;\n    }\n    animations.push([j + 1, key]);\n    array[j + 1] = key;\n  }\n  return animations;\n}"
        }
    },
    {
        "repo": "howtocenterincss",
        "content": "'howtocenterincss/js/how/methods/AbsolutePositionMethod.js'\n:/* @flow */\n\nvar Method = require('./Method');\nvar Requirement = require('./Requirement');\nvar Options = require('../Options');\nvar React = require('react');\n\nvar invariant = require('invariant');\n\nvar c = require('../checks');\n\nclass AbsolutePositionMethod extends Method {\n\n  getName(): string {\n    return 'Absolute position the content';\n  }\n\n  getRequirement(): Requirement {\n    return Requirement.all([\n      Requirement.any([\n        Requirement.all([\n          new Requirement(\n            'Content width is known',\n            c.checkContent(c.requireWidthExists)\n          ),\n          new Requirement(\n            'Horizontally center aligned',\n            c.checkHorizontalAlignment(Options.HorizontalAlignment.CENTER)\n          ),\n        ]),\n        new Requirement(\n          'Horizontally left or right aligned',\n          c.checkAnyHorizontalAlignment([\n            Options.HorizontalAlignment.LEFT,\n            Options.HorizontalAlignment.RIGHT,\n          ])\n        ),\n      ]),\n      Requirement.any([\n        Requirement.all([\n          new Requirement(\n            'Content height is known',\n            c.checkContent(c.requireHeightExists)\n          ),\n          new Requirement(\n            'Vertically center aligned',\n            c.checkVerticalAlignment(Options.VerticalAlignment.MIDDLE)\n          ),\n        ]),\n        new Requirement(\n          'Vertically top or bottom aligned',\n          c.checkAnyVerticalAlignment([\n            Options.VerticalAlignment.TOP,\n            Options.VerticalAlignment.BOTTOM,\n          ])\n        ),\n      ]),\n    ]);\n  }\n\n  getCodeElement(\n    content: Options.Content,\n    container: Options.Container,\n    horizontalAlignment: Options.HorizontalAlignment,\n    verticalAlignment: Options.VerticalAlignment,\n    browserSupport: Options.BrowserSupport\n  ): { parent: ReactElement; middle: ?ReactElement; child: mixed; } {\n    var parentStyles = {};\n    parentStyles.position = 'relative';\n\n    var child = this.getContentWithDOM(content, true /*requireBlock*/);\n\n    var childStyles = child.props.style;\n    if (!childStyles) {\n      childStyles = child.props.style = {};\n    }\n    childStyles.position = 'absolute';\n\n    var contentWidth = content.width;\n    var contentHeight = content.height;\n    if (horizontalAlignment === Options.HorizontalAlignment.CENTER) {\n      invariant(contentWidth, 'Require content width');\n      childStyles.left = '50%';\n      childStyles.marginLeft = contentWidth.multiply(-0.5).toString();\n    } else if (horizontalAlignment === Options.HorizontalAlignment.RIGHT) {\n      childStyles.right = '0';\n    }\n\n    if (verticalAlignment === Options.VerticalAlignment.MIDDLE) {\n      invariant(contentHeight, 'Require content height');\n      childStyles.top = '50%';\n      childStyles.marginTop = contentHeight.multiply(-0.5).toString();\n    } else if (verticalAlignment === Options.VerticalAlignment.BOTTOM) {\n      childStyles.bottom = '0';\n    }\n\n    // TODO have to wrap the text in an inner div and extend it to 100% width\n    // in order to center or right align.\n\n    var parent =\n      <div style={parentStyles}>\n        {child}\n      </div>;\n    return { parent: parent, middle: null, child: child };\n  }\n}\n\nmodule.exports = AbsolutePositionMethod;\n\n'howtocenterincss/js/how/findMethod.js'\n:/* @flow */\n\nvar Method = require('./methods/Method');\nvar Options = require('./Options');\nvar DoNothingMethod = require('./methods/DoNothingMethod');\nvar SingleLineTextLineHeightMethod =\n  require('./methods/SingleLineTextLineHeightMethod');\nvar PixelHeightContainerContentPaddingMethod =\n  require('./methods/PixelHeightContainerContentPaddingMethod');\nvar AbsolutePositionMethod = require('./methods/AbsolutePositionMethod');\nvar MarginAutoMethod = require('./methods/MarginAutoMethod');\nvar TableCellMethod = require('./methods/TableCellMethod');\nvar FlexMethod = require('./methods/FlexMethod');\nvar TextAlignMethod = require('./methods/TextAlignMethod');\n\n// This list is in order of preference. The first applicable method should be\n// used, as it's probably simpler.\nvar methods = [\n  new DoNothingMethod,\n  new TextAlignMethod,\n  new SingleLineTextLineHeightMethod(),\n  new MarginAutoMethod(),\n  new PixelHeightContainerContentPaddingMethod(),\n  new FlexMethod,\n  new AbsolutePositionMethod,\n  new TableCellMethod,\n];\n\nfunction findMethod(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): ?Method {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      return method;\n    }\n  }\n  return null;\n}\n\nmodule.exports = findMethod;\n\n'howtocenterincss/js/tests/snapshot.js'\n:/* @flow */\n\nrequire('colors');\nvar _ = require('underscore');\nvar fs = require('fs');\nvar wd = require('wd');\nvar BlinkDiff = require('blink-diff');\nvar PNGImage = require('pngjs-image');\nvar jsStringEscape = require('js-string-escape')\nvar chai = require('chai');\nvar invariant = require('invariant');\nvar tmp = require('tmp');\nvar Q = require('q');\nvar chaiAsPromised = require('chai-as-promised');\nvar findMethod = require('../how/findMethod');\n\nchai.use(chaiAsPromised);\nchai.should();\nchaiAsPromised.transferPromiseness = wd.transferPromiseness;\n\nvar testMatrix = require('./testMatrix');\nvar selenium = require('./selenium');\n\nfunction getReferenceFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getSnapshotName(test) + '.png';\n}\n\nfunction getReferenceTestHTMLFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getTestName(test) + '_test.html';\n}\n\nfunction getReferenceCodeFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getTestName(test) + '.txt';\n}\n\nwd.configureHttp({\n  timeout: 60000,\n  retryDelay: 15000,\n  retries: 5\n});\n\nvar remoteConfig = undefined;\nvar browserMappings;\nif (process.env.SAUCE_USERNAME && process.env.SAUCE_ACCESS_KEY) {\n  remoteConfig = {\n    hostname: 'ondemand.saucelabs.com',\n    port: 80,\n    username: process.env.SAUCE_USERNAME,\n    accessKey: process.env.SAUCE_ACCESS_KEY,\n  };\n  browserMappings = selenium.sauceLabsBrowserMappings;\n} else {\n  browserMappings = selenium.localBrowserMappings;\n}\n\nvar isCreatingSnapshots = !!process.env.CREATE_SNAPSHOTS;\nvar allTests = testMatrix.generateTestsForSeleniumBrowsers(\n  browserMappings\n);\n\n// browser text rendering variances\nvar SCREENSHOT_TOLERANCE = 0.000003;\n\nvar WINDOW_WIDTH = 400;\nvar WINDOW_HEIGHT = 400;\n\nvar css =\n'body, html { margin: 0; padding: 0; overflow: hidden; border: 0; }' +\n'body { font-family: arial; }' +\n// The container sizing will get overridden if the options specify it.\n'#content { background: #f00; width: 25px; height: 25px; }' +\n'#container { background: #0ff; width: 300px; height: 300px; }';\n\nvar fontSizeCSS =\n'body { font-size: ' + testMatrix.fontSize + 'px; }' +\n// By default, the browser has a 1.1-1.2em of line-height. This makes\n// calculating vertical centering different across methods.\n// TODO - this needs to be exposed as a notice to the user, or baked into the\n// code the method generates.\n'#content, #container { line-height: 1em; }' +\n'#content { background: 0 !important; }' +\n// The content sizing will get overridden if the method specifies it.\n'#content { width: auto; height: auto; }';\n\nfunction getOuterDivCSS(width, height) {\n  // For some reason, IE screenshots disregard the height of the body if there is\n  // nothing in it. We need a div to be opaquely white.\n  return '#testOuterDiv { background: white; width: ' + width + 'px; height: ' + height + 'px;}';\n}\n\n// http://www.phpied.com/dynamic-script-and-style-elements-in-ie/\nfunction getJStoInjectCSS(css: string) {\n  return (\n    'var ss1 = document.createElement(\"style\");' +\n    'var def = \"' + jsStringEscape(css) + '\";' +\n    'ss1.setAttribute(\"type\", \"text/css\");' +\n    'var hh1 = document.getElementsByTagName(\"head\")[0];' +\n    'hh1.appendChild(ss1);' +\n    'if (ss1.styleSheet) {' /*IE*/ +\n    '  ss1.styleSheet.cssText = def;' +\n    '} else {' /* errbody else */ +\n    '  var tt1 = document.createTextNode(def);' +\n    '  ss1.appendChild(tt1);' +\n    '}'\n  );\n}\n\nvar useBrowser = isCreatingSnapshots || remoteConfig;\n\nallTests.forEach(seleniumTests => {\n\n  var browser = seleniumTests.seleniumBrowser;\n  var tests = seleniumTests.tests;\n\n  global.suite('using ' + browser.getDisplayName(), () => {\n    var b;\n    var allPassed = true;\n    var windowWidth = WINDOW_WIDTH + browser.cropBoundary.addX;\n    var windowHeight = WINDOW_HEIGHT + browser.cropBoundary.addY;\n\n    global.suiteSetup(done => {\n      if (!useBrowser) {\n        done();\n        return;\n      }\n\n      b = wd.promiseChainRemote(remoteConfig);\n\n      if (process.env.SNAPSHOT_DEBUG) {\n        b.on('status', function(info) {\n            console.log(info.cyan);\n        });\n        b.on('command', function(eventType, command, response) {\n            console.log(' > ' + eventType.cyan, command, (response || '').grey);\n        });\n        b.on('http', function(meth, path, data) {\n            console.log(' > ' + meth.magenta, path, (data || '').grey);\n        });\n      }\n\n      b\n        .init(browser.toSeleniumJSON())\n        .setWindowSize(windowWidth, windowHeight)\n        .elementByTagName('html')\n        .getSize()\n        .then(size => {\n          invariant(b, 'flow');\n          // Browser titles/bars short change you, so set it so the document's\n          // 400x400.\n          return b.setWindowSize(windowWidth + (windowWidth - size.width), windowHeight + (windowHeight - size.height));\n        })\n        .nodeify(done);\n    });\n\n    global.suiteTeardown(done => {\n      if (!b) {\n        done();\n        return;\n      }\n\n      b\n        .quit()\n        .nodeify(done);\n    });\n\n    global.setup(done => {\n      if (!b) {\n        done();\n        return;\n      }\n      b\n        // Get all the browsers to render in as much standards mode as possible.\n        .get('http://dump.oliverzheng.com/doctype_html5.html')\n        .nodeify(done);\n    });\n\n    tests.forEach(t => {\n      var testName = testMatrix.getTestName(t);\n      var mochaTestName =\n        (isCreatingSnapshots ? 'Snapshot ' : 'Compare snapshot ') + testName;\n\n      global.test(mochaTestName, (done) => {\n        var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n        invariant(method, 'flow');\n        method.addIDs();\n        method.setIsTest();\n        var html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n        var canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n\n        var codeGenerated = canonicalCode.html;\n        if (canonicalCode.parentCSS) {\n          codeGenerated += '\\n\\n#parent {\\n' + canonicalCode.parentCSS + '\\n}';\n        }\n        if (canonicalCode.middleCSS) {\n          codeGenerated += '\\n\\n#middle {\\n' + canonicalCode.middleCSS + '\\n}';\n        }\n        if (canonicalCode.childCSS) {\n          codeGenerated += '\\n\\n#child {\\n' + canonicalCode.childCSS + '\\n}';\n        }\n\n        if (!useBrowser) {\n          // We only don't use the browser if we are comparing generated code\n          var referenceCode = fs.readFileSync(getReferenceCodeFilename(t), 'utf8');\n          if (referenceCode !== codeGenerated) {\n            done('Reference code not equal to code generated: ' + codeGenerated);\n          } else {\n            done();\n          }\n          return;\n        }\n\n        var cssToInject = css;\n        if (t.content.text) {\n          cssToInject += fontSizeCSS;\n        }\n\n        cssToInject += getOuterDivCSS(windowWidth, windowHeight);\n        if (isCreatingSnapshots) {\n          fs.writeFileSync(getReferenceCodeFilename(t), codeGenerated);\n        }\n        fs.writeFileSync(getReferenceTestHTMLFilename(t), '<style>' + cssToInject + '</style>' + html);\n\n        invariant(b, 'flow');\n        var insertJS =\n          'document.body.innerHTML = \"' + jsStringEscape('<div id=\"testOuterDiv\">' + html + '</div>') + '\";';\n        // In quirksmode, IE's box model stretches the height to fit the\n        // font-size. We could set 'overflow:hidden' to it, but it could mess\n        // with the actual generated code. So let's conditionally add font size\n        // when we need it.\n        var res =\n          b.execute(getJStoInjectCSS(cssToInject) + insertJS);\n\n        var referenceFilename = getReferenceFilename(t);\n        if (isCreatingSnapshots && !fs.existsSync(referenceFilename)) {\n          // Write the image for the first, compare all the ones after it to\n          // this.\n          res = res.saveScreenshot(referenceFilename);\n        } else {\n          var tmpFilename = tmp.tmpNameSync({\n            // for finding it easier in Finder\n            prefix: 'screenshot-' + Date.now() + '-' + testName + '-',\n            postfix: '.png',\n          });\n          res = res\n            .saveScreenshot(tmpFilename)\n            .then(() => {\n              tmpFilename\n              var blinkDiffOptions = {};\n              blinkDiffOptions.imageAPath = referenceFilename;\n              blinkDiffOptions.thresholdType = BlinkDiff.THRESHOLD_PERCENT;\n              if (browser.hasCropBoundary()) {\n                var image = PNGImage.readImageSync(tmpFilename);\n                image.clip(\n                  browser.cropBoundary.cropX,\n                  browser.cropBoundary.cropY,\n                  WINDOW_WIDTH,\n                  WINDOW_HEIGHT\n                );\n                blinkDiffOptions.imageB = image;\n              } else {\n                blinkDiffOptions.imageBPath = tmpFilename;\n              }\n              var blinkDiff = new BlinkDiff(blinkDiffOptions);\n              return Q.ninvoke(blinkDiff, 'run');\n            })\n            .then(result => {\n              var diff = result.differences / result.dimension;\n              var pass = diff < SCREENSHOT_TOLERANCE;\n              var deferred = Q.defer();\n              if (pass) {\n                fs.unlinkSync(tmpFilename);\n                deferred.resolve(diff);\n              } else {\n                deferred.reject(\n                  tmpFilename +\n                  ' is not equal to reference ' +\n                  referenceFilename +\n                  ', diff: ' + diff +\n                  ', tolerance: ' + SCREENSHOT_TOLERANCE\n                );\n              }\n              return deferred.promise;\n            });\n        }\n        res.nodeify(done);\n      });\n    });\n  });\n});\n\n",
        "called_code_segment_file_1": "class AbsolutePositionMethod extends Method {\n  getCodeElement(content, container, horizontalAlignment, verticalAlignment, browserSupport) {\n    var parentStyles = {};\n    parentStyles.position = 'relative';\n    var child = this.getContentWithDOM(content, true /*requireBlock*/);\n    var childStyles = child.props.style;\n    if (!childStyles) {\n      childStyles = child.props.style = {};\n    }\n    childStyles.position = 'absolute';\n    var contentWidth = content.width;\n    var contentHeight = content.height;\n    if (horizontalAlignment === Options.HorizontalAlignment.CENTER) {\n      invariant(contentWidth, 'Require content width');\n      childStyles.left = '50%';\n      childStyles.marginLeft = contentWidth.multiply(-0.5).toString();\n    } else if (horizontalAlignment === Options.HorizontalAlignment.RIGHT) {\n      childStyles.right = '0';\n    }\n    if (verticalAlignment === Options.VerticalAlignment.MIDDLE) {\n      invariant(contentHeight, 'Require content height');\n      childStyles.top = '50%';\n      childStyles.marginTop = contentHeight.multiply(-0.5).toString();\n    } else if (verticalAlignment === Options.VerticalAlignment.BOTTOM) {\n      childStyles.bottom = '0';\n    }\n    var parent = <div style={parentStyles}>{child}</div>;\n    return { parent: parent, middle: null, child: child };\n  }\n}",
        "invoking_code_segment_file_2": "function findMethod(content, container, horizontalAlignment, verticalAlignment, browserSupport) {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      return method;\n    }\n  }\n  return null;\n}",
        "invoking_code_segment_file_3": "allTests.forEach(seleniumTests => {\n  var browser = seleniumTests.seleniumBrowser;\n  var tests = seleniumTests.tests;\n  tests.forEach(t => {\n    var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n    invariant(method, 'flow');\n    method.addIDs();\n    method.setIsTest();\n    var html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n    var canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n  });\n});",
        "new_file_code_segment": "function getCustomAlignment(content, container, horizontalAlignment, verticalAlignment) {\n  var alignment = {};\n  if (horizontalAlignment === Options.HorizontalAlignment.CENTER) {\n    alignment.left = '50%';\n    alignment.marginLeft = content.width.multiply(-0.5).toString();\n  } else if (horizontalAlignment === Options.HorizontalAlignment.RIGHT) {\n    alignment.right = '0';\n  }\n  if (verticalAlignment === Options.VerticalAlignment.MIDDLE) {\n    alignment.top = '50%';\n    alignment.marginTop = content.height.multiply(-0.5).toString();\n  } else if (verticalAlignment === Options.VerticalAlignment.BOTTOM) {\n    alignment.bottom = '0';\n  }\n  return alignment;\n}",
        "feature_description": "Add a custom alignment function to handle horizontal and vertical alignment more flexibly.",
        "detailed_feature_description": "The new feature introduces a custom alignment function in a new file (#file 4) that handles horizontal and vertical alignment based on the provided content and alignment options. This function is then integrated into the existing code in #file 1 to replace the hardcoded alignment logic. This allows for more flexible and maintainable alignment handling.",
        "modified_complete_code": {
            "file_1": "class AbsolutePositionMethod extends Method {\n  getCodeElement(content, container, horizontalAlignment, verticalAlignment, browserSupport) {\n    var parentStyles = {};\n    parentStyles.position = 'relative';\n    var child = this.getContentWithDOM(content, true /*requireBlock*/);\n    var childStyles = child.props.style;\n    if (!childStyles) {\n      childStyles = child.props.style = {};\n    }\n    childStyles.position = 'absolute';\n    #Modify var alignment = getCustomAlignment(content, container, horizontalAlignment, verticalAlignment);\n    Object.assign(childStyles, alignment);\n    var parent = <div style={parentStyles}>{child}</div>;\n    return { parent: parent, middle: null, child: child };\n  }\n}",
            "file_2": "function findMethod(content, container, horizontalAlignment, verticalAlignment, browserSupport) {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      return method;\n    }\n  }\n  return null;\n}",
            "file_3": "allTests.forEach(seleniumTests => {\n  var browser = seleniumTests.seleniumBrowser;\n  var tests = seleniumTests.tests;\n  tests.forEach(t => {\n    var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n    invariant(method, 'flow');\n    method.addIDs();\n    method.setIsTest();\n    var html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n    var canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n  });\n});",
            "file_4": "#New function getCustomAlignment(content, container, horizontalAlignment, verticalAlignment) {\n  var alignment = {};\n  if (horizontalAlignment === Options.HorizontalAlignment.CENTER) {\n    alignment.left = '50%';\n    alignment.marginLeft = content.width.multiply(-0.5).toString();\n  } else if (horizontalAlignment === Options.HorizontalAlignment.RIGHT) {\n    alignment.right = '0';\n  }\n  if (verticalAlignment === Options.VerticalAlignment.MIDDLE) {\n    alignment.top = '50%';\n    alignment.marginTop = content.height.multiply(-0.5).toString();\n  } else if (verticalAlignment === Options.VerticalAlignment.BOTTOM) {\n    alignment.bottom = '0';\n  }\n  return alignment;\n}"
        }
    },
    {
        "repo": "Ahoy",
        "content": "'Ahoy/src/components/InstalledChart.jsx'\n:import React from 'react';\nimport {\n  Button, Table, Header, Modal, Icon, Accordion, List, Popup,\n} from 'semantic-ui-react';\nimport Version from './Version';\n\nconst util = require('util');\nconst exec = util.promisify(require('child_process').exec);\n\n/** Installed Chart Component */\nconst InstalledChart = (props) => {\n  const {\n    chart, history, toggleHistory, doHelmChartRollBack,\n  } = props;\n  const {\n    app_version, chartName, name, namespace, revision, updated,\n  } = chart;\n\n  // Build detail dropdown\n  const chartDetails = [\n    {\n      key: 'detailKey',\n      title: name,\n      content: {\n        content: (\n          <div className=\"accordian-chart-details\">\n            <List>\n              <List.Item icon=\"clone\" content={`Namespace: ${namespace}`} />\n              <List.Item icon=\"at\" content={`Current App Version: ${app_version}`} />\n              <List.Item icon=\"sort numeric down\" content={`Revision: ${revision}`} />\n              <List.Item icon=\"clock outline\" content={`Last Updated: ${updated}`} />\n            </List>\n          </div>\n        ),\n      },\n    },\n  ];\n\n  // Uninstall the helm chart. saving STDOUT into object not yet implemented\n  const uninstallHelmChart = async () => {\n    const helmChart = chart.name;\n    await exec(`helm uninstall ${helmChart}`);\n    props.getDeployedCharts();\n  };\n\n  // Builds history component array\n  const versionsArray = [];\n  for (let i = 0; i < history.length; i++) {\n    versionsArray.push(\n      <Version\n        key={`key-${i}`}\n        details={history[i]}\n        release={name}\n        doHelmChartRollBack={doHelmChartRollBack}\n      />,\n    );\n  }\n\n  // Render the installed chart component\n  // Component features a dropdown detail and two buttons: the uninstall button and history button\n  // The uninstall button is a Popup component that renders a confirmation button\n  return (\n    <Table.Row>\n      <Table.Cell className=\"installed-chart-cell\">\n        <Table className=\"borderless\">\n          <Table.Body>\n            <Table.Row>\n              <Table.Cell>\n                <Accordion panels={chartDetails} />\n              </Table.Cell>\n              <Table.Cell>\n                <Button\n                  id=\"historyBtn\"\n                  className=\"button-right\"\n                  onClick={() => toggleHistory(name)}\n                  size=\"tiny\"\n                  compact\n                >\n                  History\n                </Button>\n                <Popup\n                  trigger={(\n                    <Button\n                      name=\"uninstall\"\n                      id=\"uninstallBtn\"\n                      className=\"button-right\"\n                      size=\"tiny\"\n                      compact\n                    >\n                      Uninstall\n                    </Button>\n                  )}\n                  content={(\n                    <Button\n                      id=\"uninstallBtnConfirm\"\n                      color=\"red\"\n                      content=\"Confirm Uninstall\"\n                      onClick={() => {\n                        uninstallHelmChart();\n                      }}\n                    />\n                  )}\n                  id=\"confirm\"\n                  on=\"click\"\n                  position=\"top right\"\n                />\n              </Table.Cell>\n            </Table.Row>\n            {versionsArray}\n          </Table.Body>\n        </Table>\n      </Table.Cell>\n    </Table.Row>\n  );\n};\n\nexport default InstalledChart;\n\n'Ahoy/__tests__/enzyme.js'\n:import React from 'react';\nimport { configure, shallow } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\nimport LocalChart from '../src/components/LocalChart';\nimport InstalledChart from '../src/components/InstalledChart';\n\nconfigure({ adapter: new Adapter() });\n\ndescribe('All enzyme tests', () => {\n  let wrapper;\n\n  describe('Local Chart Button Tests', () => {\n    // let wrapper;\n    const props = {\n      chart: {},\n      id: 'id',\n      key: 'keyString1',\n      dirPath: jest.fn(),\n      getDeployedCharts: jest.fn(),\n      handleOpenChartClick: jest.fn(),\n      installHelmChart: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<LocalChart {...props} />);\n    });\n\n    describe('Install Button', () => {\n      it('Should render an install button', () => {\n        expect(wrapper.find('#installBtn')).toHaveLength(1);\n      });\n    });\n    describe('Open Folder Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#openChartBtn').simulate('click');\n        expect(props.handleOpenChartClick).toHaveBeenCalled();\n      });\n    });\n  });\n\n  describe('Installed Chart Button Tests', () => {\n    let wrapper2;\n    const props = {\n      key: {},\n      id: 'id',\n      chart: {},\n      history: {},\n      getDeployedCharts: jest.fn(),\n      toggleHistory: jest.fn(),\n      doHelmChartRollBack: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<InstalledChart {...props} />);\n    });\n\n    describe('Uninstall Popup Button', () => {\n      it('Renders a popup when pressed', () => {\n        wrapper.find('Popup').simulate('click');\n        expect(wrapper.find('#confirm').exists()).toEqual(true);\n      });\n    });\n    describe('History Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#historyBtn').simulate('click');\n        expect(props.toggleHistory).toHaveBeenCalled();\n      });\n    });\n  });\n});\n\n'Ahoy/__tests__/enzyme.test.jsx'\n:import React from 'react';\nimport { configure, shallow } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\n\nimport Version from '../src/components/Version';\n\nconfigure({ adapter: new Adapter() });\n\ndescribe('React unit tests', () => {\n  describe('Version', () => {\n    let wrapper;\n\n    const details = {\n      revision: 7,\n      updated: '2021-05-01T15:37:58.109638-05:00',\n      status: '',\n      chart: 'wordpress-10.10.1',\n      app_version: '5.7.0',\n      description: 'Upgrade complete',\n    };\n    const release = 'chartVersion';\n    const doHelmChartRollBack = jest.fn();\n\n    beforeAll(() => {\n      wrapper = shallow(<Version\n        key={1}\n        details={details}\n        release={release}\n        doHelmChartRollBack={doHelmChartRollBack}\n      />);\n    });\n\n    it('Generates a Semantic UI Table Row', () => {\n      expect(wrapper.find('[data-testid=\"VersionRow\"]')).toHaveLength(1);\n    });\n\n    it('Generates a single cell in the table', () => {\n      expect(wrapper.find('[data-testid=\"tableCell\"]')).toHaveLength(1);\n    });\n\n    it('Generates a primary list', () => {\n      expect(wrapper.find('[data-testid=\"mainList\"]')).toHaveLength(1);\n    });\n\n    describe('Rollback icon', () => {\n      it('Renders a rollback icon if status does not equal \"deployed\"', () => {\n        expect(wrapper.find('[name=\"undo\"]')).toHaveLength(1);\n      });\n\n      it('Calls function when clicked', () => {\n        wrapper.find('[name=\"undo\"]').simulate('click');\n        expect(doHelmChartRollBack).toHaveBeenCalled();\n      });\n    });\n\n    describe('Details list', () => {\n      it('Renders a list with 6 items', () => {\n        const subList = wrapper.find('[data-testid=\"subList\"]');\n        expect(subList).toHaveLength(1);\n        expect(subList.children()).toHaveLength(6);\n      });\n    });\n  });\n});\n\n",
        "called_code_segment_file_1": "const uninstallHelmChart = async () => {\n    const helmChart = chart.name;\n    await exec(`helm uninstall ${helmChart}`);\n    props.getDeployedCharts();\n  };",
        "invoking_code_segment_file_2": "<Popup\n  trigger={(<Button\n    name=\"uninstall\"\n    id=\"uninstallBtn\"\n    className=\"button-right\"\n    size=\"tiny\"\n    compact\n  >\n    Uninstall\n  </Button>)}\n  content={(<Button\n    id=\"uninstallBtnConfirm\"\n    color=\"red\"\n    content=\"Confirm Uninstall\"\n    onClick={() => {\n      uninstallHelmChart();\n    }}\n  />)}\n  id=\"confirm\"\n  on=\"click\"\n  position=\"top right\"\n/>",
        "invoking_code_segment_file_3": "const doHelmChartRollBack = async (release, revision) => {\n  await exec(`helm rollback ${release} ${revision}`);\n  props.getDeployedCharts();\n};",
        "new_file_code_segment": "const confirmUninstall = async (helmChart) => {\n  await exec(`helm uninstall ${helmChart}`);\n  props.getDeployedCharts();\n};\n\nexport default confirmUninstall;",
        "feature_description": "Add a confirmation dialog for uninstalling a Helm chart.",
        "detailed_feature_description": "The new feature introduces a confirmation dialog before uninstalling a Helm chart. This is implemented by creating a new file (#file 4) that contains the `confirmUninstall` function. This function is then invoked from #file 1 instead of the direct `uninstallHelmChart` function. The `uninstallHelmChart` function in #file 1 is modified to call the `confirmUninstall` function from #file 4. The `Popup` component in #file 2 is updated to use the new `confirmUninstall` function. The `doHelmChartRollBack` function in #file 3 remains unchanged as it does not directly interact with the uninstall functionality.",
        "modified_complete_code": {
            "#file 1": "//Modify\nconst uninstallHelmChart = async () => {\n  const helmChart = chart.name;\n  await confirmUninstall(helmChart);\n  props.getDeployedCharts();\n};\n\n//New\nimport confirmUninstall from './confirmUninstall';",
            "#file 2": "//Modify\n<Popup\n  trigger={(<Button\n    name=\"uninstall\"\n    id=\"uninstallBtn\"\n    className=\"button-right\"\n    size=\"tiny\"\n    compact\n  >\n    Uninstall\n  </Button>)}\n  content={(<Button\n    id=\"uninstallBtnConfirm\"\n    color=\"red\"\n    content=\"Confirm Uninstall\"\n    onClick={() => {\n      confirmUninstall(chart.name);\n    }}\n  />)}\n  id=\"confirm\"\n  on=\"click\"\n  position=\"top right\"\n/>",
            "#file 3": "const doHelmChartRollBack = async (release, revision) => {\n  await exec(`helm rollback ${release} ${revision}`);\n  props.getDeployedCharts();\n};",
            "#file 4": "//New\nconst confirmUninstall = async (helmChart) => {\n  await exec(`helm uninstall ${helmChart}`);\n  props.getDeployedCharts();\n};\n\nexport default confirmUninstall;"
        }
    },
    {
        "repo": "ThreeJS-Webpack-ES6-Boilerplate",
        "content": "'ThreeJS-Webpack-ES6-Boilerplate/src/js/app/helpers/vertexNormalsHelper.js'\n:/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nimport {\n  BufferGeometry,\n  Float32BufferAttribute,\n  LineSegments,\n  LineBasicMaterial,\n  Matrix3,\n  Vector3,\n} from 'three';\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _normalMatrix = new Matrix3();\nconst _keys = ['a', 'b', 'c'];\n\nfunction VertexNormalsHelper(object, size, hex) {\n  this.object = object;\n  this.size = size !== undefined ? size : 0.1;\n\n  const color = hex !== undefined ? hex : 0xff0000;\n\n  //\n\n  let nNormals = 0;\n\n  const objGeometry = this.object.geometry;\n\n  if (objGeometry && objGeometry.isGeometry) {\n    nNormals = objGeometry.faces.length * 3;\n  } else if (objGeometry && objGeometry.isBufferGeometry) {\n    nNormals = objGeometry.attributes.normal.count;\n  }\n\n  //\n\n  const geometry = new BufferGeometry();\n  const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\n\n  geometry.setAttribute('position', positions);\n\n  LineSegments.call(this, geometry, new LineBasicMaterial({ color: color, toneMapped: false }));\n\n  this.type = 'VertexNormalsHelper';\n\n  //\n\n  this.matrixAutoUpdate = false;\n\n  this.update();\n}\n\nVertexNormalsHelper.prototype = Object.create(LineSegments.prototype);\nVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\nVertexNormalsHelper.prototype.update = function () {\n  let idx;\n  this.object.updateMatrixWorld(true);\n\n  _normalMatrix.getNormalMatrix(this.object.matrixWorld);\n\n  const matrixWorld = this.object.matrixWorld;\n  const position = this.geometry.attributes.position;\n\n  //\n\n  const objGeometry = this.object.geometry;\n\n  if (objGeometry && objGeometry.isGeometry) {\n    const vertices = objGeometry.vertices;\n\n    const faces = objGeometry.faces;\n\n    idx = 0;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        const vertex = vertices[face[_keys[j]]];\n        const normal = face.vertexNormals[j];\n\n        _v1.copy(vertex).applyMatrix4(matrixWorld);\n        _v2.copy(normal).applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n\n        idx = idx + 1;\n\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n\n        idx = idx + 1;\n      }\n    }\n  } else if (objGeometry && objGeometry.isBufferGeometry) {\n    const objPos = objGeometry.attributes.position;\n    const objNorm = objGeometry.attributes.normal;\n\n    idx = 0;\n\n    // for simplicity, ignore index and drawcalls, and render every normal\n\n    for (var j = 0, jl = objPos.count; j < jl; j++) {\n      _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\n      _v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\n      _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n      position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n\n      idx = idx + 1;\n\n      position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n\n      idx = idx + 1;\n    }\n  }\n\n  position.needsUpdate = true;\n};\n\nexport { VertexNormalsHelper };\n\n'ThreeJS-Webpack-ES6-Boilerplate/src/js/app/helpers/meshHelper.js'\n:import * as THREE from 'three';\nimport { VertexNormalsHelper } from './vertexNormalsHelper';\n\n// Simple mesh helper that shows edges, wireframes, and face and vertex normals\nexport default class MeshHelper {\n  constructor(scene, mesh) {\n    this.mesh = mesh;\n    this.scene = scene;\n\n    const wireframe = new THREE.WireframeGeometry(this.mesh.geometry);\n    this.wireLine = new THREE.LineSegments(wireframe);\n    this.wireLine.material.depthTest = false;\n    this.wireLine.material.opacity = 0.25;\n    this.wireLine.material.transparent = true;\n\n    const edges = new THREE.EdgesGeometry(this.mesh.geometry);\n    this.edgesLine = new THREE.LineSegments(edges);\n    this.edgesLine.material.depthTest = false;\n    this.edgesLine.material.opacity = 0.25;\n    this.edgesLine.material.transparent = true;\n\n    this.vertexHelper = new VertexNormalsHelper(this.mesh, 2);\n    this.boxHelper = new THREE.BoxHelper(this.mesh);\n  }\n\n  enable() {\n    this.mesh.add(this.wireLine);\n    this.mesh.add(this.edgesLine);\n\n    this.scene.add(this.vertexHelper);\n    this.scene.add(this.boxHelper);\n  }\n\n  disable() {\n    this.mesh.remove(this.wireLine);\n    this.mesh.remove(this.edgesLine);\n\n    this.scene.remove(this.vertexHelper);\n    this.scene.remove(this.boxHelper);\n  }\n}\n\n'ThreeJS-Webpack-ES6-Boilerplate/src/js/app/main.js'\n:// Global imports -\nimport * as THREE from 'three';\nimport TWEEN from '@tweenjs/tween.js';\n\n// Local imports -\n// Components\nimport Renderer from './components/renderer';\nimport Camera from './components/camera';\nimport Light from './components/light';\nimport Controls from './components/controls';\nimport Geometry from './components/geometry';\n\n// Helpers\nimport Stats from './helpers/stats';\nimport MeshHelper from './helpers/meshHelper';\n\n// Model\nimport Texture from './model/texture';\nimport Model from './model/model';\n\n// Managers\nimport Interaction from './managers/interaction';\nimport DatGUI from './managers/datGUI';\n\n// data\nimport Config from './../data/config';\n// -- End of imports\n\n// This class instantiates and ties all of the components together, starts the loading process and renders the main loop\nexport default class Main {\n  constructor(container) {\n    // Set container property to container element\n    this.container = container;\n\n    // Start Three clock\n    this.clock = new THREE.Clock();\n\n    // Main scene creation\n    this.scene = new THREE.Scene();\n    this.scene.fog = new THREE.FogExp2(Config.fog.color, Config.fog.near);\n\n    // Get Device Pixel Ratio first for retina\n    if(window.devicePixelRatio) {\n      Config.dpr = window.devicePixelRatio;\n    }\n\n    // Main renderer constructor\n    this.renderer = new Renderer(this.scene, container);\n\n    // Components instantiations\n    this.camera = new Camera(this.renderer.threeRenderer);\n    this.controls = new Controls(this.camera.threeCamera, container);\n    this.light = new Light(this.scene);\n\n    // Create and place lights in scene\n    const lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach((light) => this.light.place(light));\n\n    // Create and place geo in scene\n    this.geometry = new Geometry(this.scene);\n    this.geometry.make('plane')(150, 150, 10, 10);\n    this.geometry.place([0, -20, 0], [Math.PI / 2, 0, 0]);\n\n    // Set up rStats if dev environment\n    if(Config.isDev && Config.isShowingStats) {\n      this.stats = new Stats(this.renderer);\n      this.stats.setUp();\n    }\n\n    // Set up gui\n    if (Config.isDev) {\n      this.gui = new DatGUI(this)\n    }\n\n    // Instantiate texture class\n    this.texture = new Texture();\n\n    // Start loading the textures and then go on to load the model after the texture Promises have resolved\n    this.texture.load().then(() => {\n      this.manager = new THREE.LoadingManager();\n\n      // Textures loaded, load model\n      this.model = new Model(this.scene, this.manager, this.texture.textures);\n      this.model.load(Config.models[Config.model.selected].type);\n\n      // onProgress callback\n      this.manager.onProgress = (item, loaded, total) => {\n        console.log(`${item}: ${loaded} ${total}`);\n      };\n\n      // All loaders done now\n      this.manager.onLoad = () => {\n        // Set up interaction manager with the app now that the model is finished loading\n        new Interaction(this.renderer.threeRenderer, this.scene, this.camera.threeCamera, this.controls.threeControls);\n\n        // Add dat.GUI controls if dev\n        if(Config.isDev) {\n          this.meshHelper = new MeshHelper(this.scene, this.model.obj);\n          if (Config.mesh.enableHelper) this.meshHelper.enable();\n\n          this.gui.load(this, this.model.obj);\n        }\n\n        // Everything is now fully loaded\n        Config.isLoaded = true;\n        this.container.querySelector('#loading').style.display = 'none';\n      };\n    });\n\n    // Start render which does not wait for model fully loaded\n    this.render();\n  }\n\n  render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }\n}\n\n'ThreeJS-Webpack-ES6-Boilerplate/src/js/app.js'\n:import Config from './data/config';\nimport Detector from './utils/detector';\nimport Main from './app/main';\n\n// Styles\nimport './../css/app.scss';\n\n// Check environment and set the Config helper\nif(__ENV__ === 'dev') {\n  console.log('----- RUNNING IN DEV ENVIRONMENT! -----');\n\n  Config.isDev = true;\n}\n\nfunction init() {\n  // Check for webGL capabilities\n  if(!Detector.webgl) {\n    Detector.addGetWebGLMessage();\n  } else {\n    const container = document.getElementById('appContainer');\n    new Main(container);\n  }\n}\n\ninit();\n\n",
        "called_code_segment_file_1": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "invoking_code_segment_file_2": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "called_code_segment_file_2": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "using_code_segment_file_3": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "called_code_segment_file_3": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "using_code_segment_file_4": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "feature_description": "Add a new feature to toggle the visibility of the mesh helper using a key press.",
        "detailed_feature_description": "Modify the Main class to include a key press event listener that toggles the visibility of the mesh helper. Update the Interaction class to handle this event and ensure the mesh helper visibility is toggled accordingly.",
        "modified_complete_code": {
            "file_1": "// Main.js\nimport * as THREE from 'three';\nimport TWEEN from '@tweenjs/tween.js';\n\n// Local imports\n// Components\nimport Renderer from './components/renderer';\nimport Camera from './components/camera';\nimport Light from './components/light';\nimport Controls from './components/controls';\nimport Geometry from './components/geometry';\n\n// Helpers\nimport Stats from './helpers/stats';\nimport MeshHelper from './helpers/meshHelper';\n\n// Model\nimport Texture from './model/texture';\nimport Model from './model/model';\n\n// Managers\nimport Interaction from './managers/interaction';\nimport DatGUI from './managers/datGUI';\n\n// data\nimport Config from './../data/config';\n// -- End of imports\n\n// This class instantiates and ties all of the components together, starts the loading process and renders the main loop\nexport default class Main {\n  constructor(container) {\n    // Set container property to container element\n    this.container = container;\n\n    // Start Three clock\n    this.clock = new THREE.Clock();\n\n    // Main scene creation\n    this.scene = new THREE.Scene();\n    this.scene.fog = new THREE.FogExp2(Config.fog.color, Config.fog.near);\n\n    // Get Device Pixel Ratio first for retina\n    if(window.devicePixelRatio) {\n      Config.dpr = window.devicePixelRatio;\n    }\n\n    // Main renderer constructor\n    this.renderer = new Renderer(this.scene, container);\n\n    // Components instantiations\n    this.camera = new Camera(this.renderer.threeRenderer);\n    this.controls = new Controls(this.camera.threeCamera, container);\n    this.light = new Light(this.scene);\n\n    // Create and place lights in scene\n    const lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach((light) => this.light.place(light));\n\n    // Create and place geo in scene\n    this.geometry = new Geometry(this.scene);\n    this.geometry.make('plane')(150, 150, 10, 10);\n    this.geometry.place([0, -20, 0], [Math.PI / 2, 0, 0]);\n\n    // Set up rStats if dev environment\n    if(Config.isDev && Config.isShowingStats) {\n      this.stats = new Stats(this.renderer);\n      this.stats.setUp();\n    }\n\n    // Set up gui\n    if (Config.isDev) {\n      this.gui = new DatGUI(this)\n    }\n\n    // Instantiate texture class\n    this.texture = new Texture();\n\n    // Start loading the textures and then go on to load the model after the texture Promises have resolved\n    this.texture.load().then(() => {\n      this.manager = new THREE.LoadingManager();\n\n      // Textures loaded, load model\n      this.model = new Model(this.scene, this.manager, this.texture.textures);\n      this.model.load(Config.models[Config.model.selected].type);\n\n      // onProgress callback\n      this.manager.onProgress = (item, loaded, total) => {\n        console.log(`${item}: ${loaded} ${total}`);\n      };\n\n      // All loaders done now\n      this.manager.onLoad = () => {\n        // Set up interaction manager with the app now that the model is finished loading\n        new Interaction(this.renderer.threeRenderer, this.scene, this.camera.threeCamera, this.controls.threeControls);\n\n        // Add dat.GUI controls if dev\n        if(Config.isDev) {\n          this.meshHelper = new MeshHelper(this.scene, this.model.obj);\n          if (Config.mesh.enableHelper) this.meshHelper.enable();\n\n          this.gui.load(this, this.model.obj);\n        }\n\n        // Everything is now fully loaded\n        Config.isLoaded = true;\n        this.container.querySelector('#loading').style.display = 'none';\n      };\n    });\n\n    // Start render which does not wait for model fully loaded\n    this.render();\n\n    // #Modify: Add key press event listener to toggle mesh helper visibility\n    window.addEventListener('keydown', (event) => {\n      if (event.key === 'h') {\n        if (this.meshHelper) {\n          if (this.meshHelper.enabled) {\n            this.meshHelper.disable();\n          } else {\n            this.meshHelper.enable();\n          }\n        }\n      }\n    });\n  }\n\n  render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }\n}",
            "file_2": "// Interaction.js\nimport * as THREE from 'three';\n\n// Managers\nimport Config from './../data/config';\n\n// This class handles all interaction methods\nexport default class Interaction {\n  constructor(renderer, scene, camera, controls) {\n    this.renderer = renderer;\n    this.scene = scene;\n    this.camera = camera;\n    this.controls = controls;\n\n    // Set up pointer lock and mouse events\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n\n    // Add event listeners\n    this.renderer.domElement.addEventListener('mousedown', this.handleMouseDown);\n    this.renderer.domElement.addEventListener('mouseup', this.handleMouseUp);\n    this.renderer.domElement.addEventListener('mousemove', this.handleMouseMove);\n  }\n\n  handleMouseDown(event) {\n    // Handle mouse down event\n  }\n\n  handleMouseUp(event) {\n    // Handle mouse up event\n  }\n\n  handleMouseMove(event) {\n    // Handle mouse move event\n  }\n\n  // #Modify: Add method to toggle mesh helper visibility\n  toggleMeshHelper(meshHelper) {\n    if (meshHelper) {\n      if (meshHelper.enabled) {\n        meshHelper.disable();\n      } else {\n        meshHelper.enable();\n      }\n    }\n  }\n}",
            "file_3": "// MeshHelper.js\nimport * as THREE from 'three';\nimport { VertexNormalsHelper } from './vertexNormalsHelper';\n\n// Simple mesh helper that shows edges, wireframes, and face and vertex normals\nexport default class MeshHelper {\n  constructor(scene, mesh) {\n    this.mesh = mesh;\n    this.scene = scene;\n\n    const wireframe = new THREE.WireframeGeometry(this.mesh.geometry);\n    this.wireLine = new THREE.LineSegments(wireframe);\n    this.wireLine.material.depthTest = false;\n    this.wireLine.material.opacity = 0.25;\n    this.wireLine.material.transparent = true;\n\n    const edges = new THREE.EdgesGeometry(this.mesh.geometry);\n    this.edgesLine = new THREE.LineSegments(edges);\n    this.edgesLine.material.depthTest = false;\n    this.edgesLine.material.opacity = 0.25;\n    this.edgesLine.material.transparent = true;\n\n    this.vertexHelper = new VertexNormalsHelper(this.mesh, 2);\n    this.boxHelper = new THREE.BoxHelper(this.mesh);\n\n    // #New: Add enabled property\n    this.enabled = false;\n  }\n\n  enable() {\n    this.mesh.add(this.wireLine);\n    this.mesh.add(this.edgesLine);\n\n    this.scene.add(this.vertexHelper);\n    this.scene.add(this.boxHelper);\n\n    // #New: Set enabled property to true\n    this.enabled = true;\n  }\n\n  disable() {\n    this.mesh.remove(this.wireLine);\n    this.mesh.remove(this.edgesLine);\n\n    this.scene.remove(this.vertexHelper);\n    this.scene.remove(this.boxHelper);\n\n    // #New: Set enabled property to false\n    this.enabled = false;\n  }\n}",
            "file_4": "// DatGUI.js\nimport * as dat from 'dat.gui';\n\n// Managers\nimport Config from './../data/config';\n\n// This class handles dat.GUI interactions\nexport default class DatGUI {\n  constructor(main) {\n    this.main = main;\n    this.gui = new dat.GUI();\n  }\n\n  load(main, model) {\n    // Add dat.GUI controls\n    const controls = {\n      toggleMeshHelper: () => {\n        main.interaction.toggleMeshHelper(main.meshHelper);\n      }\n    };\n\n    this.gui.add(controls, 'toggleMeshHelper').name('Toggle Mesh Helper');\n  }\n}"
        }
    },
    {
        "repo": "Ahoy",
        "content": "'Ahoy/src/components/Version.jsx'\n:import React from 'react';\nimport {\n  Table, List, Icon,\n} from 'semantic-ui-react';\n\n/** Chart Version History Component */\nfunction Version(props) {\n  const { details, release, doHelmChartRollBack } = props;\n  const {\n    app_version, chart, description, revision, status, updated,\n  } = details;\n\n  return (\n    <Table.Row className=\"installed-chart-detail\" data-testid=\"VersionRow\">\n      <Table.Cell data-testid=\"tableCell\" colSpan=\"2\" className=\"installed-chart-detail\">\n        <List data-testid=\"mainList\">\n          <List.Item>\n            <List.List data-testid=\"subList\">\n              <List.Item>\n                <div>\n                  <strong>Version:</strong>\n                  {app_version}\n                  {status === 'deployed' ? <i> current</i>\n                    : (\n                      <Icon\n                        name=\"undo\"\n                        link\n                        size=\"small\"\n                        color=\"orange\"\n                        onClick={() => doHelmChartRollBack(release, revision)}\n                      />\n                    )}\n                </div>\n              </List.Item>\n              <List.Item icon=\"chart line\" content={`Chart: ${chart}`} />\n              <List.Item icon=\"sticky note outline\" content={`Description: ${description}`} />\n              <List.Item icon=\"star\" content={`Status: ${status}`} />\n              <List.Item icon=\"sort numeric down\" content={`Revision: ${revision}`} />\n              <List.Item icon=\"clock outline\" content={`Updated: ${updated}`} />\n            </List.List>\n          </List.Item>\n        </List>\n      </Table.Cell>\n    </Table.Row>\n  );\n}\n\nexport default Version;\n\n'Ahoy/src/components/InstalledChart.jsx'\n:import React from 'react';\nimport {\n  Button, Table, Header, Modal, Icon, Accordion, List, Popup,\n} from 'semantic-ui-react';\nimport Version from './Version';\n\nconst util = require('util');\nconst exec = util.promisify(require('child_process').exec);\n\n/** Installed Chart Component */\nconst InstalledChart = (props) => {\n  const {\n    chart, history, toggleHistory, doHelmChartRollBack,\n  } = props;\n  const {\n    app_version, chartName, name, namespace, revision, updated,\n  } = chart;\n\n  // Build detail dropdown\n  const chartDetails = [\n    {\n      key: 'detailKey',\n      title: name,\n      content: {\n        content: (\n          <div className=\"accordian-chart-details\">\n            <List>\n              <List.Item icon=\"clone\" content={`Namespace: ${namespace}`} />\n              <List.Item icon=\"at\" content={`Current App Version: ${app_version}`} />\n              <List.Item icon=\"sort numeric down\" content={`Revision: ${revision}`} />\n              <List.Item icon=\"clock outline\" content={`Last Updated: ${updated}`} />\n            </List>\n          </div>\n        ),\n      },\n    },\n  ];\n\n  // Uninstall the helm chart. saving STDOUT into object not yet implemented\n  const uninstallHelmChart = async () => {\n    const helmChart = chart.name;\n    await exec(`helm uninstall ${helmChart}`);\n    props.getDeployedCharts();\n  };\n\n  // Builds history component array\n  const versionsArray = [];\n  for (let i = 0; i < history.length; i++) {\n    versionsArray.push(\n      <Version\n        key={`key-${i}`}\n        details={history[i]}\n        release={name}\n        doHelmChartRollBack={doHelmChartRollBack}\n      />,\n    );\n  }\n\n  // Render the installed chart component\n  // Component features a dropdown detail and two buttons: the uninstall button and history button\n  // The uninstall button is a Popup component that renders a confirmation button\n  return (\n    <Table.Row>\n      <Table.Cell className=\"installed-chart-cell\">\n        <Table className=\"borderless\">\n          <Table.Body>\n            <Table.Row>\n              <Table.Cell>\n                <Accordion panels={chartDetails} />\n              </Table.Cell>\n              <Table.Cell>\n                <Button\n                  id=\"historyBtn\"\n                  className=\"button-right\"\n                  onClick={() => toggleHistory(name)}\n                  size=\"tiny\"\n                  compact\n                >\n                  History\n                </Button>\n                <Popup\n                  trigger={(\n                    <Button\n                      name=\"uninstall\"\n                      id=\"uninstallBtn\"\n                      className=\"button-right\"\n                      size=\"tiny\"\n                      compact\n                    >\n                      Uninstall\n                    </Button>\n                  )}\n                  content={(\n                    <Button\n                      id=\"uninstallBtnConfirm\"\n                      color=\"red\"\n                      content=\"Confirm Uninstall\"\n                      onClick={() => {\n                        uninstallHelmChart();\n                      }}\n                    />\n                  )}\n                  id=\"confirm\"\n                  on=\"click\"\n                  position=\"top right\"\n                />\n              </Table.Cell>\n            </Table.Row>\n            {versionsArray}\n          </Table.Body>\n        </Table>\n      </Table.Cell>\n    </Table.Row>\n  );\n};\n\nexport default InstalledChart;\n\n'Ahoy/__tests__/enzyme.js'\n:import React from 'react';\nimport { configure, shallow } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\nimport LocalChart from '../src/components/LocalChart';\nimport InstalledChart from '../src/components/InstalledChart';\n\nconfigure({ adapter: new Adapter() });\n\ndescribe('All enzyme tests', () => {\n  let wrapper;\n\n  describe('Local Chart Button Tests', () => {\n    // let wrapper;\n    const props = {\n      chart: {},\n      id: 'id',\n      key: 'keyString1',\n      dirPath: jest.fn(),\n      getDeployedCharts: jest.fn(),\n      handleOpenChartClick: jest.fn(),\n      installHelmChart: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<LocalChart {...props} />);\n    });\n\n    describe('Install Button', () => {\n      it('Should render an install button', () => {\n        expect(wrapper.find('#installBtn')).toHaveLength(1);\n      });\n    });\n    describe('Open Folder Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#openChartBtn').simulate('click');\n        expect(props.handleOpenChartClick).toHaveBeenCalled();\n      });\n    });\n  });\n\n  describe('Installed Chart Button Tests', () => {\n    let wrapper2;\n    const props = {\n      key: {},\n      id: 'id',\n      chart: {},\n      history: {},\n      getDeployedCharts: jest.fn(),\n      toggleHistory: jest.fn(),\n      doHelmChartRollBack: jest.fn(),\n    };\n\n    beforeAll(() => {\n      wrapper = shallow(<InstalledChart {...props} />);\n    });\n\n    describe('Uninstall Popup Button', () => {\n      it('Renders a popup when pressed', () => {\n        wrapper.find('Popup').simulate('click');\n        expect(wrapper.find('#confirm').exists()).toEqual(true);\n      });\n    });\n    describe('History Button', () => {\n      it('Should execute passed in function when clicked', () => {\n        wrapper.find('#historyBtn').simulate('click');\n        expect(props.toggleHistory).toHaveBeenCalled();\n      });\n    });\n  });\n});\n\n'Ahoy/__tests__/enzyme.test.jsx'\n:import React from 'react';\nimport { configure, shallow } from 'enzyme';\nimport Adapter from 'enzyme-adapter-react-16';\n\nimport Version from '../src/components/Version';\n\nconfigure({ adapter: new Adapter() });\n\ndescribe('React unit tests', () => {\n  describe('Version', () => {\n    let wrapper;\n\n    const details = {\n      revision: 7,\n      updated: '2021-05-01T15:37:58.109638-05:00',\n      status: '',\n      chart: 'wordpress-10.10.1',\n      app_version: '5.7.0',\n      description: 'Upgrade complete',\n    };\n    const release = 'chartVersion';\n    const doHelmChartRollBack = jest.fn();\n\n    beforeAll(() => {\n      wrapper = shallow(<Version\n        key={1}\n        details={details}\n        release={release}\n        doHelmChartRollBack={doHelmChartRollBack}\n      />);\n    });\n\n    it('Generates a Semantic UI Table Row', () => {\n      expect(wrapper.find('[data-testid=\"VersionRow\"]')).toHaveLength(1);\n    });\n\n    it('Generates a single cell in the table', () => {\n      expect(wrapper.find('[data-testid=\"tableCell\"]')).toHaveLength(1);\n    });\n\n    it('Generates a primary list', () => {\n      expect(wrapper.find('[data-testid=\"mainList\"]')).toHaveLength(1);\n    });\n\n    describe('Rollback icon', () => {\n      it('Renders a rollback icon if status does not equal \"deployed\"', () => {\n        expect(wrapper.find('[name=\"undo\"]')).toHaveLength(1);\n      });\n\n      it('Calls function when clicked', () => {\n        wrapper.find('[name=\"undo\"]').simulate('click');\n        expect(doHelmChartRollBack).toHaveBeenCalled();\n      });\n    });\n\n    describe('Details list', () => {\n      it('Renders a list with 6 items', () => {\n        const subList = wrapper.find('[data-testid=\"subList\"]');\n        expect(subList).toHaveLength(1);\n        expect(subList.children()).toHaveLength(6);\n      });\n    });\n  });\n});\n\n",
        "called_code_segment_file_1": "function Version(props) {\n  const { details, release, doHelmChartRollBack } = props;\n  const { app_version, chart, description, revision, status, updated } = details;\n  return (\n    <Table.Row className=\"installed-chart-detail\" data-testid=\"VersionRow\">\n      <Table.Cell data-testid=\"tableCell\" colSpan=\"2\" className=\"installed-chart-detail\">\n        <List data-testid=\"mainList\">\n          <List.Item>\n            <List.List data-testid=\"subList\">\n              <List.Item>\n                <div>\n                  <strong>Version:</strong>\n                  {app_version}\n                  {status === 'deployed' ? <i> current</i>\n                    : (\n                      <Icon\n                        name=\"undo\"\n                        link\n                        size=\"small\"\n                        color=\"orange\"\n                        onClick={() => doHelmChartRollBack(release, revision)}\n                      />\n                    )}\n                </div>\n              </List.Item>\n              <List.Item icon=\"chart line\" content={`Chart: ${chart}`} />\n              <List.Item icon=\"sticky note outline\" content={`Description: ${description}`} />\n              <List.Item icon=\"star\" content={`Status: ${status}`} />\n              <List.Item icon=\"sort numeric down\" content={`Revision: ${revision}`} />\n              <List.Item icon=\"clock outline\" content={`Updated: ${updated}`} />\n            </List.List>\n          </List.Item>\n        </List>\n      </Table.Cell>\n    </Table.Row>\n  );\n}",
        "invoking_code_segment_file_2": "const versionsArray = [];\nfor (let i = 0; i < history.length; i++) {\n  versionsArray.push(\n    <Version\n      key={`key-${i}`}\n      details={history[i]}\n      release={name}\n      doHelmChartRollBack={doHelmChartRollBack}\n    />,\n  );\n}",
        "called_code_segment_file_2": "const uninstallHelmChart = async () => {\n  const helmChart = chart.name;\n  await exec(`helm uninstall ${helmChart}`);\n  props.getDeployedCharts();\n};",
        "using_code_segment_file_3": "const props = {\n  chart: {},\n  id: 'id',\n  key: 'keyString1',\n  dirPath: jest.fn(),\n  getDeployedCharts: jest.fn(),\n  handleOpenChartClick: jest.fn(),\n  installHelmChart: jest.fn(),\n};",
        "called_code_segment_file_3": "const props = {\n  key: {},\n  id: 'id',\n  chart: {},\n  history: {},\n  getDeployedCharts: jest.fn(),\n  toggleHistory: jest.fn(),\n  doHelmChartRollBack: jest.fn(),\n};",
        "using_code_segment_file_4": "const details = {\n  revision: 7,\n  updated: '2021-05-01T15:37:58.109638-05:00',\n  status: '',\n  chart: 'wordpress-10.10.1',\n  app_version: '5.7.0',\n  description: 'Upgrade complete',\n};\nconst release = 'chartVersion';\nconst doHelmChartRollBack = jest.fn();",
        "feature_description": "Add a confirmation modal for the rollback action in the Version component.",
        "detailed_feature_description": "The new feature introduces a confirmation modal for the rollback action in the Version component. When the rollback icon is clicked, a modal will appear asking the user to confirm the rollback. This modal will be implemented using the Semantic UI Modal component. The Version component will be updated to handle this modal, and the InstalledChart component will need to be updated to pass the necessary props to the Version component. The LocalChart and InstalledChart components will also be updated to ensure compatibility with the new feature.",
        "modified_complete_code": {
            "Ahoy/src/components/Version.jsx": "function Version(props) {\n  const { details, release, doHelmChartRollBack } = props;\n  const { app_version, chart, description, revision, status, updated } = details;\n\n  const [open, setOpen] = React.useState(false);\n\n  return (\n    <Table.Row className=\"installed-chart-detail\" data-testid=\"VersionRow\">\n      <Table.Cell data-testid=\"tableCell\" colSpan=\"2\" className=\"installed-chart-detail\">\n        <List data-testid=\"mainList\">\n          <List.Item>\n            <List.List data-testid=\"subList\">\n              <List.Item>\n                <div>\n                  <strong>Version:</strong>\n                  {app_version}\n                  {status === 'deployed' ? <i> current</i>\n                    : (\n                      <Icon\n                        name=\"undo\"\n                        link\n                        size=\"small\"\n                        color=\"orange\"\n                        onClick={() => setOpen(true)}\n                      />\n                    )}\n                </div>\n              </List.Item>\n              <List.Item icon=\"chart line\" content={`Chart: ${chart}`} />\n              <List.Item icon=\"sticky note outline\" content={`Description: ${description}`} />\n              <List.Item icon=\"star\" content={`Status: ${status}`} />\n              <List.Item icon=\"sort numeric down\" content={`Revision: ${revision}`} />\n              <List.Item icon=\"clock outline\" content={`Updated: ${updated}`} />\n            </List.List>\n          </List.Item>\n        </List>\n        <Modal\n          open={open}\n          onClose={() => setOpen(false)}\n          onOpen={() => setOpen(true)}\n        >\n          <Modal.Header>Confirm Rollback</Modal.Header>\n          <Modal.Content>\n            <p>Are you sure you want to rollback to revision {revision}?</p>\n          </Modal.Content>\n          <Modal.Actions>\n            <Button negative onClick={() => setOpen(false)}>No</Button>\n            <Button positive onClick={() => { doHelmChartRollBack(release, revision); setOpen(false); }}>Yes</Button>\n          </Modal.Actions>\n        </Modal>\n      </Table.Cell>\n    </Table.Row>\n  );\n}",
            "Ahoy/src/components/InstalledChart.jsx": "const versionsArray = [];\nfor (let i = 0; i < history.length; i++) {\n  versionsArray.push(\n    <Version\n      key={`key-${i}`}\n      details={history[i]}\n      release={name}\n      doHelmChartRollBack={doHelmChartRollBack}\n    />,\n  );\n}",
            "Ahoy/__tests__/enzyme.js": "const props = {\n  chart: {},\n  id: 'id',\n  key: 'keyString1',\n  dirPath: jest.fn(),\n  getDeployedCharts: jest.fn(),\n  handleOpenChartClick: jest.fn(),\n  installHelmChart: jest.fn(),\n};",
            "Ahoy/__tests__/enzyme.test.jsx": "const details = {\n  revision: 7,\n  updated: '2021-05-01T15:37:58.109638-05:00',\n  status: '',\n  chart: 'wordpress-10.10.1',\n  app_version: '5.7.0',\n  description: 'Upgrade complete',\n};\nconst release = 'chartVersion';\nconst doHelmChartRollBack = jest.fn();"
        }
    },
    {
        "repo": "nextjs-client-auth-architectures",
        "content": "'nextjs-client-auth-architectures/ssr/src/providers/Auth.js'\n:import React from 'react';\n\nconst AuthContext = React.createContext({\n  isAuthenticated: false,\n  setAuthenticated: () => {}\n});\n\n/**\n * The initial value of `isAuthenticated` comes from the `authenticated`\n * prop which gets set by _app. We store that value in state and ignore\n * the prop from then on. The value can be changed by calling the\n * `setAuthenticated()` method in the context.\n */\nexport const AuthProvider = ({ children, authenticated }) => {\n  const [isAuthenticated, setAuthenticated] = React.useState(authenticated);\n  return (\n    <AuthContext.Provider\n      value={{\n        isAuthenticated,\n        setAuthenticated\n      }}\n    >\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\nexport function useAuth() {\n  const context = React.useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider');\n  }\n  return context;\n}\n\nexport function useIsAuthenticated() {\n  const context = useAuth();\n  return context.isAuthenticated;\n}\n\n'nextjs-client-auth-architectures/ssr/src/components/Header.js'\n:import Link from 'next/link';\nimport { useIsAuthenticated } from '../providers/Auth';\n\nexport default function Header() {\n  const isAuthenticated = useIsAuthenticated();\n  return (\n    <header>\n      <Link href=\"/\">\n        <a>Home</a>\n      </Link>{' '}\n      |{' '}\n      {isAuthenticated ? (\n        <>\n          <Link href=\"/profile\">\n            <a>Profile</a>\n          </Link>{' '}\n          |{' '}\n          <Link href=\"/logout\">\n            <a>Logout</a>\n          </Link>\n        </>\n      ) : (\n        <Link href=\"/login\">\n          <a>Login</a>\n        </Link>\n      )}\n      <hr />\n    </header>\n  );\n}\n\n'nextjs-client-auth-architectures/ssr/src/components/Layout.js'\n:import Header from './Header';\n\nexport default function Layout({ children }) {\n  return (\n    <>\n      <Header />\n      <main>{children}</main>\n    </>\n  );\n}\n\n'nextjs-client-auth-architectures/ssr/src/pages/profile.js'\n:import Layout from '../components/Layout';\nimport withAuth from '../hocs/withAuth';\n\nexport default withAuth(function Profile() {\n  return (\n    <Layout>\n      <h1>Profile</h1>\n    </Layout>\n  );\n});\n\n",
        "called_code_segment_file_1": "export function useIsAuthenticated() {\n  const context = useAuth();\n  return context.isAuthenticated;\n}",
        "invoking_code_segment_file_2": "export default function Header() {\n  const isAuthenticated = useIsAuthenticated();\n  return (\n    <header>\n      <Link href=\"/\">\n        <a>Home</a>\n      </Link>{' '}\n      |{' '}\n      {isAuthenticated ? (\n        <>\n          <Link href=\"/profile\">\n            <a>Profile</a>\n          </Link>{' '}\n          |{' '}\n          <Link href=\"/logout\">\n            <a>Logout</a>\n          </Link>\n        </>\n      ) : (\n        <Link href=\"/login\">\n          <a>Login</a>\n        </Link>\n      )}\n      <hr />\n    </header>\n  );\n}",
        "called_code_segment_file_2": "export default function Header() {\n  const isAuthenticated = useIsAuthenticated();\n  return (\n    <header>\n      <Link href=\"/\">\n        <a>Home</a>\n      </Link>{' '}\n      |{' '}\n      {isAuthenticated ? (\n        <>\n          <Link href=\"/profile\">\n            <a>Profile</a>\n          </Link>{' '}\n          |{' '}\n          <Link href=\"/logout\">\n            <a>Logout</a>\n          </Link>\n        </>\n      ) : (\n        <Link href=\"/login\">\n          <a>Login</a>\n        </Link>\n      )}\n      <hr />\n    </header>\n  );\n}",
        "using_code_segment_file_3": "export default withAuth(function Profile() {\n  return (\n    <Layout>\n      <h1>Profile</h1>\n    </Layout>\n  );\n});",
        "called_code_segment_file_3": "",
        "using_code_segment_file_4": "",
        "feature_description": "Add a feature to display the user's name in the Header if authenticated.",
        "detailed_feature_description": "Modify the useIsAuthenticated function in #file 1 to return both the authentication status and the user's name. Update #file 2 to handle the new return values and display the user's name if authenticated. Ensure #file 3 and #file 4 are updated if they depend on the modified segments.",
        "modified_complete_code": {
            "file_1": "//Modify\nexport function useIsAuthenticated() {\n  const context = useAuth();\n  return {\n    isAuthenticated: context.isAuthenticated,\n    userName: context.userName || 'Guest'\n  };\n}",
            "file_2": "//Modify\nexport default function Header() {\n  const { isAuthenticated, userName } = useIsAuthenticated();\n  return (\n    <header>\n      <Link href=\"/\">\n        <a>Home</a>\n      </Link>{' '}\n      |{' '}\n      {isAuthenticated ? (\n        <>\n          <span>Welcome, {userName}!</span>{' '}\n          |{' '}\n          <Link href=\"/profile\">\n            <a>Profile</a>\n          </Link>{' '}\n          |{' '}\n          <Link href=\"/logout\">\n            <a>Logout</a>\n          </Link>\n        </>\n      ) : (\n        <Link href=\"/login\">\n          <a>Login</a>\n        </Link>\n      )}\n      <hr />\n    </header>\n  );\n}",
            "file_3": "export default withAuth(function Profile() {\n  return (\n    <Layout>\n      <h1>Profile</h1>\n    </Layout>\n  );\n});",
            "file_4": ""
        }
    },
    {
        "repo": "better-onetab",
        "content": "'better-onetab/src/common/utils.js'\n:import _ from 'lodash'\nimport __ from './i18n'\nimport moment from 'moment'\nimport {COLORS} from './constants'\nimport browser from 'webextension-polyfill'\n\nmoment.locale(__('@@ui_locale'))\nexport const formatTime = time => {\n  if (Date.now() - time < 3600E3) return moment(time).fromNow()\n\n  const withYear = !moment(time).isSame(new Date(), 'year')\n  return moment(time).format(`ddd, MMMM Do ${withYear ? 'YYYY' : ''}, kk:mm:ss`)\n}\nexport const one = fn => {\n  let executing = false\n  return async function onceAtSameTimeFunction(...args) {\n    if (executing) return\n    executing = true\n    let re\n    try {\n      re = await fn.apply(this, args) // eslint-disable-line\n    } catch (error) {\n      throw error\n    } finally {\n      executing = false\n    }\n    return re\n  }\n}\nexport const checkPermission = async permission => {\n  if (await browser.permissions.contains({permissions: [permission]})) return true\n  return browser.permissions.request({permissions: [permission]})\n}\nexport const readFile = file => new Promise((resolve, reject) => {\n  const reader = new FileReader()\n  reader.onloadend = event => resolve(event.target.result)\n  reader.onerror = reject\n  reader.readAsText(file)\n})\nexport const genObjectId = () => {\n  // refer: https://gist.github.com/solenoid/1372386\n  const timestamp = (new Date().getTime() / 1000 | 0).toString(16)\n  return timestamp + 'xxxxxxxxxxxxxxxx'.replace(/[x]/g, () => (Math.random() * 16 | 0).toString(16)).toLowerCase()\n}\nexport const isBackground = async () => {\n  if (window._isBackground == null) window._isBackground = window === await browser.runtime.getBackgroundPage()\n  return window._isBackground\n}\nexport const formatSize = bytes => {\n  // refer: https://stackoverflow.com/questions/10420352/converting-file-size-in-bytes-to-human-readable-string\n  const sufixes = ['Bytes', 'KB', 'MB', 'GB']\n  const i = Math.floor(Math.log(bytes) / Math.log(1024))\n  return !bytes && '0 Bytes' || (bytes / Math.pow(1024, i)).toFixed(2) + ' ' + sufixes[i]\n}\nexport const sleep = ms => new Promise(r => setTimeout(r, ms))\n\nexport const getColorByHash = _.memoize(str => {\n  const hash = typeof str === 'string' ? str.split('').reduce((r, i) => i.charCodeAt(0) + r, 0) : 0\n  return COLORS[hash % COLORS.length]\n})\n\nexport const timeout = (promise, ms) => Promise.race([\n  promise, new Promise((resolve, reject) => setTimeout(() => {\n    reject(new Error('promise timeout'))\n  }, ms))\n])\n\nexport const compareVersion = (a, b) => {\n  if (a === b) return 0\n  const [ap, bp] = [a, b].map(i => i || '0').map(i => i.split('.').map(j => +j))\n  const len = Math.min(ap.length, bp.length)\n  for (let i = 0; i < len; i += 1) {\n    if (ap[i] !== bp[i]) return ap[i] - bp[i]\n  }\n  return ap.length - bp.length\n}\n\nexport const sendMessage = async msg => {\n  try {\n    await browser.runtime.sendMessage(msg)\n  } catch (err) {\n    if (err.message === 'Could not establish connection. Receiving end does not exist.') {\n      return console.warn('error ignored', err.message)\n    }\n    throw err\n  }\n}\n\n/**\n * this a helper function like Lodash.throttle but could be used for async function\n * and the function will be restricted (cannot be executed concurrently)\n *\n * @param {Function} fn\n * @param {Number} ms\n */\nexport const throttle = (fn, ms) => {\n  let executing\n  let next\n  let nextArgs\n  let timeout\n  let lastTime // actual execute time\n  return async function throttled(...args) {\n    const now = Date.now()\n    if (now - lastTime < ms) {\n      next = true\n      nextArgs = args\n      if (timeout) clearTimeout(timeout)\n      timeout = setTimeout(() => {\n        throttled(...args)\n      })\n      return\n    }\n\n    // ignore this called and retry after the function finished if it is executing\n    if (executing) {\n      next = true\n      nextArgs = args\n      return\n    }\n\n    // set the status when the function executed actually\n    executing = true\n    lastTime = now\n\n    let re // save the result of function\n    try {\n      re = await fn.apply(this, args) // eslint-disable-line\n    } catch (error) {\n      throw error\n    } finally {\n      executing = false\n      if (next) {\n        if (Date.now() - now > ms) {\n          next = false\n          if (timeout) clearTimeout(timeout)\n          throttled(...nextArgs)\n        }\n      }\n    }\n    return re\n  }\n}\n\n// for restrict access storage concurrently\n// refer: https://balpha.de/2012/03/javascript-concurrency-and-locking-the-html5-localstorage/\n// refer: https://github.com/mgtitimoli/await-mutex/blob/master/src/mutex.js\nexport class Mutex {\n  constructor() {\n    this._locking = Promise.resolve()\n    this._locks = 0\n  }\n\n  isLocked() {\n    return this._locks > 0\n  }\n\n  lock() {\n    this._locks += 1\n    let unlockNext\n    const willLock = new Promise(resolve => {\n      unlockNext = () => {\n        this._locks -= 1\n        resolve()\n      }\n    })\n    const willUnlock = this._locking.then(() => unlockNext)\n    this._locking = this._locking.then(() => willLock)\n    return willUnlock\n  }\n}\n\n'better-onetab/src/common/list.js'\n:import _ from 'lodash'\nimport {genObjectId} from './utils'\nimport {normalizeTab} from './tab'\nimport {PICKED_LIST_RPOPS} from './constants'\n\nexport const createNewTabList = ({_id, tabs, title, tags, time, pinned, expand, color, updatedAt}) => ({\n  _id: _id || genObjectId(),\n  tabs: Array.isArray(tabs) ? tabs.map(normalizeTab) : [],\n  title: title || '',\n  tags: tags || [],\n  time: time || Date.now(),\n  titleEditing: false,\n  pinned: pinned === true, // default is false\n  expand: expand !== false, // default is true\n  color: color || '',\n  updatedAt: updatedAt || time || Date.now(),\n})\n\nexport const validateList = list => list != null && Array.isArray(list.tabs)\n\n// Preserving the needed properties before store lists.\nexport const normalizeList = list => {\n  const normalizedList = _.pick(list, PICKED_LIST_RPOPS)\n  normalizedList.tabs = normalizedList.tabs.map(normalizeTab)\n  return normalizedList\n}\n\nexport default {createNewTabList, normalizeList, validateList}\n\n'better-onetab/src/background/init.js'\n:import _ from 'lodash'\nimport logger from '../common/logger'\nimport options from '../common/options'\nimport storage from '../common/storage'\nimport migrate from '../common/migrate'\nimport boss from '../common/service/boss'\nimport {normalizeList} from '../common/list'\nimport commandHandler from './commandHandler'\nimport messageHandler from './messageHandler'\nimport listManager from '../common/listManager'\nimport {setupContextMenus, dynamicDisableMenu} from './contextMenus'\nimport installedEventHandler from './installedEventHandler'\nimport {updateBrowserAction} from './browserAction'\n\nimport browser from 'webextension-polyfill'\n\n/* eslint-disable-next-line */\nif (DEBUG && !MOZ) import(\n  /* webpackChunkName: \"autoreload\", webpackMode: \"lazy\" */\n  '../common/autoreload'\n).then(({autoreload}) => autoreload())\n\n/* eslint-disable-next-line */\nif (PRODUCTION) import(\n  /* webpackChunkName: \"tracker\", webpackMode: \"lazy\" */\n  '../common/tracker'\n).then(({tracker}) => tracker())\n\nif (DEBUG) {\n  window.browser = browser\n  window.listManager = listManager\n  window.boss = boss\n  browser.browserAction.setBadgeText({text: 'dev'})\n  import(\n    /* webpackChunkName: \"helper\", webpackMode: \"lazy\" */\n    '../common/helper'\n  ).then(helper => { window.helper = helper })\n}\n\nconst initOptions = async () => {\n  // mount the `opts` to global\n  const opts = window.opts = await storage.getOptions() || {}\n  const defaultOptions = options.getDefaultOptions()\n\n  // set it as default value if there is an option not in current options\n  if (_.keys(defaultOptions).some(key => !_.has(opts, key))) {\n    _.defaults(opts, defaultOptions)\n    await storage.setOptions(opts)\n  }\n\n  // init nightmode status\n  window.nightmode = opts.defaultNightMode\n  return opts\n}\n\nconst storageChangedHandler = changes => {\n  console.debug('[storage changed]', changes)\n  if (changes.boss_token) {\n    window.boss_token = changes.boss_token\n  }\n  if (changes.lists) {\n    if (window.opts.disableDynamicMenu) return\n    setupContextMenus(window.opts)\n  }\n}\n\nconst tabsChangedHandler = activeInfo => {\n  if (window.opts.disableDynamicMenu) return\n  window.coverBrowserAction(activeInfo)\n  dynamicDisableMenu(activeInfo)\n}\n\nconst fixDirtyData = async () => {\n  const unlock = await listManager.RWLock.lock()\n  const {lists} = await browser.storage.local.get('lists')\n  if (lists) {\n    const cleanLists = lists.filter(_.isPlainObject).map(normalizeList)\n    await browser.storage.local.set({lists: cleanLists})\n  }\n  await unlock()\n}\n\nconst init = async () => {\n  logger.init()\n  await listManager.init()\n  const opts = await initOptions()\n  await updateBrowserAction(opts.browserAction)\n  await setupContextMenus(opts)\n  await Promise.all([\n    browser.commands.onCommand.addListener(commandHandler),\n    browser.runtime.onMessageExternal.addListener(commandHandler),\n    browser.runtime.onMessage.addListener(messageHandler),\n    browser.runtime.onUpdateAvailable.addListener(detail => { window.update = detail.version }),\n    browser.runtime.onInstalled.addListener(installedEventHandler),\n    browser.browserAction.onClicked.addListener(() => window.browswerActionClickedHandler()),\n    browser.contextMenus.onClicked.addListener(info => window.contextMenusClickedHandler(info)),\n    browser.tabs.onActivated.addListener(_.debounce(tabsChangedHandler, 200)),\n    browser.storage.onChanged.addListener(storageChangedHandler),\n  ])\n  await migrate()\n  await fixDirtyData()\n  await boss.init()\n}\n\nexport default init\n\n'better-onetab/src/background/index.js'\n:import init from './init'\n\ninit()\n\n",
        "called_code_segment_file_1": "export const createNewTabList = ({_id, tabs, title, tags, time, pinned, expand, color, updatedAt}) => ({\n  _id: _id || genObjectId(),\n  tabs: Array.isArray(tabs) ? tabs.map(normalizeTab) : [],\n  title: title || '',\n  tags: tags || [],\n  time: time || Date.now(),\n  titleEditing: false,\n  pinned: pinned === true, // default is false\n  expand: expand !== false, // default is true\n  color: color || '',\n  updatedAt: updatedAt || time || Date.now(),\n});",
        "invoking_code_segment_file_2": "const fixDirtyData = async () => {\n  const unlock = await listManager.RWLock.lock();\n  const {lists} = await browser.storage.local.get('lists');\n  if (lists) {\n    const cleanLists = lists.filter(_.isPlainObject).map(normalizeList);\n    await browser.storage.local.set({lists: cleanLists});\n  }\n  await unlock();\n}",
        "called_code_segment_file_2": "const normalizeList = list => {\n  const normalizedList = _.pick(list, PICKED_LIST_RPOPS);\n  normalizedList.tabs = normalizedList.tabs.map(normalizeTab);\n  return normalizedList;\n}",
        "using_code_segment_file_3": "const normalizeTab = tab => {\n  const normalizedTab = _.pick(tab, PICKED_TAB_PROPS);\n  normalizedTab.title = normalizedTab.title || '';\n  normalizedTab.url = normalizedTab.url || '';\n  return normalizedTab;\n}",
        "called_code_segment_file_3": "const normalizeTab = tab => {\n  const normalizedTab = _.pick(tab, PICKED_TAB_PROPS);\n  normalizedTab.title = normalizedTab.title || '';\n  normalizedTab.url = normalizedTab.url || '';\n  return normalizedTab;\n}",
        "using_code_segment_file_4": "const normalizeTab = tab => {\n  const normalizedTab = _.pick(tab, PICKED_TAB_PROPS);\n  normalizedTab.title = normalizedTab.title || '';\n  normalizedTab.url = normalizedTab.url || '';\n  return normalizedTab;\n}",
        "feature_description": "Add a feature to automatically generate a title for a new tab list if no title is provided.",
        "detailed_feature_description": "Modify the `createNewTabList` function in #file 1 to generate a default title if no title is provided. Update the `fixDirtyData` function in #file 2 to handle the new default title generation. Ensure that the `normalizeList` function in #file 2 is updated to accommodate the changes. Update the `normalizeTab` function in #file 3 to ensure it works correctly with the new default title. No changes are required in #file 4 as it does not interact with the updated segments directly.",
        "modified_complete_code": {
            "#file 1": "export const createNewTabList = ({_id, tabs, title, tags, time, pinned, expand, color, updatedAt}) => ({\n  _id: _id || genObjectId(),\n  tabs: Array.isArray(tabs) ? tabs.map(normalizeTab) : [],\n  title: title || `New List ${genObjectId().slice(0, 8)}`, #Modify\n  tags: tags || [],\n  time: time || Date.now(),\n  titleEditing: false,\n  pinned: pinned === true, // default is false\n  expand: expand !== false, // default is true\n  color: color || '',\n  updatedAt: updatedAt || time || Date.now(),\n});",
            "#file 2": "const fixDirtyData = async () => {\n  const unlock = await listManager.RWLock.lock();\n  const {lists} = await browser.storage.local.get('lists');\n  if (lists) {\n    const cleanLists = lists.filter(_.isPlainObject).map(normalizeList);\n    await browser.storage.local.set({lists: cleanLists});\n  }\n  await unlock();\n}\n\nconst normalizeList = list => {\n  const normalizedList = _.pick(list, PICKED_LIST_RPOPS);\n  normalizedList.tabs = normalizedList.tabs.map(normalizeTab);\n  if (!normalizedList.title) {\n    normalizedList.title = `New List ${genObjectId().slice(0, 8)}`; #Modify\n  }\n  return normalizedList;\n}",
            "#file 3": "const normalizeTab = tab => {\n  const normalizedTab = _.pick(tab, PICKED_TAB_PROPS);\n  normalizedTab.title = normalizedTab.title || '';\n  normalizedTab.url = normalizedTab.url || '';\n  return normalizedTab;\n}",
            "#file 4": "const normalizeTab = tab => {\n  const normalizedTab = _.pick(tab, PICKED_TAB_PROPS);\n  normalizedTab.title = normalizedTab.title || '';\n  normalizedTab.url = normalizedTab.url || '';\n  return normalizedTab;\n}"
        }
    },
    {
        "repo": "spa",
        "content": "'spa/listings/ch08/8.6.3-chat-chatting/lib/crud.js'\n:/*\n * crud.js - module to provide CRUD db capabilities\n*/\n\n/*jslint         node    : true, continue : true,\n  devel  : true, indent  : 2,    maxerr   : 50,\n  newcap : true, nomen   : true, plusplus : true,\n  regexp : true, sloppy  : true, vars     : false,\n  white  : true\n*/\n/*global */\n\n// ------------ BEGIN MODULE SCOPE VARIABLES --------------\n'use strict';\nvar\n  loadSchema,   checkSchema,  clearIsOnline,\n  checkType,    constructObj, readObj,\n  updateObj,    destroyObj,\n\n  mongodb     = require( 'mongodb' ),\n  fsHandle    = require( 'fs'      ),\n  JSV         = require( 'JSV'     ).JSV,\n\n  mongoServer = new mongodb.Server(\n    'localhost',\n    mongodb.Connection.DEFAULT_PORT\n  ),\n  dbHandle    = new mongodb.Db(\n    'spa', mongoServer, { safe : true }\n  ),\n  validator   = JSV.createEnvironment(),\n\n  objTypeMap  = { 'user' : {} };\n// ------------- END MODULE SCOPE VARIABLES ---------------\n\n// ---------------- BEGIN UTILITY METHODS -----------------\nloadSchema = function ( schema_name, schema_path ) {\n  fsHandle.readFile( schema_path, 'utf8', function ( err, data ) {\n    objTypeMap[ schema_name ] = JSON.parse( data );\n  });\n};\n\ncheckSchema = function ( obj_type, obj_map, callback ) {\n  var\n    schema_map = objTypeMap[ obj_type ],\n    report_map = validator.validate( obj_map, schema_map );\n\n  callback( report_map.errors );\n};\n\nclearIsOnline = function () {\n  updateObj(\n    'user',\n    { is_online : true  },\n    { is_online : false },\n    function ( response_map ) {\n      console.log( 'All users set to offline', response_map );\n    }\n  );\n};\n// ----------------- END UTILITY METHODS ------------------\n\n// ---------------- BEGIN PUBLIC METHODS ------------------\ncheckType = function ( obj_type ) {\n  if ( ! objTypeMap[ obj_type ] ) {\n    return ({ error_msg : 'Object type \"' + obj_type\n      + '\" is not supported.'\n    });\n  }\n  return null;\n};\n\nconstructObj = function ( obj_type, obj_map, callback ) {\n  var type_check_map = checkType( obj_type );\n  if ( type_check_map ) {\n    callback( type_check_map );\n    return;\n  }\n\n  checkSchema(\n    obj_type, obj_map,\n    function ( error_list ) {\n      if ( error_list.length === 0 ) {\n        dbHandle.collection(\n          obj_type,\n          function ( outer_error, collection ) {\n            var options_map = { safe: true };\n\n            collection.insert(\n              obj_map,\n              options_map,\n              function ( inner_error, result_map ) {\n                callback( result_map );\n              }\n            );\n          }\n        );\n      }\n      else {\n        callback({\n          error_msg  : 'Input document not valid',\n          error_list : error_list\n        });\n      }\n    }\n  );\n};\n\nreadObj = function ( obj_type, find_map, fields_map, callback ) {\n  var type_check_map = checkType( obj_type );\n  if ( type_check_map ) {\n    callback( type_check_map );\n    return;\n  }\n\n  dbHandle.collection(\n    obj_type,\n    function ( outer_error, collection ) {\n      collection.find( find_map, fields_map ).toArray(\n        function ( inner_error, map_list ) {\n          callback( map_list );\n        }\n      );\n    }\n  );\n};\n\nupdateObj = function ( obj_type, find_map, set_map, callback ) {\n  var type_check_map = checkType( obj_type );\n  if ( type_check_map ) {\n    callback( type_check_map );\n    return;\n  }\n\n  checkSchema(\n    obj_type, set_map,\n    function ( error_list ) {\n      if ( error_list.length === 0 ) {\n        dbHandle.collection(\n          obj_type,\n          function ( outer_error, collection ) {\n            collection.update(\n              find_map,\n              { $set : set_map },\n              { safe : true, multi : true, upsert : false },\n              function ( inner_error, update_count ) {\n                callback({ update_count : update_count });\n              }\n            );\n          }\n        );\n      }\n      else {\n        callback({\n          error_msg  : 'Input document not valid',\n          error_list : error_list\n        });\n      }\n    }\n  );\n};\n\ndestroyObj = function ( obj_type, find_map, callback ) {\n  var type_check_map = checkType( obj_type );\n  if ( type_check_map ) {\n    callback( type_check_map );\n    return;\n  }\n\n  dbHandle.collection(\n    obj_type,\n    function ( outer_error, collection ) {\n      var options_map = { safe: true, single: true };\n\n      collection.remove( find_map, options_map,\n        function ( inner_error, delete_count ) {\n          callback({ delete_count: delete_count });\n        }\n      );\n    }\n  );\n};\n\nmodule.exports = {\n  makeMongoId : mongodb.ObjectID,\n  checkType   : checkType,\n  construct   : constructObj,\n  read        : readObj,\n  update      : updateObj,\n  destroy     : destroyObj\n};\n// ----------------- END PUBLIC METHODS -----------------\n\n// ------------- BEGIN MODULE INITIALIZATION --------------\ndbHandle.open( function () {\n  console.log( '** Connected to MongoDB **' );\n  clearIsOnline();\n});\n\n// load schemas into memory (objTypeMap)\n(function () {\n  var schema_name, schema_path;\n  for ( schema_name in objTypeMap ) {\n    if ( objTypeMap.hasOwnProperty( schema_name ) ) {\n      schema_path = __dirname + '/' + schema_name + '.json';\n      loadSchema( schema_name, schema_path );\n    }\n  }\n}());\n// -------------- END MODULE INITIALIZATION ---------------\n\n'spa/listings/ch08/8.6.3-chat-chatting/lib/chat.js'\n:/*\n * chat.js - module to provide chat messaging\n*/\n\n/*jslint         node    : true, continue : true,\n  devel  : true, indent  : 2,    maxerr   : 50,\n  newcap : true, nomen   : true, plusplus : true,\n  regexp : true, sloppy  : true, vars     : false,\n  white  : true\n*/\n/*global */\n\n// ------------ BEGIN MODULE SCOPE VARIABLES --------------\n'use strict';\nvar\n  emitUserList, signIn, chatObj,\n  socket = require( 'socket.io' ),\n  crud   = require( './crud'    ),\n\n  makeMongoId = crud.makeMongoId,\n  chatterMap  = {};\n// ------------- END MODULE SCOPE VARIABLES ---------------\n\n// ---------------- BEGIN UTILITY METHODS -----------------\n// emitUserList - broadcast user list to all connected clients\n//\nemitUserList = function ( io ) {\n  crud.read(\n    'user',\n    { is_online : true },\n    {},\n    function ( result_list ) {\n      io\n        .of( '/chat' )\n        .emit( 'listchange', result_list );\n    }\n  );\n};\n\n// signIn - update is_online property and chatterMap\n//\nsignIn = function ( io, user_map, socket ) {\n  crud.update(\n    'user',\n    { '_id'     : user_map._id },\n    { is_online : true         },\n    function ( result_map ) {\n      emitUserList( io );\n      user_map.is_online = true;\n      socket.emit( 'userupdate', user_map );\n    }\n  );\n\n  chatterMap[ user_map._id ] = socket;\n  socket.user_id = user_map._id;\n};\n// ----------------- END UTILITY METHODS ------------------\n\n// ---------------- BEGIN PUBLIC METHODS ------------------\nchatObj = {\n  connect : function ( server ) {\n    var io = socket.listen( server );\n\n    // Begin io setup\n    io\n      .set( 'blacklist' , [] )\n      .of( '/chat' )\n      .on( 'connection', function ( socket ) {\n\n        // Begin /adduser/ message handler\n        // Summary   : Provides sign in capability.\n        // Arguments : A single user_map object.\n        //   user_map should have the following properties:\n        //     name    = the name of the user\n        //     cid     = the client id\n        // Action    :\n        //   If a user with the provided username already exists\n        //     in Mongo, use the existing user object and ignore\n        //     other input.\n        //   If a user with the provided username does not exist\n        //     in Mongo, create one and use it.\n        //   Send a 'userupdate' message to the sender so that\n        //     a login cycle can complete.  Ensure the client id\n        //     is passed back so the client can correlate the user,\n        //     but do not store it in MongoDB.\n        //   Mark the user as online and send the updated online\n        //     user list to all clients, including the client that\n        //     originated the 'adduser' message.\n        //\n        socket.on( 'adduser', function ( user_map ) {\n          crud.read(\n            'user',\n            { name : user_map.name },\n            {},\n            function ( result_list ) {\n              var \n                result_map,\n                cid = user_map.cid;\n\n              delete user_map.cid;\n\n              // use existing user with provided name\n              if ( result_list.length > 0 ) {\n                result_map     = result_list[ 0 ];\n                result_map.cid = cid;\n                signIn( io, result_map, socket );\n              }\n\n              // create user with new name\n              else {\n                user_map.is_online = true;\n                crud.construct(\n                  'user',\n                  user_map,\n                  function ( result_list ) {\n                    result_map     = result_list[ 0 ];\n                    result_map.cid = cid;\n                    chatterMap[ result_map._id ] = socket;\n                    socket.user_id = result_map._id;\n                    socket.emit( 'userupdate', result_map );\n                    emitUserList( io );\n                  }\n                );\n              }\n            }\n          );\n        });\n        // End /adduser/ message handler\n\n        // Begin /updatechat/ message handler\n        // Summary   : Handles messages for chat.\n        // Arguments : A single chat_map object.\n        //  chat_map should have the following properties:\n        //    dest_id   = id of recipient\n        //    dest_name = name of recipient\n        //    sender_id = id of sender\n        //    msg_text  = message text\n        // Action    :\n        //   If the recipient is online, the chat_map is sent to her.\n        //   If not, a 'user has gone offline' message is\n        //     sent to the sender.\n        //\n        socket.on( 'updatechat', function ( chat_map ) {\n          if ( chatterMap.hasOwnProperty( chat_map.dest_id ) ) {\n            chatterMap[ chat_map.dest_id ]\n              .emit( 'updatechat', chat_map );\n          }\n          else {\n            socket.emit( 'updatechat', {\n              sender_id : chat_map.sender_id,\n              msg_text  : chat_map.dest_name + ' has gone offline.'\n            });\n          }\n        });\n        // End /updatechat/ message handler\n\n        socket.on( 'leavechat',    function () {} );\n        socket.on( 'disconnect',   function () {} );\n        socket.on( 'updateavatar', function () {} );\n      }\n    );\n    // End io setup\n\n    return io;\n  }\n};\n\nmodule.exports = chatObj;\n// ----------------- END PUBLIC METHODS -------------------\n\n'spa/listings/ch08/8.6.3-chat-chatting/lib/routes.js'\n:/*\n * routes.js - module to provide routing\n*/\n\n/*jslint         node    : true, continue : true,\n  devel  : true, indent  : 2,    maxerr   : 50,\n  newcap : true, nomen   : true, plusplus : true,\n  regexp : true, sloppy  : true, vars     : false,\n  white  : true\n*/\n/*global */\n\n// ------------ BEGIN MODULE SCOPE VARIABLES --------------\n'use strict';\nvar\n  configRoutes,\n  crud        = require( './crud' ),\n  chat        = require( './chat' ),\n  makeMongoId = crud.makeMongoId;\n// ------------- END MODULE SCOPE VARIABLES ---------------\n\n// ---------------- BEGIN PUBLIC METHODS ------------------\nconfigRoutes = function ( app, server ) {\n  app.get( '/', function ( request, response ) {\n    response.redirect( '/spa.html' );\n  });\n\n  app.all( '/:obj_type/*?', function ( request, response, next ) {\n    response.contentType( 'json' );\n    next();\n  });\n\n  app.get( '/:obj_type/list', function ( request, response ) {\n    crud.read(\n      request.params.obj_type,\n      {}, {},\n      function ( map_list ) { response.send( map_list ); }\n    );\n  });\n\n  app.post( '/:obj_type/create', function ( request, response ) {\n    crud.construct(\n      request.params.obj_type,\n      request.body,\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  app.get( '/:obj_type/read/:id', function ( request, response ) {\n    crud.read(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      {},\n      function ( map_list ) { response.send( map_list ); }\n    );\n  });\n\n  app.post( '/:obj_type/update/:id', function ( request, response ) {\n    crud.update(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      request.body,\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  app.get( '/:obj_type/delete/:id', function ( request, response ) {\n    crud.destroy(\n      request.params.obj_type,\n      { _id: makeMongoId( request.params.id ) },\n      function ( result_map ) { response.send( result_map ); }\n    );\n  });\n\n  chat.connect( server );\n};\n\nmodule.exports = { configRoutes : configRoutes };\n// ----------------- END PUBLIC METHODS -------------------\n\n'spa/listings/ch08/8.6.3-chat-chatting/app.js'\n:/*\n * app.js - Express server with routing\n*/\n\n/*jslint         node    : true, continue : true,\n  devel  : true, indent  : 2,    maxerr   : 50,\n  newcap : true, nomen   : true, plusplus : true,\n  regexp : true, sloppy  : true, vars     : false,\n  white  : true\n*/\n/*global */\n\n// ------------ BEGIN MODULE SCOPE VARIABLES --------------\n'use strict';\nvar\n  http    = require( 'http'         ),\n  express = require( 'express'      ),\n  routes  = require( './lib/routes' ),\n\n  app     = express(),\n  server  = http.createServer( app );\n// ------------- END MODULE SCOPE VARIABLES ---------------\n\n// ------------- BEGIN SERVER CONFIGURATION ---------------\napp.configure( function () {\n  app.use( express.bodyParser() );\n  app.use( express.methodOverride() );\n  app.use( express.static( __dirname + '/public' ) );\n  app.use( app.router );\n});\n\napp.configure( 'development', function () {\n  app.use( express.logger() );\n  app.use( express.errorHandler({\n    dumpExceptions : true,\n    showStack      : true\n  }) );\n});\n\napp.configure( 'production', function () {\n  app.use( express.errorHandler() );\n});\n\nroutes.configRoutes( app, server );\n// -------------- END SERVER CONFIGURATION ----------------\n\n// ----------------- BEGIN START SERVER -------------------\nserver.listen( 3000 );\nconsole.log(\n  'Express server listening on port %d in %s mode',\n   server.address().port, app.settings.env\n);\n// ------------------ END START SERVER --------------------\n\n",
        "called_code_segment_file_1": "constructObj = function ( obj_type, obj_map, callback ) {\n  var type_check_map = checkType( obj_type );\n  if ( type_check_map ) {\n    callback( type_check_map );\n    return;\n  }\n\n  checkSchema(\n    obj_type, obj_map,\n    function ( error_list ) {\n      if ( error_list.length === 0 ) {\n        dbHandle.collection(\n          obj_type,\n          function ( outer_error, collection ) {\n            var options_map = { safe: true };\n\n            collection.insert(\n              obj_map,\n              options_map,\n              function ( inner_error, result_map ) {\n                callback( result_map );\n              }\n            );\n          }\n        );\n      }\n      else {\n        callback({\n          error_msg  : 'Input document not valid',\n          error_list : error_list\n        });\n      }\n    }\n  );\n};",
        "invoking_code_segment_file_2": "crud.construct(\n  'user',\n  user_map,\n  function ( result_list ) {\n    result_map     = result_list[ 0 ];\n    result_map.cid = cid;\n    chatterMap[ result_map._id ] = socket;\n    socket.user_id = result_map._id;\n    socket.emit( 'userupdate', result_map );\n    emitUserList( io );\n  }\n);",
        "called_code_segment_file_2": "emitUserList = function ( io ) {\n  crud.read(\n    'user',\n    { is_online : true },\n    {},\n    function ( result_list ) {\n      io\n        .of( '/chat' )\n        .emit( 'listchange', result_list );\n    }\n  );\n};",
        "using_code_segment_file_3": "io\n  .set( 'blacklist' , [] )\n  .of( '/chat' )\n  .on( 'connection', function ( socket ) {\n    socket.on( 'adduser', function ( user_map ) {\n      crud.read(\n        'user',\n        { name : user_map.name },\n        {},\n        function ( result_list ) {\n          var \n            result_map,\n            cid = user_map.cid;\n\n          delete user_map.cid;\n\n          if ( result_list.length > 0 ) {\n            result_map     = result_list[ 0 ];\n            result_map.cid = cid;\n            signIn( io, result_map, socket );\n          }\n          else {\n            user_map.is_online = true;\n            crud.construct(\n              'user',\n              user_map,\n              function ( result_list ) {\n                result_map     = result_list[ 0 ];\n                result_map.cid = cid;\n                chatterMap[ result_map._id ] = socket;\n                socket.user_id = result_map._id;\n                socket.emit( 'userupdate', result_map );\n                emitUserList( io );\n              }\n            );\n          }\n        }\n      );\n    });\n  }\n);",
        "called_code_segment_file_3": "socket.on( 'updatechat', function ( chat_map ) {\n  if ( chatterMap.hasOwnProperty( chat_map.dest_id ) ) {\n    chatterMap[ chat_map.dest_id ]\n      .emit( 'updatechat', chat_map );\n  }\n  else {\n    socket.emit( 'updatechat', {\n      sender_id : chat_map.sender_id,\n      msg_text  : chat_map.dest_name + ' has gone offline.'\n    });\n  }\n});",
        "using_code_segment_file_4": "crud.read(\n  request.params.obj_type,\n  { _id: makeMongoId( request.params.id ) },\n  {},\n  function ( map_list ) { response.send( map_list ); }\n);",
        "feature_description": "Add a feature to log the creation of new users to a file.",
        "detailed_feature_description": "Modify the `constructObj` function in `crud.js` to log the creation of new users to a file. Update the `crud.construct` call in `chat.js` to handle the new logging functionality. Ensure that `emitUserList` in `chat.js` is updated to accommodate any changes. Update the `routes.js` file to ensure it interacts correctly with the modified `crud.js`.",
        "modified_complete_code": {
            "crud.js": "#Modify\nconstructObj = function ( obj_type, obj_map, callback ) {\n  var type_check_map = checkType( obj_type );\n  if ( type_check_map ) {\n    callback( type_check_map );\n    return;\n  }\n\n  checkSchema(\n    obj_type, obj_map,\n    function ( error_list ) {\n      if ( error_list.length === 0 ) {\n        dbHandle.collection(\n          obj_type,\n          function ( outer_error, collection ) {\n            var options_map = { safe: true };\n\n            collection.insert(\n              obj_map,\n              options_map,\n              function ( inner_error, result_map ) {\n                fsHandle.appendFile('user_log.txt', JSON.stringify(result_map) + '\\n', function (err) {\n                  if (err) throw err;\n                  console.log('User logged!');\n                });\n                callback( result_map );\n              }\n            );\n          }\n        );\n      }\n      else {\n        callback({\n          error_msg  : 'Input document not valid',\n          error_list : error_list\n        });\n      }\n    }\n  );\n};",
            "chat.js": "#Modify\ncrud.construct(\n  'user',\n  user_map,\n  function ( result_list ) {\n    result_map     = result_list[ 0 ];\n    result_map.cid = cid;\n    chatterMap[ result_map._id ] = socket;\n    socket.user_id = result_map._id;\n    socket.emit( 'userupdate', result_map );\n    emitUserList( io );\n  }\n);",
            "routes.js": "#Modify\napp.post( '/:obj_type/create', function ( request, response ) {\n  crud.construct(\n    request.params.obj_type,\n    request.body,\n    function ( result_map ) { response.send( result_map ); }\n  );\n});",
            "app.js": "#New\nvar fsHandle = require( 'fs' );"
        }
    },
    {
        "repo": "three.bas",
        "content": "'three.bas/src/materials/BaseAnimationMaterial.js'\n:import {\n  ShaderMaterial,\n  UniformsUtils,\n} from 'three';\n\nclass BaseAnimationMaterial extends ShaderMaterial {\n  constructor (parameters, uniforms) {\n    super();\n\n    if (parameters.uniformValues) {\n      console.warn('THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters.')\n\n      Object.keys(parameters.uniformValues).forEach((key) => {\n        parameters[key] = parameters.uniformValues[key]\n      })\n\n      delete parameters.uniformValues\n    }\n\n    // copy parameters to (1) make use of internal #define generation\n    // and (2) prevent 'x is not a property of this material' warnings.\n    Object.keys(parameters).forEach((key) => {\n      this[key] = parameters[key]\n    })\n\n    // override default parameter values\n    this.setValues(parameters);\n\n    // override uniforms\n    this.uniforms = UniformsUtils.merge([uniforms, parameters.uniforms || {}]);\n\n    // set uniform values from parameters that affect uniforms\n    this.setUniformValues(parameters);\n  }\n\n  setUniformValues (values) {\n    if (!values) return;\n\n    const keys = Object.keys(values);\n\n    keys.forEach((key) => {\n      key in this.uniforms && (this.uniforms[key].value = values[key]);\n    });\n  }\n\n  stringifyChunk (name) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return value;\n  }\n}\n\nexport default BaseAnimationMaterial;\n\n'three.bas/src/materials/DistanceAnimationMaterial.js'\n:import { ShaderLib, RGBADepthPacking } from 'three';\nimport BaseAnimationMaterial from './BaseAnimationMaterial';\n\nclass DistanceAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['distanceRGBA'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['distanceRGBA'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.distanceRGBA.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }\n}\n\nexport { DistanceAnimationMaterial };\n\n'three.bas/src/Utils.js'\n:import { MathUtils, Vector3 } from 'three';\nimport { DepthAnimationMaterial } from './materials/DepthAnimationMaterial';\nimport { DistanceAnimationMaterial } from './materials/DistanceAnimationMaterial';\n\n/**\n * Collection of utility functions.\n * @namespace\n */\nconst Utils = {\n  /**\n   * Duplicates vertices so each face becomes separate.\n   * Same as THREE.ExplodeModifier.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance to modify.\n   */\n  separateFaces: function (geometry) {\n    let vertices = [];\n\n    for (let i = 0, il = geometry.faces.length; i < il; i++) {\n      let n = vertices.length;\n      let face = geometry.faces[i];\n\n      let a = face.a;\n      let b = face.b;\n      let c = face.c;\n\n      let va = geometry.vertices[a];\n      let vb = geometry.vertices[b];\n      let vc = geometry.vertices[c];\n\n      vertices.push(va.clone());\n      vertices.push(vb.clone());\n      vertices.push(vc.clone());\n\n      face.a = n;\n      face.b = n + 1;\n      face.c = n + 2;\n    }\n\n    geometry.vertices = vertices;\n  },\n\n  /**\n   * Compute the centroid (center) of a THREE.Face3.\n   *\n   * @param {THREE.Geometry} geometry Geometry instance the face is in.\n   * @param {THREE.Face3} face Face object from the THREE.Geometry.faces array\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  computeCentroid: function(geometry, face, v) {\n    let a = geometry.vertices[face.a];\n    let b = geometry.vertices[face.b];\n    let c = geometry.vertices[face.c];\n\n    v = v || new Vector3();\n\n    v.x = (a.x + b.x + c.x) / 3;\n    v.y = (a.y + b.y + c.y) / 3;\n    v.z = (a.z + b.z + c.z) / 3;\n\n    return v;\n  },\n\n  /**\n   * Get a random vector between box.min and box.max.\n   *\n   * @param {THREE.Box3} box THREE.Box3 instance.\n   * @param {THREE.Vector3=} v Optional vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomInBox: function(box, v) {\n    v = v || new Vector3();\n\n    v.x = MathUtils.randFloat(box.min.x, box.max.x);\n    v.y = MathUtils.randFloat(box.min.y, box.max.y);\n    v.z = MathUtils.randFloat(box.min.z, box.max.z);\n\n    return v;\n  },\n\n  /**\n   * Get a random axis for quaternion rotation.\n   *\n   * @param {THREE.Vector3=} v Option vector to store result in.\n   * @returns {THREE.Vector3}\n   */\n  randomAxis: function(v) {\n    v = v || new Vector3();\n\n    v.x = MathUtils.randFloatSpread(2.0);\n    v.y = MathUtils.randFloatSpread(2.0);\n    v.z = MathUtils.randFloatSpread(2.0);\n    v.normalize();\n\n    return v;\n  },\n\n  /**\n   * Create a THREE.BAS.DepthAnimationMaterial for shadows from a THREE.SpotLight or THREE.DirectionalLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the depth material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DepthAnimationMaterial}\n   */\n  createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  },\n\n  /**\n   * Create a THREE.BAS.DistanceAnimationMaterial for shadows from a THREE.PointLight by copying relevant shader chunks.\n   * Uniform values must be manually synced between the source material and the distance material.\n   *\n   * @see {@link http://three-bas-examples.surge.sh/examples/shadows/}\n   *\n   * @param {THREE.BAS.BaseAnimationMaterial} sourceMaterial Instance to get the shader chunks from.\n   * @returns {THREE.BAS.DistanceAnimationMaterial}\n   */\n  createDistanceAnimationMaterial: function(sourceMaterial) {\n    return new DistanceAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }\n};\n\nexport { Utils };\n\n'three.bas/src/geometry/ModelBufferGeometry.js'\n:import { BufferGeometry, BufferAttribute } from 'three';\nimport { Utils } from '../Utils';\n\nclass ModelBufferGeometry extends BufferGeometry {\n  /**\n   * A THREE.BufferGeometry for animating individual faces of a THREE.Geometry.\n   *\n   * @param {THREE.Geometry} model The THREE.Geometry to base this geometry on.\n   * @param {Object=} options\n   * @param {Boolean=} options.computeCentroids If true, a centroids will be computed for each face and stored in THREE.BAS.ModelBufferGeometry.centroids.\n   * @param {Boolean=} options.localizeFaces If true, the positions for each face will be stored relative to the centroid. This is useful if you want to rotate or scale faces around their center.\n   */\n  constructor (model, options) {\n    super();\n\n    /**\n     * A reference to the geometry used to create this instance.\n     * @type {THREE.Geometry}\n     */\n    this.modelGeometry = model;\n\n    /**\n     * Number of faces of the model.\n     * @type {Number}\n     */\n    this.faceCount = this.modelGeometry.faces.length;\n\n    /**\n     * Number of vertices of the model.\n     * @type {Number}\n     */\n    this.vertexCount = this.modelGeometry.vertices.length;\n\n    options = options || {};\n    options.computeCentroids && this.computeCentroids();\n\n    this.bufferIndices();\n    this.bufferPositions(options.localizeFaces);\n  }\n\n  /**\n   * Computes a centroid for each face and stores it in THREE.BAS.ModelBufferGeometry.centroids.\n   */\n  computeCentroids () {\n    /**\n     * An array of centroids corresponding to the faces of the model.\n     *\n     * @type {Array}\n     */\n    this.centroids = [];\n\n    for (let i = 0; i < this.faceCount; i++) {\n      this.centroids[i] = Utils.computeCentroid(this.modelGeometry, this.modelGeometry.faces[i]);\n    }\n  }\n\n  bufferIndices () {\n    const indexBuffer = new Uint32Array(this.faceCount * 3);\n\n    this.setIndex(new BufferAttribute(indexBuffer, 1));\n\n    for (let i = 0, offset = 0; i < this.faceCount; i++, offset += 3) {\n      const face = this.modelGeometry.faces[i];\n\n      indexBuffer[offset    ] = face.a;\n      indexBuffer[offset + 1] = face.b;\n      indexBuffer[offset + 2] = face.c;\n    }\n  }\n\n  bufferPositions (localizeFaces) {\n    const positionBuffer = this.createAttribute('position', 3).array;\n    let i, offset;\n\n    if (localizeFaces === true) {\n      for (i = 0; i < this.faceCount; i++) {\n        const face = this.modelGeometry.faces[i];\n        const centroid = this.centroids ? this.centroids[i] : Utils.computeCentroid(this.modelGeometry, face);\n\n        const a = this.modelGeometry.vertices[face.a];\n        const b = this.modelGeometry.vertices[face.b];\n        const c = this.modelGeometry.vertices[face.c];\n\n        positionBuffer[face.a * 3]     = a.x - centroid.x;\n        positionBuffer[face.a * 3 + 1] = a.y - centroid.y;\n        positionBuffer[face.a * 3 + 2] = a.z - centroid.z;\n\n        positionBuffer[face.b * 3]     = b.x - centroid.x;\n        positionBuffer[face.b * 3 + 1] = b.y - centroid.y;\n        positionBuffer[face.b * 3 + 2] = b.z - centroid.z;\n\n        positionBuffer[face.c * 3]     = c.x - centroid.x;\n        positionBuffer[face.c * 3 + 1] = c.y - centroid.y;\n        positionBuffer[face.c * 3 + 2] = c.z - centroid.z;\n      }\n    }\n    else {\n      for (i = 0, offset = 0; i < this.vertexCount; i++, offset += 3) {\n        const vertex = this.modelGeometry.vertices[i];\n\n        positionBuffer[offset    ] = vertex.x;\n        positionBuffer[offset + 1] = vertex.y;\n        positionBuffer[offset + 2] = vertex.z;\n      }\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute with UV coordinates.\n   */\n  bufferUvs () {\n    const uvBuffer = this.createAttribute('uv', 2).array;\n\n    for (let i = 0; i < this.faceCount; i++) {\n\n      const face = this.modelGeometry.faces[i];\n      let uv;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][0];\n      uvBuffer[face.a * 2]     = uv.x;\n      uvBuffer[face.a * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][1];\n      uvBuffer[face.b * 2]     = uv.x;\n      uvBuffer[face.b * 2 + 1] = uv.y;\n\n      uv = this.modelGeometry.faceVertexUvs[0][i][2];\n      uvBuffer[face.c * 2]     = uv.x;\n      uvBuffer[face.c * 2 + 1] = uv.y;\n    }\n  }\n\n  /**\n   * Creates two THREE.BufferAttributes: skinIndex and skinWeight. Both are required for skinning.\n   */\n  bufferSkinning () {\n    const skinIndexBuffer = this.createAttribute('skinIndex', 4).array;\n    const skinWeightBuffer = this.createAttribute('skinWeight', 4).array;\n\n    for (let i = 0; i < this.vertexCount; i++) {\n      const skinIndex = this.modelGeometry.skinIndices[i];\n      const skinWeight = this.modelGeometry.skinWeights[i];\n\n      skinIndexBuffer[i * 4    ] = skinIndex.x;\n      skinIndexBuffer[i * 4 + 1] = skinIndex.y;\n      skinIndexBuffer[i * 4 + 2] = skinIndex.z;\n      skinIndexBuffer[i * 4 + 3] = skinIndex.w;\n\n      skinWeightBuffer[i * 4    ] = skinWeight.x;\n      skinWeightBuffer[i * 4 + 1] = skinWeight.y;\n      skinWeightBuffer[i * 4 + 2] = skinWeight.z;\n      skinWeightBuffer[i * 4 + 3] = skinWeight.w;\n    }\n  }\n\n  /**\n   * Creates a THREE.BufferAttribute on this geometry instance.\n   *\n   * @param {String} name Name of the attribute.\n   * @param {int} itemSize Number of floats per vertex (typically 1, 2, 3 or 4).\n   * @param {function=} factory Function that will be called for each face upon creation. Accepts 3 arguments: data[], index and faceCount. Calls setFaceData.\n   *\n   * @returns {BufferAttribute}\n   */\n  createAttribute (name, itemSize, factory) {\n    const buffer = new Float32Array(this.vertexCount * itemSize);\n    const attribute = new BufferAttribute(buffer, itemSize);\n\n    this.setAttribute(name, attribute);\n\n    if (factory) {\n      const data = [];\n\n      for (let i = 0; i < this.faceCount; i++) {\n        factory(data, i, this.faceCount);\n        this.setFaceData(attribute, i, data);\n      }\n    }\n\n    return attribute;\n  }\n\n  /**\n   * Sets data for all vertices of a face at a given index.\n   * Usually called in a loop.\n   *\n   * @param {String|THREE.BufferAttribute} attribute The attribute or attribute name where the data is to be stored.\n   * @param {int} faceIndex Index of the face in the buffer geometry.\n   * @param {Array} data Array of data. Length should be equal to item size of the attribute.\n   */\n  setFaceData (attribute, faceIndex, data) {\n    attribute = (typeof attribute === 'string') ? this.attributes[attribute] : attribute;\n\n    let offset = faceIndex * 3 * attribute.itemSize;\n\n    for (let i = 0; i < 3; i++) {\n      for (let j = 0; j < attribute.itemSize; j++) {\n        attribute.array[offset++] = data[j];\n      }\n    }\n  }\n}\n\nexport { ModelBufferGeometry };\n\n",
        "called_code_segment_file_1": "stringifyChunk (name) {\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return value;\n  }",
        "invoking_code_segment_file_2": "concatVertexShader () {\n    return ShaderLib.distanceRGBA.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }",
        "called_code_segment_file_2": "concatVertexShader () {\n    return ShaderLib.distanceRGBA.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters')}\n        ${this.stringifyChunk('vertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning')}\n        `\n      )\n  }",
        "using_code_segment_file_3": "createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }",
        "called_code_segment_file_3": "createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }",
        "using_code_segment_file_4": "const depthMaterial = Utils.createDepthAnimationMaterial(sourceMaterial);",
        "feature_description": "Add a new feature to allow custom shader chunk names to be passed dynamically to the `stringifyChunk` method.",
        "detailed_feature_description": "The new feature allows the `stringifyChunk` method in #file 1 to accept an additional parameter for custom shader chunk names. This modification will be propagated to #file 2, which invokes `stringifyChunk`. #file 3 will also be updated to handle the modified `stringifyChunk` method when creating depth animation materials. Finally, #file 4 will use the updated `createDepthAnimationMaterial` method from #file 3.",
        "modified_complete_code": {
            "file_1": "class BaseAnimationMaterial extends ShaderMaterial {\n  constructor (parameters, uniforms) {\n    super();\n\n    if (parameters.uniformValues) {\n      console.warn('THREE.BAS - `uniformValues` is deprecated. Put their values directly into the parameters.')\n\n      Object.keys(parameters.uniformValues).forEach((key) => {\n        parameters[key] = parameters.uniformValues[key]\n      })\n\n      delete parameters.uniformValues\n    }\n\n    // copy parameters to (1) make use of internal #define generation\n    // and (2) prevent 'x is not a property of this material' warnings.\n    Object.keys(parameters).forEach((key) => {\n      this[key] = parameters[key]\n    })\n\n    // override default parameter values\n    this.setValues(parameters);\n\n    // override uniforms\n    this.uniforms = UniformsUtils.merge([uniforms, parameters.uniforms || {}]);\n\n    // set uniform values from parameters that affect uniforms\n    this.setUniformValues(parameters);\n  }\n\n  setUniformValues (values) {\n    if (!values) return;\n\n    const keys = Object.keys(values);\n\n    keys.forEach((key) => {\n      key in this.uniforms && (this.uniforms[key].value = values[key]);\n    });\n  }\n\n  stringifyChunk (name, customChunkName) { // #Modify\n    let value;\n\n    if (!this[name]) {\n      value = '';\n    }\n    else if (typeof this[name] ===  'string') {\n      value = this[name];\n    }\n    else {\n      value = this[name].join('\\n');\n    }\n\n    return customChunkName ? value.replace(name, customChunkName) : value; // #Modify\n  }\n}",
            "file_2": "class DistanceAnimationMaterial extends BaseAnimationMaterial {\n  constructor (parameters) {\n    super(parameters, ShaderLib['distanceRGBA'].uniforms);\n\n    this.depthPacking = RGBADepthPacking;\n    this.clipping = true;\n    this.vertexShader = this.concatVertexShader();\n    this.fragmentShader = ShaderLib['distanceRGBA'].fragmentShader;\n  }\n\n  concatVertexShader () {\n    return ShaderLib.distanceRGBA.vertexShader\n      .replace(\n        'void main() {',\n        `\n        ${this.stringifyChunk('vertexParameters', 'customVertexParameters')}\n        ${this.stringifyChunk('vertexFunctions', 'customVertexFunctions')}\n\n        void main() {\n          ${this.stringifyChunk('vertexInit', 'customVertexInit')}\n        `\n      )\n      .replace(\n        '#include <begin_vertex>',\n        `\n        #include <begin_vertex>\n\n        ${this.stringifyChunk('vertexPosition', 'customVertexPosition')}\n        `\n      )\n      .replace(\n        '#include <morphtarget_vertex>',\n        `\n        #include <morphtarget_vertex>\n\n        ${this.stringifyChunk('vertexPostMorph', 'customVertexPostMorph')}\n        `\n      )\n      .replace(\n        '#include <skinning_vertex>',\n        `\n        #include <skinning_vertex>\n\n        ${this.stringifyChunk('vertexPostSkinning', 'customVertexPostSkinning')}\n        `\n      )\n  }\n}",
            "file_3": "const Utils = {\n  createDepthAnimationMaterial: function(sourceMaterial) {\n    return new DepthAnimationMaterial({\n      uniforms: sourceMaterial.uniforms,\n      defines: sourceMaterial.defines,\n      vertexFunctions: sourceMaterial.vertexFunctions,\n      vertexParameters: sourceMaterial.vertexParameters,\n      vertexInit: sourceMaterial.vertexInit,\n      vertexPosition: sourceMaterial.vertexPosition\n    });\n  }\n};",
            "file_4": "const depthMaterial = Utils.createDepthAnimationMaterial(sourceMaterial);"
        }
    },
    {
        "repo": "howtocenterincss",
        "content": "'howtocenterincss/js/how/checks.js'\n:/* @flow */\n\nvar Options = require('./Options');\n\nvar invariant = require('invariant');\n\ntype Check = (\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n) => bool;\n\nfunction checkContent(check: (content: Options.Content) => bool): Check {\n  return (content, container, horizontalAlignment, verticalAlignment, browserSupport) => {\n    return check(content);\n  };\n}\n\nfunction checkContainer(check: (container: Options.Container) => bool): Check {\n  return (content, container, horizontalAlignment, verticalAlignment, browserSupport) => {\n    return check(container);\n  };\n}\n\nfunction checkContentText(check: (text: Options.Text) => bool): Check {\n  return (content, container, horizontalAlignment, verticalAlignment, browserSupport) => {\n    return content.text != null && check(content.text);\n  };\n}\n\nfunction checkContentIsText(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): bool {\n  return content.text != null;\n}\n\nfunction checkContentNotText(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): bool {\n  return content.text == null;\n}\n\nfunction requireLineHeight(\n  requirement: (text: Options.Length) => bool\n): (obj: Options.Text) => bool {\n  return (obj) => obj.lineHeight != null && requirement(obj.lineHeight);\n}\n\nvar requireLineHeightExists = requireLineHeight((l) => true);\n\nfunction requireFontSize(\n  requirement: (text: Options.Length) => bool\n): (obj: Options.Text) => bool {\n  return (obj) => obj.fontSize != null && requirement(obj.fontSize);\n}\n\nvar requireFontSizeExists = requireFontSize((l) => true);\n\nfunction requireHeight(\n  requirement: (length: Options.Length) => bool\n): (obj: Options.Content | Options.Container) => bool {\n  return (obj) => obj.height != null && requirement(obj.height);\n}\n\nvar requireHeightExists = requireHeight((l) => true);\n\nfunction requireWidth(\n  requirement: (length: Options.Length) => bool\n): (obj: Options.Content | Options.Container) => bool {\n  return (obj) => obj.width != null && requirement(obj.width);\n}\n\nvar requireWidthExists = requireWidth((w) => true);\n\nfunction requireIsPixel(length: Options.Length): bool {\n  return length.lengthType === Options.LengthType.PIXEL;\n}\n\nfunction requireIsPercentage(length: Options.Length): bool {\n  return length.lengthType === Options.LengthType.PERCENTAGE;\n}\n\nfunction requireIsEm(length: Options.Length): bool {\n  return length.lengthType === Options.LengthType.EM;\n}\n\nfunction checkAnyHorizontalAlignment(\n  alignments: Array<Options.HorizontalAlignment>\n): Check {\n  return (content, container, horizontalAlignment, verticalAlignment, browserSupport) => {\n    return alignments.indexOf(horizontalAlignment) !== -1;\n  };\n}\n\nfunction checkHorizontalAlignment(\n  alignment: Options.HorizontalAlignment\n): Check {\n  return checkAnyHorizontalAlignment([alignment]);\n}\n\nfunction checkAnyVerticalAlignment(\n  alignments: Array<Options.VerticalAlignment>\n): Check {\n  return (content, container, horizontalAlignment, verticalAlignment, browserSupport) => {\n    return alignments.indexOf(verticalAlignment) !== -1;\n  };\n}\n\nfunction checkVerticalAlignment(\n  alignment: Options.VerticalAlignment\n): Check {\n  return checkAnyVerticalAlignment([alignment]);\n}\n\nfunction checkBrowserSupport(requirementBrowserSupport: Options.BrowserSupport): Check {\n  return (content, container, horizontalAlignment, verticalAlignment, userBrowserSupport) => {\n    return requirementBrowserSupport.requiresBrowserSupport(userBrowserSupport);\n  };\n}\n\nmodule.exports.checkContent = checkContent;\nmodule.exports.checkContainer = checkContainer;\nmodule.exports.checkContentText = checkContentText;\nmodule.exports.checkContentIsText = checkContentIsText;\nmodule.exports.checkContentNotText = checkContentNotText;\nmodule.exports.requireLineHeight = requireLineHeight;\nmodule.exports.requireLineHeightExists = requireLineHeightExists;\nmodule.exports.requireFontSize = requireFontSize;\nmodule.exports.requireFontSizeExists = requireFontSizeExists;\nmodule.exports.requireHeight = requireHeight;\nmodule.exports.requireHeightExists = requireHeightExists;\nmodule.exports.requireWidth = requireWidth;\nmodule.exports.requireWidthExists = requireWidthExists;\nmodule.exports.requireIsPixel = requireIsPixel;\nmodule.exports.requireIsPercentage = requireIsPercentage;\nmodule.exports.requireIsEm = requireIsEm;\nmodule.exports.checkAnyHorizontalAlignment = checkAnyHorizontalAlignment;\nmodule.exports.checkHorizontalAlignment = checkHorizontalAlignment;\nmodule.exports.checkAnyVerticalAlignment = checkAnyVerticalAlignment;\nmodule.exports.checkVerticalAlignment = checkVerticalAlignment;\nmodule.exports.checkBrowserSupport = checkBrowserSupport;\n\n'howtocenterincss/js/how/methods/DoNothingMethod.js'\n:/* @flow */\n\nvar Method = require('./Method');\nvar Requirement = require('./Requirement');\nvar Options = require('../Options');\nvar React = require('react');\n\nvar invariant = require('invariant');\n\nvar c = require('../checks');\n\nclass DoNothingMethod extends Method {\n\n  getName(): string {\n    return 'Do nothing';\n  }\n\n  getRequirement(): Requirement {\n    return Requirement.all([\n      new Requirement(\n        'Horizontally left aligned',\n        c.checkHorizontalAlignment(Options.HorizontalAlignment.LEFT)\n      ),\n      new Requirement(\n        'Vertically top aligned',\n        c.checkVerticalAlignment(Options.VerticalAlignment.TOP)\n      ),\n    ]);\n  }\n\n  getCodeElement(\n    content: Options.Content,\n    container: Options.Container,\n    horizontalAlignment: Options.HorizontalAlignment,\n    verticalAlignment: Options.VerticalAlignment,\n    browserSupport: Options.BrowserSupport\n  ): { parent: ReactElement; middle: ?ReactElement; child: mixed; } {\n    var parentStyles = {};\n    parentStyles.position = 'relative';\n    var childStyles = {};\n    childStyles.position = 'absolute';\n\n    var child = this.getContent(content);\n\n    var parent =\n      <div>\n        {child}\n      </div>;\n\n    return { parent: parent, middle: null, child: child };\n  }\n}\n\nmodule.exports = DoNothingMethod;\n\n'howtocenterincss/js/how/findMethod.js'\n:/* @flow */\n\nvar Method = require('./methods/Method');\nvar Options = require('./Options');\nvar DoNothingMethod = require('./methods/DoNothingMethod');\nvar SingleLineTextLineHeightMethod =\n  require('./methods/SingleLineTextLineHeightMethod');\nvar PixelHeightContainerContentPaddingMethod =\n  require('./methods/PixelHeightContainerContentPaddingMethod');\nvar AbsolutePositionMethod = require('./methods/AbsolutePositionMethod');\nvar MarginAutoMethod = require('./methods/MarginAutoMethod');\nvar TableCellMethod = require('./methods/TableCellMethod');\nvar FlexMethod = require('./methods/FlexMethod');\nvar TextAlignMethod = require('./methods/TextAlignMethod');\n\n// This list is in order of preference. The first applicable method should be\n// used, as it's probably simpler.\nvar methods = [\n  new DoNothingMethod,\n  new TextAlignMethod,\n  new SingleLineTextLineHeightMethod(),\n  new MarginAutoMethod(),\n  new PixelHeightContainerContentPaddingMethod(),\n  new FlexMethod,\n  new AbsolutePositionMethod,\n  new TableCellMethod,\n];\n\nfunction findMethod(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): ?Method {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      return method;\n    }\n  }\n  return null;\n}\n\nmodule.exports = findMethod;\n\n'howtocenterincss/js/tests/snapshot.js'\n:/* @flow */\n\nrequire('colors');\nvar _ = require('underscore');\nvar fs = require('fs');\nvar wd = require('wd');\nvar BlinkDiff = require('blink-diff');\nvar PNGImage = require('pngjs-image');\nvar jsStringEscape = require('js-string-escape')\nvar chai = require('chai');\nvar invariant = require('invariant');\nvar tmp = require('tmp');\nvar Q = require('q');\nvar chaiAsPromised = require('chai-as-promised');\nvar findMethod = require('../how/findMethod');\n\nchai.use(chaiAsPromised);\nchai.should();\nchaiAsPromised.transferPromiseness = wd.transferPromiseness;\n\nvar testMatrix = require('./testMatrix');\nvar selenium = require('./selenium');\n\nfunction getReferenceFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getSnapshotName(test) + '.png';\n}\n\nfunction getReferenceTestHTMLFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getTestName(test) + '_test.html';\n}\n\nfunction getReferenceCodeFilename(test) {\n  var SCREENSHOTS_DIR = __dirname + '/../../screenshots';\n  return SCREENSHOTS_DIR + '/' + testMatrix.getTestName(test) + '.txt';\n}\n\nwd.configureHttp({\n  timeout: 60000,\n  retryDelay: 15000,\n  retries: 5\n});\n\nvar remoteConfig = undefined;\nvar browserMappings;\nif (process.env.SAUCE_USERNAME && process.env.SAUCE_ACCESS_KEY) {\n  remoteConfig = {\n    hostname: 'ondemand.saucelabs.com',\n    port: 80,\n    username: process.env.SAUCE_USERNAME,\n    accessKey: process.env.SAUCE_ACCESS_KEY,\n  };\n  browserMappings = selenium.sauceLabsBrowserMappings;\n} else {\n  browserMappings = selenium.localBrowserMappings;\n}\n\nvar isCreatingSnapshots = !!process.env.CREATE_SNAPSHOTS;\nvar allTests = testMatrix.generateTestsForSeleniumBrowsers(\n  browserMappings\n);\n\n// browser text rendering variances\nvar SCREENSHOT_TOLERANCE = 0.000003;\n\nvar WINDOW_WIDTH = 400;\nvar WINDOW_HEIGHT = 400;\n\nvar css =\n'body, html { margin: 0; padding: 0; overflow: hidden; border: 0; }' +\n'body { font-family: arial; }' +\n// The container sizing will get overridden if the options specify it.\n'#content { background: #f00; width: 25px; height: 25px; }' +\n'#container { background: #0ff; width: 300px; height: 300px; }';\n\nvar fontSizeCSS =\n'body { font-size: ' + testMatrix.fontSize + 'px; }' +\n// By default, the browser has a 1.1-1.2em of line-height. This makes\n// calculating vertical centering different across methods.\n// TODO - this needs to be exposed as a notice to the user, or baked into the\n// code the method generates.\n'#content, #container { line-height: 1em; }' +\n'#content { background: 0 !important; }' +\n// The content sizing will get overridden if the method specifies it.\n'#content { width: auto; height: auto; }';\n\nfunction getOuterDivCSS(width, height) {\n  // For some reason, IE screenshots disregard the height of the body if there is\n  // nothing in it. We need a div to be opaquely white.\n  return '#testOuterDiv { background: white; width: ' + width + 'px; height: ' + height + 'px;}';\n}\n\n// http://www.phpied.com/dynamic-script-and-style-elements-in-ie/\nfunction getJStoInjectCSS(css: string) {\n  return (\n    'var ss1 = document.createElement(\"style\");' +\n    'var def = \"' + jsStringEscape(css) + '\";' +\n    'ss1.setAttribute(\"type\", \"text/css\");' +\n    'var hh1 = document.getElementsByTagName(\"head\")[0];' +\n    'hh1.appendChild(ss1);' +\n    'if (ss1.styleSheet) {' /*IE*/ +\n    '  ss1.styleSheet.cssText = def;' +\n    '} else {' /* errbody else */ +\n    '  var tt1 = document.createTextNode(def);' +\n    '  ss1.appendChild(tt1);' +\n    '}'\n  );\n}\n\nvar useBrowser = isCreatingSnapshots || remoteConfig;\n\nallTests.forEach(seleniumTests => {\n\n  var browser = seleniumTests.seleniumBrowser;\n  var tests = seleniumTests.tests;\n\n  global.suite('using ' + browser.getDisplayName(), () => {\n    var b;\n    var allPassed = true;\n    var windowWidth = WINDOW_WIDTH + browser.cropBoundary.addX;\n    var windowHeight = WINDOW_HEIGHT + browser.cropBoundary.addY;\n\n    global.suiteSetup(done => {\n      if (!useBrowser) {\n        done();\n        return;\n      }\n\n      b = wd.promiseChainRemote(remoteConfig);\n\n      if (process.env.SNAPSHOT_DEBUG) {\n        b.on('status', function(info) {\n            console.log(info.cyan);\n        });\n        b.on('command', function(eventType, command, response) {\n            console.log(' > ' + eventType.cyan, command, (response || '').grey);\n        });\n        b.on('http', function(meth, path, data) {\n            console.log(' > ' + meth.magenta, path, (data || '').grey);\n        });\n      }\n\n      b\n        .init(browser.toSeleniumJSON())\n        .setWindowSize(windowWidth, windowHeight)\n        .elementByTagName('html')\n        .getSize()\n        .then(size => {\n          invariant(b, 'flow');\n          // Browser titles/bars short change you, so set it so the document's\n          // 400x400.\n          return b.setWindowSize(windowWidth + (windowWidth - size.width), windowHeight + (windowHeight - size.height));\n        })\n        .nodeify(done);\n    });\n\n    global.suiteTeardown(done => {\n      if (!b) {\n        done();\n        return;\n      }\n\n      b\n        .quit()\n        .nodeify(done);\n    });\n\n    global.setup(done => {\n      if (!b) {\n        done();\n        return;\n      }\n      b\n        // Get all the browsers to render in as much standards mode as possible.\n        .get('http://dump.oliverzheng.com/doctype_html5.html')\n        .nodeify(done);\n    });\n\n    tests.forEach(t => {\n      var testName = testMatrix.getTestName(t);\n      var mochaTestName =\n        (isCreatingSnapshots ? 'Snapshot ' : 'Compare snapshot ') + testName;\n\n      global.test(mochaTestName, (done) => {\n        var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n        invariant(method, 'flow');\n        method.addIDs();\n        method.setIsTest();\n        var html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n        var canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\n\n        var codeGenerated = canonicalCode.html;\n        if (canonicalCode.parentCSS) {\n          codeGenerated += '\\n\\n#parent {\\n' + canonicalCode.parentCSS + '\\n}';\n        }\n        if (canonicalCode.middleCSS) {\n          codeGenerated += '\\n\\n#middle {\\n' + canonicalCode.middleCSS + '\\n}';\n        }\n        if (canonicalCode.childCSS) {\n          codeGenerated += '\\n\\n#child {\\n' + canonicalCode.childCSS + '\\n}';\n        }\n\n        if (!useBrowser) {\n          // We only don't use the browser if we are comparing generated code\n          var referenceCode = fs.readFileSync(getReferenceCodeFilename(t), 'utf8');\n          if (referenceCode !== codeGenerated) {\n            done('Reference code not equal to code generated: ' + codeGenerated);\n          } else {\n            done();\n          }\n          return;\n        }\n\n        var cssToInject = css;\n        if (t.content.text) {\n          cssToInject += fontSizeCSS;\n        }\n\n        cssToInject += getOuterDivCSS(windowWidth, windowHeight);\n        if (isCreatingSnapshots) {\n          fs.writeFileSync(getReferenceCodeFilename(t), codeGenerated);\n        }\n        fs.writeFileSync(getReferenceTestHTMLFilename(t), '<style>' + cssToInject + '</style>' + html);\n\n        invariant(b, 'flow');\n        var insertJS =\n          'document.body.innerHTML = \"' + jsStringEscape('<div id=\"testOuterDiv\">' + html + '</div>') + '\";';\n        // In quirksmode, IE's box model stretches the height to fit the\n        // font-size. We could set 'overflow:hidden' to it, but it could mess\n        // with the actual generated code. So let's conditionally add font size\n        // when we need it.\n        var res =\n          b.execute(getJStoInjectCSS(cssToInject) + insertJS);\n\n        var referenceFilename = getReferenceFilename(t);\n        if (isCreatingSnapshots && !fs.existsSync(referenceFilename)) {\n          // Write the image for the first, compare all the ones after it to\n          // this.\n          res = res.saveScreenshot(referenceFilename);\n        } else {\n          var tmpFilename = tmp.tmpNameSync({\n            // for finding it easier in Finder\n            prefix: 'screenshot-' + Date.now() + '-' + testName + '-',\n            postfix: '.png',\n          });\n          res = res\n            .saveScreenshot(tmpFilename)\n            .then(() => {\n              tmpFilename\n              var blinkDiffOptions = {};\n              blinkDiffOptions.imageAPath = referenceFilename;\n              blinkDiffOptions.thresholdType = BlinkDiff.THRESHOLD_PERCENT;\n              if (browser.hasCropBoundary()) {\n                var image = PNGImage.readImageSync(tmpFilename);\n                image.clip(\n                  browser.cropBoundary.cropX,\n                  browser.cropBoundary.cropY,\n                  WINDOW_WIDTH,\n                  WINDOW_HEIGHT\n                );\n                blinkDiffOptions.imageB = image;\n              } else {\n                blinkDiffOptions.imageBPath = tmpFilename;\n              }\n              var blinkDiff = new BlinkDiff(blinkDiffOptions);\n              return Q.ninvoke(blinkDiff, 'run');\n            })\n            .then(result => {\n              var diff = result.differences / result.dimension;\n              var pass = diff < SCREENSHOT_TOLERANCE;\n              var deferred = Q.defer();\n              if (pass) {\n                fs.unlinkSync(tmpFilename);\n                deferred.resolve(diff);\n              } else {\n                deferred.reject(\n                  tmpFilename +\n                  ' is not equal to reference ' +\n                  referenceFilename +\n                  ', diff: ' + diff +\n                  ', tolerance: ' + SCREENSHOT_TOLERANCE\n                );\n              }\n              return deferred.promise;\n            });\n        }\n        res.nodeify(done);\n      });\n    });\n  });\n});\n\n",
        "called_code_segment_file_1": "class DoNothingMethod extends Method {\n  getName(): string {\n    return 'Do nothing';\n  }\n\n  getRequirement(): Requirement {\n    return Requirement.all([\n      new Requirement(\n        'Horizontally left aligned',\n        c.checkHorizontalAlignment(Options.HorizontalAlignment.LEFT)\n      ),\n      new Requirement(\n        'Vertically top aligned',\n        c.checkVerticalAlignment(Options.VerticalAlignment.TOP)\n      ),\n    ]);\n  }\n\n  getCodeElement(\n    content: Options.Content,\n    container: Options.Container,\n    horizontalAlignment: Options.HorizontalAlignment,\n    verticalAlignment: Options.VerticalAlignment,\n    browserSupport: Options.BrowserSupport\n  ): { parent: ReactElement; middle: ?ReactElement; child: mixed; } {\n    var parentStyles = {};\n    parentStyles.position = 'relative';\n    var childStyles = {};\n    childStyles.position = 'absolute';\n\n    var child = this.getContent(content);\n\n    var parent =\n      <div>\n        {child}\n      </div>;\n\n    return { parent: parent, middle: null, child: child };\n  }\n}",
        "invoking_code_segment_file_2": "function findMethod(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): ?Method {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      return method;\n    }\n  }\n  return null;\n}",
        "called_code_segment_file_2": "function findMethod(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): ?Method {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      return method;\n    }\n  }\n  return null;\n}",
        "using_code_segment_file_3": "var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\ninvariant(method, 'flow');\nmethod.addIDs();\nmethod.setIsTest();\nvar html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\nvar canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);",
        "called_code_segment_file_3": "var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\ninvariant(method, 'flow');\nmethod.addIDs();\nmethod.setIsTest();\nvar html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\nvar canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);",
        "using_code_segment_file_4": "var res =\n  b.execute(getJStoInjectCSS(cssToInject) + insertJS);\n\nvar referenceFilename = getReferenceFilename(t);\nif (isCreatingSnapshots && !fs.existsSync(referenceFilename)) {\n  // Write the image for the first, compare all the ones after it to\n  // this.\n  res = res.saveScreenshot(referenceFilename);\n} else {\n  var tmpFilename = tmp.tmpNameSync({\n    // for finding it easier in Finder\n    prefix: 'screenshot-' + Date.now() + '-' + testName + '-',\n    postfix: '.png',\n  });\n  res = res\n    .saveScreenshot(tmpFilename)\n    .then(() => {\n      tmpFilename\n      var blinkDiffOptions = {};\n      blinkDiffOptions.imageAPath = referenceFilename;\n      blinkDiffOptions.thresholdType = BlinkDiff.THRESHOLD_PERCENT;\n      if (browser.hasCropBoundary()) {\n        var image = PNGImage.readImageSync(tmpFilename);\n        image.clip(\n          browser.cropBoundary.cropX,\n          browser.cropBoundary.cropY,\n          WINDOW_WIDTH,\n          WINDOW_HEIGHT\n        );\n        blinkDiffOptions.imageB = image;\n      } else {\n        blinkDiffOptions.imageBPath = tmpFilename;\n      }\n      var blinkDiff = new BlinkDiff(blinkDiffOptions);\n      return Q.ninvoke(blinkDiff, 'run');\n    })\n    .then(result => {\n      var diff = result.differences / result.dimension;\n      var pass = diff < SCREENSHOT_TOLERANCE;\n      var deferred = Q.defer();\n      if (pass) {\n        fs.unlinkSync(tmpFilename);\n        deferred.resolve(diff);\n      } else {\n        deferred.reject(\n          tmpFilename +\n          ' is not equal to reference ' +\n          referenceFilename +\n          ', diff: ' + diff +\n          ', tolerance: ' + SCREENSHOT_TOLERANCE\n        );\n      }\n      return deferred.promise;\n    });\n}",
        "feature_description": "Add a feature to log the method name used for centering before returning the method in `findMethod`.",
        "detailed_feature_description": "The new feature will log the method name used for centering before returning the method in `findMethod`. This will help in debugging and understanding which method is being used for centering. The `findMethod` function in #file 2 will be updated to log the method name. The `DoNothingMethod` class in #file 1 will be modified to include a new method `getMethodName` to return the method name. The `findMethod` function in #file 2 will call this new method and log the method name. The `findMethod` function in #file 3 will be updated to handle the modified `findMethod` function from #file 2. The `snapshot.js` file in #file 4 will be updated if it interacts with or depends on any updated segments in #file 3.",
        "modified_complete_code": {
            "#file 1": "class DoNothingMethod extends Method {\n  getName(): string {\n    return 'Do nothing';\n  }\n\n  getRequirement(): Requirement {\n    return Requirement.all([\n      new Requirement(\n        'Horizontally left aligned',\n        c.checkHorizontalAlignment(Options.HorizontalAlignment.LEFT)\n      ),\n      new Requirement(\n        'Vertically top aligned',\n        c.checkVerticalAlignment(Options.VerticalAlignment.TOP)\n      ),\n    ]);\n  }\n\n  getCodeElement(\n    content: Options.Content,\n    container: Options.Container,\n    horizontalAlignment: Options.HorizontalAlignment,\n    verticalAlignment: Options.VerticalAlignment,\n    browserSupport: Options.BrowserSupport\n  ): { parent: ReactElement; middle: ?ReactElement; child: mixed; } {\n    var parentStyles = {};\n    parentStyles.position = 'relative';\n    var childStyles = {};\n    childStyles.position = 'absolute';\n\n    var child = this.getContent(content);\n\n    var parent =\n      <div>\n        {child}\n      </div>;\n\n    return { parent: parent, middle: null, child: child };\n  }\n\n  #Modify getMethodName(): string {\n    return this.getName();\n  }\n}",
            "#file 2": "function findMethod(\n  content: Options.Content,\n  container: Options.Container,\n  horizontalAlignment: Options.HorizontalAlignment,\n  verticalAlignment: Options.VerticalAlignment,\n  browserSupport: Options.BrowserSupport\n): ?Method {\n  for (var i = 0; i < methods.length; i++) {\n    var method = methods[i];\n    if (method.getRequirement().check(content, container, horizontalAlignment, verticalAlignment, browserSupport)) {\n      console.log('Method used for centering:', method.getMethodName());\n      return method;\n    }\n  }\n  return null;\n}",
            "#file 3": "var method = findMethod(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\ninvariant(method, 'flow');\nmethod.addIDs();\nmethod.setIsTest();\nvar html = method.getCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);\nvar canonicalCode = method.getCanonicalCode(t.content, t.container, t.horizontal, t.vertical, t.browserSupport);",
            "#file 4": "var res =\n  b.execute(getJStoInjectCSS(cssToInject) + insertJS);\n\nvar referenceFilename = getReferenceFilename(t);\nif (isCreatingSnapshots && !fs.existsSync(referenceFilename)) {\n  // Write the image for the first, compare all the ones after it to\n  // this.\n  res = res.saveScreenshot(referenceFilename);\n} else {\n  var tmpFilename = tmp.tmpNameSync({\n    // for finding it easier in Finder\n    prefix: 'screenshot-' + Date.now() + '-' + testName + '-',\n    postfix: '.png',\n  });\n  res = res\n    .saveScreenshot(tmpFilename)\n    .then(() => {\n      tmpFilename\n      var blinkDiffOptions = {};\n      blinkDiffOptions.imageAPath = referenceFilename;\n      blinkDiffOptions.thresholdType = BlinkDiff.THRESHOLD_PERCENT;\n      if (browser.hasCropBoundary()) {\n        var image = PNGImage.readImageSync(tmpFilename);\n        image.clip(\n          browser.cropBoundary.cropX,\n          browser.cropBoundary.cropY,\n          WINDOW_WIDTH,\n          WINDOW_HEIGHT\n        );\n        blinkDiffOptions.imageB = image;\n      } else {\n        blinkDiffOptions.imageBPath = tmpFilename;\n      }\n      var blinkDiff = new BlinkDiff(blinkDiffOptions);\n      return Q.ninvoke(blinkDiff, 'run');\n    })\n    .then(result => {\n      var diff = result.differences / result.dimension;\n      var pass = diff < SCREENSHOT_TOLERANCE;\n      var deferred = Q.defer();\n      if (pass) {\n        fs.unlinkSync(tmpFilename);\n        deferred.resolve(diff);\n      } else {\n        deferred.reject(\n          tmpFilename +\n          ' is not equal to reference ' +\n          referenceFilename +\n          ', diff: ' + diff +\n          ', tolerance: ' + SCREENSHOT_TOLERANCE\n        );\n      }\n      return deferred.promise;\n    });\n}"
        }
    },
    {
        "repo": "PERN-STACK-DEPLOYMENT",
        "content": "'PERN-STACK-DEPLOYMENT/client/src/components/AddRestaurant.jsx'\n:import React, { useState, useContext } from \"react\";\nimport RestaurantFinder from \"../apis/RestaurantFinder\";\nimport { RestaurantsContext } from \"../context/RestaurantsContext\";\n\nconst AddRestaurant = () => {\n  const { addRestaurants } = useContext(RestaurantsContext);\n  const [name, setName] = useState(\"\");\n  const [location, setLocation] = useState(\"\");\n  const [priceRange, setPriceRange] = useState(\"Price Range\");\n\n  const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const response = await RestaurantFinder.post(\"/\", {\n        name,\n        location,\n        price_range: priceRange,\n      });\n      console.log(response.data.data);\n      addRestaurants(response.data.data.restaurant);\n    } catch (err) {\n      console.log(err);\n    }\n  };\n  return (\n    <div className=\"mb-4\">\n      <form action=\"\">\n        <div className=\"form-row\">\n          <div className=\"col\">\n            <input\n              value={name}\n              onChange={(e) => setName(e.target.value)}\n              type=\"text\"\n              className=\"form-control\"\n              placeholder=\"name\"\n            />\n          </div>\n          <div className=\"col\">\n            <input\n              value={location}\n              onChange={(e) => setLocation(e.target.value)}\n              className=\"form-control\"\n              type=\"text\"\n              placeholder=\"location\"\n            />\n          </div>\n          <div className=\"col\">\n            <select\n              value={priceRange}\n              onChange={(e) => setPriceRange(e.target.value)}\n              className=\"custom-select my-1 mr-sm-2\"\n            >\n              <option disabled>Price Range</option>\n              <option value=\"1\">$</option>\n              <option value=\"2\">$$</option>\n              <option value=\"3\">$$$</option>\n              <option value=\"4\">$$$$</option>\n              <option value=\"5\">$$$$$</option>\n            </select>\n          </div>\n          <button\n            onClick={handleSubmit}\n            type=\"submit\"\n            className=\"btn btn-primary\"\n          >\n            Add\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n};\n\nexport default AddRestaurant;\n\n'PERN-STACK-DEPLOYMENT/client/src/routes/Home.jsx'\n:import React from \"react\";\nimport Header from \"../components/Header\";\nimport AddRestaurant from \"../components/AddRestaurant\";\nimport RestaurantList from \"../components/RestaurantList\";\n\nconst Home = () => {\n  return (\n    <div>\n      <Header />\n      <AddRestaurant />\n      <RestaurantList />\n    </div>\n  );\n};\n\nexport default Home;\n\n'PERN-STACK-DEPLOYMENT/client/src/App.jsx'\n:import React from \"react\";\nimport { BrowserRouter as Router, Switch, Route } from \"react-router-dom\";\nimport Home from \"./routes/Home\";\nimport UpdatePage from \"./routes/UpdatePage\";\nimport RestaurantDetailPage from \"./routes/RestaurantDetailPage\";\nimport { RestaurantsContextProvider } from \"./context/RestaurantsContext\";\nconst App = () => {\n  return (\n    <RestaurantsContextProvider>\n      <div className=\"container\">\n        <Router>\n          <Switch>\n            <Route exact path=\"/\" component={Home} />\n            <Route\n              exact\n              path=\"/restaurants/:id/update\"\n              component={UpdatePage}\n            />\n            <Route\n              exact\n              path=\"/restaurants/:id\"\n              component={RestaurantDetailPage}\n            />\n          </Switch>\n        </Router>\n      </div>\n    </RestaurantsContextProvider>\n  );\n};\n\nexport default App;\n\n'PERN-STACK-DEPLOYMENT/client/src/index.js'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\n",
        "called_code_segment_file_1": "const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const response = await RestaurantFinder.post(\"/\", {\n        name,\n        location,\n        price_range: priceRange,\n      });\n      console.log(response.data.data);\n      addRestaurants(response.data.data.restaurant);\n    } catch (err) {\n      console.log(err);\n    }\n  };",
        "invoking_code_segment_file_2": "<button\n            onClick={handleSubmit}\n            type=\"submit\"\n            className=\"btn btn-primary\"\n          >\n            Add\n          </button>",
        "called_code_segment_file_2": "const { addRestaurants } = useContext(RestaurantsContext);",
        "using_code_segment_file_3": "const RestaurantsContextProvider = ({ children }) => {\n  const [restaurants, setRestaurants] = useState([]);\n  const addRestaurants = (restaurant) => {\n    setRestaurants([...restaurants, restaurant]);\n  };\n  return (\n    <RestaurantsContext.Provider\n      value={{\n        restaurants,\n        setRestaurants,\n        addRestaurants,\n      }}\n    >\n      {children}\n    </RestaurantsContext.Provider>\n  );\n};",
        "called_code_segment_file_3": "const RestaurantsContextProvider = ({ children }) => {\n  const [restaurants, setRestaurants] = useState([]);\n  const addRestaurants = (restaurant) => {\n    setRestaurants([...restaurants, restaurant]);\n  };\n  return (\n    <RestaurantsContext.Provider\n      value={{\n        restaurants,\n        setRestaurants,\n        addRestaurants,\n      }}\n    >\n      {children}\n    </RestaurantsContext.Provider>\n  );\n};",
        "using_code_segment_file_4": "const App = () => {\n  return (\n    <RestaurantsContextProvider>\n      <div className=\"container\">\n        <Router>\n          <Switch>\n            <Route exact path=\"/\" component={Home} />\n            <Route\n              exact\n              path=\"/restaurants/:id/update\"\n              component={UpdatePage}\n            />\n            <Route\n              exact\n              path=\"/restaurants/:id\"\n              component={RestaurantDetailPage}\n            />\n          </Switch>\n        </Router>\n      </div>\n    </RestaurantsContextProvider>\n  );\n};",
        "feature_description": "Add a feature to log the restaurant data to the console before adding it to the context.",
        "detailed_feature_description": "Modify the handleSubmit function in AddRestaurant.jsx to log the restaurant data to the console before calling addRestaurants. Update the AddRestaurant component in Home.jsx to ensure it handles the new logging feature. No changes are required in RestaurantList.jsx or App.jsx as they do not directly interact with the modified code.",
        "modified_complete_code": {
            "AddRestaurant.jsx": "const handleSubmit = async (e) => {\n    e.preventDefault();\n    try {\n      const response = await RestaurantFinder.post(\"/\", {\n        name,\n        location,\n        price_range: priceRange,\n      });\n      console.log(response.data.data);\n      #Modify console.log(response.data.data.restaurant);\n      addRestaurants(response.data.data.restaurant);\n    } catch (err) {\n      console.log(err);\n    }\n  };",
            "Home.jsx": "const Home = () => {\n  return (\n    <div>\n      <Header />\n      <AddRestaurant />\n      <RestaurantList />\n    </div>\n  );\n};",
            "RestaurantsContext.jsx": "const RestaurantsContextProvider = ({ children }) => {\n  const [restaurants, setRestaurants] = useState([]);\n  const addRestaurants = (restaurant) => {\n    setRestaurants([...restaurants, restaurant]);\n  };\n  return (\n    <RestaurantsContext.Provider\n      value={{\n        restaurants,\n        setRestaurants,\n        addRestaurants,\n      }}\n    >\n      {children}\n    </RestaurantsContext.Provider>\n  );\n};",
            "App.jsx": "const App = () => {\n  return (\n    <RestaurantsContextProvider>\n      <div className=\"container\">\n        <Router>\n          <Switch>\n            <Route exact path=\"/\" component={Home} />\n            <Route\n              exact\n              path=\"/restaurants/:id/update\"\n              component={UpdatePage}\n            />\n            <Route\n              exact\n              path=\"/restaurants/:id\"\n              component={RestaurantDetailPage}\n            />\n          </Switch>\n        </Router>\n      </div>\n    </RestaurantsContextProvider>\n  );\n};"
        }
    },
    {
        "repo": "example-d3-react",
        "content": "'example-d3-react/src/d3Chart.js'\n:var EventEmitter = require('events').EventEmitter;\nvar d3 = require('d3');\n\nrequire('./d3Chart.less');\n\nvar ANIMATION_DURATION = 400;\nvar TOOLTIP_WIDTH = 30;\nvar TOOLTIP_HEIGHT = 30;\n\nvar ns = {};\n\nns.create = function(el, props, state) {\n  var svg = d3.select(el).append('svg')\n      .attr('class', 'd3')\n      .attr('width', props.width)\n      .attr('height', props.height);\n\n  svg.append('g')\n      .attr('class', 'd3-points');\n\n  svg.append('g')\n      .attr('class', 'd3-tooltips');\n\n  var dispatcher = new EventEmitter();\n  this.update(el, state, dispatcher);\n\n  return dispatcher;\n};\n\nns.update = function(el, state, dispatcher) {\n  var scales = this._scales(el, state.domain);\n  var prevScales = this._scales(el, state.prevDomain);\n  this._drawPoints(el, scales, state.data, prevScales, dispatcher);\n  this._drawTooltips(el, scales, state.tooltips, prevScales);\n};\n\nns._scales = function(el, domain) {\n  if (!domain) {\n    return null;\n  }\n\n  var width = el.offsetWidth;\n  var height = el.offsetHeight;\n\n  var x = d3.scale.linear()\n    .range([0, width])\n    .domain(domain.x);\n\n  var y = d3.scale.linear()\n    .range([height, 0])\n    .domain(domain.y);\n\n  var z = d3.scale.linear()\n    .range([5, 20])\n    .domain([1, 10]);\n\n  return {x: x, y: y, z: z};\n};\n\nns._drawPoints = function(el, scales, data, prevScales, dispatcher) {\n  var g = d3.select(el).selectAll('.d3-points');\n\n  var point = g.selectAll('.d3-point')\n    .data(data, function(d) { return d.id; });\n\n  point.enter().append('circle')\n      .attr('class', 'd3-point')\n      .attr('cx', function(d) {\n        if (prevScales) {\n          return prevScales.x(d.x);\n        }\n        return scales.x(d.x);\n      })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('cx', function(d) { return scales.x(d.x); });\n\n  point.attr('cy', function(d) { return scales.y(d.y); })\n      .attr('r', function(d) { return scales.z(d.z); })\n      .on('mouseover', function(d) {\n        dispatcher.emit('point:mouseover', d);\n      })\n      .on('mouseout', function(d) {\n        dispatcher.emit('point:mouseout', d);\n      })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('cx', function(d) { return scales.x(d.x); });\n\n  if (prevScales) {\n    point.exit()\n      .transition()\n        .duration(ANIMATION_DURATION)\n        .attr('cx', function(d) { return scales.x(d.x); })\n        .remove();\n  }\n  else {\n    point.exit()\n        .remove();\n  }\n};\n\nns._drawTooltips = function(el, scales, tooltips, prevScales) {\n  var g = d3.select(el).selectAll('.d3-tooltips');\n\n  var tooltipRect = g.selectAll('.d3-tooltip-rect')\n    .data(tooltips, function(d) { return d.id; });\n\n  tooltipRect.enter().append('rect')\n      .attr('class', 'd3-tooltip-rect')\n      .attr('width', TOOLTIP_WIDTH)\n      .attr('height', TOOLTIP_HEIGHT)\n      .attr('x', function(d) {\n        if (prevScales) {\n          return prevScales.x(d.x) - TOOLTIP_WIDTH/2;\n        }\n        return scales.x(d.x) - TOOLTIP_WIDTH/2;\n      })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('x', function(d) { return scales.x(d.x) - TOOLTIP_WIDTH/2; });\n\n  tooltipRect.attr('y', function(d) { return scales.y(d.y) - scales.z(d.z)/2 - TOOLTIP_HEIGHT; })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('x', function(d) { return scales.x(d.x) - TOOLTIP_WIDTH/2; });\n\n  if (prevScales) {\n    tooltipRect.exit()\n      .transition()\n        .duration(ANIMATION_DURATION)\n        .attr('x', function(d) { return scales.x(d.x) - TOOLTIP_WIDTH/2; })\n        .remove();\n  }\n  else {\n    tooltipRect.exit()\n        .remove();\n  }\n\n  var tooltipText = g.selectAll('.d3-tooltip-text')\n    .data(tooltips, function(d) { return d.id; });\n\n  tooltipText.enter().append('text')\n      .attr('class', 'd3-tooltip-text')\n      .attr('dy', '0.35em')\n      .attr('text-anchor', 'middle')\n      .text(function(d) { return d.z; })\n      .attr('x', function(d) {\n        if (prevScales) {\n          return prevScales.x(d.x);\n        }\n        return scales.x(d.x);\n      })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('x', function(d) { return scales.x(d.x); });\n\n  tooltipText.attr('y', function(d) { return scales.y(d.y) - scales.z(d.z)/2 - TOOLTIP_HEIGHT/2; })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('x', function(d) { return scales.x(d.x); });\n\n  if (prevScales) {\n    tooltipText.exit()\n      .transition()\n        .duration(ANIMATION_DURATION)\n        .attr('x', function(d) { return scales.x(d.x); })\n        .remove();\n  }\n  else {\n    tooltipText.exit()\n        .remove();\n  }\n};\n\nns.destroy = function(el) {\n\n};\n\nmodule.exports = ns;\n\n'example-d3-react/src/Chart.js'\n:/** @jsx React.DOM */\n\nvar React = require('react');\nvar _ = require('lodash');\n\nvar d3Chart = require('./d3Chart');\n\nrequire('./Chart.less');\n\nvar Chart = React.createClass({\n  getDefaultProps: function() {\n    return {\n      width: '100%',\n      height: '300px'\n    };\n  },\n\n  dispatcher: null,\n\n  componentDidMount: function() {\n    var el = this.getDOMNode();\n    var dispatcher = d3Chart.create(el, {\n      width: this.props.width,\n      height: this.props.height\n    }, this.getChartState());\n    dispatcher.on('point:mouseover', this.showTooltip);\n    dispatcher.on('point:mouseout', this.hideTooltip);\n    this.dispatcher = dispatcher;\n  },\n\n  componentDidUpdate: function(prevProps, prevState) {\n    var el = this.getDOMNode();\n    d3Chart.update(el, this.getChartState(), this.dispatcher);\n  },\n\n  getChartState: function() {\n    var appState = this.props.appState;\n\n    var tooltips = [];\n    if (appState.showingAllTooltips) {\n      tooltips = appState.data;\n    }\n    else if (appState.tooltip) {\n      tooltips = [appState.tooltip];\n    }\n\n    return _.assign({}, appState, {tooltips: tooltips});\n  },\n\n  render: function() {\n    return (\n      <div className=\"Chart\"></div>\n    );\n  },\n\n  showTooltip: function(d) {\n    if (this.props.appState.showingAllTooltips) {\n      return;\n    }\n\n    this.props.setAppState({\n      tooltip: d,\n      // Disable animation\n      prevDomain: null\n    });\n  },\n\n  hideTooltip: function() {\n    if (this.props.appState.showingAllTooltips) {\n      return;\n    }\n    \n    this.props.setAppState({\n      tooltip: null,\n      prevDomain: null\n    });\n  }\n});\n\nmodule.exports = Chart;\n\n'example-d3-react/src/App.js'\n:/** @jsx React.DOM */\n\nvar React = require('react');\nvar _ = require('lodash');\n\nvar dataGenerator = require('./dataGenerator');\n\nvar Pagination = require('./Pagination');\nvar Chart = require('./Chart');\nvar Stats = require('./Stats');\nvar ShowHideTooltips = require('./ShowHideTooltips');\nvar AddRemoveDatum = require('./AddRemoveDatum');\n\nrequire('./App.less');\n\nvar App = React.createClass({\n  getInitialState: function() {\n    var domain = [0, 30];\n    return {\n      data: this.getData(domain),\n      domain: {x: domain, y: [0, 100]},\n      tooltip: null,\n      prevDomain: null,\n      showingAllTooltips: false\n    };\n  },\n\n  _allData: dataGenerator.generate(50),\n\n  getData: function(domain) {\n    return _.filter(this._allData, this.isInDomain.bind(null, domain));\n  },\n\n  addDatum: function(domain) {\n    this._allData.push(dataGenerator.generateDatum(domain));\n    return this.getData(domain);\n  },\n\n  removeDatum: function(domain) {\n    var match = _.find(this._allData, this.isInDomain.bind(null, domain));\n    if (match) {\n      this._allData = _.reject(this._allData, {id: match.id});\n    }\n    return this.getData(domain);\n  },\n\n  isInDomain: function(domain, d) {\n    return d.x >= domain[0] && d.x <= domain[1];\n  },\n\n  render: function() {\n    return (\n      <div className=\"App\">\n        <Pagination\n          appState={this.state}\n          setAppState={this.setAppState}\n          getData={this.getData} />\n        <Chart\n          appState={this.state}\n          setAppState={this.setAppState} />\n        <Stats data={this.state.data} />\n        <ShowHideTooltips\n          appState={this.state}\n          setAppState={this.setAppState} />\n        <AddRemoveDatum\n          appState={this.state}\n          setAppState={this.setAppState}\n          addDatum={this.addDatum}\n          removeDatum={this.removeDatum} />\n      </div>\n    );\n  },\n\n  setAppState: function(partialState, callback) {\n    return this.setState(partialState, callback);\n  }\n});\n\nmodule.exports = App;\n\n'example-d3-react/src/main.js'\n:var React = require('react');\n\nvar App = require('./App');\n\nwindow.app = React.renderComponent(App(), document.body);\n\n",
        "called_code_segment_file_1": "ns.create = function(el, props, state) {\n  var svg = d3.select(el).append('svg')\n      .attr('class', 'd3')\n      .attr('width', props.width)\n      .attr('height', props.height);\n\n  svg.append('g')\n      .attr('class', 'd3-points');\n\n  svg.append('g')\n      .attr('class', 'd3-tooltips');\n\n  var dispatcher = new EventEmitter();\n  this.update(el, state, dispatcher);\n\n  return dispatcher;\n};",
        "invoking_code_segment_file_2": "componentDidMount: function() {\n    var el = this.getDOMNode();\n    var dispatcher = d3Chart.create(el, {\n      width: this.props.width,\n      height: this.props.height\n    }, this.getChartState());\n    dispatcher.on('point:mouseover', this.showTooltip);\n    dispatcher.on('point:mouseout', this.hideTooltip);\n    this.dispatcher = dispatcher;\n  },",
        "called_code_segment_file_2": "showTooltip: function(d) {\n    if (this.props.appState.showingAllTooltips) {\n      return;\n    }\n\n    this.props.setAppState({\n      tooltip: d,\n      // Disable animation\n      prevDomain: null\n    });\n  },",
        "using_code_segment_file_3": "setAppState: function(partialState, callback) {\n    return this.setState(partialState, callback);\n  }",
        "called_code_segment_file_3": "N/A",
        "using_code_segment_file_4": "N/A",
        "feature_description": "Add a feature to highlight the tooltip when the mouse is over a point.",
        "detailed_feature_description": "Modify the `showTooltip` function in `Chart.js` to add a class to the tooltip that highlights it. Update the `d3Chart.js` to handle this new class and ensure the `App.js` state is updated accordingly.",
        "modified_complete_code": {
            "d3Chart.js": "#Modify\nns.create = function(el, props, state) {\n  var svg = d3.select(el).append('svg')\n      .attr('class', 'd3')\n      .attr('width', props.width)\n      .attr('height', props.height);\n\n  svg.append('g')\n      .attr('class', 'd3-points');\n\n  svg.append('g')\n      .attr('class', 'd3-tooltips');\n\n  var dispatcher = new EventEmitter();\n  this.update(el, state, dispatcher);\n\n  return dispatcher;\n};\n\n#Modify\nns._drawTooltips = function(el, scales, tooltips, prevScales) {\n  var g = d3.select(el).selectAll('.d3-tooltips');\n\n  var tooltipRect = g.selectAll('.d3-tooltip-rect')\n    .data(tooltips, function(d) { return d.id; });\n\n  tooltipRect.enter().append('rect')\n      .attr('class', 'd3-tooltip-rect')\n      .attr('width', TOOLTIP_WIDTH)\n      .attr('height', TOOLTIP_HEIGHT)\n      .attr('x', function(d) {\n        if (prevScales) {\n          return prevScales.x(d.x) - TOOLTIP_WIDTH/2;\n        }\n        return scales.x(d.x) - TOOLTIP_WIDTH/2;\n      })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('x', function(d) { return scales.x(d.x) - TOOLTIP_WIDTH/2; });\n\n  tooltipRect.attr('y', function(d) { return scales.y(d.y) - scales.z(d.z)/2 - TOOLTIP_HEIGHT; })\n    .attr('class', function(d) { return d.highlight ? 'd3-tooltip-rect highlight' : 'd3-tooltip-rect'; })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('x', function(d) { return scales.x(d.x) - TOOLTIP_WIDTH/2; });\n\n  if (prevScales) {\n    tooltipRect.exit()\n      .transition()\n        .duration(ANIMATION_DURATION)\n        .attr('x', function(d) { return scales.x(d.x) - TOOLTIP_WIDTH/2; })\n        .remove();\n  } else {\n    tooltipRect.exit()\n        .remove();\n  }\n\n  var tooltipText = g.selectAll('.d3-tooltip-text')\n    .data(tooltips, function(d) { return d.id; });\n\n  tooltipText.enter().append('text')\n      .attr('class', 'd3-tooltip-text')\n      .attr('dy', '0.35em')\n      .attr('text-anchor', 'middle')\n      .text(function(d) { return d.z; })\n      .attr('x', function(d) {\n        if (prevScales) {\n          return prevScales.x(d.x);\n        }\n        return scales.x(d.x);\n      })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('x', function(d) { return scales.x(d.x); });\n\n  tooltipText.attr('y', function(d) { return scales.y(d.y) - scales.z(d.z)/2 - TOOLTIP_HEIGHT/2; })\n    .transition()\n      .duration(ANIMATION_DURATION)\n      .attr('x', function(d) { return scales.x(d.x); });\n\n  if (prevScales) {\n    tooltipText.exit()\n      .transition()\n        .duration(ANIMATION_DURATION)\n        .attr('x', function(d) { return scales.x(d.x); })\n        .remove();\n  } else {\n    tooltipText.exit()\n        .remove();\n  }\n};",
            "Chart.js": "#Modify\nshowTooltip: function(d) {\n    if (this.props.appState.showingAllTooltips) {\n      return;\n    }\n\n    this.props.setAppState({\n      tooltip: {\n        ...d,\n        highlight: true\n      },\n      // Disable animation\n      prevDomain: null\n    });\n  },\n\n#Modify\nhideTooltip: function() {\n    if (this.props.appState.showingAllTooltips) {\n      return;\n    }\n\n    this.props.setAppState({\n      tooltip: null,\n      prevDomain: null\n    });\n  }",
            "App.js": "#Modify\nsetAppState: function(partialState, callback) {\n    return this.setState(partialState, callback);\n  }",
            "main.js": "// No changes needed in this file"
        }
    },
    {
        "repo": "Registration-and-Login-using-MERN-stack",
        "content": "'Registration-and-Login-using-MERN-stack/api/constants/constants.js'\n:const RouteNames = {\n    register: '/register',\n    login: '/login',\n    data: '/allData',\n    validate: '/validateUsername'\n\n};\n\nmodule.exports = RouteNames;\n'Registration-and-Login-using-MERN-stack/api/route.js'\n:const express = require('express');\nconst registrationRoutes = express.Router();\nconst bcrypt = require('bcryptjs');\nlet Registration = require('./schema/User');\nlet RouteNames = require(\"./constants/constants\");\n//NOTE  Registration route\nregistrationRoutes.route(RouteNames.register).post(function(req, res) {\n    let register = new Registration(req.body);\n    register.save()\n        .then(reg => {\n            res.sendStatus(200);\n        })\n        .catch(err => {\n            res.status(400).send(\"Failed to store to database\");\n        });\n});\n\n// Login Router\nregistrationRoutes.route(RouteNames.login).post(function(req, res) {\n    Registration.findOne({ user_name: req.body.user_name })\n        .then(user => {\n            console.log(\"User from login\", user)\n            if (!user) res.sendStatus(204);\n            else {\n                bcrypt.compare(req.body.password, user.password)\n                    .then(passwordMatch => passwordMatch ? res.sendStatus(200) : res.sendStatus(204))\n            }\n        });\n});\n\n// Username validation Router\nregistrationRoutes.route(RouteNames.validate)\n    .post(function(req, res) {\n        Registration.findOne({ user_name: req.body.user_name })\n            .then(user => user ? res.sendStatus(204) : res.sendStatus(200))\n    });\n\n// Get allData\nregistrationRoutes.route(RouteNames.data).get(function(req, res) {\n    Registration.find((err, data) => err ? res.status(400).send(\"Error occured\") : res.json(data));\n});\n\nmodule.exports = registrationRoutes;\n'Registration-and-Login-using-MERN-stack/api/server.js'\n:const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst PORT = 4000;\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst config = require('./DB.js');\nconst registrationRoutes = require('./route');\n\nmongoose.Promise = global.Promise;\nmongoose.connect(config.DB, { useNewUrlParser: true }).then(\n    () => { console.log('Database is connected') },\n    err => { console.log('Can not connect to the database' + err) }\n);\n\napp.use(cors());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(\"./schema/User\", registrationRoutes);\n\n\nmodule.exports = app\n'Registration-and-Login-using-MERN-stack/api/app.js'\n:var app = require(\"./server\");\nconst PORT = 4000;\n\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});\n",
        "called_code_segment_file_1": "registrationRoutes.route(RouteNames.register).post(function(req, res) {\n    let register = new Registration(req.body);\n    register.save()\n        .then(reg => {\n            res.sendStatus(200);\n        })\n        .catch(err => {\n            res.status(400).send(\"Failed to store to database\");\n        });\n});",
        "invoking_code_segment_file_2": "app.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(\"./schema/User\", registrationRoutes);",
        "called_code_segment_file_2": "app.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(\"./schema/User\", registrationRoutes);",
        "using_code_segment_file_3": "app.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});",
        "called_code_segment_file_3": "app.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});",
        "using_code_segment_file_4": "const PORT = 4000;\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});",
        "feature_description": "Add a feature to log the registration details to the console before saving them to the database.",
        "detailed_feature_description": "Modify the registration route in #file 1 to log the registration details to the console before saving them to the database. Update #file 2 to handle the modified code from #file 1. Since #file 3 directly interacts with #file 2, ensure that the changes in #file 2 are compatible with #file 3. #file 4 does not interact with the updated segments in #file 3, so no changes are required in #file 4.",
        "modified_complete_code": {
            "#file 1": "const express = require('express');\nconst registrationRoutes = express.Router();\nconst bcrypt = require('bcryptjs');\nlet Registration = require('./schema/User');\nlet RouteNames = require(\"./constants/constants\");\n//NOTE  Registration route\nregistrationRoutes.route(RouteNames.register).post(function(req, res) {\n    let register = new Registration(req.body);\n    console.log('Registration Details:', register); // #Modify\n    register.save()\n        .then(reg => {\n            res.sendStatus(200);\n        })\n        .catch(err => {\n            res.status(400).send(\"Failed to store to database\");\n        });\n});\n\n// Login Router\nregistrationRoutes.route(RouteNames.login).post(function(req, res) {\n    Registration.findOne({ user_name: req.body.user_name })\n        .then(user => {\n            console.log(\"User from login\", user)\n            if (!user) res.sendStatus(204);\n            else {\n                bcrypt.compare(req.body.password, user.password)\n                    .then(passwordMatch => passwordMatch ? res.sendStatus(200) : res.sendStatus(204))\n            }\n        });\n});\n\n// Username validation Router\nregistrationRoutes.route(RouteNames.validate)\n    .post(function(req, res) {\n        Registration.findOne({ user_name: req.body.user_name })\n            .then(user => user ? res.sendStatus(204) : res.sendStatus(200))\n    });\n\n// Get allData\nregistrationRoutes.route(RouteNames.data).get(function(req, res) {\n    Registration.find((err, data) => err ? res.status(400).send(\"Error occured\") : res.json(data));\n});\n\nmodule.exports = registrationRoutes;",
            "#file 2": "const express = require('express');\nconst app = express();\nconst bodyParser = require('body-parser');\nconst PORT = 4000;\nconst cors = require('cors');\nconst mongoose = require('mongoose');\nconst config = require('./DB.js');\nconst registrationRoutes = require('./route');\n\nmongoose.Promise = global.Promise;\nmongoose.connect(config.DB, { useNewUrlParser: true }).then(\n    () => { console.log('Database is connected') },\n    err => { console.log('Can not connect to the database' + err) }\n);\n\napp.use(cors());\napp.use(bodyParser.urlencoded({ extended: true }));\napp.use(bodyParser.json());\napp.use(\"./schema/User\", registrationRoutes);\n\nmodule.exports = app;",
            "#file 3": "var app = require(\"./server\");\nconst PORT = 4000;\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});",
            "#file 4": "const PORT = 4000;\n\napp.listen(PORT, function() {\n    console.log('Server is running on Port:', PORT);\n});"
        }
    },
    {
        "repo": "vue-cart",
        "content": "'vue-cart/build/utils.js'\n:'use strict'\nconst path = require('path')\nconst config = require('../config')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst packageConfig = require('../package.json')\n\nexports.assetsPath = function (_path) {\n  const assetsSubDirectory = process.env.NODE_ENV === 'production'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  return path.posix.join(assetsSubDirectory, _path)\n}\n\nexports.cssLoaders = function (options) {\n  options = options || {}\n\n  const cssLoader = {\n    loader: 'css-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  const postcssLoader = {\n    loader: 'postcss-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  // generate loader string to be used with extract text plugin\n  function generateLoaders (loader, loaderOptions) {\n    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n\n    if (loader) {\n      loaders.push({\n        loader: loader + '-loader',\n        options: Object.assign({}, loaderOptions, {\n          sourceMap: options.sourceMap\n        })\n      })\n    }\n\n    // Extract CSS when that option is specified\n    // (which is the case during production build)\n    if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader'\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }\n  }\n\n  // https://vue-loader.vuejs.org/en/configurations/extract-css.html\n  return {\n    css: generateLoaders(),\n    postcss: generateLoaders(),\n    less: generateLoaders('less'),\n    sass: generateLoaders('sass', { indentedSyntax: true }),\n    scss: generateLoaders('sass'),\n    stylus: generateLoaders('stylus'),\n    styl: generateLoaders('stylus')\n  }\n}\n\n// Generate loaders for standalone style files (outside of .vue)\nexports.styleLoaders = function (options) {\n  const output = []\n  const loaders = exports.cssLoaders(options)\n\n  for (const extension in loaders) {\n    const loader = loaders[extension]\n    output.push({\n      test: new RegExp('\\\\.' + extension + '$'),\n      use: loader\n    })\n  }\n\n  return output\n}\n\nexports.createNotifierCallback = () => {\n  const notifier = require('node-notifier')\n\n  return (severity, errors) => {\n    if (severity !== 'error') return\n\n    const error = errors[0]\n    const filename = error.file && error.file.split('!').pop()\n\n    notifier.notify({\n      title: packageConfig.name,\n      message: severity + ': ' + error.name,\n      subtitle: filename || '',\n      icon: path.join(__dirname, 'logo.png')\n    })\n  }\n}\n\n'vue-cart/build/webpack.base.conf.js'\n:'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst config = require('../config')\nconst vueLoaderConfig = require('./vue-loader.conf')\n\nfunction resolve (dir) {\n  return path.join(__dirname, '..', dir)\n}\n\nconst createLintingRule = () => ({\n  test: /\\.(js|vue)$/,\n  loader: 'eslint-loader',\n  enforce: 'pre',\n  include: [resolve('src'), resolve('test')],\n  options: {\n    formatter: require('eslint-friendly-formatter'),\n    emitWarning: !config.dev.showEslintErrorsInOverlay\n  }\n})\n\nmodule.exports = {\n  context: path.resolve(__dirname, '../'),\n  entry: {\n    app: './src/main.js'\n  },\n  output: {\n    path: config.build.assetsRoot,\n    filename: '[name].js',\n    publicPath: process.env.NODE_ENV === 'production'\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n  resolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n    }\n  },\n  module: {\n    rules: [\n      ...(config.dev.useEslint ? [createLintingRule()] : []),\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('img/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('media/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n        }\n      }\n    ]\n  },\n  node: {\n    // prevent webpack from injecting useless setImmediate polyfill because Vue\n    // source contains it (although only uses it if it's native).\n    setImmediate: false,\n    // prevent webpack from injecting mocks to Node native modules\n    // that does not make sense for the client\n    dgram: 'empty',\n    fs: 'empty',\n    net: 'empty',\n    tls: 'empty',\n    child_process: 'empty'\n  }\n}\n\n'vue-cart/build/webpack.prod.conf.js'\n:'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\n\nconst env = require('../config/prod.env')\n\nconst webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  devtool: config.build.productionSourceMap ? config.build.devtool : false,\n  output: {\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath('js/[name].[chunkhash].js'),\n    chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')\n  },\n  plugins: [\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    new webpack.DefinePlugin({\n      'process.env': env\n    }),\n    new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          warnings: false\n        }\n      },\n      sourceMap: config.build.productionSourceMap,\n      parallel: true\n    }),\n    // extract css into its own file\n    new ExtractTextPlugin({\n      filename: utils.assetsPath('css/[name].[contenthash].css'),\n      // Setting the following option to `false` will not extract CSS from codesplit chunks.\n      // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.\n      // It's currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it's `false`, \n      // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110\n      allChunks: true,\n    }),\n    // Compress extracted CSS. We are using this plugin so that possible\n    // duplicated CSS from different components can be deduped.\n    new OptimizeCSSPlugin({\n      cssProcessorOptions: config.build.productionSourceMap\n        ? { safe: true, map: { inline: false } }\n        : { safe: true }\n    }),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: 'index.html',\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      chunksSortMode: 'dependency'\n    }),\n    // keep module.id stable when vendor modules does not change\n    new webpack.HashedModuleIdsPlugin(),\n    // enable scope hoisting\n    new webpack.optimize.ModuleConcatenationPlugin(),\n    // split vendor js into its own file\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n      minChunks (module) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &&\n          /\\.js$/.test(module.resource) &&\n          module.resource.indexOf(\n            path.join(__dirname, '../node_modules')\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'manifest',\n      minChunks: Infinity\n    }),\n    // This instance extracts shared chunks from code splitted chunks and bundles them\n    // in a separate chunk, similar to the vendor chunk\n    // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'app',\n      async: 'vendor-async',\n      children: true,\n      minChunks: 3\n    }),\n\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.build.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nif (config.build.productionGzip) {\n  const CompressionWebpackPlugin = require('compression-webpack-plugin')\n\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      asset: '[path].gz[query]',\n      algorithm: 'gzip',\n      test: new RegExp(\n        '\\\\.(' +\n        config.build.productionGzipExtensions.join('|') +\n        ')$'\n      ),\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nif (config.build.bundleAnalyzerReport) {\n  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n  webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n\nmodule.exports = webpackConfig\n\n'vue-cart/build/build.js'\n:'use strict'\nrequire('./check-versions')()\n\nprocess.env.NODE_ENV = 'production'\n\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n\nconst spinner = ora('building for production...')\nspinner.start()\n\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {\n  if (err) throw err\n  webpack(webpackConfig, (err, stats) => {\n    spinner.stop()\n    if (err) throw err\n    process.stdout.write(stats.toString({\n      colors: true,\n      modules: false,\n      children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build.\n      chunks: false,\n      chunkModules: false\n    }) + '\\n\\n')\n\n    if (stats.hasErrors()) {\n      console.log(chalk.red('  Build failed with errors.\\n'))\n      process.exit(1)\n    }\n\n    console.log(chalk.cyan('  Build complete.\\n'))\n    console.log(chalk.yellow(\n      '  Tip: built files are meant to be served over an HTTP server.\\n' +\n      '  Opening index.html over file:// won\\'t work.\\n'\n    ))\n  })\n})\n\n",
        "called_code_segment_file_1": "exports.assetsPath = function (_path) {\n  const assetsSubDirectory = process.env.NODE_ENV === 'production'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  return path.posix.join(assetsSubDirectory, _path)\n}",
        "invoking_code_segment_file_2": "const webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  // Other configurations...\n})",
        "called_code_segment_file_2": "const webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  // Other configurations...\n})",
        "using_code_segment_file_3": "const output = []\nconst loaders = exports.cssLoaders(options)\n\nfor (const extension in loaders) {\n  const loader = loaders[extension]\n  output.push({\n    test: new RegExp('\\\\.' + extension + '$'),\n    use: loader\n  })\n}\n\nreturn output",
        "called_code_segment_file_3": "exports.createNotifierCallback = () => {\n  const notifier = require('node-notifier')\n\n  return (severity, errors) => {\n    if (severity !== 'error') return\n\n    const error = errors[0]\n    const filename = error.file && error.file.split('!').pop()\n\n    notifier.notify({\n      title: packageConfig.name,\n      message: severity + ': ' + error.name,\n      subtitle: filename || '',\n      icon: path.join(__dirname, 'logo.png')\n    })\n  }\n}",
        "using_code_segment_file_4": "const createLintingRule = () => ({\n  test: /\\.(js|vue)$/,\n  loader: 'eslint-loader',\n  enforce: 'pre',\n  include: [resolve('src'), resolve('test')],\n  options: {\n    formatter: require('eslint-friendly-formatter'),\n    emitWarning: !config.dev.showEslintErrorsInOverlay\n  }\n})",
        "feature_description": "Add a new feature to dynamically adjust the assets path based on the environment and a new configuration parameter.",
        "detailed_feature_description": "The new feature modifies the `assetsPath` function in #file 1 to accept an additional parameter for custom path adjustments. This change is propagated to #file 2, where the `styleLoaders` function is updated to handle the new parameter. #file 3 is updated to reflect the changes in `styleLoaders`, and #file 4 remains unchanged as it does not directly interact with the modified segments.",
        "modified_complete_code": {
            "file_1": "exports.assetsPath = function (_path, customPath) {\n  const assetsSubDirectory = process.env.NODE_ENV === 'production'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  const finalPath = customPath ? path.posix.join(customPath, _path) : path.posix.join(assetsSubDirectory, _path)\n  return finalPath\n} #Modify",
            "file_2": "const webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true,\n      customPath: config.build.customAssetsPath #New\n    })\n  },\n  // Other configurations...\n}) #Modify",
            "file_3": "const output = []\nconst loaders = exports.cssLoaders(options)\n\nfor (const extension in loaders) {\n  const loader = loaders[extension]\n  output.push({\n    test: new RegExp('\\\\.' + extension + '$'),\n    use: loader\n  })\n}\n\nreturn output #Modify",
            "file_4": "const createLintingRule = () => ({\n  test: /\\.(js|vue)$/,\n  loader: 'eslint-loader',\n  enforce: 'pre',\n  include: [resolve('src'), resolve('test')],\n  options: {\n    formatter: require('eslint-friendly-formatter'),\n    emitWarning: !config.dev.showEslintErrorsInOverlay\n  }\n})"
        }
    },
    {
        "repo": "onedrive-api",
        "content": "'onedrive-api/lib/helpers/pathHelper.js'\n:function generateUserPath(params) {\n  if (params.drive === \"user\") return \"users/\" + params.driveId + \"/drive/\";\n  if (params.drive === \"drive\") return \"drives/\" + params.driveId + \"/\";\n  if (params.drive === \"group\") return \"groups/\" + params.driveId + \"/drive/\";\n  if (params.drive === \"site\") return \"sites/\" + params.driveId + \"/drive/\";\n\n  return \"me/drive/\";\n}\n\nfunction formatItemPath(itemPath) {\n  if (itemPath === \"/\") {\n    return \"root\"\n  }\n\n  if (itemPath[0] === '/') {\n    itemPath = itemPath.slice(1)\n  }\n  if (itemPath[itemPath.length - 1] === '/') {\n    itemPath = itemPath.slice(0, -1)\n  }\n\n  return \"root:/\" + itemPath + \":\"\n}\n\nmodule.exports = {\n  userPathGenerator: generateUserPath,\n  itemPathFormatter: formatItemPath\n};\n\n'onedrive-api/lib/items/getMetadata.js'\n:const got = import(\"got\");\nconst gotConfig = require(\"../helpers/gotHelper\");\nconst {userPathGenerator, itemPathFormatter} = require(\"../helpers/pathHelper\");\n\n/**\n * @function getMetadata\n * @description Get items metadata (file or folder)\n *\n * @param {Object} params\n * @param {String} params.accessToken OneDrive access token\n * @param {String} params.itemId Item id\n * @param {String} params.itemPath Item path\n *\n * @return {Promise<Object>} Item's metadata\n */\nasync function getMetadata(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.itemId && !params.itemPath) {\n    throw new Error(\"Missing both params.itemId and params.itemPath\");\n  }\n\n  const userPath = userPathGenerator(params);\n  const URI = appConfig.apiUrl + userPath + (params.itemId ? (\"items/\" + params.itemId) : itemPathFormatter(params.itemPath));\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: gotConfig.headerJSON,\n    responseType: gotConfig.responseJSON,\n    method: \"GET\",\n  });\n\n  const response = await gotExtend(URI);\n  return response.body;\n}\n\nmodule.exports = getMetadata;\n\n'onedrive-api/lib/items/partialDownload.js'\n:// partialDownload.js\nconst getMetadata = require(\"./getMetadata\");\nconst got = import(\"got\");\nconst gotConfig = require(\"../helpers/gotHelper\");\n\n/**\n * @function partialDownload\n * @description partially download item content\n *\n * @param {Object} params\n * @param {String} params.accessToken OneDrive access token\n * @param {String} params.graphDownloadURL The URL string from `@microsoft.graph.downloadUrl`\n * @param {String} params.itemId item id. If `graphDownloadURL` is provided, this parameter will be ignored\n * @param {String} params.itemPath item path\n * @param {Number} params.bytesFrom the starting byte to stream\n * @param {Number} params.bytesTo the ending byte of the stream\n *\n * @return {Promise<NodeJS.ReadableStream>} A promise with the result is a `Readable stream` with partial item's content\n */\n\nasync function partialDownload(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.graphDownloadURL && !params.itemId && !params.itemPath) {\n    throw new Error(\"Missing all of params.graphDownloadURL, params.itemId and params.itemPath\");\n  }\n\n  if (!params.bytesFrom) {\n    params.bytesFrom = 0;\n  }\n\n  if (!params.bytesTo) {\n    throw new Error(\"Missing params.bytesTo\");\n  }\n\n  const headersRequest = {\n    Range: `bytes=${params.bytesFrom}-${params.bytesTo}`,\n  };\n  let URI = params.graphDownloadURL;\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: headersRequest,\n    isStream: true,\n    method: \"GET\",\n  });\n\n  if (!URI) {\n    const metaItem = await getMetadata(params);\n    URI = metaItem[\"@microsoft.graph.downloadUrl\"];\n    if (!URI) {\n      throw new Error(\"Item does not have @microsoft.graph.downloadUrl field\");\n    }\n  }\n  return gotExtend.stream(URI);\n}\n\nmodule.exports = partialDownload;\n\n'onedrive-api/lib/items/index.js'\n:// lib/items/index.js\n\nconst listChildren = require(\"./listChildren\"),\n  createFolder = require(\"./createFolder\"),\n  uploadSimple = require(\"./uploadSimple\"),\n  uploadSession = require(\"./uploadSession\"),\n  update = require(\"./update\"),\n  getMetadata = require(\"./getMetadata\"),\n  download = require(\"./download\"),\n  partialDownload = require(\"./partialDownload\"),\n  sync = require(\"./sync\"),\n  customEndpoint = require(\"./customEndpoint\"),\n  _delete = require(\"./delete\"),\n  thumbnails = require(\"./thumbnails\"),\n  preview = require(\"./preview\"),\n  createLink = require(\"./createLink\");\n\nmodule.exports = {\n  listChildren: listChildren,\n  createFolder: createFolder,\n  uploadSimple: uploadSimple,\n  uploadSession: uploadSession,\n  update: update,\n  getMetadata: getMetadata,\n  download: download,\n  partialDownload: partialDownload,\n  sync: sync,\n  customEndpoint: customEndpoint,\n  delete: _delete,\n  thumbnails: thumbnails,\n  preview: preview,\n  createLink: createLink\n};\n\n",
        "called_code_segment_file_1": "async function getMetadata(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.itemId && !params.itemPath) {\n    throw new Error(\"Missing both params.itemId and params.itemPath\");\n  }\n\n  const userPath = userPathGenerator(params);\n  const URI = appConfig.apiUrl + userPath + (params.itemId ? (\"items/\" + params.itemId) : itemPathFormatter(params.itemPath));\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: gotConfig.headerJSON,\n    responseType: gotConfig.responseJSON,\n    method: \"GET\",\n  });\n\n  const response = await gotExtend(URI);\n  return response.body;\n}",
        "invoking_code_segment_file_2": "async function partialDownload(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.graphDownloadURL && !params.itemId && !params.itemPath) {\n    throw new Error(\"Missing all of params.graphDownloadURL, params.itemId and params.itemPath\");\n  }\n\n  if (!params.bytesFrom) {\n    params.bytesFrom = 0;\n  }\n\n  if (!params.bytesTo) {\n    throw new Error(\"Missing params.bytesTo\");\n  }\n\n  const headersRequest = {\n    Range: `bytes=${params.bytesFrom}-${params.bytesTo}`,\n  };\n  let URI = params.graphDownloadURL;\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: headersRequest,\n    isStream: true,\n    method: \"GET\",\n  });\n\n  if (!URI) {\n    const metaItem = await getMetadata(params);\n    URI = metaItem[\"@microsoft.graph.downloadUrl\"];\n    if (!URI) {\n      throw new Error(\"Item does not have @microsoft.graph.downloadUrl field\");\n    }\n  }\n  return gotExtend.stream(URI);\n}",
        "called_code_segment_file_2": "async function getMetadata(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.itemId && !params.itemPath) {\n    throw new Error(\"Missing both params.itemId and params.itemPath\");\n  }\n\n  const userPath = userPathGenerator(params);\n  const URI = appConfig.apiUrl + userPath + (params.itemId ? (\"items/\" + params.itemId) : itemPathFormatter(params.itemPath));\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: gotConfig.headerJSON,\n    responseType: gotConfig.responseJSON,\n    method: \"GET\",\n  });\n\n  const response = await gotExtend(URI);\n  return response.body;\n}",
        "using_code_segment_file_3": "const getMetadata = require(\"./getMetadata\");\n\nasync function partialDownload(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.graphDownloadURL && !params.itemId && !params.itemPath) {\n    throw new Error(\"Missing all of params.graphDownloadURL, params.itemId and params.itemPath\");\n  }\n\n  if (!params.bytesFrom) {\n    params.bytesFrom = 0;\n  }\n\n  if (!params.bytesTo) {\n    throw new Error(\"Missing params.bytesTo\");\n  }\n\n  const headersRequest = {\n    Range: `bytes=${params.bytesFrom}-${params.bytesTo}`,\n  };\n  let URI = params.graphDownloadURL;\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: headersRequest,\n    isStream: true,\n    method: \"GET\",\n  });\n\n  if (!URI) {\n    const metaItem = await getMetadata(params);\n    URI = metaItem[\"@microsoft.graph.downloadUrl\"];\n    if (!URI) {\n      throw new Error(\"Item does not have @microsoft.graph.downloadUrl field\");\n    }\n  }\n  return gotExtend.stream(URI);\n}",
        "called_code_segment_file_3": "async function partialDownload(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.graphDownloadURL && !params.itemId && !params.itemPath) {\n    throw new Error(\"Missing all of params.graphDownloadURL, params.itemId and params.itemPath\");\n  }\n\n  if (!params.bytesFrom) {\n    params.bytesFrom = 0;\n  }\n\n  if (!params.bytesTo) {\n    throw new Error(\"Missing params.bytesTo\");\n  }\n\n  const headersRequest = {\n    Range: `bytes=${params.bytesFrom}-${params.bytesTo}`,\n  };\n  let URI = params.graphDownloadURL;\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: headersRequest,\n    isStream: true,\n    method: \"GET\",\n  });\n\n  if (!URI) {\n    const metaItem = await getMetadata(params);\n    URI = metaItem[\"@microsoft.graph.downloadUrl\"];\n    if (!URI) {\n      throw new Error(\"Item does not have @microsoft.graph.downloadUrl field\");\n    }\n  }\n  return gotExtend.stream(URI);\n}",
        "using_code_segment_file_4": "const partialDownload = require(\"./partialDownload\");\n\nasync function downloadFile(params) {\n  const stream = await partialDownload(params);\n  stream.pipe(fs.createWriteStream(params.destinationPath));\n}",
        "feature_description": "Add a new feature to handle large file downloads by splitting the download into multiple parts and downloading each part separately.",
        "detailed_feature_description": "The new feature will modify the `partialDownload` function to accept an additional parameter `partSize` which will determine the size of each part. The function will then split the download into multiple parts and download each part separately. This will require modifications in `partialDownload`, `getMetadata`, and any other functions that interact with `partialDownload`.",
        "modified_complete_code": {
            "file_1": "async function getMetadata(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.itemId && !params.itemPath) {\n    throw new Error(\"Missing both params.itemId and params.itemPath\");\n  }\n\n  const userPath = userPathGenerator(params);\n  const URI = appConfig.apiUrl + userPath + (params.itemId ? (\"items/\" + params.itemId) : itemPathFormatter(params.itemPath));\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: gotConfig.headerJSON,\n    responseType: gotConfig.responseJSON,\n    method: \"GET\",\n  });\n\n  const response = await gotExtend(URI);\n  return response.body;\n}",
            "file_2": "async function partialDownload(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.graphDownloadURL && !params.itemId && !params.itemPath) {\n    throw new Error(\"Missing all of params.graphDownloadURL, params.itemId and params.itemPath\");\n  }\n\n  if (!params.bytesFrom) {\n    params.bytesFrom = 0;\n  }\n\n  if (!params.bytesTo) {\n    throw new Error(\"Missing params.bytesTo\");\n  }\n\n  const headersRequest = {\n    Range: `bytes=${params.bytesFrom}-${params.bytesTo}`,\n  };\n  let URI = params.graphDownloadURL;\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: headersRequest,\n    isStream: true,\n    method: \"GET\",\n  });\n\n  if (!URI) {\n    const metaItem = await getMetadata(params);\n    URI = metaItem[\"@microsoft.graph.downloadUrl\"];\n    if (!URI) {\n      throw new Error(\"Item does not have @microsoft.graph.downloadUrl field\");\n    }\n  }\n  return gotExtend.stream(URI);\n}",
            "file_3": "const getMetadata = require(\"./getMetadata\");\n\nasync function partialDownload(params) {\n  if (!params.accessToken) {\n    throw new Error(\"Missing params.accessToken\");\n  }\n\n  if (!params.graphDownloadURL && !params.itemId && !params.itemPath) {\n    throw new Error(\"Missing all of params.graphDownloadURL, params.itemId and params.itemPath\");\n  }\n\n  if (!params.bytesFrom) {\n    params.bytesFrom = 0;\n  }\n\n  if (!params.bytesTo) {\n    throw new Error(\"Missing params.bytesTo\");\n  }\n\n  const headersRequest = {\n    Range: `bytes=${params.bytesFrom}-${params.bytesTo}`,\n  };\n  let URI = params.graphDownloadURL;\n\n  const gotExtend = (await got).got.extend({\n    hooks: {\n      beforeRequest: gotConfig.beforeRequestHookGot(params.accessToken),\n    },\n    headers: headersRequest,\n    isStream: true,\n    method: \"GET\",\n  });\n\n  if (!URI) {\n    const metaItem = await getMetadata(params);\n    URI = metaItem[\"@microsoft.graph.downloadUrl\"];\n    if (!URI) {\n      throw new Error(\"Item does not have @microsoft.graph.downloadUrl field\");\n    }\n  }\n  return gotExtend.stream(URI);\n}",
            "file_4": "const partialDownload = require(\"./partialDownload\");\n\nasync function downloadFile(params) {\n  const stream = await partialDownload(params);\n  stream.pipe(fs.createWriteStream(params.destinationPath));\n}"
        }
    },
    {
        "repo": "LogicPull",
        "content": "'LogicPull/lib/func.js'\n:/*  Copyright 2014 Chris Zieba <zieba.chris@gmail.com>\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU\n  Affero General Public License as published by the Free Software Foundation, either version 3 of the\n  License, or (at your option) any later version.\n  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE. See the GNU Affero General Public License for more details. You should have received a\n  copy of the GNU Affero General Public License along with this program. If not, see\n  <http://www.gnu.org/licenses/>.\n*/\n\n// Functions passed into the stylesheet and used in the interview\nexports.common = {\n  /**\n   * Return the multiplication of the two inputs\n   *\n   * @rent {number} The amount of rent per month\n   * @months {number} The number of months\n   *\n   */\n  abatement: function (rent, months) {\n    return rent*months;\n  },\n\n  /**\n   * Capitalize the first letter of a string\n   *\n   * @str {string} The string to capitalize\n   *\n   */\n  capitalize: function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n  },\n\n  /**\n   * Round a number\n   *\n   * @val {number} The number to round\n   *\n   */\n  round: function (val) {\n    return Math.round(val);\n  },\n\n  /**\n   * Return the ordinal of a given index up to 20\n   *\n   * @index {number} The index corresponding to the word we want\n   *\n   * Examples:\n   *\n   * numberWord(0) returns 'zero'\n   * numberWord(20) returns 'twenty'\n   *\n   */\n  numberWord: function (index) {\n    var od = ['zero','one','two','three','four','five','six','seven','eight','nine','ten','eleven','twelve','thirteen','fourteen','fifteen','sixteen','seventeen','eighteen','nineteen','twenty'];\n    \n    if (arguments.length === 1) {\n      if (od[index]) {\n        return od[index];\n      }\n    } \n\n    return false;\n    \n  },\n\n  /**\n   * Return the ordinal of a given index up to 20\n   *\n   * @index {int} The number to turn into an ordinal\n   * @num {boolean} Optional parameter that returns the numbered ordinal when set to true \n   *\n   */\n  ordinal: function (index, num) {\n    var od = ['zeroeth','first','second','third','fourth','fifth','sixth','seventh','eighth','ninth','tenth','eleventh','twelfth','thirteenth','fourteenth','fifteenth','sixteenth','seventeenth','eighteenth','nineteenth','twentieth'],\n      odn = ['0th','1st','2nd','3rd','4th','5th','6th','7th','8th','9th','10th','11th','12th','13th','14th','15th','16th','17th','18th','19th','20th'];\n    \n    if (arguments.length === 2) {\n      if (odn[index]) {\n        return odn[index];\n      }\n    } else {\n      if (od[index]) {\n        return od[index];\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * The difference between two dates. The first two arguments are mandatory, and if the last two \n   * are not given we set the date d2 to today. If the second date parameter (d2) comes after the first, than the result will be positive.\n   *\n   * @date {string} Date string\n   * @in_format {string} The format of the string given\n   * @out_format {string} The format to convert the string to\n   *\n   * Examples\n   *\n   * dateDifference('12/24/1977', 'MM/DD/YYYY', 'days', '01/01/2012', 'MM/DD/YYYY') // 13504\n   * dateDifference('01/01/2012', 'MM/DD/YYYY', 'days', '12/24/1977', 'MM/DD/YYYY') // -13504\n   *\n   */\n  dateFormat : function (date, in_format, out_format) {\n    var moment = require('moment');\n      // the allowed formats is used to check against the date entered\n    var formats = ['DD/MM/YYYY','MM/DD/YYYY', 'days'];\n\n    // if no format for the date is given as an argument, use a default\n    in_format = formats.indexOf(in_format) >= 0 ? in_format : 'MM/DD/YYYY';\n\n    // if no format is given for the output date, use a default\n    out_format = typeof out_format !== 'undefined' ? out_format : 'MM/DD/YYYY';\n\n    // if the in_format is days and the date is a number (ie. days)\n    if (in_format === 'days') {\n      return moment(\"01/01/1900\", \"MM/DD/YYYY\").add('days', date).format(out_format);\n    } \n\n    // if no date is given as input, set it to today\n    date = typeof date !== 'undefined' ? moment(date, in_format) : moment(new Date());\n    \n    return date.format(out_format);\n  },\n  \n  /**\n   * The difference between two dates. The first two arguments are mandatory, and if the last two \n   * are not given we set the date d2 to today. If the second date parameter (d2) comes after the first, than the result will be positive.\n   *\n   * @d1 {string} The date\n   * @f1 {string} The format of d1\n   * @m {string} The unit for the difference. Possible inputs are 'months', 'days', 'years'\n   * @d2 {string} The string to capitalize\n   * @f2 {string} The string to capitalize\n   *\n   * Examples\n   *\n   * dateDifference('12/24/1977', 'MM/DD/YYYY', 'days', '01/01/2012', 'MM/DD/YYYY') // 13504\n   * dateDifference('01/01/2012', 'MM/DD/YYYY', 'days', '12/24/1977', 'MM/DD/YYYY') // -13504\n   *\n   */\n  dateDifference : function (d1, f1, m, d2, f2) {\n    var moment = require('moment'),\n      allowed_in_formats = [\n        'DD/MM/YYYY',\n        'MM/DD/YYYY'\n      ];\n\n    var index1, index2, date1, date2;\n\n    if (arguments.length === 3) {\n      index1 = allowed_in_formats.indexOf(f1);\n      date2 = moment(new Date());\n\n      // check if the format is allowed\n      if (index1 >= 0) {\n        date1 = moment(d1, f1);\n\n        return date2.diff(date1, m);\n      }\n\n    // 5 arguments means that two dates were given\n    } else if (arguments.length === 5) {\n      index1 = allowed_in_formats.indexOf(f1);\n      index2 = allowed_in_formats.indexOf(f2);\n      date1 = moment(d1, f1);\n      date2 = moment(d2, f2);\n\n      // check if the format is allowed\n      if (index1 >= 0 && index2 >= 0) {\n        date1 = moment(d1, f1);\n\n        return date2.diff(date1, m);\n      }\n    }\n    return false;\n  },\n\n  /**\n   * Return the number of days since 1900\n   *\n   * @date {string, variable} The date can be a string, or the variable containing the date string.\n   * @format {string} The format of date. If no format is given the default is \"MM/DD/YYYY\"\n   *\n   * Examples\n   *\n   * dateDays('12/24/1977') // 44504\n   * dateDays(varname, 'MM/DD/YYYY') // 124423\n   *\n   */\n  dateDays : function (date, format) {\n    var moment = require('moment');\n    // the allowed formats is used to check against the date entered\n    var formats = ['DD/MM/YYYY','MM/DD/YYYY'];\n    // this the date to start counting days from\n    var date2 = moment(\"01/01/1900\", \"MM/DD/YYYY\");\n\n    // if not format is given as an argument, use a default\n    format = formats.indexOf(format) >= 0 ? format : 'MM/DD/YYYY';\n    // if no date is given as input, set it to today\n    date = typeof date !== 'undefined' ? moment(date,format) : moment(new Date());\n\n    return date.diff(date2, 'days');              \n  },\n\n  /**\n   * Format a string into a currency string\n   *\n   * @input {string, number} The string to convert\n   *\n   * Examples\n   * \n   * formatMoney(1234) // $1,234.00\n   * formatMoney('34.239234') // $34.23\n   *\n   */\n  formatMoney: function (input) {\n    var accounting = require(\"accounting\");\n    return accounting.formatMoney(input);\n  },\n\n  /**\n   * Format a string into a number\n   *\n   * @input {string, number} The string to convert\n   * @p {int} The number of decimal places to use\n   * @l {boolean} Use a comma\n   *\n   * Examples\n   * \n   * formatNumber(1234) // 1,234.00\n   * formatNumber(1234, 0) // 1,234\n   * formatNumber(1234, 2, false) // 1234.00\n   * formatNumber(1234, 5, true) // 1,234.00000\n   *\n   */\n  formatNumber: function (input, p, l) {\n    var accounting = require(\"accounting\");\n    p = parseInt(p,10) || 2;\n    l = (l === \"\" || l === false) ? \"\" : (l || \",\");\n\n    return accounting.formatNumber(input,p,l);\n  },\n\n  /**\n   * Returns the sum {float} of an array of numbers\n   *\n   * @input {array} An array of numbers\n   *\n   * Examples\n   * \n   * sum([1,2,3]) // 6\n   *\n   */\n  sum: function (datas) {\n    // if the input is an array, look through each element and add to sum\n    var num;\n    var sum = 0;\n\n    if (Array.isArray(datas)) {\n      for (var i = 0; i < datas.length; i+=1) {\n        num = parseFloat(datas[i]);\n        if (!isNaN(num)) {\n          sum = sum + num;\n        } \n      }\n\n      return sum;\n    }\n\n    return parseFloat(datas);\n  },\n\n};\n\n// These are all the standard functions for use in the stylesheet\nexports.stylesheet = {\n  /**\n   * Checks if a variable was answered and has a value (not empty string)\n   *\n   * @name {string, array} The name of the variable\n   * @index {int} Optional loop index\n   *\n   */\n  isAnswered: function (name, index) {\n    if (Array.isArray(name)) {\n      for (var i = 0; i < name.length; i+=1) {\n\n        if (index !== null && typeof index !== 'undefined') {\n          if (this.master[name[i]] !== null && typeof this.master[name[i]] !== 'undefined') {\n            if (this.master[name].values[name[i]][index] !== null && typeof this.master[name[i]].values[name][index] !== 'undefined' && this.master[name[i]].values[name[i]][index] !== '') {\n              return true;\n            } \n          }\n        } else {\n          if (this.master[name[i]] !== null && typeof this.master[name[i]] !== 'undefined') {\n            if (this.master[name[i]].values[name] !== '' && this.master[name[i]].values[name[i]].length !== 0) {\n              return true;\n            }\n          }\n        }\n      }\n    } else {\n      if (index !== null && typeof index !== 'undefined') {\n        if (this.master[name] !== null && typeof this.master[name] !== 'undefined') {\n          if (this.master[name].values[name][index] !== null && typeof this.master[name].values[name][index] !== 'undefined' && this.master[name].values[name][index] !== '') {\n            return true;\n          } \n        }\n      } else {\n        if (this.master[name] !== null && typeof this.master[name] !== 'undefined') {\n          if (this.master[name].values[name] !== '' && this.master[name].values[name].length !== 0) {\n            return true;\n          }\n        } \n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Takes the name and the id of the checkbox we want to evaluate. If the checkbox is\n   * part of a loop the index needs to be passed in to correctly parse the checkbox. To check if\n   * NOTA was checked, pass in 'nota' as the @id parameter.\n   *\n   * @name {string} The name of the checkbox field\n   * @id {string, array} The ID given to the checkbox field option in the editor\n   * @index {int} The optional loop index\n   *\n   * Examples\n   *\n   * isChecked('translator_needed', 'rid1')\n   * isChecked('translator_needed', 'nota')\n   * isChecked('translator_needed', 'rid1', 0)\n   * isChecked('translator_needed', ['rid1','rid2', 'nota'], 0)\n   *\n   */\n  isChecked: function (name, id, index) {\n    var checkbox;\n\n    index = (typeof index !== 'undefined') ? parseInt(index, 10) : null;\n\n    // first check if the name is defined\n    if (this.master[name] !== null && typeof this.master[name] !== 'undefined' && this.master[name].type === 'checkbox') {\n      checkbox = (index !== null && !isNaN(index)) ? this.master[name].values[name][index] : this.master[name].values[name];\n\n      if (typeof checkbox === 'undefined' || checkbox === null || checkbox === \"\" || checkbox === \"[]\" || checkbox === \"[,]\") {\n        return false;\n      }\n\n      // checkbox to see if id is an array\n      if (Array.isArray(id)) {\n        // if we don't find the id on any iteration the function returns false\n        for (var i = 0; i < id.length; i+=1) {\n          if (JSON.parse(checkbox).indexOf(id[i]) === -1) {\n            return false;\n          } \n        }\n        // if we get through the loop that means each id was OK \n        return true;\n      } \n\n      // we need to parse the stringified array and check if the supplied id is in it\n      if (JSON.parse(checkbox).indexOf(id) >= 0) {\n        return true;\n      }\n      \n    } \n    return false;\n  },\n\n  /**\n   * Returns the value (or values, if array) of the given answer as a string.\n   *\n   * @name {string} The name of the variable to return the values for.\n   * @index {int} Optional loop index\n   *\n   */\n  get: function (name, index) {\n    if (index !== null && typeof index !== 'undefined') {\n      if (this.master[name] !== null && typeof this.master[name] !== 'undefined') {\n        if (this.master[name].values[name][index] !== null && typeof this.master[name].values[name][index] !== 'undefined' && this.master[name].values[name][index] !== '') {\n          return this.master[name].values[name][index].toString().trim();\n        } \n      }\n    } else {\n      if (this.master[name] !== null && typeof this.master[name] !== 'undefined') {\n        if (this.master[name].values[name] !== null && this.master[name].values[name] !== '' && this.master[name].values[name].length !== 0) {\n          return this.master[name].values[name].toString().trim();\n        }\n      } \n    }\n    \n    return '';\n  },\n\n  /**\n   * Exits a stylesheet. This function is used to determine if we want to add the stylesheet or not.\n   * Sometimes a stylesheet depends on the value of a variable, so if this is called all processing\n   * on the stylesheet is abandoned. It is best to check this at the beginning of a style sheet.\n   *\n   */\n  exit: function () {\n    throw \"exit\";\n  }\n};\n\n\n// These are all the standard functions for use in the interview\nexports.interview = {\n  /**\n   * Checks if a variable was answered and has a value (not empty string).\n   * THIS IS DIFFERENT THAN THE STYLESHEET FUNCTION because we must pass the variable instead of a string.\n   * When a variable in the form isAnswered(varname[counter]), both the array varname['one','two'] \n   * and the counter 0 get passed individually into the function.\n   *\n   * @name {answer} The variable we are checking\n   *\n   * Examples\n   *\n   * isAnswered(q16_1[counter1])\n   * isAnswered(q16_1)\n   *\n   */\n  isAnswered: function (answer) {\n    if (answer !== null && answer !== '' && typeof answer !== 'undefined' && answer !== 'undefined') {\n      return true;\n    }\n    return false;\n  },\n  \n  // id can be an array of ids to check...they one of them is not checked false is returned\n  // ischecked(varname[counter], 'id') - if this is usage than the answer will be stringified array of arrays\n  // ischecked(varname, 'id') - if this is usage than the answer will be stringified array\n\n  /**\n   * Returns a boolean true/false whether or not a checkbox id is checked in the interview\n   * To lookup if NOTA was checked, pass in 'nota' as the @id parameter.\n   *\n   * @answer {variable} The variable which stores the checkbox id's\n   * @id {string, array} The ID to lookup\n   *\n   * Examples\n   *\n   * ischecked(varname[counter], 'id')\n   * ischecked(varname[counter], ['id1','id2'])\n   * ischecked(varname, 'id')\n   *\n   */\n  isChecked: function (answer, id) {\n    //first check if the answer is an array (normal checkbox), or an array of arrays (checkbox inside loop)\n    answer = JSON.parse(answer);\n\n    if (Array.isArray(answer)) {\n      // now the answer is an array of id's\n      // CHECK IF THE INPUT WAS AN Array\n      if (Array.isArray(id)) {\n        for (var i = 0; i < id.length; i+=1) {\n          if (answer.indexOf(id[i]) === -1) {\n            return false;\n          } \n        }\n        // if we get through the loop that means each id was OK \n        return true;\n      }\n\n      // the id is just a string\n      if (answer.indexOf(id) >= 0) {\n        return true;\n      }\n    }\n    return false;\n  }\n};\n\n'LogicPull/lib/interviews/process.js'\n:/*  Copyright 2015 Chris Zieba <zieba.chris@gmail.com>\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU\n  Affero General Public License as published by the Free Software Foundation, either version 3 of the\n  License, or (at your option) any later version.\n  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE. See the GNU Affero General Public License for more details. You should have received a\n  copy of the GNU Affero General Public License along with this program. If not, see\n  <http://www.gnu.org/licenses/>.\n*/\n\nvar utils = require('../utils'),\n  helpers = require('../helpers'),\n  ejs = require('ejs'),\n  fs = require('fs'),\n  async = require('async'),\n  spawn = require('child_process').spawn,\n  nodemailer = require(\"nodemailer\"),\n  func = require('../func'),\n  models = require('../../models/models');\n\n/**\n * Returns the filename for a tmp file (.fo)\n *\n * @input_type {string} The file extension of the file we are trying to save\n *\n */\nfunction tmpFilename (input_type) {\n  \"use strict\";\n\n  // Since some .fo files are generated at the exact same time, just choose random names\n  // to avoid collision, since these files don't matter\n  var time = new Date().getTime();\n  time = time * Math.random();\n  time = Math.round(time).toString();\n  return time + \".\" + input_type;\n}\n\n/**\n * Returns the filename for the final output for the deliverable.\n *\n * @interview {array}\n * @name {string} The name given to the deliverable when uploading it in the manager\n * @type {string} The output type of the deliverable set when adding a deliverable\n * @client {string} If given the name of the person completing the interview, use it in the filename\n * @date {object} The interview completion date\n * @count {string} Optional index used when looping through documents \n * @options {object} Extra options used for building the output name\n *\n */\nfunction outFilename (interview, name, type, client, date, count, options) {\n  \"use strict\";\n\n  var monthNames = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\" ];\n  var FILE_LIMIT = 200;\n\n  if (type === 'pdf_form') {\n    type = 'pdf';\n  }\n\n  interview = (typeof interview !== 'undefined' && interview !== null && interview !== '') ? interview + '_' : '';\n  // Remove the interview name id the setting exists\n  if (options && options.prepend_interview === false) {\n    interview = '';\n  }\n\n  name = (typeof name !== 'undefined' && name !== null && name !== '') ? name + '_' : '';\n  count = count || '0';\n\n  var filename = interview.toUpperCase() + name.toUpperCase() + monthNames[date.getMonth()].toUpperCase() + '_' + date.getDate() + '_' + date.getFullYear() + '_' + count + '_' + Date.now() + '.' + type;\n\n  if (filename.length > FILE_LIMIT) {\n    var tag = '_' + count + '_' + Date.now() + '.' + type;\n    var name_length = FILE_LIMIT-tag.length;\n    filename = (name_length > 0) ? name.substr(0, name_length) + tag : tag;\n  }\n\n  return filename;\n}\n\n\n/**\n * Takes an array of filenames and zips the contents.\n *\n * @base {string} The base folder\n * @name {string} The name of the output deliverable\n * @folder {string} The folder to save the zipped file in\n * @email_callback {function} Callback that gets run after zipping the folder\n *\n */\nfunction zipFiles (base, name, folder, email_callback) {\n  \"use strict\";\n  \n  var file_path = base + 'generated/tmp/' + name;\n  var zip = spawn('zip', ['-r', '-j', file_path, base + folder]);\n\n  // End the response on zip exit\n  zip.on('exit', function (code) {\n    if(code !== 0) {\n      console.log('zip process exited with code ' + code);\n      email_callback('zip process exited with code ' + code);\n    } else {\n      email_callback(null, file_path);\n    }\n  });\n}\n\n// takes all the variables and tries to find the clients name\n\n/**\n * Build a string of the clients (user completing the interview) name\n *\n * @first {object} The first name of the client given as an answer object from the interview\n * @last {object} The last name of the client given as an answer object from the interview\n * @full {object} The full name of the client given as an answer object from the interview\n *\n */\nfunction clientName (first, last, full) {\n  \"use strict\";\n\n  // default\n  var name = {\n    first: 'Unknown',\n    last: 'Unknown',\n    full: 'Unknown_Name'\n  };\n\n  // if the first and last name are not given use the full name,\n  // if its an array just ignore \n  if (first && last && !Array.isArray(first.values)) {\n    name.first = first.values.Client_first_name_TE.toString().replace(/\\s/g,\"_\");\n    name.last = last.values.Client_last_name_TE.toString().replace(/\\s/g,\"_\");\n    name.full = name.last + '_' + name.first;     \n  } else if (full && !Array.isArray(first.values)) {\n    name.full = full.values.Client_full_name_TE.replace(/\\s/g,\"_\");\n  } \n\n  return name;\n}\n\n/**\n * Called when the finish button is clicked in the interview.\n * Handles all the deliverables plus any miscellaneous functions after the interview completes.\n *\n * @doc {object} The interview object from the database\n * @master {object} All the answers collected so far\n * @progress {array} The array of the order in which question are answered\n * @base_location {string} The base folder of the application\n * @app {object} The LogicPull application object that contains settings we need\n * @user {integer} The user ID if a registered user is performing the interview. Null if not logged in.\n * @socket_callback {function} Callback that gets run after completion\n *\n */\nexports.output = function (doc, master, progress, base_location, app, user, socket_callback) {\n  \"use strict\";\n\n  // use the microtime to create a temp directory to hold all the files generated\n  var deliverables = doc.deliverables, \n    datetime = new Date(),\n    microtime = Math.round(datetime.getTime()).toString(),\n    json_answer_file = \"generated/answers/\" + microtime + \".json\",\n    // this is for the intermediate files...inserted data into templates and before we render the final output\n    tmp_directory = \"generated/tmp/\",\n    // this is the directory where users upload interview specific deliverables\n    uploads_directory = \"uploads/deliverables/\" + doc.name + \"-\" + doc.id + \"/\",\n    // this will be the directory that holds all the final output files...use this folder to create a zip later\n    out_directory = \"generated/output/\" + doc.name + \"-\" + doc.id + \"/\" + microtime + \"/\",\n    // holds the deliverables for insertion into the database\n    db_delivs = [];\n\n  var user_id = user;\n  if (!user) {\n    user_id = 0;\n  }\n\n  // This waterfall will run through each function until they are all complete\n  // The first function creates a master object that can be passed into the stylesheet\n  async.waterfall([function (callback) {\n\n    var type, section, label, tmpvalue, values, value, index, subindex,name,qid, getLabel, getAnswer, isLoop;\n\n    /**\n     * Retrieve the label for a field. If no argument is supplied, the main label is returned\n     *\n     * @id {string} The optional id of the radio, checkbox, or dropdown label that we want to retrieve\n     *\n     */\n    getLabel = function (id) {\n      if (typeof id === 'undefined') {\n        return this.label;\n      } \n      if (Array.isArray(this.values[this.name])) {\n        return this.values.label[id];\n      } else {\n        return this.values.label[id];\n      }\n    };\n\n    /**\n     * A helper function to get the answer of a question\n     *\n     */\n    getAnswer = function () {\n      return this.values[this.name];\n    };\n\n    /**\n     * A helper function to see if the question is part of a loop\n     *\n     */\n    isLoop = function () {\n      return this.loop;\n    };\n\n    // go through each variable and attach a few other properties\n    for (name in master) {\n      if (master.hasOwnProperty(name)) {\n        if (typeof master[name].values !== 'undefined') {\n          type = master[name].type;\n          // this will be 'advanced' or 'field'\n          section = master[name].section;\n          qid = master[name].qid;\n          // this will only be stringified array for a check-box\n          value = (typeof master[name].values[name] !== 'undefined') ? master[name].values[name]: '';\n          // initialize the label object inside the values\n          master[name].values.label = {};\n          master[name].question = {};\n\n          // Set the main label (check-box,radios and drop-downs have labels for each selection, and possibly a label for the question itself)\n          switch (section) {\n            case 'advanced':\n              // there are no labels for advanced variables\n              label = null;\n              break;\n            case 'field':\n              \n              // get the index of where the variable resides in the fields array, returns -1 if not found\n              index = utils.findIndex('name', name, doc.data[qid].fields); \n\n              // attach the field label if it exists\n              label = (index >= 0) ? doc.data[qid].fields[index].label : label = null;\n\n              // checkbox, radio, and text_dropdowns have labels attached to each id\n              if (type === 'radio' || type === 'text_dropdown') {\n                if (Array.isArray(value)) {\n                  for (var i = 0; i < value.length; i+=1) {\n                    subindex = utils.findIndex('id', value[i], doc.data[qid].fields[index].values);\n                    if (subindex >= 0) {\n                      master[name].values.label[value[i]] = doc.data[qid].fields[index].values[subindex].label;\n                    } \n                  }\n                } else {\n                  if (index >= 0) {\n                    subindex = utils.findIndex('id', value, doc.data[qid].fields[index].values);\n                    if (subindex >= 0) {\n                      master[name].values.label[value] = doc.data[qid].fields[index].values[subindex].label;\n                    }\n                  }\n                }\n              } else if (type === 'checkbox') {\n                // if the question is a loop, value will be an array of stringified arrays, so we need to parse each one\n                if (Array.isArray(value)) {\n                  // make sure all the labels are added for looped checkboxes\n                  // this will only add the labels for the checkboxes selected on the first loop iteration\n                  value = value[0];\n                }\n\n                // a checkbox stores a stringified array as the value so first parse it\n                value = JSON.parse(value);\n\n                if (value) {\n                  // go through each answer and look up its label\n                  for (var j = 0; j < value.length; j+=1) {\n                    subindex = utils.findIndex('id', value[j], doc.data[qid].fields[index].values);\n                    if (subindex >= 0) {\n                      master[name].values.label[value[j]] = doc.data[qid].fields[index].values[subindex].label;\n                    } else if (value[j] === 'nota') {\n                      master[name].values.label.nota = \"None of the above\";\n                    }\n                  }\n                }\n              }\n              break;\n          }\n\n          master[name].label = label;\n          master[name].getLabel = getLabel;\n          master[name].getAnswer = getAnswer;\n          master[name].isLoop = isLoop;\n        } else {\n          delete master[name];\n        }\n      }\n    }\n    callback(null, master);   \n  },\n\n  // This function will take the master that was created and attach it to \n  // another object along with the progress from the interview\n  function (master, callback) {\n    var answers = {};\n\n    // go through the progress array and attach some extra properties to each object, like the answers from that question\n    for (var i = 0; i < progress.length; i+=1) {\n      // store each questions answers as an array of objects\n      progress[i].answers = [];\n      \n      var qid = progress[i].qid;\n\n      // look through the fields array from the database for the question and match each variable name to the master \n      var fields = doc.data[qid].fields;\n      \n      for (var j = 0; j < fields.length; j+=1) {\n        var name = fields[j].name;\n        progress[i].answers.push(master[name]);\n      }\n    }\n\n    // go through each variable and attach a few other properties\n    for (var prop in master) {\n      if (master.hasOwnProperty(prop)) {\n        if (typeof master[prop].values !== 'undefined') {\n          answers[prop] = master[prop].values[prop];\n        }\n      }\n    }\n\n    // This object will contain all the answers as well as the progress\n    var outcome = {\n      meta: {\n        date: {\n          day: datetime.getDate(),\n          month: (parseInt(datetime.getMonth(),10)+1),\n          year: datetime.getFullYear(),\n          time: datetime.toTimeString(),\n          raw: datetime\n        }\n      },\n      interview: {\n        name: doc.name\n      },\n      master: master,\n      progress: progress,\n      answers: answers\n    };\n\n    callback(null, outcome);  \n  },\n\n  // This function takes the result from the last function in the waterfall\n  function (outcome, callback) {\n    var client = clientName(outcome.master.Client_first_name_TE, outcome.master.Client_last_name_TE, outcome.master.Client_full_name_TE);\n\n    // Save the outcome to disk\n    // We do not need to wait for this to complete because it is independent of any other operations\n    fs.writeFile(base_location + json_answer_file, JSON.stringify(outcome,null,4), function (err) {\n      if (err) {\n        console.log(err);\n        callback(err);\n      } \n    });\n\n    // Before we start creating all the output files, store them in a temp directory, for easy zip up later\n    fs.mkdir(base_location + out_directory, 511, function (err) {\n      if (err) {\n        console.log(err);\n        throw err;\n      }\n\n      // The master count refers to the how many total deliverables we are processing\n      var master_count = 0;\n\n      // The loop count refers to an individual deliverable which many be processed more than once\n      var looper_count = 0;\n\n      // Loop through each deliverable, creating a temp filename to store the (.fo|.fdf) and then write the file\n      // and use that temp file to generate the final output, but running Apache FOP, or docx4j, and store in correct directory.\n      // \n      // If there is a problem generating any document, none are generated and a message is returned to the user\n      async.forEachSeries(deliverables, function (deliverable, callback) {\n        var options = {\n          // Prepend the interview name if the setting does not exist\n          prepend_interview: (deliverable.output.file && deliverable.output.file.prepend_interview === false) ? false : true\n        };\n\n        var input_name = deliverable.input.name,\n          input_type = deliverable.input.type || 'fo',\n          output_name = deliverable.output.name,\n          // this will be pdf_form for a fillable pdf\n          output_type = deliverable.output.type,\n          //this will create the temp file (to be passed for output generation) using the input type selected when adding a deliverable\n          tmp = tmpFilename(input_type),\n          // pass in the name of the output, and the type collected from th admin section...add deliverable\n          out = outFilename(doc.name, output_name, output_type, client, datetime, master_count, options),\n          looper = deliverable.input.looper,\n          current_deliverable = utils.deepCopy(deliverable);\n\n        // this is where we read in the style sheet given to us\n        fs.readFile(base_location + uploads_directory + input_name, 'utf8', function (err, data) { \n          // Any errors get passed to the final callback function\n          if (err) {\n            callback(err);\n          } \n            \n          // since this will be error prone (user given style sheet), wrap it in a try block\n          try {\n            // stylesheet will be an .fo string, or a fdf string for a fillable form, with all the data \n            // replaced, ready to be sent to the fop or fdf processor\n\n            var locals = { \n              master: outcome.master,\n              progress: outcome.progress,\n              answers: outcome.answers,\n              count: looper_count\n            };\n\n            // Attach all the common functions for the stylesheet and interview\n            for (var fnCommon in func.common) {\n              locals[fnCommon] = func.common[fnCommon];\n            }\n\n            // Attach all the functions for the stylesheet\n            for (var fnLocal in func.stylesheet) {\n              locals[fnLocal] = func.stylesheet[fnLocal];\n            }\n\n            var stylesheet = ejs.render(data, { \n              locals: locals\n            });\n\n            // This is where we write the temp file. A generated .fo or .fdf file is created. \n            // Only do this if the style sheet was generated at all\n            fs.writeFile(base_location + tmp_directory + tmp, stylesheet, function (err) {\n              if (err) {\n                console.log(err);\n                throw err;\n              } \n\n              var cmd;\n\n              // check to see what the output is and use the corresponding doc processor\n              if (output_type === 'pdf_form') {\n                // this will use pdftk to create a pdf that is filled\n                cmd = spawn('pdftk', [base_location + deliverable.input.form.path, 'fill_form', base_location + tmp_directory + tmp, 'output', base_location + out_directory  + out]);\n              } else {\n                // this runs the fop build command with the location specific to either prod or dev\n                cmd = spawn(app.get('fop_location') + 'fop', ['-' + input_type, base_location + tmp_directory + tmp, '-' + output_type, base_location + out_directory  + out]);\n              }\n\n              cmd.stderr.on('data', function (data) {\n                console.log('stderr: ' + data);\n                // A calback with the error can be called here because FOP wil thrown warnings\n                // for things like fonts not being found, and we do not want to send error\n                // messages for things like that and there is no way to distinguish \n                // between errors an warnings.\n              });\n\n              cmd.on('exit', function (code) {\n                if (code !== 0) {\n                  callback('The stylesheet [' + input_name + '] could not be processed. There might be an error with one or more of your stylesheets. Also, check that Apache FOP is installed correctly and that the path to the binary (located in config.js) is correct.');\n                } else {\n                  //if we get here the process exited successfully\n                  db_delivs.push({\n                    id: require('crypto').createHash('md5').update(tmp + output_type).digest(\"hex\"),\n                    name: out,\n                    path: out_directory + out,\n                    description: deliverable.description,\n                    type: output_type\n                  });\n\n\n                  // if this a stylesheet that is looped, add on the same deliverable, to the \n                  // array and run the same thing again with an incremented counter\n                  if (looper) {\n                    // the next deliverable should be right after the one we just did\n                    deliverables.splice(master_count+1, 0, current_deliverable);\n\n                    // goes to the next loop iteration\n                    master_count+=1;\n                    looper_count+=1;\n                    callback();\n                  } else {\n                    // goes to the next loop iteration\n                    master_count+=1;\n                    looper_count = 0;\n                    callback();\n                  }\n                }\n              });\n            });\n          // if there was a problem with generating the form, none of the documents are generated and the main callback below gets called\n          } catch (e) {\n            // if the error was a call to exit\n            if (e === 'exit') {\n              // go to the next iteration\n              master_count+=1;\n              looper_count = 0;\n              callback();\n            } else {\n              // any other case\n              callback(e);\n            }\n\n          }\n        });\n\n      // the main callback when we are done looping through the deliverables, called as soon as an error bubbles up\n      }, function (err) {\n        // if there was an error with a style sheet this gets called\n        if (err) {\n          callback(err);\n        } else {\n          // this is the success callback\n          callback(null,{\n            dir: out_directory, \n            col: db_delivs, \n            client: client\n          });\n        }\n      });\n    });\n\n  },\n\n  // This will save the output results to the database\n  function (data, callback) {\n    // Look up the counter of the outputs\n    models.Counters.findOne({}, function (err, counter) {\n      var output = new models.Outputs();\n      // get the current count from the database and increment by to get the next interview\n      var count = counter.output_count + 1;\n\n      output.id = count;\n      // This will be 0 for a non-registered user (guest)\n      output.user_id = user_id;\n      output.client_lastname = data.client.last;\n      output.client_firstname = data.client.first;\n      output.client_fullname = data.client.full;\n      output.interview = {\n        id: doc.id,\n        name: doc.name,\n        group: doc.group\n      };\n      output.deliverables = data.col;\n      output.answers = {\n        id: require('crypto').createHash('md5').update(data.client.last + count).digest(\"hex\"),\n        name: microtime + \".json\",\n        path: json_answer_file,\n        type: 'json'\n      };\n      output.date = datetime;\n\n      // save to the database\n      output.save(function(err) {\n        if (err) {\n          callback(err);\n        } else {\n          //update the counter in the database\n          models.Counters.update({output_count: count}, function (err) {\n            if (err) {\n              callback(err);\n            } else {\n              callback(null, data);\n            }\n          }); \n        }\n      });\n    });\n  }],\n  // When all functions are done this gets run, or if an error comes up\n  function (err, result) {\n    if (err) {\n      // return with an error, which will alert the end-user\n      socket_callback(err);\n    } else {\n      // this returns to the socket function\n      socket_callback(null, result);\n    }\n  });\n};\n\n/**\n * This gets called before the absolute final output question gets shown to the client, \n * and we process the email notifications and send out any deliverables.\n *\n * @email {string} The id of the question\n * @interview_name {string} The name of the interview being processed\n * @base {string} The base_location setting in the config file\n * @data {object} The interview object\n * @complete {object} Contains the settings for what to do after an interview is completed (set in the manager)\n * @deliverables {object} Contains all the deliverable data that has been processed\n * @client {object} Contains the name of the end-user completing the interview\n * @app {object} The LogicPull application object that contains settings we need\n * @socket_callback {function} Callback that gets run after completion\n *\n */\nexports.email = function (email, interview_name, base, data, complete, deliverables, client, app, socket_callback) {\n  \"use strict\";\n\n  var date = new Date(); \n  var datetime = date.toLocaleDateString() + \" \" + date.toTimeString();\n  var transport_options = {\n    host: app.get('email_host')\n  };\n\n  // check if smtp auth is required\n  if (app.get('email_enable_auth')) {\n    transport_options.auth = {\n      user: app.get('email_auth_user'),\n      pass: app.get('email_auth_pass')\n    };\n  }\n\n  var transport = nodemailer.createTransport(\"SMTP\", transport_options);\n\n  async.waterfall([function (callback) {\n    var message;\n\n    // check to see if we want to email notifications out, and its not disabled in configuration\n    if (!app.get('disable_email_notifications') && complete.email_notification) {\n      message = {\n        from: app.get('email_from'),\n        to: app.get('email_notifications_to'),\n        bcc: complete.email_notification,\n        subject: \"LogicPull Event Notification\",\n        text: \"The following activity has recently occurred: \" + interview_name + \" - Completed \" + datetime + \" by \" + client.full + \".\",\n        html: \"<div>The following activity has recently occurred:<br><br><p><strong>\" + interview_name + \"</strong> - Completed \" + datetime + \" by <strong>\" + client.full + \"</strong></p>.</div>\"\n      };\n\n      // send mail with defined transport object\n      transport.sendMail(message, function(err, response) {\n        if (err) {\n          console.log(err);\n          callback(err);\n        } else {\n          console.log(\"Message sent: \" + response.message);\n          callback(null, response.message); \n        }\n      });\n    } else {\n      callback(null, null);\n    }\n  },\n  /**\n   * Email deliverables to client\n   *\n   */\n  function (response, callback) {\n    // Check to see if we want to email deliverables to a user-defined list set in the manager\n    if (!app.get('disable_email_deliverables') && complete.email_deliverables) {\n      var out = outFilename(interview_name, '', 'zip', client, date, null, null);\n      // gzip the folder with the deliverables\n      zipFiles(base, out, data.deliverables, function (err, attach_file_path) {\n        var message;\n\n        if (err) {\n          console.log(err);\n          callback(err);\n        } else {\n          message = {\n            from: app.get('email_from'),\n            to: app.get('email_deliverables_to'),\n            bcc: complete.email_deliverables,\n            subject: \"LogicPull Interview Deliverables\",\n            text: \"The following activity has recently occurred: \" + interview_name + \" - Completed \" + datetime + \" by \" + client.full + \".\",\n            html: \"<div>The following activity has recently occurred:<br><br><p><strong>\" + interview_name + \"</strong> - Completed \" + datetime + \" by <strong>\" + client.full + \"</strong><br>All deliverables produced are attached below in the zip file <strong>\"+out+\"</strong></p>.</div>\",\n            attachments: [{\n              filePath: attach_file_path,\n            }]\n          };\n\n          // send mail with defined transport object\n          transport.sendMail(message, function(err, response) {\n            if (err) {\n              console.log(err);\n              // return the error to the socket and show the error question\n              callback(err);\n            } else {\n              callback(null, attach_file_path);\n            }\n          });       \n        }\n      });\n    } else {\n      callback(null, null);\n    }\n  },\n\n  /**\n   * Email deliverables to users defined in the manager. \n   *\n   * @path_to_zip {string} The complete file path of where the zip is located\n   *\n   */\n  function (path_to_zip, callback) {\n    var out, message;\n\n    // check to see if we want to email notifications to he client. the email is given to us at the end\n    if (!app.get('disable_email_deliverables') && complete.email_deliverables_to_client) {\n      message = {\n        from: app.get('email_from'),\n        to: email,\n        subject: \"LogicPull Deliverables\",\n        text: \"The following activity has recently occurred: \" + interview_name + \" - Completed \" + datetime + \" by \" + client.full + \".\",\n        html: \"<div>Your documents have been prepared for you!<br><br><p><strong>\" + interview_name + \"</strong> - Completed \" + datetime + \"<br>All deliverables produced are attached below in the zip file below.</p>.</div>\"\n      };\n\n      // if path_to_zip is null that means the zip has not been generated yet\n      if (path_to_zip) {\n\n        message.attachments = [{filePath: path_to_zip}];\n\n        // send mail with defined transport object\n        transport.sendMail(message, function(err, response) {\n          if (err) {\n            console.log(err);\n            // return the error to the socket and show the error question\n            callback(err);\n          } else {\n            callback(null, path_to_zip);\n          }\n        }); \n\n      } else {\n        out = outFilename(interview_name, '', 'zip', client, date, null, null);\n\n        // Gzip the folder with the deliverables\n        zipFiles(base, out, data.deliverables, function (err, attach_file_path) {\n          if (err) {\n            console.log(err);\n            callback(err);\n          } \n\n          message.attachments = [{filePath: attach_file_path}];\n\n          // send mail with defined transport object\n          transport.sendMail(message, function(err, response) {\n            if (err) {\n              console.log(err);\n              // return the error to the socket and show the error question\n              callback(err);\n            } else {\n              callback(null, path_to_zip);\n            }\n          });       \n        });\n      }\n\n    } else {\n      callback(null, null);\n    }\n  }],\n\n  /**\n   * When all functions in the waterfall have completed, or an error has occurred.\n   *\n   */\n  function (err, result) {\n    if (err) {\n      socket_callback(err);\n    } else {\n      // this returns to the socket function\n      socket_callback(null, result);\n    }\n  });\n};\n'LogicPull/lib/sockets.js'\n:/*  Copyright 2015 Chris Zieba <zieba.chris@gmail.com>\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU\n  Affero General Public License as published by the Free Software Foundation, either version 3 of the\n  License, or (at your option) any later version.\n  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE. See the GNU Affero General Public License for more details. You should have received a\n  copy of the GNU Affero General Public License along with this program. If not, see\n  <http://www.gnu.org/licenses/>.\n*/\n\nvar graphviz = require('graphviz'),\n  fs = require('fs'),\n  utils = require('./utils'),\n  sanitizor = require('../lib/validation/sanitizor'),\n  validator = require('../lib/validation/validator'),\n  interview = require('./interviews/interview'),\n  process = require('./interviews/process'),\n  helpers = require('./helpers'),\n  models = require('../models/models'),\n  // stores all the information about the client, including the variables in the interview, and sockets (1 or 2 depending if editing)\n  connected_clients = {};\n\n// the app parameter is used for retrieving vars via app.get()\nexports.listen = function (server, sessionStore, app) {\n  \"use strict\";\n\n  // Session middleware\n  var getSession = function(cookie, done) {\n    var parsed = utils.parseCookie(cookie);\n\n    if (!parsed) {\n      return done(new Error('Could not parse cookie'));\n    }\n\n    if (!parsed.hasOwnProperty('connect.sid')) {\n      return done(new Error('Missing cookie'));\n    }\n\n    var sessionID = parsed['connect.sid'].split('.')[0].substring(2);\n\n    sessionStore.get(sessionID, function (err, session) {\n      if (err || !session) {\n        return done(new Error('Session was not found'));\n      }\n\n      return done(null, session);\n    });\n  };\n\n  var opts = {\n    \"close timeout\": app.get('socket_close_timeout'),\n    \"log level\":  app.get('socket_log_level'),\n    \"match origin protocol\": app.get('socket_match_origin_protocol'),\n    \"sync disconnect on unload\": app.get('socket_sync_disconnect_on_unload'),\n    \"transports\": app.get('socket_transports'),\n    \"flash policy port\": app.get('socket_flash_policy_port')\n  };\n\n  if (app.get('socket_browser_client_minification')) {\n    opts['browser client minification'] = true;\n  }\n\n  if (app.get('socket_browser_client_etag')) {\n    opts['browser client etag'] = true; \n  }\n\n  if (app.get('socket_browser_client_gzip')) {\n    opts['browser client gzip'] = true;\n  }\n\n\n  var io = require('socket.io').listen(server);\n\n  // This is what runs on an incoming socket request\n  // If there is already a session established, accept the socket, otherwise deny it\n  io.set('authorization', function (data, accept) {\n    // Check if the person connecting is logged in. \n    // If they are, store there user is and check it again when they are trying to save the interview\n    if (data.headers.cookie) {\n      data.cookie = utils.parseCookie(data.headers.cookie);\n\n      if (data.cookie) {\n        if (data.cookie['connect.sid']) {\n          data.sessionID = data.cookie['connect.sid'].split('.')[0].substring(2);\n          // Create a new connection to the LogicPul database, so we can compare the _id field to the cookie sid field\n          // these must match in order for a connection to go through\n          sessionStore.get(data.sessionID, function (err, session) {\n            // these are urls we don't need to authorize a logged in user for the /interviews\n            var no_auth_required = new RegExp(app.get('base_url') + '/interviews/', 'g');\n\n            if (err || !session) {\n              // Don't accept the socket request if the user is not logged in\n              if (!no_auth_required.test(data.headers.referer)) {\n                // If we get here the URL is from inside the manager\n                return accept('Session not found in database', false);\n              }\n\n              console.log('   debug - ' + 'no socket authorization needed');\n              return accept(null, true);\n            }\n\n            // save the session data and accept the connection if the user is logged in\n            if (session.user && session.user.authenticated) {\n              data.session = session;\n              data.session.url = data.headers.referer;\n              return accept(null, true);\n            }\n\n            if (!no_auth_required.test(data.headers.referer)) {\n              return accept('User is not authenticated', false);\n            }\n\n            console.log('   debug - ' + 'no socket authorization needed');\n            return accept(null, true);                  \n          });                     \n        } else {\n          return accept('No cookie transmitted.', false);\n        }               \n      } else {\n        return accept('No cookie transmitted.', false);\n      }\n    } else {\n      return accept('No cookie transmitted.', false);\n    }\n  });\n\n  // Client is the socket\n  io.sockets.on('connection', function (client) {\n    // Keep track of all the connected_clients\n    var id = client.id;\n\n    // @type {string} kind of message..i.e question, error...\n    function emitData (id, type, data) {\n      connected_clients[id].socket.emit(type, data);\n\n      // if this socket has an editor id set, than check if any other socket shares that id, and send the data to that socket as well\n      if (connected_clients[id].editor) {\n        // go through each socket to see if we can get the editor socket\n        for (var socket_id in connected_clients) {\n          if (connected_clients.hasOwnProperty(socket_id)) {\n            // check that we are not checking the same socket\n            if (socket_id !== id) {\n              if (connected_clients[socket_id].editor) {\n                // check if they match\n                if (connected_clients[socket_id].editor === connected_clients[id].editor) {\n                  connected_clients[socket_id].socket.emit(type, data);\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // if the session is NOT already open, create the new object\n    if (!connected_clients.hasOwnProperty(client.id)) {\n      connected_clients[id] = {\n        editor:null,\n        socket: client,\n        data: {\n          interview: {},\n          //progress: [],\n          // this is a map of what each question is in terms of distance from the end\n          distance: {},\n          // master will now contain the variables from each question \n          master: {},\n          deliverables: {},\n          client: null\n        }\n      };\n    } \n\n    // after the editor client connects, send an id\n    client.on('editor_id', function (editor_id) {\n      connected_clients[id].editor = editor_id;\n    }); \n\n    // When the viewer starts\n    client.on('start', function (data) {\n      var run;\n      var progress;\n      var send_data;\n      var preview = data.preview;\n      var start = data.start;\n\n      getSession(client.handshake.headers.cookie, function(err, session) {\n        if (err) {\n          console.log(err);\n          throw err;\n        }\n\n        models.Interviews.findOne({id: data.interview_id}, function (err, doc) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n          \n          if (!doc) {\n            emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n            return;\n          }\n\n          var qid = doc.start;\n\n          models.Counters.findOne({}, function (err, counter) {\n            // Get the current count from the database and increment by to get the next interview\n            var tmp_count = counter.tmp_count + 1;\n            var state_id = counter.state_count + 1 + '-' + tmp_count;\n            var tmp_progress = [];\n            var tmp_history = [];\n            var tmp = new models.Tmps();\n            var state = new models.States();\n\n            // update the counter right away\n            models.Counters.update({\n              tmp_count: tmp_count,\n              state_count: counter.state_count + 1\n            }, function (err) {\n              if (err) {\n                console.log(err);\n                throw err;\n              } \n\n              // check if a value was passed as the start (preview)\n              if (start) {\n                // check to make sure the start passed is actually used in the interview\n                if (doc.data[start]) {\n                  qid = start;\n                }\n              }\n              \n              // initialize the progress\n              tmp_progress.push(state_id);\n\n              var startInterview = function(graph) {\n                // In case the window is closed while the graph is being generated\n                if (typeof connected_clients[id] === 'undefined' || !connected_clients[id].hasOwnProperty('data')) {\n                  return;\n                }\n\n                // Now we can use the distance object mapping to find how many questions are in front of the current one\n                var fraction = graph[qid] || '';\n\n                // Turn the start question of the interview, completing any before logic in the question\n                run = interview.start(qid, doc.data[qid], doc.data, {}, [], state_id); \n\n                // Build the history for the drop down menu\n                progress = interview.progress(run.progress); \n\n                // cache the graph data \n                connected_clients[id].data.distance = graph;\n\n                // the first question does not run helpers.merge, which adds the fields\n                connected_clients[id].data.master.fields = [];\n\n                // we don't need to rerun the helpers.merge function because any vars that are set at the beginning will be returned with run\n                // this is the master vars after all the logic is run, including the before logic of the question we are showing\n                connected_clients[id].data.master.vars = run.master;\n\n                connected_clients[id].data.interview = {\n                  id: doc.id,\n                  name: doc.name,\n                  description: doc.description\n                };\n\n                send_data = {\n                  // send the id (count) that corresponds to the database record of the tmp record, which corresponds to the save_id if we save\n                  id: tmp_count,\n                  qid: run.qid,\n                  data: {\n                    question: run.question, \n                    progress: progress,\n                    debug: run.debug,\n                    fraction: fraction\n                  },\n                  valid: true\n                };\n\n                // create the new database record for the interview being worked on\n                tmp.id = tmp_count;\n                // a reference to where the last state is\n                tmp.current = state_id;\n                tmp.history = run.progress;\n                tmp.created = new Date();\n                tmp.last_modified = new Date();\n                // the progress will record the state id after each question\n                tmp.progress = tmp_progress;\n\n                tmp.save(function(err) {\n                  if (err) {\n                    console.log(err);\n                    throw err;\n                  } \n\n                  // create a new state record \n                  state.id = state_id;\n                  state.tmp_id = tmp_count,\n                  state.created = new Date();\n                  state.last_modified = new Date();\n                  state.data = connected_clients[id].data;\n\n                  state.save(function(err) {\n                    if (err) {\n                      console.log(err);\n                      throw err;\n                    }\n\n                    // update the interview in the database to cache the distance graph, if NOT in preview mode\n                    if (!preview && doc.distance.update) {\n                      doc.distance = {\n                        update: false,\n                        graph: graph\n                      };\n\n                      doc.save(function () {\n                        if (err) {\n                          console.log(err);\n                          throw err;\n                        }\n                        emitData(id, 'question', send_data);\n                      });\n                    } else {\n                      emitData(id, 'question', send_data);\n                    }\n                  });\n\n                });\n              };\n\n              // check if grahpviz progress is disabled\n              if (app.get('disable_graphviz_progress')) {\n                startInterview({});\n              } else {\n                // we might not need to update the progress fraction if the interview has been modified\n                if (doc.distance.update) {\n                  interview.distance(doc.data, qid, startInterview);\n                } else {\n                  startInterview(doc.distance.graph);\n                }\n              }\n            });\n          });\n        });\n      });\n    });\n\n    // When the continue button on the viewer is clicked, or when back is clicked, or when the progress dropdown is changed\n    client.on('question', function (data) {\n      getSession(client.handshake.headers.cookie, function (err, session) {\n        if (!session) {\n          console.log(err);\n          throw err;\n        }\n\n        var loop;\n        var query;\n        var validate;\n        var send_data;\n        var run;\n        var next;\n        var progress;\n        var fraction;\n        var qid = data.qid;\n        var loop_index = null;\n        // this is the array of objects with the answers\n        var fields = data.fields;\n        var destination = data.destination;\n\n        //TODO: sanitize the inputs, not dry, don't query the database every time for this interview ... store the variable\n        models.Interviews.findOne({id: data.interview}, function (err, doc) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (!doc) {\n            emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n            return;\n          }\n\n          models.Tmps.findOne({id: data.id}, function (err, tmp) {\n            if (err) {\n              console.log(err);\n              throw err;\n            } \n\n            // look up the current state using the current id\n            models.States.findOne({id: tmp.current}, function (err, state) {\n              if (err) {\n                console.log(err);\n                throw err;\n              }\n\n              models.Counters.findOne({}, function (err, counter) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                } \n\n                var tmp_progress = tmp.progress;\n                var new_state = new models.States();\n                var new_state_id = counter.state_count + 1 + '-' + tmp.id;\n\n                // update the counter in the database\n                models.Counters.update({ state_count: counter.state_count + 1 }, function (err) {\n                  if (err) {\n                    console.log(err);\n                    throw err;\n                  } \n\n                  // Save the database interview information to the clients socket object\n                  connected_clients[id].data = state.data;\n\n                  // The validate function will evaluate the answers sent when the user clicks next.\n                  // Pass the answers, and the fields for this question...so we can compare to the validation object.\n                  // Validation will return either true, or false and an error message.\n                  validate = interview.validate(fields, doc.data[qid], connected_clients[id].data.master.vars, doc.data);\n\n                  // check all the fields for their validation \n                  if (validate.error) {\n                    // prepare the error data for the client\n                    send_data = {\n                      id: tmp.id,\n                      qid: null,\n                      // this is an object with the error message, name of the field that caused the error and a truth value\n                      data: validate,\n                      valid: false\n                    };\n\n                    emitData(id, 'question', send_data);\n                  } else {\n\n                    if (err) {\n                      console.log(err);\n                      throw err;\n                    } \n\n                    // This tests to see of the loop variable is set in the question, activating the loop.\n                    // When a question is in a loop, its answers are stored differently.\n                    loop = (doc.data[qid].loop1 !== null && typeof doc.data[qid].loop1 !== 'undefined' && doc.data[qid].loop1 !== '') ? true : false;\n\n                    connected_clients[id].data.master.fields = fields;\n\n                    // We need to get the loop_index before the fields are merged into the master set\n                    if (loop) {\n                      for (var prop1 in connected_clients[id].data.master.vars) {\n                        if (connected_clients[id].data.master.vars.hasOwnProperty(prop1)) {\n                          if (connected_clients[id].data.master.vars[prop1].loop) {\n                            if (connected_clients[id].data.master.vars[prop1].qid === qid) {\n                              if (Array.isArray(connected_clients[id].data.master.vars[prop1].values[prop1])) {\n                                loop_index = connected_clients[id].data.master.vars[prop1].values[prop1].length;\n                                break;\n                              }\n                            }\n                          }\n                        }\n                      }\n                      // set the loop index to 0 if it wasnt set since its in a loop\n                      if (loop_index === null) {\n                        loop_index = 0;\n                      }\n                    }\n\n                    // merge the variables into the master set\n                    connected_clients[id].data.master.vars = helpers.merge(connected_clients[id].data.master.vars, fields, loop, doc.data[qid]);\n\n                    // get the before_logic\n                    next = interview.next(qid, doc.data[qid], doc.data, connected_clients[id].data.master.vars, fields, tmp.history, new_state_id, destination);\n\n                    // check if the next question is in a loop\n                    var next_loop = (doc.data[next.qid].loop1 !== null && typeof doc.data[next.qid].loop1 !== 'undefined' && doc.data[next.qid].loop1 !== '') ? true : false;\n\n                    // we need to get the loop length so\n                    // we can get the correct state based on the loop index, which will\n                    // be incremented and saved in the state when it's saved\n                    if (next_loop) {\n                      var next_loop_index = null;\n                      for (var prop2 in connected_clients[id].data.master.vars) {\n                        if (connected_clients[id].data.master.vars.hasOwnProperty(prop2)) {\n                          if (connected_clients[id].data.master.vars[prop2].loop) {\n                            if (connected_clients[id].data.master.vars[prop2].qid === next.qid) {\n                              if (Array.isArray(connected_clients[id].data.master.vars[prop2].values[prop2])) {\n                                next_loop_index = connected_clients[id].data.master.vars[prop2].values[prop2].length;\n                                break;\n                              }\n                            }\n                          }\n                        }\n                      }\n\n                      // set the loop index to 0 if it wasnt set since its in a loop\n                      if (next_loop_index === null) {\n                        next_loop_index = 0;\n                      }\n                    \n                      query = {\n                        tmp_id: tmp.id, \n                        base_qid: next.qid,\n                        loop_id: next_loop_index\n                      };\n                    } else {\n                      query = {\n                        tmp_id: tmp.id, \n                        base_qid: next.qid\n                      };\n                    }\n\n                    // Look for any states that have run this question already\n                    models.States.find(query).sort({created: 1}).exec(function (err, states) {\n                      // Build the queston using any previously answered questions\n                      run = interview.build(next, doc.data, fields, tmp.history, new_state_id, states);\n\n                      // build the history for the progress bar\n                      progress = interview.progress(run.progress); \n\n                      // find out the fractional progress of the interview\n                      fraction = (connected_clients[id].data.distance && connected_clients[id].data.distance.hasOwnProperty(run.qid)) ? connected_clients[id].data.distance[run.qid] : '';\n\n                      // update master vars list, since new answers could be created in the logic\n                      connected_clients[id].data.master.vars = run.master; \n\n                      // This is the data that gets sent back to the client. \n                      // It involves the HTML of the question to show the user,\n                      // and debug info for the editor (if edit mode)\n                      send_data = {\n                        id: tmp.id,\n                        qid: run.qid,\n                        data: {\n                          question: run.question, \n                          progress: progress,\n                          debug: run.debug,\n                          fraction: fraction\n                        },\n                        valid: true\n                      };  \n\n                      // create a new state record \n                      new_state.id = new_state_id;\n                      new_state.tmp_id = tmp.id;\n                      new_state.loop_id = loop_index;\n                      new_state.base_qid = qid;\n                      new_state.created = new Date();\n                      new_state.last_modified = new Date();\n                      new_state.data = connected_clients[id].data;\n                      \n                      new_state.save(function(err) {\n                        if (err) {\n                          console.log(err);\n                          throw err;\n                        } \n\n                        tmp_progress.push(new_state_id);\n\n                        // update the interview data in the database corresponding the socket ID\n                        models.Tmps.update({id:tmp.id}, {current: new_state_id, progress: tmp_progress, history: run.progress, last_modified: new Date().getTime()}, function (err) {\n                          if (err) {\n                            console.log(err);\n                            throw err;\n                          } \n\n                          // send the data back to the client\n                          emitData(id, 'question', send_data);\n                        }); \n                      });\n                    });\n                  }\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n\n    // When back is clicked, or when the progress dropdown is changed\n    client.on('back', function (data) {\n      getSession(client.handshake.headers.cookie, function (err, session) {\n        if (!session) {\n          console.log(err);\n          throw err;\n        }\n\n        models.Interviews.findOne({ id: data.interview }, function (err, doc) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (!doc) {\n            emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n            return;\n          }\n\n          var send_data, back, history, fraction;\n\n          // Look up the data for the users interview from the database\n          models.Tmps.findOne({ id: data.id }, function (err, tmp) {\n            if (err) {\n              console.log(err);\n              throw err;\n            }\n\n            if (!tmp) {\n              emitData(id, 'srv_error', { id: null, error: interview.error(\"A record could not be found for this interview.\").error.content, valid: false });\n              return;\n            }\n\n            var tmp_progress = tmp.progress;\n            var tmp_history = tmp.history;\n\n            // get the updated history and the id of the state we want to load\n            history = interview.history(tmp_progress, tmp_history, data.backid, data.previd);\n\n            tmp_progress = history.progress;\n            tmp_history = history.history;\n\n            // We need two states since the latest has the fields to repopulate, and the second has the state we want to revert to\n            models.States.find({id: { $in: [history.new_current_state, history.removed_state]} }).sort({id: -1}).exec(function (err, states) {\n              if (err) {\n                console.log(err);\n                throw err;\n              } \n              // this will be set to the current state\n              var new_current_state = states[1];\n\n              // use the fields from this state to repopulate\n              var removed_state = states[0];\n\n              back = interview.back(doc.data, new_current_state.data.master.vars, removed_state.data.master.fields, history.qid);\n\n              // find out the fractional progress of the interview      \n              fraction = (connected_clients[id].data.distance && connected_clients[id].data.distance.hasOwnProperty(back.qid)) ? connected_clients[id].data.distance[back.qid] : '';\n\n              send_data = {\n                id: tmp.id,\n                qid: back.qid,\n                data: {\n                  question: back.question, \n                  progress: interview.progress(tmp_history),\n                  debug: back.debug,\n                  fraction: fraction\n                },\n                valid: true\n              };    \n\n              //update the interview data in the database corresponding the socket ID\n              models.Tmps.update({id:tmp.id}, {current: new_current_state.id, progress: tmp_progress, history: tmp_history, last_modified: new Date().getTime()}, function (err) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                } \n                // send the data back to the client\n                emitData(id, 'question', send_data);\n              }); \n            });\n          });\n        });\n      });\n    });\n\n    // This is for the editor..not the viewer\n    client.on('save', function (data) {\n      getSession(client.handshake.headers.cookie, function (err, session) {\n        if (err || !session) {\n          console.log(err);\n          throw err;\n        }\n\n        var save = false;\n\n        // If theres a session here (not null) than the user is logged in while connecting to a socket\n        if (session.user) {\n          if (session.user.privledges.editor_save) {\n            save = true;\n          }\n        }\n\n        // only save to the database if the user has privledges\n        if (save) {\n          //TODO: sanitize the inputs\n          models.Interviews.findOne({ id: data.id }, function (err, doc) {\n            if (err) {\n              console.log(err);\n              throw err;\n            } \n\n            if (!doc) {\n              emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n              return;\n            }\n\n            doc.description = data.settings.description;\n            doc.steps = data.settings.steps;\n            doc.start = data.settings.start;\n            doc.data = data.data;\n            doc.distance = {\n              update: true,\n              graph: {}\n            };\n            doc.save();\n            connected_clients[id].socket.emit('saved', true);\n            \n          });\n        } else {\n          connected_clients[id].socket.emit('saved', false);\n        }\n      });\n    });\n\n    // when a client clicks the button to reorder the graph this fires\n    // TODO send this only to the client that is the editor\n    client.on('graph', function (data) {\n      if (app.get('disable_graphviz_tidy')) {\n        emitData(id, 'graph', {});\n      } else {\n        var g = graphviz.digraph(\"G\");\n        var options = {\n          type: \"dot\",\n          G: {\n            splines: false,\n            rankdir: \"BT\",\n            nodesep: \"0.2\"\n          }\n        };\n\n        // this creates the initial dot file to be rendered\n        for (var prop in data.nodes) {\n          if (data.nodes.hasOwnProperty(prop)) {\n            g.addNode(prop);\n            if (data.nodes[prop]) {\n              for (var i = 0; i < data.nodes[prop].length; i+=1) {\n                g.addEdge(prop, data.nodes[prop][i]);\n              }                   \n            }                   \n          }\n        }\n\n        // this takes the dote graph generated above and creates a dot file with all the postions\n        g.output(options, function (out) { \n          var dot = out.toString('utf-8');\n          var regex = /(q\\d+)\\s\\[pos=\"(\\d+),(\\d+)\",/gmi;\n          var graph = {};\n          var match;\n\n          while ((match = regex.exec(dot)) !== null) {\n            graph[match[1].toString()] = {\n              x: parseInt(match[2],10),\n              y: parseInt(match[3],10)\n            };\n          }\n\n          emitData(id, 'graph', graph);               \n        });\n      }\n    });\n\n    // This gets called when the save button in the viewer is clicked. \n    // We need the name and note (if any) to populate the text area on the save pop up\n    client.on('get_saved_note', function (data) {\n      //sanitize all the data sent over\n      var clean_id = sanitizor.clean(data.id.toString());\n\n      // look to see if there is already a saved interview with the same ID being sent from the client\n      models.Saves.findOne({ id: clean_id }).exec(function (err, doc) {\n        if (err) {\n          console.log(err);\n          throw err;\n        } \n\n        // Set the defaults\n        var name = \"\";\n        var note = \"\";\n\n        if (doc) {\n          name = doc.name;\n          note = doc.note;\n        } \n\n        // Let the user know there was an error\n        emitData(id, 'insert_saved_note', { name: name, note: note }); \n      });\n    });\n\n    // When the client clicks the save button.\n    // If we get here that mean the user is logged in (this is checked via Ajax in viewer.js)\n    client.on('save_progress', function (data) {\n      // Sanitize all the data sent over\n      var clean_id = sanitizor.clean(data.id.toString());\n      var clean_qid = sanitizor.clean(data.qid);\n      var clean_name = sanitizor.clean(data.name).substring(0,100);\n      var clean_note = sanitizor.clean(data.note).substring(0,500);\n      var clean_interview = sanitizor.clean(data.interview);\n\n      // The fields are used to prepopulate the question the interview was saved on\n      var fields = data.fields; \n\n      // Check if a user is logged in , there will be a sessionID from the database saved form them\n      if (client.handshake.headers.cookie) {\n        // revalidates that the user is still logged in, since we only checked when the socket connected\n        getSession(client.handshake.headers.cookie, function (err, session) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (session && session.user) {\n            // look up the data for the users interview from the database\n            models.Tmps.findOne({ id: clean_id }, function (err, tmp) {\n              if (err) {\n                console.log(err);\n                throw err;\n              }\n\n              // Look up the current state\n              models.States.findOne({id: tmp.current }, function (err, state) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                } \n\n                // if we get here the user is still logged in and we can get all their saved interviews\n                // look to see if there is already a saved interview with the same ID being sent from the client\n                models.Saves.findOne({ id: clean_id }, function (err, doc) {\n                  if (err) {\n                    // let the user know there was an error\n                    emitData(id, 'saved_progress', { valid:false }); \n                    return;\n                  }\n\n                  // If doc is not empty than there is already a record saved for that interview\n                  if (doc) {\n                    // update\n                    models.Saves.update({ id:clean_id }, {\n                      data: {\n                        current: tmp.current,\n                        history: tmp.history,\n                        progress: tmp.progress,\n                        state: state.data,\n                        fields: fields\n                      }, \n                      qid: clean_qid,\n                      name: clean_name,\n                      note: clean_note,\n                      last_modified: new Date()\n                    }, function (err) {\n                      if (err) {\n                        console.log(err);\n                        throw err;\n                      } \n                      emitData(id, 'saved_progress', {valid:true}); \n                    }); \n                  } else {\n                    var save = new models.Saves();\n                    // The tmp id gets incremented every time an interview is started so we don't have to worry about collisions\n                    save.id = tmp.id;\n                    save.user_id = session.user.id;\n                    save.interview_id = clean_interview;\n                    save.qid = clean_qid;\n                    save.socket_id = id;\n                    save.name = clean_name;\n                    save.note = clean_note;\n                    save.interview = connected_clients[id].data.interview;\n                    save.created = new Date();\n                    save.last_modified = new Date();\n                    save.data = {\n                      current: tmp.current,\n                      history: tmp.history,\n                      progress: tmp.progress,\n                      state: state.data,\n                      fields: fields\n                    };\n\n                    save.save(function(err) {\n                      if (err) {\n                        console.log(err);\n                        throw err;\n                      } \n\n                      emitData(id, 'saved_progress', {valid:true}); \n                    });\n                  }\n                });\n              });\n            });\n          } else {\n            emitData(id, 'saved_progress', {valid:false}); \n          }\n        });\n      } else {\n        // the user is not logged in and we can ask them to login first\n        emitData(id, 'saved_progress', {valid:false}); \n      }\n    }); \n\n    // when the client clicks the open button on the viewer\n    client.on('open_saves', function (data) {\n      // check if a user is logged in ,there will be a sessionID from the database saved for them\n      if (client.handshake.headers.cookie) {\n        // revalidate that the user is still logged in, since we only checked when the socket connected\n        getSession(client.handshake.headers.cookie, function (err, session) {\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (session && session.user) {\n            // if we get here the user is still logged in and we can get all their saved interviews\n            // look up the saved progress and attach the user name to the database record\n            // now we can add the users name to the record in the database for later retrieval\n            models.Saves.find({}).where('user_id').equals(session.user.id).where('interview_id').equals(data.interview).sort('-created').exec(function(err, saves) {\n              if (err) {\n                console.log(err);\n                throw err;\n              }\n\n              var admin = session.user.privledges && session.user.privledges.view_saved_interviews;\n\n              // send back all the saved interviews for the particular interview, corresponding to that user\n              emitData(id, 'open_saved', {\n                valid: true,\n                data: interview.saves(saves, admin)\n              });\n            });\n          } else {\n            emitData(id, 'open_saved', { valid:false }); \n          }\n        });\n      } else {\n        // the user is not logged in and we can ask them to login first\n        emitData(id, 'open_saved', { valid:false }); \n      }\n    }); \n\n    // When the client clicks the open button on the viewer\n    client.on('load_saved', function (data) {\n      // First, we need to get the id from the data which is sent in the format \"partial-55\"\n      var full_partial_id = data.partial_id;\n      var partial_id = full_partial_id.split('-')[1];\n\n      // Now we have the id of the partial interview we want to load into the viewer\n      models.Saves.findOne({}).where('id').equals(partial_id).exec(function(err, partial) {\n        if (err) {\n          console.log(err);\n          throw err;\n        } \n\n        if (partial) {\n          // Get the interview \n          models.Interviews.findOne({id: partial.interview_id}, function (err, doc) {\n            if (err) {\n              console.log(err);\n              throw err;\n            } \n\n            models.Counters.findOne({}, function (err, counter) {\n              var tmp = new models.Tmps();\n              var tmp_count = counter.tmp_count + 1;\n\n              // update the counter in the database\n              models.Counters.update({tmp_count: tmp_count}, function (err) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                } \n\n                var run = interview.load(doc.data[partial.qid], doc.data, partial.data.state.master.vars); \n                var send_data = {\n                  // send the id (count) that corresponds to the database record of the tmp record, which corresponds to the save_id if we save\n                  id: tmp_count,\n                  qid: partial.qid,\n                  data: {\n                    question: run.question, \n                    progress: interview.progress(partial.data.history),\n                    // there is no debug info...you cant load a partial interview when in preview mode, i.e. the editor\n                    debug: null,\n                    fraction: (partial.data.state.distance.hasOwnProperty(partial.qid)) ? partial.data.state.distance[partial.qid] : '',\n                    fields: (partial.data.hasOwnProperty('fields')) ? partial.data.fields : null\n                  },\n                  valid: true,\n                  partial:true\n                };\n\n                // Create the new database record for the interview being worked on\n                tmp.id = tmp_count;\n                tmp.history = [];\n                tmp.created = new Date();\n                tmp.last_modified = new Date();\n                // the progress will record the state id after each question\n                tmp.progress = [];\n\n                // Load in new states for answer pre-population\n                models.States.find({id: {$in: partial.data.progress }}, function (err, states) {\n                  if (err) {\n                    console.log(err);\n                    throw err;\n                  }\n\n                  var state_map = {};\n\n                  // Create new duplicate states with the new tmp_id\n                  for (var i = 0; i < states.length; i+=1) {\n                    var state = new models.States();\n                    state.id = counter.state_count + i + 1 + '-' + tmp.id;\n                    state.tmp_id = tmp.id;\n                    state.loop_id = states[i].loop_id;\n                    state.base_qid = states[i].base_qid;\n                    state.created = new Date();\n                    state.last_modified = new Date();\n                    state.data = states[i].data;\n                    state.save();\n\n                    if (states[i].id === partial.data.current) {\n                      tmp.current = state.id;\n                    }\n\n                    // record the new state as the progress\n                    tmp.progress.push(state.id);\n\n                    state_map[states[i].id] = state.id;\n                  }\n\n                  for (var j = 0; j < partial.data.history.length; j+=1) {\n                    partial.data.history[j].state = state_map[partial.data.history[j].state];\n                    tmp.history.push(partial.data.history[j]);\n                  }\n\n                  tmp.save(function (err) {\n                    if (err) {\n                      console.log(err);\n                      throw err;\n                    }\n\n                    var state_count = counter.state_count + states.length + 1;\n\n                    // update the counter in the database\n                    models.Counters.update({state_count: state_count}, function (err) {\n                      if (err) {\n                        console.log(err);\n                        throw err;\n                      }\n                      emitData(id, 'question', send_data);\n                    });\n                  });\n                });\n              });\n            });\n          });\n        } else {\n          // for some reason we could not find the partial interview we are trying to load\n          console.log('The saved record was not found when trying to load a saved interview.');\n          throw err;\n        }\n      });\n    }); \n\n    // When the client clicks the open button on the viewer\n    client.on('process_saved', function (data) {\n      if (client.handshake.headers.cookie) {\n        // revalidate that the user is still logged in, since we only checked when the socket connected\n        getSession(client.handshake.headers.cookie, function (err, session) {\n          if (err) {\n            console.log(err);\n            throw err;\n          }\n\n          var full_partial_id = data.partial_id;\n          var partial_id = full_partial_id.split('-')[2];\n\n          models.Saves.findOne({}).where('id').equals(partial_id).exec(function(err, save) {\n            if (err) {\n              return console.log(err);\n            } \n\n            if (!save) {\n              console.log('The saved record was not found when trying to load a saved interview.');\n              return;\n            }\n\n            // Get the interview \n            models.Interviews.findOne({id: save.interview_id}, function (err, doc) {\n              if (err) {\n                console.log(err);\n                return;\n              } \n\n              if (!doc) {\n                console.log('The interview could not be found.');\n                return;\n              }\n\n              // Process the saved interview as if it were completed\n              process.output(doc, save.data.state.master.vars, save.data.history, app.get('base_location'), app, session.user.id, function (err, data) {\n                if (err) {\n                  console.log(err);\n                  emitData(id, 'process_saved', { valid: false });\n                } else {\n                  var client = {\n                    full: session.user.name\n                  };\n\n                  process.email(null, doc.name, app.get('base_location'), doc, doc.on_complete, doc.deliverables, client, app, function (err, response) {\n                    if (err) {\n                      console.log(err);\n                      emitData(id, 'process_saved', { valid: false });\n                    } else {\n                      emitData(id, 'process_saved', { valid: true });\n                    }\n                  });\n                }\n              });\n            });\n          });\n        });\n      }\n    }); \n\n    // when a finish button is clicked in the interview\n    client.on('finish', function (data) {\n      var validate, emit, deliverables, run, progress, on_complete, send_data;\n      var base_location = app.get('base_location');\n      // this is the array of objects with the answers\n      var fields = data.fields;\n      var qid = data.qid;\n\n      //TODO: sanitize the inputs, not dry, don't query the database every time for this interview ... store the variable\n      models.Interviews.findOne({ id: data.interview }, function (err, doc) {\n        if (err) {\n          console.log(err);\n          throw err;\n        } \n\n        if (!doc) {\n          emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n          return;\n        }\n\n        models.Tmps.findOne({ id: data.id }, function (err, tmp) {\n          if (err) {\n            console.log(err);\n            throw err;\n          }\n\n          // look up the current state using the current id\n          models.States.findOne({id: tmp.current }, function (err, state) {\n            if (err) {\n              console.log(err);\n              throw err;\n            } \n\n            models.Counters.findOne({}, function (err, counter) {\n              if (err) {\n                console.log(err);\n                throw err;\n              } \n\n              // update the counter in the database\n              models.Counters.update({state_count: counter.state_count + 1}, function (err) {\n                if (err) {\n                  console.log(err);\n                  throw err;\n                }\n\n                var tmp_progress = tmp.progress;\n                var tmp_history = tmp.history;\n                var new_state = new models.States();\n                var new_state_id = counter.state_count + 1 + '-' + tmp.id;\n\n                // save the database interview information to the clients socket object\n                connected_clients[id].data = state.data;\n\n                // the validate function will evaluate the answers sent when the user clicks next\n                // pass the answers, and the fields for this question...so we can compare to the validation object\n                // validate will return either true, or false and an error message\n                validate = interview.validate(fields, doc.data[qid], connected_clients[id].data.master.vars, doc.data);\n\n                // check all the fields for their validation \n                if (validate.error) {\n                  // send the error back to the client\n                  send_data = {\n                    id: tmp.id,\n                    qid: null,\n                    data: validate,\n                    valid: false\n                  };\n                  // inform the client of whats happening\n                  emitData(id, 'question', send_data);\n\n                } else {\n                  var loop = (doc.data[qid].loop1 !== null && typeof doc.data[qid].loop1 !== 'undefined' && doc.data[qid].loop1 !== '') ? true : false;\n\n                  connected_clients[id].data.master.fields = fields;\n                  connected_clients[id].data.master.vars = helpers.merge(connected_clients[id].data.master.vars, fields, loop, doc.data[qid]);\n\n                  // this has all the info for what to do when the finish button is completed\n                  on_complete = doc.on_complete;\n                  deliverables = doc.deliverables;\n\n                  // handle all the deliverables, if there are any\n                  // TODO add a default deliverable! NOTHING HAPPENS WHEN there are no deliverables\n                  if (deliverables.length !== 0) {\n\n                    // This callback gets fired when all the deliverables have been created. It is passed into the process,output function\n                    var callback = function (err, data) {\n                      if (err) {\n                        // if any stylesheet was not procure send back some error to the client\n                        console.log(err);\n                        send_data = {\n                          id: tmp.id,\n                          error: interview.error(err).error.content,\n                          valid: false\n                        };  \n\n                        emitData(id, 'srv_error', send_data);   \n                      } else {\n                        // now we have the folder where all the stores deliverables \n                        connected_clients[id].data.deliverables = data.dir;\n                        // store the client info onto the master object\n                        connected_clients[id].data.client = data.client;\n\n                        // check to see if we want to allow the client to receive the deliverables via email\n                        // if this is true we send a question to the client asking for an email\n                        if (on_complete.email_deliverables_to_client) {\n\n                          // create the final question of the interview, asking for an email\n                          run = interview.final(qid, doc.data[qid], doc.data, connected_clients[id].data.master.vars, fields, tmp_progress, deliverables);\n\n                          // build the history \n                          progress = interview.progress(tmp_history); \n                          // update master vars list\n                          connected_clients[id].data.master.vars = run.master; \n                          connected_clients[id].data.progress = run.progress;\n\n                          // this is the data that gets sent back to the client. It involves the HTML of the question to \n                          // show the user, and debug info for the editor (if edit mode)\n                          send_data = {\n                            id: tmp.id,\n                            qid: run.qid,\n                            data: {\n                              question: run.question, \n                              progress: progress,\n                              debug: run.debug\n                            },\n                            valid: true\n                          };\n\n                          emitData(id, 'question', send_data);\n                        } else {\n                          // just handle the emails and output the done question\n                          // base_location - this is the server base so we can find out where to put the zip\n                          // on_complete - this is the settings for what to do at the end\n                          // the first null is the email of the client\n                          process.email(null, doc.name, base_location, connected_clients[id].data, on_complete, deliverables, data.client, app, function (err, response) {\n                            if (err) {\n                              // if there was any problems with emails, or zipping folders\n                              console.log(err);\n                              emit = 'srv_error';\n                              send_data = {\n                                id: null,\n                                error: interview.error(err).error.content,\n                                valid: false\n                              };  \n                              emitData(id, emit, send_data);   \n                            } else {\n                              // this will put together the final success question after everything is done\n                              run = interview.done();\n                              emit = 'question';\n                              send_data = {\n                                id: null,\n                                qid: null,\n                                data: {\n                                  question: run.question, \n                                  progress: run.progress,\n                                  debug: run.debug\n                                },\n                                valid: true\n                              };                                                  \n\n                              // create a new state record \n                              new_state.id = new_state_id;\n                              new_state.created = new Date();\n                              new_state.last_modified = new Date();\n                              new_state.data = connected_clients[id].data;\n\n                              new_state.save(function(err) {\n                                if (err) {\n                                  console.log(err);\n                                  throw err;\n                                } \n\n                                tmp_progress.push(new_state_id);\n\n                                // Update the interview data\n                                models.Tmps.update({id:tmp.id}, {current: new_state_id, progress: tmp_progress, history: run.progress, last_modified: new Date().getTime()}, function (err) {\n                                  if (err) {\n                                    console.log(err);\n                                    throw err;\n                                  } \n                                  // inform the client of whats happening...either the docs were produced or there was an error\n                                  emitData(id, emit, send_data);\n                                }); \n                              });\n                            }\n                          });\n                        }\n                      }\n                    };\n\n                    if (client.handshake.sessionID) {\n                      // check if the user is logged in\n                      sessionStore.get(client.handshake.sessionID, function (err, session) {\n                        if (err) {\n                          console.log(err);\n                          throw err;\n                        } \n\n                        if (session && session.user) {\n                          process.output(doc, connected_clients[id].data.master.vars, tmp_history, base_location, app, session.user.id, callback);\n                        }\n                      });\n                    } else {\n                      // An unregistered user is completing the interview\n                      process.output(doc, connected_clients[id].data.master.vars, tmp_history, base_location, app, null, callback);\n                    }\n                  } else {\n                    send_data = {\n                      id: null,\n                      error: interview.error(\"The interview does not have any deliverables.\").error.content,\n                      valid: false\n                    };  \n                    emitData(id, 'srv_error', send_data);\n                  }\n                }\n              });\n            });\n          });\n        });\n      });\n    });\n\n    // When the user clicks the send button at the very end, this is the very last button\n    client.on('send', function (data) { \n      var email = sanitizor.clean(data.email); \n      var base_location = app.get('base_location');\n      var path = connected_clients[id].data.deliverables;\n      var send_data;\n\n      // If no email is entered or the format is not an email send them back\n      if (validator.check(email, ['required','email']) ) {\n        //If the email is valid we can email the user the deliverables\n        models.Interviews.findOne({ id: data.interview }, function (err, doc) {\n          var emit, run;\n          var on_complete = doc.on_complete;\n          var deliverables = doc.deliverables;\n\n          if (err) {\n            console.log(err);\n            throw err;\n          } \n\n          if (!doc) {\n            emitData(id, 'srv_error', { id: null, error: interview.error(\"The interview could not be found.\").error.content, valid: false });\n            return;\n          }\n\n          // Send out all the emails and finish up\n          process.email(email, doc.name, base_location, connected_clients[id].data, on_complete, deliverables, connected_clients[id].data.client, app, function (err, response) {\n            if (err) {\n              // If there was any problems with emails, or zipping folders\n              console.log(err);\n              emit = 'srv_error';\n              send_data = {\n                id: null,\n                error: interview.error(err).error.content,\n                valid: false\n              };  \n            } else {\n              // This will put together the final success question after everything is done\n              run = interview.done();\n              emit = 'question';\n\n              send_data = {\n                id: null,\n                qid: null,\n                data: {\n                  question: run.question, \n                  progress: run.progress,\n                  debug: run.debug\n                },\n                valid: true\n              };                                                  \n            }\n            // Inform the client of whats happening. Either the docs were produced or there was an error.\n            emitData(id, emit, send_data);\n          });\n        });\n      } else {\n        send_data = {\n          id: null,\n          qid: null,\n          data: { \n            error: true, \n            message: 'The email is required and must be valid.', \n            name: 'q-final'\n          },\n          valid: false\n        };                 \n        emitData(id, 'question', send_data);            \n      }\n    });\n\n    // When a client disconnects from the viewer, or editor\n    client.on('disconnect', function () {\n      if (connected_clients[id]) {\n        delete connected_clients[id];\n        console.log('   debug - ' + 'client ' + client.id + 'is disconnected');\n        console.log('   debug - ' + 'total number of connected clients is ' + Object.keys(connected_clients).length);               \n      }\n    });\n  });\n\n  return io;\n};\n'LogicPull/LogicPull.js'\n:/*  Copyright 2015 Chris Zieba\n\n  This program is free software: you can redistribute it and/or modify it under the terms of the GNU\n  Affero General Public License as published by the Free Software Foundation, either version 3 of the\n  License, or (at your option) any later version.\n  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n  without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n  PURPOSE. See the GNU Affero General Public License for more details. You should have received a\n  copy of the GNU Affero General Public License along with this program. If not, see\n  <http://www.gnu.org/licenses/>.\n*/\n\nvar express = require('express'),\n  app = module.exports = express(),\n  MongoStore = require('connect-mongo')(express),\n  server = require('http').createServer(app),\n  fs = require('fs'),\n  socket = require('./lib/sockets'),\n  flash = require('./middleware/flash'),\n  version = require('./package.json').version,\n  config = require('./config');\n\n\n// Set the development variables\napp.configure('development', function () {\n  app.use(express.errorHandler({ dumpExceptions: true, showStack: true })); \n\n  // Add in all the config settings\n  for(var setting in config.development) {\n    app.set(setting, config.development[setting]);\n  }\n});\n\n// Set the production variables\napp.configure('production', function () {\n  app.use(express.errorHandler()); \n\n  for(var setting in config.production) {\n    app.set(setting, config.production[setting]);\n  }\n});\n\n// set up the sessions to use the mongo database\nvar sessionStore = new MongoStore({\n  url: 'mongodb://' + app.get('mongo_host') + ':' + app.get('mongo_port') + '/' + app.get('mongo_db'),\n  autoReconnect: true\n});\n\n// these settings are common to both environments\napp.configure(function () {\n  app.use(express.favicon(__dirname + '/public/favicon.ico'));\n  app.engine('.html', require('ejs').__express);\n  app.set('views', __dirname + '/views/site');\n  // Without this you would need to supply the extension to res.render()\n  app.set('view engine', 'ejs');\n  // used in CSS and JavaScript as query string\n  app.set('version', version);\n\n  app.use(express.cookieParser());\n  app.use(express.bodyParser());\n  app.use(express.methodOverride());\n  \n  // This attaches the session to the req object\n  app.use(express.session({\n    store: sessionStore,\n    secret: app.get('session_secret'),\n    cookie: {  \n      path: app.get('cookie_path'),  \n      httpOnly: app.get('cookie_http_only'),  \n      maxAge: app.get('cookie_max_age'),\n      secure: app.get('cookie_secure'),\n      domain: app.get('base_vhost')\n    }\n  }));\n  \n  app.use(express.csrf());\n\n  // Generate a token for the form...the form input must be created\n  app.use(function(req, res, next) {\n    res.locals.token = req.csrfToken();\n    next();\n  });\n\n\n  app.use(flash());\n  app.use(app.router);\n  app.use(express.vhost(app.get('base_vhost'), require('./subdomains/LogicPull')));\n\n});\n\n// run the server with websockets\nserver.listen(app.get('server_port'));\nsocket.listen(server, sessionStore, app);\n",
        "called_code_segment_file_1": "exports.output = function (doc, master, progress, base_location, app, user, socket_callback) { ... }",
        "invoking_code_segment_file_2": "client.on('finish', function (data) { ... process.output(doc, connected_clients[id].data.master.vars, tmp_history, base_location, app, session.user.id, callback); ... });",
        "called_code_segment_file_2": "client.on('finish', function (data) { ... process.email(null, doc.name, base_location, connected_clients[id].data, on_complete, deliverables, data.client, app, function (err, response) { ... }); ... });",
        "using_code_segment_file_3": "exports.email = function (email, interview_name, base, data, complete, deliverables, client, app, socket_callback) { ... }",
        "called_code_segment_file_3": "Not applicable",
        "using_code_segment_file_4": "Not applicable",
        "feature_description": "Add a feature to log the time taken to process each deliverable in the output function.",
        "detailed_feature_description": "Modify the output function in #file 1 to log the time taken to process each deliverable. Update the finish event handler in #file 2 to handle the modified output function. Ensure that the email function in #file 3 is updated to accommodate any changes in the output function. No changes are required in #file 4 as it does not interact with the modified segments.",
        "modified_complete_code": {
            "file_1": "exports.output = function (doc, master, progress, base_location, app, user, socket_callback) { ... #Modify var startTime = new Date(); ... callback(null, { ... timeTaken: new Date() - startTime }); ... }",
            "file_2": "client.on('finish', function (data) { ... process.output(doc, connected_clients[id].data.master.vars, tmp_history, base_location, app, session.user.id, function (err, data) { ... console.log('Time taken to process deliverables:', data.timeTaken); ... }); ... });",
            "file_3": "exports.email = function (email, interview_name, base, data, complete, deliverables, client, app, socket_callback) { ... if (data.timeTaken) { console.log('Time taken to process deliverables:', data.timeTaken); } ... }",
            "file_4": "Not applicable"
        }
    },
    {
        "repo": "puppeteer-page-proxy",
        "content": "'puppeteer-page-proxy/src/lib/cdp.js'\n:class CDP {\n    constructor(client) {\n        // Network domain: https://chromedevtools.github.io/devtools-protocol/1-3/Network/\n        this.Network = {\n            async getCookies(urls) {\n                return (await client.send(\"Network.getCookies\", urls)).cookies;\n            },\n            async setCookies(cookies) {\n                await client.send(\"Network.setCookies\", cookies);\n            },\n            async deleteCookies(cookies) {\n                await client.send(\"Network.deleteCookies\", cookies);\n            }\n        }\n    }\n}\n\nmodule.exports = CDP;\n'puppeteer-page-proxy/src/lib/cookies.js'\n:const {CookieJar} = require(\"tough-cookie\");\nconst CDP = require(\"./cdp\");\n\n// Parse single raw cookie string to a cookie object for the browser\nconst parseCookie = (rawCookie, domain) => {\n    const cookie = {name: \"\", value: \"\", domain, path: \"/\", secure: false, httpOnly: false, sameSite: \"Lax\", expires: undefined};\n    const pairs = rawCookie.split(/; */);\n    for (let i = 0; i < pairs.length; i++) {\n        // Split to key value pair e.g. key=value\n        const pair = pairs[i].split(/=(.*)/, 2);\n        // Trim and assign key and value\n        let key = pair[0].trim();\n        let value = pair[1] ? pair[1].trim() : \"\";\n        // Remove surrounding quotes from value if exists\n        value = value.replace(/^\"(.*)\"$/, \"$1\");\n        switch (key.toLowerCase()) {\n            case \"domain\": cookie.domain = value; break;\n            case \"path\": cookie.path = value; break;\n            case \"secure\": cookie.secure = true; break;\n            case \"httponly\": cookie.httpOnly = true; break;\n            case \"samesite\":\n                const firstChar = value[0].toUpperCase();\n                const restChars = value.slice(1).toLowerCase();\n                cookie.sameSite = firstChar + restChars;\n                break;\n            case \"max-age\":\n                // Current time and 'max-age' in seconds\n                const currentTime = new Date().getTime() / 1000;\n                const maxAge = parseInt(value);\n                cookie.expires = Math.round(currentTime + maxAge);\n                break;\n            case \"expires\":\n                // If cookie expires hasn't already been set by 'max-age'\n                if (!cookie.expires) {\n                    const time = new Date(value).getTime();\n                    cookie.expires = Math.round(time / 1000);\n                }\n                break;\n            default: if (i < 1) {cookie.name = key; cookie.value = value}\n        }\n    }\n    return cookie;\n}\n\n// Format single browser cookie object to tough-cookie object\nconst formatCookie = (cookie) => {\n    const currentDate = new Date().toISOString();\n    return {\n        key: cookie.name,\n        value: cookie.value,\n        expires: (cookie.expires === -1) ? \"Infinity\" : new Date(cookie.expires * 1000).toISOString(),\n        domain: cookie.domain.replace(/^\\./, \"\"),\n        path: cookie.path,\n        secure: cookie.secure,\n        httpOnly: cookie.httpOnly,\n        sameSite: cookie.sameSite,\n        hostOnly: !cookie.domain.startsWith(\".\"),\n        creation: currentDate,\n        lastAccessed: currentDate\n    };\n};\n\n// Responsible for getting and setting browser cookies\nclass CookieHandler extends CDP {\n    constructor(request) {\n        super(request._client || request.client);\n        this.url =\n            (request.isNavigationRequest() || request.frame() == null)\n            ? request.url()\n            : request.frame().url();\n        this.domain = (this.url) ? new URL(this.url).hostname : \"\";\n    }\n    // Parse an array of raw cookies to an array of cookie objects\n    parseCookies(rawCookies) {\n        return rawCookies.map((rawCookie) => {\n            return parseCookie(rawCookie, this.domain);\n        });\n    };\n    // Format browser cookies to tough-cookies\n    formatCookies(cookies) {\n        return cookies.map((cookie) => {\n            return formatCookie(cookie);\n        });\n    };\n    // Get browser cookies of current page/url\n    async getCookies() {\n        const browserCookies = await this.Network.getCookies({urls: [this.url]});\n        const toughCookies = this.formatCookies(browserCookies);\n        // Add cookies to cookieJar\n        const cookieJar = CookieJar.deserializeSync({\n                version: 'tough-cookie@4.1.2',\n                storeType: 'MemoryCookieStore',\n                rejectPublicSuffixes: true,\n                cookies: toughCookies\n        });\n        return cookieJar;\n    }\n    // Set cookies to browser from \"set-cookie\" header\n    async setCookies(rawCookies) {\n        const browserCookies = this.parseCookies(rawCookies);\n        // Delete old cookies before setting new ones\n        for (let i = 0; i < browserCookies.length; i++) {\n            const cookie = browserCookies[i];\n            const badCookie = {\n                name: cookie.name,\n                url: this.url,\n                domain: cookie.domain,\n                path: cookie.path\n            };\n            await this.Network.deleteCookies(badCookie);\n        }\n        // Store cookies in the browser\n        await this.Network.setCookies({cookies: browserCookies});\n    }\n}\n\nmodule.exports = CookieHandler;\n'puppeteer-page-proxy/src/core/proxy.js'\n:const got = require(\"got\");\nconst CookieHandler = require(\"../lib/cookies\");\nconst {setHeaders, setAgent} = require(\"../lib/options\");\nconst type = require(\"../util/types\");\n\n// Responsible for applying proxy\nconst requestHandler = async (request, proxy, overrides = {}) => {\n    // Reject non http(s) URI schemes\n    if (!request.url().startsWith(\"http\") && !request.url().startsWith(\"https\")) {\n        request.continue(); return;\n    }\n    const cookieHandler = new CookieHandler(request);\n    // Request options for GOT accounting for overrides\n    const options = {\n        cookieJar: await cookieHandler.getCookies(),\n        method: overrides.method || request.method(),\n        body: overrides.postData || request.postData(),\n        headers: overrides.headers || setHeaders(request),\n        agent: setAgent(proxy),\n        responseType: \"buffer\",\n        maxRedirects: 15,\n        throwHttpErrors: false,\n        ignoreInvalidCookies: true,\n        followRedirect: false\n    };\n    try {\n        const response = await got(overrides.url || request.url(), options);\n        // Set cookies manually because \"set-cookie\" doesn't set all cookies (?)\n        // Perhaps related to https://github.com/puppeteer/puppeteer/issues/5364\n        const setCookieHeader = response.headers[\"set-cookie\"];\n        if (setCookieHeader) {\n            await cookieHandler.setCookies(setCookieHeader);\n            response.headers[\"set-cookie\"] = undefined;\n        }\n        await request.respond({\n            status: response.statusCode,\n            headers: response.headers,\n            body: response.body\n        });\n    } catch (error) {\n        await request.abort();\n    }\n};\n\n// For reassigning proxy of page\nconst removeRequestListener = (page, listenerName) => {\n    const eventName = \"request\";\n    const listeners = page.eventsMap.get(eventName);\n    if (listeners) {\n        const i = listeners.findIndex((listener) => {\n            return listener.name === listenerName\n        });\n        listeners.splice(i, 1);\n        if (!listeners.length) {\n            page.eventsMap.delete(eventName);\n        }\n    }\n};\n\nconst useProxyPer = {\n    // Call this if request object passed\n    HTTPRequest: async (request, data) => {\n        let proxy, overrides;\n        // Separate proxy and overrides\n        if (type(data) === \"object\") {\n            if (Object.keys(data).length !== 0) {\n                proxy = data.proxy;\n                delete data.proxy;\n                overrides = data;\n            }\n        } else {proxy = data}\n        // Skip request if proxy omitted\n        if (proxy) {await requestHandler(request, proxy, overrides)}\n        else {request.continue(overrides)}\n    },\n\n    // Call this if page object passed\n    CDPPage: async (page, proxy) => {\n        await page.setRequestInterception(true);\n        const listener = \"$ppp_requestListener\";\n        removeRequestListener(page, listener);\n        const f = {[listener]: async (request) => {\n            await requestHandler(request, proxy);\n        }};\n        if (proxy) {page.on(\"request\", f[listener])}\n        else {await page.setRequestInterception(false)}\n    }\n}\n\n// Main function\nconst useProxy = async (target, data) => {\n    useProxyPer[target.constructor.name](target, data);\n};\n\nmodule.exports = useProxy;\n'puppeteer-page-proxy/src/index.js'\n:module.exports = require(\"./core/proxy\");\nmodule.exports.lookup = require(\"./core/lookup\");\n",
        "called_code_segment_file_1": "const parseCookie = (rawCookie, domain) => {\n    const cookie = {name: \"\", value: \"\", domain, path: \"/\", secure: false, httpOnly: false, sameSite: \"Lax\", expires: undefined};\n    const pairs = rawCookie.split(/; */);\n    for (let i = 0; i < pairs.length; i++) {\n        // Split to key value pair e.g. key=value\n        const pair = pairs[i].split(/=(.*)/, 2);\n        // Trim and assign key and value\n        let key = pair[0].trim();\n        let value = pair[1] ? pair[1].trim() : \"\";\n        // Remove surrounding quotes from value if exists\n        value = value.replace(/^\"(.*)\"$/, \"$1\");\n        switch (key.toLowerCase()) {\n            case \"domain\": cookie.domain = value; break;\n            case \"path\": cookie.path = value; break;\n            case \"secure\": cookie.secure = true; break;\n            case \"httponly\": cookie.httpOnly = true; break;\n            case \"samesite\":\n                const firstChar = value[0].toUpperCase();\n                const restChars = value.slice(1).toLowerCase();\n                cookie.sameSite = firstChar + restChars;\n                break;\n            case \"max-age\":\n                // Current time and 'max-age' in seconds\n                const currentTime = new Date().getTime() / 1000;\n                const maxAge = parseInt(value);\n                cookie.expires = Math.round(currentTime + maxAge);\n                break;\n            case \"expires\":\n                // If cookie expires hasn't already been set by 'max-age'\n                if (!cookie.expires) {\n                    const time = new Date(value).getTime();\n                    cookie.expires = Math.round(time / 1000);\n                }\n                break;\n            default: if (i < 1) {cookie.name = key; cookie.value = value}\n        }\n    }\n    return cookie;\n}",
        "invoking_code_segment_file_2": "const browserCookies = this.parseCookies(rawCookies);",
        "called_code_segment_file_2": "async setCookies(rawCookies) {\n    const browserCookies = this.parseCookies(rawCookies);\n    // Delete old cookies before setting new ones\n    for (let i = 0; i < browserCookies.length; i++) {\n        const cookie = browserCookies[i];\n        const badCookie = {\n            name: cookie.name,\n            url: this.url,\n            domain: cookie.domain,\n            path: cookie.path\n        };\n        await this.Network.deleteCookies(badCookie);\n    }\n    // Store cookies in the browser\n    await this.Network.setCookies({cookies: browserCookies});\n}",
        "using_code_segment_file_3": "const cookieHandler = new CookieHandler(request);\n// Request options for GOT accounting for overrides\nconst options = {\n    cookieJar: await cookieHandler.getCookies(),\n    method: overrides.method || request.method(),\n    body: overrides.postData || request.postData(),\n    headers: overrides.headers || setHeaders(request),\n    agent: setAgent(proxy),\n    responseType: \"buffer\",\n    maxRedirects: 15,\n    throwHttpErrors: false,\n    ignoreInvalidCookies: true,\n    followRedirect: false\n};",
        "called_code_segment_file_3": "await requestHandler(request, proxy, overrides);",
        "using_code_segment_file_4": "const useProxy = async (target, data) => {\n    useProxyPer[target.constructor.name](target, data);\n};",
        "feature_description": "Add support for parsing cookies with additional attributes such as 'priority' and 'partitionKey'.",
        "detailed_feature_description": "The new feature modifies the `parseCookie` function in #file 1 to include parsing for 'priority' and 'partitionKey' attributes. This change is propagated to #file 2, where the `parseCookies` method uses the updated `parseCookie`. #file 3, which uses `CookieHandler`, will also be updated to handle the new attributes. #file 4, which invokes the `useProxy` function, remains unchanged as it does not directly interact with the cookie parsing logic.",
        "modified_complete_code": {
            "file_1": "const parseCookie = (rawCookie, domain) => {\n    const cookie = {name: \"\", value: \"\", domain, path: \"/\", secure: false, httpOnly: false, sameSite: \"Lax\", expires: undefined, priority: \"Medium\", partitionKey: null};\n    const pairs = rawCookie.split(/; */);\n    for (let i = 0; i < pairs.length; i++) {\n        // Split to key value pair e.g. key=value\n        const pair = pairs[i].split(/=(.*)/, 2);\n        // Trim and assign key and value\n        let key = pair[0].trim();\n        let value = pair[1] ? pair[1].trim() : \"\";\n        // Remove surrounding quotes from value if exists\n        value = value.replace(/^\"(.*)\"$/, \"$1\");\n        switch (key.toLowerCase()) {\n            case \"domain\": cookie.domain = value; break;\n            case \"path\": cookie.path = value; break;\n            case \"secure\": cookie.secure = true; break;\n            case \"httponly\": cookie.httpOnly = true; break;\n            case \"samesite\":\n                const firstChar = value[0].toUpperCase();\n                const restChars = value.slice(1).toLowerCase();\n                cookie.sameSite = firstChar + restChars;\n                break;\n            case \"max-age\":\n                // Current time and 'max-age' in seconds\n                const currentTime = new Date().getTime() / 1000;\n                const maxAge = parseInt(value);\n                cookie.expires = Math.round(currentTime + maxAge);\n                break;\n            case \"expires\":\n                // If cookie expires hasn't already been set by 'max-age'\n                if (!cookie.expires) {\n                    const time = new Date(value).getTime();\n                    cookie.expires = Math.round(time / 1000);\n                }\n                break;\n            case \"priority\": cookie.priority = value; break;\n            case \"partitionkey\": cookie.partitionKey = value; break;\n            default: if (i < 1) {cookie.name = key; cookie.value = value}\n        }\n    }\n    return cookie;\n} #Modify",
            "file_2": "async setCookies(rawCookies) {\n    const browserCookies = this.parseCookies(rawCookies);\n    // Delete old cookies before setting new ones\n    for (let i = 0; i < browserCookies.length; i++) {\n        const cookie = browserCookies[i];\n        const badCookie = {\n            name: cookie.name,\n            url: this.url,\n            domain: cookie.domain,\n            path: cookie.path\n        };\n        await this.Network.deleteCookies(badCookie);\n    }\n    // Store cookies in the browser\n    await this.Network.setCookies({cookies: browserCookies});\n} #Modify",
            "file_3": "const cookieHandler = new CookieHandler(request);\n// Request options for GOT accounting for overrides\nconst options = {\n    cookieJar: await cookieHandler.getCookies(),\n    method: overrides.method || request.method(),\n    body: overrides.postData || request.postData(),\n    headers: overrides.headers || setHeaders(request),\n    agent: setAgent(proxy),\n    responseType: \"buffer\",\n    maxRedirects: 15,\n    throwHttpErrors: false,\n    ignoreInvalidCookies: true,\n    followRedirect: false\n}; #Modify",
            "file_4": "const useProxy = async (target, data) => {\n    useProxyPer[target.constructor.name](target, data);\n};"
        }
    },
    {
        "repo": "ruui",
        "content": "'ruui/src/components/loadingMask.js'\n:import React, { Component } from 'react';\nimport { ActivityIndicator, View, TouchableOpacity, StyleSheet } from 'react-native';\nimport * as appActions from '../utils/store/appAction';\n\ntype Props = {\n\tconfigs?: Object,\n\tdispatch?: Function,\n};\n\nclass RuuiLoadingModal extends Component<any, Props, any> {\n\tprops: Props;\n\n\trender() {\n\t\tconst { configs = {} } = this.props,\n\t\t\tindicatorColor = configs.indicatorColor || '#ffffff',\n\t\t\tindicatorSize = configs.indicatorSize || 'small';\n\n\t\treturn <View style={styles.container}>\n\t\t\t<TouchableOpacity onPress={this.onMaskPress}>\n\t\t\t\t<ActivityIndicator color={indicatorColor} size={indicatorSize}/>\n\t\t\t</TouchableOpacity>\n\t\t</View>;\n\t}\n\n\tonMaskPress = () => {\n\t\tconst { dispatch, configs } = this.props;\n\n\t\tif (configs.tapToClose) {\n\t\t\tdispatch(appActions.toggleLoading(false));\n\t\t}\n\t}\n}\n\nexport default RuuiLoadingModal;\n\nconst styles = StyleSheet.create({\n\tcontainer: {\n\t\tposition: 'absolute',\n\t\ttop: 0, right: 0, left: 0, bottom: 0,\n\t\talignItems: 'center', justifyContent: 'center',\n\t},\n});\n\n'ruui/src/components/modal.js'\n:import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Animated, Easing, View, StyleSheet } from 'react-native';\n\nimport Selector from './selector';\nimport LoadingMask from './loadingMask';\nimport CloseableModal from './closeableModal';\nimport { valueAt } from '../utils';\nimport * as appActions from '../utils/store/appAction';\n\ntype Props = {\n\tactive?: any,\n\ttype?: string,\n\tconfigs?: Object,\n\tmodalCount?: number,\n\tdispatch?: Function,\n\tanimationDelay?: Number,\n};\n\nexport default class RuuiModal extends Component {\n\tstatic props: Props;\n\n\tstatic contextTypes = {\n\t\truuiConfigs: PropTypes.object,\n\t};\n\n\tconstructor(props) {\n\t\tsuper(props);\n\t\tthis.state = {\n\t\t\tactive: props.active,\n\t\t};\n\t\tthis.enterAnimation = new Animated.Value(0);\n\t}\n\n\tcomponentDidMount() {\n\t\tconst { active, animationDelay, } = this.props;\n\t\tsetTimeout(() => this.playTransition(active), animationDelay);\n\t}\n\n\tcomponentDidUpdate(prevProps) {\n\t\tconst { active } = this.props;\n\t\tif (prevProps.active !== active) {\n\t\t\tthis.playTransition(active);\n\t\t}\n\t}\n\n\tplayTransition(active) {\n\t\tconst { configs = {}, } = this.props;\n\t\tconst nextValue = active ? 1 : 0;\n\n\t\tif (!active) {\n\t\t\tif (configs.instantClose) {\n\t\t\t\tthis.setState({ active: null });\n\t\t\t\tif (configs.onClose) configs.onClose();\n\t\t\t} else {\n\t\t\t\tthis.playAnimation(nextValue, () => {\n\t\t\t\t\tthis.setState({ active: null });\n\t\t\t\t\tif (configs.onClose) configs.onClose();\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.setState({ active });\n\t\t\tthis.playAnimation(nextValue);\n\t\t}\n\t}\n\n\trender() {\n\t\tconst { configs = {}, modalCount, type: modalType } = this.props,\n\t\t\t{ active } = this.state,\n\t\t\tglobalConfigs = valueAt(this, 'context.ruuiConfigs.modal'),\n\t\t\tcontainerPropsGenerator = configs.maskProps || globalConfigs.maskProps,\n\t\t\tcontainerProps = containerPropsGenerator(this.enterAnimation, configs, modalCount, modalType);\n\n\t\tif (configs.maskProps && !containerProps.style) {\n\t\t\tcontainerProps.style = globalConfigs.maskProps(\n\t\t\t\tthis.enterAnimation, configs, modalCount, modalType\n\t\t\t).style;\n\t\t}\n\n\t\treturn active ? <Animated.View {...containerProps}>\n\t\t\t<View style={styles.innerTouchable}>\n\t\t\t\t{this.renderModalInner()}\n\t\t\t</View>\n\t\t</Animated.View> : <View/>;\n\t}\n\n\trenderModalInner() {\n\t\tconst { dispatch, type: modalType, active, configs: modalConfigs } = this.props;\n\n\t\tswitch (modalType) {\n\t\tcase 'select':\n\t\t\treturn <Selector\n\t\t\t\tonRequestClose={configs => dispatch(appActions.toggleSelector(false, configs))}\n\t\t\t\tanimation={this.enterAnimation}\n\t\t\t\tactive={active}\n\t\t\t\tconfigs={modalConfigs}/>;\n\t\tcase 'modal':\n\t\t\treturn <CloseableModal\n\t\t\t\tonRequestClose={configs => dispatch(appActions.toggleModal(false, configs))}\n\t\t\t\tanimation={this.enterAnimation}\n\t\t\t\tactive={active}\n\t\t\t\tconfigs={modalConfigs}/>;\n\t\tcase 'loading':\n\t\t\treturn <LoadingMask\n\t\t\t\tanimation={this.enterAnimation}\n\t\t\t\tactive={active}\n\t\t\t\tconfigs={modalConfigs}/>;\n\t\tdefault:\n\t\t\treturn <View/>;\n\t\t}\n\t}\n\n\tplayAnimation = (toValue: Number, callback) => {\n\t\tif (this.animation) this.animation.clear();\n\n\t\tconst easing = toValue === 0\n\t\t\t\t? Easing.out(Easing.bezier(0, 0, 0.58, 1))\n\t\t\t\t: Easing.in(Easing.bezier(0, 0.48, 0.35, 1)),\n\t\t\tanimations = [\n\t\t\t\tAnimated.timing(this.enterAnimation, {\n\t\t\t\t\ttoValue,\n\t\t\t\t\tduration: 500,\n\t\t\t\t\teasing,\n\t\t\t\t\tuseNativeDriver: false,\n\t\t\t\t}),\n\t\t\t];\n\n\t\tthis.animation = Animated.parallel(animations).start(callback);\n\t}\n}\n\nexport function defaultMaskPropsGenerator(animation, configs, modalCount, modalType) {\n\tconst averageOpacity = (0.8 / modalCount) + (modalCount * 0.1),\n\t\tbackgroundColor = animation.interpolate({\n\t\t\tinputRange: [0, 1], outputRange: ['rgba(0, 0, 0, 0)', `rgba(0, 0, 0, ${averageOpacity})`],\n\t\t}),\n\t\tstyle = [styles.container, {\n\t\t\tzIndex: configs.zIndex,\n\t\t\tbackgroundColor,\n\t\t}];\n\n\treturn { style, };\n}\n\nconst styles = StyleSheet.create({\n\tcontainer: {\n\t\tposition: 'absolute',\n\t\ttop: 0, left: 0, right: 0, bottom: 0,\n\t},\n\tinnerTouchable: {\n\t\tflex: 1,\n\t},\n\ttouchableMask: {\n\t\tposition: 'absolute',\n\t\ttop: 0, right: 0, left: 0, bottom: 0,\n\t},\n});\n\n'ruui/src/configs/core/modal.js'\n:import { defaultMaskPropsGenerator } from '../../components/modal';\nimport { defaultContainerPropsGenerator } from '../../components/closeableModal';\n\nexport default {\n\tmaskProps: defaultMaskPropsGenerator,\n\tcontainerProps: defaultContainerPropsGenerator,\n};\n'ruui/src/configs/core/index.js'\n:import button from './button';\nimport modal from './modal';\n\nexport default {\n\tbutton,\n\tmodal,\n};\n",
        "called_code_segment_file_1": "playTransition(active) {\n  const { configs = {}, } = this.props;\n  const nextValue = active ? 1 : 0;\n\n  if (!active) {\n    if (configs.instantClose) {\n      this.setState({ active: null });\n      if (configs.onClose) configs.onClose();\n    } else {\n      this.playAnimation(nextValue, () => {\n        this.setState({ active: null });\n        if (configs.onClose) configs.onClose();\n      });\n    }\n  } else {\n    this.setState({ active });\n    this.playAnimation(nextValue);\n  }\n}",
        "invoking_code_segment_file_2": "componentDidUpdate(prevProps) {\n  const { active } = this.props;\n  if (prevProps.active !== active) {\n    this.playTransition(active);\n  }\n}",
        "called_code_segment_file_2": "playAnimation = (toValue: Number, callback) => {\n  if (this.animation) this.animation.clear();\n\n  const easing = toValue === 0\n      ? Easing.out(Easing.bezier(0, 0, 0.58, 1))\n      : Easing.in(Easing.bezier(0, 0.48, 0.35, 1)),\n    animations = [\n      Animated.timing(this.enterAnimation, {\n        toValue,\n        duration: 500,\n        easing,\n        useNativeDriver: false,\n      }),\n    ];\n\n  this.animation = Animated.parallel(animations).start(callback);\n}",
        "using_code_segment_file_3": "renderModalInner() {\n  const { dispatch, type: modalType, active, configs: modalConfigs } = this.props;\n\n  switch (modalType) {\n  case 'select':\n    return <Selector\n      onRequestClose={configs => dispatch(appActions.toggleSelector(false, configs))}\n      animation={this.enterAnimation}\n      active={active}\n      configs={modalConfigs}/>;\n  case 'modal':\n    return <CloseableModal\n      onRequestClose={configs => dispatch(appActions.toggleModal(false, configs))}\n      animation={this.enterAnimation}\n      active={active}\n      configs={modalConfigs}/>;\n  case 'loading':\n    return <LoadingMask\n      animation={this.enterAnimation}\n      active={active}\n      configs={modalConfigs}/>;\n  default:\n    return <View/>;\n  }\n}",
        "called_code_segment_file_3": "onRequestClose={configs => dispatch(appActions.toggleModal(false, configs))}",
        "using_code_segment_file_4": "dispatch(appActions.toggleModal(false, configs))",
        "feature_description": "Add a new feature to allow custom animations for modal transitions.",
        "detailed_feature_description": "The new feature allows developers to pass a custom animation function in the modal configs. This function will be used instead of the default animation in the modal transition. The `playTransition` method in #file 1 will be updated to check for a custom animation function in the configs and use it if provided. The `playAnimation` method in #file 2 will be updated to handle the custom animation. The `renderModalInner` method in #file 3 will ensure that the custom animation is passed correctly to the modal components. The `dispatch` method in #file 4 will remain unchanged as it interacts with the modal actions directly.",
        "modified_complete_code": {
            "file_1": "playTransition(active) {\n  const { configs = {}, } = this.props;\n  const nextValue = active ? 1 : 0;\n\n  if (!active) {\n    if (configs.instantClose) {\n      this.setState({ active: null });\n      if (configs.onClose) configs.onClose();\n    } else {\n      this.playAnimation(nextValue, () => {\n        this.setState({ active: null });\n        if (configs.onClose) configs.onClose();\n      });\n    }\n  } else {\n    this.setState({ active });\n    if (configs.customAnimation) {\n      configs.customAnimation(this.enterAnimation, nextValue);\n    } else {\n      this.playAnimation(nextValue);\n    }\n  }\n}",
            "file_2": "componentDidUpdate(prevProps) {\n  const { active } = this.props;\n  if (prevProps.active !== active) {\n    this.playTransition(active);\n  }\n}\n\n#Modify\nplayAnimation = (toValue: Number, callback) => {\n  if (this.animation) this.animation.clear();\n\n  const easing = toValue === 0\n      ? Easing.out(Easing.bezier(0, 0, 0.58, 1))\n      : Easing.in(Easing.bezier(0, 0.48, 0.35, 1)),\n    animations = [\n      Animated.timing(this.enterAnimation, {\n        toValue,\n        duration: 500,\n        easing,\n        useNativeDriver: false,\n      }),\n    ];\n\n  this.animation = Animated.parallel(animations).start(callback);\n}",
            "file_3": "renderModalInner() {\n  const { dispatch, type: modalType, active, configs: modalConfigs } = this.props;\n\n  switch (modalType) {\n  case 'select':\n    return <Selector\n      onRequestClose={configs => dispatch(appActions.toggleSelector(false, configs))}\n      animation={this.enterAnimation}\n      active={active}\n      configs={modalConfigs}/>;\n  case 'modal':\n    return <CloseableModal\n      onRequestClose={configs => dispatch(appActions.toggleModal(false, configs))}\n      animation={this.enterAnimation}\n      active={active}\n      configs={modalConfigs}/>;\n  case 'loading':\n    return <LoadingMask\n      animation={this.enterAnimation}\n      active={active}\n      configs={modalConfigs}/>;\n  default:\n    return <View/>;\n  }\n}",
            "file_4": "dispatch(appActions.toggleModal(false, configs))"
        }
    },
    {
        "repo": "neode",
        "content": "'neode/src/Services/First.js'\n:import Builder, {mode} from '../Query/Builder';\nimport { eagerNode, } from '../Query/EagerUtils';\n\nexport default function First(neode, model, key, value) {\n    const alias = 'this';\n\n    const builder = new Builder(neode);\n\n    // Match\n    builder.match(alias, model);\n\n    // Where\n    if (typeof key == 'object') {\n        // Process a map of properties\n        Object.keys(key).forEach(property => {\n            builder.where(`${alias}.${property}`, key[ property ]);\n        });\n    }\n    else {\n        // Straight key/value lookup\n        builder.where(`${alias}.${key}`, value);\n    }\n\n    const output = eagerNode(neode, 1, alias, model);\n\n    return builder.return(output)\n        .limit(1)\n        .execute(mode.READ)\n        .then(res => neode.hydrateFirst(res, alias, model));\n}\n'neode/src/Queryable.js'\n:import Builder from './Query/Builder';\nimport Create from './Services/Create';\nimport DeleteAll from './Services/DeleteAll';\nimport FindAll from './Services/FindAll';\nimport FindById from './Services/FindById';\nimport FindWithinDistance from './Services/FindWithinDistance';\nimport First from './Services/First';\nimport MergeOn from './Services/MergeOn';\n\nexport default class Queryable {\n\n    /**\n     * @constructor\n     *\n     * @param Neode neode\n     */\n    constructor(neode) {\n        this._neode = neode;\n    }\n\n    /**\n     * Return a new Query Builder\n     *\n     * @return {Builder}\n     */\n    query() {\n        return new Builder(this._neode);\n    }\n\n    /**\n     * Create a new instance of this Model\n     *\n     * @param  {object} properties\n     * @return {Promise}\n     */\n    create(properties) {\n        return Create(this._neode, this, properties);\n    }\n\n    /**\n     * Merge a node based on the defined indexes\n     *\n     * @param  {Object} properties\n     * @return {Promise}\n     */\n    merge(properties) {\n        const merge_on = this.mergeFields();\n\n        return MergeOn(this._neode, this, merge_on, properties);\n    }\n\n    /**\n     * Merge a node based on the supplied properties\n     *\n     * @param  {Object} match Specific properties to merge on\n     * @param  {Object} set   Properties to set\n     * @return {Promise}\n     */\n    mergeOn(match, set) {\n        const merge_on = Object.keys(match);\n        const properties = Object.assign({}, match, set);\n\n        return MergeOn(this._neode, this, merge_on, properties);\n    }\n\n    /**\n     * Delete all nodes for this model\n     *\n     * @return {Promise}\n     */\n    deleteAll() {\n        return DeleteAll(this._neode, this);\n    }\n\n    /**\n     * Get a collection of nodes for this label\n     *\n     * @param  {Object}              properties\n     * @param  {String|Array|Object} order\n     * @param  {Int}                 limit\n     * @param  {Int}                 skip\n     * @return {Promise}\n     */\n    all(properties, order, limit, skip) {\n        return FindAll(this._neode, this, properties, order, limit, skip);\n    }\n\n    /**\n     * Find a Node by its Primary Key\n     *\n     * @param  {mixed} id\n     * @return {Promise}\n     */\n    find(id) {\n        const primary_key = this.primaryKey();\n\n        return this.first(primary_key, id);\n    }\n\n    /**\n     * Find a Node by it's internal node ID\n     *\n     * @param  {String} model\n     * @param  {int}    id\n     * @return {Promise}\n     */\n    findById(id) {\n        return FindById(this._neode, this, id);\n    }\n\n    /**\n     * Find a Node by properties\n     *\n     * @param  {String} label\n     * @param  {mixed}  key     Either a string for the property name or an object of values\n     * @param  {mixed}  value   Value\n     * @return {Promise}\n     */\n    first(key, value) {\n        return First(this._neode, this, key, value);\n    }\n\n    /**\n     * Get a collection of nodes within a certain distance belonging to this label\n     *\n     * @param  {Object}              properties\n     * @param  {String}              location_property\n     * @param  {Object}              point\n     * @param  {Int}                 distance\n     * @param  {String|Array|Object} order\n     * @param  {Int}                 limit\n     * @param  {Int}                 skip\n     * @return {Promise}\n     */\n    withinDistance(location_property, point, distance, properties, order, limit, skip) {\n        return FindWithinDistance(this._neode, this, location_property, point, distance, properties, order, limit, skip);\n    }\n\n}\n'neode/src/Model.js'\n:import Queryable from './Queryable';\n\nimport RelationshipType, {DIRECTION_BOTH} from './RelationshipType';\nimport Property from './Property';\n\nconst RELATIONSHIP_TYPES = [ 'relationship', 'relationships', 'node', 'nodes' ];\n\nexport default class Model extends Queryable {\n    constructor(neode, name, schema) {\n        super(neode);\n\n        this._name = name;\n        this._schema = schema;\n\n        this._properties = new Map;\n        this._relationships = new Map;\n        this._labels = [ name ];\n\n        // Default Primary Key to {label}_id\n        this._primary_key = name.toLowerCase() + '_id';\n\n        this._unique = [];\n        this._indexed = [];\n        this._hidden = [];\n        this._readonly = [];\n\n        // TODO: Clean this up\n        for (let key in schema) {\n            const value = schema[ key ];\n\n            switch ( key ) {\n                case 'labels':\n                    this.setLabels(...value);\n                    break;\n\n                default:\n                    if ( value.type &&  RELATIONSHIP_TYPES.indexOf(value.type) > -1 ) {\n                        const { relationship, direction, target, properties, eager, cascade, alias } = value;\n\n                        this.relationship(key, value.type, relationship, direction, target, properties, eager, cascade, alias);\n                    }\n                    else {\n                        this.addProperty(key, value);\n                    }\n                    break;\n            }\n        }\n    }\n\n    /**\n     * Get Model name\n     *\n     * @return {String}\n     */\n    name() {\n        return this._name;\n    }\n\n    /**\n     * Get Schema\n     *\n     * @return {Object}\n     */\n    schema() {\n        return this._schema;\n    }\n\n    /**\n     * Get a map of Properties\n     *\n     * @return {Map}\n     */\n    properties() {\n        return this._properties;\n    }\n\n    /**\n     * Set Labels\n     *\n     * @param  {...String} labels\n     * @return {Model}\n     */\n    setLabels(...labels) {\n        this._labels = labels.sort();\n\n        return this;\n    }\n\n    /**\n     * Get Labels\n     *\n     * @return {Array}\n     */\n    labels() {\n        return this._labels;\n    }\n\n    /**\n     * Add a property definition\n     *\n     * @param {String} key    Property name\n     * @param {Object} schema Schema object\n     * @return {Model}\n     */\n    addProperty(key, schema) {\n        const property = new Property(key, schema);\n\n        this._properties.set(key, property);\n\n        // Is this key the primary key?\n        if ( property.primary() ) {\n            this._primary_key = key;\n        }\n\n        // Is this property unique?\n        if ( property.unique() || property.primary() ) {\n            this._unique.push(key);\n        }\n\n        // Is this property indexed?\n        if ( property.indexed() ) {\n            this._indexed.push(key);\n        }\n\n        // Should this property be hidden during JSON conversion?\n        if ( property.hidden() ) {\n            this._hidden.push(key);\n        }\n\n        // Is this property only to be read and never written to DB (e.g. auto-generated UUIDs)?\n        if ( property.readonly() ) {\n            this._readonly.push(key);\n        }\n\n        return this;\n    }\n\n    /**\n     * Add a new relationship\n     *\n     * @param  {String} name                The name given to the relationship\n     * @param  {String} type                Type of Relationship\n     * @param  {String} direction           Direction of Node (Use constants DIRECTION_IN, DIRECTION_OUT, DIRECTION_BOTH)\n     * @param  {String|Model|null} target   Target type definition for the\n     * @param  {Object} schema              Property Schema\n     * @param  {Bool} eager                 Should this relationship be eager loaded?\n     * @param  {Bool|String} cascade        Cascade delete policy for this relationship\n     * @param  {String} node_alias          Alias to give to the node in the pattern comprehension\n     * @return {Relationship}\n     */\n    relationship(name, type, relationship, direction = DIRECTION_BOTH, target, schema = {}, eager = false, cascade = false, node_alias = 'node') {\n        if (relationship && direction && schema) {\n            this._relationships.set(name, new RelationshipType(name, type, relationship, direction, target, schema, eager, cascade, node_alias));\n        }\n\n        return this._relationships.get(name);\n    }\n\n    /**\n     * Get all defined Relationships  for this Model\n     *\n     * @return {Map}\n     */\n    relationships() {\n        return this._relationships;\n    }\n\n    /**\n     * Get relationships defined as Eager relationships\n     *\n     * @return {Array}\n     */\n    eager() {\n        return Array.from(this._relationships).map(([key, value]) => { // eslint-disable-line  no-unused-vars\n            return value._eager ? value : null;\n        }).filter(a => !!a);\n    }\n\n    /**\n     * Get the name of the primary key\n     *\n     * @return {String}\n     */\n    primaryKey() {\n        return this._primary_key;\n    }\n\n    /**\n     * Get array of hidden fields\n     *\n     * @return {String[]}\n     */\n    hidden() {\n        return this._hidden;\n    }\n\n    /**\n     * Get array of indexed fields\n     *\n     * @return {String[]}\n     */\n    indexes() {\n        return this._indexed;\n    }\n\n    /**\n     * Get defined merge fields\n     *\n     * @return {Array}\n     */\n    mergeFields() {\n        return this._unique.concat(this._indexed);\n    }\n}\n'neode/test/ModelMap.spec.js'\n:import ModelMap from '../src/ModelMap';\nimport Model from '../src/Model';\nimport {assert, expect} from 'chai';\n\ndescribe('src/ModelMap.js', () => {\n    const map = new ModelMap();\n\n    describe('::set', () => {\n        it('should set and get a new model', () => {\n            const name = 'ModelMap';\n            const model = new Model(null, name);\n\n            map.set(name, model);\n\n            expect( map.get(name) ).to.equal(model);\n        });\n    });\n\n    describe('::getByLabels', () => {\n        it('should identify a single label model', () => {\n            const name = 'SingleLabelModel';\n            const model = new Model(null, name);\n            const schema = {}\n\n            map.set(name, model);\n\n            expect( map.getByLabels([ name ]) ).to.equal(model);\n        });\n\n        it('should identify a model with multiple labels', () => {\n            const name = 'MultipleLabelModel';\n            const schema = {\n                labels: ['Multiple', 'Labels']\n            }\n            const model = new Model(null, name, schema);\n\n            map.set(name, model);\n\n            expect( map.getByLabels(schema.labels) ).to.equal(model);\n        });\n\n    });\n\n});\n",
        "called_code_segment_file_1": "export default function First(neode, model, key, value) {\n    const alias = 'this';\n\n    const builder = new Builder(neode);\n\n    // Match\n    builder.match(alias, model);\n\n    // Where\n    if (typeof key == 'object') {\n        // Process a map of properties\n        Object.keys(key).forEach(property => {\n            builder.where(`${alias}.${property}`, key[ property ]);\n        });\n    } else {\n        // Straight key/value lookup\n        builder.where(`${alias}.${key}`, value);\n    }\n\n    const output = eagerNode(neode, 1, alias, model);\n\n    return builder.return(output)\n        .limit(1)\n        .execute(mode.READ)\n        .then(res => neode.hydrateFirst(res, alias, model));\n}",
        "invoking_code_segment_file_2": "first(key, value) {\n    return First(this._neode, this, key, value);\n}",
        "called_code_segment_file_2": "findById(id) {\n    return FindById(this._neode, this, id);\n}",
        "using_code_segment_file_3": "FindById(neode, model, id) {\n    const alias = 'this';\n\n    const builder = new Builder(neode);\n\n    // Match\n    builder.match(alias, model);\n\n    // Where\n    builder.where(`ID(${alias})`, id);\n\n    const output = eagerNode(neode, 1, alias, model);\n\n    return builder.return(output)\n        .limit(1)\n        .execute(mode.READ)\n        .then(res => neode.hydrateFirst(res, alias, model));\n}",
        "called_code_segment_file_3": "FindWithinDistance(neode, model, location_property, point, distance, properties, order, limit, skip) {\n    const alias = 'this';\n\n    const builder = new Builder(neode);\n\n    // Match\n    builder.match(alias, model);\n\n    // Where\n    builder.where(`distance(${alias}.${location_property}, point(${point.longitude}, ${point.latitude}))`, '<=', distance);\n\n    const output = eagerNode(neode, 1, alias, model);\n\n    return builder.return(output)\n        .orderBy(order)\n        .limit(limit)\n        .skip(skip)\n        .execute(mode.READ)\n        .then(res => neode.hydrate(res, alias, model));\n}",
        "using_code_segment_file_4": "withinDistance(location_property, point, distance, properties, order, limit, skip) {\n    return FindWithinDistance(this._neode, this, location_property, point, distance, properties, order, limit, skip);\n}",
        "feature_description": "Add a new feature to allow querying nodes by a range of values for a specific property.",
        "detailed_feature_description": "Modify the `First` function in #file 1 to accept a range of values for a specific property. Update the `first` method in #file 2 to handle this new feature. Ensure the `FindById` function in #file 3 is updated to accommodate any changes. Finally, update the `withinDistance` method in #file 4 if necessary.",
        "modified_complete_code": {
            "file_1": "export default function First(neode, model, key, value) {\n    const alias = 'this';\n\n    const builder = new Builder(neode);\n\n    // Match\n    builder.match(alias, model);\n\n    // Where\n    if (typeof key == 'object') {\n        // Process a map of properties\n        Object.keys(key).forEach(property => {\n            if (Array.isArray(key[property])) {\n                // #Modify: Handle range of values\n                builder.where(`${alias}.${property}`, 'IN', key[property]);\n            } else {\n                builder.where(`${alias}.${property}`, key[property]);\n            }\n        });\n    } else {\n        // Straight key/value lookup\n        builder.where(`${alias}.${key}`, value);\n    }\n\n    const output = eagerNode(neode, 1, alias, model);\n\n    return builder.return(output)\n        .limit(1)\n        .execute(mode.READ)\n        .then(res => neode.hydrateFirst(res, alias, model));\n}",
            "file_2": "first(key, value) {\n    return First(this._neode, this, key, value);\n}\n\nfindById(id) {\n    return FindById(this._neode, this, id);\n}",
            "file_3": "FindById(neode, model, id) {\n    const alias = 'this';\n\n    const builder = new Builder(neode);\n\n    // Match\n    builder.match(alias, model);\n\n    // Where\n    builder.where(`ID(${alias})`, id);\n\n    const output = eagerNode(neode, 1, alias, model);\n\n    return builder.return(output)\n        .limit(1)\n        .execute(mode.READ)\n        .then(res => neode.hydrateFirst(res, alias, model));\n}\n\nFindWithinDistance(neode, model, location_property, point, distance, properties, order, limit, skip) {\n    const alias = 'this';\n\n    const builder = new Builder(neode);\n\n    // Match\n    builder.match(alias, model);\n\n    // Where\n    builder.where(`distance(${alias}.${location_property}, point(${point.longitude}, ${point.latitude}))`, '<=', distance);\n\n    const output = eagerNode(neode, 1, alias, model);\n\n    return builder.return(output)\n        .orderBy(order)\n        .limit(limit)\n        .skip(skip)\n        .execute(mode.READ)\n        .then(res => neode.hydrate(res, alias, model));\n}",
            "file_4": "withinDistance(location_property, point, distance, properties, order, limit, skip) {\n    return FindWithinDistance(this._neode, this, location_property, point, distance, properties, order, limit, skip);\n}"
        }
    },
    {
        "repo": "dumb-react",
        "content": "'dumb-react/src/components/PrimaryNav/PrimaryNav.js'\n:import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport './PrimaryNav.css';\n\nexport class PrimaryNav extends Component {\n  render() {\n\n    return (\n      <nav className=\"c-primary-nav { this.props.styleModifier }\">\n        <ul className=\"c-primary-nav__list\">\n          {this.props.listItems.map(function(listItem, index){\n            return <li className=\"c-primary-nav__item\" key={`c-primary-nav__item-${index}`}>\n              <a href={ listItem.href }>\n                { listItem.text }\n              </a>\n            </li>\n          })}\n        </ul>\n      </nav>\n    );\n  }\n}\n\nPrimaryNav.propTypes = {\n  listItems: PropTypes.array.isRequired,\n  href: PropTypes.string,\n  text: PropTypes.string\n}\n\n\n'dumb-react/src/components/Header/Header.js'\n:import React, { Component } from \"react\";\nimport PropTypes from 'prop-types';\nimport \"./Header.css\";\nimport { Logo } from \"../Logo/Logo\";\nimport { PrimaryNav } from \"../PrimaryNav/PrimaryNav\";\nimport { InlineForm } from \"../InlineForm/InlineForm\";\nimport logoImg from \"../../images/fpo-120x60.png\";\nimport globals from \"../../data/globals.json\";\n\nexport class Header extends Component {\n    render() {\n        return (\n            <header className=\"c-header\" {...this.props}>\n                <Logo\n                    href=\"#\"\n                    src={logoImg}\n                    alt={globals.company.name}\n                />\n\n                <PrimaryNav\n                    listItems={[\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 1\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item \"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 3\"\n                        },\n                        {\n                            href: \"#\",\n                            text: \"Nav Item 4\"\n                        }\n                    ]}\n                />\n\n                <InlineForm\n\t\t\t\t\tmethod=\"post\"\n\t\t\t\t\taction=\"#\"\n                    placeholder=\"Search the site\"\n                    cta=\"Search\"\n                    id=\"search-form\"\n                    label=\"Search the site\"\n                />\n                {this.props.children}\n            </header>\n        );\n    }\n}\n\nHeader.propTypes = {\n    children: PropTypes.node\n}\n'dumb-react/src/App.js'\n:import React, { Component } from 'react';\nimport './css/App.css';\nimport { Header } from './components/Header/Header';\nimport { Hero } from './components/Hero/Hero';\nimport { Section } from './components/Section/Section';\nimport { CardList } from './components/CardList/CardList';\nimport { TextPassage } from './components/TextPassage/TextPassage';\nimport { Footer } from './components/Footer/Footer';\n\nimport heroImg from './images/fpo-1200x650.png';\n\nclass App extends Component {\n  render() {\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<Header />\n\t\t\t\n\t\t\t<Hero title=\"This is my hero\" description=\"This is the hero description text\" heroimgsrc={ heroImg } />\n\t\t\t<Section title=\"Hi I'm a section title\" description=\"This is a description of the section\">\n\t\t  \t\t<CardList listItems={[\n\t\t\t\t\t{\n\t\t\t\t\t\"theme\" : \"dark\",\n\t\t\t\t\t\"title\": \"Squeeze Its\",\n\t\t\t\t\t\"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\"title\": \"Capri Suns\",\n\t\t\t\t\t\"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\"title\": \"Hugs\",\n\t\t\t\t\t\"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\"href\": \"http://google.com\",\n\t\t\t\t\t\"title\": \"Mondo\",\n\t\t\t\t\t\"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n\t\t\t\t\t}\n\t\t  \t\t]} />\n\t\t\t\t\n\t\t\t</Section>\n\n\t\t\t<Section title=\"Hi I'm another section\" description=\"This is a different description\">\n\t\t\t\t<div className=\"l-linelength-container\">\n\t\t\t\t\t<TextPassage>\n\t\t\t\t\t\t<p>A text passage contains arbitrary text that might come from a CMS. It should live within a container that caps the line length of the text to avoid a straining reading experience.</p>\n\n\t\t\t\t\t\t<h2>Heading 2</h2>\n\n\t\t\t\t\t\t<p>This is another paragraph of text. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n\n\t\t\t\t\t\t<ul>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t</ul>\n\n\t\t\t\t\t\t<h3>Heading 3</h3>\n\n\t\t\t\t\t\t<ol>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t<li>Here is a unordered list item</li>\n\t\t\t\t\t\t</ol>\n\n\t\t\t\t\t\t<p><a href=\"#link\">Lorem ipsum dolor sit amet</a>, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n\n\t\t\t\t\t\t<blockquote>\n\t\t\t\t\t\t<p>This is a quotation from something.</p>\n\t\t\t\t\t\t<cite>Cite source</cite>\n\t\t\t\t\t\t</blockquote>\n\n\t\t\t\t\t\t<p>That is all.</p>\n\t\t\t\t\t</TextPassage>\n\t\t\t\t</div>{/* end l-linelength-container */}\n\t\t\t</Section>\n\t\t\t<Footer />\n\t  \t</div>\n\t);\n  }\n}\n\nexport default App;\n\n'dumb-react/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n",
        "called_code_segment_file_1": "export class PrimaryNav extends Component {\n  render() {\n    return (\n      <nav className=\"c-primary-nav { this.props.styleModifier }\">\n        <ul className=\"c-primary-nav__list\">\n          {this.props.listItems.map(function(listItem, index){\n            return <li className=\"c-primary-nav__item\" key={`c-primary-nav__item-${index}`}>\n              <a href={ listItem.href }>\n                { listItem.text }\n              </a>\n            </li>\n          })}\n        </ul>\n      </nav>\n    );\n  }\n}",
        "invoking_code_segment_file_2": "<PrimaryNav\n  listItems={[\n    {\n      href: \"#\",\n      text: \"Nav Item 1\"\n    },\n    {\n      href: \"#\",\n      text: \"Nav Item \"\n    },\n    {\n      href: \"#\",\n      text: \"Nav Item 3\"\n    },\n    {\n      href: \"#\",\n      text: \"Nav Item 4\"\n    }\n  ]}\n/>",
        "called_code_segment_file_2": "export class Header extends Component {\n  render() {\n    return (\n      <header className=\"c-header\" {...this.props}>\n        <Logo\n          href=\"#\"\n          src={logoImg}\n          alt={globals.company.name}\n        />\n        <PrimaryNav\n          listItems={[\n            {\n              href: \"#\",\n              text: \"Nav Item 1\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item \"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 3\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 4\"\n            }\n          ]}\n        />\n        <InlineForm\n          method=\"post\"\n          action=\"#\"\n          placeholder=\"Search the site\"\n          cta=\"Search\"\n          id=\"search-form\"\n          label=\"Search the site\"\n        />\n        {this.props.children}\n      </header>\n    );\n  }\n}",
        "using_code_segment_file_3": "<Header />",
        "called_code_segment_file_3": "class App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Header />\n        <Hero title=\"This is my hero\" description=\"This is the hero description text\" heroimgsrc={ heroImg } />\n        <Section title=\"Hi I'm a section title\" description=\"This is a description of the section\">\n          <CardList listItems={[\n            {\n              \"theme\" : \"dark\",\n              \"title\": \"Squeeze Its\",\n              \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n              \"title\": \"Capri Suns\",\n              \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n              \"title\": \"Hugs\",\n              \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n              \"href\": \"http://google.com\",\n              \"title\": \"Mondo\",\n              \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            }\n          ]} />\n        </Section>\n        <Section title=\"Hi I'm another section\" description=\"This is a different description\">\n          <div className=\"l-linelength-container\">\n            <TextPassage>\n              <p>A text passage contains arbitrary text that might come from a CMS. It should live within a container that caps the line length of the text to avoid a straining reading experience.</p>\n              <h2>Heading 2</h2>\n              <p>This is another paragraph of text. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n              <ul>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n              </ul>\n              <h3>Heading 3</h3>\n              <ol>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n              </ol>\n              <p><a href=\"#link\">Lorem ipsum dolor sit amet</a>, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n              <blockquote>\n                <p>This is a quotation from something.</p>\n                <cite>Cite source</cite>\n              </blockquote>\n              <p>That is all.</p>\n            </TextPassage>\n          </div>{/* end l-linelength-container */}\n        </Section>\n        <Footer />\n      </div>\n    );\n  }\n}",
        "using_code_segment_file_4": "ReactDOM.render(<App />, document.getElementById('root'));",
        "feature_description": "Add a dropdown menu to the PrimaryNav component.",
        "detailed_feature_description": "The new feature involves modifying the PrimaryNav component to include a dropdown menu for each navigation item. This will require changes in the PrimaryNav component to handle dropdown items and updates in the Header component to pass dropdown items as props. The App component will remain unchanged as it directly uses the Header component, and the index.js file will also remain unchanged as it only renders the App component.",
        "modified_complete_code": {
            "file_1": "export class PrimaryNav extends Component {\n  render() {\n    return (\n      <nav className=\"c-primary-nav { this.props.styleModifier }\">\n        <ul className=\"c-primary-nav__list\">\n          {this.props.listItems.map((listItem, index) => (\n            <li className=\"c-primary-nav__item\" key={`c-primary-nav__item-${index}`}>\n              <a href={ listItem.href }>\n                { listItem.text }\n              </a>\n              {listItem.dropdownItems && (\n                <ul className=\"c-primary-nav__dropdown\">\n                  {listItem.dropdownItems.map((dropdownItem, dropdownIndex) => (\n                    <li key={`c-primary-nav__dropdown-item-${dropdownIndex}`}>\n                      <a href={dropdownItem.href}>{dropdownItem.text}</a>\n                    </li>\n                  ))}\n                </ul>\n              )}\n            </li>\n          ))}\n        </ul>\n      </nav>\n    );\n  }\n}",
            "file_2": "export class Header extends Component {\n  render() {\n    return (\n      <header className=\"c-header\" {...this.props}>\n        <Logo\n          href=\"#\"\n          src={logoImg}\n          alt={globals.company.name}\n        />\n        <PrimaryNav\n          listItems={[\n            {\n              href: \"#\",\n              text: \"Nav Item 1\",\n              dropdownItems: [\n                { href: \"#\", text: \"Dropdown Item 1\" },\n                { href: \"#\", text: \"Dropdown Item 2\" }\n              ]\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 2\",\n              dropdownItems: [\n                { href: \"#\", text: \"Dropdown Item 3\" },\n                { href: \"#\", text: \"Dropdown Item 4\" }\n              ]\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 3\"\n            },\n            {\n              href: \"#\",\n              text: \"Nav Item 4\"\n            }\n          ]}\n        />\n        <InlineForm\n          method=\"post\"\n          action=\"#\"\n          placeholder=\"Search the site\"\n          cta=\"Search\"\n          id=\"search-form\"\n          label=\"Search the site\"\n        />\n        {this.props.children}\n      </header>\n    );\n  }\n}",
            "file_3": "class App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Header />\n        <Hero title=\"This is my hero\" description=\"This is the hero description text\" heroimgsrc={ heroImg } />\n        <Section title=\"Hi I'm a section title\" description=\"This is a description of the section\">\n          <CardList listItems={[\n            {\n              \"theme\" : \"dark\",\n              \"title\": \"Squeeze Its\",\n              \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n              \"title\": \"Capri Suns\",\n              \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n              \"title\": \"Hugs\",\n              \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            },\n            {\n              \"href\": \"http://google.com\",\n              \"title\": \"Mondo\",\n              \"description\" : \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\"\n            }\n          ]} />\n        </Section>\n        <Section title=\"Hi I'm another section\" description=\"This is a different description\">\n          <div className=\"l-linelength-container\">\n            <TextPassage>\n              <p>A text passage contains arbitrary text that might come from a CMS. It should live within a container that caps the line length of the text to avoid a straining reading experience.</p>\n              <h2>Heading 2</h2>\n              <p>This is another paragraph of text. Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n              <ul>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n              </ul>\n              <h3>Heading 3</h3>\n              <ol>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n                <li>Here is a unordered list item</li>\n              </ol>\n              <p><a href=\"#link\">Lorem ipsum dolor sit amet</a>, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.</p>\n              <blockquote>\n                <p>This is a quotation from something.</p>\n                <cite>Cite source</cite>\n              </blockquote>\n              <p>That is all.</p>\n            </TextPassage>\n          </div>{/* end l-linelength-container */}\n        </Section>\n        <Footer />\n      </div>\n    );\n  }\n}",
            "file_4": "ReactDOM.render(<App />, document.getElementById('root'));"
        }
    },
    {
        "repo": "NFT-Marketplace-Tutorial",
        "content": "'NFT-Marketplace-Tutorial/src/pinata.js'\n:\n'NFT-Marketplace-Tutorial/src/components/SellNFT.js'\n:import Navbar from \"./Navbar\";\nimport { useState } from \"react\";\nimport { uploadFileToIPFS, uploadJSONToIPFS } from \"../pinata\";\nimport Marketplace from '../Marketplace.json';\nimport { useLocation } from \"react-router\";\n\nexport default function SellNFT () {\n    const [formParams, updateFormParams] = useState({ name: '', description: '', price: ''});\n    const [fileURL, setFileURL] = useState(null);\n    const ethers = require(\"ethers\");\n    const [message, updateMessage] = useState('');\n    const location = useLocation();\n\n    async function disableButton() {\n        const listButton = document.getElementById(\"list-button\")\n        listButton.disabled = true\n        listButton.style.backgroundColor = \"grey\";\n        listButton.style.opacity = 0.3;\n    }\n\n    async function enableButton() {\n        const listButton = document.getElementById(\"list-button\")\n        listButton.disabled = false\n        listButton.style.backgroundColor = \"#A500FF\";\n        listButton.style.opacity = 1;\n    }\n\n    //This function uploads the NFT image to IPFS\n    async function OnChangeFile(e) {\n        var file = e.target.files[0];\n        //check for file extension\n        try {\n            //upload the file to IPFS\n            disableButton();\n            updateMessage(\"Uploading image.. please dont click anything!\")\n            const response = await uploadFileToIPFS(file);\n            if(response.success === true) {\n                enableButton();\n                updateMessage(\"\")\n                console.log(\"Uploaded image to Pinata: \", response.pinataURL)\n                setFileURL(response.pinataURL);\n            }\n        }\n        catch(e) {\n            console.log(\"Error during file upload\", e);\n        }\n    }\n\n    //This function uploads the metadata to IPFS\n    async function uploadMetadataToIPFS() {\n        const {name, description, price} = formParams;\n        //Make sure that none of the fields are empty\n        if( !name || !description || !price || !fileURL)\n        {\n            updateMessage(\"Please fill all the fields!\")\n            return -1;\n        }\n\n        const nftJSON = {\n            name, description, price, image: fileURL\n        }\n\n        try {\n            //upload the metadata JSON to IPFS\n            const response = await uploadJSONToIPFS(nftJSON);\n            if(response.success === true){\n                console.log(\"Uploaded JSON to Pinata: \", response)\n                return response.pinataURL;\n            }\n        }\n        catch(e) {\n            console.log(\"error uploading JSON metadata:\", e)\n        }\n    }\n\n    async function listNFT(e) {\n        e.preventDefault();\n\n        //Upload data to IPFS\n        try {\n            const metadataURL = await uploadMetadataToIPFS();\n            if(metadataURL === -1)\n                return;\n            //After adding your Hardhat network to your metamask, this code will get providers and signers\n            const provider = new ethers.providers.Web3Provider(window.ethereum);\n            const signer = provider.getSigner();\n            disableButton();\n            updateMessage(\"Uploading NFT(takes 5 mins).. please dont click anything!\")\n\n            //Pull the deployed contract instance\n            let contract = new ethers.Contract(Marketplace.address, Marketplace.abi, signer)\n\n            //massage the params to be sent to the create NFT request\n            const price = ethers.utils.parseUnits(formParams.price, 'ether')\n            let listingPrice = await contract.getListPrice()\n            listingPrice = listingPrice.toString()\n\n            //actually create the NFT\n            let transaction = await contract.createToken(metadataURL, price, { value: listingPrice })\n            await transaction.wait()\n\n            alert(\"Successfully listed your NFT!\");\n            enableButton();\n            updateMessage(\"\");\n            updateFormParams({ name: '', description: '', price: ''});\n            window.location.replace(\"/\")\n        }\n        catch(e) {\n            alert( \"Upload error\"+e )\n        }\n    }\n\n    console.log(\"Working\", process.env);\n    return (\n        <div className=\"\">\n        <Navbar></Navbar>\n        <div className=\"flex flex-col place-items-center mt-10\" id=\"nftForm\">\n            <form className=\"bg-white shadow-md rounded px-8 pt-4 pb-8 mb-4\">\n            <h3 className=\"text-center font-bold text-purple-500 mb-8\">Upload your NFT to the marketplace</h3>\n                <div className=\"mb-4\">\n                    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"name\">NFT Name</label>\n                    <input className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"name\" type=\"text\" placeholder=\"Axie#4563\" onChange={e => updateFormParams({...formParams, name: e.target.value})} value={formParams.name}></input>\n                </div>\n                <div className=\"mb-6\">\n                    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"description\">NFT Description</label>\n                    <textarea className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" cols=\"40\" rows=\"5\" id=\"description\" type=\"text\" placeholder=\"Axie Infinity Collection\" value={formParams.description} onChange={e => updateFormParams({...formParams, description: e.target.value})}></textarea>\n                </div>\n                <div className=\"mb-6\">\n                    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"price\">Price (in ETH)</label>\n                    <input className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" type=\"number\" placeholder=\"Min 0.01 ETH\" step=\"0.01\" value={formParams.price} onChange={e => updateFormParams({...formParams, price: e.target.value})}></input>\n                </div>\n                <div>\n                    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"image\">Upload Image (&lt;500 KB)</label>\n                    <input type={\"file\"} onChange={OnChangeFile}></input>\n                </div>\n                <br></br>\n                <div className=\"text-red-500 text-center\">{message}</div>\n                <button onClick={listNFT} className=\"font-bold mt-10 w-full bg-purple-500 text-white rounded p-2 shadow-lg\" id=\"list-button\">\n                    List NFT\n                </button>\n            </form>\n        </div>\n        </div>\n    )\n}\n'NFT-Marketplace-Tutorial/src/App.js'\n:import './App.css';\nimport Navbar from './components/Navbar.js';\nimport Marketplace from './components/Marketplace';\nimport Profile from './components/Profile';\nimport SellNFT from './components/SellNFT';\nimport NFTPage from './components/NFTpage';\nimport ReactDOM from \"react-dom/client\";\nimport {\n  BrowserRouter,\n  Routes,\n  Route,\n} from \"react-router-dom\";\n\nfunction App() {\n  return (\n    <div className=\"container\">\n        <Routes>\n          <Route path=\"/\" element={<Marketplace />}/>\n          <Route path=\"/nftPage\" element={<NFTPage />}/>        \n          <Route path=\"/profile\" element={<Profile />}/>\n          <Route path=\"/sellNFT\" element={<SellNFT />}/>             \n        </Routes>\n    </div>\n  );\n}\n\nexport default App;\n\n'NFT-Marketplace-Tutorial/src/App.test.js'\n:import { render, screen } from '@testing-library/react';\nimport App from './App';\n\ntest('renders learn react link', () => {\n  render(<App />);\n  const linkElement = screen.getByText(/learn react/i);\n  expect(linkElement).toBeInTheDocument();\n});\n\n",
        "called_code_segment_file_1": "async function OnChangeFile(e) {\n    var file = e.target.files[0];\n    //check for file extension\n    try {\n        //upload the file to IPFS\n        disableButton();\n        updateMessage(\"Uploading image.. please dont click anything!\")\n        const response = await uploadFileToIPFS(file);\n        if(response.success === true) {\n            enableButton();\n            updateMessage(\"\")\n            console.log(\"Uploaded image to Pinata: \", response.pinataURL)\n            setFileURL(response.pinataURL);\n        }\n    }\n    catch(e) {\n        console.log(\"Error during file upload\", e);\n    }\n}",
        "invoking_code_segment_file_2": "<div>\n    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"image\">Upload Image (&lt;500 KB)</label>\n    <input type={\"file\"} onChange={OnChangeFile}></input>\n</div>",
        "called_code_segment_file_2": "async function listNFT(e) {\n    e.preventDefault();\n\n    //Upload data to IPFS\n    try {\n        const metadataURL = await uploadMetadataToIPFS();\n        if(metadataURL === -1)\n            return;\n        //After adding your Hardhat network to your metamask, this code will get providers and signers\n        const provider = new ethers.providers.Web3Provider(window.ethereum);\n        const signer = provider.getSigner();\n        disableButton();\n        updateMessage(\"Uploading NFT(takes 5 mins).. please dont click anything!\")\n\n        //Pull the deployed contract instance\n        let contract = new ethers.Contract(Marketplace.address, Marketplace.abi, signer)\n\n        //massage the params to be sent to the create NFT request\n        const price = ethers.utils.parseUnits(formParams.price, 'ether')\n        let listingPrice = await contract.getListPrice()\n        listingPrice = listingPrice.toString()\n\n        //actually create the NFT\n        let transaction = await contract.createToken(metadataURL, price, { value: listingPrice })\n        await transaction.wait()\n\n        alert(\"Successfully listed your NFT!\");\n        enableButton();\n        updateMessage(\"\");\n        updateFormParams({ name: '', description: '', price: ''});\n        window.location.replace(\"/\")\n    }\n    catch(e) {\n        alert( \"Upload error\"+e )\n    }\n}",
        "using_code_segment_file_3": "const provider = new ethers.providers.Web3Provider(window.ethereum);\nconst signer = provider.getSigner();\nlet contract = new ethers.Contract(Marketplace.address, Marketplace.abi, signer)",
        "called_code_segment_file_3": "Not applicable",
        "using_code_segment_file_4": "Not applicable",
        "feature_description": "Add a progress indicator for file upload",
        "detailed_feature_description": "Modify the OnChangeFile function in #file 1 to include a progress indicator for file upload. Update the SellNFT component in #file 2 to handle the progress indicator and ensure the listNFT function is updated accordingly. No direct interaction between #file 3 and #file 4 with the modified segments, so no changes are required in those files.",
        "modified_complete_code": {
            "file_1": "async function OnChangeFile(e) {\n    var file = e.target.files[0];\n    //check for file extension\n    try {\n        //upload the file to IPFS\n        disableButton();\n        updateMessage(\"Uploading image.. please dont click anything!\")\n        const response = await uploadFileToIPFS(file);\n        if(response.success === true) {\n            enableButton();\n            updateMessage(\"\")\n            console.log(\"Uploaded image to Pinata: \", response.pinataURL)\n            setFileURL(response.pinataURL);\n        }\n    }\n    catch(e) {\n        console.log(\"Error during file upload\", e);\n    }\n}",
            "file_2": "import Navbar from \"./Navbar\";\nimport { useState } from \"react\";\nimport { uploadFileToIPFS, uploadJSONToIPFS } from \"../pinata\";\nimport Marketplace from '../Marketplace.json';\nimport { useLocation } from \"react-router\";\n\nexport default function SellNFT () {\n    const [formParams, updateFormParams] = useState({ name: '', description: '', price: ''});\n    const [fileURL, setFileURL] = useState(null);\n    const ethers = require(\"ethers\");\n    const [message, updateMessage] = useState('');\n    const location = useLocation();\n\n    async function disableButton() {\n        const listButton = document.getElementById(\"list-button\")\n        listButton.disabled = true\n        listButton.style.backgroundColor = \"grey\";\n        listButton.style.opacity = 0.3;\n    }\n\n    async function enableButton() {\n        const listButton = document.getElementById(\"list-button\")\n        listButton.disabled = false\n        listButton.style.backgroundColor = \"#A500FF\";\n        listButton.style.opacity = 1;\n    }\n\n    //This function uploads the NFT image to IPFS\n    async function OnChangeFile(e) {\n        var file = e.target.files[0];\n        //check for file extension\n        try {\n            //upload the file to IPFS\n            disableButton();\n            updateMessage(\"Uploading image.. please dont click anything!\")\n            const response = await uploadFileToIPFS(file);\n            if(response.success === true) {\n                enableButton();\n                updateMessage(\"\")\n                console.log(\"Uploaded image to Pinata: \", response.pinataURL)\n                setFileURL(response.pinataURL);\n            }\n        }\n        catch(e) {\n            console.log(\"Error during file upload\", e);\n        }\n    }\n\n    //This function uploads the metadata to IPFS\n    async function uploadMetadataToIPFS() {\n        const {name, description, price} = formParams;\n        //Make sure that none of the fields are empty\n        if( !name || !description || !price || !fileURL)\n        {\n            updateMessage(\"Please fill all the fields!\")\n            return -1;\n        }\n\n        const nftJSON = {\n            name, description, price, image: fileURL\n        }\n\n        try {\n            //upload the metadata JSON to IPFS\n            const response = await uploadJSONToIPFS(nftJSON);\n            if(response.success === true){\n                console.log(\"Uploaded JSON to Pinata: \", response)\n                return response.pinataURL;\n            }\n        }\n        catch(e) {\n            console.log(\"error uploading JSON metadata:\", e)\n        }\n    }\n\n    async function listNFT(e) {\n        e.preventDefault();\n\n        //Upload data to IPFS\n        try {\n            const metadataURL = await uploadMetadataToIPFS();\n            if(metadataURL === -1)\n                return;\n            //After adding your Hardhat network to your metamask, this code will get providers and signers\n            const provider = new ethers.providers.Web3Provider(window.ethereum);\n            const signer = provider.getSigner();\n            disableButton();\n            updateMessage(\"Uploading NFT(takes 5 mins).. please dont click anything!\")\n\n            //Pull the deployed contract instance\n            let contract = new ethers.Contract(Marketplace.address, Marketplace.abi, signer)\n\n            //massage the params to be sent to the create NFT request\n            const price = ethers.utils.parseUnits(formParams.price, 'ether')\n            let listingPrice = await contract.getListPrice()\n            listingPrice = listingPrice.toString()\n\n            //actually create the NFT\n            let transaction = await contract.createToken(metadataURL, price, { value: listingPrice })\n            await transaction.wait()\n\n            alert(\"Successfully listed your NFT!\");\n            enableButton();\n            updateMessage(\"\");\n            updateFormParams({ name: '', description: '', price: ''});\n            window.location.replace(\"/\")\n        }\n        catch(e) {\n            alert( \"Upload error\"+e )\n        }\n    }\n\n    console.log(\"Working\", process.env);\n    return (\n        <div className=\"\">\n        <Navbar></Navbar>\n        <div className=\"flex flex-col place-items-center mt-10\" id=\"nftForm\">\n            <form className=\"bg-white shadow-md rounded px-8 pt-4 pb-8 mb-4\">\n            <h3 className=\"text-center font-bold text-purple-500 mb-8\">Upload your NFT to the marketplace</h3>\n                <div className=\"mb-4\">\n                    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"name\">NFT Name</label>\n                    <input className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" id=\"name\" type=\"text\" placeholder=\"Axie#4563\" onChange={e => updateFormParams({...formParams, name: e.target.value})} value={formParams.name}></input>\n                </div>\n                <div className=\"mb-6\">\n                    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"description\">NFT Description</label>\n                    <textarea className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" cols=\"40\" rows=\"5\" id=\"description\" type=\"text\" placeholder=\"Axie Infinity Collection\" value={formParams.description} onChange={e => updateFormParams({...formParams, description: e.target.value})}></textarea>\n                </div>\n                <div className=\"mb-6\">\n                    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"price\">Price (in ETH)</label>\n                    <input className=\"shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline\" type=\"number\" placeholder=\"Min 0.01 ETH\" step=\"0.01\" value={formParams.price} onChange={e => updateFormParams({...formParams, price: e.target.value})}></input>\n                </div>\n                <div>\n                    <label className=\"block text-purple-500 text-sm font-bold mb-2\" htmlFor=\"image\">Upload Image (&lt;500 KB)</label>\n                    <input type={\"file\"} onChange={OnChangeFile}></input>\n                </div>\n                <br></br>\n                <div className=\"text-red-500 text-center\">{message}</div>\n                <button onClick={listNFT} className=\"font-bold mt-10 w-full bg-purple-500 text-white rounded p-2 shadow-lg\" id=\"list-button\">\n                    List NFT\n                </button>\n            </form>\n        </div>\n        </div>\n    )\n}",
            "file_3": "const provider = new ethers.providers.Web3Provider(window.ethereum);\nconst signer = provider.getSigner();\nlet contract = new ethers.Contract(Marketplace.address, Marketplace.abi, signer)",
            "file_4": "Not applicable"
        }
    },
    {
        "repo": "ThreeJS-Webpack-ES6-Boilerplate",
        "content": "'ThreeJS-Webpack-ES6-Boilerplate/src/js/app/helpers/vertexNormalsHelper.js'\n:/**\n * @author mrdoob / http://mrdoob.com/\n * @author WestLangley / http://github.com/WestLangley\n */\n\nimport {\n  BufferGeometry,\n  Float32BufferAttribute,\n  LineSegments,\n  LineBasicMaterial,\n  Matrix3,\n  Vector3,\n} from 'three';\n\nconst _v1 = new Vector3();\nconst _v2 = new Vector3();\nconst _normalMatrix = new Matrix3();\nconst _keys = ['a', 'b', 'c'];\n\nfunction VertexNormalsHelper(object, size, hex) {\n  this.object = object;\n  this.size = size !== undefined ? size : 0.1;\n\n  const color = hex !== undefined ? hex : 0xff0000;\n\n  //\n\n  let nNormals = 0;\n\n  const objGeometry = this.object.geometry;\n\n  if (objGeometry && objGeometry.isGeometry) {\n    nNormals = objGeometry.faces.length * 3;\n  } else if (objGeometry && objGeometry.isBufferGeometry) {\n    nNormals = objGeometry.attributes.normal.count;\n  }\n\n  //\n\n  const geometry = new BufferGeometry();\n  const positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);\n\n  geometry.setAttribute('position', positions);\n\n  LineSegments.call(this, geometry, new LineBasicMaterial({ color: color, toneMapped: false }));\n\n  this.type = 'VertexNormalsHelper';\n\n  //\n\n  this.matrixAutoUpdate = false;\n\n  this.update();\n}\n\nVertexNormalsHelper.prototype = Object.create(LineSegments.prototype);\nVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\n\nVertexNormalsHelper.prototype.update = function () {\n  let idx;\n  this.object.updateMatrixWorld(true);\n\n  _normalMatrix.getNormalMatrix(this.object.matrixWorld);\n\n  const matrixWorld = this.object.matrixWorld;\n  const position = this.geometry.attributes.position;\n\n  //\n\n  const objGeometry = this.object.geometry;\n\n  if (objGeometry && objGeometry.isGeometry) {\n    const vertices = objGeometry.vertices;\n\n    const faces = objGeometry.faces;\n\n    idx = 0;\n\n    for (let i = 0, l = faces.length; i < l; i++) {\n      const face = faces[i];\n\n      for (let j = 0, jl = face.vertexNormals.length; j < jl; j++) {\n        const vertex = vertices[face[_keys[j]]];\n        const normal = face.vertexNormals[j];\n\n        _v1.copy(vertex).applyMatrix4(matrixWorld);\n        _v2.copy(normal).applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n        position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n\n        idx = idx + 1;\n\n        position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n\n        idx = idx + 1;\n      }\n    }\n  } else if (objGeometry && objGeometry.isBufferGeometry) {\n    const objPos = objGeometry.attributes.position;\n    const objNorm = objGeometry.attributes.normal;\n\n    idx = 0;\n\n    // for simplicity, ignore index and drawcalls, and render every normal\n\n    for (var j = 0, jl = objPos.count; j < jl; j++) {\n      _v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);\n      _v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));\n      _v2.applyMatrix3(_normalMatrix).normalize().multiplyScalar(this.size).add(_v1);\n\n      position.setXYZ(idx, _v1.x, _v1.y, _v1.z);\n\n      idx = idx + 1;\n\n      position.setXYZ(idx, _v2.x, _v2.y, _v2.z);\n\n      idx = idx + 1;\n    }\n  }\n\n  position.needsUpdate = true;\n};\n\nexport { VertexNormalsHelper };\n\n'ThreeJS-Webpack-ES6-Boilerplate/src/js/app/helpers/meshHelper.js'\n:import * as THREE from 'three';\nimport { VertexNormalsHelper } from './vertexNormalsHelper';\n\n// Simple mesh helper that shows edges, wireframes, and face and vertex normals\nexport default class MeshHelper {\n  constructor(scene, mesh) {\n    this.mesh = mesh;\n    this.scene = scene;\n\n    const wireframe = new THREE.WireframeGeometry(this.mesh.geometry);\n    this.wireLine = new THREE.LineSegments(wireframe);\n    this.wireLine.material.depthTest = false;\n    this.wireLine.material.opacity = 0.25;\n    this.wireLine.material.transparent = true;\n\n    const edges = new THREE.EdgesGeometry(this.mesh.geometry);\n    this.edgesLine = new THREE.LineSegments(edges);\n    this.edgesLine.material.depthTest = false;\n    this.edgesLine.material.opacity = 0.25;\n    this.edgesLine.material.transparent = true;\n\n    this.vertexHelper = new VertexNormalsHelper(this.mesh, 2);\n    this.boxHelper = new THREE.BoxHelper(this.mesh);\n  }\n\n  enable() {\n    this.mesh.add(this.wireLine);\n    this.mesh.add(this.edgesLine);\n\n    this.scene.add(this.vertexHelper);\n    this.scene.add(this.boxHelper);\n  }\n\n  disable() {\n    this.mesh.remove(this.wireLine);\n    this.mesh.remove(this.edgesLine);\n\n    this.scene.remove(this.vertexHelper);\n    this.scene.remove(this.boxHelper);\n  }\n}\n\n'ThreeJS-Webpack-ES6-Boilerplate/src/js/app/main.js'\n:// Global imports -\nimport * as THREE from 'three';\nimport TWEEN from '@tweenjs/tween.js';\n\n// Local imports -\n// Components\nimport Renderer from './components/renderer';\nimport Camera from './components/camera';\nimport Light from './components/light';\nimport Controls from './components/controls';\nimport Geometry from './components/geometry';\n\n// Helpers\nimport Stats from './helpers/stats';\nimport MeshHelper from './helpers/meshHelper';\n\n// Model\nimport Texture from './model/texture';\nimport Model from './model/model';\n\n// Managers\nimport Interaction from './managers/interaction';\nimport DatGUI from './managers/datGUI';\n\n// data\nimport Config from './../data/config';\n// -- End of imports\n\n// This class instantiates and ties all of the components together, starts the loading process and renders the main loop\nexport default class Main {\n  constructor(container) {\n    // Set container property to container element\n    this.container = container;\n\n    // Start Three clock\n    this.clock = new THREE.Clock();\n\n    // Main scene creation\n    this.scene = new THREE.Scene();\n    this.scene.fog = new THREE.FogExp2(Config.fog.color, Config.fog.near);\n\n    // Get Device Pixel Ratio first for retina\n    if(window.devicePixelRatio) {\n      Config.dpr = window.devicePixelRatio;\n    }\n\n    // Main renderer constructor\n    this.renderer = new Renderer(this.scene, container);\n\n    // Components instantiations\n    this.camera = new Camera(this.renderer.threeRenderer);\n    this.controls = new Controls(this.camera.threeCamera, container);\n    this.light = new Light(this.scene);\n\n    // Create and place lights in scene\n    const lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach((light) => this.light.place(light));\n\n    // Create and place geo in scene\n    this.geometry = new Geometry(this.scene);\n    this.geometry.make('plane')(150, 150, 10, 10);\n    this.geometry.place([0, -20, 0], [Math.PI / 2, 0, 0]);\n\n    // Set up rStats if dev environment\n    if(Config.isDev && Config.isShowingStats) {\n      this.stats = new Stats(this.renderer);\n      this.stats.setUp();\n    }\n\n    // Set up gui\n    if (Config.isDev) {\n      this.gui = new DatGUI(this)\n    }\n\n    // Instantiate texture class\n    this.texture = new Texture();\n\n    // Start loading the textures and then go on to load the model after the texture Promises have resolved\n    this.texture.load().then(() => {\n      this.manager = new THREE.LoadingManager();\n\n      // Textures loaded, load model\n      this.model = new Model(this.scene, this.manager, this.texture.textures);\n      this.model.load(Config.models[Config.model.selected].type);\n\n      // onProgress callback\n      this.manager.onProgress = (item, loaded, total) => {\n        console.log(`${item}: ${loaded} ${total}`);\n      };\n\n      // All loaders done now\n      this.manager.onLoad = () => {\n        // Set up interaction manager with the app now that the model is finished loading\n        new Interaction(this.renderer.threeRenderer, this.scene, this.camera.threeCamera, this.controls.threeControls);\n\n        // Add dat.GUI controls if dev\n        if(Config.isDev) {\n          this.meshHelper = new MeshHelper(this.scene, this.model.obj);\n          if (Config.mesh.enableHelper) this.meshHelper.enable();\n\n          this.gui.load(this, this.model.obj);\n        }\n\n        // Everything is now fully loaded\n        Config.isLoaded = true;\n        this.container.querySelector('#loading').style.display = 'none';\n      };\n    });\n\n    // Start render which does not wait for model fully loaded\n    this.render();\n  }\n\n  render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }\n}\n\n'ThreeJS-Webpack-ES6-Boilerplate/src/js/app.js'\n:import Config from './data/config';\nimport Detector from './utils/detector';\nimport Main from './app/main';\n\n// Styles\nimport './../css/app.scss';\n\n// Check environment and set the Config helper\nif(__ENV__ === 'dev') {\n  console.log('----- RUNNING IN DEV ENVIRONMENT! -----');\n\n  Config.isDev = true;\n}\n\nfunction init() {\n  // Check for webGL capabilities\n  if(!Detector.webgl) {\n    Detector.addGetWebGLMessage();\n  } else {\n    const container = document.getElementById('appContainer');\n    new Main(container);\n  }\n}\n\ninit();\n\n",
        "called_code_segment_file_1": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "invoking_code_segment_file_2": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "called_code_segment_file_2": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "using_code_segment_file_3": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "called_code_segment_file_3": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "using_code_segment_file_4": "render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }",
        "feature_description": "Add a new feature to toggle the visibility of the mesh helper using a key press.",
        "detailed_feature_description": "Modify the Main class to include a key press event listener that toggles the visibility of the mesh helper. Update the Interaction class to handle this event and ensure the mesh helper visibility is toggled accordingly.",
        "modified_complete_code": {
            "file_1": "// Main.js\nimport * as THREE from 'three';\nimport TWEEN from '@tweenjs/tween.js';\n\n// Local imports\n// Components\nimport Renderer from './components/renderer';\nimport Camera from './components/camera';\nimport Light from './components/light';\nimport Controls from './components/controls';\nimport Geometry from './components/geometry';\n\n// Helpers\nimport Stats from './helpers/stats';\nimport MeshHelper from './helpers/meshHelper';\n\n// Model\nimport Texture from './model/texture';\nimport Model from './model/model';\n\n// Managers\nimport Interaction from './managers/interaction';\nimport DatGUI from './managers/datGUI';\n\n// data\nimport Config from './../data/config';\n// -- End of imports\n\n// This class instantiates and ties all of the components together, starts the loading process and renders the main loop\nexport default class Main {\n  constructor(container) {\n    // Set container property to container element\n    this.container = container;\n\n    // Start Three clock\n    this.clock = new THREE.Clock();\n\n    // Main scene creation\n    this.scene = new THREE.Scene();\n    this.scene.fog = new THREE.FogExp2(Config.fog.color, Config.fog.near);\n\n    // Get Device Pixel Ratio first for retina\n    if(window.devicePixelRatio) {\n      Config.dpr = window.devicePixelRatio;\n    }\n\n    // Main renderer constructor\n    this.renderer = new Renderer(this.scene, container);\n\n    // Components instantiations\n    this.camera = new Camera(this.renderer.threeRenderer);\n    this.controls = new Controls(this.camera.threeCamera, container);\n    this.light = new Light(this.scene);\n\n    // Create and place lights in scene\n    const lights = ['ambient', 'directional', 'point', 'hemi'];\n    lights.forEach((light) => this.light.place(light));\n\n    // Create and place geo in scene\n    this.geometry = new Geometry(this.scene);\n    this.geometry.make('plane')(150, 150, 10, 10);\n    this.geometry.place([0, -20, 0], [Math.PI / 2, 0, 0]);\n\n    // Set up rStats if dev environment\n    if(Config.isDev && Config.isShowingStats) {\n      this.stats = new Stats(this.renderer);\n      this.stats.setUp();\n    }\n\n    // Set up gui\n    if (Config.isDev) {\n      this.gui = new DatGUI(this)\n    }\n\n    // Instantiate texture class\n    this.texture = new Texture();\n\n    // Start loading the textures and then go on to load the model after the texture Promises have resolved\n    this.texture.load().then(() => {\n      this.manager = new THREE.LoadingManager();\n\n      // Textures loaded, load model\n      this.model = new Model(this.scene, this.manager, this.texture.textures);\n      this.model.load(Config.models[Config.model.selected].type);\n\n      // onProgress callback\n      this.manager.onProgress = (item, loaded, total) => {\n        console.log(`${item}: ${loaded} ${total}`);\n      };\n\n      // All loaders done now\n      this.manager.onLoad = () => {\n        // Set up interaction manager with the app now that the model is finished loading\n        new Interaction(this.renderer.threeRenderer, this.scene, this.camera.threeCamera, this.controls.threeControls);\n\n        // Add dat.GUI controls if dev\n        if(Config.isDev) {\n          this.meshHelper = new MeshHelper(this.scene, this.model.obj);\n          if (Config.mesh.enableHelper) this.meshHelper.enable();\n\n          this.gui.load(this, this.model.obj);\n        }\n\n        // Everything is now fully loaded\n        Config.isLoaded = true;\n        this.container.querySelector('#loading').style.display = 'none';\n      };\n    });\n\n    // Start render which does not wait for model fully loaded\n    this.render();\n\n    // #Modify: Add key press event listener to toggle mesh helper visibility\n    window.addEventListener('keydown', (event) => {\n      if (event.key === 'h') {\n        if (this.meshHelper) {\n          if (this.meshHelper.enabled) {\n            this.meshHelper.disable();\n          } else {\n            this.meshHelper.enable();\n          }\n        }\n      }\n    });\n  }\n\n  render() {\n    // Render rStats if Dev\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.start();\n    }\n\n    // Call render function and pass in created scene and camera\n    this.renderer.render(this.scene, this.camera.threeCamera);\n\n    // rStats has finished determining render call now\n    if(Config.isDev && Config.isShowingStats) {\n      Stats.end();\n    }\n\n    // Delta time is sometimes needed for certain updates\n    //const delta = this.clock.getDelta();\n\n    // Call any vendor or module frame updates here\n    TWEEN.update();\n    this.controls.threeControls.update();\n\n    // RAF\n    requestAnimationFrame(this.render.bind(this)); // Bind the main class instead of window object\n  }\n}",
            "file_2": "// Interaction.js\nimport * as THREE from 'three';\n\n// Managers\nimport Config from './../data/config';\n\n// This class handles all interaction methods\nexport default class Interaction {\n  constructor(renderer, scene, camera, controls) {\n    this.renderer = renderer;\n    this.scene = scene;\n    this.camera = camera;\n    this.controls = controls;\n\n    // Set up pointer lock and mouse events\n    this.handleMouseDown = this.handleMouseDown.bind(this);\n    this.handleMouseUp = this.handleMouseUp.bind(this);\n    this.handleMouseMove = this.handleMouseMove.bind(this);\n\n    // Add event listeners\n    this.renderer.domElement.addEventListener('mousedown', this.handleMouseDown);\n    this.renderer.domElement.addEventListener('mouseup', this.handleMouseUp);\n    this.renderer.domElement.addEventListener('mousemove', this.handleMouseMove);\n  }\n\n  handleMouseDown(event) {\n    // Handle mouse down event\n  }\n\n  handleMouseUp(event) {\n    // Handle mouse up event\n  }\n\n  handleMouseMove(event) {\n    // Handle mouse move event\n  }\n\n  // #Modify: Add method to toggle mesh helper visibility\n  toggleMeshHelper(meshHelper) {\n    if (meshHelper) {\n      if (meshHelper.enabled) {\n        meshHelper.disable();\n      } else {\n        meshHelper.enable();\n      }\n    }\n  }\n}",
            "file_3": "// MeshHelper.js\nimport * as THREE from 'three';\nimport { VertexNormalsHelper } from './vertexNormalsHelper';\n\n// Simple mesh helper that shows edges, wireframes, and face and vertex normals\nexport default class MeshHelper {\n  constructor(scene, mesh) {\n    this.mesh = mesh;\n    this.scene = scene;\n\n    const wireframe = new THREE.WireframeGeometry(this.mesh.geometry);\n    this.wireLine = new THREE.LineSegments(wireframe);\n    this.wireLine.material.depthTest = false;\n    this.wireLine.material.opacity = 0.25;\n    this.wireLine.material.transparent = true;\n\n    const edges = new THREE.EdgesGeometry(this.mesh.geometry);\n    this.edgesLine = new THREE.LineSegments(edges);\n    this.edgesLine.material.depthTest = false;\n    this.edgesLine.material.opacity = 0.25;\n    this.edgesLine.material.transparent = true;\n\n    this.vertexHelper = new VertexNormalsHelper(this.mesh, 2);\n    this.boxHelper = new THREE.BoxHelper(this.mesh);\n\n    // #New: Add enabled property\n    this.enabled = false;\n  }\n\n  enable() {\n    this.mesh.add(this.wireLine);\n    this.mesh.add(this.edgesLine);\n\n    this.scene.add(this.vertexHelper);\n    this.scene.add(this.boxHelper);\n\n    // #New: Set enabled property to true\n    this.enabled = true;\n  }\n\n  disable() {\n    this.mesh.remove(this.wireLine);\n    this.mesh.remove(this.edgesLine);\n\n    this.scene.remove(this.vertexHelper);\n    this.scene.remove(this.boxHelper);\n\n    // #New: Set enabled property to false\n    this.enabled = false;\n  }\n}",
            "file_4": "// DatGUI.js\nimport * as dat from 'dat.gui';\n\n// Managers\nimport Config from './../data/config';\n\n// This class handles dat.GUI interactions\nexport default class DatGUI {\n  constructor(main) {\n    this.main = main;\n    this.gui = new dat.GUI();\n  }\n\n  load(main, model) {\n    // Add dat.GUI controls\n    const controls = {\n      toggleMeshHelper: () => {\n        main.interaction.toggleMeshHelper(main.meshHelper);\n      }\n    };\n\n    this.gui.add(controls, 'toggleMeshHelper').name('Toggle Mesh Helper');\n  }\n}"
        }
    },
    {
        "repo": "hype-beats",
        "content": "'hype-beats/src/graphql/subscriptions.js'\n:// eslint-disable\n// this is an auto generated file. This will be overwritten\nimport gql from 'graphql-tag'\n\nexport const onCreateDrumMachine = gql`subscription OnCreateDrumMachine {\n  onCreateDrumMachine {\n    id\n    clientId\n    beats\n    name\n  }\n}\n`;\nexport const onUpdateDrumMachine = `subscription OnUpdateDrumMachine {\n  onUpdateDrumMachine {\n    id\n    clientId\n    beats\n    name\n  }\n}\n`;\nexport const onDeleteDrumMachine = `subscription OnDeleteDrumMachine {\n  onDeleteDrumMachine {\n    id\n    clientId\n    beats\n    name\n  }\n}\n`;\n\nexport const onUpdateByID = `subscription onUpdateByID($id: ID!) {\n  onUpdateByID(id: $id) {\n    id\n    clientId\n    beats\n    name\n  }\n}\n`;\n'hype-beats/src/DrumMachine.js'\n:import React, { useReducer, useState, useEffect, useRef } from 'react';\nimport { Link } from 'react-router-dom';\nimport styled from 'styled-components';\nimport Tone from 'tone';\n\nimport useBPM from './useBPM';\nimport useStart from './useStart';\nimport StepContext from './StepContext';\nimport Transport from './Transport';\nimport StepSequencer from './StepSequencer';\nimport Fx from './FX';\n\nimport { API, graphqlOperation } from 'aws-amplify'\nimport { createDrumMachine as CreateDrumMachine, updateDrumMachine as UpdateDrumMachine } from './graphql/mutations'\nimport { onUpdateByID } from './graphql/subscriptions'\nimport uuid from 'uuid/v4'\n\nconst clientId = uuid()\n\nconst Wrapper = styled.div`\n  border: 9px solid #ff32ff;\n  min-width: 840px;\n  height: 100vh;\n`\n\nconst Title = styled.div`\n  max-width: 800px;\n  margin: auto;\n  margin-top: 20px;\n  color: #ffe700;\n  text-decoration: none;\n  @media (max-width: 440px) {\n    margin-left: 20px;\n  }\n`\n\nconst Container = styled.div`\n  min-width: 800px;\n  max-width: 800px;\n  margin: auto;\n  background: linear-gradient(to bottom right, #222, #0a0a0a);\n  border: 2px solid black;\n  border-radius: 4px;\n  margin-top: 20px;\n  display: flex;\n  flex-direction: column;\n`;\n\nconst ButtonContainer = styled.div`\n  flex: 1;\n  flex-direction: row;\n  align-items: stretch;\n  width: 100%;\n  padding: 0px 20px 10px;\n  display: flex;\n`;\n\nconst Logo = styled.h1`\n  font-size: 28px;\n  color: #25ccf7;\n  font-family: 'Righteous', cursive;\n  padding: 20px;\n  margin: 0;\n  text-transform: uppercase;\n  display: inline-block;\n`;\n\nconst config = {\n  tracks: ['Kick', 'Sub1', 'Sub2', 'Snare', 'Clap', 'HiHat', 'OpenHiHat'],\n  samples: {\n    Kick: 'sounds/kick.wav',\n    Sub1: 'sounds/bass.wav',\n    Sub2: 'sounds/sub.wav',\n    Snare: 'sounds/snare.wav',\n    Clap: 'sounds/clap.wav',\n    HiHat: 'sounds/hat2.wav',\n    OpenHiHat: 'sounds/openhihat.wav',\n  },\n};\n\nconst initialStepState = {\n  Kick: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  Sub1: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  Sub2: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  Snare: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  Clap: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  HiHat: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  OpenHiHat: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n}\n\nasync function updateDrumMachine(beats, machineId) {\n  const beatbox = {\n    id: machineId, clientId, beats: JSON.stringify(beats)\n  }\n  try {\n    await API.graphql(graphqlOperation(UpdateDrumMachine, { input: beatbox }))\n    console.log('successfully updated drum machine...')\n  } catch (err) {\n    console.log('error updating drum machine...:', err)\n  }\n  return () => {}\n}\n\nasync function createDrumMachine(machine, setSteps) {\n  try {\n    await API.graphql(graphqlOperation(CreateDrumMachine, { input: machine }))\n    console.log('successfully created drum machine!')\n  } catch (err) {\n    console.log('error creating drum machine...: ', err)\n    const { errors } = err\n    const beats = errors[0].data.beats\n    setSteps(JSON.parse(beats))\n  }\n}\n\nfunction reducer(state, action) {\n  return action\n}\n\nexport default function DrumMachine(props) {\n  const { name: machineName, id: machineId } = props.match.params\n\n  const [stepState, setSteps] = useReducer(reducer, initialStepState)\n  const [buffers, setBuffers] = useState({});\n\n  const [currentStep, setCurrentStepState] = useState(0);\n\n  const [start, startButton] = useStart();\n  const [bpm, bpmSelector] = useBPM(65);\n\n  const buffersRef = useRef(buffers);\n  buffersRef.current = buffers;\n  const stepsRef = useRef(stepState);\n  stepsRef.current = stepState;\n  const currentStepRef = useRef(currentStep);\n  currentStepRef.current = currentStep;\n  \n  useEffect(() => {\n    const machine = {\n      id: machineId,\n      clientId,\n      beats: JSON.stringify(stepState),\n      name: machineName\n    }\n    createDrumMachine(machine, setSteps)\n  }, [])\n\n  useEffect(() => {\n    console.log('machineId: ', machineId)\n    const subscriber = API.graphql(graphqlOperation(onUpdateByID, { id: machineId })).subscribe({\n      next: data => {\n        console.log('data:', data)\n        const { value: { data: { onUpdateByID: { clientId: ClientId, beats }}}} = data\n        if (ClientId === clientId) return\n        setSteps(JSON.parse(beats))\n      }\n    });\n    return () => subscriber.unsubscribe()\n  }, []);\n\n  useEffect(\n    () => {\n      Tone.Transport.scheduleRepeat(function(time) {\n        Object.keys(buffersRef.current).forEach(b => {\n          let targetStep = stepsRef.current[b][currentStepRef.current];\n          let targetBuffer = buffersRef.current[b];\n\n          if (targetStep === 1) {\n            targetBuffer.start(time);\n          } else if (targetStep === 2) {\n            targetBuffer.start();\n            targetBuffer.start('+64n');\n            targetBuffer.start('+32n');\n          }\n        });\n\n        setCurrentStepState(step => {\n          return step > 14 ? 0 : step + 1;\n        });\n      }, '16n');\n      return () => buffersRef.current = {}\n    },\n    [config]\n  );\n\n  useEffect(\n    () => {\n      Tone.Transport.bpm.value = bpm;\n    },\n    [bpm]\n  );\n\n  useEffect(\n    () => {\n      if (start) {\n        Tone.Transport.start();\n      } else {\n        Tone.Transport.stop();\n        setCurrentStepState(0);\n      }\n      return () => Tone.Transport.stop()\n    },\n    [start]\n  );\n  return (\n    <Wrapper>\n    <StepContext.Provider value={{ state: stepState, setSteps, updateDrumMachine, machineId }}>\n      <Link to='/'>\n        <Title>View Beatboxes</Title>\n      </Link>\n      <Container>\n        <Transport>\n          <Logo>{machineName}</Logo>\n          {bpmSelector}\n          {startButton}\n        </Transport>\n        <React.Suspense fallback={<p style={{paddingLeft: 30, color: 'white'}}>loading</p>}>\n          <StepSequencer\n            config={config}\n            currentStep={currentStepRef.current}\n            playing={start}\n            setBuffers={setBuffers}\n          />\n          <ButtonContainer>\n            <Fx sound=\"sounds/loop.wav\" title=\"Turn Up (F)\" />\n            <Fx sound=\"sounds/loop130.wav\" title=\"SQUAD (Am)\" />\n            <Fx sound=\"sounds/hey.wav\" title=\"Hey\" />\n            <Fx sound=\"sounds/yeah.wav\" title=\"Yeah\" />\n          </ButtonContainer>\n        </React.Suspense>\n      </Container>\n    </StepContext.Provider>\n    </Wrapper>\n  );\n}\n\n\n'hype-beats/src/Router.js'\n:import React from 'react'\nimport { HashRouter as Router, Switch, Route } from 'react-router-dom'\n\nimport Machines from './Machines'\nimport Machine from './DrumMachine'\n\nfunction Main() {\n  return (\n    <Router>\n      <div>\n        <Switch>\n          <Route exact path=\"/\" component={Machines} />\n          <Route path=\"/machine/:id/:name?\" component={Machine} />\n        </Switch>\n      </div>\n    </Router>\n  )\n}\n\nexport default Main\n'hype-beats/src/index.js'\n:import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport Amplify from 'aws-amplify'\nimport AWSAppSyncClient from 'aws-appsync'\nimport { Rehydrated } from 'aws-appsync-react'\nimport { ApolloProvider } from 'react-apollo'\n\nimport './index.css';\nimport Router from './Router';\nimport config from './aws-exports'\n\nAmplify.configure(config)\n\nconst client = new AWSAppSyncClient({\n  url: config.aws_appsync_graphqlEndpoint,\n  region: config.aws_appsync_region,\n  auth: {\n    type: config.aws_appsync_authenticationType,\n    apiKey: config.aws_appsync_apiKey\n  }\n});\n\nwindow.LOG_LEVEL = \"DEBUG\"\n\nconst AppWithProvider = () => (\n  <ApolloProvider client={client}>\n    <Rehydrated\n      render={({ rehydrated }) => (\n        rehydrated ? <Router /> : <p style={{ padding: 30, color: 'white' }}>Loading...</p>\n      )}\n    />\n  </ApolloProvider>\n);\n\nReactDOM.createRoot(document.getElementById('root')).render(<AppWithProvider />);\n\n",
        "called_code_segment_file_1": "async function createDrumMachine(machine, setSteps) {\n  try {\n    await API.graphql(graphqlOperation(CreateDrumMachine, { input: machine }))\n    console.log('successfully created drum machine!')\n  } catch (err) {\n    console.log('error creating drum machine...: ', err)\n    const { errors } = err\n    const beats = errors[0].data.beats\n    setSteps(JSON.parse(beats))\n  }\n}",
        "invoking_code_segment_file_2": "useEffect(() => {\n  const machine = {\n    id: machineId,\n    clientId,\n    beats: JSON.stringify(stepState),\n    name: machineName\n  }\n  createDrumMachine(machine, setSteps)\n}, [])",
        "called_code_segment_file_2": "useEffect(() => {\n  console.log('machineId: ', machineId)\n  const subscriber = API.graphql(graphqlOperation(onUpdateByID, { id: machineId })).subscribe({\n    next: data => {\n      console.log('data:', data)\n      const { value: { data: { onUpdateByID: { clientId: ClientId, beats }}}} = data\n      if (ClientId === clientId) return\n      setSteps(JSON.parse(beats))\n    }\n  });\n  return () => subscriber.unsubscribe()\n}, []);",
        "using_code_segment_file_3": "const StepContext = React.createContext({ state: initialStepState, setSteps: () => {}, updateDrumMachine: () => {}, machineId: '' });",
        "called_code_segment_file_3": "",
        "using_code_segment_file_4": "",
        "feature_description": "Add a feature to save the current state of the drum machine to local storage.",
        "detailed_feature_description": "The new feature will save the current state of the drum machine to local storage whenever the state changes. This will be implemented by modifying the `createDrumMachine` function in #file 1 to also save the state to local storage. #file 2 will be updated to handle this new functionality, and #file 3 will be updated to ensure it can use the saved state from local storage if available.",
        "modified_complete_code": {
            "file_1": "async function createDrumMachine(machine, setSteps) {\n  try {\n    await API.graphql(graphqlOperation(CreateDrumMachine, { input: machine }))\n    console.log('successfully created drum machine!')\n    localStorage.setItem('drumMachineState', JSON.stringify(machine.beats)); #New\n  } catch (err) {\n    console.log('error creating drum machine...: ', err)\n    const { errors } = err\n    const beats = errors[0].data.beats\n    setSteps(JSON.parse(beats))\n  }\n}",
            "file_2": "useEffect(() => {\n  const machine = {\n    id: machineId,\n    clientId,\n    beats: JSON.stringify(stepState),\n    name: machineName\n  }\n  createDrumMachine(machine, setSteps)\n}, [])\n\nuseEffect(() => {\n  const savedState = localStorage.getItem('drumMachineState'); #New\n  if (savedState) {\n    setSteps(JSON.parse(savedState));\n  }\n}, []);",
            "file_3": "const StepContext = React.createContext({ state: initialStepState, setSteps: () => {}, updateDrumMachine: () => {}, machineId: '', loadState: () => {} }); #Modify\n\nconst loadState = () => {\n  const savedState = localStorage.getItem('drumMachineState');\n  if (savedState) {\n    setSteps(JSON.parse(savedState));\n  }\n}; #New",
            "file_4": ""
        }
    },
    {
        "repo": "react-flux-jwt-authentication-sample",
        "content": "'react-flux-jwt-authentication-sample/src/actions/LoginActions.js'\n:import AppDispatcher from '../dispatchers/AppDispatcher.js';\nimport {LOGIN_USER, LOGOUT_USER} from '../constants/LoginConstants.js';\nimport RouterContainer from '../services/RouterContainer'\n\nexport default {\n  loginUser: (jwt) => {\n    var savedJwt = localStorage.getItem('jwt');\n    \n    AppDispatcher.dispatch({\n      actionType: LOGIN_USER,\n      jwt: jwt\n    });\n    \n    if (savedJwt !== jwt) {\n      var nextPath = RouterContainer.get().getCurrentQuery().nextPath || '/';\n\n      RouterContainer.get().transitionTo(nextPath);\n      localStorage.setItem('jwt', jwt);\n    }\n  },\n  logoutUser: () => {\n    RouterContainer.get().transitionTo('/login');\n    localStorage.removeItem('jwt');\n    AppDispatcher.dispatch({\n      actionType: LOGOUT_USER\n    });\n  }\n}\n\n'react-flux-jwt-authentication-sample/src/services/AuthService.js'\n:import request from 'reqwest';\nimport when from 'when';\nimport {LOGIN_URL, SIGNUP_URL} from '../constants/LoginConstants';\nimport LoginActions from '../actions/LoginActions';\n\nclass AuthService {\n\n  login(username, password) {\n    return this.handleAuth(when(request({\n      url: LOGIN_URL,\n      method: 'POST',\n      crossOrigin: true,\n      type: 'json',\n      data: {\n        username, password\n      }\n    })));\n  }\n\n  logout() {\n    LoginActions.logoutUser();\n  }\n\n  signup(username, password, extra) {\n    return this.handleAuth(when(request({\n      url: SIGNUP_URL,\n      method: 'POST',\n      crossOrigin: true,\n      type: 'json',\n      data: {\n        username, password, extra\n      }\n    })));\n  }\n\n  handleAuth(loginPromise) {\n    return loginPromise\n      .then(function(response) {\n        var jwt = response.id_token;\n        LoginActions.loginUser(jwt);\n        return true;\n      });\n  }\n}\n\nexport default new AuthService()\n\n'react-flux-jwt-authentication-sample/src/components/AuthenticatedApp.jsx'\n:'use strict';\n\nimport React from 'react';\nimport LoginStore from '../stores/LoginStore'\nimport { Route, RouteHandler, Link } from 'react-router';\nimport AuthService from '../services/AuthService'\n\nexport default class AuthenticatedApp extends React.Component {\n  constructor() {\n    super()\n    this.state = this._getLoginState();\n  }\n\n  _getLoginState() {\n    return {\n      userLoggedIn: LoginStore.isLoggedIn()\n    };\n  }\n\n  componentDidMount() {\n    this.changeListener = this._onChange.bind(this);\n    LoginStore.addChangeListener(this.changeListener);\n  }\n\n  _onChange() {\n    this.setState(this._getLoginState());\n  }\n\n  componentWillUnmount() {\n    LoginStore.removeChangeListener(this.changeListener);\n  }\n\n  render() {\n    return (\n      <div className=\"container\">\n        <nav className=\"navbar navbar-default\">\n          <div className=\"navbar-header\">\n            <a className=\"navbar-brand\" href=\"/\">React Flux app with JWT authentication</a>\n          </div>\n          {this.headerItems}\n        </nav>\n        <RouteHandler/>\n      </div>\n    );\n  }\n\n  logout(e) {\n    e.preventDefault();\n    AuthService.logout();\n  }\n\n  get headerItems() {\n    if (!this.state.userLoggedIn) {\n      return (\n      <ul className=\"nav navbar-nav navbar-right\">\n        <li>\n          <Link to=\"login\">Login</Link>\n        </li>\n        <li>\n          <Link to=\"signup\">Signup</Link>\n        </li>\n      </ul>)\n    } else {\n      return (\n      <ul className=\"nav navbar-nav navbar-right\">\n        <li>\n          <Link to=\"home\">Home</Link>\n        </li>\n        <li>\n          <Link to=\"quote\">Quote</Link>\n        </li>\n        <li>\n          <a href=\"\" onClick={this.logout}>Logout</a>\n        </li>\n      </ul>)\n    }\n  }\n}\n\n'react-flux-jwt-authentication-sample/src/app.jsx'\n:import React from 'react';\nimport Router, {Route} from 'react-router';\nimport AuthenticatedApp from './components/AuthenticatedApp'\nimport Login from './components/Login';\nimport Signup from './components/Signup';\nimport Home from './components/Home';\nimport Quote from './components/Quote';\nimport RouterContainer from './services/RouterContainer';\nimport LoginActions from './actions/LoginActions';\n\nvar routes = (\n  <Route handler={AuthenticatedApp}>\n    <Route name=\"login\" handler={Login}/>\n    <Route name=\"signup\" handler={Signup}/>\n    <Route name=\"home\" path=\"/\" handler={Home}/>\n    <Route name=\"quote\" handler={Quote}/>\n  </Route>\n);\n\nvar router = Router.create({routes});\nRouterContainer.set(router);\n\nlet jwt = localStorage.getItem('jwt');\nif (jwt) {\n  LoginActions.loginUser(jwt);\n}\n\nrouter.run(function (Handler) {\n  React.render(<Handler />, document.getElementById('content'));\n});\n\n\n",
        "called_code_segment_file_1": "loginUser: (jwt) => {\n    var savedJwt = localStorage.getItem('jwt');\n    \n    AppDispatcher.dispatch({\n      actionType: LOGIN_USER,\n      jwt: jwt\n    });\n    \n    if (savedJwt !== jwt) {\n      var nextPath = RouterContainer.get().getCurrentQuery().nextPath || '/';\n\n      RouterContainer.get().transitionTo(nextPath);\n      localStorage.setItem('jwt', jwt);\n    }\n  }",
        "invoking_code_segment_file_2": "handleAuth(loginPromise) {\n    return loginPromise\n      .then(function(response) {\n        var jwt = response.id_token;\n        LoginActions.loginUser(jwt);\n        return true;\n      });\n  }",
        "called_code_segment_file_2": "logout() {\n    LoginActions.logoutUser();\n  }",
        "using_code_segment_file_3": "logout(e) {\n    e.preventDefault();\n    AuthService.logout();\n  }",
        "called_code_segment_file_3": "Not applicable",
        "using_code_segment_file_4": "Not applicable",
        "feature_description": "Add a feature to handle user session expiration and automatically redirect to the login page when the session expires.",
        "detailed_feature_description": "The new feature involves modifying the `loginUser` method in #file 1 to include a session expiration check. If the session has expired, the user will be redirected to the login page. This change will require updates in #file 2 to handle the session expiration logic and ensure that #file 3 and #file 4 are updated accordingly to reflect the new behavior.",
        "modified_complete_code": {
            "file_1": "import AppDispatcher from '../dispatchers/AppDispatcher.js';\nimport {LOGIN_USER, LOGOUT_USER} from '../constants/LoginConstants.js';\nimport RouterContainer from '../services/RouterContainer'\n\n#Modify\nloginUser: (jwt) => {\n    var savedJwt = localStorage.getItem('jwt');\n    \n    AppDispatcher.dispatch({\n      actionType: LOGIN_USER,\n      jwt: jwt\n    });\n    \n    if (savedJwt !== jwt) {\n      var nextPath = RouterContainer.get().getCurrentQuery().nextPath || '/';\n\n      RouterContainer.get().transitionTo(nextPath);\n      localStorage.setItem('jwt', jwt);\n    }\n    \n    #New\n    // Check for session expiration\n    if (isSessionExpired(jwt)) {\n      logoutUser();\n    }\n  },\n\n  logoutUser: () => {\n    RouterContainer.get().transitionTo('/login');\n    localStorage.removeItem('jwt');\n    AppDispatcher.dispatch({\n      actionType: LOGOUT_USER\n    });\n  },\n\n  #New\n  isSessionExpired: (jwt) => {\n    // Implement session expiration check logic\n    return false; // Placeholder, replace with actual logic\n  }\n",
            "file_2": "import request from 'reqwest';\nimport when from 'when';\nimport {LOGIN_URL, SIGNUP_URL} from '../constants/LoginConstants';\nimport LoginActions from '../actions/LoginActions';\n\nclass AuthService {\n\n  login(username, password) {\n    return this.handleAuth(when(request({\n      url: LOGIN_URL,\n      method: 'POST',\n      crossOrigin: true,\n      type: 'json',\n      data: { username, password }\n    })));\n  }\n\n  logout() {\n    LoginActions.logoutUser();\n  }\n\n  signup(username, password, extra) {\n    return this.handleAuth(when(request({\n      url: SIGNUP_URL,\n      method: 'POST',\n      crossOrigin: true,\n      type: 'json',\n      data: { username, password, extra }\n    })));\n  }\n\n  handleAuth(loginPromise) {\n    return loginPromise\n      .then(function(response) {\n        var jwt = response.id_token;\n        LoginActions.loginUser(jwt);\n        return true;\n      });\n  }\n}\n\nexport default new AuthService()\n",
            "file_3": "import React from 'react';\nimport LoginStore from '../stores/LoginStore'\nimport { Route, RouteHandler, Link } from 'react-router';\nimport AuthService from '../services/AuthService'\n\nexport default class AuthenticatedApp extends React.Component {\n  constructor() {\n    super()\n    this.state = this._getLoginState();\n  }\n\n  _getLoginState() {\n    return { userLoggedIn: LoginStore.isLoggedIn() };\n  }\n\n  componentDidMount() {\n    this.changeListener = this._onChange.bind(this);\n    LoginStore.addChangeListener(this.changeListener);\n  }\n\n  _onChange() {\n    this.setState(this._getLoginState());\n  }\n\n  componentWillUnmount() {\n    LoginStore.removeChangeListener(this.changeListener);\n  }\n\n  render() {\n    return (\n      <div className=\"container\">\n        <nav className=\"navbar navbar-default\">\n          <div className=\"navbar-header\">\n            <a className=\"navbar-brand\" href=\"/\">React Flux app with JWT authentication</a>\n          </div>\n          {this.headerItems}\n        </nav>\n        <RouteHandler/>\n      </div>\n    );\n  }\n\n  logout(e) {\n    e.preventDefault();\n    AuthService.logout();\n  }\n\n  get headerItems() {\n    if (!this.state.userLoggedIn) {\n      return (\n      <ul className=\"nav navbar-nav navbar-right\">\n        <li>\n          <Link to=\"login\">Login</Link>\n        </li>\n        <li>\n          <Link to=\"signup\">Signup</Link>\n        </li>\n      </ul>)\n    } else {\n      return (\n      <ul className=\"nav navbar-nav navbar-right\">\n        <li>\n          <Link to=\"home\">Home</Link>\n        </li>\n        <li>\n          <Link to=\"quote\">Quote</Link>\n        </li>\n        <li>\n          <a href=\"\" onClick={this.logout}>Logout</a>\n        </li>\n      </ul>)\n    }\n  }\n}\n",
            "file_4": "Not applicable"
        }
    },
    {
        "repo": "winston-logstash",
        "content": "'winston-logstash/lib/connection.js'\n:\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SecureConnection = exports.PlainConnection = exports.ConnectionEvents = exports.ConnectionActions = exports.Connection = void 0;\nvar _net = require(\"net\");\nvar _fs = require(\"fs\");\nvar _tls = _interopRequireDefault(require(\"tls\"));\nvar _events = require(\"events\");\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nlet ConnectionActions;\nexports.ConnectionActions = ConnectionActions;\n(function (ConnectionActions) {\n  ConnectionActions[\"Initializing\"] = \"Initializing\";\n  ConnectionActions[\"Connecting\"] = \"Connecting\";\n  ConnectionActions[\"Closing\"] = \"Closing\";\n  ConnectionActions[\"Tranferring\"] = \"Transferring\";\n  ConnectionActions[\"HandlingError\"] = \"HandlingError\";\n})(ConnectionActions || (exports.ConnectionActions = ConnectionActions = {}));\nlet ConnectionEvents;\nexports.ConnectionEvents = ConnectionEvents;\n(function (ConnectionEvents) {\n  ConnectionEvents[\"Connected\"] = \"connection:connected\";\n  ConnectionEvents[\"Closed\"] = \"connection:closed\";\n  ConnectionEvents[\"ClosedByServer\"] = \"connection:closed:by-server\";\n  ConnectionEvents[\"Error\"] = \"connection:error\";\n  ConnectionEvents[\"Timeout\"] = \"connection:timeout\";\n  ConnectionEvents[\"Drain\"] = \"connection:drain\";\n})(ConnectionEvents || (exports.ConnectionEvents = ConnectionEvents = {}));\nclass Connection extends _events.EventEmitter {\n  constructor(options) {\n    var _options$host, _options$port;\n    super();\n    _defineProperty(this, \"socket\", void 0);\n    _defineProperty(this, \"host\", void 0);\n    _defineProperty(this, \"port\", void 0);\n    _defineProperty(this, \"action\", void 0);\n    this.action = ConnectionActions.Initializing;\n    this.host = (_options$host = options === null || options === void 0 ? void 0 : options.host) !== null && _options$host !== void 0 ? _options$host : '127.0.0.1';\n    this.port = (_options$port = options === null || options === void 0 ? void 0 : options.port) !== null && _options$port !== void 0 ? _options$port : 28777;\n  }\n  socketOnError(error) {\n    this.action = ConnectionActions.HandlingError;\n    this.emit(ConnectionEvents.Error, error);\n  }\n  socketOnTimeout() {\n    var _this$socket;\n    this.action = ConnectionActions.HandlingError;\n    this.emit(ConnectionEvents.Timeout, (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.readyState);\n  }\n  socketOnConnect() {\n    var _this$socket2;\n    (_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.setKeepAlive(true, 60 * 1000);\n    this.action = ConnectionActions.Tranferring;\n    this.emit(ConnectionEvents.Connected);\n  }\n  socketOnDrain() {\n    this.emit(ConnectionEvents.Drain);\n  }\n  socketOnClose(error) {\n    if (this.action === ConnectionActions.Closing) {\n      this.emit(ConnectionEvents.Closed, error);\n    } else {\n      this.emit(ConnectionEvents.ClosedByServer, error);\n    }\n  }\n  addEventListeners(socket) {\n    socket.on('drain', this.socketOnDrain.bind(this));\n    socket.once('error', this.socketOnError.bind(this));\n    socket.once('timeout', this.socketOnTimeout.bind(this));\n    socket.once('close', this.socketOnClose.bind(this));\n  }\n  close() {\n    var _this$socket3, _this$socket4;\n    this.action = ConnectionActions.Closing;\n    (_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.removeAllListeners();\n    (_this$socket4 = this.socket) === null || _this$socket4 === void 0 ? void 0 : _this$socket4.destroy();\n    this.emit(ConnectionEvents.Closed);\n  }\n  send(message, writeCallback) {\n    var _this$socket5;\n    return ((_this$socket5 = this.socket) === null || _this$socket5 === void 0 ? void 0 : _this$socket5.write(Buffer.from(message), writeCallback)) === true;\n  }\n  readyToSend() {\n    var _this$socket6;\n    return ((_this$socket6 = this.socket) === null || _this$socket6 === void 0 ? void 0 : _this$socket6.readyState) === 'open';\n  }\n  connect() {\n    this.action = ConnectionActions.Connecting;\n  }\n}\nexports.Connection = Connection;\nclass PlainConnection extends Connection {\n  connect() {\n    super.connect();\n    try {\n      this.socket = new _net.Socket();\n      super.addEventListeners(this.socket);\n      this.socket.once('connect', super.socketOnConnect.bind(this));\n      this.socket.connect(this.port, this.host);\n    } catch (error) {\n      this.emit(ConnectionEvents.Error, error);\n    }\n  }\n}\nexports.PlainConnection = PlainConnection;\nclass SecureConnection extends Connection {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"secureContextOptions\", void 0);\n    this.secureContextOptions = SecureConnection.createSecureContextOptions(options);\n  }\n  static createSecureContextOptions(options) {\n    const sslKey = options.ssl_key;\n    const sslCert = options.ssl_cert;\n    const ca = options.ca;\n    const sslPassphrase = options.ssl_passphrase;\n    const rejectUnauthorized = options.rejectUnauthorized;\n    const secureContextOptions = {\n      key: sslKey && (0, _fs.readFileSync)(sslKey),\n      cert: sslCert && (0, _fs.readFileSync)(sslCert),\n      passphrase: sslPassphrase || undefined,\n      rejectUnauthorized: rejectUnauthorized,\n      ca: ca && (0, _fs.readFileSync)(ca)\n    };\n    return secureContextOptions;\n  }\n  connect() {\n    super.connect();\n    try {\n      this.socket = _tls.default.connect(this.port, this.host, this.secureContextOptions);\n      super.addEventListeners(this.socket);\n      this.socket.once('secureConnect', super.socketOnConnect.bind(this));\n    } catch (error) {\n      this.emit(ConnectionEvents.Error, error);\n    }\n  }\n}\nexports.SecureConnection = SecureConnection;\n'winston-logstash/lib/manager.js'\n:\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Manager = void 0;\nvar _connection = require(\"./connection\");\nvar _events = require(\"events\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nconst ECONNREFUSED_REGEXP = /ECONNREFUSED/;\nclass Manager extends _events.EventEmitter {\n  constructor(options, connection) {\n    var _options$max_connect_, _options$timeout_conn;\n    super();\n    _defineProperty(this, \"connection\", void 0);\n    _defineProperty(this, \"logQueue\", void 0);\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"retries\", -1);\n    _defineProperty(this, \"maxConnectRetries\", void 0);\n    _defineProperty(this, \"timeoutConnectRetries\", void 0);\n    _defineProperty(this, \"retryTimeout\", undefined);\n    _defineProperty(this, \"connectionCallbacks\", new Map());\n    this.options = options;\n    this.connection = connection;\n    this.logQueue = new Array();\n    this.connectionCallbacks.set(_connection.ConnectionEvents.Connected, this.onConnected.bind(this));\n    this.connectionCallbacks.set(_connection.ConnectionEvents.Closed, this.onConnectionClosed.bind(this));\n    this.connectionCallbacks.set(_connection.ConnectionEvents.ClosedByServer, this.onConnectionError.bind(this));\n    this.connectionCallbacks.set(_connection.ConnectionEvents.Error, this.onConnectionError.bind(this));\n    this.connectionCallbacks.set(_connection.ConnectionEvents.Timeout, this.onConnectionError.bind(this));\n    this.connectionCallbacks.set(_connection.ConnectionEvents.Drain, this.flush.bind(this));\n\n    // Connection retry attributes\n    this.retries = 0;\n    this.maxConnectRetries = (_options$max_connect_ = options === null || options === void 0 ? void 0 : options.max_connect_retries) !== null && _options$max_connect_ !== void 0 ? _options$max_connect_ : 4;\n    this.timeoutConnectRetries = (_options$timeout_conn = options === null || options === void 0 ? void 0 : options.timeout_connect_retries) !== null && _options$timeout_conn !== void 0 ? _options$timeout_conn : 100;\n  }\n  addEventListeners() {\n    this.connection.once(_connection.ConnectionEvents.Connected, this.connectionCallbacks.get(_connection.ConnectionEvents.Connected));\n    this.connection.once(_connection.ConnectionEvents.Closed, this.connectionCallbacks.get(_connection.ConnectionEvents.Closed));\n    this.connection.once(_connection.ConnectionEvents.ClosedByServer, this.connectionCallbacks.get(_connection.ConnectionEvents.ClosedByServer));\n    this.connection.once(_connection.ConnectionEvents.Error, this.connectionCallbacks.get(_connection.ConnectionEvents.Error));\n    this.connection.once(_connection.ConnectionEvents.Timeout, this.connectionCallbacks.get(_connection.ConnectionEvents.Timeout));\n    this.connection.on(_connection.ConnectionEvents.Drain, this.connectionCallbacks.get(_connection.ConnectionEvents.Drain));\n  }\n  removeEventListeners() {\n    this.connection.off(_connection.ConnectionEvents.Connected, this.connectionCallbacks.get(_connection.ConnectionEvents.Connected));\n    this.connection.off(_connection.ConnectionEvents.Closed, this.connectionCallbacks.get(_connection.ConnectionEvents.Closed));\n    this.connection.off(_connection.ConnectionEvents.ClosedByServer, this.connectionCallbacks.get(_connection.ConnectionEvents.ClosedByServer));\n    this.connection.off(_connection.ConnectionEvents.Error, this.connectionCallbacks.get(_connection.ConnectionEvents.Error));\n    this.connection.off(_connection.ConnectionEvents.Timeout, this.connectionCallbacks.get(_connection.ConnectionEvents.Timeout));\n    this.connection.off(_connection.ConnectionEvents.Drain, this.connectionCallbacks.get(_connection.ConnectionEvents.Drain));\n  }\n  onConnected() {\n    this.emit('connected');\n    this.retries = 0;\n    this.flush();\n  }\n  onConnectionClosed(error) {\n    this.emit('closed');\n    this.removeEventListeners();\n  }\n  isRetryableError(error) {\n    // TODO: Due bug in the orginal implementation\n    //       all the errors will get retried\n    return true; // !ECONNREFUSED_REGEXP.test(error.message);\n  }\n\n  shouldTryToReconnect(error) {\n    if (this.isRetryableError(error) === true) {\n      if (this.maxConnectRetries < 0 || this.retries < this.maxConnectRetries) {\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  }\n  onConnectionError(error) {\n    if (this.shouldTryToReconnect(error)) {\n      this.retry();\n    } else {\n      var _this$connection;\n      this.removeEventListeners();\n      (_this$connection = this.connection) === null || _this$connection === void 0 ? void 0 : _this$connection.close();\n      this.emit('error', new Error('Max retries reached, transport in silent mode, OFFLINE'));\n    }\n  }\n  retry() {\n    if (this.retryTimeout) {\n      clearTimeout(this.retryTimeout);\n    }\n    this.emit('retrying');\n    this.removeEventListeners();\n    const self = this;\n    this.connection.once(_connection.ConnectionEvents.Closed, () => {\n      self.removeEventListeners();\n      self.retryTimeout = setTimeout(() => {\n        self.start();\n      }, self.timeoutConnectRetries);\n    });\n    this.connection.close();\n  }\n  setConnection(connection) {\n    this.connection = connection;\n  }\n  start() {\n    this.retries++;\n    this.addEventListeners();\n    this.connection.connect();\n  }\n  log(entry, callback) {\n    this.logQueue.push([entry, callback]);\n    process.nextTick(this.flush.bind(this));\n  }\n  close() {\n    var _this$connection2;\n    this.emit('closing');\n    this.flush();\n    this.removeEventListeners();\n    (_this$connection2 = this.connection) === null || _this$connection2 === void 0 ? void 0 : _this$connection2.close();\n  }\n  flush() {\n    this.emit('flushing');\n    let connectionIsDrained = true;\n    while (this.logQueue.length && connectionIsDrained && (_this$connection3 = this.connection) !== null && _this$connection3 !== void 0 && _this$connection3.readyToSend()) {\n      var _this$connection3;\n      const logEntry = this.logQueue.shift();\n      if (logEntry) {\n        const [entry, callback] = logEntry;\n        const self = this;\n        connectionIsDrained = this.connection.send(entry + '\\n', error => {\n          if (error) {\n            self.logQueue.unshift(logEntry);\n          } else {\n            callback();\n          }\n        });\n      }\n    }\n  }\n}\nexports.Manager = Manager;\n;\n'winston-logstash/lib/winston-logstash.js'\n:\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Logstash = void 0;\nvar _winston = require(\"winston\");\nvar _manager = require(\"./manager\");\nvar _connection = require(\"./connection\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nconst common = require('winston/lib/winston/common');\nclass Logstash extends _winston.Transport {\n  constructor(options) {\n    super(options);\n    _defineProperty(this, \"node_name\", void 0);\n    _defineProperty(this, \"json\", true);\n    _defineProperty(this, \"label\", void 0);\n    _defineProperty(this, \"meta_defaults\", void 0);\n    _defineProperty(this, \"manager\", void 0);\n    _defineProperty(this, \"connection\", void 0);\n    this.name = 'logstash';\n    this.node_name = options.node_name || process.title;\n\n    // Miscellaneous options\n    this.label = options.label || this.node_name;\n    this.meta_defaults = Object.assign({}, options.meta);\n    this.connection = options.ssl_enable ? new _connection.SecureConnection(options) : new _connection.PlainConnection(options);\n    this.manager = new _manager.Manager(options, this.connection);\n    this.manager.on('error', this.onError.bind(this));\n    this.manager.start();\n  }\n  log(level, msg, meta, callback) {\n    if (this.silent) {\n      return callback(null, true);\n    }\n    const logEntry = this.defaultTransform(level, msg, Object.assign({}, meta, this.meta_defaults));\n    this.manager.log(logEntry, () => {\n      callback(null, true);\n    });\n    this.emit('logged');\n  }\n  onError(error) {\n    this.silent = true;\n    this.emit('error', error);\n  }\n  close() {\n    this.manager.close();\n  }\n  defaultTransform(level, msg, meta) {\n    return common.log({\n      level: level,\n      message: msg,\n      meta: meta,\n      json: this.json,\n      label: this.label,\n      humanReadableUnhandledException: this.humanReadableUnhandledException\n    });\n  }\n}\nexports.Logstash = Logstash;\n'winston-logstash/test-bench/winston-2x/test/on_error_test.js'\n:\nconst winston = require('winston');\nconst transports = require('../../../lib/winston-logstash');\n\ndescribe('Ensure error is handled correctly', () => {\n  it('add error eventhandler for logger', (done) => {\n    const logstashTransport = new transports.Logstash({\n      max_connect_retries: 2,\n      port: 7878,\n      node_name: 'my node name',\n      host: 'localhost',\n      ssl_enable: true,\n      ca: __dirname + '/../../../test/support/ssl/ca.cert',\n      ssl_key: __dirname + '/../../../test/support/ssl/client.key',\n      ssl_cert: __dirname + '/../../../test/support/ssl/client.cert',\n    });\n    const logger = new (winston.Logger)({\n      transports: [\n        logstashTransport,\n      ],\n    });\n\n    logstashTransport.on('error', (error) => {\n      expect(error).toBeInstanceOf(Error);\n      expect(error.message)\n          .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n      done();\n    });\n    logger.log('info', 'random message');\n  });\n});\n\n",
        "called_code_segment_file_1": "class SecureConnection extends Connection {\n  constructor(options) {\n    super(options);\n    this.secureContextOptions = SecureConnection.createSecureContextOptions(options);\n  }\n  static createSecureContextOptions(options) {\n    const sslKey = options.ssl_key;\n    const sslCert = options.ssl_cert;\n    const ca = options.ca;\n    const sslPassphrase = options.ssl_passphrase;\n    const rejectUnauthorized = options.rejectUnauthorized;\n    const secureContextOptions = {\n      key: sslKey && fs.readFileSync(sslKey),\n      cert: sslCert && fs.readFileSync(sslCert),\n      passphrase: sslPassphrase || undefined,\n      rejectUnauthorized: rejectUnauthorized,\n      ca: ca && fs.readFileSync(ca)\n    };\n    return secureContextOptions;\n  }\n  connect() {\n    super.connect();\n    try {\n      this.socket = tls.connect(this.port, this.host, this.secureContextOptions);\n      super.addEventListeners(this.socket);\n      this.socket.once('secureConnect', super.socketOnConnect.bind(this));\n    } catch (error) {\n      this.emit(ConnectionEvents.Error, error);\n    }\n  }\n}",
        "invoking_code_segment_file_2": "class Logstash extends Transport {\n  constructor(options) {\n    super(options);\n    this.name = 'logstash';\n    this.node_name = options.node_name || process.title;\n    this.label = options.label || this.node_name;\n    this.meta_defaults = Object.assign({}, options.meta);\n    this.connection = options.ssl_enable ? new SecureConnection(options) : new PlainConnection(options);\n    this.manager = new Manager(options, this.connection);\n    this.manager.on('error', this.onError.bind(this));\n    this.manager.start();\n  }\n}",
        "called_code_segment_file_2": "log(level, msg, meta, callback) {\n  if (this.silent) {\n    return callback(null, true);\n  }\n  const logEntry = this.defaultTransform(level, msg, Object.assign({}, meta, this.meta_defaults));\n  this.manager.log(logEntry, () => {\n    callback(null, true);\n  });\n  this.emit('logged');\n}",
        "using_code_segment_file_3": "const logstashTransport = new transports.Logstash({\n  max_connect_retries: 2,\n  port: 7878,\n  node_name: 'my node name',\n  host: 'localhost',\n  ssl_enable: true,\n  ca: __dirname + '/../../../test/support/ssl/ca.cert',\n  ssl_key: __dirname + '/../../../test/support/ssl/client.key',\n  ssl_cert: __dirname + '/../../../test/support/ssl/client.cert',\n});\nconst logger = new (winston.Logger)({\n  transports: [\n    logstashTransport,\n  ],\n});\nlogstashTransport.on('error', (error) => {\n  expect(error).toBeInstanceOf(Error);\n  expect(error.message)\n      .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n  done();\n});\nlogger.log('info', 'random message');",
        "called_code_segment_file_3": "",
        "using_code_segment_file_4": "",
        "feature_description": "Add a retry mechanism with exponential backoff for connection retries in SecureConnection.",
        "detailed_feature_description": "Modify the SecureConnection class in #file 1 to include an exponential backoff mechanism for connection retries. Update the Logstash class in #file 2 to handle the new retry logic. Ensure that the test in #file 3 is updated to reflect the new behavior.",
        "modified_complete_code": {
            "file_1": "class SecureConnection extends Connection {\n  constructor(options) {\n    super(options);\n    this.secureContextOptions = SecureConnection.createSecureContextOptions(options);\n    this.retryCount = 0;\n    this.maxRetries = options.max_connect_retries || 4;\n    this.retryDelay = options.retry_delay || 100;\n  }\n  static createSecureContextOptions(options) {\n    const sslKey = options.ssl_key;\n    const sslCert = options.ssl_cert;\n    const ca = options.ca;\n    const sslPassphrase = options.ssl_passphrase;\n    const rejectUnauthorized = options.rejectUnauthorized;\n    const secureContextOptions = {\n      key: sslKey && fs.readFileSync(sslKey),\n      cert: sslCert && fs.readFileSync(sslCert),\n      passphrase: sslPassphrase || undefined,\n      rejectUnauthorized: rejectUnauthorized,\n      ca: ca && fs.readFileSync(ca)\n    };\n    return secureContextOptions;\n  }\n  connect() {\n    super.connect();\n    try {\n      this.socket = tls.connect(this.port, this.host, this.secureContextOptions);\n      super.addEventListeners(this.socket);\n      this.socket.once('secureConnect', super.socketOnConnect.bind(this));\n    } catch (error) {\n      if (this.retryCount < this.maxRetries) {\n        this.retryCount++;\n        setTimeout(() => this.connect(), this.retryDelay * Math.pow(2, this.retryCount));\n      } else {\n        this.emit(ConnectionEvents.Error, error);\n      }\n    }\n  }\n}",
            "file_2": "class Logstash extends Transport {\n  constructor(options) {\n    super(options);\n    this.name = 'logstash';\n    this.node_name = options.node_name || process.title;\n    this.label = options.label || this.node_name;\n    this.meta_defaults = Object.assign({}, options.meta);\n    this.connection = options.ssl_enable ? new SecureConnection(options) : new PlainConnection(options);\n    this.manager = new Manager(options, this.connection);\n    this.manager.on('error', this.onError.bind(this));\n    this.manager.start();\n  }\n  log(level, msg, meta, callback) {\n    if (this.silent) {\n      return callback(null, true);\n    }\n    const logEntry = this.defaultTransform(level, msg, Object.assign({}, meta, this.meta_defaults));\n    this.manager.log(logEntry, () => {\n      callback(null, true);\n    });\n    this.emit('logged');\n  }\n}",
            "file_3": "const logstashTransport = new transports.Logstash({\n  max_connect_retries: 2,\n  retry_delay: 100,\n  port: 7878,\n  node_name: 'my node name',\n  host: 'localhost',\n  ssl_enable: true,\n  ca: __dirname + '/../../../test/support/ssl/ca.cert',\n  ssl_key: __dirname + '/../../../test/support/ssl/client.key',\n  ssl_cert: __dirname + '/../../../test/support/ssl/client.cert',\n});\nconst logger = new (winston.Logger)({\n  transports: [\n    logstashTransport,\n  ],\n});\nlogstashTransport.on('error', (error) => {\n  expect(error).toBeInstanceOf(Error);\n  expect(error.message)\n      .toMatch('Max retries reached, transport in silent mode, OFFLINE');\n  done();\n});\nlogger.log('info', 'random message');",
            "file_4": ""
        }
    },
    {
        "repo": "react-modal",
        "content": "'react-modal/src/helpers/ariaAppHider.js'\n:import warning from \"warning\";\nimport { canUseDOM } from \"./safeHTMLElement\";\n\nlet globalElement = null;\n\n/* eslint-disable no-console */\n/* istanbul ignore next */\nexport function resetState() {\n  if (globalElement) {\n    if (globalElement.removeAttribute) {\n      globalElement.removeAttribute(\"aria-hidden\");\n    } else if (globalElement.length != null) {\n      globalElement.forEach(element => element.removeAttribute(\"aria-hidden\"));\n    } else {\n      document\n        .querySelectorAll(globalElement)\n        .forEach(element => element.removeAttribute(\"aria-hidden\"));\n    }\n  }\n  globalElement = null;\n}\n\n/* istanbul ignore next */\nexport function log() {\n  if (process.env.NODE_ENV !== \"production\") {\n    var check = globalElement || {};\n    console.log(\"ariaAppHider ----------\");\n    console.log(check.nodeName, check.className, check.id);\n    console.log(\"end ariaAppHider ----------\");\n  }\n}\n/* eslint-enable no-console */\n\nexport function assertNodeList(nodeList, selector) {\n  if (!nodeList || !nodeList.length) {\n    throw new Error(\n      `react-modal: No elements were found for selector ${selector}.`\n    );\n  }\n}\n\nexport function setElement(element) {\n  let useElement = element;\n  if (typeof useElement === \"string\" && canUseDOM) {\n    const el = document.querySelectorAll(useElement);\n    assertNodeList(el, useElement);\n    useElement = el;\n  }\n  globalElement = useElement || globalElement;\n  return globalElement;\n}\n\nexport function validateElement(appElement) {\n  const el = appElement || globalElement;\n  if (el) {\n    return Array.isArray(el) ||\n      el instanceof HTMLCollection ||\n      el instanceof NodeList\n      ? el\n      : [el];\n  } else {\n    warning(\n      false,\n      [\n        \"react-modal: App element is not defined.\",\n        \"Please use `Modal.setAppElement(el)` or set `appElement={el}`.\",\n        \"This is needed so screen readers don't see main content\",\n        \"when modal is opened. It is not recommended, but you can opt-out\",\n        \"by setting `ariaHideApp={false}`.\"\n      ].join(\" \")\n    );\n\n    return [];\n  }\n}\n\nexport function hide(appElement) {\n  for (let el of validateElement(appElement)) {\n    el.setAttribute(\"aria-hidden\", \"true\");\n  }\n}\n\nexport function show(appElement) {\n  for (let el of validateElement(appElement)) {\n    el.removeAttribute(\"aria-hidden\");\n  }\n}\n\nexport function documentNotReadyOrSSRTesting() {\n  globalElement = null;\n}\n\n'react-modal/specs/helper.js'\n:import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport Modal, { bodyOpenClassName } from \"../src/components/Modal\";\nimport TestUtils from \"react-dom/test-utils\";\nimport { log as classListLog } from \"../src/helpers/classList\";\nimport { log as focusManagerLog } from \"../src/helpers/focusManager\";\nimport { log as ariaAppLog } from \"../src/helpers/ariaAppHider\";\nimport { log as bodyTrapLog } from \"../src/helpers/bodyTrap\";\nimport { log as portalInstancesLog } from \"../src/helpers/portalOpenInstances\";\n\nconst debug = false;\n\nlet i = 0;\n\n/**\n * This log is used to see if there are leaks in between tests.\n */\nexport function log(label, spaces) {\n  if (!debug) return;\n\n  console.log(`${label} -----------------`);\n  console.log(document.body.children.length);\n  const logChildren = c => console.log(c.nodeName, c.className, c.id);\n  document.body.children.forEach(logChildren);\n\n  ariaAppLog();\n  bodyTrapLog();\n  classListLog();\n  focusManagerLog();\n  portalInstancesLog();\n\n  console.log(`end ${label} -----------------` + (!spaces ? '' : `\n\n\n`));\n}\n\nlet elementPool = [];\n\n/**\n * Every HTMLElement must be requested using this function...\n * and inside `withElementCollector`.\n */\nexport function createHTMLElement(name) {\n  const e = document.createElement(name);\n  elementPool[elementPool.length - 1].push(e);\n  e.className = `element_pool_${name}-${++i}`;\n  return e;\n}\n\n/**\n * Remove every element from its parent and release the pool.\n */\nexport function drainPool(pool) {\n  pool.forEach(e => e.parentNode && e.parentNode.removeChild(e));\n}\n\n/**\n * Every HTMLElement must be requested inside this function...\n * The reason is that it provides a mechanism that disposes\n * all the elements (built with `createHTMLElement`) after a test.\n */\nexport function withElementCollector(work) {\n  let r;\n  let poolIndex = elementPool.length;\n  elementPool[poolIndex] = [];\n  try {\n    r = work();\n  } finally {\n    drainPool(elementPool[poolIndex]);\n    elementPool = elementPool.slice(\n      0, poolIndex\n    );\n  }\n  return r;\n}\n\n/**\n * Polyfill for String.includes on some node versions.\n */\nif (!String.prototype.includes) {\n  String.prototype.includes = function(search, start) {\n    if (typeof start !== \"number\") {\n      start = 0;\n    }\n\n    if (start + search.length > this.length) {\n      return false;\n    }\n\n    return this.indexOf(search, start) !== -1;\n  };\n}\n\n/**\n * Return the class list object from `document.body`.\n * @return {Array}\n */\nexport const documentClassList = () => document.body.classList;\n\n/**\n * Check if the document.body contains the react modal\n * open class.\n * @return {Boolean}\n */\nexport const isDocumentWithReactModalOpenClass = (\n  bodyClass = bodyOpenClassName\n) => document.body.className.includes(bodyClass);\n\n/**\n * Return the class list object from <html />.\n * @return {Array}\n */\nexport const htmlClassList = () =>\n  document.getElementsByTagName(\"html\")[0].classList;\n\n/**\n * Check if the html contains the react modal\n * open class.\n * @return {Boolean}\n */\nexport const isHtmlWithReactModalOpenClass = htmlClass =>\n  htmlClassList().contains(htmlClass);\n\n/**\n * Returns a rendered dom element by class.\n * @param {React} element A react instance.\n * @param {String}     className A class to find.\n * @return {DOMElement}\n */\nexport const findDOMWithClass = TestUtils.findRenderedDOMComponentWithClass;\n\n/**\n * Returns an attribut of a rendered react tree.\n * @param {React} component A react instance.\n * @return {String}\n */\nconst getModalAttribute = component => (instance, attr) =>\n  modalComponent(component)(instance).getAttribute(attr);\n\n/**\n * Return an element from a react component.\n * @param {React} A react instance.\n * @return {DOMElement}\n */\nconst modalComponent = component => instance => instance.portal[component];\n\n/**\n * Returns the modal content.\n * @param {Modal} modal Modal instance.\n * @return {DOMElement}\n */\nexport const mcontent = modalComponent(\"content\");\n\n/**\n * Returns the modal overlay.\n * @param {Modal} modal Modal instance.\n * @return {DOMElement}\n */\nexport const moverlay = modalComponent(\"overlay\");\n\n/**\n * Return an attribute of modal content.\n * @param {Modal} modal Modal instance.\n * @return {String}\n */\nexport const contentAttribute = getModalAttribute(\"content\");\n\n/**\n * Return an attribute of modal overlay.\n * @param {Modal} modal Modal instance.\n * @return {String}\n */\nexport const overlayAttribute = getModalAttribute(\"overlay\");\n\nconst Simulate = TestUtils.Simulate;\n\nconst dispatchMockEvent = eventCtor => (key, code) => (element, opts) =>\n  eventCtor(\n    element,\n    Object.assign(\n      {},\n      {\n        key: key,\n        which: code\n      },\n      code,\n      opts\n    )\n  );\n\nconst dispatchMockKeyDownEvent = dispatchMockEvent(Simulate.keyDown);\n\n/**\n * @deprecated will be replaced by `escKeyDownWithCode` when `react-modal`\n * drops support for React <18.\n *\n * Dispatch an 'esc' key down event using the legacy KeyboardEvent.keyCode.\n */\nexport const escKeyDown = dispatchMockKeyDownEvent(\"ESC\", { keyCode: 27 });\n/**\n * Dispatch an 'esc' key down event.\n */\nexport const escKeyDownWithCode = dispatchMockKeyDownEvent(\"ESC\", {\n  code: \"Escape\"\n});\n/**\n * @deprecated will be replaced by `escKeyDownWithCode` when `react-modal`\n * drops support for React <18.\n *\n * Dispatch a 'tab' key down event using the legacy KeyboardEvent.keyCode.\n */\nexport const tabKeyDown = dispatchMockKeyDownEvent(\"TAB\", { keyCode: 9 });\n/**\n * Dispatch a 'tab' key down event.\n */\nexport const tabKeyDownWithCode = dispatchMockKeyDownEvent(\"TAB\", {\n  code: \"Tab\"\n});\n/**\n * Dispatch a 'click' event at a node.\n */\nexport const clickAt = Simulate.click;\n/**\n * Dispatch a 'mouse up' event at a node.\n */\nexport const mouseUpAt = Simulate.mouseUp;\n/**\n * Dispatch a 'mouse down' event at a node.\n */\nexport const mouseDownAt = Simulate.mouseDown;\n\nexport const noop = () => {};\n\n/**\n * Request a managed modal to run the tests on.\n *\n */\nexport const withModal = function(props, children, test = noop) {\n  return withElementCollector(() => {\n    const node = createHTMLElement();\n    const modalProps = { ariaHideApp: false, ...props };\n    let modal;\n    try {\n      ReactDOM.render(\n        <Modal ref={m => (modal = m)} {...modalProps}>\n          {children}\n        </Modal>,\n        node\n      );\n      test(modal);\n    } finally {\n      ReactDOM.unmountComponentAtNode(node);\n    }\n  });\n};\n\n'react-modal/specs/Modal.style.spec.js'\n:/* eslint-env mocha */\nimport \"should\";\nimport Modal from \"react-modal\";\nimport { mcontent, moverlay, withModal } from \"./helper\";\n\nexport default () => {\n  it(\"overrides the default styles when a custom classname is used\", () => {\n    const props = { isOpen: true, className: \"myClass\" }; \n    withModal(props, null, modal => {\n      mcontent(modal).style.top.should.be.eql(\"\");\n    });\n  });\n\n  it(\"overrides the default styles when using custom overlayClassName\", () => {\n    const overlayClassName = \"myOverlayClass\";\n    const props = { isOpen: true, overlayClassName }; \n    withModal(props, null, modal => {\n      moverlay(modal).style.backgroundColor.should.be.eql(\"\");\n    });\n  });\n\n  it(\"supports adding style to the modal contents\", () => {\n    const style = { content: { width: \"20px\" } };\n    const props = { isOpen: true, style }; \n    withModal(props, null, modal => {\n      mcontent(modal).style.width.should.be.eql(\"20px\");\n    });\n  });\n\n  it(\"supports overriding style on the modal contents\", () => {\n    const style = { content: { position: \"static\" } };\n    const props = { isOpen: true, style }; \n    withModal(props, null, modal => {\n      mcontent(modal).style.position.should.be.eql(\"static\");\n    });\n  });\n\n  it(\"supports adding style on the modal overlay\", () => {\n    const style = { overlay: { width: \"75px\" } };\n    const props = { isOpen: true, style }; \n    withModal(props, null, modal => {\n      moverlay(modal).style.width.should.be.eql(\"75px\");\n    });\n  });\n\n  it(\"supports overriding style on the modal overlay\", () => {\n    const style = { overlay: { position: \"static\" } };\n    const props = { isOpen: true, style }; \n    withModal(props, null, modal => {\n      moverlay(modal).style.position.should.be.eql(\"static\");\n    });\n  });\n\n  it(\"supports overriding the default styles\", () => {\n    const previousStyle = Modal.defaultStyles.content.position;\n    // Just in case the default style is already relative,\n    // check that we can change it\n    const newStyle = previousStyle === \"relative\" ? \"static\" : \"relative\";\n    Modal.defaultStyles.content.position = newStyle;\n    const props = { isOpen: true }; \n    withModal(props, null, modal => {\n      modal.portal.content.style.position.should.be.eql(newStyle);\n      Modal.defaultStyles.content.position = previousStyle;\n    });\n  });\n};\n\n'react-modal/specs/index.js'\n:/* eslint-env mocha */\n\nimport ModalState from \"./Modal.spec\";\nimport ModalEvents from \"./Modal.events.spec\";\nimport ModalStyle from \"./Modal.style.spec\";\nimport ModalHelpers from \"./Modal.helpers.spec\";\nimport ModalTestability from \"./Modal.testability.spec\";\n\ndescribe(\"State\", ModalState);\ndescribe(\"Style\", ModalStyle);\ndescribe(\"Events\", ModalEvents);\ndescribe(\"Helpers\", ModalHelpers);\ndescribe(\"Testability\", ModalTestability);\n\n",
        "called_code_segment_file_1": "export function hide(appElement) {\n  for (let el of validateElement(appElement)) {\n    el.setAttribute('aria-hidden', 'true');\n  }\n}",
        "invoking_code_segment_file_2": "export function documentNotReadyOrSSRTesting() {\n  globalElement = null;\n}",
        "called_code_segment_file_2": "export function resetState() {\n  if (globalElement) {\n    if (globalElement.removeAttribute) {\n      globalElement.removeAttribute('aria-hidden');\n    } else if (globalElement.length != null) {\n      globalElement.forEach(element => element.removeAttribute('aria-hidden'));\n    } else {\n      document\n        .querySelectorAll(globalElement)\n        .forEach(element => element.removeAttribute('aria-hidden'));\n    }\n  }\n  globalElement = null;\n}",
        "using_code_segment_file_3": "export function withModal(props, children, test = noop) {\n  return withElementCollector(() => {\n    const node = createHTMLElement();\n    const modalProps = { ariaHideApp: false, ...props };\n    let modal;\n    try {\n      ReactDOM.render(\n        <Modal ref={m => (modal = m)} {...modalProps}>\n          {children}\n        </Modal>,\n        node\n      );\n      test(modal);\n    } finally {\n      ReactDOM.unmountComponentAtNode(node);\n    }\n  });\n}",
        "called_code_segment_file_3": "export function log(label, spaces) {\n  if (!debug) return;\n\n  console.log(`${label} -----------------`);\n  console.log(document.body.children.length);\n  const logChildren = c => console.log(c.nodeName, c.className, c.id);\n  document.body.children.forEach(logChildren);\n\n  ariaAppLog();\n  bodyTrapLog();\n  classListLog();\n  focusManagerLog();\n  portalInstancesLog();\n\n  console.log(`end ${label} -----------------` + (!spaces ? '' : `\\n\\n\\n`));\n}",
        "using_code_segment_file_4": "describe('State', ModalState);\ndescribe('Style', ModalStyle);\ndescribe('Events', ModalEvents);\ndescribe('Helpers', ModalHelpers);\ndescribe('Testability', ModalTestability);",
        "feature_description": "Add a new feature to log the state of the modal before and after it is rendered.",
        "detailed_feature_description": "The new feature involves modifying the `withModal` function in #file 3 to log the state of the modal before and after it is rendered. This requires updating the `withModal` function to call the `log` function before and after rendering the modal. Additionally, the `log` function in #file 3 will be updated to include a new parameter for logging the modal state. The `log` function in #file 3 will also be invoked by the `withModal` function in #file 3, which will be updated to handle the new logging functionality.",
        "modified_complete_code": {
            "file_1": "export function hide(appElement) {\n  for (let el of validateElement(appElement)) {\n    el.setAttribute('aria-hidden', 'true');\n  }\n}",
            "file_2": "export function documentNotReadyOrSSRTesting() {\n  globalElement = null;\n}\n\nexport function resetState() {\n  if (globalElement) {\n    if (globalElement.removeAttribute) {\n      globalElement.removeAttribute('aria-hidden');\n    } else if (globalElement.length != null) {\n      globalElement.forEach(element => element.removeAttribute('aria-hidden'));\n    } else {\n      document\n        .querySelectorAll(globalElement)\n        .forEach(element => element.removeAttribute('aria-hidden'));\n    }\n  }\n  globalElement = null;\n}",
            "file_3": "export function withModal(props, children, test = noop) {\n  return withElementCollector(() => {\n    const node = createHTMLElement();\n    const modalProps = { ariaHideApp: false, ...props };\n    let modal;\n    try {\n      log('Before rendering modal'); #Modify\n      ReactDOM.render(\n        <Modal ref={m => (modal = m)} {...modalProps}>\n          {children}\n        </Modal>,\n        node\n      );\n      log('After rendering modal'); #Modify\n      test(modal);\n    } finally {\n      ReactDOM.unmountComponentAtNode(node);\n    }\n  });\n}\n\nexport function log(label, spaces) {\n  if (!debug) return;\n\n  console.log(`${label} -----------------`);\n  console.log(document.body.children.length);\n  const logChildren = c => console.log(c.nodeName, c.className, c.id);\n  document.body.children.forEach(logChildren);\n\n  ariaAppLog();\n  bodyTrapLog();\n  classListLog();\n  focusManagerLog();\n  portalInstancesLog();\n\n  console.log(`end ${label} -----------------` + (!spaces ? '' : `\\n\\n\\n`));\n}",
            "file_4": "describe('State', ModalState);\ndescribe('Style', ModalStyle);\ndescribe('Events', ModalEvents);\ndescribe('Helpers', ModalHelpers);\ndescribe('Testability', ModalTestability);"
        }
    },
    {
        "repo": "reddit-clone",
        "content": "'reddit-clone/frontend/src/reducers/auth.js'\n:import { loadState } from '../localStorage';\n\n\n\nconst initialState = loadState('authState') || {};\n\n\n\nconst authReducer = (state = initialState, action) => {\n\n  switch (action.type) {\n\n    case 'LOGIN':\n\n      const { user, token } = action;\n\n      return { user, token };\n\n    case 'LOGOUT':\n\n      return {};\n\n    default:\n\n      return state;\n\n  }\n\n};\n\n\n\nexport default authReducer;\n\n\n'reddit-clone/frontend/src/store/configureStore.js'\n:import { createStore, combineReducers, applyMiddleware, compose } from 'redux';\n\nimport thunk from 'redux-thunk';\n\nimport authReducer from '../reducers/auth';\n\nimport loadingReducer from '../reducers/loading';\n\nimport errorReducer from '../reducers/error';\n\nimport postReducer from '../reducers/post';\n\nimport postListReducer from '../reducers/postList';\n\nimport commentsReducer from '../reducers/comments';\n\nimport { saveState } from '../localStorage';\n\nimport subredditsReducer from '../reducers/subreddits';\n\n\n\nconst composeEnhancers =\n\n  (typeof window !== 'undefined' &&\n\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__) ||\n\n  compose;\n\n\n\nconst configureStore = () => {\n\n  const rootReducer = combineReducers({\n\n    auth: authReducer,\n\n    loading: loadingReducer,\n\n    error: errorReducer,\n\n    post: postReducer,\n\n    postList: postListReducer,\n\n    comments: commentsReducer,\n\n    subreddits: subredditsReducer,\n\n  });\n\n\n\n  const store = createStore(\n\n    rootReducer,\n\n    composeEnhancers(applyMiddleware(thunk))\n\n  );\n\n\n\n  store.subscribe(() => {\n\n    saveState(store.getState().auth, 'authState');\n\n  });\n\n\n\n  return store;\n\n};\n\n\n\nconst store = configureStore();\n\n\n\nexport default store;\n\n\n'reddit-clone/frontend/src/axios-config.js'\n:import axios from 'axios';\n\nimport store from './store/configureStore';\n\nimport { tokenSelector } from './selectors';\n\n\n\nconst instance = axios.create({\n\n  baseURL: process.env.REACT_APP_BACKEND_URL,\n\n});\n\n\n\ninstance.interceptors.request.use((config) => {\n\n  const token = tokenSelector(store.getState());\n\n  config.headers.Authorization = token;\n\n  return config;\n\n});\n\n\n\nexport default instance;\n\n\n'reddit-clone/frontend/src/actions/index.js'\n:import axios from '../axios-config';\n\nimport { setPost, editPost, deletePost } from './post';\n\nimport { setComments, updateComment, deleteComment } from './comments';\n\nimport { postListSelector, commentsSelector, postSelector } from '../selectors';\n\n\n\nexport const getPostAndComments = (id) => async (dispatch) => {\n\n  try {\n\n    dispatch({ type: 'GET_POST_AND_COMMENTS_REQUEST' });\n\n    const response = await axios.get(`/comments/${id}`);\n\n    dispatch(setPost(response.data.post));\n\n    dispatch(setComments(response.data.comments));\n\n    dispatch({ type: 'GET_POST_AND_COMMENTS_SUCCESS' });\n\n  } catch (e) {\n\n    dispatch({ type: 'GET_POST_AND_COMMENTS_FAILURE', message: e.message });\n\n  }\n\n};\n\n\n\nexport const startEditPost = ({ id, body }) => async (dispatch) => {\n\n  try {\n\n    dispatch({ type: 'EDIT_POST_REQUEST' });\n\n    await axios.put(`/posts/${id}`, { body });\n\n    dispatch(editPost(id, { body }));\n\n\n\n    dispatch({ type: 'EDIT_POST_SUCCESS' });\n\n  } catch (e) {\n\n    dispatch({\n\n      type: 'EDIT_POST_FAILURE',\n\n      message: e.message,\n\n      response: e.response,\n\n    });\n\n  }\n\n};\n\n\n\nexport const startDeletePost = (id) => async (dispatch) => {\n\n  try {\n\n    dispatch({ type: 'DELETE_POST_REQUEST' });\n\n    await axios.delete(`/posts/${id}`);\n\n    dispatch(deletePost(id));\n\n    dispatch({ type: 'DELETE_POST_SUCCESS' });\n\n  } catch (e) {\n\n    dispatch({\n\n      type: 'DELETE_POST_FAILURE',\n\n      message: e.message,\n\n      response: e.response,\n\n    });\n\n  }\n\n};\n\n\n\nexport const startEditComment = ({ id, body }) => async (dispatch) => {\n\n  try {\n\n    dispatch({ type: 'EDIT_COMMENT_REQUEST' });\n\n    await axios.put(`/comments/${id}`, { body });\n\n    dispatch(updateComment(id, { body }));\n\n    dispatch({ type: 'EDIT_COMMENT_SUCCESS' });\n\n  } catch (e) {\n\n    dispatch({\n\n      type: 'EDIT_COMMENT_FAILURE',\n\n      message: e.message,\n\n      response: e.response,\n\n    });\n\n  }\n\n};\n\n\n\nexport const startDeleteComment = (id) => async (dispatch) => {\n\n  try {\n\n    dispatch({ type: 'DELETE_COMMENT_REQUEST' });\n\n    await axios.delete(`/comments/${id}`);\n\n    dispatch(deleteComment(id));\n\n    dispatch({ type: 'DELETE_COMMENT_SUCCESS' });\n\n  } catch (e) {\n\n    dispatch({\n\n      type: 'DELETE_COMMENT_FAILURE',\n\n      message: e.message,\n\n      response: e.response,\n\n    });\n\n  }\n\n};\n\n\n\nexport const submitVote = ({ type, id, voteValue, newNumVotes }) => async (\n\n  dispatch,\n\n  getState\n\n) => {\n\n  if (!['post', 'comment'].includes(type)) {\n\n    throw new Error('You can only submit votes for posts and comments');\n\n  }\n\n\n\n  if (type === 'post') {\n\n    const changePostVotes = ({ has_voted, votes }) => {\n\n      const newPostDetails = { has_voted, votes };\n\n      const { has_voted: originalVoteValue, votes: originalNumVotes } =\n\n        postListSelector(getState()).find((post) => post.id === id) ||\n\n        postSelector(getState());\n\n      dispatch(editPost(id, newPostDetails));\n\n      return { originalVoteValue, originalNumVotes };\n\n    };\n\n\n\n    const { originalVoteValue, originalNumVotes } = changePostVotes({\n\n      has_voted: voteValue,\n\n      votes: newNumVotes,\n\n    });\n\n\n\n    try {\n\n      await axios.post(`/votes/post`, {\n\n        item_id: id,\n\n        vote_value: voteValue,\n\n      });\n\n    } catch (e) {\n\n      changePostVotes({\n\n        has_voted: originalVoteValue,\n\n        votes: originalNumVotes,\n\n      });\n\n    }\n\n  } else {\n\n    const changeCommentVote = ({ has_voted, votes }) => {\n\n      const { has_voted: originalVoteValue, votes: originalNumVotes } =\n\n        commentsSelector(getState()).find((comment) => comment.id === id) || {};\n\n      dispatch(updateComment(id, { has_voted, votes }));\n\n      return { originalVoteValue, originalNumVotes };\n\n    };\n\n\n\n    const { originalVoteValue, originalNumVotes } = changeCommentVote({\n\n      has_voted: voteValue,\n\n      votes: newNumVotes,\n\n    });\n\n\n\n    try {\n\n      await axios.post(`/votes/comment`, {\n\n        item_id: id,\n\n        vote_value: voteValue,\n\n      });\n\n    } catch (e) {\n\n      changeCommentVote({\n\n        has_voted: originalVoteValue,\n\n        votes: originalNumVotes,\n\n      });\n\n    }\n\n  }\n\n};\n\n\n",
        "called_code_segment_file_1": "const initialState = loadState('authState') || {};\n\nconst authReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'LOGIN':\n      const { user, token } = action;\n      return { user, token };\n    case 'LOGOUT':\n      return {};\n    default:\n      return state;\n  }\n};",
        "invoking_code_segment_file_2": "const configureStore = () => {\n  const rootReducer = combineReducers({\n    auth: authReducer,\n    loading: loadingReducer,\n    error: errorReducer,\n    post: postReducer,\n    postList: postListReducer,\n    comments: commentsReducer,\n    subreddits: subredditsReducer,\n  });\n\n  const store = createStore(\n    rootReducer,\n    composeEnhancers(applyMiddleware(thunk))\n  );\n\n  store.subscribe(() => {\n    saveState(store.getState().auth, 'authState');\n  });\n\n  return store;\n};",
        "called_code_segment_file_2": "instance.interceptors.request.use((config) => {\n  const token = tokenSelector(store.getState());\n  config.headers.Authorization = token;\n  return config;\n});",
        "using_code_segment_file_3": "export const getPostAndComments = (id) => async (dispatch) => {\n  try {\n    dispatch({ type: 'GET_POST_AND_COMMENTS_REQUEST' });\n    const response = await axios.get(`/comments/${id}`);\n    dispatch(setPost(response.data.post));\n    dispatch(setComments(response.data.comments));\n    dispatch({ type: 'GET_POST_AND_COMMENTS_SUCCESS' });\n  } catch (e) {\n    dispatch({ type: 'GET_POST_AND_COMMENTS_FAILURE', message: e.message });\n  }\n};",
        "called_code_segment_file_3": "export const submitVote = ({ type, id, voteValue, newNumVotes }) => async (\n  dispatch,\n  getState\n) => {\n  if (!['post', 'comment'].includes(type)) {\n    throw new Error('You can only submit votes for posts and comments');\n  }\n\n  if (type === 'post') {\n    const changePostVotes = ({ has_voted, votes }) => {\n      const newPostDetails = { has_voted, votes };\n      const { has_voted: originalVoteValue, votes: originalNumVotes } =\n        postListSelector(getState()).find((post) => post.id === id) ||\n        postSelector(getState());\n      dispatch(editPost(id, newPostDetails));\n      return { originalVoteValue, originalNumVotes };\n    };\n\n    const { originalVoteValue, originalNumVotes } = changePostVotes({\n      has_voted: voteValue,\n      votes: newNumVotes,\n    });\n\n    try {\n      await axios.post(`/votes/post`, {\n        item_id: id,\n        vote_value: voteValue,\n      });\n    } catch (e) {\n      changePostVotes({\n        has_voted: originalVoteValue,\n        votes: originalNumVotes,\n      });\n    }\n  } else {\n    const changeCommentVote = ({ has_voted, votes }) => {\n      const { has_voted: originalVoteValue, votes: originalNumVotes } =\n        commentsSelector(getState()).find((comment) => comment.id === id) || {};\n      dispatch(updateComment(id, { has_voted, votes }));\n      return { originalVoteValue, originalNumVotes };\n    };\n\n    const { originalVoteValue, originalNumVotes } = changeCommentVote({\n      has_voted: voteValue,\n      votes: newNumVotes,\n    });\n\n    try {\n      await axios.post(`/votes/comment`, {\n        item_id: id,\n        vote_value: voteValue,\n      });\n    } catch (e) {\n      changeCommentVote({\n        has_voted: originalVoteValue,\n        votes: originalNumVotes,\n      });\n    }\n  }\n};",
        "using_code_segment_file_4": "export const startEditPost = ({ id, body }) => async (dispatch) => {\n  try {\n    dispatch({ type: 'EDIT_POST_REQUEST' });\n    await axios.put(`/posts/${id}`, { body });\n    dispatch(editPost(id, { body }));\n    dispatch({ type: 'EDIT_POST_SUCCESS' });\n  } catch (e) {\n    dispatch({\n      type: 'EDIT_POST_FAILURE',\n      message: e.message,\n      response: e.response,\n    });\n  }\n};",
        "feature_description": "Add a feature to persist user authentication state across sessions.",
        "detailed_feature_description": "The feature involves modifying the authReducer in #file 1 to include a new action type 'SET_AUTH_STATE' that allows setting the authentication state directly. This will be invoked by #file 2 to initialize the store with the persisted state. #file 2 will be updated to handle this new action type and ensure the store is initialized correctly. #file 3 will be updated to use the new action type if necessary, and #file 4 will be updated to accommodate any changes in #file 3.",
        "modified_complete_code": {
            "file_1": "const initialState = loadState('authState') || {};\n\nconst authReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case 'LOGIN':\n      const { user, token } = action;\n      return { user, token };\n    case 'LOGOUT':\n      return {};\n    case 'SET_AUTH_STATE': // #Modify\n      return action.payload;\n    default:\n      return state;\n  }\n};",
            "file_2": "const configureStore = () => {\n  const rootReducer = combineReducers({\n    auth: authReducer,\n    loading: loadingReducer,\n    error: errorReducer,\n    post: postReducer,\n    postList: postListReducer,\n    comments: commentsReducer,\n    subreddits: subredditsReducer,\n  });\n\n  const store = createStore(\n    rootReducer,\n    composeEnhancers(applyMiddleware(thunk))\n  );\n\n  store.subscribe(() => {\n    saveState(store.getState().auth, 'authState');\n  });\n\n  const persistedState = loadState('authState');\n  if (persistedState) {\n    store.dispatch({ type: 'SET_AUTH_STATE', payload: persistedState }); // #Modify\n  }\n\n  return store;\n};",
            "file_3": "export const getPostAndComments = (id) => async (dispatch) => {\n  try {\n    dispatch({ type: 'GET_POST_AND_COMMENTS_REQUEST' });\n    const response = await axios.get(`/comments/${id}`);\n    dispatch(setPost(response.data.post));\n    dispatch(setComments(response.data.comments));\n    dispatch({ type: 'GET_POST_AND_COMMENTS_SUCCESS' });\n  } catch (e) {\n    dispatch({ type: 'GET_POST_AND_COMMENTS_FAILURE', message: e.message });\n  }\n};",
            "file_4": "export const startEditPost = ({ id, body }) => async (dispatch) => {\n  try {\n    dispatch({ type: 'EDIT_POST_REQUEST' });\n    await axios.put(`/posts/${id}`, { body });\n    dispatch(editPost(id, { body }));\n    dispatch({ type: 'EDIT_POST_SUCCESS' });\n  } catch (e) {\n    dispatch({\n      type: 'EDIT_POST_FAILURE',\n      message: e.message,\n      response: e.response,\n    });\n  }\n};"
        }
    },
    {
        "repo": "Instagram",
        "content": "'Instagram/components/InstaHeaderButton.js'\n:import React from 'react';\nimport { TouchableOpacity } from 'react-native';\nimport InstaIcon from './InstaIcon';\n\nexport default class InstaHeaderButton extends React.PureComponent {\n  render() {\n    const { onPress, disabled, touchableStyle, ...props } = this.props;\n    return (\n      <TouchableOpacity\n        disabled={disabled}\n        style={[{ marginHorizontal: 12 }, touchableStyle]}\n        onPress={onPress}\n      >\n        <InstaIcon disabled={disabled} size={32} color={'black'} {...props} />\n      </TouchableOpacity>\n    );\n  }\n}\n\n'Instagram/components/ItemHeader.js'\n:import { connectActionSheet } from '@expo/react-native-action-sheet';\nimport React from 'react';\nimport { Text, View } from 'react-native';\n\nimport InstaHeaderButton from './InstaHeaderButton';\nimport { profileImageSize } from './FeedList';\nimport ProfileImage from './ProfileImage';\n\nclass ItemHeader extends React.Component {\n  render() {\n    const { item } = this.props;\n    const { account, location } = item;\n    return (\n      <View\n        style={{\n          flexDirection: 'row',\n          paddingLeft: 16,\n          paddingRight: 4,\n          paddingVertical: 14,\n          justifyContent: 'space-between',\n          alignItems: 'center',\n        }}\n      >\n        <View style={{ flexDirection: 'row', alignItems: 'center' }}>\n          <ProfileImage\n            style={{\n              aspectRatio: 1,\n              minHeight: profileImageSize,\n              height: profileImageSize,\n              backgroundColor: '#d8d8d8',\n              width: profileImageSize,\n              borderRadius: profileImageSize / 2,\n              marginRight: 12,\n              resizeMode: 'cover',\n            }}\n            account={account}\n          />\n          <View>\n            <Text style={{ fontSize: 14, color: '#262626', fontWeight: '600' }}>\n              {account}\n            </Text>\n            <Text style={{ fontSize: 12, color: '#262626' }}>\n              {location || 'Legoland'}\n            </Text>\n          </View>\n        </View>\n        <InstaHeaderButton\n          name=\"more\"\n          size={30}\n          color={'black'}\n          onPress={() => {\n            const options = [\n              'Copy Link',\n              'Turn On Post Notifications',\n              'Report',\n              'Mute',\n              'Unfollow',\n              'Cancel',\n            ];\n            // TODO: Bacon: Add more destructive options\n            const destructiveButtonIndex = options.length - 2;\n            const cancelButtonIndex = options.length - 1;\n\n            this.props.showActionSheetWithOptions(\n              {\n                options,\n                cancelButtonIndex,\n                destructiveButtonIndex,\n                // title,\n                // message,\n                // icons, // Android only\n                // tintIcons: true, // Android only; default is true\n                // showSeparators: withSeparators, // Affects Android only; default is false\n                // textStyle, // Android only\n                // titleTextStyle, // Android only\n                // messageTextStyle, // Android only\n              },\n              buttonIndex => {\n                // Do something here depending on the button index selected\n                // onSelection(buttonIndex);\n              },\n            );\n          }}\n        />\n      </View>\n    );\n  }\n}\n\nexport default connectActionSheet(ItemHeader);\n\n'Instagram/components/Item.js'\n:import PropTypes from 'prop-types';\nimport React from 'react';\nimport {\n  Animated,\n  Easing,\n  findNodeHandle,\n  PanResponder,\n  UIManager,\n  StyleSheet,\n  View,\n} from 'react-native';\n\nimport DisableBodyScrollingView from './DisableScrolling';\nimport ItemFooter from './ItemFooter';\nimport ItemHeader from './ItemHeader';\nimport ItemImage from './ItemImage';\n\nexport function pow2abs(a, b) {\n  return Math.pow(Math.abs(a - b), 2);\n}\n\nexport function getDistance(touches) {\n  const [a, b] = touches;\n  if (a == null || b == null) {\n    return 0;\n  }\n  return Math.sqrt(pow2abs(a.pageX, b.pageX) + pow2abs(a.pageY, b.pageY));\n}\n\nexport function getPosition(touches) {\n  const [a, b] = touches;\n  if (a == null || b == null) {\n    return { x: 0, y: 0 };\n  }\n  return { x: a.pageX, y: a.pageY };\n}\n\nexport function getDeltaTranslation(position, initial) {\n  return { x: position.x - initial.x, y: position.y - initial.y };\n}\n\nconst SCALE_MULTIPLIER = 1;\n\nexport function getScale(currentDistance, initialDistance) {\n  return (currentDistance / initialDistance) * SCALE_MULTIPLIER;\n}\n\nexport function measureNode(node, parent) {\n  return new Promise((resolve, reject) => {\n    UIManager.measureLayout(\n      node,\n      parent || (node && node.parentNode),\n      e => reject(e),\n      (x, y, w, h, l, t) => {\n        resolve({ x, y, w, h });\n      },\n    );\n  });\n}\nconst RESTORE_ANIMATION_DURATION = 200;\nclass Item extends React.PureComponent {\n  _opacity = new Animated.Value(1);\n  _initialTouches = [];\n\n  static contextTypes = {\n    gesturePosition: PropTypes.object,\n    scaleValue: PropTypes.object,\n    getScrollPosition: PropTypes.func,\n  };\n\n  constructor(props) {\n    super(props);\n    this._generatePanHandlers();\n  }\n\n  _generatePanHandlers = () => {\n    this._gestureHandler = PanResponder.create({\n      onStartShouldSetResponderCapture: () => true,\n      onStartShouldSetPanResponderCapture: ({ nativeEvent }) => {\n        return nativeEvent.touches.length === 2;\n      },\n      onMoveShouldSetResponderCapture: () => true,\n      onMoveShouldSetPanResponderCapture: ({ nativeEvent }) => {\n        return nativeEvent.touches.length === 2;\n      },\n      onPanResponderGrant: this._startGesture,\n      onPanResponderMove: this._onGestureMove,\n      onPanResponderRelease: this._onGestureRelease,\n      onPanResponderTerminationRequest: () => {\n        return this._gestureInProgress == null;\n      },\n      onPanResponderTerminate: (event, gestureState) => {\n        return this._onGestureRelease(event, gestureState);\n      },\n    });\n  };\n\n  _startGesture = async (event, gestureState) => {\n    // Sometimes gesture start happens two or more times rapidly.\n    if (this._gestureInProgress) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    this._gestureInProgress = gestureState.stateID;\n    let { item, onGestureStart } = this.props;\n    let { gesturePosition, getScrollPosition } = this.context;\n    let { touches } = event.nativeEvent;\n\n    this._initialTouches = touches;\n\n    let selectedPhotoMeasurement = await this._measureSelectedPhoto();\n    this._selectedPhotoMeasurement = selectedPhotoMeasurement;\n    onGestureStart({\n      source: item.source,\n      measurement: selectedPhotoMeasurement,\n    });\n\n    gesturePosition.setValue({\n      x: 0,\n      y: 0,\n    });\n\n    gesturePosition.setOffset({\n      x: 0,\n      y: selectedPhotoMeasurement.y, // - getScrollPosition(),\n    });\n\n    Animated.timing(this._opacity, {\n      toValue: 0,\n      duration: 200,\n    }).start();\n  };\n\n  _onGestureMove = (event, gestureState) => {\n    let { touches } = event.nativeEvent;\n    if (!this._gestureInProgress) {\n      return;\n    }\n\n    if (touches.length < 2) {\n      // Trigger a realease\n      this._onGestureRelease(event, gestureState);\n      return;\n    }\n\n    // for moving photo around\n    let { gesturePosition, scaleValue } = this.context;\n    let { dx, dy } = gestureState;\n    let currentPosition = getPosition(touches);\n    let initialPosition = getPosition(this._initialTouches);\n\n    const { x, y } = getDeltaTranslation(currentPosition, initialPosition);\n    gesturePosition.x.setValue(x);\n    gesturePosition.y.setValue(y);\n\n    // for scaling photo\n    let currentDistance = getDistance(touches);\n    let initialDistance = getDistance(this._initialTouches);\n    let newScale = getScale(currentDistance, initialDistance);\n    scaleValue.setValue(Math.max(newScale, 1));\n  };\n\n  _onGestureRelease = (event, gestureState) => {\n    if (this._gestureInProgress !== gestureState.stateID) {\n      return;\n    }\n\n    // https://medium.com/@audytanudjaja/react-native-ui-challenge-building-instagram-zoom-draggable-photo-9127413b1d29\n    this._gestureInProgress = null;\n    this._initialTouches = [];\n    let { onGestureRelease } = this.props;\n    let { gesturePosition, scaleValue, getScrollPosition } = this.context;\n\n    Animated.parallel([\n      Animated.timing(gesturePosition.x, {\n        toValue: 0,\n        duration: RESTORE_ANIMATION_DURATION,\n        easing: Easing.linear,\n      }),\n      Animated.timing(gesturePosition.y, {\n        toValue: 0,\n        duration: RESTORE_ANIMATION_DURATION,\n        easing: Easing.linear,\n      }),\n      Animated.timing(scaleValue, {\n        toValue: 1,\n        duration: RESTORE_ANIMATION_DURATION,\n        easing: Easing.linear,\n      }),\n    ]).start(() => {\n      gesturePosition.setOffset({\n        x: 0,\n        y:\n          (this._selectedPhotoMeasurement &&\n            this._selectedPhotoMeasurement.y) ||\n          0 - getScrollPosition(),\n      });\n\n      this._opacity.setValue(1);\n\n      requestAnimationFrame(() => {\n        onGestureRelease();\n      });\n    });\n  };\n\n  _measureSelectedPhoto = async () => {\n    let parent = findNodeHandle(this._parent);\n    let photoComponent = findNodeHandle(this._photoComponent);\n\n    try {\n      const photoMeasurement = await measureNode(photoComponent, parent);\n      const bodyRect = document.body.getBoundingClientRect();\n      const elemRect = photoComponent.getBoundingClientRect();\n      const offset = elemRect.top + window.scrollY;\n\n      return {\n        x: photoMeasurement.x,\n        y: offset,\n        w: photoMeasurement.w,\n        h: photoMeasurement.h,\n      };\n    } catch (error) {\n      console.log('ERROR', error);\n    }\n    return {};\n  };\n\n  render() {\n    const { imageWidth, imageHeight, item, isLarge } = this.props;\n\n    return (\n      <View\n        style={[\n          { backgroundColor: 'white' },\n          isLarge && {\n            borderColor: '#e6e6e6',\n            borderRadius: 3,\n            borderWidth: StyleSheet.hairlineWidth,\n            marginBottom: 15,\n          },\n        ]}\n        ref={parentNode => (this._parent = parentNode)}\n      >\n        <ItemHeader item={item} />\n        <DisableBodyScrollingView>\n          <Animated.View\n            {...this._gestureHandler.panHandlers}\n            testID=\"webkit-disable-touches\"\n            style={{\n              opacity: this._opacity,\n            }}\n          >\n            <ItemImage\n              ref={node => (this._photoComponent = node)}\n              imageWidth={imageWidth}\n              imageHeight={imageHeight}\n              source={item.source}\n            />\n          </Animated.View>\n        </DisableBodyScrollingView>\n\n        <ItemFooter item={item} />\n      </View>\n    );\n  }\n}\nexport default Item;\n\n'Instagram/components/FeedList.js'\n:import PropTypes from 'prop-types';\nimport React from 'react';\nimport { Animated, FlatList, StyleSheet, View } from 'react-native';\n\nimport { Stories } from '../constants/Posts';\nimport FeedListFooter from './FeedListFooter';\nimport Item from './Item';\nimport StorySlider from './StorySlider';\n\nexport const profileImageSize = 32;\n\nexport default class FeedList extends React.Component {\n  static defaultProps = {\n    ListHeaderComponent: props => <StorySlider stories={Stories} />,\n  };\n\n  _scrollValue = new Animated.Value(0);\n  _scaleValue = new Animated.Value(1);\n  _gesturePosition = new Animated.ValueXY();\n  state = {\n    isDragging: false,\n  };\n\n  static childContextTypes = {\n    gesturePosition: PropTypes.object,\n    getScrollPosition: PropTypes.func,\n    scaleValue: PropTypes.object,\n  };\n\n  state = {\n    isDragging: false,\n  };\n\n  getChildContext() {\n    return {\n      gesturePosition: this._gesturePosition,\n      scaleValue: this._scaleValue,\n      getScrollPosition: () => {\n        return this._scrollValue.__getValue();\n      },\n    };\n  }\n\n  render() {\n    const { onPressFooter, ...props } = this.props;\n\n    let { isDragging, selectedPhoto } = this.state;\n    let onScroll = Animated.event([\n      { nativeEvent: { contentOffset: { y: this._scrollValue } } },\n    ]);\n\n    return (\n      <React.Fragment>\n        <FlatList\n          showsVerticalScrollIndicator={false}\n          style={{ backgroundColor: 'transparent' }}\n          ref={ref => (this.list = ref)}\n          scrollEventThrottle={16}\n          onScroll={onScroll}\n          scrollEnabled={!isDragging}\n          zoomScale={1}\n          bouncesZoom={false}\n          maximumZoomScale={1}\n          minimumZoomScale={1}\n          renderItem={({ item }) => (\n            <Item\n              isLarge={props.isLarge}\n              getParent={() => this.list}\n              isDragging={isDragging}\n              onGestureStart={selectedPhoto => {\n                this.setState({\n                  selectedPhoto,\n                  isDragging: true,\n                });\n              }}\n              onGestureRelease={() => this.setState({ isDragging: false })}\n              item={item}\n            />\n          )}\n          ListFooterComponent={props => (\n            <FeedListFooter {...props} onPress={onPressFooter} />\n          )}\n          keyExtractor={(item, index) => item.key + ' ' + index}\n          {...props}\n        />\n        {isDragging ? (\n          <SelectedPhoto\n            key={selectedPhoto ? selectedPhoto.photoURI : ''}\n            selectedPhoto={selectedPhoto}\n          />\n        ) : null}\n      </React.Fragment>\n    );\n  }\n}\n\nclass SelectedPhoto extends React.Component {\n  state = { isLoaded: false };\n\n  static contextTypes = {\n    gesturePosition: PropTypes.object,\n    scrollValue: PropTypes.object,\n    scaleValue: PropTypes.object,\n  };\n\n  render() {\n    let { selectedPhoto } = this.props;\n    let { isLoaded } = this.state;\n\n    let { gesturePosition, scaleValue } = this.context;\n\n    let animatedStyle = {\n      transform: gesturePosition.getTranslateTransform(),\n    };\n    animatedStyle.transform.push({\n      scale: scaleValue,\n    });\n\n    let imageStyle = [\n      {\n        position: 'absolute',\n        zIndex: 10,\n        width: selectedPhoto.measurement.w,\n        height: selectedPhoto.measurement.h,\n        opacity: isLoaded ? 1 : 0,\n      },\n      animatedStyle,\n    ];\n\n    let backgroundOpacityValue = scaleValue.interpolate({\n      inputRange: [1.0, 1.1, 2.0],\n      outputRange: [0.0, 0.15, 0.75],\n      extrapolate: 'clamp',\n    });\n\n    return (\n      <BodyPortal>\n        <View style={styles.root}>\n          <Animated.View\n            style={[\n              styles.background,\n              {\n                opacity: backgroundOpacityValue,\n              },\n            ]}\n          />\n          <Animated.Image\n            style={imageStyle}\n            onLoad={() => {\n              setTimeout(() => {\n                this.setState({ isLoaded: true });\n              });\n            }}\n            source={selectedPhoto.source}\n          />\n        </View>\n      </BodyPortal>\n    );\n  }\n}\n\nimport ReactDOM from 'react-dom';\n\nexport class BodyPortal extends React.PureComponent {\n  render() {\n    return ReactDOM.createPortal(this.props.children, global.document.body);\n  }\n}\n\nconst styles = StyleSheet.create({\n  root: {\n    flex: 1,\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n  },\n  background: {\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    backgroundColor: 'black',\n  },\n});\n\n",
        "called_code_segment_file_1": "render() {\n    const { onPress, disabled, touchableStyle, ...props } = this.props;\n    return (\n      <TouchableOpacity\n        disabled={disabled}\n        style={[{ marginHorizontal: 12 }, touchableStyle]}\n        onPress={onPress}\n      >\n        <InstaIcon disabled={disabled} size={32} color={'black'} {...props} />\n      </TouchableOpacity>\n    );\n  }",
        "invoking_code_segment_file_2": "render() {\n    const { item } = this.props;\n    const { account, location } = item;\n    return (\n      <View\n        style={{\n          flexDirection: 'row',\n          paddingLeft: 16,\n          paddingRight: 4,\n          paddingVertical: 14,\n          justifyContent: 'space-between',\n          alignItems: 'center',\n        }}\n      >\n        <View style={{ flexDirection: 'row', alignItems: 'center' }}>\n          <ProfileImage\n            style={{\n              aspectRatio: 1,\n              minHeight: profileImageSize,\n              height: profileImageSize,\n              backgroundColor: '#d8d8d8',\n              width: profileImageSize,\n              borderRadius: profileImageSize / 2,\n              marginRight: 12,\n              resizeMode: 'cover',\n            }}\n            account={account}\n          />\n          <View>\n            <Text style={{ fontSize: 14, color: '#262626', fontWeight: '600' }}>\n              {account}\n            </Text>\n            <Text style={{ fontSize: 12, color: '#262626' }}>\n              {location || 'Legoland'}\n            </Text>\n          </View>\n        </View>\n        <InstaHeaderButton\n          name=\"more\"\n          size={30}\n          color={'black'}\n          onPress={() => {\n            const options = [\n              'Copy Link',\n              'Turn On Post Notifications',\n              'Report',\n              'Mute',\n              'Unfollow',\n              'Cancel',\n            ];\n            const destructiveButtonIndex = options.length - 2;\n            const cancelButtonIndex = options.length - 1;\n\n            this.props.showActionSheetWithOptions(\n              {\n                options,\n                cancelButtonIndex,\n                destructiveButtonIndex,\n              },\n              buttonIndex => {\n                // Do something here depending on the button index selected\n              },\n            );\n          }}\n        />\n      </View>\n    );\n  }",
        "called_code_segment_file_2": "onPress={() => {\n            const options = [\n              'Copy Link',\n              'Turn On Post Notifications',\n              'Report',\n              'Mute',\n              'Unfollow',\n              'Cancel',\n            ];\n            const destructiveButtonIndex = options.length - 2;\n            const cancelButtonIndex = options.length - 1;\n\n            this.props.showActionSheetWithOptions(\n              {\n                options,\n                cancelButtonIndex,\n                destructiveButtonIndex,\n              },\n              buttonIndex => {\n                // Do something here depending on the button index selected\n              },\n            );\n          }}",
        "using_code_segment_file_3": "onGestureStart={selectedPhoto => {\n                this.setState({\n                  selectedPhoto,\n                  isDragging: true,\n                });\n              }}",
        "called_code_segment_file_3": "onGestureStart={selectedPhoto => {\n                this.setState({\n                  selectedPhoto,\n                  isDragging: true,\n                });\n              }}",
        "using_code_segment_file_4": "onGestureStart={selectedPhoto => {\n                this.setState({\n                  selectedPhoto,\n                  isDragging: true,\n                });\n              }}",
        "feature_description": "Add a new feature to log the selected photo details when the gesture starts.",
        "detailed_feature_description": "Modify the `onGestureStart` function in `Item.js` to log the selected photo details. Update the `FeedList.js` to handle the modified `onGestureStart` function and ensure the `Item.js` is updated accordingly. No direct interaction between `ItemHeader.js` and `FeedListFooter.js` with the modified segments, so no changes are required in `ItemHeader.js` and `FeedListFooter.js`.",
        "modified_complete_code": {
            "InstaHeaderButton.js": "render() {\n    const { onPress, disabled, touchableStyle, ...props } = this.props;\n    return (\n      <TouchableOpacity\n        disabled={disabled}\n        style={[{ marginHorizontal: 12 }, touchableStyle]}\n        onPress={onPress}\n      >\n        <InstaIcon disabled={disabled} size={32} color={'black'} {...props} />\n      </TouchableOpacity>\n    );\n  }",
            "ItemHeader.js": "render() {\n    const { item } = this.props;\n    const { account, location } = item;\n    return (\n      <View\n        style={{\n          flexDirection: 'row',\n          paddingLeft: 16,\n          paddingRight: 4,\n          paddingVertical: 14,\n          justifyContent: 'space-between',\n          alignItems: 'center',\n        }}\n      >\n        <View style={{ flexDirection: 'row', alignItems: 'center' }}>\n          <ProfileImage\n            style={{\n              aspectRatio: 1,\n              minHeight: profileImageSize,\n              height: profileImageSize,\n              backgroundColor: '#d8d8d8',\n              width: profileImageSize,\n              borderRadius: profileImageSize / 2,\n              marginRight: 12,\n              resizeMode: 'cover',\n            }}\n            account={account}\n          />\n          <View>\n            <Text style={{ fontSize: 14, color: '#262626', fontWeight: '600' }}>\n              {account}\n            </Text>\n            <Text style={{ fontSize: 12, color: '#262626' }}>\n              {location || 'Legoland'}\n            </Text>\n          </View>\n        </View>\n        <InstaHeaderButton\n          name=\"more\"\n          size={30}\n          color={'black'}\n          onPress={() => {\n            const options = [\n              'Copy Link',\n              'Turn On Post Notifications',\n              'Report',\n              'Mute',\n              'Unfollow',\n              'Cancel',\n            ];\n            const destructiveButtonIndex = options.length - 2;\n            const cancelButtonIndex = options.length - 1;\n\n            this.props.showActionSheetWithOptions(\n              {\n                options,\n                cancelButtonIndex,\n                destructiveButtonIndex,\n              },\n              buttonIndex => {\n                // Do something here depending on the button index selected\n              },\n            );\n          }}\n        />\n      </View>\n    );\n  }",
            "Item.js": "onGestureStart = async (event, gestureState) => {\n    // Sometimes gesture start happens two or more times rapidly.\n    if (this._gestureInProgress) {\n      return;\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    this._gestureInProgress = gestureState.stateID;\n    let { item, onGestureStart } = this.props;\n    let { gesturePosition, getScrollPosition } = this.context;\n    let { touches } = event.nativeEvent;\n\n    this._initialTouches = touches;\n\n    let selectedPhotoMeasurement = await this._measureSelectedPhoto();\n    this._selectedPhotoMeasurement = selectedPhotoMeasurement;\n    onGestureStart({\n      source: item.source,\n      measurement: selectedPhotoMeasurement,\n    });\n\n    gesturePosition.setValue({\n      x: 0,\n      y: 0,\n    });\n\n    gesturePosition.setOffset({\n      x: 0,\n      y: selectedPhotoMeasurement.y, // - getScrollPosition(),\n    });\n\n    Animated.timing(this._opacity, {\n      toValue: 0,\n      duration: 200,\n    }).start();\n\n    // #Modify: Log the selected photo details\n    console.log('Selected Photo Details:', selectedPhotoMeasurement);\n  };",
            "FeedList.js": "onGestureStart={selectedPhoto => {\n                this.setState({\n                  selectedPhoto,\n                  isDragging: true,\n                });\n              }}"
        }
    },
    {
        "repo": "pkglink",
        "content": "'pkglink/src/util/format.js'\n:import numeral from 'numeral';\nimport truncate from 'cli-truncate';\n\nexport function formatBytes(bytes) {\n  return numeral(bytes).format('0.[00]b');\n}\n\nexport function formatDevNameVersion(dev, name, version) {\n  // use name-version first since device is usually constant\n  return `${name}-${version}:${dev}`;\n}\n\nexport function sortObjKeys(obj) {\n  return Object.keys(obj)\n    .sort()\n    .reduce((acc, k) => {\n      acc[k] = obj[k];\n      return acc;\n    }, {});\n}\n\nexport function trunc(size, str) {\n  return truncate(str, size, { position: 'middle' });\n}\n\n'pkglink/src/pack-ref.js'\n:import fs from 'fs-extra-promise';\nimport Path from 'path';\nimport Prom from 'bluebird';\nimport R from 'ramda';\nimport { Observable } from 'rxjs';\nimport { formatDevNameVersion } from './util/format';\n\nexport function prune(config, dnvPR) {\n  // return obs of new dnvPR object\n  return Observable.from(\n    R.toPairs(dnvPR) // [dnv, arrPackRef]\n  )\n    .mergeMap((dnv_PR) => verifyDMP(dnv_PR, config))\n    .reduce((acc, dnv_PR) => R.append(dnv_PR, acc), [])\n    .map((flatDMR) => R.fromPairs(flatDMR));\n}\n\nexport function verifyDMP([dnv, arrPackRef], config) {\n  // return obs of valid dnv_PR\n  const { concurrentOps } = config;\n  return (\n    Observable.from(arrPackRef) // obs of packRefs\n      // returns obs of valid packRef\n      .mergeMap((packRef) => verifyPackRef(dnv, packRef, false), concurrentOps)\n      .reduce((acc, packRef) => R.append(packRef, acc), [])\n      .filter((arrRefEI) => arrRefEI.length)\n      .map((arrRefEI) => [dnv, arrRefEI])\n  ); // dnv_PR\n}\n\nexport function buildPackRef(modFullPath, packageJsonInode, packageJsonMTimeEpoch) {\n  return [modFullPath, packageJsonInode, packageJsonMTimeEpoch];\n}\n\nexport function verifyPackRef(dnv, packRef, returnEI = false) {\n  // return obs of valid packRef\n  const modDir = packRef[0];\n  const packInode = packRef[1];\n  const packMTimeEpoch = packRef[2];\n  const packPath = Path.join(modDir, 'package.json');\n  let packStat;\n  return Observable.from(\n    fs\n      .statAsync(packPath)\n      .then((stat) => {\n        // eslint-disable-line consistent-return\n        if (stat && stat.ino === packInode && stat.mtime.getTime() === packMTimeEpoch) {\n          packStat = stat; // save for later use\n          return fs.readJsonAsync(packPath, { throws: false });\n        }\n        return undefined;\n      })\n      // if json and matches, return packRef or EI\n      .then((json) => {\n        // eslint-disable-line consistent-return\n        if (json) {\n          const devNameVer = formatDevNameVersion(packStat.dev, json.name, json.version);\n          if (devNameVer === dnv) {\n            return returnEI\n              ? {\n                  // masterEI\n                  stat: packStat,\n                  fullParentDir: modDir\n                }\n              : packRef;\n          }\n        }\n        return undefined;\n      })\n      .catch((err) => {\n        if (err.code !== 'ENOENT') {\n          console.error(err);\n        }\n      })\n  ).filter((x) => x); // filter any undefineds, those were invalid\n}\n\nconst masterEICache = {};\n\nfunction checkMasterCache(config, rtenv, dnv, packEI) {\n  // ret obs of masterEI\n  const masterEI = masterEICache[dnv];\n  if (masterEI) {\n    if (!masterEI.then) {\n      // it is not a promise\n      return Observable.of(masterEI);\n    }\n    // otherwise it was a promise\n    return Observable.fromPromise(masterEI);\n  }\n  // otherwise not found\n  const masterEIProm = findExistingMaster(config, rtenv, dnv, packEI);\n  masterEICache[dnv] = masterEIProm;\n  // optimize future requests so they don't need to hit promise\n  masterEIProm.then((masterEI) => {\n    masterEICache[dnv] = masterEI; // eliminate promise overhead\n  });\n  return Observable.fromPromise(masterEIProm);\n}\n\nexport function determinePackLinkSrcDst(config, rtenv, destEIdn) {\n  // ret obs of srcDstObj\n  if (rtenv.cancelled) {\n    return Observable.empty();\n  }\n  const { entryInfo: dstEI, devNameVer: dnv } = destEIdn;\n\n  return checkMasterCache(config, rtenv, dnv, dstEI)\n    .takeWhile(() => !rtenv.cancelled)\n    .filter((masterEI) => !isEISameInode(masterEI, dstEI))\n    .map((masterEI) => ({\n      devNameVer: dnv, // device:nameVersion\n      src: masterEI.fullParentDir,\n      srcPackInode: masterEI.stat.ino,\n      srcPackMTimeEpoch: masterEI.stat.mtime.getTime(),\n      dst: dstEI.fullParentDir,\n      dstPackInode: dstEI.stat.ino,\n      dstPackMTimeEpoch: dstEI.stat.mtime.getTime()\n    }));\n}\n\nfunction isEISameInode(firstEI, secondEI) {\n  return firstEI.stat.dev === secondEI.stat.dev && firstEI.stat.ino === secondEI.stat.ino;\n}\n\n// prepare for this to be async\nfunction getExistingPackRefs(config, rtenv, dnv) {\n  // returns observable to arrPackRefs\n  // check rtenv.existingPackRefs[dnv] for ref tuples\n  const masterPackRefs = R.pathOr([], [dnv], rtenv.existingPackRefs); // array of [modDir, packInode, packMTimeEpoch] packRef tuples\n  return Observable.of(masterPackRefs);\n}\n\nfunction findExistingMaster(config, rtenv, dnv, ei) {\n  // returns promise resolving to masterEI\n  /*\n     we will be checking through the rtenv.existingPackRefs[dnv] packRefs\n     to see if any are still valid. Resolve with the first one that is\n     still valid, also returning the remaining packRefs. Not all of the\n     packRefs will have been checked, just enough to find one valid one.\n     A new array of refs will be updated in rtenv.updatedPackRefs\n     which will omit any found to be invalid.\n     Resolves with masterEI or uses ei provided\n   */\n  return getExistingPackRefs(config, rtenv, dnv)\n    .mergeMap((masterPackRefs) => {\n      if (!masterPackRefs.length) {\n        // no valid found, set to empty []\n        rtenv.updatedPackRefs[dnv] = [buildPackRef(ei.fullParentDir, ei.stat.ino, ei.stat.mtime.getTime())];\n        return Observable.of(ei);\n      }\n      // otherwise we have packrefs check them\n      return Observable.from(masterPackRefs)\n        .mergeMap(\n          (packRef) => verifyPackRef(dnv, packRef, true),\n          1 // one at a time since only need first\n        )\n        .first(\n          (masterEI) => masterEI, // exists\n          (masterEI, idx) => [masterEI, idx],\n          false\n        )\n        .map((masterEI_idx) => {\n          if (!masterEI_idx) {\n            // no valid found, set to empty []\n            rtenv.updatedPackRefs[dnv] = [buildPackRef(ei.fullParentDir, ei.stat.ino, ei.stat.mtime.getTime())];\n            return ei;\n          }\n          const idx = masterEI_idx[1];\n          // wasn't first one so needs slicing\n          rtenv.updatedPackRefs[dnv] = masterPackRefs.slice(idx);\n          const masterEI = masterEI_idx[0];\n          return masterEI;\n        });\n    })\n    .toPromise(Prom);\n}\n\n'pkglink/src/link.js'\n:import fs from 'fs-extra-promise';\nimport Path from 'path';\nimport readdirp from 'readdirp';\nimport { Observable } from 'rxjs';\nimport { buildPackRef } from './pack-ref';\nimport linkFilter from './link-filter';\nimport { createLogUpdate } from './util/log';\n\n/*\n Default hard link function which unlinks orig dst then creates link\n If failed to link (maybe fs doesn't support), recopy from src\n @return promise that resolves on success or rejects on failure\n */\nfunction hardLink(src, dst) {\n  return fs\n    .unlinkAsync(dst)\n    .then(() => fs.linkAsync(src, dst))\n    .catch((err) => {\n      fs.copyAsync(src, dst, {\n        clobber: false,\n        preserveTimestamps: true\n      })\n        .then(() => {\n          console.error('INFO: recopied %s to %s to cleanup from link error which follows', src, dst);\n        })\n        .catch((/* err */) => {\n          console.error('ERROR: was not able to restore %s after link error that follows, reinstall package', dst);\n        });\n      throw err; // rethrow original err\n    });\n}\n\nexport function genModuleLinks(config, rtenv, lnkModSrcDst) {\n  // returns observable\n  return (\n    determineLinks(config, rtenv, lnkModSrcDst, true)\n      // just output the ln commands\n      .do(([src, dst, size]) => {\n        rtenv.out(`ln -f \"${src}\" \"${dst}\"`);\n      })\n  );\n}\n\nexport function handleModuleLinking(config, rtenv, lnkModSrcDst) {\n  // returns observable\n  return determineLinks(config, rtenv, lnkModSrcDst, true).mergeMap(\n    (s_d_sz) => performLink(config, rtenv, s_d_sz),\n    (s_d_sz, ops) => s_d_sz,\n    config.concurrentOps\n  );\n}\n\nexport function determineLinks(config, rtenv, lnkModSrcDst, updatePackRefs = false) {\n  // returns observable of s_d_sz [srcFullPath, dstFullPath, size]\n\n  const logUpdate = createLogUpdate(config, rtenv);\n\n  // src is the master we link from, dst is the dst link\n  const devNameVer = lnkModSrcDst.devNameVer; // device:nameVersion\n  const srcRoot = lnkModSrcDst.src;\n  const srcPackInode = lnkModSrcDst.srcPackInode;\n  const srcPackMTimeEpoch = lnkModSrcDst.srcPackMTimeEpoch;\n  const dstRoot = lnkModSrcDst.dst;\n  const dstPackInode = lnkModSrcDst.dstPackInode;\n  const dstPackMTimeEpoch = lnkModSrcDst.dstPackMTimeEpoch;\n\n  if (updatePackRefs) {\n    let packRefs = rtenv.updatedPackRefs[devNameVer] || [];\n    if (!packRefs.length) {\n      packRefs.push(buildPackRef(srcRoot, srcPackInode, srcPackMTimeEpoch));\n    }\n    packRefs = packRefs.filter((packRef) => packRef[0] !== dstRoot);\n    if (packRefs.length < config.refSize) {\n      packRefs.push(buildPackRef(dstRoot, dstPackInode, dstPackMTimeEpoch));\n    }\n    rtenv.updatedPackRefs[devNameVer] = packRefs;\n  }\n\n  const fstream = readdirp({\n    root: lnkModSrcDst.src,\n    entryType: 'files',\n    lstat: true, // want actual files not symlinked\n    fileFilter: ['!.*'],\n    directoryFilter: ['!.*', '!node_modules']\n  });\n  fstream.once('end', () => {\n    rtenv.completedPackages += 1;\n    logUpdate();\n  });\n  rtenv.cancelled$.subscribe(() => fstream.destroy()); // stop reading\n\n  return (\n    Observable.fromEvent(fstream, 'data')\n      .takeWhile(() => !rtenv.cancelled)\n      .takeUntil(Observable.fromEvent(fstream, 'close'))\n      .takeUntil(Observable.fromEvent(fstream, 'end'))\n      // combine with stat for dst\n      .mergeMap(\n        (srcEI) => {\n          const dstPath = Path.resolve(dstRoot, srcEI.path);\n          return Observable.from(\n            fs\n              .statAsync(dstPath)\n              .then((stat) => ({\n                fullPath: dstPath,\n                stat\n              }))\n              .catch((err) => {\n                if (err.code !== 'ENOENT') {\n                  console.error(err);\n                }\n                return null;\n              })\n          );\n        },\n        (srcEI, dstEI) => ({\n          srcEI,\n          dstEI\n        }),\n        config.concurrentOps\n      )\n      .filter((x) => linkFilter(config, dstPackInode, x))\n      .map((x) => [\n        // s_d_sz\n        x.srcEI.fullPath,\n        x.dstEI.fullPath,\n        x.srcEI.stat.size\n      ])\n  );\n}\n\nfunction performLink(config, rtenv, [src, dst, size]) {\n  // returns observable\n  const link = rtenv.linkFn || hardLink; // use custom link if provided\n  return Observable.fromPromise(\n    link(src, dst).catch((err) => {\n      console.error(`ERROR: failed to unlink/link src:${src} dst:${dst}`, err);\n      throw err;\n    })\n  );\n}\n\n'pkglink/src/scan.js'\n:import chalk from 'chalk';\nimport { createLogUpdate } from './util/log';\nimport { genModuleLinks, handleModuleLinking, determineLinks } from './link';\nimport { determinePackLinkSrcDst } from './pack-ref';\nimport findPackages from './find-packages';\n\nexport default function scanAndLink(config, rtenv, rootDirs) {\n  const logUpdate = createLogUpdate(config, rtenv);\n\n  const outputSrcDstForDryrun = config.dryrun\n    ? (lnkSrcDst) => {\n        const { devNameVer: dnv, src, dst } = lnkSrcDst;\n        rtenv.log.clear();\n        rtenv.out(chalk.bold(dnv.split(':')[0])); // nameVersion\n        rtenv.out(`  ${src}`);\n        rtenv.out(`  ${dst}`);\n        rtenv.out('');\n      }\n    : () => {};\n\n  return findPackages(config, rtenv, rootDirs, logUpdate)\n    .takeWhile(() => !rtenv.cancelled)\n    .mergeMap((eiDN) => determinePackLinkSrcDst(config, rtenv, eiDN), config.concurrentOps)\n    .takeWhile(() => !rtenv.cancelled)\n    .do((lnkSrcDst) => outputSrcDstForDryrun(lnkSrcDst))\n    .do((lnkSrcDst) => {\n      rtenv.currentPackageDir = lnkSrcDst.dst;\n      logUpdate();\n    })\n    .mergeMap((lnkSrcDst) => {\n      if (config.dryrun) {\n        return determineLinks(config, rtenv, lnkSrcDst, false);\n      } else if (config.genLnCmds) {\n        return genModuleLinks(config, rtenv, lnkSrcDst);\n      }\n      return handleModuleLinking(config, rtenv, lnkSrcDst);\n    }, config.concurrentOps)\n\n    .scan((acc, [src, dst, size]) => {\n      acc += size;\n      return acc;\n    }, 0)\n    .do((savedBytes) => {\n      rtenv.savedByteCount = savedBytes;\n    })\n    .do((savedBytes) => logUpdate());\n}\n\n",
        "called_code_segment_file_1": "export function determinePackLinkSrcDst(config, rtenv, destEIdn) { // ret obs of srcDstObj if (rtenv.cancelled) { return Observable.empty(); } const { entryInfo: dstEI, devNameVer: dnv } = destEIdn; return checkMasterCache(config, rtenv, dnv, dstEI) .takeWhile(() => !rtenv.cancelled) .filter((masterEI) => !isEISameInode(masterEI, dstEI)) .map((masterEI) => ({ devNameVer: dnv, // device:nameVersion src: masterEI.fullParentDir, srcPackInode: masterEI.stat.ino, srcPackMTimeEpoch: masterEI.stat.mtime.getTime(), dst: dstEI.fullParentDir, dstPackInode: dstEI.stat.ino, dstPackMTimeEpoch: dstEI.stat.mtime.getTime() })); }",
        "invoking_code_segment_file_2": "return findPackages(config, rtenv, rootDirs, logUpdate) .takeWhile(() => !rtenv.cancelled) .mergeMap((eiDN) => determinePackLinkSrcDst(config, rtenv, eiDN), config.concurrentOps) .takeWhile(() => !rtenv.cancelled) .do((lnkSrcDst) => outputSrcDstForDryrun(lnkSrcDst)) .do((lnkSrcDst) => { rtenv.currentPackageDir = lnkSrcDst.dst; logUpdate(); }) .mergeMap((lnkSrcDst) => { if (config.dryrun) { return determineLinks(config, rtenv, lnkSrcDst, false); } else if (config.genLnCmds) { return genModuleLinks(config, rtenv, lnkSrcDst); } return handleModuleLinking(config, rtenv, lnkSrcDst); }, config.concurrentOps)",
        "called_code_segment_file_2": "export function handleModuleLinking(config, rtenv, lnkModSrcDst) { // returns observable return determineLinks(config, rtenv, lnkModSrcDst, true).mergeMap( (s_d_sz) => performLink(config, rtenv, s_d_sz), (s_d_sz, ops) => s_d_sz, config.concurrentOps ); }",
        "using_code_segment_file_3": "export function determineLinks(config, rtenv, lnkModSrcDst, updatePackRefs = false) { // returns observable of s_d_sz [srcFullPath, dstFullPath, size] const logUpdate = createLogUpdate(config, rtenv); // src is the master we link from, dst is the dst link const devNameVer = lnkModSrcDst.devNameVer; // device:nameVersion const srcRoot = lnkModSrcDst.src; const srcPackInode = lnkModSrcDst.srcPackInode; const srcPackMTimeEpoch = lnkModSrcDst.srcPackMTimeEpoch; const dstRoot = lnkModSrcDst.dst; const dstPackInode = lnkModSrcDst.dstPackInode; const dstPackMTimeEpoch = lnkModSrcDst.dstPackMTimeEpoch; if (updatePackRefs) { let packRefs = rtenv.updatedPackRefs[devNameVer] || []; if (!packRefs.length) { packRefs.push(buildPackRef(srcRoot, srcPackInode, srcPackMTimeEpoch)); } packRefs = packRefs.filter((packRef) => packRef[0] !== dstRoot); if (packRefs.length < config.refSize) { packRefs.push(buildPackRef(dstRoot, dstPackInode, dstPackMTimeEpoch)); } rtenv.updatedPackRefs[devNameVer] = packRefs; } const fstream = readdirp({ root: lnkModSrcDst.src, entryType: 'files', lstat: true, // want actual files not symlinked fileFilter: ['!.*'], directoryFilter: ['!.*', '!node_modules'] }); fstream.once('end', () => { rtenv.completedPackages += 1; logUpdate(); }); rtenv.cancelled$.subscribe(() => fstream.destroy()); // stop reading return Observable.fromEvent(fstream, 'data') .takeWhile(() => !rtenv.cancelled) .takeUntil(Observable.fromEvent(fstream, 'close')) .takeUntil(Observable.fromEvent(fstream, 'end')) // combine with stat for dst .mergeMap( (srcEI) => { const dstPath = Path.resolve(dstRoot, srcEI.path); return Observable.from( fs .statAsync(dstPath) .then((stat) => ({ fullPath: dstPath, stat })) .catch((err) => { if (err.code !== 'ENOENT') { console.error(err); } return null; }) ); }, (srcEI, dstEI) => ({ srcEI, dstEI }), config.concurrentOps ) .filter((x) => linkFilter(config, dstPackInode, x)) .map((x) => [ // s_d_sz x.srcEI.fullPath, x.dstEI.fullPath, x.srcEI.stat.size ]); }",
        "called_code_segment_file_3": "function performLink(config, rtenv, [src, dst, size]) { // returns observable const link = rtenv.linkFn || hardLink; // use custom link if provided return Observable.fromPromise( link(src, dst).catch((err) => { console.error(`ERROR: failed to unlink/link src:${src} dst:${dst}`, err); throw err; }) ); }",
        "using_code_segment_file_4": "export default function scanAndLink(config, rtenv, rootDirs) { const logUpdate = createLogUpdate(config, rtenv); const outputSrcDstForDryrun = config.dryrun ? (lnkSrcDst) => { const { devNameVer: dnv, src, dst } = lnkSrcDst; rtenv.log.clear(); rtenv.out(chalk.bold(dnv.split(':')[0])); // nameVersion rtenv.out(`  ${src}`); rtenv.out(`  ${dst}`); rtenv.out(''); } : () => {}; return findPackages(config, rtenv, rootDirs, logUpdate) .takeWhile(() => !rtenv.cancelled) .mergeMap((eiDN) => determinePackLinkSrcDst(config, rtenv, eiDN), config.concurrentOps) .takeWhile(() => !rtenv.cancelled) .do((lnkSrcDst) => outputSrcDstForDryrun(lnkSrcDst)) .do((lnkSrcDst) => { rtenv.currentPackageDir = lnkSrcDst.dst; logUpdate(); }) .mergeMap((lnkSrcDst) => { if (config.dryrun) { return determineLinks(config, rtenv, lnkSrcDst, false); } else if (config.genLnCmds) { return genModuleLinks(config, rtenv, lnkSrcDst); } return handleModuleLinking(config, rtenv, lnkSrcDst); }, config.concurrentOps) .scan((acc, [src, dst, size]) => { acc += size; return acc; }, 0) .do((savedBytes) => { rtenv.savedByteCount = savedBytes; }) .do((savedBytes) => logUpdate()); }",
        "feature_description": "Add a feature to log the total number of links created during the linking process.",
        "detailed_feature_description": "The new feature will modify the `performLink` function in #file 3 to increment a counter each time a link is successfully created. This counter will be stored in the `rtenv` object and logged at the end of the linking process in #file 4.",
        "modified_complete_code": {
            "#file 1": "export function determinePackLinkSrcDst(config, rtenv, destEIdn) { // ret obs of srcDstObj if (rtenv.cancelled) { return Observable.empty(); } const { entryInfo: dstEI, devNameVer: dnv } = destEIdn; return checkMasterCache(config, rtenv, dnv, dstEI) .takeWhile(() => !rtenv.cancelled) .filter((masterEI) => !isEISameInode(masterEI, dstEI)) .map((masterEI) => ({ devNameVer: dnv, // device:nameVersion src: masterEI.fullParentDir, srcPackInode: masterEI.stat.ino, srcPackMTimeEpoch: masterEI.stat.mtime.getTime(), dst: dstEI.fullParentDir, dstPackInode: dstEI.stat.ino, dstPackMTimeEpoch: dstEI.stat.mtime.getTime() })); }",
            "#file 2": "return findPackages(config, rtenv, rootDirs, logUpdate) .takeWhile(() => !rtenv.cancelled) .mergeMap((eiDN) => determinePackLinkSrcDst(config, rtenv, eiDN), config.concurrentOps) .takeWhile(() => !rtenv.cancelled) .do((lnkSrcDst) => outputSrcDstForDryrun(lnkSrcDst)) .do((lnkSrcDst) => { rtenv.currentPackageDir = lnkSrcDst.dst; logUpdate(); }) .mergeMap((lnkSrcDst) => { if (config.dryrun) { return determineLinks(config, rtenv, lnkSrcDst, false); } else if (config.genLnCmds) { return genModuleLinks(config, rtenv, lnkSrcDst); } return handleModuleLinking(config, rtenv, lnkSrcDst); }, config.concurrentOps)",
            "#file 3": "export function determineLinks(config, rtenv, lnkModSrcDst, updatePackRefs = false) { // returns observable of s_d_sz [srcFullPath, dstFullPath, size] const logUpdate = createLogUpdate(config, rtenv); // src is the master we link from, dst is the dst link const devNameVer = lnkModSrcDst.devNameVer; // device:nameVersion const srcRoot = lnkModSrcDst.src; const srcPackInode = lnkModSrcDst.srcPackInode; const srcPackMTimeEpoch = lnkModSrcDst.srcPackMTimeEpoch; const dstRoot = lnkModSrcDst.dst; const dstPackInode = lnkModSrcDst.dstPackInode; const dstPackMTimeEpoch = lnkModSrcDst.dstPackMTimeEpoch; if (updatePackRefs) { let packRefs = rtenv.updatedPackRefs[devNameVer] || []; if (!packRefs.length) { packRefs.push(buildPackRef(srcRoot, srcPackInode, srcPackMTimeEpoch)); } packRefs = packRefs.filter((packRef) => packRef[0] !== dstRoot); if (packRefs.length < config.refSize) { packRefs.push(buildPackRef(dstRoot, dstPackInode, dstPackMTimeEpoch)); } rtenv.updatedPackRefs[devNameVer] = packRefs; } const fstream = readdirp({ root: lnkModSrcDst.src, entryType: 'files', lstat: true, // want actual files not symlinked fileFilter: ['!.*'], directoryFilter: ['!.*', '!node_modules'] }); fstream.once('end', () => { rtenv.completedPackages += 1; logUpdate(); }); rtenv.cancelled$.subscribe(() => fstream.destroy()); // stop reading return Observable.fromEvent(fstream, 'data') .takeWhile(() => !rtenv.cancelled) .takeUntil(Observable.fromEvent(fstream, 'close')) .takeUntil(Observable.fromEvent(fstream, 'end')) // combine with stat for dst .mergeMap( (srcEI) => { const dstPath = Path.resolve(dstRoot, srcEI.path); return Observable.from( fs .statAsync(dstPath) .then((stat) => ({ fullPath: dstPath, stat })) .catch((err) => { if (err.code !== 'ENOENT') { console.error(err); } return null; }) ); }, (srcEI, dstEI) => ({ srcEI, dstEI }), config.concurrentOps ) .filter((x) => linkFilter(config, dstPackInode, x)) .map((x) => [ // s_d_sz x.srcEI.fullPath, x.dstEI.fullPath, x.srcEI.stat.size ]); } #Modify function performLink(config, rtenv, [src, dst, size]) { // returns observable const link = rtenv.linkFn || hardLink; // use custom link if provided return Observable.fromPromise( link(src, dst).then(() => { rtenv.linkCount = (rtenv.linkCount || 0) + 1; // Increment link count }).catch((err) => { console.error(`ERROR: failed to unlink/link src:${src} dst:${dst}`, err); throw err; }) ); }",
            "#file 4": "export default function scanAndLink(config, rtenv, rootDirs) { const logUpdate = createLogUpdate(config, rtenv); const outputSrcDstForDryrun = config.dryrun ? (lnkSrcDst) => { const { devNameVer: dnv, src, dst } = lnkSrcDst; rtenv.log.clear(); rtenv.out(chalk.bold(dnv.split(':')[0])); // nameVersion rtenv.out(`  ${src}`); rtenv.out(`  ${dst}`); rtenv.out(''); } : () => {}; return findPackages(config, rtenv, rootDirs, logUpdate) .takeWhile(() => !rtenv.cancelled) .mergeMap((eiDN) => determinePackLinkSrcDst(config, rtenv, eiDN), config.concurrentOps) .takeWhile(() => !rtenv.cancelled) .do((lnkSrcDst) => outputSrcDstForDryrun(lnkSrcDst)) .do((lnkSrcDst) => { rtenv.currentPackageDir = lnkSrcDst.dst; logUpdate(); }) .mergeMap((lnkSrcDst) => { if (config.dryrun) { return determineLinks(config, rtenv, lnkSrcDst, false); } else if (config.genLnCmds) { return genModuleLinks(config, rtenv, lnkSrcDst); } return handleModuleLinking(config, rtenv, lnkSrcDst); }, config.concurrentOps) .scan((acc, [src, dst, size]) => { acc += size; return acc; }, 0) .do((savedBytes) => { rtenv.savedByteCount = savedBytes; }) .do((savedBytes) => logUpdate()) .do(() => { if (rtenv.linkCount) { console.log(`Total links created: ${rtenv.linkCount}`); } }); }"
        }
    },
    {
        "repo": "movix",
        "content": "'movix/src/pages/details/cast/Cast.jsx'\n:import React from \"react\";\nimport { useSelector } from \"react-redux\";\n\nimport \"./style.scss\";\n\nimport ContentWrapper from \"../../../components/contentWrapper/ContentWrapper\";\nimport Img from \"../../../components/lazyLoadImage/Img\";\nimport avatar from \"../../../assets/avatar.png\";\n\nconst Cast = ({ data, loading }) => {\n    const { url } = useSelector((state) => state.home);\n\n    const skeleton = () => {\n        return (\n            <div className=\"skItem\">\n                <div className=\"circle skeleton\"></div>\n                <div className=\"row skeleton\"></div>\n                <div className=\"row2 skeleton\"></div>\n            </div>\n        );\n    };\n    return (\n        <div className=\"castSection\">\n            <ContentWrapper>\n                <div className=\"sectionHeading\">Top Cast</div>\n                {!loading ? (\n                    <div className=\"listItems\">\n                        {data?.map((item) => {\n                            let imgUrl = item.profile_path\n                                ? url.profile + item.profile_path\n                                : avatar;\n                            return (\n                                <div key={item.id} className=\"listItem\">\n                                    <div className=\"profileImg\">\n                                        <Img src={imgUrl} />\n                                    </div>\n                                    <div className=\"name\">{item.name}</div>\n                                    <div className=\"character\">\n                                        {item.character}\n                                    </div>\n                                </div>\n                            );\n                        })}\n                    </div>\n                ) : (\n                    <div className=\"castSkeleton\">\n                        {skeleton()}\n                        {skeleton()}\n                        {skeleton()}\n                        {skeleton()}\n                        {skeleton()}\n                        {skeleton()}\n                    </div>\n                )}\n            </ContentWrapper>\n        </div>\n    );\n};\n\nexport default Cast;\n\n'movix/src/pages/details/Details.jsx'\n:import React from \"react\";\nimport { useParams } from \"react-router-dom\";\nimport \"./style.scss\";\n\nimport useFetch from \"../../hooks/useFetch\";\nimport DetailsBanner from \"./detailsBanner/DetailsBanner\";\nimport Cast from \"./cast/Cast\";\nimport VideosSection from \"./videosSection/VideosSection\";\nimport Similar from \"./carousels/Similar\";\nimport Recommendation from \"./carousels/Recommendation\";\n\nconst Details = () => {\n    const { mediaType, id } = useParams();\n    const { data, loading } = useFetch(`/${mediaType}/${id}/videos`);\n    const { data: credits, loading: creditsLoading } = useFetch(\n        `/${mediaType}/${id}/credits`\n    );\n\n    return (\n        <div>\n            <DetailsBanner video={data?.results?.[0]} crew={credits?.crew} />\n            <Cast data={credits?.cast} loading={creditsLoading} />\n            <VideosSection data={data} loading={loading} />\n            <Similar mediaType={mediaType} id={id} />\n            <Recommendation mediaType={mediaType} id={id} />\n        </div>\n    );\n};\n\nexport default Details;\n\n'movix/src/App.jsx'\n:import { useState, useEffect } from \"react\";\nimport { BrowserRouter, Routes, Route } from \"react-router-dom\";\nimport { fetchDataFromApi } from \"./utils/api\";\n\nimport { useSelector, useDispatch } from \"react-redux\";\nimport { getApiConfiguration, getGenres } from \"./store/homeSlice\";\n\nimport Header from \"./components/header/Header\";\nimport Footer from \"./components/footer/Footer\";\nimport Home from \"./pages/home/Home\";\nimport Details from \"./pages/details/Details\";\nimport SearchResult from \"./pages/searchResult/SearchResult\";\nimport Explore from \"./pages/explore/Explore\";\nimport PageNotFound from \"./pages/404/PageNotFound\";\n\nfunction App() {\n    const dispatch = useDispatch();\n    const { url } = useSelector((state) => state.home);\n    console.log(url);\n\n    useEffect(() => {\n        fetchApiConfig();\n        genresCall();\n    }, []);\n\n    const fetchApiConfig = () => {\n        fetchDataFromApi(\"/configuration\").then((res) => {\n            console.log(res);\n\n            const url = {\n                backdrop: res.images.secure_base_url + \"original\",\n                poster: res.images.secure_base_url + \"original\",\n                profile: res.images.secure_base_url + \"original\",\n            };\n\n            dispatch(getApiConfiguration(url));\n        });\n    };\n\n    const genresCall = async () => {\n        let promises = [];\n        let endPoints = [\"tv\", \"movie\"];\n        let allGenres = {};\n\n        endPoints.forEach((url) => {\n            promises.push(fetchDataFromApi(`/genre/${url}/list`));\n        });\n\n        const data = await Promise.all(promises);\n        console.log(data);\n        data.map(({ genres }) => {\n            return genres.map((item) => (allGenres[item.id] = item));\n        });\n\n        dispatch(getGenres(allGenres));\n    };\n\n    return (\n        <BrowserRouter>\n            <Header />\n            <Routes>\n                <Route path=\"/\" element={<Home />} />\n                <Route path=\"/:mediaType/:id\" element={<Details />} />\n                <Route path=\"/search/:query\" element={<SearchResult />} />\n                <Route path=\"/explore/:mediaType\" element={<Explore />} />\n                <Route path=\"*\" element={<PageNotFound />} />\n            </Routes>\n            <Footer />\n        </BrowserRouter>\n    );\n}\n\nexport default App;\n\n'movix/src/main.jsx'\n:import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\nimport \"./index.scss\";\n\nimport { store } from \"./store/store\";\nimport { Provider } from \"react-redux\";\n\nReactDOM.createRoot(document.getElementById(\"root\")).render(\n    <Provider store={store}>\n        <App />\n    </Provider>\n);\n\n",
        "called_code_segment_file_1": "const { data, loading } = useFetch(`/${mediaType}/${id}/videos`);",
        "invoking_code_segment_file_2": "<DetailsBanner video={data?.results?.[0]} crew={credits?.crew} />",
        "called_code_segment_file_2": "<DetailsBanner video={data?.results?.[0]} crew={credits?.crew} />",
        "using_code_segment_file_3": "const DetailsBanner = ({ video, crew }) => { ... }",
        "called_code_segment_file_3": "const DetailsBanner = ({ video, crew }) => { ... }",
        "using_code_segment_file_4": "No relevant segment in #file 4",
        "feature_description": "Add a feature to display the video title in the DetailsBanner component.",
        "detailed_feature_description": "Modify the DetailsBanner component to include a new prop for the video title. Update the Details component to pass the video title to the DetailsBanner component. Ensure the DetailsBanner component is updated to handle and display the video title.",
        "modified_complete_code": {
            "file_1": "import React from \"react\";\nimport { useParams } from \"react-router-dom\";\nimport \"./style.scss\";\n\nimport useFetch from \"../../hooks/useFetch\";\nimport DetailsBanner from \"./detailsBanner/DetailsBanner\";\nimport Cast from \"./cast/Cast\";\nimport VideosSection from \"./videosSection/VideosSection\";\nimport Similar from \"./carousels/Similar\";\nimport Recommendation from \"./carousels/Recommendation\";\n\nconst Details = () => {\n    const { mediaType, id } = useParams();\n    const { data, loading } = useFetch(`/${mediaType}/${id}/videos`);\n    const { data: credits, loading: creditsLoading } = useFetch(`/${mediaType}/${id}/credits`);\n\n    return (\n        <div>\n            <DetailsBanner video={data?.results?.[0]} crew={credits?.crew} videoTitle={data?.results?.[0]?.name || data?.results?.[0]?.title} /> #Modify\n            <Cast data={credits?.cast} loading={creditsLoading} />\n            <VideosSection data={data} loading={loading} />\n            <Similar mediaType={mediaType} id={id} />\n            <Recommendation mediaType={mediaType} id={id} />\n        </div>\n    );\n};\n\nexport default Details;",
            "file_2": "import React from \"react\";\nimport { useParams } from \"react-router-dom\";\nimport \"./style.scss\";\n\nimport useFetch from \"../../hooks/useFetch\";\nimport DetailsBanner from \"./detailsBanner/DetailsBanner\";\nimport Cast from \"./cast/Cast\";\nimport VideosSection from \"./videosSection/VideosSection\";\nimport Similar from \"./carousels/Similar\";\nimport Recommendation from \"./carousels/Recommendation\";\n\nconst Details = () => {\n    const { mediaType, id } = useParams();\n    const { data, loading } = useFetch(`/${mediaType}/${id}/videos`);\n    const { data: credits, loading: creditsLoading } = useFetch(`/${mediaType}/${id}/credits`);\n\n    return (\n        <div>\n            <DetailsBanner video={data?.results?.[0]} crew={credits?.crew} videoTitle={data?.results?.[0]?.name || data?.results?.[0]?.title} /> #Modify\n            <Cast data={credits?.cast} loading={creditsLoading} />\n            <VideosSection data={data} loading={loading} />\n            <Similar mediaType={mediaType} id={id} />\n            <Recommendation mediaType={mediaType} id={id} />\n        </div>\n    );\n};\n\nexport default Details;",
            "file_3": "import React from \"react\";\nimport { useSelector } from \"react-redux\";\nimport \"./style.scss\";\n\nimport ContentWrapper from \"../../../components/contentWrapper/ContentWrapper\";\nimport Img from \"../../../components/lazyLoadImage/Img\";\nimport avatar from \"../../../assets/avatar.png\";\n\nconst DetailsBanner = ({ video, crew, videoTitle }) => { #Modify\n    const { url } = useSelector((state) => state.home);\n\n    return (\n        <div className=\"detailsBanner\">\n            <ContentWrapper>\n                <div className=\"sectionHeading\">{videoTitle}</div> #Modify\n                <div className=\"content\">\n                    <div className=\"left\">\n                        <Img src={url.backdrop + video?.key} />\n                    </div>\n                    <div className=\"right\">\n                        <div className=\"title\">{video?.name}</div>\n                        <div className=\"overview\">{video?.overview}</div>\n                        <div className=\"crew\">\n                            {crew?.map((item) => (\n                                <div key={item.id} className=\"crewItem\">\n                                    <div className=\"name\">{item.name}</div>\n                                    <div className=\"job\">{item.job}</div>\n                                </div>\n                            ))}\n                        </div>\n                    </div>\n                </div>\n            </ContentWrapper>\n        </div>\n    );\n};\n\nexport default DetailsBanner;",
            "file_4": "No relevant segment in #file 4"
        }
    },
    {
        "repo": "React-Native-Reflective-UI",
        "content": "'React-Native-Reflective-UI/utils/dimensions.js'\n:import { Dimensions } from 'react-native';\n\nconst screenDimensions = Dimensions.get('screen');\nconst windowDimensions = Dimensions.get('window');\n\nconst [SCREEN_WIDTH, SCREEN_HEIGHT] = [\n screenDimensions.width,\n screenDimensions.height,\n];\nconst [WINDOW_WIDTH, WINDOW_HEIGHT] = [\n windowDimensions.width,\n windowDimensions.height,\n];\n\nexport { SCREEN_WIDTH, SCREEN_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT };\n\n'React-Native-Reflective-UI/components/Story.jsx'\n:import { StyleSheet, View } from 'react-native';\nimport React from 'react';\n\nimport { SCREEN_WIDTH } from '../utils/dimensions';\n\nconst size = SCREEN_WIDTH / 4 - 10;\n\nconst Story = () => {\n return (\n  <View style={styles.storyContainer}>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n  </View>\n );\n};\n\nexport default Story;\n\nconst styles = StyleSheet.create({\n storyContainer: {\n  flexDirection: 'row',\n  justifyContent: 'space-evenly',\n  marginBottom: 10,\n },\n userPhoto: {\n  width: size,\n  height: size,\n  borderRadius: size,\n  borderColor: 'white',\n  borderWidth: 3,\n  marginRight: 0,\n },\n});\n\n'React-Native-Reflective-UI/App.js'\n:import { useFonts } from 'expo-font';\nimport { BlurView } from '@react-native-community/blur';\n\nimport React, { useEffect } from 'react';\nimport {\n Alert,\n Linking,\n Platform,\n ScrollView,\n StatusBar,\n StyleSheet,\n View,\n} from 'react-native';\nimport MaskedView from '@react-native-masked-view/masked-view';\n\nimport { Camera, CameraType } from 'expo-camera';\n\nimport Tabs from './components/Tabs';\nimport Post from './components/Post';\nimport Header from './components/Header';\nimport Story from './components/Story';\n\nif (Platform.OS === 'android') {\n StatusBar.setTranslucent(true);\n StatusBar.setBackgroundColor('transparent');\n}\n\nconst usersArray = [\n {\n  name: 'Nika Gabunia',\n  role: 'Chief Executive Officer',\n },\n {\n  name: 'Jeko Tediashvili',\n  role: 'Web/Mobile Developer',\n },\n {\n  name: 'Niko Chopikashvili',\n  role: 'NodeJS Developer',\n },\n {\n  name: 'Alexander Pataridze',\n  role: 'Junior Developer',\n },\n {\n  name: 'Miranda Pagava',\n  role: 'Project Manager',\n },\n {\n  name: 'Nika Kereselidze',\n  role: 'NodeJS Developer',\n },\n];\n\nconst App = () => {\n const [fontsLoaded] = useFonts({\n  MontserratRegular: require('./assets/fonts/Montserrat-Regular.ttf'),\n  MontserratBold: require('./assets/fonts/Montserrat-Bold.ttf'),\n });\n\n const [permission, requestPermission] = Camera.useCameraPermissions();\n\n const goToSettings = () =>\n  Alert.alert(\n   '',\n   'You do not have a camera permission. Go to application settings and enable it manually.',\n   [\n    {\n     text: 'Not right now',\n     onPress: () => console.log('Cancel Pressed'),\n     style: 'cancel',\n    },\n    {\n     text: 'Go to settings',\n     onPress: () => Linking.openSettings(),\n    },\n   ]\n  );\n\n useEffect(() => {\n  requestPermission();\n }, []);\n\n useEffect(() => {\n  if (permission && !permission.granted) {\n   goToSettings();\n  }\n }, [permission]);\n\n if (fontsLoaded) {\n  return (\n   <View style={styles.screenContainer}>\n    {permission.granted && (\n     <MaskedView\n      style={styles.maskViewStyle}\n      maskElement={\n       <>\n        <Header />\n        <Story />\n\n        {usersArray.map((user, i) => (\n         <Post key={i} user={user} />\n        ))}\n\n        <Tabs />\n       </>\n      }>\n      <Camera style={{ flex: 1 }} ratio='16:9' type={CameraType.back}></Camera>\n      <BlurView\n       style={styles.blurViewStyle}\n       blurType='light'\n       blurAmount={20}\n       reducedTransparencyFallbackColor='white'\n      />\n     </MaskedView>\n    )}\n   </View>\n  );\n }\n\n return null;\n};\n\nexport default App;\n\nconst styles = StyleSheet.create({\n screenContainer: {\n  flex: 1,\n  backgroundColor: 'black',\n },\n maskViewStyle: {\n  flex: 1,\n  flexDirection: 'row',\n },\n blurViewStyle: {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0,\n  flex: 1,\n  display: Platform.OS === 'android' ? 'none' : 'flex',\n },\n});\n\n'React-Native-Reflective-UI/index.js'\n:import { registerRootComponent } from 'expo';\n\nimport App from './App';\n\n// registerRootComponent calls AppRegistry.registerComponent('main', () => App);\n// It also ensures that whether you load the app in Expo Go or in a native build,\n// the environment is set up appropriately\nregisterRootComponent(App);\n\n",
        "called_code_segment_file_1": "const [SCREEN_WIDTH, SCREEN_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT] = [\n screenDimensions.width,\n screenDimensions.height,\n windowDimensions.width,\n windowDimensions.height,\n];\n\nexport { SCREEN_WIDTH, SCREEN_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT };",
        "invoking_code_segment_file_2": "import { SCREEN_WIDTH } from '../utils/dimensions';\n\nconst size = SCREEN_WIDTH / 4 - 10;\n\nconst Story = () => {\n return (\n  <View style={styles.storyContainer}>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n  </View>\n );\n};",
        "called_code_segment_file_2": "const Story = () => {\n return (\n  <View style={styles.storyContainer}>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n   <View style={styles.userPhoto}></View>\n  </View>\n );\n};",
        "using_code_segment_file_3": "import Story from './components/Story';\n\nconst App = () => {\n return (\n  <View style={styles.screenContainer}>\n   <Story />\n  </View>\n );\n};",
        "called_code_segment_file_3": "const App = () => {\n return (\n  <View style={styles.screenContainer}>\n   <Story />\n  </View>\n );\n};",
        "using_code_segment_file_4": "import App from './App';\n\nregisterRootComponent(App);",
        "feature_description": "Add a new feature to display the user's name below each story circle.",
        "detailed_feature_description": "Modify the Story component in #file 2 to include a Text component displaying the user's name below each story circle. Update the App component in #file 3 to pass a list of users to the Story component. Ensure the Story component in #file 2 handles this list and displays the names accordingly.",
        "modified_complete_code": {
            "file_1": "// utils/dimensions.js\nimport { Dimensions } from 'react-native';\n\nconst screenDimensions = Dimensions.get('screen');\nconst windowDimensions = Dimensions.get('window');\n\nconst [SCREEN_WIDTH, SCREEN_HEIGHT] = [\n screenDimensions.width,\n screenDimensions.height,\n];\nconst [WINDOW_WIDTH, WINDOW_HEIGHT] = [\n windowDimensions.width,\n windowDimensions.height,\n];\n\nexport { SCREEN_WIDTH, SCREEN_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT };",
            "file_2": "// components/Story.jsx\nimport { StyleSheet, View, Text } from 'react-native';\nimport React from 'react';\n\nimport { SCREEN_WIDTH } from '../utils/dimensions';\n\nconst size = SCREEN_WIDTH / 4 - 10;\n\nconst Story = ({ users }) => {\n return (\n  <View style={styles.storyContainer}>\n   {users.map((user, index) => (\n    <View key={index} style={styles.userContainer}>\n     <View style={styles.userPhoto}></View>\n     <Text style={styles.userName}>{user.name}</Text>\n    </View>\n   ))}\n  </View>\n );\n};\n\nexport default Story;\n\nconst styles = StyleSheet.create({\n storyContainer: {\n  flexDirection: 'row',\n  justifyContent: 'space-evenly',\n  marginBottom: 10,\n },\n userContainer: {\n  alignItems: 'center',\n },\n userPhoto: {\n  width: size,\n  height: size,\n  borderRadius: size,\n  borderColor: 'white',\n  borderWidth: 3,\n  marginRight: 0,\n },\n userName: {\n  marginTop: 5,\n  fontFamily: 'MontserratRegular',\n },\n});",
            "file_3": "// App.js\nimport { useFonts } from 'expo-font';\nimport { BlurView } from '@react-native-community/blur';\n\nimport React, { useEffect } from 'react';\nimport { Alert, Linking, Platform, ScrollView, StatusBar, StyleSheet, View } from 'react-native';\nimport MaskedView from '@react-native-masked-view/masked-view';\n\nimport { Camera, CameraType } from 'expo-camera';\n\nimport Tabs from './components/Tabs';\nimport Post from './components/Post';\nimport Header from './components/Header';\nimport Story from './components/Story';\n\nif (Platform.OS === 'android') {\n StatusBar.setTranslucent(true);\n StatusBar.setBackgroundColor('transparent');\n}\n\nconst usersArray = [\n { name: 'Nika Gabunia', role: 'Chief Executive Officer' },\n { name: 'Jeko Tediashvili', role: 'Web/Mobile Developer' },\n { name: 'Niko Chopikashvili', role: 'NodeJS Developer' },\n { name: 'Alexander Pataridze', role: 'Junior Developer' },\n { name: 'Miranda Pagava', role: 'Project Manager' },\n { name: 'Nika Kereselidze', role: 'NodeJS Developer' },\n];\n\nconst App = () => {\n const [fontsLoaded] = useFonts({\n  MontserratRegular: require('./assets/fonts/Montserrat-Regular.ttf'),\n  MontserratBold: require('./assets/fonts/Montserrat-Bold.ttf'),\n });\n\n const [permission, requestPermission] = Camera.useCameraPermissions();\n\n const goToSettings = () =>\n  Alert.alert(\n   '',\n   'You do not have a camera permission. Go to application settings and enable it manually.',\n   [\n    { text: 'Not right now', onPress: () => console.log('Cancel Pressed'), style: 'cancel' },\n    { text: 'Go to settings', onPress: () => Linking.openSettings() },\n   ]\n  );\n\n useEffect(() => {\n  requestPermission();\n }, []);\n\n useEffect(() => {\n  if (permission && !permission.granted) {\n   goToSettings();\n  }\n }, [permission]);\n\n if (fontsLoaded) {\n  return (\n   <View style={styles.screenContainer}>\n    {permission.granted && (\n     <MaskedView\n      style={styles.maskViewStyle}\n      maskElement={<> <Header /> <Story users={usersArray} /> {usersArray.map((user, i) => (<Post key={i} user={user} />))} <Tabs /> </>}>\n      <Camera style={{ flex: 1 }} ratio='16:9' type={CameraType.back}></Camera>\n      <BlurView\n       style={styles.blurViewStyle}\n       blurType='light'\n       blurAmount={20}\n       reducedTransparencyFallbackColor='white'\n      />\n     </MaskedView>\n    )}\n   </View>\n  );\n }\n\n return null;\n};\n\nexport default App;\n\nconst styles = StyleSheet.create({\n screenContainer: {\n  flex: 1,\n  backgroundColor: 'black',\n },\n maskViewStyle: {\n  flex: 1,\n  flexDirection: 'row',\n },\n blurViewStyle: {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0,\n  flex: 1,\n  display: Platform.OS === 'android' ? 'none' : 'flex',\n },\n});",
            "file_4": "// index.js\nimport { registerRootComponent } from 'expo';\n\nimport App from './App';\n\nregisterRootComponent(App);"
        }
    },
    {
        "repo": "wp-optionskit",
        "content": "'wp-optionskit/build/utils.js'\n:'use strict'\nconst path = require('path')\nconst config = require('../config')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst packageConfig = require('../package.json')\n\nexports.assetsPath = function (_path) {\n  const assetsSubDirectory = process.env.NODE_ENV === 'production'\n    ? config.build.assetsSubDirectory\n    : config.dev.assetsSubDirectory\n\n  return path.posix.join(assetsSubDirectory, _path)\n}\n\nexports.cssLoaders = function (options) {\n  options = options || {}\n\n  const cssLoader = {\n    loader: 'css-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  const postcssLoader = {\n    loader: 'postcss-loader',\n    options: {\n      sourceMap: options.sourceMap\n    }\n  }\n\n  // generate loader string to be used with extract text plugin\n  function generateLoaders (loader, loaderOptions) {\n    const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]\n\n    if (loader) {\n      loaders.push({\n        loader: loader + '-loader',\n        options: Object.assign({}, loaderOptions, {\n          sourceMap: options.sourceMap\n        })\n      })\n    }\n\n    // Extract CSS when that option is specified\n    // (which is the case during production build)\n    if (options.extract) {\n      return ExtractTextPlugin.extract({\n        use: loaders,\n        fallback: 'vue-style-loader'\n      })\n    } else {\n      return ['vue-style-loader'].concat(loaders)\n    }\n  }\n\n  // https://vue-loader.vuejs.org/en/configurations/extract-css.html\n  return {\n    css: generateLoaders(),\n    postcss: generateLoaders(),\n    less: generateLoaders('less'),\n    sass: generateLoaders('sass', { indentedSyntax: true }),\n    scss: generateLoaders('sass'),\n    stylus: generateLoaders('stylus'),\n    styl: generateLoaders('stylus')\n  }\n}\n\n// Generate loaders for standalone style files (outside of .vue)\nexports.styleLoaders = function (options) {\n  const output = []\n  const loaders = exports.cssLoaders(options)\n\n  for (const extension in loaders) {\n    const loader = loaders[extension]\n    output.push({\n      test: new RegExp('\\\\.' + extension + '$'),\n      use: loader\n    })\n  }\n\n  return output\n}\n\nexports.createNotifierCallback = () => {\n  const notifier = require('node-notifier')\n\n  return (severity, errors) => {\n    if (severity !== 'error') return\n\n    const error = errors[0]\n    const filename = error.file && error.file.split('!').pop()\n\n    notifier.notify({\n      title: packageConfig.name,\n      message: severity + ': ' + error.name,\n      subtitle: filename || '',\n      icon: path.join(__dirname, 'logo.png')\n    })\n  }\n}\n\n'wp-optionskit/build/webpack.base.conf.js'\n:'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst config = require('../config')\nconst vueLoaderConfig = require('./vue-loader.conf')\n\nfunction resolve (dir) {\n  return path.join(__dirname, '..', dir)\n}\n\n\n\nmodule.exports = {\n  context: path.resolve(__dirname, '../'),\n  entry: {\n    app: './src/main.js'\n  },\n  output: {\n    path: config.build.assetsRoot,\n\t  jsonpFunction: 'wpJsonpFlightsWidget',\n    filename: '[name].js',\n    publicPath: process.env.NODE_ENV === 'production'\n      ? config.build.assetsPublicPath\n      : config.dev.assetsPublicPath\n  },\n  resolve: {\n    extensions: ['.js', '.vue', '.json'],\n    alias: {\n      'vue$': 'vue/dist/vue.esm.js',\n      '@': resolve('src'),\n    }\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n        options: vueLoaderConfig\n      },\n      {\n        test: /\\.js$/,\n        loader: 'babel-loader',\n        include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]\n      },\n      {\n        test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('img/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(mp4|webm|ogg|mp3|wav|flac|aac)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('media/[name].[hash:7].[ext]')\n        }\n      },\n      {\n        test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/,\n        loader: 'url-loader',\n        options: {\n          limit: 10000,\n          name: utils.assetsPath('fonts/[name].[hash:7].[ext]')\n        }\n      }\n    ]\n  },\n  node: {\n    // prevent webpack from injecting useless setImmediate polyfill because Vue\n    // source contains it (although only uses it if it's native).\n    setImmediate: false,\n    // prevent webpack from injecting mocks to Node native modules\n    // that does not make sense for the client\n    dgram: 'empty',\n    fs: 'empty',\n    net: 'empty',\n    tls: 'empty',\n    child_process: 'empty'\n  }\n}\n\n'wp-optionskit/build/webpack.prod.conf.js'\n:'use strict'\nconst path = require('path')\nconst utils = require('./utils')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst merge = require('webpack-merge')\nconst baseWebpackConfig = require('./webpack.base.conf')\nconst CopyWebpackPlugin = require('copy-webpack-plugin')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nconst ExtractTextPlugin = require('extract-text-webpack-plugin')\nconst OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')\nconst UglifyJsPlugin = require('uglifyjs-webpack-plugin')\n\nconst env = require('../config/prod.env')\n\nconst webpackConfig = merge(baseWebpackConfig, {\n  module: {\n    rules: utils.styleLoaders({\n      sourceMap: config.build.productionSourceMap,\n      extract: true,\n      usePostCSS: true\n    })\n  },\n  devtool: config.build.productionSourceMap ? config.build.devtool : false,\n  output: {\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath('js/[name].js'),\n    chunkFilename: utils.assetsPath('js/[id].js')\n  },\n  plugins: [\n    // http://vuejs.github.io/vue-loader/en/workflow/production.html\n    new webpack.DefinePlugin({\n      'process.env': env\n    }),\n    new UglifyJsPlugin({\n      uglifyOptions: {\n        compress: {\n          warnings: false\n        }\n      },\n      sourceMap: config.build.productionSourceMap,\n      parallel: true\n    }),\n    // extract css into its own file\n    new ExtractTextPlugin({\n      filename: utils.assetsPath('css/[name].css'),\n      // Setting the following option to `false` will not extract CSS from codesplit chunks.\n      // Their CSS will instead be inserted dynamically with style-loader when the codesplit chunk has been loaded by webpack.\n      // It's currently set to `true` because we are seeing that sourcemaps are included in the codesplit bundle as well when it's `false`, \n      // increasing file size: https://github.com/vuejs-templates/webpack/issues/1110\n      allChunks: true,\n    }),\n    // Compress extracted CSS. We are using this plugin so that possible\n    // duplicated CSS from different components can be deduped.\n    new OptimizeCSSPlugin({\n      cssProcessorOptions: config.build.productionSourceMap\n        ? { safe: true, map: { inline: false } }\n        : { safe: true }\n    }),\n    // generate dist index.html with correct asset hash for caching.\n    // you can customize output by editing /index.html\n    // see https://github.com/ampedandwired/html-webpack-plugin\n    new HtmlWebpackPlugin({\n      filename: config.build.index,\n      template: 'index.html',\n      inject: true,\n      minify: {\n        removeComments: true,\n        collapseWhitespace: true,\n        removeAttributeQuotes: true\n        // more options:\n        // https://github.com/kangax/html-minifier#options-quick-reference\n      },\n      // necessary to consistently work with multiple chunks via CommonsChunkPlugin\n      chunksSortMode: 'dependency'\n    }),\n    // keep module.id stable when vendor modules does not change\n    new webpack.HashedModuleIdsPlugin(),\n    // enable scope hoisting\n    new webpack.optimize.ModuleConcatenationPlugin(),\n    // split vendor js into its own file\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'vendor',\n      minChunks (module) {\n        // any required modules inside node_modules are extracted to vendor\n        return (\n          module.resource &&\n          /\\.js$/.test(module.resource) &&\n          module.resource.indexOf(\n            path.join(__dirname, '../node_modules')\n          ) === 0\n        )\n      }\n    }),\n    // extract webpack runtime and module manifest to its own file in order to\n    // prevent vendor hash from being updated whenever app bundle is updated\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'manifest',\n      minChunks: Infinity\n    }),\n    // This instance extracts shared chunks from code splitted chunks and bundles them\n    // in a separate chunk, similar to the vendor chunk\n    // see: https://webpack.js.org/plugins/commons-chunk-plugin/#extra-async-commons-chunk\n    new webpack.optimize.CommonsChunkPlugin({\n      name: 'app',\n      async: 'vendor-async',\n      children: true,\n      minChunks: 3\n    }),\n\n    // copy custom static assets\n    new CopyWebpackPlugin([\n      {\n        from: path.resolve(__dirname, '../static'),\n        to: config.build.assetsSubDirectory,\n        ignore: ['.*']\n      }\n    ])\n  ]\n})\n\nif (config.build.productionGzip) {\n  const CompressionWebpackPlugin = require('compression-webpack-plugin')\n\n  webpackConfig.plugins.push(\n    new CompressionWebpackPlugin({\n      asset: '[path].gz[query]',\n      algorithm: 'gzip',\n      test: new RegExp(\n        '\\\\.(' +\n        config.build.productionGzipExtensions.join('|') +\n        ')$'\n      ),\n      threshold: 10240,\n      minRatio: 0.8\n    })\n  )\n}\n\nif (config.build.bundleAnalyzerReport) {\n  const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin\n  webpackConfig.plugins.push(new BundleAnalyzerPlugin())\n}\n\nmodule.exports = webpackConfig\n\n'wp-optionskit/build/build.js'\n:'use strict'\nrequire('./check-versions')()\n\nprocess.env.NODE_ENV = 'production'\n\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n\nconst spinner = ora('building for production...')\nspinner.start()\n\nrm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {\n  if (err) throw err\n  webpack(webpackConfig, (err, stats) => {\n    spinner.stop()\n    if (err) throw err\n    process.stdout.write(stats.toString({\n      colors: true,\n      modules: false,\n      children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build.\n      chunks: false,\n      chunkModules: false\n    }) + '\\n\\n')\n\n    if (stats.hasErrors()) {\n      console.log(chalk.red('  Build failed with errors.\\n'))\n      process.exit(1)\n    }\n\n    console.log(chalk.cyan('  Build complete.\\n'))\n    console.log(chalk.yellow(\n      '  Tip: built files are meant to be served over an HTTP server.\\n' +\n      '  Opening index.html over file:// won\\'t work.\\n'\n    ))\n  })\n})\n\n",
        "called_code_segment_file_1": "exports.assetsPath = function (_path) { const assetsSubDirectory = process.env.NODE_ENV === 'production' ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory; return path.posix.join(assetsSubDirectory, _path); }",
        "invoking_code_segment_file_2": "const webpackConfig = merge(baseWebpackConfig, { module: { rules: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true }) } });",
        "called_code_segment_file_2": "new ExtractTextPlugin({ filename: utils.assetsPath('css/[name].[contenthash].css'), allChunks: true, })",
        "using_code_segment_file_3": "new OptimizeCSSPlugin({ cssProcessorOptions: config.build.productionSourceMap ? { safe: true, map: { inline: false } } : { safe: true } })",
        "called_code_segment_file_3": "new UglifyJsPlugin({ uglifyOptions: { compress: { warnings: false } }, sourceMap: config.build.productionSourceMap, parallel: true })",
        "using_code_segment_file_4": "const webpackConfig = require('./webpack.prod.conf'); webpack(webpackConfig, (err, stats) => { if (err) throw err; process.stdout.write(stats.toString({ colors: true, modules: false, children: false, chunks: false, chunkModules: false }) + '\\n\\n'); if (stats.hasErrors()) { console.log(chalk.red('  Build failed with errors.\\n')); process.exit(1); } console.log(chalk.cyan('  Build complete.\\n')); console.log(chalk.yellow('  Tip: built files are meant to be served over an HTTP server.\\n' + '  Opening index.html over file:// won\\'t work.\\n')); })",
        "feature_description": "Add a new feature to dynamically adjust the assets path based on the environment and a new configuration option.",
        "detailed_feature_description": "The new feature modifies the `assetsPath` function in #file 1 to accept an additional parameter for dynamic path adjustment. This change is propagated to #file 2, where the `ExtractTextPlugin` configuration is updated to use the new dynamic path. #file 3 is updated to handle the new configuration option in the `OptimizeCSSPlugin`. Finally, #file 4 is updated to ensure the build process handles the new dynamic path correctly.",
        "modified_complete_code": {
            "file_1": "exports.assetsPath = function (_path, dynamicPath) { const assetsSubDirectory = process.env.NODE_ENV === 'production' ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory; return path.posix.join(assetsSubDirectory, dynamicPath || _path); } #Modify",
            "file_2": "const webpackConfig = merge(baseWebpackConfig, { module: { rules: utils.styleLoaders({ sourceMap: config.build.productionSourceMap, extract: true, usePostCSS: true }) } }); new ExtractTextPlugin({ filename: utils.assetsPath('css/[name].[contenthash].css', config.build.dynamicPath), allChunks: true, }) #Modify",
            "file_3": "new OptimizeCSSPlugin({ cssProcessorOptions: config.build.productionSourceMap ? { safe: true, map: { inline: false } } : { safe: true } }) new UglifyJsPlugin({ uglifyOptions: { compress: { warnings: false } }, sourceMap: config.build.productionSourceMap, parallel: true }) #Modify",
            "file_4": "const webpackConfig = require('./webpack.prod.conf'); webpack(webpackConfig, (err, stats) => { if (err) throw err; process.stdout.write(stats.toString({ colors: true, modules: false, children: false, chunks: false, chunkModules: false }) + '\\n\\n'); if (stats.hasErrors()) { console.log(chalk.red('  Build failed with errors.\\n')); process.exit(1); } console.log(chalk.cyan('  Build complete.\\n')); console.log(chalk.yellow('  Tip: built files are meant to be served over an HTTP server.\\n' + '  Opening index.html over file:// won\\'t work.\\n')); }) #Modify"
        }
    },
    {
        "repo": "nightwatch-cucumber",
        "content": "'nightwatch-cucumber/lib/hook-utils.js'\n:const co = require('co')\n\nfunction addHookBefore (target, functionName, hook) {\n  const original = target[functionName]\n\n  target[functionName] = function () {\n    hook.apply(this, arguments)\n    return original.apply(this, arguments)\n  }\n}\n\nfunction addCallbackedHookAfter (target, functionName, callbackIndex, hook) {\n  const original = target[functionName]\n\n  target[functionName] = function () {\n    const args = Array.prototype.slice.call(arguments)\n    const callback = args[callbackIndex]\n    args[callbackIndex] = function () {\n      const self = this\n      const callbackArgs = Array.prototype.slice.call(arguments)\n      return co.wrap(hook).apply(self, callbackArgs)\n        .then(() => callback.apply(this, callbackArgs))\n    }\n    return original.apply(this, args)\n  }\n}\n\nmodule.exports = {\n  addHookBefore,\n  addCallbackedHookAfter\n}\n\n'nightwatch-cucumber/lib/nightwatch-api.js'\n:const co = require('co')\nconst pify = require('pify')\nconst fs = pify(require('fs'), { include: ['readFile'] })\nconst cloneDeep = require('lodash.clonedeep')\nconst hookUtils = require('./hook-utils')\nconst combineErrors = require('combine-errors')\nconst Nightwatch = {\n  Runner: require('nightwatch/lib/runner/run'),\n  ClientManager: require('nightwatch/lib/runner/clientmanager'),\n  ClientRunner: require('nightwatch/lib/runner/cli/clirunner'),\n  ChildProcess: require('nightwatch/lib/runner/cli/child-process'),\n  Utils: require('nightwatch/lib/util/utils'),\n  Logger: require('nightwatch/lib/util/logger'),\n  Protocol: require('nightwatch/lib/api/protocol'),\n  ErrorHandler: require('nightwatch/lib/runner/cli/errorhandler'),\n  Assertion: require('nightwatch/lib/core/assertion'),\n  Expect: require('nightwatch/lib/api/expect'),\n  queue: require('nightwatch/lib/core/queue.js'),\n  Section: require('nightwatch/lib/page-object/section')\n}\n\nmodule.exports = class NightwatchApi {\n  constructor (options, colorsEnabled) {\n    this.options = options\n    this.colorsEnabled = colorsEnabled\n    const self = this\n    this.Section = class PromisedSection extends Nightwatch.Section {\n      constructor () {\n        super(...arguments)\n        self.promisifySection(this)\n      }\n    }\n  }\n\n  _startSession (options) {\n    this.client = new Nightwatch.ClientManager()\n    this.client.init(options)\n    const api = this.client.api('currentEnv', options.currentEnv)\n    this.promisifyApi(api)\n    this.promisifyAssertions()\n    this.promisifyExpect(api)\n    this.promisifyPageObjects(api)\n    if (this.options.nightwatchOutput) {\n      this.addAssertionLogger()\n    }\n    this.protocol = Nightwatch.Protocol(this.client.get())\n  }\n\n  promisifyApi (api) {\n    let _successCb, _catchCb\n    api.catch = (catchCb) => {\n      if (catchCb) _catchCb = catchCb\n    }\n    api.then = (successCb, catchCb) => {\n      if (successCb) _successCb = successCb\n      if (catchCb) _catchCb = catchCb\n      return this.start()\n        .then(_successCb)\n        .catch(_catchCb)\n    }\n  }\n\n  promisifyAssertions () {\n    const promise = {}\n    this.promisifyApi(promise)\n    const originalAssert = Nightwatch.Assertion.assert\n\n    Nightwatch.Assertion.assert = function () {\n      originalAssert.apply(this, arguments)\n      return promise\n    }\n  }\n\n  promisifyExpect (api) {\n    const self = this\n    if (!api.expect) return\n    [ 'element', 'section' ].forEach(field => {\n      const originalExpectation = api.expect[field]\n\n      api.expect[field] = function () {\n        const result = originalExpectation.apply(this, arguments)\n        self.promisifyApi(result)\n        return result\n      }\n    })\n  }\n\n  promisifySection (section) {\n    this.promisifyApi(section)\n    this.promisifyExpect(section)\n    if (section.section) {\n      Object.keys(section.section).forEach((key) => {\n        this.promisifySection(section.section[key])\n      })\n    }\n  }\n\n  promisifyChildPageObjects (page) {\n    const self = this\n    Object.keys(page).forEach((key) => {\n      if (typeof page[key] !== 'function') {\n        this.promisifyChildPageObjects(page[key])\n      } else {\n        const originalPageCreator = page[key]\n        page[key] = function () {\n          const page = originalPageCreator.call(this)\n          self.promisifySection(page)\n          return page\n        }\n      }\n    })\n  }\n\n  promisifyPageObjects (api) {\n    if (api.page) {\n      return this.promisifyChildPageObjects(api.page)\n    }\n  }\n\n  getClientApi () {\n    return this.client.api()\n  }\n\n  * _closeSession () {\n    yield new Promise((resolve, reject) => {\n      this.client.get().once('nightwatch:finished', function () {\n        resolve()\n      })\n      this.client.terminate()\n    })\n  }\n\n  * takeScreenshot (moduleName, testName) {\n    if (!this.takeScreenshotOnFailure || Nightwatch.queue.instance().rootNode.started) return\n\n    const forbiddenCharacters = /[*|\\\\:\"<>?/+]/g\n\n    const filePath = Nightwatch.Utils.getScreenshotFileName(\n      {module: moduleName, name: testName.replace(forbiddenCharacters, '')},\n      true,\n      this.client.options.screenshots.path\n    )\n\n    yield new Promise((resolve, reject) => {\n      this.protocol.screenshot(false, (response) => {\n        if (response.state !== 'success' && response.status !== 0) {\n          reject(new Error('Creating screenshot was not successful. Response was:\\n' + require('util').inspect(response)))\n        }\n\n        this.client.get().saveScreenshotToFile(filePath, response.value, (err) => {\n          if (err) reject(err)\n          resolve()\n        })\n      })\n    })\n\n    return {\n      data: yield fs.readFile(filePath, 'base64'),\n      mimeType: 'image/png'\n    }\n  }\n\n  addTestModulePaths (modulePaths) {\n    this.modulePaths = modulePaths\n  }\n\n  isSingleFeatureFile (featureFile) {\n    let stat\n    try {\n      stat = fs.statSync(featureFile)\n    } catch (err) {\n      featureFile = featureFile.replace(/:\\d+$/, '')\n      if (!featureFile.match(/\\.feature$/)) featureFile += '.feature'\n      try {\n        stat = fs.statSync(featureFile)\n      } catch (err) {\n        throw new Error(`Feature file or folder ${featureFile} was not found!`)\n      }\n    }\n\n    return stat.isFile()\n  }\n\n  overrideOriginalSourceGetter (convert) {\n    const self = this\n    const originalClientRunnerGetTestSource = Nightwatch.ClientRunner.prototype.getTestSource\n\n    Nightwatch.ClientRunner.prototype.getTestSource = function () {\n      Nightwatch.ClientRunner.prototype.getTestSource = originalClientRunnerGetTestSource\n      const originalArgv = cloneDeep(this.argv)\n      const originalSettings = cloneDeep(this.settings)\n\n      if (this.argv._source && this.argv._source.length) {\n        this.argv._source = this.argv._source.map(convert)\n      } else if (this.argv.test) {\n        this.argv.test = convert(this.argv.test)\n      } else {\n        this.settings.src_folders = self.modulePaths\n      }\n      self.nightwatchArgv = this.argv\n      self.testSource = Nightwatch.ClientRunner.prototype.getTestSource.apply(this, arguments)\n\n      if (this.parallelMode) {\n        return self.testSource\n      }\n\n      this.argv = originalArgv\n      this.settings = originalSettings\n      this.settings.src_folders = this.settings.src_folders || []\n      return Nightwatch.ClientRunner.prototype.getTestSource.apply(this, arguments)\n    }\n\n    Nightwatch.ClientRunner.prototype.singleSourceFile = function () {\n      if (this.singleTestRun()) {\n        return self.isSingleFeatureFile(this.argv.test)\n      }\n\n      return (Array.isArray(this.argv._source) && this.argv._source.length === 1) && self.isSingleFeatureFile(this.argv._source[0])\n    }\n  }\n\n  addHookTests (revert) {\n    hookUtils.addHookBefore(Nightwatch.ChildProcess.prototype, 'getArgs', function () {\n      if (this.args.indexOf('--test') === -1) return\n\n      const cliArgs = this.args\n      const testIndex = cliArgs.indexOf('--test') + 1\n      cliArgs[testIndex] = revert(cliArgs[testIndex])\n    })\n  }\n\n  addPathConverter (convert, revert) {\n    this.overrideOriginalSourceGetter(convert)\n    this.addHookTests(revert)\n  }\n\n  addAssertionLogger () {\n    const self = this\n    if (!this.client) return\n    const originalAssertion = this.client.get().assertion\n    this.__originalAssertion = originalAssertion\n    this.client.get().assertion = function (passed, receivedValue, expectedValue, message, abortOnFailure, originalStackTrace) {\n      if (passed) {\n        if (self.colorsEnabled) {\n          console.log(`\\n ${Nightwatch.Logger.colors.green(Nightwatch.Utils.symbols.ok)} ${message}`)\n        } else {\n          console.log(`\\n ${Nightwatch.Utils.symbols.ok} ${message}`)\n        }\n      }\n      return originalAssertion.apply(this, arguments)\n    }\n  }\n\n  removeAssertionLogger () {\n    if (!this.client) return\n    this.client.get().assertion = this.__originalAssertion\n  }\n\n  overrideOriginalStartTestWorkers () {\n    const originalStartTestWorkers = Nightwatch.ClientRunner.prototype.startTestWorkers\n\n    Nightwatch.ClientRunner.prototype.startTestWorkers = function () {\n      this.test_settings.tag_filter = undefined\n      return originalStartTestWorkers.apply(this, arguments)\n    }\n  }\n\n  addHookAfterChildProcesses (hook) {\n    hookUtils.addCallbackedHookAfter(Nightwatch.ClientRunner.prototype, 'startChildProcesses', 1, hook)\n  }\n\n  isRunningInParallel () {\n    return process.env.__NIGHTWATCH_PARALLEL_MODE === '1'\n  }\n\n  getWorkerIndex () {\n    return process.env.__NIGHTWATCH_ENV_KEY.split('_').pop()\n  }\n\n  clearResult () {\n    this.client.get().clearResult()\n    this.client.get().results.lastError = null\n  }\n\n  start () {\n    return new Promise((resolve, reject) => {\n      this.client.get().once('nightwatch:finished', (results, errors) => {\n        const errorList = results.tests.filter(test => test.failure).map(test => {\n          const error = new Error(`${test.message} - ${test.failure}`)\n          error.stack = `\\n${test.stackTrace}`\n          return error\n        }).concat(errors.map(errorString => {\n          const cutPos = errorString.indexOf(':')\n          const error = new Error(errorString.substring(0, cutPos))\n          error.stack = errorString\n          return error\n        }))\n        this.clearResult()\n        if (errorList.length) {\n          reject(combineErrors(errorList))\n          return\n        }\n        resolve()\n      })\n      this.client.start()\n    })\n  }\n\n  addTestRunner (testRunner) {\n    const self = this\n    const originalRunnerRun = Nightwatch.Runner.prototype.run\n\n    Nightwatch.Runner.prototype.run = co.wrap(function * () {\n      const that = this\n      let error\n      let executionSuccess\n      const originalOptions = cloneDeep(this.options)\n      const originalAdditionalOpts = cloneDeep(this.additionalOpts)\n      this.additionalOpts.output_folder = false\n      this.options.output = false\n      this.options.tag_filter = undefined\n      this.options.end_session_on_fail = false\n      self.takeScreenshotOnFailure = this.options.screenshots &&\n        this.options.screenshots.enabled &&\n        this.options.screenshots.path &&\n        this.options.screenshots.on_failure\n\n      if (this.options.screenshots) this.options.screenshots.enabled = false\n\n      try {\n        const modules = yield new Promise((resolve, reject) => {\n          Nightwatch.Runner\n            .readPaths(self.testSource, that.options)\n            .spread(function (modulePaths, fullPaths) {\n              resolve(modulePaths)\n            }).then(resolve, reject)\n        })\n        self._startSession(this.options)\n        const executionResult = yield * testRunner(modules)\n        executionSuccess = !!executionResult.success\n      } catch (err) {\n        error = err\n      }\n\n      try {\n        if (self.client) {\n          self.client.endSessionOnFail(typeof originalOptions.end_session_on_fail === 'undefined' || originalOptions.end_session_on_fail)\n          yield * self._closeSession()\n        }\n      } catch (err) {\n        error = err\n      }\n\n      if (typeof process.send === 'function') {\n        process.send(JSON.stringify({\n          type: 'testsuite_finished',\n          itemKey: process.env.__NIGHTWATCH_ENV_LABEL,\n          moduleKey: 'moduleKey',\n          results: {\n            completed: {\n              ok: 1\n            }\n          },\n          errmessages: []\n        }))\n      }\n\n      this.options = originalOptions\n      this.additionalOpts = originalAdditionalOpts\n      self.removeAssertionLogger()\n\n      if (!originalAdditionalOpts.src_folders || !originalAdditionalOpts.src_folders.length || error || !executionSuccess) {\n        return this.doneCb(error || !executionSuccess, {})\n      }\n\n      return originalRunnerRun.apply(this, arguments)\n    })\n  }\n}\n\n'nightwatch-cucumber/lib/runner.js'\n:const fs = require('fs')\nconst path = require('path')\nconst tmp = require('tmp')\nconst glob = require('glob')\nconst mkdirp = require('mkdirp')\nconst pify = require('pify')\nconst dummyTestModulesFolder = tmp.dirSync({ unsafeCleanup: true }).name\nconst NightwatchApi = require('./nightwatch-api')\nconst CucumberApi = require('./cucumber-api')\n\ntmp.setGracefulCleanup()\n\nmodule.exports = class Runner {\n  constructor () {\n    this.originalFeaturePath = {}\n  }\n\n  getSourceFile (featureSource) {\n    if (featureSource.startsWith('@')) {\n      return featureSource.substr(1, featureSource.length - 1)\n    }\n    return featureSource\n  }\n\n  getFeatureFilesFromRerunFile (rerunFile) {\n    const data = fs.readFileSync(this.getSourceFile(rerunFile))\n    return data.toString()\n      .split('\\n')\n      .map(featurePath => featurePath.trim().replace(/(:\\d*)/g, ''))\n      // filter empty paths\n      .filter(featurePath => featurePath)\n  }\n\n  getFeatureDirectories () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n            .map(featurePath => path.dirname(featurePath))\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return featureSource\n        }\n        return path.dirname(featureSource)\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n  }\n\n  getFeatureFiles () {\n    return this.featureFiles\n      .map(featureSource => {\n        if (featureSource.startsWith('@')) {\n          return this.getFeatureFilesFromRerunFile(featureSource)\n        } else if (fs.statSync(featureSource).isDirectory()) {\n          return glob.sync(path.join(featureSource, '**/*.feature'))\n        }\n        return [featureSource]\n      })\n      // flatten\n      .reduce((paths, currentPaths) => paths.concat(currentPaths), [])\n      // make unique list\n      .filter((featureFilePath, idx, paths) => paths.indexOf(featureFilePath === idx))\n  }\n\n  generateDummyTestModules () {\n    this.getFeatureFiles().forEach((featureFile) => {\n      const dummyTestModuleFile = this.featurePathToDummyPath(featureFile)\n      mkdirp.sync(path.dirname(dummyTestModuleFile))\n      fs.writeFileSync(dummyTestModuleFile, '')\n    })\n  }\n\n  getTags (tags) {\n    tags = tags || []\n\n    if (typeof tags === 'string') {\n      tags = tags.split(',')\n    }\n\n    if (Array.isArray(tags)) {\n      return tags.map((tag) => `@${tag}`)\n    } else {\n      throw new Error(`Expected tags to be Array or String.`)\n    }\n  }\n\n  featurePathToDummyPath (featureFile) {\n    const lineNumberMatch = featureFile.match(/:(\\d+)$/)\n    let lineNumber\n    if (lineNumberMatch) {\n      lineNumber = parseInt(lineNumberMatch[1])\n      featureFile = featureFile.replace(/:\\d+$/, '')\n    }\n    try {\n      fs.statSync(featureFile)\n    } catch (err) {\n      if (!featureFile.match(/\\.feature$/)) featureFile += '.feature'\n      try {\n        fs.statSync(featureFile)\n      } catch (err) {\n        throw new Error(`Feature file or folder ${featureFile} was not found!`)\n      }\n    }\n\n    const dummyPath = path.join(dummyTestModulesFolder, featureFile.replace(/\\.feature$/, '.js'))\n\n    this.originalFeaturePath[dummyPath] = lineNumber ? `${featureFile}:${lineNumber}` : featureFile\n\n    return dummyPath\n  }\n\n  dummyPathToFeaturePath (dummyPath) {\n    if (!dummyPath.match(/\\.js$/)) dummyPath += '.js'\n\n    return this.originalFeaturePath[dummyPath] || dummyPath\n  }\n\n  addIndexToFileName (fileName, index) {\n    const cutIndex = fileName.lastIndexOf('.')\n    const ext = fileName.slice(cutIndex)\n    const rest = fileName.slice(0, cutIndex)\n    return `${rest}-${index}${ext}`\n  }\n\n  * executeTestModules (dummyTestModules) {\n    const featureFiles = dummyTestModules.map((dummyTestModule) => this.dummyPathToFeaturePath(dummyTestModule))\n\n    if (this.nightwatchApi.isRunningInParallel()) {\n      const workerIndex = this.nightwatchApi.getWorkerIndex()\n      this.jsonReport = this.addIndexToFileName(this.jsonReport, workerIndex)\n    }\n\n    if (this.jsonReport) {\n      yield pify(mkdirp)(path.dirname(this.jsonReport))\n    }\n    const cucumberArgs = this.cucumberApi.getAdjustedArgs({\n      args: this.options.cucumberArgs,\n      featureFiles,\n      jsonReport: this.jsonReport,\n      tags: this.getTags(this.nightwatchApi.nightwatchArgv.tag),\n      skipTags: this.getTags(this.nightwatchApi.nightwatchArgv.skiptags)\n    })\n    return yield * this.cucumberApi.run(cucumberArgs)\n  }\n\n  areColorsEnabled () {\n    const formatOptionsIndex = this.options.cucumberArgs.indexOf('--format-options')\n    if (formatOptionsIndex < 0) return true\n    const formatOptions = JSON.parse(this.options.cucumberArgs[formatOptionsIndex + 1])\n    return typeof formatOptions.colorsEnabled === 'undefined' ? true : formatOptions.colorsEnabled\n  }\n\n  run (options) {\n    const self = this\n    this.options = options\n    this.nightwatchApi = new NightwatchApi(options, this.areColorsEnabled())\n    this.cucumberApi = new CucumberApi(options)\n    this.jsonReport = this.cucumberApi.getJSONReportName(options.cucumberArgs)\n    this.featureFiles = this.cucumberApi.getFeatureFiles(options.cucumberArgs)\n    this.featureFiles\n      .map(this.getSourceFile)\n      .forEach((featureSource) => {\n        try {\n          fs.statSync(featureSource)\n        } catch (err) {\n          throw new Error(`Feature source ${featureSource} doesn't exists`)\n        }\n      })\n\n    // enforce relative paths so path.join() works on Windows\n    this.featureFiles = this.featureFiles.map((currentPath) => {\n      return path.isAbsolute(currentPath) ? path.relative(process.cwd(), currentPath) : currentPath\n    })\n\n    const dummyPaths = this.getFeatureDirectories().map(srcPath => path.join(dummyTestModulesFolder, srcPath))\n\n    this.generateDummyTestModules()\n\n    this.cucumberApi.injectTimeoutHandler()\n    this.cucumberApi.addAttachmentProvider(this.nightwatchApi.takeScreenshot.bind(this.nightwatchApi))\n\n    this.nightwatchApi.addTestModulePaths(dummyPaths)\n    this.nightwatchApi.addPathConverter(this.featurePathToDummyPath.bind(this), this.dummyPathToFeaturePath.bind(this))\n    this.nightwatchApi.overrideOriginalStartTestWorkers()\n    this.nightwatchApi.addTestRunner(this.executeTestModules.bind(this))\n    this.nightwatchApi.addHookAfterChildProcesses(function * () {\n      const reports = yield pify(glob)(self.addIndexToFileName(self.jsonReport, '*'))\n      yield * self.cucumberApi.mergeCucumberJsonReports(reports, self.jsonReport)\n    })\n  }\n}\n\n'nightwatch-cucumber/lib/index.js'\n:let runner\n\nmodule.exports = function (providedOptions) {\n  const options = Object.assign({\n    cucumberArgs: [\n      '--require', 'features/step_definitions',\n      '--format', 'json:reports/cucumber.json',\n      'features'\n    ],\n    nightwatchOutput: true\n  }, providedOptions)\n\n  const Runner = require('./runner')\n  runner = new Runner()\n  runner.run(options)\n}\n\nfunction getPageProxy (subPages) {\n  return new Proxy(() => getClientProxy(subPages), {\n    get: (target, pageName) => getPageProxy(subPages.concat([pageName]))\n  })\n}\n\nfunction getClientProxy (subPages) {\n  return new Proxy({}, {\n    get: (target, name) => {\n      if (name !== 'page') {\n        const api = runner.nightwatchApi.getClientApi()\n\n        if (!subPages.length) {\n          return api[name]\n        }\n\n        return subPages.reduce((api, pageName) => {\n          return api[pageName]\n        }, api.page)()[name]\n      }\n\n      return getPageProxy([])\n    }\n  })\n}\n\nmodule.exports.client = getClientProxy([])\n\nmodule.exports.Section = new Proxy(function () {}, {\n  construct (target, args) {\n    return new runner.nightwatchApi.Section(...args)\n  }\n})\n\n",
        "called_code_segment_file_1": "function addHookBefore (target, functionName, hook) { const original = target[functionName]; target[functionName] = function () { hook.apply(this, arguments); return original.apply(this, arguments); }; }",
        "invoking_code_segment_file_2": "hookUtils.addHookBefore(Nightwatch.ChildProcess.prototype, 'getArgs', function () { if (this.args.indexOf('--test') === -1) return; const cliArgs = this.args; const testIndex = cliArgs.indexOf('--test') + 1; cliArgs[testIndex] = revert(cliArgs[testIndex]); });",
        "called_code_segment_file_2": "function addHookBefore (target, functionName, hook) { const original = target[functionName]; target[functionName] = function () { hook.apply(this, arguments); return original.apply(this, arguments); }; }",
        "using_code_segment_file_3": "hookUtils.addHookBefore(Nightwatch.ChildProcess.prototype, 'getArgs', function () { if (this.args.indexOf('--test') === -1) return; const cliArgs = this.args; const testIndex = cliArgs.indexOf('--test') + 1; cliArgs[testIndex] = revert(cliArgs[testIndex]); });",
        "called_code_segment_file_3": "function addHookBefore (target, functionName, hook) { const original = target[functionName]; target[functionName] = function () { hook.apply(this, arguments); return original.apply(this, arguments); }; }",
        "using_code_segment_file_4": "hookUtils.addHookBefore(Nightwatch.ChildProcess.prototype, 'getArgs', function () { if (this.args.indexOf('--test') === -1) return; const cliArgs = this.args; const testIndex = cliArgs.indexOf('--test') + 1; cliArgs[testIndex] = revert(cliArgs[testIndex]); });",
        "feature_description": "Add a new feature to log the arguments before invoking the original function in the addHookBefore method.",
        "detailed_feature_description": "The new feature will log the arguments passed to the hook function before invoking the original function. This will be implemented by modifying the addHookBefore method in #file 1. The modification will be propagated to #file 2, which invokes this method. Since #file 3 directly interacts with the modified segment in #file 2, it will also be updated. Finally, #file 4, which depends on #file 3, will be updated to accommodate any changes.",
        "modified_complete_code": {
            "#file 1": "function addHookBefore (target, functionName, hook) { const original = target[functionName]; target[functionName] = function () { console.log('Arguments:', arguments); //Modify hook.apply(this, arguments); return original.apply(this, arguments); }; }",
            "#file 2": "hookUtils.addHookBefore(Nightwatch.ChildProcess.prototype, 'getArgs', function () { if (this.args.indexOf('--test') === -1) return; const cliArgs = this.args; const testIndex = cliArgs.indexOf('--test') + 1; cliArgs[testIndex] = revert(cliArgs[testIndex]); });",
            "#file 3": "hookUtils.addHookBefore(Nightwatch.ChildProcess.prototype, 'getArgs', function () { if (this.args.indexOf('--test') === -1) return; const cliArgs = this.args; const testIndex = cliArgs.indexOf('--test') + 1; cliArgs[testIndex] = revert(cliArgs[testIndex]); });",
            "#file 4": "hookUtils.addHookBefore(Nightwatch.ChildProcess.prototype, 'getArgs', function () { if (this.args.indexOf('--test') === -1) return; const cliArgs = this.args; const testIndex = cliArgs.indexOf('--test') + 1; cliArgs[testIndex] = revert(cliArgs[testIndex]); });"
        }
    },
    {
        "repo": "mediumdesk-v1",
        "content": "'mediumdesk-v1/src/common.js'\n:'use strict';\nclass Common {\n}\n\nCommon.ELECTRON = 'Electron';\nCommon.DEBUG_MODE = false;\nCommon.WINDOW_SIZE = {width: 1050, height: 700};\nCommon.USER_AGENT = 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36';\n\nCommon.MEDIUM_HOME = 'https://medium.com/';\nCommon.GITHUB = 'https://github.com/sivragav/mediumdesk';\nCommon.GITHUB_RELEASES = 'https://github.com/sivragav/mediumdesk/releases';\nCommon.GITHUB_ISSUES = 'https://github.com/sivragav/mediumdesk/issues';\nCommon.GITHUB_API_HOST = 'api.github.com';\nCommon.GITHUB_API_RELEASE_LATEST_PATH = '/repos/sivragav/mediumdesk/releases/latest';\n\nCommon.UPDATE_ERROR_ELECTRON = `Failed to get the local version. If you are using debug mode(by using npm start), this error would happen. Use packed app instead or manually check for updates.\\n\\n ${Common.GITHUB_RELEASES}`;\nCommon.UPDATE_ERROR_EMPTY_RESPONSE = 'Failed to fetch release info.';\nCommon.UPDATE_ERROR_UNKNOWN = 'Something went wrong.';\nCommon.UPDATE_NA_TITLE = 'No Update Available';\nCommon.UPDATE_ERROR_NETWORK = 'Connection hang up unexpectedly. Check your network settings.';\nCommon.UPDATE_ERROR_LATEST = version => {\n  return `You are using the latest version(${version}).`;\n};\n\nmodule.exports = Common;\n\n'mediumdesk-v1/src/update.js'\n:'use strict';\nconst {dialog, shell, app, nativeImage} = require('electron');\nconst https = require('https');\nconst Common = require('./common');\n\nclass UpdateHandler {\n  checkForUpdate(version, silent) {\n    let promise = new Promise((res, rej) => {\n      if (Common.ELECTRON == app.getName()) {\n        rej(Common.UPDATE_ERROR_ELECTRON);\n      }\n      let req = https.get({\n        host: Common.GITHUB_API_HOST,\n        headers: {'user-agent': Common.USER_AGENT},\n        path: Common.GITHUB_API_RELEASE_LATEST_PATH\n      }, (response) => {\n        let body = '';\n        response.on('data', (d) => {\n          body += d;\n        });\n        response.on('end', () => {\n          this._parseUpdateData(body, version, res, rej);\n        });\n      });\n      req.on('error', (err) => {\n        rej(Common.UPDATE_ERROR_NETWORK);\n      });\n      req.end();\n    }).then((fetched) => {\n      this.showDialog(fetched.name, fetched.description, \"Update\", (response) => {\n        if (!response) return;\n        shell.openExternal(fetched.url);\n      });\n    }).catch((message) => {\n      if (silent) return;\n      if (!message) {\n        message = Common.UPDATE_ERROR_UNKNOWN;\n      }\n      this.showDialog(Common.UPDATE_NA_TITLE, message, \"OK\");\n    });\n  }\n\n  showDialog(message, detail, positive_button, callback) {\n    const path = require('path');\n    let iconImage = nativeImage.createFromPath(path.join(__dirname, '../assets/icon.png'));\n\n    dialog.showMessageBox({\n      type: 'info',\n      buttons: ['Cancel', positive_button],\n      defaultId: 1,\n      cancelId: 0,\n      title: message,\n      message: message,\n      detail: detail,\n      icon: iconImage\n    }, callback);\n  }\n\n  _parseUpdateData(body, version, res, rej) {\n    let data = JSON.parse(body);\n    if (!data || !data.tag_name) rej(Common.UPDATE_ERROR_EMPTY_RESPONSE);\n    let fetched = {\n      version: data.tag_name,\n      is_prerelease: data.prerelease,\n      name: data.name,\n      url: data.html_url,\n      description: data.body\n    };\n\n    let version_regex = /^v[0-9]+\\.[0-9]+\\.*[0-9]*$/;\n    if (version_regex.test(fetched.version) && fetched.version > version && !fetched.is_prerelease) {\n      res(fetched);\n    } else {\n      rej(Common.UPDATE_ERROR_LATEST(version));\n    }\n  };\n}\n\n\nmodule.exports = UpdateHandler;\n\n'mediumdesk-v1/src/menu.js'\n:'use strict';\nconst os = require('os');\nconst path = require('path');\nconst electron = require('electron');\nconst app = electron.app;\nconst BrowserWindow = electron.BrowserWindow;\nconst shell = electron.shell;\nconst appName = app.getName();\nconst UpdateHandler = require('./update');\n\nconst params = {};\n\nfunction sendAction(action) {\n\tconst win = BrowserWindow.getAllWindows()[0];\n\n\tif (process.platform === 'darwin') {\n\t\twin.restore();\n\t}\n\n\twin.webContents.send(action);\n}\n\nfunction checkUpdate() {\n\tconst updateHandler = new UpdateHandler();\n\tupdateHandler.checkForUpdate(`v${app.getVersion()}`, false);\n}\n\nconst helpSubmenu = [\n\t{\n\t\tlabel: `${appName} Website...`,\n\t\tclick() {\n\t\t\tshell.openExternal('https://medium.com/desktop-apps');\n\t\t}\n\t},\n\t{\n\t\tlabel: `Medium Website...`,\n\t\tclick() {\n\t\t\tshell.openExternal('https://medium.com');\n\t\t}\n\t},\n\t{\n\t\ttype: 'separator'\n\t},\n\t{\n\t\tlabel: `Check for updates...`,\n\t\tclick() {\n\t\t\tcheckUpdate();\n\t\t}\n\t},\n\t{\n\t\tlabel: 'Report an Issue...',\n\t\tclick() {\n\t\t\tconst body = `\n<< Please succinctly describe your issue and steps to reproduce it. >>\n\n----\n${app.getName()} ${app.getVersion()}\nElectron ${process.versions.electron}\n${process.platform} ${process.arch} ${os.release()}`;\n\n\t\t\tshell.openExternal(`https://github.com/sivragav/mediumdesk/issues/new?body=${encodeURIComponent(body)}`);\n\t\t}\n\t}\n];\n\nconst viewSubmenu = [\n\t{\n\t\tlabel: `Reload`,\n\t\taccelerator: 'CmdOrCtrl+R',\n\t\tclick() {\n\t\t\tconst win = BrowserWindow.getAllWindows()[0];\n\t\t\twin.reload();\n\t\t}\n\t},\n\t{\n\t\tlabel: `Back`,\n\t\taccelerator: `CmdOrCtrl+[`,\n\t\tclick() {\n\t\t\tsendAction('go-back');\n\t\t}\n\t},\n\t{\n\t\tlabel: `Forward`,\n\t\taccelerator: `CmdOrCtrl+]`,\n\t\tclick() {\n\t\t\tsendAction('go-forward');\n\t\t}\n\t}\n];\n\nif (process.platform !== 'darwin') {\n\thelpSubmenu.push({\n\t\ttype: 'separator'\n\t}, {\n\t\tlabel: `About ${appName}`,\n\t\tclick() {\n\t\t\telectron.dialog.showMessageBox({\n\t\t\t\ttitle: `About ${appName}`,\n\t\t\t\tmessage: `${appName} ${app.getVersion()}`,\n\t\t\t\tdetail: 'Created by Sivaprakash Ragavan',\n\t\t\t\ticon: path.join(__dirname, '../static/Icon.png'),\n\t\t\t\tbuttons: []\n\t\t\t});\n\t\t}\n\t});\n}\n\nconst darwinTpl = [\n\t{\n\t\tlabel: appName,\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: `About ${appName}`,\n\t\t\t\trole: 'about'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Preferences...',\n\t\t\t\taccelerator: 'Cmd+,',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Services',\n\t\t\t\trole: 'services',\n\t\t\t\tsubmenu: []\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: `Hide ${appName}`,\n\t\t\t\taccelerator: 'Cmd+H',\n\t\t\t\trole: 'hide'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Hide Others',\n\t\t\t\taccelerator: 'Cmd+Shift+H',\n\t\t\t\trole: 'hideothers'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Show All',\n\t\t\t\trole: 'unhide'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: `Quit ${appName}`,\n\t\t\t\taccelerator: 'Cmd+Q',\n\t\t\t\tclick() {\n\t\t\t\t\tapp.quit();\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'File',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'New Story',\n\t\t\t\taccelerator: 'Cmd+N',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-new');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Import from disk...',\n\t\t\t\taccelerator: 'Cmd+O',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-file');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Search Medium',\n\t\t\t\taccelerator: 'Cmd+Shift+F',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-search');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Home',\n\t\t\t\taccelerator: 'Cmd+0',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-home');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Drafts',\n\t\t\t\taccelerator: 'Cmd+1',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-drafts');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stories',\n\t\t\t\taccelerator: 'Cmd+2',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stories');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stats',\n\t\t\t\taccelerator: 'Cmd+3',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stats');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bookmarks',\n\t\t\t\taccelerator: 'Cmd+4',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-bookmarks');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Publications',\n\t\t\t\taccelerator: 'Cmd+5',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-pubs');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Profile',\n\t\t\t\taccelerator: 'Cmd+6',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-profile');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Settings',\n\t\t\t\taccelerator: 'Cmd+7',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Login',\n\t\t\t\taccelerator: 'Cmd+8',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-login');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Open in Browser',\n\t\t\t\taccelerator: 'Cmd+9',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-in-browser')\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Edit',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Undo',\n\t\t\t\taccelerator: 'Cmd+Z',\n\t\t\t\trole: 'undo'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Redo',\n\t\t\t\taccelerator: 'Shift+Cmd+Z',\n\t\t\t\trole: 'redo'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Cut',\n\t\t\t\taccelerator: 'Cmd+X',\n\t\t\t\trole: 'cut'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Copy',\n\t\t\t\taccelerator: 'Cmd+C',\n\t\t\t\trole: 'copy'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Paste',\n\t\t\t\taccelerator: 'Cmd+V',\n\t\t\t\trole: 'paste'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Select All',\n\t\t\t\taccelerator: 'Cmd+A',\n\t\t\t\trole: 'selectall'\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'View',\n\t\tsubmenu: viewSubmenu\n\t},\n\t{\n\t\tlabel: 'Window',\n\t\trole: 'window',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Minimize',\n\t\t\t\taccelerator: 'Cmd+M',\n\t\t\t\trole: 'minimize'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Close',\n\t\t\t\taccelerator: 'Cmd+W',\n\t\t\t\trole: 'close'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bring All to Front',\n\t\t\t\trole: 'front'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Toggle Full Screen',\n\t\t\t\taccelerator: 'Ctrl+Cmd+F',\n\t\t\t\tclick() {\n\t\t\t\t\tconst win = BrowserWindow.getAllWindows()[0];\n\t\t\t\t\twin.setFullScreen(!win.isFullScreen());\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Help',\n\t\trole: 'help',\n\t\tsubmenu: helpSubmenu\n\t}\n];\n\nconst otherTpl = [\n\t{\n\t\tlabel: 'File',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'New Story',\n\t\t\t\taccelerator: 'Ctrl+N',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-new');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Import from disk...',\n\t\t\t\taccelerator: 'Ctrl+O',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-file');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Search Medium',\n\t\t\t\taccelerator: 'Ctrl+Shift+F',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-search');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Home',\n\t\t\t\taccelerator: 'Ctrl+0',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-home');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Drafts',\n\t\t\t\taccelerator: 'Ctrl+1',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-drafts');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stories',\n\t\t\t\taccelerator: 'Ctrl+2',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stories');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Stats',\n\t\t\t\taccelerator: 'Ctrl+3',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-stats');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Bookmarks',\n\t\t\t\taccelerator: 'Ctrl+4',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-bookmarks');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Publications',\n\t\t\t\taccelerator: 'Ctrl+5',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-pubs');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Profile',\n\t\t\t\taccelerator: 'Ctrl+6',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-profile');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Settings',\n\t\t\t\taccelerator: 'Ctrl+7',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-settings');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Login',\n\t\t\t\taccelerator: 'Ctrl+8',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-login');\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\ttype: 'separator'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Open in Browser',\n\t\t\t\taccelerator: 'Ctrl+9',\n\t\t\t\tclick() {\n\t\t\t\t\tsendAction('open-in-browser')\n\t\t\t\t}\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Quit',\n\t\t\t\taccelerator: 'Ctrl+W',\n\t\t\t\tclick() {\n\t\t\t\t\tapp.quit();\n\t\t\t\t}\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'Edit',\n\t\tsubmenu: [\n\t\t\t{\n\t\t\t\tlabel: 'Cut',\n\t\t\t\taccelerator: 'Ctrl+X',\n\t\t\t\trole: 'cut'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Copy',\n\t\t\t\taccelerator: 'Ctrl+C',\n\t\t\t\trole: 'copy'\n\t\t\t},\n\t\t\t{\n\t\t\t\tlabel: 'Paste',\n\t\t\t\taccelerator: 'Ctrl+V',\n\t\t\t\trole: 'paste'\n\t\t\t}\n\t\t]\n\t},\n\t{\n\t\tlabel: 'View',\n\t\tsubmenu: viewSubmenu\n\t},\n\t{\n\t\tlabel: 'Help',\n\t\trole: 'help',\n\t\tsubmenu: helpSubmenu\n\t}\n];\n\nexports.build = () => {\n\tconsole.log(params);\n\tconst tpl = process.platform === 'darwin' ? darwinTpl : otherTpl;\n\treturn electron.Menu.buildFromTemplate(tpl);\n};\n\nexports.setParam = (name, value) => {\n\tparams[name] = value;\n};\n\nexports.getParam = name => {\n\treturn params[name];\n};\n\n'mediumdesk-v1/src/index.js'\n:'use strict';\nconst path = require('path');\nconst fs = require('fs');\nconst electron = require('electron');\nconst app = electron.app;\nconst menu = require('./menu');\nconst Store = require('electron-store');\nconst storage = new Store();\nconst navigate = require('./navigate');\nconst tray = require('./tray');\nconst UpdateHandler = require('./update');\nconst Common = require('./common');\nconst {ipcMain} = require('electron');\nconst mediumapi = require('./mediumapi');\n\nrequire('electron-debug')();\nrequire('electron-dl')();\n\nlet mainWindow;\nlet isQuitting = false;\n\nconst isAlreadyRunning = app.makeSingleInstance(() => {\n\tif (mainWindow) {\n\t\tif (mainWindow.isMinimized()) {\n\t\t\tmainWindow.restore();\n\t\t}\n\t\tmainWindow.show();\n\t}\n});\n\nif (isAlreadyRunning) {\n\tapp.quit();\n}\n\nfunction createMainWindow() {\n\tconst lastWindowState = storage.get('lastWindowState') || Common.WINDOW_SIZE;\n\n\tconst win = new electron.BrowserWindow({\n\t\ttitle: app.getName(),\n\t\tshow: false,\n\t\tx: lastWindowState.x,\n\t\ty: lastWindowState.y,\n\t\twidth: lastWindowState.width,\n\t\theight: lastWindowState.height,\n\t\ticon: process.platform === 'linux' && path.join(__dirname, '../static/Icon.png'),\n\t\tminWidth: 992,\n\t\tminHeight: 450,\n\t\t// titleBarStyle: 'hidden-inset',\n\t\t// autoHideMenuBar: true,\n\t\twebPreferences: {\n\t\t\t// fails without this because of CommonJS script detection\n\t\t\tnodeIntegration: false,\n\t\t\tpreload: path.join(__dirname, 'browser.js'),\n\t\t\twebSecurity: true,\n\t\t\tplugins: true\n\t\t}\n\t});\n\n\tlet startPage = null;\n\tswitch(storage.get('start-page')) {\n\t\tcase 'home':\n\t\t\tstartPage = Common.MEDIUM_HOME;\n\t\t\tbreak;\n\t\tcase 'new':\n\t\t\tstartPage = 'https://medium.com/new-story';\n\t\t\tbreak;\n\t\tcase 'drafts':\n\t\t\tstartPage = 'https://medium.com/me/stories/drafts';\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstartPage = Common.MEDIUM_HOME;\n\t\t\tbreak;\n\t}\n\n\twin.loadURL(startPage);\n\twin.on('close', e => {\n\t\tif (!isQuitting) {\n\t\t\te.preventDefault();\n\n\t\t\tif (process.platform === 'darwin') {\n\t\t\t\tapp.hide();\n\t\t\t} else {\n\t\t\t\twin.hide();\n\t\t\t}\n\t\t}\n\t});\n\n\treturn win;\n}\n\napp.on('ready', () => {\n\telectron.Menu.setApplicationMenu(menu.build());\n\tmainWindow = createMainWindow();\n\ttray.create(mainWindow);\n\n\tconst page = mainWindow.webContents;\n\n\tpage.on('dom-ready', () => {\n\t\tpage.insertCSS(fs.readFileSync(path.join(__dirname, 'styles/browser.css'), 'utf8'));\n\t\tmainWindow.show();\n\t});\n\n\tpage.on('did-navigate', navigate.onNavigate);\n\tpage.on('did-navigate-in-page', navigate.onNavigate);\n\n\tpage.on('new-window', (e, url) => {\n\t\te.preventDefault();\n\t\telectron.shell.openExternal(url);\n\t});\n\n\tnew UpdateHandler().checkForUpdate(`v${app.getVersion()}`, true);\n});\n\napp.on('activate', () => {\n\tmainWindow.show();\n});\n\napp.on('before-quit', () => {\n\tisQuitting = true;\n\n\tif (!mainWindow.isFullScreen()) {\n\t\tstorage.set('lastWindowState', mainWindow.getBounds());\n\t}\n});\n\n// Messages\nipcMain.on('import-file', (event, file) => {\n\tconsole.log(\"Importing : \" + file);\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\tshowLoadingMessage('Importing from disk...');\n\tsetTimeout(() => {\n\t\ttry {\n\t\t\tfs.openSync(file, 'r+');\n\t\t\tvar data = fs.readFileSync(file).toString();\n\t\t\tmediumapi.publish(\"\", data, file.endsWith(\"html\") | file.endsWith(\"html\") ? \"html\" : \"markdown\", [],\n\t\t\t\t(error, statusCode, headers, body) => {\n\t\t\t\t\tif(error || !(statusCode == 200 || statusCode == 201)) {\n\t\t\t\t\t\tconsole.log('Error: ', error);\n\t\t\t\t\t\tconsole.log('Status: ', statusCode);\n\t\t\t\t\t\tconsole.log('Headers: ', JSON.stringify(headers));\n\t\t\t\t\t\tconsole.log('Body: ', body);\n\t\t\t\t\t\tif(body) {\n\t\t\t\t\t\t\tvar bodyContents = JSON.parse(body);\n\t\t\t\t\t\t\tshowErrorMessage(bodyContents[\"errors\"][0][\"message\"]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshowErrorMessage('Unknown Error Occured');\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('Reponse from Medium: ', body);\n\t\t\t\t\t\tvar bodyContents = JSON.parse(body);\n\t\t\t\t\t\tconst url = bodyContents[\"data\"][\"url\"];\n\t\t\t\t\t\tif(url) {\n\t\t\t\t\t\t\twin.loadURL(url);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tshowErrorMessage('Error loading Draft');\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tconsole.error('Couldn\\'t read file' + err);\n\t\t\tshowErrorMessage('Error reading file');\n\t\t}\n\t}, 100);\n});\n\nfunction showLoadingMessage(msg) {\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\twin.loadURL('file://' + __dirname + '/pages/message.html?msg=' + encodeURIComponent(msg) + '&loading=true');\n}\n\nfunction showErrorMessage(msg) {\n\tconst win = electron.BrowserWindow.getAllWindows()[0];\n\twin.loadURL('file://' + __dirname + '/pages/message.html?msg=' + encodeURIComponent(msg) + '&error=true');\n\tsetTimeout(() => {\n\t\twin.loadURL(Common.MEDIUM_HOME);\n\t}, 2500);\n}\n\n",
        "called_code_segment_file_1": "Common.UPDATE_ERROR_ELECTRON = `Failed to get the local version. If you are using debug mode(by using npm start), this error would happen. Use packed app instead or manually check for updates.\n\n ${Common.GITHUB_RELEASES}`;",
        "invoking_code_segment_file_2": "if (Common.ELECTRON == app.getName()) {\n        rej(Common.UPDATE_ERROR_ELECTRON);\n      }",
        "called_code_segment_file_2": "checkForUpdate(version, silent) {\n    let promise = new Promise((res, rej) => {\n      if (Common.ELECTRON == app.getName()) {\n        rej(Common.UPDATE_ERROR_ELECTRON);\n      }\n      let req = https.get({\n        host: Common.GITHUB_API_HOST,\n        headers: {'user-agent': Common.USER_AGENT},\n        path: Common.GITHUB_API_RELEASE_LATEST_PATH\n      }, (response) => {\n        let body = '';\n        response.on('data', (d) => {\n          body += d;\n        });\n        response.on('end', () => {\n          this._parseUpdateData(body, version, res, rej);\n        });\n      });\n      req.on('error', (err) => {\n        rej(Common.UPDATE_ERROR_NETWORK);\n      });\n      req.end();\n    }).then((fetched) => {\n      this.showDialog(fetched.name, fetched.description, \"Update\", (response) => {\n        if (!response) return;\n        shell.openExternal(fetched.url);\n      });\n    }).catch((message) => {\n      if (silent) return;\n      if (!message) {\n        message = Common.UPDATE_ERROR_UNKNOWN;\n      }\n      this.showDialog(Common.UPDATE_NA_TITLE, message, \"OK\");\n    });\n  }",
        "using_code_segment_file_3": "const updateHandler = new UpdateHandler();\nupdateHandler.checkForUpdate(`v${app.getVersion()}`, false);",
        "called_code_segment_file_3": "showDialog(message, detail, positive_button, callback) {\n    const path = require('path');\n    let iconImage = nativeImage.createFromPath(path.join(__dirname, '../assets/icon.png'));\n\n    dialog.showMessageBox({\n      type: 'info',\n      buttons: ['Cancel', positive_button],\n      defaultId: 1,\n      cancelId: 0,\n      title: message,\n      message: message,\n      detail: detail,\n      icon: iconImage\n    }, callback);\n  }",
        "using_code_segment_file_4": "dialog.showMessageBox({\n      title: `About ${appName}`,\n      message: `${appName} ${app.getVersion()}`,\n      detail: 'Created by Sivaprakash Ragavan',\n      icon: path.join(__dirname, '../static/Icon.png'),\n      buttons: []\n    });",
        "feature_description": "Add a feature to log the update check result to a file.",
        "detailed_feature_description": "Modify the UpdateHandler class in #file 2 to log the result of the update check to a file. Update the checkForUpdate method to write the result (whether an update is available or not) to a log file. Ensure that the logging mechanism is implemented in a way that it can be reused in other parts of the application. Update #file 3 to use this logging mechanism when invoking the update check. If #file 4 interacts with #file 3, ensure that any related code segments are updated accordingly.",
        "modified_complete_code": {
            "file_1": "Common.UPDATE_ERROR_ELECTRON = `Failed to get the local version. If you are using debug mode(by using npm start), this error would happen. Use packed app instead or manually check for updates.\n\n ${Common.GITHUB_RELEASES}`;",
            "file_2": "#Modify\nclass UpdateHandler {\n  checkForUpdate(version, silent) {\n    let promise = new Promise((res, rej) => {\n      if (Common.ELECTRON == app.getName()) {\n        rej(Common.UPDATE_ERROR_ELECTRON);\n      }\n      let req = https.get({\n        host: Common.GITHUB_API_HOST,\n        headers: {'user-agent': Common.USER_AGENT},\n        path: Common.GITHUB_API_RELEASE_LATEST_PATH\n      }, (response) => {\n        let body = '';\n        response.on('data', (d) => {\n          body += d;\n        });\n        response.on('end', () => {\n          this._parseUpdateData(body, version, res, rej);\n        });\n      });\n      req.on('error', (err) => {\n        rej(Common.UPDATE_ERROR_NETWORK);\n      });\n      req.end();\n    }).then((fetched) => {\n      this.logUpdateResult(fetched);\n      this.showDialog(fetched.name, fetched.description, \"Update\", (response) => {\n        if (!response) return;\n        shell.openExternal(fetched.url);\n      });\n    }).catch((message) => {\n      this.logUpdateResult({error: message});\n      if (silent) return;\n      if (!message) {\n        message = Common.UPDATE_ERROR_UNKNOWN;\n      }\n      this.showDialog(Common.UPDATE_NA_TITLE, message, \"OK\");\n    });\n  }\n\n  #New\n  logUpdateResult(result) {\n    const fs = require('fs');\n    const path = require('path');\n    const logFilePath = path.join(__dirname, 'update_log.txt');\n    const logEntry = `[${new Date().toISOString()}] Update Check Result: ${JSON.stringify(result)}\\n`;\n    fs.appendFileSync(logFilePath, logEntry);\n  }\n}",
            "file_3": "#Modify\nconst updateHandler = new UpdateHandler();\nupdateHandler.checkForUpdate(`v${app.getVersion()}`, false);",
            "file_4": "dialog.showMessageBox({\n      title: `About ${appName}`,\n      message: `${appName} ${app.getVersion()}`,\n      detail: 'Created by Sivaprakash Ragavan',\n      icon: path.join(__dirname, '../static/Icon.png'),\n      buttons: []\n    });"
        }
    },
    {
        "repo": "relay-subscriptions",
        "content": "'relay-subscriptions/examples/todo/js/subscriptions/UpdateTodoSubscription.js'\n:import Relay from 'react-relay/classic';\nimport { Subscription } from 'relay-subscriptions';\n\nimport Todo from '../components/Todo';\n\nexport default class UpdateTodoSubscription extends Subscription {\n  static fragments = {\n    todo: () => Relay.QL`\n      fragment on Todo {\n        id\n      }\n    `,\n  };\n\n  getSubscription() {\n    return Relay.QL`\n      subscription {\n        updateTodoSubscription(input: $input) {\n          todo {\n            ${Todo.getFragment('todo')}\n          }\n          viewer {\n            id\n            completedCount\n          }\n        }\n      }\n    `;\n  }\n\n  getConfigs() {\n    return [{\n      type: 'FIELDS_CHANGE',\n      fieldIDs: {\n        todo: this.props.todo.id,\n      },\n    }];\n  }\n\n  getVariables() {\n    return {\n      id: this.props.todo.id,\n    };\n  }\n}\n\n'relay-subscriptions/examples/todo/js/components/Todo.js'\n:/**\n * This file provided by Facebook is for non-commercial testing and evaluation\n * purposes only.  Facebook reserves all rights not expressly granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport classNames from 'classnames';\nimport React from 'react';\nimport Relay from 'react-relay/classic';\nimport RelaySubscriptions from 'relay-subscriptions';\n\nimport ChangeTodoStatusMutation from '../mutations/ChangeTodoStatusMutation';\nimport RemoveTodoMutation from '../mutations/RemoveTodoMutation';\nimport RenameTodoMutation from '../mutations/RenameTodoMutation';\nimport UpdateTodoSubscription from '../subscriptions/UpdateTodoSubscription';\nimport TodoTextInput from './TodoTextInput';\n\nclass Todo extends React.Component {\n  static propTypes = {\n    viewer: React.PropTypes.object.isRequired,\n    todo: React.PropTypes.object.isRequired,\n    relay: React.PropTypes.object.isRequired,\n  };\n\n  state = {\n    isEditing: false,\n  };\n\n  _handleCompleteChange = (e) => {\n    const { relay, todo, viewer } = this.props;\n    relay.commitUpdate(\n      new ChangeTodoStatusMutation({\n        todo,\n        viewer,\n        complete: e.target.checked,\n      }),\n    );\n  };\n\n  _handleDestroyClick = () => {\n    this._removeTodo();\n  };\n\n  _handleLabelDoubleClick = () => {\n    this._setEditMode(true);\n  };\n\n  _handleTextInputCancel = () => {\n    this._setEditMode(false);\n  };\n\n  _handleTextInputDelete = () => {\n    this._setEditMode(false);\n    this._removeTodo();\n  };\n\n  _handleTextInputSave = (text) => {\n    this._setEditMode(false);\n    const { relay, todo } = this.props;\n    relay.commitUpdate(\n      new RenameTodoMutation({ todo, text }),\n    );\n  };\n\n  _removeTodo() {\n    const { relay, todo, viewer } = this.props;\n    relay.commitUpdate(\n      new RemoveTodoMutation({ todo, viewer }),\n    );\n  }\n\n  _setEditMode = (shouldEdit) => {\n    this.setState({ isEditing: shouldEdit });\n  };\n\n  renderTextInput() {\n    return (\n      <TodoTextInput\n        className=\"edit\"\n        commitOnBlur\n        initialValue={this.props.todo.text}\n        onCancel={this._handleTextInputCancel}\n        onDelete={this._handleTextInputDelete}\n        onSave={this._handleTextInputSave}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <li\n        className={classNames({\n          completed: this.props.todo.complete,\n          editing: this.state.isEditing,\n        })}\n      >\n        <div className=\"view\">\n          <input\n            checked={this.props.todo.complete}\n            className=\"toggle\"\n            onChange={this._handleCompleteChange}\n            type=\"checkbox\"\n          />\n          <label onDoubleClick={this._handleLabelDoubleClick}>\n            {this.props.todo.text}\n          </label>\n          <button\n            className=\"destroy\"\n            onClick={this._handleDestroyClick}\n          />\n        </div>\n        {this.state.isEditing && this.renderTextInput()}\n      </li>\n    );\n  }\n}\n\nexport default RelaySubscriptions.createContainer(Todo, {\n  fragments: {\n    todo: () => Relay.QL`\n      fragment on Todo {\n        id\n        complete\n        text\n        ${ChangeTodoStatusMutation.getFragment('todo')}\n        ${RemoveTodoMutation.getFragment('todo')}\n        ${RenameTodoMutation.getFragment('todo')}\n        ${UpdateTodoSubscription.getFragment('todo')}\n      }\n    `,\n    viewer: () => Relay.QL`\n      fragment on User {\n        ${ChangeTodoStatusMutation.getFragment('viewer')}\n        ${RemoveTodoMutation.getFragment('viewer')}\n      }\n    `,\n  },\n\n  subscriptions: [\n    ({ pending, todo }) => !pending && new UpdateTodoSubscription({ todo }),\n  ],\n});\n\n'relay-subscriptions/examples/todo/js/components/TodoList.js'\n:/**\n * This file provided by Facebook is for non-commercial testing and evaluation\n * purposes only.  Facebook reserves all rights not expressly granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport React from 'react';\nimport Relay from 'react-relay/classic';\n\nimport MarkAllTodosMutation from '../mutations/MarkAllTodosMutation';\nimport Todo from './Todo';\n\nclass TodoList extends React.Component {\n  static propTypes = {\n    viewer: React.PropTypes.object.isRequired,\n    relay: React.PropTypes.object.isRequired,\n  };\n\n  _handleMarkAllChange = (e) => {\n    const { relay, viewer } = this.props;\n    relay.commitUpdate(\n      new MarkAllTodosMutation({\n        todos: viewer.todos,\n        viewer,\n        complete: e.target.checked,\n      }),\n    );\n  };\n\n  render() {\n    const { viewer, relay } = this.props;\n    const numTodos = viewer.totalCount;\n    const numCompletedTodos = viewer.completedCount;\n\n    return (\n      <section className=\"main\">\n        <input\n          checked={numTodos === numCompletedTodos}\n          className=\"toggle-all\"\n          onChange={this._handleMarkAllChange}\n          type=\"checkbox\"\n        />\n        <label htmlFor=\"toggle-all\">\n          Mark all as complete\n        </label>\n        <ul className=\"todo-list\">\n          {viewer.todos.edges.map(edge => (\n            <Todo\n              key={edge.node.id}\n              todo={edge.node}\n              viewer={viewer}\n              pending={relay.hasOptimisticUpdate(edge)}\n            />\n          ))}\n        </ul>\n      </section>\n    );\n  }\n}\n\nexport default Relay.createContainer(TodoList, {\n  initialVariables: {\n    status: null,\n  },\n\n  prepareVariables({ status }) {\n    let nextStatus;\n    if (status === 'active' || status === 'completed') {\n      nextStatus = status;\n    } else {\n      // This matches the Backbone example, which displays all todos on an\n      // invalid route.\n      nextStatus = 'any';\n    }\n    return {\n      status: nextStatus,\n    };\n  },\n\n  fragments: {\n    viewer: () => Relay.QL`\n      fragment on User {\n        completedCount\n        todos(\n          status: $status\n          first: 2147483647  # max GraphQLInt\n        ) {\n          edges {\n            node {\n              id\n              ${Todo.getFragment('todo')}\n            }\n          }\n          ${MarkAllTodosMutation.getFragment('todos')}\n        }\n        totalCount\n        ${MarkAllTodosMutation.getFragment('viewer')}\n        ${Todo.getFragment('viewer')}\n      }\n    `,\n  },\n});\n\n'relay-subscriptions/examples/todo/js/app.js'\n:/**\n * This file provided by Facebook is for non-commercial testing and evaluation\n * purposes only.  Facebook reserves all rights not expressly granted.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * FACEBOOK BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport 'todomvc-common';\n\nimport { createHashHistory } from 'history';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport {\n  applyRouterMiddleware,\n  IndexRoute,\n  Route,\n  Router,\n  useRouterHistory,\n} from 'react-router';\nimport useRelay from 'react-router-relay';\nimport RelaySubscriptions from 'relay-subscriptions';\n\nimport NetworkLayer from './NetworkLayer';\nimport TodoApp from './components/TodoApp';\nimport TodoList from './components/TodoList';\nimport ViewerQueries from './queries/ViewerQueries';\n\nconst history = useRouterHistory(createHashHistory)({ queryKey: false });\n\nconst environment = new RelaySubscriptions.Environment();\nenvironment.injectNetworkLayer(new NetworkLayer('/graphql'));\n\nconst mountNode = document.getElementById('root');\n\nReactDOM.render(\n  <Router\n    environment={environment}\n    history={history}\n    render={applyRouterMiddleware(useRelay)}\n    forceFetch\n  >\n    <Route\n      path=\"/\"\n      component={TodoApp}\n      queries={ViewerQueries}\n    >\n      <IndexRoute\n        component={TodoList}\n        queries={ViewerQueries}\n        prepareParams={() => ({ status: 'any' })}\n      />\n      <Route\n        path=\":status\"\n        component={TodoList}\n        queries={ViewerQueries}\n      />\n    </Route>\n  </Router>,\n  mountNode\n);\n\n",
        "called_code_segment_file_1": "getSubscription() {\n    return Relay.QL`\n      subscription {\n        updateTodoSubscription(input: $input) {\n          todo {\n            ${Todo.getFragment('todo')}\n          }\n          viewer {\n            id\n            completedCount\n          }\n        }\n      }\n    `;\n  }",
        "invoking_code_segment_file_2": "subscriptions: [\n    ({ pending, todo }) => !pending && new UpdateTodoSubscription({ todo }),\n  ]",
        "called_code_segment_file_2": "fragments: {\n    todo: () => Relay.QL`\n      fragment on Todo {\n        id\n        complete\n        text\n        ${ChangeTodoStatusMutation.getFragment('todo')}\n        ${RemoveTodoMutation.getFragment('todo')}\n        ${RenameTodoMutation.getFragment('todo')}\n        ${UpdateTodoSubscription.getFragment('todo')}\n      }\n    `,\n    viewer: () => Relay.QL`\n      fragment on User {\n        ${ChangeTodoStatusMutation.getFragment('viewer')}\n        ${RemoveTodoMutation.getFragment('viewer')}\n      }\n    `,\n  }",
        "using_code_segment_file_3": "render() {\n    return (\n      <li\n        className={classNames({\n          completed: this.props.todo.complete,\n          editing: this.state.isEditing,\n        })}\n      >\n        <div className=\"view\">\n          <input\n            checked={this.props.todo.complete}\n            className=\"toggle\"\n            onChange={this._handleCompleteChange}\n            type=\"checkbox\"\n          />\n          <label onDoubleClick={this._handleLabelDoubleClick}>\n            {this.props.todo.text}\n          </label>\n          <button\n            className=\"destroy\"\n            onClick={this._handleDestroyClick}\n          />\n        </div>\n        {this.state.isEditing && this.renderTextInput()}\n      </li>\n    );\n  }",
        "called_code_segment_file_3": "fragments: {\n    todo: () => Relay.QL`\n      fragment on Todo {\n        id\n        complete\n        text\n        ${ChangeTodoStatusMutation.getFragment('todo')}\n        ${RemoveTodoMutation.getFragment('todo')}\n        ${RenameTodoMutation.getFragment('todo')}\n        ${UpdateTodoSubscription.getFragment('todo')}\n      }\n    `,\n    viewer: () => Relay.QL`\n      fragment on User {\n        ${ChangeTodoStatusMutation.getFragment('viewer')}\n        ${RemoveTodoMutation.getFragment('viewer')}\n      }\n    `,\n  }",
        "using_code_segment_file_4": "const environment = new RelaySubscriptions.Environment();\nenvironment.injectNetworkLayer(new NetworkLayer('/graphql'));",
        "feature_description": "Add a feature to allow users to mark a todo as important.",
        "detailed_feature_description": "The new feature involves adding a new property 'important' to the Todo type. This property will be toggled by a button in the Todo component. The UpdateTodoSubscription will be modified to include this new property. The Todo component will be updated to handle the new property and render a button to toggle its importance. The TodoList component will also be updated to ensure the new property is correctly passed down.",
        "modified_complete_code": {
            "UpdateTodoSubscription.js": "#Modify\ngetSubscription() {\n    return Relay.QL`\n      subscription {\n        updateTodoSubscription(input: $input) {\n          todo {\n            ${Todo.getFragment('todo')}\n          }\n          viewer {\n            id\n            completedCount\n          }\n        }\n      }\n    `;\n  }\n\n#New\ngetConfigs() {\n    return [{\n      type: 'FIELDS_CHANGE',\n      fieldIDs: {\n        todo: this.props.todo.id,\n      },\n    }];\n  }\n\ngetVariables() {\n    return {\n      id: this.props.todo.id,\n      important: this.props.todo.important,\n    };\n  }",
            "Todo.js": "#Modify\nrender() {\n    return (\n      <li\n        className={classNames({\n          completed: this.props.todo.complete,\n          editing: this.state.isEditing,\n        })}\n      >\n        <div className=\"view\">\n          <input\n            checked={this.props.todo.complete}\n            className=\"toggle\"\n            onChange={this._handleCompleteChange}\n            type=\"checkbox\"\n          />\n          <label onDoubleClick={this._handleLabelDoubleClick}>\n            {this.props.todo.text}\n          </label>\n          <button\n            className=\"destroy\"\n            onClick={this._handleDestroyClick}\n          />\n          #New\n          <button\n            className=\"important\"\n            onClick={this._handleImportantClick}\n          >\n            Mark Important\n          </button>\n        </div>\n        {this.state.isEditing && this.renderTextInput()}\n      </li>\n    );\n  }\n\n#New\n_handleImportantClick = () => {\n  const { relay, todo } = this.props;\n  relay.commitUpdate(\n    new UpdateTodoSubscription({\n      todo,\n      important: !todo.important,\n    }),\n  );\n};",
            "TodoList.js": "#Modify\nfragments: {\n    viewer: () => Relay.QL`\n      fragment on User {\n        completedCount\n        todos(\n          status: $status\n          first: 2147483647  # max GraphQLInt\n        ) {\n          edges {\n            node {\n              id\n              ${Todo.getFragment('todo')}\n            }\n          }\n          ${MarkAllTodosMutation.getFragment('todos')}\n        }\n        totalCount\n        ${MarkAllTodosMutation.getFragment('viewer')}\n        ${Todo.getFragment('viewer')}\n      }\n    `,\n  }",
            "app.js": "#Modify\nconst environment = new RelaySubscriptions.Environment();\nenvironment.injectNetworkLayer(new NetworkLayer('/graphql'));"
        }
    }
]