[
    {
        "repo": "atomix",
        "description": "The atomix library is a header-only, wait-free audio mixing library that leverages stdatomic.h and SSE intrinsics for high performance.",
        "function": "It provides configurable memory allocation, pure mixing capabilities at any sampling rate, and operates efficiently for real-time audio applications, with potential future features like 3D audio support and easier integration with miniaudio.",
        "files": [
            {
                "file": "atomix/atomix.h",
                "function": "This is a detailed look at the `atomix.h` header file, which provides a portable, single-file, wait-free atomic sound mixing library optimized for performance, including the use of SSE (Streaming SIMD Extensions) for mixing. Below is an explanation of key components and how they fit together:\n\n### Configuration Options:\n1. **`ATOMIX_EXTERN`**: Used when `atomix` is included in multiple compilation units within a project. The functions and data structures are declared but not defined here.\n2. **`ATOMIX_IMPLEMENTATION`**: Must be defined exactly once in a source file. This triggers the function and variable definitions for the actual implementation of the functions declared in the header.\n3. **`ATOMIX_STATIC`**: If defined, all functions are declared `static`, meaning they are only accessible within the compilation unit they are defined in.\n4. **`ATOMIX_NO_CLIP`**: Disables internal clipping in the mixing process. This is useful if the backend already handles clipping.\n5. **`ATOMIX_NO_SSE`**: Disables SSE optimizations, which significantly reduces performance (about 4x slower) but can help reduce memory usage.\n6. **`ATOMIX_LBITS`**: Defines the number of layers for mixing. The default is 8, which translates to 256 layers.\n7. **`ATOMIX_ZALLOC(S)`**: Allows you to override the memory allocation function for `atomix`. By default, it uses `calloc`.\n\n### Core Concepts and Functions:\n\n#### 1. **Sound (`atomix_sound`)**:\n- Represents a sound in `atomix`, which includes the number of channels (`cha`), the length of the sound (`len`), and the data (`data`).\n- Sound data is stored in a dynamically allocated buffer, and in case of SSE, it\u2019s aligned to a 16-byte boundary for performance.\n\n   - **Function: `atomixSoundNew`** \u2013 Creates a new sound from the provided audio data (`data`), copies it into a new buffer, and returns a pointer to the new sound structure.\n\n   - **Function: `atomixSoundLength`** \u2013 Returns the length of a given sound in frames (always a multiple of 4).\n\n#### 2. **Mixer (`atomix_mixer`)**:\n- The mixer holds the overall state of sound layers, including their volumes, fading states, and the sounds they are mixing.\n- **Layers** are individual tracks or channels within the mixer. Each layer corresponds to a unique sound instance.\n\n   - **Function: `atomixMixerNew`** \u2013 Creates a new mixer, initializing it with a specific volume and fade value.\n\n   - **Function: `atomixMixerMix`** \u2013 Mixes a specified number of frames (samples) from all active layers and writes them to the provided buffer. This function handles mixing with or without SSE depending on the configuration.\n\n   - **Function: `atomixMixerPlay`** \u2013 Starts playing a sound on the mixer. You can specify the initial state, gain, and pan for the sound.\n\n   - **Function: `atomixMixerStopAll`** \u2013 Stops all sounds currently playing in the mixer by setting their state to \"stop.\"\n\n   - **Function: `atomixMixerHaltAll`** \u2013 Pauses all sounds, allowing them to be resumed later.\n\n   - **Function: `atomixMixerPlayAll`** \u2013 Resumes all sounds that were previously halted.\n\n#### 3. **Mixing Logic**:\n- The library mixes audio data by processing each layer in the mixer. The layers are handled by the `atmx_layer` struct, which stores information like:\n  - **`cursor`**: The current position in the sound's data.\n  - **`gain`**: The current gain for the layer, including panning information.\n  - **`fade`**: How much fading is applied to the layer (for example, during stop or resume actions).\n  - **`state`**: The current state of the sound (e.g., playing, stopped, halted).\n\n#### 4. **Thread Safety**:\n- The library uses atomic operations (`atomic_store_explicit`, `atomic_load_explicit`, and `atomic_compare_exchange_strong_explicit`) to manage the state of each layer in a thread-safe manner. This is crucial for the performance and reliability of the mixer when running in a multithreaded environment.\n\n#### 5. **SSE Optimizations**:\n- If SSE is enabled (`ATOMIX_NO_SSE` is not defined), the library uses SSE intrinsics (such as `__m128`) for faster processing of audio data. The mixing operations take advantage of SIMD (Single Instruction, Multiple Data) to process multiple samples in parallel, providing a significant performance boost.\n\n#### 6. **Fading**:\n- Sounds fade in and out automatically when their state changes. When a sound is stopped (`ATOMIX_STOP`) or halted (`ATOMIX_HALT`), it fades out. When a sound is resumed (`ATOMIX_PLAY` or `ATOMIX_LOOP`), it fades in, depending on its state and position.\n\n#### 7. **Layering and State Management**:\n- Each sound is placed on one of the **layers** in the mixer. Layers are assigned unique IDs and managed via atomic flags and cursors.\n- When a sound is played, the appropriate layer is populated with the sound's data and its cursor is set to the start of the sound. The flag for the layer is then set to indicate the sound's state (e.g., playing, stopped).\n\n#### 8. **Clip Handling**:\n- The library has optional internal clipping to ensure that the final mixed values stay within the valid audio range (-1.0f to 1.0f). This can be disabled if the backend (such as a sound API) handles clipping externally.\n\n### SSE Optimizations and Performance Considerations:\n- **SSE-enabled build**: Uses aligned memory buffers (`__m128`), and mixing is done in parallel for multiple frames. This approach significantly speeds up mixing.\n- **Non-SSE build**: The mixing is performed in a more straightforward manner (one frame at a time), leading to slower performance but lower memory usage.\n\n### Possible Use Cases:\n- **Game Audio**: Perfect for real-time sound mixing in games, where you may need to mix many audio channels at once.\n- **Multimedia Applications**: Any application requiring efficient, high-performance sound mixing.\n- **Cross-Platform Projects**: Being a single-file library, `atomix` is ideal for use in embedded systems or other projects where simplicity and portability are essential.\n\n### Example Usage:\nHere's a simple usage scenario where a sound is created, played, and mixed:\n\n```c\n#include \"atomix.h\"\n\n// Example sound data (stereo, 1 frame per channel)\nfloat sound_data[] = {0.5f, -0.5f}; // left channel, right channel\n\nint main() {\n    // Create sound with 2 channels (stereo) and 1 frame of data\n    struct atomix_sound* sound = atomixSoundNew(2, sound_data, 1);\n\n    // Create mixer with default volume and fade value\n    struct atomix_mixer* mixer = atomixMixerNew(1.0f, 100);\n\n    // Play sound on mixer with default settings (gain = 1.0, pan = 0.0)\n    uint32_t sound_id = atomixMixerPlay(mixer, sound, ATOMIX_PLAY, 1.0f, 0.0f);\n\n    // Mix 1 frame of audio into the buffer\n    float buffer[2]; // Stereo buffer (2 channels)\n    atomixMixerMix(mixer, buffer, 1);\n\n    // Stop all sounds\n    atomixMixerStopAll(mixer);\n\n    // Free allocated memory\n    free(sound);\n    free(mixer);\n\n    return 0;\n}\n```\n\nIn this example:\n- A stereo sound is created with one frame of data.\n- A mixer is initialized with default volume and fade values.\n- The sound is played with a specified gain and pan.\n- The mixer mixes one frame into a buffer, and then all sounds are stopped.\n\n### Conclusion:\n`atomix.h` provides a high-performance, portable, and flexible sound mixing solution. With the ability to disable SSE for compatibility or enable it for maximum performance, this library can be used in a wide range of applications that require efficient audio processing."
            },
            {
                "file": "atomix/test.c",
                "function": "The code provides a command-line utility for benchmarking and demonstrating audio mixing capabilities using the Atomix audio library and the miniaudio framework. It allows the user to load music and sound files, perform mixing and playback, and measure the performance of the mixing process."
            },
            {
                "file": "atomix/libs/miniaudio.h",
                "function": "It looks like you've shared the header of a C library called **miniaudio**, which is designed for audio playback and capture. This file contains documentation, version history, API changes, building instructions, and platform-specific details for using the library.\n\n### Key Information from the Header:\n\n#### **Library Overview:**\n- **miniaudio** is a single-file C library for audio playback and capture, designed to be simple to use and to provide access to a wide range of audio backends.\n- It supports various audio formats and platforms, making it highly versatile for different audio applications. Some notable features include **full-duplex** support, multiple backend options (like WASAPI, Core Audio, ALSA), and compatibility with multiple audio formats (e.g., 16-bit PCM, 32-bit float).\n\n#### **Key Features:**\n1. **Rebranding**: The library was originally named `mini_al` and has been rebranded to `miniaudio`. Along with the rebrand, the namespace was changed from `mal` to `ma`.\n2. **Full-Duplex Support**: Version 0.9 adds full-duplex (simultaneous playback and capture), which required a major restructuring of the API.\n3. **Simplified Device Initialization**: The device configuration has been simplified, with a new structure that allows easy configuration of playback and capture settings.\n4. **Error Handling and Logging**: New error handling APIs and a logging system allow better tracking and resolution of issues.\n5. **New API Changes**: Some functions have been renamed (e.g., `mal_decoder_read()` \u2192 `ma_decoder_read_pcm_frames()`), and deprecated or removed APIs include methods like `mal_device_get_buffer_size_in_bytes()`.\n\n#### **Platform Support:**\nThe library supports a wide range of platforms, including:\n- **Windows (WASAPI, DirectSound, WinMM)**\n- **macOS/iOS (Core Audio)**\n- **Linux (ALSA, PulseAudio)**\n- **Android (AAudio, OpenSL)**\n- **Web Audio (Emscripten)**\n\n#### **Common Usage:**\n1. **Initialization**: To use the library, you typically define `MINIAUDIO_IMPLEMENTATION` in one `.c` file to include the implementation, then include `miniaudio.h` elsewhere in your project.\n2. **Device Initialization**: Devices (both playback and capture) are initialized using the `ma_device_init()` function, and the data is processed through a callback function.\n\n#### **Sample Playback Example:**\n```c\nvoid data_callback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount)\n{\n    ma_decoder* pDecoder = (ma_decoder*)pDevice->pUserData;\n    if (pDecoder == NULL) {\n        return;\n    }\n\n    ma_decoder_read_pcm_frames(pDecoder, frameCount, pOutput);\n}\n...\nma_device_config config = ma_device_config_init(ma_device_type_playback);\nconfig.playback.format   = decoder.outputFormat;\nconfig.playback.channels = decoder.outputChannels;\nconfig.sampleRate        = decoder.outputSampleRate;\nconfig.dataCallback      = data_callback;\nconfig.pUserData         = &decoder;\n\nma_device device;\nif (ma_device_init(NULL, &config, &device) != MA_SUCCESS) {\n    ... An error occurred ...\n}\n\nma_device_start(&device); // Start playback\n\n...\nma_device_uninit(&device); // Uninitialize when done\n```\n\n#### **Build Instructions:**\n- The library should compile without requiring external dependencies, and platform-specific configuration is typically minimal.\n- For **Windows**, the library works out-of-the-box with most popular compilers.\n- For **Linux/BSD**, you need to link against `-ldl`, `-lpthread`, and `-lm`.\n\n#### **Performance Optimization Options:**\n- The library includes options to disable certain features like backends (`MA_NO_WASAPI`, `MA_NO_DSOUND`, etc.) or optimizations (`MA_NO_SSE2`, `MA_NO_AVX2`, etc.).\n  \n### Key API Changes in Version 0.9:\n1. **Callback Change**: The data callback now supports full-duplex (both playback and capture) by using a unified callback signature:\n   ```c\n   void data_callback(ma_device* pDevice, void* pOutput, const void* pInput, ma_uint32 frameCount);\n   ```\n   - In full-duplex, both `pOutput` and `pInput` are used.\n   - In capture-only or playback-only modes, one of the pointers (`pOutput` or `pInput`) will be `NULL`.\n\n2. **Device Configuration**: The `ma_device_config` structure now supports separate settings for both playback and capture devices (e.g., format, channels, and device ID).\n\n3. **Renamed Functions**: Several functions have been renamed for clarity:\n   - `mal_decoder_read()` \u2192 `ma_decoder_read_pcm_frames()`\n   - `mal_sine_wave_read()` \u2192 `ma_sine_wave_read_f32()`\n\n4. **Log Callback**: The log callback now includes a `logLevel` parameter for better logging control.\n\n#### **Platform-Specific Notes:**\n- On **Android**, you must add the `RECORD_AUDIO` permission to the manifest.\n- On **WebAudio/Emscripten**, the `ScriptProcessorNode` is used, but it may be deprecated in the future.\n\n### Conclusion:\nThe **miniaudio** library is a powerful, flexible, and lightweight solution for handling audio on various platforms, with full-duplex capabilities introduced in version 0.9. It simplifies the initialization process and allows for easy integration into a wide range of applications, from playback to capture. If you are working on audio-based projects and need a cross-platform, easy-to-use library, **miniaudio** offers a great option."
            },
            {
                "file": "atomix/libs/stb_vorbis.h",
                "function": "This is the header file for the `stb_vorbis` library, a simple, single-file decoder for Ogg Vorbis audio files. The library is designed to be easy to integrate into C/C++ applications and is in the public domain. The code supports both pull-based and push-based APIs for decoding audio and offers features like seeking, file handling, and memory management. Here's a breakdown of the key sections:\n\n### Key Components\n\n1. **License & Contributors**\n   - The code is public domain and has been contributed by several developers and organizations over the years. It is primarily authored by Sean Barrett.\n\n2. **General Settings**\n   - The library supports both static and dynamic linking (`STB_VORBIS_STATIC`).\n   - The library can be compiled without standard I/O support (`STB_VORBIS_NO_STDIO`).\n\n3. **Thread Safety**\n   - Each `stb_vorbis` handle is not thread-safe. If you need to decode from multiple threads, use separate handles for each thread.\n\n4. **Memory Allocation**\n   - The library uses `malloc()` for general memory allocation and `alloca()` for stack-based temporary allocations.\n   - Custom memory allocation can be configured by overriding memory allocation functions or by using the `stb_vorbis_alloc` struct, where you provide a buffer for all memory allocations.\n\n5. **Decoding Functions**\n   - **Information Retrieval**: Functions like `stb_vorbis_get_info()` provide metadata about the Vorbis file, such as sample rate and number of channels.\n   - **Error Handling**: `stb_vorbis_get_error()` returns the last error that occurred during the decoding process.\n   - **File Handling**: Functions such as `stb_vorbis_open_filename()` and `stb_vorbis_open_memory()` allow loading Vorbis streams from files or memory.\n   - **Decoding Audio**: `stb_vorbis_decode_frame_pushdata()` and `stb_vorbis_get_samples_*()` functions decode audio frames, either in float or integer format.\n\n6. **Pushdata API**\n   - In this mode, you buffer audio data manually and feed it to `stb_vorbis` piece by piece. This is useful when reading data from streaming sources or files that cannot be fully loaded into memory.\n   - Functions like `stb_vorbis_open_pushdata()` and `stb_vorbis_decode_frame_pushdata()` are used for this mode.\n\n7. **Pulldata API**\n   - The pulldata API assumes that the library can fetch data from a source, such as a memory block or a file. Functions such as `stb_vorbis_open_filename()` are used for file-based sources, while `stb_vorbis_open_memory()` is used for in-memory Vorbis data.\n   - The pulldata API can handle seeking and allows for decoding entire files or specific sections of a Vorbis stream.\n\n8. **Error Codes**\n   - The library defines various error codes like `VORBIS_outofmem` (out of memory) and `VORBIS_invalid_stream` (stream corruption). These help in identifying the reason for a failure during decoding.\n\n### Example Use Case\n\nIf you're decoding an Ogg Vorbis file from memory, you might use the pulldata API like this:\n\n```c\n#include \"stb_vorbis.h\"\n\nstb_vorbis *vorbis;\nint error;\nstb_vorbis_alloc alloc = { NULL, 0 };\n\n// Open Vorbis stream from memory\nvorbis = stb_vorbis_open_memory(data, data_length, &error, &alloc);\nif (vorbis == NULL) {\n    printf(\"Error: %d\\n\", error);\n    return;\n}\n\n// Get information about the Vorbis file\nstb_vorbis_info info = stb_vorbis_get_info(vorbis);\nprintf(\"Sample Rate: %d, Channels: %d\\n\", info.sample_rate, info.channels);\n\n// Decode frames\nint channels;\nfloat **output;\nint samples;\nwhile (stb_vorbis_decode_frame(vorbis, &channels, &output, &samples) > 0) {\n    // Process decoded samples\n    // output is a 2D array of float* buffers for each channel\n    // samples is the number of samples per channel\n}\n\n// Clean up\nstb_vorbis_close(vorbis);\n```\n\nThis example shows how you might load an Ogg Vorbis stream from memory, retrieve metadata, and decode frames.\n\n### Custom Memory Allocation\n\nYou can use custom memory allocation by providing a buffer for the `stb_vorbis_alloc` structure. This is useful in environments with specific memory constraints or when integrating into larger systems.\n\n### Conclusion\n\n`stb_vorbis` is a lightweight and flexible audio decoder, ideal for projects where simplicity and minimal external dependencies are important. The library provides both high-level and low-level interfaces for working with Ogg Vorbis streams, along with detailed error handling and memory management options."
            }
        ],
        "gt": "[['atomix/atomix.h', 'atomix/test.c'], ['atomix/libs/miniaudio.h', 'atomix/test.c'], ['atomix/test.c'], ['atomix/libs/stb_vorbis.h', 'atomix/test.c'], ['atomix/libs/miniaudio.h']]"
    },
    {
        "repo": "blinkstick-firmware",
        "description": "BlinkStick is an open-source USB RGB LED designed for DIY enthusiasts, resembling the size of a USB flash drive.",
        "function": "Contains the firmware needed for the ATTiny85 chip, enabling users to assemble and program their own BlinkStick devices.",
        "files": [
            {
                "file": "blinkstick-firmware/requests.h",
                "function": "This header file defines USB request numbers for communication between host software and firmware in a basic USB application, including specific requests to set colors (red, green, and blue)."
            },
            {
                "file": "blinkstick-firmware/usbconfig.h",
                "function": "The `usbconfig.h` file is a configuration header for the AVR USB driver, allowing users to define hardware and functional settings for USB communication on AVR microcontrollers, such as the port and pin assignments for USB data lines, endpoint configurations, and power settings. It also provides options to customize USB descriptors and the behavior of USB device features like HID and control transfers."
            },
            {
                "file": "blinkstick-firmware/usbdrv/oddebug.c",
                "function": "The file `oddebug.c` implements a debugging utility for an AVR library, allowing the output of hexadecimal representations of data through a UART interface. It provides a function, `odDebug`, which formats and sends a prefix followed by hexadecimal data over serial communication for debugging purposes."
            },
            {
                "file": "blinkstick-firmware/usbdrv/oddebug.h",
                "function": "The file `oddebug.h` provides a debugging utility for logging messages over the serial line of AVR microcontrollers, allowing developers to control the verbosity of logging through a configurable `DEBUG_LEVEL` macro. It defines macros for different levels of debugging output and includes functions for initializing the debugging interface."
            },
            {
                "file": "blinkstick-firmware/usbdrv/usbconfig-prototype.h",
                "function": "The file `usbconfig.h` provides configuration settings for the V-USB driver, enabling USB communication on Atmel AVR microcontrollers. It specifies pin assignments, clock settings, device descriptors, and various USB functionalities such as power settings, endpoint configurations, and interrupt handling."
            },
            {
                "file": "blinkstick-firmware/usbdrv/usbdrv.c",
                "function": "The code you provided is from a USB driver implementation for Atmel AVR microcontrollers, particularly using the V-USB library. It's designed to handle USB communication for devices that don't have native USB hardware. The core functionality involves managing USB requests, device descriptors, and data transmission/reception. Here\u2019s a breakdown of the major components and sections:\n\n### Key Sections of the Code:\n\n1. **Global Variables**:\n   - These variables store buffers and statuses for incoming (`usbRxBuf`, `usbRxLen`, etc.) and outgoing USB data (`usbTxBuf`, `usbTxLen`, etc.).\n   - The `usbRxBuf` stores the raw incoming USB data, and `usbTxBuf` holds data to be transmitted. `usbRxLen` and `usbTxLen` hold the length of data to be received and transmitted, respectively.\n\n2. **String Descriptors**:\n   - String descriptors are used to store the device's string data (vendor name, product name, serial number) in a human-readable form. The code checks whether these descriptors are defined in the configuration (`USB_CFG_DESCR_PROPS_STRINGS`), and if not, defaults are used.\n   - The descriptors include language strings, vendor strings, product strings, and serial numbers.\n\n3. **Device Descriptor**:\n   - This part contains the device descriptor, which is required by USB hosts to understand the device capabilities (such as USB version, device ID, etc.). The descriptor defines information like vendor ID, device ID, and configuration settings.\n   - `usbDescriptorDevice` stores this descriptor in a format compliant with the USB specification.\n\n4. **Configuration Descriptor**:\n   - The configuration descriptor tells the USB host how the device operates in terms of interfaces and endpoints. The configuration also includes descriptors for HID (Human Interface Device) reports, if applicable.\n   - The code handles optional HID report descriptors and endpoint descriptors for communication, such as interrupt endpoints.\n\n5. **USB Request Handlers**:\n   - The function `usbDriverSetup` handles standard USB requests like `GET_STATUS`, `SET_ADDRESS`, `GET_DESCRIPTOR`, etc. This function processes the requests and prepares appropriate responses.\n   - The `usbProcessRx` function processes incoming USB data, distinguishing between different types of packets (SETUP, DATA, OUT) based on the `usbRxToken`.\n\n6. **Data Transmission and Reception**:\n   - The code includes mechanisms to read and write data from/to USB (`usbDeviceRead`, `usbBuildTxBlock`, `usbSetInterrupt`).\n   - `usbDeviceRead` reads data from either ROM or RAM, depending on the flag set in `usbMsgFlags`.\n   - `usbSetInterrupt` and related functions handle interrupt-driven data transfers, ensuring that data is transferred asynchronously and in response to interrupts.\n\n7. **Helper Functions**:\n   - `usbResetDataToggling` and `usbResetStall` are used to reset the data toggling and stall conditions for endpoints.\n   - `usbDriverDescriptor` handles descriptor retrieval based on the request type. It reads the requested descriptor (device, configuration, string, etc.) and prepares the data to be sent to the host.\n\n8. **USB Descriptor Retrieval**:\n   - The code uses a macro `GET_DESCRIPTOR` to abstract the logic of fetching various descriptors. This macro helps manage different descriptor types (like device, configuration, string) and whether the descriptor is stored in ROM or RAM.\n\n9. **Switch-Case for Command Processing**:\n   - The code includes `SWITCH_START`, `SWITCH_CASE`, and related macros for handling different USB commands. The switch statement approach is used to simplify branching logic for handling multiple USB requests.\n\n### Optimizations and Considerations:\n\n1. **Memory Usage**:\n   - The `PROGMEM` directive is used to store large constant data (like descriptors) in flash memory, which is more limited than RAM on AVR microcontrollers.\n   - Using `PROGMEM` helps save valuable SRAM for dynamic data.\n\n2. **Flow Control**:\n   - The code employs flow control using the `usbRxLen` and `usbTxLen` variables to indicate when the USB buffers are full or ready to be transmitted. This ensures that the device doesn\u2019t overload the USB bus with too much data at once.\n\n3. **Interrupt-Driven Architecture**:\n   - Interrupt handling is central to the operation of this driver, especially for managing incoming and outgoing USB data asynchronously.\n\n4. **Data Integrity**:\n   - The function `usbGenericSetInterrupt` includes a mechanism for toggling the data tokens to ensure proper data integrity for interrupt endpoints.\n   - CRC checks and data toggling ensure that the transmitted data is not corrupted.\n\n5. **USB Control Requests**:\n   - The USB specification defines many control requests (such as `GET_STATUS`, `SET_ADDRESS`, etc.), which are essential for communication between the host and the device. The code provides an implementation to handle these requests and manage device state (e.g., address assignment, feature management).\n\n### Conclusion:\nThis file provides a detailed implementation of a USB driver for AVR microcontrollers that enables them to communicate with USB hosts as if they had native USB functionality. The code is highly modular, allowing for flexible configuration of descriptors, endpoints, and control request handling. However, it requires proper setup of hardware (e.g., pin configuration, interrupts) and careful memory management due to the limited resources of microcontrollers."
            },
            {
                "file": "blinkstick-firmware/usbdrv/usbdrv.h",
                "function": "The code you provided is part of a USB driver designed for AVR microcontrollers, specifically for implementing low-speed USB functionality (1.5 Mbps) through the V-USB library. It outlines various parameters, configurations, and functions for handling USB communication. Let\u2019s break it down and clarify key parts of the file:\n\n### Key Features and Components:\n1. **Hardware Requirements:**\n   - The USB data lines (D+ and D-) must be wired to the same I/O port. The recommendation is for D+ to trigger interrupts (commonly using `INT0`), but it is possible to use D- as the interrupt source.\n   - A 1.5k pull-up resistor on D- is necessary for identifying low-speed devices.\n   - The device must be clocked at specific frequencies (e.g., 12 MHz, 16 MHz, etc.).\n\n2. **Limitations:**\n   - The driver assumes error-free communication but does not check for several types of communication errors (e.g., CRC checks, bit stuffing).\n   - It only supports low-speed USB (1.5 Mbps), and therefore error handling is limited compared to high-speed implementations.\n   - It does not fully implement the USB suspend mode functionality (which is limited to 500 \u00b5A of current draw when the device is in suspend).\n\n3. **Endpoints:**\n   - **Endpoint 0:** Default control endpoint.\n   - **Interrupt- or Bulk-Out Endpoints:** Can be used for data out transfers.\n   - **Interrupt-In Endpoint:** Used for sending interrupt or bulk data to the host.\n   - **Endpoint 3 (Optional):** Another interrupt or bulk-in endpoint, configurable in the driver.\n\n4. **Data Payloads:**\n   - Control transfers can have payloads of up to 254 bytes (by default). If more than 254 bytes are needed, a larger transfer size (up to 16384 bytes) can be used.\n   - The driver allows handling control-in and control-out transfers, including functions for receiving (`usbFunctionWrite()`) and sending (`usbFunctionRead()`) data.\n\n5. **Device State Management:**\n   - **Device Connect/Disconnect:** Functions like `usbDeviceConnect()` and `usbDeviceDisconnect()` manage whether the device is connected to the host, typically by controlling the pull-up resistor on D-.\n   - **Interrupt Handling:** The interrupt service routine should be fast (maximum of 1200 CPU cycles @ 12 MHz).\n\n6. **Data Handling Functions:**\n   - Functions like `usbFunctionWriteOut()` and `usbSetInterrupt()` handle data transfers on interrupt or bulk-out endpoints.\n   - `usbFunctionSetup()` handles the setup phase of control transfers (SETUP packets).\n\n7. **CRC Calculation:**\n   - The `usbCrc16()` function calculates CRC values for data packets, useful for error detection in the USB communication.\n\n8. **Descriptor Management:**\n   - USB descriptors (e.g., device descriptor, configuration descriptor, HID descriptor) are used to define the characteristics of the USB device.\n   - If descriptors are provided at runtime (dynamic descriptors), the `usbFunctionDescriptor()` function is called to provide them.\n\n9. **Configuration and Setup:**\n   - The configuration and setup options, like `USB_CFG_HID_REPORT_DESCRIPTOR_LENGTH` or `USB_CFG_HAVE_INTRIN_ENDPOINT`, enable or disable certain features of the driver at compile time.\n   - Specific features such as HID or interrupt-in endpoints must be enabled in `usbconfig.h` to activate them.\n\n### Important Macros and Functions:\n- **`USB_PUBLIC`**: Used to define the visibility of functions. This can be adjusted to `static` if the driver code is compiled directly into an application.\n- **`usbFunctionSetup()`**: Handles setup packets in control transfers, guiding the flow for reading or writing data.\n- **`usbSetInterrupt()`**: Sends interrupt data to the host when an interrupt transfer is ready.\n- **`usbCrc16()`**: Computes the CRC checksum for data, used for error-checking in USB packets.\n- **`usbDeviceConnect()` and `usbDeviceDisconnect()`**: Control whether the USB device is connected or disconnected from the host.\n- **`usbFunctionWriteOut()`**: Handles data received from bulk-out or interrupt-out endpoints.\n\n### Configuration Considerations:\n- **USB Timing and Interrupt Latency**: The USB driver expects that the USB interrupt routine is fast and doesn\u2019t block for more than 25 CPU cycles at 12 MHz.\n- **Power Consumption**: When in suspend mode, devices must adhere to a maximum of 500 \u00b5A of current draw.\n- **Endpoint Limitations**: Bulk endpoints are not supported for low-speed devices according to the USB standard, but they may still work on certain operating systems.\n\n### Advanced Features:\n- **Dynamic Descriptors**: The driver can return USB descriptors dynamically through `usbFunctionDescriptor()` if needed, with properties like `USB_PROP_IS_DYNAMIC` and `USB_PROP_IS_RAM` to handle whether the descriptors are stored in RAM or Flash memory.\n- **USB Polling and Event Handling**: The `usbPoll()` function must be called at regular intervals to keep the USB communication active. This function handles the periodic polling of the USB interface to ensure the device remains recognized by the host.\n\n### Conclusion:\nThis file is part of a low-level USB driver for AVR microcontrollers that handles basic USB communication for low-speed devices. It includes functions for managing control transfers, interrupt and bulk endpoints, CRC calculations, and dynamic USB descriptors. By configuring the driver properly and implementing the necessary functions in your application (e.g., `usbFunctionWrite()`, `usbFunctionRead()`), you can create a custom USB device with the AVR microcontroller. The file also provides critical timing, hardware, and configuration guidelines to ensure reliable USB operation."
            },
            {
                "file": "blinkstick-firmware/usbdrv/usbportability.h",
                "function": "The `usbportability.h` header file facilitates compatibility between the V-USB project and various development environments, including IAR, CodeVision AVR, and avr-gcc/avr-libc, by defining specific macros and including relevant headers for each environment. Its main functionality is to abstract system-dependent code, allowing for a seamless integration of the USB driver across different AVR microcontroller development platforms."
            }
        ],
        "gt": "[['blinkstick-firmware/usbconfig.h', 'blinkstick-firmware/usbdrv/usbdrv.h', 'blinkstick-firmware/usbdrv/usbdrv.c'], ['blinkstick-firmware/usbdrv/usbportability.h', 'blinkstick-firmware/usbdrv/usbdrv.h', 'blinkstick-firmware/usbdrv/usbdrv.c'], ['blinkstick-firmware/requests.h'], ['blinkstick-firmware/usbdrv/usbdrv.h', 'blinkstick-firmware/usbdrv/usbdrv.c'], ['blinkstick-firmware/usbdrv/usbconfig-prototype.h'], ['blinkstick-firmware/usbdrv/oddebug.c'], ['blinkstick-firmware/usbdrv/oddebug.h', 'blinkstick-firmware/usbdrv/usbdrv.c'], ['blinkstick-firmware/usbdrv/usbdrv.c'], ['blinkstick-firmware/usbdrv/usbportability.h', 'blinkstick-firmware/usbdrv/oddebug.h', 'blinkstick-firmware/usbdrv/oddebug.c'], ['blinkstick-firmware/usbdrv/oddebug.h', 'blinkstick-firmware/usbdrv/oddebug.c'], ['blinkstick-firmware/usbdrv/usbportability.h', 'blinkstick-firmware/usbdrv/oddebug.h', 'blinkstick-firmware/usbdrv/usbdrv.c'], ['blinkstick-firmware/usbdrv/usbportability.h']]"
    },
    {
        "repo": "bruteforce-luks",
        "description": "A project for managing and analyzing data related to the COVID-19 pandemic.",
        "function": "Provides tools for data collection, visualization, and analysis of COVID-19 statistics. Includes features for tracking cases, deaths, and recoveries, with options for exporting data in various formats.",
        "files": [
            {
                "file": "bruteforce-luks/src/bruteforce-luks.c",
                "function": "The code you provided is a **bruteforce tool for LUKS volumes** using various methods to guess passwords. Below is a detailed breakdown of the code:\n\n### Overview\nThis program is a password cracking tool for LUKS (Linux Unified Key Setup) encrypted volumes. It can attempt to brute-force passwords using a variety of methods:\n- **Dictionary-based attack**: Reads passwords from a dictionary file.\n- **Brute-force generation**: Generates passwords using a custom charset and specified length.\n- **Multithreading**: Supports multiple threads to speed up the cracking process.\n- **State saving and restoring**: Allows saving and restoring the state of a brute-force session, which is useful for resuming a session if interrupted.\n\n### Main Components\n\n#### 1. **Configuration and Parameters:**\n   The program accepts several command-line options to control its behavior:\n   - `-b <prefix>`: Prefix to append to generated passwords.\n   - `-e <suffix>`: Suffix to append to generated passwords.\n   - `-f <file>`: Read passwords from a file instead of generating them.\n   - `-h`: Show help.\n   - `-l <min_len>`: Minimum password length (default is 1).\n   - `-m <max_len>`: Maximum password length (default is 8).\n   - `-s <charset>`: Character set to use for password generation.\n   - `-t <n>`: Number of threads to use (default is 1).\n   - `-v <n>`: Print progress information every `n` seconds.\n   - `-w <file>`: Restore state from a previous session and save it regularly.\n\n#### 2. **Password Generation (Brute-force)**\n   The program can generate passwords by iterating over a specified charset and length range. The password generation mechanism works as follows:\n   - The password is constructed using a **prefix**, **charset**, and **suffix**.\n   - The program maintains a table (`tab`) that tracks the current \"index\" for each character position in the password. This table is incremented in a way similar to how an odometer works, ensuring all combinations are tried.\n   - Each password attempt is printed and checked against the LUKS volume.\n\n#### 3. **Dictionary Attack**\n   If a dictionary file is provided, the program will attempt to read each line from the file and test it as a password. The dictionary attack mode will override the brute-force options (prefix, suffix, charset, length range).\n\n#### 4. **Decryption Functionality**\n   The core decryption functionality is handled by the `decryption_func()` function:\n   - It initializes the LUKS volume using the `cryptsetup` library (`crypt_init()`, `crypt_load()`).\n   - The program attempts to unlock the volume by passing the generated password or dictionary password to the `crypt_activate_by_passphrase()` function.\n   - If the correct password is found, it will print the password and stop further attempts.\n\n#### 5. **Multithreading**\n   The program uses multiple threads to speed up the process:\n   - A separate thread (`status_func`) periodically prints progress statistics.\n   - Another thread (`state_func`) saves the current state of the brute-force process, allowing the user to resume later.\n\n#### 6. **State Management**\n   - The program can save its progress to a state file (`-w <file>`), which allows resuming the brute-force process if interrupted. \n   - It records the time, charset, prefix, suffix, and the position in the password space.\n   - When resuming, the program reads the state file, restoring the progress.\n\n#### 7. **Progress Reporting**\n   The `print_status()` function tracks and reports:\n   - The total number of passwords tried.\n   - The number of passwords per second.\n   - The current progress as a percentage.\n   - The estimated time of arrival (ETA) for cracking the password.\n\n#### 8. **Error Handling**\n   - Memory allocations are checked, and errors are printed if any allocation fails.\n   - The code includes various validation checks for parameters and inputs (e.g., checking charset validity).\n\n### Code Flow\n\n1. **Main Function**:\n   - The `main()` function processes command-line arguments and sets up the environment for the brute-force process.\n   - Depending on the options, it prepares the charset, prefix, suffix, and dictionary.\n   - It starts multiple threads to handle the decryption process, status updates, and state saving.\n\n2. **Password Generation**:\n   - The function `generate_next_password()` creates a new password based on the current values in the `tab` array and iterates through all possible combinations based on the charset.\n\n3. **State Management**:\n   - The `save_state()` function periodically saves the current progress to a file, allowing for session recovery.\n   - The `restore_state()` function restores the saved state, ensuring that the brute-force attack can continue from where it left off.\n\n### Example of How the Tool Works\n\n1. You start the tool with the path to a LUKS volume and specify options:\n   ```bash\n   ./bruteforce-luks -s \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" -b \"abc\" -e \"xyz\" -l 6 -m 8 -t 4 /path/to/luks/volume\n   ```\n   - This will attempt to brute-force passwords of length 6 to 8, using the specified charset, and will add \"abc\" as a prefix and \"xyz\" as a suffix.\n   - It will use 4 threads to speed up the process.\n\n2. If you want to resume a previous session, you can provide a state file:\n   ```bash\n   ./bruteforce-luks -w /path/to/statefile /path/to/luks/volume\n   ```\n\n### Conclusion\n\nThis tool is a powerful LUKS volume password cracking utility that leverages multithreading and supports both brute-force and dictionary attacks. It provides flexibility with custom password character sets, length ranges, and progress reporting. It also includes advanced features like state saving and restoration to resume long-running brute-force attempts. However, as with any password-cracking tool, its use should be ethical and legal, limited to situations where you have permission to attempt decryption."
            },
            {
                "file": "bruteforce-luks/src/version.h",
                "function": "This file defines a version number for a program that performs brute-force attacks on LUKS volumes, outlining the licensing under the GNU General Public License."
            }
        ],
        "gt": "[['bruteforce-luks/src/bruteforce-luks.c'], ['bruteforce-luks/src/version.h', 'bruteforce-luks/src/bruteforce-luks.c'], ['bruteforce-luks/src/version.h']]"
    },
    {
        "repo": "CacheLineSize",
        "description": "A cross-platform C function for retrieving the processor's cache line size.",
        "function": "Determines the cache line size in bytes, returning 0 in case of failure. Compatible with multiple platforms and provides reference to related MATLAB and .NET implementations.",
        "files": [
            {
                "file": "CacheLineSize/CacheLineSize.c",
                "function": "The file defines a function `CacheLineSize()` that retrieves the size of the cache line for different operating systems (Apple, Windows, and Linux) by utilizing system-specific APIs or file reading techniques to access this hardware detail. The function returns the cache line size as a `size_t` value."
            },
            {
                "file": "CacheLineSize/CacheLineSize.h",
                "function": "This file defines a header for a function `CacheLineSize()` that returns the cache line size of the processor in bytes, or 0 if the retrieval fails. It includes necessary header files and prevents multiple inclusions with include guards."
            }
        ],
        "gt": "[['CacheLineSize/CacheLineSize.c'], ['CacheLineSize/CacheLineSize.h', 'CacheLineSize/CacheLineSize.c']]"
    },
    {
        "repo": "CANopenSocket",
        "description": "CANopenSocket is a collection of CANopen tools and examples based on the CANopenNode stack.",
        "function": "Provides a Linux command-line tool for CANopen gateway communication, a CGI interface for web server integration, and various examples for CANopen device implementation and testing.",
        "files": [
            {
                "file": "CANopenSocket/canopencgi/CANopenCGI.c",
                "function": "This file provides a CGI interface for interacting with CANopenSocket, allowing commands to read or write data to a CANopen network via a Unix domain socket. It processes HTTP query strings, validates commands, and communicates with the CANopenSocket using specified configurations."
            },
            {
                "file": "CANopenSocket/cocomm/cocomm.c",
                "function": "This file implements a client interface for sending and receiving CANopen commands via a socket to a CANopen gateway. It supports communication over Unix domain or TCP sockets, processes commands from input files or command-line arguments, and handles CANopen device status responses."
            },
            {
                "file": "CANopenSocket/examples/basicDevice/CO_application.c",
                "function": "The file implements the application interface for CANopenNode, providing functions for managing the Object Dictionary (OD) and handling the initialization of application-specific data, including version information and testing variables. It also includes routines for communication resets and periodic updates within a CANopen network environment."
            },
            {
                "file": "CANopenSocket/examples/basicDevice/CO_application.h",
                "function": "The file defines the application interface for the CANopenNode open-source CANopen stack, providing essential functions for initializing, resetting, and managing the program's execution and communication lifecycle in a CANopen environment. It includes functions for starting the application, handling communication resets, and executing regularcyclical tasks."
            },
            {
                "file": "CANopenSocket/examples/basicDevice/CO_driver_custom.h",
                "function": "This file provides custom configurations for the CANopenNode stack, including definitions for managing Emergency (EM) message settings, disabling certain gateway functionalities, and specifying persistent storage options for application data. It overrides default settings to tailor the stack's behavior for specific application needs."
            },
            {
                "file": "CANopenSocket/examples/basicDevice/OD.c",
                "function": "It looks like you've posted a large segment of a CANopen Object Dictionary definition, possibly from a CANopenNode V4.0 device configuration. Are you looking to delve deeper into understanding how certain elements work, or would you like help with a specific aspect, like the mapping parameters, communication settings, or something else?"
            },
            {
                "file": "CANopenSocket/examples/basicDevice/OD.h",
                "function": "This file defines the Object Dictionary (OD) for a basic CANopen device, specifying the structure, communication parameters, and mappings for various CANopen objects like Heartbeat, SDO, PDO, and error handling. It includes data declarations for persistent, runtime, and test variables, as well as shortcuts for accessing different OD entries."
            }
        ],
        "gt": "[['CANopenSocket/canopencgi/CANopenCGI.c'], ['CANopenSocket/examples/basicDevice/CO_application.h', 'CANopenSocket/examples/basicDevice/CO_application.c'], ['CANopenSocket/cocomm/cocomm.c'], ['CANopenSocket/examples/basicDevice/OD.h', 'CANopenSocket/examples/basicDevice/CO_application.c'], ['CANopenSocket/examples/basicDevice/CO_application.c'], ['CANopenSocket/examples/basicDevice/OD.h', 'CANopenSocket/examples/basicDevice/OD.c'], ['CANopenSocket/examples/basicDevice/CO_driver_custom.h'], ['CANopenSocket/examples/basicDevice/OD.c']]"
    },
    {
        "repo": "compsize",
        "description": "compsize is a tool for measuring compression statistics on btrfs filesystems.",
        "function": "Analyzes a list of files to report on used compression types, effective compression ratio, and provides detailed statistics including disk usage, uncompressed extents, and referenced sizes.",
        "files": [
            {
                "file": "compsize/compsize.c",
                "function": "The program computes and displays the disk usage statistics of files or directories, taking into account compression, reflinks, and partially overwritten extents in a Btrfs filesystem. It recursively analyzes files, tracks data compression types, and provides detailed usage metrics, including raw and human-readable formats."
            },
            {
                "file": "compsize/endianness.h",
                "function": "This file defines macros for converting 32-bit and 64-bit integers to little-endian format, taking into account the system's endianness. It includes conditional compilation for different platforms to ensure compatibility with various architectures."
            },
            {
                "file": "compsize/kerncompat.h",
                "function": "The file provides kernel compatibility macros and inline functions for handling memory management, mutexes, bit operations, error handling, and type conversions, primarily intended for environments where kernel-like functionalities are needed in user-space code. It also includes debugging and trace utilities, such as assertions and backtrace printing."
            },
            {
                "file": "compsize/radix-tree.c",
                "function": "The provided code is an implementation of a radix tree in C, commonly used in systems for efficient storage and retrieval of key-value pairs. A radix tree, or compact prefix tree, is an ordered tree data structure where each node represents a possible value of a certain part of a key. Here's a breakdown of the main components and concepts:\n\n### Key Concepts:\n- **Radix Tree Root**: The top-level structure where the tree begins. It holds a pointer to the root node and tracks the height of the tree.\n- **Radix Tree Node**: Represents a node in the tree. It contains an array of slots (each slot can hold a value or point to a child node) and an array of \"tags\" used to mark certain nodes.\n- **Slot**: In the context of the radix tree node, each slot corresponds to a position in the node's array and is used to either store a value or reference another node in the tree.\n\n### Core Functions:\n1. **Node Allocation and Deallocation**:\n   - `radix_tree_node_alloc`: Allocates memory for a new node and initializes it.\n   - `radix_tree_node_free`: Frees a previously allocated node.\n\n2. **Tree Expansion**:\n   - `radix_tree_extend`: This function increases the tree\u2019s height to accommodate new keys if necessary. If a node can\u2019t accommodate a key at its current level, a new node is allocated, and the tree\u2019s height is increased.\n\n3. **Insertions**:\n   - `radix_tree_insert`: This inserts a key-value pair into the radix tree at the correct position based on its index. It ensures that the tree is tall enough to accommodate the new key, and if necessary, it extends the tree.\n\n4. **Lookups**:\n   - `radix_tree_lookup`: This function retrieves the value associated with a key at a specific index. It traverses the tree, starting from the root, to find the corresponding slot.\n   - `radix_tree_lookup_slot`: Similar to `radix_tree_lookup`, but it looks for the \"slot\" where the key could potentially be inserted, allowing for update-if-exists operations.\n\n5. **Tagging**:\n   - **Tagging System**: Each node in the tree can have tags set or cleared. The functions `tag_set`, `tag_clear`, and `tag_get` manipulate these tags. These tags are useful for operations that require marking specific nodes or entries.\n   - `radix_tree_tag_set` and `radix_tree_tag_clear`: Set or clear a specific tag on a node based on the key\u2019s index.\n\n6. **Deletion**:\n   - `radix_tree_delete`: Removes a key-value pair from the radix tree at the specified index. This function also adjusts the tree\u2019s structure if necessary by shrinking its height.\n\n7. **Gang Lookups**:\n   - **`radix_tree_gang_lookup`**: This function performs multiple lookups in the tree, starting from a specific index and continuing until the maximum number of results (`max_items`) has been reached or the tree is exhausted.\n   - **`radix_tree_gang_lookup_tag`**: Similar to `radix_tree_gang_lookup`, but this function retrieves items that have a specific tag set.\n\n### Performance Considerations:\n- **Efficiency**: Radix trees are efficient for storing large amounts of sparse data. The tree's structure allows for fast searches, insertions, and deletions.\n- **Memory Usage**: The node and tag structures allow radix trees to be memory-efficient, as they avoid the overhead of having to store all possible keys explicitly.\n\n### Other Details:\n- **Preloading**: The `radix_tree_preload` function helps to ensure that the system is ready to handle inserts by preloading nodes into per-CPU buffers.\n- **Shifting**: The radix tree uses bit-shifting to navigate through the tree. The shift amount is determined by the height of the tree and the size of each slot (determined by `RADIX_TREE_MAP_SHIFT`).\n\n### Example Use Cases:\n- **Kernel Space**: This implementation seems to be written with kernel space usage in mind, with functions like `preempt_disable` and `__get_cpu_var` suggesting its potential use in systems like operating kernels where efficiency and concurrency management are crucial.\n- **Efficient Data Retrieval**: Radix trees are ideal when you need fast lookups, such as in filesystem indexing, routing tables, or network data storage.\n\n### Potential Issues or Areas of Concern:\n- **Memory Management**: The manual allocation and deallocation of nodes must be handled carefully to avoid memory leaks. The use of `malloc` and `free` without further optimization (such as pooling or slabbing) might be suboptimal for high-performance applications.\n- **Concurrency**: The `radix_tree_preload` function aims to handle concurrency by associating a preloaded buffer with each CPU, ensuring that operations like inserts don\u2019t fail due to memory allocation errors.\n\n### Conclusion:\nThis implementation is a robust example of a radix tree used in environments where efficient memory use and quick access to stored data are needed. It's particularly suited for systems programming, where low-level control over data structures is required for performance optimization."
            },
            {
                "file": "compsize/radix-tree.h",
                "function": "The file defines the data structure and operations for a radix tree in C, including functions for inserting, looking up, deleting, and tagging nodes within the tree. It provides a framework for efficient storage and retrieval of data indexed by unsigned long keys."
            }
        ],
        "gt": "[['compsize/kerncompat.h', 'compsize/radix-tree.c'], ['compsize/radix-tree.c'], ['compsize/kerncompat.h', 'compsize/radix-tree.h', 'compsize/compsize.c'], ['compsize/compsize.c'], ['compsize/endianness.h', 'compsize/compsize.c'], ['compsize/radix-tree.h', 'compsize/radix-tree.c'], ['compsize/kerncompat.h', 'compsize/radix-tree.h', 'compsize/radix-tree.c'], ['compsize/radix-tree.h', 'compsize/compsize.c']]"
    },
    {
        "repo": "corvus",
        "description": "Corvus is an experimental project in genetic programming simulating birds as Brainfuck (BF) virtual machines that evolve to find food in a mathematical environment.",
        "function": "The birds, representing modified BF virtual machines, explore a defined function, reproducing upon successfully finding food or 'starving' if they fail. Users can change the target function to modify the birds' objective in the experiment.",
        "files": [
            {
                "file": "corvus/bird.c",
                "function": "The code defines functionality to mutate and create \"Bird\" objects, which are represented by a genetic \"Strand\" and have attributes such as fat and a virtual machine. It also includes methods to generate an array of birds, find the fattest bird, update bird states, free resources, and replace bird instances."
            },
            {
                "file": "corvus/bird.h",
                "function": "The file defines the structure and constants for managing the state of birds in a virtual environment within a simulation, including their health (fat), position, and associated virtual machine functionality. It also includes a reference to another file, \"bird.c,\" likely containing related implementation details for the birds."
            },
            {
                "file": "corvus/engine.c",
                "function": "The code defines a function `tick` that updates the state of birds in a simulation based on certain conditions, including modifying their properties and potentially replacing them based on their fat levels. It also includes a function `freeEngine` that deallocates memory used for birds when the engine is no longer needed."
            },
            {
                "file": "corvus/engine.h",
                "function": "The file defines a structure for an engine that manages the simulation of birds in a virtual environment, including a target function and a counter for the number of iterations. It also incorporates a bird array to represent the active birds within the simulation."
            },
            {
                "file": "corvus/graphics.c",
                "function": "The code initializes a graphical interface using the curses library, sets up color pairs, and provides functions to draw bird objects from an array on the screen, updating the display with each redraw call. It allows for visual output of bird attributes and engine iteration count in a terminal environment."
            },
            {
                "file": "corvus/main.c",
                "function": "This C program simulates a graphical representation of birds attempting to reach a target function defined as `targetFunction`, utilizing an engine to manage iterations and graphics rendering in a continuous loop. It initializes the engine and graphics, generates birds, and updates their positions based on the game logic in the `tick` function while continuously redrawing the graphics."
            },
            {
                "file": "corvus/types.h",
                "function": "This code defines a new data type `byte` as an unsigned char and creates a type alias `Strand` representing a pointer to a `byte`."
            },
            {
                "file": "corvus/virtualMachine.c",
                "function": "This code implements a basic virtual machine that interprets a Brainfuck-like programming language. It provides functions to create the virtual machine, execute commands, manage memory, and handle jumps in the program based on loop structures."
            },
            {
                "file": "corvus/virtualMachine.h",
                "function": "The file defines a `VirtualMachine` structure that contains pointers for the program counter, data counter, and arrays for program code and data space, along with constants for maximum text and data sizes. It includes a header for type definitions and references an implementation file for virtual machine functionality."
            }
        ],
        "gt": "[['corvus/bird.h', 'corvus/engine.h', 'corvus/main.c'], ['corvus/graphics.c', 'corvus/main.c'], ['corvus/virtualMachine.h', 'corvus/bird.h', 'corvus/engine.h', 'corvus/main.c'], ['corvus/bird.c', 'corvus/bird.h', 'corvus/engine.h', 'corvus/main.c'], ['corvus/engine.c', 'corvus/engine.h', 'corvus/main.c'], ['corvus/engine.h', 'corvus/main.c'], ['corvus/main.c'], ['corvus/types.h', 'corvus/main.c'], ['corvus/types.h', 'corvus/virtualMachine.h', 'corvus/bird.h', 'corvus/engine.h', 'corvus/main.c'], ['corvus/virtualMachine.c', 'corvus/virtualMachine.h', 'corvus/bird.h', 'corvus/engine.h', 'corvus/main.c'], ['corvus/types.h']]"
    },
    {
        "repo": "c-p2p-chat",
        "description": "A peer-to-peer chat application developed in C for CS 3251 coursework.",
        "function": "Allows users to connect to a chat tracker, create and join chat rooms, and send messages to peers. Utilizes UDP sockets for communication, enabling a decentralized chatting experience.",
        "files": [
            {
                "file": "c-p2p-chat/message.h",
                "function": "The file defines a structure for a message header and a packet, where the message header contains metadata such as type, error status, room identifier, and payload length, and the packet structure includes this header along with a payload of up to 1000 characters."
            },
            {
                "file": "c-p2p-chat/peer.c",
                "function": "The program implements a client for a chat application that communicates with a tracker and other peers using UDP. It allows users to create, join, and leave chatrooms, send and receive messages, and query available rooms. The client uses multithreading to handle user input and incoming network packets."
            },
            {
                "file": "c-p2p-chat/tracker.c",
                "function": "This code you've provided is part of a server implementation for managing rooms and peers in a network, with functions for creating rooms, joining rooms, leaving rooms, and handling ping responses. It is written in C, with multithreading and networking using UDP sockets. Below is a detailed breakdown of the main aspects of the code.\n\n### Key Components:\n\n1. **Data Structures:**\n   - **`struct peer`:** Represents each peer (client) in the system, storing their IP, port, room number, and alive status. The `UT_hash_handle hh` is used for hashing in the `uthash` library, allowing efficient peer management.\n   - **Global variables:** \n     - `peers` is a pointer to a hash table that stores the list of connected peers.\n     - `sock` and `ping_sock` are UDP sockets for communication with peers and for handling ping requests/responses.\n     - `stdout_lock` and `peers_lock` are mutexes used for thread synchronization (to avoid race conditions).\n\n2. **Main Functions:**\n   - **`main()`**: This is the entry point of the server. It initializes the necessary sockets, binds them to appropriate ports, and starts two threads:\n     - One thread listens for ping responses (`ping_input`).\n     - Another thread periodically sends pings and removes \"dead\" peers (`ping_output`).\n   \n3. **Threaded Operations:**\n   - **`ping_input()`**: This thread listens for incoming ping requests (of type `'p'`). When a valid ping response is received, it marks the peer as \"alive\".\n   - **`ping_output()`**: This thread periodically sends ping requests to all known peers (every 5 seconds). If a peer does not respond within a certain time, it is considered \"dead\" and removed.\n\n4. **Peer Management:**\n   - **`peer_create_room()`**: A peer can create a room. The server checks if the maximum number of rooms (`MAX_NUM_ROOMS`) has been reached, and if so, sends an error to the peer. If there\u2019s space, the server creates a room and adds the peer to the hash table.\n   - **`peer_join()`**: Peers can join an existing room. The server checks if the room exists and if there\u2019s space in the room (`MAX_ROOM_SIZE`). If successful, the peer is added to the room.\n   - **`peer_leave()`**: A peer can leave a room, and the server removes the peer from the hash table and sends a message to update the other peers in the room.\n   - **`room_list()`**: This function sends a list of all rooms, including the number of participants in each room.\n\n5. **Error Handling:**\n   - The code handles several error scenarios, such as when a peer tries to create a room but the maximum number of rooms is reached, when joining a non-existent room, or when a peer is already in a room.\n   - The `send_error()` function sends an error message back to the peer.\n\n6. **UDP Communication:**\n   - The `sendto()` function is used to send packets to peers. Each packet has a header that includes the type of message (`type`), error information (`error`), the room number (`room`), and the payload length. \n   - The payload typically includes a list of peers or other room-related information.\n\n7. **Socket Addressing:**\n   - **`get_sockaddr_in()`**: This function is used to convert an IP address and port number into a `sockaddr_in` structure, which is required for socket communication.\n\n8. **Room Handling:**\n   - **`get_total_num_rooms()`**: This function calculates how many rooms currently exist by iterating over the peers and counting unique room numbers.\n   - **`peer_list()`**: This function is responsible for sending a list of peers in a room to the room's participants. It handles both updates for existing peers and the addition of new peers joining.\n\n9. **Logging and Debugging:**\n   - The code logs various operations (e.g., room creation, joining, leaving, errors) using `fprintf(stderr, ...)`.\n   - Mutexes (`stdout_lock`, `peers_lock`) are used to ensure thread safety when logging or modifying the global peer list.\n\n### Potential Areas for Improvement:\n\n- **Memory Management**: The server allocates memory for new peers but doesn't seem to handle memory deallocation in all cases. While peers are freed when they leave a room, there might be edge cases where this doesn't happen.\n- **Error Handling**: More comprehensive error handling could be added, especially for socket operations. For example, when sending or receiving data, more detailed error messages or retries could improve robustness.\n- **Concurrency**: The server uses threads for handling ping responses and periodic actions. This approach is good for scalability, but further precautions (e.g., checking for deadlocks or race conditions) should be taken, especially around the global `peers` list.\n- **Scalability**: As the number of peers grows, the operations (e.g., iterating through the hash table) may become less efficient. Optimizations like using more specialized data structures or limiting the number of peers per room could improve performance.\n\n### Understanding the Flow:\n\n1. **Peer Creation (Command `'c'`)**:\n   - A peer sends a packet of type `'c'` to create a room. The server checks if there\u2019s space, creates a room if possible, and then sends the room number back to the peer.\n\n2. **Peer Joining (Command `'j'`)**:\n   - A peer sends a packet of type `'j'` to join a room. The server checks if the room exists and if there\u2019s space. If successful, the peer is added to the room and other peers in the room are notified.\n\n3. **Peer Leaving (Command `'l'`)**:\n   - A peer can leave the room by sending a `'l'` type packet. The server removes the peer from the room and notifies others.\n\n4. **Room Listing (Command `'r'`)**:\n   - A peer requests the list of all rooms. The server sends a summary of each room (number of participants and room size).\n\n### Conclusion:\n\nThis code implements a simple chatroom server using UDP sockets, with basic features like room creation, joining, leaving, and periodic pinging to check the status of peers. It's a good starting point for a multiplayer chat system but could benefit from further error handling, scalability improvements, and more efficient memory management."
            },
            {
                "file": "c-p2p-chat/uthash.h",
                "function": "The file defines a hash table implementation in C, providing macros and structures for adding, deleting, finding, and managing hash table entries. It supports various hash functions, bucket expansion, and sorting, ensuring efficient operations for managing key-value pairs."
            }
        ],
        "gt": "[['c-p2p-chat/tracker.c'], ['c-p2p-chat/peer.c'], ['c-p2p-chat/uthash.h', 'c-p2p-chat/tracker.c'], ['c-p2p-chat/message.h', 'c-p2p-chat/tracker.c'], ['c-p2p-chat/message.h', 'c-p2p-chat/peer.c'], ['c-p2p-chat/uthash.h']]"
    },
    {
        "repo": "ctaes",
        "description": "ctaes is a simple C module designed for constant-time AES encryption and decryption with no dependencies.",
        "function": "It implements AES using a bit-sliced approach without any data-dependent branches or tables, achieving a small executable size and moderate throughput on modern CPUs.",
        "files": [
            {
                "file": "ctaes/bench.c",
                "function": "This file is a benchmarking tool for AES encryption algorithms (AES128, AES192, and AES256), measuring the time taken for initialization, encryption, and decryption operations across multiple iterations. It provides detailed timing statistics including minimum, average, and maximum execution times for each benchmarked function."
            },
            {
                "file": "ctaes/ctaes.c",
                "function": "> retrieving file (file-PAP6gytrSbVciadkfKSzs3)> retrieving file (file-RhMTiWoPam3VoXE4nT5TYC) ok \u2705\n\n ok \u2705\n\nThis is a detailed C implementation of AES with a specific focus on bit-sliced processing, which is a technique used to make AES resistant to timing attacks. It uses 16-bit integers to represent a single AES state instead of the usual 128-bit blocks, and performs operations such as substitution, shifting rows, and mixing columns in constant time. \n\n### Key Features and Structure of the Code:\n\n#### 1. **Bit-sliced AES Implementation**:\n   - The AES state is represented as 8 16-bit integers, as opposed to the typical 128-bit state used in standard AES implementations.\n   - This approach helps in achieving constant-time execution, which is critical for cryptographic operations on potentially vulnerable systems where timing attacks could expose secret keys.\n\n#### 2. **Functions Overview**:\n   - **LoadByte and LoadBytes**: These functions load a byte (or 16 bytes) into the AES state in a \"bit-sliced\" form. Each bit of a byte is placed into a specific position of a corresponding 16-bit integer.\n   - **SaveBytes**: Converts the internal bit-sliced state back into the normal byte array format.\n   - **SubBytes**: Performs the non-linear substitution step of AES. This function applies a substitution box (S-box) operation, which is a key part of AES's cryptographic security. The implementation is optimized to be resistant to timing attacks by using bit-sliced operations.\n   - **ShiftRows and InvShiftRows**: These functions perform the row shifting operation, which is part of the AES mix of data. ShiftRows is done in the encryption process, and InvShiftRows is used in the decryption process.\n   - **MixColumns and InvMixColumns**: These functions apply the column mixing step in AES encryption and decryption, respectively. In the bit-sliced implementation, these are optimized to minimize timing variations.\n   - **AddRoundKey**: This is where the round key is XORed into the state during both encryption and decryption. It is critical for the security of the cipher.\n   - **KeySetup and Key Expansion**: The key setup and expansion functions generate the round keys used in the AES rounds.\n\n#### 3. **Optimizations**:\n   - The AES S-box is implemented using the logic from Boyar and Peralta's circuit for the S-box, which ensures constant-time execution even with operations that involve the S-box.\n   - The row shifts, column mixes, and other operations are all performed with the goal of achieving constant-time execution, which helps mitigate the risk of timing attacks where attackers might infer secret keys by measuring the execution time of cryptographic operations.\n\n#### 4. **Mathematical Operations**:\n   - Operations such as rotations (`ROT`) and bitwise shifts (`BIT_RANGE_LEFT`, `BIT_RANGE_RIGHT`) are used to manipulate bits efficiently.\n   - The polynomial-based field multiplications (like multiplying by `x` and its inverse) are optimized using bitwise operations, which are crucial for the bit-sliced design.\n\n#### 5. **Inverse Operations**:\n   - The `inv` flag in several functions (such as `SubBytes`, `ShiftRows`, `MixColumns`) indicates whether to apply the inverse transformation, necessary for decryption.\n   - For example, in `MixColumns`, the inverse multiplication uses a different fixed polynomial.\n\n#### 6. **Security Focus**:\n   - The implementation emphasizes constant-time operations, which are crucial for side-channel resistance.\n   - The functions are designed to operate in such a way that the execution time does not vary depending on input values (such as the key or plaintext), which is a key technique to prevent timing attacks.\n\n### Possible Improvements:\n1. **Efficiency**: This implementation is written in a simple and concise form but may not be the most efficient in terms of computational performance. Further optimization could involve parallelization or using more specialized hardware instructions for bit manipulation.\n2. **Portability**: While the implementation is portable to platforms where C is supported, hardware-specific optimizations (e.g., for ARM or x86) could improve speed.\n3. **Precompiled Tables**: Using precomputed S-boxes or other lookup tables (e.g., for MixColumns) could further speed up the execution, though care must be taken to maintain the constant-time property.\n\n### Conclusion:\nThis bit-sliced AES implementation prioritizes cryptographic security against timing attacks, using a non-optimized but clear and constant-time design. It is suitable for environments where timing attacks are a concern and where hardware-specific optimization is either not available or unnecessary."
            },
            {
                "file": "ctaes/ctaes.h",
                "function": "The file defines a header for a library that implements the AES (Advanced Encryption Standard) encryption algorithm in multiple modes (AES128, AES192, AES256) and provides functionality for both encryption and decryption, including support for Cipher Block Chaining (CBC) mode. It includes data structures and function prototypes for initializing contexts, encrypting, and decrypting data blocks."
            },
            {
                "file": "ctaes/test.c",
                "function": "The file contains a test suite for the AES encryption algorithm, validating both ECB and CBC modes against standard test vectors. It performs encryption and decryption using different key sizes (128, 192, and 256 bits) and checks the results for correctness, reporting any discrepancies."
            }
        ],
        "gt": "[['ctaes/ctaes.h', 'ctaes/test.c'], ['ctaes/bench.c'], ['ctaes/ctaes.h', 'ctaes/bench.c'], ['ctaes/test.c'], ['ctaes/ctaes.c'], ['ctaes/ctaes.h', 'ctaes/ctaes.c'], ['ctaes/ctaes.h']]"
    },
    {
        "repo": "dev_rickroll",
        "description": "A kernel module that creates a virtual audio device for playful rickrolling.",
        "function": "Creates the `/dev/rickroll` audio device that can be accessed using audio playback tools like 'aplay' to play Rick Astley's 'Never Gonna Give You Up'.",
        "files": [
            {
                "file": "dev_rickroll/music.h",
                "function": "It looks like you've provided a long array of hexadecimal values, seemingly for some kind of data or a file, possibly audio or text in a specific format. If you're trying to embed or store this data for a specific purpose (like in a C program or something similar), it's important to know the exact type of data you're working with to give a more precise explanation or guidance.\n\nCould you clarify what this data represents or how you'd like to use it? I can help you process or manipulate it if you want."
            },
            {
                "file": "dev_rickroll/rickroll.c",
                "function": "The file defines a Linux kernel module that creates a character device named \"rickroll,\" allowing read-only access to its content. The device supports open, read, and release operations, with write operations unsupported."
            },
            {
                "file": "dev_rickroll/rickroll.h",
                "function": "This file defines a Linux kernel module for a misc device, implementing open, release, read, and write operations for interacting with the device."
            }
        ],
        "gt": "[['dev_rickroll/rickroll.c'], ['dev_rickroll/music.h', 'dev_rickroll/rickroll.c'], ['dev_rickroll/rickroll.h', 'dev_rickroll/rickroll.c']]"
    },
    {
        "repo": "DmxSerial2",
        "description": "An Arduino library for handling DMX and RDM communication.",
        "function": "Allows sending and receiving DMX RDM packets, compatible with Arduino platforms and DMX shields. It also supports storing DMX start addresses and parameters in EEPROM for persistence across power cycles.",
        "files": [
            {
                "file": "DmxSerial2/src/DMXSerial2.h",
                "function": "The file defines a library for interfacing with DMX and RDM protocols, enabling communication with lighting and sensor devices. It supports RDM commands, device identification, sensor data retrieval, and DMX channel control, with callbacks for device-specific functionality."
            },
            {
                "file": "DmxSerial2/src/rdm.h",
                "function": "This file defines constants and parameters for the ANSI E1.20 Remote Device Management (RDM) protocol over DMX512 networks, including command classes, response types, parameter IDs, and various device and sensor-related definitions."
            }
        ],
        "gt": "[['DmxSerial2/src/DMXSerial2.h'], ['DmxSerial2/src/rdm.h', 'DmxSerial2/src/DMXSerial2.h']]"
    },
    {
        "repo": "dracut-crypt-ssh",
        "description": "A dracut module enabling remote unlocking of full disk-encrypted systems via SSH.",
        "function": "Allows remote unlocking of encrypted systems during boot using SSH with strict key-based authentication. Supports both interactive and automated unlocking methods, and provides configuration options for SSH keys and network settings.",
        "files": [
            {
                "file": "dracut-crypt-ssh/modules/60crypt-ssh/helper/auth.c",
                "function": "The program prompts the user for a passphrase, injects it into the console using `ioctl` with `TIOCSTI`, and then securely clears the passphrase from memory."
            },
            {
                "file": "dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab-test.c",
                "function": "The file defines a test program to validate the parsing of a crypttab file by comparing parsed entries against expected results. It checks the number of entries and the correctness of each entry's fields, reporting the test results."
            },
            {
                "file": "dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab.c",
                "function": "This file provides functions to parse and manage entries in a crypttab file, including handling whitespace, parsing fields, resizing entry lists, and looking up block device IDs."
            },
            {
                "file": "dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab.h",
                "function": "The file defines structures and functions for managing encrypted block devices, including parsing a configuration file, looking up block device identifiers, and freeing allocated resources."
            },
            {
                "file": "dracut-crypt-ssh/modules/60crypt-ssh/helper/unlock.c",
                "function": "The program reads a list of LUKS devices from `/etc/crypttab`, determines which devices to unlock based on user input or default criteria, and uses `cryptsetup` to unlock them. It handles memory locking, password input, and error handling, ensuring sensitive data is securely managed."
            }
        ],
        "gt": "[['dracut-crypt-ssh/modules/60crypt-ssh/helper/unlock.c'], ['dracut-crypt-ssh/modules/60crypt-ssh/helper/auth.c'], ['dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab.c'], ['dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab-test.c'], ['dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab.h', 'dracut-crypt-ssh/modules/60crypt-ssh/helper/unlock.c'], ['dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab.h', 'dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab.c'], ['dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab.h', 'dracut-crypt-ssh/modules/60crypt-ssh/helper/crypttab-test.c']]"
    },
    {
        "repo": "dress",
        "description": "A tool to add symbols back into a stripped ELF binary.",
        "function": "Allows users to restore symbols (global variables and function names) into stripped ELF binaries using a symbol file. Supports 64-bit ELF files and provides verbose output for debugging.",
        "files": [
            {
                "file": "dress/dress.c",
                "function": "The program reads an ELF file, processes a symbol file to extract function names and addresses, and appends these symbols to the ELF file, writing the modified ELF to an output file."
            },
            {
                "file": "dress/libelf.c",
                "function": "This file provides functionality for manipulating ELF64 files, including reading, writing, updating, and modifying sections and symbols. It supports operations like expanding sections, appending data, creating new sections, and adding symbols to an ELF64 file."
            },
            {
                "file": "dress/libelf.h",
                "function": "The file defines structures and functions for handling ELF64 files, including reading, writing, and managing sections, symbols, and headers. It provides functionality to create, modify, and delete ELF64 files, as well as print sections and symbols."
            },
            {
                "file": "dress/logging.c",
                "function": "This file provides logging functions (`print`, `error`, `info`, `warn`) that output messages with colored formatting and can be toggled on or off using a `verbose` flag."
            },
            {
                "file": "dress/logging.h",
                "function": "The file provides logging functions (`print`, `error`, `info`, `warn`) to output messages with different severity levels (fatal, normal, minor errors) and can be toggled on/off via a verbose flag."
            },
            {
                "file": "dress/example/test.c",
                "function": "The program increments a global counter and prints its value in a loop, displaying the counter's value five times."
            }
        ],
        "gt": "[['dress/logging.h', 'dress/logging.c'], ['dress/libelf.h', 'dress/dress.c'], ['dress/logging.h', 'dress/dress.c'], ['dress/example/test.c'], ['dress/logging.c'], ['dress/libelf.c'], ['dress/dress.c'], ['dress/libelf.h'], ['dress/logging.h', 'dress/libelf.c'], ['dress/libelf.h', 'dress/libelf.c']]"
    },
    {
        "repo": "ds3vita",
        "description": "A plugin for the PlayStation Vita that enables support for DualShock 3 (DS3) controllers.",
        "function": "Allows users to pair and use DS3 or Sixaxis controllers with the Vita by adding the plugin to taiHEN's configuration and using a pairing tool to connect the controller.",
        "files": [
            {
                "file": "ds3vita/log.c",
                "function": "The file provides logging functionality, allowing the writing and flushing of log data to a file, with buffer management for non-release builds."
            },
            {
                "file": "ds3vita/log.h",
                "function": "The file defines a logging system for writing messages to a specified log file, with macros for conditional logging and testing function return values."
            },
            {
                "file": "ds3vita/main.c",
                "function": "This file implements a module for the PlayStation Vita to support the DualShock 3 (DS3) controller over Bluetooth, including handling input data, managing connections, and patching system functions to integrate DS3 functionality seamlessly."
            }
        ],
        "gt": "[['ds3vita/log.h', 'ds3vita/log.c'], ['ds3vita/main.c'], ['ds3vita/log.h', 'ds3vita/main.c'], ['ds3vita/log.c']]"
    },
    {
        "repo": "dumpulator",
        "description": "Dumpulator is a library for emulating code within minidump files, aiding in reverse engineering and malware analysis.",
        "function": "It allows users to call functions, trace execution, read strings, run code snippets, and implement custom syscalls. The library leverages the full process memory from minidumps for efficient emulation.",
        "files": [
            {
                "file": "dumpulator/tests/DumpulatorTests/Tests/debug.h",
                "function": "The file defines a `DebugPrint` function to output Unicode strings using `NtDisplayString`, simplifying trace output. It supports both C++ and C environments, with C++ providing a template-based implementation for string literals."
            },
            {
                "file": "dumpulator/tests/DumpulatorTests/Tests/ntstatusdb.h",
                "function": "The file defines a function `status2str` that converts a `uint32_t` status code into a corresponding string representation."
            },
            {
                "file": "dumpulator/tests/DumpulatorTests/Tests/phnt.h",
                "function": "An error occurred: Error code: 400 - {'error': {'message': \"This model's maximum context length is 65536 tokens. However, you requested 407186 tokens (407186 in the messages, 0 in the completion). Please reduce the length of the messages or completion.\", 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_request_error'}}"
            },
            {
                "file": "dumpulator/utils/phnt.c",
                "function": "The file includes headers from the PHNT (Private Headers for Native Tools) library, which provides access to undocumented Windows kernel and system APIs for low-level system programming."
            }
        ],
        "gt": "[['dumpulator/tests/DumpulatorTests/Tests/debug.h'], ['dumpulator/tests/DumpulatorTests/Tests/phnt.h', 'dumpulator/utils/phnt.c'], ['dumpulator/tests/DumpulatorTests/Tests/phnt.h', 'dumpulator/tests/DumpulatorTests/Tests/debug.h'], ['dumpulator/utils/phnt.c'], ['dumpulator/tests/DumpulatorTests/Tests/ntstatusdb.h'], ['dumpulator/tests/DumpulatorTests/Tests/phnt.h']]"
    },
    {
        "repo": "dwm",
        "description": "A customized version of dwm, a dynamic window manager for X11, with numerous improvements and patches.",
        "function": "Includes various patches and refactors, such as alwaysfullscreen, barperf, and multikeycode, while maintaining synchronization with upstream dwm. Features unused code left in place to minimize merge conflicts.",
        "files": [
            {
                "file": "dwm/config.def.h",
                "function": "This configuration file customizes the appearance, behavior, and keybindings of a window manager, defining window layouts, colors, rules for applications, and key/mouse actions for managing windows and workspaces."
            },
            {
                "file": "dwm/config.h",
                "function": "This configuration file customizes the appearance, behavior, and keybindings of a window manager, defining window rules, layouts, and commands for launching applications and managing system functions."
            },
            {
                "file": "dwm/drw.c",
                "function": "The file provides a drawing library for X11, offering functions to create and manage drawing contexts, handle fonts, colors, and text rendering, and draw shapes and text on X11 windows. It includes utilities for UTF-8 text decoding and font fallback handling."
            },
            {
                "file": "dwm/drw.h",
                "function": "The file defines an abstraction layer for drawing operations in X11, providing functions to manage fonts, colors, cursors, and drawing contexts, as well as to render text and shapes on a drawable surface."
            },
            {
                "file": "dwm/dwm.c",
                "function": "The file defines a dynamic window manager (dwm) for X11, handling window management through event-driven X events. It organizes clients (windows) into a linked list, manages focus and layout changes, and supports keybindings and rules for window behavior. The manager uses a modular event handler system for efficient event dispatching and supports multiple monitors and layouts."
            },
            {
                "file": "dwm/transient.c",
                "function": "This program creates a persistent main window and a transient window that appears after a 5-second delay, using the X11 library for window management."
            },
            {
                "file": "dwm/util.c",
                "function": "The file defines utility functions for error handling and memory allocation. The `die` function prints an error message and exits the program, while `ecalloc` safely allocates memory and terminates the program on failure."
            },
            {
                "file": "dwm/util.h",
                "function": "This file defines macros for basic operations like finding the maximum, minimum, and checking if a value is between two others. It also includes functions for error handling and memory allocation."
            }
        ],
        "gt": "[['dwm/drw.h', 'dwm/drw.c'], ['dwm/drw.c'], ['dwm/dwm.c'], ['dwm/util.c'], ['dwm/transient.c'], ['dwm/drw.h', 'dwm/dwm.c'], ['dwm/util.h', 'dwm/drw.c'], ['dwm/util.h', 'dwm/dwm.c'], ['dwm/config.def.h'], ['dwm/util.h', 'dwm/util.c'], ['dwm/config.h', 'dwm/dwm.c']]"
    },
    {
        "repo": "ee",
        "description": "An EEPROM emulation library for STM32 microcontrollers.",
        "function": "Emulates EEPROM functionality by utilizing the latest sector or page of the MCU for data storage. Provides easy initialization, reading, and writing of data structures.",
        "files": [
            {
                "file": "ee/ee.c",
                "function": "This file provides functions for initializing, formatting, reading, and writing to an EEPROM emulation module on STM32 microcontrollers, handling different flash memory configurations based on the MCU model."
            },
            {
                "file": "ee/ee.h",
                "function": "The file defines an EEPROM emulation library for STM32 microcontrollers, providing functions for initialization, capacity retrieval, formatting, reading, and writing data to flash memory. It includes a handle structure for managing data, size, and memory addresses."
            },
            {
                "file": "ee/NimaLTD.I-CUBE-EE_conf.h",
                "function": "This file configures settings for the NimaLTD.I-CUBE-EE middleware, including page sector sizes, manual configuration mode, selected page sector number, bank, and address for flash memory usage."
            }
        ],
        "gt": "[['ee/NimaLTD.I-CUBE-EE_conf.h', 'ee/ee.c'], ['ee/ee.c'], ['ee/ee.h', 'ee/ee.c']]"
    },
    {
        "repo": "EmbeddableWebServer",
        "description": "A lightweight, embeddable web server for C/C++ applications, implemented in a single header file.",
        "function": "Allows serving static files, handling dynamic responses, and processing HTML forms and JSON data. It supports multi-threading for handling multiple connections simultaneously and provides debugging tools.",
        "files": [
            {
                "file": "EmbeddableWebServer/EmbeddableWebServer.h",
                "function": "The file defines a lightweight, embeddable C web server that can handle HTTP requests and serve files. It supports dynamic request handling, file serving, and basic HTML/JSON responses, with a focus on simplicity and ease of integration into existing projects. The server operates on a thread-per-connection model and is designed for use on Windows, Linux, and macOS, though it is not recommended for internet-facing applications due to limited security features."
            },
            {
                "file": "EmbeddableWebServer/EWSFuzz.c",
                "function": "The file defines a fuzz test for an embedded web server, initializing a server and simulating a connection to handle requests. It includes functionality to create and serve responses based on POST parameters and request paths."
            }
        ],
        "gt": "[['EmbeddableWebServer/EmbeddableWebServer.h'], ['EmbeddableWebServer/EWSFuzz.c']]"
    },
    {
        "repo": "ESP8266",
        "description": "A library for the Esp8266 series microcontroller, designed for integration with STM32F103VC using Keil Compiler and STM32CubeMX.",
        "function": "Enables WiFi functionality on STM32F103VC by integrating FreeRTOS, configuring USART with interrupts, and providing initialization and user configuration options.",
        "files": [
            {
                "file": "ESP8266/Wifi.c",
                "function": "This file provides a comprehensive set of functions to manage Wi-Fi communication, including sending and receiving data, handling TCP/IP connections, configuring Wi-Fi modes, and interacting with access points. It also includes utilities for parsing and processing received data, managing network settings, and handling various Wi-Fi module commands."
            },
            {
                "file": "ESP8266/Wifi.h",
                "function": "The file defines a WiFi module with functions for initializing, managing, and interacting with WiFi connections, including setting modes, handling TCP/IP connections, and managing station and soft AP configurations."
            },
            {
                "file": "ESP8266/WifiConfig.h",
                "function": "This file defines configuration parameters for a WiFi module, including USART settings, buffer sizes, and wait times for different operations."
            },
            {
                "file": "ESP8266/WifiUser.c",
                "function": "This file initializes a Wi-Fi connection in station mode, connects to a specified access point, and manages TCP/IP communication by starting a TCP connection and responding to incoming TCP/UDP data with an \"OK\" message."
            }
        ],
        "gt": "[['ESP8266/Wifi.c'], ['ESP8266/WifiUser.c'], ['ESP8266/WifiConfig.h', 'ESP8266/Wifi.c'], ['ESP8266/Wifi.h', 'ESP8266/WifiUser.c'], ['ESP8266/Wifi.h', 'ESP8266/Wifi.c'], ['ESP8266/WifiConfig.h', 'ESP8266/Wifi.h', 'ESP8266/WifiUser.c'], ['ESP8266/WifiConfig.h', 'ESP8266/Wifi.h', 'ESP8266/Wifi.c'], ['ESP8266/WifiConfig.h']]"
    },
    {
        "repo": "ESP8266MQTTClient",
        "description": "An MQTT client library for ESP8266 Arduino, enabling communication with MQTT brokers.",
        "function": "Supports subscribing, publishing, authentication, will messages, keep-alive pings, and all three QoS levels. Provides APIs for setup, events, and pub/sub operations.",
        "files": [
            {
                "file": "ESP8266MQTTClient/src/ESP8266MQTTClient.h",
                "function": "The file defines an MQTT client library for the ESP8266 microcontroller, enabling it to connect to MQTT brokers, publish messages, and subscribe to topics, with support for secure connections and various callback functions for handling events."
            },
            {
                "file": "ESP8266MQTTClient/src/MQTTTransport.h",
                "function": "The file defines traits for MQTT transport over WebSocket, including connection, data writing, and reading, with support for both secure and non-secure modes."
            },
            {
                "file": "ESP8266MQTTClient/src/mqtt_msg.c",
                "function": "This file provides functions for creating and handling MQTT messages, including connection setup, publishing, subscribing, and various control packets, ensuring proper formatting and encoding according to the MQTT protocol."
            },
            {
                "file": "ESP8266MQTTClient/src/mqtt_msg.h",
                "function": "This file defines structures and functions for handling MQTT protocol messages, including message types, connection management, and operations like publishing, subscribing, and ping requests."
            },
            {
                "file": "ESP8266MQTTClient/src/mqtt_outbox.c",
                "function": "This file implements an MQTT outbox system to manage and store outgoing MQTT messages, providing functions to create, retrieve, delete, and clean up messages based on various criteria such as message ID, type, expiration, and size constraints."
            },
            {
                "file": "ESP8266MQTTClient/src/mqtt_outbox.h",
                "function": "The file defines an MQTT outbox structure and functions to manage outgoing MQTT messages, including creation, insertion, retrieval, deletion, and cleanup based on various criteria like message ID, type, expiration, and size limits."
            },
            {
                "file": "ESP8266MQTTClient/src/uri_parser.c",
                "function": "The file provides a URI parsing function that breaks down a given URL into its components (scheme, host, port, path, query, fragment, username, and password) and stores them in a structured format. It also includes functions to print and free the parsed URI data."
            },
            {
                "file": "ESP8266MQTTClient/src/uri_parser.h",
                "function": "The file defines a URI parser that parses a URI string into its components (scheme, host, port, path, query, fragment, etc.) and provides functions to manage and free the parsed URI structure."
            }
        ],
        "gt": "[['ESP8266MQTTClient/src/uri_parser.c'], ['ESP8266MQTTClient/src/ESP8266MQTTClient.h'], ['ESP8266MQTTClient/src/mqtt_outbox.h', 'ESP8266MQTTClient/src/ESP8266MQTTClient.h'], ['ESP8266MQTTClient/src/mqtt_msg.h', 'ESP8266MQTTClient/src/mqtt_msg.c'], ['ESP8266MQTTClient/src/mqtt_msg.c'], ['ESP8266MQTTClient/src/mqtt_outbox.c'], ['ESP8266MQTTClient/src/mqtt_msg.h', 'ESP8266MQTTClient/src/ESP8266MQTTClient.h'], ['ESP8266MQTTClient/src/MQTTTransport.h'], ['ESP8266MQTTClient/src/uri_parser.h', 'ESP8266MQTTClient/src/uri_parser.c'], ['ESP8266MQTTClient/src/mqtt_outbox.h', 'ESP8266MQTTClient/src/mqtt_outbox.c'], ['ESP8266MQTTClient/src/uri_parser.h', 'ESP8266MQTTClient/src/ESP8266MQTTClient.h']]"
    },
    {
        "repo": "evdev-right-click-emulation",
        "description": "A program for emulating right-click functionality on Linux touchscreen devices using long-press gestures.",
        "function": "It reads touchscreen input events via `evdev`, detects long presses, and triggers a right-click using `uinput`. Works across Xorg and Wayland without requiring specific desktop environments.",
        "files": [
            {
                "file": "evdev-right-click-emulation/input.c",
                "function": "The file implements a system to detect long-press events on input devices and simulate a right-click action upon timeout. It uses `libevdev` to handle input events, `timerfd` to manage timeouts, and `uinput` to generate synthetic input events. The system tracks touch events, schedules delayed right-clicks, and cancels them if the touch is released or moved beyond a specified threshold."
            },
            {
                "file": "evdev-right-click-emulation/input.h",
                "function": "The file defines a function `process_evdev_input` to handle input events from multiple evdev devices."
            },
            {
                "file": "evdev-right-click-emulation/rce.c",
                "function": "The program scans `/dev/input` for touchscreen devices, applying a blacklist or whitelist filter based on device names. It then processes input events from the filtered devices."
            },
            {
                "file": "evdev-right-click-emulation/rce.h",
                "function": "The file defines constants and external variables related to touchscreen interactions, including the maximum number of touchscreens and parameters for long click detection."
            },
            {
                "file": "evdev-right-click-emulation/uinput.c",
                "function": "The file defines functions to initialize a simulated right-click input device and send right-click events using the uinput interface."
            },
            {
                "file": "evdev-right-click-emulation/uinput.h",
                "function": "The file defines functions to initialize a uinput device and send a right-click event using libevdev."
            }
        ],
        "gt": "[['evdev-right-click-emulation/rce.c'], ['evdev-right-click-emulation/input.c'], ['evdev-right-click-emulation/uinput.h', 'evdev-right-click-emulation/rce.c'], ['evdev-right-click-emulation/uinput.h', 'evdev-right-click-emulation/input.c'], ['evdev-right-click-emulation/uinput.h', 'evdev-right-click-emulation/uinput.c'], ['evdev-right-click-emulation/uinput.c'], ['evdev-right-click-emulation/input.h'], ['evdev-right-click-emulation/rce.h', 'evdev-right-click-emulation/rce.c'], ['evdev-right-click-emulation/rce.h', 'evdev-right-click-emulation/input.c'], ['evdev-right-click-emulation/rce.h']]"
    },
    {
        "repo": "face-injector-v2",
        "description": "A tool for injecting faces into games by KANKOSHEV.",
        "function": "Allows users to inject faces into specific games by targeting their window class names. Supports Valorant, Apex Legends, and Warface. Users can modify the code, drivers, or mappers for improvements.",
        "files": [
            {
                "file": "face-injector-v2/face_injector_v2/api/api.h",
                "function": "The file defines functions for generating random strings, manipulating file paths, and executing processes with elevated privileges. It also includes functionality for dropping and executing shellcode-related files (mapper and driver) while ensuring they are deleted after use."
            },
            {
                "file": "face-injector-v2/face_injector_v2/api/drvutils.h",
                "function": "The file defines a function `start_driver()` that initializes and handles a driver, checking if it is already loaded and attempting to map it if not. It outputs status messages indicating success or failure."
            },
            {
                "file": "face-injector-v2/face_injector_v2/api/shellcode.h",
                "function": "An error occurred: Error code: 400 - {'error': {'message': \"This model's maximum context length is 65536 tokens. However, you requested 1637926 tokens (1637926 in the messages, 0 in the completion). Please reduce the length of the messages or completion.\", 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_request_error'}}"
            },
            {
                "file": "face-injector-v2/face_injector_v2/api/utilit.h",
                "function": "The file provides utility functions for retrieving the parent directory of a given path, obtaining the executable's directory, and setting specific privileges on a Windows system. It also includes inline functions to get and set the last NT status."
            },
            {
                "file": "face-injector-v2/face_injector_v2/api/xor.h",
                "function": "The file defines compile-time encryption and decryption mechanisms for strings using XOR operations, with separate implementations for single-byte and wide-character strings. It also includes a compile-time random number generator and utilities for constructing index lists."
            },
            {
                "file": "face-injector-v2/face_injector_v2/define/stdafx.h",
                "function": "The file appears to be a header file that includes a wide range of Windows API and C++ standard library headers, likely for developing a Windows-based application involving process management, file handling, threading, and system-level operations."
            },
            {
                "file": "face-injector-v2/face_injector_v2/driver/defines.h",
                "function": "This file defines IOCTL codes and structures for interacting with a device driver, enabling operations such as memory allocation, protection, copying, and module information retrieval."
            },
            {
                "file": "face-injector-v2/face_injector_v2/driver/driver.h",
                "function": "The file defines a `c_driver` class for interacting with a Windows driver, providing functionality to attach to processes, send service requests, manage memory (read, write, protect, allocate, free), and retrieve module information. It supports singleton access to ensure a single instance of the driver is used."
            },
            {
                "file": "face-injector-v2/face_injector_v2/inject/injector.h",
                "function": "The file defines functionality for injecting a DLL into a remote process by dynamically loading it, resolving imports, relocating sections, and executing the DLL's entry point. It includes shellcode for remote loading and calling the DLL's main function, along with structures and functions to manage the injection process."
            },
            {
                "file": "face-injector-v2/face_injector_v2/inject/utils.h",
                "function": "The file contains functions for loading a DLL from a file, converting a string to a wide character string, retrieving process and thread IDs by window class or process name, and obtaining a process name by its ID."
            }
        ],
        "gt": "[['face-injector-v2/face_injector_v2/api/xor.h'], ['face-injector-v2/face_injector_v2/inject/utils.h', 'face-injector-v2/face_injector_v2/inject/injector.h'], ['face-injector-v2/face_injector_v2/driver/driver.h'], ['face-injector-v2/face_injector_v2/inject/injector.h'], ['face-injector-v2/face_injector_v2/define/stdafx.h'], ['face-injector-v2/face_injector_v2/api/shellcode.h', 'face-injector-v2/face_injector_v2/api/api.h'], ['face-injector-v2/face_injector_v2/api/api.h'], ['face-injector-v2/face_injector_v2/driver/defines.h', 'face-injector-v2/face_injector_v2/driver/driver.h'], ['face-injector-v2/face_injector_v2/api/drvutils.h'], ['face-injector-v2/face_injector_v2/api/utilit.h']]"
    },
    {
        "repo": "fork-raspiraw",
        "description": "Raspiraw is an application for capturing raw data directly from CSI sensors on the Raspberry Pi.",
        "function": "It supports various sensors like OV5647, IMX219, and ADV7282M, and allows for high-frame-rate capturing with options to modify sensor registers, set exposure, gain, and flip settings, and save raw Bayer format frames. The captured frames can be converted to .ppm images using a modified dcraw.",
        "files": [
            {
                "file": "fork-raspiraw/adv7282m_modes.h",
                "function": "This file defines configuration settings and registers for the ADV7282-M video decoder, including initialization, input/output control, and power management, to support various video standards and input types."
            },
            {
                "file": "fork-raspiraw/imx219_modes.h",
                "function": "The file defines various configurations and settings for the IMX219 sensor, including register values for different modes (e.g., 8MP, 1080p, 720p) and control registers for exposure, gain, and flip settings. It also includes a structure to manage these configurations and I2C communication details for the sensor."
            },
            {
                "file": "fork-raspiraw/ov5647_modes.h",
                "function": "This file defines various configurations and register settings for the OV5647 camera sensor, including different modes for capturing images at various resolutions and formats. It also includes settings for sensor identification, flipping, exposure, gain, and output sizes."
            },
            {
                "file": "fork-raspiraw/RaspiCLI.c",
                "function": "The file provides functions for parsing command line parameters, mapping strings to command IDs, displaying help information, and converting between string and integer representations of commands."
            },
            {
                "file": "fork-raspiraw/RaspiCLI.h",
                "function": "The file defines structures for command lists and cross-references, and provides functions to display help, retrieve command IDs, and map/unmap cross-references based on mode strings and IDs."
            },
            {
                "file": "fork-raspiraw/raspiraw.c",
                "function": "This file is a C program for controlling and capturing raw image data from a camera sensor connected to a Raspberry Pi via I2C. It supports various sensors, allows configuration of settings like exposure, gain, and flip, and can save captured frames with optional headers."
            },
            {
                "file": "fork-raspiraw/raw_header.h",
                "function": "This file defines a raw image header structure for a camera module, including metadata such as image dimensions, format, and padding, along with a version identifier and offset to image data."
            },
            {
                "file": "fork-raspiraw/tools/double.c",
                "function": "This program reads a PPM or PGM image file, doubles its width by mirroring each row, and outputs the modified image to standard output."
            }
        ],
        "gt": "[['fork-raspiraw/adv7282m_modes.h', 'fork-raspiraw/raspiraw.c'], ['fork-raspiraw/imx219_modes.h', 'fork-raspiraw/raspiraw.c'], ['fork-raspiraw/tools/double.c'], ['fork-raspiraw/raspiraw.c'], ['fork-raspiraw/raw_header.h', 'fork-raspiraw/raspiraw.c'], ['fork-raspiraw/RaspiCLI.c'], ['fork-raspiraw/RaspiCLI.h', 'fork-raspiraw/raspiraw.c'], ['fork-raspiraw/ov5647_modes.h', 'fork-raspiraw/raspiraw.c'], ['fork-raspiraw/RaspiCLI.h', 'fork-raspiraw/RaspiCLI.c'], ['fork-raspiraw/ov5647_modes.h']]"
    },
    {
        "repo": "Fully-Undetectable-Techniques",
        "description": "A repository focused on researching and developing fully undetectable (FUD) techniques and tools.",
        "function": "Explores methods and tools designed to evade detection by security systems, aiming to create stealthy and undetectable solutions.",
        "files": [
            {
                "file": "Fully-Undetectable-Techniques/minizinh0-FUD/src/minizinh0-FUD.c",
                "function": "This file implements a ransomware that encrypts files using AES-CBC and RSA encryption, writes a ransom note, and operates stealthily by creating a hidden desktop environment."
            },
            {
                "file": "Fully-Undetectable-Techniques/possessor/src/base64.c",
                "function": "This file provides functions for encoding and decoding data using the Base64 algorithm, including building and cleaning up the decoding table."
            },
            {
                "file": "Fully-Undetectable-Techniques/possessor/src/base64.h",
                "function": "The file provides functions for encoding data into Base64 format and decoding Base64-encoded data, along with utilities to build a decoding table and clean up resources."
            },
            {
                "file": "Fully-Undetectable-Techniques/possessor/src/possessor.c",
                "function": "The file implements a remote command execution tool that interacts with Windows systems via a network socket. It allows sending commands to execute in cmd.exe or PowerShell, writing files, and retrieving results, all while using stealth techniques like creating hidden desktops and encoding/encrypting data for communication."
            },
            {
                "file": "Fully-Undetectable-Techniques/possessor/src/possessor.h",
                "function": "The file defines constants for buffer sizes, port, server IP, and other configurations. It includes functions for interacting with a window handle, sending commands, encoding/decoding Base64, and managing network connections."
            },
            {
                "file": "Fully-Undetectable-Techniques/user-imitation/stealth.c",
                "function": "The program creates a hidden desktop, spawns an explorer process within it, and executes a series of commands to write and execute a payload file, potentially for malicious purposes."
            }
        ],
        "gt": "[['Fully-Undetectable-Techniques/possessor/src/base64.c'], ['Fully-Undetectable-Techniques/possessor/src/possessor.c'], ['Fully-Undetectable-Techniques/possessor/src/base64.h', 'Fully-Undetectable-Techniques/minizinh0-FUD/src/minizinh0-FUD.c'], ['Fully-Undetectable-Techniques/possessor/src/base64.h', 'Fully-Undetectable-Techniques/possessor/src/possessor.c'], ['Fully-Undetectable-Techniques/user-imitation/stealth.c'], ['Fully-Undetectable-Techniques/possessor/src/possessor.h', 'Fully-Undetectable-Techniques/possessor/src/possessor.c'], ['Fully-Undetectable-Techniques/minizinh0-FUD/src/minizinh0-FUD.c'], ['Fully-Undetectable-Techniques/possessor/src/base64.h']]"
    },
    {
        "repo": "gnome-monitor-config",
        "description": "A configuration tool for managing monitor settings in GNOME environments.",
        "function": "Allows users to list current monitor configurations, set new configurations, and manage multi-monitor setups with options for positioning, scaling, orientation, and resolution settings.",
        "files": [
            {
                "file": "gnome-monitor-config/src/gmc-display-config-manager.c",
                "function": "The file defines a manager for handling display configurations, including creating and applying monitor configurations, and interfacing with a D-Bus service to manage display settings."
            },
            {
                "file": "gnome-monitor-config/src/gmc-display-config-manager.h",
                "function": "The file defines a manager for handling display configurations, allowing the creation of current display states, applying new configurations, and managing display settings."
            },
            {
                "file": "gnome-monitor-config/src/gmc-display-config.c",
                "function": "This file defines structures and functions for managing display configurations, including monitors, modes, and logical layouts, and provides functionality to retrieve and manipulate display settings via D-Bus."
            },
            {
                "file": "gnome-monitor-config/src/gmc-display-config.h",
                "function": "This file defines a library for managing display configurations, including handling monitor states, logical monitor layouts, and display modes, with support for scaling, transformations, and primary monitor settings."
            },
            {
                "file": "gnome-monitor-config/src/gmc-display-test.c",
                "function": "This program manages display configurations, allowing users to list current monitors, set new configurations, and show monitor labels. It supports adding logical monitors, setting positions, scales, transforms, and marking monitors as primary, with options for both logical and physical layout modes."
            }
        ],
        "gt": "[['gnome-monitor-config/src/gmc-display-config.h', 'gnome-monitor-config/src/gmc-display-config-manager.h', 'gnome-monitor-config/src/gmc-display-test.c'], ['gnome-monitor-config/src/gmc-display-config.h', 'gnome-monitor-config/src/gmc-display-config-manager.c'], ['gnome-monitor-config/src/gmc-display-config.h', 'gnome-monitor-config/src/gmc-display-test.c'], ['gnome-monitor-config/src/gmc-display-config-manager.h', 'gnome-monitor-config/src/gmc-display-config-manager.c'], ['gnome-monitor-config/src/gmc-display-test.c'], ['gnome-monitor-config/src/gmc-display-config-manager.h', 'gnome-monitor-config/src/gmc-display-test.c'], ['gnome-monitor-config/src/gmc-display-config.h', 'gnome-monitor-config/src/gmc-display-config-manager.h', 'gnome-monitor-config/src/gmc-display-config-manager.c'], ['gnome-monitor-config/src/gmc-display-config.c'], ['gnome-monitor-config/src/gmc-display-config-manager.c'], ['gnome-monitor-config/src/gmc-display-config.h', 'gnome-monitor-config/src/gmc-display-config.c'], ['gnome-monitor-config/src/gmc-display-config.h']]"
    },
    {
        "repo": "Google-Dino-GBA",
        "description": "A recreation of the Google Dinosaur game for the Gameboy Advance.",
        "function": "Allows players to control a dinosaur using the D-pad and A button to jump and crouch, with gameplay mechanics balanced to match the original. Can be built using devkitPro and TONC library or played via ROM in any Gameboy Advance emulator.",
        "files": [
            {
                "file": "Google-Dino-GBA/include/dino.h",
                "function": "This file defines constants, structures, and functions for a game involving a dinosaur, including mechanics for jumping, ducking, obstacle generation, collision detection, and game state management."
            },
            {
                "file": "Google-Dino-GBA/include/dinoSheet.h",
                "function": "The file defines a sprite sheet (`dinoSheet`) for a game, containing 1024 tiles and a 256-entry palette, used for rendering graphical assets on a GBA."
            },
            {
                "file": "Google-Dino-GBA/include/dinoSheetHelper.h",
                "function": "This file defines constants, structs, and functions for managing sprite attributes and animations in a game, particularly for a Dino-themed game, including sprite indices, object sets, and manipulation functions for positioning, visibility, and animation."
            },
            {
                "file": "Google-Dino-GBA/source/dino.c",
                "function": "The file defines the main functionality of a game, likely a side-scrolling runner, where the player controls a character (dino) to avoid obstacles, collect points, and manage game states. It includes initialization, input handling, game updates, collision detection, and rendering logic for the game's mechanics, including jumping, ducking, obstacle spawning, and night-day transitions."
            },
            {
                "file": "Google-Dino-GBA/source/dinoSheet.c",
                "function": "An error occurred: Error code: 400 - {'error': {'message': \"This model's maximum context length is 65536 tokens. However, you requested 121077 tokens (121077 in the messages, 0 in the completion). Please reduce the length of the messages or completion.\", 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_request_error'}}"
            },
            {
                "file": "Google-Dino-GBA/source/dinoSheetHelper.c",
                "function": "This file defines various object sets and helper functions for managing sprite attributes, positions, and animations in a game, likely for a GBA or similar platform. It includes functionality for creating and manipulating game elements like the dino, birds, clouds, obstacles, and UI components such as scores and game-over screens."
            }
        ],
        "gt": "[['Google-Dino-GBA/include/dinoSheet.h', 'Google-Dino-GBA/source/dino.c'], ['Google-Dino-GBA/include/dinoSheetHelper.h', 'Google-Dino-GBA/source/dinoSheetHelper.c'], ['Google-Dino-GBA/source/dino.c'], ['Google-Dino-GBA/source/dinoSheetHelper.c'], ['Google-Dino-GBA/include/dino.h', 'Google-Dino-GBA/source/dino.c'], ['Google-Dino-GBA/include/dino.h', 'Google-Dino-GBA/source/dinoSheetHelper.c'], ['Google-Dino-GBA/include/dinoSheetHelper.h', 'Google-Dino-GBA/source/dino.c'], ['Google-Dino-GBA/source/dinoSheet.c']]"
    },
    {
        "repo": "gpio-watch",
        "description": "A tool for running scripts in response to GPIO events on devices like the Raspberry Pi.",
        "function": "Monitors specified GPIO pins for rising, falling, or both edge events, triggering shell scripts located in a specified directory. Supports per-pin edge configuration and switch debouncing.",
        "files": [
            {
                "file": "gpio-watch/fileutil.c",
                "function": "The file provides utility functions to determine if a given path is a regular file or a directory by using the `stat` system call."
            },
            {
                "file": "gpio-watch/fileutil.h",
                "function": "The file provides utility functions to check if a given path is a file or a directory."
            },
            {
                "file": "gpio-watch/gpio.c",
                "function": "The file provides functions to manage GPIO pins, including exporting pins, setting their direction (input/output), and configuring edge detection for GPIO events."
            },
            {
                "file": "gpio-watch/gpio.h",
                "function": "The file defines constants and functions for interacting with GPIO pins, including parsing directions and edges, exporting pins, and setting their edge and direction."
            },
            {
                "file": "gpio-watch/logging.c",
                "function": "The file provides logging functionality, including a `logprint` function for formatted output to `stderr` and a `logtime` function to generate timestamp strings for log entries."
            },
            {
                "file": "gpio-watch/logging.h",
                "function": "The file defines logging macros (`LOG_ERROR`, `LOG_WARN`, `LOG_INFO`, `LOG_DEBUG`) that conditionally log messages based on a specified log level. It also declares external functions for logging and retrieving the current time for log entries."
            },
            {
                "file": "gpio-watch/main.c",
                "function": "The program monitors GPIO pins for events and executes corresponding scripts when events occur, with options to configure logging, script directories, and edge detection modes."
            }
        ],
        "gt": "[['gpio-watch/logging.c'], ['gpio-watch/main.c'], ['gpio-watch/gpio.h', 'gpio-watch/main.c'], ['gpio-watch/logging.h', 'gpio-watch/main.c'], ['gpio-watch/gpio.h', 'gpio-watch/gpio.c'], ['gpio-watch/gpio.c'], ['gpio-watch/fileutil.h', 'gpio-watch/main.c'], ['gpio-watch/fileutil.h', 'gpio-watch/gpio.c'], ['gpio-watch/fileutil.h', 'gpio-watch/fileutil.c'], ['gpio-watch/fileutil.c'], ['gpio-watch/logging.h', 'gpio-watch/logging.c'], ['gpio-watch/logging.h', 'gpio-watch/gpio.c']]"
    },
    {
        "repo": "igbinary",
        "description": "Igbinary is a PHP extension that serves as a more efficient binary serializer.",
        "function": "It reduces storage requirements by storing PHP data structures in compact binary form, supports various PHP data types, and offers options for optimizing string handling and integration with APC cache.",
        "files": [
            {
                "file": "igbinary/apc_serializer.h",
                "function": "This file defines a serializer and unserializer interface for the APC (Alternative PHP Cache) extension, allowing custom serialization and deserialization functions to be registered and used within the extension."
            },
            {
                "file": "igbinary/hash.h",
                "function": "The file defines a hash table implementation (`hash_si`) that maps string keys to 32-bit integer values, supporting operations like initialization, insertion, lookup, removal, traversal, and querying size and capacity."
            },
            {
                "file": "igbinary/hash_si.c",
                "function": "This file implements a hash table with string keys and integer values, providing functions for initialization, deinitialization, insertion, removal, rehashing, and traversal."
            },
            {
                "file": "igbinary/igbinary.c",
                "function": "The file defines a PHP extension for binary serialization and deserialization, providing functions to serialize and unserialize PHP data structures efficiently. It supports various data types, including arrays, objects, strings, and numbers, and includes mechanisms for handling references and optimizing string storage."
            },
            {
                "file": "igbinary/igbinary.h",
                "function": "The file defines functions for serializing and unserializing PHP variables (zvals) into a binary format, with optional memory management for custom allocation and deallocation."
            },
            {
                "file": "igbinary/ig_win32.h",
                "function": "This file defines macros and types for compatibility with Windows environments, including inline function definitions, boolean type definitions, and boolean constants."
            },
            {
                "file": "igbinary/php_igbinary.h",
                "function": "The file defines the PHP extension \"igbinary,\" which provides binary serialization and deserialization functions (`igbinary_serialize` and `igbinary_unserialize`). It includes module initialization, shutdown, and request handling functions, along with macros for handling references and versioning."
            }
        ],
        "gt": "[['igbinary/php_igbinary.h', 'igbinary/igbinary.c'], ['igbinary/ig_win32.h'], ['igbinary/igbinary.h'], ['igbinary/apc_serializer.h'], ['igbinary/igbinary.c'], ['igbinary/hash.h', 'igbinary/igbinary.c'], ['igbinary/hash_si.c'], ['igbinary/hash.h', 'igbinary/hash_si.c']]"
    },
    {
        "repo": "iso15765-canbus",
        "description": "A platform-agnostic C library implementing the ISO15765-2 (ISO-TP) protocol for CANBus communication.",
        "function": "Provides transparent interaction with lower ISO layers, allowing users to define CANBus frame transmission and reception. Supports UDS, OBDII, and other application layer protocols requiring ISO15765-2 TP.",
        "files": [
            {
                "file": "iso15765-canbus/exm/ISO15765Development.c",
                "function": "The file implements a communication example using the ISO 15765 protocol, managing two handlers (`handler1` and `handler2`) to send and receive CAN bus frames, with error handling and frame validation. It demonstrates bidirectional communication between two nodes, printing frame details and ensuring data integrity during transmission and reception."
            },
            {
                "file": "iso15765-canbus/lib/lib_iqueue.c",
                "function": "The file implements a queue data structure with functions for initialization, enqueueing, dequeueing, and managing queue elements. It supports operations like advancing the queue pointer, retrieving the next enqueue position, and determining the queue size."
            },
            {
                "file": "iso15765-canbus/lib/lib_iqueue.h",
                "function": "The file defines a generic queue data structure (`iqueue_t`) and provides functions for initializing, enqueueing, dequeueing, and managing the queue, including operations for advancing the queue and retrieving the next element."
            },
            {
                "file": "iso15765-canbus/src/lib_iso15765.c",
                "function": "The file implements the ISO15765-2 protocol, providing functions for handling CANBus frames, managing inbound and outbound streams, and processing timeouts. It supports single-frame, first-frame, consecutive-frame, and flow-control frame types, ensuring proper communication and error handling."
            },
            {
                "file": "iso15765-canbus/src/lib_iso15765.h",
                "function": "The file defines a library for ISO 15765-2 (CAN transport protocol) with structures, enums, and functions for handling CAN bus frames, addressing modes, and protocol control information. It supports message transmission, reception, and flow control, with configurable timing and callbacks for various events."
            }
        ],
        "gt": "[['iso15765-canbus/src/lib_iso15765.h', 'iso15765-canbus/src/lib_iso15765.c'], ['iso15765-canbus/lib/lib_iqueue.c'], ['iso15765-canbus/lib/lib_iqueue.h', 'iso15765-canbus/lib/lib_iqueue.c'], ['iso15765-canbus/exm/ISO15765Development.c'], ['iso15765-canbus/src/lib_iso15765.c'], ['iso15765-canbus/lib/lib_iqueue.h', 'iso15765-canbus/src/lib_iso15765.h', 'iso15765-canbus/exm/ISO15765Development.c'], ['iso15765-canbus/lib/lib_iqueue.h', 'iso15765-canbus/src/lib_iso15765.h', 'iso15765-canbus/src/lib_iso15765.c'], ['iso15765-canbus/src/lib_iso15765.h', 'iso15765-canbus/exm/ISO15765Development.c'], ['iso15765-canbus/src/lib_iso15765.h']]"
    },
    {
        "repo": "ld_preload-sounds",
        "description": "An experimental tool that generates WAV audio by hooking memory allocation (malloc) and file read (read) functions.",
        "function": "Hooks into malloc() and read() calls to create WAV files based on memory allocation sizes and file read operations. Allows customization of wave parameters and supports optional environment variables to control behavior.",
        "files": [
            {
                "file": "ld_preload-sounds/support.c",
                "function": "This file defines a library that intercepts and modifies standard C library functions (`malloc`, `read`, `fclose`) to enable writing WAV audio files. It initializes and manages a WAV file header, writes audio data, and ensures proper file size updates upon closing."
            },
            {
                "file": "ld_preload-sounds/support.h",
                "function": "This file defines macros and structures for handling audio sampling, byte manipulation, and debugging, with conditional compilation for platform-specific functions and assertions for correctness."
            },
            {
                "file": "ld_preload-sounds/writeWav.c",
                "function": "The file defines functionality for generating square waves during `malloc` and `read` operations, with parameters such as frequency, duration, and amplitude. It includes macros to clamp and set these parameters, and implements the wave generation logic in functions that are triggered during memory allocation and data reading."
            }
        ],
        "gt": "[['ld_preload-sounds/support.c'], ['ld_preload-sounds/support.h', 'ld_preload-sounds/support.c'], ['ld_preload-sounds/writeWav.c'], ['ld_preload-sounds/support.h', 'ld_preload-sounds/writeWav.c']]"
    },
    {
        "repo": "libcube2cyl",
        "description": "libcube2cyl is a single-header library for converting cubic panoramic images to cylindrical projection.",
        "function": "The library allows users to initialize the conversion algorithm, generate mappings between cubic and cylindrical projections, and access pixel coordinates for accurate panorama creation with support for anti-aliasing.",
        "files": [
            {
                "file": "libcube2cyl/example/demo_c/main.c",
                "function": "The program reads six cube face images, initializes a mapping algorithm to convert them into a cylindrical panorama, and generates an output panorama image by mapping pixels from the cube faces to the cylindrical projection."
            },
            {
                "file": "libcube2cyl/example/deps/qdbmp/qdbmp.c",
                "function": "The file provides functionality for creating, reading, writing, and manipulating BMP image files, including handling headers, pixel data, and palette colors. It supports 8, 24, and 32-bit BMP images and includes error handling for various operations."
            },
            {
                "file": "libcube2cyl/example/deps/qdbmp/qdbmp.h",
                "function": "The file defines a lightweight BMP image processing library, supporting creation, manipulation, and I/O operations for uncompressed 32 BPP, 24 BPP, and 8 BPP indexed color BMP images. It includes functions for pixel access, palette handling, and error management."
            },
            {
                "file": "libcube2cyl/src/cube_to_cyl.h",
                "function": "This file defines functionality for mapping 360-degree panoramic images to a cube map representation and vice versa, including initialization, coordinate calculation, and mapping generation."
            }
        ],
        "gt": "[['libcube2cyl/example/demo_c/main.c'], ['libcube2cyl/example/deps/qdbmp/qdbmp.h', 'libcube2cyl/example/deps/qdbmp/qdbmp.c'], ['libcube2cyl/src/cube_to_cyl.h', 'libcube2cyl/example/demo_c/main.c'], ['libcube2cyl/example/deps/qdbmp/qdbmp.c'], ['libcube2cyl/example/deps/qdbmp/qdbmp.h', 'libcube2cyl/example/demo_c/main.c']]"
    },
    {
        "repo": "libjuice",
        "description": "libjuice is a UDP Interactive Connectivity Establishment (ICE) library for NAT traversal.",
        "function": "It implements a simplified version of the ICE protocol, supporting STUN, TURN, and SDP-based interfaces, enabling bidirectional UDP streams across NATs. The library is written in C, platform-independent, and has no dependencies.",
        "files": [
            {
                "file": "libjuice/fuzzer/fuzzer.c",
                "function": "This file implements a fuzz testing function for validating STUN message parsing and integrity checks within specified input size limits."
            },
            {
                "file": "libjuice/include/juice/juice.h",
                "function": "This file defines a C API for an ICE (Interactive Connectivity Establishment) agent and server, providing functionality for NAT traversal, candidate gathering, and secure communication using STUN/TURN servers. It also includes logging and configuration options for managing connections and server operations."
            },
            {
                "file": "libjuice/src/addr.c",
                "function": "This file provides utility functions for working with socket addresses, including getting and setting ports, checking address types, converting between address families, and resolving hostnames to addresses."
            },
            {
                "file": "libjuice/src/addr.h",
                "function": "This file provides functions for handling and manipulating network addresses, including getting and setting ports, comparing addresses, converting addresses to strings, and resolving hostnames to address records."
            },
            {
                "file": "libjuice/src/agent.c",
                "function": "Unable to read file content."
            }
        ],
        "gt": "[['libjuice/include/juice/juice.h'], ['libjuice/src/addr.c'], ['libjuice/fuzzer/fuzzer.c'], ['libjuice/src/agent.c'], ['libjuice/src/addr.h', 'libjuice/src/addr.c']]"
    },
    {
        "repo": "llco",
        "description": "A low-level coroutine library for C designed to support other coroutine libraries like sco and neco.",
        "function": "Provides stackful coroutines with no allocations, cross-platform support, fast context switching using assembly, and a single-file amalgamation with no dependencies. Users manage coroutine priorities and cleanup.",
        "files": [
            {
                "file": "llco/llco.c",
                "function": "The file provides a lightweight coroutine library (`llco`) that supports various platforms and architectures, including ARM, x86, x64, RISC-V, and WebAssembly. It implements coroutine switching using assembly code, stack jumping, or platform-specific mechanisms like Windows Fibers and ucontext. The library allows for efficient context switching and supports cleanup operations when coroutines exit."
            },
            {
                "file": "llco/llco.h",
                "function": "The file defines a lightweight coroutine library (`llco`) with functions to manage coroutine creation, switching, and stack unwinding. It includes structures for coroutine descriptors and stack symbols, and provides methods for starting, switching, and unwinding coroutines."
            },
            {
                "file": "llco/test.c",
                "function": "The file implements a lightweight coroutine system using the `llco` library, demonstrating coroutine creation, switching, and cleanup. It includes a performance test to measure the efficiency of coroutine switching."
            },
            {
                "file": "llco/unwind.c",
                "function": "The file defines a program that demonstrates coroutine functionality using the `llco` library, including stack management, function calls, and stack unwinding for debugging purposes. It includes functions for cleanup, symbol unwinding, and a main entry point to start and switch between coroutines."
            }
        ],
        "gt": "[['llco/unwind.c'], ['llco/llco.c'], ['llco/test.c'], ['llco/llco.h', 'llco/test.c'], ['llco/llco.h', 'llco/unwind.c'], ['llco/llco.h', 'llco/llco.c']]"
    },
    {
        "repo": "LoudSunRun",
        "description": "A stack spoofing tool that generates synthetic frames for learning and experimentation purposes.",
        "function": "The program allocates arguments on the stack, creates fake frames, prepares syscalls, spoofs return addresses, and executes functions with synthetic frames. It supports indirect syscalls and can be used to call functions like NtAllocateVirtualMemory and execute shellcode.",
        "files": [
            {
                "file": "LoudSunRun/Macros.h",
                "function": "This file defines macros for status checks, success codes, boolean values, stack size limits, and an operation info constant."
            },
            {
                "file": "LoudSunRun/Structs.h",
                "function": "This file defines structures and enums related to stack frame management, register states, and unwind operations, primarily for Windows-based systems. It includes data structures for tracking register values, stack frame details, and unwind codes for exception handling and stack unwinding."
            },
            {
                "file": "LoudSunRun/Testing.c",
                "function": "The file defines functions to find a specific instruction pattern in a module, calculate the stack size required for a function based on its unwind information, and execute various system calls and memory allocation operations while spoofing return addresses. It also includes a main function that demonstrates these functionalities by iterating through different scenarios and printing results."
            }
        ],
        "gt": "[['LoudSunRun/Structs.h', 'LoudSunRun/Testing.c'], ['LoudSunRun/Testing.c'], ['LoudSunRun/Macros.h', 'LoudSunRun/Testing.c'], ['LoudSunRun/Macros.h']]"
    },
    {
        "repo": "lstack",
        "description": "A lock-free stack implementation using C11's atomic features.",
        "function": "Provides a thread-safe stack that avoids traditional locks by using C11's `stdatomic.h` and double-wide CAS to handle ABA problems.",
        "files": [
            {
                "file": "lstack/lstack.c",
                "function": "This file implements a lock-free stack with pre-allocated nodes, providing functions to initialize, push, and pop elements while managing memory efficiently."
            },
            {
                "file": "lstack/lstack.h",
                "function": "The file defines a lock-free stack (`lstack_t`) with functions to initialize, push, pop, and manage the stack, ensuring thread-safe operations using atomic operations."
            },
            {
                "file": "lstack/main.c",
                "function": "The program generates SHA-1 hashes and collects those with a specified number of leading zeros using multiple threads. It monitors progress and prints the collected hashes once the desired number is reached."
            },
            {
                "file": "lstack/sha1.c",
                "function": "This file implements the SHA-1 hashing algorithm in C, providing functions to initialize, update, and finalize the hash computation for input data. It includes a self-test to verify the correctness of the implementation against known test vectors."
            },
            {
                "file": "lstack/sha1.h",
                "function": "This file provides an implementation of the SHA-1 hashing algorithm, including functions to initialize, update, and finalize the hash computation."
            }
        ],
        "gt": "[['lstack/sha1.c'], ['lstack/main.c'], ['lstack/lstack.h', 'lstack/main.c'], ['lstack/lstack.c'], ['lstack/sha1.h', 'lstack/main.c'], ['lstack/lstack.h', 'lstack/lstack.c'], ['lstack/sha1.h', 'lstack/sha1.c']]"
    },
    {
        "repo": "minilibs",
        "description": "A collection of single-file libraries for various functionalities.",
        "function": "Includes a self-balancing binary search tree, JavaScript-compatible regular expressions, an XML parser with mini-DOM, and a pure Lua XML parser. All libraries are in the public domain.",
        "files": [
            {
                "file": "minilibs/regexp.c",
                "function": "This file implements a regular expression compiler and matcher in C. It supports basic and advanced regex features, including character classes, quantifiers, lookaheads, and backreferences, and provides functions to compile regex patterns and execute matches against input strings."
            },
            {
                "file": "minilibs/regexp.h",
                "function": "This file defines a simple regular expression library with functions for compiling, executing, and freeing regular expressions, along with structures and flags for handling pattern matching and substitutions."
            },
            {
                "file": "minilibs/tree.c",
                "function": "This file implements an AA-tree data structure, providing functions for creating, inserting, looking up, and freeing nodes, with optional test functionality for printing and managing command-line arguments."
            },
            {
                "file": "minilibs/tree.h",
                "function": "The file defines a simple tree data structure with functions to insert key-value pairs, lookup values by key, and free the tree."
            },
            {
                "file": "minilibs/xml.c",
                "function": "This file implements a basic XML parser that reads XML data, parses it into a tree structure, and provides functions to navigate and manipulate the parsed XML elements. It supports parsing tags, attributes, text, and CDATA sections, and includes functionality to free the allocated memory for the parsed XML structure."
            },
            {
                "file": "minilibs/xml.h",
                "function": "This file provides functions for parsing, navigating, and querying XML data, including operations for traversing the XML tree, accessing node attributes and text, and finding specific nodes by tag name."
            }
        ],
        "gt": "[['minilibs/regexp.h', 'minilibs/regexp.c'], ['minilibs/regexp.c'], ['minilibs/xml.h', 'minilibs/xml.c'], ['minilibs/tree.c'], ['minilibs/tree.h', 'minilibs/tree.c'], ['minilibs/xml.c']]"
    },
    {
        "repo": "mojozork",
        "description": "An educational implementation of the Z-Machine, a virtual machine used by Infocom for their text-based games.",
        "function": "Supports most of the Version 3 Z-Machine, allowing users to play classic Infocom games like Zork I. Includes a multiplayer telnet server for shared gameplay and a libretro core for playing Z-Machine games in RetroArch.",
        "files": [
            {
                "file": "mojozork/libretro.h",
                "function": "The file defines the Libretro API, which provides a standardized interface for emulators and game engines to interact with frontends. It includes structures, constants, and function prototypes for handling input, video, audio, memory, and other system functionalities, enabling compatibility across various platforms and frontends."
            },
            {
                "file": "mojozork/mojozork-libretro-font.h",
                "function": "An error occurred: Error code: 400 - {'error': {'message': \"This model's maximum context length is 65536 tokens. However, you requested 73623 tokens (73623 in the messages, 0 in the completion). Please reduce the length of the messages or completion.\", 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_request_error'}}"
            },
            {
                "file": "mojozork/mojozork-libretro.c",
                "function": "This file implements a simple Z-Machine interpreter for text-based adventure games, integrated with the libretro API. It supports keyboard, mouse, touch, and controller input, and renders the game in a terminal-like framebuffer. The interpreter handles game logic, input processing, and rendering, with save/load states managed via libretro's serialization system."
            },
            {
                "file": "mojozork/mojozork.c",
                "function": "This file implements a Z-Machine interpreter, specifically for Infocom's text-based adventure games. It reads and executes Z-Machine bytecode, handling various opcodes, memory management, and user input to simulate the game's logic and output. The interpreter supports debugging, stack operations, and various Z-Machine instructions, including arithmetic, object manipulation, and text output."
            },
            {
                "file": "mojozork/multizorkd.c",
                "function": "This file implements a multiplayer server for the Z-Machine, allowing multiple players to interact with a shared text-based adventure game. It handles player connections, game state management, and database persistence for game instances and player data. The server supports creating new games, joining existing ones, and replaying archived games. It also manages player input, game logic, and communication between players in the same game instance."
            }
        ],
        "gt": "[['mojozork/mojozork-libretro-font.h', 'mojozork/mojozork-libretro.c'], ['mojozork/mojozork-libretro.c'], ['mojozork/libretro.h', 'mojozork/mojozork-libretro.c'], ['mojozork/multizorkd.c'], ['mojozork/mojozork.c', 'mojozork/mojozork-libretro.c'], ['mojozork/mojozork.c', 'mojozork/multizorkd.c'], ['mojozork/mojozork-libretro-font.h']]"
    },
    {
        "repo": "npk-tools",
        "description": "A utility for managing Mikrotik's NPK packages in RouterOS.",
        "function": "Allows users to dump or unpack NPK packages, providing tools for analyzing and working with RouterOS firmware.",
        "files": [
            {
                "file": "npk-tools/npk.h",
                "function": "This file defines the structure and constants for parsing Mikrotik's NPK files, which contain package information, scripts, and file data for installation and management on Mikrotik devices."
            },
            {
                "file": "npk-tools/unnpk.c",
                "function": "This program processes MikroTik's NPK packages, allowing users to list, extract, or dump the contents of NPK files, including decompressing and handling various partition types within the package."
            }
        ],
        "gt": "[['npk-tools/npk.h', 'npk-tools/unnpk.c'], ['npk-tools/unnpk.c']]"
    },
    {
        "repo": "nymph",
        "description": "Nymph is a C-like programming language that acts as a preprocessor, converting Nymph files into C files.",
        "function": "Supports class-based object-oriented programming and subtyping. It allows for class and object variables, methods, and constructors, with ongoing development for additional features like destructors, type inference, and lambdas.",
        "files": [
            {
                "file": "nymph/hmap.c",
                "function": "This file implements a hash map data structure with functions to create, update, fetch, remove, and free hash map entries, using a hash function to manage key-value pairs."
            },
            {
                "file": "nymph/hmap.h",
                "function": "The file defines a hash map (HMap) with functions to create, update, fetch, remove, and free entries in the map."
            },
            {
                "file": "nymph/nymph.c",
                "function": "The file defines a compiler or parser for a custom programming language, handling tokenization, class and function parsing, and code generation for C-like output. It processes source files, manages class inheritance, and constructs corresponding C code structures and functions."
            },
            {
                "file": "nymph/nymph.h",
                "function": "The file defines several custom data structures (structs) such as `NFile`, `Token`, `Scope`, `Class`, `Func`, `Var`, `Property`, and `Function`, likely for organizing and managing different components in a programming or data structure context."
            },
            {
                "file": "nymph/String.c",
                "function": "Unable to read file content."
            },
            {
                "file": "nymph/String.h",
                "function": "Unable to read file content."
            },
            {
                "file": "nymph/libs/String.c",
                "function": "This file implements a string manipulation library in C, providing functions for initializing, modifying, and analyzing strings, including operations like slicing, replacing, case conversion, appending, prepending, and trimming."
            },
            {
                "file": "nymph/libs/String.h",
                "function": "The file defines a `Class_String` and an `Object_String` structure, providing methods for string manipulation such as initialization, reallocation, slicing, searching, case conversion, and modification. The `startString` function is likely used to initialize the string class."
            }
        ],
        "gt": "[['nymph/libs/String.c'], ['nymph/nymph.h', 'nymph/nymph.c'], ['nymph/nymph.c'], ['nymph/String.c'], ['nymph/hmap.h', 'nymph/nymph.c'], ['nymph/hmap.c'], ['nymph/hmap.h', 'nymph/hmap.c'], ['nymph/String.h', 'nymph/libs/String.c'], ['nymph/libs/String.h']]"
    },
    {
        "repo": "path-rendering",
        "description": "A high-quality vector graphics rendering library for OpenGL and OpenGL ES, based on NVIDIA's GPU-accelerated path rendering techniques.",
        "function": "Supports geometric primitives like lines, quadratic and cubic beziers, and arcs. Provides features for filling, stroking, end caps, join styles, attribute interpolation, SVG path syntax, and glyph rendering using Freetype 2. Currently working on dashing support.",
        "files": [
            {
                "file": "path-rendering/ft-path.c",
                "function": "The file defines functions and structures for decomposing and processing font outlines, converting them into a path format with commands and coordinates. It includes functions for handling move-to, line-to, conic-to, cubic-to, and close operations, and provides a mechanism to convert glyph outlines into a structured path representation."
            },
            {
                "file": "path-rendering/ft-path.h",
                "function": "The file defines a `path` structure to store vector path data, including commands and coordinates, and provides functions to convert a FreeType glyph outline into a `path` structure and to free the allocated memory for a `path`."
            },
            {
                "file": "path-rendering/khash.h",
                "function": "The file defines a generic hash table library with functions for initializing, destroying, resizing, inserting, retrieving, and deleting elements. It supports various key types and provides efficient hash functions and collision resolution mechanisms."
            },
            {
                "file": "path-rendering/kvec.h",
                "function": "The file defines a macro-based dynamic array implementation, providing functions for initialization, resizing, insertion, deletion, and accessing elements in a flexible array structure."
            },
            {
                "file": "path-rendering/pr.c",
                "function": "The file defines a comprehensive system for handling and rendering SVG-like paths using OpenGL. It includes functionality for path creation, reduction, stroke and fill generation, and rendering. The core features include:\n\n1. **Path Management**: Functions to create, delete, and manage paths, including handling path commands and coordinates.\n2. **Geometry Generation**: Algorithms to generate stroke and fill geometries for paths, including handling quadratic and cubic curves, and applying stroke styles like miter, bevel, and round joins.\n3. **Rendering**: OpenGL shaders and rendering techniques for stenciling and filling paths, with support for various fill modes and stroke styles.\n4. **Dash Patterns**: Support for dashed strokes and calculating dash offsets.\n5. **Instanced Rendering**: Functions to render multiple paths with different transformations and bounding box calculations.\n\nThe system is designed to handle complex path data and efficiently render it using OpenGL, with a focus on performance and flexibility."
            },
            {
                "file": "path-rendering/pr.h",
                "function": "This file defines constants and functions for path rendering in OpenGL, including path generation, manipulation, and rendering operations. It provides functionality for creating, modifying, and rendering paths with various shapes, curves, and transformations."
            },
            {
                "file": "path-rendering/svg-path.c",
                "function": "The file provides functionality for parsing SVG path data, converting it into a structured format with commands and coordinates. It includes functions to handle whitespace, commas, and numbers, and processes SVG path commands like M, L, Q, C, and Z. The parsed data is stored in dynamically allocated arrays for commands and coordinates, which can be freed later."
            },
            {
                "file": "path-rendering/svg-path.h",
                "function": "The file defines a parser for SVG path data, converting a string representation of an SVG path into a structured format with commands and coordinates. It also provides functions to free the allocated memory for the parsed SVG path."
            }
        ],
        "gt": "[['path-rendering/ft-path.h', 'path-rendering/ft-path.c'], ['path-rendering/pr.h', 'path-rendering/pr.c'], ['path-rendering/khash.h'], ['path-rendering/ft-path.c'], ['path-rendering/khash.h', 'path-rendering/pr.c'], ['path-rendering/kvec.h', 'path-rendering/ft-path.c'], ['path-rendering/pr.c'], ['path-rendering/svg-path.c'], ['path-rendering/svg-path.h', 'path-rendering/svg-path.c'], ['path-rendering/svg-path.h', 'path-rendering/pr.c'], ['path-rendering/kvec.h', 'path-rendering/pr.c'], ['path-rendering/kvec.h', 'path-rendering/svg-path.c']]"
    },
    {
        "repo": "pipeline_kafka",
        "description": "An extension for PipelineDB that adds Kafka support, enabling data ingestion and production.",
        "function": "Allows PipelineDB to consume messages from Kafka topics into streams and produce messages to Kafka topics. Supports parallel consumption, message formatting, and trigger-based message production.",
        "files": [
            {
                "file": "pipeline_kafka/pipeline_kafka.c",
                "function": "The file provides functionality for integrating Kafka with PipelineDB, enabling the consumption and production of messages from Kafka topics into PostgreSQL relations and streams. It includes background worker processes for consuming Kafka messages, managing offsets, and producing messages to Kafka topics. The module supports various configurations for message formats, delimiters, and parallelism, and provides functions to start and stop Kafka consumers for specific topics and relations."
            },
            {
                "file": "pipeline_kafka/pipeline_kafka.h",
                "function": "The file defines support for Kafka integration in PipelineDB, including a function `kafka_consume_main` for consuming Kafka messages."
            }
        ],
        "gt": "[['pipeline_kafka/pipeline_kafka.c'], ['pipeline_kafka/pipeline_kafka.h', 'pipeline_kafka/pipeline_kafka.c'], ['pipeline_kafka/pipeline_kafka.h']]"
    },
    {
        "repo": "Probabilistic-Backpropagation",
        "description": "An implementation of Probabilistic Backpropagation for scalable Bayesian inference in deep neural networks.",
        "function": "Provides C and Theano versions of the algorithm, with the C version being significantly faster. Both versions create and train a two-hidden-layer neural network using the Boston Housing dataset, computing test RMSE and log-likelihood after training.",
        "files": [
            {
                "file": "Probabilistic-Backpropagation/c/PBP_net/network.c",
                "function": "This file implements a Bayesian neural network in C, trained using probabilistic backpropagation (PBP). It includes functions for initializing and destroying the network, performing forward and backward propagation, updating the network parameters, and making predictions. The network supports both deterministic and probabilistic forward propagation, and it refines the prior distribution during training."
            },
            {
                "file": "Probabilistic-Backpropagation/c/PBP_net/network.h",
                "function": "This module implements a Bayesian neural network in C, trained using probabilistic backpropagation (PBP). It supports forward and backward passes, parameter updates, and prediction with both probabilistic and deterministic outputs."
            },
            {
                "file": "Probabilistic-Backpropagation/c/PBP_net/pnorm.c",
                "function": "The file provides functions to compute the cumulative distribution function (CDF) and related operations for the normal distribution, using rational approximations for high accuracy. It includes `pnorm5` for calculating the CDF, `pnorm_both` for both lower and upper tail probabilities, and additional functions for log probabilities and density calculations."
            },
            {
                "file": "Probabilistic-Backpropagation/c/PBP_net/pnorm.h",
                "function": "This module provides functions to compute the cumulative distribution function (pnorm) and density function (dnorm) of the standard Gaussian distribution, including their logarithmic versions."
            }
        ],
        "gt": "[['Probabilistic-Backpropagation/c/PBP_net/network.h', 'Probabilistic-Backpropagation/c/PBP_net/network.c'], ['Probabilistic-Backpropagation/c/PBP_net/pnorm.h', 'Probabilistic-Backpropagation/c/PBP_net/network.c'], ['Probabilistic-Backpropagation/c/PBP_net/network.c'], ['Probabilistic-Backpropagation/c/PBP_net/pnorm.c']]"
    },
    {
        "repo": "ptest",
        "description": "ptest is a DRY Microtesting framework for the C programming language.",
        "function": "It allows developers to write and organize unit tests in a concise manner, supporting both nested function declarations and a more repetitive format for broader compatibility. Tests are grouped into suites, and assertions are used to verify conditions.",
        "files": [
            {
                "file": "ptest/example.c",
                "function": "This file defines two test suites, `suite_basic` and `suite_other`, containing various unit tests for mathematical operations, string comparisons, and basic assertions. It uses the `ptest` framework to run these tests."
            },
            {
                "file": "ptest/example2.c",
                "function": "The file defines and runs multiple test suites for basic mathematical operations, string comparisons, and logical assertions, using a custom testing framework."
            },
            {
                "file": "ptest/ptest.c",
                "function": "This file implements a lightweight testing framework for C, allowing users to define and run test suites and individual tests, with support for assertions and colored output for test results."
            },
            {
                "file": "ptest/ptest.h",
                "function": "The file defines a lightweight unit testing framework with macros for defining test suites, test functions, and assertions. It provides functionality to register tests, run them, and handle assertion failures with detailed error reporting."
            }
        ],
        "gt": "[['ptest/example2.c'], ['ptest/ptest.h', 'ptest/example.c'], ['ptest/example.c'], ['ptest/ptest.c'], ['ptest/ptest.h', 'ptest/example2.c'], ['ptest/ptest.h', 'ptest/ptest.c'], ['ptest/ptest.h']]"
    },
    {
        "repo": "ptrace-examples",
        "description": "A collection of examples demonstrating the use of the Linux PTrace system call.",
        "function": "Shows how to intercept and emulate Linux system calls using Ptrace, allowing for process tracing and manipulation.",
        "files": [
            {
                "file": "ptrace-examples/example.c",
                "function": "The program opens `/dev/urandom`, reads random data, pledges to restrict file operations, and attempts to open `/dev/urandom` again to demonstrate the pledge's effect. It confirms that the initial file handle remains usable after the pledge."
            },
            {
                "file": "ptrace-examples/minimal_strace.c",
                "function": "This program traces system calls made by a child process, capturing and printing the system call numbers, arguments, and return values."
            },
            {
                "file": "ptrace-examples/xpledge.c",
                "function": "The program uses `ptrace` to trace and control a child process, blocking specific system calls based on predefined rules. It allows or denies system calls dynamically and handles special cases like `SYS_exit` and `SYS_xpledge`."
            },
            {
                "file": "ptrace-examples/xpledge.h",
                "function": "The file defines macros and a system call wrapper for a custom system call (`xpledge`) that restricts certain operations (read/write and file opening) based on provided flags."
            }
        ],
        "gt": "[['ptrace-examples/example.c'], ['ptrace-examples/minimal_strace.c'], ['ptrace-examples/xpledge.c'], ['ptrace-examples/xpledge.h', 'ptrace-examples/example.c'], ['ptrace-examples/xpledge.h', 'ptrace-examples/xpledge.c']]"
    },
    {
        "repo": "ramrecovery",
        "description": "A project demonstrating the remanence of data in RAM, inspired by cold boot attacks.",
        "function": "The project includes programs to fill RAM with images of the Mona Lisa, a bare metal kernel for memory dumping, and a Linux kernel module to inject images into contiguous memory. It also features an automated experiment setup using Raspberry Pi and modified hardware to simulate cold boot attacks.",
        "files": [
            {
                "file": "ramrecovery/src/load.c",
                "function": "The program reads a TGA image file into memory, calculates available system memory, and attempts to allocate a large block of memory by decrementing the size until successful. It then fills the allocated memory with copies of the image and keeps the program running indefinitely."
            },
            {
                "file": "ramrecovery/src-memcopy/io.c",
                "function": "This file provides low-level GPIO and UART control for a Raspberry Pi, enabling GPIO pin configuration, output control, and UART communication with byte-level read/write operations."
            },
            {
                "file": "ramrecovery/src-memcopy/io.h",
                "function": "The file defines functions for initializing and managing UART communication, including writing text, reading bytes, and checking read readiness, as well as utility functions for memory-mapped I/O operations."
            },
            {
                "file": "ramrecovery/src-memcopy/kernel.c",
                "function": "This program initializes UART, aligns a memory region, and dumps its contents byte by byte over UART."
            },
            {
                "file": "ramrecovery/src-module/ramrec.c",
                "function": "The module allocates contiguous RAM, either writing a specified image file (e.g., \"mona.tga\") repeatedly into the memory or reading the memory content and saving it to a file. It supports options to write a single image or dump the entire memory content."
            }
        ],
        "gt": "[['ramrecovery/src/load.c'], ['ramrecovery/src-memcopy/io.h', 'ramrecovery/src-memcopy/io.c'], ['ramrecovery/src-module/ramrec.c'], ['ramrecovery/src-memcopy/io.c'], ['ramrecovery/src-memcopy/kernel.c'], ['ramrecovery/src-memcopy/io.h', 'ramrecovery/src-memcopy/kernel.c'], ['ramrecovery/src-memcopy/io.h']]"
    },
    {
        "repo": "remoteink",
        "description": "RemoteInk is a tool that allows users to use a PocketBook E-Ink reader as a secondary monitor for their Linux computer.",
        "function": "It enables connection via Wi-Fi or USB, supports screen orientation changes, window tracking, zooming, cursor capturing, and color inversion. It also allows customization of keyboard shortcuts and secure connections with a password.",
        "files": [
            {
                "file": "remoteink/client/client.c",
                "function": "This file implements a client that connects to a server, processes commands to draw on a screen, and manages network communication, including sending confirmations and handling various drawing commands."
            },
            {
                "file": "remoteink/client/client.h",
                "function": "The file defines a client interface with functions to establish a connection (`client_connect`) with specified dimensions and to shut down the client (`client_shutdown`)."
            },
            {
                "file": "remoteink/client/main.c",
                "function": "Unable to read file content."
            }
        ],
        "gt": "[['remoteink/client/client.c'], ['remoteink/client/client.h', 'remoteink/client/client.c'], ['remoteink/client/main.c'], ['remoteink/client/client.h']]"
    },
    {
        "repo": "rootadb",
        "description": "A tool to restart Android's adbd service with root privileges.",
        "function": "Allows users to enable root access for the adbd service on Android devices, facilitating advanced debugging and development tasks.",
        "files": [
            {
                "file": "rootadb/jni/rootadb.c",
                "function": "The file provides functionality to patch the `adbd` daemon, remount partitions, and copy files, primarily for modifying system behavior on a rooted device. It includes functions to find a process by command name, patch `adbd` to bypass security checks, remount partitions read-write, and copy files with specified permissions."
            },
            {
                "file": "rootadb/jni/setpropex.c",
                "function": "The file defines a utility to modify Android system properties by attaching to the init process, reading its memory maps, and updating property values in both the local memory and the init process's memory."
            },
            {
                "file": "rootadb/jni/system_properties.c",
                "function": "This file defines a system for managing and accessing Android system properties, using a hybrid trie/binary tree structure to store and retrieve property names and values efficiently. It includes functions for initializing the property area, finding properties, and managing property data."
            },
            {
                "file": "rootadb/jni/system_properties_compat.c",
                "function": "This file provides compatibility for accessing system properties in older versions of Android's init process during OTA updates, ensuring backward compatibility with pre-K versions."
            },
            {
                "file": "rootadb/jni/_system_properties.h",
                "function": "This file defines structures and constants for managing system properties in Android, including compatibility modes for different versions, and provides functions to interact with these properties."
            },
            {
                "file": "rootadb/jni/inc/cutils/properties.h",
                "function": "This file defines functions for managing system properties, including `property_get` to retrieve property values, `property_set` to set property values, and `property_list` to enumerate properties."
            }
        ],
        "gt": "[['rootadb/jni/inc/cutils/properties.h', 'rootadb/jni/setpropex.c'], ['rootadb/jni/rootadb.c'], ['rootadb/jni/_system_properties.h', 'rootadb/jni/setpropex.c'], ['rootadb/jni/_system_properties.h', 'rootadb/jni/system_properties_compat.c'], ['rootadb/jni/system_properties.c'], ['rootadb/jni/_system_properties.h', 'rootadb/jni/system_properties.c'], ['rootadb/jni/setpropex.c'], ['rootadb/jni/system_properties_compat.c'], ['rootadb/jni/_system_properties.h']]"
    },
    {
        "repo": "Sia-GPU-Miner",
        "description": "A GPU miner designed for mining Siacoin, optimized for increased hashrate performance.",
        "function": "The miner runs in a command prompt, supports multiple GPUs, and allows configuration of intensity, platform, device, and API port. It provides real-time hashrate and mined block information.",
        "files": [
            {
                "file": "Sia-GPU-Miner/network.c",
                "function": "The file provides functions to interact with a Sia blockchain node (`siad`) using libcurl. It initializes network connections, fetches block headers for mining, and submits completed block headers back to the node."
            },
            {
                "file": "Sia-GPU-Miner/network.h",
                "function": "The file provides functions for initializing and managing network operations, including setting a host and port, retrieving work headers, submitting headers, and freeing network resources."
            },
            {
                "file": "Sia-GPU-Miner/sia-gpu-miner.c",
                "function": "This file implements a cross-platform GPU miner for Sia, utilizing OpenCL for GPU operations and libcurl for communication with the Sia daemon. It manages GPU device selection, kernel execution, and mining operations, calculating hash rates and submitting valid blocks to the Sia network."
            }
        ],
        "gt": "[['Sia-GPU-Miner/network.h', 'Sia-GPU-Miner/sia-gpu-miner.c'], ['Sia-GPU-Miner/network.h', 'Sia-GPU-Miner/network.c'], ['Sia-GPU-Miner/sia-gpu-miner.c'], ['Sia-GPU-Miner/network.c']]"
    },
    {
        "repo": "smolar",
        "description": "A minimalistic C implementation of multidimensional arrays inspired by numpy.",
        "function": "Supports N-dimensional arrays of float datatype, including array creation, initialization, traversal, broadcasting, and elementwise addition. Future plans include support for more operations, data types, and parallelism.",
        "files": [
            {
                "file": "smolar/main.c",
                "function": "The program creates two arrays with specific shapes, adds them together, and prints the resulting arrays."
            },
            {
                "file": "smolar/smolar-simd.c",
                "function": "This file implements a multidimensional array library with functions for creating, manipulating, and performing operations on arrays, including broadcasting, reshaping, transposing, and element-wise arithmetic operations. It supports parallelization for certain operations and handles memory management for array data."
            },
            {
                "file": "smolar/smolar.c",
                "function": "This file implements a multi-dimensional array library with functionalities for memory management, random number generation, array creation, reshaping, broadcasting, element-wise operations, and matrix multiplication. It also includes utility functions for checking memory allocation, generating random numbers, and applying functions element-wise."
            },
            {
                "file": "smolar/smolar.h",
                "function": "The file defines a multidimensional array library in C, providing functions for array creation, manipulation, and operations like reshaping, transposing, and arithmetic operations. It supports both C-order and Fortran-order arrays and includes utility functions for random number generation and array management."
            },
            {
                "file": "smolar/examples/addtranspose.c",
                "function": "The program creates two arrays, reshapes and transposes one of them, adds the two arrays together, and prints the results."
            },
            {
                "file": "smolar/examples/dot.c",
                "function": "The program initializes two arrays with values from 1 to 10, computes their dot product, displays the arrays and the result, and then cleans up the allocated memory."
            },
            {
                "file": "smolar/examples/expanddims.c",
                "function": "The file demonstrates the use of functions from a custom library (`smolar.h`) to create and manipulate arrays, including expanding dimensions and displaying array details."
            },
            {
                "file": "smolar/examples/matmul.c",
                "function": "The program benchmarks the performance of matrix multiplication (`smMatMul`) by creating two multi-dimensional arrays, performing the operation multiple times, and calculating the average execution time."
            },
            {
                "file": "smolar/examples/squeeze.c",
                "function": "The file demonstrates reshaping and squeezing operations on an array using functions from the `smolar` library, and prints the original and modified arrays."
            }
        ],
        "gt": "[['smolar/main.c'], ['smolar/smolar.c'], ['smolar/examples/expanddims.c'], ['smolar/examples/matmul.c'], ['smolar/examples/addtranspose.c'], ['smolar/smolar-simd.c'], ['smolar/examples/squeeze.c'], ['smolar/examples/dot.c'], ['smolar/smolar.h', 'smolar/smolar.c'], ['smolar/smolar.h', 'smolar/main.c']]"
    },
    {
        "repo": "SSE-convolution",
        "description": "A project demonstrating the acceleration of 1D convolution using SSE (Streaming SIMD Extensions).",
        "function": "Implements optimized 1D convolution using SSE for improved performance. Includes a Python script for testing and benchmarking, comparing execution times and FLOPS estimates.",
        "files": [
            {
                "file": "SSE-convolution/convolve.c",
                "function": "The file provides various implementations of 1D convolution algorithms, optimized for different SIMD instruction sets (SSE and AVX). These functions compute the convolution of an input array with a kernel, producing an output array, with optimizations focusing on parallel processing and loop unrolling for performance improvement."
            },
            {
                "file": "SSE-convolution/convolve.h",
                "function": "This file defines various convolution functions optimized for different hardware capabilities (e.g., SSE3, AVX) and provides a macro to generate multiple convolution routines for repeated use."
            },
            {
                "file": "SSE-convolution/convolve_2d.c",
                "function": "The file implements a 2D convolution operation using SSE (Streaming SIMD Extensions) for optimized performance. It includes a function to convolve along rows with transpose and a separable 2D convolution function that processes input data in two passes: first along rows and then along columns."
            },
            {
                "file": "SSE-convolution/convolve_2d.h",
                "function": "The file defines a macro `MULTIPLE_CONVOLVE_2D` to generate wrapper functions for 2D convolution routines, allowing multiple executions of a given convolution function. It also includes an SSE3-optimized implementation of separable 2D convolution."
            },
            {
                "file": "SSE-convolution/multiple_convolve.c",
                "function": "This file defines a macro to generate multiple convolution functions, allowing repeated execution of a base convolution function with different implementations optimized for SSE and AVX instruction sets."
            },
            {
                "file": "SSE-convolution/test_convolve.c",
                "function": "This program performs 2D convolution on input data using a kernel, measures the execution time for multiple iterations, and validates the result against a known correct output."
            },
            {
                "file": "SSE-convolution/test_data.c",
                "function": "The file defines three arrays of 32-bit unsigned integers (`_kernel_16`, `_input_data_1024`, and `_output_in1024_kernel16`) and casts them to `float*` pointers. These arrays likely represent data for numerical computations, such as input, kernel, and output data for a convolution or other mathematical operation."
            },
            {
                "file": "SSE-convolution/test_data.h",
                "function": "The file defines external variables for test data, including a 16-element kernel, a 1024-element input dataset, and a 1024-element output dataset resulting from applying the kernel."
            }
        ],
        "gt": "[['SSE-convolution/test_data.c'], ['SSE-convolution/multiple_convolve.c'], ['SSE-convolution/convolve_2d.c'], ['SSE-convolution/convolve_2d.h', 'SSE-convolution/convolve_2d.c'], ['SSE-convolution/convolve.h', 'SSE-convolution/convolve.c'], ['SSE-convolution/test_convolve.c'], ['SSE-convolution/test_data.h', 'SSE-convolution/test_convolve.c'], ['SSE-convolution/convolve_2d.h', 'SSE-convolution/test_convolve.c'], ['SSE-convolution/convolve.h', 'SSE-convolution/test_convolve.c'], ['SSE-convolution/convolve.c'], ['SSE-convolution/convolve.h', 'SSE-convolution/multiple_convolve.c'], ['SSE-convolution/test_data.h']]"
    },
    {
        "repo": "stelf-loader",
        "description": "A stealthy ELF loader designed to execute ELF binaries without creating files or using execve, primarily for x86_64 architectures.",
        "function": "Converts static or static-pie ELFs into shellcode that can be injected directly into memory via shell commands, bypassing traditional file-based execution methods. Utilizes techniques like fd redirection, program counter leak, and tail-seeking for stealthy and portable execution.",
        "files": [
            {
                "file": "stelf-loader/test_elfs/glibc-static-pie.c",
                "function": "The program prints a greeting and lists the command-line arguments passed to it."
            },
            {
                "file": "stelf-loader/test_elfs/glibc-static.c",
                "function": "The file defines a simple C program that prints \"Hello, glibc static ELF!\" to the console."
            },
            {
                "file": "stelf-loader/test_elfs/linux_syscall_support.h",
                "function": "An error occurred: Error code: 400 - {'error': {'message': \"This model's maximum context length is 65536 tokens. However, you requested 69983 tokens (69983 in the messages, 0 in the completion). Please reduce the length of the messages or completion.\", 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_request_error'}}"
            },
            {
                "file": "stelf-loader/test_elfs/syscall-static-pie.c",
                "function": "The file defines a minimal static-pie ELF executable that uses direct syscalls to print a message and exit."
            }
        ],
        "gt": "[['stelf-loader/test_elfs/syscall-static-pie.c'], ['stelf-loader/test_elfs/glibc-static.c'], ['stelf-loader/test_elfs/glibc-static-pie.c'], ['stelf-loader/test_elfs/linux_syscall_support.h', 'stelf-loader/test_elfs/syscall-static-pie.c']]"
    },
    {
        "repo": "tiny_ktx",
        "description": "A small C-based library for loading and saving Khronos KTX texture files.",
        "function": "Supports various texture formats, dimensions, mipmaps, and custom data extensions. Provides options to handle texture formats in both GL/KTX and Vulkan/Dx12/Metal styles.",
        "files": [
            {
                "file": "tiny_ktx/include/tiny_ktx/tinyktx.h",
                "function": "The file defines a library for reading and writing KTX (Khronos Texture) files, which are container formats for textures used in graphics applications. The library provides functions to handle KTX file headers, image data, and metadata, supporting various texture formats and compression types. It also includes functionality for managing mipmaps, endianness, and GL-specific formats."
            },
            {
                "file": "tiny_ktx/include/tiny_ktx/tinyktx2.h",
                "function": "The file defines a library for reading and writing KTX2 texture files, providing functions to handle texture data, including mipmaps, dimensions, and formats, with support for various compression schemes and supercompression techniques."
            },
            {
                "file": "tiny_ktx/src/tinyktx.c",
                "function": "The file defines the implementation of the TinyKTX library, which is used for handling KTX (Khronos Texture) files, and includes necessary headers for base image format support and TinyKTX functionality."
            }
        ],
        "gt": "[['tiny_ktx/include/tiny_ktx/tinyktx.h', 'tiny_ktx/src/tinyktx.c'], ['tiny_ktx/include/tiny_ktx/tinyktx2.h'], ['tiny_ktx/src/tinyktx.c'], ['tiny_ktx/include/tiny_ktx/tinyktx.h']]"
    },
    {
        "repo": "torrent-net",
        "description": "TorrentNet is a distributed search engine built on BitTorrent and SQLite.",
        "function": "It allows users to query distributed torrent sites without downloading the entire database, prioritizing piece downloads based on search queries. Sites are hosted via BitTorrent and can be updated using Mutable Torrents, enabling interactive and queryable experiences.",
        "files": [
            {
                "file": "torrent-net/reddit-browser/sqlite3.c",
                "function": "Unable to read file content."
            },
            {
                "file": "torrent-net/reddit-browser/importer/json/json-forwards.h",
                "function": "This file provides forward declarations for all JsonCpp types, allowing users to include only this header for forward-declared types without needing the full library headers."
            },
            {
                "file": "torrent-net/reddit-browser/importer/json/json.h",
                "function": "This file is an amalgamated header for the JsonCpp library, providing functionality for parsing and generating JSON data. It includes classes for reading and writing JSON, handling JSON values, and configuring parsing and writing behaviors."
            }
        ],
        "gt": "[['torrent-net/reddit-browser/importer/json/json.h'], ['torrent-net/reddit-browser/importer/json/json-forwards.h', 'torrent-net/reddit-browser/importer/json/json.h'], ['torrent-net/reddit-browser/sqlite3.c'], ['torrent-net/reddit-browser/importer/json/json-forwards.h']]"
    },
    {
        "repo": "ts80player",
        "description": "TS80player is a custom firmware for the TS80 soldering iron, enhancing its functionality.",
        "function": "The firmware adds features like a Tetris game, improved UI, and additional settings. It is installed by flashing a .hex file to the device via USB.",
        "files": [
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80midi/bach.h",
                "function": "The file contains a sequence of hexadecimal values representing audio data, likely for a specific piece of music, with a defined frame rate of 0x3c."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80midi/boomer.h",
                "function": "The file defines a sequence of hexadecimal values representing animation or timing data, likely for a simple animation or sequence with a specified frame rate."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80midi/brigada.h",
                "function": "The file defines a sequence of hexadecimal values representing animation or frame data, likely for a visual or graphical application, with a specified frame rate of 0x3c (60 frames per second)."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80midi/bumble.h",
                "function": "The file defines a sequence of hexadecimal values representing animation or timing data, likely for a visual or audio effect, with a specified frame rate of 0x3c."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80midi/chopin.h",
                "function": "The file defines a binary data array (`chopin_data`) containing a sequence of hexadecimal values, likely representing audio or musical data, with a specified frame rate of 0x3c."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80midi/sept.h",
                "function": "The file contains a sequence of hexadecimal values representing data, likely for a specific application or device, with the first value indicating a frame rate."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80msc/image.h",
                "function": "The file contains a raw binary image, likely representing a boot sector or a disk image, with specific data structures and error messages indicating a non-bootable disk."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80player/fatal.pt3.h",
                "function": "The file defines a binary data array `fatal_pt3` stored in program memory (`PROGMEM`). This data likely represents a compiled audio track or music module in a specific format, such as PT3 (ProTracker 3) for playing on a device with limited resources, such as an Arduino. The array contains the raw data needed to reproduce the audio or music, which can be processed by a player or decoder to generate sound."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80player/music_data.h",
                "function": "The file defines a configuration for including different music data files based on the `APPLE_PT3` or `FATAL_PT3` preprocessor directives, defaulting to `rage.pt3.h` if neither is defined."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80player/nq_bad_apple.pt3.h",
                "function": "An error occurred: Error code: 400 - {'error': {'message': \"This model's maximum context length is 65536 tokens. However, you requested 122905 tokens (122905 in the messages, 0 in the completion). Please reduce the length of the messages or completion.\", 'type': 'invalid_request_error', 'param': None, 'code': 'invalid_request_error'}}"
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80player/pt3_play_shiru.h",
                "function": "The file implements a Pro Tracker 3.x music player, providing functions to initialize (`pt3_init`) and play (`pt3_play`) music modules. It emulates the AY-3-8910 sound chip to generate audio, processes music patterns, and outputs stereo or mono audio samples at various bit depths."
            },
            {
                "file": "ts80player/firmware/Arduino_STM32/ts80player/pt3_play_shiru_cpp.h",
                "function": "Unable to read file content."
            }
        ],
        "gt": "[['ts80player/firmware/Arduino_STM32/ts80midi/bach.h'], ['ts80player/firmware/Arduino_STM32/ts80midi/bumble.h'], ['ts80player/firmware/Arduino_STM32/ts80msc/image.h'], ['ts80player/firmware/Arduino_STM32/ts80midi/chopin.h'], ['ts80player/firmware/Arduino_STM32/ts80midi/boomer.h'], ['ts80player/firmware/Arduino_STM32/ts80player/fatal.pt3.h', 'ts80player/firmware/Arduino_STM32/ts80player/music_data.h', 'ts80player/firmware/Arduino_STM32/ts80player/pt3_play_shiru.h'], ['ts80player/firmware/Arduino_STM32/ts80midi/brigada.h'], ['ts80player/firmware/Arduino_STM32/ts80player/pt3_play_shiru_cpp.h'], ['ts80player/firmware/Arduino_STM32/ts80midi/sept.h'], ['ts80player/firmware/Arduino_STM32/ts80player/music_data.h', 'ts80player/firmware/Arduino_STM32/ts80player/pt3_play_shiru.h'], ['ts80player/firmware/Arduino_STM32/ts80player/nq_bad_apple.pt3.h', 'ts80player/firmware/Arduino_STM32/ts80player/music_data.h', 'ts80player/firmware/Arduino_STM32/ts80player/pt3_play_shiru.h'], ['ts80player/firmware/Arduino_STM32/ts80player/pt3_play_shiru.h']]"
    },
    {
        "repo": "wild-web-midi",
        "description": "Wild Web Midi is a browser-based wavetable synthesizer that runs JavaScript to play MIDI files using sample-based synthesis.",
        "function": "It leverages emscripten, WildMidi, and Freepats to decode and convert MIDI files into audio, allowing playback, streaming, and saving of WAV files directly in the browser. Features include improved player controls, reverb, resampling, and real-time web audio playback.",
        "files": [
            {
                "file": "wild-web-midi/src/config.h",
                "function": "The file defines configuration macros for the WildMidi package, including package details, version information, compiler feature checks, and audio driver support."
            },
            {
                "file": "wild-web-midi/src/wildwebmidi.c",
                "function": "The file implements a MIDI player using the WildMidi library, supporting both WAV file output and system audio playback via OpenAL. It processes MIDI files, converts them into audio, and either writes the output to a WAV file or streams it to an audio device. The player also supports pausing, resuming, and seeking within the MIDI playback."
            }
        ],
        "gt": "[['wild-web-midi/src/config.h', 'wild-web-midi/src/wildwebmidi.c'], ['wild-web-midi/src/wildwebmidi.c']]"
    },
    {
        "repo": "wmd",
        "description": "A Python and Matlab implementation of the Word Mover's Distance (WMD) algorithm for measuring document similarity.",
        "function": "Extracts word vectors and BOW vectors from text documents, computes the distance matrix between documents using WMD, and supports KNN classification with fallback mechanisms. Includes datasets and pre-trained word embeddings for testing.",
        "files": [
            {
                "file": "wmd/emd/emd.c",
                "function": "The file implements the Earth Mover's Distance (EMD) algorithm, which calculates the minimum cost required to transform one distribution (signature) into another based on a given ground distance function. The implementation uses a transportation problem approach and iteratively optimizes the solution until the optimal flow is found."
            },
            {
                "file": "wmd/emd/emd.h",
                "function": "The file defines a MATLAB interface for the Earth Mover's Distance (EMD) algorithm, which calculates the dissimilarity between two sets of weighted features. It includes structures for feature signatures and flow, and a function to compute the EMD."
            },
            {
                "file": "wmd/emd/emd_mex.c",
                "function": "This file implements a MATLAB MEX function to compute the Earth Mover's Distance (EMD) between two signatures, using a provided cost matrix. It supports both the distance calculation and the flow information between features."
            },
            {
                "file": "wmd/python-emd-master/emd.c",
                "function": "The file implements the Earth Mover's Distance (EMD) algorithm, which calculates the minimum cost required to transform one distribution (signature) into another based on a given ground distance function. The implementation uses a transportation problem approach and iteratively optimizes the solution until the optimal flow is found."
            },
            {
                "file": "wmd/python-emd-master/emd.h",
                "function": "The file defines a C implementation of the Earth Mover's Distance (EMD), a measure of the distance between two distributions. It includes structures for feature signatures and flow, and a function to compute the EMD using a user-defined ground distance function."
            },
            {
                "file": "wmd/python-emd-master/example1.c",
                "function": "The file defines a function to calculate the Euclidean distance between two features and uses it to compute the Earth Mover's Distance (EMD) between two sets of weighted features, printing the result."
            },
            {
                "file": "wmd/python-emd-master/example2.c",
                "function": "This program calculates the Earth Mover's Distance (EMD) between two sets of features and weights, and prints the resulting distance along with the flow of mass between features."
            }
        ],
        "gt": "[['wmd/emd/emd.h'], ['wmd/python-emd-master/example2.c'], ['wmd/emd/emd.c'], ['wmd/python-emd-master/example1.c'], ['wmd/emd/emd_mex.c'], ['wmd/python-emd-master/emd.c'], ['wmd/python-emd-master/emd.h', 'wmd/python-emd-master/emd.c'], ['wmd/python-emd-master/emd.h', 'wmd/emd/emd.c'], ['wmd/python-emd-master/emd.h', 'wmd/python-emd-master/example1.c'], ['wmd/python-emd-master/emd.h', 'wmd/python-emd-master/example2.c'], ['wmd/python-emd-master/emd.h', 'wmd/emd/emd_mex.c']]"
    },
    {
        "repo": "wmi-static-spoofer",
        "description": "A proof-of-concept tool for spoofing HDD/disk drive serial numbers.",
        "function": "Manipulates serial numbers in kernel memory and updates registry entries without requiring kernel hooks or persistent drivers. Allows for random serial generation with customizable length and offsets.",
        "files": [
            {
                "file": "wmi-static-spoofer/WMIC_static_spoofer/main.c",
                "function": "The file defines a Windows kernel driver with a `DriverEntry` function that sets up an unload routine and calls a function to spoof HDD information, returning success status."
            },
            {
                "file": "wmi-static-spoofer/WMIC_static_spoofer/main.h",
                "function": "The file defines macros and includes necessary headers for a Windows kernel driver, specifically for interacting with storage devices, and includes utility and spoofer functionality for modifying or spoofing device information."
            },
            {
                "file": "wmi-static-spoofer/WMIC_static_spoofer/Spoofer.h",
                "function": "The file defines structures and functions to spoof hard drive serial numbers by generating random serial strings and modifying the corresponding device extensions in the system."
            },
            {
                "file": "wmi-static-spoofer/WMIC_static_spoofer/Util.h",
                "function": "The file defines a function `randstring` to generate random strings and a function `GetKernelAddress` to retrieve the base address of a kernel module by name. It also includes definitions for system information classes and structures related to system modules."
            }
        ],
        "gt": "[['wmi-static-spoofer/WMIC_static_spoofer/Util.h', 'wmi-static-spoofer/WMIC_static_spoofer/main.h', 'wmi-static-spoofer/WMIC_static_spoofer/main.c'], ['wmi-static-spoofer/WMIC_static_spoofer/Spoofer.h', 'wmi-static-spoofer/WMIC_static_spoofer/main.h', 'wmi-static-spoofer/WMIC_static_spoofer/main.c'], ['wmi-static-spoofer/WMIC_static_spoofer/main.c'], ['wmi-static-spoofer/WMIC_static_spoofer/main.h', 'wmi-static-spoofer/WMIC_static_spoofer/main.c'], ['wmi-static-spoofer/WMIC_static_spoofer/Util.h']]"
    },
    {
        "repo": "xdp-xconnect",
        "description": "A daemon for cross-connecting Linux network interfaces using XDP and eBPF.",
        "function": "The daemon reads a YAML configuration file to pair interfaces, attaches eBPF programs to their XDP hooks, and uses bpf_redirect_map to redirect packets between interfaces. It supports dynamic reconfiguration and requires root privileges.",
        "files": [
            {
                "file": "xdp-xconnect/ebpf/xconnect.c",
                "function": "The file defines a BPF program that uses a `DEVMAP` to redirect network packets to different network interfaces based on the ingress interface index."
            },
            {
                "file": "xdp-xconnect/ebpf/include/bpf/bpf_helpers.h",
                "function": "This file defines macros and structures for eBPF (extended Berkeley Packet Filter) programs, including helper macros for debugging, section placement in ELF files, and a structure for describing BPF map attributes."
            },
            {
                "file": "xdp-xconnect/ebpf/include/bpf/bpf_helper_defs.h",
                "function": "The file defines a collection of BPF (Berkeley Packet Filter) helper functions and structures, providing functionality for network packet manipulation, socket operations, tracing, and more. It includes forward declarations for various BPF-related structures and detailed descriptions of each helper function, specifying their purpose, parameters, return values, and usage constraints. The helpers cover tasks such as map operations, packet redirection, checksum manipulation, socket redirection, and debugging."
            },
            {
                "file": "xdp-xconnect/ebpf/include/linux/bpf.h",
                "function": "The file defines the Linux BPF (Berkeley Packet Filter) interface, providing structures, constants, and helper functions for BPF programs. It includes instructions for BPF operations, syscall commands, map types, program types, and various helper functions for network packet manipulation, socket operations, and tracing. The file also defines BPF return codes, metadata structures for packets, and socket information, enabling BPF programs to interact with the kernel for tasks like packet filtering, forwarding, and monitoring."
            }
        ],
        "gt": "[['xdp-xconnect/ebpf/include/bpf/bpf_helper_defs.h', 'xdp-xconnect/ebpf/include/bpf/bpf_helpers.h', 'xdp-xconnect/ebpf/xconnect.c'], ['xdp-xconnect/ebpf/include/linux/bpf.h', 'xdp-xconnect/ebpf/xconnect.c'], ['xdp-xconnect/ebpf/xconnect.c'], ['xdp-xconnect/ebpf/include/bpf/bpf_helpers.h', 'xdp-xconnect/ebpf/xconnect.c']]"
    }
]